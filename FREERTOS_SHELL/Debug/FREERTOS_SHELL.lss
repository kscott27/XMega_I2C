
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004efa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000236  00802000  00004efa  00004f8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802236  00802236  000051c4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000051c4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000051f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a78  00000000  00000000  00005234  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001c7d3  00000000  00000000  00005cac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000727b  00000000  00000000  0002247f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006921  00000000  00000000  000296fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001f98  00000000  00000000  0003001c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000071c9  00000000  00000000  00031fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a1ce  00000000  00000000  0003917d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009d0  00000000  00000000  0004334b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 39 03 	jmp	0x672	; 0x672 <__ctors_end>
       4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      10:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      14:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      18:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      1c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      20:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      24:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      28:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      2c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      30:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      34:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      38:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      3c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      40:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      44:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      48:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      4c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      50:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      54:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      58:	0c 94 b5 11 	jmp	0x236a	; 0x236a <__vector_22>
      5c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      60:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      64:	0c 94 8a 21 	jmp	0x4314	; 0x4314 <__vector_25>
      68:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      6c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      70:	0c 94 e8 21 	jmp	0x43d0	; 0x43d0 <__vector_28>
      74:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      78:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      7c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      80:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      84:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      88:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      8c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      90:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      94:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      98:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      9c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e8:	0c 94 02 23 	jmp	0x4604	; 0x4604 <__vector_58>
      ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      fc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     100:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     104:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     108:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     10c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     110:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     114:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     118:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     11c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     120:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     124:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     128:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     12c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     130:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     134:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     138:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     13c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     140:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     144:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     148:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     14c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     150:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     154:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     158:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     15c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     160:	0c 94 46 22 	jmp	0x448c	; 0x448c <__vector_88>
     164:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     168:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     16c:	0c 94 a4 22 	jmp	0x4548	; 0x4548 <__vector_91>
     170:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     174:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     178:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     17c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     180:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     184:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     188:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     18c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     190:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     194:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     198:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     19c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1fc:	76 1f       	adc	r23, r22
     1fe:	79 1f       	adc	r23, r25
     200:	7c 1f       	adc	r23, r28
     202:	7f 1f       	adc	r23, r31
     204:	82 1f       	adc	r24, r18
     206:	85 1f       	adc	r24, r21
     208:	87 1f       	adc	r24, r23
     20a:	98 1f       	adc	r25, r24
     20c:	a0 1f       	adc	r26, r16
     20e:	aa 1f       	adc	r26, r26
     210:	a8 1f       	adc	r26, r24

00000212 <__trampolines_start>:
     212:	0c 94 2a 24 	jmp	0x4854	; 0x4854 <_ZN9frt_queueIiE10get_a_copyEv>
     216:	0c 94 ee 20 	jmp	0x41dc	; 0x41dc <_ZN5rs23214check_for_charEv>
     21a:	0c 94 be 24 	jmp	0x497c	; 0x497c <_ZN9frt_queueIjE11ISR_butt_inERKj>
     21e:	0c 94 72 23 	jmp	0x46e4	; 0x46e4 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     222:	0c 94 ca 1c 	jmp	0x3994	; 0x3994 <_ZN14frt_text_queue7putcharEc>
     226:	0c 94 20 1f 	jmp	0x3e40	; 0x3e40 <_ZN8emstream12transmit_nowEv>
     22a:	0c 94 d6 24 	jmp	0x49ac	; 0x49ac <_ZN9frt_queueIjE7ISR_putERKj>
     22e:	0c 94 dc 23 	jmp	0x47b8	; 0x47b8 <_ZN9frt_queueIjE10get_a_copyEv>
     232:	0c 94 d1 08 	jmp	0x11a2	; 0x11a2 <_ZN9frt_queueIhE7ISR_getEPh>
     236:	0c 94 aa 1f 	jmp	0x3f54	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23a:	0c 94 a0 1f 	jmp	0x3f40	; 0x3f40 <_ZN8emstreamlsE15ser_manipulator+0x72>
     23e:	0c 94 5f 05 	jmp	0xabe	; 0xabe <_ZN9I2CMaster10StartState11serialDebugEv>
     242:	0c 94 1e 25 	jmp	0x4a3c	; 0x4a3c <_ZN9frt_queueIjE7butt_inERKj>
     246:	0c 94 6c 24 	jmp	0x48d8	; 0x48d8 <_ZN9frt_queueIjE7ISR_getEPj>
     24a:	0c 94 a1 1c 	jmp	0x3942	; 0x3942 <_ZN14frt_text_queue7getcharEv>
     24e:	0c 94 1e 24 	jmp	0x483c	; 0x483c <_ZN9frt_queueIiE10get_a_copyERi>
     252:	0c 94 a8 1f 	jmp	0x3f50	; 0x3f50 <_ZN8emstreamlsE15ser_manipulator+0x82>
     256:	0c 94 51 24 	jmp	0x48a2	; 0x48a2 <_ZN9frt_queueIiE3getEv>
     25a:	0c 94 01 21 	jmp	0x4202	; 0x4202 <_ZN5rs23212clear_screenEv>
     25e:	0c 94 9f 23 	jmp	0x473e	; 0x473e <_ZN9frt_queueIjE9not_emptyEv>
     262:	0c 94 21 1f 	jmp	0x3e42	; 0x3e42 <_ZN8emstream12clear_screenEv>
     266:	0c 94 f7 23 	jmp	0x47ee	; 0x47ee <_ZN9frt_queueIjE3getEPj>
     26a:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     26e:	0c 94 09 26 	jmp	0x4c12	; 0x4c12 <_GLOBAL__sub_I_counter>
     272:	0c 94 26 0a 	jmp	0x144c	; 0x144c <_ZN7MMA845116QueryZRegCommand11writePacketER6Packet>
     276:	0c 94 7f 08 	jmp	0x10fe	; 0x10fe <_ZN9frt_queueIhE8is_emptyEv>
     27a:	0c 94 6d 08 	jmp	0x10da	; 0x10da <_ZN9frt_queueIhE12num_items_inEv>
     27e:	0c 94 74 05 	jmp	0xae8	; 0xae8 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     282:	0c 94 a6 24 	jmp	0x494c	; 0x494c <_ZN9frt_queueIiE7ISR_getEv>
     286:	0c 94 79 1f 	jmp	0x3ef2	; 0x3ef2 <_ZN8emstreamlsE15ser_manipulator+0x24>
     28a:	0c 94 92 05 	jmp	0xb24	; 0xb24 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     28e:	0c 94 c8 20 	jmp	0x4190	; 0x4190 <_ZN5rs2327getcharEv>
     292:	0c 94 06 25 	jmp	0x4a0c	; 0x4a0c <_ZN9frt_queueIiE7ISR_putERKi>
     296:	0c 94 44 08 	jmp	0x1088	; 0x1088 <_ZN6MB120212RangeCommand11writePacketER6Packet>
     29a:	0c 94 6f 04 	jmp	0x8de	; 0x8de <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     29e:	0c 94 7c 1f 	jmp	0x3ef8	; 0x3ef8 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2a2:	0c 94 aa 23 	jmp	0x4754	; 0x4754 <_ZN9frt_queueIjE8is_emptyEv>
     2a6:	0c 94 7c 23 	jmp	0x46f8	; 0x46f8 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2aa:	0c 94 85 1f 	jmp	0x3f0a	; 0x3f0a <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2ae:	0c 94 9f 04 	jmp	0x93e	; 0x93e <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     2b2:	0c 94 30 25 	jmp	0x4a60	; 0x4a60 <_ZN9frt_queueIjE3putERKj>
     2b6:	0c 94 e2 0b 	jmp	0x17c4	; 0x17c4 <_ZN11task_sensor3runEv>
     2ba:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <_ZN8I2CAgent11resetPacketER6Packet>
     2be:	0c 94 1b 1f 	jmp	0x3e36	; 0x3e36 <_ZN8emstream7getcharEv>
     2c2:	0c 94 11 09 	jmp	0x1222	; 0x1222 <_ZN9frt_queueIhE7ISR_putERKh>
     2c6:	0c 94 91 0d 	jmp	0x1b22	; 0x1b22 <_ZN9task_user3runEv>
     2ca:	0c 94 91 03 	jmp	0x722	; 0x722 <_ZN8I2CAgent7receiveEv>
     2ce:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <_ZN9frt_queueIhE9not_emptyEv>
     2d2:	0c 94 87 1f 	jmp	0x3f0e	; 0x3f0e <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d6:	0c 94 63 08 	jmp	0x10c6	; 0x10c6 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2da:	0c 94 03 24 	jmp	0x4806	; 0x4806 <_ZN9frt_queueIjE3getEv>
     2de:	0c 94 c6 23 	jmp	0x478c	; 0x478c <_ZN9frt_queueIiE8is_emptyEv>
     2e2:	0c 94 57 1b 	jmp	0x36ae	; 0x36ae <_ZN8frt_task12print_statusER8emstream>
     2e6:	0c 94 98 23 	jmp	0x4730	; 0x4730 <_ZN9frt_queueIjE12num_items_inEv>
     2ea:	0c 94 95 24 	jmp	0x492a	; 0x492a <_ZN9frt_queueIiE7ISR_getEPi>
     2ee:	0c 94 76 1f 	jmp	0x3eec	; 0x3eec <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f2:	0c 94 35 04 	jmp	0x86a	; 0x86a <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     2f6:	0c 94 0b 05 	jmp	0xa16	; 0xa16 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     2fa:	0c 94 60 23 	jmp	0x46c0	; 0x46c0 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2fe:	0c 94 45 24 	jmp	0x488a	; 0x488a <_ZN9frt_queueIiE3getEPi>
     302:	0c 94 21 08 	jmp	0x1042	; 0x1042 <_ZN9I2CMaster10StartState7executeER6Packet>
     306:	0c 94 c5 04 	jmp	0x98a	; 0x98a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     30a:	0c 94 67 23 	jmp	0x46ce	; 0x46ce <_ZN9frt_queueIjE13ISR_not_emptyEv>
     30e:	0c 94 bf 1c 	jmp	0x397e	; 0x397e <_ZN14frt_text_queue14check_for_charEv>
     312:	0c 94 7f 1f 	jmp	0x3efe	; 0x3efe <_ZN8emstreamlsE15ser_manipulator+0x30>
     316:	0c 94 b9 08 	jmp	0x1172	; 0x1172 <_ZN9frt_queueIhE3getEv>
     31a:	0c 94 0c 0a 	jmp	0x1418	; 0x1418 <_ZN7MMA845116QueryXRegCommand11writePacketER6Packet>
     31e:	0c 94 bc 03 	jmp	0x778	; 0x778 <_ZN8I2CAgent11writePacketER7Command>
     322:	0c 94 7d 24 	jmp	0x48fa	; 0x48fa <_ZN9frt_queueIjE7ISR_getEv>
     326:	0c 94 19 0a 	jmp	0x1432	; 0x1432 <_ZN7MMA845116QueryYRegCommand11writePacketER6Packet>
     32a:	0c 94 98 1f 	jmp	0x3f30	; 0x3f30 <_ZN8emstreamlsE15ser_manipulator+0x62>
     32e:	0c 94 35 05 	jmp	0xa6a	; 0xa6a <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     332:	0c 94 82 1f 	jmp	0x3f04	; 0x3f04 <_ZN8emstreamlsE15ser_manipulator+0x36>
     336:	0c 94 b4 23 	jmp	0x4768	; 0x4768 <_ZN9frt_queueIiE12num_items_inEv>
     33a:	0c 94 36 03 	jmp	0x66c	; 0x66c <_call_static_run_method>
     33e:	0c 94 fb 03 	jmp	0x7f6	; 0x7f6 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     342:	0c 94 da 04 	jmp	0x9b4	; 0x9b4 <_ZN9I2CMaster9DoneState7executeER6Packet>
     346:	0c 94 95 14 	jmp	0x292a	; 0x292a <prvIdleTask>
     34a:	0c 94 bb 23 	jmp	0x4776	; 0x4776 <_ZN9frt_queueIiE9not_emptyEv>
     34e:	0c 94 95 08 	jmp	0x112a	; 0x112a <_ZN9frt_queueIhE10get_a_copyEv>
     352:	0c 94 d0 23 	jmp	0x47a0	; 0x47a0 <_ZN9frt_queueIjE10get_a_copyERj>
     356:	0c 94 1e 1f 	jmp	0x3e3c	; 0x3e3c <_ZN8emstream14check_for_charEv>
     35a:	0c 94 42 25 	jmp	0x4a84	; 0x4a84 <_ZN9frt_queueIiE7butt_inERKi>
     35e:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     362:	0c 94 b0 05 	jmp	0xb60	; 0xb60 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     366:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <_ZN8I2CAgent10readPacketEv>
     36a:	0c 94 83 23 	jmp	0x4706	; 0x4706 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     36e:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     372:	0c 94 ee 24 	jmp	0x49dc	; 0x49dc <_ZN9frt_queueIiE11ISR_butt_inERKi>
     376:	0c 94 82 1e 	jmp	0x3d04	; 0x3d04 <__cxa_pure_virtual>
     37a:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <_ZN9I2CMaster10ErrorState11serialDebugEv>
     37e:	0c 94 f9 08 	jmp	0x11f2	; 0x11f2 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     382:	0c 94 ad 08 	jmp	0x115a	; 0x115a <_ZN9frt_queueIhE3getEPh>
     386:	0c 94 f6 04 	jmp	0x9ec	; 0x9ec <_ZN9I2CMaster9DoneState11serialDebugEv>
     38a:	0c 94 4a 05 	jmp	0xa94	; 0xa94 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     38e:	0c 94 54 25 	jmp	0x4aa8	; 0x4aa8 <_ZN9frt_queueIiE3putERKi>
     392:	0c 94 58 08 	jmp	0x10b0	; 0x10b0 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     396:	0c 94 29 09 	jmp	0x1252	; 0x1252 <_ZN9frt_queueIhE7butt_inERKh>
     39a:	0c 94 ed 09 	jmp	0x13da	; 0x13da <_ZN7MMA845113ActiveCommand11writePacketER6Packet>
     39e:	0c 94 89 08 	jmp	0x1112	; 0x1112 <_ZN9frt_queueIhE10get_a_copyERh>
     3a2:	0c 94 8e 23 	jmp	0x471c	; 0x471c <_ZN9frt_queueIiE12ISR_is_emptyEv>
     3a6:	0c 94 a4 20 	jmp	0x4148	; 0x4148 <_ZN5rs2327putcharEc>
     3aa:	0c 94 e2 08 	jmp	0x11c4	; 0x11c4 <_ZN9frt_queueIhE7ISR_getEv>
     3ae:	0c 94 3b 09 	jmp	0x1276	; 0x1276 <_ZN9frt_queueIhE3putERKh>
     3b2:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <_ZN8I2CAgent8transmitER7Command>
     3b6:	0c 94 19 1f 	jmp	0x3e32	; 0x3e32 <_ZN8emstream13ready_to_sendEv>

000003ba <__trampolines_end>:
     3ba:	2c 20       	and	r2, r12
     3bc:	54 43       	sbci	r21, 0x34	; 52
     3be:	43 30       	cpi	r20, 0x03	; 3
     3c0:	43 43       	sbci	r20, 0x33	; 51
     3c2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c5 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c5:	2f 00                                               /.

000003c7 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d5 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d5:	54 69 6d 65 3a 20 00                                Time: .

000003dc <_ZZN9task_user11show_statusEvE3__c_0>:
     3dc:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e8 <_ZZN9task_user11show_statusEvE3__c>:
     3e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000407 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     407:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000416 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     416:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     426:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000431 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     431:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     441:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46f:	6d 61 74 69 6f 6e 00                                mation.

00000476 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     476:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     486:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000497 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     497:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a7:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004af <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4af:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bf:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004cb <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4cb:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4db:	68 65 20 41 56 52 00                                he AVR.

000004e2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4e2:	20 68 65 6c 70 00                                    help.

000004e8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000507 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     507:	1b 5b 33 30 6d 00                                   .[30m.

0000050d <_ZZN9task_user18print_help_messageEvE3__c>:
     50d:	1b 5b 34 36 6d 00                                   .[46m.

00000513 <_ZZN9task_user3runEvE3__c_3>:
     513:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     523:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000530 <_ZZN9task_user3runEvE3__c_2>:
     530:	3a 57 54 46 3f 00                                   :WTF?.

00000536 <_ZZN9task_user3runEvE3__c_1>:
     536:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     546:	65 00                                               e.

00000548 <_ZZN9task_user3runEvE3__c_0>:
     548:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000556 <_ZZN9task_user3runEvE3__c>:
     556:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     566:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000574 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     574:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057e <_ZZN8frt_task15emergency_resetEvE3__c>:
     57e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000058d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     58d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     59d:	61 73 6b 20 00                                      ask .

000005a2 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     5a2:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005b0 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5b0:	20 63 72 65 61 74 65 64 00                           created.

000005b9 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b9:	54 61 73 6b 20 00                                   Task .

000005bf <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bf:	1b 5b 32 32 6d 00                                   .[22m.

000005c5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c5:	54 61 73 6b 3a 20 00                                Task: .

000005cc <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5cc:	1b 5b 31 6d 00                                      .[1m.

000005d1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5d1:	1b 5b 32 32 6d 00                                   .[22m.

000005d7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005e2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5e2:	1b 5b 31 6d 00                                      .[1m.

000005e7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e7:	09 09 00                                            ...

000005ea <_ZZ15print_task_listP8emstreamE3__c_8>:
     5ea:	2f 00                                               /.

000005ec <_ZZ15print_task_listP8emstreamE3__c_7>:
     5ec:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f7:	09 2d 2d 2d 2d 00                                   .----.

000005fd <_ZZ15print_task_listP8emstreamE3__c_5>:
     5fd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000609 <_ZZ15print_task_listP8emstreamE3__c_4>:
     609:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000061a <_ZZ15print_task_listP8emstreamE3__c_3>:
     61a:	09 52 75 6e 73 00                                   .Runs.

00000620 <_ZZ15print_task_listP8emstreamE3__c_2>:
     620:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000062c <_ZZ15print_task_listP8emstreamE3__c_1>:
     62c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000063d <_ZZ15print_task_listP8emstreamE3__c_0>:
     63d:	09 53 74 61 63 6b 00                                .Stack.

00000644 <_ZZ15print_task_listP8emstreamE3__c>:
     644:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64f:	09 00                                               ..

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     653:	2f 00                                               /.

00000655 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     655:	09 00                                               ..

00000657 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     657:	09 00                                               ..

00000659 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     659:	1b 5b 32 32 6d 00                                   .[22m.

0000065f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65f:	1b 5b 31 6d 00                                      .[1m.

00000664 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     664:	1b 5b 31 6d 00                                      .[1m.

00000669 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     669:	20 20 00                                              .

0000066c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     66c:	0e 94 ef 19 	call	0x33de	; 0x33de <_ZN8frt_task22_call_users_run_methodEPS_>

00000670 <__ctors_start>:
     670:	09 26       	eor	r0, r25

00000672 <__ctors_end>:
     672:	11 24       	eor	r1, r1
     674:	1f be       	out	0x3f, r1	; 63
     676:	cf ef       	ldi	r28, 0xFF	; 255
     678:	cd bf       	out	0x3d, r28	; 61
     67a:	df e3       	ldi	r29, 0x3F	; 63
     67c:	de bf       	out	0x3e, r29	; 62
     67e:	00 e0       	ldi	r16, 0x00	; 0
     680:	0c bf       	out	0x3c, r16	; 60
     682:	18 be       	out	0x38, r1	; 56
     684:	19 be       	out	0x39, r1	; 57
     686:	1a be       	out	0x3a, r1	; 58
     688:	1b be       	out	0x3b, r1	; 59

0000068a <__do_copy_data>:
     68a:	12 e2       	ldi	r17, 0x22	; 34
     68c:	a0 e0       	ldi	r26, 0x00	; 0
     68e:	b0 e2       	ldi	r27, 0x20	; 32
     690:	ea ef       	ldi	r30, 0xFA	; 250
     692:	fe e4       	ldi	r31, 0x4E	; 78
     694:	00 e0       	ldi	r16, 0x00	; 0
     696:	0b bf       	out	0x3b, r16	; 59
     698:	02 c0       	rjmp	.+4      	; 0x69e <__do_copy_data+0x14>
     69a:	07 90       	elpm	r0, Z+
     69c:	0d 92       	st	X+, r0
     69e:	a6 33       	cpi	r26, 0x36	; 54
     6a0:	b1 07       	cpc	r27, r17
     6a2:	d9 f7       	brne	.-10     	; 0x69a <__do_copy_data+0x10>
     6a4:	1b be       	out	0x3b, r1	; 59

000006a6 <__do_clear_bss>:
     6a6:	23 e3       	ldi	r18, 0x33	; 51
     6a8:	a6 e3       	ldi	r26, 0x36	; 54
     6aa:	b2 e2       	ldi	r27, 0x22	; 34
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <.do_clear_bss_start>

000006ae <.do_clear_bss_loop>:
     6ae:	1d 92       	st	X+, r1

000006b0 <.do_clear_bss_start>:
     6b0:	a4 30       	cpi	r26, 0x04	; 4
     6b2:	b2 07       	cpc	r27, r18
     6b4:	e1 f7       	brne	.-8      	; 0x6ae <.do_clear_bss_loop>

000006b6 <__do_global_ctors>:
     6b6:	13 e0       	ldi	r17, 0x03	; 3
     6b8:	c9 e3       	ldi	r28, 0x39	; 57
     6ba:	d3 e0       	ldi	r29, 0x03	; 3
     6bc:	00 e0       	ldi	r16, 0x00	; 0
     6be:	06 c0       	rjmp	.+12     	; 0x6cc <__do_global_ctors+0x16>
     6c0:	21 97       	sbiw	r28, 0x01	; 1
     6c2:	01 09       	sbc	r16, r1
     6c4:	80 2f       	mov	r24, r16
     6c6:	fe 01       	movw	r30, r28
     6c8:	0e 94 d7 26 	call	0x4dae	; 0x4dae <__tablejump2__>
     6cc:	c8 33       	cpi	r28, 0x38	; 56
     6ce:	d1 07       	cpc	r29, r17
     6d0:	80 e0       	ldi	r24, 0x00	; 0
     6d2:	08 07       	cpc	r16, r24
     6d4:	a9 f7       	brne	.-22     	; 0x6c0 <__do_global_ctors+0xa>
     6d6:	0e 94 7b 25 	call	0x4af6	; 0x4af6 <main>
     6da:	0c 94 7b 27 	jmp	0x4ef6	; 0x4ef6 <_exit>

000006de <__bad_interrupt>:
     6de:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006e2 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6e2:	bc 01       	movw	r22, r24
     6e4:	6e 5f       	subi	r22, 0xFE	; 254
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	dc 01       	movw	r26, r24
     6ea:	ed 91       	ld	r30, X+
     6ec:	fc 91       	ld	r31, X
     6ee:	00 84       	ldd	r0, Z+8	; 0x08
     6f0:	f1 85       	ldd	r31, Z+9	; 0x09
     6f2:	e0 2d       	mov	r30, r0
     6f4:	19 95       	eicall
     6f6:	08 95       	ret

000006f8 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fe:	e8 81       	ld	r30, Y
     700:	f9 81       	ldd	r31, Y+1	; 0x01
     702:	04 80       	ldd	r0, Z+4	; 0x04
     704:	f5 81       	ldd	r31, Z+5	; 0x05
     706:	e0 2d       	mov	r30, r0
     708:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     70a:	be 01       	movw	r22, r28
     70c:	62 5f       	subi	r22, 0xF2	; 242
     70e:	7f 4f       	sbci	r23, 0xFF	; 255

  };

  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     710:	ec 8d       	ldd	r30, Y+28	; 0x1c
     712:	fd 8d       	ldd	r31, Y+29	; 0x1d
     714:	80 81       	ld	r24, Z
     716:	91 81       	ldd	r25, Z+1	; 0x01
     718:	0e 94 20 07 	call	0xe40	; 0xe40 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     722:	ef 92       	push	r14
     724:	ff 92       	push	r15
     726:	0f 93       	push	r16
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72e:	7c 01       	movw	r14, r24
     730:	82 e0       	ldi	r24, 0x02	; 2
     732:	e8 0e       	add	r14, r24
     734:	f1 1c       	adc	r15, r1
     736:	e8 81       	ld	r30, Y
     738:	f9 81       	ldd	r31, Y+1	; 0x01
     73a:	00 84       	ldd	r0, Z+8	; 0x08
     73c:	f1 85       	ldd	r31, Z+9	; 0x09
     73e:	e0 2d       	mov	r30, r0
     740:	b7 01       	movw	r22, r14
     742:	ce 01       	movw	r24, r28
     744:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     746:	28 85       	ldd	r18, Y+8	; 0x08
     748:	39 85       	ldd	r19, Y+9	; 0x09
     74a:	4a 85       	ldd	r20, Y+10	; 0x0a
     74c:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74e:	be 01       	movw	r22, r28
     750:	60 5e       	subi	r22, 0xE0	; 224
     752:	7f 4f       	sbci	r23, 0xFF	; 255
     754:	00 e0       	ldi	r16, 0x00	; 0
     756:	8e 81       	ldd	r24, Y+6	; 0x06
     758:	9f 81       	ldd	r25, Y+7	; 0x07
     75a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75e:	ec 8d       	ldd	r30, Y+28	; 0x1c
     760:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     762:	b7 01       	movw	r22, r14
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	0e 94 63 07 	call	0xec6	; 0xec6 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	0f 91       	pop	r16
     772:	ff 90       	pop	r15
     774:	ef 90       	pop	r14
     776:	08 95       	ret

00000778 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     778:	cf 92       	push	r12
     77a:	df 92       	push	r13
     77c:	ef 92       	push	r14
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	ec 01       	movw	r28, r24
     788:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     78a:	6c 01       	movw	r12, r24
     78c:	8e e0       	ldi	r24, 0x0E	; 14
     78e:	c8 0e       	add	r12, r24
     790:	d1 1c       	adc	r13, r1
     792:	e8 81       	ld	r30, Y
     794:	f9 81       	ldd	r31, Y+1	; 0x01
     796:	00 84       	ldd	r0, Z+8	; 0x08
     798:	f1 85       	ldd	r31, Z+9	; 0x09
     79a:	e0 2d       	mov	r30, r0
     79c:	b6 01       	movw	r22, r12
     79e:	ce 01       	movw	r24, r28
     7a0:	19 95       	eicall
     7a2:	2c 89       	ldd	r18, Y+20	; 0x14
     7a4:	3d 89       	ldd	r19, Y+21	; 0x15
     7a6:	4e 89       	ldd	r20, Y+22	; 0x16
     7a8:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7aa:	be 01       	movw	r22, r28
     7ac:	61 5e       	subi	r22, 0xE1	; 225
     7ae:	7f 4f       	sbci	r23, 0xFF	; 255
     7b0:	00 e0       	ldi	r16, 0x00	; 0
     7b2:	8a 89       	ldd	r24, Y+18	; 0x12
     7b4:	9b 89       	ldd	r25, Y+19	; 0x13
     7b6:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7ba:	d7 01       	movw	r26, r14
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	01 90       	ld	r0, Z+
     7c2:	f0 81       	ld	r31, Z
     7c4:	e0 2d       	mov	r30, r0
     7c6:	b6 01       	movw	r22, r12
     7c8:	c7 01       	movw	r24, r14
     7ca:	19 95       	eicall
}
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	0f 91       	pop	r16
     7d2:	ff 90       	pop	r15
     7d4:	ef 90       	pop	r14
     7d6:	df 90       	pop	r13
     7d8:	cf 90       	pop	r12
     7da:	08 95       	ret

000007dc <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7dc:	cb 01       	movw	r24, r22
  packet.resetContent();
     7de:	0e 94 ca 0b 	call	0x1794	; 0x1794 <_ZN6Packet12resetContentEv>
     7e2:	08 95       	ret

000007e4 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e4:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e6:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e8:	86 2f       	mov	r24, r22
     7ea:	88 0f       	add	r24, r24
     7ec:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ee:	68 2f       	mov	r22, r24
     7f0:	61 60       	ori	r22, 0x01	; 1
     7f2:	60 a3       	std	Z+32, r22	; 0x20
     7f4:	08 95       	ret

000007f6 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     7f6:	cf 93       	push	r28
     7f8:	df 93       	push	r29
     7fa:	1f 92       	push	r1
     7fc:	1f 92       	push	r1
     7fe:	cd b7       	in	r28, 0x3d	; 61
     800:	de b7       	in	r29, 0x3e	; 62
     802:	dc 01       	movw	r26, r24
     804:	19 96       	adiw	r26, 0x09	; 9
     806:	8d 91       	ld	r24, X+
     808:	9c 91       	ld	r25, X
     80a:	1a 97       	sbiw	r26, 0x0a	; 10
     80c:	89 83       	std	Y+1, r24	; 0x01
     80e:	9a 83       	std	Y+2, r25	; 0x02
     810:	29 81       	ldd	r18, Y+1	; 0x01
     812:	3a 81       	ldd	r19, Y+2	; 0x02
     814:	21 50       	subi	r18, 0x01	; 1
     816:	31 09       	sbc	r19, r1
     818:	29 83       	std	Y+1, r18	; 0x01
     81a:	3a 83       	std	Y+2, r19	; 0x02
     81c:	23 2b       	or	r18, r19
     81e:	51 f0       	breq	.+20     	; 0x834 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3e>
     820:	17 96       	adiw	r26, 0x07	; 7
     822:	ed 91       	ld	r30, X+
     824:	fc 91       	ld	r31, X
     826:	18 97       	sbiw	r26, 0x08	; 8
     828:	04 80       	ldd	r0, Z+4	; 0x04
     82a:	f5 81       	ldd	r31, Z+5	; 0x05
     82c:	e0 2d       	mov	r30, r0
     82e:	94 81       	ldd	r25, Z+4	; 0x04
     830:	96 ff       	sbrs	r25, 6
     832:	ee cf       	rjmp	.-36     	; 0x810 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
     834:	17 96       	adiw	r26, 0x07	; 7
     836:	ed 91       	ld	r30, X+
     838:	fc 91       	ld	r31, X
     83a:	18 97       	sbiw	r26, 0x08	; 8
     83c:	04 80       	ldd	r0, Z+4	; 0x04
     83e:	f5 81       	ldd	r31, Z+5	; 0x05
     840:	e0 2d       	mov	r30, r0
     842:	84 81       	ldd	r24, Z+4	; 0x04
     844:	84 fd       	sbrc	r24, 4
     846:	08 c0       	rjmp	.+16     	; 0x858 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x62>
     848:	84 81       	ldd	r24, Z+4	; 0x04
     84a:	86 ff       	sbrs	r24, 6
     84c:	05 c0       	rjmp	.+10     	; 0x858 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x62>
     84e:	12 96       	adiw	r26, 0x02	; 2
     850:	8d 91       	ld	r24, X+
     852:	9c 91       	ld	r25, X
     854:	13 97       	sbiw	r26, 0x03	; 3
     856:	04 c0       	rjmp	.+8      	; 0x860 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x6a>
     858:	14 96       	adiw	r26, 0x04	; 4
     85a:	8d 91       	ld	r24, X+
     85c:	9c 91       	ld	r25, X
     85e:	15 97       	sbiw	r26, 0x05	; 5
     860:	0f 90       	pop	r0
     862:	0f 90       	pop	r0
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	08 95       	ret

0000086a <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	1f 92       	push	r1
     870:	1f 92       	push	r1
     872:	cd b7       	in	r28, 0x3d	; 61
     874:	de b7       	in	r29, 0x3e	; 62
     876:	dc 01       	movw	r26, r24
     878:	19 96       	adiw	r26, 0x09	; 9
     87a:	8d 91       	ld	r24, X+
     87c:	9c 91       	ld	r25, X
     87e:	1a 97       	sbiw	r26, 0x0a	; 10
     880:	89 83       	std	Y+1, r24	; 0x01
     882:	9a 83       	std	Y+2, r25	; 0x02
     884:	29 81       	ldd	r18, Y+1	; 0x01
     886:	3a 81       	ldd	r19, Y+2	; 0x02
     888:	21 50       	subi	r18, 0x01	; 1
     88a:	31 09       	sbc	r19, r1
     88c:	29 83       	std	Y+1, r18	; 0x01
     88e:	3a 83       	std	Y+2, r19	; 0x02
     890:	23 2b       	or	r18, r19
     892:	51 f0       	breq	.+20     	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x3e>
     894:	17 96       	adiw	r26, 0x07	; 7
     896:	ed 91       	ld	r30, X+
     898:	fc 91       	ld	r31, X
     89a:	18 97       	sbiw	r26, 0x08	; 8
     89c:	04 80       	ldd	r0, Z+4	; 0x04
     89e:	f5 81       	ldd	r31, Z+5	; 0x05
     8a0:	e0 2d       	mov	r30, r0
     8a2:	94 81       	ldd	r25, Z+4	; 0x04
     8a4:	99 23       	and	r25, r25
     8a6:	74 f7       	brge	.-36     	; 0x884 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x1a>
     8a8:	17 96       	adiw	r26, 0x07	; 7
     8aa:	ed 91       	ld	r30, X+
     8ac:	fc 91       	ld	r31, X
     8ae:	18 97       	sbiw	r26, 0x08	; 8
     8b0:	04 80       	ldd	r0, Z+4	; 0x04
     8b2:	f5 81       	ldd	r31, Z+5	; 0x05
     8b4:	e0 2d       	mov	r30, r0
     8b6:	84 81       	ldd	r24, Z+4	; 0x04
     8b8:	84 fd       	sbrc	r24, 4
     8ba:	08 c0       	rjmp	.+16     	; 0x8cc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x62>
     8bc:	84 81       	ldd	r24, Z+4	; 0x04
     8be:	88 23       	and	r24, r24
     8c0:	2c f4       	brge	.+10     	; 0x8cc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x62>
     8c2:	12 96       	adiw	r26, 0x02	; 2
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	13 97       	sbiw	r26, 0x03	; 3
     8ca:	04 c0       	rjmp	.+8      	; 0x8d4 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x6a>
     8cc:	14 96       	adiw	r26, 0x04	; 4
     8ce:	8d 91       	ld	r24, X+
     8d0:	9c 91       	ld	r25, X
     8d2:	15 97       	sbiw	r26, 0x05	; 5
     8d4:	0f 90       	pop	r0
     8d6:	0f 90       	pop	r0
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     8de:	ef 92       	push	r14
     8e0:	ff 92       	push	r15
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
     8e6:	cf 93       	push	r28
     8e8:	df 93       	push	r29
     8ea:	8c 01       	movw	r16, r24
     8ec:	eb 01       	movw	r28, r22
     8ee:	e8 81       	ld	r30, Y
     8f0:	f9 81       	ldd	r31, Y+1	; 0x01
     8f2:	00 8c       	ldd	r0, Z+24	; 0x18
     8f4:	f1 8d       	ldd	r31, Z+25	; 0x19
     8f6:	e0 2d       	mov	r30, r0
     8f8:	cb 01       	movw	r24, r22
     8fa:	19 95       	eicall
     8fc:	88 23       	and	r24, r24
     8fe:	a9 f0       	breq	.+42     	; 0x92a <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     900:	e8 81       	ld	r30, Y
     902:	f9 81       	ldd	r31, Y+1	; 0x01
     904:	02 84       	ldd	r0, Z+10	; 0x0a
     906:	f3 85       	ldd	r31, Z+11	; 0x0b
     908:	e0 2d       	mov	r30, r0
     90a:	e1 2c       	mov	r14, r1
     90c:	f1 2c       	mov	r15, r1
     90e:	b7 01       	movw	r22, r14
     910:	ce 01       	movw	r24, r28
     912:	19 95       	eicall
     914:	d8 01       	movw	r26, r16
     916:	17 96       	adiw	r26, 0x07	; 7
     918:	ed 91       	ld	r30, X+
     91a:	fc 91       	ld	r31, X
     91c:	18 97       	sbiw	r26, 0x08	; 8
     91e:	04 80       	ldd	r0, Z+4	; 0x04
     920:	f5 81       	ldd	r31, Z+5	; 0x05
     922:	e0 2d       	mov	r30, r0
     924:	d7 01       	movw	r26, r14
     926:	8c 91       	ld	r24, X
     928:	87 83       	std	Z+7, r24	; 0x07
     92a:	f8 01       	movw	r30, r16
     92c:	82 81       	ldd	r24, Z+2	; 0x02
     92e:	93 81       	ldd	r25, Z+3	; 0x03
     930:	df 91       	pop	r29
     932:	cf 91       	pop	r28
     934:	1f 91       	pop	r17
     936:	0f 91       	pop	r16
     938:	ff 90       	pop	r15
     93a:	ef 90       	pop	r14
     93c:	08 95       	ret

0000093e <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     93e:	0f 93       	push	r16
     940:	1f 93       	push	r17
     942:	cf 93       	push	r28
     944:	df 93       	push	r29
     946:	1f 92       	push	r1
     948:	cd b7       	in	r28, 0x3d	; 61
     94a:	de b7       	in	r29, 0x3e	; 62
     94c:	8c 01       	movw	r16, r24
     94e:	cb 01       	movw	r24, r22
     950:	d8 01       	movw	r26, r16
     952:	17 96       	adiw	r26, 0x07	; 7
     954:	ed 91       	ld	r30, X+
     956:	fc 91       	ld	r31, X
     958:	18 97       	sbiw	r26, 0x08	; 8
     95a:	04 80       	ldd	r0, Z+4	; 0x04
     95c:	f5 81       	ldd	r31, Z+5	; 0x05
     95e:	e0 2d       	mov	r30, r0
     960:	27 81       	ldd	r18, Z+7	; 0x07
     962:	29 83       	std	Y+1, r18	; 0x01
     964:	db 01       	movw	r26, r22
     966:	ed 91       	ld	r30, X+
     968:	fc 91       	ld	r31, X
     96a:	01 90       	ld	r0, Z+
     96c:	f0 81       	ld	r31, Z
     96e:	e0 2d       	mov	r30, r0
     970:	be 01       	movw	r22, r28
     972:	6f 5f       	subi	r22, 0xFF	; 255
     974:	7f 4f       	sbci	r23, 0xFF	; 255
     976:	19 95       	eicall
     978:	f8 01       	movw	r30, r16
     97a:	82 81       	ldd	r24, Z+2	; 0x02
     97c:	93 81       	ldd	r25, Z+3	; 0x03
     97e:	0f 90       	pop	r0
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	1f 91       	pop	r17
     986:	0f 91       	pop	r16
     988:	08 95       	ret

0000098a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     98a:	cf 93       	push	r28
     98c:	df 93       	push	r29
     98e:	ec 01       	movw	r28, r24
     990:	cb 01       	movw	r24, r22
     992:	db 01       	movw	r26, r22
     994:	ed 91       	ld	r30, X+
     996:	fc 91       	ld	r31, X
     998:	04 88       	ldd	r0, Z+20	; 0x14
     99a:	f5 89       	ldd	r31, Z+21	; 0x15
     99c:	e0 2d       	mov	r30, r0
     99e:	19 95       	eicall
     9a0:	88 23       	and	r24, r24
     9a2:	19 f0       	breq	.+6      	; 0x9aa <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     9a4:	8a 81       	ldd	r24, Y+2	; 0x02
     9a6:	9b 81       	ldd	r25, Y+3	; 0x03
     9a8:	02 c0       	rjmp	.+4      	; 0x9ae <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     9aa:	8c 81       	ldd	r24, Y+4	; 0x04
     9ac:	9d 81       	ldd	r25, Y+5	; 0x05
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	08 95       	ret

000009b4 <_ZN9I2CMaster9DoneState7executeER6Packet>:
     9b4:	21 e0       	ldi	r18, 0x01	; 1
     9b6:	fb 01       	movw	r30, r22
     9b8:	23 87       	std	Z+11, r18	; 0x0b
     9ba:	fc 01       	movw	r30, r24
     9bc:	82 81       	ldd	r24, Z+2	; 0x02
     9be:	93 81       	ldd	r25, Z+3	; 0x03
     9c0:	08 95       	ret

000009c2 <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	dc 01       	movw	r26, r24
     9c8:	17 96       	adiw	r26, 0x07	; 7
     9ca:	ed 91       	ld	r30, X+
     9cc:	fc 91       	ld	r31, X
     9ce:	18 97       	sbiw	r26, 0x08	; 8
     9d0:	c6 81       	ldd	r28, Z+6	; 0x06
     9d2:	d7 81       	ldd	r29, Z+7	; 0x07
     9d4:	64 e1       	ldi	r22, 0x14	; 20
     9d6:	70 e2       	ldi	r23, 0x20	; 32
     9d8:	ce 01       	movw	r24, r28
     9da:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     9de:	66 e0       	ldi	r22, 0x06	; 6
     9e0:	ce 01       	movw	r24, r28
     9e2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	08 95       	ret

000009ec <_ZN9I2CMaster9DoneState11serialDebugEv>:
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	dc 01       	movw	r26, r24
     9f2:	17 96       	adiw	r26, 0x07	; 7
     9f4:	ed 91       	ld	r30, X+
     9f6:	fc 91       	ld	r31, X
     9f8:	18 97       	sbiw	r26, 0x08	; 8
     9fa:	c6 81       	ldd	r28, Z+6	; 0x06
     9fc:	d7 81       	ldd	r29, Z+7	; 0x07
     9fe:	6a e1       	ldi	r22, 0x1A	; 26
     a00:	70 e2       	ldi	r23, 0x20	; 32
     a02:	ce 01       	movw	r24, r28
     a04:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     a08:	66 e0       	ldi	r22, 0x06	; 6
     a0a:	ce 01       	movw	r24, r28
     a0c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	08 95       	ret

00000a16 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	dc 01       	movw	r26, r24
     a1c:	17 96       	adiw	r26, 0x07	; 7
     a1e:	ed 91       	ld	r30, X+
     a20:	fc 91       	ld	r31, X
     a22:	18 97       	sbiw	r26, 0x08	; 8
     a24:	c6 81       	ldd	r28, Z+6	; 0x06
     a26:	d7 81       	ldd	r29, Z+7	; 0x07
     a28:	6f e1       	ldi	r22, 0x1F	; 31
     a2a:	70 e2       	ldi	r23, 0x20	; 32
     a2c:	ce 01       	movw	r24, r28
     a2e:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     a32:	66 e0       	ldi	r22, 0x06	; 6
     a34:	ce 01       	movw	r24, r28
     a36:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	08 95       	ret

00000a40 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	dc 01       	movw	r26, r24
     a46:	17 96       	adiw	r26, 0x07	; 7
     a48:	ed 91       	ld	r30, X+
     a4a:	fc 91       	ld	r31, X
     a4c:	18 97       	sbiw	r26, 0x08	; 8
     a4e:	c6 81       	ldd	r28, Z+6	; 0x06
     a50:	d7 81       	ldd	r29, Z+7	; 0x07
     a52:	68 e2       	ldi	r22, 0x28	; 40
     a54:	70 e2       	ldi	r23, 0x20	; 32
     a56:	ce 01       	movw	r24, r28
     a58:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     a5c:	66 e0       	ldi	r22, 0x06	; 6
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     a6a:	cf 93       	push	r28
     a6c:	df 93       	push	r29
     a6e:	dc 01       	movw	r26, r24
     a70:	17 96       	adiw	r26, 0x07	; 7
     a72:	ed 91       	ld	r30, X+
     a74:	fc 91       	ld	r31, X
     a76:	18 97       	sbiw	r26, 0x08	; 8
     a78:	c6 81       	ldd	r28, Z+6	; 0x06
     a7a:	d7 81       	ldd	r29, Z+7	; 0x07
     a7c:	61 e3       	ldi	r22, 0x31	; 49
     a7e:	70 e2       	ldi	r23, 0x20	; 32
     a80:	ce 01       	movw	r24, r28
     a82:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     a86:	66 e0       	ldi	r22, 0x06	; 6
     a88:	ce 01       	movw	r24, r28
     a8a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	dc 01       	movw	r26, r24
     a9a:	17 96       	adiw	r26, 0x07	; 7
     a9c:	ed 91       	ld	r30, X+
     a9e:	fc 91       	ld	r31, X
     aa0:	18 97       	sbiw	r26, 0x08	; 8
     aa2:	c6 81       	ldd	r28, Z+6	; 0x06
     aa4:	d7 81       	ldd	r29, Z+7	; 0x07
     aa6:	6c e3       	ldi	r22, 0x3C	; 60
     aa8:	70 e2       	ldi	r23, 0x20	; 32
     aaa:	ce 01       	movw	r24, r28
     aac:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     ab0:	66 e0       	ldi	r22, 0x06	; 6
     ab2:	ce 01       	movw	r24, r28
     ab4:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <_ZN9I2CMaster10StartState11serialDebugEv>:
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	dc 01       	movw	r26, r24
     ac4:	17 96       	adiw	r26, 0x07	; 7
     ac6:	ed 91       	ld	r30, X+
     ac8:	fc 91       	ld	r31, X
     aca:	18 97       	sbiw	r26, 0x08	; 8
     acc:	c6 81       	ldd	r28, Z+6	; 0x06
     ace:	d7 81       	ldd	r29, Z+7	; 0x07
     ad0:	67 e4       	ldi	r22, 0x47	; 71
     ad2:	70 e2       	ldi	r23, 0x20	; 32
     ad4:	ce 01       	movw	r24, r28
     ad6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     ada:	66 e0       	ldi	r22, 0x06	; 6
     adc:	ce 01       	movw	r24, r28
     ade:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
     ae8:	1f 93       	push	r17
     aea:	cf 93       	push	r28
     aec:	df 93       	push	r29
     aee:	dc 01       	movw	r26, r24
     af0:	17 96       	adiw	r26, 0x07	; 7
     af2:	ed 91       	ld	r30, X+
     af4:	fc 91       	ld	r31, X
     af6:	18 97       	sbiw	r26, 0x08	; 8
     af8:	a4 81       	ldd	r26, Z+4	; 0x04
     afa:	b5 81       	ldd	r27, Z+5	; 0x05
     afc:	14 96       	adiw	r26, 0x04	; 4
     afe:	1c 91       	ld	r17, X
     b00:	c6 81       	ldd	r28, Z+6	; 0x06
     b02:	d7 81       	ldd	r29, Z+7	; 0x07
     b04:	6d e4       	ldi	r22, 0x4D	; 77
     b06:	70 e2       	ldi	r23, 0x20	; 32
     b08:	ce 01       	movw	r24, r28
     b0a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     b0e:	61 2f       	mov	r22, r17
     b10:	ce 01       	movw	r24, r28
     b12:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
     b16:	66 e0       	ldi	r22, 0x06	; 6
     b18:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     b1c:	df 91       	pop	r29
     b1e:	cf 91       	pop	r28
     b20:	1f 91       	pop	r17
     b22:	08 95       	ret

00000b24 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     b24:	1f 93       	push	r17
     b26:	cf 93       	push	r28
     b28:	df 93       	push	r29
     b2a:	dc 01       	movw	r26, r24
     b2c:	17 96       	adiw	r26, 0x07	; 7
     b2e:	ed 91       	ld	r30, X+
     b30:	fc 91       	ld	r31, X
     b32:	18 97       	sbiw	r26, 0x08	; 8
     b34:	a4 81       	ldd	r26, Z+4	; 0x04
     b36:	b5 81       	ldd	r27, Z+5	; 0x05
     b38:	14 96       	adiw	r26, 0x04	; 4
     b3a:	1c 91       	ld	r17, X
     b3c:	c6 81       	ldd	r28, Z+6	; 0x06
     b3e:	d7 81       	ldd	r29, Z+7	; 0x07
     b40:	68 e5       	ldi	r22, 0x58	; 88
     b42:	70 e2       	ldi	r23, 0x20	; 32
     b44:	ce 01       	movw	r24, r28
     b46:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     b4a:	61 2f       	mov	r22, r17
     b4c:	ce 01       	movw	r24, r28
     b4e:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
     b52:	66 e0       	ldi	r22, 0x06	; 6
     b54:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	08 95       	ret

00000b60 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	ec 01       	movw	r28, r24
     b6c:	ef 81       	ldd	r30, Y+7	; 0x07
     b6e:	f8 85       	ldd	r31, Y+8	; 0x08
     b70:	a4 81       	ldd	r26, Z+4	; 0x04
     b72:	b5 81       	ldd	r27, Z+5	; 0x05
     b74:	14 96       	adiw	r26, 0x04	; 4
     b76:	fc 90       	ld	r15, X
     b78:	06 81       	ldd	r16, Z+6	; 0x06
     b7a:	17 81       	ldd	r17, Z+7	; 0x07
     b7c:	63 e6       	ldi	r22, 0x63	; 99
     b7e:	70 e2       	ldi	r23, 0x20	; 32
     b80:	c8 01       	movw	r24, r16
     b82:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
     b86:	6f 2d       	mov	r22, r15
     b88:	c8 01       	movw	r24, r16
     b8a:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
     b8e:	66 e0       	ldi	r22, 0x06	; 6
     b90:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
     b94:	8a 81       	ldd	r24, Y+2	; 0x02
     b96:	9b 81       	ldd	r25, Y+3	; 0x03
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	08 95       	ret

00000ba4 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	8c 01       	movw	r16, r24
     bae:	eb 01       	movw	r28, r22
     bb0:	e8 81       	ld	r30, Y
     bb2:	f9 81       	ldd	r31, Y+1	; 0x01
     bb4:	04 8c       	ldd	r0, Z+28	; 0x1c
     bb6:	f5 8d       	ldd	r31, Z+29	; 0x1d
     bb8:	e0 2d       	mov	r30, r0
     bba:	cb 01       	movw	r24, r22
     bbc:	19 95       	eicall
     bbe:	2a 85       	ldd	r18, Y+10	; 0x0a
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	82 17       	cp	r24, r18
     bc4:	93 07       	cpc	r25, r19
     bc6:	79 f4       	brne	.+30     	; 0xbe6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     bc8:	d8 01       	movw	r26, r16
     bca:	17 96       	adiw	r26, 0x07	; 7
     bcc:	ed 91       	ld	r30, X+
     bce:	fc 91       	ld	r31, X
     bd0:	18 97       	sbiw	r26, 0x08	; 8
     bd2:	04 80       	ldd	r0, Z+4	; 0x04
     bd4:	f5 81       	ldd	r31, Z+5	; 0x05
     bd6:	e0 2d       	mov	r30, r0
     bd8:	87 e0       	ldi	r24, 0x07	; 7
     bda:	83 83       	std	Z+3, r24	; 0x03
     bdc:	12 96       	adiw	r26, 0x02	; 2
     bde:	8d 91       	ld	r24, X+
     be0:	9c 91       	ld	r25, X
     be2:	13 97       	sbiw	r26, 0x03	; 3
     be4:	0e c0       	rjmp	.+28     	; 0xc02 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     be6:	d8 01       	movw	r26, r16
     be8:	17 96       	adiw	r26, 0x07	; 7
     bea:	ed 91       	ld	r30, X+
     bec:	fc 91       	ld	r31, X
     bee:	18 97       	sbiw	r26, 0x08	; 8
     bf0:	04 80       	ldd	r0, Z+4	; 0x04
     bf2:	f5 81       	ldd	r31, Z+5	; 0x05
     bf4:	e0 2d       	mov	r30, r0
     bf6:	82 e0       	ldi	r24, 0x02	; 2
     bf8:	83 83       	std	Z+3, r24	; 0x03
     bfa:	14 96       	adiw	r26, 0x04	; 4
     bfc:	8d 91       	ld	r24, X+
     bfe:	9c 91       	ld	r25, X
     c00:	15 97       	sbiw	r26, 0x05	; 5
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	08 95       	ret

00000c0c <_ZN9I2CMaster11TransmitterC1EPS_>:
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ec 01       	movw	r28, r24
     c16:	8b 01       	movw	r16, r22
     c18:	68 83       	st	Y, r22
     c1a:	79 83       	std	Y+1, r23	; 0x01
     c1c:	89 e0       	ldi	r24, 0x09	; 9
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     c24:	fc 01       	movw	r30, r24
     c26:	16 82       	std	Z+6, r1	; 0x06
     c28:	8f ea       	ldi	r24, 0xAF	; 175
     c2a:	90 e2       	ldi	r25, 0x20	; 32
     c2c:	80 83       	st	Z, r24
     c2e:	91 83       	std	Z+1, r25	; 0x01
     c30:	07 83       	std	Z+7, r16	; 0x07
     c32:	10 87       	std	Z+8, r17	; 0x08
     c34:	ec 83       	std	Y+4, r30	; 0x04
     c36:	fd 83       	std	Y+5, r31	; 0x05
     c38:	8b e0       	ldi	r24, 0x0B	; 11
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     c40:	fc 01       	movw	r30, r24
     c42:	89 89       	ldd	r24, Y+17	; 0x11
     c44:	9a 89       	ldd	r25, Y+18	; 0x12
     c46:	16 82       	std	Z+6, r1	; 0x06
     c48:	27 eb       	ldi	r18, 0xB7	; 183
     c4a:	30 e2       	ldi	r19, 0x20	; 32
     c4c:	20 83       	st	Z, r18
     c4e:	31 83       	std	Z+1, r19	; 0x01
     c50:	07 83       	std	Z+7, r16	; 0x07
     c52:	10 87       	std	Z+8, r17	; 0x08
     c54:	81 87       	std	Z+9, r24	; 0x09
     c56:	92 87       	std	Z+10, r25	; 0x0a
     c58:	ee 83       	std	Y+6, r30	; 0x06
     c5a:	ff 83       	std	Y+7, r31	; 0x07
     c5c:	89 e0       	ldi	r24, 0x09	; 9
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     c64:	fc 01       	movw	r30, r24
     c66:	16 82       	std	Z+6, r1	; 0x06
     c68:	87 ec       	ldi	r24, 0xC7	; 199
     c6a:	90 e2       	ldi	r25, 0x20	; 32
     c6c:	80 83       	st	Z, r24
     c6e:	91 83       	std	Z+1, r25	; 0x01
     c70:	07 83       	std	Z+7, r16	; 0x07
     c72:	10 87       	std	Z+8, r17	; 0x08
     c74:	e8 87       	std	Y+8, r30	; 0x08
     c76:	f9 87       	std	Y+9, r31	; 0x09
     c78:	89 e0       	ldi	r24, 0x09	; 9
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     c80:	fc 01       	movw	r30, r24
     c82:	16 82       	std	Z+6, r1	; 0x06
     c84:	87 ed       	ldi	r24, 0xD7	; 215
     c86:	90 e2       	ldi	r25, 0x20	; 32
     c88:	80 83       	st	Z, r24
     c8a:	91 83       	std	Z+1, r25	; 0x01
     c8c:	07 83       	std	Z+7, r16	; 0x07
     c8e:	10 87       	std	Z+8, r17	; 0x08
     c90:	ea 87       	std	Y+10, r30	; 0x0a
     c92:	fb 87       	std	Y+11, r31	; 0x0b
     c94:	89 e0       	ldi	r24, 0x09	; 9
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     c9c:	fc 01       	movw	r30, r24
     c9e:	16 82       	std	Z+6, r1	; 0x06
     ca0:	8f ee       	ldi	r24, 0xEF	; 239
     ca2:	90 e2       	ldi	r25, 0x20	; 32
     ca4:	80 83       	st	Z, r24
     ca6:	91 83       	std	Z+1, r25	; 0x01
     ca8:	07 83       	std	Z+7, r16	; 0x07
     caa:	10 87       	std	Z+8, r17	; 0x08
     cac:	ec 87       	std	Y+12, r30	; 0x0c
     cae:	fd 87       	std	Y+13, r31	; 0x0d
     cb0:	89 e0       	ldi	r24, 0x09	; 9
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     cb8:	fc 01       	movw	r30, r24
     cba:	16 82       	std	Z+6, r1	; 0x06
     cbc:	87 ee       	ldi	r24, 0xE7	; 231
     cbe:	90 e2       	ldi	r25, 0x20	; 32
     cc0:	80 83       	st	Z, r24
     cc2:	91 83       	std	Z+1, r25	; 0x01
     cc4:	07 83       	std	Z+7, r16	; 0x07
     cc6:	10 87       	std	Z+8, r17	; 0x08
     cc8:	ee 87       	std	Y+14, r30	; 0x0e
     cca:	ff 87       	std	Y+15, r31	; 0x0f
     ccc:	80 e1       	ldi	r24, 0x10	; 16
     cce:	97 e2       	ldi	r25, 0x27	; 39
     cd0:	89 8b       	std	Y+17, r24	; 0x11
     cd2:	9a 8b       	std	Y+18, r25	; 0x12
     cd4:	8e 81       	ldd	r24, Y+6	; 0x06
     cd6:	9f 81       	ldd	r25, Y+7	; 0x07
     cd8:	ec 81       	ldd	r30, Y+4	; 0x04
     cda:	fd 81       	ldd	r31, Y+5	; 0x05
     cdc:	82 83       	std	Z+2, r24	; 0x02
     cde:	93 83       	std	Z+3, r25	; 0x03
     ce0:	84 83       	std	Z+4, r24	; 0x04
     ce2:	95 83       	std	Z+5, r25	; 0x05
     ce4:	8c 85       	ldd	r24, Y+12	; 0x0c
     ce6:	9d 85       	ldd	r25, Y+13	; 0x0d
     ce8:	28 85       	ldd	r18, Y+8	; 0x08
     cea:	39 85       	ldd	r19, Y+9	; 0x09
     cec:	ee 81       	ldd	r30, Y+6	; 0x06
     cee:	ff 81       	ldd	r31, Y+7	; 0x07
     cf0:	22 83       	std	Z+2, r18	; 0x02
     cf2:	33 83       	std	Z+3, r19	; 0x03
     cf4:	84 83       	std	Z+4, r24	; 0x04
     cf6:	95 83       	std	Z+5, r25	; 0x05
     cf8:	8a 85       	ldd	r24, Y+10	; 0x0a
     cfa:	9b 85       	ldd	r25, Y+11	; 0x0b
     cfc:	e8 85       	ldd	r30, Y+8	; 0x08
     cfe:	f9 85       	ldd	r31, Y+9	; 0x09
     d00:	82 83       	std	Z+2, r24	; 0x02
     d02:	93 83       	std	Z+3, r25	; 0x03
     d04:	84 83       	std	Z+4, r24	; 0x04
     d06:	95 83       	std	Z+5, r25	; 0x05
     d08:	8e 81       	ldd	r24, Y+6	; 0x06
     d0a:	9f 81       	ldd	r25, Y+7	; 0x07
     d0c:	2e 85       	ldd	r18, Y+14	; 0x0e
     d0e:	3f 85       	ldd	r19, Y+15	; 0x0f
     d10:	ea 85       	ldd	r30, Y+10	; 0x0a
     d12:	fb 85       	ldd	r31, Y+11	; 0x0b
     d14:	22 83       	std	Z+2, r18	; 0x02
     d16:	33 83       	std	Z+3, r19	; 0x03
     d18:	84 83       	std	Z+4, r24	; 0x04
     d1a:	95 83       	std	Z+5, r25	; 0x05
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	1f 91       	pop	r17
     d22:	0f 91       	pop	r16
     d24:	08 95       	ret

00000d26 <_ZN9I2CMaster8ReceiverC1EPS_>:
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	ec 01       	movw	r28, r24
     d30:	8b 01       	movw	r16, r22
     d32:	68 83       	st	Y, r22
     d34:	79 83       	std	Y+1, r23	; 0x01
     d36:	89 e0       	ldi	r24, 0x09	; 9
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     d3e:	fc 01       	movw	r30, r24
     d40:	16 82       	std	Z+6, r1	; 0x06
     d42:	8f ea       	ldi	r24, 0xAF	; 175
     d44:	90 e2       	ldi	r25, 0x20	; 32
     d46:	80 83       	st	Z, r24
     d48:	91 83       	std	Z+1, r25	; 0x01
     d4a:	07 83       	std	Z+7, r16	; 0x07
     d4c:	10 87       	std	Z+8, r17	; 0x08
     d4e:	ec 83       	std	Y+4, r30	; 0x04
     d50:	fd 83       	std	Y+5, r31	; 0x05
     d52:	8b e0       	ldi	r24, 0x0B	; 11
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     d5a:	fc 01       	movw	r30, r24
     d5c:	89 89       	ldd	r24, Y+17	; 0x11
     d5e:	9a 89       	ldd	r25, Y+18	; 0x12
     d60:	16 82       	std	Z+6, r1	; 0x06
     d62:	2f eb       	ldi	r18, 0xBF	; 191
     d64:	30 e2       	ldi	r19, 0x20	; 32
     d66:	20 83       	st	Z, r18
     d68:	31 83       	std	Z+1, r19	; 0x01
     d6a:	07 83       	std	Z+7, r16	; 0x07
     d6c:	10 87       	std	Z+8, r17	; 0x08
     d6e:	81 87       	std	Z+9, r24	; 0x09
     d70:	92 87       	std	Z+10, r25	; 0x0a
     d72:	ee 83       	std	Y+6, r30	; 0x06
     d74:	ff 83       	std	Y+7, r31	; 0x07
     d76:	89 e0       	ldi	r24, 0x09	; 9
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     d7e:	fc 01       	movw	r30, r24
     d80:	16 82       	std	Z+6, r1	; 0x06
     d82:	8f ec       	ldi	r24, 0xCF	; 207
     d84:	90 e2       	ldi	r25, 0x20	; 32
     d86:	80 83       	st	Z, r24
     d88:	91 83       	std	Z+1, r25	; 0x01
     d8a:	07 83       	std	Z+7, r16	; 0x07
     d8c:	10 87       	std	Z+8, r17	; 0x08
     d8e:	e8 87       	std	Y+8, r30	; 0x08
     d90:	f9 87       	std	Y+9, r31	; 0x09
     d92:	89 e0       	ldi	r24, 0x09	; 9
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     d9a:	fc 01       	movw	r30, r24
     d9c:	16 82       	std	Z+6, r1	; 0x06
     d9e:	8f ed       	ldi	r24, 0xDF	; 223
     da0:	90 e2       	ldi	r25, 0x20	; 32
     da2:	80 83       	st	Z, r24
     da4:	91 83       	std	Z+1, r25	; 0x01
     da6:	07 83       	std	Z+7, r16	; 0x07
     da8:	10 87       	std	Z+8, r17	; 0x08
     daa:	ea 87       	std	Y+10, r30	; 0x0a
     dac:	fb 87       	std	Y+11, r31	; 0x0b
     dae:	89 e0       	ldi	r24, 0x09	; 9
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     db6:	fc 01       	movw	r30, r24
     db8:	16 82       	std	Z+6, r1	; 0x06
     dba:	8f ee       	ldi	r24, 0xEF	; 239
     dbc:	90 e2       	ldi	r25, 0x20	; 32
     dbe:	80 83       	st	Z, r24
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	07 83       	std	Z+7, r16	; 0x07
     dc4:	10 87       	std	Z+8, r17	; 0x08
     dc6:	ec 87       	std	Y+12, r30	; 0x0c
     dc8:	fd 87       	std	Y+13, r31	; 0x0d
     dca:	89 e0       	ldi	r24, 0x09	; 9
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     dd2:	fc 01       	movw	r30, r24
     dd4:	16 82       	std	Z+6, r1	; 0x06
     dd6:	87 ee       	ldi	r24, 0xE7	; 231
     dd8:	90 e2       	ldi	r25, 0x20	; 32
     dda:	80 83       	st	Z, r24
     ddc:	91 83       	std	Z+1, r25	; 0x01
     dde:	07 83       	std	Z+7, r16	; 0x07
     de0:	10 87       	std	Z+8, r17	; 0x08
     de2:	ee 87       	std	Y+14, r30	; 0x0e
     de4:	ff 87       	std	Y+15, r31	; 0x0f
     de6:	80 e1       	ldi	r24, 0x10	; 16
     de8:	97 e2       	ldi	r25, 0x27	; 39
     dea:	89 8b       	std	Y+17, r24	; 0x11
     dec:	9a 8b       	std	Y+18, r25	; 0x12
     dee:	8e 81       	ldd	r24, Y+6	; 0x06
     df0:	9f 81       	ldd	r25, Y+7	; 0x07
     df2:	ec 81       	ldd	r30, Y+4	; 0x04
     df4:	fd 81       	ldd	r31, Y+5	; 0x05
     df6:	82 83       	std	Z+2, r24	; 0x02
     df8:	93 83       	std	Z+3, r25	; 0x03
     dfa:	84 83       	std	Z+4, r24	; 0x04
     dfc:	95 83       	std	Z+5, r25	; 0x05
     dfe:	8c 85       	ldd	r24, Y+12	; 0x0c
     e00:	9d 85       	ldd	r25, Y+13	; 0x0d
     e02:	28 85       	ldd	r18, Y+8	; 0x08
     e04:	39 85       	ldd	r19, Y+9	; 0x09
     e06:	ee 81       	ldd	r30, Y+6	; 0x06
     e08:	ff 81       	ldd	r31, Y+7	; 0x07
     e0a:	22 83       	std	Z+2, r18	; 0x02
     e0c:	33 83       	std	Z+3, r19	; 0x03
     e0e:	84 83       	std	Z+4, r24	; 0x04
     e10:	95 83       	std	Z+5, r25	; 0x05
     e12:	8a 85       	ldd	r24, Y+10	; 0x0a
     e14:	9b 85       	ldd	r25, Y+11	; 0x0b
     e16:	e8 85       	ldd	r30, Y+8	; 0x08
     e18:	f9 85       	ldd	r31, Y+9	; 0x09
     e1a:	82 83       	std	Z+2, r24	; 0x02
     e1c:	93 83       	std	Z+3, r25	; 0x03
     e1e:	84 83       	std	Z+4, r24	; 0x04
     e20:	95 83       	std	Z+5, r25	; 0x05
     e22:	8e 81       	ldd	r24, Y+6	; 0x06
     e24:	9f 81       	ldd	r25, Y+7	; 0x07
     e26:	2e 85       	ldd	r18, Y+14	; 0x0e
     e28:	3f 85       	ldd	r19, Y+15	; 0x0f
     e2a:	ea 85       	ldd	r30, Y+10	; 0x0a
     e2c:	fb 85       	ldd	r31, Y+11	; 0x0b
     e2e:	22 83       	std	Z+2, r18	; 0x02
     e30:	33 83       	std	Z+3, r19	; 0x03
     e32:	84 83       	std	Z+4, r24	; 0x04
     e34:	95 83       	std	Z+5, r25	; 0x05
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e40:	0f 93       	push	r16
     e42:	1f 93       	push	r17
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	ec 01       	movw	r28, r24
     e4a:	8b 01       	movw	r16, r22
     e4c:	8c 81       	ldd	r24, Y+4	; 0x04
     e4e:	9d 81       	ldd	r25, Y+5	; 0x05
     e50:	8a 83       	std	Y+2, r24	; 0x02
     e52:	9b 83       	std	Y+3, r25	; 0x03
     e54:	2e 85       	ldd	r18, Y+14	; 0x0e
     e56:	3f 85       	ldd	r19, Y+15	; 0x0f
     e58:	82 17       	cp	r24, r18
     e5a:	93 07       	cpc	r25, r19
     e5c:	d9 f0       	breq	.+54     	; 0xe94 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     e5e:	2c 85       	ldd	r18, Y+12	; 0x0c
     e60:	3d 85       	ldd	r19, Y+13	; 0x0d
     e62:	82 17       	cp	r24, r18
     e64:	93 07       	cpc	r25, r19
     e66:	31 f4       	brne	.+12     	; 0xe74 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     e68:	17 c0       	rjmp	.+46     	; 0xe98 <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     e6a:	2c 85       	ldd	r18, Y+12	; 0x0c
     e6c:	3d 85       	ldd	r19, Y+13	; 0x0d
     e6e:	28 17       	cp	r18, r24
     e70:	39 07       	cpc	r19, r25
     e72:	99 f0       	breq	.+38     	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e74:	dc 01       	movw	r26, r24
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	01 90       	ld	r0, Z+
     e7c:	f0 81       	ld	r31, Z
     e7e:	e0 2d       	mov	r30, r0
     e80:	b8 01       	movw	r22, r16
     e82:	19 95       	eicall
     e84:	8a 83       	std	Y+2, r24	; 0x02
     e86:	9b 83       	std	Y+3, r25	; 0x03
     e88:	2e 85       	ldd	r18, Y+14	; 0x0e
     e8a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e8c:	28 17       	cp	r18, r24
     e8e:	39 07       	cpc	r19, r25
     e90:	61 f7       	brne	.-40     	; 0xe6a <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     e92:	03 c0       	rjmp	.+6      	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e94:	c9 01       	movw	r24, r18
     e96:	01 c0       	rjmp	.+2      	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e98:	c9 01       	movw	r24, r18
     e9a:	dc 01       	movw	r26, r24
     e9c:	ed 91       	ld	r30, X+
     e9e:	fc 91       	ld	r31, X
     ea0:	01 90       	ld	r0, Z+
     ea2:	f0 81       	ld	r31, Z
     ea4:	e0 2d       	mov	r30, r0
     ea6:	b8 01       	movw	r22, r16
     ea8:	19 95       	eicall
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	4a 81       	ldd	r20, Y+2	; 0x02
     eae:	5b 81       	ldd	r21, Y+3	; 0x03
     eb0:	2e 85       	ldd	r18, Y+14	; 0x0e
     eb2:	3f 85       	ldd	r19, Y+15	; 0x0f
     eb4:	42 17       	cp	r20, r18
     eb6:	53 07       	cpc	r21, r19
     eb8:	09 f0       	breq	.+2      	; 0xebc <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	df 91       	pop	r29
     ebe:	cf 91       	pop	r28
     ec0:	1f 91       	pop	r17
     ec2:	0f 91       	pop	r16
     ec4:	08 95       	ret

00000ec6 <_ZN9I2CMaster8Receiver3runER6Packet>:
     ec6:	0f 93       	push	r16
     ec8:	1f 93       	push	r17
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	ec 01       	movw	r28, r24
     ed0:	8b 01       	movw	r16, r22
     ed2:	8c 81       	ldd	r24, Y+4	; 0x04
     ed4:	9d 81       	ldd	r25, Y+5	; 0x05
     ed6:	8a 83       	std	Y+2, r24	; 0x02
     ed8:	9b 83       	std	Y+3, r25	; 0x03
     eda:	2e 85       	ldd	r18, Y+14	; 0x0e
     edc:	3f 85       	ldd	r19, Y+15	; 0x0f
     ede:	82 17       	cp	r24, r18
     ee0:	93 07       	cpc	r25, r19
     ee2:	d9 f0       	breq	.+54     	; 0xf1a <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     ee4:	2c 85       	ldd	r18, Y+12	; 0x0c
     ee6:	3d 85       	ldd	r19, Y+13	; 0x0d
     ee8:	82 17       	cp	r24, r18
     eea:	93 07       	cpc	r25, r19
     eec:	31 f4       	brne	.+12     	; 0xefa <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     eee:	17 c0       	rjmp	.+46     	; 0xf1e <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     ef0:	2c 85       	ldd	r18, Y+12	; 0x0c
     ef2:	3d 85       	ldd	r19, Y+13	; 0x0d
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	99 f0       	breq	.+38     	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     efa:	dc 01       	movw	r26, r24
     efc:	ed 91       	ld	r30, X+
     efe:	fc 91       	ld	r31, X
     f00:	01 90       	ld	r0, Z+
     f02:	f0 81       	ld	r31, Z
     f04:	e0 2d       	mov	r30, r0
     f06:	b8 01       	movw	r22, r16
     f08:	19 95       	eicall
     f0a:	8a 83       	std	Y+2, r24	; 0x02
     f0c:	9b 83       	std	Y+3, r25	; 0x03
     f0e:	2e 85       	ldd	r18, Y+14	; 0x0e
     f10:	3f 85       	ldd	r19, Y+15	; 0x0f
     f12:	28 17       	cp	r18, r24
     f14:	39 07       	cpc	r19, r25
     f16:	61 f7       	brne	.-40     	; 0xef0 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     f18:	03 c0       	rjmp	.+6      	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f1a:	c9 01       	movw	r24, r18
     f1c:	01 c0       	rjmp	.+2      	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f1e:	c9 01       	movw	r24, r18
     f20:	dc 01       	movw	r26, r24
     f22:	ed 91       	ld	r30, X+
     f24:	fc 91       	ld	r31, X
     f26:	01 90       	ld	r0, Z+
     f28:	f0 81       	ld	r31, Z
     f2a:	e0 2d       	mov	r30, r0
     f2c:	b8 01       	movw	r22, r16
     f2e:	19 95       	eicall
     f30:	c8 01       	movw	r24, r16
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	1f 91       	pop	r17
     f38:	0f 91       	pop	r16
     f3a:	08 95       	ret

00000f3c <_ZN9I2CMaster12set_baudrateEm>:
     f3c:	cf 93       	push	r28
     f3e:	df 93       	push	r29
     f40:	ec 01       	movw	r28, r24
     f42:	9a 01       	movw	r18, r20
     f44:	ab 01       	movw	r20, r22
     f46:	22 0f       	add	r18, r18
     f48:	33 1f       	adc	r19, r19
     f4a:	44 1f       	adc	r20, r20
     f4c:	55 1f       	adc	r21, r21
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	78 e4       	ldi	r23, 0x48	; 72
     f52:	88 ee       	ldi	r24, 0xE8	; 232
     f54:	91 e0       	ldi	r25, 0x01	; 1
     f56:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
     f5a:	25 50       	subi	r18, 0x05	; 5
     f5c:	2a 87       	std	Y+10, r18	; 0x0a
     f5e:	ec 81       	ldd	r30, Y+4	; 0x04
     f60:	fd 81       	ldd	r31, Y+5	; 0x05
     f62:	25 83       	std	Z+5, r18	; 0x05
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	08 95       	ret

00000f6a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
     f6a:	ef 92       	push	r14
     f6c:	ff 92       	push	r15
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	ec 01       	movw	r28, r24
     f78:	7b 01       	movw	r14, r22
     f7a:	ba 01       	movw	r22, r20
     f7c:	a9 01       	movw	r20, r18
     f7e:	ec 82       	std	Y+4, r14	; 0x04
     f80:	fd 82       	std	Y+5, r15	; 0x05
     f82:	0e 83       	std	Y+6, r16	; 0x06
     f84:	1f 83       	std	Y+7, r17	; 0x07
     f86:	4b 87       	std	Y+11, r20	; 0x0b
     f88:	5c 87       	std	Y+12, r21	; 0x0c
     f8a:	6d 87       	std	Y+13, r22	; 0x0d
     f8c:	7e 87       	std	Y+14, r23	; 0x0e
     f8e:	80 e8       	ldi	r24, 0x80	; 128
     f90:	e8 16       	cp	r14, r24
     f92:	84 e0       	ldi	r24, 0x04	; 4
     f94:	f8 06       	cpc	r15, r24
     f96:	29 f4       	brne	.+10     	; 0xfa2 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
     f98:	80 e4       	ldi	r24, 0x40	; 64
     f9a:	96 e0       	ldi	r25, 0x06	; 6
     f9c:	88 87       	std	Y+8, r24	; 0x08
     f9e:	99 87       	std	Y+9, r25	; 0x09
     fa0:	09 c0       	rjmp	.+18     	; 0xfb4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     fa2:	e0 ea       	ldi	r30, 0xA0	; 160
     fa4:	ee 16       	cp	r14, r30
     fa6:	e4 e0       	ldi	r30, 0x04	; 4
     fa8:	fe 06       	cpc	r15, r30
     faa:	21 f4       	brne	.+8      	; 0xfb4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     fac:	80 e8       	ldi	r24, 0x80	; 128
     fae:	96 e0       	ldi	r25, 0x06	; 6
     fb0:	88 87       	std	Y+8, r24	; 0x08
     fb2:	99 87       	std	Y+9, r25	; 0x09
     fb4:	e8 85       	ldd	r30, Y+8	; 0x08
     fb6:	f9 85       	ldd	r31, Y+9	; 0x09
     fb8:	83 e0       	ldi	r24, 0x03	; 3
     fba:	81 83       	std	Z+1, r24	; 0x01
     fbc:	e8 85       	ldd	r30, Y+8	; 0x08
     fbe:	f9 85       	ldd	r31, Y+9	; 0x09
     fc0:	88 e3       	ldi	r24, 0x38	; 56
     fc2:	80 8b       	std	Z+16, r24	; 0x10
     fc4:	e8 85       	ldd	r30, Y+8	; 0x08
     fc6:	f9 85       	ldd	r31, Y+9	; 0x09
     fc8:	81 8b       	std	Z+17, r24	; 0x11
     fca:	82 e0       	ldi	r24, 0x02	; 2
     fcc:	f7 01       	movw	r30, r14
     fce:	82 83       	std	Z+2, r24	; 0x02
     fd0:	ce 01       	movw	r24, r28
     fd2:	0e 94 9e 07 	call	0xf3c	; 0xf3c <_ZN9I2CMaster12set_baudrateEm>
     fd6:	f7 01       	movw	r30, r14
     fd8:	84 81       	ldd	r24, Z+4	; 0x04
     fda:	8d 6c       	ori	r24, 0xCD	; 205
     fdc:	84 83       	std	Z+4, r24	; 0x04
     fde:	88 e0       	ldi	r24, 0x08	; 8
     fe0:	81 83       	std	Z+1, r24	; 0x01
     fe2:	83 e1       	ldi	r24, 0x13	; 19
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     fea:	7c 01       	movw	r14, r24
     fec:	be 01       	movw	r22, r28
     fee:	0e 94 06 06 	call	0xc0c	; 0xc0c <_ZN9I2CMaster11TransmitterC1EPS_>
     ff2:	e8 82       	st	Y, r14
     ff4:	f9 82       	std	Y+1, r15	; 0x01
     ff6:	84 e1       	ldi	r24, 0x14	; 20
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
     ffe:	7c 01       	movw	r14, r24
    1000:	be 01       	movw	r22, r28
    1002:	0e 94 93 06 	call	0xd26	; 0xd26 <_ZN9I2CMaster8ReceiverC1EPS_>
    1006:	ea 82       	std	Y+2, r14	; 0x02
    1008:	fb 82       	std	Y+3, r15	; 0x03
    100a:	0e 80       	ldd	r0, Y+6	; 0x06
    100c:	df 81       	ldd	r29, Y+7	; 0x07
    100e:	c0 2d       	mov	r28, r0
    1010:	65 e8       	ldi	r22, 0x85	; 133
    1012:	70 e2       	ldi	r23, 0x20	; 32
    1014:	ce 01       	movw	r24, r28
    1016:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    101a:	66 e0       	ldi	r22, 0x06	; 6
    101c:	ce 01       	movw	r24, r28
    101e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	08 95       	ret

00001030 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1030:	dc 01       	movw	r26, r24
    1032:	14 96       	adiw	r26, 0x04	; 4
    1034:	ed 91       	ld	r30, X+
    1036:	fc 91       	ld	r31, X
    1038:	15 97       	sbiw	r26, 0x05	; 5
    103a:	83 81       	ldd	r24, Z+3	; 0x03
    103c:	81 60       	ori	r24, 0x01	; 1
    103e:	83 83       	std	Z+3, r24	; 0x03
    1040:	08 95       	ret

00001042 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1042:	0f 93       	push	r16
    1044:	1f 93       	push	r17
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
    104a:	ec 01       	movw	r28, r24
    104c:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    104e:	db 01       	movw	r26, r22
    1050:	ed 91       	ld	r30, X+
    1052:	fc 91       	ld	r31, X
    1054:	02 84       	ldd	r0, Z+10	; 0x0a
    1056:	f3 85       	ldd	r31, Z+11	; 0x0b
    1058:	e0 2d       	mov	r30, r0
    105a:	00 e0       	ldi	r16, 0x00	; 0
    105c:	10 e0       	ldi	r17, 0x00	; 0
    105e:	b8 01       	movw	r22, r16
    1060:	19 95       	eicall
  driver_->send_start();
    1062:	8f 81       	ldd	r24, Y+7	; 0x07
    1064:	98 85       	ldd	r25, Y+8	; 0x08
    1066:	0e 94 18 08 	call	0x1030	; 0x1030 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    106a:	ef 81       	ldd	r30, Y+7	; 0x07
    106c:	f8 85       	ldd	r31, Y+8	; 0x08
    106e:	04 80       	ldd	r0, Z+4	; 0x04
    1070:	f5 81       	ldd	r31, Z+5	; 0x05
    1072:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1074:	d8 01       	movw	r26, r16
    1076:	8c 91       	ld	r24, X
    1078:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    107a:	8a 81       	ldd	r24, Y+2	; 0x02
    107c:	9b 81       	ldd	r25, Y+3	; 0x03
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	1f 91       	pop	r17
    1084:	0f 91       	pop	r16
    1086:	08 95       	ret

00001088 <_ZN6MB120212RangeCommand11writePacketER6Packet>:
		 */
		virtual bool ISR_butt_in (const data_type& item)
		{
			(void) item;                    // This just shuts up a compiler warning
			return (false);
		}
    1088:	db 01       	movw	r26, r22
    108a:	bc 01       	movw	r22, r24
    108c:	6e 5f       	subi	r22, 0xFE	; 254
    108e:	7f 4f       	sbci	r23, 0xFF	; 255
    1090:	ed 91       	ld	r30, X+
    1092:	fc 91       	ld	r31, X
    1094:	11 97       	sbiw	r26, 0x01	; 1
    1096:	01 90       	ld	r0, Z+
    1098:	f0 81       	ld	r31, Z
    109a:	e0 2d       	mov	r30, r0
    109c:	cd 01       	movw	r24, r26
    109e:	19 95       	eicall
    10a0:	08 95       	ret

000010a2 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    10a2:	fc 01       	movw	r30, r24
    10a4:	84 81       	ldd	r24, Z+4	; 0x04
    10a6:	95 81       	ldd	r25, Z+5	; 0x05
    10a8:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
		}
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	08 95       	ret

000010b0 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    10b0:	fc 01       	movw	r30, r24
    10b2:	84 81       	ldd	r24, Z+4	; 0x04
    10b4:	95 81       	ldd	r25, Z+5	; 0x05
    10b6:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    10ba:	91 e0       	ldi	r25, 0x01	; 1
    10bc:	81 11       	cpse	r24, r1
    10be:	01 c0       	rjmp	.+2      	; 0x10c2 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    10c0:	90 e0       	ldi	r25, 0x00	; 0
		}
    10c2:	89 2f       	mov	r24, r25
    10c4:	08 95       	ret

000010c6 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    10c6:	fc 01       	movw	r30, r24
    10c8:	84 81       	ldd	r24, Z+4	; 0x04
    10ca:	95 81       	ldd	r25, Z+5	; 0x05
    10cc:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    10d0:	91 e0       	ldi	r25, 0x01	; 1
    10d2:	81 11       	cpse	r24, r1
    10d4:	90 e0       	ldi	r25, 0x00	; 0
		}
    10d6:	89 2f       	mov	r24, r25
    10d8:	08 95       	ret

000010da <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    10da:	fc 01       	movw	r30, r24
    10dc:	84 81       	ldd	r24, Z+4	; 0x04
    10de:	95 81       	ldd	r25, Z+5	; 0x05
    10e0:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
		}
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	08 95       	ret

000010e8 <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    10e8:	fc 01       	movw	r30, r24
    10ea:	84 81       	ldd	r24, Z+4	; 0x04
    10ec:	95 81       	ldd	r25, Z+5	; 0x05
    10ee:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	81 11       	cpse	r24, r1
    10f6:	01 c0       	rjmp	.+2      	; 0x10fa <_ZN9frt_queueIhE9not_emptyEv+0x12>
    10f8:	90 e0       	ldi	r25, 0x00	; 0
		}
    10fa:	89 2f       	mov	r24, r25
    10fc:	08 95       	ret

000010fe <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    10fe:	fc 01       	movw	r30, r24
    1100:	84 81       	ldd	r24, Z+4	; 0x04
    1102:	95 81       	ldd	r25, Z+5	; 0x05
    1104:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    1108:	91 e0       	ldi	r25, 0x01	; 1
    110a:	81 11       	cpse	r24, r1
    110c:	90 e0       	ldi	r25, 0x00	; 0
		}
    110e:	89 2f       	mov	r24, r25
    1110:	08 95       	ret

00001112 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    1112:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    1114:	01 e0       	ldi	r16, 0x01	; 1
    1116:	2f ef       	ldi	r18, 0xFF	; 255
    1118:	3f ef       	ldi	r19, 0xFF	; 255
    111a:	a9 01       	movw	r20, r18
    111c:	fc 01       	movw	r30, r24
    111e:	84 81       	ldd	r24, Z+4	; 0x04
    1120:	95 81       	ldd	r25, Z+5	; 0x05
    1122:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    1126:	0f 91       	pop	r16
    1128:	08 95       	ret

0000112a <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    112a:	0f 93       	push	r16
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	1f 92       	push	r1
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    1136:	01 e0       	ldi	r16, 0x01	; 1
    1138:	2f ef       	ldi	r18, 0xFF	; 255
    113a:	3f ef       	ldi	r19, 0xFF	; 255
    113c:	a9 01       	movw	r20, r18
    113e:	be 01       	movw	r22, r28
    1140:	6f 5f       	subi	r22, 0xFF	; 255
    1142:	7f 4f       	sbci	r23, 0xFF	; 255
    1144:	fc 01       	movw	r30, r24
    1146:	84 81       	ldd	r24, Z+4	; 0x04
    1148:	95 81       	ldd	r25, Z+5	; 0x05
    114a:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	0f 90       	pop	r0
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	0f 91       	pop	r16
    1158:	08 95       	ret

0000115a <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    115a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    115c:	00 e0       	ldi	r16, 0x00	; 0
    115e:	2f ef       	ldi	r18, 0xFF	; 255
    1160:	3f ef       	ldi	r19, 0xFF	; 255
    1162:	a9 01       	movw	r20, r18
    1164:	fc 01       	movw	r30, r24
    1166:	84 81       	ldd	r24, Z+4	; 0x04
    1168:	95 81       	ldd	r25, Z+5	; 0x05
    116a:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    116e:	0f 91       	pop	r16
    1170:	08 95       	ret

00001172 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    1172:	0f 93       	push	r16
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	1f 92       	push	r1
    117a:	cd b7       	in	r28, 0x3d	; 61
    117c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    117e:	00 e0       	ldi	r16, 0x00	; 0
    1180:	2f ef       	ldi	r18, 0xFF	; 255
    1182:	3f ef       	ldi	r19, 0xFF	; 255
    1184:	a9 01       	movw	r20, r18
    1186:	be 01       	movw	r22, r28
    1188:	6f 5f       	subi	r22, 0xFF	; 255
    118a:	7f 4f       	sbci	r23, 0xFF	; 255
    118c:	fc 01       	movw	r30, r24
    118e:	84 81       	ldd	r24, Z+4	; 0x04
    1190:	95 81       	ldd	r25, Z+5	; 0x05
    1192:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    1196:	89 81       	ldd	r24, Y+1	; 0x01
    1198:	0f 90       	pop	r0
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	0f 91       	pop	r16
    11a0:	08 95       	ret

000011a2 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	1f 92       	push	r1
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    11ac:	ae 01       	movw	r20, r28
    11ae:	4f 5f       	subi	r20, 0xFF	; 255
    11b0:	5f 4f       	sbci	r21, 0xFF	; 255
    11b2:	fc 01       	movw	r30, r24
    11b4:	84 81       	ldd	r24, Z+4	; 0x04
    11b6:	95 81       	ldd	r25, Z+5	; 0x05
    11b8:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
}
    11bc:	0f 90       	pop	r0
    11be:	df 91       	pop	r29
    11c0:	cf 91       	pop	r28
    11c2:	08 95       	ret

000011c4 <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	1f 92       	push	r1
    11ca:	1f 92       	push	r1
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    11d0:	ae 01       	movw	r20, r28
    11d2:	4e 5f       	subi	r20, 0xFE	; 254
    11d4:	5f 4f       	sbci	r21, 0xFF	; 255
    11d6:	be 01       	movw	r22, r28
    11d8:	6f 5f       	subi	r22, 0xFF	; 255
    11da:	7f 4f       	sbci	r23, 0xFF	; 255
    11dc:	fc 01       	movw	r30, r24
    11de:	84 81       	ldd	r24, Z+4	; 0x04
    11e0:	95 81       	ldd	r25, Z+5	; 0x05
    11e2:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
	return (recv_item);
}
    11e6:	89 81       	ldd	r24, Y+1	; 0x01
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	08 95       	ret

000011f2 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    11f2:	cf 93       	push	r28
    11f4:	df 93       	push	r29
    11f6:	1f 92       	push	r1
    11f8:	cd b7       	in	r28, 0x3d	; 61
    11fa:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    11fc:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    11fe:	21 e0       	ldi	r18, 0x01	; 1
    1200:	ae 01       	movw	r20, r28
    1202:	4f 5f       	subi	r20, 0xFF	; 255
    1204:	5f 4f       	sbci	r21, 0xFF	; 255
    1206:	fc 01       	movw	r30, r24
    1208:	84 81       	ldd	r24, Z+4	; 0x04
    120a:	95 81       	ldd	r25, Z+5	; 0x05
    120c:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1210:	91 e0       	ldi	r25, 0x01	; 1
    1212:	81 11       	cpse	r24, r1
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    1216:	90 e0       	ldi	r25, 0x00	; 0
}
    1218:	89 2f       	mov	r24, r25
    121a:	0f 90       	pop	r0
    121c:	df 91       	pop	r29
    121e:	cf 91       	pop	r28
    1220:	08 95       	ret

00001222 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	1f 92       	push	r1
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    122c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	ae 01       	movw	r20, r28
    1232:	4f 5f       	subi	r20, 0xFF	; 255
    1234:	5f 4f       	sbci	r21, 0xFF	; 255
    1236:	fc 01       	movw	r30, r24
    1238:	84 81       	ldd	r24, Z+4	; 0x04
    123a:	95 81       	ldd	r25, Z+5	; 0x05
    123c:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1240:	91 e0       	ldi	r25, 0x01	; 1
    1242:	81 11       	cpse	r24, r1
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    1246:	90 e0       	ldi	r25, 0x00	; 0
}
    1248:	89 2f       	mov	r24, r25
    124a:	0f 90       	pop	r0
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    1252:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    1254:	fc 01       	movw	r30, r24
    1256:	26 81       	ldd	r18, Z+6	; 0x06
    1258:	37 81       	ldd	r19, Z+7	; 0x07
    125a:	40 85       	ldd	r20, Z+8	; 0x08
    125c:	51 85       	ldd	r21, Z+9	; 0x09
    125e:	01 e0       	ldi	r16, 0x01	; 1
    1260:	84 81       	ldd	r24, Z+4	; 0x04
    1262:	95 81       	ldd	r25, Z+5	; 0x05
    1264:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    1268:	91 e0       	ldi	r25, 0x01	; 1
    126a:	81 11       	cpse	r24, r1
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    126e:	90 e0       	ldi	r25, 0x00	; 0
		}
    1270:	89 2f       	mov	r24, r25
    1272:	0f 91       	pop	r16
    1274:	08 95       	ret

00001276 <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    1276:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    1278:	fc 01       	movw	r30, r24
    127a:	26 81       	ldd	r18, Z+6	; 0x06
    127c:	37 81       	ldd	r19, Z+7	; 0x07
    127e:	40 85       	ldd	r20, Z+8	; 0x08
    1280:	51 85       	ldd	r21, Z+9	; 0x09
    1282:	00 e0       	ldi	r16, 0x00	; 0
    1284:	84 81       	ldd	r24, Z+4	; 0x04
    1286:	95 81       	ldd	r25, Z+5	; 0x05
    1288:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    128c:	91 e0       	ldi	r25, 0x01	; 1
    128e:	81 11       	cpse	r24, r1
    1290:	01 c0       	rjmp	.+2      	; 0x1294 <_ZN9frt_queueIhE3putERKh+0x1e>
    1292:	90 e0       	ldi	r25, 0x00	; 0
		}
    1294:	89 2f       	mov	r24, r25
    1296:	0f 91       	pop	r16
    1298:	08 95       	ret

0000129a <_ZN6MB1202C1EP9I2CMasterP8emstream>:
//-------------------------------------------------------------------------------------
/** This constructor creates an object to use when interacting with the SPI registers on the MAX31855
    Thermocouple Analog to Digital Converter chip.
 *  @param SPIM A pointer to an SPI_master object
 */
MB1202::MB1202(I2CMaster * d, emstream * s)
    129a:	3f 92       	push	r3
    129c:	4f 92       	push	r4
    129e:	5f 92       	push	r5
    12a0:	6f 92       	push	r6
    12a2:	7f 92       	push	r7
    12a4:	8f 92       	push	r8
    12a6:	9f 92       	push	r9
    12a8:	af 92       	push	r10
    12aa:	bf 92       	push	r11
    12ac:	cf 92       	push	r12
    12ae:	df 92       	push	r13
    12b0:	ef 92       	push	r14
    12b2:	ff 92       	push	r15
    12b4:	0f 93       	push	r16
    12b6:	1f 93       	push	r17
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	8c 01       	movw	r16, r24
    12be:	7b 01       	movw	r14, r22
    12c0:	6a 01       	movw	r12, r20
  : driver_(d),
  	p_serial(s),
  	i2cAgent_(new I2CAgent(s, outPacketSize_, inPacketSize_)),
  	slaveAddr_(SLAVE_ADDR),
  	rangeCommand_(new RangeCommand())
    12c2:	dc 01       	movw	r26, r24
    12c4:	6d 93       	st	X+, r22
    12c6:	7c 93       	st	X, r23
    12c8:	11 97       	sbiw	r26, 0x01	; 1
    12ca:	12 96       	adiw	r26, 0x02	; 2
    12cc:	4d 93       	st	X+, r20
    12ce:	5c 93       	st	X, r21
    12d0:	13 97       	sbiw	r26, 0x03	; 3
    12d2:	81 e2       	ldi	r24, 0x21	; 33
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    12da:	ec 01       	movw	r28, r24
class CommAgent
{
public:
  CommAgent( uint8_t outPacketSize, uint8_t inPacketSize)
    : inPacket_(inPacketSize,NULL,10),
      outPacket_(outPacketSize,NULL,10)
    12dc:	8f e3       	ldi	r24, 0x3F	; 63
    12de:	91 e2       	ldi	r25, 0x21	; 33
    12e0:	88 83       	st	Y, r24
    12e2:	99 83       	std	Y+1, r25	; 0x01

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    12e4:	1c 82       	std	Y+4, r1	; 0x04
    12e6:	1d 82       	std	Y+5, r1	; 0x05
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    12e8:	0f 2e       	mov	r0, r31
    12ea:	f7 ef       	ldi	r31, 0xF7	; 247
    12ec:	af 2e       	mov	r10, r31
    12ee:	f0 e2       	ldi	r31, 0x20	; 32
    12f0:	bf 2e       	mov	r11, r31
    12f2:	f0 2d       	mov	r31, r0
    12f4:	aa 82       	std	Y+2, r10	; 0x02
    12f6:	bb 82       	std	Y+3, r11	; 0x03
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    12f8:	40 e0       	ldi	r20, 0x00	; 0
    12fa:	61 e0       	ldi	r22, 0x01	; 1
    12fc:	82 e0       	ldi	r24, 0x02	; 2
    12fe:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    1302:	8e 83       	std	Y+6, r24	; 0x06
    1304:	9f 83       	std	Y+7, r25	; 0x07

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    1306:	0f 2e       	mov	r0, r31
    1308:	fa e0       	ldi	r31, 0x0A	; 10
    130a:	4f 2e       	mov	r4, r31
    130c:	51 2c       	mov	r5, r1
    130e:	61 2c       	mov	r6, r1
    1310:	71 2c       	mov	r7, r1
    1312:	f0 2d       	mov	r31, r0
    1314:	48 86       	std	Y+8, r4	; 0x08
    1316:	59 86       	std	Y+9, r5	; 0x09
    1318:	6a 86       	std	Y+10, r6	; 0x0a
    131a:	7b 86       	std	Y+11, r7	; 0x0b
  : public frt_queue< uint8_t >
{
public:
  inline Packet( uint8_t queue_size = 10, emstream * p_ser_dev = NULL, portTickType wait_time = 10 )
    : frt_queue(queue_size, p_ser_dev, wait_time),
      size_(queue_size)
    131c:	0f 2e       	mov	r0, r31
    131e:	fb e1       	ldi	r31, 0x1B	; 27
    1320:	8f 2e       	mov	r8, r31
    1322:	f1 e2       	ldi	r31, 0x21	; 33
    1324:	9f 2e       	mov	r9, r31
    1326:	f0 2d       	mov	r31, r0
    1328:	8a 82       	std	Y+2, r8	; 0x02
    132a:	9b 82       	std	Y+3, r9	; 0x03
    132c:	68 94       	set
    132e:	33 24       	eor	r3, r3
    1330:	31 f8       	bld	r3, 1
    1332:	3c 86       	std	Y+12, r3	; 0x0c
    1334:	18 8a       	std	Y+16, r1	; 0x10
    1336:	19 8a       	std	Y+17, r1	; 0x11
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    1338:	ae 86       	std	Y+14, r10	; 0x0e
    133a:	bf 86       	std	Y+15, r11	; 0x0f
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	61 e0       	ldi	r22, 0x01	; 1
    1340:	82 e0       	ldi	r24, 0x02	; 2
    1342:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    1346:	8a 8b       	std	Y+18, r24	; 0x12
    1348:	9b 8b       	std	Y+19, r25	; 0x13

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    134a:	4c 8a       	std	Y+20, r4	; 0x14
    134c:	5d 8a       	std	Y+21, r5	; 0x15
    134e:	6e 8a       	std	Y+22, r6	; 0x16
    1350:	7f 8a       	std	Y+23, r7	; 0x17
    1352:	8e 86       	std	Y+14, r8	; 0x0e
    1354:	9f 86       	std	Y+15, r9	; 0x0f
    1356:	38 8e       	std	Y+24, r3	; 0x18
  inline I2CAgent( uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize)
  {}
  inline I2CAgent( emstream * s, uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize),
      p_serial(s)
    1358:	8a e0       	ldi	r24, 0x0A	; 10
    135a:	90 e2       	ldi	r25, 0x20	; 32
    135c:	88 83       	st	Y, r24
    135e:	99 83       	std	Y+1, r25	; 0x01
    1360:	ca 8e       	std	Y+26, r12	; 0x1a
    1362:	db 8e       	std	Y+27, r13	; 0x1b
    1364:	f8 01       	movw	r30, r16
    1366:	c4 83       	std	Z+4, r28	; 0x04
    1368:	d5 83       	std	Z+5, r29	; 0x05
    136a:	80 e7       	ldi	r24, 0x70	; 112
    136c:	86 83       	std	Z+6, r24	; 0x06
    136e:	10 86       	std	Z+8, r1	; 0x08
    1370:	11 86       	std	Z+9, r1	; 0x09
    1372:	12 86       	std	Z+10, r1	; 0x0a
    1374:	13 86       	std	Z+11, r1	; 0x0b
    1376:	14 86       	std	Z+12, r1	; 0x0c
    1378:	83 e0       	ldi	r24, 0x03	; 3
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
		: public Command
	{
	public:

		inline RangeCommand()
			: commandCode_(RANGE_CMD)
    1380:	2d e4       	ldi	r18, 0x4D	; 77
    1382:	31 e2       	ldi	r19, 0x21	; 33
    1384:	fc 01       	movw	r30, r24
    1386:	20 83       	st	Z, r18
    1388:	31 83       	std	Z+1, r19	; 0x01
    138a:	21 e5       	ldi	r18, 0x51	; 81
    138c:	22 83       	std	Z+2, r18	; 0x02
    138e:	d8 01       	movw	r26, r16
    1390:	1f 96       	adiw	r26, 0x0f	; 15
    1392:	8d 93       	st	X+, r24
    1394:	9c 93       	st	X, r25
    1396:	50 97       	sbiw	r26, 0x10	; 16
{
	i2cAgent_->setI2CDriver(d);
    1398:	14 96       	adiw	r26, 0x04	; 4
    139a:	ed 91       	ld	r30, X+
    139c:	fc 91       	ld	r31, X
    139e:	15 97       	sbiw	r26, 0x05	; 5
  {}
  virtual bool transmit( Command & cmd );
  virtual Packet & receive();
  void setI2CDriver( I2CMaster * d ) { driver_ = d; }
    13a0:	e4 8e       	std	Z+28, r14	; 0x1c
    13a2:	f5 8e       	std	Z+29, r15	; 0x1d
	i2cAgent_->setSlaveAddr(slaveAddr_);
    13a4:	16 96       	adiw	r26, 0x06	; 6
    13a6:	6c 91       	ld	r22, X
    13a8:	16 97       	sbiw	r26, 0x06	; 6
    13aa:	14 96       	adiw	r26, 0x04	; 4
    13ac:	8d 91       	ld	r24, X+
    13ae:	9c 91       	ld	r25, X
    13b0:	15 97       	sbiw	r26, 0x05	; 5
    13b2:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	ff 90       	pop	r15
    13c0:	ef 90       	pop	r14
    13c2:	df 90       	pop	r13
    13c4:	cf 90       	pop	r12
    13c6:	bf 90       	pop	r11
    13c8:	af 90       	pop	r10
    13ca:	9f 90       	pop	r9
    13cc:	8f 90       	pop	r8
    13ce:	7f 90       	pop	r7
    13d0:	6f 90       	pop	r6
    13d2:	5f 90       	pop	r5
    13d4:	4f 90       	pop	r4
    13d6:	3f 90       	pop	r3
    13d8:	08 95       	ret

000013da <_ZN7MMA845113ActiveCommand11writePacketER6Packet>:
}

bool MMA8451::is_ready()
{
  return driver_->is_ready(slaveAddr_);
}
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	8c 01       	movw	r16, r24
    13e4:	eb 01       	movw	r28, r22
    13e6:	bc 01       	movw	r22, r24
    13e8:	6e 5f       	subi	r22, 0xFE	; 254
    13ea:	7f 4f       	sbci	r23, 0xFF	; 255
    13ec:	e8 81       	ld	r30, Y
    13ee:	f9 81       	ldd	r31, Y+1	; 0x01
    13f0:	01 90       	ld	r0, Z+
    13f2:	f0 81       	ld	r31, Z
    13f4:	e0 2d       	mov	r30, r0
    13f6:	ce 01       	movw	r24, r28
    13f8:	19 95       	eicall
    13fa:	b8 01       	movw	r22, r16
    13fc:	6d 5f       	subi	r22, 0xFD	; 253
    13fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1400:	e8 81       	ld	r30, Y
    1402:	f9 81       	ldd	r31, Y+1	; 0x01
    1404:	01 90       	ld	r0, Z+
    1406:	f0 81       	ld	r31, Z
    1408:	e0 2d       	mov	r30, r0
    140a:	ce 01       	movw	r24, r28
    140c:	19 95       	eicall
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	1f 91       	pop	r17
    1414:	0f 91       	pop	r16
    1416:	08 95       	ret

00001418 <_ZN7MMA845116QueryXRegCommand11writePacketER6Packet>:
    1418:	db 01       	movw	r26, r22
    141a:	bc 01       	movw	r22, r24
    141c:	6e 5f       	subi	r22, 0xFE	; 254
    141e:	7f 4f       	sbci	r23, 0xFF	; 255
    1420:	ed 91       	ld	r30, X+
    1422:	fc 91       	ld	r31, X
    1424:	11 97       	sbiw	r26, 0x01	; 1
    1426:	01 90       	ld	r0, Z+
    1428:	f0 81       	ld	r31, Z
    142a:	e0 2d       	mov	r30, r0
    142c:	cd 01       	movw	r24, r26
    142e:	19 95       	eicall
    1430:	08 95       	ret

00001432 <_ZN7MMA845116QueryYRegCommand11writePacketER6Packet>:
    1432:	db 01       	movw	r26, r22
    1434:	bc 01       	movw	r22, r24
    1436:	6e 5f       	subi	r22, 0xFE	; 254
    1438:	7f 4f       	sbci	r23, 0xFF	; 255
    143a:	ed 91       	ld	r30, X+
    143c:	fc 91       	ld	r31, X
    143e:	11 97       	sbiw	r26, 0x01	; 1
    1440:	01 90       	ld	r0, Z+
    1442:	f0 81       	ld	r31, Z
    1444:	e0 2d       	mov	r30, r0
    1446:	cd 01       	movw	r24, r26
    1448:	19 95       	eicall
    144a:	08 95       	ret

0000144c <_ZN7MMA845116QueryZRegCommand11writePacketER6Packet>:
    144c:	db 01       	movw	r26, r22
    144e:	bc 01       	movw	r22, r24
    1450:	6e 5f       	subi	r22, 0xFE	; 254
    1452:	7f 4f       	sbci	r23, 0xFF	; 255
    1454:	ed 91       	ld	r30, X+
    1456:	fc 91       	ld	r31, X
    1458:	11 97       	sbiw	r26, 0x01	; 1
    145a:	01 90       	ld	r0, Z+
    145c:	f0 81       	ld	r31, Z
    145e:	e0 2d       	mov	r30, r0
    1460:	cd 01       	movw	r24, r26
    1462:	19 95       	eicall
    1464:	08 95       	ret

00001466 <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    1466:	4f 92       	push	r4
    1468:	5f 92       	push	r5
    146a:	6f 92       	push	r6
    146c:	7f 92       	push	r7
    146e:	8f 92       	push	r8
    1470:	9f 92       	push	r9
    1472:	af 92       	push	r10
    1474:	bf 92       	push	r11
    1476:	cf 92       	push	r12
    1478:	df 92       	push	r13
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	8c 01       	movw	r16, r24
    1488:	7b 01       	movw	r14, r22
    148a:	6a 01       	movw	r12, r20
    148c:	dc 01       	movw	r26, r24
    148e:	6d 93       	st	X+, r22
    1490:	7c 93       	st	X, r23
    1492:	11 97       	sbiw	r26, 0x01	; 1
    1494:	12 96       	adiw	r26, 0x02	; 2
    1496:	4d 93       	st	X+, r20
    1498:	5c 93       	st	X, r21
    149a:	13 97       	sbiw	r26, 0x03	; 3
    149c:	81 e2       	ldi	r24, 0x21	; 33
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    14a4:	ec 01       	movw	r28, r24
    14a6:	8f e3       	ldi	r24, 0x3F	; 63
    14a8:	91 e2       	ldi	r25, 0x21	; 33
    14aa:	88 83       	st	Y, r24
    14ac:	99 83       	std	Y+1, r25	; 0x01
    14ae:	1c 82       	std	Y+4, r1	; 0x04
    14b0:	1d 82       	std	Y+5, r1	; 0x05
    14b2:	0f 2e       	mov	r0, r31
    14b4:	f7 ef       	ldi	r31, 0xF7	; 247
    14b6:	af 2e       	mov	r10, r31
    14b8:	f0 e2       	ldi	r31, 0x20	; 32
    14ba:	bf 2e       	mov	r11, r31
    14bc:	f0 2d       	mov	r31, r0
    14be:	aa 82       	std	Y+2, r10	; 0x02
    14c0:	bb 82       	std	Y+3, r11	; 0x03
    14c2:	40 e0       	ldi	r20, 0x00	; 0
    14c4:	61 e0       	ldi	r22, 0x01	; 1
    14c6:	82 e0       	ldi	r24, 0x02	; 2
    14c8:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    14cc:	8e 83       	std	Y+6, r24	; 0x06
    14ce:	9f 83       	std	Y+7, r25	; 0x07
    14d0:	0f 2e       	mov	r0, r31
    14d2:	fa e0       	ldi	r31, 0x0A	; 10
    14d4:	4f 2e       	mov	r4, r31
    14d6:	51 2c       	mov	r5, r1
    14d8:	61 2c       	mov	r6, r1
    14da:	71 2c       	mov	r7, r1
    14dc:	f0 2d       	mov	r31, r0
    14de:	48 86       	std	Y+8, r4	; 0x08
    14e0:	59 86       	std	Y+9, r5	; 0x09
    14e2:	6a 86       	std	Y+10, r6	; 0x0a
    14e4:	7b 86       	std	Y+11, r7	; 0x0b
    14e6:	0f 2e       	mov	r0, r31
    14e8:	fb e1       	ldi	r31, 0x1B	; 27
    14ea:	8f 2e       	mov	r8, r31
    14ec:	f1 e2       	ldi	r31, 0x21	; 33
    14ee:	9f 2e       	mov	r9, r31
    14f0:	f0 2d       	mov	r31, r0
    14f2:	8a 82       	std	Y+2, r8	; 0x02
    14f4:	9b 82       	std	Y+3, r9	; 0x03
    14f6:	82 e0       	ldi	r24, 0x02	; 2
    14f8:	8c 87       	std	Y+12, r24	; 0x0c
    14fa:	18 8a       	std	Y+16, r1	; 0x10
    14fc:	19 8a       	std	Y+17, r1	; 0x11
    14fe:	ae 86       	std	Y+14, r10	; 0x0e
    1500:	bf 86       	std	Y+15, r11	; 0x0f
    1502:	40 e0       	ldi	r20, 0x00	; 0
    1504:	61 e0       	ldi	r22, 0x01	; 1
    1506:	83 e0       	ldi	r24, 0x03	; 3
    1508:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    150c:	8a 8b       	std	Y+18, r24	; 0x12
    150e:	9b 8b       	std	Y+19, r25	; 0x13
    1510:	4c 8a       	std	Y+20, r4	; 0x14
    1512:	5d 8a       	std	Y+21, r5	; 0x15
    1514:	6e 8a       	std	Y+22, r6	; 0x16
    1516:	7f 8a       	std	Y+23, r7	; 0x17
    1518:	8e 86       	std	Y+14, r8	; 0x0e
    151a:	9f 86       	std	Y+15, r9	; 0x0f
    151c:	0f 2e       	mov	r0, r31
    151e:	f3 e0       	ldi	r31, 0x03	; 3
    1520:	bf 2e       	mov	r11, r31
    1522:	f0 2d       	mov	r31, r0
    1524:	b8 8e       	std	Y+24, r11	; 0x18
    1526:	8a e0       	ldi	r24, 0x0A	; 10
    1528:	90 e2       	ldi	r25, 0x20	; 32
    152a:	88 83       	st	Y, r24
    152c:	99 83       	std	Y+1, r25	; 0x01
    152e:	ca 8e       	std	Y+26, r12	; 0x1a
    1530:	db 8e       	std	Y+27, r13	; 0x1b
    1532:	f8 01       	movw	r30, r16
    1534:	c4 83       	std	Z+4, r28	; 0x04
    1536:	d5 83       	std	Z+5, r29	; 0x05
    1538:	8d e1       	ldi	r24, 0x1D	; 29
    153a:	86 83       	std	Z+6, r24	; 0x06
    153c:	84 e0       	ldi	r24, 0x04	; 4
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    1544:	fc 01       	movw	r30, r24
    1546:	83 e5       	ldi	r24, 0x53	; 83
    1548:	91 e2       	ldi	r25, 0x21	; 33
    154a:	80 83       	st	Z, r24
    154c:	91 83       	std	Z+1, r25	; 0x01
    154e:	8a e2       	ldi	r24, 0x2A	; 42
    1550:	82 83       	std	Z+2, r24	; 0x02
    1552:	c1 e0       	ldi	r28, 0x01	; 1
    1554:	c3 83       	std	Z+3, r28	; 0x03
    1556:	d8 01       	movw	r26, r16
    1558:	19 96       	adiw	r26, 0x09	; 9
    155a:	ed 93       	st	X+, r30
    155c:	fc 93       	st	X, r31
    155e:	1a 97       	sbiw	r26, 0x0a	; 10
    1560:	83 e0       	ldi	r24, 0x03	; 3
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    1568:	29 e5       	ldi	r18, 0x59	; 89
    156a:	31 e2       	ldi	r19, 0x21	; 33
    156c:	fc 01       	movw	r30, r24
    156e:	20 83       	st	Z, r18
    1570:	31 83       	std	Z+1, r19	; 0x01
    1572:	c2 83       	std	Z+2, r28	; 0x02
    1574:	d8 01       	movw	r26, r16
    1576:	1b 96       	adiw	r26, 0x0b	; 11
    1578:	8d 93       	st	X+, r24
    157a:	9c 93       	st	X, r25
    157c:	1c 97       	sbiw	r26, 0x0c	; 12
    157e:	83 e0       	ldi	r24, 0x03	; 3
    1580:	90 e0       	ldi	r25, 0x00	; 0
    1582:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    1586:	2f e5       	ldi	r18, 0x5F	; 95
    1588:	31 e2       	ldi	r19, 0x21	; 33
    158a:	fc 01       	movw	r30, r24
    158c:	20 83       	st	Z, r18
    158e:	31 83       	std	Z+1, r19	; 0x01
    1590:	b2 82       	std	Z+2, r11	; 0x02
    1592:	d8 01       	movw	r26, r16
    1594:	1d 96       	adiw	r26, 0x0d	; 13
    1596:	8d 93       	st	X+, r24
    1598:	9c 93       	st	X, r25
    159a:	1e 97       	sbiw	r26, 0x0e	; 14
    159c:	83 e0       	ldi	r24, 0x03	; 3
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    15a4:	25 e6       	ldi	r18, 0x65	; 101
    15a6:	31 e2       	ldi	r19, 0x21	; 33
    15a8:	fc 01       	movw	r30, r24
    15aa:	20 83       	st	Z, r18
    15ac:	31 83       	std	Z+1, r19	; 0x01
    15ae:	25 e0       	ldi	r18, 0x05	; 5
    15b0:	22 83       	std	Z+2, r18	; 0x02
    15b2:	d8 01       	movw	r26, r16
    15b4:	1f 96       	adiw	r26, 0x0f	; 15
    15b6:	8d 93       	st	X+, r24
    15b8:	9c 93       	st	X, r25
    15ba:	50 97       	sbiw	r26, 0x10	; 16
    15bc:	14 96       	adiw	r26, 0x04	; 4
    15be:	ed 91       	ld	r30, X+
    15c0:	fc 91       	ld	r31, X
    15c2:	15 97       	sbiw	r26, 0x05	; 5
    15c4:	e4 8e       	std	Z+28, r14	; 0x1c
    15c6:	f5 8e       	std	Z+29, r15	; 0x1d
    15c8:	16 96       	adiw	r26, 0x06	; 6
    15ca:	6c 91       	ld	r22, X
    15cc:	16 97       	sbiw	r26, 0x06	; 6
    15ce:	14 96       	adiw	r26, 0x04	; 4
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	15 97       	sbiw	r26, 0x05	; 5
    15d6:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	ff 90       	pop	r15
    15e4:	ef 90       	pop	r14
    15e6:	df 90       	pop	r13
    15e8:	cf 90       	pop	r12
    15ea:	bf 90       	pop	r11
    15ec:	af 90       	pop	r10
    15ee:	9f 90       	pop	r9
    15f0:	8f 90       	pop	r8
    15f2:	7f 90       	pop	r7
    15f4:	6f 90       	pop	r6
    15f6:	5f 90       	pop	r5
    15f8:	4f 90       	pop	r4
    15fa:	08 95       	ret

000015fc <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1604:	8c 81       	ldd	r24, Y+4	; 0x04
    1606:	9d 81       	ldd	r25, Y+5	; 0x05
    1608:	69 85       	ldd	r22, Y+9	; 0x09
    160a:	7a 85       	ldd	r23, Y+10	; 0x0a
    160c:	dc 01       	movw	r26, r24
    160e:	ed 91       	ld	r30, X+
    1610:	fc 91       	ld	r31, X
    1612:	01 90       	ld	r0, Z+
    1614:	f0 81       	ld	r31, Z
    1616:	e0 2d       	mov	r30, r0
    1618:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    161a:	8c 81       	ldd	r24, Y+4	; 0x04
    161c:	9d 81       	ldd	r25, Y+5	; 0x05
    161e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1620:	7c 85       	ldd	r23, Y+12	; 0x0c
    1622:	dc 01       	movw	r26, r24
    1624:	ed 91       	ld	r30, X+
    1626:	fc 91       	ld	r31, X
    1628:	01 90       	ld	r0, Z+
    162a:	f0 81       	ld	r31, Z
    162c:	e0 2d       	mov	r30, r0
    162e:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    1630:	8c 81       	ldd	r24, Y+4	; 0x04
    1632:	9d 81       	ldd	r25, Y+5	; 0x05
    1634:	dc 01       	movw	r26, r24
    1636:	ed 91       	ld	r30, X+
    1638:	fc 91       	ld	r31, X
    163a:	02 80       	ldd	r0, Z+2	; 0x02
    163c:	f3 81       	ldd	r31, Z+3	; 0x03
    163e:	e0 2d       	mov	r30, r0
    1640:	19 95       	eicall
    1642:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    1644:	8b 85       	ldd	r24, Y+11	; 0x0b
    1646:	88 23       	and	r24, r24
    1648:	b9 f0       	breq	.+46     	; 0x1678 <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    164a:	e8 81       	ld	r30, Y
    164c:	f9 81       	ldd	r31, Y+1	; 0x01
    164e:	00 84       	ldd	r0, Z+8	; 0x08
    1650:	f1 85       	ldd	r31, Z+9	; 0x09
    1652:	e0 2d       	mov	r30, r0
    1654:	ce 01       	movw	r24, r28
    1656:	19 95       	eicall
    1658:	18 2f       	mov	r17, r24
    165a:	e8 81       	ld	r30, Y
    165c:	f9 81       	ldd	r31, Y+1	; 0x01
    165e:	00 84       	ldd	r0, Z+8	; 0x08
    1660:	f1 85       	ldd	r31, Z+9	; 0x09
    1662:	e0 2d       	mov	r30, r0
    1664:	ce 01       	movw	r24, r28
    1666:	19 95       	eicall
    1668:	21 2f       	mov	r18, r17
    166a:	30 e0       	ldi	r19, 0x00	; 0
    166c:	32 2f       	mov	r19, r18
    166e:	22 27       	eor	r18, r18
    1670:	a9 01       	movw	r20, r18
    1672:	48 2b       	or	r20, r24
    1674:	ca 01       	movw	r24, r20
    1676:	02 c0       	rjmp	.+4      	; 0x167c <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    1678:	80 e0       	ldi	r24, 0x00	; 0
    167a:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    167c:	df 91       	pop	r29
    167e:	cf 91       	pop	r28
    1680:	1f 91       	pop	r17
    1682:	08 95       	ret

00001684 <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    1684:	1f 93       	push	r17
    1686:	cf 93       	push	r28
    1688:	df 93       	push	r29
    168a:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    168c:	8c 81       	ldd	r24, Y+4	; 0x04
    168e:	9d 81       	ldd	r25, Y+5	; 0x05
    1690:	69 85       	ldd	r22, Y+9	; 0x09
    1692:	7a 85       	ldd	r23, Y+10	; 0x0a
    1694:	dc 01       	movw	r26, r24
    1696:	ed 91       	ld	r30, X+
    1698:	fc 91       	ld	r31, X
    169a:	01 90       	ld	r0, Z+
    169c:	f0 81       	ld	r31, Z
    169e:	e0 2d       	mov	r30, r0
    16a0:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    16a2:	8c 81       	ldd	r24, Y+4	; 0x04
    16a4:	9d 81       	ldd	r25, Y+5	; 0x05
    16a6:	6d 85       	ldd	r22, Y+13	; 0x0d
    16a8:	7e 85       	ldd	r23, Y+14	; 0x0e
    16aa:	dc 01       	movw	r26, r24
    16ac:	ed 91       	ld	r30, X+
    16ae:	fc 91       	ld	r31, X
    16b0:	01 90       	ld	r0, Z+
    16b2:	f0 81       	ld	r31, Z
    16b4:	e0 2d       	mov	r30, r0
    16b6:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    16b8:	8c 81       	ldd	r24, Y+4	; 0x04
    16ba:	9d 81       	ldd	r25, Y+5	; 0x05
    16bc:	dc 01       	movw	r26, r24
    16be:	ed 91       	ld	r30, X+
    16c0:	fc 91       	ld	r31, X
    16c2:	02 80       	ldd	r0, Z+2	; 0x02
    16c4:	f3 81       	ldd	r31, Z+3	; 0x03
    16c6:	e0 2d       	mov	r30, r0
    16c8:	19 95       	eicall
    16ca:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    16cc:	8b 85       	ldd	r24, Y+11	; 0x0b
    16ce:	88 23       	and	r24, r24
    16d0:	b9 f0       	breq	.+46     	; 0x1700 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    16d2:	e8 81       	ld	r30, Y
    16d4:	f9 81       	ldd	r31, Y+1	; 0x01
    16d6:	00 84       	ldd	r0, Z+8	; 0x08
    16d8:	f1 85       	ldd	r31, Z+9	; 0x09
    16da:	e0 2d       	mov	r30, r0
    16dc:	ce 01       	movw	r24, r28
    16de:	19 95       	eicall
    16e0:	18 2f       	mov	r17, r24
    16e2:	e8 81       	ld	r30, Y
    16e4:	f9 81       	ldd	r31, Y+1	; 0x01
    16e6:	00 84       	ldd	r0, Z+8	; 0x08
    16e8:	f1 85       	ldd	r31, Z+9	; 0x09
    16ea:	e0 2d       	mov	r30, r0
    16ec:	ce 01       	movw	r24, r28
    16ee:	19 95       	eicall
    16f0:	21 2f       	mov	r18, r17
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	32 2f       	mov	r19, r18
    16f6:	22 27       	eor	r18, r18
    16f8:	a9 01       	movw	r20, r18
    16fa:	48 2b       	or	r20, r24
    16fc:	ca 01       	movw	r24, r20
    16fe:	02 c0       	rjmp	.+4      	; 0x1704 <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    1700:	80 e0       	ldi	r24, 0x00	; 0
    1702:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    1704:	df 91       	pop	r29
    1706:	cf 91       	pop	r28
    1708:	1f 91       	pop	r17
    170a:	08 95       	ret

0000170c <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    170c:	1f 93       	push	r17
    170e:	cf 93       	push	r28
    1710:	df 93       	push	r29
    1712:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1714:	8c 81       	ldd	r24, Y+4	; 0x04
    1716:	9d 81       	ldd	r25, Y+5	; 0x05
    1718:	69 85       	ldd	r22, Y+9	; 0x09
    171a:	7a 85       	ldd	r23, Y+10	; 0x0a
    171c:	dc 01       	movw	r26, r24
    171e:	ed 91       	ld	r30, X+
    1720:	fc 91       	ld	r31, X
    1722:	01 90       	ld	r0, Z+
    1724:	f0 81       	ld	r31, Z
    1726:	e0 2d       	mov	r30, r0
    1728:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    172a:	8c 81       	ldd	r24, Y+4	; 0x04
    172c:	9d 81       	ldd	r25, Y+5	; 0x05
    172e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1730:	78 89       	ldd	r23, Y+16	; 0x10
    1732:	dc 01       	movw	r26, r24
    1734:	ed 91       	ld	r30, X+
    1736:	fc 91       	ld	r31, X
    1738:	01 90       	ld	r0, Z+
    173a:	f0 81       	ld	r31, Z
    173c:	e0 2d       	mov	r30, r0
    173e:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    1740:	8c 81       	ldd	r24, Y+4	; 0x04
    1742:	9d 81       	ldd	r25, Y+5	; 0x05
    1744:	dc 01       	movw	r26, r24
    1746:	ed 91       	ld	r30, X+
    1748:	fc 91       	ld	r31, X
    174a:	02 80       	ldd	r0, Z+2	; 0x02
    174c:	f3 81       	ldd	r31, Z+3	; 0x03
    174e:	e0 2d       	mov	r30, r0
    1750:	19 95       	eicall
    1752:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    1754:	8b 85       	ldd	r24, Y+11	; 0x0b
    1756:	88 23       	and	r24, r24
    1758:	b9 f0       	breq	.+46     	; 0x1788 <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    175a:	e8 81       	ld	r30, Y
    175c:	f9 81       	ldd	r31, Y+1	; 0x01
    175e:	00 84       	ldd	r0, Z+8	; 0x08
    1760:	f1 85       	ldd	r31, Z+9	; 0x09
    1762:	e0 2d       	mov	r30, r0
    1764:	ce 01       	movw	r24, r28
    1766:	19 95       	eicall
    1768:	18 2f       	mov	r17, r24
    176a:	e8 81       	ld	r30, Y
    176c:	f9 81       	ldd	r31, Y+1	; 0x01
    176e:	00 84       	ldd	r0, Z+8	; 0x08
    1770:	f1 85       	ldd	r31, Z+9	; 0x09
    1772:	e0 2d       	mov	r30, r0
    1774:	ce 01       	movw	r24, r28
    1776:	19 95       	eicall
    1778:	21 2f       	mov	r18, r17
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	32 2f       	mov	r19, r18
    177e:	22 27       	eor	r18, r18
    1780:	a9 01       	movw	r20, r18
    1782:	48 2b       	or	r20, r24
    1784:	ca 01       	movw	r24, r20
    1786:	02 c0       	rjmp	.+4      	; 0x178c <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    1788:	80 e0       	ldi	r24, 0x00	; 0
    178a:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	08 95       	ret

00001794 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	ec 01       	movw	r28, r24
  success_ = false;
    179a:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    179c:	e8 81       	ld	r30, Y
    179e:	f9 81       	ldd	r31, Y+1	; 0x01
    17a0:	00 8c       	ldd	r0, Z+24	; 0x18
    17a2:	f1 8d       	ldd	r31, Z+25	; 0x19
    17a4:	e0 2d       	mov	r30, r0
    17a6:	ce 01       	movw	r24, r28
    17a8:	19 95       	eicall
    17aa:	88 23       	and	r24, r24
    17ac:	41 f0       	breq	.+16     	; 0x17be <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    17ae:	e8 81       	ld	r30, Y
    17b0:	f9 81       	ldd	r31, Y+1	; 0x01
    17b2:	00 84       	ldd	r0, Z+8	; 0x08
    17b4:	f1 85       	ldd	r31, Z+9	; 0x09
    17b6:	e0 2d       	mov	r30, r0
    17b8:	ce 01       	movw	r24, r28
    17ba:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    17bc:	ef cf       	rjmp	.-34     	; 0x179c <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    17be:	df 91       	pop	r29
    17c0:	cf 91       	pop	r28
    17c2:	08 95       	ret

000017c4 <_ZN11task_sensor3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sensor::run (void)
{
    17c4:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    17c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    17c8:	81 11       	cpse	r24, r1
    17ca:	39 c0       	rjmp	.+114    	; 0x183e <_ZN11task_sensor3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    17cc:	8c 89       	ldd	r24, Y+20	; 0x14
    17ce:	9d 89       	ldd	r25, Y+21	; 0x15
    17d0:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <_ZN7MMA845111getXReadingEv>
    17d4:	7c 01       	movw	r14, r24
    17d6:	0e 81       	ldd	r16, Y+6	; 0x06
    17d8:	1f 81       	ldd	r17, Y+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    17da:	67 e6       	ldi	r22, 0x67	; 103
    17dc:	71 e2       	ldi	r23, 0x21	; 33
    17de:	c8 01       	movw	r24, r16
    17e0:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    17e4:	b7 01       	movw	r22, r14
    17e6:	c8 01       	movw	r24, r16
    17e8:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    17ec:	66 e0       	ldi	r22, 0x06	; 6
    17ee:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    17f2:	8c 89       	ldd	r24, Y+20	; 0x14
    17f4:	9d 89       	ldd	r25, Y+21	; 0x15
    17f6:	0e 94 42 0b 	call	0x1684	; 0x1684 <_ZN7MMA845111getYReadingEv>
    17fa:	7c 01       	movw	r14, r24
    17fc:	0e 81       	ldd	r16, Y+6	; 0x06
    17fe:	1f 81       	ldd	r17, Y+7	; 0x07
    1800:	6b e6       	ldi	r22, 0x6B	; 107
    1802:	71 e2       	ldi	r23, 0x21	; 33
    1804:	c8 01       	movw	r24, r16
    1806:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    180a:	b7 01       	movw	r22, r14
    180c:	c8 01       	movw	r24, r16
    180e:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    1812:	66 e0       	ldi	r22, 0x06	; 6
    1814:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    1818:	8c 89       	ldd	r24, Y+20	; 0x14
    181a:	9d 89       	ldd	r25, Y+21	; 0x15
    181c:	0e 94 86 0b 	call	0x170c	; 0x170c <_ZN7MMA845111getZReadingEv>
    1820:	7c 01       	movw	r14, r24
    1822:	0e 81       	ldd	r16, Y+6	; 0x06
    1824:	1f 81       	ldd	r17, Y+7	; 0x07
    1826:	6f e6       	ldi	r22, 0x6F	; 111
    1828:	71 e2       	ldi	r23, 0x21	; 33
    182a:	c8 01       	movw	r24, r16
    182c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1830:	b7 01       	movw	r22, r14
    1832:	c8 01       	movw	r24, r16
    1834:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    1838:	66 e0       	ldi	r22, 0x06	; 6
    183a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    183e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1840:	9f 85       	ldd	r25, Y+15	; 0x0f
    1842:	a8 89       	ldd	r26, Y+16	; 0x10
    1844:	b9 89       	ldd	r27, Y+17	; 0x11
    1846:	01 96       	adiw	r24, 0x01	; 1
    1848:	a1 1d       	adc	r26, r1
    184a:	b1 1d       	adc	r27, r1
    184c:	8e 87       	std	Y+14, r24	; 0x0e
    184e:	9f 87       	std	Y+15, r25	; 0x0f
    1850:	a8 8b       	std	Y+16, r26	; 0x10
    1852:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1854:	68 ee       	ldi	r22, 0xE8	; 232
    1856:	73 e0       	ldi	r23, 0x03	; 3
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	90 e0       	ldi	r25, 0x00	; 0
    185c:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1860:	b2 cf       	rjmp	.-156    	; 0x17c6 <_ZN11task_sensor3runEv+0x2>

00001862 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sensor::task_sensor (const char* a_name, 
    1862:	cf 92       	push	r12
    1864:	df 92       	push	r13
    1866:	ef 92       	push	r14
    1868:	ff 92       	push	r15
    186a:	0f 93       	push	r16
    186c:	1f 93       	push	r17
    186e:	cf 93       	push	r28
    1870:	df 93       	push	r29
    1872:	ec 01       	movw	r28, r24
    1874:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    1876:	0e 94 02 1a 	call	0x3404	; 0x3404 <_ZN8frt_taskC1EPKchjP8emstream>
    187a:	87 e7       	ldi	r24, 0x77	; 119
    187c:	91 e2       	ldi	r25, 0x21	; 33
    187e:	88 83       	st	Y, r24
    1880:	99 83       	std	Y+1, r25	; 0x01
    1882:	ec 8a       	std	Y+20, r14	; 0x14
    1884:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    1886:	ce 8a       	std	Y+22, r12	; 0x16
    1888:	df 8a       	std	Y+23, r13	; 0x17
}
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	1f 91       	pop	r17
    1890:	0f 91       	pop	r16
    1892:	ff 90       	pop	r15
    1894:	ef 90       	pop	r14
    1896:	df 90       	pop	r13
    1898:	cf 90       	pop	r12
    189a:	08 95       	ret

0000189c <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    189c:	0f 93       	push	r16
    189e:	1f 93       	push	r17
    18a0:	cf 93       	push	r28
    18a2:	df 93       	push	r29
    18a4:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    18a6:	0e 94 02 1a 	call	0x3404	; 0x3404 <_ZN8frt_taskC1EPKchjP8emstream>
    18aa:	8f e7       	ldi	r24, 0x7F	; 127
    18ac:	91 e2       	ldi	r25, 0x21	; 33
    18ae:	88 83       	st	Y, r24
    18b0:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    18b2:	df 91       	pop	r29
    18b4:	cf 91       	pop	r28
    18b6:	1f 91       	pop	r17
    18b8:	0f 91       	pop	r16
    18ba:	08 95       	ret

000018bc <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    18bc:	0f 93       	push	r16
    18be:	1f 93       	push	r17
    18c0:	cf 93       	push	r28
    18c2:	df 93       	push	r29
    18c4:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    18c6:	6a e0       	ldi	r22, 0x0A	; 10
    18c8:	8e 81       	ldd	r24, Y+6	; 0x06
    18ca:	9f 81       	ldd	r25, Y+7	; 0x07
    18cc:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    18d0:	8c 01       	movw	r16, r24
    18d2:	6d e0       	ldi	r22, 0x0D	; 13
    18d4:	75 e0       	ldi	r23, 0x05	; 5
    18d6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    18da:	6a e0       	ldi	r22, 0x0A	; 10
    18dc:	c8 01       	movw	r24, r16
    18de:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    18e2:	8c 01       	movw	r16, r24
    18e4:	67 e0       	ldi	r22, 0x07	; 7
    18e6:	75 e0       	ldi	r23, 0x05	; 5
    18e8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    18ec:	67 e0       	ldi	r22, 0x07	; 7
    18ee:	c8 01       	movw	r24, r16
    18f0:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    18f4:	6a e0       	ldi	r22, 0x0A	; 10
    18f6:	8e 81       	ldd	r24, Y+6	; 0x06
    18f8:	9f 81       	ldd	r25, Y+7	; 0x07
    18fa:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    18fe:	8c 01       	movw	r16, r24
    1900:	68 ee       	ldi	r22, 0xE8	; 232
    1902:	74 e0       	ldi	r23, 0x04	; 4
    1904:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1908:	6a e0       	ldi	r22, 0x0A	; 10
    190a:	c8 01       	movw	r24, r16
    190c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1910:	8c 01       	movw	r16, r24
    1912:	62 ee       	ldi	r22, 0xE2	; 226
    1914:	74 e0       	ldi	r23, 0x04	; 4
    1916:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    191a:	66 e0       	ldi	r22, 0x06	; 6
    191c:	c8 01       	movw	r24, r16
    191e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1922:	6a e0       	ldi	r22, 0x0A	; 10
    1924:	8e 81       	ldd	r24, Y+6	; 0x06
    1926:	9f 81       	ldd	r25, Y+7	; 0x07
    1928:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    192c:	8c 01       	movw	r16, r24
    192e:	6b ec       	ldi	r22, 0xCB	; 203
    1930:	74 e0       	ldi	r23, 0x04	; 4
    1932:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1936:	66 e0       	ldi	r22, 0x06	; 6
    1938:	c8 01       	movw	r24, r16
    193a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    193e:	6a e0       	ldi	r22, 0x0A	; 10
    1940:	8e 81       	ldd	r24, Y+6	; 0x06
    1942:	9f 81       	ldd	r25, Y+7	; 0x07
    1944:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1948:	8c 01       	movw	r16, r24
    194a:	6f ea       	ldi	r22, 0xAF	; 175
    194c:	74 e0       	ldi	r23, 0x04	; 4
    194e:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1952:	66 e0       	ldi	r22, 0x06	; 6
    1954:	c8 01       	movw	r24, r16
    1956:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    195a:	6a e0       	ldi	r22, 0x0A	; 10
    195c:	8e 81       	ldd	r24, Y+6	; 0x06
    195e:	9f 81       	ldd	r25, Y+7	; 0x07
    1960:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1964:	8c 01       	movw	r16, r24
    1966:	67 e9       	ldi	r22, 0x97	; 151
    1968:	74 e0       	ldi	r23, 0x04	; 4
    196a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    196e:	66 e0       	ldi	r22, 0x06	; 6
    1970:	c8 01       	movw	r24, r16
    1972:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1976:	6a e0       	ldi	r22, 0x0A	; 10
    1978:	8e 81       	ldd	r24, Y+6	; 0x06
    197a:	9f 81       	ldd	r25, Y+7	; 0x07
    197c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1980:	8c 01       	movw	r16, r24
    1982:	66 e7       	ldi	r22, 0x76	; 118
    1984:	74 e0       	ldi	r23, 0x04	; 4
    1986:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    198a:	66 e0       	ldi	r22, 0x06	; 6
    198c:	c8 01       	movw	r24, r16
    198e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1992:	6a e0       	ldi	r22, 0x0A	; 10
    1994:	8e 81       	ldd	r24, Y+6	; 0x06
    1996:	9f 81       	ldd	r25, Y+7	; 0x07
    1998:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    199c:	8c 01       	movw	r16, r24
    199e:	6f e4       	ldi	r22, 0x4F	; 79
    19a0:	74 e0       	ldi	r23, 0x04	; 4
    19a2:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    19a6:	66 e0       	ldi	r22, 0x06	; 6
    19a8:	c8 01       	movw	r24, r16
    19aa:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    19ae:	6a e0       	ldi	r22, 0x0A	; 10
    19b0:	8e 81       	ldd	r24, Y+6	; 0x06
    19b2:	9f 81       	ldd	r25, Y+7	; 0x07
    19b4:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    19b8:	8c 01       	movw	r16, r24
    19ba:	61 e3       	ldi	r22, 0x31	; 49
    19bc:	74 e0       	ldi	r23, 0x04	; 4
    19be:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    19c2:	66 e0       	ldi	r22, 0x06	; 6
    19c4:	c8 01       	movw	r24, r16
    19c6:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    19ca:	6a e0       	ldi	r22, 0x0A	; 10
    19cc:	8e 81       	ldd	r24, Y+6	; 0x06
    19ce:	9f 81       	ldd	r25, Y+7	; 0x07
    19d0:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    19d4:	8c 01       	movw	r16, r24
    19d6:	66 e1       	ldi	r22, 0x16	; 22
    19d8:	74 e0       	ldi	r23, 0x04	; 4
    19da:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    19de:	66 e0       	ldi	r22, 0x06	; 6
    19e0:	c8 01       	movw	r24, r16
    19e2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    19e6:	6a e0       	ldi	r22, 0x0A	; 10
    19e8:	8e 81       	ldd	r24, Y+6	; 0x06
    19ea:	9f 81       	ldd	r25, Y+7	; 0x07
    19ec:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    19f0:	ec 01       	movw	r28, r24
    19f2:	67 e0       	ldi	r22, 0x07	; 7
    19f4:	74 e0       	ldi	r23, 0x04	; 4
    19f6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    19fa:	66 e0       	ldi	r22, 0x06	; 6
    19fc:	ce 01       	movw	r24, r28
    19fe:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
}
    1a02:	df 91       	pop	r29
    1a04:	cf 91       	pop	r28
    1a06:	1f 91       	pop	r17
    1a08:	0f 91       	pop	r16
    1a0a:	08 95       	ret

00001a0c <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1a0c:	af 92       	push	r10
    1a0e:	bf 92       	push	r11
    1a10:	cf 92       	push	r12
    1a12:	df 92       	push	r13
    1a14:	ef 92       	push	r14
    1a16:	ff 92       	push	r15
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <_ZN9task_user11show_statusEv+0x16>
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <_ZN9task_user11show_statusEv+0x18>
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1a2a:	19 82       	std	Y+1, r1	; 0x01
    1a2c:	1a 82       	std	Y+2, r1	; 0x02
    1a2e:	1b 82       	std	Y+3, r1	; 0x03
    1a30:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1a32:	1d 82       	std	Y+5, r1	; 0x05
    1a34:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1a36:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <xPortGetFreeHeapSize>
    1a3a:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a3c:	ce 01       	movw	r24, r28
    1a3e:	01 96       	adiw	r24, 0x01	; 1
    1a40:	0e 94 b3 1d 	call	0x3b66	; 0x3b66 <_ZN10time_stamp10set_to_nowEv>
    1a44:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1a46:	66 e0       	ldi	r22, 0x06	; 6
    1a48:	f8 01       	movw	r30, r16
    1a4a:	86 81       	ldd	r24, Z+6	; 0x06
    1a4c:	97 81       	ldd	r25, Z+7	; 0x07
    1a4e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1a52:	6a e0       	ldi	r22, 0x0A	; 10
    1a54:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1a58:	7c 01       	movw	r14, r24
    1a5a:	68 ee       	ldi	r22, 0xE8	; 232
    1a5c:	73 e0       	ldi	r23, 0x03	; 3
    1a5e:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1a62:	6a e0       	ldi	r22, 0x0A	; 10
    1a64:	c7 01       	movw	r24, r14
    1a66:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1a6a:	7c 01       	movw	r14, r24
    1a6c:	6c ed       	ldi	r22, 0xDC	; 220
    1a6e:	73 e0       	ldi	r23, 0x03	; 3
    1a70:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1a74:	66 e0       	ldi	r22, 0x06	; 6
    1a76:	c7 01       	movw	r24, r14
    1a78:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a7c:	6a e0       	ldi	r22, 0x0A	; 10
    1a7e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1a82:	7c 01       	movw	r14, r24
    1a84:	65 ed       	ldi	r22, 0xD5	; 213
    1a86:	73 e0       	ldi	r23, 0x03	; 3
    1a88:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1a8c:	b5 01       	movw	r22, r10
    1a8e:	c7 01       	movw	r24, r14
    1a90:	0e 94 57 1d 	call	0x3aae	; 0x3aae <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1a94:	6a e0       	ldi	r22, 0x0A	; 10
    1a96:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1a9a:	7c 01       	movw	r14, r24
    1a9c:	67 ec       	ldi	r22, 0xC7	; 199
    1a9e:	73 e0       	ldi	r23, 0x03	; 3
    1aa0:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1aa4:	b6 01       	movw	r22, r12
    1aa6:	c7 01       	movw	r24, r14
    1aa8:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    1aac:	6a e0       	ldi	r22, 0x0A	; 10
    1aae:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1ab2:	7c 01       	movw	r14, r24
    1ab4:	65 ec       	ldi	r22, 0xC5	; 197
    1ab6:	73 e0       	ldi	r23, 0x03	; 3
    1ab8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1abc:	4f ef       	ldi	r20, 0xFF	; 255
    1abe:	5f e0       	ldi	r21, 0x0F	; 15
    1ac0:	60 e0       	ldi	r22, 0x00	; 0
    1ac2:	70 e0       	ldi	r23, 0x00	; 0
    1ac4:	c7 01       	movw	r24, r14
    1ac6:	0e 94 e2 1f 	call	0x3fc4	; 0x3fc4 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1aca:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1ace:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1ad2:	6a e0       	ldi	r22, 0x0A	; 10
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	86 81       	ldd	r24, Z+6	; 0x06
    1ad8:	97 81       	ldd	r25, Z+7	; 0x07
    1ada:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1ade:	7c 01       	movw	r14, r24
    1ae0:	6a eb       	ldi	r22, 0xBA	; 186
    1ae2:	73 e0       	ldi	r23, 0x03	; 3
    1ae4:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1ae8:	b6 01       	movw	r22, r12
    1aea:	c7 01       	movw	r24, r14
    1aec:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    1af0:	66 e0       	ldi	r22, 0x06	; 6
    1af2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1af6:	66 e0       	ldi	r22, 0x06	; 6
    1af8:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1afc:	f8 01       	movw	r30, r16
    1afe:	86 81       	ldd	r24, Z+6	; 0x06
    1b00:	97 81       	ldd	r25, Z+7	; 0x07
    1b02:	0e 94 10 1c 	call	0x3820	; 0x3820 <_Z15print_task_listP8emstream>
}
    1b06:	26 96       	adiw	r28, 0x06	; 6
    1b08:	cd bf       	out	0x3d, r28	; 61
    1b0a:	de bf       	out	0x3e, r29	; 62
    1b0c:	df 91       	pop	r29
    1b0e:	cf 91       	pop	r28
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	ff 90       	pop	r15
    1b16:	ef 90       	pop	r14
    1b18:	df 90       	pop	r13
    1b1a:	cf 90       	pop	r12
    1b1c:	bf 90       	pop	r11
    1b1e:	af 90       	pop	r10
    1b20:	08 95       	ret

00001b22 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1b22:	cf 93       	push	r28
    1b24:	df 93       	push	r29
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <_ZN9task_user3runEv+0x6>
    1b28:	00 d0       	rcall	.+0      	; 0x1b2a <_ZN9task_user3runEv+0x8>
    1b2a:	cd b7       	in	r28, 0x3d	; 61
    1b2c:	de b7       	in	r29, 0x3e	; 62
    1b2e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1b30:	19 82       	std	Y+1, r1	; 0x01
    1b32:	1a 82       	std	Y+2, r1	; 0x02
    1b34:	1b 82       	std	Y+3, r1	; 0x03
    1b36:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1b38:	1d 82       	std	Y+5, r1	; 0x05
    1b3a:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1b3c:	6a e0       	ldi	r22, 0x0A	; 10
    1b3e:	dc 01       	movw	r26, r24
    1b40:	16 96       	adiw	r26, 0x06	; 6
    1b42:	8d 91       	ld	r24, X+
    1b44:	9c 91       	ld	r25, X
    1b46:	17 97       	sbiw	r26, 0x07	; 7
    1b48:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1b4c:	7c 01       	movw	r14, r24
    1b4e:	66 e5       	ldi	r22, 0x56	; 86
    1b50:	75 e0       	ldi	r23, 0x05	; 5
    1b52:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1b56:	66 e0       	ldi	r22, 0x06	; 6
    1b58:	c7 01       	movw	r24, r14
    1b5a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1b5e:	f8 01       	movw	r30, r16
    1b60:	84 85       	ldd	r24, Z+12	; 0x0c
    1b62:	88 23       	and	r24, r24
    1b64:	21 f0       	breq	.+8      	; 0x1b6e <_ZN9task_user3runEv+0x4c>
    1b66:	81 30       	cpi	r24, 0x01	; 1
    1b68:	09 f4       	brne	.+2      	; 0x1b6c <_ZN9task_user3runEv+0x4a>
    1b6a:	5d c0       	rjmp	.+186    	; 0x1c26 <_ZN9task_user3runEv+0x104>
    1b6c:	d8 c0       	rjmp	.+432    	; 0x1d1e <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1b6e:	86 81       	ldd	r24, Z+6	; 0x06
    1b70:	97 81       	ldd	r25, Z+7	; 0x07
    1b72:	dc 01       	movw	r26, r24
    1b74:	ed 91       	ld	r30, X+
    1b76:	fc 91       	ld	r31, X
    1b78:	04 80       	ldd	r0, Z+4	; 0x04
    1b7a:	f5 81       	ldd	r31, Z+5	; 0x05
    1b7c:	e0 2d       	mov	r30, r0
    1b7e:	19 95       	eicall
    1b80:	88 23       	and	r24, r24
    1b82:	a9 f1       	breq	.+106    	; 0x1bee <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1b84:	f8 01       	movw	r30, r16
    1b86:	86 81       	ldd	r24, Z+6	; 0x06
    1b88:	97 81       	ldd	r25, Z+7	; 0x07
    1b8a:	dc 01       	movw	r26, r24
    1b8c:	ed 91       	ld	r30, X+
    1b8e:	fc 91       	ld	r31, X
    1b90:	06 80       	ldd	r0, Z+6	; 0x06
    1b92:	f7 81       	ldd	r31, Z+7	; 0x07
    1b94:	e0 2d       	mov	r30, r0
    1b96:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1b98:	99 27       	eor	r25, r25
    1b9a:	81 30       	cpi	r24, 0x01	; 1
    1b9c:	91 05       	cpc	r25, r1
    1b9e:	f9 f0       	breq	.+62     	; 0x1bde <_ZN9task_user3runEv+0xbc>
    1ba0:	03 97       	sbiw	r24, 0x03	; 3
    1ba2:	09 f0       	breq	.+2      	; 0x1ba6 <_ZN9task_user3runEv+0x84>
    1ba4:	d8 c0       	rjmp	.+432    	; 0x1d56 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1ba6:	6a e0       	ldi	r22, 0x0A	; 10
    1ba8:	f8 01       	movw	r30, r16
    1baa:	86 81       	ldd	r24, Z+6	; 0x06
    1bac:	97 81       	ldd	r25, Z+7	; 0x07
    1bae:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1bb2:	8c 01       	movw	r16, r24
    1bb4:	68 e4       	ldi	r22, 0x48	; 72
    1bb6:	75 e0       	ldi	r23, 0x05	; 5
    1bb8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1bbc:	66 e0       	ldi	r22, 0x06	; 6
    1bbe:	c8 01       	movw	r24, r16
    1bc0:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1bc4:	93 e0       	ldi	r25, 0x03	; 3
    1bc6:	88 ed       	ldi	r24, 0xD8	; 216
    1bc8:	08 b6       	in	r0, 0x38	; 56
    1bca:	18 be       	out	0x38, r1	; 56
    1bcc:	84 bf       	out	0x34, r24	; 52
    1bce:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1bd2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1bd6:	81 fd       	sbrc	r24, 1
    1bd8:	fc cf       	rjmp	.-8      	; 0x1bd2 <_ZN9task_user3runEv+0xb0>
    1bda:	08 be       	out	0x38, r0	; 56
    1bdc:	ff cf       	rjmp	.-2      	; 0x1bdc <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1bde:	c8 01       	movw	r24, r16
    1be0:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1be4:	61 e0       	ldi	r22, 0x01	; 1
    1be6:	c8 01       	movw	r24, r16
    1be8:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8frt_task13transition_toEh>
							break;
    1bec:	b4 c0       	rjmp	.+360    	; 0x1d56 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1bee:	82 ef       	ldi	r24, 0xF2	; 242
    1bf0:	92 e3       	ldi	r25, 0x32	; 50
    1bf2:	0e 94 bf 1c 	call	0x397e	; 0x397e <_ZN14frt_text_queue14check_for_charEv>
    1bf6:	88 23       	and	r24, r24
    1bf8:	09 f4       	brne	.+2      	; 0x1bfc <_ZN9task_user3runEv+0xda>
    1bfa:	ad c0       	rjmp	.+346    	; 0x1d56 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1bfc:	d8 01       	movw	r26, r16
    1bfe:	16 96       	adiw	r26, 0x06	; 6
    1c00:	ed 91       	ld	r30, X+
    1c02:	fc 91       	ld	r31, X
    1c04:	17 97       	sbiw	r26, 0x07	; 7
    1c06:	01 90       	ld	r0, Z+
    1c08:	f0 81       	ld	r31, Z
    1c0a:	e0 2d       	mov	r30, r0
    1c0c:	e2 80       	ldd	r14, Z+2	; 0x02
    1c0e:	f3 80       	ldd	r15, Z+3	; 0x03
    1c10:	82 ef       	ldi	r24, 0xF2	; 242
    1c12:	92 e3       	ldi	r25, 0x32	; 50
    1c14:	0e 94 a1 1c 	call	0x3942	; 0x3942 <_ZN14frt_text_queue7getcharEv>
    1c18:	68 2f       	mov	r22, r24
    1c1a:	f8 01       	movw	r30, r16
    1c1c:	86 81       	ldd	r24, Z+6	; 0x06
    1c1e:	97 81       	ldd	r25, Z+7	; 0x07
    1c20:	f7 01       	movw	r30, r14
    1c22:	19 95       	eicall
    1c24:	98 c0       	rjmp	.+304    	; 0x1d56 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1c26:	86 81       	ldd	r24, Z+6	; 0x06
    1c28:	97 81       	ldd	r25, Z+7	; 0x07
    1c2a:	dc 01       	movw	r26, r24
    1c2c:	ed 91       	ld	r30, X+
    1c2e:	fc 91       	ld	r31, X
    1c30:	04 80       	ldd	r0, Z+4	; 0x04
    1c32:	f5 81       	ldd	r31, Z+5	; 0x05
    1c34:	e0 2d       	mov	r30, r0
    1c36:	19 95       	eicall
    1c38:	88 23       	and	r24, r24
    1c3a:	09 f4       	brne	.+2      	; 0x1c3e <_ZN9task_user3runEv+0x11c>
    1c3c:	8c c0       	rjmp	.+280    	; 0x1d56 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1c3e:	f8 01       	movw	r30, r16
    1c40:	86 81       	ldd	r24, Z+6	; 0x06
    1c42:	97 81       	ldd	r25, Z+7	; 0x07
    1c44:	dc 01       	movw	r26, r24
    1c46:	ed 91       	ld	r30, X+
    1c48:	fc 91       	ld	r31, X
    1c4a:	06 80       	ldd	r0, Z+6	; 0x06
    1c4c:	f7 81       	ldd	r31, Z+7	; 0x07
    1c4e:	e0 2d       	mov	r30, r0
    1c50:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1c52:	9c 01       	movw	r18, r24
    1c54:	33 27       	eor	r19, r19
    1c56:	28 36       	cpi	r18, 0x68	; 104
    1c58:	31 05       	cpc	r19, r1
    1c5a:	59 f1       	breq	.+86     	; 0x1cb2 <_ZN9task_user3runEv+0x190>
    1c5c:	3c f4       	brge	.+14     	; 0x1c6c <_ZN9task_user3runEv+0x14a>
    1c5e:	2b 31       	cpi	r18, 0x1B	; 27
    1c60:	31 05       	cpc	r19, r1
    1c62:	59 f1       	breq	.+86     	; 0x1cba <_ZN9task_user3runEv+0x198>
    1c64:	25 36       	cpi	r18, 0x65	; 101
    1c66:	31 05       	cpc	r19, r1
    1c68:	41 f1       	breq	.+80     	; 0x1cba <_ZN9task_user3runEv+0x198>
    1c6a:	3b c0       	rjmp	.+118    	; 0x1ce2 <_ZN9task_user3runEv+0x1c0>
    1c6c:	23 37       	cpi	r18, 0x73	; 115
    1c6e:	31 05       	cpc	r19, r1
    1c70:	c1 f0       	breq	.+48     	; 0x1ca2 <_ZN9task_user3runEv+0x180>
    1c72:	26 37       	cpi	r18, 0x76	; 118
    1c74:	31 05       	cpc	r19, r1
    1c76:	89 f0       	breq	.+34     	; 0x1c9a <_ZN9task_user3runEv+0x178>
    1c78:	2e 36       	cpi	r18, 0x6E	; 110
    1c7a:	31 05       	cpc	r19, r1
    1c7c:	91 f5       	brne	.+100    	; 0x1ce2 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1c7e:	ce 01       	movw	r24, r28
    1c80:	01 96       	adiw	r24, 0x01	; 1
    1c82:	0e 94 b3 1d 	call	0x3b66	; 0x3b66 <_ZN10time_stamp10set_to_nowEv>
    1c86:	bc 01       	movw	r22, r24
    1c88:	f8 01       	movw	r30, r16
    1c8a:	86 81       	ldd	r24, Z+6	; 0x06
    1c8c:	97 81       	ldd	r25, Z+7	; 0x07
    1c8e:	0e 94 57 1d 	call	0x3aae	; 0x3aae <_ZlsR8emstreamR10time_stamp>
    1c92:	66 e0       	ldi	r22, 0x06	; 6
    1c94:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
							break;
    1c98:	5e c0       	rjmp	.+188    	; 0x1d56 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1c9a:	c8 01       	movw	r24, r16
    1c9c:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <_ZN9task_user11show_statusEv>
							break;
    1ca0:	5a c0       	rjmp	.+180    	; 0x1d56 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1ca2:	d8 01       	movw	r26, r16
    1ca4:	16 96       	adiw	r26, 0x06	; 6
    1ca6:	8d 91       	ld	r24, X+
    1ca8:	9c 91       	ld	r25, X
    1caa:	17 97       	sbiw	r26, 0x07	; 7
    1cac:	0e 94 17 1b 	call	0x362e	; 0x362e <_Z17print_task_stacksP8emstream>
							break;
    1cb0:	52 c0       	rjmp	.+164    	; 0x1d56 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1cb2:	c8 01       	movw	r24, r16
    1cb4:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <_ZN9task_user18print_help_messageEv>
							break;
    1cb8:	4e c0       	rjmp	.+156    	; 0x1d56 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1cba:	6a e0       	ldi	r22, 0x0A	; 10
    1cbc:	f8 01       	movw	r30, r16
    1cbe:	86 81       	ldd	r24, Z+6	; 0x06
    1cc0:	97 81       	ldd	r25, Z+7	; 0x07
    1cc2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1cc6:	7c 01       	movw	r14, r24
    1cc8:	66 e3       	ldi	r22, 0x36	; 54
    1cca:	75 e0       	ldi	r23, 0x05	; 5
    1ccc:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1cd0:	66 e0       	ldi	r22, 0x06	; 6
    1cd2:	c7 01       	movw	r24, r14
    1cd4:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1cd8:	60 e0       	ldi	r22, 0x00	; 0
    1cda:	c8 01       	movw	r24, r16
    1cdc:	0e 94 fe 19 	call	0x33fc	; 0x33fc <_ZN8frt_task13transition_toEh>
							break;
    1ce0:	3a c0       	rjmp	.+116    	; 0x1d56 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1ce2:	f8 01       	movw	r30, r16
    1ce4:	a6 81       	ldd	r26, Z+6	; 0x06
    1ce6:	b7 81       	ldd	r27, Z+7	; 0x07
    1ce8:	ed 91       	ld	r30, X+
    1cea:	fc 91       	ld	r31, X
    1cec:	11 97       	sbiw	r26, 0x01	; 1
    1cee:	02 80       	ldd	r0, Z+2	; 0x02
    1cf0:	f3 81       	ldd	r31, Z+3	; 0x03
    1cf2:	e0 2d       	mov	r30, r0
    1cf4:	68 2f       	mov	r22, r24
    1cf6:	cd 01       	movw	r24, r26
    1cf8:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1cfa:	6a e0       	ldi	r22, 0x0A	; 10
    1cfc:	d8 01       	movw	r26, r16
    1cfe:	16 96       	adiw	r26, 0x06	; 6
    1d00:	8d 91       	ld	r24, X+
    1d02:	9c 91       	ld	r25, X
    1d04:	17 97       	sbiw	r26, 0x07	; 7
    1d06:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1d0a:	7c 01       	movw	r14, r24
    1d0c:	60 e3       	ldi	r22, 0x30	; 48
    1d0e:	75 e0       	ldi	r23, 0x05	; 5
    1d10:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1d14:	66 e0       	ldi	r22, 0x06	; 6
    1d16:	c7 01       	movw	r24, r14
    1d18:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
							break;
    1d1c:	1c c0       	rjmp	.+56     	; 0x1d56 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1d1e:	6a e0       	ldi	r22, 0x0A	; 10
    1d20:	f8 01       	movw	r30, r16
    1d22:	86 81       	ldd	r24, Z+6	; 0x06
    1d24:	97 81       	ldd	r25, Z+7	; 0x07
    1d26:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    1d2a:	8c 01       	movw	r16, r24
    1d2c:	63 e1       	ldi	r22, 0x13	; 19
    1d2e:	75 e0       	ldi	r23, 0x05	; 5
    1d30:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    1d34:	66 e0       	ldi	r22, 0x06	; 6
    1d36:	c8 01       	movw	r24, r16
    1d38:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1d3c:	93 e0       	ldi	r25, 0x03	; 3
    1d3e:	88 ed       	ldi	r24, 0xD8	; 216
    1d40:	08 b6       	in	r0, 0x38	; 56
    1d42:	18 be       	out	0x38, r1	; 56
    1d44:	84 bf       	out	0x34, r24	; 52
    1d46:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1d4a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1d4e:	81 fd       	sbrc	r24, 1
    1d50:	fc cf       	rjmp	.-8      	; 0x1d4a <_ZN9task_user3runEv+0x228>
    1d52:	08 be       	out	0x38, r0	; 56
    1d54:	ff cf       	rjmp	.-2      	; 0x1d54 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1d56:	f8 01       	movw	r30, r16
    1d58:	86 85       	ldd	r24, Z+14	; 0x0e
    1d5a:	97 85       	ldd	r25, Z+15	; 0x0f
    1d5c:	a0 89       	ldd	r26, Z+16	; 0x10
    1d5e:	b1 89       	ldd	r27, Z+17	; 0x11
    1d60:	01 96       	adiw	r24, 0x01	; 1
    1d62:	a1 1d       	adc	r26, r1
    1d64:	b1 1d       	adc	r27, r1
    1d66:	86 87       	std	Z+14, r24	; 0x0e
    1d68:	97 87       	std	Z+15, r25	; 0x0f
    1d6a:	a0 8b       	std	Z+16, r26	; 0x10
    1d6c:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1d6e:	68 ee       	ldi	r22, 0xE8	; 232
    1d70:	73 e0       	ldi	r23, 0x03	; 3
    1d72:	80 e0       	ldi	r24, 0x00	; 0
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1d7a:	f1 ce       	rjmp	.-542    	; 0x1b5e <_ZN9task_user3runEv+0x3c>

00001d7c <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d7c:	0f 93       	push	r16
    1d7e:	1f 93       	push	r17
    1d80:	cf 93       	push	r28
    1d82:	df 93       	push	r29
    1d84:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1d86:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1d8a:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <__data_end>
    1d8e:	81 11       	cpse	r24, r1
    1d90:	1d c0       	rjmp	.+58     	; 0x1dcc <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1d92:	ab e3       	ldi	r26, 0x3B	; 59
    1d94:	b2 e2       	ldi	r27, 0x22	; 34
    1d96:	ef e3       	ldi	r30, 0x3F	; 63
    1d98:	f2 e2       	ldi	r31, 0x22	; 34
    1d9a:	ed 93       	st	X+, r30
    1d9c:	fc 93       	st	X, r31
    1d9e:	11 97       	sbiw	r26, 0x01	; 1
    1da0:	12 96       	adiw	r26, 0x02	; 2
    1da2:	1d 92       	st	X+, r1
    1da4:	1c 92       	st	X, r1
    1da6:	13 97       	sbiw	r26, 0x03	; 3
    1da8:	a7 e3       	ldi	r26, 0x37	; 55
    1daa:	b2 e2       	ldi	r27, 0x22	; 34
    1dac:	8f ef       	ldi	r24, 0xFF	; 255
    1dae:	9f e0       	ldi	r25, 0x0F	; 15
    1db0:	12 96       	adiw	r26, 0x02	; 2
    1db2:	8d 93       	st	X+, r24
    1db4:	9c 93       	st	X, r25
    1db6:	13 97       	sbiw	r26, 0x03	; 3
    1db8:	1d 92       	st	X+, r1
    1dba:	1c 92       	st	X, r1
    1dbc:	11 97       	sbiw	r26, 0x01	; 1
    1dbe:	82 83       	std	Z+2, r24	; 0x02
    1dc0:	93 83       	std	Z+3, r25	; 0x03
    1dc2:	a0 83       	st	Z, r26
    1dc4:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1dc6:	81 e0       	ldi	r24, 0x01	; 1
    1dc8:	80 93 36 22 	sts	0x2236, r24	; 0x802236 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1dcc:	20 97       	sbiw	r28, 0x00	; 0
    1dce:	09 f4       	brne	.+2      	; 0x1dd2 <pvPortMalloc+0x56>
    1dd0:	5f c0       	rjmp	.+190    	; 0x1e90 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1dd2:	9e 01       	movw	r18, r28
    1dd4:	2b 5f       	subi	r18, 0xFB	; 251
    1dd6:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1dd8:	24 96       	adiw	r28, 0x04	; 4
    1dda:	ce 3f       	cpi	r28, 0xFE	; 254
    1ddc:	df 40       	sbci	r29, 0x0F	; 15
    1dde:	08 f0       	brcs	.+2      	; 0x1de2 <pvPortMalloc+0x66>
    1de0:	5a c0       	rjmp	.+180    	; 0x1e96 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1de2:	e0 91 3b 22 	lds	r30, 0x223B	; 0x80223b <xStart>
    1de6:	f0 91 3c 22 	lds	r31, 0x223C	; 0x80223c <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1dea:	ab e3       	ldi	r26, 0x3B	; 59
    1dec:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1dee:	02 c0       	rjmp	.+4      	; 0x1df4 <pvPortMalloc+0x78>
    1df0:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1df2:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1df4:	82 81       	ldd	r24, Z+2	; 0x02
    1df6:	93 81       	ldd	r25, Z+3	; 0x03
    1df8:	82 17       	cp	r24, r18
    1dfa:	93 07       	cpc	r25, r19
    1dfc:	20 f4       	brcc	.+8      	; 0x1e06 <pvPortMalloc+0x8a>
    1dfe:	80 81       	ld	r24, Z
    1e00:	91 81       	ldd	r25, Z+1	; 0x01
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	a9 f7       	brne	.-22     	; 0x1df0 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1e06:	c2 e2       	ldi	r28, 0x22	; 34
    1e08:	e7 33       	cpi	r30, 0x37	; 55
    1e0a:	fc 07       	cpc	r31, r28
    1e0c:	09 f4       	brne	.+2      	; 0x1e10 <pvPortMalloc+0x94>
    1e0e:	46 c0       	rjmp	.+140    	; 0x1e9c <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1e10:	cd 91       	ld	r28, X+
    1e12:	dc 91       	ld	r29, X
    1e14:	11 97       	sbiw	r26, 0x01	; 1
    1e16:	8e 01       	movw	r16, r28
    1e18:	0b 5f       	subi	r16, 0xFB	; 251
    1e1a:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e1c:	80 81       	ld	r24, Z
    1e1e:	91 81       	ldd	r25, Z+1	; 0x01
    1e20:	8d 93       	st	X+, r24
    1e22:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e24:	82 81       	ldd	r24, Z+2	; 0x02
    1e26:	93 81       	ldd	r25, Z+3	; 0x03
    1e28:	82 1b       	sub	r24, r18
    1e2a:	93 0b       	sbc	r25, r19
    1e2c:	8b 30       	cpi	r24, 0x0B	; 11
    1e2e:	91 05       	cpc	r25, r1
    1e30:	10 f1       	brcs	.+68     	; 0x1e76 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1e32:	bf 01       	movw	r22, r30
    1e34:	62 0f       	add	r22, r18
    1e36:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e38:	db 01       	movw	r26, r22
    1e3a:	12 96       	adiw	r26, 0x02	; 2
    1e3c:	8d 93       	st	X+, r24
    1e3e:	9c 93       	st	X, r25
    1e40:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1e42:	22 83       	std	Z+2, r18	; 0x02
    1e44:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1e46:	12 96       	adiw	r26, 0x02	; 2
    1e48:	4d 91       	ld	r20, X+
    1e4a:	5c 91       	ld	r21, X
    1e4c:	13 97       	sbiw	r26, 0x03	; 3
    1e4e:	8b e3       	ldi	r24, 0x3B	; 59
    1e50:	92 e2       	ldi	r25, 0x22	; 34
    1e52:	01 c0       	rjmp	.+2      	; 0x1e56 <pvPortMalloc+0xda>
    1e54:	cd 01       	movw	r24, r26
    1e56:	ec 01       	movw	r28, r24
    1e58:	a8 81       	ld	r26, Y
    1e5a:	b9 81       	ldd	r27, Y+1	; 0x01
    1e5c:	12 96       	adiw	r26, 0x02	; 2
    1e5e:	2d 91       	ld	r18, X+
    1e60:	3c 91       	ld	r19, X
    1e62:	13 97       	sbiw	r26, 0x03	; 3
    1e64:	24 17       	cp	r18, r20
    1e66:	35 07       	cpc	r19, r21
    1e68:	a8 f3       	brcs	.-22     	; 0x1e54 <pvPortMalloc+0xd8>
    1e6a:	eb 01       	movw	r28, r22
    1e6c:	a8 83       	st	Y, r26
    1e6e:	b9 83       	std	Y+1, r27	; 0x01
    1e70:	dc 01       	movw	r26, r24
    1e72:	6d 93       	st	X+, r22
    1e74:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1e76:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1e7a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1e7e:	22 81       	ldd	r18, Z+2	; 0x02
    1e80:	33 81       	ldd	r19, Z+3	; 0x03
    1e82:	82 1b       	sub	r24, r18
    1e84:	93 0b       	sbc	r25, r19
    1e86:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1e8a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1e8e:	08 c0       	rjmp	.+16     	; 0x1ea0 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1e90:	00 e0       	ldi	r16, 0x00	; 0
    1e92:	10 e0       	ldi	r17, 0x00	; 0
    1e94:	05 c0       	rjmp	.+10     	; 0x1ea0 <pvPortMalloc+0x124>
    1e96:	00 e0       	ldi	r16, 0x00	; 0
    1e98:	10 e0       	ldi	r17, 0x00	; 0
    1e9a:	02 c0       	rjmp	.+4      	; 0x1ea0 <pvPortMalloc+0x124>
    1e9c:	00 e0       	ldi	r16, 0x00	; 0
    1e9e:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1ea0:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1ea4:	c8 01       	movw	r24, r16
    1ea6:	df 91       	pop	r29
    1ea8:	cf 91       	pop	r28
    1eaa:	1f 91       	pop	r17
    1eac:	0f 91       	pop	r16
    1eae:	08 95       	ret

00001eb0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1eb0:	0f 93       	push	r16
    1eb2:	1f 93       	push	r17
    1eb4:	cf 93       	push	r28
    1eb6:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	41 f1       	breq	.+80     	; 0x1f0c <vPortFree+0x5c>
    1ebc:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1ebe:	8c 01       	movw	r16, r24
    1ec0:	05 50       	subi	r16, 0x05	; 5
    1ec2:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1ec4:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1ec8:	f8 01       	movw	r30, r16
    1eca:	42 81       	ldd	r20, Z+2	; 0x02
    1ecc:	53 81       	ldd	r21, Z+3	; 0x03
    1ece:	ab e3       	ldi	r26, 0x3B	; 59
    1ed0:	b2 e2       	ldi	r27, 0x22	; 34
    1ed2:	01 c0       	rjmp	.+2      	; 0x1ed6 <vPortFree+0x26>
    1ed4:	df 01       	movw	r26, r30
    1ed6:	ed 91       	ld	r30, X+
    1ed8:	fc 91       	ld	r31, X
    1eda:	11 97       	sbiw	r26, 0x01	; 1
    1edc:	22 81       	ldd	r18, Z+2	; 0x02
    1ede:	33 81       	ldd	r19, Z+3	; 0x03
    1ee0:	24 17       	cp	r18, r20
    1ee2:	35 07       	cpc	r19, r21
    1ee4:	b8 f3       	brcs	.-18     	; 0x1ed4 <vPortFree+0x24>
    1ee6:	25 97       	sbiw	r28, 0x05	; 5
    1ee8:	e8 83       	st	Y, r30
    1eea:	f9 83       	std	Y+1, r31	; 0x01
    1eec:	0d 93       	st	X+, r16
    1eee:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1ef0:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1ef4:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    1efa:	9b 81       	ldd	r25, Y+3	; 0x03
    1efc:	82 0f       	add	r24, r18
    1efe:	93 1f       	adc	r25, r19
    1f00:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f04:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1f08:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
	}
}
    1f0c:	df 91       	pop	r29
    1f0e:	cf 91       	pop	r28
    1f10:	1f 91       	pop	r17
    1f12:	0f 91       	pop	r16
    1f14:	08 95       	ret

00001f16 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1f16:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1f1a:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1f1e:	08 95       	ret

00001f20 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1f20:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1f22:	03 96       	adiw	r24, 0x03	; 3
    1f24:	81 83       	std	Z+1, r24	; 0x01
    1f26:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f28:	4f ef       	ldi	r20, 0xFF	; 255
    1f2a:	5f ef       	ldi	r21, 0xFF	; 255
    1f2c:	ba 01       	movw	r22, r20
    1f2e:	43 83       	std	Z+3, r20	; 0x03
    1f30:	54 83       	std	Z+4, r21	; 0x04
    1f32:	65 83       	std	Z+5, r22	; 0x05
    1f34:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1f36:	87 83       	std	Z+7, r24	; 0x07
    1f38:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1f3a:	81 87       	std	Z+9, r24	; 0x09
    1f3c:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1f3e:	10 82       	st	Z, r1
    1f40:	08 95       	ret

00001f42 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f42:	fc 01       	movw	r30, r24
    1f44:	12 86       	std	Z+10, r1	; 0x0a
    1f46:	13 86       	std	Z+11, r1	; 0x0b
    1f48:	08 95       	ret

00001f4a <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1f4a:	cf 93       	push	r28
    1f4c:	df 93       	push	r29
    1f4e:	fc 01       	movw	r30, r24
    1f50:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1f52:	21 81       	ldd	r18, Z+1	; 0x01
    1f54:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1f56:	e9 01       	movw	r28, r18
    1f58:	8c 81       	ldd	r24, Y+4	; 0x04
    1f5a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f5c:	14 96       	adiw	r26, 0x04	; 4
    1f5e:	8d 93       	st	X+, r24
    1f60:	9c 93       	st	X, r25
    1f62:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1f64:	81 81       	ldd	r24, Z+1	; 0x01
    1f66:	92 81       	ldd	r25, Z+2	; 0x02
    1f68:	16 96       	adiw	r26, 0x06	; 6
    1f6a:	8d 93       	st	X+, r24
    1f6c:	9c 93       	st	X, r25
    1f6e:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f70:	8c 81       	ldd	r24, Y+4	; 0x04
    1f72:	9d 81       	ldd	r25, Y+5	; 0x05
    1f74:	ec 01       	movw	r28, r24
    1f76:	6e 83       	std	Y+6, r22	; 0x06
    1f78:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f7a:	e9 01       	movw	r28, r18
    1f7c:	6c 83       	std	Y+4, r22	; 0x04
    1f7e:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1f80:	61 83       	std	Z+1, r22	; 0x01
    1f82:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f84:	1a 96       	adiw	r26, 0x0a	; 10
    1f86:	ed 93       	st	X+, r30
    1f88:	fc 93       	st	X, r31
    1f8a:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1f8c:	80 81       	ld	r24, Z
    1f8e:	8f 5f       	subi	r24, 0xFF	; 255
    1f90:	80 83       	st	Z, r24
}
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	08 95       	ret

00001f98 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1f98:	0f 93       	push	r16
    1f9a:	1f 93       	push	r17
    1f9c:	cf 93       	push	r28
    1f9e:	df 93       	push	r29
    1fa0:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1fa2:	08 81       	ld	r16, Y
    1fa4:	19 81       	ldd	r17, Y+1	; 0x01
    1fa6:	2a 81       	ldd	r18, Y+2	; 0x02
    1fa8:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1faa:	0f 3f       	cpi	r16, 0xFF	; 255
    1fac:	4f ef       	ldi	r20, 0xFF	; 255
    1fae:	14 07       	cpc	r17, r20
    1fb0:	24 07       	cpc	r18, r20
    1fb2:	34 07       	cpc	r19, r20
    1fb4:	31 f4       	brne	.+12     	; 0x1fc2 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1fb6:	dc 01       	movw	r26, r24
    1fb8:	19 96       	adiw	r26, 0x09	; 9
    1fba:	ed 91       	ld	r30, X+
    1fbc:	fc 91       	ld	r31, X
    1fbe:	1a 97       	sbiw	r26, 0x0a	; 10
    1fc0:	1f c0       	rjmp	.+62     	; 0x2000 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	33 96       	adiw	r30, 0x03	; 3
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	17 96       	adiw	r26, 0x07	; 7
    1fca:	4d 91       	ld	r20, X+
    1fcc:	5c 91       	ld	r21, X
    1fce:	18 97       	sbiw	r26, 0x08	; 8
    1fd0:	da 01       	movw	r26, r20
    1fd2:	4d 91       	ld	r20, X+
    1fd4:	5d 91       	ld	r21, X+
    1fd6:	6d 91       	ld	r22, X+
    1fd8:	7c 91       	ld	r23, X
    1fda:	04 17       	cp	r16, r20
    1fdc:	15 07       	cpc	r17, r21
    1fde:	26 07       	cpc	r18, r22
    1fe0:	37 07       	cpc	r19, r23
    1fe2:	70 f0       	brcs	.+28     	; 0x2000 <vListInsert+0x68>
    1fe4:	04 80       	ldd	r0, Z+4	; 0x04
    1fe6:	f5 81       	ldd	r31, Z+5	; 0x05
    1fe8:	e0 2d       	mov	r30, r0
    1fea:	a4 81       	ldd	r26, Z+4	; 0x04
    1fec:	b5 81       	ldd	r27, Z+5	; 0x05
    1fee:	4d 91       	ld	r20, X+
    1ff0:	5d 91       	ld	r21, X+
    1ff2:	6d 91       	ld	r22, X+
    1ff4:	7c 91       	ld	r23, X
    1ff6:	04 17       	cp	r16, r20
    1ff8:	15 07       	cpc	r17, r21
    1ffa:	26 07       	cpc	r18, r22
    1ffc:	37 07       	cpc	r19, r23
    1ffe:	90 f7       	brcc	.-28     	; 0x1fe4 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2000:	a4 81       	ldd	r26, Z+4	; 0x04
    2002:	b5 81       	ldd	r27, Z+5	; 0x05
    2004:	ac 83       	std	Y+4, r26	; 0x04
    2006:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2008:	16 96       	adiw	r26, 0x06	; 6
    200a:	cd 93       	st	X+, r28
    200c:	dc 93       	st	X, r29
    200e:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    2010:	ee 83       	std	Y+6, r30	; 0x06
    2012:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2014:	c4 83       	std	Z+4, r28	; 0x04
    2016:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2018:	8a 87       	std	Y+10, r24	; 0x0a
    201a:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    201c:	fc 01       	movw	r30, r24
    201e:	20 81       	ld	r18, Z
    2020:	2f 5f       	subi	r18, 0xFF	; 255
    2022:	20 83       	st	Z, r18
}
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	1f 91       	pop	r17
    202a:	0f 91       	pop	r16
    202c:	08 95       	ret

0000202e <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    202e:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2030:	a4 81       	ldd	r26, Z+4	; 0x04
    2032:	b5 81       	ldd	r27, Z+5	; 0x05
    2034:	86 81       	ldd	r24, Z+6	; 0x06
    2036:	97 81       	ldd	r25, Z+7	; 0x07
    2038:	16 96       	adiw	r26, 0x06	; 6
    203a:	8d 93       	st	X+, r24
    203c:	9c 93       	st	X, r25
    203e:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2040:	a6 81       	ldd	r26, Z+6	; 0x06
    2042:	b7 81       	ldd	r27, Z+7	; 0x07
    2044:	84 81       	ldd	r24, Z+4	; 0x04
    2046:	95 81       	ldd	r25, Z+5	; 0x05
    2048:	14 96       	adiw	r26, 0x04	; 4
    204a:	8d 93       	st	X+, r24
    204c:	9c 93       	st	X, r25
    204e:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2050:	a2 85       	ldd	r26, Z+10	; 0x0a
    2052:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2054:	11 96       	adiw	r26, 0x01	; 1
    2056:	8d 91       	ld	r24, X+
    2058:	9c 91       	ld	r25, X
    205a:	12 97       	sbiw	r26, 0x02	; 2
    205c:	e8 17       	cp	r30, r24
    205e:	f9 07       	cpc	r31, r25
    2060:	31 f4       	brne	.+12     	; 0x206e <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2062:	86 81       	ldd	r24, Z+6	; 0x06
    2064:	97 81       	ldd	r25, Z+7	; 0x07
    2066:	11 96       	adiw	r26, 0x01	; 1
    2068:	8d 93       	st	X+, r24
    206a:	9c 93       	st	X, r25
    206c:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    206e:	12 86       	std	Z+10, r1	; 0x0a
    2070:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    2072:	8c 91       	ld	r24, X
    2074:	81 50       	subi	r24, 0x01	; 1
    2076:	8c 93       	st	X, r24
    2078:	08 95       	ret

0000207a <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    207a:	80 93 02 33 	sts	0x3302, r24	; 0x803302 <portStackTopForTask>
    207e:	90 93 03 33 	sts	0x3303, r25	; 0x803303 <portStackTopForTask+0x1>
    2082:	31 e1       	ldi	r19, 0x11	; 17
    2084:	fc 01       	movw	r30, r24
    2086:	30 83       	st	Z, r19
    2088:	31 97       	sbiw	r30, 0x01	; 1
    208a:	22 e2       	ldi	r18, 0x22	; 34
    208c:	20 83       	st	Z, r18
    208e:	31 97       	sbiw	r30, 0x01	; 1
    2090:	a3 e3       	ldi	r26, 0x33	; 51
    2092:	a0 83       	st	Z, r26
    2094:	31 97       	sbiw	r30, 0x01	; 1
    2096:	60 83       	st	Z, r22
    2098:	31 97       	sbiw	r30, 0x01	; 1
    209a:	70 83       	st	Z, r23
    209c:	31 97       	sbiw	r30, 0x01	; 1
    209e:	10 82       	st	Z, r1
    20a0:	31 97       	sbiw	r30, 0x01	; 1
    20a2:	10 82       	st	Z, r1
    20a4:	31 97       	sbiw	r30, 0x01	; 1
    20a6:	60 e8       	ldi	r22, 0x80	; 128
    20a8:	60 83       	st	Z, r22
    20aa:	31 97       	sbiw	r30, 0x01	; 1
    20ac:	10 82       	st	Z, r1
    20ae:	31 97       	sbiw	r30, 0x01	; 1
    20b0:	10 82       	st	Z, r1
    20b2:	31 97       	sbiw	r30, 0x01	; 1
    20b4:	10 82       	st	Z, r1
    20b6:	31 97       	sbiw	r30, 0x01	; 1
    20b8:	62 e0       	ldi	r22, 0x02	; 2
    20ba:	60 83       	st	Z, r22
    20bc:	31 97       	sbiw	r30, 0x01	; 1
    20be:	63 e0       	ldi	r22, 0x03	; 3
    20c0:	60 83       	st	Z, r22
    20c2:	31 97       	sbiw	r30, 0x01	; 1
    20c4:	64 e0       	ldi	r22, 0x04	; 4
    20c6:	60 83       	st	Z, r22
    20c8:	31 97       	sbiw	r30, 0x01	; 1
    20ca:	65 e0       	ldi	r22, 0x05	; 5
    20cc:	60 83       	st	Z, r22
    20ce:	31 97       	sbiw	r30, 0x01	; 1
    20d0:	66 e0       	ldi	r22, 0x06	; 6
    20d2:	60 83       	st	Z, r22
    20d4:	31 97       	sbiw	r30, 0x01	; 1
    20d6:	67 e0       	ldi	r22, 0x07	; 7
    20d8:	60 83       	st	Z, r22
    20da:	31 97       	sbiw	r30, 0x01	; 1
    20dc:	68 e0       	ldi	r22, 0x08	; 8
    20de:	60 83       	st	Z, r22
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	69 e0       	ldi	r22, 0x09	; 9
    20e4:	60 83       	st	Z, r22
    20e6:	31 97       	sbiw	r30, 0x01	; 1
    20e8:	60 e1       	ldi	r22, 0x10	; 16
    20ea:	60 83       	st	Z, r22
    20ec:	31 97       	sbiw	r30, 0x01	; 1
    20ee:	30 83       	st	Z, r19
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	32 e1       	ldi	r19, 0x12	; 18
    20f4:	30 83       	st	Z, r19
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	33 e1       	ldi	r19, 0x13	; 19
    20fa:	30 83       	st	Z, r19
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	34 e1       	ldi	r19, 0x14	; 20
    2100:	30 83       	st	Z, r19
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	35 e1       	ldi	r19, 0x15	; 21
    2106:	30 83       	st	Z, r19
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	36 e1       	ldi	r19, 0x16	; 22
    210c:	30 83       	st	Z, r19
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	37 e1       	ldi	r19, 0x17	; 23
    2112:	30 83       	st	Z, r19
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	38 e1       	ldi	r19, 0x18	; 24
    2118:	30 83       	st	Z, r19
    211a:	31 97       	sbiw	r30, 0x01	; 1
    211c:	39 e1       	ldi	r19, 0x19	; 25
    211e:	30 83       	st	Z, r19
    2120:	31 97       	sbiw	r30, 0x01	; 1
    2122:	30 e2       	ldi	r19, 0x20	; 32
    2124:	30 83       	st	Z, r19
    2126:	31 97       	sbiw	r30, 0x01	; 1
    2128:	31 e2       	ldi	r19, 0x21	; 33
    212a:	30 83       	st	Z, r19
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	20 83       	st	Z, r18
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	23 e2       	ldi	r18, 0x23	; 35
    2134:	20 83       	st	Z, r18
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	40 83       	st	Z, r20
    213a:	31 97       	sbiw	r30, 0x01	; 1
    213c:	50 83       	st	Z, r21
    213e:	31 97       	sbiw	r30, 0x01	; 1
    2140:	26 e2       	ldi	r18, 0x26	; 38
    2142:	20 83       	st	Z, r18
    2144:	31 97       	sbiw	r30, 0x01	; 1
    2146:	27 e2       	ldi	r18, 0x27	; 39
    2148:	20 83       	st	Z, r18
    214a:	31 97       	sbiw	r30, 0x01	; 1
    214c:	28 e2       	ldi	r18, 0x28	; 40
    214e:	20 83       	st	Z, r18
    2150:	31 97       	sbiw	r30, 0x01	; 1
    2152:	29 e2       	ldi	r18, 0x29	; 41
    2154:	20 83       	st	Z, r18
    2156:	31 97       	sbiw	r30, 0x01	; 1
    2158:	20 e3       	ldi	r18, 0x30	; 48
    215a:	20 83       	st	Z, r18
    215c:	31 97       	sbiw	r30, 0x01	; 1
    215e:	21 e3       	ldi	r18, 0x31	; 49
    2160:	20 83       	st	Z, r18
    2162:	89 97       	sbiw	r24, 0x29	; 41
    2164:	08 95       	ret

00002166 <xPortStartScheduler>:
    2166:	8c e7       	ldi	r24, 0x7C	; 124
    2168:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    216c:	8f ef       	ldi	r24, 0xFF	; 255
    216e:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    2172:	81 e0       	ldi	r24, 0x01	; 1
    2174:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    2178:	91 e1       	ldi	r25, 0x11	; 17
    217a:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    217e:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    2182:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    2186:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    218a:	cd 91       	ld	r28, X+
    218c:	cd bf       	out	0x3d, r28	; 61
    218e:	dd 91       	ld	r29, X+
    2190:	de bf       	out	0x3e, r29	; 62
    2192:	ff 91       	pop	r31
    2194:	ef 91       	pop	r30
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
    219a:	bf 91       	pop	r27
    219c:	af 91       	pop	r26
    219e:	9f 91       	pop	r25
    21a0:	8f 91       	pop	r24
    21a2:	7f 91       	pop	r23
    21a4:	6f 91       	pop	r22
    21a6:	5f 91       	pop	r21
    21a8:	4f 91       	pop	r20
    21aa:	3f 91       	pop	r19
    21ac:	2f 91       	pop	r18
    21ae:	1f 91       	pop	r17
    21b0:	0f 91       	pop	r16
    21b2:	ff 90       	pop	r15
    21b4:	ef 90       	pop	r14
    21b6:	df 90       	pop	r13
    21b8:	cf 90       	pop	r12
    21ba:	bf 90       	pop	r11
    21bc:	af 90       	pop	r10
    21be:	9f 90       	pop	r9
    21c0:	8f 90       	pop	r8
    21c2:	7f 90       	pop	r7
    21c4:	6f 90       	pop	r6
    21c6:	5f 90       	pop	r5
    21c8:	4f 90       	pop	r4
    21ca:	3f 90       	pop	r3
    21cc:	2f 90       	pop	r2
    21ce:	1f 90       	pop	r1
    21d0:	0f 90       	pop	r0
    21d2:	0c be       	out	0x3c, r0	; 60
    21d4:	0f 90       	pop	r0
    21d6:	0b be       	out	0x3b, r0	; 59
    21d8:	0f 90       	pop	r0
    21da:	0f be       	out	0x3f, r0	; 63
    21dc:	0f 90       	pop	r0
    21de:	08 95       	ret
    21e0:	08 95       	ret

000021e2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    21e2:	0f 92       	push	r0
    21e4:	0f b6       	in	r0, 0x3f	; 63
    21e6:	f8 94       	cli
    21e8:	0f 92       	push	r0
    21ea:	0b b6       	in	r0, 0x3b	; 59
    21ec:	0f 92       	push	r0
    21ee:	0c b6       	in	r0, 0x3c	; 60
    21f0:	0f 92       	push	r0
    21f2:	1f 92       	push	r1
    21f4:	11 24       	eor	r1, r1
    21f6:	2f 92       	push	r2
    21f8:	3f 92       	push	r3
    21fa:	4f 92       	push	r4
    21fc:	5f 92       	push	r5
    21fe:	6f 92       	push	r6
    2200:	7f 92       	push	r7
    2202:	8f 92       	push	r8
    2204:	9f 92       	push	r9
    2206:	af 92       	push	r10
    2208:	bf 92       	push	r11
    220a:	cf 92       	push	r12
    220c:	df 92       	push	r13
    220e:	ef 92       	push	r14
    2210:	ff 92       	push	r15
    2212:	0f 93       	push	r16
    2214:	1f 93       	push	r17
    2216:	2f 93       	push	r18
    2218:	3f 93       	push	r19
    221a:	4f 93       	push	r20
    221c:	5f 93       	push	r21
    221e:	6f 93       	push	r22
    2220:	7f 93       	push	r23
    2222:	8f 93       	push	r24
    2224:	9f 93       	push	r25
    2226:	af 93       	push	r26
    2228:	bf 93       	push	r27
    222a:	cf 93       	push	r28
    222c:	df 93       	push	r29
    222e:	ef 93       	push	r30
    2230:	ff 93       	push	r31
    2232:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    2236:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    223a:	0d b6       	in	r0, 0x3d	; 61
    223c:	0d 92       	st	X+, r0
    223e:	0e b6       	in	r0, 0x3e	; 62
    2240:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2242:	0e 94 00 18 	call	0x3000	; 0x3000 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2246:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    224a:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    224e:	cd 91       	ld	r28, X+
    2250:	cd bf       	out	0x3d, r28	; 61
    2252:	dd 91       	ld	r29, X+
    2254:	de bf       	out	0x3e, r29	; 62
    2256:	ff 91       	pop	r31
    2258:	ef 91       	pop	r30
    225a:	df 91       	pop	r29
    225c:	cf 91       	pop	r28
    225e:	bf 91       	pop	r27
    2260:	af 91       	pop	r26
    2262:	9f 91       	pop	r25
    2264:	8f 91       	pop	r24
    2266:	7f 91       	pop	r23
    2268:	6f 91       	pop	r22
    226a:	5f 91       	pop	r21
    226c:	4f 91       	pop	r20
    226e:	3f 91       	pop	r19
    2270:	2f 91       	pop	r18
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	df 90       	pop	r13
    227c:	cf 90       	pop	r12
    227e:	bf 90       	pop	r11
    2280:	af 90       	pop	r10
    2282:	9f 90       	pop	r9
    2284:	8f 90       	pop	r8
    2286:	7f 90       	pop	r7
    2288:	6f 90       	pop	r6
    228a:	5f 90       	pop	r5
    228c:	4f 90       	pop	r4
    228e:	3f 90       	pop	r3
    2290:	2f 90       	pop	r2
    2292:	1f 90       	pop	r1
    2294:	0f 90       	pop	r0
    2296:	0c be       	out	0x3c, r0	; 60
    2298:	0f 90       	pop	r0
    229a:	0b be       	out	0x3b, r0	; 59
    229c:	0f 90       	pop	r0
    229e:	0f be       	out	0x3f, r0	; 63
    22a0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22a2:	08 95       	ret

000022a4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22a4:	0f 92       	push	r0
    22a6:	0f b6       	in	r0, 0x3f	; 63
    22a8:	f8 94       	cli
    22aa:	0f 92       	push	r0
    22ac:	0b b6       	in	r0, 0x3b	; 59
    22ae:	0f 92       	push	r0
    22b0:	0c b6       	in	r0, 0x3c	; 60
    22b2:	0f 92       	push	r0
    22b4:	1f 92       	push	r1
    22b6:	11 24       	eor	r1, r1
    22b8:	2f 92       	push	r2
    22ba:	3f 92       	push	r3
    22bc:	4f 92       	push	r4
    22be:	5f 92       	push	r5
    22c0:	6f 92       	push	r6
    22c2:	7f 92       	push	r7
    22c4:	8f 92       	push	r8
    22c6:	9f 92       	push	r9
    22c8:	af 92       	push	r10
    22ca:	bf 92       	push	r11
    22cc:	cf 92       	push	r12
    22ce:	df 92       	push	r13
    22d0:	ef 92       	push	r14
    22d2:	ff 92       	push	r15
    22d4:	0f 93       	push	r16
    22d6:	1f 93       	push	r17
    22d8:	2f 93       	push	r18
    22da:	3f 93       	push	r19
    22dc:	4f 93       	push	r20
    22de:	5f 93       	push	r21
    22e0:	6f 93       	push	r22
    22e2:	7f 93       	push	r23
    22e4:	8f 93       	push	r24
    22e6:	9f 93       	push	r25
    22e8:	af 93       	push	r26
    22ea:	bf 93       	push	r27
    22ec:	cf 93       	push	r28
    22ee:	df 93       	push	r29
    22f0:	ef 93       	push	r30
    22f2:	ff 93       	push	r31
    22f4:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    22f8:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    22fc:	0d b6       	in	r0, 0x3d	; 61
    22fe:	0d 92       	st	X+, r0
    2300:	0e b6       	in	r0, 0x3e	; 62
    2302:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2304:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <vTaskIncrementTick>
	vTaskSwitchContext();
    2308:	0e 94 00 18 	call	0x3000	; 0x3000 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    230c:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    2310:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2314:	cd 91       	ld	r28, X+
    2316:	cd bf       	out	0x3d, r28	; 61
    2318:	dd 91       	ld	r29, X+
    231a:	de bf       	out	0x3e, r29	; 62
    231c:	ff 91       	pop	r31
    231e:	ef 91       	pop	r30
    2320:	df 91       	pop	r29
    2322:	cf 91       	pop	r28
    2324:	bf 91       	pop	r27
    2326:	af 91       	pop	r26
    2328:	9f 91       	pop	r25
    232a:	8f 91       	pop	r24
    232c:	7f 91       	pop	r23
    232e:	6f 91       	pop	r22
    2330:	5f 91       	pop	r21
    2332:	4f 91       	pop	r20
    2334:	3f 91       	pop	r19
    2336:	2f 91       	pop	r18
    2338:	1f 91       	pop	r17
    233a:	0f 91       	pop	r16
    233c:	ff 90       	pop	r15
    233e:	ef 90       	pop	r14
    2340:	df 90       	pop	r13
    2342:	cf 90       	pop	r12
    2344:	bf 90       	pop	r11
    2346:	af 90       	pop	r10
    2348:	9f 90       	pop	r9
    234a:	8f 90       	pop	r8
    234c:	7f 90       	pop	r7
    234e:	6f 90       	pop	r6
    2350:	5f 90       	pop	r5
    2352:	4f 90       	pop	r4
    2354:	3f 90       	pop	r3
    2356:	2f 90       	pop	r2
    2358:	1f 90       	pop	r1
    235a:	0f 90       	pop	r0
    235c:	0c be       	out	0x3c, r0	; 60
    235e:	0f 90       	pop	r0
    2360:	0b be       	out	0x3b, r0	; 59
    2362:	0f 90       	pop	r0
    2364:	0f be       	out	0x3f, r0	; 63
    2366:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2368:	08 95       	ret

0000236a <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    236a:	0e 94 52 11 	call	0x22a4	; 0x22a4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    236e:	18 95       	reti

00002370 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2370:	cf 93       	push	r28
    2372:	df 93       	push	r29
    2374:	ec 01       	movw	r28, r24
    2376:	88 a1       	ldd	r24, Y+32	; 0x20
    2378:	81 11       	cpse	r24, r1
    237a:	0b c0       	rjmp	.+22     	; 0x2392 <prvCopyDataToQueue+0x22>
    237c:	88 81       	ld	r24, Y
    237e:	99 81       	ldd	r25, Y+1	; 0x01
    2380:	89 2b       	or	r24, r25
    2382:	e1 f5       	brne	.+120    	; 0x23fc <prvCopyDataToQueue+0x8c>
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	9b 81       	ldd	r25, Y+3	; 0x03
    2388:	0e 94 bb 19 	call	0x3376	; 0x3376 <vTaskPriorityDisinherit>
    238c:	1a 82       	std	Y+2, r1	; 0x02
    238e:	1b 82       	std	Y+3, r1	; 0x03
    2390:	35 c0       	rjmp	.+106    	; 0x23fc <prvCopyDataToQueue+0x8c>
    2392:	41 11       	cpse	r20, r1
    2394:	17 c0       	rjmp	.+46     	; 0x23c4 <prvCopyDataToQueue+0x54>
    2396:	48 2f       	mov	r20, r24
    2398:	50 e0       	ldi	r21, 0x00	; 0
    239a:	8c 81       	ldd	r24, Y+4	; 0x04
    239c:	9d 81       	ldd	r25, Y+5	; 0x05
    239e:	0e 94 fa 26 	call	0x4df4	; 0x4df4 <memcpy>
    23a2:	28 a1       	ldd	r18, Y+32	; 0x20
    23a4:	8c 81       	ldd	r24, Y+4	; 0x04
    23a6:	9d 81       	ldd	r25, Y+5	; 0x05
    23a8:	82 0f       	add	r24, r18
    23aa:	91 1d       	adc	r25, r1
    23ac:	8c 83       	std	Y+4, r24	; 0x04
    23ae:	9d 83       	std	Y+5, r25	; 0x05
    23b0:	2a 81       	ldd	r18, Y+2	; 0x02
    23b2:	3b 81       	ldd	r19, Y+3	; 0x03
    23b4:	82 17       	cp	r24, r18
    23b6:	93 07       	cpc	r25, r19
    23b8:	08 f1       	brcs	.+66     	; 0x23fc <prvCopyDataToQueue+0x8c>
    23ba:	88 81       	ld	r24, Y
    23bc:	99 81       	ldd	r25, Y+1	; 0x01
    23be:	8c 83       	std	Y+4, r24	; 0x04
    23c0:	9d 83       	std	Y+5, r25	; 0x05
    23c2:	1c c0       	rjmp	.+56     	; 0x23fc <prvCopyDataToQueue+0x8c>
    23c4:	48 2f       	mov	r20, r24
    23c6:	50 e0       	ldi	r21, 0x00	; 0
    23c8:	8e 81       	ldd	r24, Y+6	; 0x06
    23ca:	9f 81       	ldd	r25, Y+7	; 0x07
    23cc:	0e 94 fa 26 	call	0x4df4	; 0x4df4 <memcpy>
    23d0:	88 a1       	ldd	r24, Y+32	; 0x20
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	91 95       	neg	r25
    23d6:	81 95       	neg	r24
    23d8:	91 09       	sbc	r25, r1
    23da:	2e 81       	ldd	r18, Y+6	; 0x06
    23dc:	3f 81       	ldd	r19, Y+7	; 0x07
    23de:	28 0f       	add	r18, r24
    23e0:	39 1f       	adc	r19, r25
    23e2:	2e 83       	std	Y+6, r18	; 0x06
    23e4:	3f 83       	std	Y+7, r19	; 0x07
    23e6:	48 81       	ld	r20, Y
    23e8:	59 81       	ldd	r21, Y+1	; 0x01
    23ea:	24 17       	cp	r18, r20
    23ec:	35 07       	cpc	r19, r21
    23ee:	30 f4       	brcc	.+12     	; 0x23fc <prvCopyDataToQueue+0x8c>
    23f0:	2a 81       	ldd	r18, Y+2	; 0x02
    23f2:	3b 81       	ldd	r19, Y+3	; 0x03
    23f4:	82 0f       	add	r24, r18
    23f6:	93 1f       	adc	r25, r19
    23f8:	8e 83       	std	Y+6, r24	; 0x06
    23fa:	9f 83       	std	Y+7, r25	; 0x07
    23fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23fe:	8f 5f       	subi	r24, 0xFF	; 255
    2400:	8e 8f       	std	Y+30, r24	; 0x1e
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	08 95       	ret

00002408 <prvCopyDataFromQueue>:
    2408:	fc 01       	movw	r30, r24
    240a:	80 81       	ld	r24, Z
    240c:	91 81       	ldd	r25, Z+1	; 0x01
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	a1 f0       	breq	.+40     	; 0x243a <prvCopyDataFromQueue+0x32>
    2412:	40 a1       	ldd	r20, Z+32	; 0x20
    2414:	50 e0       	ldi	r21, 0x00	; 0
    2416:	26 81       	ldd	r18, Z+6	; 0x06
    2418:	37 81       	ldd	r19, Z+7	; 0x07
    241a:	24 0f       	add	r18, r20
    241c:	35 1f       	adc	r19, r21
    241e:	26 83       	std	Z+6, r18	; 0x06
    2420:	37 83       	std	Z+7, r19	; 0x07
    2422:	a2 81       	ldd	r26, Z+2	; 0x02
    2424:	b3 81       	ldd	r27, Z+3	; 0x03
    2426:	2a 17       	cp	r18, r26
    2428:	3b 07       	cpc	r19, r27
    242a:	10 f0       	brcs	.+4      	; 0x2430 <prvCopyDataFromQueue+0x28>
    242c:	86 83       	std	Z+6, r24	; 0x06
    242e:	97 83       	std	Z+7, r25	; 0x07
    2430:	cb 01       	movw	r24, r22
    2432:	66 81       	ldd	r22, Z+6	; 0x06
    2434:	77 81       	ldd	r23, Z+7	; 0x07
    2436:	0e 94 fa 26 	call	0x4df4	; 0x4df4 <memcpy>
    243a:	08 95       	ret

0000243c <prvUnlockQueue>:
    243c:	0f 93       	push	r16
    243e:	1f 93       	push	r17
    2440:	cf 93       	push	r28
    2442:	df 93       	push	r29
    2444:	ec 01       	movw	r28, r24
    2446:	0f b6       	in	r0, 0x3f	; 63
    2448:	f8 94       	cli
    244a:	0f 92       	push	r0
    244c:	8a a1       	ldd	r24, Y+34	; 0x22
    244e:	18 16       	cp	r1, r24
    2450:	b4 f4       	brge	.+44     	; 0x247e <prvUnlockQueue+0x42>
    2452:	8b 89       	ldd	r24, Y+19	; 0x13
    2454:	81 11       	cpse	r24, r1
    2456:	05 c0       	rjmp	.+10     	; 0x2462 <prvUnlockQueue+0x26>
    2458:	12 c0       	rjmp	.+36     	; 0x247e <prvUnlockQueue+0x42>
    245a:	8b 89       	ldd	r24, Y+19	; 0x13
    245c:	81 11       	cpse	r24, r1
    245e:	04 c0       	rjmp	.+8      	; 0x2468 <prvUnlockQueue+0x2c>
    2460:	0e c0       	rjmp	.+28     	; 0x247e <prvUnlockQueue+0x42>
    2462:	8e 01       	movw	r16, r28
    2464:	0d 5e       	subi	r16, 0xED	; 237
    2466:	1f 4f       	sbci	r17, 0xFF	; 255
    2468:	c8 01       	movw	r24, r16
    246a:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    246e:	81 11       	cpse	r24, r1
    2470:	0e 94 44 19 	call	0x3288	; 0x3288 <vTaskMissedYield>
    2474:	8a a1       	ldd	r24, Y+34	; 0x22
    2476:	81 50       	subi	r24, 0x01	; 1
    2478:	8a a3       	std	Y+34, r24	; 0x22
    247a:	18 16       	cp	r1, r24
    247c:	74 f3       	brlt	.-36     	; 0x245a <prvUnlockQueue+0x1e>
    247e:	8f ef       	ldi	r24, 0xFF	; 255
    2480:	8a a3       	std	Y+34, r24	; 0x22
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63
    2486:	0f b6       	in	r0, 0x3f	; 63
    2488:	f8 94       	cli
    248a:	0f 92       	push	r0
    248c:	89 a1       	ldd	r24, Y+33	; 0x21
    248e:	18 16       	cp	r1, r24
    2490:	b4 f4       	brge	.+44     	; 0x24be <prvUnlockQueue+0x82>
    2492:	88 85       	ldd	r24, Y+8	; 0x08
    2494:	81 11       	cpse	r24, r1
    2496:	05 c0       	rjmp	.+10     	; 0x24a2 <prvUnlockQueue+0x66>
    2498:	12 c0       	rjmp	.+36     	; 0x24be <prvUnlockQueue+0x82>
    249a:	88 85       	ldd	r24, Y+8	; 0x08
    249c:	81 11       	cpse	r24, r1
    249e:	04 c0       	rjmp	.+8      	; 0x24a8 <prvUnlockQueue+0x6c>
    24a0:	0e c0       	rjmp	.+28     	; 0x24be <prvUnlockQueue+0x82>
    24a2:	8e 01       	movw	r16, r28
    24a4:	08 5f       	subi	r16, 0xF8	; 248
    24a6:	1f 4f       	sbci	r17, 0xFF	; 255
    24a8:	c8 01       	movw	r24, r16
    24aa:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    24ae:	81 11       	cpse	r24, r1
    24b0:	0e 94 44 19 	call	0x3288	; 0x3288 <vTaskMissedYield>
    24b4:	89 a1       	ldd	r24, Y+33	; 0x21
    24b6:	81 50       	subi	r24, 0x01	; 1
    24b8:	89 a3       	std	Y+33, r24	; 0x21
    24ba:	18 16       	cp	r1, r24
    24bc:	74 f3       	brlt	.-36     	; 0x249a <prvUnlockQueue+0x5e>
    24be:	8f ef       	ldi	r24, 0xFF	; 255
    24c0:	89 a3       	std	Y+33, r24	; 0x21
    24c2:	0f 90       	pop	r0
    24c4:	0f be       	out	0x3f, r0	; 63
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	1f 91       	pop	r17
    24cc:	0f 91       	pop	r16
    24ce:	08 95       	ret

000024d0 <xQueueGenericReset>:
    24d0:	1f 93       	push	r17
    24d2:	cf 93       	push	r28
    24d4:	df 93       	push	r29
    24d6:	61 30       	cpi	r22, 0x01	; 1
    24d8:	59 f0       	breq	.+22     	; 0x24f0 <xQueueGenericReset+0x20>
    24da:	fc 01       	movw	r30, r24
    24dc:	23 89       	ldd	r18, Z+19	; 0x13
    24de:	30 85       	ldd	r19, Z+8	; 0x08
    24e0:	31 11       	cpse	r19, r1
    24e2:	2c c0       	rjmp	.+88     	; 0x253c <xQueueGenericReset+0x6c>
    24e4:	11 e0       	ldi	r17, 0x01	; 1
    24e6:	21 11       	cpse	r18, r1
    24e8:	10 e0       	ldi	r17, 0x00	; 0
    24ea:	21 11       	cpse	r18, r1
    24ec:	28 c0       	rjmp	.+80     	; 0x253e <xQueueGenericReset+0x6e>
    24ee:	01 c0       	rjmp	.+2      	; 0x24f2 <xQueueGenericReset+0x22>
    24f0:	11 e0       	ldi	r17, 0x01	; 1
    24f2:	ec 01       	movw	r28, r24
    24f4:	48 81       	ld	r20, Y
    24f6:	59 81       	ldd	r21, Y+1	; 0x01
    24f8:	28 a1       	ldd	r18, Y+32	; 0x20
    24fa:	30 e0       	ldi	r19, 0x00	; 0
    24fc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    24fe:	62 9f       	mul	r22, r18
    2500:	c0 01       	movw	r24, r0
    2502:	63 9f       	mul	r22, r19
    2504:	90 0d       	add	r25, r0
    2506:	11 24       	eor	r1, r1
    2508:	ba 01       	movw	r22, r20
    250a:	68 0f       	add	r22, r24
    250c:	79 1f       	adc	r23, r25
    250e:	6a 83       	std	Y+2, r22	; 0x02
    2510:	7b 83       	std	Y+3, r23	; 0x03
    2512:	1e 8e       	std	Y+30, r1	; 0x1e
    2514:	4c 83       	std	Y+4, r20	; 0x04
    2516:	5d 83       	std	Y+5, r21	; 0x05
    2518:	82 1b       	sub	r24, r18
    251a:	93 0b       	sbc	r25, r19
    251c:	84 0f       	add	r24, r20
    251e:	95 1f       	adc	r25, r21
    2520:	8e 83       	std	Y+6, r24	; 0x06
    2522:	9f 83       	std	Y+7, r25	; 0x07
    2524:	8f ef       	ldi	r24, 0xFF	; 255
    2526:	89 a3       	std	Y+33, r24	; 0x21
    2528:	8a a3       	std	Y+34, r24	; 0x22
    252a:	ce 01       	movw	r24, r28
    252c:	08 96       	adiw	r24, 0x08	; 8
    252e:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2532:	ce 01       	movw	r24, r28
    2534:	43 96       	adiw	r24, 0x13	; 19
    2536:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    253a:	01 c0       	rjmp	.+2      	; 0x253e <xQueueGenericReset+0x6e>
    253c:	10 e0       	ldi	r17, 0x00	; 0
    253e:	81 2f       	mov	r24, r17
    2540:	df 91       	pop	r29
    2542:	cf 91       	pop	r28
    2544:	1f 91       	pop	r17
    2546:	08 95       	ret

00002548 <xQueueGenericCreate>:
    2548:	0f 93       	push	r16
    254a:	1f 93       	push	r17
    254c:	cf 93       	push	r28
    254e:	df 93       	push	r29
    2550:	88 23       	and	r24, r24
    2552:	01 f1       	breq	.+64     	; 0x2594 <xQueueGenericCreate+0x4c>
    2554:	06 2f       	mov	r16, r22
    2556:	18 2f       	mov	r17, r24
    2558:	83 e2       	ldi	r24, 0x23	; 35
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    2560:	ec 01       	movw	r28, r24
    2562:	89 2b       	or	r24, r25
    2564:	c9 f0       	breq	.+50     	; 0x2598 <xQueueGenericCreate+0x50>
    2566:	10 9f       	mul	r17, r16
    2568:	c0 01       	movw	r24, r0
    256a:	11 24       	eor	r1, r1
    256c:	01 96       	adiw	r24, 0x01	; 1
    256e:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    2572:	88 83       	st	Y, r24
    2574:	99 83       	std	Y+1, r25	; 0x01
    2576:	89 2b       	or	r24, r25
    2578:	39 f0       	breq	.+14     	; 0x2588 <xQueueGenericCreate+0x40>
    257a:	1f 8f       	std	Y+31, r17	; 0x1f
    257c:	08 a3       	std	Y+32, r16	; 0x20
    257e:	61 e0       	ldi	r22, 0x01	; 1
    2580:	ce 01       	movw	r24, r28
    2582:	0e 94 68 12 	call	0x24d0	; 0x24d0 <xQueueGenericReset>
    2586:	08 c0       	rjmp	.+16     	; 0x2598 <xQueueGenericCreate+0x50>
    2588:	ce 01       	movw	r24, r28
    258a:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vPortFree>
    258e:	c0 e0       	ldi	r28, 0x00	; 0
    2590:	d0 e0       	ldi	r29, 0x00	; 0
    2592:	02 c0       	rjmp	.+4      	; 0x2598 <xQueueGenericCreate+0x50>
    2594:	c0 e0       	ldi	r28, 0x00	; 0
    2596:	d0 e0       	ldi	r29, 0x00	; 0
    2598:	ce 01       	movw	r24, r28
    259a:	df 91       	pop	r29
    259c:	cf 91       	pop	r28
    259e:	1f 91       	pop	r17
    25a0:	0f 91       	pop	r16
    25a2:	08 95       	ret

000025a4 <xQueueGenericSend>:
    25a4:	af 92       	push	r10
    25a6:	bf 92       	push	r11
    25a8:	cf 92       	push	r12
    25aa:	df 92       	push	r13
    25ac:	ef 92       	push	r14
    25ae:	ff 92       	push	r15
    25b0:	0f 93       	push	r16
    25b2:	1f 93       	push	r17
    25b4:	cf 93       	push	r28
    25b6:	df 93       	push	r29
    25b8:	cd b7       	in	r28, 0x3d	; 61
    25ba:	de b7       	in	r29, 0x3e	; 62
    25bc:	29 97       	sbiw	r28, 0x09	; 9
    25be:	cd bf       	out	0x3d, r28	; 61
    25c0:	de bf       	out	0x3e, r29	; 62
    25c2:	7c 01       	movw	r14, r24
    25c4:	5b 01       	movw	r10, r22
    25c6:	2e 83       	std	Y+6, r18	; 0x06
    25c8:	3f 83       	std	Y+7, r19	; 0x07
    25ca:	48 87       	std	Y+8, r20	; 0x08
    25cc:	59 87       	std	Y+9, r21	; 0x09
    25ce:	10 e0       	ldi	r17, 0x00	; 0
    25d0:	6c 01       	movw	r12, r24
    25d2:	88 e0       	ldi	r24, 0x08	; 8
    25d4:	c8 0e       	add	r12, r24
    25d6:	d1 1c       	adc	r13, r1
    25d8:	0f b6       	in	r0, 0x3f	; 63
    25da:	f8 94       	cli
    25dc:	0f 92       	push	r0
    25de:	f7 01       	movw	r30, r14
    25e0:	96 8d       	ldd	r25, Z+30	; 0x1e
    25e2:	87 8d       	ldd	r24, Z+31	; 0x1f
    25e4:	98 17       	cp	r25, r24
    25e6:	a8 f4       	brcc	.+42     	; 0x2612 <xQueueGenericSend+0x6e>
    25e8:	40 2f       	mov	r20, r16
    25ea:	b5 01       	movw	r22, r10
    25ec:	c7 01       	movw	r24, r14
    25ee:	0e 94 b8 11 	call	0x2370	; 0x2370 <prvCopyDataToQueue>
    25f2:	f7 01       	movw	r30, r14
    25f4:	83 89       	ldd	r24, Z+19	; 0x13
    25f6:	88 23       	and	r24, r24
    25f8:	41 f0       	breq	.+16     	; 0x260a <xQueueGenericSend+0x66>
    25fa:	c7 01       	movw	r24, r14
    25fc:	43 96       	adiw	r24, 0x13	; 19
    25fe:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    2602:	81 30       	cpi	r24, 0x01	; 1
    2604:	11 f4       	brne	.+4      	; 0x260a <xQueueGenericSend+0x66>
    2606:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    260a:	0f 90       	pop	r0
    260c:	0f be       	out	0x3f, r0	; 63
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	56 c0       	rjmp	.+172    	; 0x26be <xQueueGenericSend+0x11a>
    2612:	8e 81       	ldd	r24, Y+6	; 0x06
    2614:	9f 81       	ldd	r25, Y+7	; 0x07
    2616:	a8 85       	ldd	r26, Y+8	; 0x08
    2618:	b9 85       	ldd	r27, Y+9	; 0x09
    261a:	89 2b       	or	r24, r25
    261c:	8a 2b       	or	r24, r26
    261e:	8b 2b       	or	r24, r27
    2620:	21 f4       	brne	.+8      	; 0x262a <xQueueGenericSend+0x86>
    2622:	0f 90       	pop	r0
    2624:	0f be       	out	0x3f, r0	; 63
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	4a c0       	rjmp	.+148    	; 0x26be <xQueueGenericSend+0x11a>
    262a:	11 11       	cpse	r17, r1
    262c:	05 c0       	rjmp	.+10     	; 0x2638 <xQueueGenericSend+0x94>
    262e:	ce 01       	movw	r24, r28
    2630:	01 96       	adiw	r24, 0x01	; 1
    2632:	0e 94 c6 18 	call	0x318c	; 0x318c <vTaskSetTimeOutState>
    2636:	11 e0       	ldi	r17, 0x01	; 1
    2638:	0f 90       	pop	r0
    263a:	0f be       	out	0x3f, r0	; 63
    263c:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vTaskSuspendAll>
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	f8 94       	cli
    2644:	0f 92       	push	r0
    2646:	f7 01       	movw	r30, r14
    2648:	81 a1       	ldd	r24, Z+33	; 0x21
    264a:	8f 3f       	cpi	r24, 0xFF	; 255
    264c:	09 f4       	brne	.+2      	; 0x2650 <xQueueGenericSend+0xac>
    264e:	11 a2       	std	Z+33, r1	; 0x21
    2650:	f7 01       	movw	r30, r14
    2652:	82 a1       	ldd	r24, Z+34	; 0x22
    2654:	8f 3f       	cpi	r24, 0xFF	; 255
    2656:	09 f4       	brne	.+2      	; 0x265a <xQueueGenericSend+0xb6>
    2658:	12 a2       	std	Z+34, r1	; 0x22
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
    265e:	be 01       	movw	r22, r28
    2660:	6a 5f       	subi	r22, 0xFA	; 250
    2662:	7f 4f       	sbci	r23, 0xFF	; 255
    2664:	ce 01       	movw	r24, r28
    2666:	01 96       	adiw	r24, 0x01	; 1
    2668:	0e 94 d7 18 	call	0x31ae	; 0x31ae <xTaskCheckForTimeOut>
    266c:	81 11       	cpse	r24, r1
    266e:	21 c0       	rjmp	.+66     	; 0x26b2 <xQueueGenericSend+0x10e>
    2670:	0f b6       	in	r0, 0x3f	; 63
    2672:	f8 94       	cli
    2674:	0f 92       	push	r0
    2676:	f7 01       	movw	r30, r14
    2678:	96 8d       	ldd	r25, Z+30	; 0x1e
    267a:	0f 90       	pop	r0
    267c:	0f be       	out	0x3f, r0	; 63
    267e:	87 8d       	ldd	r24, Z+31	; 0x1f
    2680:	98 13       	cpse	r25, r24
    2682:	11 c0       	rjmp	.+34     	; 0x26a6 <xQueueGenericSend+0x102>
    2684:	4e 81       	ldd	r20, Y+6	; 0x06
    2686:	5f 81       	ldd	r21, Y+7	; 0x07
    2688:	68 85       	ldd	r22, Y+8	; 0x08
    268a:	79 85       	ldd	r23, Y+9	; 0x09
    268c:	c6 01       	movw	r24, r12
    268e:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskPlaceOnEventList>
    2692:	c7 01       	movw	r24, r14
    2694:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
    2698:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
    269c:	81 11       	cpse	r24, r1
    269e:	9c cf       	rjmp	.-200    	; 0x25d8 <xQueueGenericSend+0x34>
    26a0:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    26a4:	99 cf       	rjmp	.-206    	; 0x25d8 <xQueueGenericSend+0x34>
    26a6:	c7 01       	movw	r24, r14
    26a8:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
    26ac:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
    26b0:	93 cf       	rjmp	.-218    	; 0x25d8 <xQueueGenericSend+0x34>
    26b2:	c7 01       	movw	r24, r14
    26b4:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
    26b8:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	29 96       	adiw	r28, 0x09	; 9
    26c0:	cd bf       	out	0x3d, r28	; 61
    26c2:	de bf       	out	0x3e, r29	; 62
    26c4:	df 91       	pop	r29
    26c6:	cf 91       	pop	r28
    26c8:	1f 91       	pop	r17
    26ca:	0f 91       	pop	r16
    26cc:	ff 90       	pop	r15
    26ce:	ef 90       	pop	r14
    26d0:	df 90       	pop	r13
    26d2:	cf 90       	pop	r12
    26d4:	bf 90       	pop	r11
    26d6:	af 90       	pop	r10
    26d8:	08 95       	ret

000026da <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    26da:	0f 93       	push	r16
    26dc:	1f 93       	push	r17
    26de:	cf 93       	push	r28
    26e0:	df 93       	push	r29
    26e2:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    26e4:	fc 01       	movw	r30, r24
    26e6:	56 8d       	ldd	r21, Z+30	; 0x1e
    26e8:	37 8d       	ldd	r19, Z+31	; 0x1f
    26ea:	53 17       	cp	r21, r19
    26ec:	c0 f4       	brcc	.+48     	; 0x271e <xQueueGenericSendFromISR+0x44>
    26ee:	42 2f       	mov	r20, r18
    26f0:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26f2:	0e 94 b8 11 	call	0x2370	; 0x2370 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    26f6:	8a a1       	ldd	r24, Y+34	; 0x22
    26f8:	8f 3f       	cpi	r24, 0xFF	; 255
    26fa:	69 f4       	brne	.+26     	; 0x2716 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26fc:	8b 89       	ldd	r24, Y+19	; 0x13
    26fe:	88 23       	and	r24, r24
    2700:	81 f0       	breq	.+32     	; 0x2722 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2702:	ce 01       	movw	r24, r28
    2704:	43 96       	adiw	r24, 0x13	; 19
    2706:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    270a:	88 23       	and	r24, r24
    270c:	61 f0       	breq	.+24     	; 0x2726 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    270e:	81 e0       	ldi	r24, 0x01	; 1
    2710:	f8 01       	movw	r30, r16
    2712:	80 83       	st	Z, r24
    2714:	09 c0       	rjmp	.+18     	; 0x2728 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2716:	8f 5f       	subi	r24, 0xFF	; 255
    2718:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	05 c0       	rjmp	.+10     	; 0x2728 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    271e:	80 e0       	ldi	r24, 0x00	; 0
    2720:	03 c0       	rjmp	.+6      	; 0x2728 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2722:	81 e0       	ldi	r24, 0x01	; 1
    2724:	01 c0       	rjmp	.+2      	; 0x2728 <xQueueGenericSendFromISR+0x4e>
    2726:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2728:	df 91       	pop	r29
    272a:	cf 91       	pop	r28
    272c:	1f 91       	pop	r17
    272e:	0f 91       	pop	r16
    2730:	08 95       	ret

00002732 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2732:	af 92       	push	r10
    2734:	bf 92       	push	r11
    2736:	cf 92       	push	r12
    2738:	df 92       	push	r13
    273a:	ef 92       	push	r14
    273c:	ff 92       	push	r15
    273e:	0f 93       	push	r16
    2740:	1f 93       	push	r17
    2742:	cf 93       	push	r28
    2744:	df 93       	push	r29
    2746:	cd b7       	in	r28, 0x3d	; 61
    2748:	de b7       	in	r29, 0x3e	; 62
    274a:	29 97       	sbiw	r28, 0x09	; 9
    274c:	cd bf       	out	0x3d, r28	; 61
    274e:	de bf       	out	0x3e, r29	; 62
    2750:	7c 01       	movw	r14, r24
    2752:	5b 01       	movw	r10, r22
    2754:	2e 83       	std	Y+6, r18	; 0x06
    2756:	3f 83       	std	Y+7, r19	; 0x07
    2758:	48 87       	std	Y+8, r20	; 0x08
    275a:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    275c:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    275e:	6c 01       	movw	r12, r24
    2760:	83 e1       	ldi	r24, 0x13	; 19
    2762:	c8 0e       	add	r12, r24
    2764:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2766:	0f b6       	in	r0, 0x3f	; 63
    2768:	f8 94       	cli
    276a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    276c:	f7 01       	movw	r30, r14
    276e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2770:	88 23       	and	r24, r24
    2772:	99 f1       	breq	.+102    	; 0x27da <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2774:	c6 80       	ldd	r12, Z+6	; 0x06
    2776:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2778:	b5 01       	movw	r22, r10
    277a:	c7 01       	movw	r24, r14
    277c:	0e 94 04 12 	call	0x2408	; 0x2408 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2780:	01 11       	cpse	r16, r1
    2782:	1a c0       	rjmp	.+52     	; 0x27b8 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2784:	f7 01       	movw	r30, r14
    2786:	86 8d       	ldd	r24, Z+30	; 0x1e
    2788:	81 50       	subi	r24, 0x01	; 1
    278a:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    278c:	80 81       	ld	r24, Z
    278e:	91 81       	ldd	r25, Z+1	; 0x01
    2790:	89 2b       	or	r24, r25
    2792:	29 f4       	brne	.+10     	; 0x279e <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2794:	0e 94 61 19 	call	0x32c2	; 0x32c2 <xTaskGetCurrentTaskHandle>
    2798:	f7 01       	movw	r30, r14
    279a:	82 83       	std	Z+2, r24	; 0x02
    279c:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    279e:	f7 01       	movw	r30, r14
    27a0:	80 85       	ldd	r24, Z+8	; 0x08
    27a2:	88 23       	and	r24, r24
    27a4:	b1 f0       	breq	.+44     	; 0x27d2 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    27a6:	c7 01       	movw	r24, r14
    27a8:	08 96       	adiw	r24, 0x08	; 8
    27aa:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    27ae:	81 30       	cpi	r24, 0x01	; 1
    27b0:	81 f4       	brne	.+32     	; 0x27d2 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    27b2:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    27b6:	0d c0       	rjmp	.+26     	; 0x27d2 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    27b8:	f7 01       	movw	r30, r14
    27ba:	c6 82       	std	Z+6, r12	; 0x06
    27bc:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27be:	83 89       	ldd	r24, Z+19	; 0x13
    27c0:	88 23       	and	r24, r24
    27c2:	39 f0       	breq	.+14     	; 0x27d2 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27c4:	c7 01       	movw	r24, r14
    27c6:	43 96       	adiw	r24, 0x13	; 19
    27c8:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    27cc:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    27ce:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    27d2:	0f 90       	pop	r0
    27d4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    27d6:	81 e0       	ldi	r24, 0x01	; 1
    27d8:	62 c0       	rjmp	.+196    	; 0x289e <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    27da:	8e 81       	ldd	r24, Y+6	; 0x06
    27dc:	9f 81       	ldd	r25, Y+7	; 0x07
    27de:	a8 85       	ldd	r26, Y+8	; 0x08
    27e0:	b9 85       	ldd	r27, Y+9	; 0x09
    27e2:	89 2b       	or	r24, r25
    27e4:	8a 2b       	or	r24, r26
    27e6:	8b 2b       	or	r24, r27
    27e8:	21 f4       	brne	.+8      	; 0x27f2 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    27ea:	0f 90       	pop	r0
    27ec:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    27ee:	80 e0       	ldi	r24, 0x00	; 0
    27f0:	56 c0       	rjmp	.+172    	; 0x289e <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    27f2:	11 11       	cpse	r17, r1
    27f4:	05 c0       	rjmp	.+10     	; 0x2800 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    27f6:	ce 01       	movw	r24, r28
    27f8:	01 96       	adiw	r24, 0x01	; 1
    27fa:	0e 94 c6 18 	call	0x318c	; 0x318c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    27fe:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2800:	0f 90       	pop	r0
    2802:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2804:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	0f 92       	push	r0
    280e:	f7 01       	movw	r30, r14
    2810:	81 a1       	ldd	r24, Z+33	; 0x21
    2812:	8f 3f       	cpi	r24, 0xFF	; 255
    2814:	09 f4       	brne	.+2      	; 0x2818 <xQueueGenericReceive+0xe6>
    2816:	11 a2       	std	Z+33, r1	; 0x21
    2818:	f7 01       	movw	r30, r14
    281a:	82 a1       	ldd	r24, Z+34	; 0x22
    281c:	8f 3f       	cpi	r24, 0xFF	; 255
    281e:	09 f4       	brne	.+2      	; 0x2822 <xQueueGenericReceive+0xf0>
    2820:	12 a2       	std	Z+34, r1	; 0x22
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2826:	be 01       	movw	r22, r28
    2828:	6a 5f       	subi	r22, 0xFA	; 250
    282a:	7f 4f       	sbci	r23, 0xFF	; 255
    282c:	ce 01       	movw	r24, r28
    282e:	01 96       	adiw	r24, 0x01	; 1
    2830:	0e 94 d7 18 	call	0x31ae	; 0x31ae <xTaskCheckForTimeOut>
    2834:	81 11       	cpse	r24, r1
    2836:	2d c0       	rjmp	.+90     	; 0x2892 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2838:	0f b6       	in	r0, 0x3f	; 63
    283a:	f8 94       	cli
    283c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    283e:	f7 01       	movw	r30, r14
    2840:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2842:	0f 90       	pop	r0
    2844:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2846:	81 11       	cpse	r24, r1
    2848:	1e c0       	rjmp	.+60     	; 0x2886 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    284a:	80 81       	ld	r24, Z
    284c:	91 81       	ldd	r25, Z+1	; 0x01
    284e:	89 2b       	or	r24, r25
    2850:	49 f4       	brne	.+18     	; 0x2864 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2852:	0f b6       	in	r0, 0x3f	; 63
    2854:	f8 94       	cli
    2856:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2858:	82 81       	ldd	r24, Z+2	; 0x02
    285a:	93 81       	ldd	r25, Z+3	; 0x03
    285c:	0e 94 66 19 	call	0x32cc	; 0x32cc <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2864:	4e 81       	ldd	r20, Y+6	; 0x06
    2866:	5f 81       	ldd	r21, Y+7	; 0x07
    2868:	68 85       	ldd	r22, Y+8	; 0x08
    286a:	79 85       	ldd	r23, Y+9	; 0x09
    286c:	c6 01       	movw	r24, r12
    286e:	0e 94 5d 18 	call	0x30ba	; 0x30ba <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2872:	c7 01       	movw	r24, r14
    2874:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2878:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
    287c:	81 11       	cpse	r24, r1
    287e:	73 cf       	rjmp	.-282    	; 0x2766 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2880:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    2884:	70 cf       	rjmp	.-288    	; 0x2766 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2886:	c7 01       	movw	r24, r14
    2888:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    288c:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
    2890:	6a cf       	rjmp	.-300    	; 0x2766 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2892:	c7 01       	movw	r24, r14
    2894:	0e 94 1e 12 	call	0x243c	; 0x243c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2898:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    289c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    289e:	29 96       	adiw	r28, 0x09	; 9
    28a0:	cd bf       	out	0x3d, r28	; 61
    28a2:	de bf       	out	0x3e, r29	; 62
    28a4:	df 91       	pop	r29
    28a6:	cf 91       	pop	r28
    28a8:	1f 91       	pop	r17
    28aa:	0f 91       	pop	r16
    28ac:	ff 90       	pop	r15
    28ae:	ef 90       	pop	r14
    28b0:	df 90       	pop	r13
    28b2:	cf 90       	pop	r12
    28b4:	bf 90       	pop	r11
    28b6:	af 90       	pop	r10
    28b8:	08 95       	ret

000028ba <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    28ba:	0f 93       	push	r16
    28bc:	1f 93       	push	r17
    28be:	cf 93       	push	r28
    28c0:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    28c2:	fc 01       	movw	r30, r24
    28c4:	26 8d       	ldd	r18, Z+30	; 0x1e
    28c6:	22 23       	and	r18, r18
    28c8:	d9 f0       	breq	.+54     	; 0x2900 <xQueueReceiveFromISR+0x46>
    28ca:	8a 01       	movw	r16, r20
    28cc:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    28ce:	0e 94 04 12 	call	0x2408	; 0x2408 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    28d2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    28d4:	81 50       	subi	r24, 0x01	; 1
    28d6:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    28d8:	89 a1       	ldd	r24, Y+33	; 0x21
    28da:	8f 3f       	cpi	r24, 0xFF	; 255
    28dc:	69 f4       	brne	.+26     	; 0x28f8 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28de:	88 85       	ldd	r24, Y+8	; 0x08
    28e0:	88 23       	and	r24, r24
    28e2:	81 f0       	breq	.+32     	; 0x2904 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28e4:	ce 01       	movw	r24, r28
    28e6:	08 96       	adiw	r24, 0x08	; 8
    28e8:	0e 94 87 18 	call	0x310e	; 0x310e <xTaskRemoveFromEventList>
    28ec:	88 23       	and	r24, r24
    28ee:	61 f0       	breq	.+24     	; 0x2908 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    28f0:	81 e0       	ldi	r24, 0x01	; 1
    28f2:	f8 01       	movw	r30, r16
    28f4:	80 83       	st	Z, r24
    28f6:	09 c0       	rjmp	.+18     	; 0x290a <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    28f8:	8f 5f       	subi	r24, 0xFF	; 255
    28fa:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    28fc:	81 e0       	ldi	r24, 0x01	; 1
    28fe:	05 c0       	rjmp	.+10     	; 0x290a <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2900:	80 e0       	ldi	r24, 0x00	; 0
    2902:	03 c0       	rjmp	.+6      	; 0x290a <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2904:	81 e0       	ldi	r24, 0x01	; 1
    2906:	01 c0       	rjmp	.+2      	; 0x290a <xQueueReceiveFromISR+0x50>
    2908:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    290a:	df 91       	pop	r29
    290c:	cf 91       	pop	r28
    290e:	1f 91       	pop	r17
    2910:	0f 91       	pop	r16
    2912:	08 95       	ret

00002914 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2914:	0f b6       	in	r0, 0x3f	; 63
    2916:	f8 94       	cli
    2918:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    291a:	fc 01       	movw	r30, r24
    291c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    291e:	0f 90       	pop	r0
    2920:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2922:	08 95       	ret

00002924 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2924:	fc 01       	movw	r30, r24
    2926:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    2928:	08 95       	ret

0000292a <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    292a:	c2 e7       	ldi	r28, 0x72	; 114
    292c:	d2 e3       	ldi	r29, 0x32	; 50
    292e:	88 81       	ld	r24, Y
    2930:	82 30       	cpi	r24, 0x02	; 2
    2932:	e8 f3       	brcs	.-6      	; 0x292e <prvIdleTask+0x4>
    2934:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    2938:	fa cf       	rjmp	.-12     	; 0x292e <prvIdleTask+0x4>

0000293a <prvAddCurrentTaskToDelayedList>:
    293a:	cf 92       	push	r12
    293c:	df 92       	push	r13
    293e:	ef 92       	push	r14
    2940:	ff 92       	push	r15
    2942:	6b 01       	movw	r12, r22
    2944:	7c 01       	movw	r14, r24
    2946:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    294a:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    294e:	62 83       	std	Z+2, r22	; 0x02
    2950:	73 83       	std	Z+3, r23	; 0x03
    2952:	84 83       	std	Z+4, r24	; 0x04
    2954:	95 83       	std	Z+5, r25	; 0x05
    2956:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    295a:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    295e:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2962:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2966:	c8 16       	cp	r12, r24
    2968:	d9 06       	cpc	r13, r25
    296a:	ea 06       	cpc	r14, r26
    296c:	fb 06       	cpc	r15, r27
    296e:	68 f4       	brcc	.+26     	; 0x298a <prvAddCurrentTaskToDelayedList+0x50>
    2970:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    2974:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2978:	80 91 58 32 	lds	r24, 0x3258	; 0x803258 <pxOverflowDelayedTaskList>
    297c:	90 91 59 32 	lds	r25, 0x3259	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2980:	6e 5f       	subi	r22, 0xFE	; 254
    2982:	7f 4f       	sbci	r23, 0xFF	; 255
    2984:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <vListInsert>
    2988:	21 c0       	rjmp	.+66     	; 0x29cc <prvAddCurrentTaskToDelayedList+0x92>
    298a:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    298e:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2992:	80 91 5a 32 	lds	r24, 0x325A	; 0x80325a <pxDelayedTaskList>
    2996:	90 91 5b 32 	lds	r25, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    299a:	6e 5f       	subi	r22, 0xFE	; 254
    299c:	7f 4f       	sbci	r23, 0xFF	; 255
    299e:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <vListInsert>
    29a2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    29a6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    29aa:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    29ae:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    29b2:	c8 16       	cp	r12, r24
    29b4:	d9 06       	cpc	r13, r25
    29b6:	ea 06       	cpc	r14, r26
    29b8:	fb 06       	cpc	r15, r27
    29ba:	40 f4       	brcc	.+16     	; 0x29cc <prvAddCurrentTaskToDelayedList+0x92>
    29bc:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    29c0:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    29c4:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    29c8:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    29cc:	ff 90       	pop	r15
    29ce:	ef 90       	pop	r14
    29d0:	df 90       	pop	r13
    29d2:	cf 90       	pop	r12
    29d4:	08 95       	ret

000029d6 <xTaskGenericCreate>:
    29d6:	4f 92       	push	r4
    29d8:	5f 92       	push	r5
    29da:	6f 92       	push	r6
    29dc:	7f 92       	push	r7
    29de:	8f 92       	push	r8
    29e0:	9f 92       	push	r9
    29e2:	af 92       	push	r10
    29e4:	bf 92       	push	r11
    29e6:	cf 92       	push	r12
    29e8:	df 92       	push	r13
    29ea:	ef 92       	push	r14
    29ec:	ff 92       	push	r15
    29ee:	0f 93       	push	r16
    29f0:	1f 93       	push	r17
    29f2:	cf 93       	push	r28
    29f4:	df 93       	push	r29
    29f6:	5c 01       	movw	r10, r24
    29f8:	4b 01       	movw	r8, r22
    29fa:	3a 01       	movw	r6, r20
    29fc:	29 01       	movw	r4, r18
    29fe:	88 e2       	ldi	r24, 0x28	; 40
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    2a06:	ec 01       	movw	r28, r24
    2a08:	89 2b       	or	r24, r25
    2a0a:	09 f4       	brne	.+2      	; 0x2a0e <xTaskGenericCreate+0x38>
    2a0c:	d4 c0       	rjmp	.+424    	; 0x2bb6 <xTaskGenericCreate+0x1e0>
    2a0e:	c1 14       	cp	r12, r1
    2a10:	d1 04       	cpc	r13, r1
    2a12:	09 f0       	breq	.+2      	; 0x2a16 <xTaskGenericCreate+0x40>
    2a14:	cc c0       	rjmp	.+408    	; 0x2bae <xTaskGenericCreate+0x1d8>
    2a16:	c3 01       	movw	r24, r6
    2a18:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    2a1c:	8b 8f       	std	Y+27, r24	; 0x1b
    2a1e:	9c 8f       	std	Y+28, r25	; 0x1c
    2a20:	00 97       	sbiw	r24, 0x00	; 0
    2a22:	21 f4       	brne	.+8      	; 0x2a2c <xTaskGenericCreate+0x56>
    2a24:	ce 01       	movw	r24, r28
    2a26:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <vPortFree>
    2a2a:	c5 c0       	rjmp	.+394    	; 0x2bb6 <xTaskGenericCreate+0x1e0>
    2a2c:	a3 01       	movw	r20, r6
    2a2e:	61 e1       	ldi	r22, 0x11	; 17
    2a30:	70 e0       	ldi	r23, 0x00	; 0
    2a32:	0e 94 03 27 	call	0x4e06	; 0x4e06 <memset>
    2a36:	93 01       	movw	r18, r6
    2a38:	21 50       	subi	r18, 0x01	; 1
    2a3a:	31 09       	sbc	r19, r1
    2a3c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a3e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a40:	3c 01       	movw	r6, r24
    2a42:	62 0e       	add	r6, r18
    2a44:	73 1e       	adc	r7, r19
    2a46:	4a e0       	ldi	r20, 0x0A	; 10
    2a48:	50 e0       	ldi	r21, 0x00	; 0
    2a4a:	b4 01       	movw	r22, r8
    2a4c:	ce 01       	movw	r24, r28
    2a4e:	4d 96       	adiw	r24, 0x1d	; 29
    2a50:	0e 94 0a 27 	call	0x4e14	; 0x4e14 <strncpy>
    2a54:	1e a2       	std	Y+38, r1	; 0x26
    2a56:	10 2f       	mov	r17, r16
    2a58:	04 30       	cpi	r16, 0x04	; 4
    2a5a:	08 f0       	brcs	.+2      	; 0x2a5e <xTaskGenericCreate+0x88>
    2a5c:	13 e0       	ldi	r17, 0x03	; 3
    2a5e:	1a 8f       	std	Y+26, r17	; 0x1a
    2a60:	1f a3       	std	Y+39, r17	; 0x27
    2a62:	6e 01       	movw	r12, r28
    2a64:	22 e0       	ldi	r18, 0x02	; 2
    2a66:	c2 0e       	add	r12, r18
    2a68:	d1 1c       	adc	r13, r1
    2a6a:	c6 01       	movw	r24, r12
    2a6c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialiseItem>
    2a70:	ce 01       	movw	r24, r28
    2a72:	0e 96       	adiw	r24, 0x0e	; 14
    2a74:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialiseItem>
    2a78:	ca 87       	std	Y+10, r28	; 0x0a
    2a7a:	db 87       	std	Y+11, r29	; 0x0b
    2a7c:	84 e0       	ldi	r24, 0x04	; 4
    2a7e:	90 e0       	ldi	r25, 0x00	; 0
    2a80:	a0 e0       	ldi	r26, 0x00	; 0
    2a82:	b0 e0       	ldi	r27, 0x00	; 0
    2a84:	81 1b       	sub	r24, r17
    2a86:	91 09       	sbc	r25, r1
    2a88:	a1 09       	sbc	r26, r1
    2a8a:	b1 09       	sbc	r27, r1
    2a8c:	8e 87       	std	Y+14, r24	; 0x0e
    2a8e:	9f 87       	std	Y+15, r25	; 0x0f
    2a90:	a8 8b       	std	Y+16, r26	; 0x10
    2a92:	b9 8b       	std	Y+17, r27	; 0x11
    2a94:	ce 8b       	std	Y+22, r28	; 0x16
    2a96:	df 8b       	std	Y+23, r29	; 0x17
    2a98:	a2 01       	movw	r20, r4
    2a9a:	b5 01       	movw	r22, r10
    2a9c:	c3 01       	movw	r24, r6
    2a9e:	0e 94 3d 10 	call	0x207a	; 0x207a <pxPortInitialiseStack>
    2aa2:	88 83       	st	Y, r24
    2aa4:	99 83       	std	Y+1, r25	; 0x01
    2aa6:	e1 14       	cp	r14, r1
    2aa8:	f1 04       	cpc	r15, r1
    2aaa:	19 f0       	breq	.+6      	; 0x2ab2 <xTaskGenericCreate+0xdc>
    2aac:	f7 01       	movw	r30, r14
    2aae:	c0 83       	st	Z, r28
    2ab0:	d1 83       	std	Z+1, r29	; 0x01
    2ab2:	0f b6       	in	r0, 0x3f	; 63
    2ab4:	f8 94       	cli
    2ab6:	0f 92       	push	r0
    2ab8:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2abc:	8f 5f       	subi	r24, 0xFF	; 255
    2abe:	80 93 4a 32 	sts	0x324A, r24	; 0x80324a <uxCurrentNumberOfTasks>
    2ac2:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2ac6:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2aca:	89 2b       	or	r24, r25
    2acc:	89 f5       	brne	.+98     	; 0x2b30 <xTaskGenericCreate+0x15a>
    2ace:	c0 93 9e 32 	sts	0x329E, r28	; 0x80329e <pxCurrentTCB>
    2ad2:	d0 93 9f 32 	sts	0x329F, r29	; 0x80329f <pxCurrentTCB+0x1>
    2ad6:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2ada:	81 30       	cpi	r24, 0x01	; 1
    2adc:	c1 f5       	brne	.+112    	; 0x2b4e <xTaskGenericCreate+0x178>
    2ade:	82 e7       	ldi	r24, 0x72	; 114
    2ae0:	92 e3       	ldi	r25, 0x32	; 50
    2ae2:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2ae6:	8d e7       	ldi	r24, 0x7D	; 125
    2ae8:	92 e3       	ldi	r25, 0x32	; 50
    2aea:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2aee:	88 e8       	ldi	r24, 0x88	; 136
    2af0:	92 e3       	ldi	r25, 0x32	; 50
    2af2:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2af6:	83 e9       	ldi	r24, 0x93	; 147
    2af8:	92 e3       	ldi	r25, 0x32	; 50
    2afa:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2afe:	87 e6       	ldi	r24, 0x67	; 103
    2b00:	92 e3       	ldi	r25, 0x32	; 50
    2b02:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2b06:	8c e5       	ldi	r24, 0x5C	; 92
    2b08:	92 e3       	ldi	r25, 0x32	; 50
    2b0a:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2b0e:	8d e4       	ldi	r24, 0x4D	; 77
    2b10:	92 e3       	ldi	r25, 0x32	; 50
    2b12:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vListInitialise>
    2b16:	87 e6       	ldi	r24, 0x67	; 103
    2b18:	92 e3       	ldi	r25, 0x32	; 50
    2b1a:	80 93 5a 32 	sts	0x325A, r24	; 0x80325a <pxDelayedTaskList>
    2b1e:	90 93 5b 32 	sts	0x325B, r25	; 0x80325b <pxDelayedTaskList+0x1>
    2b22:	8c e5       	ldi	r24, 0x5C	; 92
    2b24:	92 e3       	ldi	r25, 0x32	; 50
    2b26:	80 93 58 32 	sts	0x3258, r24	; 0x803258 <pxOverflowDelayedTaskList>
    2b2a:	90 93 59 32 	sts	0x3259, r25	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2b2e:	0f c0       	rjmp	.+30     	; 0x2b4e <xTaskGenericCreate+0x178>
    2b30:	80 91 43 32 	lds	r24, 0x3243	; 0x803243 <xSchedulerRunning>
    2b34:	81 11       	cpse	r24, r1
    2b36:	0b c0       	rjmp	.+22     	; 0x2b4e <xTaskGenericCreate+0x178>
    2b38:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2b3c:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2b40:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b42:	08 17       	cp	r16, r24
    2b44:	20 f0       	brcs	.+8      	; 0x2b4e <xTaskGenericCreate+0x178>
    2b46:	c0 93 9e 32 	sts	0x329E, r28	; 0x80329e <pxCurrentTCB>
    2b4a:	d0 93 9f 32 	sts	0x329F, r29	; 0x80329f <pxCurrentTCB+0x1>
    2b4e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b50:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <uxTopUsedPriority>
    2b54:	98 17       	cp	r25, r24
    2b56:	10 f4       	brcc	.+4      	; 0x2b5c <xTaskGenericCreate+0x186>
    2b58:	80 93 45 32 	sts	0x3245, r24	; 0x803245 <uxTopUsedPriority>
    2b5c:	90 91 3e 32 	lds	r25, 0x323E	; 0x80323e <uxTaskNumber>
    2b60:	9f 5f       	subi	r25, 0xFF	; 255
    2b62:	90 93 3e 32 	sts	0x323E, r25	; 0x80323e <uxTaskNumber>
    2b66:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2b6a:	98 17       	cp	r25, r24
    2b6c:	10 f4       	brcc	.+4      	; 0x2b72 <xTaskGenericCreate+0x19c>
    2b6e:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2b72:	fb e0       	ldi	r31, 0x0B	; 11
    2b74:	8f 9f       	mul	r24, r31
    2b76:	c0 01       	movw	r24, r0
    2b78:	11 24       	eor	r1, r1
    2b7a:	b6 01       	movw	r22, r12
    2b7c:	8e 58       	subi	r24, 0x8E	; 142
    2b7e:	9d 4c       	sbci	r25, 0xCD	; 205
    2b80:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
    2b84:	0f 90       	pop	r0
    2b86:	0f be       	out	0x3f, r0	; 63
    2b88:	80 91 43 32 	lds	r24, 0x3243	; 0x803243 <xSchedulerRunning>
    2b8c:	88 23       	and	r24, r24
    2b8e:	59 f0       	breq	.+22     	; 0x2ba6 <xTaskGenericCreate+0x1d0>
    2b90:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2b94:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2b98:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b9a:	80 17       	cp	r24, r16
    2b9c:	30 f4       	brcc	.+12     	; 0x2baa <xTaskGenericCreate+0x1d4>
    2b9e:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    2ba2:	81 e0       	ldi	r24, 0x01	; 1
    2ba4:	09 c0       	rjmp	.+18     	; 0x2bb8 <xTaskGenericCreate+0x1e2>
    2ba6:	81 e0       	ldi	r24, 0x01	; 1
    2ba8:	07 c0       	rjmp	.+14     	; 0x2bb8 <xTaskGenericCreate+0x1e2>
    2baa:	81 e0       	ldi	r24, 0x01	; 1
    2bac:	05 c0       	rjmp	.+10     	; 0x2bb8 <xTaskGenericCreate+0x1e2>
    2bae:	cb 8e       	std	Y+27, r12	; 0x1b
    2bb0:	dc 8e       	std	Y+28, r13	; 0x1c
    2bb2:	c6 01       	movw	r24, r12
    2bb4:	3b cf       	rjmp	.-394    	; 0x2a2c <xTaskGenericCreate+0x56>
    2bb6:	8f ef       	ldi	r24, 0xFF	; 255
    2bb8:	df 91       	pop	r29
    2bba:	cf 91       	pop	r28
    2bbc:	1f 91       	pop	r17
    2bbe:	0f 91       	pop	r16
    2bc0:	ff 90       	pop	r15
    2bc2:	ef 90       	pop	r14
    2bc4:	df 90       	pop	r13
    2bc6:	cf 90       	pop	r12
    2bc8:	bf 90       	pop	r11
    2bca:	af 90       	pop	r10
    2bcc:	9f 90       	pop	r9
    2bce:	8f 90       	pop	r8
    2bd0:	7f 90       	pop	r7
    2bd2:	6f 90       	pop	r6
    2bd4:	5f 90       	pop	r5
    2bd6:	4f 90       	pop	r4
    2bd8:	08 95       	ret

00002bda <uxTaskPriorityGet>:
    2bda:	0f b6       	in	r0, 0x3f	; 63
    2bdc:	f8 94       	cli
    2bde:	0f 92       	push	r0
    2be0:	00 97       	sbiw	r24, 0x00	; 0
    2be2:	21 f4       	brne	.+8      	; 0x2bec <uxTaskPriorityGet+0x12>
    2be4:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2be8:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2bec:	0f 90       	pop	r0
    2bee:	0f be       	out	0x3f, r0	; 63
    2bf0:	fc 01       	movw	r30, r24
    2bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf4:	08 95       	ret

00002bf6 <vTaskStartScheduler>:
    2bf6:	af 92       	push	r10
    2bf8:	bf 92       	push	r11
    2bfa:	cf 92       	push	r12
    2bfc:	df 92       	push	r13
    2bfe:	ef 92       	push	r14
    2c00:	ff 92       	push	r15
    2c02:	0f 93       	push	r16
    2c04:	a1 2c       	mov	r10, r1
    2c06:	b1 2c       	mov	r11, r1
    2c08:	c1 2c       	mov	r12, r1
    2c0a:	d1 2c       	mov	r13, r1
    2c0c:	0f 2e       	mov	r0, r31
    2c0e:	fb e4       	ldi	r31, 0x4B	; 75
    2c10:	ef 2e       	mov	r14, r31
    2c12:	f2 e3       	ldi	r31, 0x32	; 50
    2c14:	ff 2e       	mov	r15, r31
    2c16:	f0 2d       	mov	r31, r0
    2c18:	00 e0       	ldi	r16, 0x00	; 0
    2c1a:	20 e0       	ldi	r18, 0x00	; 0
    2c1c:	30 e0       	ldi	r19, 0x00	; 0
    2c1e:	44 e6       	ldi	r20, 0x64	; 100
    2c20:	50 e0       	ldi	r21, 0x00	; 0
    2c22:	63 e8       	ldi	r22, 0x83	; 131
    2c24:	71 e2       	ldi	r23, 0x21	; 33
    2c26:	85 e9       	ldi	r24, 0x95	; 149
    2c28:	94 e1       	ldi	r25, 0x14	; 20
    2c2a:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <xTaskGenericCreate>
    2c2e:	81 30       	cpi	r24, 0x01	; 1
    2c30:	69 f4       	brne	.+26     	; 0x2c4c <vTaskStartScheduler+0x56>
    2c32:	f8 94       	cli
    2c34:	80 93 43 32 	sts	0x3243, r24	; 0x803243 <xSchedulerRunning>
    2c38:	10 92 46 32 	sts	0x3246, r1	; 0x803246 <xTickCount>
    2c3c:	10 92 47 32 	sts	0x3247, r1	; 0x803247 <xTickCount+0x1>
    2c40:	10 92 48 32 	sts	0x3248, r1	; 0x803248 <xTickCount+0x2>
    2c44:	10 92 49 32 	sts	0x3249, r1	; 0x803249 <xTickCount+0x3>
    2c48:	0e 94 b3 10 	call	0x2166	; 0x2166 <xPortStartScheduler>
    2c4c:	0f 91       	pop	r16
    2c4e:	ff 90       	pop	r15
    2c50:	ef 90       	pop	r14
    2c52:	df 90       	pop	r13
    2c54:	cf 90       	pop	r12
    2c56:	bf 90       	pop	r11
    2c58:	af 90       	pop	r10
    2c5a:	08 95       	ret

00002c5c <vTaskSuspendAll>:
    2c5c:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2c60:	8f 5f       	subi	r24, 0xFF	; 255
    2c62:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxSchedulerSuspended>
    2c66:	08 95       	ret

00002c68 <xTaskGetTickCount>:
    2c68:	0f b6       	in	r0, 0x3f	; 63
    2c6a:	f8 94       	cli
    2c6c:	0f 92       	push	r0
    2c6e:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount>
    2c72:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x1>
    2c76:	80 91 48 32 	lds	r24, 0x3248	; 0x803248 <xTickCount+0x2>
    2c7a:	90 91 49 32 	lds	r25, 0x3249	; 0x803249 <xTickCount+0x3>
    2c7e:	0f 90       	pop	r0
    2c80:	0f be       	out	0x3f, r0	; 63
    2c82:	08 95       	ret

00002c84 <pcTaskGetTaskName>:
    2c84:	00 97       	sbiw	r24, 0x00	; 0
    2c86:	21 f4       	brne	.+8      	; 0x2c90 <pcTaskGetTaskName+0xc>
    2c88:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2c8c:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2c90:	4d 96       	adiw	r24, 0x1d	; 29
    2c92:	08 95       	ret

00002c94 <xTaskGetIdleTaskHandle>:
    2c94:	80 91 4b 32 	lds	r24, 0x324B	; 0x80324b <xIdleTaskHandle>
    2c98:	90 91 4c 32 	lds	r25, 0x324C	; 0x80324c <xIdleTaskHandle+0x1>
    2c9c:	08 95       	ret

00002c9e <vTaskIncrementTick>:
    2c9e:	ff 92       	push	r15
    2ca0:	0f 93       	push	r16
    2ca2:	1f 93       	push	r17
    2ca4:	cf 93       	push	r28
    2ca6:	df 93       	push	r29
    2ca8:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2cac:	81 11       	cpse	r24, r1
    2cae:	ed c0       	rjmp	.+474    	; 0x2e8a <vTaskIncrementTick+0x1ec>
    2cb0:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2cb4:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2cb8:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2cbc:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2cc0:	01 96       	adiw	r24, 0x01	; 1
    2cc2:	a1 1d       	adc	r26, r1
    2cc4:	b1 1d       	adc	r27, r1
    2cc6:	80 93 46 32 	sts	0x3246, r24	; 0x803246 <xTickCount>
    2cca:	90 93 47 32 	sts	0x3247, r25	; 0x803247 <xTickCount+0x1>
    2cce:	a0 93 48 32 	sts	0x3248, r26	; 0x803248 <xTickCount+0x2>
    2cd2:	b0 93 49 32 	sts	0x3249, r27	; 0x803249 <xTickCount+0x3>
    2cd6:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2cda:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2cde:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2ce2:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2ce6:	89 2b       	or	r24, r25
    2ce8:	8a 2b       	or	r24, r26
    2cea:	8b 2b       	or	r24, r27
    2cec:	f1 f5       	brne	.+124    	; 0x2d6a <vTaskIncrementTick+0xcc>
    2cee:	80 91 5a 32 	lds	r24, 0x325A	; 0x80325a <pxDelayedTaskList>
    2cf2:	90 91 5b 32 	lds	r25, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2cf6:	20 91 58 32 	lds	r18, 0x3258	; 0x803258 <pxOverflowDelayedTaskList>
    2cfa:	30 91 59 32 	lds	r19, 0x3259	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2cfe:	20 93 5a 32 	sts	0x325A, r18	; 0x80325a <pxDelayedTaskList>
    2d02:	30 93 5b 32 	sts	0x325B, r19	; 0x80325b <pxDelayedTaskList+0x1>
    2d06:	80 93 58 32 	sts	0x3258, r24	; 0x803258 <pxOverflowDelayedTaskList>
    2d0a:	90 93 59 32 	sts	0x3259, r25	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2d0e:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <xNumOfOverflows>
    2d12:	8f 5f       	subi	r24, 0xFF	; 255
    2d14:	80 93 3f 32 	sts	0x323F, r24	; 0x80323f <xNumOfOverflows>
    2d18:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d1c:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d20:	80 81       	ld	r24, Z
    2d22:	81 11       	cpse	r24, r1
    2d24:	0c c0       	rjmp	.+24     	; 0x2d3e <vTaskIncrementTick+0xa0>
    2d26:	8f ef       	ldi	r24, 0xFF	; 255
    2d28:	9f ef       	ldi	r25, 0xFF	; 255
    2d2a:	dc 01       	movw	r26, r24
    2d2c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d30:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d34:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d38:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d3c:	16 c0       	rjmp	.+44     	; 0x2d6a <vTaskIncrementTick+0xcc>
    2d3e:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d42:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d46:	07 80       	ldd	r0, Z+7	; 0x07
    2d48:	f0 85       	ldd	r31, Z+8	; 0x08
    2d4a:	e0 2d       	mov	r30, r0
    2d4c:	00 84       	ldd	r0, Z+8	; 0x08
    2d4e:	f1 85       	ldd	r31, Z+9	; 0x09
    2d50:	e0 2d       	mov	r30, r0
    2d52:	82 81       	ldd	r24, Z+2	; 0x02
    2d54:	93 81       	ldd	r25, Z+3	; 0x03
    2d56:	a4 81       	ldd	r26, Z+4	; 0x04
    2d58:	b5 81       	ldd	r27, Z+5	; 0x05
    2d5a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d5e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d62:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d66:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d6a:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2d6e:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2d72:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2d76:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2d7a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2d7e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d82:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d86:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d8a:	48 17       	cp	r20, r24
    2d8c:	59 07       	cpc	r21, r25
    2d8e:	6a 07       	cpc	r22, r26
    2d90:	7b 07       	cpc	r23, r27
    2d92:	08 f4       	brcc	.+2      	; 0x2d96 <vTaskIncrementTick+0xf8>
    2d94:	7f c0       	rjmp	.+254    	; 0x2e94 <vTaskIncrementTick+0x1f6>
    2d96:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d9a:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d9e:	80 81       	ld	r24, Z
    2da0:	88 23       	and	r24, r24
    2da2:	f9 f0       	breq	.+62     	; 0x2de2 <vTaskIncrementTick+0x144>
    2da4:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2da8:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2dac:	07 80       	ldd	r0, Z+7	; 0x07
    2dae:	f0 85       	ldd	r31, Z+8	; 0x08
    2db0:	e0 2d       	mov	r30, r0
    2db2:	c0 85       	ldd	r28, Z+8	; 0x08
    2db4:	d1 85       	ldd	r29, Z+9	; 0x09
    2db6:	8a 81       	ldd	r24, Y+2	; 0x02
    2db8:	9b 81       	ldd	r25, Y+3	; 0x03
    2dba:	ac 81       	ldd	r26, Y+4	; 0x04
    2dbc:	bd 81       	ldd	r27, Y+5	; 0x05
    2dbe:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2dc2:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2dc6:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2dca:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2dce:	48 17       	cp	r20, r24
    2dd0:	59 07       	cpc	r21, r25
    2dd2:	6a 07       	cpc	r22, r26
    2dd4:	7b 07       	cpc	r23, r27
    2dd6:	58 f1       	brcs	.+86     	; 0x2e2e <vTaskIncrementTick+0x190>
    2dd8:	0f 2e       	mov	r0, r31
    2dda:	fb e0       	ldi	r31, 0x0B	; 11
    2ddc:	ff 2e       	mov	r15, r31
    2dde:	f0 2d       	mov	r31, r0
    2de0:	2f c0       	rjmp	.+94     	; 0x2e40 <vTaskIncrementTick+0x1a2>
    2de2:	8f ef       	ldi	r24, 0xFF	; 255
    2de4:	9f ef       	ldi	r25, 0xFF	; 255
    2de6:	dc 01       	movw	r26, r24
    2de8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2dec:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2df0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2df4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2df8:	4d c0       	rjmp	.+154    	; 0x2e94 <vTaskIncrementTick+0x1f6>
    2dfa:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2dfe:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2e02:	07 80       	ldd	r0, Z+7	; 0x07
    2e04:	f0 85       	ldd	r31, Z+8	; 0x08
    2e06:	e0 2d       	mov	r30, r0
    2e08:	c0 85       	ldd	r28, Z+8	; 0x08
    2e0a:	d1 85       	ldd	r29, Z+9	; 0x09
    2e0c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e0e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e10:	ac 81       	ldd	r26, Y+4	; 0x04
    2e12:	bd 81       	ldd	r27, Y+5	; 0x05
    2e14:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2e18:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2e1c:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2e20:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2e24:	48 17       	cp	r20, r24
    2e26:	59 07       	cpc	r21, r25
    2e28:	6a 07       	cpc	r22, r26
    2e2a:	7b 07       	cpc	r23, r27
    2e2c:	48 f4       	brcc	.+18     	; 0x2e40 <vTaskIncrementTick+0x1a2>
    2e2e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e32:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e36:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e3a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e3e:	2a c0       	rjmp	.+84     	; 0x2e94 <vTaskIncrementTick+0x1f6>
    2e40:	8e 01       	movw	r16, r28
    2e42:	0e 5f       	subi	r16, 0xFE	; 254
    2e44:	1f 4f       	sbci	r17, 0xFF	; 255
    2e46:	c8 01       	movw	r24, r16
    2e48:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
    2e4c:	88 8d       	ldd	r24, Y+24	; 0x18
    2e4e:	99 8d       	ldd	r25, Y+25	; 0x19
    2e50:	89 2b       	or	r24, r25
    2e52:	21 f0       	breq	.+8      	; 0x2e5c <vTaskIncrementTick+0x1be>
    2e54:	ce 01       	movw	r24, r28
    2e56:	0e 96       	adiw	r24, 0x0e	; 14
    2e58:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
    2e5c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e5e:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2e62:	98 17       	cp	r25, r24
    2e64:	10 f4       	brcc	.+4      	; 0x2e6a <vTaskIncrementTick+0x1cc>
    2e66:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2e6a:	f8 9e       	mul	r15, r24
    2e6c:	c0 01       	movw	r24, r0
    2e6e:	11 24       	eor	r1, r1
    2e70:	b8 01       	movw	r22, r16
    2e72:	8e 58       	subi	r24, 0x8E	; 142
    2e74:	9d 4c       	sbci	r25, 0xCD	; 205
    2e76:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
    2e7a:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2e7e:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2e82:	80 81       	ld	r24, Z
    2e84:	81 11       	cpse	r24, r1
    2e86:	b9 cf       	rjmp	.-142    	; 0x2dfa <vTaskIncrementTick+0x15c>
    2e88:	ac cf       	rjmp	.-168    	; 0x2de2 <vTaskIncrementTick+0x144>
    2e8a:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2e8e:	8f 5f       	subi	r24, 0xFF	; 255
    2e90:	80 93 41 32 	sts	0x3241, r24	; 0x803241 <uxMissedTicks>
    2e94:	df 91       	pop	r29
    2e96:	cf 91       	pop	r28
    2e98:	1f 91       	pop	r17
    2e9a:	0f 91       	pop	r16
    2e9c:	ff 90       	pop	r15
    2e9e:	08 95       	ret

00002ea0 <xTaskResumeAll>:
    2ea0:	cf 92       	push	r12
    2ea2:	df 92       	push	r13
    2ea4:	ef 92       	push	r14
    2ea6:	ff 92       	push	r15
    2ea8:	0f 93       	push	r16
    2eaa:	1f 93       	push	r17
    2eac:	cf 93       	push	r28
    2eae:	df 93       	push	r29
    2eb0:	0f b6       	in	r0, 0x3f	; 63
    2eb2:	f8 94       	cli
    2eb4:	0f 92       	push	r0
    2eb6:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2eba:	81 50       	subi	r24, 0x01	; 1
    2ebc:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxSchedulerSuspended>
    2ec0:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2ec4:	81 11       	cpse	r24, r1
    2ec6:	60 c0       	rjmp	.+192    	; 0x2f88 <xTaskResumeAll+0xe8>
    2ec8:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2ecc:	81 11       	cpse	r24, r1
    2ece:	2c c0       	rjmp	.+88     	; 0x2f28 <xTaskResumeAll+0x88>
    2ed0:	5e c0       	rjmp	.+188    	; 0x2f8e <xTaskResumeAll+0xee>
    2ed2:	d7 01       	movw	r26, r14
    2ed4:	17 96       	adiw	r26, 0x07	; 7
    2ed6:	ed 91       	ld	r30, X+
    2ed8:	fc 91       	ld	r31, X
    2eda:	18 97       	sbiw	r26, 0x08	; 8
    2edc:	c0 85       	ldd	r28, Z+8	; 0x08
    2ede:	d1 85       	ldd	r29, Z+9	; 0x09
    2ee0:	ce 01       	movw	r24, r28
    2ee2:	0e 96       	adiw	r24, 0x0e	; 14
    2ee4:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
    2ee8:	8e 01       	movw	r16, r28
    2eea:	0e 5f       	subi	r16, 0xFE	; 254
    2eec:	1f 4f       	sbci	r17, 0xFF	; 255
    2eee:	c8 01       	movw	r24, r16
    2ef0:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
    2ef4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ef6:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2efa:	98 17       	cp	r25, r24
    2efc:	10 f4       	brcc	.+4      	; 0x2f02 <xTaskResumeAll+0x62>
    2efe:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2f02:	d8 9e       	mul	r13, r24
    2f04:	c0 01       	movw	r24, r0
    2f06:	11 24       	eor	r1, r1
    2f08:	b8 01       	movw	r22, r16
    2f0a:	8e 58       	subi	r24, 0x8E	; 142
    2f0c:	9d 4c       	sbci	r25, 0xCD	; 205
    2f0e:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
    2f12:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2f16:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2f1a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f1e:	98 17       	cp	r25, r24
    2f20:	70 f0       	brcs	.+28     	; 0x2f3e <xTaskResumeAll+0x9e>
    2f22:	cc 24       	eor	r12, r12
    2f24:	c3 94       	inc	r12
    2f26:	0b c0       	rjmp	.+22     	; 0x2f3e <xTaskResumeAll+0x9e>
    2f28:	c1 2c       	mov	r12, r1
    2f2a:	0f 2e       	mov	r0, r31
    2f2c:	fd e4       	ldi	r31, 0x4D	; 77
    2f2e:	ef 2e       	mov	r14, r31
    2f30:	f2 e3       	ldi	r31, 0x32	; 50
    2f32:	ff 2e       	mov	r15, r31
    2f34:	f0 2d       	mov	r31, r0
    2f36:	0f 2e       	mov	r0, r31
    2f38:	fb e0       	ldi	r31, 0x0B	; 11
    2f3a:	df 2e       	mov	r13, r31
    2f3c:	f0 2d       	mov	r31, r0
    2f3e:	f7 01       	movw	r30, r14
    2f40:	80 81       	ld	r24, Z
    2f42:	81 11       	cpse	r24, r1
    2f44:	c6 cf       	rjmp	.-116    	; 0x2ed2 <xTaskResumeAll+0x32>
    2f46:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f4a:	88 23       	and	r24, r24
    2f4c:	81 f0       	breq	.+32     	; 0x2f6e <xTaskResumeAll+0xce>
    2f4e:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f52:	88 23       	and	r24, r24
    2f54:	99 f0       	breq	.+38     	; 0x2f7c <xTaskResumeAll+0xdc>
    2f56:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <vTaskIncrementTick>
    2f5a:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f5e:	81 50       	subi	r24, 0x01	; 1
    2f60:	80 93 41 32 	sts	0x3241, r24	; 0x803241 <uxMissedTicks>
    2f64:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f68:	81 11       	cpse	r24, r1
    2f6a:	f5 cf       	rjmp	.-22     	; 0x2f56 <xTaskResumeAll+0xb6>
    2f6c:	07 c0       	rjmp	.+14     	; 0x2f7c <xTaskResumeAll+0xdc>
    2f6e:	f1 e0       	ldi	r31, 0x01	; 1
    2f70:	cf 16       	cp	r12, r31
    2f72:	21 f0       	breq	.+8      	; 0x2f7c <xTaskResumeAll+0xdc>
    2f74:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <xMissedYield>
    2f78:	81 30       	cpi	r24, 0x01	; 1
    2f7a:	41 f4       	brne	.+16     	; 0x2f8c <xTaskResumeAll+0xec>
    2f7c:	10 92 40 32 	sts	0x3240, r1	; 0x803240 <xMissedYield>
    2f80:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
    2f84:	81 e0       	ldi	r24, 0x01	; 1
    2f86:	03 c0       	rjmp	.+6      	; 0x2f8e <xTaskResumeAll+0xee>
    2f88:	80 e0       	ldi	r24, 0x00	; 0
    2f8a:	01 c0       	rjmp	.+2      	; 0x2f8e <xTaskResumeAll+0xee>
    2f8c:	80 e0       	ldi	r24, 0x00	; 0
    2f8e:	0f 90       	pop	r0
    2f90:	0f be       	out	0x3f, r0	; 63
    2f92:	df 91       	pop	r29
    2f94:	cf 91       	pop	r28
    2f96:	1f 91       	pop	r17
    2f98:	0f 91       	pop	r16
    2f9a:	ff 90       	pop	r15
    2f9c:	ef 90       	pop	r14
    2f9e:	df 90       	pop	r13
    2fa0:	cf 90       	pop	r12
    2fa2:	08 95       	ret

00002fa4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2fa4:	cf 92       	push	r12
    2fa6:	df 92       	push	r13
    2fa8:	ef 92       	push	r14
    2faa:	ff 92       	push	r15
    2fac:	6b 01       	movw	r12, r22
    2fae:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2fb0:	67 2b       	or	r22, r23
    2fb2:	68 2b       	or	r22, r24
    2fb4:	69 2b       	or	r22, r25
    2fb6:	e9 f0       	breq	.+58     	; 0x2ff2 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2fb8:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fbc:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2fc0:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2fc4:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2fc8:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2fcc:	c8 0e       	add	r12, r24
    2fce:	d9 1e       	adc	r13, r25
    2fd0:	ea 1e       	adc	r14, r26
    2fd2:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2fd4:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2fd8:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2fdc:	02 96       	adiw	r24, 0x02	; 2
    2fde:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2fe2:	c7 01       	movw	r24, r14
    2fe4:	b6 01       	movw	r22, r12
    2fe6:	0e 94 9d 14 	call	0x293a	; 0x293a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2fea:	0e 94 50 17 	call	0x2ea0	; 0x2ea0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2fee:	81 11       	cpse	r24, r1
    2ff0:	02 c0       	rjmp	.+4      	; 0x2ff6 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2ff2:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <vPortYield>
		}
	}
    2ff6:	ff 90       	pop	r15
    2ff8:	ef 90       	pop	r14
    2ffa:	df 90       	pop	r13
    2ffc:	cf 90       	pop	r12
    2ffe:	08 95       	ret

00003000 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3000:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    3004:	81 11       	cpse	r24, r1
    3006:	0c c0       	rjmp	.+24     	; 0x3020 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3008:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <uxTopReadyPriority>
    300c:	4b e0       	ldi	r20, 0x0B	; 11
    300e:	e4 9f       	mul	r30, r20
    3010:	f0 01       	movw	r30, r0
    3012:	11 24       	eor	r1, r1
    3014:	ee 58       	subi	r30, 0x8E	; 142
    3016:	fd 4c       	sbci	r31, 0xCD	; 205
    3018:	80 81       	ld	r24, Z
    301a:	88 23       	and	r24, r24
    301c:	29 f0       	breq	.+10     	; 0x3028 <vTaskSwitchContext+0x28>
    301e:	14 c0       	rjmp	.+40     	; 0x3048 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3020:	81 e0       	ldi	r24, 0x01	; 1
    3022:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <xMissedYield>
    3026:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3028:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    302a:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <uxTopReadyPriority>
    302e:	81 50       	subi	r24, 0x01	; 1
    3030:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3034:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <uxTopReadyPriority>
    3038:	9e 9f       	mul	r25, r30
    303a:	f0 01       	movw	r30, r0
    303c:	11 24       	eor	r1, r1
    303e:	ee 58       	subi	r30, 0x8E	; 142
    3040:	fd 4c       	sbci	r31, 0xCD	; 205
    3042:	80 81       	ld	r24, Z
    3044:	88 23       	and	r24, r24
    3046:	89 f3       	breq	.-30     	; 0x302a <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3048:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <uxTopReadyPriority>
    304c:	28 2f       	mov	r18, r24
    304e:	30 e0       	ldi	r19, 0x00	; 0
    3050:	4b e0       	ldi	r20, 0x0B	; 11
    3052:	84 9f       	mul	r24, r20
    3054:	c0 01       	movw	r24, r0
    3056:	11 24       	eor	r1, r1
    3058:	dc 01       	movw	r26, r24
    305a:	ae 58       	subi	r26, 0x8E	; 142
    305c:	bd 4c       	sbci	r27, 0xCD	; 205
    305e:	11 96       	adiw	r26, 0x01	; 1
    3060:	ed 91       	ld	r30, X+
    3062:	fc 91       	ld	r31, X
    3064:	12 97       	sbiw	r26, 0x02	; 2
    3066:	04 80       	ldd	r0, Z+4	; 0x04
    3068:	f5 81       	ldd	r31, Z+5	; 0x05
    306a:	e0 2d       	mov	r30, r0
    306c:	11 96       	adiw	r26, 0x01	; 1
    306e:	ed 93       	st	X+, r30
    3070:	fc 93       	st	X, r31
    3072:	12 97       	sbiw	r26, 0x02	; 2
    3074:	8b 58       	subi	r24, 0x8B	; 139
    3076:	9d 4c       	sbci	r25, 0xCD	; 205
    3078:	e8 17       	cp	r30, r24
    307a:	f9 07       	cpc	r31, r25
    307c:	61 f4       	brne	.+24     	; 0x3096 <vTaskSwitchContext+0x96>
    307e:	84 81       	ldd	r24, Z+4	; 0x04
    3080:	95 81       	ldd	r25, Z+5	; 0x05
    3082:	4b e0       	ldi	r20, 0x0B	; 11
    3084:	42 9f       	mul	r20, r18
    3086:	f0 01       	movw	r30, r0
    3088:	43 9f       	mul	r20, r19
    308a:	f0 0d       	add	r31, r0
    308c:	11 24       	eor	r1, r1
    308e:	ee 58       	subi	r30, 0x8E	; 142
    3090:	fd 4c       	sbci	r31, 0xCD	; 205
    3092:	81 83       	std	Z+1, r24	; 0x01
    3094:	92 83       	std	Z+2, r25	; 0x02
    3096:	8b e0       	ldi	r24, 0x0B	; 11
    3098:	82 9f       	mul	r24, r18
    309a:	f0 01       	movw	r30, r0
    309c:	83 9f       	mul	r24, r19
    309e:	f0 0d       	add	r31, r0
    30a0:	11 24       	eor	r1, r1
    30a2:	ee 58       	subi	r30, 0x8E	; 142
    30a4:	fd 4c       	sbci	r31, 0xCD	; 205
    30a6:	01 80       	ldd	r0, Z+1	; 0x01
    30a8:	f2 81       	ldd	r31, Z+2	; 0x02
    30aa:	e0 2d       	mov	r30, r0
    30ac:	80 85       	ldd	r24, Z+8	; 0x08
    30ae:	91 85       	ldd	r25, Z+9	; 0x09
    30b0:	80 93 9e 32 	sts	0x329E, r24	; 0x80329e <pxCurrentTCB>
    30b4:	90 93 9f 32 	sts	0x329F, r25	; 0x80329f <pxCurrentTCB+0x1>
    30b8:	08 95       	ret

000030ba <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    30ba:	cf 92       	push	r12
    30bc:	df 92       	push	r13
    30be:	ef 92       	push	r14
    30c0:	ff 92       	push	r15
    30c2:	6a 01       	movw	r12, r20
    30c4:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    30c6:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    30ca:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    30ce:	62 5f       	subi	r22, 0xF2	; 242
    30d0:	7f 4f       	sbci	r23, 0xFF	; 255
    30d2:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30d6:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    30da:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    30de:	02 96       	adiw	r24, 0x02	; 2
    30e0:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    30e4:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    30e8:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    30ec:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    30f0:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    30f4:	bc 01       	movw	r22, r24
    30f6:	cd 01       	movw	r24, r26
    30f8:	6c 0d       	add	r22, r12
    30fa:	7d 1d       	adc	r23, r13
    30fc:	8e 1d       	adc	r24, r14
    30fe:	9f 1d       	adc	r25, r15
    3100:	0e 94 9d 14 	call	0x293a	; 0x293a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3104:	ff 90       	pop	r15
    3106:	ef 90       	pop	r14
    3108:	df 90       	pop	r13
    310a:	cf 90       	pop	r12
    310c:	08 95       	ret

0000310e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    310e:	0f 93       	push	r16
    3110:	1f 93       	push	r17
    3112:	cf 93       	push	r28
    3114:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3116:	dc 01       	movw	r26, r24
    3118:	17 96       	adiw	r26, 0x07	; 7
    311a:	ed 91       	ld	r30, X+
    311c:	fc 91       	ld	r31, X
    311e:	18 97       	sbiw	r26, 0x08	; 8
    3120:	c0 85       	ldd	r28, Z+8	; 0x08
    3122:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3124:	8e 01       	movw	r16, r28
    3126:	02 5f       	subi	r16, 0xF2	; 242
    3128:	1f 4f       	sbci	r17, 0xFF	; 255
    312a:	c8 01       	movw	r24, r16
    312c:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3130:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    3134:	81 11       	cpse	r24, r1
    3136:	16 c0       	rjmp	.+44     	; 0x3164 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3138:	0c 50       	subi	r16, 0x0C	; 12
    313a:	11 09       	sbc	r17, r1
    313c:	c8 01       	movw	r24, r16
    313e:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3142:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3144:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    3148:	98 17       	cp	r25, r24
    314a:	10 f4       	brcc	.+4      	; 0x3150 <xTaskRemoveFromEventList+0x42>
    314c:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    3150:	bb e0       	ldi	r27, 0x0B	; 11
    3152:	8b 9f       	mul	r24, r27
    3154:	c0 01       	movw	r24, r0
    3156:	11 24       	eor	r1, r1
    3158:	b8 01       	movw	r22, r16
    315a:	8e 58       	subi	r24, 0x8E	; 142
    315c:	9d 4c       	sbci	r25, 0xCD	; 205
    315e:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
    3162:	05 c0       	rjmp	.+10     	; 0x316e <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3164:	b8 01       	movw	r22, r16
    3166:	8d e4       	ldi	r24, 0x4D	; 77
    3168:	92 e3       	ldi	r25, 0x32	; 50
    316a:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    316e:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    3172:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    3176:	81 e0       	ldi	r24, 0x01	; 1
    3178:	2a 8d       	ldd	r18, Y+26	; 0x1a
    317a:	92 8d       	ldd	r25, Z+26	; 0x1a
    317c:	29 17       	cp	r18, r25
    317e:	08 f4       	brcc	.+2      	; 0x3182 <xTaskRemoveFromEventList+0x74>
    3180:	80 e0       	ldi	r24, 0x00	; 0
}
    3182:	df 91       	pop	r29
    3184:	cf 91       	pop	r28
    3186:	1f 91       	pop	r17
    3188:	0f 91       	pop	r16
    318a:	08 95       	ret

0000318c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    318c:	20 91 3f 32 	lds	r18, 0x323F	; 0x80323f <xNumOfOverflows>
    3190:	fc 01       	movw	r30, r24
    3192:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    3194:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    3198:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    319c:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    31a0:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    31a4:	41 83       	std	Z+1, r20	; 0x01
    31a6:	52 83       	std	Z+2, r21	; 0x02
    31a8:	63 83       	std	Z+3, r22	; 0x03
    31aa:	74 83       	std	Z+4, r23	; 0x04
    31ac:	08 95       	ret

000031ae <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    31ae:	8f 92       	push	r8
    31b0:	9f 92       	push	r9
    31b2:	af 92       	push	r10
    31b4:	bf 92       	push	r11
    31b6:	cf 92       	push	r12
    31b8:	df 92       	push	r13
    31ba:	ef 92       	push	r14
    31bc:	ff 92       	push	r15
    31be:	0f 93       	push	r16
    31c0:	1f 93       	push	r17
    31c2:	cf 93       	push	r28
    31c4:	df 93       	push	r29
    31c6:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    31c8:	0f b6       	in	r0, 0x3f	; 63
    31ca:	f8 94       	cli
    31cc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    31ce:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <xNumOfOverflows>
    31d2:	90 81       	ld	r25, Z
    31d4:	98 17       	cp	r25, r24
    31d6:	89 f0       	breq	.+34     	; 0x31fa <xTaskCheckForTimeOut+0x4c>
    31d8:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    31dc:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    31e0:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    31e4:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    31e8:	01 81       	ldd	r16, Z+1	; 0x01
    31ea:	12 81       	ldd	r17, Z+2	; 0x02
    31ec:	23 81       	ldd	r18, Z+3	; 0x03
    31ee:	34 81       	ldd	r19, Z+4	; 0x04
    31f0:	80 17       	cp	r24, r16
    31f2:	91 07       	cpc	r25, r17
    31f4:	a2 07       	cpc	r26, r18
    31f6:	b3 07       	cpc	r27, r19
    31f8:	a8 f5       	brcc	.+106    	; 0x3264 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    31fa:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    31fe:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    3202:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    3206:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    320a:	c1 80       	ldd	r12, Z+1	; 0x01
    320c:	d2 80       	ldd	r13, Z+2	; 0x02
    320e:	e3 80       	ldd	r14, Z+3	; 0x03
    3210:	f4 80       	ldd	r15, Z+4	; 0x04
    3212:	eb 01       	movw	r28, r22
    3214:	08 81       	ld	r16, Y
    3216:	19 81       	ldd	r17, Y+1	; 0x01
    3218:	2a 81       	ldd	r18, Y+2	; 0x02
    321a:	3b 81       	ldd	r19, Y+3	; 0x03
    321c:	8c 19       	sub	r24, r12
    321e:	9d 09       	sbc	r25, r13
    3220:	ae 09       	sbc	r26, r14
    3222:	bf 09       	sbc	r27, r15
    3224:	80 17       	cp	r24, r16
    3226:	91 07       	cpc	r25, r17
    3228:	a2 07       	cpc	r26, r18
    322a:	b3 07       	cpc	r27, r19
    322c:	e8 f4       	brcc	.+58     	; 0x3268 <xTaskCheckForTimeOut+0xba>
    322e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3230:	80 90 46 32 	lds	r8, 0x3246	; 0x803246 <xTickCount>
    3234:	90 90 47 32 	lds	r9, 0x3247	; 0x803247 <xTickCount+0x1>
    3238:	a0 90 48 32 	lds	r10, 0x3248	; 0x803248 <xTickCount+0x2>
    323c:	b0 90 49 32 	lds	r11, 0x3249	; 0x803249 <xTickCount+0x3>
    3240:	b5 01       	movw	r22, r10
    3242:	a4 01       	movw	r20, r8
    3244:	4c 19       	sub	r20, r12
    3246:	5d 09       	sbc	r21, r13
    3248:	6e 09       	sbc	r22, r14
    324a:	7f 09       	sbc	r23, r15
    324c:	04 1b       	sub	r16, r20
    324e:	15 0b       	sbc	r17, r21
    3250:	26 0b       	sbc	r18, r22
    3252:	37 0b       	sbc	r19, r23
    3254:	08 83       	st	Y, r16
    3256:	19 83       	std	Y+1, r17	; 0x01
    3258:	2a 83       	std	Y+2, r18	; 0x02
    325a:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    325c:	0e 94 c6 18 	call	0x318c	; 0x318c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3260:	80 e0       	ldi	r24, 0x00	; 0
    3262:	03 c0       	rjmp	.+6      	; 0x326a <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3264:	81 e0       	ldi	r24, 0x01	; 1
    3266:	01 c0       	rjmp	.+2      	; 0x326a <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    3268:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    326a:	0f 90       	pop	r0
    326c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    326e:	df 91       	pop	r29
    3270:	cf 91       	pop	r28
    3272:	1f 91       	pop	r17
    3274:	0f 91       	pop	r16
    3276:	ff 90       	pop	r15
    3278:	ef 90       	pop	r14
    327a:	df 90       	pop	r13
    327c:	cf 90       	pop	r12
    327e:	bf 90       	pop	r11
    3280:	af 90       	pop	r10
    3282:	9f 90       	pop	r9
    3284:	8f 90       	pop	r8
    3286:	08 95       	ret

00003288 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    3288:	81 e0       	ldi	r24, 0x01	; 1
    328a:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <xMissedYield>
    328e:	08 95       	ret

00003290 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3290:	00 97       	sbiw	r24, 0x00	; 0
    3292:	21 f4       	brne	.+8      	; 0x329c <uxTaskGetStackHighWaterMark+0xc>
    3294:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    3298:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    329c:	dc 01       	movw	r26, r24
    329e:	5b 96       	adiw	r26, 0x1b	; 27
    32a0:	ed 91       	ld	r30, X+
    32a2:	fc 91       	ld	r31, X
    32a4:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32a6:	80 81       	ld	r24, Z
    32a8:	81 31       	cpi	r24, 0x11	; 17
    32aa:	41 f4       	brne	.+16     	; 0x32bc <uxTaskGetStackHighWaterMark+0x2c>
    32ac:	31 96       	adiw	r30, 0x01	; 1
    32ae:	80 e0       	ldi	r24, 0x00	; 0
    32b0:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    32b2:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32b4:	21 91       	ld	r18, Z+
    32b6:	21 31       	cpi	r18, 0x11	; 17
    32b8:	e1 f3       	breq	.-8      	; 0x32b2 <uxTaskGetStackHighWaterMark+0x22>
    32ba:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    32bc:	80 e0       	ldi	r24, 0x00	; 0
    32be:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    32c0:	08 95       	ret

000032c2 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    32c2:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    32c6:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>

		return xReturn;
	}
    32ca:	08 95       	ret

000032cc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    32cc:	0f 93       	push	r16
    32ce:	1f 93       	push	r17
    32d0:	cf 93       	push	r28
    32d2:	df 93       	push	r29
    32d4:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    32d6:	22 8d       	ldd	r18, Z+26	; 0x1a
    32d8:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    32dc:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    32e0:	5a 96       	adiw	r26, 0x1a	; 26
    32e2:	8c 91       	ld	r24, X
    32e4:	28 17       	cp	r18, r24
    32e6:	08 f0       	brcs	.+2      	; 0x32ea <vTaskPriorityInherit+0x1e>
    32e8:	41 c0       	rjmp	.+130    	; 0x336c <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    32ea:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    32ee:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    32f2:	5a 96       	adiw	r26, 0x1a	; 26
    32f4:	3c 91       	ld	r19, X
    32f6:	84 e0       	ldi	r24, 0x04	; 4
    32f8:	90 e0       	ldi	r25, 0x00	; 0
    32fa:	a0 e0       	ldi	r26, 0x00	; 0
    32fc:	b0 e0       	ldi	r27, 0x00	; 0
    32fe:	83 1b       	sub	r24, r19
    3300:	91 09       	sbc	r25, r1
    3302:	a1 09       	sbc	r26, r1
    3304:	b1 09       	sbc	r27, r1
    3306:	86 87       	std	Z+14, r24	; 0x0e
    3308:	97 87       	std	Z+15, r25	; 0x0f
    330a:	a0 8b       	std	Z+16, r26	; 0x10
    330c:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    330e:	8b e0       	ldi	r24, 0x0B	; 11
    3310:	28 9f       	mul	r18, r24
    3312:	90 01       	movw	r18, r0
    3314:	11 24       	eor	r1, r1
    3316:	2e 58       	subi	r18, 0x8E	; 142
    3318:	3d 4c       	sbci	r19, 0xCD	; 205
    331a:	84 85       	ldd	r24, Z+12	; 0x0c
    331c:	95 85       	ldd	r25, Z+13	; 0x0d
    331e:	82 17       	cp	r24, r18
    3320:	93 07       	cpc	r25, r19
    3322:	e9 f4       	brne	.+58     	; 0x335e <vTaskPriorityInherit+0x92>
    3324:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    3326:	ef 01       	movw	r28, r30
    3328:	22 96       	adiw	r28, 0x02	; 2
    332a:	ce 01       	movw	r24, r28
    332c:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3330:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    3334:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3338:	82 8d       	ldd	r24, Z+26	; 0x1a
    333a:	f8 01       	movw	r30, r16
    333c:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    333e:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    3342:	98 17       	cp	r25, r24
    3344:	10 f4       	brcc	.+4      	; 0x334a <vTaskPriorityInherit+0x7e>
    3346:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    334a:	fb e0       	ldi	r31, 0x0B	; 11
    334c:	8f 9f       	mul	r24, r31
    334e:	c0 01       	movw	r24, r0
    3350:	11 24       	eor	r1, r1
    3352:	be 01       	movw	r22, r28
    3354:	8e 58       	subi	r24, 0x8E	; 142
    3356:	9d 4c       	sbci	r25, 0xCD	; 205
    3358:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
    335c:	07 c0       	rjmp	.+14     	; 0x336c <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    335e:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    3362:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3366:	5a 96       	adiw	r26, 0x1a	; 26
    3368:	8c 91       	ld	r24, X
    336a:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    336c:	df 91       	pop	r29
    336e:	cf 91       	pop	r28
    3370:	1f 91       	pop	r17
    3372:	0f 91       	pop	r16
    3374:	08 95       	ret

00003376 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    3376:	0f 93       	push	r16
    3378:	1f 93       	push	r17
    337a:	cf 93       	push	r28
    337c:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    337e:	00 97       	sbiw	r24, 0x00	; 0
    3380:	49 f1       	breq	.+82     	; 0x33d4 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3382:	fc 01       	movw	r30, r24
    3384:	32 8d       	ldd	r19, Z+26	; 0x1a
    3386:	27 a1       	ldd	r18, Z+39	; 0x27
    3388:	32 17       	cp	r19, r18
    338a:	21 f1       	breq	.+72     	; 0x33d4 <vTaskPriorityDisinherit+0x5e>
    338c:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    338e:	8c 01       	movw	r16, r24
    3390:	0e 5f       	subi	r16, 0xFE	; 254
    3392:	1f 4f       	sbci	r17, 0xFF	; 255
    3394:	c8 01       	movw	r24, r16
    3396:	0e 94 17 10 	call	0x202e	; 0x202e <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    339a:	8f a1       	ldd	r24, Y+39	; 0x27
    339c:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    339e:	44 e0       	ldi	r20, 0x04	; 4
    33a0:	50 e0       	ldi	r21, 0x00	; 0
    33a2:	60 e0       	ldi	r22, 0x00	; 0
    33a4:	70 e0       	ldi	r23, 0x00	; 0
    33a6:	48 1b       	sub	r20, r24
    33a8:	51 09       	sbc	r21, r1
    33aa:	61 09       	sbc	r22, r1
    33ac:	71 09       	sbc	r23, r1
    33ae:	4e 87       	std	Y+14, r20	; 0x0e
    33b0:	5f 87       	std	Y+15, r21	; 0x0f
    33b2:	68 8b       	std	Y+16, r22	; 0x10
    33b4:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    33b6:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    33ba:	98 17       	cp	r25, r24
    33bc:	10 f4       	brcc	.+4      	; 0x33c2 <vTaskPriorityDisinherit+0x4c>
    33be:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    33c2:	fb e0       	ldi	r31, 0x0B	; 11
    33c4:	8f 9f       	mul	r24, r31
    33c6:	c0 01       	movw	r24, r0
    33c8:	11 24       	eor	r1, r1
    33ca:	b8 01       	movw	r22, r16
    33cc:	8e 58       	subi	r24, 0x8E	; 142
    33ce:	9d 4c       	sbci	r25, 0xCD	; 205
    33d0:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <vListInsertEnd>
			}
		}
	}
    33d4:	df 91       	pop	r29
    33d6:	cf 91       	pop	r28
    33d8:	1f 91       	pop	r17
    33da:	0f 91       	pop	r16
    33dc:	08 95       	ret

000033de <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    33de:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    33e0:	e8 81       	ld	r30, Y
    33e2:	f9 81       	ldd	r31, Y+1	; 0x01
    33e4:	01 90       	ld	r0, Z+
    33e6:	f0 81       	ld	r31, Z
    33e8:	e0 2d       	mov	r30, r0
    33ea:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    33ec:	1a 82       	std	Y+2, r1	; 0x02
    33ee:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    33f0:	6f ef       	ldi	r22, 0xFF	; 255
    33f2:	7f ef       	ldi	r23, 0xFF	; 255
    33f4:	cb 01       	movw	r24, r22
    33f6:	0e 94 d2 17 	call	0x2fa4	; 0x2fa4 <vTaskDelay>
    33fa:	fa cf       	rjmp	.-12     	; 0x33f0 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000033fc <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    33fc:	fc 01       	movw	r30, r24
    33fe:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3400:	65 87       	std	Z+13, r22	; 0x0d
    3402:	08 95       	ret

00003404 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    3404:	4f 92       	push	r4
    3406:	5f 92       	push	r5
    3408:	6f 92       	push	r6
    340a:	7f 92       	push	r7
    340c:	8f 92       	push	r8
    340e:	9f 92       	push	r9
    3410:	af 92       	push	r10
    3412:	bf 92       	push	r11
    3414:	cf 92       	push	r12
    3416:	df 92       	push	r13
    3418:	ef 92       	push	r14
    341a:	ff 92       	push	r15
    341c:	0f 93       	push	r16
    341e:	1f 93       	push	r17
    3420:	cf 93       	push	r28
    3422:	df 93       	push	r29
    3424:	cd b7       	in	r28, 0x3d	; 61
    3426:	de b7       	in	r29, 0x3e	; 62
    3428:	2a 97       	sbiw	r28, 0x0a	; 10
    342a:	cd bf       	out	0x3d, r28	; 61
    342c:	de bf       	out	0x3e, r29	; 62
    342e:	4c 01       	movw	r8, r24
    3430:	29 01       	movw	r4, r18
    3432:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    3434:	8c e8       	ldi	r24, 0x8C	; 140
    3436:	91 e2       	ldi	r25, 0x21	; 33
    3438:	f4 01       	movw	r30, r8
    343a:	80 83       	st	Z, r24
    343c:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    343e:	fb 01       	movw	r30, r22
    3440:	80 81       	ld	r24, Z
    3442:	88 23       	and	r24, r24
    3444:	69 f0       	breq	.+26     	; 0x3460 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    3446:	de 01       	movw	r26, r28
    3448:	11 96       	adiw	r26, 0x01	; 1
    344a:	31 96       	adiw	r30, 0x01	; 1
    344c:	90 e0       	ldi	r25, 0x00	; 0
    344e:	02 c0       	rjmp	.+4      	; 0x3454 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3450:	99 30       	cpi	r25, 0x09	; 9
    3452:	39 f0       	breq	.+14     	; 0x3462 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    3454:	9f 5f       	subi	r25, 0xFF	; 255
    3456:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3458:	81 91       	ld	r24, Z+
    345a:	81 11       	cpse	r24, r1
    345c:	f9 cf       	rjmp	.-14     	; 0x3450 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    345e:	01 c0       	rjmp	.+2      	; 0x3462 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3460:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3462:	e1 e0       	ldi	r30, 0x01	; 1
    3464:	f0 e0       	ldi	r31, 0x00	; 0
    3466:	ec 0f       	add	r30, r28
    3468:	fd 1f       	adc	r31, r29
    346a:	e9 0f       	add	r30, r25
    346c:	f1 1d       	adc	r31, r1
    346e:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3470:	74 01       	movw	r14, r8
    3472:	f2 e0       	ldi	r31, 0x02	; 2
    3474:	ef 0e       	add	r14, r31
    3476:	f1 1c       	adc	r15, r1
    3478:	a1 2c       	mov	r10, r1
    347a:	b1 2c       	mov	r11, r1
    347c:	c1 2c       	mov	r12, r1
    347e:	d1 2c       	mov	r13, r1
    3480:	04 2f       	mov	r16, r20
    3482:	94 01       	movw	r18, r8
    3484:	a2 01       	movw	r20, r4
    3486:	be 01       	movw	r22, r28
    3488:	6f 5f       	subi	r22, 0xFF	; 255
    348a:	7f 4f       	sbci	r23, 0xFF	; 255
    348c:	86 e3       	ldi	r24, 0x36	; 54
    348e:	93 e0       	ldi	r25, 0x03	; 3
    3490:	0e 94 eb 14 	call	0x29d6	; 0x29d6 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    3494:	f4 01       	movw	r30, r8
    3496:	66 82       	std	Z+6, r6	; 0x06
    3498:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    349a:	40 86       	std	Z+8, r4	; 0x08
    349c:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    349e:	20 91 a0 32 	lds	r18, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    34a2:	30 91 a1 32 	lds	r19, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    34a6:	24 83       	std	Z+4, r18	; 0x04
    34a8:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    34aa:	80 92 a0 32 	sts	0x32A0, r8	; 0x8032a0 <last_created_task_pointer>
    34ae:	90 92 a1 32 	sts	0x32A1, r9	; 0x8032a1 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    34b2:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    34b4:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    34b6:	40 90 02 33 	lds	r4, 0x3302	; 0x803302 <portStackTopForTask>
    34ba:	50 90 03 33 	lds	r5, 0x3303	; 0x803303 <portStackTopForTask+0x1>
    34be:	ff ef       	ldi	r31, 0xFF	; 255
    34c0:	4f 1a       	sub	r4, r31
    34c2:	5f 0a       	sbc	r5, r31
    34c4:	40 92 02 33 	sts	0x3302, r4	; 0x803302 <portStackTopForTask>
    34c8:	50 92 03 33 	sts	0x3303, r5	; 0x803303 <portStackTopForTask+0x1>
    34cc:	f4 01       	movw	r30, r8
    34ce:	42 86       	std	Z+10, r4	; 0x0a
    34d0:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    34d2:	16 86       	std	Z+14, r1	; 0x0e
    34d4:	17 86       	std	Z+15, r1	; 0x0f
    34d6:	10 8a       	std	Z+16, r1	; 0x10
    34d8:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    34da:	61 14       	cp	r6, r1
    34dc:	71 04       	cpc	r7, r1
    34de:	09 f4       	brne	.+2      	; 0x34e2 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    34e0:	44 c0       	rjmp	.+136    	; 0x356a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    34e2:	81 30       	cpi	r24, 0x01	; 1
    34e4:	79 f5       	brne	.+94     	; 0x3544 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    34e6:	6a e0       	ldi	r22, 0x0A	; 10
    34e8:	c3 01       	movw	r24, r6
    34ea:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    34ee:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    34f0:	69 eb       	ldi	r22, 0xB9	; 185
    34f2:	75 e0       	ldi	r23, 0x05	; 5
    34f4:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    34f8:	be 01       	movw	r22, r28
    34fa:	6f 5f       	subi	r22, 0xFF	; 255
    34fc:	7f 4f       	sbci	r23, 0xFF	; 255
    34fe:	c7 01       	movw	r24, r14
    3500:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3504:	6a e0       	ldi	r22, 0x0A	; 10
    3506:	c7 01       	movw	r24, r14
    3508:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    350c:	7c 01       	movw	r14, r24
    350e:	60 eb       	ldi	r22, 0xB0	; 176
    3510:	75 e0       	ldi	r23, 0x05	; 5
    3512:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3516:	6a e0       	ldi	r22, 0x0A	; 10
    3518:	c7 01       	movw	r24, r14
    351a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    351e:	7c 01       	movw	r14, r24
    3520:	62 ea       	ldi	r22, 0xA2	; 162
    3522:	75 e0       	ldi	r23, 0x05	; 5
    3524:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3528:	63 e0       	ldi	r22, 0x03	; 3
    352a:	c7 01       	movw	r24, r14
    352c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3530:	b2 01       	movw	r22, r4
    3532:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    3536:	62 e0       	ldi	r22, 0x02	; 2
    3538:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    353c:	66 e0       	ldi	r22, 0x06	; 6
    353e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3542:	13 c0       	rjmp	.+38     	; 0x356a <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    3544:	6a e0       	ldi	r22, 0x0A	; 10
    3546:	c3 01       	movw	r24, r6
    3548:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    354c:	4c 01       	movw	r8, r24
    354e:	6d e8       	ldi	r22, 0x8D	; 141
    3550:	75 e0       	ldi	r23, 0x05	; 5
    3552:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3556:	be 01       	movw	r22, r28
    3558:	6f 5f       	subi	r22, 0xFF	; 255
    355a:	7f 4f       	sbci	r23, 0xFF	; 255
    355c:	c4 01       	movw	r24, r8
    355e:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3562:	66 e0       	ldi	r22, 0x06	; 6
    3564:	c4 01       	movw	r24, r8
    3566:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    356a:	2a 96       	adiw	r28, 0x0a	; 10
    356c:	cd bf       	out	0x3d, r28	; 61
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	df 91       	pop	r29
    3572:	cf 91       	pop	r28
    3574:	1f 91       	pop	r17
    3576:	0f 91       	pop	r16
    3578:	ff 90       	pop	r15
    357a:	ef 90       	pop	r14
    357c:	df 90       	pop	r13
    357e:	cf 90       	pop	r12
    3580:	bf 90       	pop	r11
    3582:	af 90       	pop	r10
    3584:	9f 90       	pop	r9
    3586:	8f 90       	pop	r8
    3588:	7f 90       	pop	r7
    358a:	6f 90       	pop	r6
    358c:	5f 90       	pop	r5
    358e:	4f 90       	pop	r4
    3590:	08 95       	ret

00003592 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3592:	cf 92       	push	r12
    3594:	df 92       	push	r13
    3596:	ef 92       	push	r14
    3598:	ff 92       	push	r15
    359a:	0f 93       	push	r16
    359c:	1f 93       	push	r17
    359e:	cf 93       	push	r28
    35a0:	df 93       	push	r29
    35a2:	ec 01       	movw	r28, r24
    35a4:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    35a6:	8a 81       	ldd	r24, Y+2	; 0x02
    35a8:	9b 81       	ldd	r25, Y+3	; 0x03
    35aa:	0e 94 42 16 	call	0x2c84	; 0x2c84 <pcTaskGetTaskName>
    35ae:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    35b0:	6a e0       	ldi	r22, 0x0A	; 10
    35b2:	c7 01       	movw	r24, r14
    35b4:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    35b8:	8c 01       	movw	r16, r24
    35ba:	6c ec       	ldi	r22, 0xCC	; 204
    35bc:	75 e0       	ldi	r23, 0x05	; 5
    35be:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    35c2:	6a e0       	ldi	r22, 0x0A	; 10
    35c4:	c8 01       	movw	r24, r16
    35c6:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    35ca:	8c 01       	movw	r16, r24
    35cc:	65 ec       	ldi	r22, 0xC5	; 197
    35ce:	75 e0       	ldi	r23, 0x05	; 5
    35d0:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    35d4:	b6 01       	movw	r22, r12
    35d6:	c8 01       	movw	r24, r16
    35d8:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    35dc:	6a e0       	ldi	r22, 0x0A	; 10
    35de:	c8 01       	movw	r24, r16
    35e0:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    35e4:	8c 01       	movw	r16, r24
    35e6:	6f eb       	ldi	r22, 0xBF	; 191
    35e8:	75 e0       	ldi	r23, 0x05	; 5
    35ea:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    35ee:	66 e0       	ldi	r22, 0x06	; 6
    35f0:	c8 01       	movw	r24, r16
    35f2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    35f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    35f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    35fa:	e8 85       	ldd	r30, Y+8	; 0x08
    35fc:	f9 85       	ldd	r31, Y+9	; 0x09
    35fe:	01 e1       	ldi	r16, 0x11	; 17
    3600:	21 e0       	ldi	r18, 0x01	; 1
    3602:	a7 01       	movw	r20, r14
    3604:	bc 01       	movw	r22, r24
    3606:	8e 1b       	sub	r24, r30
    3608:	9f 0b       	sbc	r25, r31
    360a:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    360e:	8c 81       	ldd	r24, Y+4	; 0x04
    3610:	9d 81       	ldd	r25, Y+5	; 0x05
    3612:	00 97       	sbiw	r24, 0x00	; 0
    3614:	19 f0       	breq	.+6      	; 0x361c <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3616:	b7 01       	movw	r22, r14
    3618:	0e 94 c9 1a 	call	0x3592	; 0x3592 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    361c:	df 91       	pop	r29
    361e:	cf 91       	pop	r28
    3620:	1f 91       	pop	r17
    3622:	0f 91       	pop	r16
    3624:	ff 90       	pop	r15
    3626:	ef 90       	pop	r14
    3628:	df 90       	pop	r13
    362a:	cf 90       	pop	r12
    362c:	08 95       	ret

0000362e <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    362e:	0f 93       	push	r16
    3630:	1f 93       	push	r17
    3632:	cf 93       	push	r28
    3634:	df 93       	push	r29
    3636:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    3638:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    363c:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    3640:	00 97       	sbiw	r24, 0x00	; 0
    3642:	19 f0       	breq	.+6      	; 0x364a <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3644:	be 01       	movw	r22, r28
    3646:	0e 94 c9 1a 	call	0x3592	; 0x3592 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    364a:	6a e0       	ldi	r22, 0x0A	; 10
    364c:	ce 01       	movw	r24, r28
    364e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3652:	8c 01       	movw	r16, r24
    3654:	62 ee       	ldi	r22, 0xE2	; 226
    3656:	75 e0       	ldi	r23, 0x05	; 5
    3658:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    365c:	6a e0       	ldi	r22, 0x0A	; 10
    365e:	c8 01       	movw	r24, r16
    3660:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3664:	8c 01       	movw	r16, r24
    3666:	67 ed       	ldi	r22, 0xD7	; 215
    3668:	75 e0       	ldi	r23, 0x05	; 5
    366a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    366e:	6a e0       	ldi	r22, 0x0A	; 10
    3670:	c8 01       	movw	r24, r16
    3672:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3676:	8c 01       	movw	r16, r24
    3678:	61 ed       	ldi	r22, 0xD1	; 209
    367a:	75 e0       	ldi	r23, 0x05	; 5
    367c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3680:	66 e0       	ldi	r22, 0x06	; 6
    3682:	c8 01       	movw	r24, r16
    3684:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3688:	80 91 02 33 	lds	r24, 0x3302	; 0x803302 <portStackTopForTask>
    368c:	90 91 03 33 	lds	r25, 0x3303	; 0x803303 <portStackTopForTask+0x1>
    3690:	bc 01       	movw	r22, r24
    3692:	6f 5f       	subi	r22, 0xFF	; 255
    3694:	7f 4f       	sbci	r23, 0xFF	; 255
    3696:	01 e1       	ldi	r16, 0x11	; 17
    3698:	21 e0       	ldi	r18, 0x01	; 1
    369a:	ae 01       	movw	r20, r28
    369c:	83 56       	subi	r24, 0x63	; 99
    369e:	91 09       	sbc	r25, r1
    36a0:	0e 94 cb 1d 	call	0x3b96	; 0x3b96 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    36a4:	df 91       	pop	r29
    36a6:	cf 91       	pop	r28
    36a8:	1f 91       	pop	r17
    36aa:	0f 91       	pop	r16
    36ac:	08 95       	ret

000036ae <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    36ae:	8f 92       	push	r8
    36b0:	9f 92       	push	r9
    36b2:	af 92       	push	r10
    36b4:	bf 92       	push	r11
    36b6:	cf 92       	push	r12
    36b8:	df 92       	push	r13
    36ba:	ef 92       	push	r14
    36bc:	ff 92       	push	r15
    36be:	0f 93       	push	r16
    36c0:	1f 93       	push	r17
    36c2:	cf 93       	push	r28
    36c4:	df 93       	push	r29
    36c6:	ec 01       	movw	r28, r24
    36c8:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    36ca:	8a 81       	ldd	r24, Y+2	; 0x02
    36cc:	9b 81       	ldd	r25, Y+3	; 0x03
    36ce:	0e 94 42 16 	call	0x2c84	; 0x2c84 <pcTaskGetTaskName>
    36d2:	bc 01       	movw	r22, r24
    36d4:	c8 01       	movw	r24, r16
    36d6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    36da:	d8 01       	movw	r26, r16
    36dc:	ed 91       	ld	r30, X+
    36de:	fc 91       	ld	r31, X
    36e0:	02 80       	ldd	r0, Z+2	; 0x02
    36e2:	f3 81       	ldd	r31, Z+3	; 0x03
    36e4:	e0 2d       	mov	r30, r0
    36e6:	69 e0       	ldi	r22, 0x09	; 9
    36e8:	c8 01       	movw	r24, r16
    36ea:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    36ec:	8a 81       	ldd	r24, Y+2	; 0x02
    36ee:	9b 81       	ldd	r25, Y+3	; 0x03
    36f0:	0e 94 42 16 	call	0x2c84	; 0x2c84 <pcTaskGetTaskName>
    36f4:	fc 01       	movw	r30, r24
    36f6:	01 90       	ld	r0, Z+
    36f8:	00 20       	and	r0, r0
    36fa:	e9 f7       	brne	.-6      	; 0x36f6 <_ZN8frt_task12print_statusER8emstream+0x48>
    36fc:	31 97       	sbiw	r30, 0x01	; 1
    36fe:	e8 1b       	sub	r30, r24
    3700:	f9 0b       	sbc	r31, r25
    3702:	38 97       	sbiw	r30, 0x08	; 8
    3704:	48 f4       	brcc	.+18     	; 0x3718 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3706:	d8 01       	movw	r26, r16
    3708:	ed 91       	ld	r30, X+
    370a:	fc 91       	ld	r31, X
    370c:	02 80       	ldd	r0, Z+2	; 0x02
    370e:	f3 81       	ldd	r31, Z+3	; 0x03
    3710:	e0 2d       	mov	r30, r0
    3712:	69 e0       	ldi	r22, 0x09	; 9
    3714:	c8 01       	movw	r24, r16
    3716:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    3718:	ce 84       	ldd	r12, Y+14	; 0x0e
    371a:	df 84       	ldd	r13, Y+15	; 0x0f
    371c:	e8 88       	ldd	r14, Y+16	; 0x10
    371e:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3720:	a8 84       	ldd	r10, Y+8	; 0x08
    3722:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3724:	8a 81       	ldd	r24, Y+2	; 0x02
    3726:	9b 81       	ldd	r25, Y+3	; 0x03
    3728:	0e 94 48 19 	call	0x3290	; 0x3290 <uxTaskGetStackHighWaterMark>
    372c:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    372e:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3730:	8a 81       	ldd	r24, Y+2	; 0x02
    3732:	9b 81       	ldd	r25, Y+3	; 0x03
    3734:	0e 94 ed 15 	call	0x2bda	; 0x2bda <uxTaskPriorityGet>
    3738:	68 2f       	mov	r22, r24
    373a:	c8 01       	movw	r24, r16
    373c:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    3740:	6a e0       	ldi	r22, 0x0A	; 10
    3742:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3746:	ec 01       	movw	r28, r24
    3748:	67 e5       	ldi	r22, 0x57	; 87
    374a:	76 e0       	ldi	r23, 0x06	; 6
    374c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3750:	68 2d       	mov	r22, r8
    3752:	ce 01       	movw	r24, r28
    3754:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3758:	6a e0       	ldi	r22, 0x0A	; 10
    375a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    375e:	ec 01       	movw	r28, r24
    3760:	65 e5       	ldi	r22, 0x55	; 85
    3762:	76 e0       	ldi	r23, 0x06	; 6
    3764:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3768:	69 2d       	mov	r22, r9
    376a:	ce 01       	movw	r24, r28
    376c:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    3770:	6a e0       	ldi	r22, 0x0A	; 10
    3772:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3776:	ec 01       	movw	r28, r24
    3778:	63 e5       	ldi	r22, 0x53	; 83
    377a:	76 e0       	ldi	r23, 0x06	; 6
    377c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3780:	b5 01       	movw	r22, r10
    3782:	ce 01       	movw	r24, r28
    3784:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    3788:	6a e0       	ldi	r22, 0x0A	; 10
    378a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    378e:	ec 01       	movw	r28, r24
    3790:	61 e5       	ldi	r22, 0x51	; 81
    3792:	76 e0       	ldi	r23, 0x06	; 6
    3794:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    3798:	6a e0       	ldi	r22, 0x0A	; 10
    379a:	ce 01       	movw	r24, r28
    379c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    37a0:	ec 01       	movw	r28, r24
    37a2:	6f e4       	ldi	r22, 0x4F	; 79
    37a4:	76 e0       	ldi	r23, 0x06	; 6
    37a6:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    37aa:	b7 01       	movw	r22, r14
    37ac:	a6 01       	movw	r20, r12
    37ae:	ce 01       	movw	r24, r28
    37b0:	0e 94 e2 1f 	call	0x3fc4	; 0x3fc4 <_ZN8emstreamlsEm>
}
    37b4:	df 91       	pop	r29
    37b6:	cf 91       	pop	r28
    37b8:	1f 91       	pop	r17
    37ba:	0f 91       	pop	r16
    37bc:	ff 90       	pop	r15
    37be:	ef 90       	pop	r14
    37c0:	df 90       	pop	r13
    37c2:	cf 90       	pop	r12
    37c4:	bf 90       	pop	r11
    37c6:	af 90       	pop	r10
    37c8:	9f 90       	pop	r9
    37ca:	8f 90       	pop	r8
    37cc:	08 95       	ret

000037ce <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    37ce:	cf 93       	push	r28
    37d0:	df 93       	push	r29
    37d2:	ec 01       	movw	r28, r24
    37d4:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    37d6:	db 01       	movw	r26, r22
    37d8:	ed 91       	ld	r30, X+
    37da:	fc 91       	ld	r31, X
    37dc:	02 80       	ldd	r0, Z+2	; 0x02
    37de:	f3 81       	ldd	r31, Z+3	; 0x03
    37e0:	e0 2d       	mov	r30, r0
    37e2:	be 01       	movw	r22, r28
    37e4:	19 95       	eicall
	return (ser_dev);
}
    37e6:	ce 01       	movw	r24, r28
    37e8:	df 91       	pop	r29
    37ea:	cf 91       	pop	r28
    37ec:	08 95       	ret

000037ee <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    37ee:	0f 93       	push	r16
    37f0:	1f 93       	push	r17
    37f2:	cf 93       	push	r28
    37f4:	df 93       	push	r29
    37f6:	ec 01       	movw	r28, r24
    37f8:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    37fa:	bc 01       	movw	r22, r24
    37fc:	c8 01       	movw	r24, r16
    37fe:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <_ZlsR8emstreamR8frt_task>
    3802:	66 e0       	ldi	r22, 0x06	; 6
    3804:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    3808:	8c 81       	ldd	r24, Y+4	; 0x04
    380a:	9d 81       	ldd	r25, Y+5	; 0x05
    380c:	00 97       	sbiw	r24, 0x00	; 0
    380e:	19 f0       	breq	.+6      	; 0x3816 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3810:	b8 01       	movw	r22, r16
    3812:	0e 94 f7 1b 	call	0x37ee	; 0x37ee <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	1f 91       	pop	r17
    381c:	0f 91       	pop	r16
    381e:	08 95       	ret

00003820 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3820:	0f 93       	push	r16
    3822:	1f 93       	push	r17
    3824:	cf 93       	push	r28
    3826:	df 93       	push	r29
    3828:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    382a:	6a e0       	ldi	r22, 0x0A	; 10
    382c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3830:	8c 01       	movw	r16, r24
    3832:	64 e4       	ldi	r22, 0x44	; 68
    3834:	76 e0       	ldi	r23, 0x06	; 6
    3836:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    383a:	6a e0       	ldi	r22, 0x0A	; 10
    383c:	c8 01       	movw	r24, r16
    383e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3842:	8c 01       	movw	r16, r24
    3844:	6d e3       	ldi	r22, 0x3D	; 61
    3846:	76 e0       	ldi	r23, 0x06	; 6
    3848:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    384c:	66 e0       	ldi	r22, 0x06	; 6
    384e:	c8 01       	movw	r24, r16
    3850:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3854:	6a e0       	ldi	r22, 0x0A	; 10
    3856:	ce 01       	movw	r24, r28
    3858:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    385c:	8c 01       	movw	r16, r24
    385e:	6c e2       	ldi	r22, 0x2C	; 44
    3860:	76 e0       	ldi	r23, 0x06	; 6
    3862:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3866:	6a e0       	ldi	r22, 0x0A	; 10
    3868:	c8 01       	movw	r24, r16
    386a:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    386e:	8c 01       	movw	r16, r24
    3870:	60 e2       	ldi	r22, 0x20	; 32
    3872:	76 e0       	ldi	r23, 0x06	; 6
    3874:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3878:	6a e0       	ldi	r22, 0x0A	; 10
    387a:	c8 01       	movw	r24, r16
    387c:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3880:	8c 01       	movw	r16, r24
    3882:	6a e1       	ldi	r22, 0x1A	; 26
    3884:	76 e0       	ldi	r23, 0x06	; 6
    3886:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    388a:	66 e0       	ldi	r22, 0x06	; 6
    388c:	c8 01       	movw	r24, r16
    388e:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3892:	6a e0       	ldi	r22, 0x0A	; 10
    3894:	ce 01       	movw	r24, r28
    3896:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    389a:	8c 01       	movw	r16, r24
    389c:	69 e0       	ldi	r22, 0x09	; 9
    389e:	76 e0       	ldi	r23, 0x06	; 6
    38a0:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    38a4:	6a e0       	ldi	r22, 0x0A	; 10
    38a6:	c8 01       	movw	r24, r16
    38a8:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    38ac:	8c 01       	movw	r16, r24
    38ae:	6d ef       	ldi	r22, 0xFD	; 253
    38b0:	75 e0       	ldi	r23, 0x05	; 5
    38b2:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    38b6:	6a e0       	ldi	r22, 0x0A	; 10
    38b8:	c8 01       	movw	r24, r16
    38ba:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    38be:	8c 01       	movw	r16, r24
    38c0:	67 ef       	ldi	r22, 0xF7	; 247
    38c2:	75 e0       	ldi	r23, 0x05	; 5
    38c4:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    38c8:	66 e0       	ldi	r22, 0x06	; 6
    38ca:	c8 01       	movw	r24, r16
    38cc:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    38d0:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    38d4:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    38d8:	00 97       	sbiw	r24, 0x00	; 0
    38da:	19 f0       	breq	.+6      	; 0x38e2 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    38dc:	be 01       	movw	r22, r28
    38de:	0e 94 f7 1b 	call	0x37ee	; 0x37ee <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    38e2:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <xTaskGetIdleTaskHandle>
    38e6:	0e 94 48 19 	call	0x3290	; 0x3290 <uxTaskGetStackHighWaterMark>
    38ea:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    38ec:	6a e0       	ldi	r22, 0x0A	; 10
    38ee:	ce 01       	movw	r24, r28
    38f0:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    38f4:	ec 01       	movw	r28, r24
    38f6:	6c ee       	ldi	r22, 0xEC	; 236
    38f8:	75 e0       	ldi	r23, 0x05	; 5
    38fa:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    38fe:	61 2f       	mov	r22, r17
    3900:	ce 01       	movw	r24, r28
    3902:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3906:	6a e0       	ldi	r22, 0x0A	; 10
    3908:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    390c:	ec 01       	movw	r28, r24
    390e:	6a ee       	ldi	r22, 0xEA	; 234
    3910:	75 e0       	ldi	r23, 0x05	; 5
    3912:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3916:	64 e6       	ldi	r22, 0x64	; 100
    3918:	70 e0       	ldi	r23, 0x00	; 0
    391a:	ce 01       	movw	r24, r28
    391c:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    3920:	6a e0       	ldi	r22, 0x0A	; 10
    3922:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3926:	ec 01       	movw	r28, r24
    3928:	67 ee       	ldi	r22, 0xE7	; 231
    392a:	75 e0       	ldi	r23, 0x05	; 5
    392c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3930:	66 e0       	ldi	r22, 0x06	; 6
    3932:	ce 01       	movw	r24, r28
    3934:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
}
    3938:	df 91       	pop	r29
    393a:	cf 91       	pop	r28
    393c:	1f 91       	pop	r17
    393e:	0f 91       	pop	r16
    3940:	08 95       	ret

00003942 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3942:	0f 93       	push	r16
    3944:	cf 93       	push	r28
    3946:	df 93       	push	r29
    3948:	1f 92       	push	r1
    394a:	cd b7       	in	r28, 0x3d	; 61
    394c:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    394e:	00 e0       	ldi	r16, 0x00	; 0
    3950:	2f ef       	ldi	r18, 0xFF	; 255
    3952:	3f ef       	ldi	r19, 0xFF	; 255
    3954:	a9 01       	movw	r20, r18
    3956:	be 01       	movw	r22, r28
    3958:	6f 5f       	subi	r22, 0xFF	; 255
    395a:	7f 4f       	sbci	r23, 0xFF	; 255
    395c:	fc 01       	movw	r30, r24
    395e:	80 85       	ldd	r24, Z+8	; 0x08
    3960:	91 85       	ldd	r25, Z+9	; 0x09
    3962:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
    3966:	81 30       	cpi	r24, 0x01	; 1
    3968:	19 f4       	brne	.+6      	; 0x3970 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    396a:	89 81       	ldd	r24, Y+1	; 0x01
    396c:	90 e0       	ldi	r25, 0x00	; 0
    396e:	02 c0       	rjmp	.+4      	; 0x3974 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3970:	8f ef       	ldi	r24, 0xFF	; 255
    3972:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3974:	0f 90       	pop	r0
    3976:	df 91       	pop	r29
    3978:	cf 91       	pop	r28
    397a:	0f 91       	pop	r16
    397c:	08 95       	ret

0000397e <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    397e:	fc 01       	movw	r30, r24
    3980:	80 85       	ldd	r24, Z+8	; 0x08
    3982:	91 85       	ldd	r25, Z+9	; 0x09
    3984:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    3988:	91 e0       	ldi	r25, 0x01	; 1
    398a:	81 11       	cpse	r24, r1
    398c:	01 c0       	rjmp	.+2      	; 0x3990 <_ZN14frt_text_queue14check_for_charEv+0x12>
    398e:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3990:	89 2f       	mov	r24, r25
    3992:	08 95       	ret

00003994 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3994:	0f 93       	push	r16
    3996:	cf 93       	push	r28
    3998:	df 93       	push	r29
    399a:	1f 92       	push	r1
    399c:	cd b7       	in	r28, 0x3d	; 61
    399e:	de b7       	in	r29, 0x3e	; 62
    39a0:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    39a2:	fc 01       	movw	r30, r24
    39a4:	22 85       	ldd	r18, Z+10	; 0x0a
    39a6:	33 85       	ldd	r19, Z+11	; 0x0b
    39a8:	44 85       	ldd	r20, Z+12	; 0x0c
    39aa:	55 85       	ldd	r21, Z+13	; 0x0d
    39ac:	00 e0       	ldi	r16, 0x00	; 0
    39ae:	be 01       	movw	r22, r28
    39b0:	6f 5f       	subi	r22, 0xFF	; 255
    39b2:	7f 4f       	sbci	r23, 0xFF	; 255
    39b4:	80 85       	ldd	r24, Z+8	; 0x08
    39b6:	91 85       	ldd	r25, Z+9	; 0x09
    39b8:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    39bc:	91 e0       	ldi	r25, 0x01	; 1
    39be:	81 11       	cpse	r24, r1
    39c0:	01 c0       	rjmp	.+2      	; 0x39c4 <_ZN14frt_text_queue7putcharEc+0x30>
    39c2:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    39c4:	89 2f       	mov	r24, r25
    39c6:	0f 90       	pop	r0
    39c8:	df 91       	pop	r29
    39ca:	cf 91       	pop	r28
    39cc:	0f 91       	pop	r16
    39ce:	08 95       	ret

000039d0 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    39d0:	8f 92       	push	r8
    39d2:	9f 92       	push	r9
    39d4:	bf 92       	push	r11
    39d6:	cf 92       	push	r12
    39d8:	df 92       	push	r13
    39da:	ef 92       	push	r14
    39dc:	ff 92       	push	r15
    39de:	0f 93       	push	r16
    39e0:	1f 93       	push	r17
    39e2:	cf 93       	push	r28
    39e4:	df 93       	push	r29
    39e6:	ec 01       	movw	r28, r24
    39e8:	b6 2e       	mov	r11, r22
    39ea:	4a 01       	movw	r8, r20
    39ec:	68 01       	movw	r12, r16
    39ee:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    39f0:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <_ZN8emstreamC1Ev>
    39f4:	84 e9       	ldi	r24, 0x94	; 148
    39f6:	91 e2       	ldi	r25, 0x21	; 33
    39f8:	88 83       	st	Y, r24
    39fa:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    39fc:	8e 86       	std	Y+14, r8	; 0x0e
    39fe:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3a00:	40 e0       	ldi	r20, 0x00	; 0
    3a02:	61 e0       	ldi	r22, 0x01	; 1
    3a04:	8b 2d       	mov	r24, r11
    3a06:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    3a0a:	88 87       	std	Y+8, r24	; 0x08
    3a0c:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3a0e:	ca 86       	std	Y+10, r12	; 0x0a
    3a10:	db 86       	std	Y+11, r13	; 0x0b
    3a12:	ec 86       	std	Y+12, r14	; 0x0c
    3a14:	fd 86       	std	Y+13, r15	; 0x0d
}
    3a16:	df 91       	pop	r29
    3a18:	cf 91       	pop	r28
    3a1a:	1f 91       	pop	r17
    3a1c:	0f 91       	pop	r16
    3a1e:	ff 90       	pop	r15
    3a20:	ef 90       	pop	r14
    3a22:	df 90       	pop	r13
    3a24:	cf 90       	pop	r12
    3a26:	bf 90       	pop	r11
    3a28:	9f 90       	pop	r9
    3a2a:	8f 90       	pop	r8
    3a2c:	08 95       	ret

00003a2e <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3a2e:	cf 92       	push	r12
    3a30:	df 92       	push	r13
    3a32:	ef 92       	push	r14
    3a34:	ff 92       	push	r15
    3a36:	cf 93       	push	r28
    3a38:	df 93       	push	r29
    3a3a:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3a3c:	68 81       	ld	r22, Y
    3a3e:	79 81       	ldd	r23, Y+1	; 0x01
    3a40:	8a 81       	ldd	r24, Y+2	; 0x02
    3a42:	9b 81       	ldd	r25, Y+3	; 0x03
    3a44:	0f 2e       	mov	r0, r31
    3a46:	f8 ee       	ldi	r31, 0xE8	; 232
    3a48:	cf 2e       	mov	r12, r31
    3a4a:	f3 e0       	ldi	r31, 0x03	; 3
    3a4c:	df 2e       	mov	r13, r31
    3a4e:	e1 2c       	mov	r14, r1
    3a50:	f1 2c       	mov	r15, r1
    3a52:	f0 2d       	mov	r31, r0
    3a54:	a7 01       	movw	r20, r14
    3a56:	96 01       	movw	r18, r12
    3a58:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
    3a5c:	9b 01       	movw	r18, r22
    3a5e:	ac 01       	movw	r20, r24
    3a60:	60 e4       	ldi	r22, 0x40	; 64
    3a62:	72 e4       	ldi	r23, 0x42	; 66
    3a64:	8f e0       	ldi	r24, 0x0F	; 15
    3a66:	90 e0       	ldi	r25, 0x00	; 0
    3a68:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <__mulsi3>
    3a6c:	a7 01       	movw	r20, r14
    3a6e:	96 01       	movw	r18, r12
    3a70:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
    3a74:	69 01       	movw	r12, r18
    3a76:	7a 01       	movw	r14, r20
    3a78:	ac 81       	ldd	r26, Y+4	; 0x04
    3a7a:	bd 81       	ldd	r27, Y+5	; 0x05
    3a7c:	20 e4       	ldi	r18, 0x40	; 64
    3a7e:	32 e4       	ldi	r19, 0x42	; 66
    3a80:	4f e0       	ldi	r20, 0x0F	; 15
    3a82:	50 e0       	ldi	r21, 0x00	; 0
    3a84:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <__muluhisi3>
    3a88:	20 e0       	ldi	r18, 0x00	; 0
    3a8a:	38 e4       	ldi	r19, 0x48	; 72
    3a8c:	48 ee       	ldi	r20, 0xE8	; 232
    3a8e:	51 e0       	ldi	r21, 0x01	; 1
    3a90:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
    3a94:	c7 01       	movw	r24, r14
    3a96:	b6 01       	movw	r22, r12
    3a98:	62 0f       	add	r22, r18
    3a9a:	73 1f       	adc	r23, r19
    3a9c:	84 1f       	adc	r24, r20
    3a9e:	95 1f       	adc	r25, r21
}
    3aa0:	df 91       	pop	r29
    3aa2:	cf 91       	pop	r28
    3aa4:	ff 90       	pop	r15
    3aa6:	ef 90       	pop	r14
    3aa8:	df 90       	pop	r13
    3aaa:	cf 90       	pop	r12
    3aac:	08 95       	ret

00003aae <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3aae:	cf 92       	push	r12
    3ab0:	df 92       	push	r13
    3ab2:	ef 92       	push	r14
    3ab4:	ff 92       	push	r15
    3ab6:	0f 93       	push	r16
    3ab8:	1f 93       	push	r17
    3aba:	cf 93       	push	r28
    3abc:	df 93       	push	r29
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62
    3ac2:	2f 97       	sbiw	r28, 0x0f	; 15
    3ac4:	cd bf       	out	0x3d, r28	; 61
    3ac6:	de bf       	out	0x3e, r29	; 62
    3ac8:	6c 01       	movw	r12, r24
    3aca:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3acc:	db 01       	movw	r26, r22
    3ace:	6d 91       	ld	r22, X+
    3ad0:	7d 91       	ld	r23, X+
    3ad2:	8d 91       	ld	r24, X+
    3ad4:	9c 91       	ld	r25, X
    3ad6:	28 ee       	ldi	r18, 0xE8	; 232
    3ad8:	33 e0       	ldi	r19, 0x03	; 3
    3ada:	40 e0       	ldi	r20, 0x00	; 0
    3adc:	50 e0       	ldi	r21, 0x00	; 0
    3ade:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
    3ae2:	ba 01       	movw	r22, r20
    3ae4:	a9 01       	movw	r20, r18
    3ae6:	c6 01       	movw	r24, r12
    3ae8:	0e 94 e2 1f 	call	0x3fc4	; 0x3fc4 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3aec:	d6 01       	movw	r26, r12
    3aee:	ed 91       	ld	r30, X+
    3af0:	fc 91       	ld	r31, X
    3af2:	02 80       	ldd	r0, Z+2	; 0x02
    3af4:	f3 81       	ldd	r31, Z+3	; 0x03
    3af6:	e0 2d       	mov	r30, r0
    3af8:	6e e2       	ldi	r22, 0x2E	; 46
    3afa:	c6 01       	movw	r24, r12
    3afc:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3afe:	c8 01       	movw	r24, r16
    3b00:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <_ZN10time_stamp12get_microsecEv>
    3b04:	8e 01       	movw	r16, r28
    3b06:	09 5f       	subi	r16, 0xF9	; 249
    3b08:	1f 4f       	sbci	r17, 0xFF	; 255
    3b0a:	fe 01       	movw	r30, r28
    3b0c:	31 96       	adiw	r30, 0x01	; 1
    3b0e:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3b10:	2a e0       	ldi	r18, 0x0A	; 10
    3b12:	30 e0       	ldi	r19, 0x00	; 0
    3b14:	40 e0       	ldi	r20, 0x00	; 0
    3b16:	50 e0       	ldi	r21, 0x00	; 0
    3b18:	0e 94 b8 26 	call	0x4d70	; 0x4d70 <__divmodsi4>
    3b1c:	e6 2f       	mov	r30, r22
    3b1e:	28 87       	std	Y+8, r18	; 0x08
    3b20:	39 87       	std	Y+9, r19	; 0x09
    3b22:	4a 87       	std	Y+10, r20	; 0x0a
    3b24:	5b 87       	std	Y+11, r21	; 0x0b
    3b26:	68 85       	ldd	r22, Y+8	; 0x08
    3b28:	79 85       	ldd	r23, Y+9	; 0x09
    3b2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b2c:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3b2e:	20 e3       	ldi	r18, 0x30	; 48
    3b30:	2e 0f       	add	r18, r30
    3b32:	d8 01       	movw	r26, r16
    3b34:	2e 93       	st	-X, r18
    3b36:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3b38:	ae 15       	cp	r26, r14
    3b3a:	bf 05       	cpc	r27, r15
    3b3c:	49 f7       	brne	.-46     	; 0x3b10 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3b3e:	1f 82       	std	Y+7, r1	; 0x07
    3b40:	be 01       	movw	r22, r28
    3b42:	6f 5f       	subi	r22, 0xFF	; 255
    3b44:	7f 4f       	sbci	r23, 0xFF	; 255
    3b46:	c6 01       	movw	r24, r12
    3b48:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3b4c:	c6 01       	movw	r24, r12
    3b4e:	2f 96       	adiw	r28, 0x0f	; 15
    3b50:	cd bf       	out	0x3d, r28	; 61
    3b52:	de bf       	out	0x3e, r29	; 62
    3b54:	df 91       	pop	r29
    3b56:	cf 91       	pop	r28
    3b58:	1f 91       	pop	r17
    3b5a:	0f 91       	pop	r16
    3b5c:	ff 90       	pop	r15
    3b5e:	ef 90       	pop	r14
    3b60:	df 90       	pop	r13
    3b62:	cf 90       	pop	r12
    3b64:	08 95       	ret

00003b66 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3b66:	cf 93       	push	r28
    3b68:	df 93       	push	r29
    3b6a:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3b6c:	0f b6       	in	r0, 0x3f	; 63
    3b6e:	f8 94       	cli
    3b70:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3b72:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3b76:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3b7a:	8c 83       	std	Y+4, r24	; 0x04
    3b7c:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3b7e:	0e 94 34 16 	call	0x2c68	; 0x2c68 <xTaskGetTickCount>
    3b82:	68 83       	st	Y, r22
    3b84:	79 83       	std	Y+1, r23	; 0x01
    3b86:	8a 83       	std	Y+2, r24	; 0x02
    3b88:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3b8a:	0f 90       	pop	r0
    3b8c:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3b8e:	ce 01       	movw	r24, r28
    3b90:	df 91       	pop	r29
    3b92:	cf 91       	pop	r28
    3b94:	08 95       	ret

00003b96 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3b96:	5f 92       	push	r5
    3b98:	6f 92       	push	r6
    3b9a:	7f 92       	push	r7
    3b9c:	8f 92       	push	r8
    3b9e:	9f 92       	push	r9
    3ba0:	af 92       	push	r10
    3ba2:	bf 92       	push	r11
    3ba4:	cf 92       	push	r12
    3ba6:	df 92       	push	r13
    3ba8:	ef 92       	push	r14
    3baa:	ff 92       	push	r15
    3bac:	0f 93       	push	r16
    3bae:	1f 93       	push	r17
    3bb0:	cf 93       	push	r28
    3bb2:	df 93       	push	r29
    3bb4:	5c 01       	movw	r10, r24
    3bb6:	4b 01       	movw	r8, r22
    3bb8:	7a 01       	movw	r14, r20
    3bba:	12 2f       	mov	r17, r18
    3bbc:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3bbe:	63 e0       	ldi	r22, 0x03	; 3
    3bc0:	ca 01       	movw	r24, r20
    3bc2:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3bc6:	a8 14       	cp	r10, r8
    3bc8:	b9 04       	cpc	r11, r9
    3bca:	08 f0       	brcs	.+2      	; 0x3bce <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3bcc:	7d c0       	rjmp	.+250    	; 0x3cc8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3bce:	65 01       	movw	r12, r10
    3bd0:	84 e1       	ldi	r24, 0x14	; 20
    3bd2:	c8 0e       	add	r12, r24
    3bd4:	d1 1c       	adc	r13, r1
    3bd6:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3bd8:	6a 2c       	mov	r6, r10
    3bda:	5b 2c       	mov	r5, r11
    3bdc:	b5 01       	movw	r22, r10
    3bde:	c7 01       	movw	r24, r14
    3be0:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <_ZN8emstreamlsEj>
    3be4:	6a e0       	ldi	r22, 0x0A	; 10
    3be6:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3bea:	69 e6       	ldi	r22, 0x69	; 105
    3bec:	76 e0       	ldi	r23, 0x06	; 6
    3bee:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3bf2:	11 23       	and	r17, r17
    3bf4:	09 f4       	brne	.+2      	; 0x3bf8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3bf6:	6d c0       	rjmp	.+218    	; 0x3cd2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3bf8:	00 23       	and	r16, r16
    3bfa:	09 f4       	brne	.+2      	; 0x3bfe <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3bfc:	6a c0       	rjmp	.+212    	; 0x3cd2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3bfe:	6a e0       	ldi	r22, 0x0A	; 10
    3c00:	c7 01       	movw	r24, r14
    3c02:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3c06:	64 e6       	ldi	r22, 0x64	; 100
    3c08:	76 e0       	ldi	r23, 0x06	; 6
    3c0a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    3c0e:	61 c0       	rjmp	.+194    	; 0x3cd2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3c10:	11 23       	and	r17, r17
    3c12:	71 f0       	breq	.+28     	; 0x3c30 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c14:	01 11       	cpse	r16, r1
    3c16:	0c c0       	rjmp	.+24     	; 0x3c30 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c18:	88 81       	ld	r24, Y
    3c1a:	87 15       	cp	r24, r7
    3c1c:	49 f0       	breq	.+18     	; 0x3c30 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3c1e:	6a e0       	ldi	r22, 0x0A	; 10
    3c20:	c7 01       	movw	r24, r14
    3c22:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3c26:	6f e5       	ldi	r22, 0x5F	; 95
    3c28:	76 e0       	ldi	r23, 0x06	; 6
    3c2a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c2e:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3c30:	69 91       	ld	r22, Y+
    3c32:	c7 01       	movw	r24, r14
    3c34:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c38:	dc 01       	movw	r26, r24
    3c3a:	ed 91       	ld	r30, X+
    3c3c:	fc 91       	ld	r31, X
    3c3e:	02 80       	ldd	r0, Z+2	; 0x02
    3c40:	f3 81       	ldd	r31, Z+3	; 0x03
    3c42:	e0 2d       	mov	r30, r0
    3c44:	60 e2       	ldi	r22, 0x20	; 32
    3c46:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3c48:	cc 16       	cp	r12, r28
    3c4a:	dd 06       	cpc	r13, r29
    3c4c:	09 f7       	brne	.-62     	; 0x3c10 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3c4e:	11 23       	and	r17, r17
    3c50:	89 f0       	breq	.+34     	; 0x3c74 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3c52:	6a e0       	ldi	r22, 0x0A	; 10
    3c54:	c7 01       	movw	r24, r14
    3c56:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3c5a:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c5c:	69 e5       	ldi	r22, 0x59	; 89
    3c5e:	76 e0       	ldi	r23, 0x06	; 6
    3c60:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c64:	e8 81       	ld	r30, Y
    3c66:	f9 81       	ldd	r31, Y+1	; 0x01
    3c68:	02 80       	ldd	r0, Z+2	; 0x02
    3c6a:	f3 81       	ldd	r31, Z+3	; 0x03
    3c6c:	e0 2d       	mov	r30, r0
    3c6e:	60 e2       	ldi	r22, 0x20	; 32
    3c70:	ce 01       	movw	r24, r28
    3c72:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c74:	c6 2d       	mov	r28, r6
    3c76:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3c78:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3c7a:	80 ee       	ldi	r24, 0xE0	; 224
    3c7c:	86 0f       	add	r24, r22
    3c7e:	8f 35       	cpi	r24, 0x5F	; 95
    3c80:	48 f4       	brcc	.+18     	; 0x3c94 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3c82:	d7 01       	movw	r26, r14
    3c84:	ed 91       	ld	r30, X+
    3c86:	fc 91       	ld	r31, X
    3c88:	02 80       	ldd	r0, Z+2	; 0x02
    3c8a:	f3 81       	ldd	r31, Z+3	; 0x03
    3c8c:	e0 2d       	mov	r30, r0
    3c8e:	c7 01       	movw	r24, r14
    3c90:	19 95       	eicall
    3c92:	09 c0       	rjmp	.+18     	; 0x3ca6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3c94:	d7 01       	movw	r26, r14
    3c96:	ed 91       	ld	r30, X+
    3c98:	fc 91       	ld	r31, X
    3c9a:	02 80       	ldd	r0, Z+2	; 0x02
    3c9c:	f3 81       	ldd	r31, Z+3	; 0x03
    3c9e:	e0 2d       	mov	r30, r0
    3ca0:	6e e2       	ldi	r22, 0x2E	; 46
    3ca2:	c7 01       	movw	r24, r14
    3ca4:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3ca6:	cc 16       	cp	r12, r28
    3ca8:	dd 06       	cpc	r13, r29
    3caa:	31 f7       	brne	.-52     	; 0x3c78 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3cac:	b4 e1       	ldi	r27, 0x14	; 20
    3cae:	ab 0e       	add	r10, r27
    3cb0:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3cb2:	66 e0       	ldi	r22, 0x06	; 6
    3cb4:	c7 01       	movw	r24, r14
    3cb6:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    3cba:	84 e1       	ldi	r24, 0x14	; 20
    3cbc:	c8 0e       	add	r12, r24
    3cbe:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3cc0:	a8 14       	cp	r10, r8
    3cc2:	b9 04       	cpc	r11, r9
    3cc4:	08 f4       	brcc	.+2      	; 0x3cc8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3cc6:	88 cf       	rjmp	.-240    	; 0x3bd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3cc8:	62 e0       	ldi	r22, 0x02	; 2
    3cca:	c7 01       	movw	r24, r14
    3ccc:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
}
    3cd0:	03 c0       	rjmp	.+6      	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3cd2:	c6 2d       	mov	r28, r6
    3cd4:	d5 2d       	mov	r29, r5
    3cd6:	9c cf       	rjmp	.-200    	; 0x3c10 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3cd8:	df 91       	pop	r29
    3cda:	cf 91       	pop	r28
    3cdc:	1f 91       	pop	r17
    3cde:	0f 91       	pop	r16
    3ce0:	ff 90       	pop	r15
    3ce2:	ef 90       	pop	r14
    3ce4:	df 90       	pop	r13
    3ce6:	cf 90       	pop	r12
    3ce8:	bf 90       	pop	r11
    3cea:	af 90       	pop	r10
    3cec:	9f 90       	pop	r9
    3cee:	8f 90       	pop	r8
    3cf0:	7f 90       	pop	r7
    3cf2:	6f 90       	pop	r6
    3cf4:	5f 90       	pop	r5
    3cf6:	08 95       	ret

00003cf8 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3cf8:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    3cfc:	08 95       	ret

00003cfe <_Znaj>:
    3cfe:	0e 94 be 0e 	call	0x1d7c	; 0x1d7c <pvPortMalloc>
    3d02:	08 95       	ret

00003d04 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3d04:	08 95       	ret

00003d06 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	fc 01       	movw	r30, r24
    3d0c:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3d0e:	40 3a       	cpi	r20, 0xA0	; 160
    3d10:	68 e0       	ldi	r22, 0x08	; 8
    3d12:	56 07       	cpc	r21, r22
    3d14:	49 f4       	brne	.+18     	; 0x3d28 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3d16:	80 e4       	ldi	r24, 0x40	; 64
    3d18:	96 e0       	ldi	r25, 0x06	; 6
    3d1a:	82 83       	std	Z+2, r24	; 0x02
    3d1c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d1e:	82 e0       	ldi	r24, 0x02	; 2
    3d20:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d22:	83 e0       	ldi	r24, 0x03	; 3
    3d24:	85 83       	std	Z+5, r24	; 0x05
    3d26:	32 c0       	rjmp	.+100    	; 0x3d8c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3d28:	40 3b       	cpi	r20, 0xB0	; 176
    3d2a:	78 e0       	ldi	r23, 0x08	; 8
    3d2c:	57 07       	cpc	r21, r23
    3d2e:	49 f4       	brne	.+18     	; 0x3d42 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3d30:	80 e4       	ldi	r24, 0x40	; 64
    3d32:	96 e0       	ldi	r25, 0x06	; 6
    3d34:	82 83       	std	Z+2, r24	; 0x02
    3d36:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d38:	86 e0       	ldi	r24, 0x06	; 6
    3d3a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d3c:	87 e0       	ldi	r24, 0x07	; 7
    3d3e:	85 83       	std	Z+5, r24	; 0x05
    3d40:	25 c0       	rjmp	.+74     	; 0x3d8c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3d42:	40 3a       	cpi	r20, 0xA0	; 160
    3d44:	89 e0       	ldi	r24, 0x09	; 9
    3d46:	58 07       	cpc	r21, r24
    3d48:	49 f4       	brne	.+18     	; 0x3d5c <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3d4a:	80 e6       	ldi	r24, 0x60	; 96
    3d4c:	96 e0       	ldi	r25, 0x06	; 6
    3d4e:	82 83       	std	Z+2, r24	; 0x02
    3d50:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d52:	82 e0       	ldi	r24, 0x02	; 2
    3d54:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d56:	83 e0       	ldi	r24, 0x03	; 3
    3d58:	85 83       	std	Z+5, r24	; 0x05
    3d5a:	18 c0       	rjmp	.+48     	; 0x3d8c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3d5c:	40 3b       	cpi	r20, 0xB0	; 176
    3d5e:	69 e0       	ldi	r22, 0x09	; 9
    3d60:	56 07       	cpc	r21, r22
    3d62:	49 f4       	brne	.+18     	; 0x3d76 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3d64:	80 e6       	ldi	r24, 0x60	; 96
    3d66:	96 e0       	ldi	r25, 0x06	; 6
    3d68:	82 83       	std	Z+2, r24	; 0x02
    3d6a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d6c:	86 e0       	ldi	r24, 0x06	; 6
    3d6e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d70:	87 e0       	ldi	r24, 0x07	; 7
    3d72:	85 83       	std	Z+5, r24	; 0x05
    3d74:	0b c0       	rjmp	.+22     	; 0x3d8c <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3d76:	40 3a       	cpi	r20, 0xA0	; 160
    3d78:	5a 40       	sbci	r21, 0x0A	; 10
    3d7a:	41 f4       	brne	.+16     	; 0x3d8c <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3d7c:	80 e8       	ldi	r24, 0x80	; 128
    3d7e:	96 e0       	ldi	r25, 0x06	; 6
    3d80:	82 83       	std	Z+2, r24	; 0x02
    3d82:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d84:	82 e0       	ldi	r24, 0x02	; 2
    3d86:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d88:	83 e0       	ldi	r24, 0x03	; 3
    3d8a:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3d8c:	a6 83       	std	Z+6, r26	; 0x06
    3d8e:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3d90:	cd 01       	movw	r24, r26
    3d92:	01 96       	adiw	r24, 0x01	; 1
    3d94:	80 87       	std	Z+8, r24	; 0x08
    3d96:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3d98:	03 96       	adiw	r24, 0x03	; 3
    3d9a:	82 87       	std	Z+10, r24	; 0x0a
    3d9c:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3d9e:	25 81       	ldd	r18, Z+5	; 0x05
    3da0:	c2 81       	ldd	r28, Z+2	; 0x02
    3da2:	d3 81       	ldd	r29, Z+3	; 0x03
    3da4:	4c 81       	ldd	r20, Y+4	; 0x04
    3da6:	81 e0       	ldi	r24, 0x01	; 1
    3da8:	90 e0       	ldi	r25, 0x00	; 0
    3daa:	bc 01       	movw	r22, r24
    3dac:	02 c0       	rjmp	.+4      	; 0x3db2 <_ZN7base232C1EjP12USART_struct+0xac>
    3dae:	66 0f       	add	r22, r22
    3db0:	77 1f       	adc	r23, r23
    3db2:	2a 95       	dec	r18
    3db4:	e2 f7       	brpl	.-8      	; 0x3dae <_ZN7base232C1EjP12USART_struct+0xa8>
    3db6:	9b 01       	movw	r18, r22
    3db8:	24 2b       	or	r18, r20
    3dba:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3dbc:	25 81       	ldd	r18, Z+5	; 0x05
    3dbe:	c2 81       	ldd	r28, Z+2	; 0x02
    3dc0:	d3 81       	ldd	r29, Z+3	; 0x03
    3dc2:	48 81       	ld	r20, Y
    3dc4:	bc 01       	movw	r22, r24
    3dc6:	02 c0       	rjmp	.+4      	; 0x3dcc <_ZN7base232C1EjP12USART_struct+0xc6>
    3dc8:	66 0f       	add	r22, r22
    3dca:	77 1f       	adc	r23, r23
    3dcc:	2a 95       	dec	r18
    3dce:	e2 f7       	brpl	.-8      	; 0x3dc8 <_ZN7base232C1EjP12USART_struct+0xc2>
    3dd0:	9b 01       	movw	r18, r22
    3dd2:	24 2b       	or	r18, r20
    3dd4:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3dd6:	34 81       	ldd	r19, Z+4	; 0x04
    3dd8:	c2 81       	ldd	r28, Z+2	; 0x02
    3dda:	d3 81       	ldd	r29, Z+3	; 0x03
    3ddc:	28 81       	ld	r18, Y
    3dde:	02 c0       	rjmp	.+4      	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0xde>
    3de0:	88 0f       	add	r24, r24
    3de2:	99 1f       	adc	r25, r25
    3de4:	3a 95       	dec	r19
    3de6:	e2 f7       	brpl	.-8      	; 0x3de0 <_ZN7base232C1EjP12USART_struct+0xda>
    3de8:	80 95       	com	r24
    3dea:	90 95       	com	r25
    3dec:	82 23       	and	r24, r18
    3dee:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3df0:	80 e1       	ldi	r24, 0x10	; 16
    3df2:	13 96       	adiw	r26, 0x03	; 3
    3df4:	8c 93       	st	X, r24
    3df6:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3df8:	83 e0       	ldi	r24, 0x03	; 3
    3dfa:	15 96       	adiw	r26, 0x05	; 5
    3dfc:	8c 93       	st	X, r24
    3dfe:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3e00:	80 ef       	ldi	r24, 0xF0	; 240
    3e02:	17 96       	adiw	r26, 0x07	; 7
    3e04:	8c 93       	st	X, r24
    3e06:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3e08:	81 e2       	ldi	r24, 0x21	; 33
    3e0a:	16 96       	adiw	r26, 0x06	; 6
    3e0c:	8c 93       	st	X, r24
    3e0e:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3e10:	88 e1       	ldi	r24, 0x18	; 24
    3e12:	14 96       	adiw	r26, 0x04	; 4
    3e14:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3e16:	80 e8       	ldi	r24, 0x80	; 128
    3e18:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3e1a:	80 e4       	ldi	r24, 0x40	; 64
    3e1c:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3e1e:	80 e2       	ldi	r24, 0x20	; 32
    3e20:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3e22:	06 80       	ldd	r0, Z+6	; 0x06
    3e24:	f7 81       	ldd	r31, Z+7	; 0x07
    3e26:	e0 2d       	mov	r30, r0
    3e28:	80 81       	ld	r24, Z
    3e2a:	80 81       	ld	r24, Z
}
    3e2c:	df 91       	pop	r29
    3e2e:	cf 91       	pop	r28
    3e30:	08 95       	ret

00003e32 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3e32:	81 e0       	ldi	r24, 0x01	; 1
    3e34:	08 95       	ret

00003e36 <_ZN8emstream7getcharEv>:
    3e36:	80 e0       	ldi	r24, 0x00	; 0
    3e38:	90 e0       	ldi	r25, 0x00	; 0
    3e3a:	08 95       	ret

00003e3c <_ZN8emstream14check_for_charEv>:
    3e3c:	80 e0       	ldi	r24, 0x00	; 0
    3e3e:	08 95       	ret

00003e40 <_ZN8emstream12transmit_nowEv>:
    3e40:	08 95       	ret

00003e42 <_ZN8emstream12clear_screenEv>:
    3e42:	08 95       	ret

00003e44 <_ZN8emstreamC1Ev>:
    3e44:	fc 01       	movw	r30, r24
    3e46:	84 ea       	ldi	r24, 0xA4	; 164
    3e48:	91 e2       	ldi	r25, 0x21	; 33
    3e4a:	80 83       	st	Z, r24
    3e4c:	91 83       	std	Z+1, r25	; 0x01
    3e4e:	8a e0       	ldi	r24, 0x0A	; 10
    3e50:	82 83       	std	Z+2, r24	; 0x02
    3e52:	13 82       	std	Z+3, r1	; 0x03
    3e54:	83 e0       	ldi	r24, 0x03	; 3
    3e56:	85 83       	std	Z+5, r24	; 0x05
    3e58:	14 82       	std	Z+4, r1	; 0x04
    3e5a:	16 82       	std	Z+6, r1	; 0x06
    3e5c:	17 82       	std	Z+7, r1	; 0x07
    3e5e:	08 95       	ret

00003e60 <_ZN8emstream4putsEPKc>:
    3e60:	0f 93       	push	r16
    3e62:	1f 93       	push	r17
    3e64:	cf 93       	push	r28
    3e66:	df 93       	push	r29
    3e68:	8c 01       	movw	r16, r24
    3e6a:	fb 01       	movw	r30, r22
    3e6c:	dc 01       	movw	r26, r24
    3e6e:	14 96       	adiw	r26, 0x04	; 4
    3e70:	8c 91       	ld	r24, X
    3e72:	81 11       	cpse	r24, r1
    3e74:	04 c0       	rjmp	.+8      	; 0x3e7e <_ZN8emstream4putsEPKc+0x1e>
    3e76:	60 81       	ld	r22, Z
    3e78:	61 11       	cpse	r22, r1
    3e7a:	17 c0       	rjmp	.+46     	; 0x3eaa <_ZN8emstream4putsEPKc+0x4a>
    3e7c:	23 c0       	rjmp	.+70     	; 0x3ec4 <_ZN8emstream4putsEPKc+0x64>
    3e7e:	d8 01       	movw	r26, r16
    3e80:	14 96       	adiw	r26, 0x04	; 4
    3e82:	1c 92       	st	X, r1
    3e84:	eb 01       	movw	r28, r22
    3e86:	21 96       	adiw	r28, 0x01	; 1
    3e88:	64 91       	lpm	r22, Z
    3e8a:	66 23       	and	r22, r22
    3e8c:	d9 f0       	breq	.+54     	; 0x3ec4 <_ZN8emstream4putsEPKc+0x64>
    3e8e:	d8 01       	movw	r26, r16
    3e90:	ed 91       	ld	r30, X+
    3e92:	fc 91       	ld	r31, X
    3e94:	02 80       	ldd	r0, Z+2	; 0x02
    3e96:	f3 81       	ldd	r31, Z+3	; 0x03
    3e98:	e0 2d       	mov	r30, r0
    3e9a:	c8 01       	movw	r24, r16
    3e9c:	19 95       	eicall
    3e9e:	fe 01       	movw	r30, r28
    3ea0:	64 91       	lpm	r22, Z
    3ea2:	21 96       	adiw	r28, 0x01	; 1
    3ea4:	61 11       	cpse	r22, r1
    3ea6:	f3 cf       	rjmp	.-26     	; 0x3e8e <_ZN8emstream4putsEPKc+0x2e>
    3ea8:	0d c0       	rjmp	.+26     	; 0x3ec4 <_ZN8emstream4putsEPKc+0x64>
    3eaa:	ef 01       	movw	r28, r30
    3eac:	21 96       	adiw	r28, 0x01	; 1
    3eae:	d8 01       	movw	r26, r16
    3eb0:	ed 91       	ld	r30, X+
    3eb2:	fc 91       	ld	r31, X
    3eb4:	02 80       	ldd	r0, Z+2	; 0x02
    3eb6:	f3 81       	ldd	r31, Z+3	; 0x03
    3eb8:	e0 2d       	mov	r30, r0
    3eba:	c8 01       	movw	r24, r16
    3ebc:	19 95       	eicall
    3ebe:	69 91       	ld	r22, Y+
    3ec0:	61 11       	cpse	r22, r1
    3ec2:	f5 cf       	rjmp	.-22     	; 0x3eae <_ZN8emstream4putsEPKc+0x4e>
    3ec4:	df 91       	pop	r29
    3ec6:	cf 91       	pop	r28
    3ec8:	1f 91       	pop	r17
    3eca:	0f 91       	pop	r16
    3ecc:	08 95       	ret

00003ece <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3ece:	cf 93       	push	r28
    3ed0:	df 93       	push	r29
    3ed2:	ec 01       	movw	r28, r24
	switch (new_manip)
    3ed4:	86 2f       	mov	r24, r22
    3ed6:	90 e0       	ldi	r25, 0x00	; 0
    3ed8:	8b 30       	cpi	r24, 0x0B	; 11
    3eda:	91 05       	cpc	r25, r1
    3edc:	d8 f5       	brcc	.+118    	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3ede:	fc 01       	movw	r30, r24
    3ee0:	88 27       	eor	r24, r24
    3ee2:	e2 50       	subi	r30, 0x02	; 2
    3ee4:	ff 4f       	sbci	r31, 0xFF	; 255
    3ee6:	8f 4f       	sbci	r24, 0xFF	; 255
    3ee8:	0c 94 d7 26 	jmp	0x4dae	; 0x4dae <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3eec:	82 e0       	ldi	r24, 0x02	; 2
    3eee:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ef0:	31 c0       	rjmp	.+98     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3ef2:	88 e0       	ldi	r24, 0x08	; 8
    3ef4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ef6:	2e c0       	rjmp	.+92     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3ef8:	8a e0       	ldi	r24, 0x0A	; 10
    3efa:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3efc:	2b c0       	rjmp	.+86     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3efe:	80 e1       	ldi	r24, 0x10	; 16
    3f00:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f02:	28 c0       	rjmp	.+80     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3f04:	81 e0       	ldi	r24, 0x01	; 1
    3f06:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3f08:	25 c0       	rjmp	.+74     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3f0a:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3f0c:	23 c0       	rjmp	.+70     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3f0e:	e8 81       	ld	r30, Y
    3f10:	f9 81       	ldd	r31, Y+1	; 0x01
    3f12:	02 80       	ldd	r0, Z+2	; 0x02
    3f14:	f3 81       	ldd	r31, Z+3	; 0x03
    3f16:	e0 2d       	mov	r30, r0
    3f18:	6d e0       	ldi	r22, 0x0D	; 13
    3f1a:	ce 01       	movw	r24, r28
    3f1c:	19 95       	eicall
    3f1e:	e8 81       	ld	r30, Y
    3f20:	f9 81       	ldd	r31, Y+1	; 0x01
    3f22:	02 80       	ldd	r0, Z+2	; 0x02
    3f24:	f3 81       	ldd	r31, Z+3	; 0x03
    3f26:	e0 2d       	mov	r30, r0
    3f28:	6a e0       	ldi	r22, 0x0A	; 10
    3f2a:	ce 01       	movw	r24, r28
    3f2c:	19 95       	eicall
			break;
    3f2e:	12 c0       	rjmp	.+36     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3f30:	e8 81       	ld	r30, Y
    3f32:	f9 81       	ldd	r31, Y+1	; 0x01
    3f34:	02 84       	ldd	r0, Z+10	; 0x0a
    3f36:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f38:	e0 2d       	mov	r30, r0
    3f3a:	ce 01       	movw	r24, r28
    3f3c:	19 95       	eicall
			break;
    3f3e:	0a c0       	rjmp	.+20     	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3f40:	e8 81       	ld	r30, Y
    3f42:	f9 81       	ldd	r31, Y+1	; 0x01
    3f44:	00 84       	ldd	r0, Z+8	; 0x08
    3f46:	f1 85       	ldd	r31, Z+9	; 0x09
    3f48:	e0 2d       	mov	r30, r0
    3f4a:	ce 01       	movw	r24, r28
    3f4c:	19 95       	eicall
			break;
    3f4e:	02 c0       	rjmp	.+4      	; 0x3f54 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3f50:	81 e0       	ldi	r24, 0x01	; 1
    3f52:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3f54:	ce 01       	movw	r24, r28
    3f56:	df 91       	pop	r29
    3f58:	cf 91       	pop	r28
    3f5a:	08 95       	ret

00003f5c <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3f5c:	ff 92       	push	r15
    3f5e:	0f 93       	push	r16
    3f60:	1f 93       	push	r17
    3f62:	cf 93       	push	r28
    3f64:	df 93       	push	r29
    3f66:	cd b7       	in	r28, 0x3d	; 61
    3f68:	de b7       	in	r29, 0x3e	; 62
    3f6a:	61 97       	sbiw	r28, 0x11	; 17
    3f6c:	cd bf       	out	0x3d, r28	; 61
    3f6e:	de bf       	out	0x3e, r29	; 62
    3f70:	8c 01       	movw	r16, r24
    3f72:	f6 2e       	mov	r15, r22
    3f74:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3f76:	f8 01       	movw	r30, r16
    3f78:	42 81       	ldd	r20, Z+2	; 0x02
    3f7a:	40 31       	cpi	r20, 0x10	; 16
    3f7c:	21 f0       	breq	.+8      	; 0x3f86 <_ZN8emstreamlsEj+0x2a>
    3f7e:	48 30       	cpi	r20, 0x08	; 8
    3f80:	11 f0       	breq	.+4      	; 0x3f86 <_ZN8emstreamlsEj+0x2a>
    3f82:	42 30       	cpi	r20, 0x02	; 2
    3f84:	41 f4       	brne	.+16     	; 0x3f96 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3f86:	69 2f       	mov	r22, r25
    3f88:	c8 01       	movw	r24, r16
    3f8a:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    3f8e:	6f 2d       	mov	r22, r15
    3f90:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    3f94:	0d c0       	rjmp	.+26     	; 0x3fb0 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3f96:	50 e0       	ldi	r21, 0x00	; 0
    3f98:	be 01       	movw	r22, r28
    3f9a:	6f 5f       	subi	r22, 0xFF	; 255
    3f9c:	7f 4f       	sbci	r23, 0xFF	; 255
    3f9e:	8f 2d       	mov	r24, r15
    3fa0:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3fa4:	be 01       	movw	r22, r28
    3fa6:	6f 5f       	subi	r22, 0xFF	; 255
    3fa8:	7f 4f       	sbci	r23, 0xFF	; 255
    3faa:	c8 01       	movw	r24, r16
    3fac:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3fb0:	c8 01       	movw	r24, r16
    3fb2:	61 96       	adiw	r28, 0x11	; 17
    3fb4:	cd bf       	out	0x3d, r28	; 61
    3fb6:	de bf       	out	0x3e, r29	; 62
    3fb8:	df 91       	pop	r29
    3fba:	cf 91       	pop	r28
    3fbc:	1f 91       	pop	r17
    3fbe:	0f 91       	pop	r16
    3fc0:	ff 90       	pop	r15
    3fc2:	08 95       	ret

00003fc4 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3fc4:	df 92       	push	r13
    3fc6:	ef 92       	push	r14
    3fc8:	ff 92       	push	r15
    3fca:	0f 93       	push	r16
    3fcc:	1f 93       	push	r17
    3fce:	cf 93       	push	r28
    3fd0:	df 93       	push	r29
    3fd2:	cd b7       	in	r28, 0x3d	; 61
    3fd4:	de b7       	in	r29, 0x3e	; 62
    3fd6:	a1 97       	sbiw	r28, 0x21	; 33
    3fd8:	cd bf       	out	0x3d, r28	; 61
    3fda:	de bf       	out	0x3e, r29	; 62
    3fdc:	8c 01       	movw	r16, r24
    3fde:	d4 2e       	mov	r13, r20
    3fe0:	e5 2e       	mov	r14, r21
    3fe2:	f6 2e       	mov	r15, r22
    3fe4:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3fe6:	f8 01       	movw	r30, r16
    3fe8:	22 81       	ldd	r18, Z+2	; 0x02
    3fea:	20 31       	cpi	r18, 0x10	; 16
    3fec:	21 f0       	breq	.+8      	; 0x3ff6 <_ZN8emstreamlsEm+0x32>
    3fee:	28 30       	cpi	r18, 0x08	; 8
    3ff0:	11 f0       	breq	.+4      	; 0x3ff6 <_ZN8emstreamlsEm+0x32>
    3ff2:	22 30       	cpi	r18, 0x02	; 2
    3ff4:	71 f4       	brne	.+28     	; 0x4012 <__stack+0x13>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3ff6:	69 2f       	mov	r22, r25
    3ff8:	c8 01       	movw	r24, r16
    3ffa:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    3ffe:	6f 2d       	mov	r22, r15
    4000:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    4004:	6e 2d       	mov	r22, r14
    4006:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    400a:	6d 2d       	mov	r22, r13
    400c:	0e 94 24 20 	call	0x4048	; 0x4048 <_ZN8emstreamlsEh>
    4010:	0f c0       	rjmp	.+30     	; 0x4030 <__stack+0x31>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    4012:	30 e0       	ldi	r19, 0x00	; 0
    4014:	ae 01       	movw	r20, r28
    4016:	4f 5f       	subi	r20, 0xFF	; 255
    4018:	5f 4f       	sbci	r21, 0xFF	; 255
    401a:	6d 2d       	mov	r22, r13
    401c:	7e 2d       	mov	r23, r14
    401e:	8f 2d       	mov	r24, r15
    4020:	0e 94 19 27 	call	0x4e32	; 0x4e32 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    4024:	be 01       	movw	r22, r28
    4026:	6f 5f       	subi	r22, 0xFF	; 255
    4028:	7f 4f       	sbci	r23, 0xFF	; 255
    402a:	c8 01       	movw	r24, r16
    402c:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    4030:	c8 01       	movw	r24, r16
    4032:	a1 96       	adiw	r28, 0x21	; 33
    4034:	cd bf       	out	0x3d, r28	; 61
    4036:	de bf       	out	0x3e, r29	; 62
    4038:	df 91       	pop	r29
    403a:	cf 91       	pop	r28
    403c:	1f 91       	pop	r17
    403e:	0f 91       	pop	r16
    4040:	ff 90       	pop	r15
    4042:	ef 90       	pop	r14
    4044:	df 90       	pop	r13
    4046:	08 95       	ret

00004048 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    4048:	cf 92       	push	r12
    404a:	df 92       	push	r13
    404c:	ef 92       	push	r14
    404e:	ff 92       	push	r15
    4050:	0f 93       	push	r16
    4052:	1f 93       	push	r17
    4054:	cf 93       	push	r28
    4056:	df 93       	push	r29
    4058:	cd b7       	in	r28, 0x3d	; 61
    405a:	de b7       	in	r29, 0x3e	; 62
    405c:	29 97       	sbiw	r28, 0x09	; 9
    405e:	cd bf       	out	0x3d, r28	; 61
    4060:	de bf       	out	0x3e, r29	; 62
    4062:	8c 01       	movw	r16, r24
    4064:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    4066:	dc 01       	movw	r26, r24
    4068:	13 96       	adiw	r26, 0x03	; 3
    406a:	8c 91       	ld	r24, X
    406c:	13 97       	sbiw	r26, 0x03	; 3
    406e:	88 23       	and	r24, r24
    4070:	41 f0       	breq	.+16     	; 0x4082 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    4072:	ed 91       	ld	r30, X+
    4074:	fc 91       	ld	r31, X
    4076:	02 80       	ldd	r0, Z+2	; 0x02
    4078:	f3 81       	ldd	r31, Z+3	; 0x03
    407a:	e0 2d       	mov	r30, r0
    407c:	c8 01       	movw	r24, r16
    407e:	19 95       	eicall
    4080:	56 c0       	rjmp	.+172    	; 0x412e <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    4082:	f8 01       	movw	r30, r16
    4084:	42 81       	ldd	r20, Z+2	; 0x02
    4086:	42 30       	cpi	r20, 0x02	; 2
    4088:	19 f5       	brne	.+70     	; 0x40d0 <_ZN8emstreamlsEh+0x88>
    408a:	68 94       	set
    408c:	cc 24       	eor	r12, r12
    408e:	c3 f8       	bld	r12, 3
    4090:	d1 2c       	mov	r13, r1
    4092:	68 94       	set
    4094:	ff 24       	eor	r15, r15
    4096:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    4098:	8e 2d       	mov	r24, r14
    409a:	8f 21       	and	r24, r15
    409c:	51 f0       	breq	.+20     	; 0x40b2 <_ZN8emstreamlsEh+0x6a>
    409e:	d8 01       	movw	r26, r16
    40a0:	ed 91       	ld	r30, X+
    40a2:	fc 91       	ld	r31, X
    40a4:	02 80       	ldd	r0, Z+2	; 0x02
    40a6:	f3 81       	ldd	r31, Z+3	; 0x03
    40a8:	e0 2d       	mov	r30, r0
    40aa:	61 e3       	ldi	r22, 0x31	; 49
    40ac:	c8 01       	movw	r24, r16
    40ae:	19 95       	eicall
    40b0:	09 c0       	rjmp	.+18     	; 0x40c4 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    40b2:	d8 01       	movw	r26, r16
    40b4:	ed 91       	ld	r30, X+
    40b6:	fc 91       	ld	r31, X
    40b8:	02 80       	ldd	r0, Z+2	; 0x02
    40ba:	f3 81       	ldd	r31, Z+3	; 0x03
    40bc:	e0 2d       	mov	r30, r0
    40be:	60 e3       	ldi	r22, 0x30	; 48
    40c0:	c8 01       	movw	r24, r16
    40c2:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    40c4:	f6 94       	lsr	r15
    40c6:	b1 e0       	ldi	r27, 0x01	; 1
    40c8:	cb 1a       	sub	r12, r27
    40ca:	d1 08       	sbc	r13, r1
    40cc:	29 f7       	brne	.-54     	; 0x4098 <_ZN8emstreamlsEh+0x50>
    40ce:	2f c0       	rjmp	.+94     	; 0x412e <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    40d0:	40 31       	cpi	r20, 0x10	; 16
    40d2:	f9 f4       	brne	.+62     	; 0x4112 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    40d4:	62 95       	swap	r22
    40d6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    40d8:	01 90       	ld	r0, Z+
    40da:	f0 81       	ld	r31, Z
    40dc:	e0 2d       	mov	r30, r0
    40de:	02 80       	ldd	r0, Z+2	; 0x02
    40e0:	f3 81       	ldd	r31, Z+3	; 0x03
    40e2:	e0 2d       	mov	r30, r0
    40e4:	6a 30       	cpi	r22, 0x0A	; 10
    40e6:	10 f0       	brcs	.+4      	; 0x40ec <_ZN8emstreamlsEh+0xa4>
    40e8:	69 5c       	subi	r22, 0xC9	; 201
    40ea:	01 c0       	rjmp	.+2      	; 0x40ee <_ZN8emstreamlsEh+0xa6>
    40ec:	60 5d       	subi	r22, 0xD0	; 208
    40ee:	c8 01       	movw	r24, r16
    40f0:	19 95       	eicall
		temp_char = num & 0x0F;
    40f2:	6e 2d       	mov	r22, r14
    40f4:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    40f6:	d8 01       	movw	r26, r16
    40f8:	ed 91       	ld	r30, X+
    40fa:	fc 91       	ld	r31, X
    40fc:	02 80       	ldd	r0, Z+2	; 0x02
    40fe:	f3 81       	ldd	r31, Z+3	; 0x03
    4100:	e0 2d       	mov	r30, r0
    4102:	6a 30       	cpi	r22, 0x0A	; 10
    4104:	10 f0       	brcs	.+4      	; 0x410a <_ZN8emstreamlsEh+0xc2>
    4106:	69 5c       	subi	r22, 0xC9	; 201
    4108:	01 c0       	rjmp	.+2      	; 0x410c <_ZN8emstreamlsEh+0xc4>
    410a:	60 5d       	subi	r22, 0xD0	; 208
    410c:	c8 01       	movw	r24, r16
    410e:	19 95       	eicall
    4110:	0e c0       	rjmp	.+28     	; 0x412e <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4112:	50 e0       	ldi	r21, 0x00	; 0
    4114:	be 01       	movw	r22, r28
    4116:	6f 5f       	subi	r22, 0xFF	; 255
    4118:	7f 4f       	sbci	r23, 0xFF	; 255
    411a:	8e 2d       	mov	r24, r14
    411c:	90 e0       	ldi	r25, 0x00	; 0
    411e:	0e 94 46 27 	call	0x4e8c	; 0x4e8c <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    4122:	be 01       	movw	r22, r28
    4124:	6f 5f       	subi	r22, 0xFF	; 255
    4126:	7f 4f       	sbci	r23, 0xFF	; 255
    4128:	c8 01       	movw	r24, r16
    412a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    412e:	c8 01       	movw	r24, r16
    4130:	29 96       	adiw	r28, 0x09	; 9
    4132:	cd bf       	out	0x3d, r28	; 61
    4134:	de bf       	out	0x3e, r29	; 62
    4136:	df 91       	pop	r29
    4138:	cf 91       	pop	r28
    413a:	1f 91       	pop	r17
    413c:	0f 91       	pop	r16
    413e:	ff 90       	pop	r15
    4140:	ef 90       	pop	r14
    4142:	df 90       	pop	r13
    4144:	cf 90       	pop	r12
    4146:	08 95       	ret

00004148 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    4148:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    414a:	50 96       	adiw	r26, 0x10	; 16
    414c:	ed 91       	ld	r30, X+
    414e:	fc 91       	ld	r31, X
    4150:	51 97       	sbiw	r26, 0x11	; 17
    4152:	80 81       	ld	r24, Z
    4154:	54 96       	adiw	r26, 0x14	; 20
    4156:	4c 91       	ld	r20, X
    4158:	54 97       	sbiw	r26, 0x14	; 20
    415a:	84 23       	and	r24, r20
    415c:	29 f0       	breq	.+10     	; 0x4168 <_ZN5rs2327putcharEc+0x20>
    415e:	09 c0       	rjmp	.+18     	; 0x4172 <_ZN5rs2327putcharEc+0x2a>
    4160:	21 50       	subi	r18, 0x01	; 1
    4162:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4164:	19 f4       	brne	.+6      	; 0x416c <_ZN5rs2327putcharEc+0x24>
    4166:	12 c0       	rjmp	.+36     	; 0x418c <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4168:	21 e2       	ldi	r18, 0x21	; 33
    416a:	3e e4       	ldi	r19, 0x4E	; 78
    416c:	90 81       	ld	r25, Z
    416e:	94 23       	and	r25, r20
    4170:	b9 f3       	breq	.-18     	; 0x4160 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4172:	90 81       	ld	r25, Z
    4174:	56 96       	adiw	r26, 0x16	; 22
    4176:	8c 91       	ld	r24, X
    4178:	56 97       	sbiw	r26, 0x16	; 22
    417a:	89 2b       	or	r24, r25
    417c:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    417e:	1e 96       	adiw	r26, 0x0e	; 14
    4180:	ed 91       	ld	r30, X+
    4182:	fc 91       	ld	r31, X
    4184:	1f 97       	sbiw	r26, 0x0f	; 15
    4186:	60 83       	st	Z, r22
	return (true);
    4188:	81 e0       	ldi	r24, 0x01	; 1
    418a:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    418c:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    418e:	08 95       	ret

00004190 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    4190:	cf 93       	push	r28
    4192:	df 93       	push	r29
    4194:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    4196:	c1 8d       	ldd	r28, Z+25	; 0x19
    4198:	d2 8d       	ldd	r29, Z+26	; 0x1a
    419a:	28 81       	ld	r18, Y
    419c:	39 81       	ldd	r19, Y+1	; 0x01
    419e:	a3 8d       	ldd	r26, Z+27	; 0x1b
    41a0:	b4 8d       	ldd	r27, Z+28	; 0x1c
    41a2:	4d 91       	ld	r20, X+
    41a4:	5c 91       	ld	r21, X
    41a6:	24 17       	cp	r18, r20
    41a8:	35 07       	cpc	r19, r21
    41aa:	e9 f3       	breq	.-6      	; 0x41a6 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    41ac:	a7 89       	ldd	r26, Z+23	; 0x17
    41ae:	b0 8d       	ldd	r27, Z+24	; 0x18
    41b0:	0d 90       	ld	r0, X+
    41b2:	bc 91       	ld	r27, X
    41b4:	a0 2d       	mov	r26, r0
    41b6:	a2 0f       	add	r26, r18
    41b8:	b3 1f       	adc	r27, r19
    41ba:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    41bc:	2f 5f       	subi	r18, 0xFF	; 255
    41be:	3f 4f       	sbci	r19, 0xFF	; 255
    41c0:	28 83       	st	Y, r18
    41c2:	39 83       	std	Y+1, r19	; 0x01
    41c4:	24 36       	cpi	r18, 0x64	; 100
    41c6:	31 05       	cpc	r19, r1
    41c8:	28 f0       	brcs	.+10     	; 0x41d4 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    41ca:	01 8c       	ldd	r0, Z+25	; 0x19
    41cc:	f2 8d       	ldd	r31, Z+26	; 0x1a
    41ce:	e0 2d       	mov	r30, r0
    41d0:	10 82       	st	Z, r1
    41d2:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	df 91       	pop	r29
    41d8:	cf 91       	pop	r28
    41da:	08 95       	ret

000041dc <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    41dc:	cf 93       	push	r28
    41de:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    41e0:	ec 01       	movw	r28, r24
    41e2:	a9 8d       	ldd	r26, Y+25	; 0x19
    41e4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    41e6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    41e8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    41ea:	81 e0       	ldi	r24, 0x01	; 1
    41ec:	4d 91       	ld	r20, X+
    41ee:	5c 91       	ld	r21, X
    41f0:	20 81       	ld	r18, Z
    41f2:	31 81       	ldd	r19, Z+1	; 0x01
    41f4:	42 17       	cp	r20, r18
    41f6:	53 07       	cpc	r21, r19
    41f8:	09 f4       	brne	.+2      	; 0x41fc <_ZN5rs23214check_for_charEv+0x20>
    41fa:	80 e0       	ldi	r24, 0x00	; 0
}
    41fc:	df 91       	pop	r29
    41fe:	cf 91       	pop	r28
    4200:	08 95       	ret

00004202 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    4202:	dc 01       	movw	r26, r24
    4204:	ed 91       	ld	r30, X+
    4206:	fc 91       	ld	r31, X
    4208:	02 80       	ldd	r0, Z+2	; 0x02
    420a:	f3 81       	ldd	r31, Z+3	; 0x03
    420c:	e0 2d       	mov	r30, r0
    420e:	6c e0       	ldi	r22, 0x0C	; 12
    4210:	19 95       	eicall
    4212:	08 95       	ret

00004214 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    4214:	ef 92       	push	r14
    4216:	ff 92       	push	r15
    4218:	0f 93       	push	r16
    421a:	1f 93       	push	r17
    421c:	cf 93       	push	r28
    421e:	df 93       	push	r29
    4220:	ec 01       	movw	r28, r24
    4222:	7b 01       	movw	r14, r22
    4224:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    4226:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <_ZN8emstreamC1Ev>
    422a:	a8 01       	movw	r20, r16
    422c:	b7 01       	movw	r22, r14
    422e:	ce 01       	movw	r24, r28
    4230:	08 96       	adiw	r24, 0x08	; 8
    4232:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <_ZN7base232C1EjP12USART_struct>
    4236:	84 eb       	ldi	r24, 0xB4	; 180
    4238:	91 e2       	ldi	r25, 0x21	; 33
    423a:	88 83       	st	Y, r24
    423c:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    423e:	00 3a       	cpi	r16, 0xA0	; 160
    4240:	88 e0       	ldi	r24, 0x08	; 8
    4242:	18 07       	cpc	r17, r24
    4244:	69 f4       	brne	.+26     	; 0x4260 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4246:	8e eb       	ldi	r24, 0xBE	; 190
    4248:	92 e3       	ldi	r25, 0x32	; 50
    424a:	8f 8b       	std	Y+23, r24	; 0x17
    424c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    424e:	84 eb       	ldi	r24, 0xB4	; 180
    4250:	92 e3       	ldi	r25, 0x32	; 50
    4252:	89 8f       	std	Y+25, r24	; 0x19
    4254:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4256:	8a ea       	ldi	r24, 0xAA	; 170
    4258:	92 e3       	ldi	r25, 0x32	; 50
    425a:	8b 8f       	std	Y+27, r24	; 0x1b
    425c:	9c 8f       	std	Y+28, r25	; 0x1c
    425e:	42 c0       	rjmp	.+132    	; 0x42e4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4260:	00 3b       	cpi	r16, 0xB0	; 176
    4262:	e8 e0       	ldi	r30, 0x08	; 8
    4264:	1e 07       	cpc	r17, r30
    4266:	69 f4       	brne	.+26     	; 0x4282 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    4268:	8c eb       	ldi	r24, 0xBC	; 188
    426a:	92 e3       	ldi	r25, 0x32	; 50
    426c:	8f 8b       	std	Y+23, r24	; 0x17
    426e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4270:	82 eb       	ldi	r24, 0xB2	; 178
    4272:	92 e3       	ldi	r25, 0x32	; 50
    4274:	89 8f       	std	Y+25, r24	; 0x19
    4276:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    4278:	88 ea       	ldi	r24, 0xA8	; 168
    427a:	92 e3       	ldi	r25, 0x32	; 50
    427c:	8b 8f       	std	Y+27, r24	; 0x1b
    427e:	9c 8f       	std	Y+28, r25	; 0x1c
    4280:	31 c0       	rjmp	.+98     	; 0x42e4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    4282:	00 3a       	cpi	r16, 0xA0	; 160
    4284:	f9 e0       	ldi	r31, 0x09	; 9
    4286:	1f 07       	cpc	r17, r31
    4288:	69 f4       	brne	.+26     	; 0x42a4 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    428a:	8a eb       	ldi	r24, 0xBA	; 186
    428c:	92 e3       	ldi	r25, 0x32	; 50
    428e:	8f 8b       	std	Y+23, r24	; 0x17
    4290:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    4292:	80 eb       	ldi	r24, 0xB0	; 176
    4294:	92 e3       	ldi	r25, 0x32	; 50
    4296:	89 8f       	std	Y+25, r24	; 0x19
    4298:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    429a:	86 ea       	ldi	r24, 0xA6	; 166
    429c:	92 e3       	ldi	r25, 0x32	; 50
    429e:	8b 8f       	std	Y+27, r24	; 0x1b
    42a0:	9c 8f       	std	Y+28, r25	; 0x1c
    42a2:	20 c0       	rjmp	.+64     	; 0x42e4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    42a4:	00 3b       	cpi	r16, 0xB0	; 176
    42a6:	89 e0       	ldi	r24, 0x09	; 9
    42a8:	18 07       	cpc	r17, r24
    42aa:	69 f4       	brne	.+26     	; 0x42c6 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    42ac:	88 eb       	ldi	r24, 0xB8	; 184
    42ae:	92 e3       	ldi	r25, 0x32	; 50
    42b0:	8f 8b       	std	Y+23, r24	; 0x17
    42b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    42b4:	8e ea       	ldi	r24, 0xAE	; 174
    42b6:	92 e3       	ldi	r25, 0x32	; 50
    42b8:	89 8f       	std	Y+25, r24	; 0x19
    42ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    42bc:	84 ea       	ldi	r24, 0xA4	; 164
    42be:	92 e3       	ldi	r25, 0x32	; 50
    42c0:	8b 8f       	std	Y+27, r24	; 0x1b
    42c2:	9c 8f       	std	Y+28, r25	; 0x1c
    42c4:	0f c0       	rjmp	.+30     	; 0x42e4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    42c6:	00 3a       	cpi	r16, 0xA0	; 160
    42c8:	1a 40       	sbci	r17, 0x0A	; 10
    42ca:	61 f4       	brne	.+24     	; 0x42e4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    42cc:	86 eb       	ldi	r24, 0xB6	; 182
    42ce:	92 e3       	ldi	r25, 0x32	; 50
    42d0:	8f 8b       	std	Y+23, r24	; 0x17
    42d2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    42d4:	8c ea       	ldi	r24, 0xAC	; 172
    42d6:	92 e3       	ldi	r25, 0x32	; 50
    42d8:	89 8f       	std	Y+25, r24	; 0x19
    42da:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    42dc:	82 ea       	ldi	r24, 0xA2	; 162
    42de:	92 e3       	ldi	r25, 0x32	; 50
    42e0:	8b 8f       	std	Y+27, r24	; 0x1b
    42e2:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    42e4:	0f 89       	ldd	r16, Y+23	; 0x17
    42e6:	18 8d       	ldd	r17, Y+24	; 0x18
    42e8:	84 e6       	ldi	r24, 0x64	; 100
    42ea:	90 e0       	ldi	r25, 0x00	; 0
    42ec:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znaj>
    42f0:	f8 01       	movw	r30, r16
    42f2:	80 83       	st	Z, r24
    42f4:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    42f6:	e9 8d       	ldd	r30, Y+25	; 0x19
    42f8:	fa 8d       	ldd	r31, Y+26	; 0x1a
    42fa:	10 82       	st	Z, r1
    42fc:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    42fe:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4300:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4302:	10 82       	st	Z, r1
    4304:	11 82       	std	Z+1, r1	; 0x01
}
    4306:	df 91       	pop	r29
    4308:	cf 91       	pop	r28
    430a:	1f 91       	pop	r17
    430c:	0f 91       	pop	r16
    430e:	ff 90       	pop	r15
    4310:	ef 90       	pop	r14
    4312:	08 95       	ret

00004314 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    4314:	1f 92       	push	r1
    4316:	0f 92       	push	r0
    4318:	0f b6       	in	r0, 0x3f	; 63
    431a:	0f 92       	push	r0
    431c:	11 24       	eor	r1, r1
    431e:	08 b6       	in	r0, 0x38	; 56
    4320:	0f 92       	push	r0
    4322:	18 be       	out	0x38, r1	; 56
    4324:	0b b6       	in	r0, 0x3b	; 59
    4326:	0f 92       	push	r0
    4328:	1b be       	out	0x3b, r1	; 59
    432a:	2f 93       	push	r18
    432c:	3f 93       	push	r19
    432e:	8f 93       	push	r24
    4330:	9f 93       	push	r25
    4332:	ef 93       	push	r30
    4334:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    4336:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    433a:	e0 91 be 32 	lds	r30, 0x32BE	; 0x8032be <rcvC0_buffer>
    433e:	f0 91 bf 32 	lds	r31, 0x32BF	; 0x8032bf <rcvC0_buffer+0x1>
    4342:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    4346:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    434a:	e8 0f       	add	r30, r24
    434c:	f9 1f       	adc	r31, r25
    434e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    4350:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    4354:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    4358:	01 96       	adiw	r24, 0x01	; 1
    435a:	84 36       	cpi	r24, 0x64	; 100
    435c:	91 05       	cpc	r25, r1
    435e:	60 f4       	brcc	.+24     	; 0x4378 <__vector_25+0x64>
    4360:	80 93 aa 32 	sts	0x32AA, r24	; 0x8032aa <rcvC0_write_index>
    4364:	90 93 ab 32 	sts	0x32AB, r25	; 0x8032ab <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4368:	20 91 b4 32 	lds	r18, 0x32B4	; 0x8032b4 <rcvC0_read_index>
    436c:	30 91 b5 32 	lds	r19, 0x32B5	; 0x8032b5 <rcvC0_read_index+0x1>
    4370:	82 17       	cp	r24, r18
    4372:	93 07       	cpc	r25, r19
    4374:	f1 f4       	brne	.+60     	; 0x43b2 <__vector_25+0x9e>
    4376:	0c c0       	rjmp	.+24     	; 0x4390 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    4378:	10 92 aa 32 	sts	0x32AA, r1	; 0x8032aa <rcvC0_write_index>
    437c:	10 92 ab 32 	sts	0x32AB, r1	; 0x8032ab <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4380:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <rcvC0_read_index>
    4384:	90 91 b5 32 	lds	r25, 0x32B5	; 0x8032b5 <rcvC0_read_index+0x1>
    4388:	18 16       	cp	r1, r24
    438a:	19 06       	cpc	r1, r25
    438c:	91 f4       	brne	.+36     	; 0x43b2 <__vector_25+0x9e>
    438e:	0e c0       	rjmp	.+28     	; 0x43ac <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4390:	01 96       	adiw	r24, 0x01	; 1
    4392:	84 36       	cpi	r24, 0x64	; 100
    4394:	91 05       	cpc	r25, r1
    4396:	28 f4       	brcc	.+10     	; 0x43a2 <__vector_25+0x8e>
    4398:	80 93 b4 32 	sts	0x32B4, r24	; 0x8032b4 <rcvC0_read_index>
    439c:	90 93 b5 32 	sts	0x32B5, r25	; 0x8032b5 <rcvC0_read_index+0x1>
    43a0:	08 c0       	rjmp	.+16     	; 0x43b2 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    43a2:	10 92 b4 32 	sts	0x32B4, r1	; 0x8032b4 <rcvC0_read_index>
    43a6:	10 92 b5 32 	sts	0x32B5, r1	; 0x8032b5 <rcvC0_read_index+0x1>
}
    43aa:	03 c0       	rjmp	.+6      	; 0x43b2 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    43ac:	81 e0       	ldi	r24, 0x01	; 1
    43ae:	90 e0       	ldi	r25, 0x00	; 0
    43b0:	f3 cf       	rjmp	.-26     	; 0x4398 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    43b2:	ff 91       	pop	r31
    43b4:	ef 91       	pop	r30
    43b6:	9f 91       	pop	r25
    43b8:	8f 91       	pop	r24
    43ba:	3f 91       	pop	r19
    43bc:	2f 91       	pop	r18
    43be:	0f 90       	pop	r0
    43c0:	0b be       	out	0x3b, r0	; 59
    43c2:	0f 90       	pop	r0
    43c4:	08 be       	out	0x38, r0	; 56
    43c6:	0f 90       	pop	r0
    43c8:	0f be       	out	0x3f, r0	; 63
    43ca:	0f 90       	pop	r0
    43cc:	1f 90       	pop	r1
    43ce:	18 95       	reti

000043d0 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    43d0:	1f 92       	push	r1
    43d2:	0f 92       	push	r0
    43d4:	0f b6       	in	r0, 0x3f	; 63
    43d6:	0f 92       	push	r0
    43d8:	11 24       	eor	r1, r1
    43da:	08 b6       	in	r0, 0x38	; 56
    43dc:	0f 92       	push	r0
    43de:	18 be       	out	0x38, r1	; 56
    43e0:	0b b6       	in	r0, 0x3b	; 59
    43e2:	0f 92       	push	r0
    43e4:	1b be       	out	0x3b, r1	; 59
    43e6:	2f 93       	push	r18
    43e8:	3f 93       	push	r19
    43ea:	8f 93       	push	r24
    43ec:	9f 93       	push	r25
    43ee:	ef 93       	push	r30
    43f0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    43f2:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    43f6:	e0 91 bc 32 	lds	r30, 0x32BC	; 0x8032bc <rcvC1_buffer>
    43fa:	f0 91 bd 32 	lds	r31, 0x32BD	; 0x8032bd <rcvC1_buffer+0x1>
    43fe:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC1_write_index>
    4402:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC1_write_index+0x1>
    4406:	e8 0f       	add	r30, r24
    4408:	f9 1f       	adc	r31, r25
    440a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    440c:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC1_write_index>
    4410:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC1_write_index+0x1>
    4414:	01 96       	adiw	r24, 0x01	; 1
    4416:	84 36       	cpi	r24, 0x64	; 100
    4418:	91 05       	cpc	r25, r1
    441a:	60 f4       	brcc	.+24     	; 0x4434 <__vector_28+0x64>
    441c:	80 93 a8 32 	sts	0x32A8, r24	; 0x8032a8 <rcvC1_write_index>
    4420:	90 93 a9 32 	sts	0x32A9, r25	; 0x8032a9 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4424:	20 91 b2 32 	lds	r18, 0x32B2	; 0x8032b2 <rcvC1_read_index>
    4428:	30 91 b3 32 	lds	r19, 0x32B3	; 0x8032b3 <rcvC1_read_index+0x1>
    442c:	82 17       	cp	r24, r18
    442e:	93 07       	cpc	r25, r19
    4430:	f1 f4       	brne	.+60     	; 0x446e <__vector_28+0x9e>
    4432:	0c c0       	rjmp	.+24     	; 0x444c <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4434:	10 92 a8 32 	sts	0x32A8, r1	; 0x8032a8 <rcvC1_write_index>
    4438:	10 92 a9 32 	sts	0x32A9, r1	; 0x8032a9 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    443c:	80 91 b2 32 	lds	r24, 0x32B2	; 0x8032b2 <rcvC1_read_index>
    4440:	90 91 b3 32 	lds	r25, 0x32B3	; 0x8032b3 <rcvC1_read_index+0x1>
    4444:	18 16       	cp	r1, r24
    4446:	19 06       	cpc	r1, r25
    4448:	91 f4       	brne	.+36     	; 0x446e <__vector_28+0x9e>
    444a:	0e c0       	rjmp	.+28     	; 0x4468 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    444c:	01 96       	adiw	r24, 0x01	; 1
    444e:	84 36       	cpi	r24, 0x64	; 100
    4450:	91 05       	cpc	r25, r1
    4452:	28 f4       	brcc	.+10     	; 0x445e <__vector_28+0x8e>
    4454:	80 93 b2 32 	sts	0x32B2, r24	; 0x8032b2 <rcvC1_read_index>
    4458:	90 93 b3 32 	sts	0x32B3, r25	; 0x8032b3 <rcvC1_read_index+0x1>
    445c:	08 c0       	rjmp	.+16     	; 0x446e <__vector_28+0x9e>
	rcvC1_read_index = 0;
    445e:	10 92 b2 32 	sts	0x32B2, r1	; 0x8032b2 <rcvC1_read_index>
    4462:	10 92 b3 32 	sts	0x32B3, r1	; 0x8032b3 <rcvC1_read_index+0x1>
}
    4466:	03 c0       	rjmp	.+6      	; 0x446e <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4468:	81 e0       	ldi	r24, 0x01	; 1
    446a:	90 e0       	ldi	r25, 0x00	; 0
    446c:	f3 cf       	rjmp	.-26     	; 0x4454 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    446e:	ff 91       	pop	r31
    4470:	ef 91       	pop	r30
    4472:	9f 91       	pop	r25
    4474:	8f 91       	pop	r24
    4476:	3f 91       	pop	r19
    4478:	2f 91       	pop	r18
    447a:	0f 90       	pop	r0
    447c:	0b be       	out	0x3b, r0	; 59
    447e:	0f 90       	pop	r0
    4480:	08 be       	out	0x38, r0	; 56
    4482:	0f 90       	pop	r0
    4484:	0f be       	out	0x3f, r0	; 63
    4486:	0f 90       	pop	r0
    4488:	1f 90       	pop	r1
    448a:	18 95       	reti

0000448c <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    448c:	1f 92       	push	r1
    448e:	0f 92       	push	r0
    4490:	0f b6       	in	r0, 0x3f	; 63
    4492:	0f 92       	push	r0
    4494:	11 24       	eor	r1, r1
    4496:	08 b6       	in	r0, 0x38	; 56
    4498:	0f 92       	push	r0
    449a:	18 be       	out	0x38, r1	; 56
    449c:	0b b6       	in	r0, 0x3b	; 59
    449e:	0f 92       	push	r0
    44a0:	1b be       	out	0x3b, r1	; 59
    44a2:	2f 93       	push	r18
    44a4:	3f 93       	push	r19
    44a6:	8f 93       	push	r24
    44a8:	9f 93       	push	r25
    44aa:	ef 93       	push	r30
    44ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    44ae:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    44b2:	e0 91 ba 32 	lds	r30, 0x32BA	; 0x8032ba <rcvD0_buffer>
    44b6:	f0 91 bb 32 	lds	r31, 0x32BB	; 0x8032bb <rcvD0_buffer+0x1>
    44ba:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    44be:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    44c2:	e8 0f       	add	r30, r24
    44c4:	f9 1f       	adc	r31, r25
    44c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    44c8:	80 91 a6 32 	lds	r24, 0x32A6	; 0x8032a6 <rcvD0_write_index>
    44cc:	90 91 a7 32 	lds	r25, 0x32A7	; 0x8032a7 <rcvD0_write_index+0x1>
    44d0:	01 96       	adiw	r24, 0x01	; 1
    44d2:	84 36       	cpi	r24, 0x64	; 100
    44d4:	91 05       	cpc	r25, r1
    44d6:	60 f4       	brcc	.+24     	; 0x44f0 <__vector_88+0x64>
    44d8:	80 93 a6 32 	sts	0x32A6, r24	; 0x8032a6 <rcvD0_write_index>
    44dc:	90 93 a7 32 	sts	0x32A7, r25	; 0x8032a7 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    44e0:	20 91 b0 32 	lds	r18, 0x32B0	; 0x8032b0 <rcvD0_read_index>
    44e4:	30 91 b1 32 	lds	r19, 0x32B1	; 0x8032b1 <rcvD0_read_index+0x1>
    44e8:	82 17       	cp	r24, r18
    44ea:	93 07       	cpc	r25, r19
    44ec:	f1 f4       	brne	.+60     	; 0x452a <__vector_88+0x9e>
    44ee:	0c c0       	rjmp	.+24     	; 0x4508 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    44f0:	10 92 a6 32 	sts	0x32A6, r1	; 0x8032a6 <rcvD0_write_index>
    44f4:	10 92 a7 32 	sts	0x32A7, r1	; 0x8032a7 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    44f8:	80 91 b0 32 	lds	r24, 0x32B0	; 0x8032b0 <rcvD0_read_index>
    44fc:	90 91 b1 32 	lds	r25, 0x32B1	; 0x8032b1 <rcvD0_read_index+0x1>
    4500:	18 16       	cp	r1, r24
    4502:	19 06       	cpc	r1, r25
    4504:	91 f4       	brne	.+36     	; 0x452a <__vector_88+0x9e>
    4506:	0e c0       	rjmp	.+28     	; 0x4524 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4508:	01 96       	adiw	r24, 0x01	; 1
    450a:	84 36       	cpi	r24, 0x64	; 100
    450c:	91 05       	cpc	r25, r1
    450e:	28 f4       	brcc	.+10     	; 0x451a <__vector_88+0x8e>
    4510:	80 93 b0 32 	sts	0x32B0, r24	; 0x8032b0 <rcvD0_read_index>
    4514:	90 93 b1 32 	sts	0x32B1, r25	; 0x8032b1 <rcvD0_read_index+0x1>
    4518:	08 c0       	rjmp	.+16     	; 0x452a <__vector_88+0x9e>
	rcvD0_read_index = 0;
    451a:	10 92 b0 32 	sts	0x32B0, r1	; 0x8032b0 <rcvD0_read_index>
    451e:	10 92 b1 32 	sts	0x32B1, r1	; 0x8032b1 <rcvD0_read_index+0x1>
}
    4522:	03 c0       	rjmp	.+6      	; 0x452a <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4524:	81 e0       	ldi	r24, 0x01	; 1
    4526:	90 e0       	ldi	r25, 0x00	; 0
    4528:	f3 cf       	rjmp	.-26     	; 0x4510 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    452a:	ff 91       	pop	r31
    452c:	ef 91       	pop	r30
    452e:	9f 91       	pop	r25
    4530:	8f 91       	pop	r24
    4532:	3f 91       	pop	r19
    4534:	2f 91       	pop	r18
    4536:	0f 90       	pop	r0
    4538:	0b be       	out	0x3b, r0	; 59
    453a:	0f 90       	pop	r0
    453c:	08 be       	out	0x38, r0	; 56
    453e:	0f 90       	pop	r0
    4540:	0f be       	out	0x3f, r0	; 63
    4542:	0f 90       	pop	r0
    4544:	1f 90       	pop	r1
    4546:	18 95       	reti

00004548 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4548:	1f 92       	push	r1
    454a:	0f 92       	push	r0
    454c:	0f b6       	in	r0, 0x3f	; 63
    454e:	0f 92       	push	r0
    4550:	11 24       	eor	r1, r1
    4552:	08 b6       	in	r0, 0x38	; 56
    4554:	0f 92       	push	r0
    4556:	18 be       	out	0x38, r1	; 56
    4558:	0b b6       	in	r0, 0x3b	; 59
    455a:	0f 92       	push	r0
    455c:	1b be       	out	0x3b, r1	; 59
    455e:	2f 93       	push	r18
    4560:	3f 93       	push	r19
    4562:	8f 93       	push	r24
    4564:	9f 93       	push	r25
    4566:	ef 93       	push	r30
    4568:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    456a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    456e:	e0 91 b8 32 	lds	r30, 0x32B8	; 0x8032b8 <rcvD1_buffer>
    4572:	f0 91 b9 32 	lds	r31, 0x32B9	; 0x8032b9 <rcvD1_buffer+0x1>
    4576:	80 91 a4 32 	lds	r24, 0x32A4	; 0x8032a4 <rcvD1_write_index>
    457a:	90 91 a5 32 	lds	r25, 0x32A5	; 0x8032a5 <rcvD1_write_index+0x1>
    457e:	e8 0f       	add	r30, r24
    4580:	f9 1f       	adc	r31, r25
    4582:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4584:	80 91 a4 32 	lds	r24, 0x32A4	; 0x8032a4 <rcvD1_write_index>
    4588:	90 91 a5 32 	lds	r25, 0x32A5	; 0x8032a5 <rcvD1_write_index+0x1>
    458c:	01 96       	adiw	r24, 0x01	; 1
    458e:	84 36       	cpi	r24, 0x64	; 100
    4590:	91 05       	cpc	r25, r1
    4592:	60 f4       	brcc	.+24     	; 0x45ac <__vector_91+0x64>
    4594:	80 93 a4 32 	sts	0x32A4, r24	; 0x8032a4 <rcvD1_write_index>
    4598:	90 93 a5 32 	sts	0x32A5, r25	; 0x8032a5 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    459c:	20 91 ae 32 	lds	r18, 0x32AE	; 0x8032ae <rcvD1_read_index>
    45a0:	30 91 af 32 	lds	r19, 0x32AF	; 0x8032af <rcvD1_read_index+0x1>
    45a4:	82 17       	cp	r24, r18
    45a6:	93 07       	cpc	r25, r19
    45a8:	f1 f4       	brne	.+60     	; 0x45e6 <__vector_91+0x9e>
    45aa:	0c c0       	rjmp	.+24     	; 0x45c4 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    45ac:	10 92 a4 32 	sts	0x32A4, r1	; 0x8032a4 <rcvD1_write_index>
    45b0:	10 92 a5 32 	sts	0x32A5, r1	; 0x8032a5 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    45b4:	80 91 ae 32 	lds	r24, 0x32AE	; 0x8032ae <rcvD1_read_index>
    45b8:	90 91 af 32 	lds	r25, 0x32AF	; 0x8032af <rcvD1_read_index+0x1>
    45bc:	18 16       	cp	r1, r24
    45be:	19 06       	cpc	r1, r25
    45c0:	91 f4       	brne	.+36     	; 0x45e6 <__vector_91+0x9e>
    45c2:	0e c0       	rjmp	.+28     	; 0x45e0 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    45c4:	01 96       	adiw	r24, 0x01	; 1
    45c6:	84 36       	cpi	r24, 0x64	; 100
    45c8:	91 05       	cpc	r25, r1
    45ca:	28 f4       	brcc	.+10     	; 0x45d6 <__vector_91+0x8e>
    45cc:	80 93 ae 32 	sts	0x32AE, r24	; 0x8032ae <rcvD1_read_index>
    45d0:	90 93 af 32 	sts	0x32AF, r25	; 0x8032af <rcvD1_read_index+0x1>
    45d4:	08 c0       	rjmp	.+16     	; 0x45e6 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    45d6:	10 92 ae 32 	sts	0x32AE, r1	; 0x8032ae <rcvD1_read_index>
    45da:	10 92 af 32 	sts	0x32AF, r1	; 0x8032af <rcvD1_read_index+0x1>
}
    45de:	03 c0       	rjmp	.+6      	; 0x45e6 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    45e0:	81 e0       	ldi	r24, 0x01	; 1
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	f3 cf       	rjmp	.-26     	; 0x45cc <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    45e6:	ff 91       	pop	r31
    45e8:	ef 91       	pop	r30
    45ea:	9f 91       	pop	r25
    45ec:	8f 91       	pop	r24
    45ee:	3f 91       	pop	r19
    45f0:	2f 91       	pop	r18
    45f2:	0f 90       	pop	r0
    45f4:	0b be       	out	0x3b, r0	; 59
    45f6:	0f 90       	pop	r0
    45f8:	08 be       	out	0x38, r0	; 56
    45fa:	0f 90       	pop	r0
    45fc:	0f be       	out	0x3f, r0	; 63
    45fe:	0f 90       	pop	r0
    4600:	1f 90       	pop	r1
    4602:	18 95       	reti

00004604 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4604:	1f 92       	push	r1
    4606:	0f 92       	push	r0
    4608:	0f b6       	in	r0, 0x3f	; 63
    460a:	0f 92       	push	r0
    460c:	11 24       	eor	r1, r1
    460e:	08 b6       	in	r0, 0x38	; 56
    4610:	0f 92       	push	r0
    4612:	18 be       	out	0x38, r1	; 56
    4614:	0b b6       	in	r0, 0x3b	; 59
    4616:	0f 92       	push	r0
    4618:	1b be       	out	0x3b, r1	; 59
    461a:	2f 93       	push	r18
    461c:	3f 93       	push	r19
    461e:	8f 93       	push	r24
    4620:	9f 93       	push	r25
    4622:	ef 93       	push	r30
    4624:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4626:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    462a:	e0 91 b6 32 	lds	r30, 0x32B6	; 0x8032b6 <rcvE0_buffer>
    462e:	f0 91 b7 32 	lds	r31, 0x32B7	; 0x8032b7 <rcvE0_buffer+0x1>
    4632:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvE0_write_index>
    4636:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvE0_write_index+0x1>
    463a:	e8 0f       	add	r30, r24
    463c:	f9 1f       	adc	r31, r25
    463e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4640:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvE0_write_index>
    4644:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvE0_write_index+0x1>
    4648:	01 96       	adiw	r24, 0x01	; 1
    464a:	84 36       	cpi	r24, 0x64	; 100
    464c:	91 05       	cpc	r25, r1
    464e:	60 f4       	brcc	.+24     	; 0x4668 <__vector_58+0x64>
    4650:	80 93 a2 32 	sts	0x32A2, r24	; 0x8032a2 <rcvE0_write_index>
    4654:	90 93 a3 32 	sts	0x32A3, r25	; 0x8032a3 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4658:	20 91 ac 32 	lds	r18, 0x32AC	; 0x8032ac <rcvE0_read_index>
    465c:	30 91 ad 32 	lds	r19, 0x32AD	; 0x8032ad <rcvE0_read_index+0x1>
    4660:	82 17       	cp	r24, r18
    4662:	93 07       	cpc	r25, r19
    4664:	f1 f4       	brne	.+60     	; 0x46a2 <__vector_58+0x9e>
    4666:	0c c0       	rjmp	.+24     	; 0x4680 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4668:	10 92 a2 32 	sts	0x32A2, r1	; 0x8032a2 <rcvE0_write_index>
    466c:	10 92 a3 32 	sts	0x32A3, r1	; 0x8032a3 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4670:	80 91 ac 32 	lds	r24, 0x32AC	; 0x8032ac <rcvE0_read_index>
    4674:	90 91 ad 32 	lds	r25, 0x32AD	; 0x8032ad <rcvE0_read_index+0x1>
    4678:	18 16       	cp	r1, r24
    467a:	19 06       	cpc	r1, r25
    467c:	91 f4       	brne	.+36     	; 0x46a2 <__vector_58+0x9e>
    467e:	0e c0       	rjmp	.+28     	; 0x469c <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4680:	01 96       	adiw	r24, 0x01	; 1
    4682:	84 36       	cpi	r24, 0x64	; 100
    4684:	91 05       	cpc	r25, r1
    4686:	28 f4       	brcc	.+10     	; 0x4692 <__vector_58+0x8e>
    4688:	80 93 ac 32 	sts	0x32AC, r24	; 0x8032ac <rcvE0_read_index>
    468c:	90 93 ad 32 	sts	0x32AD, r25	; 0x8032ad <rcvE0_read_index+0x1>
    4690:	08 c0       	rjmp	.+16     	; 0x46a2 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    4692:	10 92 ac 32 	sts	0x32AC, r1	; 0x8032ac <rcvE0_read_index>
    4696:	10 92 ad 32 	sts	0x32AD, r1	; 0x8032ad <rcvE0_read_index+0x1>
}
    469a:	03 c0       	rjmp	.+6      	; 0x46a2 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    469c:	81 e0       	ldi	r24, 0x01	; 1
    469e:	90 e0       	ldi	r25, 0x00	; 0
    46a0:	f3 cf       	rjmp	.-26     	; 0x4688 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    46a2:	ff 91       	pop	r31
    46a4:	ef 91       	pop	r30
    46a6:	9f 91       	pop	r25
    46a8:	8f 91       	pop	r24
    46aa:	3f 91       	pop	r19
    46ac:	2f 91       	pop	r18
    46ae:	0f 90       	pop	r0
    46b0:	0b be       	out	0x3b, r0	; 59
    46b2:	0f 90       	pop	r0
    46b4:	08 be       	out	0x38, r0	; 56
    46b6:	0f 90       	pop	r0
    46b8:	0f be       	out	0x3f, r0	; 63
    46ba:	0f 90       	pop	r0
    46bc:	1f 90       	pop	r1
    46be:	18 95       	reti

000046c0 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    46c0:	fc 01       	movw	r30, r24
    46c2:	84 81       	ldd	r24, Z+4	; 0x04
    46c4:	95 81       	ldd	r25, Z+5	; 0x05
    46c6:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
		}
    46ca:	90 e0       	ldi	r25, 0x00	; 0
    46cc:	08 95       	ret

000046ce <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    46ce:	fc 01       	movw	r30, r24
    46d0:	84 81       	ldd	r24, Z+4	; 0x04
    46d2:	95 81       	ldd	r25, Z+5	; 0x05
    46d4:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    46d8:	91 e0       	ldi	r25, 0x01	; 1
    46da:	81 11       	cpse	r24, r1
    46dc:	01 c0       	rjmp	.+2      	; 0x46e0 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    46de:	90 e0       	ldi	r25, 0x00	; 0
		}
    46e0:	89 2f       	mov	r24, r25
    46e2:	08 95       	ret

000046e4 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    46e4:	fc 01       	movw	r30, r24
    46e6:	84 81       	ldd	r24, Z+4	; 0x04
    46e8:	95 81       	ldd	r25, Z+5	; 0x05
    46ea:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    46ee:	91 e0       	ldi	r25, 0x01	; 1
    46f0:	81 11       	cpse	r24, r1
    46f2:	90 e0       	ldi	r25, 0x00	; 0
		}
    46f4:	89 2f       	mov	r24, r25
    46f6:	08 95       	ret

000046f8 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    46f8:	fc 01       	movw	r30, r24
    46fa:	84 81       	ldd	r24, Z+4	; 0x04
    46fc:	95 81       	ldd	r25, Z+5	; 0x05
    46fe:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
		}
    4702:	90 e0       	ldi	r25, 0x00	; 0
    4704:	08 95       	ret

00004706 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4706:	fc 01       	movw	r30, r24
    4708:	84 81       	ldd	r24, Z+4	; 0x04
    470a:	95 81       	ldd	r25, Z+5	; 0x05
    470c:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    4710:	91 e0       	ldi	r25, 0x01	; 1
    4712:	81 11       	cpse	r24, r1
    4714:	01 c0       	rjmp	.+2      	; 0x4718 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    4716:	90 e0       	ldi	r25, 0x00	; 0
		}
    4718:	89 2f       	mov	r24, r25
    471a:	08 95       	ret

0000471c <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    471c:	fc 01       	movw	r30, r24
    471e:	84 81       	ldd	r24, Z+4	; 0x04
    4720:	95 81       	ldd	r25, Z+5	; 0x05
    4722:	0e 94 92 14 	call	0x2924	; 0x2924 <uxQueueMessagesWaitingFromISR>
    4726:	91 e0       	ldi	r25, 0x01	; 1
    4728:	81 11       	cpse	r24, r1
    472a:	90 e0       	ldi	r25, 0x00	; 0
		}
    472c:	89 2f       	mov	r24, r25
    472e:	08 95       	ret

00004730 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4730:	fc 01       	movw	r30, r24
    4732:	84 81       	ldd	r24, Z+4	; 0x04
    4734:	95 81       	ldd	r25, Z+5	; 0x05
    4736:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
		}
    473a:	90 e0       	ldi	r25, 0x00	; 0
    473c:	08 95       	ret

0000473e <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    473e:	fc 01       	movw	r30, r24
    4740:	84 81       	ldd	r24, Z+4	; 0x04
    4742:	95 81       	ldd	r25, Z+5	; 0x05
    4744:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    4748:	91 e0       	ldi	r25, 0x01	; 1
    474a:	81 11       	cpse	r24, r1
    474c:	01 c0       	rjmp	.+2      	; 0x4750 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    474e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4750:	89 2f       	mov	r24, r25
    4752:	08 95       	ret

00004754 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4754:	fc 01       	movw	r30, r24
    4756:	84 81       	ldd	r24, Z+4	; 0x04
    4758:	95 81       	ldd	r25, Z+5	; 0x05
    475a:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    475e:	91 e0       	ldi	r25, 0x01	; 1
    4760:	81 11       	cpse	r24, r1
    4762:	90 e0       	ldi	r25, 0x00	; 0
		}
    4764:	89 2f       	mov	r24, r25
    4766:	08 95       	ret

00004768 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4768:	fc 01       	movw	r30, r24
    476a:	84 81       	ldd	r24, Z+4	; 0x04
    476c:	95 81       	ldd	r25, Z+5	; 0x05
    476e:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
		}
    4772:	90 e0       	ldi	r25, 0x00	; 0
    4774:	08 95       	ret

00004776 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4776:	fc 01       	movw	r30, r24
    4778:	84 81       	ldd	r24, Z+4	; 0x04
    477a:	95 81       	ldd	r25, Z+5	; 0x05
    477c:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    4780:	91 e0       	ldi	r25, 0x01	; 1
    4782:	81 11       	cpse	r24, r1
    4784:	01 c0       	rjmp	.+2      	; 0x4788 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4786:	90 e0       	ldi	r25, 0x00	; 0
		}
    4788:	89 2f       	mov	r24, r25
    478a:	08 95       	ret

0000478c <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    478c:	fc 01       	movw	r30, r24
    478e:	84 81       	ldd	r24, Z+4	; 0x04
    4790:	95 81       	ldd	r25, Z+5	; 0x05
    4792:	0e 94 8a 14 	call	0x2914	; 0x2914 <uxQueueMessagesWaiting>
    4796:	91 e0       	ldi	r25, 0x01	; 1
    4798:	81 11       	cpse	r24, r1
    479a:	90 e0       	ldi	r25, 0x00	; 0
		}
    479c:	89 2f       	mov	r24, r25
    479e:	08 95       	ret

000047a0 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    47a0:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    47a2:	01 e0       	ldi	r16, 0x01	; 1
    47a4:	2f ef       	ldi	r18, 0xFF	; 255
    47a6:	3f ef       	ldi	r19, 0xFF	; 255
    47a8:	a9 01       	movw	r20, r18
    47aa:	fc 01       	movw	r30, r24
    47ac:	84 81       	ldd	r24, Z+4	; 0x04
    47ae:	95 81       	ldd	r25, Z+5	; 0x05
    47b0:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    47b4:	0f 91       	pop	r16
    47b6:	08 95       	ret

000047b8 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    47b8:	0f 93       	push	r16
    47ba:	cf 93       	push	r28
    47bc:	df 93       	push	r29
    47be:	1f 92       	push	r1
    47c0:	1f 92       	push	r1
    47c2:	cd b7       	in	r28, 0x3d	; 61
    47c4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    47c6:	01 e0       	ldi	r16, 0x01	; 1
    47c8:	2f ef       	ldi	r18, 0xFF	; 255
    47ca:	3f ef       	ldi	r19, 0xFF	; 255
    47cc:	a9 01       	movw	r20, r18
    47ce:	be 01       	movw	r22, r28
    47d0:	6f 5f       	subi	r22, 0xFF	; 255
    47d2:	7f 4f       	sbci	r23, 0xFF	; 255
    47d4:	fc 01       	movw	r30, r24
    47d6:	84 81       	ldd	r24, Z+4	; 0x04
    47d8:	95 81       	ldd	r25, Z+5	; 0x05
    47da:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    47de:	89 81       	ldd	r24, Y+1	; 0x01
    47e0:	9a 81       	ldd	r25, Y+2	; 0x02
    47e2:	0f 90       	pop	r0
    47e4:	0f 90       	pop	r0
    47e6:	df 91       	pop	r29
    47e8:	cf 91       	pop	r28
    47ea:	0f 91       	pop	r16
    47ec:	08 95       	ret

000047ee <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    47ee:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    47f0:	00 e0       	ldi	r16, 0x00	; 0
    47f2:	2f ef       	ldi	r18, 0xFF	; 255
    47f4:	3f ef       	ldi	r19, 0xFF	; 255
    47f6:	a9 01       	movw	r20, r18
    47f8:	fc 01       	movw	r30, r24
    47fa:	84 81       	ldd	r24, Z+4	; 0x04
    47fc:	95 81       	ldd	r25, Z+5	; 0x05
    47fe:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    4802:	0f 91       	pop	r16
    4804:	08 95       	ret

00004806 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4806:	0f 93       	push	r16
    4808:	cf 93       	push	r28
    480a:	df 93       	push	r29
    480c:	1f 92       	push	r1
    480e:	1f 92       	push	r1
    4810:	cd b7       	in	r28, 0x3d	; 61
    4812:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4814:	00 e0       	ldi	r16, 0x00	; 0
    4816:	2f ef       	ldi	r18, 0xFF	; 255
    4818:	3f ef       	ldi	r19, 0xFF	; 255
    481a:	a9 01       	movw	r20, r18
    481c:	be 01       	movw	r22, r28
    481e:	6f 5f       	subi	r22, 0xFF	; 255
    4820:	7f 4f       	sbci	r23, 0xFF	; 255
    4822:	fc 01       	movw	r30, r24
    4824:	84 81       	ldd	r24, Z+4	; 0x04
    4826:	95 81       	ldd	r25, Z+5	; 0x05
    4828:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    482c:	89 81       	ldd	r24, Y+1	; 0x01
    482e:	9a 81       	ldd	r25, Y+2	; 0x02
    4830:	0f 90       	pop	r0
    4832:	0f 90       	pop	r0
    4834:	df 91       	pop	r29
    4836:	cf 91       	pop	r28
    4838:	0f 91       	pop	r16
    483a:	08 95       	ret

0000483c <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    483c:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    483e:	01 e0       	ldi	r16, 0x01	; 1
    4840:	2f ef       	ldi	r18, 0xFF	; 255
    4842:	3f ef       	ldi	r19, 0xFF	; 255
    4844:	a9 01       	movw	r20, r18
    4846:	fc 01       	movw	r30, r24
    4848:	84 81       	ldd	r24, Z+4	; 0x04
    484a:	95 81       	ldd	r25, Z+5	; 0x05
    484c:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    4850:	0f 91       	pop	r16
    4852:	08 95       	ret

00004854 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4854:	0f 93       	push	r16
    4856:	cf 93       	push	r28
    4858:	df 93       	push	r29
    485a:	1f 92       	push	r1
    485c:	1f 92       	push	r1
    485e:	cd b7       	in	r28, 0x3d	; 61
    4860:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4862:	01 e0       	ldi	r16, 0x01	; 1
    4864:	2f ef       	ldi	r18, 0xFF	; 255
    4866:	3f ef       	ldi	r19, 0xFF	; 255
    4868:	a9 01       	movw	r20, r18
    486a:	be 01       	movw	r22, r28
    486c:	6f 5f       	subi	r22, 0xFF	; 255
    486e:	7f 4f       	sbci	r23, 0xFF	; 255
    4870:	fc 01       	movw	r30, r24
    4872:	84 81       	ldd	r24, Z+4	; 0x04
    4874:	95 81       	ldd	r25, Z+5	; 0x05
    4876:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    487a:	89 81       	ldd	r24, Y+1	; 0x01
    487c:	9a 81       	ldd	r25, Y+2	; 0x02
    487e:	0f 90       	pop	r0
    4880:	0f 90       	pop	r0
    4882:	df 91       	pop	r29
    4884:	cf 91       	pop	r28
    4886:	0f 91       	pop	r16
    4888:	08 95       	ret

0000488a <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    488a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    488c:	00 e0       	ldi	r16, 0x00	; 0
    488e:	2f ef       	ldi	r18, 0xFF	; 255
    4890:	3f ef       	ldi	r19, 0xFF	; 255
    4892:	a9 01       	movw	r20, r18
    4894:	fc 01       	movw	r30, r24
    4896:	84 81       	ldd	r24, Z+4	; 0x04
    4898:	95 81       	ldd	r25, Z+5	; 0x05
    489a:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
}
    489e:	0f 91       	pop	r16
    48a0:	08 95       	ret

000048a2 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    48a2:	0f 93       	push	r16
    48a4:	cf 93       	push	r28
    48a6:	df 93       	push	r29
    48a8:	1f 92       	push	r1
    48aa:	1f 92       	push	r1
    48ac:	cd b7       	in	r28, 0x3d	; 61
    48ae:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    48b0:	00 e0       	ldi	r16, 0x00	; 0
    48b2:	2f ef       	ldi	r18, 0xFF	; 255
    48b4:	3f ef       	ldi	r19, 0xFF	; 255
    48b6:	a9 01       	movw	r20, r18
    48b8:	be 01       	movw	r22, r28
    48ba:	6f 5f       	subi	r22, 0xFF	; 255
    48bc:	7f 4f       	sbci	r23, 0xFF	; 255
    48be:	fc 01       	movw	r30, r24
    48c0:	84 81       	ldd	r24, Z+4	; 0x04
    48c2:	95 81       	ldd	r25, Z+5	; 0x05
    48c4:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericReceive>
	return (recv_item);
}
    48c8:	89 81       	ldd	r24, Y+1	; 0x01
    48ca:	9a 81       	ldd	r25, Y+2	; 0x02
    48cc:	0f 90       	pop	r0
    48ce:	0f 90       	pop	r0
    48d0:	df 91       	pop	r29
    48d2:	cf 91       	pop	r28
    48d4:	0f 91       	pop	r16
    48d6:	08 95       	ret

000048d8 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    48d8:	cf 93       	push	r28
    48da:	df 93       	push	r29
    48dc:	1f 92       	push	r1
    48de:	cd b7       	in	r28, 0x3d	; 61
    48e0:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    48e2:	ae 01       	movw	r20, r28
    48e4:	4f 5f       	subi	r20, 0xFF	; 255
    48e6:	5f 4f       	sbci	r21, 0xFF	; 255
    48e8:	fc 01       	movw	r30, r24
    48ea:	84 81       	ldd	r24, Z+4	; 0x04
    48ec:	95 81       	ldd	r25, Z+5	; 0x05
    48ee:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
}
    48f2:	0f 90       	pop	r0
    48f4:	df 91       	pop	r29
    48f6:	cf 91       	pop	r28
    48f8:	08 95       	ret

000048fa <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	00 d0       	rcall	.+0      	; 0x4900 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4900:	cd b7       	in	r28, 0x3d	; 61
    4902:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4904:	ae 01       	movw	r20, r28
    4906:	4d 5f       	subi	r20, 0xFD	; 253
    4908:	5f 4f       	sbci	r21, 0xFF	; 255
    490a:	be 01       	movw	r22, r28
    490c:	6f 5f       	subi	r22, 0xFF	; 255
    490e:	7f 4f       	sbci	r23, 0xFF	; 255
    4910:	fc 01       	movw	r30, r24
    4912:	84 81       	ldd	r24, Z+4	; 0x04
    4914:	95 81       	ldd	r25, Z+5	; 0x05
    4916:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
	return (recv_item);
}
    491a:	89 81       	ldd	r24, Y+1	; 0x01
    491c:	9a 81       	ldd	r25, Y+2	; 0x02
    491e:	23 96       	adiw	r28, 0x03	; 3
    4920:	cd bf       	out	0x3d, r28	; 61
    4922:	de bf       	out	0x3e, r29	; 62
    4924:	df 91       	pop	r29
    4926:	cf 91       	pop	r28
    4928:	08 95       	ret

0000492a <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    492a:	cf 93       	push	r28
    492c:	df 93       	push	r29
    492e:	1f 92       	push	r1
    4930:	cd b7       	in	r28, 0x3d	; 61
    4932:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4934:	ae 01       	movw	r20, r28
    4936:	4f 5f       	subi	r20, 0xFF	; 255
    4938:	5f 4f       	sbci	r21, 0xFF	; 255
    493a:	fc 01       	movw	r30, r24
    493c:	84 81       	ldd	r24, Z+4	; 0x04
    493e:	95 81       	ldd	r25, Z+5	; 0x05
    4940:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
}
    4944:	0f 90       	pop	r0
    4946:	df 91       	pop	r29
    4948:	cf 91       	pop	r28
    494a:	08 95       	ret

0000494c <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    494c:	cf 93       	push	r28
    494e:	df 93       	push	r29
    4950:	00 d0       	rcall	.+0      	; 0x4952 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4952:	cd b7       	in	r28, 0x3d	; 61
    4954:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4956:	ae 01       	movw	r20, r28
    4958:	4d 5f       	subi	r20, 0xFD	; 253
    495a:	5f 4f       	sbci	r21, 0xFF	; 255
    495c:	be 01       	movw	r22, r28
    495e:	6f 5f       	subi	r22, 0xFF	; 255
    4960:	7f 4f       	sbci	r23, 0xFF	; 255
    4962:	fc 01       	movw	r30, r24
    4964:	84 81       	ldd	r24, Z+4	; 0x04
    4966:	95 81       	ldd	r25, Z+5	; 0x05
    4968:	0e 94 5d 14 	call	0x28ba	; 0x28ba <xQueueReceiveFromISR>
	return (recv_item);
}
    496c:	89 81       	ldd	r24, Y+1	; 0x01
    496e:	9a 81       	ldd	r25, Y+2	; 0x02
    4970:	23 96       	adiw	r28, 0x03	; 3
    4972:	cd bf       	out	0x3d, r28	; 61
    4974:	de bf       	out	0x3e, r29	; 62
    4976:	df 91       	pop	r29
    4978:	cf 91       	pop	r28
    497a:	08 95       	ret

0000497c <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    497c:	cf 93       	push	r28
    497e:	df 93       	push	r29
    4980:	1f 92       	push	r1
    4982:	cd b7       	in	r28, 0x3d	; 61
    4984:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4986:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4988:	21 e0       	ldi	r18, 0x01	; 1
    498a:	ae 01       	movw	r20, r28
    498c:	4f 5f       	subi	r20, 0xFF	; 255
    498e:	5f 4f       	sbci	r21, 0xFF	; 255
    4990:	fc 01       	movw	r30, r24
    4992:	84 81       	ldd	r24, Z+4	; 0x04
    4994:	95 81       	ldd	r25, Z+5	; 0x05
    4996:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    499a:	91 e0       	ldi	r25, 0x01	; 1
    499c:	81 11       	cpse	r24, r1
    499e:	01 c0       	rjmp	.+2      	; 0x49a2 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    49a0:	90 e0       	ldi	r25, 0x00	; 0
}
    49a2:	89 2f       	mov	r24, r25
    49a4:	0f 90       	pop	r0
    49a6:	df 91       	pop	r29
    49a8:	cf 91       	pop	r28
    49aa:	08 95       	ret

000049ac <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    49ac:	cf 93       	push	r28
    49ae:	df 93       	push	r29
    49b0:	1f 92       	push	r1
    49b2:	cd b7       	in	r28, 0x3d	; 61
    49b4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49b6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    49b8:	20 e0       	ldi	r18, 0x00	; 0
    49ba:	ae 01       	movw	r20, r28
    49bc:	4f 5f       	subi	r20, 0xFF	; 255
    49be:	5f 4f       	sbci	r21, 0xFF	; 255
    49c0:	fc 01       	movw	r30, r24
    49c2:	84 81       	ldd	r24, Z+4	; 0x04
    49c4:	95 81       	ldd	r25, Z+5	; 0x05
    49c6:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49ca:	91 e0       	ldi	r25, 0x01	; 1
    49cc:	81 11       	cpse	r24, r1
    49ce:	01 c0       	rjmp	.+2      	; 0x49d2 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    49d0:	90 e0       	ldi	r25, 0x00	; 0
}
    49d2:	89 2f       	mov	r24, r25
    49d4:	0f 90       	pop	r0
    49d6:	df 91       	pop	r29
    49d8:	cf 91       	pop	r28
    49da:	08 95       	ret

000049dc <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    49dc:	cf 93       	push	r28
    49de:	df 93       	push	r29
    49e0:	1f 92       	push	r1
    49e2:	cd b7       	in	r28, 0x3d	; 61
    49e4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49e6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    49e8:	21 e0       	ldi	r18, 0x01	; 1
    49ea:	ae 01       	movw	r20, r28
    49ec:	4f 5f       	subi	r20, 0xFF	; 255
    49ee:	5f 4f       	sbci	r21, 0xFF	; 255
    49f0:	fc 01       	movw	r30, r24
    49f2:	84 81       	ldd	r24, Z+4	; 0x04
    49f4:	95 81       	ldd	r25, Z+5	; 0x05
    49f6:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49fa:	91 e0       	ldi	r25, 0x01	; 1
    49fc:	81 11       	cpse	r24, r1
    49fe:	01 c0       	rjmp	.+2      	; 0x4a02 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4a00:	90 e0       	ldi	r25, 0x00	; 0
}
    4a02:	89 2f       	mov	r24, r25
    4a04:	0f 90       	pop	r0
    4a06:	df 91       	pop	r29
    4a08:	cf 91       	pop	r28
    4a0a:	08 95       	ret

00004a0c <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4a0c:	cf 93       	push	r28
    4a0e:	df 93       	push	r29
    4a10:	1f 92       	push	r1
    4a12:	cd b7       	in	r28, 0x3d	; 61
    4a14:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a16:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4a18:	20 e0       	ldi	r18, 0x00	; 0
    4a1a:	ae 01       	movw	r20, r28
    4a1c:	4f 5f       	subi	r20, 0xFF	; 255
    4a1e:	5f 4f       	sbci	r21, 0xFF	; 255
    4a20:	fc 01       	movw	r30, r24
    4a22:	84 81       	ldd	r24, Z+4	; 0x04
    4a24:	95 81       	ldd	r25, Z+5	; 0x05
    4a26:	0e 94 6d 13 	call	0x26da	; 0x26da <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a2a:	91 e0       	ldi	r25, 0x01	; 1
    4a2c:	81 11       	cpse	r24, r1
    4a2e:	01 c0       	rjmp	.+2      	; 0x4a32 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4a30:	90 e0       	ldi	r25, 0x00	; 0
}
    4a32:	89 2f       	mov	r24, r25
    4a34:	0f 90       	pop	r0
    4a36:	df 91       	pop	r29
    4a38:	cf 91       	pop	r28
    4a3a:	08 95       	ret

00004a3c <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4a3c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4a3e:	fc 01       	movw	r30, r24
    4a40:	26 81       	ldd	r18, Z+6	; 0x06
    4a42:	37 81       	ldd	r19, Z+7	; 0x07
    4a44:	40 85       	ldd	r20, Z+8	; 0x08
    4a46:	51 85       	ldd	r21, Z+9	; 0x09
    4a48:	01 e0       	ldi	r16, 0x01	; 1
    4a4a:	84 81       	ldd	r24, Z+4	; 0x04
    4a4c:	95 81       	ldd	r25, Z+5	; 0x05
    4a4e:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    4a52:	91 e0       	ldi	r25, 0x01	; 1
    4a54:	81 11       	cpse	r24, r1
    4a56:	01 c0       	rjmp	.+2      	; 0x4a5a <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4a58:	90 e0       	ldi	r25, 0x00	; 0
		}
    4a5a:	89 2f       	mov	r24, r25
    4a5c:	0f 91       	pop	r16
    4a5e:	08 95       	ret

00004a60 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4a60:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4a62:	fc 01       	movw	r30, r24
    4a64:	26 81       	ldd	r18, Z+6	; 0x06
    4a66:	37 81       	ldd	r19, Z+7	; 0x07
    4a68:	40 85       	ldd	r20, Z+8	; 0x08
    4a6a:	51 85       	ldd	r21, Z+9	; 0x09
    4a6c:	00 e0       	ldi	r16, 0x00	; 0
    4a6e:	84 81       	ldd	r24, Z+4	; 0x04
    4a70:	95 81       	ldd	r25, Z+5	; 0x05
    4a72:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    4a76:	91 e0       	ldi	r25, 0x01	; 1
    4a78:	81 11       	cpse	r24, r1
    4a7a:	01 c0       	rjmp	.+2      	; 0x4a7e <_ZN9frt_queueIjE3putERKj+0x1e>
    4a7c:	90 e0       	ldi	r25, 0x00	; 0
		}
    4a7e:	89 2f       	mov	r24, r25
    4a80:	0f 91       	pop	r16
    4a82:	08 95       	ret

00004a84 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4a84:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4a86:	fc 01       	movw	r30, r24
    4a88:	26 81       	ldd	r18, Z+6	; 0x06
    4a8a:	37 81       	ldd	r19, Z+7	; 0x07
    4a8c:	40 85       	ldd	r20, Z+8	; 0x08
    4a8e:	51 85       	ldd	r21, Z+9	; 0x09
    4a90:	01 e0       	ldi	r16, 0x01	; 1
    4a92:	84 81       	ldd	r24, Z+4	; 0x04
    4a94:	95 81       	ldd	r25, Z+5	; 0x05
    4a96:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    4a9a:	91 e0       	ldi	r25, 0x01	; 1
    4a9c:	81 11       	cpse	r24, r1
    4a9e:	01 c0       	rjmp	.+2      	; 0x4aa2 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4aa0:	90 e0       	ldi	r25, 0x00	; 0
		}
    4aa2:	89 2f       	mov	r24, r25
    4aa4:	0f 91       	pop	r16
    4aa6:	08 95       	ret

00004aa8 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4aa8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4aaa:	fc 01       	movw	r30, r24
    4aac:	26 81       	ldd	r18, Z+6	; 0x06
    4aae:	37 81       	ldd	r19, Z+7	; 0x07
    4ab0:	40 85       	ldd	r20, Z+8	; 0x08
    4ab2:	51 85       	ldd	r21, Z+9	; 0x09
    4ab4:	00 e0       	ldi	r16, 0x00	; 0
    4ab6:	84 81       	ldd	r24, Z+4	; 0x04
    4ab8:	95 81       	ldd	r25, Z+5	; 0x05
    4aba:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <xQueueGenericSend>
    4abe:	91 e0       	ldi	r25, 0x01	; 1
    4ac0:	81 11       	cpse	r24, r1
    4ac2:	01 c0       	rjmp	.+2      	; 0x4ac6 <_ZN9frt_queueIiE3putERKi+0x1e>
    4ac4:	90 e0       	ldi	r25, 0x00	; 0
		}
    4ac6:	89 2f       	mov	r24, r25
    4ac8:	0f 91       	pop	r16
    4aca:	08 95       	ret

00004acc <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4acc:	0f 93       	push	r16
    4ace:	cf 93       	push	r28
    4ad0:	df 93       	push	r29
    4ad2:	1f 92       	push	r1
    4ad4:	cd b7       	in	r28, 0x3d	; 61
    4ad6:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4ad8:	2f b7       	in	r18, 0x3f	; 63
    4ada:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4adc:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4ade:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4ae0:	fc 01       	movw	r30, r24
    4ae2:	08 ed       	ldi	r16, 0xD8	; 216
    4ae4:	04 bf       	out	0x34, r16	; 52
    4ae6:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4ae8:	89 81       	ldd	r24, Y+1	; 0x01
    4aea:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4aec:	0f 90       	pop	r0
    4aee:	df 91       	pop	r29
    4af0:	cf 91       	pop	r28
    4af2:	0f 91       	pop	r16
    4af4:	08 95       	ret

00004af6 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4af6:	ef 92       	push	r14
    4af8:	ff 92       	push	r15
    4afa:	0f 93       	push	r16
    4afc:	1f 93       	push	r17
    4afe:	cf 93       	push	r28
    4b00:	df 93       	push	r29
    4b02:	cd b7       	in	r28, 0x3d	; 61
    4b04:	de b7       	in	r29, 0x3e	; 62
    4b06:	c8 55       	subi	r28, 0x58	; 88
    4b08:	d1 09       	sbc	r29, r1
    4b0a:	cd bf       	out	0x3d, r28	; 61
    4b0c:	de bf       	out	0x3e, r29	; 62
	cli();
    4b0e:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4b10:	e0 e5       	ldi	r30, 0x50	; 80
    4b12:	f0 e0       	ldi	r31, 0x00	; 0
    4b14:	80 81       	ld	r24, Z
    4b16:	82 60       	ori	r24, 0x02	; 2
    4b18:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4b1a:	81 81       	ldd	r24, Z+1	; 0x01
    4b1c:	81 ff       	sbrs	r24, 1
    4b1e:	fd cf       	rjmp	.-6      	; 0x4b1a <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4b20:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4b24:	68 7f       	andi	r22, 0xF8	; 248
    4b26:	61 60       	ori	r22, 0x01	; 1
    4b28:	80 e4       	ldi	r24, 0x40	; 64
    4b2a:	90 e0       	ldi	r25, 0x00	; 0
    4b2c:	0e 94 66 25 	call	0x4acc	; 0x4acc <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4b30:	e0 e5       	ldi	r30, 0x50	; 80
    4b32:	f0 e0       	ldi	r31, 0x00	; 0
    4b34:	80 81       	ld	r24, Z
    4b36:	8e 7f       	andi	r24, 0xFE	; 254
    4b38:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4b3a:	9d ef       	ldi	r25, 0xFD	; 253
    4b3c:	88 ed       	ldi	r24, 0xD8	; 216
    4b3e:	08 b6       	in	r0, 0x38	; 56
    4b40:	18 be       	out	0x38, r1	; 56
    4b42:	84 bf       	out	0x34, r24	; 52
    4b44:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4b48:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4b4a:	40 ea       	ldi	r20, 0xA0	; 160
    4b4c:	5a e0       	ldi	r21, 0x0A	; 10
    4b4e:	60 e0       	ldi	r22, 0x00	; 0
    4b50:	70 e0       	ldi	r23, 0x00	; 0
    4b52:	ce 01       	movw	r24, r28
    4b54:	01 96       	adiw	r24, 0x01	; 1
    4b56:	0e 94 0a 21 	call	0x4214	; 0x4214 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4b5a:	67 e0       	ldi	r22, 0x07	; 7
    4b5c:	ce 01       	movw	r24, r28
    4b5e:	01 96       	adiw	r24, 0x01	; 1
    4b60:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    4b64:	8c 01       	movw	r16, r24
    4b66:	60 ec       	ldi	r22, 0xC0	; 192
    4b68:	71 e2       	ldi	r23, 0x21	; 33
    4b6a:	0e 94 30 1f 	call	0x3e60	; 0x3e60 <_ZN8emstream4putsEPKc>
    4b6e:	66 e0       	ldi	r22, 0x06	; 6
    4b70:	c8 01       	movw	r24, r16
    4b72:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
    4b76:	66 e0       	ldi	r22, 0x06	; 6
    4b78:	0e 94 67 1f 	call	0x3ece	; 0x3ece <_ZN8emstreamlsE15ser_manipulator>
	
	// Create instance of I2C driver to be used by sensor objects
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4b7c:	8e 01       	movw	r16, r28
    4b7e:	0f 5f       	subi	r16, 0xFF	; 255
    4b80:	1f 4f       	sbci	r17, 0xFF	; 255
    4b82:	20 e3       	ldi	r18, 0x30	; 48
    4b84:	32 ef       	ldi	r19, 0xF2	; 242
    4b86:	40 e0       	ldi	r20, 0x00	; 0
    4b88:	50 e0       	ldi	r21, 0x00	; 0
    4b8a:	60 ea       	ldi	r22, 0xA0	; 160
    4b8c:	74 e0       	ldi	r23, 0x04	; 4
    4b8e:	ce 01       	movw	r24, r28
    4b90:	4e 96       	adiw	r24, 0x1e	; 30
    4b92:	0e 94 b5 07 	call	0xf6a	; 0xf6a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>
	
	// Create instance of IMU class and pass in a pointer to the I2C driver
	MMA8451 mma8451(&i2c, &ser_dev);
    4b96:	a8 01       	movw	r20, r16
    4b98:	be 01       	movw	r22, r28
    4b9a:	62 5e       	subi	r22, 0xE2	; 226
    4b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b9e:	ce 01       	movw	r24, r28
    4ba0:	c7 96       	adiw	r24, 0x37	; 55
    4ba2:	0e 94 33 0a 	call	0x1466	; 0x1466 <_ZN7MMA8451C1EP9I2CMasterP8emstream>

	//Create instance of Sonar class and pass in a pointer to the I2C driver
	MB1202 mb1202(&i2c, &ser_dev);
    4ba6:	a8 01       	movw	r20, r16
    4ba8:	be 01       	movw	r22, r28
    4baa:	62 5e       	subi	r22, 0xE2	; 226
    4bac:	7f 4f       	sbci	r23, 0xFF	; 255
    4bae:	ce 01       	movw	r24, r28
    4bb0:	88 5b       	subi	r24, 0xB8	; 184
    4bb2:	9f 4f       	sbci	r25, 0xFF	; 255
    4bb4:	0e 94 4d 09 	call	0x129a	; 0x129a <_ZN6MB1202C1EP9I2CMasterP8emstream>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4bb8:	82 e1       	ldi	r24, 0x12	; 18
    4bba:	90 e0       	ldi	r25, 0x00	; 0
    4bbc:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    4bc0:	20 e8       	ldi	r18, 0x80	; 128
    4bc2:	30 e0       	ldi	r19, 0x00	; 0
    4bc4:	40 e0       	ldi	r20, 0x00	; 0
    4bc6:	6f ed       	ldi	r22, 0xDF	; 223
    4bc8:	71 e2       	ldi	r23, 0x21	; 33
    4bca:	0e 94 4e 0c 	call	0x189c	; 0x189c <_ZN9task_userC1EPKchjP8emstream>
	// new task_sonar( "Sonar", task_priority(2), 128, &ser_dev, &mb1202 );	
	new task_sensor ("Sensor", task_priority (2), 128, &ser_dev, &mma8451);
    4bce:	88 e1       	ldi	r24, 0x18	; 24
    4bd0:	90 e0       	ldi	r25, 0x00	; 0
    4bd2:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <_Znwj>
    4bd6:	9e 01       	movw	r18, r28
    4bd8:	29 5c       	subi	r18, 0xC9	; 201
    4bda:	3f 4f       	sbci	r19, 0xFF	; 255
    4bdc:	79 01       	movw	r14, r18
    4bde:	20 e8       	ldi	r18, 0x80	; 128
    4be0:	30 e0       	ldi	r19, 0x00	; 0
    4be2:	42 e0       	ldi	r20, 0x02	; 2
    4be4:	67 ee       	ldi	r22, 0xE7	; 231
    4be6:	71 e2       	ldi	r23, 0x21	; 33
    4be8:	0e 94 31 0c 	call	0x1862	; 0x1862 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4bec:	87 e0       	ldi	r24, 0x07	; 7
    4bee:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4bf2:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4bf4:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <vTaskStartScheduler>
}
    4bf8:	80 e0       	ldi	r24, 0x00	; 0
    4bfa:	90 e0       	ldi	r25, 0x00	; 0
    4bfc:	c8 5a       	subi	r28, 0xA8	; 168
    4bfe:	df 4f       	sbci	r29, 0xFF	; 255
    4c00:	cd bf       	out	0x3d, r28	; 61
    4c02:	de bf       	out	0x3e, r29	; 62
    4c04:	df 91       	pop	r29
    4c06:	cf 91       	pop	r28
    4c08:	1f 91       	pop	r17
    4c0a:	0f 91       	pop	r16
    4c0c:	ff 90       	pop	r15
    4c0e:	ef 90       	pop	r14
    4c10:	08 95       	ret

00004c12 <_GLOBAL__sub_I_counter>:
    4c12:	cf 92       	push	r12
    4c14:	df 92       	push	r13
    4c16:	ef 92       	push	r14
    4c18:	ff 92       	push	r15
    4c1a:	0f 93       	push	r16
    4c1c:	1f 93       	push	r17
    4c1e:	cf 93       	push	r28
    4c20:	df 93       	push	r29
#include "task_user.h"                      // Header for user interface task
#include "task_sensor.h"
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4c22:	0a e0       	ldi	r16, 0x0A	; 10
    4c24:	10 e0       	ldi	r17, 0x00	; 0
    4c26:	20 e0       	ldi	r18, 0x00	; 0
    4c28:	30 e0       	ldi	r19, 0x00	; 0
    4c2a:	40 e0       	ldi	r20, 0x00	; 0
    4c2c:	50 e0       	ldi	r21, 0x00	; 0
    4c2e:	60 e2       	ldi	r22, 0x20	; 32
    4c30:	70 e0       	ldi	r23, 0x00	; 0
    4c32:	82 ef       	ldi	r24, 0xF2	; 242
    4c34:	92 e3       	ldi	r25, 0x32	; 50
    4c36:	0e 94 e8 1c 	call	0x39d0	; 0x39d0 <_ZN14frt_text_queueC1EjP8emstreamm>
    4c3a:	c8 ee       	ldi	r28, 0xE8	; 232
    4c3c:	d2 e3       	ldi	r29, 0x32	; 50
    4c3e:	1a 82       	std	Y+2, r1	; 0x02
    4c40:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c42:	82 ef       	ldi	r24, 0xF2	; 242
    4c44:	91 e2       	ldi	r25, 0x21	; 33
    4c46:	88 83       	st	Y, r24
    4c48:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4c4a:	40 e0       	ldi	r20, 0x00	; 0
    4c4c:	62 e0       	ldi	r22, 0x02	; 2
    4c4e:	8f ef       	ldi	r24, 0xFF	; 255
    4c50:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    4c54:	8c 83       	std	Y+4, r24	; 0x04
    4c56:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4c58:	0f 2e       	mov	r0, r31
    4c5a:	fa e0       	ldi	r31, 0x0A	; 10
    4c5c:	cf 2e       	mov	r12, r31
    4c5e:	d1 2c       	mov	r13, r1
    4c60:	e1 2c       	mov	r14, r1
    4c62:	f1 2c       	mov	r15, r1
    4c64:	f0 2d       	mov	r31, r0
    4c66:	ce 82       	std	Y+6, r12	; 0x06
    4c68:	df 82       	std	Y+7, r13	; 0x07
    4c6a:	e8 86       	std	Y+8, r14	; 0x08
    4c6c:	f9 86       	std	Y+9, r15	; 0x09
    4c6e:	ce ed       	ldi	r28, 0xDE	; 222
    4c70:	d2 e3       	ldi	r29, 0x32	; 50
    4c72:	1a 82       	std	Y+2, r1	; 0x02
    4c74:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c76:	06 e1       	ldi	r16, 0x16	; 22
    4c78:	12 e2       	ldi	r17, 0x22	; 34
    4c7a:	08 83       	st	Y, r16
    4c7c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4c7e:	40 e0       	ldi	r20, 0x00	; 0
    4c80:	62 e0       	ldi	r22, 0x02	; 2
    4c82:	8f ef       	ldi	r24, 0xFF	; 255
    4c84:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    4c88:	8c 83       	std	Y+4, r24	; 0x04
    4c8a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4c8c:	ce 82       	std	Y+6, r12	; 0x06
    4c8e:	df 82       	std	Y+7, r13	; 0x07
    4c90:	e8 86       	std	Y+8, r14	; 0x08
    4c92:	f9 86       	std	Y+9, r15	; 0x09
    4c94:	c4 ed       	ldi	r28, 0xD4	; 212
    4c96:	d2 e3       	ldi	r29, 0x32	; 50
    4c98:	1a 82       	std	Y+2, r1	; 0x02
    4c9a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c9c:	08 83       	st	Y, r16
    4c9e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ca0:	40 e0       	ldi	r20, 0x00	; 0
    4ca2:	62 e0       	ldi	r22, 0x02	; 2
    4ca4:	8f ef       	ldi	r24, 0xFF	; 255
    4ca6:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    4caa:	8c 83       	std	Y+4, r24	; 0x04
    4cac:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cae:	ce 82       	std	Y+6, r12	; 0x06
    4cb0:	df 82       	std	Y+7, r13	; 0x07
    4cb2:	e8 86       	std	Y+8, r14	; 0x08
    4cb4:	f9 86       	std	Y+9, r15	; 0x09
    4cb6:	ca ec       	ldi	r28, 0xCA	; 202
    4cb8:	d2 e3       	ldi	r29, 0x32	; 50
    4cba:	1a 82       	std	Y+2, r1	; 0x02
    4cbc:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4cbe:	08 83       	st	Y, r16
    4cc0:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4cc2:	40 e0       	ldi	r20, 0x00	; 0
    4cc4:	62 e0       	ldi	r22, 0x02	; 2
    4cc6:	8f ef       	ldi	r24, 0xFF	; 255
    4cc8:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    4ccc:	8c 83       	std	Y+4, r24	; 0x04
    4cce:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cd0:	ce 82       	std	Y+6, r12	; 0x06
    4cd2:	df 82       	std	Y+7, r13	; 0x07
    4cd4:	e8 86       	std	Y+8, r14	; 0x08
    4cd6:	f9 86       	std	Y+9, r15	; 0x09
    4cd8:	c0 ec       	ldi	r28, 0xC0	; 192
    4cda:	d2 e3       	ldi	r29, 0x32	; 50
    4cdc:	1a 82       	std	Y+2, r1	; 0x02
    4cde:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ce0:	08 83       	st	Y, r16
    4ce2:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ce4:	40 e0       	ldi	r20, 0x00	; 0
    4ce6:	62 e0       	ldi	r22, 0x02	; 2
    4ce8:	8f ef       	ldi	r24, 0xFF	; 255
    4cea:	0e 94 a4 12 	call	0x2548	; 0x2548 <xQueueGenericCreate>
    4cee:	8c 83       	std	Y+4, r24	; 0x04
    4cf0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cf2:	ce 82       	std	Y+6, r12	; 0x06
    4cf4:	df 82       	std	Y+7, r13	; 0x07
    4cf6:	e8 86       	std	Y+8, r14	; 0x08
    4cf8:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4cfa:	df 91       	pop	r29
    4cfc:	cf 91       	pop	r28
    4cfe:	1f 91       	pop	r17
    4d00:	0f 91       	pop	r16
    4d02:	ff 90       	pop	r15
    4d04:	ef 90       	pop	r14
    4d06:	df 90       	pop	r13
    4d08:	cf 90       	pop	r12
    4d0a:	08 95       	ret

00004d0c <__mulsi3>:
    4d0c:	db 01       	movw	r26, r22
    4d0e:	8f 93       	push	r24
    4d10:	9f 93       	push	r25
    4d12:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <__muluhisi3>
    4d16:	bf 91       	pop	r27
    4d18:	af 91       	pop	r26
    4d1a:	a2 9f       	mul	r26, r18
    4d1c:	80 0d       	add	r24, r0
    4d1e:	91 1d       	adc	r25, r1
    4d20:	a3 9f       	mul	r26, r19
    4d22:	90 0d       	add	r25, r0
    4d24:	b2 9f       	mul	r27, r18
    4d26:	90 0d       	add	r25, r0
    4d28:	11 24       	eor	r1, r1
    4d2a:	08 95       	ret

00004d2c <__udivmodsi4>:
    4d2c:	a1 e2       	ldi	r26, 0x21	; 33
    4d2e:	1a 2e       	mov	r1, r26
    4d30:	aa 1b       	sub	r26, r26
    4d32:	bb 1b       	sub	r27, r27
    4d34:	fd 01       	movw	r30, r26
    4d36:	0d c0       	rjmp	.+26     	; 0x4d52 <__udivmodsi4_ep>

00004d38 <__udivmodsi4_loop>:
    4d38:	aa 1f       	adc	r26, r26
    4d3a:	bb 1f       	adc	r27, r27
    4d3c:	ee 1f       	adc	r30, r30
    4d3e:	ff 1f       	adc	r31, r31
    4d40:	a2 17       	cp	r26, r18
    4d42:	b3 07       	cpc	r27, r19
    4d44:	e4 07       	cpc	r30, r20
    4d46:	f5 07       	cpc	r31, r21
    4d48:	20 f0       	brcs	.+8      	; 0x4d52 <__udivmodsi4_ep>
    4d4a:	a2 1b       	sub	r26, r18
    4d4c:	b3 0b       	sbc	r27, r19
    4d4e:	e4 0b       	sbc	r30, r20
    4d50:	f5 0b       	sbc	r31, r21

00004d52 <__udivmodsi4_ep>:
    4d52:	66 1f       	adc	r22, r22
    4d54:	77 1f       	adc	r23, r23
    4d56:	88 1f       	adc	r24, r24
    4d58:	99 1f       	adc	r25, r25
    4d5a:	1a 94       	dec	r1
    4d5c:	69 f7       	brne	.-38     	; 0x4d38 <__udivmodsi4_loop>
    4d5e:	60 95       	com	r22
    4d60:	70 95       	com	r23
    4d62:	80 95       	com	r24
    4d64:	90 95       	com	r25
    4d66:	9b 01       	movw	r18, r22
    4d68:	ac 01       	movw	r20, r24
    4d6a:	bd 01       	movw	r22, r26
    4d6c:	cf 01       	movw	r24, r30
    4d6e:	08 95       	ret

00004d70 <__divmodsi4>:
    4d70:	05 2e       	mov	r0, r21
    4d72:	97 fb       	bst	r25, 7
    4d74:	1e f4       	brtc	.+6      	; 0x4d7c <__divmodsi4+0xc>
    4d76:	00 94       	com	r0
    4d78:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <__negsi2>
    4d7c:	57 fd       	sbrc	r21, 7
    4d7e:	07 d0       	rcall	.+14     	; 0x4d8e <__divmodsi4_neg2>
    4d80:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <__udivmodsi4>
    4d84:	07 fc       	sbrc	r0, 7
    4d86:	03 d0       	rcall	.+6      	; 0x4d8e <__divmodsi4_neg2>
    4d88:	4e f4       	brtc	.+18     	; 0x4d9c <__divmodsi4_exit>
    4d8a:	0c 94 cf 26 	jmp	0x4d9e	; 0x4d9e <__negsi2>

00004d8e <__divmodsi4_neg2>:
    4d8e:	50 95       	com	r21
    4d90:	40 95       	com	r20
    4d92:	30 95       	com	r19
    4d94:	21 95       	neg	r18
    4d96:	3f 4f       	sbci	r19, 0xFF	; 255
    4d98:	4f 4f       	sbci	r20, 0xFF	; 255
    4d9a:	5f 4f       	sbci	r21, 0xFF	; 255

00004d9c <__divmodsi4_exit>:
    4d9c:	08 95       	ret

00004d9e <__negsi2>:
    4d9e:	90 95       	com	r25
    4da0:	80 95       	com	r24
    4da2:	70 95       	com	r23
    4da4:	61 95       	neg	r22
    4da6:	7f 4f       	sbci	r23, 0xFF	; 255
    4da8:	8f 4f       	sbci	r24, 0xFF	; 255
    4daa:	9f 4f       	sbci	r25, 0xFF	; 255
    4dac:	08 95       	ret

00004dae <__tablejump2__>:
    4dae:	ee 0f       	add	r30, r30
    4db0:	ff 1f       	adc	r31, r31
    4db2:	88 1f       	adc	r24, r24
    4db4:	8b bf       	out	0x3b, r24	; 59
    4db6:	07 90       	elpm	r0, Z+
    4db8:	f6 91       	elpm	r31, Z
    4dba:	e0 2d       	mov	r30, r0
    4dbc:	1b be       	out	0x3b, r1	; 59
    4dbe:	19 94       	eijmp

00004dc0 <__muluhisi3>:
    4dc0:	0e 94 eb 26 	call	0x4dd6	; 0x4dd6 <__umulhisi3>
    4dc4:	a5 9f       	mul	r26, r21
    4dc6:	90 0d       	add	r25, r0
    4dc8:	b4 9f       	mul	r27, r20
    4dca:	90 0d       	add	r25, r0
    4dcc:	a4 9f       	mul	r26, r20
    4dce:	80 0d       	add	r24, r0
    4dd0:	91 1d       	adc	r25, r1
    4dd2:	11 24       	eor	r1, r1
    4dd4:	08 95       	ret

00004dd6 <__umulhisi3>:
    4dd6:	a2 9f       	mul	r26, r18
    4dd8:	b0 01       	movw	r22, r0
    4dda:	b3 9f       	mul	r27, r19
    4ddc:	c0 01       	movw	r24, r0
    4dde:	a3 9f       	mul	r26, r19
    4de0:	70 0d       	add	r23, r0
    4de2:	81 1d       	adc	r24, r1
    4de4:	11 24       	eor	r1, r1
    4de6:	91 1d       	adc	r25, r1
    4de8:	b2 9f       	mul	r27, r18
    4dea:	70 0d       	add	r23, r0
    4dec:	81 1d       	adc	r24, r1
    4dee:	11 24       	eor	r1, r1
    4df0:	91 1d       	adc	r25, r1
    4df2:	08 95       	ret

00004df4 <memcpy>:
    4df4:	fb 01       	movw	r30, r22
    4df6:	dc 01       	movw	r26, r24
    4df8:	02 c0       	rjmp	.+4      	; 0x4dfe <memcpy+0xa>
    4dfa:	01 90       	ld	r0, Z+
    4dfc:	0d 92       	st	X+, r0
    4dfe:	41 50       	subi	r20, 0x01	; 1
    4e00:	50 40       	sbci	r21, 0x00	; 0
    4e02:	d8 f7       	brcc	.-10     	; 0x4dfa <memcpy+0x6>
    4e04:	08 95       	ret

00004e06 <memset>:
    4e06:	dc 01       	movw	r26, r24
    4e08:	01 c0       	rjmp	.+2      	; 0x4e0c <memset+0x6>
    4e0a:	6d 93       	st	X+, r22
    4e0c:	41 50       	subi	r20, 0x01	; 1
    4e0e:	50 40       	sbci	r21, 0x00	; 0
    4e10:	e0 f7       	brcc	.-8      	; 0x4e0a <memset+0x4>
    4e12:	08 95       	ret

00004e14 <strncpy>:
    4e14:	fb 01       	movw	r30, r22
    4e16:	dc 01       	movw	r26, r24
    4e18:	41 50       	subi	r20, 0x01	; 1
    4e1a:	50 40       	sbci	r21, 0x00	; 0
    4e1c:	48 f0       	brcs	.+18     	; 0x4e30 <strncpy+0x1c>
    4e1e:	01 90       	ld	r0, Z+
    4e20:	0d 92       	st	X+, r0
    4e22:	00 20       	and	r0, r0
    4e24:	c9 f7       	brne	.-14     	; 0x4e18 <strncpy+0x4>
    4e26:	01 c0       	rjmp	.+2      	; 0x4e2a <strncpy+0x16>
    4e28:	1d 92       	st	X+, r1
    4e2a:	41 50       	subi	r20, 0x01	; 1
    4e2c:	50 40       	sbci	r21, 0x00	; 0
    4e2e:	e0 f7       	brcc	.-8      	; 0x4e28 <strncpy+0x14>
    4e30:	08 95       	ret

00004e32 <ultoa>:
    4e32:	25 32       	cpi	r18, 0x25	; 37
    4e34:	31 05       	cpc	r19, r1
    4e36:	20 f4       	brcc	.+8      	; 0x4e40 <ultoa+0xe>
    4e38:	22 30       	cpi	r18, 0x02	; 2
    4e3a:	10 f0       	brcs	.+4      	; 0x4e40 <ultoa+0xe>
    4e3c:	0c 94 24 27 	jmp	0x4e48	; 0x4e48 <__ultoa_ncheck>
    4e40:	fa 01       	movw	r30, r20
    4e42:	10 82       	st	Z, r1
    4e44:	ca 01       	movw	r24, r20
    4e46:	08 95       	ret

00004e48 <__ultoa_ncheck>:
    4e48:	bb 27       	eor	r27, r27

00004e4a <__ultoa_common>:
    4e4a:	fa 01       	movw	r30, r20
    4e4c:	a6 2f       	mov	r26, r22
    4e4e:	62 17       	cp	r22, r18
    4e50:	71 05       	cpc	r23, r1
    4e52:	81 05       	cpc	r24, r1
    4e54:	91 05       	cpc	r25, r1
    4e56:	33 0b       	sbc	r19, r19
    4e58:	30 fb       	bst	r19, 0
    4e5a:	66 f0       	brts	.+24     	; 0x4e74 <__ultoa_common+0x2a>
    4e5c:	aa 27       	eor	r26, r26
    4e5e:	66 0f       	add	r22, r22
    4e60:	77 1f       	adc	r23, r23
    4e62:	88 1f       	adc	r24, r24
    4e64:	99 1f       	adc	r25, r25
    4e66:	aa 1f       	adc	r26, r26
    4e68:	a2 17       	cp	r26, r18
    4e6a:	10 f0       	brcs	.+4      	; 0x4e70 <__ultoa_common+0x26>
    4e6c:	a2 1b       	sub	r26, r18
    4e6e:	63 95       	inc	r22
    4e70:	38 50       	subi	r19, 0x08	; 8
    4e72:	a9 f7       	brne	.-22     	; 0x4e5e <__ultoa_common+0x14>
    4e74:	a0 5d       	subi	r26, 0xD0	; 208
    4e76:	aa 33       	cpi	r26, 0x3A	; 58
    4e78:	08 f0       	brcs	.+2      	; 0x4e7c <__ultoa_common+0x32>
    4e7a:	a9 5d       	subi	r26, 0xD9	; 217
    4e7c:	a1 93       	st	Z+, r26
    4e7e:	36 f7       	brtc	.-52     	; 0x4e4c <__ultoa_common+0x2>
    4e80:	b1 11       	cpse	r27, r1
    4e82:	b1 93       	st	Z+, r27
    4e84:	10 82       	st	Z, r1
    4e86:	ca 01       	movw	r24, r20
    4e88:	0c 94 6b 27 	jmp	0x4ed6	; 0x4ed6 <strrev>

00004e8c <utoa>:
    4e8c:	45 32       	cpi	r20, 0x25	; 37
    4e8e:	51 05       	cpc	r21, r1
    4e90:	20 f4       	brcc	.+8      	; 0x4e9a <utoa+0xe>
    4e92:	42 30       	cpi	r20, 0x02	; 2
    4e94:	10 f0       	brcs	.+4      	; 0x4e9a <utoa+0xe>
    4e96:	0c 94 51 27 	jmp	0x4ea2	; 0x4ea2 <__utoa_ncheck>
    4e9a:	fb 01       	movw	r30, r22
    4e9c:	10 82       	st	Z, r1
    4e9e:	cb 01       	movw	r24, r22
    4ea0:	08 95       	ret

00004ea2 <__utoa_ncheck>:
    4ea2:	bb 27       	eor	r27, r27

00004ea4 <__utoa_common>:
    4ea4:	fb 01       	movw	r30, r22
    4ea6:	55 27       	eor	r21, r21
    4ea8:	aa 27       	eor	r26, r26
    4eaa:	88 0f       	add	r24, r24
    4eac:	99 1f       	adc	r25, r25
    4eae:	aa 1f       	adc	r26, r26
    4eb0:	a4 17       	cp	r26, r20
    4eb2:	10 f0       	brcs	.+4      	; 0x4eb8 <__utoa_common+0x14>
    4eb4:	a4 1b       	sub	r26, r20
    4eb6:	83 95       	inc	r24
    4eb8:	50 51       	subi	r21, 0x10	; 16
    4eba:	b9 f7       	brne	.-18     	; 0x4eaa <__utoa_common+0x6>
    4ebc:	a0 5d       	subi	r26, 0xD0	; 208
    4ebe:	aa 33       	cpi	r26, 0x3A	; 58
    4ec0:	08 f0       	brcs	.+2      	; 0x4ec4 <__utoa_common+0x20>
    4ec2:	a9 5d       	subi	r26, 0xD9	; 217
    4ec4:	a1 93       	st	Z+, r26
    4ec6:	00 97       	sbiw	r24, 0x00	; 0
    4ec8:	79 f7       	brne	.-34     	; 0x4ea8 <__utoa_common+0x4>
    4eca:	b1 11       	cpse	r27, r1
    4ecc:	b1 93       	st	Z+, r27
    4ece:	11 92       	st	Z+, r1
    4ed0:	cb 01       	movw	r24, r22
    4ed2:	0c 94 6b 27 	jmp	0x4ed6	; 0x4ed6 <strrev>

00004ed6 <strrev>:
    4ed6:	dc 01       	movw	r26, r24
    4ed8:	fc 01       	movw	r30, r24
    4eda:	67 2f       	mov	r22, r23
    4edc:	71 91       	ld	r23, Z+
    4ede:	77 23       	and	r23, r23
    4ee0:	e1 f7       	brne	.-8      	; 0x4eda <strrev+0x4>
    4ee2:	32 97       	sbiw	r30, 0x02	; 2
    4ee4:	04 c0       	rjmp	.+8      	; 0x4eee <strrev+0x18>
    4ee6:	7c 91       	ld	r23, X
    4ee8:	6d 93       	st	X+, r22
    4eea:	70 83       	st	Z, r23
    4eec:	62 91       	ld	r22, -Z
    4eee:	ae 17       	cp	r26, r30
    4ef0:	bf 07       	cpc	r27, r31
    4ef2:	c8 f3       	brcs	.-14     	; 0x4ee6 <strrev+0x10>
    4ef4:	08 95       	ret

00004ef6 <_exit>:
    4ef6:	f8 94       	cli

00004ef8 <__stop_program>:
    4ef8:	ff cf       	rjmp	.-2      	; 0x4ef8 <__stop_program>
