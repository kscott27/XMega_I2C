
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004abe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001c6  00802000  00004abe  00004b52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008021c6  008021c6  00004d18  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004d18  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004d48  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000970  00000000  00000000  00004d88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00019141  00000000  00000000  000056f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006ac8  00000000  00000000  0001e839  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006080  00000000  00000000  00025301  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001c90  00000000  00000000  0002b384  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006db7  00000000  00000000  0002d014  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000904f  00000000  00000000  00033dcb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008d0  00000000  00000000  0003ce1a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 03 	jmp	0x66a	; 0x66a <__ctors_end>
       4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      10:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      14:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      18:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      1c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      20:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      24:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      28:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      2c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      30:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      34:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      38:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      3c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      40:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      44:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      48:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      4c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      50:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      54:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      58:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__vector_22>
      5c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      60:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      64:	0c 94 76 1f 	jmp	0x3eec	; 0x3eec <__vector_25>
      68:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      6c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      70:	0c 94 d4 1f 	jmp	0x3fa8	; 0x3fa8 <__vector_28>
      74:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      78:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      7c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      80:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      84:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      88:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      8c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      90:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      94:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      98:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      9c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e8:	0c 94 ee 20 	jmp	0x41dc	; 0x41dc <__vector_58>
      ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      fc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     100:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     104:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     108:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     10c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     110:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     114:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     118:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     11c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     120:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     124:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     128:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     12c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     130:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     134:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     138:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     13c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     140:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     144:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     148:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     14c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     150:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     154:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     158:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     15c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     160:	0c 94 32 20 	jmp	0x4064	; 0x4064 <__vector_88>
     164:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     168:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     16c:	0c 94 90 20 	jmp	0x4120	; 0x4120 <__vector_91>
     170:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     174:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     178:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     17c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     180:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     184:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     188:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     18c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     190:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     194:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     198:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     19c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1fc:	62 1d       	adc	r22, r2
     1fe:	65 1d       	adc	r22, r5
     200:	68 1d       	adc	r22, r8
     202:	6b 1d       	adc	r22, r11
     204:	6e 1d       	adc	r22, r14
     206:	71 1d       	adc	r23, r1
     208:	73 1d       	adc	r23, r3
     20a:	84 1d       	adc	r24, r4
     20c:	8c 1d       	adc	r24, r12
     20e:	96 1d       	adc	r25, r6
     210:	94 1d       	adc	r25, r4

00000212 <__trampolines_start>:
     212:	0c 94 a0 21 	jmp	0x4340	; 0x4340 <_ZN9frt_queueIiE12num_items_inEv>
     216:	0c 94 65 1d 	jmp	0x3aca	; 0x3aca <_ZN8emstreamlsE15ser_manipulator+0x24>
     21a:	0c 94 81 12 	jmp	0x2502	; 0x2502 <prvIdleTask>
     21e:	0c 94 bc 21 	jmp	0x4378	; 0x4378 <_ZN9frt_queueIjE10get_a_copyERj>
     222:	0c 94 5e 21 	jmp	0x42bc	; 0x42bc <_ZN9frt_queueIjE12ISR_is_emptyEv>
     226:	0c 94 c8 21 	jmp	0x4390	; 0x4390 <_ZN9frt_queueIjE10get_a_copyEv>
     22a:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <_ZN9frt_queueIhE10get_a_copyEv>
     22e:	0c 94 ab 1a 	jmp	0x3556	; 0x3556 <_ZN14frt_text_queue14check_for_charEv>
     232:	0c 94 ef 21 	jmp	0x43de	; 0x43de <_ZN9frt_queueIjE3getEv>
     236:	0c 94 28 05 	jmp	0xa50	; 0xa50 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     23a:	0c 94 aa 22 	jmp	0x4554	; 0x4554 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     23e:	0c 94 43 19 	jmp	0x3286	; 0x3286 <_ZN8frt_task12print_statusER8emstream>
     242:	0c 94 62 1d 	jmp	0x3ac4	; 0x3ac4 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     246:	0c 94 b6 1a 	jmp	0x356c	; 0x356c <_ZN14frt_text_queue7putcharEc>
     24a:	0c 94 68 1d 	jmp	0x3ad0	; 0x3ad0 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     24e:	0c 94 f6 08 	jmp	0x11ec	; 0x11ec <_ZN9frt_queueIhE3putERKh>
     252:	0c 94 a7 21 	jmp	0x434e	; 0x434e <_ZN9frt_queueIiE9not_emptyEv>
     256:	0c 94 31 22 	jmp	0x4462	; 0x4462 <_ZN9frt_queueIiE3getEPi>
     25a:	0c 94 bb 04 	jmp	0x976	; 0x976 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     25e:	0c 94 6e 1c 	jmp	0x38dc	; 0x38dc <__cxa_pure_virtual>
     262:	0c 94 7c 05 	jmp	0xaf8	; 0xaf8 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     266:	0c 94 91 05 	jmp	0xb22	; 0xb22 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     26a:	0c 94 1e 08 	jmp	0x103c	; 0x103c <_ZN9frt_queueIhE12ISR_is_emptyEv>
     26e:	0c 94 e4 08 	jmp	0x11c8	; 0x11c8 <_ZN9frt_queueIhE7butt_inERKh>
     272:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     276:	0c 94 3d 05 	jmp	0xa7a	; 0xa7a <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     27a:	0c 94 69 22 	jmp	0x44d2	; 0x44d2 <_ZN9frt_queueIjE7ISR_getEv>
     27e:	0c 94 f2 22 	jmp	0x45e4	; 0x45e4 <_ZN9frt_queueIiE7ISR_putERKi>
     282:	0c 94 0a 1d 	jmp	0x3a14	; 0x3a14 <_ZN8emstream14check_for_charEv>
     286:	0c 94 52 05 	jmp	0xaa4	; 0xaa4 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     28a:	0c 94 96 21 	jmp	0x432c	; 0x432c <_ZN9frt_queueIjE8is_emptyEv>
     28e:	0c 94 cc 08 	jmp	0x1198	; 0x1198 <_ZN9frt_queueIhE7ISR_putERKh>
     292:	0c 94 0a 04 	jmp	0x814	; 0x814 <_ZN9I2CMaster10StartState7executeER6Packet>
     296:	0c 94 2e 23 	jmp	0x465c	; 0x465c <_ZN9frt_queueIiE7butt_inERKi>
     29a:	0c 94 0a 22 	jmp	0x4414	; 0x4414 <_ZN9frt_queueIiE10get_a_copyERi>
     29e:	0c 94 84 1d 	jmp	0x3b08	; 0x3b08 <_ZN8emstreamlsE15ser_manipulator+0x62>
     2a2:	0c 94 29 04 	jmp	0x852	; 0x852 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2a6:	0c 94 b2 21 	jmp	0x4364	; 0x4364 <_ZN9frt_queueIiE8is_emptyEv>
     2aa:	0c 94 cf 03 	jmp	0x79e	; 0x79e <_ZN8I2CAgent11writePacketER7Command>
     2ae:	0c 94 8c 08 	jmp	0x1118	; 0x1118 <_ZN9frt_queueIhE7ISR_getEPh>
     2b2:	0c 94 8f 03 	jmp	0x71e	; 0x71e <_ZN8I2CAgent8transmitER7Command>
     2b6:	0c 94 81 22 	jmp	0x4502	; 0x4502 <_ZN9frt_queueIiE7ISR_getEPi>
     2ba:	0c 94 13 08 	jmp	0x1026	; 0x1026 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     2be:	0c 94 3d 22 	jmp	0x447a	; 0x447a <_ZN9frt_queueIiE3getEv>
     2c2:	0c 94 71 1d 	jmp	0x3ae2	; 0x3ae2 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2c6:	0c 94 da 22 	jmp	0x45b4	; 0x45b4 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     2ca:	0c 94 ed 1e 	jmp	0x3dda	; 0x3dda <_ZN5rs23212clear_screenEv>
     2ce:	0c 94 fa 04 	jmp	0x9f4	; 0x9f4 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     2d2:	0c 94 90 1e 	jmp	0x3d20	; 0x3d20 <_ZN5rs2327putcharEc>
     2d6:	0c 94 df 09 	jmp	0x13be	; 0x13be <_ZN10task_sonar3runEv>
     2da:	0c 94 8c 1d 	jmp	0x3b18	; 0x3b18 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2de:	0c 94 0d 1d 	jmp	0x3a1a	; 0x3a1a <_ZN8emstream12clear_screenEv>
     2e2:	0c 94 6b 1d 	jmp	0x3ad6	; 0x3ad6 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2e6:	0c 94 7a 21 	jmp	0x42f4	; 0x42f4 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     2ea:	0c 94 73 1d 	jmp	0x3ae6	; 0x3ae6 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2ee:	0c 94 1c 23 	jmp	0x4638	; 0x4638 <_ZN9frt_queueIjE3putERKj>
     2f2:	0c 94 5a 04 	jmp	0x8b4	; 0x8b4 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     2f6:	0c 94 4c 21 	jmp	0x4298	; 0x4298 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2fa:	0c 94 8d 1a 	jmp	0x351a	; 0x351a <_ZN14frt_text_queue7getcharEv>
     2fe:	0c 94 53 21 	jmp	0x42a6	; 0x42a6 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     302:	0c 94 44 08 	jmp	0x1088	; 0x1088 <_ZN9frt_queueIhE10get_a_copyERh>
     306:	0c 94 a4 03 	jmp	0x748	; 0x748 <_ZN8I2CAgent7receiveEv>
     30a:	0c 94 94 1d 	jmp	0x3b28	; 0x3b28 <_ZN8emstreamlsE15ser_manipulator+0x82>
     30e:	0c 94 84 21 	jmp	0x4308	; 0x4308 <_ZN9frt_queueIjE12num_items_inEv>
     312:	0c 94 40 23 	jmp	0x4680	; 0x4680 <_ZN9frt_queueIiE3putERKi>
     316:	0c 94 b4 1e 	jmp	0x3d68	; 0x3d68 <_ZN5rs2327getcharEv>
     31a:	0c 94 0c 1d 	jmp	0x3a18	; 0x3a18 <_ZN8emstream12transmit_nowEv>
     31e:	0c 94 07 1d 	jmp	0x3a0e	; 0x3a0e <_ZN8emstream7getcharEv>
     322:	0c 94 fe 04 	jmp	0x9fc	; 0x9fc <_ZN9I2CMaster10ErrorState11serialDebugEv>
     326:	0c 94 32 03 	jmp	0x664	; 0x664 <_call_static_run_method>
     32a:	0c 94 68 21 	jmp	0x42d0	; 0x42d0 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     32e:	0c 94 05 1d 	jmp	0x3a0a	; 0x3a0a <_ZN8emstream13ready_to_sendEv>
     332:	0c 94 8b 04 	jmp	0x916	; 0x916 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     336:	0c 94 c2 22 	jmp	0x4584	; 0x4584 <_ZN9frt_queueIjE7ISR_putERKj>
     33a:	0c 94 6f 21 	jmp	0x42de	; 0x42de <_ZN9frt_queueIiE13ISR_not_emptyEv>
     33e:	0c 94 2f 08 	jmp	0x105e	; 0x105e <_ZN9frt_queueIhE9not_emptyEv>
     342:	0c 94 da 1e 	jmp	0x3db4	; 0x3db4 <_ZN5rs23214check_for_charEv>
     346:	0c 94 ff 07 	jmp	0xffe	; 0xffe <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     34a:	0c 94 16 22 	jmp	0x442c	; 0x442c <_ZN9frt_queueIiE10get_a_copyEv>
     34e:	0c 94 58 22 	jmp	0x44b0	; 0x44b0 <_ZN9frt_queueIjE7ISR_getEPj>
     352:	0c 94 67 05 	jmp	0xace	; 0xace <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     356:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_ZN8I2CAgent10readPacketEv>
     35a:	0c 94 e3 21 	jmp	0x43c6	; 0x43c6 <_ZN9frt_queueIjE3getEPj>
     35e:	0c 94 7d 0b 	jmp	0x16fa	; 0x16fa <_ZN9task_user3runEv>
     362:	0c 94 a6 05 	jmp	0xb4c	; 0xb4c <_ZN9I2CMaster10StartState11serialDebugEv>
     366:	0c 94 6e 1d 	jmp	0x3adc	; 0x3adc <_ZN8emstreamlsE15ser_manipulator+0x36>
     36a:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     36e:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <_ZN9frt_queueIhE3getEv>
     372:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <_ZN9frt_queueIhE8is_emptyEv>
     376:	0c 94 f6 04 	jmp	0x9ec	; 0x9ec <_ZN9I2CMaster9DoneState7executeER6Packet>
     37a:	0c 94 eb 23 	jmp	0x47d6	; 0x47d6 <_GLOBAL__sub_I_counter>
     37e:	0c 94 13 05 	jmp	0xa26	; 0xa26 <_ZN9I2CMaster9DoneState11serialDebugEv>
     382:	0c 94 9d 08 	jmp	0x113a	; 0x113a <_ZN9frt_queueIhE7ISR_getEv>
     386:	0c 94 28 08 	jmp	0x1050	; 0x1050 <_ZN9frt_queueIhE12num_items_inEv>
     38a:	0c 94 92 22 	jmp	0x4524	; 0x4524 <_ZN9frt_queueIiE7ISR_getEv>
     38e:	0c 94 bb 05 	jmp	0xb76	; 0xb76 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     392:	0c 94 8b 21 	jmp	0x4316	; 0x4316 <_ZN9frt_queueIjE9not_emptyEv>
     396:	0c 94 68 08 	jmp	0x10d0	; 0x10d0 <_ZN9frt_queueIhE3getEPh>
     39a:	0c 94 b4 08 	jmp	0x1168	; 0x1168 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     39e:	0c 94 78 03 	jmp	0x6f0	; 0x6f0 <_ZN8I2CAgent11resetPacketER6Packet>
     3a2:	0c 94 0a 23 	jmp	0x4614	; 0x4614 <_ZN9frt_queueIjE7butt_inERKj>
     3a6:	0c 94 96 1d 	jmp	0x3b2c	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>

000003aa <__trampolines_end>:
     3aa:	53 6f       	ori	r21, 0xF3	; 243
     3ac:	6e 61       	ori	r22, 0x1E	; 30
     3ae:	72 3a       	cpi	r23, 0xA2	; 162
     3b0:	20 00       	.word	0x0020	; ????

000003b2 <_ZZN9task_user11show_statusEvE3__c_4>:
     3b2:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

000003bd <_ZZN9task_user11show_statusEvE3__c_3>:
     3bd:	2f 00                                               /.

000003bf <_ZZN9task_user11show_statusEvE3__c_2>:
     3bf:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003cd <_ZZN9task_user11show_statusEvE3__c_1>:
     3cd:	54 69 6d 65 3a 20 00                                Time: .

000003d4 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d4:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

000003e0 <_ZZN9task_user11show_statusEvE3__c>:
     3e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003ff <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3ff:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000040e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     40e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     41e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000429 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     429:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     439:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000447 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     447:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     457:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     467:	6d 61 74 69 6f 6e 00                                mation.

0000046e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     46e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     47e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000048f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     48f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     49f:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004a7 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4a7:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4b7:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c3 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c3:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d3:	68 65 20 41 56 52 00                                he AVR.

000004da <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4da:	20 68 65 6c 70 00                                    help.

000004e0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004ff <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4ff:	1b 5b 33 30 6d 00                                   .[30m.

00000505 <_ZZN9task_user18print_help_messageEvE3__c>:
     505:	1b 5b 34 36 6d 00                                   .[46m.

0000050b <_ZZN9task_user3runEvE3__c_3>:
     50b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000528 <_ZZN9task_user3runEvE3__c_2>:
     528:	3a 57 54 46 3f 00                                   :WTF?.

0000052e <_ZZN9task_user3runEvE3__c_1>:
     52e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     53e:	65 00                                               e.

00000540 <_ZZN9task_user3runEvE3__c_0>:
     540:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000054e <_ZZN9task_user3runEvE3__c>:
     54e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     55e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000056c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     56c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000576 <_ZZN8frt_task15emergency_resetEvE3__c>:
     576:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000585 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     585:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     595:	61 73 6b 20 00                                      ask .

0000059a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005a8 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5a8:	20 63 72 65 61 74 65 64 00                           created.

000005b1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b1:	54 61 73 6b 20 00                                   Task .

000005b7 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5b7:	1b 5b 32 32 6d 00                                   .[22m.

000005bd <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5bd:	54 61 73 6b 3a 20 00                                Task: .

000005c4 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c4:	1b 5b 31 6d 00                                      .[1m.

000005c9 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5c9:	1b 5b 32 32 6d 00                                   .[22m.

000005cf <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5cf:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005da <_ZZ17print_task_stacksP8emstreamE3__c>:
     5da:	1b 5b 31 6d 00                                      .[1m.

000005df <_ZZ15print_task_listP8emstreamE3__c_9>:
     5df:	09 09 00                                            ...

000005e2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e2:	2f 00                                               /.

000005e4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005ef <_ZZ15print_task_listP8emstreamE3__c_6>:
     5ef:	09 2d 2d 2d 2d 00                                   .----.

000005f5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000601 <_ZZ15print_task_listP8emstreamE3__c_4>:
     601:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000612 <_ZZ15print_task_listP8emstreamE3__c_3>:
     612:	09 52 75 6e 73 00                                   .Runs.

00000618 <_ZZ15print_task_listP8emstreamE3__c_2>:
     618:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000624 <_ZZ15print_task_listP8emstreamE3__c_1>:
     624:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000635 <_ZZ15print_task_listP8emstreamE3__c_0>:
     635:	09 53 74 61 63 6b 00                                .Stack.

0000063c <_ZZ15print_task_listP8emstreamE3__c>:
     63c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000647 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     647:	09 00                                               ..

00000649 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     649:	09 00                                               ..

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64b:	2f 00                                               /.

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     64f:	09 00                                               ..

00000651 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     651:	1b 5b 32 32 6d 00                                   .[22m.

00000657 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     657:	1b 5b 31 6d 00                                      .[1m.

0000065c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     65c:	1b 5b 31 6d 00                                      .[1m.

00000661 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     661:	20 20 00                                              .

00000664 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     664:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <_ZN8frt_task22_call_users_run_methodEPS_>

00000668 <__ctors_start>:
     668:	eb 23       	and	r30, r27

0000066a <__ctors_end>:
     66a:	11 24       	eor	r1, r1
     66c:	1f be       	out	0x3f, r1	; 63
     66e:	cf ef       	ldi	r28, 0xFF	; 255
     670:	cd bf       	out	0x3d, r28	; 61
     672:	df e3       	ldi	r29, 0x3F	; 63
     674:	de bf       	out	0x3e, r29	; 62
     676:	00 e0       	ldi	r16, 0x00	; 0
     678:	0c bf       	out	0x3c, r16	; 60
     67a:	18 be       	out	0x38, r1	; 56
     67c:	19 be       	out	0x39, r1	; 57
     67e:	1a be       	out	0x3a, r1	; 58
     680:	1b be       	out	0x3b, r1	; 59

00000682 <__do_copy_data>:
     682:	11 e2       	ldi	r17, 0x21	; 33
     684:	a0 e0       	ldi	r26, 0x00	; 0
     686:	b0 e2       	ldi	r27, 0x20	; 32
     688:	ee eb       	ldi	r30, 0xBE	; 190
     68a:	fa e4       	ldi	r31, 0x4A	; 74
     68c:	00 e0       	ldi	r16, 0x00	; 0
     68e:	0b bf       	out	0x3b, r16	; 59
     690:	02 c0       	rjmp	.+4      	; 0x696 <__do_copy_data+0x14>
     692:	07 90       	elpm	r0, Z+
     694:	0d 92       	st	X+, r0
     696:	a6 3c       	cpi	r26, 0xC6	; 198
     698:	b1 07       	cpc	r27, r17
     69a:	d9 f7       	brne	.-10     	; 0x692 <__do_copy_data+0x10>
     69c:	1b be       	out	0x3b, r1	; 59

0000069e <__do_clear_bss>:
     69e:	22 e3       	ldi	r18, 0x32	; 50
     6a0:	a6 ec       	ldi	r26, 0xC6	; 198
     6a2:	b1 e2       	ldi	r27, 0x21	; 33
     6a4:	01 c0       	rjmp	.+2      	; 0x6a8 <.do_clear_bss_start>

000006a6 <.do_clear_bss_loop>:
     6a6:	1d 92       	st	X+, r1

000006a8 <.do_clear_bss_start>:
     6a8:	a4 39       	cpi	r26, 0x94	; 148
     6aa:	b2 07       	cpc	r27, r18
     6ac:	e1 f7       	brne	.-8      	; 0x6a6 <.do_clear_bss_loop>

000006ae <__do_global_ctors>:
     6ae:	13 e0       	ldi	r17, 0x03	; 3
     6b0:	c5 e3       	ldi	r28, 0x35	; 53
     6b2:	d3 e0       	ldi	r29, 0x03	; 3
     6b4:	00 e0       	ldi	r16, 0x00	; 0
     6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <__do_global_ctors+0x16>
     6b8:	21 97       	sbiw	r28, 0x01	; 1
     6ba:	01 09       	sbc	r16, r1
     6bc:	80 2f       	mov	r24, r16
     6be:	fe 01       	movw	r30, r28
     6c0:	0e 94 b9 24 	call	0x4972	; 0x4972 <__tablejump2__>
     6c4:	c4 33       	cpi	r28, 0x34	; 52
     6c6:	d1 07       	cpc	r29, r17
     6c8:	80 e0       	ldi	r24, 0x00	; 0
     6ca:	08 07       	cpc	r16, r24
     6cc:	a9 f7       	brne	.-22     	; 0x6b8 <__do_global_ctors+0xa>
     6ce:	0e 94 67 23 	call	0x46ce	; 0x46ce <main>
     6d2:	0c 94 5d 25 	jmp	0x4aba	; 0x4aba <_exit>

000006d6 <__bad_interrupt>:
     6d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006da <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6da:	bc 01       	movw	r22, r24
     6dc:	6e 5f       	subi	r22, 0xFE	; 254
     6de:	7f 4f       	sbci	r23, 0xFF	; 255
     6e0:	dc 01       	movw	r26, r24
     6e2:	ed 91       	ld	r30, X+
     6e4:	fc 91       	ld	r31, X
     6e6:	00 84       	ldd	r0, Z+8	; 0x08
     6e8:	f1 85       	ldd	r31, Z+9	; 0x09
     6ea:	e0 2d       	mov	r30, r0
     6ec:	19 95       	eicall
     6ee:	08 95       	ret

000006f0 <_ZN8I2CAgent11resetPacketER6Packet>:
}

void I2CAgent::resetPacket( Packet & packet )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	eb 01       	movw	r28, r22
  while( packet.not_empty() )
     6f6:	e8 81       	ld	r30, Y
     6f8:	f9 81       	ldd	r31, Y+1	; 0x01
     6fa:	00 8c       	ldd	r0, Z+24	; 0x18
     6fc:	f1 8d       	ldd	r31, Z+25	; 0x19
     6fe:	e0 2d       	mov	r30, r0
     700:	ce 01       	movw	r24, r28
     702:	19 95       	eicall
     704:	88 23       	and	r24, r24
     706:	41 f0       	breq	.+16     	; 0x718 <_ZN8I2CAgent11resetPacketER6Packet+0x28>
  {
    packet.get();
     708:	e8 81       	ld	r30, Y
     70a:	f9 81       	ldd	r31, Y+1	; 0x01
     70c:	00 84       	ldd	r0, Z+8	; 0x08
     70e:	f1 85       	ldd	r31, Z+9	; 0x09
     710:	e0 2d       	mov	r30, r0
     712:	ce 01       	movw	r24, r28
     714:	19 95       	eicall
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
  while( packet.not_empty() )
     716:	ef cf       	rjmp	.-34     	; 0x6f6 <_ZN8I2CAgent11resetPacketER6Packet+0x6>
  {
    packet.get();
  }
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	08 95       	ret

0000071e <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	ec 01       	movw	r28, r24
  writePacket(cmd);
     724:	e8 81       	ld	r30, Y
     726:	f9 81       	ldd	r31, Y+1	; 0x01
     728:	04 80       	ldd	r0, Z+4	; 0x04
     72a:	f5 81       	ldd	r31, Z+5	; 0x05
     72c:	e0 2d       	mov	r30, r0
     72e:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     730:	be 01       	movw	r22, r28
     732:	63 5f       	subi	r22, 0xF3	; 243
     734:	7f 4f       	sbci	r23, 0xFF	; 255
  };
  
  I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     736:	e8 8d       	ldd	r30, Y+24	; 0x18
     738:	f9 8d       	ldd	r31, Y+25	; 0x19
     73a:	80 81       	ld	r24, Z
     73c:	91 81       	ldd	r25, Z+1	; 0x01
     73e:	0e 94 09 07 	call	0xe12	; 0xe12 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     742:	df 91       	pop	r29
     744:	cf 91       	pop	r28
     746:	08 95       	ret

00000748 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     748:	ef 92       	push	r14
     74a:	ff 92       	push	r15
     74c:	0f 93       	push	r16
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     754:	7c 01       	movw	r14, r24
     756:	82 e0       	ldi	r24, 0x02	; 2
     758:	e8 0e       	add	r14, r24
     75a:	f1 1c       	adc	r15, r1
     75c:	e8 81       	ld	r30, Y
     75e:	f9 81       	ldd	r31, Y+1	; 0x01
     760:	00 84       	ldd	r0, Z+8	; 0x08
     762:	f1 85       	ldd	r31, Z+9	; 0x09
     764:	e0 2d       	mov	r30, r0
     766:	b7 01       	movw	r22, r14
     768:	ce 01       	movw	r24, r28
     76a:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     76c:	28 85       	ldd	r18, Y+8	; 0x08
     76e:	39 85       	ldd	r19, Y+9	; 0x09
     770:	4a 85       	ldd	r20, Y+10	; 0x0a
     772:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     774:	be 01       	movw	r22, r28
     776:	64 5e       	subi	r22, 0xE4	; 228
     778:	7f 4f       	sbci	r23, 0xFF	; 255
     77a:	00 e0       	ldi	r16, 0x00	; 0
     77c:	8e 81       	ldd	r24, Y+6	; 0x06
     77e:	9f 81       	ldd	r25, Y+7	; 0x07
     780:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     784:	e8 8d       	ldd	r30, Y+24	; 0x18
     786:	f9 8d       	ldd	r31, Y+25	; 0x19
  return driver_->getReceiver()->run(inPacket_);
     788:	b7 01       	movw	r22, r14
     78a:	82 81       	ldd	r24, Z+2	; 0x02
     78c:	93 81       	ldd	r25, Z+3	; 0x03
     78e:	0e 94 4e 07 	call	0xe9c	; 0xe9c <_ZN9I2CMaster8Receiver3runER6Packet>
}
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	0f 91       	pop	r16
     798:	ff 90       	pop	r15
     79a:	ef 90       	pop	r14
     79c:	08 95       	ret

0000079e <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     79e:	cf 92       	push	r12
     7a0:	df 92       	push	r13
     7a2:	ef 92       	push	r14
     7a4:	ff 92       	push	r15
     7a6:	0f 93       	push	r16
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	ec 01       	movw	r28, r24
     7ae:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     7b0:	6c 01       	movw	r12, r24
     7b2:	8d e0       	ldi	r24, 0x0D	; 13
     7b4:	c8 0e       	add	r12, r24
     7b6:	d1 1c       	adc	r13, r1
     7b8:	e8 81       	ld	r30, Y
     7ba:	f9 81       	ldd	r31, Y+1	; 0x01
     7bc:	00 84       	ldd	r0, Z+8	; 0x08
     7be:	f1 85       	ldd	r31, Z+9	; 0x09
     7c0:	e0 2d       	mov	r30, r0
     7c2:	b6 01       	movw	r22, r12
     7c4:	ce 01       	movw	r24, r28
     7c6:	19 95       	eicall
     7c8:	2b 89       	ldd	r18, Y+19	; 0x13
     7ca:	3c 89       	ldd	r19, Y+20	; 0x14
     7cc:	4d 89       	ldd	r20, Y+21	; 0x15
     7ce:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7d0:	be 01       	movw	r22, r28
     7d2:	65 5e       	subi	r22, 0xE5	; 229
     7d4:	7f 4f       	sbci	r23, 0xFF	; 255
     7d6:	00 e0       	ldi	r16, 0x00	; 0
     7d8:	89 89       	ldd	r24, Y+17	; 0x11
     7da:	9a 89       	ldd	r25, Y+18	; 0x12
     7dc:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7e0:	d7 01       	movw	r26, r14
     7e2:	ed 91       	ld	r30, X+
     7e4:	fc 91       	ld	r31, X
     7e6:	01 90       	ld	r0, Z+
     7e8:	f0 81       	ld	r31, Z
     7ea:	e0 2d       	mov	r30, r0
     7ec:	b6 01       	movw	r22, r12
     7ee:	c7 01       	movw	r24, r14
     7f0:	19 95       	eicall
}
     7f2:	df 91       	pop	r29
     7f4:	cf 91       	pop	r28
     7f6:	0f 91       	pop	r16
     7f8:	ff 90       	pop	r15
     7fa:	ef 90       	pop	r14
     7fc:	df 90       	pop	r13
     7fe:	cf 90       	pop	r12
     800:	08 95       	ret

00000802 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     802:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     804:	62 8f       	std	Z+26, r22	; 0x1a
  writeCommand_ = addr << 1;
     806:	86 2f       	mov	r24, r22
     808:	88 0f       	add	r24, r24
     80a:	83 8f       	std	Z+27, r24	; 0x1b
  readCommand_ = addr << 1 | 1 << 0;
     80c:	68 2f       	mov	r22, r24
     80e:	61 60       	ori	r22, 0x01	; 1
     810:	64 8f       	std	Z+28, r22	; 0x1c
     812:	08 95       	ret

00000814 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     814:	0f 93       	push	r16
     816:	1f 93       	push	r17
     818:	cf 93       	push	r28
     81a:	df 93       	push	r29
     81c:	ec 01       	movw	r28, r24
     81e:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
     820:	db 01       	movw	r26, r22
     822:	ed 91       	ld	r30, X+
     824:	fc 91       	ld	r31, X
     826:	02 84       	ldd	r0, Z+10	; 0x0a
     828:	f3 85       	ldd	r31, Z+11	; 0x0b
     82a:	e0 2d       	mov	r30, r0
     82c:	00 e0       	ldi	r16, 0x00	; 0
     82e:	10 e0       	ldi	r17, 0x00	; 0
     830:	b8 01       	movw	r22, r16
     832:	19 95       	eicall
  TWI_t *       getInterfacePtr() { return interface_; }
     834:	ef 81       	ldd	r30, Y+7	; 0x07
     836:	f8 85       	ldd	r31, Y+8	; 0x08
     838:	04 80       	ldd	r0, Z+4	; 0x04
     83a:	f5 81       	ldd	r31, Z+5	; 0x05
     83c:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
     83e:	d8 01       	movw	r26, r16
     840:	8c 91       	ld	r24, X
     842:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
     844:	8a 81       	ldd	r24, Y+2	; 0x02
     846:	9b 81       	ldd	r25, Y+3	; 0x03
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::StatusState::execute( Packet & packet )
{
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	1f 92       	push	r1
     858:	1f 92       	push	r1
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     860:	19 96       	adiw	r26, 0x09	; 9
     862:	8d 91       	ld	r24, X+
     864:	9c 91       	ld	r25, X
     866:	1a 97       	sbiw	r26, 0x0a	; 10
     868:	89 83       	std	Y+1, r24	; 0x01
     86a:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_WIF_bm)) ){ }
     86c:	29 81       	ldd	r18, Y+1	; 0x01
     86e:	3a 81       	ldd	r19, Y+2	; 0x02
     870:	21 50       	subi	r18, 0x01	; 1
     872:	31 09       	sbc	r19, r1
     874:	29 83       	std	Y+1, r18	; 0x01
     876:	3a 83       	std	Y+2, r19	; 0x02
     878:	23 2b       	or	r18, r19
     87a:	51 f0       	breq	.+20     	; 0x890 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3e>
     87c:	17 96       	adiw	r26, 0x07	; 7
     87e:	ed 91       	ld	r30, X+
     880:	fc 91       	ld	r31, X
     882:	18 97       	sbiw	r26, 0x08	; 8
     884:	04 80       	ldd	r0, Z+4	; 0x04
     886:	f5 81       	ldd	r31, Z+5	; 0x05
     888:	e0 2d       	mov	r30, r0
     88a:	94 81       	ldd	r25, Z+4	; 0x04
     88c:	90 75       	andi	r25, 0x50	; 80
     88e:	71 f7       	brne	.-36     	; 0x86c <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
  if( counter == 0 )
     890:	89 81       	ldd	r24, Y+1	; 0x01
     892:	9a 81       	ldd	r25, Y+2	; 0x02
     894:	89 2b       	or	r24, r25
     896:	29 f4       	brne	.+10     	; 0x8a2 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x50>
  {
    return returnState_;
     898:	14 96       	adiw	r26, 0x04	; 4
     89a:	8d 91       	ld	r24, X+
     89c:	9c 91       	ld	r25, X
     89e:	15 97       	sbiw	r26, 0x05	; 5
     8a0:	04 c0       	rjmp	.+8      	; 0x8aa <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
  }
  else
  {
    return nextState_;
     8a2:	12 96       	adiw	r26, 0x02	; 2
     8a4:	8d 91       	ld	r24, X+
     8a6:	9c 91       	ld	r25, X
     8a8:	13 97       	sbiw	r26, 0x03	; 3
  }
}
     8aa:	0f 90       	pop	r0
     8ac:	0f 90       	pop	r0
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	08 95       	ret

000008b4 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::StatusState::execute( Packet & packet )
{
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	1f 92       	push	r1
     8ba:	1f 92       	push	r1
     8bc:	cd b7       	in	r28, 0x3d	; 61
     8be:	de b7       	in	r29, 0x3e	; 62
     8c0:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     8c2:	19 96       	adiw	r26, 0x09	; 9
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	1a 97       	sbiw	r26, 0x0a	; 10
     8ca:	89 83       	std	Y+1, r24	; 0x01
     8cc:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_RIF_bm)) ){ }
     8ce:	29 81       	ldd	r18, Y+1	; 0x01
     8d0:	3a 81       	ldd	r19, Y+2	; 0x02
     8d2:	21 50       	subi	r18, 0x01	; 1
     8d4:	31 09       	sbc	r19, r1
     8d6:	29 83       	std	Y+1, r18	; 0x01
     8d8:	3a 83       	std	Y+2, r19	; 0x02
     8da:	23 2b       	or	r18, r19
     8dc:	51 f0       	breq	.+20     	; 0x8f2 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x3e>
     8de:	17 96       	adiw	r26, 0x07	; 7
     8e0:	ed 91       	ld	r30, X+
     8e2:	fc 91       	ld	r31, X
     8e4:	18 97       	sbiw	r26, 0x08	; 8
     8e6:	04 80       	ldd	r0, Z+4	; 0x04
     8e8:	f5 81       	ldd	r31, Z+5	; 0x05
     8ea:	e0 2d       	mov	r30, r0
     8ec:	94 81       	ldd	r25, Z+4	; 0x04
     8ee:	90 79       	andi	r25, 0x90	; 144
     8f0:	71 f7       	brne	.-36     	; 0x8ce <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x1a>
  if( counter == 0 ) {
     8f2:	89 81       	ldd	r24, Y+1	; 0x01
     8f4:	9a 81       	ldd	r25, Y+2	; 0x02
     8f6:	89 2b       	or	r24, r25
     8f8:	29 f4       	brne	.+10     	; 0x904 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x50>
    return returnState_; }
     8fa:	14 96       	adiw	r26, 0x04	; 4
     8fc:	8d 91       	ld	r24, X+
     8fe:	9c 91       	ld	r25, X
     900:	15 97       	sbiw	r26, 0x05	; 5
     902:	04 c0       	rjmp	.+8      	; 0x90c <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x58>
  else {
    return nextState_; }
     904:	12 96       	adiw	r26, 0x02	; 2
     906:	8d 91       	ld	r24, X+
     908:	9c 91       	ld	r25, X
     90a:	13 97       	sbiw	r26, 0x03	; 3
}
     90c:	0f 90       	pop	r0
     90e:	0f 90       	pop	r0
     910:	df 91       	pop	r29
     912:	cf 91       	pop	r28
     914:	08 95       	ret

00000916 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::ExchangeState::execute( Packet & packet )
{
     916:	ef 92       	push	r14
     918:	ff 92       	push	r15
     91a:	0f 93       	push	r16
     91c:	1f 93       	push	r17
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29
     922:	8c 01       	movw	r16, r24
     924:	eb 01       	movw	r28, r22
  if( packet.not_empty() )
     926:	e8 81       	ld	r30, Y
     928:	f9 81       	ldd	r31, Y+1	; 0x01
     92a:	00 8c       	ldd	r0, Z+24	; 0x18
     92c:	f1 8d       	ldd	r31, Z+25	; 0x19
     92e:	e0 2d       	mov	r30, r0
     930:	cb 01       	movw	r24, r22
     932:	19 95       	eicall
     934:	88 23       	and	r24, r24
     936:	a9 f0       	breq	.+42     	; 0x962 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
  {
    uint8_t * data; 
    packet.get(data);
     938:	e8 81       	ld	r30, Y
     93a:	f9 81       	ldd	r31, Y+1	; 0x01
     93c:	02 84       	ldd	r0, Z+10	; 0x0a
     93e:	f3 85       	ldd	r31, Z+11	; 0x0b
     940:	e0 2d       	mov	r30, r0
     942:	e1 2c       	mov	r14, r1
     944:	f1 2c       	mov	r15, r1
     946:	b7 01       	movw	r22, r14
     948:	ce 01       	movw	r24, r28
     94a:	19 95       	eicall
     94c:	d8 01       	movw	r26, r16
     94e:	17 96       	adiw	r26, 0x07	; 7
     950:	ed 91       	ld	r30, X+
     952:	fc 91       	ld	r31, X
     954:	18 97       	sbiw	r26, 0x08	; 8
     956:	04 80       	ldd	r0, Z+4	; 0x04
     958:	f5 81       	ldd	r31, Z+5	; 0x05
     95a:	e0 2d       	mov	r30, r0
    driver_->getInterfacePtr()->MASTER.DATA = *data;
     95c:	d7 01       	movw	r26, r14
     95e:	8c 91       	ld	r24, X
     960:	87 83       	std	Z+7, r24	; 0x07
  }
  return nextState_;
}
     962:	f8 01       	movw	r30, r16
     964:	82 81       	ldd	r24, Z+2	; 0x02
     966:	93 81       	ldd	r25, Z+3	; 0x03
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	1f 91       	pop	r17
     96e:	0f 91       	pop	r16
     970:	ff 90       	pop	r15
     972:	ef 90       	pop	r14
     974:	08 95       	ret

00000976 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::ExchangeState::execute( Packet & packet )
{
     976:	0f 93       	push	r16
     978:	1f 93       	push	r17
     97a:	cf 93       	push	r28
     97c:	df 93       	push	r29
     97e:	1f 92       	push	r1
     980:	cd b7       	in	r28, 0x3d	; 61
     982:	de b7       	in	r29, 0x3e	; 62
     984:	8c 01       	movw	r16, r24
     986:	cb 01       	movw	r24, r22
     988:	d8 01       	movw	r26, r16
     98a:	17 96       	adiw	r26, 0x07	; 7
     98c:	ed 91       	ld	r30, X+
     98e:	fc 91       	ld	r31, X
     990:	18 97       	sbiw	r26, 0x08	; 8
     992:	04 80       	ldd	r0, Z+4	; 0x04
     994:	f5 81       	ldd	r31, Z+5	; 0x05
     996:	e0 2d       	mov	r30, r0
  uint8_t data = driver_->getInterfacePtr()->MASTER.DATA;
     998:	27 81       	ldd	r18, Z+7	; 0x07
     99a:	29 83       	std	Y+1, r18	; 0x01
  packet.put(data);
     99c:	db 01       	movw	r26, r22
     99e:	ed 91       	ld	r30, X+
     9a0:	fc 91       	ld	r31, X
     9a2:	01 90       	ld	r0, Z+
     9a4:	f0 81       	ld	r31, Z
     9a6:	e0 2d       	mov	r30, r0
     9a8:	be 01       	movw	r22, r28
     9aa:	6f 5f       	subi	r22, 0xFF	; 255
     9ac:	7f 4f       	sbci	r23, 0xFF	; 255
     9ae:	19 95       	eicall
  return nextState_;
}
     9b0:	f8 01       	movw	r30, r16
     9b2:	82 81       	ldd	r24, Z+2	; 0x02
     9b4:	93 81       	ldd	r25, Z+3	; 0x03
     9b6:	0f 90       	pop	r0
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	08 95       	ret

000009c2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::PacketStatusState::execute( Packet & packet )
{
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	ec 01       	movw	r28, r24
     9c8:	cb 01       	movw	r24, r22
  if( packet.is_empty() )
     9ca:	db 01       	movw	r26, r22
     9cc:	ed 91       	ld	r30, X+
     9ce:	fc 91       	ld	r31, X
     9d0:	04 88       	ldd	r0, Z+20	; 0x14
     9d2:	f5 89       	ldd	r31, Z+21	; 0x15
     9d4:	e0 2d       	mov	r30, r0
     9d6:	19 95       	eicall
     9d8:	88 23       	and	r24, r24
     9da:	19 f0       	breq	.+6      	; 0x9e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
  {
    return nextState_;
     9dc:	8a 81       	ldd	r24, Y+2	; 0x02
     9de:	9b 81       	ldd	r25, Y+3	; 0x03
     9e0:	02 c0       	rjmp	.+4      	; 0x9e6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
  }
  else
  {
    return returnState_;
     9e2:	8c 81       	ldd	r24, Y+4	; 0x04
     9e4:	9d 81       	ldd	r25, Y+5	; 0x05
  }
}
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	08 95       	ret

000009ec <_ZN9I2CMaster9DoneState7executeER6Packet>:
}

I2CMaster::State * I2CMaster::DoneState::execute( Packet & packet )
{
  return nextState_;
}
     9ec:	fc 01       	movw	r30, r24
     9ee:	82 81       	ldd	r24, Z+2	; 0x02
     9f0:	93 81       	ldd	r25, Z+3	; 0x03
     9f2:	08 95       	ret

000009f4 <_ZN9I2CMaster10ErrorState7executeER6Packet>:

I2CMaster::State * I2CMaster::ErrorState::execute( Packet & packet )
{
  return nextState_;
}
     9f4:	fc 01       	movw	r30, r24
     9f6:	82 81       	ldd	r24, Z+2	; 0x02
     9f8:	93 81       	ldd	r25, Z+3	; 0x03
     9fa:	08 95       	ret

000009fc <_ZN9I2CMaster10ErrorState11serialDebugEv>:
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "error" << endl; }
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     a00:	dc 01       	movw	r26, r24
     a02:	17 96       	adiw	r26, 0x07	; 7
     a04:	ed 91       	ld	r30, X+
     a06:	fc 91       	ld	r31, X
     a08:	18 97       	sbiw	r26, 0x08	; 8
     a0a:	c6 81       	ldd	r28, Z+6	; 0x06
     a0c:	d7 81       	ldd	r29, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     a0e:	64 e1       	ldi	r22, 0x14	; 20
     a10:	70 e2       	ldi	r23, 0x20	; 32
     a12:	ce 01       	movw	r24, r28
     a14:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "error" << endl; }
     a18:	66 e0       	ldi	r22, 0x06	; 6
     a1a:	ce 01       	movw	r24, r28
     a1c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <_ZN9I2CMaster9DoneState11serialDebugEv>:
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "done" << endl; }
     a26:	cf 93       	push	r28
     a28:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     a2a:	dc 01       	movw	r26, r24
     a2c:	17 96       	adiw	r26, 0x07	; 7
     a2e:	ed 91       	ld	r30, X+
     a30:	fc 91       	ld	r31, X
     a32:	18 97       	sbiw	r26, 0x08	; 8
     a34:	c6 81       	ldd	r28, Z+6	; 0x06
     a36:	d7 81       	ldd	r29, Z+7	; 0x07
     a38:	6a e1       	ldi	r22, 0x1A	; 26
     a3a:	70 e2       	ldi	r23, 0x20	; 32
     a3c:	ce 01       	movw	r24, r28
     a3e:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "done" << endl; }
     a42:	66 e0       	ldi	r22, 0x06	; 6
     a44:	ce 01       	movw	r24, r28
     a46:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     a4a:	df 91       	pop	r29
     a4c:	cf 91       	pop	r28
     a4e:	08 95       	ret

00000a50 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r packet" << endl; }
     a50:	cf 93       	push	r28
     a52:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     a54:	dc 01       	movw	r26, r24
     a56:	17 96       	adiw	r26, 0x07	; 7
     a58:	ed 91       	ld	r30, X+
     a5a:	fc 91       	ld	r31, X
     a5c:	18 97       	sbiw	r26, 0x08	; 8
     a5e:	c6 81       	ldd	r28, Z+6	; 0x06
     a60:	d7 81       	ldd	r29, Z+7	; 0x07
     a62:	6f e1       	ldi	r22, 0x1F	; 31
     a64:	70 e2       	ldi	r23, 0x20	; 32
     a66:	ce 01       	movw	r24, r28
     a68:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r packet" << endl; }
     a6c:	66 e0       	ldi	r22, 0x06	; 6
     a6e:	ce 01       	movw	r24, r28
     a70:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	08 95       	ret

00000a7a <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t packet" << endl; }
     a7a:	cf 93       	push	r28
     a7c:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     a7e:	dc 01       	movw	r26, r24
     a80:	17 96       	adiw	r26, 0x07	; 7
     a82:	ed 91       	ld	r30, X+
     a84:	fc 91       	ld	r31, X
     a86:	18 97       	sbiw	r26, 0x08	; 8
     a88:	c6 81       	ldd	r28, Z+6	; 0x06
     a8a:	d7 81       	ldd	r29, Z+7	; 0x07
     a8c:	68 e2       	ldi	r22, 0x28	; 40
     a8e:	70 e2       	ldi	r23, 0x20	; 32
     a90:	ce 01       	movw	r24, r28
     a92:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t packet" << endl; }
     a96:	66 e0       	ldi	r22, 0x06	; 6
     a98:	ce 01       	movw	r24, r28
     a9a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	08 95       	ret

00000aa4 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r exchange" << endl; }
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     aa8:	dc 01       	movw	r26, r24
     aaa:	17 96       	adiw	r26, 0x07	; 7
     aac:	ed 91       	ld	r30, X+
     aae:	fc 91       	ld	r31, X
     ab0:	18 97       	sbiw	r26, 0x08	; 8
     ab2:	c6 81       	ldd	r28, Z+6	; 0x06
     ab4:	d7 81       	ldd	r29, Z+7	; 0x07
     ab6:	61 e3       	ldi	r22, 0x31	; 49
     ab8:	70 e2       	ldi	r23, 0x20	; 32
     aba:	ce 01       	movw	r24, r28
     abc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r exchange" << endl; }
     ac0:	66 e0       	ldi	r22, 0x06	; 6
     ac2:	ce 01       	movw	r24, r28
     ac4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     ac8:	df 91       	pop	r29
     aca:	cf 91       	pop	r28
     acc:	08 95       	ret

00000ace <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t exchange" << endl; }
     ace:	cf 93       	push	r28
     ad0:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     ad2:	dc 01       	movw	r26, r24
     ad4:	17 96       	adiw	r26, 0x07	; 7
     ad6:	ed 91       	ld	r30, X+
     ad8:	fc 91       	ld	r31, X
     ada:	18 97       	sbiw	r26, 0x08	; 8
     adc:	c6 81       	ldd	r28, Z+6	; 0x06
     ade:	d7 81       	ldd	r29, Z+7	; 0x07
     ae0:	6c e3       	ldi	r22, 0x3C	; 60
     ae2:	70 e2       	ldi	r23, 0x20	; 32
     ae4:	ce 01       	movw	r24, r28
     ae6:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t exchange" << endl; }
     aea:	66 e0       	ldi	r22, 0x06	; 6
     aec:	ce 01       	movw	r24, r28
     aee:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     af2:	df 91       	pop	r29
     af4:	cf 91       	pop	r28
     af6:	08 95       	ret

00000af8 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r status" << endl; }
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     afc:	dc 01       	movw	r26, r24
     afe:	17 96       	adiw	r26, 0x07	; 7
     b00:	ed 91       	ld	r30, X+
     b02:	fc 91       	ld	r31, X
     b04:	18 97       	sbiw	r26, 0x08	; 8
     b06:	c6 81       	ldd	r28, Z+6	; 0x06
     b08:	d7 81       	ldd	r29, Z+7	; 0x07
     b0a:	67 e4       	ldi	r22, 0x47	; 71
     b0c:	70 e2       	ldi	r23, 0x20	; 32
     b0e:	ce 01       	movw	r24, r28
     b10:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "r status" << endl; }
     b14:	66 e0       	ldi	r22, 0x06	; 6
     b16:	ce 01       	movw	r24, r28
     b18:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     b1c:	df 91       	pop	r29
     b1e:	cf 91       	pop	r28
     b20:	08 95       	ret

00000b22 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t status" << endl; }
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     b26:	dc 01       	movw	r26, r24
     b28:	17 96       	adiw	r26, 0x07	; 7
     b2a:	ed 91       	ld	r30, X+
     b2c:	fc 91       	ld	r31, X
     b2e:	18 97       	sbiw	r26, 0x08	; 8
     b30:	c6 81       	ldd	r28, Z+6	; 0x06
     b32:	d7 81       	ldd	r29, Z+7	; 0x07
     b34:	60 e5       	ldi	r22, 0x50	; 80
     b36:	70 e2       	ldi	r23, 0x20	; 32
     b38:	ce 01       	movw	r24, r28
     b3a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
      { }
      State * execute( Packet & packet );
      void serialDebug() { driver_->getSerial() << "t status" << endl; }
     b3e:	66 e0       	ldi	r22, 0x06	; 6
     b40:	ce 01       	movw	r24, r28
     b42:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	08 95       	ret

00000b4c <_ZN9I2CMaster10StartState11serialDebugEv>:
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "start" << endl; }
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream &    getSerial()       { return *p_serial; }
     b50:	dc 01       	movw	r26, r24
     b52:	17 96       	adiw	r26, 0x07	; 7
     b54:	ed 91       	ld	r30, X+
     b56:	fc 91       	ld	r31, X
     b58:	18 97       	sbiw	r26, 0x08	; 8
     b5a:	c6 81       	ldd	r28, Z+6	; 0x06
     b5c:	d7 81       	ldd	r29, Z+7	; 0x07
     b5e:	69 e5       	ldi	r22, 0x59	; 89
     b60:	70 e2       	ldi	r23, 0x20	; 32
     b62:	ce 01       	movw	r24, r28
     b64:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
    { }
    State * execute( Packet & packet );
    void serialDebug() { driver_->getSerial() << "start" << endl; }
     b68:	66 e0       	ldi	r22, 0x06	; 6
     b6a:	ce 01       	movw	r24, r28
     b6c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
     b70:	df 91       	pop	r29
     b72:	cf 91       	pop	r28
     b74:	08 95       	ret

00000b76 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
    return returnState_;
  }
}

I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	8c 01       	movw	r16, r24
     b80:	eb 01       	movw	r28, r22
  if( packet.num_items_in() == packet.getSize() ) {
     b82:	e8 81       	ld	r30, Y
     b84:	f9 81       	ldd	r31, Y+1	; 0x01
     b86:	04 8c       	ldd	r0, Z+28	; 0x1c
     b88:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b8a:	e0 2d       	mov	r30, r0
     b8c:	cb 01       	movw	r24, r22
     b8e:	19 95       	eicall
     b90:	2a 85       	ldd	r18, Y+10	; 0x0a
     b92:	30 e0       	ldi	r19, 0x00	; 0
     b94:	82 17       	cp	r24, r18
     b96:	93 07       	cpc	r25, r19
     b98:	79 f4       	brne	.+30     	; 0xbb8 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
}

void I2CMaster::send_ack_stop(void)
{
  interface_->MASTER.CTRLC = (1<<TWI_MASTER_CMD1_bp) | (1<<TWI_MASTER_CMD0_bp);
     b9a:	d8 01       	movw	r26, r16
     b9c:	17 96       	adiw	r26, 0x07	; 7
     b9e:	ed 91       	ld	r30, X+
     ba0:	fc 91       	ld	r31, X
     ba2:	18 97       	sbiw	r26, 0x08	; 8
     ba4:	04 80       	ldd	r0, Z+4	; 0x04
     ba6:	f5 81       	ldd	r31, Z+5	; 0x05
     ba8:	e0 2d       	mov	r30, r0
     baa:	83 e0       	ldi	r24, 0x03	; 3
     bac:	83 83       	std	Z+3, r24	; 0x03

I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
  if( packet.num_items_in() == packet.getSize() ) {
    driver_->send_ack_stop();
    return nextState_; }
     bae:	12 96       	adiw	r26, 0x02	; 2
     bb0:	8d 91       	ld	r24, X+
     bb2:	9c 91       	ld	r25, X
     bb4:	13 97       	sbiw	r26, 0x03	; 3
     bb6:	0e c0       	rjmp	.+28     	; 0xbd4 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     bb8:	d8 01       	movw	r26, r16
     bba:	17 96       	adiw	r26, 0x07	; 7
     bbc:	ed 91       	ld	r30, X+
     bbe:	fc 91       	ld	r31, X
     bc0:	18 97       	sbiw	r26, 0x08	; 8
     bc2:	04 80       	ldd	r0, Z+4	; 0x04
     bc4:	f5 81       	ldd	r31, Z+5	; 0x05
     bc6:	e0 2d       	mov	r30, r0
     bc8:	82 e0       	ldi	r24, 0x02	; 2
     bca:	83 83       	std	Z+3, r24	; 0x03
  if( packet.num_items_in() == packet.getSize() ) {
    driver_->send_ack_stop();
    return nextState_; }
  else {
    driver_->byte_recv();
    return returnState_; }
     bcc:	14 96       	adiw	r26, 0x04	; 4
     bce:	8d 91       	ld	r24, X+
     bd0:	9c 91       	ld	r25, X
     bd2:	15 97       	sbiw	r26, 0x05	; 5
}
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	08 95       	ret

00000bde <_ZN9I2CMaster11TransmitterC1EPS_>:
  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
}

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
     bde:	0f 93       	push	r16
     be0:	1f 93       	push	r17
     be2:	cf 93       	push	r28
     be4:	df 93       	push	r29
     be6:	ec 01       	movw	r28, r24
     be8:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     bea:	68 83       	st	Y, r22
     bec:	79 83       	std	Y+1, r23	; 0x01
     bee:	89 e0       	ldi	r24, 0x09	; 9
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     bf6:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bf8:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     bfa:	83 e6       	ldi	r24, 0x63	; 99
     bfc:	90 e2       	ldi	r25, 0x20	; 32
     bfe:	80 83       	st	Z, r24
     c00:	91 83       	std	Z+1, r25	; 0x01
     c02:	07 83       	std	Z+7, r16	; 0x07
     c04:	10 87       	std	Z+8, r17	; 0x08
     c06:	ec 83       	std	Y+4, r30	; 0x04
     c08:	fd 83       	std	Y+5, r31	; 0x05
     c0a:	8b e0       	ldi	r24, 0x0B	; 11
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     c12:	fc 01       	movw	r30, r24

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     c14:	8b 89       	ldd	r24, Y+19	; 0x13
     c16:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c18:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     c1a:	2b e6       	ldi	r18, 0x6B	; 107
     c1c:	30 e2       	ldi	r19, 0x20	; 32
     c1e:	20 83       	st	Z, r18
     c20:	31 83       	std	Z+1, r19	; 0x01
     c22:	07 83       	std	Z+7, r16	; 0x07
     c24:	10 87       	std	Z+8, r17	; 0x08
     c26:	81 87       	std	Z+9, r24	; 0x09
     c28:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     c2a:	ee 83       	std	Y+6, r30	; 0x06
     c2c:	ff 83       	std	Y+7, r31	; 0x07
     c2e:	89 e0       	ldi	r24, 0x09	; 9
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     c36:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c38:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     c3a:	8b e7       	ldi	r24, 0x7B	; 123
     c3c:	90 e2       	ldi	r25, 0x20	; 32
     c3e:	80 83       	st	Z, r24
     c40:	91 83       	std	Z+1, r25	; 0x01
     c42:	07 83       	std	Z+7, r16	; 0x07
     c44:	10 87       	std	Z+8, r17	; 0x08
     c46:	e8 87       	std	Y+8, r30	; 0x08
     c48:	f9 87       	std	Y+9, r31	; 0x09
     c4a:	89 e0       	ldi	r24, 0x09	; 9
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     c52:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c54:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     c56:	8b e8       	ldi	r24, 0x8B	; 139
     c58:	90 e2       	ldi	r25, 0x20	; 32
     c5a:	80 83       	st	Z, r24
     c5c:	91 83       	std	Z+1, r25	; 0x01
     c5e:	07 83       	std	Z+7, r16	; 0x07
     c60:	10 87       	std	Z+8, r17	; 0x08
     c62:	ea 87       	std	Y+10, r30	; 0x0a
     c64:	fb 87       	std	Y+11, r31	; 0x0b
     c66:	89 e0       	ldi	r24, 0x09	; 9
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     c6e:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c70:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     c72:	83 ea       	ldi	r24, 0xA3	; 163
     c74:	90 e2       	ldi	r25, 0x20	; 32
     c76:	80 83       	st	Z, r24
     c78:	91 83       	std	Z+1, r25	; 0x01
     c7a:	07 83       	std	Z+7, r16	; 0x07
     c7c:	10 87       	std	Z+8, r17	; 0x08
     c7e:	ec 87       	std	Y+12, r30	; 0x0c
     c80:	fd 87       	std	Y+13, r31	; 0x0d
     c82:	89 e0       	ldi	r24, 0x09	; 9
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     c8a:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c8c:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     c8e:	8b e9       	ldi	r24, 0x9B	; 155
     c90:	90 e2       	ldi	r25, 0x20	; 32
     c92:	80 83       	st	Z, r24
     c94:	91 83       	std	Z+1, r25	; 0x01
     c96:	07 83       	std	Z+7, r16	; 0x07
     c98:	10 87       	std	Z+8, r17	; 0x08
     c9a:	ee 87       	std	Y+14, r30	; 0x0e
     c9c:	ff 87       	std	Y+15, r31	; 0x0f
     c9e:	80 e1       	ldi	r24, 0x10	; 16
     ca0:	97 e2       	ldi	r25, 0x27	; 39
     ca2:	8b 8b       	std	Y+19, r24	; 0x13
     ca4:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     ca6:	8e 81       	ldd	r24, Y+6	; 0x06
     ca8:	9f 81       	ldd	r25, Y+7	; 0x07
     caa:	ec 81       	ldd	r30, Y+4	; 0x04
     cac:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     cae:	82 83       	std	Z+2, r24	; 0x02
     cb0:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     cb2:	84 83       	std	Z+4, r24	; 0x04
     cb4:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     cb6:	8c 85       	ldd	r24, Y+12	; 0x0c
     cb8:	9d 85       	ldd	r25, Y+13	; 0x0d
     cba:	28 85       	ldd	r18, Y+8	; 0x08
     cbc:	39 85       	ldd	r19, Y+9	; 0x09
     cbe:	ee 81       	ldd	r30, Y+6	; 0x06
     cc0:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     cc2:	22 83       	std	Z+2, r18	; 0x02
     cc4:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     cc6:	84 83       	std	Z+4, r24	; 0x04
     cc8:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     cca:	8a 85       	ldd	r24, Y+10	; 0x0a
     ccc:	9b 85       	ldd	r25, Y+11	; 0x0b
     cce:	e8 85       	ldd	r30, Y+8	; 0x08
     cd0:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     cd2:	82 83       	std	Z+2, r24	; 0x02
     cd4:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     cd6:	84 83       	std	Z+4, r24	; 0x04
     cd8:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     cda:	8e 81       	ldd	r24, Y+6	; 0x06
     cdc:	9f 81       	ldd	r25, Y+7	; 0x07
     cde:	2e 85       	ldd	r18, Y+14	; 0x0e
     ce0:	3f 85       	ldd	r19, Y+15	; 0x0f
     ce2:	ea 85       	ldd	r30, Y+10	; 0x0a
     ce4:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     ce6:	22 83       	std	Z+2, r18	; 0x02
     ce8:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     cea:	84 83       	std	Z+4, r24	; 0x04
     cec:	95 83       	std	Z+5, r25	; 0x05
}
     cee:	df 91       	pop	r29
     cf0:	cf 91       	pop	r28
     cf2:	1f 91       	pop	r17
     cf4:	0f 91       	pop	r16
     cf6:	08 95       	ret

00000cf8 <_ZN9I2CMaster8ReceiverC1EPS_>:

I2CMaster::Receiver::Receiver( I2CMaster * d )
     cf8:	0f 93       	push	r16
     cfa:	1f 93       	push	r17
     cfc:	cf 93       	push	r28
     cfe:	df 93       	push	r29
     d00:	ec 01       	movw	r28, r24
     d02:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     d04:	68 83       	st	Y, r22
     d06:	79 83       	std	Y+1, r23	; 0x01
     d08:	89 e0       	ldi	r24, 0x09	; 9
     d0a:	90 e0       	ldi	r25, 0x00	; 0
     d0c:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     d10:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     d12:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     d14:	83 e6       	ldi	r24, 0x63	; 99
     d16:	90 e2       	ldi	r25, 0x20	; 32
     d18:	80 83       	st	Z, r24
     d1a:	91 83       	std	Z+1, r25	; 0x01
     d1c:	07 83       	std	Z+7, r16	; 0x07
     d1e:	10 87       	std	Z+8, r17	; 0x08
     d20:	ec 83       	std	Y+4, r30	; 0x04
     d22:	fd 83       	std	Y+5, r31	; 0x05
     d24:	8b e0       	ldi	r24, 0x0B	; 11
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     d2c:	fc 01       	movw	r30, r24

I2CMaster::Receiver::Receiver( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     d2e:	8b 89       	ldd	r24, Y+19	; 0x13
     d30:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     d32:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     d34:	23 e7       	ldi	r18, 0x73	; 115
     d36:	30 e2       	ldi	r19, 0x20	; 32
     d38:	20 83       	st	Z, r18
     d3a:	31 83       	std	Z+1, r19	; 0x01
     d3c:	07 83       	std	Z+7, r16	; 0x07
     d3e:	10 87       	std	Z+8, r17	; 0x08
     d40:	81 87       	std	Z+9, r24	; 0x09
     d42:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     d44:	ee 83       	std	Y+6, r30	; 0x06
     d46:	ff 83       	std	Y+7, r31	; 0x07
     d48:	89 e0       	ldi	r24, 0x09	; 9
     d4a:	90 e0       	ldi	r25, 0x00	; 0
     d4c:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     d50:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     d52:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     d54:	83 e8       	ldi	r24, 0x83	; 131
     d56:	90 e2       	ldi	r25, 0x20	; 32
     d58:	80 83       	st	Z, r24
     d5a:	91 83       	std	Z+1, r25	; 0x01
     d5c:	07 83       	std	Z+7, r16	; 0x07
     d5e:	10 87       	std	Z+8, r17	; 0x08
     d60:	e8 87       	std	Y+8, r30	; 0x08
     d62:	f9 87       	std	Y+9, r31	; 0x09
     d64:	89 e0       	ldi	r24, 0x09	; 9
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     d6c:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     d6e:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     d70:	83 e9       	ldi	r24, 0x93	; 147
     d72:	90 e2       	ldi	r25, 0x20	; 32
     d74:	80 83       	st	Z, r24
     d76:	91 83       	std	Z+1, r25	; 0x01
     d78:	07 83       	std	Z+7, r16	; 0x07
     d7a:	10 87       	std	Z+8, r17	; 0x08
     d7c:	ea 87       	std	Y+10, r30	; 0x0a
     d7e:	fb 87       	std	Y+11, r31	; 0x0b
     d80:	89 e0       	ldi	r24, 0x09	; 9
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     d88:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     d8a:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     d8c:	83 ea       	ldi	r24, 0xA3	; 163
     d8e:	90 e2       	ldi	r25, 0x20	; 32
     d90:	80 83       	st	Z, r24
     d92:	91 83       	std	Z+1, r25	; 0x01
     d94:	07 83       	std	Z+7, r16	; 0x07
     d96:	10 87       	std	Z+8, r17	; 0x08
     d98:	ec 87       	std	Y+12, r30	; 0x0c
     d9a:	fd 87       	std	Y+13, r31	; 0x0d
     d9c:	89 e0       	ldi	r24, 0x09	; 9
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     da4:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     da6:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     da8:	8b e9       	ldi	r24, 0x9B	; 155
     daa:	90 e2       	ldi	r25, 0x20	; 32
     dac:	80 83       	st	Z, r24
     dae:	91 83       	std	Z+1, r25	; 0x01
     db0:	07 83       	std	Z+7, r16	; 0x07
     db2:	10 87       	std	Z+8, r17	; 0x08
     db4:	ee 87       	std	Y+14, r30	; 0x0e
     db6:	ff 87       	std	Y+15, r31	; 0x0f
     db8:	80 e1       	ldi	r24, 0x10	; 16
     dba:	97 e2       	ldi	r25, 0x27	; 39
     dbc:	8b 8b       	std	Y+19, r24	; 0x13
     dbe:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     dc0:	8e 81       	ldd	r24, Y+6	; 0x06
     dc2:	9f 81       	ldd	r25, Y+7	; 0x07
     dc4:	ec 81       	ldd	r30, Y+4	; 0x04
     dc6:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     dc8:	82 83       	std	Z+2, r24	; 0x02
     dca:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     dcc:	84 83       	std	Z+4, r24	; 0x04
     dce:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     dd0:	8c 85       	ldd	r24, Y+12	; 0x0c
     dd2:	9d 85       	ldd	r25, Y+13	; 0x0d
     dd4:	28 85       	ldd	r18, Y+8	; 0x08
     dd6:	39 85       	ldd	r19, Y+9	; 0x09
     dd8:	ee 81       	ldd	r30, Y+6	; 0x06
     dda:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     ddc:	22 83       	std	Z+2, r18	; 0x02
     dde:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     de0:	84 83       	std	Z+4, r24	; 0x04
     de2:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     de4:	8a 85       	ldd	r24, Y+10	; 0x0a
     de6:	9b 85       	ldd	r25, Y+11	; 0x0b
     de8:	e8 85       	ldd	r30, Y+8	; 0x08
     dea:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     dec:	82 83       	std	Z+2, r24	; 0x02
     dee:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     df0:	84 83       	std	Z+4, r24	; 0x04
     df2:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     df4:	8e 81       	ldd	r24, Y+6	; 0x06
     df6:	9f 81       	ldd	r25, Y+7	; 0x07
     df8:	2e 85       	ldd	r18, Y+14	; 0x0e
     dfa:	3f 85       	ldd	r19, Y+15	; 0x0f
     dfc:	ea 85       	ldd	r30, Y+10	; 0x0a
     dfe:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     e00:	22 83       	std	Z+2, r18	; 0x02
     e02:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     e04:	84 83       	std	Z+4, r24	; 0x04
     e06:	95 83       	std	Z+5, r25	; 0x05
}
     e08:	df 91       	pop	r29
     e0a:	cf 91       	pop	r28
     e0c:	1f 91       	pop	r17
     e0e:	0f 91       	pop	r16
     e10:	08 95       	ret

00000e12 <_ZN9I2CMaster11Transmitter3runER6Packet>:

bool I2CMaster::Transmitter::run( Packet & packet )
{
     e12:	ef 92       	push	r14
     e14:	ff 92       	push	r15
     e16:	0f 93       	push	r16
     e18:	1f 93       	push	r17
     e1a:	cf 93       	push	r28
     e1c:	df 93       	push	r29
     e1e:	ec 01       	movw	r28, r24
     e20:	7b 01       	movw	r14, r22
  currentState_ = startState_;
     e22:	8c 81       	ldd	r24, Y+4	; 0x04
     e24:	9d 81       	ldd	r25, Y+5	; 0x05
     e26:	8a 83       	std	Y+2, r24	; 0x02
     e28:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     e2a:	8a 81       	ldd	r24, Y+2	; 0x02
     e2c:	9b 81       	ldd	r25, Y+3	; 0x03
     e2e:	2e 85       	ldd	r18, Y+14	; 0x0e
     e30:	3f 85       	ldd	r19, Y+15	; 0x0f
     e32:	82 17       	cp	r24, r18
     e34:	93 07       	cpc	r25, r19
     e36:	29 f4       	brne	.+10     	; 0xe42 <_ZN9I2CMaster11Transmitter3runER6Packet+0x30>
     e38:	ac 85       	ldd	r26, Y+12	; 0x0c
     e3a:	bd 85       	ldd	r27, Y+13	; 0x0d
     e3c:	8a 17       	cp	r24, r26
     e3e:	9b 07       	cpc	r25, r27
     e40:	a9 f0       	breq	.+42     	; 0xe6c <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
  {
    State * transitionState = currentState_->execute(packet);
     e42:	dc 01       	movw	r26, r24
     e44:	ed 91       	ld	r30, X+
     e46:	fc 91       	ld	r31, X
     e48:	01 90       	ld	r0, Z+
     e4a:	f0 81       	ld	r31, Z
     e4c:	e0 2d       	mov	r30, r0
     e4e:	b7 01       	movw	r22, r14
     e50:	19 95       	eicall
     e52:	8c 01       	movw	r16, r24
    currentState_->serialDebug();
     e54:	8a 81       	ldd	r24, Y+2	; 0x02
     e56:	9b 81       	ldd	r25, Y+3	; 0x03
     e58:	dc 01       	movw	r26, r24
     e5a:	ed 91       	ld	r30, X+
     e5c:	fc 91       	ld	r31, X
     e5e:	02 80       	ldd	r0, Z+2	; 0x02
     e60:	f3 81       	ldd	r31, Z+3	; 0x03
     e62:	e0 2d       	mov	r30, r0
     e64:	19 95       	eicall
    currentState_ = transitionState;
     e66:	0a 83       	std	Y+2, r16	; 0x02
     e68:	1b 83       	std	Y+3, r17	; 0x03

bool I2CMaster::Transmitter::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     e6a:	df cf       	rjmp	.-66     	; 0xe2a <_ZN9I2CMaster11Transmitter3runER6Packet+0x18>
    State * transitionState = currentState_->execute(packet);
    currentState_->serialDebug();
    currentState_ = transitionState;
  }

  currentState_->serialDebug();
     e6c:	ed 91       	ld	r30, X+
     e6e:	fc 91       	ld	r31, X
     e70:	11 97       	sbiw	r26, 0x01	; 1
     e72:	02 80       	ldd	r0, Z+2	; 0x02
     e74:	f3 81       	ldd	r31, Z+3	; 0x03
     e76:	e0 2d       	mov	r30, r0
     e78:	cd 01       	movw	r24, r26
     e7a:	19 95       	eicall
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	4a 81       	ldd	r20, Y+2	; 0x02
     e80:	5b 81       	ldd	r21, Y+3	; 0x03
     e82:	2e 85       	ldd	r18, Y+14	; 0x0e
     e84:	3f 85       	ldd	r19, Y+15	; 0x0f
     e86:	42 17       	cp	r20, r18
     e88:	53 07       	cpc	r21, r19
     e8a:	09 f0       	breq	.+2      	; 0xe8e <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     e8c:	80 e0       	ldi	r24, 0x00	; 0
  }
  else
  {
    return false;
  }
}
     e8e:	df 91       	pop	r29
     e90:	cf 91       	pop	r28
     e92:	1f 91       	pop	r17
     e94:	0f 91       	pop	r16
     e96:	ff 90       	pop	r15
     e98:	ef 90       	pop	r14
     e9a:	08 95       	ret

00000e9c <_ZN9I2CMaster8Receiver3runER6Packet>:

Packet & I2CMaster::Receiver::run( Packet & packet )
{
     e9c:	ef 92       	push	r14
     e9e:	ff 92       	push	r15
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	ec 01       	movw	r28, r24
     eaa:	7b 01       	movw	r14, r22
  currentState_ = startState_;
     eac:	8c 81       	ldd	r24, Y+4	; 0x04
     eae:	9d 81       	ldd	r25, Y+5	; 0x05
     eb0:	8a 83       	std	Y+2, r24	; 0x02
     eb2:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     eb4:	8a 81       	ldd	r24, Y+2	; 0x02
     eb6:	9b 81       	ldd	r25, Y+3	; 0x03
     eb8:	2e 85       	ldd	r18, Y+14	; 0x0e
     eba:	3f 85       	ldd	r19, Y+15	; 0x0f
     ebc:	82 17       	cp	r24, r18
     ebe:	93 07       	cpc	r25, r19
     ec0:	29 f4       	brne	.+10     	; 0xecc <_ZN9I2CMaster8Receiver3runER6Packet+0x30>
     ec2:	ac 85       	ldd	r26, Y+12	; 0x0c
     ec4:	bd 85       	ldd	r27, Y+13	; 0x0d
     ec6:	8a 17       	cp	r24, r26
     ec8:	9b 07       	cpc	r25, r27
     eca:	a9 f0       	breq	.+42     	; 0xef6 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
  {
    State * transitionState = currentState_->execute(packet);
     ecc:	dc 01       	movw	r26, r24
     ece:	ed 91       	ld	r30, X+
     ed0:	fc 91       	ld	r31, X
     ed2:	01 90       	ld	r0, Z+
     ed4:	f0 81       	ld	r31, Z
     ed6:	e0 2d       	mov	r30, r0
     ed8:	b7 01       	movw	r22, r14
     eda:	19 95       	eicall
     edc:	8c 01       	movw	r16, r24
    currentState_->serialDebug();
     ede:	8a 81       	ldd	r24, Y+2	; 0x02
     ee0:	9b 81       	ldd	r25, Y+3	; 0x03
     ee2:	dc 01       	movw	r26, r24
     ee4:	ed 91       	ld	r30, X+
     ee6:	fc 91       	ld	r31, X
     ee8:	02 80       	ldd	r0, Z+2	; 0x02
     eea:	f3 81       	ldd	r31, Z+3	; 0x03
     eec:	e0 2d       	mov	r30, r0
     eee:	19 95       	eicall
    currentState_ = transitionState;
     ef0:	0a 83       	std	Y+2, r16	; 0x02
     ef2:	1b 83       	std	Y+3, r17	; 0x03

Packet & I2CMaster::Receiver::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     ef4:	df cf       	rjmp	.-66     	; 0xeb4 <_ZN9I2CMaster8Receiver3runER6Packet+0x18>
    State * transitionState = currentState_->execute(packet);
    currentState_->serialDebug();
    currentState_ = transitionState;
  }

  currentState_->serialDebug();
     ef6:	ed 91       	ld	r30, X+
     ef8:	fc 91       	ld	r31, X
     efa:	11 97       	sbiw	r26, 0x01	; 1
     efc:	02 80       	ldd	r0, Z+2	; 0x02
     efe:	f3 81       	ldd	r31, Z+3	; 0x03
     f00:	e0 2d       	mov	r30, r0
     f02:	cd 01       	movw	r24, r26
     f04:	19 95       	eicall

  return packet;
}
     f06:	c7 01       	movw	r24, r14
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	1f 91       	pop	r17
     f0e:	0f 91       	pop	r16
     f10:	ff 90       	pop	r15
     f12:	ef 90       	pop	r14
     f14:	08 95       	ret

00000f16 <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     f16:	cf 93       	push	r28
     f18:	df 93       	push	r29
     f1a:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     f1c:	9a 01       	movw	r18, r20
     f1e:	ab 01       	movw	r20, r22
     f20:	22 0f       	add	r18, r18
     f22:	33 1f       	adc	r19, r19
     f24:	44 1f       	adc	r20, r20
     f26:	55 1f       	adc	r21, r21
     f28:	60 e0       	ldi	r22, 0x00	; 0
     f2a:	78 e4       	ldi	r23, 0x48	; 72
     f2c:	88 ee       	ldi	r24, 0xE8	; 232
     f2e:	91 e0       	ldi	r25, 0x01	; 1
     f30:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
     f34:	25 50       	subi	r18, 0x05	; 5
     f36:	2a 87       	std	Y+10, r18	; 0x0a
  interface_->MASTER.BAUD = baudrate;
     f38:	ec 81       	ldd	r30, Y+4	; 0x04
     f3a:	fd 81       	ldd	r31, Y+5	; 0x05
     f3c:	25 83       	std	Z+5, r18	; 0x05
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
     f44:	af 92       	push	r10
     f46:	bf 92       	push	r11
     f48:	cf 92       	push	r12
     f4a:	df 92       	push	r13
     f4c:	ef 92       	push	r14
     f4e:	ff 92       	push	r15
     f50:	0f 93       	push	r16
     f52:	1f 93       	push	r17
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	ec 01       	movw	r28, r24
     f5a:	8b 01       	movw	r16, r22
     f5c:	69 01       	movw	r12, r18
     f5e:	7a 01       	movw	r14, r20
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
    receiver_(new Receiver(this))
     f60:	85 e1       	ldi	r24, 0x15	; 21
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     f68:	5c 01       	movw	r10, r24
#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
     f6a:	be 01       	movw	r22, r28
     f6c:	0e 94 ef 05 	call	0xbde	; 0xbde <_ZN9I2CMaster11TransmitterC1EPS_>
    receiver_(new Receiver(this))
     f70:	a8 82       	st	Y, r10
     f72:	b9 82       	std	Y+1, r11	; 0x01
     f74:	86 e1       	ldi	r24, 0x16	; 22
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
     f7c:	5c 01       	movw	r10, r24
     f7e:	be 01       	movw	r22, r28
     f80:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <_ZN9I2CMaster8ReceiverC1EPS_>
     f84:	aa 82       	std	Y+2, r10	; 0x02
     f86:	bb 82       	std	Y+3, r11	; 0x03
     f88:	0c 83       	std	Y+4, r16	; 0x04
     f8a:	1d 83       	std	Y+5, r17	; 0x05
     f8c:	cb 86       	std	Y+11, r12	; 0x0b
     f8e:	dc 86       	std	Y+12, r13	; 0x0c
     f90:	ed 86       	std	Y+13, r14	; 0x0d
     f92:	fe 86       	std	Y+14, r15	; 0x0e
{ 
  if (interface == &TWIC)
     f94:	00 38       	cpi	r16, 0x80	; 128
     f96:	84 e0       	ldi	r24, 0x04	; 4
     f98:	18 07       	cpc	r17, r24
     f9a:	29 f4       	brne	.+10     	; 0xfa6 <_ZN9I2CMasterC1EP10TWI_structm+0x62>
  {
    bus_port = &PORTC;
     f9c:	80 e4       	ldi	r24, 0x40	; 64
     f9e:	96 e0       	ldi	r25, 0x06	; 6
     fa0:	88 87       	std	Y+8, r24	; 0x08
     fa2:	99 87       	std	Y+9, r25	; 0x09
     fa4:	08 c0       	rjmp	.+16     	; 0xfb6 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  }
  if (interface == &TWIE)
     fa6:	00 3a       	cpi	r16, 0xA0	; 160
     fa8:	e4 e0       	ldi	r30, 0x04	; 4
     faa:	1e 07       	cpc	r17, r30
     fac:	21 f4       	brne	.+8      	; 0xfb6 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  {
    bus_port = &PORTE;
     fae:	80 e8       	ldi	r24, 0x80	; 128
     fb0:	96 e0       	ldi	r25, 0x06	; 6
     fb2:	88 87       	std	Y+8, r24	; 0x08
     fb4:	99 87       	std	Y+9, r25	; 0x09
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     fb6:	e8 85       	ldd	r30, Y+8	; 0x08
     fb8:	f9 85       	ldd	r31, Y+9	; 0x09
     fba:	83 e0       	ldi	r24, 0x03	; 3
     fbc:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     fbe:	e8 85       	ldd	r30, Y+8	; 0x08
     fc0:	f9 85       	ldd	r31, Y+9	; 0x09
     fc2:	88 e3       	ldi	r24, 0x38	; 56
     fc4:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     fc6:	e8 85       	ldd	r30, Y+8	; 0x08
     fc8:	f9 85       	ldd	r31, Y+9	; 0x09
     fca:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     fcc:	82 e0       	ldi	r24, 0x02	; 2
     fce:	f8 01       	movw	r30, r16
     fd0:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     fd2:	b7 01       	movw	r22, r14
     fd4:	a6 01       	movw	r20, r12
     fd6:	ce 01       	movw	r24, r28
     fd8:	0e 94 8b 07 	call	0xf16	; 0xf16 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     fdc:	f8 01       	movw	r30, r16
     fde:	84 81       	ldd	r24, Z+4	; 0x04
     fe0:	8d 6c       	ori	r24, 0xCD	; 205
     fe2:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     fe4:	88 e0       	ldi	r24, 0x08	; 8
     fe6:	81 83       	std	Z+1, r24	; 0x01
}
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	ff 90       	pop	r15
     ff2:	ef 90       	pop	r14
     ff4:	df 90       	pop	r13
     ff6:	cf 90       	pop	r12
     ff8:	bf 90       	pop	r11
     ffa:	af 90       	pop	r10
     ffc:	08 95       	ret

00000ffe <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return driver_->is_ready(slaveAddr_);
}
     ffe:	db 01       	movw	r26, r22
    1000:	bc 01       	movw	r22, r24
    1002:	6e 5f       	subi	r22, 0xFE	; 254
    1004:	7f 4f       	sbci	r23, 0xFF	; 255
    1006:	ed 91       	ld	r30, X+
    1008:	fc 91       	ld	r31, X
    100a:	11 97       	sbiw	r26, 0x01	; 1
    100c:	01 90       	ld	r0, Z+
    100e:	f0 81       	ld	r31, Z
    1010:	e0 2d       	mov	r30, r0
    1012:	cd 01       	movw	r24, r26
    1014:	19 95       	eicall
    1016:	08 95       	ret

00001018 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
    1018:	fc 01       	movw	r30, r24
    101a:	84 81       	ldd	r24, Z+4	; 0x04
    101c:	95 81       	ldd	r25, Z+5	; 0x05
    101e:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	08 95       	ret

00001026 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
    1026:	fc 01       	movw	r30, r24
    1028:	84 81       	ldd	r24, Z+4	; 0x04
    102a:	95 81       	ldd	r25, Z+5	; 0x05
    102c:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    1030:	91 e0       	ldi	r25, 0x01	; 1
    1032:	81 11       	cpse	r24, r1
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	89 2f       	mov	r24, r25
    103a:	08 95       	ret

0000103c <_ZN9frt_queueIhE12ISR_is_emptyEv>:
    103c:	fc 01       	movw	r30, r24
    103e:	84 81       	ldd	r24, Z+4	; 0x04
    1040:	95 81       	ldd	r25, Z+5	; 0x05
    1042:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    1046:	91 e0       	ldi	r25, 0x01	; 1
    1048:	81 11       	cpse	r24, r1
    104a:	90 e0       	ldi	r25, 0x00	; 0
    104c:	89 2f       	mov	r24, r25
    104e:	08 95       	ret

00001050 <_ZN9frt_queueIhE12num_items_inEv>:
    1050:	fc 01       	movw	r30, r24
    1052:	84 81       	ldd	r24, Z+4	; 0x04
    1054:	95 81       	ldd	r25, Z+5	; 0x05
    1056:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	08 95       	ret

0000105e <_ZN9frt_queueIhE9not_emptyEv>:
    105e:	fc 01       	movw	r30, r24
    1060:	84 81       	ldd	r24, Z+4	; 0x04
    1062:	95 81       	ldd	r25, Z+5	; 0x05
    1064:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    1068:	91 e0       	ldi	r25, 0x01	; 1
    106a:	81 11       	cpse	r24, r1
    106c:	01 c0       	rjmp	.+2      	; 0x1070 <_ZN9frt_queueIhE9not_emptyEv+0x12>
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	89 2f       	mov	r24, r25
    1072:	08 95       	ret

00001074 <_ZN9frt_queueIhE8is_emptyEv>:
    1074:	fc 01       	movw	r30, r24
    1076:	84 81       	ldd	r24, Z+4	; 0x04
    1078:	95 81       	ldd	r25, Z+5	; 0x05
    107a:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    107e:	91 e0       	ldi	r25, 0x01	; 1
    1080:	81 11       	cpse	r24, r1
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	89 2f       	mov	r24, r25
    1086:	08 95       	ret

00001088 <_ZN9frt_queueIhE10get_a_copyERh>:
    1088:	0f 93       	push	r16
    108a:	01 e0       	ldi	r16, 0x01	; 1
    108c:	2f ef       	ldi	r18, 0xFF	; 255
    108e:	3f ef       	ldi	r19, 0xFF	; 255
    1090:	a9 01       	movw	r20, r18
    1092:	fc 01       	movw	r30, r24
    1094:	84 81       	ldd	r24, Z+4	; 0x04
    1096:	95 81       	ldd	r25, Z+5	; 0x05
    1098:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
    109c:	0f 91       	pop	r16
    109e:	08 95       	ret

000010a0 <_ZN9frt_queueIhE10get_a_copyEv>:
    10a0:	0f 93       	push	r16
    10a2:	cf 93       	push	r28
    10a4:	df 93       	push	r29
    10a6:	1f 92       	push	r1
    10a8:	cd b7       	in	r28, 0x3d	; 61
    10aa:	de b7       	in	r29, 0x3e	; 62
    10ac:	01 e0       	ldi	r16, 0x01	; 1
    10ae:	2f ef       	ldi	r18, 0xFF	; 255
    10b0:	3f ef       	ldi	r19, 0xFF	; 255
    10b2:	a9 01       	movw	r20, r18
    10b4:	be 01       	movw	r22, r28
    10b6:	6f 5f       	subi	r22, 0xFF	; 255
    10b8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ba:	fc 01       	movw	r30, r24
    10bc:	84 81       	ldd	r24, Z+4	; 0x04
    10be:	95 81       	ldd	r25, Z+5	; 0x05
    10c0:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
    10c4:	89 81       	ldd	r24, Y+1	; 0x01
    10c6:	0f 90       	pop	r0
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	0f 91       	pop	r16
    10ce:	08 95       	ret

000010d0 <_ZN9frt_queueIhE3getEPh>:
    10d0:	0f 93       	push	r16
    10d2:	00 e0       	ldi	r16, 0x00	; 0
    10d4:	2f ef       	ldi	r18, 0xFF	; 255
    10d6:	3f ef       	ldi	r19, 0xFF	; 255
    10d8:	a9 01       	movw	r20, r18
    10da:	fc 01       	movw	r30, r24
    10dc:	84 81       	ldd	r24, Z+4	; 0x04
    10de:	95 81       	ldd	r25, Z+5	; 0x05
    10e0:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
    10e4:	0f 91       	pop	r16
    10e6:	08 95       	ret

000010e8 <_ZN9frt_queueIhE3getEv>:
    10e8:	0f 93       	push	r16
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29
    10ee:	1f 92       	push	r1
    10f0:	cd b7       	in	r28, 0x3d	; 61
    10f2:	de b7       	in	r29, 0x3e	; 62
    10f4:	00 e0       	ldi	r16, 0x00	; 0
    10f6:	2f ef       	ldi	r18, 0xFF	; 255
    10f8:	3f ef       	ldi	r19, 0xFF	; 255
    10fa:	a9 01       	movw	r20, r18
    10fc:	be 01       	movw	r22, r28
    10fe:	6f 5f       	subi	r22, 0xFF	; 255
    1100:	7f 4f       	sbci	r23, 0xFF	; 255
    1102:	fc 01       	movw	r30, r24
    1104:	84 81       	ldd	r24, Z+4	; 0x04
    1106:	95 81       	ldd	r25, Z+5	; 0x05
    1108:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
    110c:	89 81       	ldd	r24, Y+1	; 0x01
    110e:	0f 90       	pop	r0
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	0f 91       	pop	r16
    1116:	08 95       	ret

00001118 <_ZN9frt_queueIhE7ISR_getEPh>:
    1118:	cf 93       	push	r28
    111a:	df 93       	push	r29
    111c:	1f 92       	push	r1
    111e:	cd b7       	in	r28, 0x3d	; 61
    1120:	de b7       	in	r29, 0x3e	; 62
    1122:	ae 01       	movw	r20, r28
    1124:	4f 5f       	subi	r20, 0xFF	; 255
    1126:	5f 4f       	sbci	r21, 0xFF	; 255
    1128:	fc 01       	movw	r30, r24
    112a:	84 81       	ldd	r24, Z+4	; 0x04
    112c:	95 81       	ldd	r25, Z+5	; 0x05
    112e:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
    1132:	0f 90       	pop	r0
    1134:	df 91       	pop	r29
    1136:	cf 91       	pop	r28
    1138:	08 95       	ret

0000113a <_ZN9frt_queueIhE7ISR_getEv>:
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	1f 92       	push	r1
    1140:	1f 92       	push	r1
    1142:	cd b7       	in	r28, 0x3d	; 61
    1144:	de b7       	in	r29, 0x3e	; 62
    1146:	ae 01       	movw	r20, r28
    1148:	4e 5f       	subi	r20, 0xFE	; 254
    114a:	5f 4f       	sbci	r21, 0xFF	; 255
    114c:	be 01       	movw	r22, r28
    114e:	6f 5f       	subi	r22, 0xFF	; 255
    1150:	7f 4f       	sbci	r23, 0xFF	; 255
    1152:	fc 01       	movw	r30, r24
    1154:	84 81       	ldd	r24, Z+4	; 0x04
    1156:	95 81       	ldd	r25, Z+5	; 0x05
    1158:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
    115c:	89 81       	ldd	r24, Y+1	; 0x01
    115e:	0f 90       	pop	r0
    1160:	0f 90       	pop	r0
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	08 95       	ret

00001168 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	1f 92       	push	r1
    116e:	cd b7       	in	r28, 0x3d	; 61
    1170:	de b7       	in	r29, 0x3e	; 62
    1172:	19 82       	std	Y+1, r1	; 0x01
    1174:	21 e0       	ldi	r18, 0x01	; 1
    1176:	ae 01       	movw	r20, r28
    1178:	4f 5f       	subi	r20, 0xFF	; 255
    117a:	5f 4f       	sbci	r21, 0xFF	; 255
    117c:	fc 01       	movw	r30, r24
    117e:	84 81       	ldd	r24, Z+4	; 0x04
    1180:	95 81       	ldd	r25, Z+5	; 0x05
    1182:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
    1186:	91 e0       	ldi	r25, 0x01	; 1
    1188:	81 11       	cpse	r24, r1
    118a:	01 c0       	rjmp	.+2      	; 0x118e <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	89 2f       	mov	r24, r25
    1190:	0f 90       	pop	r0
    1192:	df 91       	pop	r29
    1194:	cf 91       	pop	r28
    1196:	08 95       	ret

00001198 <_ZN9frt_queueIhE7ISR_putERKh>:
    1198:	cf 93       	push	r28
    119a:	df 93       	push	r29
    119c:	1f 92       	push	r1
    119e:	cd b7       	in	r28, 0x3d	; 61
    11a0:	de b7       	in	r29, 0x3e	; 62
    11a2:	19 82       	std	Y+1, r1	; 0x01
    11a4:	20 e0       	ldi	r18, 0x00	; 0
    11a6:	ae 01       	movw	r20, r28
    11a8:	4f 5f       	subi	r20, 0xFF	; 255
    11aa:	5f 4f       	sbci	r21, 0xFF	; 255
    11ac:	fc 01       	movw	r30, r24
    11ae:	84 81       	ldd	r24, Z+4	; 0x04
    11b0:	95 81       	ldd	r25, Z+5	; 0x05
    11b2:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
    11b6:	91 e0       	ldi	r25, 0x01	; 1
    11b8:	81 11       	cpse	r24, r1
    11ba:	01 c0       	rjmp	.+2      	; 0x11be <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	89 2f       	mov	r24, r25
    11c0:	0f 90       	pop	r0
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	08 95       	ret

000011c8 <_ZN9frt_queueIhE7butt_inERKh>:
    11c8:	0f 93       	push	r16
    11ca:	fc 01       	movw	r30, r24
    11cc:	26 81       	ldd	r18, Z+6	; 0x06
    11ce:	37 81       	ldd	r19, Z+7	; 0x07
    11d0:	40 85       	ldd	r20, Z+8	; 0x08
    11d2:	51 85       	ldd	r21, Z+9	; 0x09
    11d4:	01 e0       	ldi	r16, 0x01	; 1
    11d6:	84 81       	ldd	r24, Z+4	; 0x04
    11d8:	95 81       	ldd	r25, Z+5	; 0x05
    11da:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    11de:	91 e0       	ldi	r25, 0x01	; 1
    11e0:	81 11       	cpse	r24, r1
    11e2:	01 c0       	rjmp	.+2      	; 0x11e6 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	89 2f       	mov	r24, r25
    11e8:	0f 91       	pop	r16
    11ea:	08 95       	ret

000011ec <_ZN9frt_queueIhE3putERKh>:
    11ec:	0f 93       	push	r16
    11ee:	fc 01       	movw	r30, r24
    11f0:	26 81       	ldd	r18, Z+6	; 0x06
    11f2:	37 81       	ldd	r19, Z+7	; 0x07
    11f4:	40 85       	ldd	r20, Z+8	; 0x08
    11f6:	51 85       	ldd	r21, Z+9	; 0x09
    11f8:	00 e0       	ldi	r16, 0x00	; 0
    11fa:	84 81       	ldd	r24, Z+4	; 0x04
    11fc:	95 81       	ldd	r25, Z+5	; 0x05
    11fe:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    1202:	91 e0       	ldi	r25, 0x01	; 1
    1204:	81 11       	cpse	r24, r1
    1206:	01 c0       	rjmp	.+2      	; 0x120a <_ZN9frt_queueIhE3putERKh+0x1e>
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	89 2f       	mov	r24, r25
    120c:	0f 91       	pop	r16
    120e:	08 95       	ret

00001210 <_ZN6MB1202C1EP9I2CMaster>:
    1210:	4f 92       	push	r4
    1212:	5f 92       	push	r5
    1214:	6f 92       	push	r6
    1216:	7f 92       	push	r7
    1218:	8f 92       	push	r8
    121a:	9f 92       	push	r9
    121c:	af 92       	push	r10
    121e:	bf 92       	push	r11
    1220:	df 92       	push	r13
    1222:	ef 92       	push	r14
    1224:	ff 92       	push	r15
    1226:	0f 93       	push	r16
    1228:	1f 93       	push	r17
    122a:	cf 93       	push	r28
    122c:	df 93       	push	r29
    122e:	8c 01       	movw	r16, r24
    1230:	7b 01       	movw	r14, r22
    1232:	dc 01       	movw	r26, r24
    1234:	6d 93       	st	X+, r22
    1236:	7c 93       	st	X, r23
    1238:	8d e1       	ldi	r24, 0x1D	; 29
    123a:	90 e0       	ldi	r25, 0x00	; 0
    123c:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
    1240:	ec 01       	movw	r28, r24
    1242:	83 ef       	ldi	r24, 0xF3	; 243
    1244:	90 e2       	ldi	r25, 0x20	; 32
    1246:	88 83       	st	Y, r24
    1248:	99 83       	std	Y+1, r25	; 0x01
    124a:	1c 82       	std	Y+4, r1	; 0x04
    124c:	1d 82       	std	Y+5, r1	; 0x05
    124e:	0f 2e       	mov	r0, r31
    1250:	fb ea       	ldi	r31, 0xAB	; 171
    1252:	8f 2e       	mov	r8, r31
    1254:	f0 e2       	ldi	r31, 0x20	; 32
    1256:	9f 2e       	mov	r9, r31
    1258:	f0 2d       	mov	r31, r0
    125a:	8a 82       	std	Y+2, r8	; 0x02
    125c:	9b 82       	std	Y+3, r9	; 0x03
    125e:	40 e0       	ldi	r20, 0x00	; 0
    1260:	61 e0       	ldi	r22, 0x01	; 1
    1262:	82 e0       	ldi	r24, 0x02	; 2
    1264:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    1268:	8e 83       	std	Y+6, r24	; 0x06
    126a:	9f 83       	std	Y+7, r25	; 0x07
    126c:	0f 2e       	mov	r0, r31
    126e:	fa e0       	ldi	r31, 0x0A	; 10
    1270:	4f 2e       	mov	r4, r31
    1272:	51 2c       	mov	r5, r1
    1274:	61 2c       	mov	r6, r1
    1276:	71 2c       	mov	r7, r1
    1278:	f0 2d       	mov	r31, r0
    127a:	48 86       	std	Y+8, r4	; 0x08
    127c:	59 86       	std	Y+9, r5	; 0x09
    127e:	6a 86       	std	Y+10, r6	; 0x0a
    1280:	7b 86       	std	Y+11, r7	; 0x0b
    1282:	0f 2e       	mov	r0, r31
    1284:	ff ec       	ldi	r31, 0xCF	; 207
    1286:	af 2e       	mov	r10, r31
    1288:	f0 e2       	ldi	r31, 0x20	; 32
    128a:	bf 2e       	mov	r11, r31
    128c:	f0 2d       	mov	r31, r0
    128e:	aa 82       	std	Y+2, r10	; 0x02
    1290:	bb 82       	std	Y+3, r11	; 0x03
    1292:	68 94       	set
    1294:	dd 24       	eor	r13, r13
    1296:	d1 f8       	bld	r13, 1
    1298:	dc 86       	std	Y+12, r13	; 0x0c
    129a:	1f 86       	std	Y+15, r1	; 0x0f
    129c:	18 8a       	std	Y+16, r1	; 0x10
    129e:	8d 86       	std	Y+13, r8	; 0x0d
    12a0:	9e 86       	std	Y+14, r9	; 0x0e
    12a2:	40 e0       	ldi	r20, 0x00	; 0
    12a4:	61 e0       	ldi	r22, 0x01	; 1
    12a6:	82 e0       	ldi	r24, 0x02	; 2
    12a8:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    12ac:	89 8b       	std	Y+17, r24	; 0x11
    12ae:	9a 8b       	std	Y+18, r25	; 0x12
    12b0:	4b 8a       	std	Y+19, r4	; 0x13
    12b2:	5c 8a       	std	Y+20, r5	; 0x14
    12b4:	6d 8a       	std	Y+21, r6	; 0x15
    12b6:	7e 8a       	std	Y+22, r7	; 0x16
    12b8:	ad 86       	std	Y+13, r10	; 0x0d
    12ba:	be 86       	std	Y+14, r11	; 0x0e
    12bc:	df 8a       	std	Y+23, r13	; 0x17
    12be:	8a e0       	ldi	r24, 0x0A	; 10
    12c0:	90 e2       	ldi	r25, 0x20	; 32
    12c2:	88 83       	st	Y, r24
    12c4:	99 83       	std	Y+1, r25	; 0x01
    12c6:	f8 01       	movw	r30, r16
    12c8:	c2 83       	std	Z+2, r28	; 0x02
    12ca:	d3 83       	std	Z+3, r29	; 0x03
    12cc:	80 e7       	ldi	r24, 0x70	; 112
    12ce:	84 83       	std	Z+4, r24	; 0x04
    12d0:	16 82       	std	Z+6, r1	; 0x06
    12d2:	17 82       	std	Z+7, r1	; 0x07
    12d4:	10 86       	std	Z+8, r1	; 0x08
    12d6:	11 86       	std	Z+9, r1	; 0x09
    12d8:	12 86       	std	Z+10, r1	; 0x0a
    12da:	83 e0       	ldi	r24, 0x03	; 3
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
    12e2:	21 e0       	ldi	r18, 0x01	; 1
    12e4:	31 e2       	ldi	r19, 0x21	; 33
    12e6:	fc 01       	movw	r30, r24
    12e8:	20 83       	st	Z, r18
    12ea:	31 83       	std	Z+1, r19	; 0x01
    12ec:	c1 e5       	ldi	r28, 0x51	; 81
    12ee:	c2 83       	std	Z+2, r28	; 0x02
    12f0:	d8 01       	movw	r26, r16
    12f2:	1d 96       	adiw	r26, 0x0d	; 13
    12f4:	8d 93       	st	X+, r24
    12f6:	9c 93       	st	X, r25
    12f8:	1e 97       	sbiw	r26, 0x0e	; 14
    12fa:	12 96       	adiw	r26, 0x02	; 2
    12fc:	ed 91       	ld	r30, X+
    12fe:	fc 91       	ld	r31, X
    1300:	13 97       	sbiw	r26, 0x03	; 3
    1302:	e0 8e       	std	Z+24, r14	; 0x18
    1304:	f1 8e       	std	Z+25, r15	; 0x19
    1306:	14 96       	adiw	r26, 0x04	; 4
    1308:	6c 91       	ld	r22, X
    130a:	14 97       	sbiw	r26, 0x04	; 4
    130c:	12 96       	adiw	r26, 0x02	; 2
    130e:	8d 91       	ld	r24, X+
    1310:	9c 91       	ld	r25, X
    1312:	13 97       	sbiw	r26, 0x03	; 3
    1314:	0e 94 01 04 	call	0x802	; 0x802 <_ZN8I2CAgent12setSlaveAddrEh>
    1318:	f8 01       	movw	r30, r16
    131a:	c5 83       	std	Z+5, r28	; 0x05
    131c:	8a ea       	ldi	r24, 0xAA	; 170
    131e:	86 83       	std	Z+6, r24	; 0x06
    1320:	85 ea       	ldi	r24, 0xA5	; 165
    1322:	87 83       	std	Z+7, r24	; 0x07
    1324:	df 91       	pop	r29
    1326:	cf 91       	pop	r28
    1328:	1f 91       	pop	r17
    132a:	0f 91       	pop	r16
    132c:	ff 90       	pop	r15
    132e:	ef 90       	pop	r14
    1330:	df 90       	pop	r13
    1332:	bf 90       	pop	r11
    1334:	af 90       	pop	r10
    1336:	9f 90       	pop	r9
    1338:	8f 90       	pop	r8
    133a:	7f 90       	pop	r7
    133c:	6f 90       	pop	r6
    133e:	5f 90       	pop	r5
    1340:	4f 90       	pop	r4
    1342:	08 95       	ret

00001344 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
	return i2cAgent_->transmit(*rangeCommand_);
    1344:	fc 01       	movw	r30, r24
    1346:	a2 81       	ldd	r26, Z+2	; 0x02
    1348:	b3 81       	ldd	r27, Z+3	; 0x03
    134a:	65 85       	ldd	r22, Z+13	; 0x0d
    134c:	76 85       	ldd	r23, Z+14	; 0x0e
    134e:	ed 91       	ld	r30, X+
    1350:	fc 91       	ld	r31, X
    1352:	11 97       	sbiw	r26, 0x01	; 1
    1354:	01 90       	ld	r0, Z+
    1356:	f0 81       	ld	r31, Z
    1358:	e0 2d       	mov	r30, r0
    135a:	cd 01       	movw	r24, r26
    135c:	19 95       	eicall
}
    135e:	08 95       	ret

00001360 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
    1360:	ff 92       	push	r15
    1362:	0f 93       	push	r16
    1364:	1f 93       	push	r17
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
    136a:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
    136c:	8a 81       	ldd	r24, Y+2	; 0x02
    136e:	9b 81       	ldd	r25, Y+3	; 0x03
    1370:	dc 01       	movw	r26, r24
    1372:	ed 91       	ld	r30, X+
    1374:	fc 91       	ld	r31, X
    1376:	02 80       	ldd	r0, Z+2	; 0x02
    1378:	f3 81       	ldd	r31, Z+3	; 0x03
    137a:	e0 2d       	mov	r30, r0
    137c:	19 95       	eicall
    137e:	8c 01       	movw	r16, r24
	range_reading = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
    1380:	dc 01       	movw	r26, r24
    1382:	ed 91       	ld	r30, X+
    1384:	fc 91       	ld	r31, X
    1386:	00 84       	ldd	r0, Z+8	; 0x08
    1388:	f1 85       	ldd	r31, Z+9	; 0x09
    138a:	e0 2d       	mov	r30, r0
    138c:	19 95       	eicall
    138e:	f8 2e       	mov	r15, r24
    1390:	d8 01       	movw	r26, r16
    1392:	ed 91       	ld	r30, X+
    1394:	fc 91       	ld	r31, X
    1396:	00 84       	ldd	r0, Z+8	; 0x08
    1398:	f1 85       	ldd	r31, Z+9	; 0x09
    139a:	e0 2d       	mov	r30, r0
    139c:	c8 01       	movw	r24, r16
    139e:	19 95       	eicall
    13a0:	2f 2d       	mov	r18, r15
    13a2:	30 e0       	ldi	r19, 0x00	; 0
    13a4:	32 2f       	mov	r19, r18
    13a6:	22 27       	eor	r18, r18
    13a8:	a9 01       	movw	r20, r18
    13aa:	48 2b       	or	r20, r24
    13ac:	ca 01       	movw	r24, r20
    13ae:	8b 87       	std	Y+11, r24	; 0x0b
    13b0:	9c 87       	std	Y+12, r25	; 0x0c
	return range_reading;
}
    13b2:	df 91       	pop	r29
    13b4:	cf 91       	pop	r28
    13b6:	1f 91       	pop	r17
    13b8:	0f 91       	pop	r16
    13ba:	ff 90       	pop	r15
    13bc:	08 95       	ret

000013be <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    13be:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    13c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13c2:	88 23       	and	r24, r24
    13c4:	19 f0       	breq	.+6      	; 0x13cc <_ZN10task_sonar3runEv+0xe>
    13c6:	81 30       	cpi	r24, 0x01	; 1
    13c8:	51 f0       	breq	.+20     	; 0x13de <_ZN10task_sonar3runEv+0x20>
    13ca:	25 c0       	rjmp	.+74     	; 0x1416 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
    13cc:	8c 89       	ldd	r24, Y+20	; 0x14
    13ce:	9d 89       	ldd	r25, Y+21	; 0x15
    13d0:	0e 94 a2 09 	call	0x1344	; 0x1344 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
    13d4:	61 e0       	ldi	r22, 0x01	; 1
    13d6:	ce 01       	movw	r24, r28
    13d8:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN8frt_task13transition_toEh>
			
			    break;
    13dc:	1c c0       	rjmp	.+56     	; 0x1416 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
    13de:	8c 89       	ldd	r24, Y+20	; 0x14
    13e0:	9d 89       	ldd	r25, Y+21	; 0x15
    13e2:	0e 94 b0 09 	call	0x1360	; 0x1360 <_ZN6MB120211get_readingEv>
    13e6:	7c 01       	movw	r14, r24
    13e8:	8a 8b       	std	Y+18, r24	; 0x12
    13ea:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
    13ec:	6a e0       	ldi	r22, 0x0A	; 10
    13ee:	8e 81       	ldd	r24, Y+6	; 0x06
    13f0:	9f 81       	ldd	r25, Y+7	; 0x07
    13f2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    13f6:	8c 01       	movw	r16, r24
    13f8:	6a ea       	ldi	r22, 0xAA	; 170
    13fa:	73 e0       	ldi	r23, 0x03	; 3
    13fc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    1400:	b7 01       	movw	r22, r14
    1402:	c8 01       	movw	r24, r16
    1404:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    1408:	66 e0       	ldi	r22, 0x06	; 6
    140a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    140e:	60 e0       	ldi	r22, 0x00	; 0
    1410:	ce 01       	movw	r24, r28
    1412:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1416:	8e 85       	ldd	r24, Y+14	; 0x0e
    1418:	9f 85       	ldd	r25, Y+15	; 0x0f
    141a:	a8 89       	ldd	r26, Y+16	; 0x10
    141c:	b9 89       	ldd	r27, Y+17	; 0x11
    141e:	01 96       	adiw	r24, 0x01	; 1
    1420:	a1 1d       	adc	r26, r1
    1422:	b1 1d       	adc	r27, r1
    1424:	8e 87       	std	Y+14, r24	; 0x0e
    1426:	9f 87       	std	Y+15, r25	; 0x0f
    1428:	a8 8b       	std	Y+16, r26	; 0x10
    142a:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
    142c:	64 ef       	ldi	r22, 0xF4	; 244
    142e:	71 e0       	ldi	r23, 0x01	; 1
    1430:	80 e0       	ldi	r24, 0x00	; 0
    1432:	90 e0       	ldi	r25, 0x00	; 0
    1434:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1438:	c3 cf       	rjmp	.-122    	; 0x13c0 <_ZN10task_sonar3runEv+0x2>

0000143a <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    143a:	cf 92       	push	r12
    143c:	df 92       	push	r13
    143e:	ef 92       	push	r14
    1440:	ff 92       	push	r15
    1442:	0f 93       	push	r16
    1444:	1f 93       	push	r17
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	ec 01       	movw	r28, r24
    144c:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
    144e:	0e 94 ee 17 	call	0x2fdc	; 0x2fdc <_ZN8frt_taskC1EPKchjP8emstream>
    1452:	87 e0       	ldi	r24, 0x07	; 7
    1454:	91 e2       	ldi	r25, 0x21	; 33
    1456:	88 83       	st	Y, r24
    1458:	99 83       	std	Y+1, r25	; 0x01
    145a:	ec 8a       	std	Y+20, r14	; 0x14
    145c:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    145e:	ce 8a       	std	Y+22, r12	; 0x16
    1460:	df 8a       	std	Y+23, r13	; 0x17
}
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	ef 90       	pop	r14
    146e:	df 90       	pop	r13
    1470:	cf 90       	pop	r12
    1472:	08 95       	ret

00001474 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1474:	0f 93       	push	r16
    1476:	1f 93       	push	r17
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    147e:	0e 94 ee 17 	call	0x2fdc	; 0x2fdc <_ZN8frt_taskC1EPKchjP8emstream>
    1482:	8f e0       	ldi	r24, 0x0F	; 15
    1484:	91 e2       	ldi	r25, 0x21	; 33
    1486:	88 83       	st	Y, r24
    1488:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	08 95       	ret

00001494 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1494:	0f 93       	push	r16
    1496:	1f 93       	push	r17
    1498:	cf 93       	push	r28
    149a:	df 93       	push	r29
    149c:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    149e:	6a e0       	ldi	r22, 0x0A	; 10
    14a0:	8e 81       	ldd	r24, Y+6	; 0x06
    14a2:	9f 81       	ldd	r25, Y+7	; 0x07
    14a4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    14a8:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    14aa:	65 e0       	ldi	r22, 0x05	; 5
    14ac:	75 e0       	ldi	r23, 0x05	; 5
    14ae:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    14b2:	6a e0       	ldi	r22, 0x0A	; 10
    14b4:	c8 01       	movw	r24, r16
    14b6:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    14ba:	8c 01       	movw	r16, r24
    14bc:	6f ef       	ldi	r22, 0xFF	; 255
    14be:	74 e0       	ldi	r23, 0x04	; 4
    14c0:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    14c4:	67 e0       	ldi	r22, 0x07	; 7
    14c6:	c8 01       	movw	r24, r16
    14c8:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    14cc:	6a e0       	ldi	r22, 0x0A	; 10
    14ce:	8e 81       	ldd	r24, Y+6	; 0x06
    14d0:	9f 81       	ldd	r25, Y+7	; 0x07
    14d2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    14d6:	8c 01       	movw	r16, r24
    14d8:	60 ee       	ldi	r22, 0xE0	; 224
    14da:	74 e0       	ldi	r23, 0x04	; 4
    14dc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    14e0:	6a e0       	ldi	r22, 0x0A	; 10
    14e2:	c8 01       	movw	r24, r16
    14e4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    14e8:	8c 01       	movw	r16, r24
    14ea:	6a ed       	ldi	r22, 0xDA	; 218
    14ec:	74 e0       	ldi	r23, 0x04	; 4
    14ee:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    14f2:	66 e0       	ldi	r22, 0x06	; 6
    14f4:	c8 01       	movw	r24, r16
    14f6:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    14fa:	6a e0       	ldi	r22, 0x0A	; 10
    14fc:	8e 81       	ldd	r24, Y+6	; 0x06
    14fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1500:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1504:	8c 01       	movw	r16, r24
    1506:	63 ec       	ldi	r22, 0xC3	; 195
    1508:	74 e0       	ldi	r23, 0x04	; 4
    150a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    150e:	66 e0       	ldi	r22, 0x06	; 6
    1510:	c8 01       	movw	r24, r16
    1512:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1516:	6a e0       	ldi	r22, 0x0A	; 10
    1518:	8e 81       	ldd	r24, Y+6	; 0x06
    151a:	9f 81       	ldd	r25, Y+7	; 0x07
    151c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1520:	8c 01       	movw	r16, r24
    1522:	67 ea       	ldi	r22, 0xA7	; 167
    1524:	74 e0       	ldi	r23, 0x04	; 4
    1526:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    152a:	66 e0       	ldi	r22, 0x06	; 6
    152c:	c8 01       	movw	r24, r16
    152e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1532:	6a e0       	ldi	r22, 0x0A	; 10
    1534:	8e 81       	ldd	r24, Y+6	; 0x06
    1536:	9f 81       	ldd	r25, Y+7	; 0x07
    1538:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    153c:	8c 01       	movw	r16, r24
    153e:	6f e8       	ldi	r22, 0x8F	; 143
    1540:	74 e0       	ldi	r23, 0x04	; 4
    1542:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    1546:	66 e0       	ldi	r22, 0x06	; 6
    1548:	c8 01       	movw	r24, r16
    154a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    154e:	6a e0       	ldi	r22, 0x0A	; 10
    1550:	8e 81       	ldd	r24, Y+6	; 0x06
    1552:	9f 81       	ldd	r25, Y+7	; 0x07
    1554:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1558:	8c 01       	movw	r16, r24
    155a:	6e e6       	ldi	r22, 0x6E	; 110
    155c:	74 e0       	ldi	r23, 0x04	; 4
    155e:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    1562:	66 e0       	ldi	r22, 0x06	; 6
    1564:	c8 01       	movw	r24, r16
    1566:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    156a:	6a e0       	ldi	r22, 0x0A	; 10
    156c:	8e 81       	ldd	r24, Y+6	; 0x06
    156e:	9f 81       	ldd	r25, Y+7	; 0x07
    1570:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1574:	8c 01       	movw	r16, r24
    1576:	67 e4       	ldi	r22, 0x47	; 71
    1578:	74 e0       	ldi	r23, 0x04	; 4
    157a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    157e:	66 e0       	ldi	r22, 0x06	; 6
    1580:	c8 01       	movw	r24, r16
    1582:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1586:	6a e0       	ldi	r22, 0x0A	; 10
    1588:	8e 81       	ldd	r24, Y+6	; 0x06
    158a:	9f 81       	ldd	r25, Y+7	; 0x07
    158c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1590:	8c 01       	movw	r16, r24
    1592:	69 e2       	ldi	r22, 0x29	; 41
    1594:	74 e0       	ldi	r23, 0x04	; 4
    1596:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    159a:	66 e0       	ldi	r22, 0x06	; 6
    159c:	c8 01       	movw	r24, r16
    159e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    15a2:	6a e0       	ldi	r22, 0x0A	; 10
    15a4:	8e 81       	ldd	r24, Y+6	; 0x06
    15a6:	9f 81       	ldd	r25, Y+7	; 0x07
    15a8:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    15ac:	8c 01       	movw	r16, r24
    15ae:	6e e0       	ldi	r22, 0x0E	; 14
    15b0:	74 e0       	ldi	r23, 0x04	; 4
    15b2:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    15b6:	66 e0       	ldi	r22, 0x06	; 6
    15b8:	c8 01       	movw	r24, r16
    15ba:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    15be:	6a e0       	ldi	r22, 0x0A	; 10
    15c0:	8e 81       	ldd	r24, Y+6	; 0x06
    15c2:	9f 81       	ldd	r25, Y+7	; 0x07
    15c4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    15c8:	ec 01       	movw	r28, r24
    15ca:	6f ef       	ldi	r22, 0xFF	; 255
    15cc:	73 e0       	ldi	r23, 0x03	; 3
    15ce:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    15d2:	66 e0       	ldi	r22, 0x06	; 6
    15d4:	ce 01       	movw	r24, r28
    15d6:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
}
    15da:	df 91       	pop	r29
    15dc:	cf 91       	pop	r28
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	08 95       	ret

000015e4 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    15e4:	af 92       	push	r10
    15e6:	bf 92       	push	r11
    15e8:	cf 92       	push	r12
    15ea:	df 92       	push	r13
    15ec:	ef 92       	push	r14
    15ee:	ff 92       	push	r15
    15f0:	0f 93       	push	r16
    15f2:	1f 93       	push	r17
    15f4:	cf 93       	push	r28
    15f6:	df 93       	push	r29
    15f8:	00 d0       	rcall	.+0      	; 0x15fa <_ZN9task_user11show_statusEv+0x16>
    15fa:	00 d0       	rcall	.+0      	; 0x15fc <_ZN9task_user11show_statusEv+0x18>
    15fc:	cd b7       	in	r28, 0x3d	; 61
    15fe:	de b7       	in	r29, 0x3e	; 62
    1600:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1602:	19 82       	std	Y+1, r1	; 0x01
    1604:	1a 82       	std	Y+2, r1	; 0x02
    1606:	1b 82       	std	Y+3, r1	; 0x03
    1608:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    160a:	1d 82       	std	Y+5, r1	; 0x05
    160c:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    160e:	0e 94 77 0d 	call	0x1aee	; 0x1aee <xPortGetFreeHeapSize>
    1612:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1614:	ce 01       	movw	r24, r28
    1616:	01 96       	adiw	r24, 0x01	; 1
    1618:	0e 94 9f 1b 	call	0x373e	; 0x373e <_ZN10time_stamp10set_to_nowEv>
    161c:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    161e:	66 e0       	ldi	r22, 0x06	; 6
    1620:	f8 01       	movw	r30, r16
    1622:	86 81       	ldd	r24, Z+6	; 0x06
    1624:	97 81       	ldd	r25, Z+7	; 0x07
    1626:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    162a:	6a e0       	ldi	r22, 0x0A	; 10
    162c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1630:	7c 01       	movw	r14, r24
    1632:	60 ee       	ldi	r22, 0xE0	; 224
    1634:	73 e0       	ldi	r23, 0x03	; 3
    1636:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    163a:	6a e0       	ldi	r22, 0x0A	; 10
    163c:	c7 01       	movw	r24, r14
    163e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1642:	7c 01       	movw	r14, r24
    1644:	64 ed       	ldi	r22, 0xD4	; 212
    1646:	73 e0       	ldi	r23, 0x03	; 3
    1648:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    164c:	66 e0       	ldi	r22, 0x06	; 6
    164e:	c7 01       	movw	r24, r14
    1650:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1654:	6a e0       	ldi	r22, 0x0A	; 10
    1656:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    165a:	7c 01       	movw	r14, r24
    165c:	6d ec       	ldi	r22, 0xCD	; 205
    165e:	73 e0       	ldi	r23, 0x03	; 3
    1660:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    1664:	b5 01       	movw	r22, r10
    1666:	c7 01       	movw	r24, r14
    1668:	0e 94 43 1b 	call	0x3686	; 0x3686 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    166c:	6a e0       	ldi	r22, 0x0A	; 10
    166e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1672:	7c 01       	movw	r14, r24
    1674:	6f eb       	ldi	r22, 0xBF	; 191
    1676:	73 e0       	ldi	r23, 0x03	; 3
    1678:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    167c:	b6 01       	movw	r22, r12
    167e:	c7 01       	movw	r24, r14
    1680:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    1684:	6a e0       	ldi	r22, 0x0A	; 10
    1686:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    168a:	7c 01       	movw	r14, r24
    168c:	6d eb       	ldi	r22, 0xBD	; 189
    168e:	73 e0       	ldi	r23, 0x03	; 3
    1690:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1694:	4f ef       	ldi	r20, 0xFF	; 255
    1696:	5f e0       	ldi	r21, 0x0F	; 15
    1698:	60 e0       	ldi	r22, 0x00	; 0
    169a:	70 e0       	ldi	r23, 0x00	; 0
    169c:	c7 01       	movw	r24, r14
    169e:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    16a2:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    16a6:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    16aa:	6a e0       	ldi	r22, 0x0A	; 10
    16ac:	f8 01       	movw	r30, r16
    16ae:	86 81       	ldd	r24, Z+6	; 0x06
    16b0:	97 81       	ldd	r25, Z+7	; 0x07
    16b2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    16b6:	7c 01       	movw	r14, r24
    16b8:	62 eb       	ldi	r22, 0xB2	; 178
    16ba:	73 e0       	ldi	r23, 0x03	; 3
    16bc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    16c0:	b6 01       	movw	r22, r12
    16c2:	c7 01       	movw	r24, r14
    16c4:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    16c8:	66 e0       	ldi	r22, 0x06	; 6
    16ca:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    16ce:	66 e0       	ldi	r22, 0x06	; 6
    16d0:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    16d4:	f8 01       	movw	r30, r16
    16d6:	86 81       	ldd	r24, Z+6	; 0x06
    16d8:	97 81       	ldd	r25, Z+7	; 0x07
    16da:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_Z15print_task_listP8emstream>
}
    16de:	26 96       	adiw	r28, 0x06	; 6
    16e0:	cd bf       	out	0x3d, r28	; 61
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	1f 91       	pop	r17
    16ea:	0f 91       	pop	r16
    16ec:	ff 90       	pop	r15
    16ee:	ef 90       	pop	r14
    16f0:	df 90       	pop	r13
    16f2:	cf 90       	pop	r12
    16f4:	bf 90       	pop	r11
    16f6:	af 90       	pop	r10
    16f8:	08 95       	ret

000016fa <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    16fa:	cf 93       	push	r28
    16fc:	df 93       	push	r29
    16fe:	00 d0       	rcall	.+0      	; 0x1700 <_ZN9task_user3runEv+0x6>
    1700:	00 d0       	rcall	.+0      	; 0x1702 <_ZN9task_user3runEv+0x8>
    1702:	cd b7       	in	r28, 0x3d	; 61
    1704:	de b7       	in	r29, 0x3e	; 62
    1706:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1708:	19 82       	std	Y+1, r1	; 0x01
    170a:	1a 82       	std	Y+2, r1	; 0x02
    170c:	1b 82       	std	Y+3, r1	; 0x03
    170e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1710:	1d 82       	std	Y+5, r1	; 0x05
    1712:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1714:	6a e0       	ldi	r22, 0x0A	; 10
    1716:	dc 01       	movw	r26, r24
    1718:	16 96       	adiw	r26, 0x06	; 6
    171a:	8d 91       	ld	r24, X+
    171c:	9c 91       	ld	r25, X
    171e:	17 97       	sbiw	r26, 0x07	; 7
    1720:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1724:	7c 01       	movw	r14, r24
    1726:	6e e4       	ldi	r22, 0x4E	; 78
    1728:	75 e0       	ldi	r23, 0x05	; 5
    172a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    172e:	66 e0       	ldi	r22, 0x06	; 6
    1730:	c7 01       	movw	r24, r14
    1732:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1736:	f8 01       	movw	r30, r16
    1738:	84 85       	ldd	r24, Z+12	; 0x0c
    173a:	88 23       	and	r24, r24
    173c:	21 f0       	breq	.+8      	; 0x1746 <_ZN9task_user3runEv+0x4c>
    173e:	81 30       	cpi	r24, 0x01	; 1
    1740:	09 f4       	brne	.+2      	; 0x1744 <_ZN9task_user3runEv+0x4a>
    1742:	5d c0       	rjmp	.+186    	; 0x17fe <_ZN9task_user3runEv+0x104>
    1744:	d8 c0       	rjmp	.+432    	; 0x18f6 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1746:	86 81       	ldd	r24, Z+6	; 0x06
    1748:	97 81       	ldd	r25, Z+7	; 0x07
    174a:	dc 01       	movw	r26, r24
    174c:	ed 91       	ld	r30, X+
    174e:	fc 91       	ld	r31, X
    1750:	04 80       	ldd	r0, Z+4	; 0x04
    1752:	f5 81       	ldd	r31, Z+5	; 0x05
    1754:	e0 2d       	mov	r30, r0
    1756:	19 95       	eicall
    1758:	88 23       	and	r24, r24
    175a:	a9 f1       	breq	.+106    	; 0x17c6 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    175c:	f8 01       	movw	r30, r16
    175e:	86 81       	ldd	r24, Z+6	; 0x06
    1760:	97 81       	ldd	r25, Z+7	; 0x07
    1762:	dc 01       	movw	r26, r24
    1764:	ed 91       	ld	r30, X+
    1766:	fc 91       	ld	r31, X
    1768:	06 80       	ldd	r0, Z+6	; 0x06
    176a:	f7 81       	ldd	r31, Z+7	; 0x07
    176c:	e0 2d       	mov	r30, r0
    176e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1770:	99 27       	eor	r25, r25
    1772:	81 30       	cpi	r24, 0x01	; 1
    1774:	91 05       	cpc	r25, r1
    1776:	f9 f0       	breq	.+62     	; 0x17b6 <_ZN9task_user3runEv+0xbc>
    1778:	03 97       	sbiw	r24, 0x03	; 3
    177a:	09 f0       	breq	.+2      	; 0x177e <_ZN9task_user3runEv+0x84>
    177c:	d8 c0       	rjmp	.+432    	; 0x192e <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    177e:	6a e0       	ldi	r22, 0x0A	; 10
    1780:	f8 01       	movw	r30, r16
    1782:	86 81       	ldd	r24, Z+6	; 0x06
    1784:	97 81       	ldd	r25, Z+7	; 0x07
    1786:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    178a:	8c 01       	movw	r16, r24
    178c:	60 e4       	ldi	r22, 0x40	; 64
    178e:	75 e0       	ldi	r23, 0x05	; 5
    1790:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    1794:	66 e0       	ldi	r22, 0x06	; 6
    1796:	c8 01       	movw	r24, r16
    1798:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    179c:	93 e0       	ldi	r25, 0x03	; 3
    179e:	88 ed       	ldi	r24, 0xD8	; 216
    17a0:	08 b6       	in	r0, 0x38	; 56
    17a2:	18 be       	out	0x38, r1	; 56
    17a4:	84 bf       	out	0x34, r24	; 52
    17a6:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    17aa:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    17ae:	81 fd       	sbrc	r24, 1
    17b0:	fc cf       	rjmp	.-8      	; 0x17aa <_ZN9task_user3runEv+0xb0>
    17b2:	08 be       	out	0x38, r0	; 56
    17b4:	ff cf       	rjmp	.-2      	; 0x17b4 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    17b6:	c8 01       	movw	r24, r16
    17b8:	0e 94 4a 0a 	call	0x1494	; 0x1494 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    17bc:	61 e0       	ldi	r22, 0x01	; 1
    17be:	c8 01       	movw	r24, r16
    17c0:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN8frt_task13transition_toEh>
							break;
    17c4:	b4 c0       	rjmp	.+360    	; 0x192e <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    17c6:	82 e8       	ldi	r24, 0x82	; 130
    17c8:	92 e3       	ldi	r25, 0x32	; 50
    17ca:	0e 94 ab 1a 	call	0x3556	; 0x3556 <_ZN14frt_text_queue14check_for_charEv>
    17ce:	88 23       	and	r24, r24
    17d0:	09 f4       	brne	.+2      	; 0x17d4 <_ZN9task_user3runEv+0xda>
    17d2:	ad c0       	rjmp	.+346    	; 0x192e <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    17d4:	d8 01       	movw	r26, r16
    17d6:	16 96       	adiw	r26, 0x06	; 6
    17d8:	ed 91       	ld	r30, X+
    17da:	fc 91       	ld	r31, X
    17dc:	17 97       	sbiw	r26, 0x07	; 7
    17de:	01 90       	ld	r0, Z+
    17e0:	f0 81       	ld	r31, Z
    17e2:	e0 2d       	mov	r30, r0
    17e4:	e2 80       	ldd	r14, Z+2	; 0x02
    17e6:	f3 80       	ldd	r15, Z+3	; 0x03
    17e8:	82 e8       	ldi	r24, 0x82	; 130
    17ea:	92 e3       	ldi	r25, 0x32	; 50
    17ec:	0e 94 8d 1a 	call	0x351a	; 0x351a <_ZN14frt_text_queue7getcharEv>
    17f0:	68 2f       	mov	r22, r24
    17f2:	f8 01       	movw	r30, r16
    17f4:	86 81       	ldd	r24, Z+6	; 0x06
    17f6:	97 81       	ldd	r25, Z+7	; 0x07
    17f8:	f7 01       	movw	r30, r14
    17fa:	19 95       	eicall
    17fc:	98 c0       	rjmp	.+304    	; 0x192e <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    17fe:	86 81       	ldd	r24, Z+6	; 0x06
    1800:	97 81       	ldd	r25, Z+7	; 0x07
    1802:	dc 01       	movw	r26, r24
    1804:	ed 91       	ld	r30, X+
    1806:	fc 91       	ld	r31, X
    1808:	04 80       	ldd	r0, Z+4	; 0x04
    180a:	f5 81       	ldd	r31, Z+5	; 0x05
    180c:	e0 2d       	mov	r30, r0
    180e:	19 95       	eicall
    1810:	88 23       	and	r24, r24
    1812:	09 f4       	brne	.+2      	; 0x1816 <_ZN9task_user3runEv+0x11c>
    1814:	8c c0       	rjmp	.+280    	; 0x192e <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1816:	f8 01       	movw	r30, r16
    1818:	86 81       	ldd	r24, Z+6	; 0x06
    181a:	97 81       	ldd	r25, Z+7	; 0x07
    181c:	dc 01       	movw	r26, r24
    181e:	ed 91       	ld	r30, X+
    1820:	fc 91       	ld	r31, X
    1822:	06 80       	ldd	r0, Z+6	; 0x06
    1824:	f7 81       	ldd	r31, Z+7	; 0x07
    1826:	e0 2d       	mov	r30, r0
    1828:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    182a:	9c 01       	movw	r18, r24
    182c:	33 27       	eor	r19, r19
    182e:	28 36       	cpi	r18, 0x68	; 104
    1830:	31 05       	cpc	r19, r1
    1832:	59 f1       	breq	.+86     	; 0x188a <_ZN9task_user3runEv+0x190>
    1834:	3c f4       	brge	.+14     	; 0x1844 <_ZN9task_user3runEv+0x14a>
    1836:	2b 31       	cpi	r18, 0x1B	; 27
    1838:	31 05       	cpc	r19, r1
    183a:	59 f1       	breq	.+86     	; 0x1892 <_ZN9task_user3runEv+0x198>
    183c:	25 36       	cpi	r18, 0x65	; 101
    183e:	31 05       	cpc	r19, r1
    1840:	41 f1       	breq	.+80     	; 0x1892 <_ZN9task_user3runEv+0x198>
    1842:	3b c0       	rjmp	.+118    	; 0x18ba <_ZN9task_user3runEv+0x1c0>
    1844:	23 37       	cpi	r18, 0x73	; 115
    1846:	31 05       	cpc	r19, r1
    1848:	c1 f0       	breq	.+48     	; 0x187a <_ZN9task_user3runEv+0x180>
    184a:	26 37       	cpi	r18, 0x76	; 118
    184c:	31 05       	cpc	r19, r1
    184e:	89 f0       	breq	.+34     	; 0x1872 <_ZN9task_user3runEv+0x178>
    1850:	2e 36       	cpi	r18, 0x6E	; 110
    1852:	31 05       	cpc	r19, r1
    1854:	91 f5       	brne	.+100    	; 0x18ba <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1856:	ce 01       	movw	r24, r28
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	0e 94 9f 1b 	call	0x373e	; 0x373e <_ZN10time_stamp10set_to_nowEv>
    185e:	bc 01       	movw	r22, r24
    1860:	f8 01       	movw	r30, r16
    1862:	86 81       	ldd	r24, Z+6	; 0x06
    1864:	97 81       	ldd	r25, Z+7	; 0x07
    1866:	0e 94 43 1b 	call	0x3686	; 0x3686 <_ZlsR8emstreamR10time_stamp>
    186a:	66 e0       	ldi	r22, 0x06	; 6
    186c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1870:	5e c0       	rjmp	.+188    	; 0x192e <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1872:	c8 01       	movw	r24, r16
    1874:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <_ZN9task_user11show_statusEv>
							break;
    1878:	5a c0       	rjmp	.+180    	; 0x192e <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    187a:	d8 01       	movw	r26, r16
    187c:	16 96       	adiw	r26, 0x06	; 6
    187e:	8d 91       	ld	r24, X+
    1880:	9c 91       	ld	r25, X
    1882:	17 97       	sbiw	r26, 0x07	; 7
    1884:	0e 94 03 19 	call	0x3206	; 0x3206 <_Z17print_task_stacksP8emstream>
							break;
    1888:	52 c0       	rjmp	.+164    	; 0x192e <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 4a 0a 	call	0x1494	; 0x1494 <_ZN9task_user18print_help_messageEv>
							break;
    1890:	4e c0       	rjmp	.+156    	; 0x192e <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1892:	6a e0       	ldi	r22, 0x0A	; 10
    1894:	f8 01       	movw	r30, r16
    1896:	86 81       	ldd	r24, Z+6	; 0x06
    1898:	97 81       	ldd	r25, Z+7	; 0x07
    189a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    189e:	7c 01       	movw	r14, r24
    18a0:	6e e2       	ldi	r22, 0x2E	; 46
    18a2:	75 e0       	ldi	r23, 0x05	; 5
    18a4:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    18a8:	66 e0       	ldi	r22, 0x06	; 6
    18aa:	c7 01       	movw	r24, r14
    18ac:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    18b0:	60 e0       	ldi	r22, 0x00	; 0
    18b2:	c8 01       	movw	r24, r16
    18b4:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <_ZN8frt_task13transition_toEh>
							break;
    18b8:	3a c0       	rjmp	.+116    	; 0x192e <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    18ba:	f8 01       	movw	r30, r16
    18bc:	a6 81       	ldd	r26, Z+6	; 0x06
    18be:	b7 81       	ldd	r27, Z+7	; 0x07
    18c0:	ed 91       	ld	r30, X+
    18c2:	fc 91       	ld	r31, X
    18c4:	11 97       	sbiw	r26, 0x01	; 1
    18c6:	02 80       	ldd	r0, Z+2	; 0x02
    18c8:	f3 81       	ldd	r31, Z+3	; 0x03
    18ca:	e0 2d       	mov	r30, r0
    18cc:	68 2f       	mov	r22, r24
    18ce:	cd 01       	movw	r24, r26
    18d0:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    18d2:	6a e0       	ldi	r22, 0x0A	; 10
    18d4:	d8 01       	movw	r26, r16
    18d6:	16 96       	adiw	r26, 0x06	; 6
    18d8:	8d 91       	ld	r24, X+
    18da:	9c 91       	ld	r25, X
    18dc:	17 97       	sbiw	r26, 0x07	; 7
    18de:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    18e2:	7c 01       	movw	r14, r24
    18e4:	68 e2       	ldi	r22, 0x28	; 40
    18e6:	75 e0       	ldi	r23, 0x05	; 5
    18e8:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    18ec:	66 e0       	ldi	r22, 0x06	; 6
    18ee:	c7 01       	movw	r24, r14
    18f0:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
							break;
    18f4:	1c c0       	rjmp	.+56     	; 0x192e <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    18f6:	6a e0       	ldi	r22, 0x0A	; 10
    18f8:	f8 01       	movw	r30, r16
    18fa:	86 81       	ldd	r24, Z+6	; 0x06
    18fc:	97 81       	ldd	r25, Z+7	; 0x07
    18fe:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    1902:	8c 01       	movw	r16, r24
    1904:	6b e0       	ldi	r22, 0x0B	; 11
    1906:	75 e0       	ldi	r23, 0x05	; 5
    1908:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    190c:	66 e0       	ldi	r22, 0x06	; 6
    190e:	c8 01       	movw	r24, r16
    1910:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1914:	93 e0       	ldi	r25, 0x03	; 3
    1916:	88 ed       	ldi	r24, 0xD8	; 216
    1918:	08 b6       	in	r0, 0x38	; 56
    191a:	18 be       	out	0x38, r1	; 56
    191c:	84 bf       	out	0x34, r24	; 52
    191e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1922:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1926:	81 fd       	sbrc	r24, 1
    1928:	fc cf       	rjmp	.-8      	; 0x1922 <_ZN9task_user3runEv+0x228>
    192a:	08 be       	out	0x38, r0	; 56
    192c:	ff cf       	rjmp	.-2      	; 0x192c <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    192e:	f8 01       	movw	r30, r16
    1930:	86 85       	ldd	r24, Z+14	; 0x0e
    1932:	97 85       	ldd	r25, Z+15	; 0x0f
    1934:	a0 89       	ldd	r26, Z+16	; 0x10
    1936:	b1 89       	ldd	r27, Z+17	; 0x11
    1938:	01 96       	adiw	r24, 0x01	; 1
    193a:	a1 1d       	adc	r26, r1
    193c:	b1 1d       	adc	r27, r1
    193e:	86 87       	std	Z+14, r24	; 0x0e
    1940:	97 87       	std	Z+15, r25	; 0x0f
    1942:	a0 8b       	std	Z+16, r26	; 0x10
    1944:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1946:	61 e0       	ldi	r22, 0x01	; 1
    1948:	70 e0       	ldi	r23, 0x00	; 0
    194a:	80 e0       	ldi	r24, 0x00	; 0
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1952:	f1 ce       	rjmp	.-542    	; 0x1736 <_ZN9task_user3runEv+0x3c>

00001954 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1954:	0f 93       	push	r16
    1956:	1f 93       	push	r17
    1958:	cf 93       	push	r28
    195a:	df 93       	push	r29
    195c:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    195e:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1962:	80 91 c6 21 	lds	r24, 0x21C6	; 0x8021c6 <__data_end>
    1966:	81 11       	cpse	r24, r1
    1968:	1d c0       	rjmp	.+58     	; 0x19a4 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    196a:	ab ec       	ldi	r26, 0xCB	; 203
    196c:	b1 e2       	ldi	r27, 0x21	; 33
    196e:	ef ec       	ldi	r30, 0xCF	; 207
    1970:	f1 e2       	ldi	r31, 0x21	; 33
    1972:	ed 93       	st	X+, r30
    1974:	fc 93       	st	X, r31
    1976:	11 97       	sbiw	r26, 0x01	; 1
    1978:	12 96       	adiw	r26, 0x02	; 2
    197a:	1d 92       	st	X+, r1
    197c:	1c 92       	st	X, r1
    197e:	13 97       	sbiw	r26, 0x03	; 3
    1980:	a7 ec       	ldi	r26, 0xC7	; 199
    1982:	b1 e2       	ldi	r27, 0x21	; 33
    1984:	8f ef       	ldi	r24, 0xFF	; 255
    1986:	9f e0       	ldi	r25, 0x0F	; 15
    1988:	12 96       	adiw	r26, 0x02	; 2
    198a:	8d 93       	st	X+, r24
    198c:	9c 93       	st	X, r25
    198e:	13 97       	sbiw	r26, 0x03	; 3
    1990:	1d 92       	st	X+, r1
    1992:	1c 92       	st	X, r1
    1994:	11 97       	sbiw	r26, 0x01	; 1
    1996:	82 83       	std	Z+2, r24	; 0x02
    1998:	93 83       	std	Z+3, r25	; 0x03
    199a:	a0 83       	st	Z, r26
    199c:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    199e:	81 e0       	ldi	r24, 0x01	; 1
    19a0:	80 93 c6 21 	sts	0x21C6, r24	; 0x8021c6 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    19a4:	20 97       	sbiw	r28, 0x00	; 0
    19a6:	09 f4       	brne	.+2      	; 0x19aa <pvPortMalloc+0x56>
    19a8:	5f c0       	rjmp	.+190    	; 0x1a68 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    19aa:	9e 01       	movw	r18, r28
    19ac:	2b 5f       	subi	r18, 0xFB	; 251
    19ae:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    19b0:	24 96       	adiw	r28, 0x04	; 4
    19b2:	ce 3f       	cpi	r28, 0xFE	; 254
    19b4:	df 40       	sbci	r29, 0x0F	; 15
    19b6:	08 f0       	brcs	.+2      	; 0x19ba <pvPortMalloc+0x66>
    19b8:	5a c0       	rjmp	.+180    	; 0x1a6e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    19ba:	e0 91 cb 21 	lds	r30, 0x21CB	; 0x8021cb <xStart>
    19be:	f0 91 cc 21 	lds	r31, 0x21CC	; 0x8021cc <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    19c2:	ab ec       	ldi	r26, 0xCB	; 203
    19c4:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19c6:	02 c0       	rjmp	.+4      	; 0x19cc <pvPortMalloc+0x78>
    19c8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    19ca:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19cc:	82 81       	ldd	r24, Z+2	; 0x02
    19ce:	93 81       	ldd	r25, Z+3	; 0x03
    19d0:	82 17       	cp	r24, r18
    19d2:	93 07       	cpc	r25, r19
    19d4:	20 f4       	brcc	.+8      	; 0x19de <pvPortMalloc+0x8a>
    19d6:	80 81       	ld	r24, Z
    19d8:	91 81       	ldd	r25, Z+1	; 0x01
    19da:	00 97       	sbiw	r24, 0x00	; 0
    19dc:	a9 f7       	brne	.-22     	; 0x19c8 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    19de:	c1 e2       	ldi	r28, 0x21	; 33
    19e0:	e7 3c       	cpi	r30, 0xC7	; 199
    19e2:	fc 07       	cpc	r31, r28
    19e4:	09 f4       	brne	.+2      	; 0x19e8 <pvPortMalloc+0x94>
    19e6:	46 c0       	rjmp	.+140    	; 0x1a74 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    19e8:	cd 91       	ld	r28, X+
    19ea:	dc 91       	ld	r29, X
    19ec:	11 97       	sbiw	r26, 0x01	; 1
    19ee:	8e 01       	movw	r16, r28
    19f0:	0b 5f       	subi	r16, 0xFB	; 251
    19f2:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    19f4:	80 81       	ld	r24, Z
    19f6:	91 81       	ldd	r25, Z+1	; 0x01
    19f8:	8d 93       	st	X+, r24
    19fa:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    19fc:	82 81       	ldd	r24, Z+2	; 0x02
    19fe:	93 81       	ldd	r25, Z+3	; 0x03
    1a00:	82 1b       	sub	r24, r18
    1a02:	93 0b       	sbc	r25, r19
    1a04:	8b 30       	cpi	r24, 0x0B	; 11
    1a06:	91 05       	cpc	r25, r1
    1a08:	10 f1       	brcs	.+68     	; 0x1a4e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1a0a:	bf 01       	movw	r22, r30
    1a0c:	62 0f       	add	r22, r18
    1a0e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1a10:	db 01       	movw	r26, r22
    1a12:	12 96       	adiw	r26, 0x02	; 2
    1a14:	8d 93       	st	X+, r24
    1a16:	9c 93       	st	X, r25
    1a18:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1a1a:	22 83       	std	Z+2, r18	; 0x02
    1a1c:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1a1e:	12 96       	adiw	r26, 0x02	; 2
    1a20:	4d 91       	ld	r20, X+
    1a22:	5c 91       	ld	r21, X
    1a24:	13 97       	sbiw	r26, 0x03	; 3
    1a26:	8b ec       	ldi	r24, 0xCB	; 203
    1a28:	91 e2       	ldi	r25, 0x21	; 33
    1a2a:	01 c0       	rjmp	.+2      	; 0x1a2e <pvPortMalloc+0xda>
    1a2c:	cd 01       	movw	r24, r26
    1a2e:	ec 01       	movw	r28, r24
    1a30:	a8 81       	ld	r26, Y
    1a32:	b9 81       	ldd	r27, Y+1	; 0x01
    1a34:	12 96       	adiw	r26, 0x02	; 2
    1a36:	2d 91       	ld	r18, X+
    1a38:	3c 91       	ld	r19, X
    1a3a:	13 97       	sbiw	r26, 0x03	; 3
    1a3c:	24 17       	cp	r18, r20
    1a3e:	35 07       	cpc	r19, r21
    1a40:	a8 f3       	brcs	.-22     	; 0x1a2c <pvPortMalloc+0xd8>
    1a42:	eb 01       	movw	r28, r22
    1a44:	a8 83       	st	Y, r26
    1a46:	b9 83       	std	Y+1, r27	; 0x01
    1a48:	dc 01       	movw	r26, r24
    1a4a:	6d 93       	st	X+, r22
    1a4c:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1a4e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a52:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a56:	22 81       	ldd	r18, Z+2	; 0x02
    1a58:	33 81       	ldd	r19, Z+3	; 0x03
    1a5a:	82 1b       	sub	r24, r18
    1a5c:	93 0b       	sbc	r25, r19
    1a5e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a62:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1a66:	08 c0       	rjmp	.+16     	; 0x1a78 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1a68:	00 e0       	ldi	r16, 0x00	; 0
    1a6a:	10 e0       	ldi	r17, 0x00	; 0
    1a6c:	05 c0       	rjmp	.+10     	; 0x1a78 <pvPortMalloc+0x124>
    1a6e:	00 e0       	ldi	r16, 0x00	; 0
    1a70:	10 e0       	ldi	r17, 0x00	; 0
    1a72:	02 c0       	rjmp	.+4      	; 0x1a78 <pvPortMalloc+0x124>
    1a74:	00 e0       	ldi	r16, 0x00	; 0
    1a76:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1a78:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a7c:	c8 01       	movw	r24, r16
    1a7e:	df 91       	pop	r29
    1a80:	cf 91       	pop	r28
    1a82:	1f 91       	pop	r17
    1a84:	0f 91       	pop	r16
    1a86:	08 95       	ret

00001a88 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a88:	0f 93       	push	r16
    1a8a:	1f 93       	push	r17
    1a8c:	cf 93       	push	r28
    1a8e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1a90:	00 97       	sbiw	r24, 0x00	; 0
    1a92:	41 f1       	breq	.+80     	; 0x1ae4 <vPortFree+0x5c>
    1a94:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1a96:	8c 01       	movw	r16, r24
    1a98:	05 50       	subi	r16, 0x05	; 5
    1a9a:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1a9c:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1aa0:	f8 01       	movw	r30, r16
    1aa2:	42 81       	ldd	r20, Z+2	; 0x02
    1aa4:	53 81       	ldd	r21, Z+3	; 0x03
    1aa6:	ab ec       	ldi	r26, 0xCB	; 203
    1aa8:	b1 e2       	ldi	r27, 0x21	; 33
    1aaa:	01 c0       	rjmp	.+2      	; 0x1aae <vPortFree+0x26>
    1aac:	df 01       	movw	r26, r30
    1aae:	ed 91       	ld	r30, X+
    1ab0:	fc 91       	ld	r31, X
    1ab2:	11 97       	sbiw	r26, 0x01	; 1
    1ab4:	22 81       	ldd	r18, Z+2	; 0x02
    1ab6:	33 81       	ldd	r19, Z+3	; 0x03
    1ab8:	24 17       	cp	r18, r20
    1aba:	35 07       	cpc	r19, r21
    1abc:	b8 f3       	brcs	.-18     	; 0x1aac <vPortFree+0x24>
    1abe:	25 97       	sbiw	r28, 0x05	; 5
    1ac0:	e8 83       	st	Y, r30
    1ac2:	f9 83       	std	Y+1, r31	; 0x01
    1ac4:	0d 93       	st	X+, r16
    1ac6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1ac8:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1acc:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1ad0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad4:	82 0f       	add	r24, r18
    1ad6:	93 1f       	adc	r25, r19
    1ad8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1adc:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1ae0:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
	}
}
    1ae4:	df 91       	pop	r29
    1ae6:	cf 91       	pop	r28
    1ae8:	1f 91       	pop	r17
    1aea:	0f 91       	pop	r16
    1aec:	08 95       	ret

00001aee <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1aee:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1af2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1af6:	08 95       	ret

00001af8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1af8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1afa:	03 96       	adiw	r24, 0x03	; 3
    1afc:	81 83       	std	Z+1, r24	; 0x01
    1afe:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b00:	4f ef       	ldi	r20, 0xFF	; 255
    1b02:	5f ef       	ldi	r21, 0xFF	; 255
    1b04:	ba 01       	movw	r22, r20
    1b06:	43 83       	std	Z+3, r20	; 0x03
    1b08:	54 83       	std	Z+4, r21	; 0x04
    1b0a:	65 83       	std	Z+5, r22	; 0x05
    1b0c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1b0e:	87 83       	std	Z+7, r24	; 0x07
    1b10:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1b12:	81 87       	std	Z+9, r24	; 0x09
    1b14:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1b16:	10 82       	st	Z, r1
    1b18:	08 95       	ret

00001b1a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b1a:	fc 01       	movw	r30, r24
    1b1c:	12 86       	std	Z+10, r1	; 0x0a
    1b1e:	13 86       	std	Z+11, r1	; 0x0b
    1b20:	08 95       	ret

00001b22 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1b22:	cf 93       	push	r28
    1b24:	df 93       	push	r29
    1b26:	fc 01       	movw	r30, r24
    1b28:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1b2a:	21 81       	ldd	r18, Z+1	; 0x01
    1b2c:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1b2e:	e9 01       	movw	r28, r18
    1b30:	8c 81       	ldd	r24, Y+4	; 0x04
    1b32:	9d 81       	ldd	r25, Y+5	; 0x05
    1b34:	14 96       	adiw	r26, 0x04	; 4
    1b36:	8d 93       	st	X+, r24
    1b38:	9c 93       	st	X, r25
    1b3a:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1b3c:	81 81       	ldd	r24, Z+1	; 0x01
    1b3e:	92 81       	ldd	r25, Z+2	; 0x02
    1b40:	16 96       	adiw	r26, 0x06	; 6
    1b42:	8d 93       	st	X+, r24
    1b44:	9c 93       	st	X, r25
    1b46:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b48:	8c 81       	ldd	r24, Y+4	; 0x04
    1b4a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b4c:	ec 01       	movw	r28, r24
    1b4e:	6e 83       	std	Y+6, r22	; 0x06
    1b50:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b52:	e9 01       	movw	r28, r18
    1b54:	6c 83       	std	Y+4, r22	; 0x04
    1b56:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1b58:	61 83       	std	Z+1, r22	; 0x01
    1b5a:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b5c:	1a 96       	adiw	r26, 0x0a	; 10
    1b5e:	ed 93       	st	X+, r30
    1b60:	fc 93       	st	X, r31
    1b62:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1b64:	80 81       	ld	r24, Z
    1b66:	8f 5f       	subi	r24, 0xFF	; 255
    1b68:	80 83       	st	Z, r24
}
    1b6a:	df 91       	pop	r29
    1b6c:	cf 91       	pop	r28
    1b6e:	08 95       	ret

00001b70 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1b70:	0f 93       	push	r16
    1b72:	1f 93       	push	r17
    1b74:	cf 93       	push	r28
    1b76:	df 93       	push	r29
    1b78:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1b7a:	08 81       	ld	r16, Y
    1b7c:	19 81       	ldd	r17, Y+1	; 0x01
    1b7e:	2a 81       	ldd	r18, Y+2	; 0x02
    1b80:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b82:	0f 3f       	cpi	r16, 0xFF	; 255
    1b84:	4f ef       	ldi	r20, 0xFF	; 255
    1b86:	14 07       	cpc	r17, r20
    1b88:	24 07       	cpc	r18, r20
    1b8a:	34 07       	cpc	r19, r20
    1b8c:	31 f4       	brne	.+12     	; 0x1b9a <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1b8e:	dc 01       	movw	r26, r24
    1b90:	19 96       	adiw	r26, 0x09	; 9
    1b92:	ed 91       	ld	r30, X+
    1b94:	fc 91       	ld	r31, X
    1b96:	1a 97       	sbiw	r26, 0x0a	; 10
    1b98:	1f c0       	rjmp	.+62     	; 0x1bd8 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b9a:	fc 01       	movw	r30, r24
    1b9c:	33 96       	adiw	r30, 0x03	; 3
    1b9e:	dc 01       	movw	r26, r24
    1ba0:	17 96       	adiw	r26, 0x07	; 7
    1ba2:	4d 91       	ld	r20, X+
    1ba4:	5c 91       	ld	r21, X
    1ba6:	18 97       	sbiw	r26, 0x08	; 8
    1ba8:	da 01       	movw	r26, r20
    1baa:	4d 91       	ld	r20, X+
    1bac:	5d 91       	ld	r21, X+
    1bae:	6d 91       	ld	r22, X+
    1bb0:	7c 91       	ld	r23, X
    1bb2:	04 17       	cp	r16, r20
    1bb4:	15 07       	cpc	r17, r21
    1bb6:	26 07       	cpc	r18, r22
    1bb8:	37 07       	cpc	r19, r23
    1bba:	70 f0       	brcs	.+28     	; 0x1bd8 <vListInsert+0x68>
    1bbc:	04 80       	ldd	r0, Z+4	; 0x04
    1bbe:	f5 81       	ldd	r31, Z+5	; 0x05
    1bc0:	e0 2d       	mov	r30, r0
    1bc2:	a4 81       	ldd	r26, Z+4	; 0x04
    1bc4:	b5 81       	ldd	r27, Z+5	; 0x05
    1bc6:	4d 91       	ld	r20, X+
    1bc8:	5d 91       	ld	r21, X+
    1bca:	6d 91       	ld	r22, X+
    1bcc:	7c 91       	ld	r23, X
    1bce:	04 17       	cp	r16, r20
    1bd0:	15 07       	cpc	r17, r21
    1bd2:	26 07       	cpc	r18, r22
    1bd4:	37 07       	cpc	r19, r23
    1bd6:	90 f7       	brcc	.-28     	; 0x1bbc <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1bd8:	a4 81       	ldd	r26, Z+4	; 0x04
    1bda:	b5 81       	ldd	r27, Z+5	; 0x05
    1bdc:	ac 83       	std	Y+4, r26	; 0x04
    1bde:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1be0:	16 96       	adiw	r26, 0x06	; 6
    1be2:	cd 93       	st	X+, r28
    1be4:	dc 93       	st	X, r29
    1be6:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1be8:	ee 83       	std	Y+6, r30	; 0x06
    1bea:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1bec:	c4 83       	std	Z+4, r28	; 0x04
    1bee:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bf0:	8a 87       	std	Y+10, r24	; 0x0a
    1bf2:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1bf4:	fc 01       	movw	r30, r24
    1bf6:	20 81       	ld	r18, Z
    1bf8:	2f 5f       	subi	r18, 0xFF	; 255
    1bfa:	20 83       	st	Z, r18
}
    1bfc:	df 91       	pop	r29
    1bfe:	cf 91       	pop	r28
    1c00:	1f 91       	pop	r17
    1c02:	0f 91       	pop	r16
    1c04:	08 95       	ret

00001c06 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c06:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c08:	a4 81       	ldd	r26, Z+4	; 0x04
    1c0a:	b5 81       	ldd	r27, Z+5	; 0x05
    1c0c:	86 81       	ldd	r24, Z+6	; 0x06
    1c0e:	97 81       	ldd	r25, Z+7	; 0x07
    1c10:	16 96       	adiw	r26, 0x06	; 6
    1c12:	8d 93       	st	X+, r24
    1c14:	9c 93       	st	X, r25
    1c16:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c18:	a6 81       	ldd	r26, Z+6	; 0x06
    1c1a:	b7 81       	ldd	r27, Z+7	; 0x07
    1c1c:	84 81       	ldd	r24, Z+4	; 0x04
    1c1e:	95 81       	ldd	r25, Z+5	; 0x05
    1c20:	14 96       	adiw	r26, 0x04	; 4
    1c22:	8d 93       	st	X+, r24
    1c24:	9c 93       	st	X, r25
    1c26:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1c28:	a2 85       	ldd	r26, Z+10	; 0x0a
    1c2a:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c2c:	11 96       	adiw	r26, 0x01	; 1
    1c2e:	8d 91       	ld	r24, X+
    1c30:	9c 91       	ld	r25, X
    1c32:	12 97       	sbiw	r26, 0x02	; 2
    1c34:	e8 17       	cp	r30, r24
    1c36:	f9 07       	cpc	r31, r25
    1c38:	31 f4       	brne	.+12     	; 0x1c46 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c3a:	86 81       	ldd	r24, Z+6	; 0x06
    1c3c:	97 81       	ldd	r25, Z+7	; 0x07
    1c3e:	11 96       	adiw	r26, 0x01	; 1
    1c40:	8d 93       	st	X+, r24
    1c42:	9c 93       	st	X, r25
    1c44:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1c46:	12 86       	std	Z+10, r1	; 0x0a
    1c48:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1c4a:	8c 91       	ld	r24, X
    1c4c:	81 50       	subi	r24, 0x01	; 1
    1c4e:	8c 93       	st	X, r24
    1c50:	08 95       	ret

00001c52 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c52:	80 93 92 32 	sts	0x3292, r24	; 0x803292 <portStackTopForTask>
    1c56:	90 93 93 32 	sts	0x3293, r25	; 0x803293 <portStackTopForTask+0x1>
    1c5a:	31 e1       	ldi	r19, 0x11	; 17
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	30 83       	st	Z, r19
    1c60:	31 97       	sbiw	r30, 0x01	; 1
    1c62:	22 e2       	ldi	r18, 0x22	; 34
    1c64:	20 83       	st	Z, r18
    1c66:	31 97       	sbiw	r30, 0x01	; 1
    1c68:	a3 e3       	ldi	r26, 0x33	; 51
    1c6a:	a0 83       	st	Z, r26
    1c6c:	31 97       	sbiw	r30, 0x01	; 1
    1c6e:	60 83       	st	Z, r22
    1c70:	31 97       	sbiw	r30, 0x01	; 1
    1c72:	70 83       	st	Z, r23
    1c74:	31 97       	sbiw	r30, 0x01	; 1
    1c76:	10 82       	st	Z, r1
    1c78:	31 97       	sbiw	r30, 0x01	; 1
    1c7a:	10 82       	st	Z, r1
    1c7c:	31 97       	sbiw	r30, 0x01	; 1
    1c7e:	60 e8       	ldi	r22, 0x80	; 128
    1c80:	60 83       	st	Z, r22
    1c82:	31 97       	sbiw	r30, 0x01	; 1
    1c84:	10 82       	st	Z, r1
    1c86:	31 97       	sbiw	r30, 0x01	; 1
    1c88:	10 82       	st	Z, r1
    1c8a:	31 97       	sbiw	r30, 0x01	; 1
    1c8c:	10 82       	st	Z, r1
    1c8e:	31 97       	sbiw	r30, 0x01	; 1
    1c90:	62 e0       	ldi	r22, 0x02	; 2
    1c92:	60 83       	st	Z, r22
    1c94:	31 97       	sbiw	r30, 0x01	; 1
    1c96:	63 e0       	ldi	r22, 0x03	; 3
    1c98:	60 83       	st	Z, r22
    1c9a:	31 97       	sbiw	r30, 0x01	; 1
    1c9c:	64 e0       	ldi	r22, 0x04	; 4
    1c9e:	60 83       	st	Z, r22
    1ca0:	31 97       	sbiw	r30, 0x01	; 1
    1ca2:	65 e0       	ldi	r22, 0x05	; 5
    1ca4:	60 83       	st	Z, r22
    1ca6:	31 97       	sbiw	r30, 0x01	; 1
    1ca8:	66 e0       	ldi	r22, 0x06	; 6
    1caa:	60 83       	st	Z, r22
    1cac:	31 97       	sbiw	r30, 0x01	; 1
    1cae:	67 e0       	ldi	r22, 0x07	; 7
    1cb0:	60 83       	st	Z, r22
    1cb2:	31 97       	sbiw	r30, 0x01	; 1
    1cb4:	68 e0       	ldi	r22, 0x08	; 8
    1cb6:	60 83       	st	Z, r22
    1cb8:	31 97       	sbiw	r30, 0x01	; 1
    1cba:	69 e0       	ldi	r22, 0x09	; 9
    1cbc:	60 83       	st	Z, r22
    1cbe:	31 97       	sbiw	r30, 0x01	; 1
    1cc0:	60 e1       	ldi	r22, 0x10	; 16
    1cc2:	60 83       	st	Z, r22
    1cc4:	31 97       	sbiw	r30, 0x01	; 1
    1cc6:	30 83       	st	Z, r19
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	32 e1       	ldi	r19, 0x12	; 18
    1ccc:	30 83       	st	Z, r19
    1cce:	31 97       	sbiw	r30, 0x01	; 1
    1cd0:	33 e1       	ldi	r19, 0x13	; 19
    1cd2:	30 83       	st	Z, r19
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	34 e1       	ldi	r19, 0x14	; 20
    1cd8:	30 83       	st	Z, r19
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	35 e1       	ldi	r19, 0x15	; 21
    1cde:	30 83       	st	Z, r19
    1ce0:	31 97       	sbiw	r30, 0x01	; 1
    1ce2:	36 e1       	ldi	r19, 0x16	; 22
    1ce4:	30 83       	st	Z, r19
    1ce6:	31 97       	sbiw	r30, 0x01	; 1
    1ce8:	37 e1       	ldi	r19, 0x17	; 23
    1cea:	30 83       	st	Z, r19
    1cec:	31 97       	sbiw	r30, 0x01	; 1
    1cee:	38 e1       	ldi	r19, 0x18	; 24
    1cf0:	30 83       	st	Z, r19
    1cf2:	31 97       	sbiw	r30, 0x01	; 1
    1cf4:	39 e1       	ldi	r19, 0x19	; 25
    1cf6:	30 83       	st	Z, r19
    1cf8:	31 97       	sbiw	r30, 0x01	; 1
    1cfa:	30 e2       	ldi	r19, 0x20	; 32
    1cfc:	30 83       	st	Z, r19
    1cfe:	31 97       	sbiw	r30, 0x01	; 1
    1d00:	31 e2       	ldi	r19, 0x21	; 33
    1d02:	30 83       	st	Z, r19
    1d04:	31 97       	sbiw	r30, 0x01	; 1
    1d06:	20 83       	st	Z, r18
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	23 e2       	ldi	r18, 0x23	; 35
    1d0c:	20 83       	st	Z, r18
    1d0e:	31 97       	sbiw	r30, 0x01	; 1
    1d10:	40 83       	st	Z, r20
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	50 83       	st	Z, r21
    1d16:	31 97       	sbiw	r30, 0x01	; 1
    1d18:	26 e2       	ldi	r18, 0x26	; 38
    1d1a:	20 83       	st	Z, r18
    1d1c:	31 97       	sbiw	r30, 0x01	; 1
    1d1e:	27 e2       	ldi	r18, 0x27	; 39
    1d20:	20 83       	st	Z, r18
    1d22:	31 97       	sbiw	r30, 0x01	; 1
    1d24:	28 e2       	ldi	r18, 0x28	; 40
    1d26:	20 83       	st	Z, r18
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	29 e2       	ldi	r18, 0x29	; 41
    1d2c:	20 83       	st	Z, r18
    1d2e:	31 97       	sbiw	r30, 0x01	; 1
    1d30:	20 e3       	ldi	r18, 0x30	; 48
    1d32:	20 83       	st	Z, r18
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	21 e3       	ldi	r18, 0x31	; 49
    1d38:	20 83       	st	Z, r18
    1d3a:	89 97       	sbiw	r24, 0x29	; 41
    1d3c:	08 95       	ret

00001d3e <xPortStartScheduler>:
    1d3e:	8c e7       	ldi	r24, 0x7C	; 124
    1d40:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1d44:	8f ef       	ldi	r24, 0xFF	; 255
    1d46:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    1d4a:	81 e0       	ldi	r24, 0x01	; 1
    1d4c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1d50:	91 e1       	ldi	r25, 0x11	; 17
    1d52:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1d56:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    1d5a:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1d5e:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1d62:	cd 91       	ld	r28, X+
    1d64:	cd bf       	out	0x3d, r28	; 61
    1d66:	dd 91       	ld	r29, X+
    1d68:	de bf       	out	0x3e, r29	; 62
    1d6a:	ff 91       	pop	r31
    1d6c:	ef 91       	pop	r30
    1d6e:	df 91       	pop	r29
    1d70:	cf 91       	pop	r28
    1d72:	bf 91       	pop	r27
    1d74:	af 91       	pop	r26
    1d76:	9f 91       	pop	r25
    1d78:	8f 91       	pop	r24
    1d7a:	7f 91       	pop	r23
    1d7c:	6f 91       	pop	r22
    1d7e:	5f 91       	pop	r21
    1d80:	4f 91       	pop	r20
    1d82:	3f 91       	pop	r19
    1d84:	2f 91       	pop	r18
    1d86:	1f 91       	pop	r17
    1d88:	0f 91       	pop	r16
    1d8a:	ff 90       	pop	r15
    1d8c:	ef 90       	pop	r14
    1d8e:	df 90       	pop	r13
    1d90:	cf 90       	pop	r12
    1d92:	bf 90       	pop	r11
    1d94:	af 90       	pop	r10
    1d96:	9f 90       	pop	r9
    1d98:	8f 90       	pop	r8
    1d9a:	7f 90       	pop	r7
    1d9c:	6f 90       	pop	r6
    1d9e:	5f 90       	pop	r5
    1da0:	4f 90       	pop	r4
    1da2:	3f 90       	pop	r3
    1da4:	2f 90       	pop	r2
    1da6:	1f 90       	pop	r1
    1da8:	0f 90       	pop	r0
    1daa:	0c be       	out	0x3c, r0	; 60
    1dac:	0f 90       	pop	r0
    1dae:	0b be       	out	0x3b, r0	; 59
    1db0:	0f 90       	pop	r0
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	0f 90       	pop	r0
    1db6:	08 95       	ret
    1db8:	08 95       	ret

00001dba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1dba:	0f 92       	push	r0
    1dbc:	0f b6       	in	r0, 0x3f	; 63
    1dbe:	f8 94       	cli
    1dc0:	0f 92       	push	r0
    1dc2:	0b b6       	in	r0, 0x3b	; 59
    1dc4:	0f 92       	push	r0
    1dc6:	0c b6       	in	r0, 0x3c	; 60
    1dc8:	0f 92       	push	r0
    1dca:	1f 92       	push	r1
    1dcc:	11 24       	eor	r1, r1
    1dce:	2f 92       	push	r2
    1dd0:	3f 92       	push	r3
    1dd2:	4f 92       	push	r4
    1dd4:	5f 92       	push	r5
    1dd6:	6f 92       	push	r6
    1dd8:	7f 92       	push	r7
    1dda:	8f 92       	push	r8
    1ddc:	9f 92       	push	r9
    1dde:	af 92       	push	r10
    1de0:	bf 92       	push	r11
    1de2:	cf 92       	push	r12
    1de4:	df 92       	push	r13
    1de6:	ef 92       	push	r14
    1de8:	ff 92       	push	r15
    1dea:	0f 93       	push	r16
    1dec:	1f 93       	push	r17
    1dee:	2f 93       	push	r18
    1df0:	3f 93       	push	r19
    1df2:	4f 93       	push	r20
    1df4:	5f 93       	push	r21
    1df6:	6f 93       	push	r22
    1df8:	7f 93       	push	r23
    1dfa:	8f 93       	push	r24
    1dfc:	9f 93       	push	r25
    1dfe:	af 93       	push	r26
    1e00:	bf 93       	push	r27
    1e02:	cf 93       	push	r28
    1e04:	df 93       	push	r29
    1e06:	ef 93       	push	r30
    1e08:	ff 93       	push	r31
    1e0a:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1e0e:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1e12:	0d b6       	in	r0, 0x3d	; 61
    1e14:	0d 92       	st	X+, r0
    1e16:	0e b6       	in	r0, 0x3e	; 62
    1e18:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1e1a:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e1e:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1e22:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1e26:	cd 91       	ld	r28, X+
    1e28:	cd bf       	out	0x3d, r28	; 61
    1e2a:	dd 91       	ld	r29, X+
    1e2c:	de bf       	out	0x3e, r29	; 62
    1e2e:	ff 91       	pop	r31
    1e30:	ef 91       	pop	r30
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	bf 91       	pop	r27
    1e38:	af 91       	pop	r26
    1e3a:	9f 91       	pop	r25
    1e3c:	8f 91       	pop	r24
    1e3e:	7f 91       	pop	r23
    1e40:	6f 91       	pop	r22
    1e42:	5f 91       	pop	r21
    1e44:	4f 91       	pop	r20
    1e46:	3f 91       	pop	r19
    1e48:	2f 91       	pop	r18
    1e4a:	1f 91       	pop	r17
    1e4c:	0f 91       	pop	r16
    1e4e:	ff 90       	pop	r15
    1e50:	ef 90       	pop	r14
    1e52:	df 90       	pop	r13
    1e54:	cf 90       	pop	r12
    1e56:	bf 90       	pop	r11
    1e58:	af 90       	pop	r10
    1e5a:	9f 90       	pop	r9
    1e5c:	8f 90       	pop	r8
    1e5e:	7f 90       	pop	r7
    1e60:	6f 90       	pop	r6
    1e62:	5f 90       	pop	r5
    1e64:	4f 90       	pop	r4
    1e66:	3f 90       	pop	r3
    1e68:	2f 90       	pop	r2
    1e6a:	1f 90       	pop	r1
    1e6c:	0f 90       	pop	r0
    1e6e:	0c be       	out	0x3c, r0	; 60
    1e70:	0f 90       	pop	r0
    1e72:	0b be       	out	0x3b, r0	; 59
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e7a:	08 95       	ret

00001e7c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e7c:	0f 92       	push	r0
    1e7e:	0f b6       	in	r0, 0x3f	; 63
    1e80:	f8 94       	cli
    1e82:	0f 92       	push	r0
    1e84:	0b b6       	in	r0, 0x3b	; 59
    1e86:	0f 92       	push	r0
    1e88:	0c b6       	in	r0, 0x3c	; 60
    1e8a:	0f 92       	push	r0
    1e8c:	1f 92       	push	r1
    1e8e:	11 24       	eor	r1, r1
    1e90:	2f 92       	push	r2
    1e92:	3f 92       	push	r3
    1e94:	4f 92       	push	r4
    1e96:	5f 92       	push	r5
    1e98:	6f 92       	push	r6
    1e9a:	7f 92       	push	r7
    1e9c:	8f 92       	push	r8
    1e9e:	9f 92       	push	r9
    1ea0:	af 92       	push	r10
    1ea2:	bf 92       	push	r11
    1ea4:	cf 92       	push	r12
    1ea6:	df 92       	push	r13
    1ea8:	ef 92       	push	r14
    1eaa:	ff 92       	push	r15
    1eac:	0f 93       	push	r16
    1eae:	1f 93       	push	r17
    1eb0:	2f 93       	push	r18
    1eb2:	3f 93       	push	r19
    1eb4:	4f 93       	push	r20
    1eb6:	5f 93       	push	r21
    1eb8:	6f 93       	push	r22
    1eba:	7f 93       	push	r23
    1ebc:	8f 93       	push	r24
    1ebe:	9f 93       	push	r25
    1ec0:	af 93       	push	r26
    1ec2:	bf 93       	push	r27
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	ef 93       	push	r30
    1eca:	ff 93       	push	r31
    1ecc:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1ed0:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1ed4:	0d b6       	in	r0, 0x3d	; 61
    1ed6:	0d 92       	st	X+, r0
    1ed8:	0e b6       	in	r0, 0x3e	; 62
    1eda:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1edc:	0e 94 3b 14 	call	0x2876	; 0x2876 <vTaskIncrementTick>
	vTaskSwitchContext();
    1ee0:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1ee4:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1ee8:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1eec:	cd 91       	ld	r28, X+
    1eee:	cd bf       	out	0x3d, r28	; 61
    1ef0:	dd 91       	ld	r29, X+
    1ef2:	de bf       	out	0x3e, r29	; 62
    1ef4:	ff 91       	pop	r31
    1ef6:	ef 91       	pop	r30
    1ef8:	df 91       	pop	r29
    1efa:	cf 91       	pop	r28
    1efc:	bf 91       	pop	r27
    1efe:	af 91       	pop	r26
    1f00:	9f 91       	pop	r25
    1f02:	8f 91       	pop	r24
    1f04:	7f 91       	pop	r23
    1f06:	6f 91       	pop	r22
    1f08:	5f 91       	pop	r21
    1f0a:	4f 91       	pop	r20
    1f0c:	3f 91       	pop	r19
    1f0e:	2f 91       	pop	r18
    1f10:	1f 91       	pop	r17
    1f12:	0f 91       	pop	r16
    1f14:	ff 90       	pop	r15
    1f16:	ef 90       	pop	r14
    1f18:	df 90       	pop	r13
    1f1a:	cf 90       	pop	r12
    1f1c:	bf 90       	pop	r11
    1f1e:	af 90       	pop	r10
    1f20:	9f 90       	pop	r9
    1f22:	8f 90       	pop	r8
    1f24:	7f 90       	pop	r7
    1f26:	6f 90       	pop	r6
    1f28:	5f 90       	pop	r5
    1f2a:	4f 90       	pop	r4
    1f2c:	3f 90       	pop	r3
    1f2e:	2f 90       	pop	r2
    1f30:	1f 90       	pop	r1
    1f32:	0f 90       	pop	r0
    1f34:	0c be       	out	0x3c, r0	; 60
    1f36:	0f 90       	pop	r0
    1f38:	0b be       	out	0x3b, r0	; 59
    1f3a:	0f 90       	pop	r0
    1f3c:	0f be       	out	0x3f, r0	; 63
    1f3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1f40:	08 95       	ret

00001f42 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1f42:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f46:	18 95       	reti

00001f48 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
    1f4c:	ec 01       	movw	r28, r24
    1f4e:	88 a1       	ldd	r24, Y+32	; 0x20
    1f50:	81 11       	cpse	r24, r1
    1f52:	0b c0       	rjmp	.+22     	; 0x1f6a <prvCopyDataToQueue+0x22>
    1f54:	88 81       	ld	r24, Y
    1f56:	99 81       	ldd	r25, Y+1	; 0x01
    1f58:	89 2b       	or	r24, r25
    1f5a:	e1 f5       	brne	.+120    	; 0x1fd4 <prvCopyDataToQueue+0x8c>
    1f5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1f60:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <vTaskPriorityDisinherit>
    1f64:	1a 82       	std	Y+2, r1	; 0x02
    1f66:	1b 82       	std	Y+3, r1	; 0x03
    1f68:	35 c0       	rjmp	.+106    	; 0x1fd4 <prvCopyDataToQueue+0x8c>
    1f6a:	41 11       	cpse	r20, r1
    1f6c:	17 c0       	rjmp	.+46     	; 0x1f9c <prvCopyDataToQueue+0x54>
    1f6e:	48 2f       	mov	r20, r24
    1f70:	50 e0       	ldi	r21, 0x00	; 0
    1f72:	8c 81       	ldd	r24, Y+4	; 0x04
    1f74:	9d 81       	ldd	r25, Y+5	; 0x05
    1f76:	0e 94 dc 24 	call	0x49b8	; 0x49b8 <memcpy>
    1f7a:	28 a1       	ldd	r18, Y+32	; 0x20
    1f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f80:	82 0f       	add	r24, r18
    1f82:	91 1d       	adc	r25, r1
    1f84:	8c 83       	std	Y+4, r24	; 0x04
    1f86:	9d 83       	std	Y+5, r25	; 0x05
    1f88:	2a 81       	ldd	r18, Y+2	; 0x02
    1f8a:	3b 81       	ldd	r19, Y+3	; 0x03
    1f8c:	82 17       	cp	r24, r18
    1f8e:	93 07       	cpc	r25, r19
    1f90:	08 f1       	brcs	.+66     	; 0x1fd4 <prvCopyDataToQueue+0x8c>
    1f92:	88 81       	ld	r24, Y
    1f94:	99 81       	ldd	r25, Y+1	; 0x01
    1f96:	8c 83       	std	Y+4, r24	; 0x04
    1f98:	9d 83       	std	Y+5, r25	; 0x05
    1f9a:	1c c0       	rjmp	.+56     	; 0x1fd4 <prvCopyDataToQueue+0x8c>
    1f9c:	48 2f       	mov	r20, r24
    1f9e:	50 e0       	ldi	r21, 0x00	; 0
    1fa0:	8e 81       	ldd	r24, Y+6	; 0x06
    1fa2:	9f 81       	ldd	r25, Y+7	; 0x07
    1fa4:	0e 94 dc 24 	call	0x49b8	; 0x49b8 <memcpy>
    1fa8:	88 a1       	ldd	r24, Y+32	; 0x20
    1faa:	90 e0       	ldi	r25, 0x00	; 0
    1fac:	91 95       	neg	r25
    1fae:	81 95       	neg	r24
    1fb0:	91 09       	sbc	r25, r1
    1fb2:	2e 81       	ldd	r18, Y+6	; 0x06
    1fb4:	3f 81       	ldd	r19, Y+7	; 0x07
    1fb6:	28 0f       	add	r18, r24
    1fb8:	39 1f       	adc	r19, r25
    1fba:	2e 83       	std	Y+6, r18	; 0x06
    1fbc:	3f 83       	std	Y+7, r19	; 0x07
    1fbe:	48 81       	ld	r20, Y
    1fc0:	59 81       	ldd	r21, Y+1	; 0x01
    1fc2:	24 17       	cp	r18, r20
    1fc4:	35 07       	cpc	r19, r21
    1fc6:	30 f4       	brcc	.+12     	; 0x1fd4 <prvCopyDataToQueue+0x8c>
    1fc8:	2a 81       	ldd	r18, Y+2	; 0x02
    1fca:	3b 81       	ldd	r19, Y+3	; 0x03
    1fcc:	82 0f       	add	r24, r18
    1fce:	93 1f       	adc	r25, r19
    1fd0:	8e 83       	std	Y+6, r24	; 0x06
    1fd2:	9f 83       	std	Y+7, r25	; 0x07
    1fd4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fd6:	8f 5f       	subi	r24, 0xFF	; 255
    1fd8:	8e 8f       	std	Y+30, r24	; 0x1e
    1fda:	df 91       	pop	r29
    1fdc:	cf 91       	pop	r28
    1fde:	08 95       	ret

00001fe0 <prvCopyDataFromQueue>:
    1fe0:	fc 01       	movw	r30, r24
    1fe2:	80 81       	ld	r24, Z
    1fe4:	91 81       	ldd	r25, Z+1	; 0x01
    1fe6:	00 97       	sbiw	r24, 0x00	; 0
    1fe8:	a1 f0       	breq	.+40     	; 0x2012 <prvCopyDataFromQueue+0x32>
    1fea:	40 a1       	ldd	r20, Z+32	; 0x20
    1fec:	50 e0       	ldi	r21, 0x00	; 0
    1fee:	26 81       	ldd	r18, Z+6	; 0x06
    1ff0:	37 81       	ldd	r19, Z+7	; 0x07
    1ff2:	24 0f       	add	r18, r20
    1ff4:	35 1f       	adc	r19, r21
    1ff6:	26 83       	std	Z+6, r18	; 0x06
    1ff8:	37 83       	std	Z+7, r19	; 0x07
    1ffa:	a2 81       	ldd	r26, Z+2	; 0x02
    1ffc:	b3 81       	ldd	r27, Z+3	; 0x03
    1ffe:	2a 17       	cp	r18, r26
    2000:	3b 07       	cpc	r19, r27
    2002:	10 f0       	brcs	.+4      	; 0x2008 <prvCopyDataFromQueue+0x28>
    2004:	86 83       	std	Z+6, r24	; 0x06
    2006:	97 83       	std	Z+7, r25	; 0x07
    2008:	cb 01       	movw	r24, r22
    200a:	66 81       	ldd	r22, Z+6	; 0x06
    200c:	77 81       	ldd	r23, Z+7	; 0x07
    200e:	0e 94 dc 24 	call	0x49b8	; 0x49b8 <memcpy>
    2012:	08 95       	ret

00002014 <prvUnlockQueue>:
    2014:	0f 93       	push	r16
    2016:	1f 93       	push	r17
    2018:	cf 93       	push	r28
    201a:	df 93       	push	r29
    201c:	ec 01       	movw	r28, r24
    201e:	0f b6       	in	r0, 0x3f	; 63
    2020:	f8 94       	cli
    2022:	0f 92       	push	r0
    2024:	8a a1       	ldd	r24, Y+34	; 0x22
    2026:	18 16       	cp	r1, r24
    2028:	b4 f4       	brge	.+44     	; 0x2056 <prvUnlockQueue+0x42>
    202a:	8b 89       	ldd	r24, Y+19	; 0x13
    202c:	81 11       	cpse	r24, r1
    202e:	05 c0       	rjmp	.+10     	; 0x203a <prvUnlockQueue+0x26>
    2030:	12 c0       	rjmp	.+36     	; 0x2056 <prvUnlockQueue+0x42>
    2032:	8b 89       	ldd	r24, Y+19	; 0x13
    2034:	81 11       	cpse	r24, r1
    2036:	04 c0       	rjmp	.+8      	; 0x2040 <prvUnlockQueue+0x2c>
    2038:	0e c0       	rjmp	.+28     	; 0x2056 <prvUnlockQueue+0x42>
    203a:	8e 01       	movw	r16, r28
    203c:	0d 5e       	subi	r16, 0xED	; 237
    203e:	1f 4f       	sbci	r17, 0xFF	; 255
    2040:	c8 01       	movw	r24, r16
    2042:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    2046:	81 11       	cpse	r24, r1
    2048:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vTaskMissedYield>
    204c:	8a a1       	ldd	r24, Y+34	; 0x22
    204e:	81 50       	subi	r24, 0x01	; 1
    2050:	8a a3       	std	Y+34, r24	; 0x22
    2052:	18 16       	cp	r1, r24
    2054:	74 f3       	brlt	.-36     	; 0x2032 <prvUnlockQueue+0x1e>
    2056:	8f ef       	ldi	r24, 0xFF	; 255
    2058:	8a a3       	std	Y+34, r24	; 0x22
    205a:	0f 90       	pop	r0
    205c:	0f be       	out	0x3f, r0	; 63
    205e:	0f b6       	in	r0, 0x3f	; 63
    2060:	f8 94       	cli
    2062:	0f 92       	push	r0
    2064:	89 a1       	ldd	r24, Y+33	; 0x21
    2066:	18 16       	cp	r1, r24
    2068:	b4 f4       	brge	.+44     	; 0x2096 <prvUnlockQueue+0x82>
    206a:	88 85       	ldd	r24, Y+8	; 0x08
    206c:	81 11       	cpse	r24, r1
    206e:	05 c0       	rjmp	.+10     	; 0x207a <prvUnlockQueue+0x66>
    2070:	12 c0       	rjmp	.+36     	; 0x2096 <prvUnlockQueue+0x82>
    2072:	88 85       	ldd	r24, Y+8	; 0x08
    2074:	81 11       	cpse	r24, r1
    2076:	04 c0       	rjmp	.+8      	; 0x2080 <prvUnlockQueue+0x6c>
    2078:	0e c0       	rjmp	.+28     	; 0x2096 <prvUnlockQueue+0x82>
    207a:	8e 01       	movw	r16, r28
    207c:	08 5f       	subi	r16, 0xF8	; 248
    207e:	1f 4f       	sbci	r17, 0xFF	; 255
    2080:	c8 01       	movw	r24, r16
    2082:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    2086:	81 11       	cpse	r24, r1
    2088:	0e 94 30 17 	call	0x2e60	; 0x2e60 <vTaskMissedYield>
    208c:	89 a1       	ldd	r24, Y+33	; 0x21
    208e:	81 50       	subi	r24, 0x01	; 1
    2090:	89 a3       	std	Y+33, r24	; 0x21
    2092:	18 16       	cp	r1, r24
    2094:	74 f3       	brlt	.-36     	; 0x2072 <prvUnlockQueue+0x5e>
    2096:	8f ef       	ldi	r24, 0xFF	; 255
    2098:	89 a3       	std	Y+33, r24	; 0x21
    209a:	0f 90       	pop	r0
    209c:	0f be       	out	0x3f, r0	; 63
    209e:	df 91       	pop	r29
    20a0:	cf 91       	pop	r28
    20a2:	1f 91       	pop	r17
    20a4:	0f 91       	pop	r16
    20a6:	08 95       	ret

000020a8 <xQueueGenericReset>:
    20a8:	1f 93       	push	r17
    20aa:	cf 93       	push	r28
    20ac:	df 93       	push	r29
    20ae:	61 30       	cpi	r22, 0x01	; 1
    20b0:	59 f0       	breq	.+22     	; 0x20c8 <xQueueGenericReset+0x20>
    20b2:	fc 01       	movw	r30, r24
    20b4:	23 89       	ldd	r18, Z+19	; 0x13
    20b6:	30 85       	ldd	r19, Z+8	; 0x08
    20b8:	31 11       	cpse	r19, r1
    20ba:	2c c0       	rjmp	.+88     	; 0x2114 <xQueueGenericReset+0x6c>
    20bc:	11 e0       	ldi	r17, 0x01	; 1
    20be:	21 11       	cpse	r18, r1
    20c0:	10 e0       	ldi	r17, 0x00	; 0
    20c2:	21 11       	cpse	r18, r1
    20c4:	28 c0       	rjmp	.+80     	; 0x2116 <xQueueGenericReset+0x6e>
    20c6:	01 c0       	rjmp	.+2      	; 0x20ca <xQueueGenericReset+0x22>
    20c8:	11 e0       	ldi	r17, 0x01	; 1
    20ca:	ec 01       	movw	r28, r24
    20cc:	48 81       	ld	r20, Y
    20ce:	59 81       	ldd	r21, Y+1	; 0x01
    20d0:	28 a1       	ldd	r18, Y+32	; 0x20
    20d2:	30 e0       	ldi	r19, 0x00	; 0
    20d4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    20d6:	62 9f       	mul	r22, r18
    20d8:	c0 01       	movw	r24, r0
    20da:	63 9f       	mul	r22, r19
    20dc:	90 0d       	add	r25, r0
    20de:	11 24       	eor	r1, r1
    20e0:	ba 01       	movw	r22, r20
    20e2:	68 0f       	add	r22, r24
    20e4:	79 1f       	adc	r23, r25
    20e6:	6a 83       	std	Y+2, r22	; 0x02
    20e8:	7b 83       	std	Y+3, r23	; 0x03
    20ea:	1e 8e       	std	Y+30, r1	; 0x1e
    20ec:	4c 83       	std	Y+4, r20	; 0x04
    20ee:	5d 83       	std	Y+5, r21	; 0x05
    20f0:	82 1b       	sub	r24, r18
    20f2:	93 0b       	sbc	r25, r19
    20f4:	84 0f       	add	r24, r20
    20f6:	95 1f       	adc	r25, r21
    20f8:	8e 83       	std	Y+6, r24	; 0x06
    20fa:	9f 83       	std	Y+7, r25	; 0x07
    20fc:	8f ef       	ldi	r24, 0xFF	; 255
    20fe:	89 a3       	std	Y+33, r24	; 0x21
    2100:	8a a3       	std	Y+34, r24	; 0x22
    2102:	ce 01       	movw	r24, r28
    2104:	08 96       	adiw	r24, 0x08	; 8
    2106:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    210a:	ce 01       	movw	r24, r28
    210c:	43 96       	adiw	r24, 0x13	; 19
    210e:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    2112:	01 c0       	rjmp	.+2      	; 0x2116 <xQueueGenericReset+0x6e>
    2114:	10 e0       	ldi	r17, 0x00	; 0
    2116:	81 2f       	mov	r24, r17
    2118:	df 91       	pop	r29
    211a:	cf 91       	pop	r28
    211c:	1f 91       	pop	r17
    211e:	08 95       	ret

00002120 <xQueueGenericCreate>:
    2120:	0f 93       	push	r16
    2122:	1f 93       	push	r17
    2124:	cf 93       	push	r28
    2126:	df 93       	push	r29
    2128:	88 23       	and	r24, r24
    212a:	01 f1       	breq	.+64     	; 0x216c <xQueueGenericCreate+0x4c>
    212c:	06 2f       	mov	r16, r22
    212e:	18 2f       	mov	r17, r24
    2130:	83 e2       	ldi	r24, 0x23	; 35
    2132:	90 e0       	ldi	r25, 0x00	; 0
    2134:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    2138:	ec 01       	movw	r28, r24
    213a:	89 2b       	or	r24, r25
    213c:	c9 f0       	breq	.+50     	; 0x2170 <xQueueGenericCreate+0x50>
    213e:	10 9f       	mul	r17, r16
    2140:	c0 01       	movw	r24, r0
    2142:	11 24       	eor	r1, r1
    2144:	01 96       	adiw	r24, 0x01	; 1
    2146:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    214a:	88 83       	st	Y, r24
    214c:	99 83       	std	Y+1, r25	; 0x01
    214e:	89 2b       	or	r24, r25
    2150:	39 f0       	breq	.+14     	; 0x2160 <xQueueGenericCreate+0x40>
    2152:	1f 8f       	std	Y+31, r17	; 0x1f
    2154:	08 a3       	std	Y+32, r16	; 0x20
    2156:	61 e0       	ldi	r22, 0x01	; 1
    2158:	ce 01       	movw	r24, r28
    215a:	0e 94 54 10 	call	0x20a8	; 0x20a8 <xQueueGenericReset>
    215e:	08 c0       	rjmp	.+16     	; 0x2170 <xQueueGenericCreate+0x50>
    2160:	ce 01       	movw	r24, r28
    2162:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vPortFree>
    2166:	c0 e0       	ldi	r28, 0x00	; 0
    2168:	d0 e0       	ldi	r29, 0x00	; 0
    216a:	02 c0       	rjmp	.+4      	; 0x2170 <xQueueGenericCreate+0x50>
    216c:	c0 e0       	ldi	r28, 0x00	; 0
    216e:	d0 e0       	ldi	r29, 0x00	; 0
    2170:	ce 01       	movw	r24, r28
    2172:	df 91       	pop	r29
    2174:	cf 91       	pop	r28
    2176:	1f 91       	pop	r17
    2178:	0f 91       	pop	r16
    217a:	08 95       	ret

0000217c <xQueueGenericSend>:
    217c:	af 92       	push	r10
    217e:	bf 92       	push	r11
    2180:	cf 92       	push	r12
    2182:	df 92       	push	r13
    2184:	ef 92       	push	r14
    2186:	ff 92       	push	r15
    2188:	0f 93       	push	r16
    218a:	1f 93       	push	r17
    218c:	cf 93       	push	r28
    218e:	df 93       	push	r29
    2190:	cd b7       	in	r28, 0x3d	; 61
    2192:	de b7       	in	r29, 0x3e	; 62
    2194:	29 97       	sbiw	r28, 0x09	; 9
    2196:	cd bf       	out	0x3d, r28	; 61
    2198:	de bf       	out	0x3e, r29	; 62
    219a:	7c 01       	movw	r14, r24
    219c:	5b 01       	movw	r10, r22
    219e:	2e 83       	std	Y+6, r18	; 0x06
    21a0:	3f 83       	std	Y+7, r19	; 0x07
    21a2:	48 87       	std	Y+8, r20	; 0x08
    21a4:	59 87       	std	Y+9, r21	; 0x09
    21a6:	10 e0       	ldi	r17, 0x00	; 0
    21a8:	6c 01       	movw	r12, r24
    21aa:	88 e0       	ldi	r24, 0x08	; 8
    21ac:	c8 0e       	add	r12, r24
    21ae:	d1 1c       	adc	r13, r1
    21b0:	0f b6       	in	r0, 0x3f	; 63
    21b2:	f8 94       	cli
    21b4:	0f 92       	push	r0
    21b6:	f7 01       	movw	r30, r14
    21b8:	96 8d       	ldd	r25, Z+30	; 0x1e
    21ba:	87 8d       	ldd	r24, Z+31	; 0x1f
    21bc:	98 17       	cp	r25, r24
    21be:	a8 f4       	brcc	.+42     	; 0x21ea <xQueueGenericSend+0x6e>
    21c0:	40 2f       	mov	r20, r16
    21c2:	b5 01       	movw	r22, r10
    21c4:	c7 01       	movw	r24, r14
    21c6:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <prvCopyDataToQueue>
    21ca:	f7 01       	movw	r30, r14
    21cc:	83 89       	ldd	r24, Z+19	; 0x13
    21ce:	88 23       	and	r24, r24
    21d0:	41 f0       	breq	.+16     	; 0x21e2 <xQueueGenericSend+0x66>
    21d2:	c7 01       	movw	r24, r14
    21d4:	43 96       	adiw	r24, 0x13	; 19
    21d6:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    21da:	81 30       	cpi	r24, 0x01	; 1
    21dc:	11 f4       	brne	.+4      	; 0x21e2 <xQueueGenericSend+0x66>
    21de:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    21e2:	0f 90       	pop	r0
    21e4:	0f be       	out	0x3f, r0	; 63
    21e6:	81 e0       	ldi	r24, 0x01	; 1
    21e8:	56 c0       	rjmp	.+172    	; 0x2296 <xQueueGenericSend+0x11a>
    21ea:	8e 81       	ldd	r24, Y+6	; 0x06
    21ec:	9f 81       	ldd	r25, Y+7	; 0x07
    21ee:	a8 85       	ldd	r26, Y+8	; 0x08
    21f0:	b9 85       	ldd	r27, Y+9	; 0x09
    21f2:	89 2b       	or	r24, r25
    21f4:	8a 2b       	or	r24, r26
    21f6:	8b 2b       	or	r24, r27
    21f8:	21 f4       	brne	.+8      	; 0x2202 <xQueueGenericSend+0x86>
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	4a c0       	rjmp	.+148    	; 0x2296 <xQueueGenericSend+0x11a>
    2202:	11 11       	cpse	r17, r1
    2204:	05 c0       	rjmp	.+10     	; 0x2210 <xQueueGenericSend+0x94>
    2206:	ce 01       	movw	r24, r28
    2208:	01 96       	adiw	r24, 0x01	; 1
    220a:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <vTaskSetTimeOutState>
    220e:	11 e0       	ldi	r17, 0x01	; 1
    2210:	0f 90       	pop	r0
    2212:	0f be       	out	0x3f, r0	; 63
    2214:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskSuspendAll>
    2218:	0f b6       	in	r0, 0x3f	; 63
    221a:	f8 94       	cli
    221c:	0f 92       	push	r0
    221e:	f7 01       	movw	r30, r14
    2220:	81 a1       	ldd	r24, Z+33	; 0x21
    2222:	8f 3f       	cpi	r24, 0xFF	; 255
    2224:	09 f4       	brne	.+2      	; 0x2228 <xQueueGenericSend+0xac>
    2226:	11 a2       	std	Z+33, r1	; 0x21
    2228:	f7 01       	movw	r30, r14
    222a:	82 a1       	ldd	r24, Z+34	; 0x22
    222c:	8f 3f       	cpi	r24, 0xFF	; 255
    222e:	09 f4       	brne	.+2      	; 0x2232 <xQueueGenericSend+0xb6>
    2230:	12 a2       	std	Z+34, r1	; 0x22
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63
    2236:	be 01       	movw	r22, r28
    2238:	6a 5f       	subi	r22, 0xFA	; 250
    223a:	7f 4f       	sbci	r23, 0xFF	; 255
    223c:	ce 01       	movw	r24, r28
    223e:	01 96       	adiw	r24, 0x01	; 1
    2240:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <xTaskCheckForTimeOut>
    2244:	81 11       	cpse	r24, r1
    2246:	21 c0       	rjmp	.+66     	; 0x228a <xQueueGenericSend+0x10e>
    2248:	0f b6       	in	r0, 0x3f	; 63
    224a:	f8 94       	cli
    224c:	0f 92       	push	r0
    224e:	f7 01       	movw	r30, r14
    2250:	96 8d       	ldd	r25, Z+30	; 0x1e
    2252:	0f 90       	pop	r0
    2254:	0f be       	out	0x3f, r0	; 63
    2256:	87 8d       	ldd	r24, Z+31	; 0x1f
    2258:	98 13       	cpse	r25, r24
    225a:	11 c0       	rjmp	.+34     	; 0x227e <xQueueGenericSend+0x102>
    225c:	4e 81       	ldd	r20, Y+6	; 0x06
    225e:	5f 81       	ldd	r21, Y+7	; 0x07
    2260:	68 85       	ldd	r22, Y+8	; 0x08
    2262:	79 85       	ldd	r23, Y+9	; 0x09
    2264:	c6 01       	movw	r24, r12
    2266:	0e 94 49 16 	call	0x2c92	; 0x2c92 <vTaskPlaceOnEventList>
    226a:	c7 01       	movw	r24, r14
    226c:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
    2270:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
    2274:	81 11       	cpse	r24, r1
    2276:	9c cf       	rjmp	.-200    	; 0x21b0 <xQueueGenericSend+0x34>
    2278:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    227c:	99 cf       	rjmp	.-206    	; 0x21b0 <xQueueGenericSend+0x34>
    227e:	c7 01       	movw	r24, r14
    2280:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
    2284:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
    2288:	93 cf       	rjmp	.-218    	; 0x21b0 <xQueueGenericSend+0x34>
    228a:	c7 01       	movw	r24, r14
    228c:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
    2290:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
    2294:	80 e0       	ldi	r24, 0x00	; 0
    2296:	29 96       	adiw	r28, 0x09	; 9
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	df 91       	pop	r29
    229e:	cf 91       	pop	r28
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	ff 90       	pop	r15
    22a6:	ef 90       	pop	r14
    22a8:	df 90       	pop	r13
    22aa:	cf 90       	pop	r12
    22ac:	bf 90       	pop	r11
    22ae:	af 90       	pop	r10
    22b0:	08 95       	ret

000022b2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    22b2:	0f 93       	push	r16
    22b4:	1f 93       	push	r17
    22b6:	cf 93       	push	r28
    22b8:	df 93       	push	r29
    22ba:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    22bc:	fc 01       	movw	r30, r24
    22be:	56 8d       	ldd	r21, Z+30	; 0x1e
    22c0:	37 8d       	ldd	r19, Z+31	; 0x1f
    22c2:	53 17       	cp	r21, r19
    22c4:	c0 f4       	brcc	.+48     	; 0x22f6 <xQueueGenericSendFromISR+0x44>
    22c6:	42 2f       	mov	r20, r18
    22c8:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    22ca:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    22ce:	8a a1       	ldd	r24, Y+34	; 0x22
    22d0:	8f 3f       	cpi	r24, 0xFF	; 255
    22d2:	69 f4       	brne	.+26     	; 0x22ee <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22d4:	8b 89       	ldd	r24, Y+19	; 0x13
    22d6:	88 23       	and	r24, r24
    22d8:	81 f0       	breq	.+32     	; 0x22fa <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22da:	ce 01       	movw	r24, r28
    22dc:	43 96       	adiw	r24, 0x13	; 19
    22de:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    22e2:	88 23       	and	r24, r24
    22e4:	61 f0       	breq	.+24     	; 0x22fe <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	f8 01       	movw	r30, r16
    22ea:	80 83       	st	Z, r24
    22ec:	09 c0       	rjmp	.+18     	; 0x2300 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    22ee:	8f 5f       	subi	r24, 0xFF	; 255
    22f0:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    22f2:	81 e0       	ldi	r24, 0x01	; 1
    22f4:	05 c0       	rjmp	.+10     	; 0x2300 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    22f6:	80 e0       	ldi	r24, 0x00	; 0
    22f8:	03 c0       	rjmp	.+6      	; 0x2300 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	01 c0       	rjmp	.+2      	; 0x2300 <xQueueGenericSendFromISR+0x4e>
    22fe:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2300:	df 91       	pop	r29
    2302:	cf 91       	pop	r28
    2304:	1f 91       	pop	r17
    2306:	0f 91       	pop	r16
    2308:	08 95       	ret

0000230a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    230a:	af 92       	push	r10
    230c:	bf 92       	push	r11
    230e:	cf 92       	push	r12
    2310:	df 92       	push	r13
    2312:	ef 92       	push	r14
    2314:	ff 92       	push	r15
    2316:	0f 93       	push	r16
    2318:	1f 93       	push	r17
    231a:	cf 93       	push	r28
    231c:	df 93       	push	r29
    231e:	cd b7       	in	r28, 0x3d	; 61
    2320:	de b7       	in	r29, 0x3e	; 62
    2322:	29 97       	sbiw	r28, 0x09	; 9
    2324:	cd bf       	out	0x3d, r28	; 61
    2326:	de bf       	out	0x3e, r29	; 62
    2328:	7c 01       	movw	r14, r24
    232a:	5b 01       	movw	r10, r22
    232c:	2e 83       	std	Y+6, r18	; 0x06
    232e:	3f 83       	std	Y+7, r19	; 0x07
    2330:	48 87       	std	Y+8, r20	; 0x08
    2332:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2334:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2336:	6c 01       	movw	r12, r24
    2338:	83 e1       	ldi	r24, 0x13	; 19
    233a:	c8 0e       	add	r12, r24
    233c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    233e:	0f b6       	in	r0, 0x3f	; 63
    2340:	f8 94       	cli
    2342:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2344:	f7 01       	movw	r30, r14
    2346:	86 8d       	ldd	r24, Z+30	; 0x1e
    2348:	88 23       	and	r24, r24
    234a:	99 f1       	breq	.+102    	; 0x23b2 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    234c:	c6 80       	ldd	r12, Z+6	; 0x06
    234e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2350:	b5 01       	movw	r22, r10
    2352:	c7 01       	movw	r24, r14
    2354:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2358:	01 11       	cpse	r16, r1
    235a:	1a c0       	rjmp	.+52     	; 0x2390 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    235c:	f7 01       	movw	r30, r14
    235e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2360:	81 50       	subi	r24, 0x01	; 1
    2362:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2364:	80 81       	ld	r24, Z
    2366:	91 81       	ldd	r25, Z+1	; 0x01
    2368:	89 2b       	or	r24, r25
    236a:	29 f4       	brne	.+10     	; 0x2376 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    236c:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <xTaskGetCurrentTaskHandle>
    2370:	f7 01       	movw	r30, r14
    2372:	82 83       	std	Z+2, r24	; 0x02
    2374:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2376:	f7 01       	movw	r30, r14
    2378:	80 85       	ldd	r24, Z+8	; 0x08
    237a:	88 23       	and	r24, r24
    237c:	b1 f0       	breq	.+44     	; 0x23aa <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    237e:	c7 01       	movw	r24, r14
    2380:	08 96       	adiw	r24, 0x08	; 8
    2382:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    2386:	81 30       	cpi	r24, 0x01	; 1
    2388:	81 f4       	brne	.+32     	; 0x23aa <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    238a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    238e:	0d c0       	rjmp	.+26     	; 0x23aa <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2390:	f7 01       	movw	r30, r14
    2392:	c6 82       	std	Z+6, r12	; 0x06
    2394:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2396:	83 89       	ldd	r24, Z+19	; 0x13
    2398:	88 23       	and	r24, r24
    239a:	39 f0       	breq	.+14     	; 0x23aa <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    239c:	c7 01       	movw	r24, r14
    239e:	43 96       	adiw	r24, 0x13	; 19
    23a0:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    23a4:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    23a6:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    23aa:	0f 90       	pop	r0
    23ac:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	62 c0       	rjmp	.+196    	; 0x2476 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    23b2:	8e 81       	ldd	r24, Y+6	; 0x06
    23b4:	9f 81       	ldd	r25, Y+7	; 0x07
    23b6:	a8 85       	ldd	r26, Y+8	; 0x08
    23b8:	b9 85       	ldd	r27, Y+9	; 0x09
    23ba:	89 2b       	or	r24, r25
    23bc:	8a 2b       	or	r24, r26
    23be:	8b 2b       	or	r24, r27
    23c0:	21 f4       	brne	.+8      	; 0x23ca <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23c2:	0f 90       	pop	r0
    23c4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23c6:	80 e0       	ldi	r24, 0x00	; 0
    23c8:	56 c0       	rjmp	.+172    	; 0x2476 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    23ca:	11 11       	cpse	r17, r1
    23cc:	05 c0       	rjmp	.+10     	; 0x23d8 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23ce:	ce 01       	movw	r24, r28
    23d0:	01 96       	adiw	r24, 0x01	; 1
    23d2:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    23d6:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    23d8:	0f 90       	pop	r0
    23da:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23dc:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	0f 92       	push	r0
    23e6:	f7 01       	movw	r30, r14
    23e8:	81 a1       	ldd	r24, Z+33	; 0x21
    23ea:	8f 3f       	cpi	r24, 0xFF	; 255
    23ec:	09 f4       	brne	.+2      	; 0x23f0 <xQueueGenericReceive+0xe6>
    23ee:	11 a2       	std	Z+33, r1	; 0x21
    23f0:	f7 01       	movw	r30, r14
    23f2:	82 a1       	ldd	r24, Z+34	; 0x22
    23f4:	8f 3f       	cpi	r24, 0xFF	; 255
    23f6:	09 f4       	brne	.+2      	; 0x23fa <xQueueGenericReceive+0xf0>
    23f8:	12 a2       	std	Z+34, r1	; 0x22
    23fa:	0f 90       	pop	r0
    23fc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23fe:	be 01       	movw	r22, r28
    2400:	6a 5f       	subi	r22, 0xFA	; 250
    2402:	7f 4f       	sbci	r23, 0xFF	; 255
    2404:	ce 01       	movw	r24, r28
    2406:	01 96       	adiw	r24, 0x01	; 1
    2408:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <xTaskCheckForTimeOut>
    240c:	81 11       	cpse	r24, r1
    240e:	2d c0       	rjmp	.+90     	; 0x246a <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2410:	0f b6       	in	r0, 0x3f	; 63
    2412:	f8 94       	cli
    2414:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2416:	f7 01       	movw	r30, r14
    2418:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    241e:	81 11       	cpse	r24, r1
    2420:	1e c0       	rjmp	.+60     	; 0x245e <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2422:	80 81       	ld	r24, Z
    2424:	91 81       	ldd	r25, Z+1	; 0x01
    2426:	89 2b       	or	r24, r25
    2428:	49 f4       	brne	.+18     	; 0x243c <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    242a:	0f b6       	in	r0, 0x3f	; 63
    242c:	f8 94       	cli
    242e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2430:	82 81       	ldd	r24, Z+2	; 0x02
    2432:	93 81       	ldd	r25, Z+3	; 0x03
    2434:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2438:	0f 90       	pop	r0
    243a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    243c:	4e 81       	ldd	r20, Y+6	; 0x06
    243e:	5f 81       	ldd	r21, Y+7	; 0x07
    2440:	68 85       	ldd	r22, Y+8	; 0x08
    2442:	79 85       	ldd	r23, Y+9	; 0x09
    2444:	c6 01       	movw	r24, r12
    2446:	0e 94 49 16 	call	0x2c92	; 0x2c92 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    244a:	c7 01       	movw	r24, r14
    244c:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2450:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
    2454:	81 11       	cpse	r24, r1
    2456:	73 cf       	rjmp	.-282    	; 0x233e <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2458:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    245c:	70 cf       	rjmp	.-288    	; 0x233e <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    245e:	c7 01       	movw	r24, r14
    2460:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2464:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
    2468:	6a cf       	rjmp	.-300    	; 0x233e <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    246a:	c7 01       	movw	r24, r14
    246c:	0e 94 0a 10 	call	0x2014	; 0x2014 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2470:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2474:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2476:	29 96       	adiw	r28, 0x09	; 9
    2478:	cd bf       	out	0x3d, r28	; 61
    247a:	de bf       	out	0x3e, r29	; 62
    247c:	df 91       	pop	r29
    247e:	cf 91       	pop	r28
    2480:	1f 91       	pop	r17
    2482:	0f 91       	pop	r16
    2484:	ff 90       	pop	r15
    2486:	ef 90       	pop	r14
    2488:	df 90       	pop	r13
    248a:	cf 90       	pop	r12
    248c:	bf 90       	pop	r11
    248e:	af 90       	pop	r10
    2490:	08 95       	ret

00002492 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2492:	0f 93       	push	r16
    2494:	1f 93       	push	r17
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    249a:	fc 01       	movw	r30, r24
    249c:	26 8d       	ldd	r18, Z+30	; 0x1e
    249e:	22 23       	and	r18, r18
    24a0:	d9 f0       	breq	.+54     	; 0x24d8 <xQueueReceiveFromISR+0x46>
    24a2:	8a 01       	movw	r16, r20
    24a4:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    24a6:	0e 94 f0 0f 	call	0x1fe0	; 0x1fe0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    24aa:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24ac:	81 50       	subi	r24, 0x01	; 1
    24ae:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    24b0:	89 a1       	ldd	r24, Y+33	; 0x21
    24b2:	8f 3f       	cpi	r24, 0xFF	; 255
    24b4:	69 f4       	brne	.+26     	; 0x24d0 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24b6:	88 85       	ldd	r24, Y+8	; 0x08
    24b8:	88 23       	and	r24, r24
    24ba:	81 f0       	breq	.+32     	; 0x24dc <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24bc:	ce 01       	movw	r24, r28
    24be:	08 96       	adiw	r24, 0x08	; 8
    24c0:	0e 94 73 16 	call	0x2ce6	; 0x2ce6 <xTaskRemoveFromEventList>
    24c4:	88 23       	and	r24, r24
    24c6:	61 f0       	breq	.+24     	; 0x24e0 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	f8 01       	movw	r30, r16
    24cc:	80 83       	st	Z, r24
    24ce:	09 c0       	rjmp	.+18     	; 0x24e2 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    24d0:	8f 5f       	subi	r24, 0xFF	; 255
    24d2:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    24d4:	81 e0       	ldi	r24, 0x01	; 1
    24d6:	05 c0       	rjmp	.+10     	; 0x24e2 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    24d8:	80 e0       	ldi	r24, 0x00	; 0
    24da:	03 c0       	rjmp	.+6      	; 0x24e2 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	01 c0       	rjmp	.+2      	; 0x24e2 <xQueueReceiveFromISR+0x50>
    24e0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24e2:	df 91       	pop	r29
    24e4:	cf 91       	pop	r28
    24e6:	1f 91       	pop	r17
    24e8:	0f 91       	pop	r16
    24ea:	08 95       	ret

000024ec <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    24ec:	0f b6       	in	r0, 0x3f	; 63
    24ee:	f8 94       	cli
    24f0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    24f2:	fc 01       	movw	r30, r24
    24f4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    24f6:	0f 90       	pop	r0
    24f8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    24fa:	08 95       	ret

000024fc <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    24fc:	fc 01       	movw	r30, r24
    24fe:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    2500:	08 95       	ret

00002502 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2502:	c2 e0       	ldi	r28, 0x02	; 2
    2504:	d2 e3       	ldi	r29, 0x32	; 50
    2506:	88 81       	ld	r24, Y
    2508:	82 30       	cpi	r24, 0x02	; 2
    250a:	e8 f3       	brcs	.-6      	; 0x2506 <prvIdleTask+0x4>
    250c:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    2510:	fa cf       	rjmp	.-12     	; 0x2506 <prvIdleTask+0x4>

00002512 <prvAddCurrentTaskToDelayedList>:
    2512:	cf 92       	push	r12
    2514:	df 92       	push	r13
    2516:	ef 92       	push	r14
    2518:	ff 92       	push	r15
    251a:	6b 01       	movw	r12, r22
    251c:	7c 01       	movw	r14, r24
    251e:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2522:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2526:	62 83       	std	Z+2, r22	; 0x02
    2528:	73 83       	std	Z+3, r23	; 0x03
    252a:	84 83       	std	Z+4, r24	; 0x04
    252c:	95 83       	std	Z+5, r25	; 0x05
    252e:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2532:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2536:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    253a:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    253e:	c8 16       	cp	r12, r24
    2540:	d9 06       	cpc	r13, r25
    2542:	ea 06       	cpc	r14, r26
    2544:	fb 06       	cpc	r15, r27
    2546:	68 f4       	brcc	.+26     	; 0x2562 <prvAddCurrentTaskToDelayedList+0x50>
    2548:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    254c:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2550:	80 91 e8 31 	lds	r24, 0x31E8	; 0x8031e8 <pxOverflowDelayedTaskList>
    2554:	90 91 e9 31 	lds	r25, 0x31E9	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    2558:	6e 5f       	subi	r22, 0xFE	; 254
    255a:	7f 4f       	sbci	r23, 0xFF	; 255
    255c:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInsert>
    2560:	21 c0       	rjmp	.+66     	; 0x25a4 <prvAddCurrentTaskToDelayedList+0x92>
    2562:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    2566:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    256a:	80 91 ea 31 	lds	r24, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    256e:	90 91 eb 31 	lds	r25, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2572:	6e 5f       	subi	r22, 0xFE	; 254
    2574:	7f 4f       	sbci	r23, 0xFF	; 255
    2576:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInsert>
    257a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    257e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2582:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2586:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    258a:	c8 16       	cp	r12, r24
    258c:	d9 06       	cpc	r13, r25
    258e:	ea 06       	cpc	r14, r26
    2590:	fb 06       	cpc	r15, r27
    2592:	40 f4       	brcc	.+16     	; 0x25a4 <prvAddCurrentTaskToDelayedList+0x92>
    2594:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2598:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    259c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    25a0:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    25a4:	ff 90       	pop	r15
    25a6:	ef 90       	pop	r14
    25a8:	df 90       	pop	r13
    25aa:	cf 90       	pop	r12
    25ac:	08 95       	ret

000025ae <xTaskGenericCreate>:
    25ae:	4f 92       	push	r4
    25b0:	5f 92       	push	r5
    25b2:	6f 92       	push	r6
    25b4:	7f 92       	push	r7
    25b6:	8f 92       	push	r8
    25b8:	9f 92       	push	r9
    25ba:	af 92       	push	r10
    25bc:	bf 92       	push	r11
    25be:	cf 92       	push	r12
    25c0:	df 92       	push	r13
    25c2:	ef 92       	push	r14
    25c4:	ff 92       	push	r15
    25c6:	0f 93       	push	r16
    25c8:	1f 93       	push	r17
    25ca:	cf 93       	push	r28
    25cc:	df 93       	push	r29
    25ce:	5c 01       	movw	r10, r24
    25d0:	4b 01       	movw	r8, r22
    25d2:	3a 01       	movw	r6, r20
    25d4:	29 01       	movw	r4, r18
    25d6:	88 e2       	ldi	r24, 0x28	; 40
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    25de:	ec 01       	movw	r28, r24
    25e0:	89 2b       	or	r24, r25
    25e2:	09 f4       	brne	.+2      	; 0x25e6 <xTaskGenericCreate+0x38>
    25e4:	d4 c0       	rjmp	.+424    	; 0x278e <xTaskGenericCreate+0x1e0>
    25e6:	c1 14       	cp	r12, r1
    25e8:	d1 04       	cpc	r13, r1
    25ea:	09 f0       	breq	.+2      	; 0x25ee <xTaskGenericCreate+0x40>
    25ec:	cc c0       	rjmp	.+408    	; 0x2786 <xTaskGenericCreate+0x1d8>
    25ee:	c3 01       	movw	r24, r6
    25f0:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    25f4:	8b 8f       	std	Y+27, r24	; 0x1b
    25f6:	9c 8f       	std	Y+28, r25	; 0x1c
    25f8:	00 97       	sbiw	r24, 0x00	; 0
    25fa:	21 f4       	brne	.+8      	; 0x2604 <xTaskGenericCreate+0x56>
    25fc:	ce 01       	movw	r24, r28
    25fe:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <vPortFree>
    2602:	c5 c0       	rjmp	.+394    	; 0x278e <xTaskGenericCreate+0x1e0>
    2604:	a3 01       	movw	r20, r6
    2606:	61 e1       	ldi	r22, 0x11	; 17
    2608:	70 e0       	ldi	r23, 0x00	; 0
    260a:	0e 94 e5 24 	call	0x49ca	; 0x49ca <memset>
    260e:	93 01       	movw	r18, r6
    2610:	21 50       	subi	r18, 0x01	; 1
    2612:	31 09       	sbc	r19, r1
    2614:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2616:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2618:	3c 01       	movw	r6, r24
    261a:	62 0e       	add	r6, r18
    261c:	73 1e       	adc	r7, r19
    261e:	4a e0       	ldi	r20, 0x0A	; 10
    2620:	50 e0       	ldi	r21, 0x00	; 0
    2622:	b4 01       	movw	r22, r8
    2624:	ce 01       	movw	r24, r28
    2626:	4d 96       	adiw	r24, 0x1d	; 29
    2628:	0e 94 ec 24 	call	0x49d8	; 0x49d8 <strncpy>
    262c:	1e a2       	std	Y+38, r1	; 0x26
    262e:	10 2f       	mov	r17, r16
    2630:	04 30       	cpi	r16, 0x04	; 4
    2632:	08 f0       	brcs	.+2      	; 0x2636 <xTaskGenericCreate+0x88>
    2634:	13 e0       	ldi	r17, 0x03	; 3
    2636:	1a 8f       	std	Y+26, r17	; 0x1a
    2638:	1f a3       	std	Y+39, r17	; 0x27
    263a:	6e 01       	movw	r12, r28
    263c:	22 e0       	ldi	r18, 0x02	; 2
    263e:	c2 0e       	add	r12, r18
    2640:	d1 1c       	adc	r13, r1
    2642:	c6 01       	movw	r24, r12
    2644:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <vListInitialiseItem>
    2648:	ce 01       	movw	r24, r28
    264a:	0e 96       	adiw	r24, 0x0e	; 14
    264c:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <vListInitialiseItem>
    2650:	ca 87       	std	Y+10, r28	; 0x0a
    2652:	db 87       	std	Y+11, r29	; 0x0b
    2654:	84 e0       	ldi	r24, 0x04	; 4
    2656:	90 e0       	ldi	r25, 0x00	; 0
    2658:	a0 e0       	ldi	r26, 0x00	; 0
    265a:	b0 e0       	ldi	r27, 0x00	; 0
    265c:	81 1b       	sub	r24, r17
    265e:	91 09       	sbc	r25, r1
    2660:	a1 09       	sbc	r26, r1
    2662:	b1 09       	sbc	r27, r1
    2664:	8e 87       	std	Y+14, r24	; 0x0e
    2666:	9f 87       	std	Y+15, r25	; 0x0f
    2668:	a8 8b       	std	Y+16, r26	; 0x10
    266a:	b9 8b       	std	Y+17, r27	; 0x11
    266c:	ce 8b       	std	Y+22, r28	; 0x16
    266e:	df 8b       	std	Y+23, r29	; 0x17
    2670:	a2 01       	movw	r20, r4
    2672:	b5 01       	movw	r22, r10
    2674:	c3 01       	movw	r24, r6
    2676:	0e 94 29 0e 	call	0x1c52	; 0x1c52 <pxPortInitialiseStack>
    267a:	88 83       	st	Y, r24
    267c:	99 83       	std	Y+1, r25	; 0x01
    267e:	e1 14       	cp	r14, r1
    2680:	f1 04       	cpc	r15, r1
    2682:	19 f0       	breq	.+6      	; 0x268a <xTaskGenericCreate+0xdc>
    2684:	f7 01       	movw	r30, r14
    2686:	c0 83       	st	Z, r28
    2688:	d1 83       	std	Z+1, r29	; 0x01
    268a:	0f b6       	in	r0, 0x3f	; 63
    268c:	f8 94       	cli
    268e:	0f 92       	push	r0
    2690:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    2694:	8f 5f       	subi	r24, 0xFF	; 255
    2696:	80 93 da 31 	sts	0x31DA, r24	; 0x8031da <uxCurrentNumberOfTasks>
    269a:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    269e:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    26a2:	89 2b       	or	r24, r25
    26a4:	89 f5       	brne	.+98     	; 0x2708 <xTaskGenericCreate+0x15a>
    26a6:	c0 93 2e 32 	sts	0x322E, r28	; 0x80322e <pxCurrentTCB>
    26aa:	d0 93 2f 32 	sts	0x322F, r29	; 0x80322f <pxCurrentTCB+0x1>
    26ae:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    26b2:	81 30       	cpi	r24, 0x01	; 1
    26b4:	c1 f5       	brne	.+112    	; 0x2726 <xTaskGenericCreate+0x178>
    26b6:	82 e0       	ldi	r24, 0x02	; 2
    26b8:	92 e3       	ldi	r25, 0x32	; 50
    26ba:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26be:	8d e0       	ldi	r24, 0x0D	; 13
    26c0:	92 e3       	ldi	r25, 0x32	; 50
    26c2:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26c6:	88 e1       	ldi	r24, 0x18	; 24
    26c8:	92 e3       	ldi	r25, 0x32	; 50
    26ca:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26ce:	83 e2       	ldi	r24, 0x23	; 35
    26d0:	92 e3       	ldi	r25, 0x32	; 50
    26d2:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26d6:	87 ef       	ldi	r24, 0xF7	; 247
    26d8:	91 e3       	ldi	r25, 0x31	; 49
    26da:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26de:	8c ee       	ldi	r24, 0xEC	; 236
    26e0:	91 e3       	ldi	r25, 0x31	; 49
    26e2:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26e6:	8d ed       	ldi	r24, 0xDD	; 221
    26e8:	91 e3       	ldi	r25, 0x31	; 49
    26ea:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <vListInitialise>
    26ee:	87 ef       	ldi	r24, 0xF7	; 247
    26f0:	91 e3       	ldi	r25, 0x31	; 49
    26f2:	80 93 ea 31 	sts	0x31EA, r24	; 0x8031ea <pxDelayedTaskList>
    26f6:	90 93 eb 31 	sts	0x31EB, r25	; 0x8031eb <pxDelayedTaskList+0x1>
    26fa:	8c ee       	ldi	r24, 0xEC	; 236
    26fc:	91 e3       	ldi	r25, 0x31	; 49
    26fe:	80 93 e8 31 	sts	0x31E8, r24	; 0x8031e8 <pxOverflowDelayedTaskList>
    2702:	90 93 e9 31 	sts	0x31E9, r25	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    2706:	0f c0       	rjmp	.+30     	; 0x2726 <xTaskGenericCreate+0x178>
    2708:	80 91 d3 31 	lds	r24, 0x31D3	; 0x8031d3 <xSchedulerRunning>
    270c:	81 11       	cpse	r24, r1
    270e:	0b c0       	rjmp	.+22     	; 0x2726 <xTaskGenericCreate+0x178>
    2710:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2714:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2718:	82 8d       	ldd	r24, Z+26	; 0x1a
    271a:	08 17       	cp	r16, r24
    271c:	20 f0       	brcs	.+8      	; 0x2726 <xTaskGenericCreate+0x178>
    271e:	c0 93 2e 32 	sts	0x322E, r28	; 0x80322e <pxCurrentTCB>
    2722:	d0 93 2f 32 	sts	0x322F, r29	; 0x80322f <pxCurrentTCB+0x1>
    2726:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2728:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <uxTopUsedPriority>
    272c:	98 17       	cp	r25, r24
    272e:	10 f4       	brcc	.+4      	; 0x2734 <xTaskGenericCreate+0x186>
    2730:	80 93 d5 31 	sts	0x31D5, r24	; 0x8031d5 <uxTopUsedPriority>
    2734:	90 91 ce 31 	lds	r25, 0x31CE	; 0x8031ce <uxTaskNumber>
    2738:	9f 5f       	subi	r25, 0xFF	; 255
    273a:	90 93 ce 31 	sts	0x31CE, r25	; 0x8031ce <uxTaskNumber>
    273e:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2742:	98 17       	cp	r25, r24
    2744:	10 f4       	brcc	.+4      	; 0x274a <xTaskGenericCreate+0x19c>
    2746:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    274a:	fb e0       	ldi	r31, 0x0B	; 11
    274c:	8f 9f       	mul	r24, r31
    274e:	c0 01       	movw	r24, r0
    2750:	11 24       	eor	r1, r1
    2752:	b6 01       	movw	r22, r12
    2754:	8e 5f       	subi	r24, 0xFE	; 254
    2756:	9d 4c       	sbci	r25, 0xCD	; 205
    2758:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
    275c:	0f 90       	pop	r0
    275e:	0f be       	out	0x3f, r0	; 63
    2760:	80 91 d3 31 	lds	r24, 0x31D3	; 0x8031d3 <xSchedulerRunning>
    2764:	88 23       	and	r24, r24
    2766:	59 f0       	breq	.+22     	; 0x277e <xTaskGenericCreate+0x1d0>
    2768:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    276c:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2770:	82 8d       	ldd	r24, Z+26	; 0x1a
    2772:	80 17       	cp	r24, r16
    2774:	30 f4       	brcc	.+12     	; 0x2782 <xTaskGenericCreate+0x1d4>
    2776:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	09 c0       	rjmp	.+18     	; 0x2790 <xTaskGenericCreate+0x1e2>
    277e:	81 e0       	ldi	r24, 0x01	; 1
    2780:	07 c0       	rjmp	.+14     	; 0x2790 <xTaskGenericCreate+0x1e2>
    2782:	81 e0       	ldi	r24, 0x01	; 1
    2784:	05 c0       	rjmp	.+10     	; 0x2790 <xTaskGenericCreate+0x1e2>
    2786:	cb 8e       	std	Y+27, r12	; 0x1b
    2788:	dc 8e       	std	Y+28, r13	; 0x1c
    278a:	c6 01       	movw	r24, r12
    278c:	3b cf       	rjmp	.-394    	; 0x2604 <xTaskGenericCreate+0x56>
    278e:	8f ef       	ldi	r24, 0xFF	; 255
    2790:	df 91       	pop	r29
    2792:	cf 91       	pop	r28
    2794:	1f 91       	pop	r17
    2796:	0f 91       	pop	r16
    2798:	ff 90       	pop	r15
    279a:	ef 90       	pop	r14
    279c:	df 90       	pop	r13
    279e:	cf 90       	pop	r12
    27a0:	bf 90       	pop	r11
    27a2:	af 90       	pop	r10
    27a4:	9f 90       	pop	r9
    27a6:	8f 90       	pop	r8
    27a8:	7f 90       	pop	r7
    27aa:	6f 90       	pop	r6
    27ac:	5f 90       	pop	r5
    27ae:	4f 90       	pop	r4
    27b0:	08 95       	ret

000027b2 <uxTaskPriorityGet>:
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	0f 92       	push	r0
    27b8:	00 97       	sbiw	r24, 0x00	; 0
    27ba:	21 f4       	brne	.+8      	; 0x27c4 <uxTaskPriorityGet+0x12>
    27bc:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    27c0:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    27c4:	0f 90       	pop	r0
    27c6:	0f be       	out	0x3f, r0	; 63
    27c8:	fc 01       	movw	r30, r24
    27ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    27cc:	08 95       	ret

000027ce <vTaskStartScheduler>:
    27ce:	af 92       	push	r10
    27d0:	bf 92       	push	r11
    27d2:	cf 92       	push	r12
    27d4:	df 92       	push	r13
    27d6:	ef 92       	push	r14
    27d8:	ff 92       	push	r15
    27da:	0f 93       	push	r16
    27dc:	a1 2c       	mov	r10, r1
    27de:	b1 2c       	mov	r11, r1
    27e0:	c1 2c       	mov	r12, r1
    27e2:	d1 2c       	mov	r13, r1
    27e4:	0f 2e       	mov	r0, r31
    27e6:	fb ed       	ldi	r31, 0xDB	; 219
    27e8:	ef 2e       	mov	r14, r31
    27ea:	f1 e3       	ldi	r31, 0x31	; 49
    27ec:	ff 2e       	mov	r15, r31
    27ee:	f0 2d       	mov	r31, r0
    27f0:	00 e0       	ldi	r16, 0x00	; 0
    27f2:	20 e0       	ldi	r18, 0x00	; 0
    27f4:	30 e0       	ldi	r19, 0x00	; 0
    27f6:	44 e6       	ldi	r20, 0x64	; 100
    27f8:	50 e0       	ldi	r21, 0x00	; 0
    27fa:	63 e1       	ldi	r22, 0x13	; 19
    27fc:	71 e2       	ldi	r23, 0x21	; 33
    27fe:	81 e8       	ldi	r24, 0x81	; 129
    2800:	92 e1       	ldi	r25, 0x12	; 18
    2802:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xTaskGenericCreate>
    2806:	81 30       	cpi	r24, 0x01	; 1
    2808:	69 f4       	brne	.+26     	; 0x2824 <vTaskStartScheduler+0x56>
    280a:	f8 94       	cli
    280c:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <xSchedulerRunning>
    2810:	10 92 d6 31 	sts	0x31D6, r1	; 0x8031d6 <xTickCount>
    2814:	10 92 d7 31 	sts	0x31D7, r1	; 0x8031d7 <xTickCount+0x1>
    2818:	10 92 d8 31 	sts	0x31D8, r1	; 0x8031d8 <xTickCount+0x2>
    281c:	10 92 d9 31 	sts	0x31D9, r1	; 0x8031d9 <xTickCount+0x3>
    2820:	0e 94 9f 0e 	call	0x1d3e	; 0x1d3e <xPortStartScheduler>
    2824:	0f 91       	pop	r16
    2826:	ff 90       	pop	r15
    2828:	ef 90       	pop	r14
    282a:	df 90       	pop	r13
    282c:	cf 90       	pop	r12
    282e:	bf 90       	pop	r11
    2830:	af 90       	pop	r10
    2832:	08 95       	ret

00002834 <vTaskSuspendAll>:
    2834:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2838:	8f 5f       	subi	r24, 0xFF	; 255
    283a:	80 93 d2 31 	sts	0x31D2, r24	; 0x8031d2 <uxSchedulerSuspended>
    283e:	08 95       	ret

00002840 <xTaskGetTickCount>:
    2840:	0f b6       	in	r0, 0x3f	; 63
    2842:	f8 94       	cli
    2844:	0f 92       	push	r0
    2846:	60 91 d6 31 	lds	r22, 0x31D6	; 0x8031d6 <xTickCount>
    284a:	70 91 d7 31 	lds	r23, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    284e:	80 91 d8 31 	lds	r24, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2852:	90 91 d9 31 	lds	r25, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2856:	0f 90       	pop	r0
    2858:	0f be       	out	0x3f, r0	; 63
    285a:	08 95       	ret

0000285c <pcTaskGetTaskName>:
    285c:	00 97       	sbiw	r24, 0x00	; 0
    285e:	21 f4       	brne	.+8      	; 0x2868 <pcTaskGetTaskName+0xc>
    2860:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2864:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2868:	4d 96       	adiw	r24, 0x1d	; 29
    286a:	08 95       	ret

0000286c <xTaskGetIdleTaskHandle>:
    286c:	80 91 db 31 	lds	r24, 0x31DB	; 0x8031db <xIdleTaskHandle>
    2870:	90 91 dc 31 	lds	r25, 0x31DC	; 0x8031dc <xIdleTaskHandle+0x1>
    2874:	08 95       	ret

00002876 <vTaskIncrementTick>:
    2876:	ff 92       	push	r15
    2878:	0f 93       	push	r16
    287a:	1f 93       	push	r17
    287c:	cf 93       	push	r28
    287e:	df 93       	push	r29
    2880:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2884:	81 11       	cpse	r24, r1
    2886:	ed c0       	rjmp	.+474    	; 0x2a62 <vTaskIncrementTick+0x1ec>
    2888:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    288c:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2890:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2894:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2898:	01 96       	adiw	r24, 0x01	; 1
    289a:	a1 1d       	adc	r26, r1
    289c:	b1 1d       	adc	r27, r1
    289e:	80 93 d6 31 	sts	0x31D6, r24	; 0x8031d6 <xTickCount>
    28a2:	90 93 d7 31 	sts	0x31D7, r25	; 0x8031d7 <xTickCount+0x1>
    28a6:	a0 93 d8 31 	sts	0x31D8, r26	; 0x8031d8 <xTickCount+0x2>
    28aa:	b0 93 d9 31 	sts	0x31D9, r27	; 0x8031d9 <xTickCount+0x3>
    28ae:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    28b2:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    28b6:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    28ba:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    28be:	89 2b       	or	r24, r25
    28c0:	8a 2b       	or	r24, r26
    28c2:	8b 2b       	or	r24, r27
    28c4:	f1 f5       	brne	.+124    	; 0x2942 <vTaskIncrementTick+0xcc>
    28c6:	80 91 ea 31 	lds	r24, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    28ca:	90 91 eb 31 	lds	r25, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    28ce:	20 91 e8 31 	lds	r18, 0x31E8	; 0x8031e8 <pxOverflowDelayedTaskList>
    28d2:	30 91 e9 31 	lds	r19, 0x31E9	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    28d6:	20 93 ea 31 	sts	0x31EA, r18	; 0x8031ea <pxDelayedTaskList>
    28da:	30 93 eb 31 	sts	0x31EB, r19	; 0x8031eb <pxDelayedTaskList+0x1>
    28de:	80 93 e8 31 	sts	0x31E8, r24	; 0x8031e8 <pxOverflowDelayedTaskList>
    28e2:	90 93 e9 31 	sts	0x31E9, r25	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    28e6:	80 91 cf 31 	lds	r24, 0x31CF	; 0x8031cf <xNumOfOverflows>
    28ea:	8f 5f       	subi	r24, 0xFF	; 255
    28ec:	80 93 cf 31 	sts	0x31CF, r24	; 0x8031cf <xNumOfOverflows>
    28f0:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    28f4:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    28f8:	80 81       	ld	r24, Z
    28fa:	81 11       	cpse	r24, r1
    28fc:	0c c0       	rjmp	.+24     	; 0x2916 <vTaskIncrementTick+0xa0>
    28fe:	8f ef       	ldi	r24, 0xFF	; 255
    2900:	9f ef       	ldi	r25, 0xFF	; 255
    2902:	dc 01       	movw	r26, r24
    2904:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2908:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    290c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2910:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2914:	16 c0       	rjmp	.+44     	; 0x2942 <vTaskIncrementTick+0xcc>
    2916:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    291a:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    291e:	07 80       	ldd	r0, Z+7	; 0x07
    2920:	f0 85       	ldd	r31, Z+8	; 0x08
    2922:	e0 2d       	mov	r30, r0
    2924:	00 84       	ldd	r0, Z+8	; 0x08
    2926:	f1 85       	ldd	r31, Z+9	; 0x09
    2928:	e0 2d       	mov	r30, r0
    292a:	82 81       	ldd	r24, Z+2	; 0x02
    292c:	93 81       	ldd	r25, Z+3	; 0x03
    292e:	a4 81       	ldd	r26, Z+4	; 0x04
    2930:	b5 81       	ldd	r27, Z+5	; 0x05
    2932:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2936:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    293a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    293e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2942:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    2946:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    294a:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    294e:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2952:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2956:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    295a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    295e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2962:	48 17       	cp	r20, r24
    2964:	59 07       	cpc	r21, r25
    2966:	6a 07       	cpc	r22, r26
    2968:	7b 07       	cpc	r23, r27
    296a:	08 f4       	brcc	.+2      	; 0x296e <vTaskIncrementTick+0xf8>
    296c:	7f c0       	rjmp	.+254    	; 0x2a6c <vTaskIncrementTick+0x1f6>
    296e:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2972:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2976:	80 81       	ld	r24, Z
    2978:	88 23       	and	r24, r24
    297a:	f9 f0       	breq	.+62     	; 0x29ba <vTaskIncrementTick+0x144>
    297c:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2980:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2984:	07 80       	ldd	r0, Z+7	; 0x07
    2986:	f0 85       	ldd	r31, Z+8	; 0x08
    2988:	e0 2d       	mov	r30, r0
    298a:	c0 85       	ldd	r28, Z+8	; 0x08
    298c:	d1 85       	ldd	r29, Z+9	; 0x09
    298e:	8a 81       	ldd	r24, Y+2	; 0x02
    2990:	9b 81       	ldd	r25, Y+3	; 0x03
    2992:	ac 81       	ldd	r26, Y+4	; 0x04
    2994:	bd 81       	ldd	r27, Y+5	; 0x05
    2996:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    299a:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    299e:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    29a2:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    29a6:	48 17       	cp	r20, r24
    29a8:	59 07       	cpc	r21, r25
    29aa:	6a 07       	cpc	r22, r26
    29ac:	7b 07       	cpc	r23, r27
    29ae:	58 f1       	brcs	.+86     	; 0x2a06 <vTaskIncrementTick+0x190>
    29b0:	0f 2e       	mov	r0, r31
    29b2:	fb e0       	ldi	r31, 0x0B	; 11
    29b4:	ff 2e       	mov	r15, r31
    29b6:	f0 2d       	mov	r31, r0
    29b8:	2f c0       	rjmp	.+94     	; 0x2a18 <vTaskIncrementTick+0x1a2>
    29ba:	8f ef       	ldi	r24, 0xFF	; 255
    29bc:	9f ef       	ldi	r25, 0xFF	; 255
    29be:	dc 01       	movw	r26, r24
    29c0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    29c4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    29c8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    29cc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    29d0:	4d c0       	rjmp	.+154    	; 0x2a6c <vTaskIncrementTick+0x1f6>
    29d2:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    29d6:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    29da:	07 80       	ldd	r0, Z+7	; 0x07
    29dc:	f0 85       	ldd	r31, Z+8	; 0x08
    29de:	e0 2d       	mov	r30, r0
    29e0:	c0 85       	ldd	r28, Z+8	; 0x08
    29e2:	d1 85       	ldd	r29, Z+9	; 0x09
    29e4:	8a 81       	ldd	r24, Y+2	; 0x02
    29e6:	9b 81       	ldd	r25, Y+3	; 0x03
    29e8:	ac 81       	ldd	r26, Y+4	; 0x04
    29ea:	bd 81       	ldd	r27, Y+5	; 0x05
    29ec:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    29f0:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    29f4:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    29f8:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    29fc:	48 17       	cp	r20, r24
    29fe:	59 07       	cpc	r21, r25
    2a00:	6a 07       	cpc	r22, r26
    2a02:	7b 07       	cpc	r23, r27
    2a04:	48 f4       	brcc	.+18     	; 0x2a18 <vTaskIncrementTick+0x1a2>
    2a06:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2a0a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a0e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a12:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a16:	2a c0       	rjmp	.+84     	; 0x2a6c <vTaskIncrementTick+0x1f6>
    2a18:	8e 01       	movw	r16, r28
    2a1a:	0e 5f       	subi	r16, 0xFE	; 254
    2a1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a1e:	c8 01       	movw	r24, r16
    2a20:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
    2a24:	88 8d       	ldd	r24, Y+24	; 0x18
    2a26:	99 8d       	ldd	r25, Y+25	; 0x19
    2a28:	89 2b       	or	r24, r25
    2a2a:	21 f0       	breq	.+8      	; 0x2a34 <vTaskIncrementTick+0x1be>
    2a2c:	ce 01       	movw	r24, r28
    2a2e:	0e 96       	adiw	r24, 0x0e	; 14
    2a30:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
    2a34:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2a36:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2a3a:	98 17       	cp	r25, r24
    2a3c:	10 f4       	brcc	.+4      	; 0x2a42 <vTaskIncrementTick+0x1cc>
    2a3e:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2a42:	f8 9e       	mul	r15, r24
    2a44:	c0 01       	movw	r24, r0
    2a46:	11 24       	eor	r1, r1
    2a48:	b8 01       	movw	r22, r16
    2a4a:	8e 5f       	subi	r24, 0xFE	; 254
    2a4c:	9d 4c       	sbci	r25, 0xCD	; 205
    2a4e:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
    2a52:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2a56:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2a5a:	80 81       	ld	r24, Z
    2a5c:	81 11       	cpse	r24, r1
    2a5e:	b9 cf       	rjmp	.-142    	; 0x29d2 <vTaskIncrementTick+0x15c>
    2a60:	ac cf       	rjmp	.-168    	; 0x29ba <vTaskIncrementTick+0x144>
    2a62:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2a66:	8f 5f       	subi	r24, 0xFF	; 255
    2a68:	80 93 d1 31 	sts	0x31D1, r24	; 0x8031d1 <uxMissedTicks>
    2a6c:	df 91       	pop	r29
    2a6e:	cf 91       	pop	r28
    2a70:	1f 91       	pop	r17
    2a72:	0f 91       	pop	r16
    2a74:	ff 90       	pop	r15
    2a76:	08 95       	ret

00002a78 <xTaskResumeAll>:
    2a78:	cf 92       	push	r12
    2a7a:	df 92       	push	r13
    2a7c:	ef 92       	push	r14
    2a7e:	ff 92       	push	r15
    2a80:	0f 93       	push	r16
    2a82:	1f 93       	push	r17
    2a84:	cf 93       	push	r28
    2a86:	df 93       	push	r29
    2a88:	0f b6       	in	r0, 0x3f	; 63
    2a8a:	f8 94       	cli
    2a8c:	0f 92       	push	r0
    2a8e:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2a92:	81 50       	subi	r24, 0x01	; 1
    2a94:	80 93 d2 31 	sts	0x31D2, r24	; 0x8031d2 <uxSchedulerSuspended>
    2a98:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2a9c:	81 11       	cpse	r24, r1
    2a9e:	60 c0       	rjmp	.+192    	; 0x2b60 <xTaskResumeAll+0xe8>
    2aa0:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    2aa4:	81 11       	cpse	r24, r1
    2aa6:	2c c0       	rjmp	.+88     	; 0x2b00 <xTaskResumeAll+0x88>
    2aa8:	5e c0       	rjmp	.+188    	; 0x2b66 <xTaskResumeAll+0xee>
    2aaa:	d7 01       	movw	r26, r14
    2aac:	17 96       	adiw	r26, 0x07	; 7
    2aae:	ed 91       	ld	r30, X+
    2ab0:	fc 91       	ld	r31, X
    2ab2:	18 97       	sbiw	r26, 0x08	; 8
    2ab4:	c0 85       	ldd	r28, Z+8	; 0x08
    2ab6:	d1 85       	ldd	r29, Z+9	; 0x09
    2ab8:	ce 01       	movw	r24, r28
    2aba:	0e 96       	adiw	r24, 0x0e	; 14
    2abc:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
    2ac0:	8e 01       	movw	r16, r28
    2ac2:	0e 5f       	subi	r16, 0xFE	; 254
    2ac4:	1f 4f       	sbci	r17, 0xFF	; 255
    2ac6:	c8 01       	movw	r24, r16
    2ac8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
    2acc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ace:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2ad2:	98 17       	cp	r25, r24
    2ad4:	10 f4       	brcc	.+4      	; 0x2ada <xTaskResumeAll+0x62>
    2ad6:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2ada:	d8 9e       	mul	r13, r24
    2adc:	c0 01       	movw	r24, r0
    2ade:	11 24       	eor	r1, r1
    2ae0:	b8 01       	movw	r22, r16
    2ae2:	8e 5f       	subi	r24, 0xFE	; 254
    2ae4:	9d 4c       	sbci	r25, 0xCD	; 205
    2ae6:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
    2aea:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2aee:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2af2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2af4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2af6:	98 17       	cp	r25, r24
    2af8:	70 f0       	brcs	.+28     	; 0x2b16 <xTaskResumeAll+0x9e>
    2afa:	cc 24       	eor	r12, r12
    2afc:	c3 94       	inc	r12
    2afe:	0b c0       	rjmp	.+22     	; 0x2b16 <xTaskResumeAll+0x9e>
    2b00:	c1 2c       	mov	r12, r1
    2b02:	0f 2e       	mov	r0, r31
    2b04:	fd ed       	ldi	r31, 0xDD	; 221
    2b06:	ef 2e       	mov	r14, r31
    2b08:	f1 e3       	ldi	r31, 0x31	; 49
    2b0a:	ff 2e       	mov	r15, r31
    2b0c:	f0 2d       	mov	r31, r0
    2b0e:	0f 2e       	mov	r0, r31
    2b10:	fb e0       	ldi	r31, 0x0B	; 11
    2b12:	df 2e       	mov	r13, r31
    2b14:	f0 2d       	mov	r31, r0
    2b16:	f7 01       	movw	r30, r14
    2b18:	80 81       	ld	r24, Z
    2b1a:	81 11       	cpse	r24, r1
    2b1c:	c6 cf       	rjmp	.-116    	; 0x2aaa <xTaskResumeAll+0x32>
    2b1e:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b22:	88 23       	and	r24, r24
    2b24:	81 f0       	breq	.+32     	; 0x2b46 <xTaskResumeAll+0xce>
    2b26:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b2a:	88 23       	and	r24, r24
    2b2c:	99 f0       	breq	.+38     	; 0x2b54 <xTaskResumeAll+0xdc>
    2b2e:	0e 94 3b 14 	call	0x2876	; 0x2876 <vTaskIncrementTick>
    2b32:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b36:	81 50       	subi	r24, 0x01	; 1
    2b38:	80 93 d1 31 	sts	0x31D1, r24	; 0x8031d1 <uxMissedTicks>
    2b3c:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b40:	81 11       	cpse	r24, r1
    2b42:	f5 cf       	rjmp	.-22     	; 0x2b2e <xTaskResumeAll+0xb6>
    2b44:	07 c0       	rjmp	.+14     	; 0x2b54 <xTaskResumeAll+0xdc>
    2b46:	f1 e0       	ldi	r31, 0x01	; 1
    2b48:	cf 16       	cp	r12, r31
    2b4a:	21 f0       	breq	.+8      	; 0x2b54 <xTaskResumeAll+0xdc>
    2b4c:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <xMissedYield>
    2b50:	81 30       	cpi	r24, 0x01	; 1
    2b52:	41 f4       	brne	.+16     	; 0x2b64 <xTaskResumeAll+0xec>
    2b54:	10 92 d0 31 	sts	0x31D0, r1	; 0x8031d0 <xMissedYield>
    2b58:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
    2b5c:	81 e0       	ldi	r24, 0x01	; 1
    2b5e:	03 c0       	rjmp	.+6      	; 0x2b66 <xTaskResumeAll+0xee>
    2b60:	80 e0       	ldi	r24, 0x00	; 0
    2b62:	01 c0       	rjmp	.+2      	; 0x2b66 <xTaskResumeAll+0xee>
    2b64:	80 e0       	ldi	r24, 0x00	; 0
    2b66:	0f 90       	pop	r0
    2b68:	0f be       	out	0x3f, r0	; 63
    2b6a:	df 91       	pop	r29
    2b6c:	cf 91       	pop	r28
    2b6e:	1f 91       	pop	r17
    2b70:	0f 91       	pop	r16
    2b72:	ff 90       	pop	r15
    2b74:	ef 90       	pop	r14
    2b76:	df 90       	pop	r13
    2b78:	cf 90       	pop	r12
    2b7a:	08 95       	ret

00002b7c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b7c:	cf 92       	push	r12
    2b7e:	df 92       	push	r13
    2b80:	ef 92       	push	r14
    2b82:	ff 92       	push	r15
    2b84:	6b 01       	movw	r12, r22
    2b86:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b88:	67 2b       	or	r22, r23
    2b8a:	68 2b       	or	r22, r24
    2b8c:	69 2b       	or	r22, r25
    2b8e:	e9 f0       	breq	.+58     	; 0x2bca <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2b90:	0e 94 1a 14 	call	0x2834	; 0x2834 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2b94:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2b98:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2b9c:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2ba0:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2ba4:	c8 0e       	add	r12, r24
    2ba6:	d9 1e       	adc	r13, r25
    2ba8:	ea 1e       	adc	r14, r26
    2baa:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2bac:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2bb0:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2bb4:	02 96       	adiw	r24, 0x02	; 2
    2bb6:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2bba:	c7 01       	movw	r24, r14
    2bbc:	b6 01       	movw	r22, r12
    2bbe:	0e 94 89 12 	call	0x2512	; 0x2512 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2bc2:	0e 94 3c 15 	call	0x2a78	; 0x2a78 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2bc6:	81 11       	cpse	r24, r1
    2bc8:	02 c0       	rjmp	.+4      	; 0x2bce <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2bca:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vPortYield>
		}
	}
    2bce:	ff 90       	pop	r15
    2bd0:	ef 90       	pop	r14
    2bd2:	df 90       	pop	r13
    2bd4:	cf 90       	pop	r12
    2bd6:	08 95       	ret

00002bd8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2bd8:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2bdc:	81 11       	cpse	r24, r1
    2bde:	0c c0       	rjmp	.+24     	; 0x2bf8 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2be0:	e0 91 d4 31 	lds	r30, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2be4:	4b e0       	ldi	r20, 0x0B	; 11
    2be6:	e4 9f       	mul	r30, r20
    2be8:	f0 01       	movw	r30, r0
    2bea:	11 24       	eor	r1, r1
    2bec:	ee 5f       	subi	r30, 0xFE	; 254
    2bee:	fd 4c       	sbci	r31, 0xCD	; 205
    2bf0:	80 81       	ld	r24, Z
    2bf2:	88 23       	and	r24, r24
    2bf4:	29 f0       	breq	.+10     	; 0x2c00 <vTaskSwitchContext+0x28>
    2bf6:	14 c0       	rjmp	.+40     	; 0x2c20 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <xMissedYield>
    2bfe:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c00:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2c02:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c06:	81 50       	subi	r24, 0x01	; 1
    2c08:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c0c:	e0 91 d4 31 	lds	r30, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c10:	9e 9f       	mul	r25, r30
    2c12:	f0 01       	movw	r30, r0
    2c14:	11 24       	eor	r1, r1
    2c16:	ee 5f       	subi	r30, 0xFE	; 254
    2c18:	fd 4c       	sbci	r31, 0xCD	; 205
    2c1a:	80 81       	ld	r24, Z
    2c1c:	88 23       	and	r24, r24
    2c1e:	89 f3       	breq	.-30     	; 0x2c02 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2c20:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c24:	28 2f       	mov	r18, r24
    2c26:	30 e0       	ldi	r19, 0x00	; 0
    2c28:	4b e0       	ldi	r20, 0x0B	; 11
    2c2a:	84 9f       	mul	r24, r20
    2c2c:	c0 01       	movw	r24, r0
    2c2e:	11 24       	eor	r1, r1
    2c30:	dc 01       	movw	r26, r24
    2c32:	ae 5f       	subi	r26, 0xFE	; 254
    2c34:	bd 4c       	sbci	r27, 0xCD	; 205
    2c36:	11 96       	adiw	r26, 0x01	; 1
    2c38:	ed 91       	ld	r30, X+
    2c3a:	fc 91       	ld	r31, X
    2c3c:	12 97       	sbiw	r26, 0x02	; 2
    2c3e:	04 80       	ldd	r0, Z+4	; 0x04
    2c40:	f5 81       	ldd	r31, Z+5	; 0x05
    2c42:	e0 2d       	mov	r30, r0
    2c44:	11 96       	adiw	r26, 0x01	; 1
    2c46:	ed 93       	st	X+, r30
    2c48:	fc 93       	st	X, r31
    2c4a:	12 97       	sbiw	r26, 0x02	; 2
    2c4c:	8b 5f       	subi	r24, 0xFB	; 251
    2c4e:	9d 4c       	sbci	r25, 0xCD	; 205
    2c50:	e8 17       	cp	r30, r24
    2c52:	f9 07       	cpc	r31, r25
    2c54:	61 f4       	brne	.+24     	; 0x2c6e <vTaskSwitchContext+0x96>
    2c56:	84 81       	ldd	r24, Z+4	; 0x04
    2c58:	95 81       	ldd	r25, Z+5	; 0x05
    2c5a:	4b e0       	ldi	r20, 0x0B	; 11
    2c5c:	42 9f       	mul	r20, r18
    2c5e:	f0 01       	movw	r30, r0
    2c60:	43 9f       	mul	r20, r19
    2c62:	f0 0d       	add	r31, r0
    2c64:	11 24       	eor	r1, r1
    2c66:	ee 5f       	subi	r30, 0xFE	; 254
    2c68:	fd 4c       	sbci	r31, 0xCD	; 205
    2c6a:	81 83       	std	Z+1, r24	; 0x01
    2c6c:	92 83       	std	Z+2, r25	; 0x02
    2c6e:	8b e0       	ldi	r24, 0x0B	; 11
    2c70:	82 9f       	mul	r24, r18
    2c72:	f0 01       	movw	r30, r0
    2c74:	83 9f       	mul	r24, r19
    2c76:	f0 0d       	add	r31, r0
    2c78:	11 24       	eor	r1, r1
    2c7a:	ee 5f       	subi	r30, 0xFE	; 254
    2c7c:	fd 4c       	sbci	r31, 0xCD	; 205
    2c7e:	01 80       	ldd	r0, Z+1	; 0x01
    2c80:	f2 81       	ldd	r31, Z+2	; 0x02
    2c82:	e0 2d       	mov	r30, r0
    2c84:	80 85       	ldd	r24, Z+8	; 0x08
    2c86:	91 85       	ldd	r25, Z+9	; 0x09
    2c88:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <pxCurrentTCB>
    2c8c:	90 93 2f 32 	sts	0x322F, r25	; 0x80322f <pxCurrentTCB+0x1>
    2c90:	08 95       	ret

00002c92 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2c92:	cf 92       	push	r12
    2c94:	df 92       	push	r13
    2c96:	ef 92       	push	r14
    2c98:	ff 92       	push	r15
    2c9a:	6a 01       	movw	r12, r20
    2c9c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2c9e:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    2ca2:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2ca6:	62 5f       	subi	r22, 0xF2	; 242
    2ca8:	7f 4f       	sbci	r23, 0xFF	; 255
    2caa:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cae:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2cb2:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2cb6:	02 96       	adiw	r24, 0x02	; 2
    2cb8:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2cbc:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2cc0:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2cc4:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2cc8:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ccc:	bc 01       	movw	r22, r24
    2cce:	cd 01       	movw	r24, r26
    2cd0:	6c 0d       	add	r22, r12
    2cd2:	7d 1d       	adc	r23, r13
    2cd4:	8e 1d       	adc	r24, r14
    2cd6:	9f 1d       	adc	r25, r15
    2cd8:	0e 94 89 12 	call	0x2512	; 0x2512 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2cdc:	ff 90       	pop	r15
    2cde:	ef 90       	pop	r14
    2ce0:	df 90       	pop	r13
    2ce2:	cf 90       	pop	r12
    2ce4:	08 95       	ret

00002ce6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2ce6:	0f 93       	push	r16
    2ce8:	1f 93       	push	r17
    2cea:	cf 93       	push	r28
    2cec:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cee:	dc 01       	movw	r26, r24
    2cf0:	17 96       	adiw	r26, 0x07	; 7
    2cf2:	ed 91       	ld	r30, X+
    2cf4:	fc 91       	ld	r31, X
    2cf6:	18 97       	sbiw	r26, 0x08	; 8
    2cf8:	c0 85       	ldd	r28, Z+8	; 0x08
    2cfa:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2cfc:	8e 01       	movw	r16, r28
    2cfe:	02 5f       	subi	r16, 0xF2	; 242
    2d00:	1f 4f       	sbci	r17, 0xFF	; 255
    2d02:	c8 01       	movw	r24, r16
    2d04:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d08:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2d0c:	81 11       	cpse	r24, r1
    2d0e:	16 c0       	rjmp	.+44     	; 0x2d3c <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d10:	0c 50       	subi	r16, 0x0C	; 12
    2d12:	11 09       	sbc	r17, r1
    2d14:	c8 01       	movw	r24, r16
    2d16:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d1a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d1c:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2d20:	98 17       	cp	r25, r24
    2d22:	10 f4       	brcc	.+4      	; 0x2d28 <xTaskRemoveFromEventList+0x42>
    2d24:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2d28:	bb e0       	ldi	r27, 0x0B	; 11
    2d2a:	8b 9f       	mul	r24, r27
    2d2c:	c0 01       	movw	r24, r0
    2d2e:	11 24       	eor	r1, r1
    2d30:	b8 01       	movw	r22, r16
    2d32:	8e 5f       	subi	r24, 0xFE	; 254
    2d34:	9d 4c       	sbci	r25, 0xCD	; 205
    2d36:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
    2d3a:	05 c0       	rjmp	.+10     	; 0x2d46 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2d3c:	b8 01       	movw	r22, r16
    2d3e:	8d ed       	ldi	r24, 0xDD	; 221
    2d40:	91 e3       	ldi	r25, 0x31	; 49
    2d42:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d46:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2d4a:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d52:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d54:	29 17       	cp	r18, r25
    2d56:	08 f4       	brcc	.+2      	; 0x2d5a <xTaskRemoveFromEventList+0x74>
    2d58:	80 e0       	ldi	r24, 0x00	; 0
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	1f 91       	pop	r17
    2d60:	0f 91       	pop	r16
    2d62:	08 95       	ret

00002d64 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2d64:	20 91 cf 31 	lds	r18, 0x31CF	; 0x8031cf <xNumOfOverflows>
    2d68:	fc 01       	movw	r30, r24
    2d6a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d6c:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    2d70:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2d74:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2d78:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2d7c:	41 83       	std	Z+1, r20	; 0x01
    2d7e:	52 83       	std	Z+2, r21	; 0x02
    2d80:	63 83       	std	Z+3, r22	; 0x03
    2d82:	74 83       	std	Z+4, r23	; 0x04
    2d84:	08 95       	ret

00002d86 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d86:	8f 92       	push	r8
    2d88:	9f 92       	push	r9
    2d8a:	af 92       	push	r10
    2d8c:	bf 92       	push	r11
    2d8e:	cf 92       	push	r12
    2d90:	df 92       	push	r13
    2d92:	ef 92       	push	r14
    2d94:	ff 92       	push	r15
    2d96:	0f 93       	push	r16
    2d98:	1f 93       	push	r17
    2d9a:	cf 93       	push	r28
    2d9c:	df 93       	push	r29
    2d9e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2da0:	0f b6       	in	r0, 0x3f	; 63
    2da2:	f8 94       	cli
    2da4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2da6:	80 91 cf 31 	lds	r24, 0x31CF	; 0x8031cf <xNumOfOverflows>
    2daa:	90 81       	ld	r25, Z
    2dac:	98 17       	cp	r25, r24
    2dae:	89 f0       	breq	.+34     	; 0x2dd2 <xTaskCheckForTimeOut+0x4c>
    2db0:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2db4:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2db8:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2dbc:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2dc0:	01 81       	ldd	r16, Z+1	; 0x01
    2dc2:	12 81       	ldd	r17, Z+2	; 0x02
    2dc4:	23 81       	ldd	r18, Z+3	; 0x03
    2dc6:	34 81       	ldd	r19, Z+4	; 0x04
    2dc8:	80 17       	cp	r24, r16
    2dca:	91 07       	cpc	r25, r17
    2dcc:	a2 07       	cpc	r26, r18
    2dce:	b3 07       	cpc	r27, r19
    2dd0:	a8 f5       	brcc	.+106    	; 0x2e3c <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2dd2:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2dd6:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2dda:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2dde:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2de2:	c1 80       	ldd	r12, Z+1	; 0x01
    2de4:	d2 80       	ldd	r13, Z+2	; 0x02
    2de6:	e3 80       	ldd	r14, Z+3	; 0x03
    2de8:	f4 80       	ldd	r15, Z+4	; 0x04
    2dea:	eb 01       	movw	r28, r22
    2dec:	08 81       	ld	r16, Y
    2dee:	19 81       	ldd	r17, Y+1	; 0x01
    2df0:	2a 81       	ldd	r18, Y+2	; 0x02
    2df2:	3b 81       	ldd	r19, Y+3	; 0x03
    2df4:	8c 19       	sub	r24, r12
    2df6:	9d 09       	sbc	r25, r13
    2df8:	ae 09       	sbc	r26, r14
    2dfa:	bf 09       	sbc	r27, r15
    2dfc:	80 17       	cp	r24, r16
    2dfe:	91 07       	cpc	r25, r17
    2e00:	a2 07       	cpc	r26, r18
    2e02:	b3 07       	cpc	r27, r19
    2e04:	e8 f4       	brcc	.+58     	; 0x2e40 <xTaskCheckForTimeOut+0xba>
    2e06:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2e08:	80 90 d6 31 	lds	r8, 0x31D6	; 0x8031d6 <xTickCount>
    2e0c:	90 90 d7 31 	lds	r9, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2e10:	a0 90 d8 31 	lds	r10, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2e14:	b0 90 d9 31 	lds	r11, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2e18:	b5 01       	movw	r22, r10
    2e1a:	a4 01       	movw	r20, r8
    2e1c:	4c 19       	sub	r20, r12
    2e1e:	5d 09       	sbc	r21, r13
    2e20:	6e 09       	sbc	r22, r14
    2e22:	7f 09       	sbc	r23, r15
    2e24:	04 1b       	sub	r16, r20
    2e26:	15 0b       	sbc	r17, r21
    2e28:	26 0b       	sbc	r18, r22
    2e2a:	37 0b       	sbc	r19, r23
    2e2c:	08 83       	st	Y, r16
    2e2e:	19 83       	std	Y+1, r17	; 0x01
    2e30:	2a 83       	std	Y+2, r18	; 0x02
    2e32:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2e34:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2e38:	80 e0       	ldi	r24, 0x00	; 0
    2e3a:	03 c0       	rjmp	.+6      	; 0x2e42 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e3c:	81 e0       	ldi	r24, 0x01	; 1
    2e3e:	01 c0       	rjmp	.+2      	; 0x2e42 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2e40:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2e42:	0f 90       	pop	r0
    2e44:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2e46:	df 91       	pop	r29
    2e48:	cf 91       	pop	r28
    2e4a:	1f 91       	pop	r17
    2e4c:	0f 91       	pop	r16
    2e4e:	ff 90       	pop	r15
    2e50:	ef 90       	pop	r14
    2e52:	df 90       	pop	r13
    2e54:	cf 90       	pop	r12
    2e56:	bf 90       	pop	r11
    2e58:	af 90       	pop	r10
    2e5a:	9f 90       	pop	r9
    2e5c:	8f 90       	pop	r8
    2e5e:	08 95       	ret

00002e60 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2e60:	81 e0       	ldi	r24, 0x01	; 1
    2e62:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <xMissedYield>
    2e66:	08 95       	ret

00002e68 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2e68:	00 97       	sbiw	r24, 0x00	; 0
    2e6a:	21 f4       	brne	.+8      	; 0x2e74 <uxTaskGetStackHighWaterMark+0xc>
    2e6c:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2e70:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2e74:	dc 01       	movw	r26, r24
    2e76:	5b 96       	adiw	r26, 0x1b	; 27
    2e78:	ed 91       	ld	r30, X+
    2e7a:	fc 91       	ld	r31, X
    2e7c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e7e:	80 81       	ld	r24, Z
    2e80:	81 31       	cpi	r24, 0x11	; 17
    2e82:	41 f4       	brne	.+16     	; 0x2e94 <uxTaskGetStackHighWaterMark+0x2c>
    2e84:	31 96       	adiw	r30, 0x01	; 1
    2e86:	80 e0       	ldi	r24, 0x00	; 0
    2e88:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2e8a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e8c:	21 91       	ld	r18, Z+
    2e8e:	21 31       	cpi	r18, 0x11	; 17
    2e90:	e1 f3       	breq	.-8      	; 0x2e8a <uxTaskGetStackHighWaterMark+0x22>
    2e92:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2e94:	80 e0       	ldi	r24, 0x00	; 0
    2e96:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2e98:	08 95       	ret

00002e9a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2e9a:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2e9e:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>

		return xReturn;
	}
    2ea2:	08 95       	ret

00002ea4 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2ea4:	0f 93       	push	r16
    2ea6:	1f 93       	push	r17
    2ea8:	cf 93       	push	r28
    2eaa:	df 93       	push	r29
    2eac:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2eae:	22 8d       	ldd	r18, Z+26	; 0x1a
    2eb0:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2eb4:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2eb8:	5a 96       	adiw	r26, 0x1a	; 26
    2eba:	8c 91       	ld	r24, X
    2ebc:	28 17       	cp	r18, r24
    2ebe:	08 f0       	brcs	.+2      	; 0x2ec2 <vTaskPriorityInherit+0x1e>
    2ec0:	41 c0       	rjmp	.+130    	; 0x2f44 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2ec2:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2ec6:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2eca:	5a 96       	adiw	r26, 0x1a	; 26
    2ecc:	3c 91       	ld	r19, X
    2ece:	84 e0       	ldi	r24, 0x04	; 4
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	a0 e0       	ldi	r26, 0x00	; 0
    2ed4:	b0 e0       	ldi	r27, 0x00	; 0
    2ed6:	83 1b       	sub	r24, r19
    2ed8:	91 09       	sbc	r25, r1
    2eda:	a1 09       	sbc	r26, r1
    2edc:	b1 09       	sbc	r27, r1
    2ede:	86 87       	std	Z+14, r24	; 0x0e
    2ee0:	97 87       	std	Z+15, r25	; 0x0f
    2ee2:	a0 8b       	std	Z+16, r26	; 0x10
    2ee4:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2ee6:	8b e0       	ldi	r24, 0x0B	; 11
    2ee8:	28 9f       	mul	r18, r24
    2eea:	90 01       	movw	r18, r0
    2eec:	11 24       	eor	r1, r1
    2eee:	2e 5f       	subi	r18, 0xFE	; 254
    2ef0:	3d 4c       	sbci	r19, 0xCD	; 205
    2ef2:	84 85       	ldd	r24, Z+12	; 0x0c
    2ef4:	95 85       	ldd	r25, Z+13	; 0x0d
    2ef6:	82 17       	cp	r24, r18
    2ef8:	93 07       	cpc	r25, r19
    2efa:	e9 f4       	brne	.+58     	; 0x2f36 <vTaskPriorityInherit+0x92>
    2efc:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2efe:	ef 01       	movw	r28, r30
    2f00:	22 96       	adiw	r28, 0x02	; 2
    2f02:	ce 01       	movw	r24, r28
    2f04:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f08:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2f0c:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2f10:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f12:	f8 01       	movw	r30, r16
    2f14:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2f16:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2f1a:	98 17       	cp	r25, r24
    2f1c:	10 f4       	brcc	.+4      	; 0x2f22 <vTaskPriorityInherit+0x7e>
    2f1e:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2f22:	fb e0       	ldi	r31, 0x0B	; 11
    2f24:	8f 9f       	mul	r24, r31
    2f26:	c0 01       	movw	r24, r0
    2f28:	11 24       	eor	r1, r1
    2f2a:	be 01       	movw	r22, r28
    2f2c:	8e 5f       	subi	r24, 0xFE	; 254
    2f2e:	9d 4c       	sbci	r25, 0xCD	; 205
    2f30:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
    2f34:	07 c0       	rjmp	.+14     	; 0x2f44 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f36:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2f3a:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2f3e:	5a 96       	adiw	r26, 0x1a	; 26
    2f40:	8c 91       	ld	r24, X
    2f42:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2f44:	df 91       	pop	r29
    2f46:	cf 91       	pop	r28
    2f48:	1f 91       	pop	r17
    2f4a:	0f 91       	pop	r16
    2f4c:	08 95       	ret

00002f4e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2f4e:	0f 93       	push	r16
    2f50:	1f 93       	push	r17
    2f52:	cf 93       	push	r28
    2f54:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2f56:	00 97       	sbiw	r24, 0x00	; 0
    2f58:	49 f1       	breq	.+82     	; 0x2fac <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	32 8d       	ldd	r19, Z+26	; 0x1a
    2f5e:	27 a1       	ldd	r18, Z+39	; 0x27
    2f60:	32 17       	cp	r19, r18
    2f62:	21 f1       	breq	.+72     	; 0x2fac <vTaskPriorityDisinherit+0x5e>
    2f64:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2f66:	8c 01       	movw	r16, r24
    2f68:	0e 5f       	subi	r16, 0xFE	; 254
    2f6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f6c:	c8 01       	movw	r24, r16
    2f6e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2f72:	8f a1       	ldd	r24, Y+39	; 0x27
    2f74:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2f76:	44 e0       	ldi	r20, 0x04	; 4
    2f78:	50 e0       	ldi	r21, 0x00	; 0
    2f7a:	60 e0       	ldi	r22, 0x00	; 0
    2f7c:	70 e0       	ldi	r23, 0x00	; 0
    2f7e:	48 1b       	sub	r20, r24
    2f80:	51 09       	sbc	r21, r1
    2f82:	61 09       	sbc	r22, r1
    2f84:	71 09       	sbc	r23, r1
    2f86:	4e 87       	std	Y+14, r20	; 0x0e
    2f88:	5f 87       	std	Y+15, r21	; 0x0f
    2f8a:	68 8b       	std	Y+16, r22	; 0x10
    2f8c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2f8e:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2f92:	98 17       	cp	r25, r24
    2f94:	10 f4       	brcc	.+4      	; 0x2f9a <vTaskPriorityDisinherit+0x4c>
    2f96:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2f9a:	fb e0       	ldi	r31, 0x0B	; 11
    2f9c:	8f 9f       	mul	r24, r31
    2f9e:	c0 01       	movw	r24, r0
    2fa0:	11 24       	eor	r1, r1
    2fa2:	b8 01       	movw	r22, r16
    2fa4:	8e 5f       	subi	r24, 0xFE	; 254
    2fa6:	9d 4c       	sbci	r25, 0xCD	; 205
    2fa8:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInsertEnd>
			}
		}
	}
    2fac:	df 91       	pop	r29
    2fae:	cf 91       	pop	r28
    2fb0:	1f 91       	pop	r17
    2fb2:	0f 91       	pop	r16
    2fb4:	08 95       	ret

00002fb6 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2fb6:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2fb8:	e8 81       	ld	r30, Y
    2fba:	f9 81       	ldd	r31, Y+1	; 0x01
    2fbc:	01 90       	ld	r0, Z+
    2fbe:	f0 81       	ld	r31, Z
    2fc0:	e0 2d       	mov	r30, r0
    2fc2:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2fc4:	1a 82       	std	Y+2, r1	; 0x02
    2fc6:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2fc8:	6f ef       	ldi	r22, 0xFF	; 255
    2fca:	7f ef       	ldi	r23, 0xFF	; 255
    2fcc:	cb 01       	movw	r24, r22
    2fce:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <vTaskDelay>
    2fd2:	fa cf       	rjmp	.-12     	; 0x2fc8 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002fd4 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2fd8:	65 87       	std	Z+13, r22	; 0x0d
    2fda:	08 95       	ret

00002fdc <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2fdc:	4f 92       	push	r4
    2fde:	5f 92       	push	r5
    2fe0:	6f 92       	push	r6
    2fe2:	7f 92       	push	r7
    2fe4:	8f 92       	push	r8
    2fe6:	9f 92       	push	r9
    2fe8:	af 92       	push	r10
    2fea:	bf 92       	push	r11
    2fec:	cf 92       	push	r12
    2fee:	df 92       	push	r13
    2ff0:	ef 92       	push	r14
    2ff2:	ff 92       	push	r15
    2ff4:	0f 93       	push	r16
    2ff6:	1f 93       	push	r17
    2ff8:	cf 93       	push	r28
    2ffa:	df 93       	push	r29
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
    3000:	2a 97       	sbiw	r28, 0x0a	; 10
    3002:	cd bf       	out	0x3d, r28	; 61
    3004:	de bf       	out	0x3e, r29	; 62
    3006:	4c 01       	movw	r8, r24
    3008:	29 01       	movw	r4, r18
    300a:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    300c:	8c e1       	ldi	r24, 0x1C	; 28
    300e:	91 e2       	ldi	r25, 0x21	; 33
    3010:	f4 01       	movw	r30, r8
    3012:	80 83       	st	Z, r24
    3014:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3016:	fb 01       	movw	r30, r22
    3018:	80 81       	ld	r24, Z
    301a:	88 23       	and	r24, r24
    301c:	69 f0       	breq	.+26     	; 0x3038 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    301e:	de 01       	movw	r26, r28
    3020:	11 96       	adiw	r26, 0x01	; 1
    3022:	31 96       	adiw	r30, 0x01	; 1
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	02 c0       	rjmp	.+4      	; 0x302c <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3028:	99 30       	cpi	r25, 0x09	; 9
    302a:	39 f0       	breq	.+14     	; 0x303a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    302c:	9f 5f       	subi	r25, 0xFF	; 255
    302e:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3030:	81 91       	ld	r24, Z+
    3032:	81 11       	cpse	r24, r1
    3034:	f9 cf       	rjmp	.-14     	; 0x3028 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3036:	01 c0       	rjmp	.+2      	; 0x303a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3038:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    303a:	e1 e0       	ldi	r30, 0x01	; 1
    303c:	f0 e0       	ldi	r31, 0x00	; 0
    303e:	ec 0f       	add	r30, r28
    3040:	fd 1f       	adc	r31, r29
    3042:	e9 0f       	add	r30, r25
    3044:	f1 1d       	adc	r31, r1
    3046:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3048:	74 01       	movw	r14, r8
    304a:	f2 e0       	ldi	r31, 0x02	; 2
    304c:	ef 0e       	add	r14, r31
    304e:	f1 1c       	adc	r15, r1
    3050:	a1 2c       	mov	r10, r1
    3052:	b1 2c       	mov	r11, r1
    3054:	c1 2c       	mov	r12, r1
    3056:	d1 2c       	mov	r13, r1
    3058:	04 2f       	mov	r16, r20
    305a:	94 01       	movw	r18, r8
    305c:	a2 01       	movw	r20, r4
    305e:	be 01       	movw	r22, r28
    3060:	6f 5f       	subi	r22, 0xFF	; 255
    3062:	7f 4f       	sbci	r23, 0xFF	; 255
    3064:	82 e3       	ldi	r24, 0x32	; 50
    3066:	93 e0       	ldi	r25, 0x03	; 3
    3068:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    306c:	f4 01       	movw	r30, r8
    306e:	66 82       	std	Z+6, r6	; 0x06
    3070:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3072:	40 86       	std	Z+8, r4	; 0x08
    3074:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3076:	20 91 30 32 	lds	r18, 0x3230	; 0x803230 <last_created_task_pointer>
    307a:	30 91 31 32 	lds	r19, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    307e:	24 83       	std	Z+4, r18	; 0x04
    3080:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3082:	80 92 30 32 	sts	0x3230, r8	; 0x803230 <last_created_task_pointer>
    3086:	90 92 31 32 	sts	0x3231, r9	; 0x803231 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    308a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    308c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    308e:	40 90 92 32 	lds	r4, 0x3292	; 0x803292 <portStackTopForTask>
    3092:	50 90 93 32 	lds	r5, 0x3293	; 0x803293 <portStackTopForTask+0x1>
    3096:	ff ef       	ldi	r31, 0xFF	; 255
    3098:	4f 1a       	sub	r4, r31
    309a:	5f 0a       	sbc	r5, r31
    309c:	40 92 92 32 	sts	0x3292, r4	; 0x803292 <portStackTopForTask>
    30a0:	50 92 93 32 	sts	0x3293, r5	; 0x803293 <portStackTopForTask+0x1>
    30a4:	f4 01       	movw	r30, r8
    30a6:	42 86       	std	Z+10, r4	; 0x0a
    30a8:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    30aa:	16 86       	std	Z+14, r1	; 0x0e
    30ac:	17 86       	std	Z+15, r1	; 0x0f
    30ae:	10 8a       	std	Z+16, r1	; 0x10
    30b0:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    30b2:	61 14       	cp	r6, r1
    30b4:	71 04       	cpc	r7, r1
    30b6:	09 f4       	brne	.+2      	; 0x30ba <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    30b8:	44 c0       	rjmp	.+136    	; 0x3142 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    30ba:	81 30       	cpi	r24, 0x01	; 1
    30bc:	79 f5       	brne	.+94     	; 0x311c <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    30be:	6a e0       	ldi	r22, 0x0A	; 10
    30c0:	c3 01       	movw	r24, r6
    30c2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    30c6:	7c 01       	movw	r14, r24
    30c8:	61 eb       	ldi	r22, 0xB1	; 177
    30ca:	75 e0       	ldi	r23, 0x05	; 5
    30cc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    30d0:	be 01       	movw	r22, r28
    30d2:	6f 5f       	subi	r22, 0xFF	; 255
    30d4:	7f 4f       	sbci	r23, 0xFF	; 255
    30d6:	c7 01       	movw	r24, r14
    30d8:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    30dc:	6a e0       	ldi	r22, 0x0A	; 10
    30de:	c7 01       	movw	r24, r14
    30e0:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    30e4:	7c 01       	movw	r14, r24
    30e6:	68 ea       	ldi	r22, 0xA8	; 168
    30e8:	75 e0       	ldi	r23, 0x05	; 5
    30ea:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    30ee:	6a e0       	ldi	r22, 0x0A	; 10
    30f0:	c7 01       	movw	r24, r14
    30f2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    30f6:	7c 01       	movw	r14, r24
    30f8:	6a e9       	ldi	r22, 0x9A	; 154
    30fa:	75 e0       	ldi	r23, 0x05	; 5
    30fc:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3100:	63 e0       	ldi	r22, 0x03	; 3
    3102:	c7 01       	movw	r24, r14
    3104:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3108:	b2 01       	movw	r22, r4
    310a:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    310e:	62 e0       	ldi	r22, 0x02	; 2
    3110:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3114:	66 e0       	ldi	r22, 0x06	; 6
    3116:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    311a:	13 c0       	rjmp	.+38     	; 0x3142 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    311c:	6a e0       	ldi	r22, 0x0A	; 10
    311e:	c3 01       	movw	r24, r6
    3120:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3124:	4c 01       	movw	r8, r24
    3126:	65 e8       	ldi	r22, 0x85	; 133
    3128:	75 e0       	ldi	r23, 0x05	; 5
    312a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    312e:	be 01       	movw	r22, r28
    3130:	6f 5f       	subi	r22, 0xFF	; 255
    3132:	7f 4f       	sbci	r23, 0xFF	; 255
    3134:	c4 01       	movw	r24, r8
    3136:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    313a:	66 e0       	ldi	r22, 0x06	; 6
    313c:	c4 01       	movw	r24, r8
    313e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3142:	2a 96       	adiw	r28, 0x0a	; 10
    3144:	cd bf       	out	0x3d, r28	; 61
    3146:	de bf       	out	0x3e, r29	; 62
    3148:	df 91       	pop	r29
    314a:	cf 91       	pop	r28
    314c:	1f 91       	pop	r17
    314e:	0f 91       	pop	r16
    3150:	ff 90       	pop	r15
    3152:	ef 90       	pop	r14
    3154:	df 90       	pop	r13
    3156:	cf 90       	pop	r12
    3158:	bf 90       	pop	r11
    315a:	af 90       	pop	r10
    315c:	9f 90       	pop	r9
    315e:	8f 90       	pop	r8
    3160:	7f 90       	pop	r7
    3162:	6f 90       	pop	r6
    3164:	5f 90       	pop	r5
    3166:	4f 90       	pop	r4
    3168:	08 95       	ret

0000316a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    316a:	cf 92       	push	r12
    316c:	df 92       	push	r13
    316e:	ef 92       	push	r14
    3170:	ff 92       	push	r15
    3172:	0f 93       	push	r16
    3174:	1f 93       	push	r17
    3176:	cf 93       	push	r28
    3178:	df 93       	push	r29
    317a:	ec 01       	movw	r28, r24
    317c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    317e:	8a 81       	ldd	r24, Y+2	; 0x02
    3180:	9b 81       	ldd	r25, Y+3	; 0x03
    3182:	0e 94 2e 14 	call	0x285c	; 0x285c <pcTaskGetTaskName>
    3186:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3188:	6a e0       	ldi	r22, 0x0A	; 10
    318a:	c7 01       	movw	r24, r14
    318c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3190:	8c 01       	movw	r16, r24
    3192:	64 ec       	ldi	r22, 0xC4	; 196
    3194:	75 e0       	ldi	r23, 0x05	; 5
    3196:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    319a:	6a e0       	ldi	r22, 0x0A	; 10
    319c:	c8 01       	movw	r24, r16
    319e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    31a2:	8c 01       	movw	r16, r24
    31a4:	6d eb       	ldi	r22, 0xBD	; 189
    31a6:	75 e0       	ldi	r23, 0x05	; 5
    31a8:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    31ac:	b6 01       	movw	r22, r12
    31ae:	c8 01       	movw	r24, r16
    31b0:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    31b4:	6a e0       	ldi	r22, 0x0A	; 10
    31b6:	c8 01       	movw	r24, r16
    31b8:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    31bc:	8c 01       	movw	r16, r24
    31be:	67 eb       	ldi	r22, 0xB7	; 183
    31c0:	75 e0       	ldi	r23, 0x05	; 5
    31c2:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    31c6:	66 e0       	ldi	r22, 0x06	; 6
    31c8:	c8 01       	movw	r24, r16
    31ca:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    31ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    31d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    31d2:	e8 85       	ldd	r30, Y+8	; 0x08
    31d4:	f9 85       	ldd	r31, Y+9	; 0x09
    31d6:	01 e1       	ldi	r16, 0x11	; 17
    31d8:	21 e0       	ldi	r18, 0x01	; 1
    31da:	a7 01       	movw	r20, r14
    31dc:	bc 01       	movw	r22, r24
    31de:	8e 1b       	sub	r24, r30
    31e0:	9f 0b       	sbc	r25, r31
    31e2:	0e 94 b7 1b 	call	0x376e	; 0x376e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    31e6:	8c 81       	ldd	r24, Y+4	; 0x04
    31e8:	9d 81       	ldd	r25, Y+5	; 0x05
    31ea:	00 97       	sbiw	r24, 0x00	; 0
    31ec:	19 f0       	breq	.+6      	; 0x31f4 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    31ee:	b7 01       	movw	r22, r14
    31f0:	0e 94 b5 18 	call	0x316a	; 0x316a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    31f4:	df 91       	pop	r29
    31f6:	cf 91       	pop	r28
    31f8:	1f 91       	pop	r17
    31fa:	0f 91       	pop	r16
    31fc:	ff 90       	pop	r15
    31fe:	ef 90       	pop	r14
    3200:	df 90       	pop	r13
    3202:	cf 90       	pop	r12
    3204:	08 95       	ret

00003206 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3206:	0f 93       	push	r16
    3208:	1f 93       	push	r17
    320a:	cf 93       	push	r28
    320c:	df 93       	push	r29
    320e:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    3210:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <last_created_task_pointer>
    3214:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    3218:	00 97       	sbiw	r24, 0x00	; 0
    321a:	19 f0       	breq	.+6      	; 0x3222 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    321c:	be 01       	movw	r22, r28
    321e:	0e 94 b5 18 	call	0x316a	; 0x316a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    3222:	6a e0       	ldi	r22, 0x0A	; 10
    3224:	ce 01       	movw	r24, r28
    3226:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    322a:	8c 01       	movw	r16, r24
    322c:	6a ed       	ldi	r22, 0xDA	; 218
    322e:	75 e0       	ldi	r23, 0x05	; 5
    3230:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3234:	6a e0       	ldi	r22, 0x0A	; 10
    3236:	c8 01       	movw	r24, r16
    3238:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    323c:	8c 01       	movw	r16, r24
    323e:	6f ec       	ldi	r22, 0xCF	; 207
    3240:	75 e0       	ldi	r23, 0x05	; 5
    3242:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3246:	6a e0       	ldi	r22, 0x0A	; 10
    3248:	c8 01       	movw	r24, r16
    324a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    324e:	8c 01       	movw	r16, r24
    3250:	69 ec       	ldi	r22, 0xC9	; 201
    3252:	75 e0       	ldi	r23, 0x05	; 5
    3254:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3258:	66 e0       	ldi	r22, 0x06	; 6
    325a:	c8 01       	movw	r24, r16
    325c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3260:	80 91 92 32 	lds	r24, 0x3292	; 0x803292 <portStackTopForTask>
    3264:	90 91 93 32 	lds	r25, 0x3293	; 0x803293 <portStackTopForTask+0x1>
    3268:	bc 01       	movw	r22, r24
    326a:	6f 5f       	subi	r22, 0xFF	; 255
    326c:	7f 4f       	sbci	r23, 0xFF	; 255
    326e:	01 e1       	ldi	r16, 0x11	; 17
    3270:	21 e0       	ldi	r18, 0x01	; 1
    3272:	ae 01       	movw	r20, r28
    3274:	83 56       	subi	r24, 0x63	; 99
    3276:	91 09       	sbc	r25, r1
    3278:	0e 94 b7 1b 	call	0x376e	; 0x376e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	1f 91       	pop	r17
    3282:	0f 91       	pop	r16
    3284:	08 95       	ret

00003286 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3286:	8f 92       	push	r8
    3288:	9f 92       	push	r9
    328a:	af 92       	push	r10
    328c:	bf 92       	push	r11
    328e:	cf 92       	push	r12
    3290:	df 92       	push	r13
    3292:	ef 92       	push	r14
    3294:	ff 92       	push	r15
    3296:	0f 93       	push	r16
    3298:	1f 93       	push	r17
    329a:	cf 93       	push	r28
    329c:	df 93       	push	r29
    329e:	ec 01       	movw	r28, r24
    32a0:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    32a2:	8a 81       	ldd	r24, Y+2	; 0x02
    32a4:	9b 81       	ldd	r25, Y+3	; 0x03
    32a6:	0e 94 2e 14 	call	0x285c	; 0x285c <pcTaskGetTaskName>
    32aa:	bc 01       	movw	r22, r24
    32ac:	c8 01       	movw	r24, r16
    32ae:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    32b2:	d8 01       	movw	r26, r16
    32b4:	ed 91       	ld	r30, X+
    32b6:	fc 91       	ld	r31, X
    32b8:	02 80       	ldd	r0, Z+2	; 0x02
    32ba:	f3 81       	ldd	r31, Z+3	; 0x03
    32bc:	e0 2d       	mov	r30, r0
    32be:	69 e0       	ldi	r22, 0x09	; 9
    32c0:	c8 01       	movw	r24, r16
    32c2:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    32c4:	8a 81       	ldd	r24, Y+2	; 0x02
    32c6:	9b 81       	ldd	r25, Y+3	; 0x03
    32c8:	0e 94 2e 14 	call	0x285c	; 0x285c <pcTaskGetTaskName>
    32cc:	fc 01       	movw	r30, r24
    32ce:	01 90       	ld	r0, Z+
    32d0:	00 20       	and	r0, r0
    32d2:	e9 f7       	brne	.-6      	; 0x32ce <_ZN8frt_task12print_statusER8emstream+0x48>
    32d4:	31 97       	sbiw	r30, 0x01	; 1
    32d6:	e8 1b       	sub	r30, r24
    32d8:	f9 0b       	sbc	r31, r25
    32da:	38 97       	sbiw	r30, 0x08	; 8
    32dc:	48 f4       	brcc	.+18     	; 0x32f0 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    32de:	d8 01       	movw	r26, r16
    32e0:	ed 91       	ld	r30, X+
    32e2:	fc 91       	ld	r31, X
    32e4:	02 80       	ldd	r0, Z+2	; 0x02
    32e6:	f3 81       	ldd	r31, Z+3	; 0x03
    32e8:	e0 2d       	mov	r30, r0
    32ea:	69 e0       	ldi	r22, 0x09	; 9
    32ec:	c8 01       	movw	r24, r16
    32ee:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    32f0:	ce 84       	ldd	r12, Y+14	; 0x0e
    32f2:	df 84       	ldd	r13, Y+15	; 0x0f
    32f4:	e8 88       	ldd	r14, Y+16	; 0x10
    32f6:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    32f8:	a8 84       	ldd	r10, Y+8	; 0x08
    32fa:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    32fc:	8a 81       	ldd	r24, Y+2	; 0x02
    32fe:	9b 81       	ldd	r25, Y+3	; 0x03
    3300:	0e 94 34 17 	call	0x2e68	; 0x2e68 <uxTaskGetStackHighWaterMark>
    3304:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3306:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3308:	8a 81       	ldd	r24, Y+2	; 0x02
    330a:	9b 81       	ldd	r25, Y+3	; 0x03
    330c:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <uxTaskPriorityGet>
    3310:	68 2f       	mov	r22, r24
    3312:	c8 01       	movw	r24, r16
    3314:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3318:	6a e0       	ldi	r22, 0x0A	; 10
    331a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    331e:	ec 01       	movw	r28, r24
    3320:	6f e4       	ldi	r22, 0x4F	; 79
    3322:	76 e0       	ldi	r23, 0x06	; 6
    3324:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3328:	68 2d       	mov	r22, r8
    332a:	ce 01       	movw	r24, r28
    332c:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3330:	6a e0       	ldi	r22, 0x0A	; 10
    3332:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3336:	ec 01       	movw	r28, r24
    3338:	6d e4       	ldi	r22, 0x4D	; 77
    333a:	76 e0       	ldi	r23, 0x06	; 6
    333c:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3340:	69 2d       	mov	r22, r9
    3342:	ce 01       	movw	r24, r28
    3344:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3348:	6a e0       	ldi	r22, 0x0A	; 10
    334a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    334e:	ec 01       	movw	r28, r24
    3350:	6b e4       	ldi	r22, 0x4B	; 75
    3352:	76 e0       	ldi	r23, 0x06	; 6
    3354:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3358:	b5 01       	movw	r22, r10
    335a:	ce 01       	movw	r24, r28
    335c:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    3360:	6a e0       	ldi	r22, 0x0A	; 10
    3362:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3366:	ec 01       	movw	r28, r24
    3368:	69 e4       	ldi	r22, 0x49	; 73
    336a:	76 e0       	ldi	r23, 0x06	; 6
    336c:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    3370:	6a e0       	ldi	r22, 0x0A	; 10
    3372:	ce 01       	movw	r24, r28
    3374:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3378:	ec 01       	movw	r28, r24
    337a:	67 e4       	ldi	r22, 0x47	; 71
    337c:	76 e0       	ldi	r23, 0x06	; 6
    337e:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3382:	b7 01       	movw	r22, r14
    3384:	a6 01       	movw	r20, r12
    3386:	ce 01       	movw	r24, r28
    3388:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <_ZN8emstreamlsEm>
}
    338c:	df 91       	pop	r29
    338e:	cf 91       	pop	r28
    3390:	1f 91       	pop	r17
    3392:	0f 91       	pop	r16
    3394:	ff 90       	pop	r15
    3396:	ef 90       	pop	r14
    3398:	df 90       	pop	r13
    339a:	cf 90       	pop	r12
    339c:	bf 90       	pop	r11
    339e:	af 90       	pop	r10
    33a0:	9f 90       	pop	r9
    33a2:	8f 90       	pop	r8
    33a4:	08 95       	ret

000033a6 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    33a6:	cf 93       	push	r28
    33a8:	df 93       	push	r29
    33aa:	ec 01       	movw	r28, r24
    33ac:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    33ae:	db 01       	movw	r26, r22
    33b0:	ed 91       	ld	r30, X+
    33b2:	fc 91       	ld	r31, X
    33b4:	02 80       	ldd	r0, Z+2	; 0x02
    33b6:	f3 81       	ldd	r31, Z+3	; 0x03
    33b8:	e0 2d       	mov	r30, r0
    33ba:	be 01       	movw	r22, r28
    33bc:	19 95       	eicall
	return (ser_dev);
}
    33be:	ce 01       	movw	r24, r28
    33c0:	df 91       	pop	r29
    33c2:	cf 91       	pop	r28
    33c4:	08 95       	ret

000033c6 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    33c6:	0f 93       	push	r16
    33c8:	1f 93       	push	r17
    33ca:	cf 93       	push	r28
    33cc:	df 93       	push	r29
    33ce:	ec 01       	movw	r28, r24
    33d0:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    33d2:	bc 01       	movw	r22, r24
    33d4:	c8 01       	movw	r24, r16
    33d6:	0e 94 d3 19 	call	0x33a6	; 0x33a6 <_ZlsR8emstreamR8frt_task>
    33da:	66 e0       	ldi	r22, 0x06	; 6
    33dc:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    33e0:	8c 81       	ldd	r24, Y+4	; 0x04
    33e2:	9d 81       	ldd	r25, Y+5	; 0x05
    33e4:	00 97       	sbiw	r24, 0x00	; 0
    33e6:	19 f0       	breq	.+6      	; 0x33ee <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    33e8:	b8 01       	movw	r22, r16
    33ea:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    33ee:	df 91       	pop	r29
    33f0:	cf 91       	pop	r28
    33f2:	1f 91       	pop	r17
    33f4:	0f 91       	pop	r16
    33f6:	08 95       	ret

000033f8 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    33f8:	0f 93       	push	r16
    33fa:	1f 93       	push	r17
    33fc:	cf 93       	push	r28
    33fe:	df 93       	push	r29
    3400:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    3402:	6a e0       	ldi	r22, 0x0A	; 10
    3404:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3408:	8c 01       	movw	r16, r24
    340a:	6c e3       	ldi	r22, 0x3C	; 60
    340c:	76 e0       	ldi	r23, 0x06	; 6
    340e:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3412:	6a e0       	ldi	r22, 0x0A	; 10
    3414:	c8 01       	movw	r24, r16
    3416:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    341a:	8c 01       	movw	r16, r24
    341c:	65 e3       	ldi	r22, 0x35	; 53
    341e:	76 e0       	ldi	r23, 0x06	; 6
    3420:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    3424:	66 e0       	ldi	r22, 0x06	; 6
    3426:	c8 01       	movw	r24, r16
    3428:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    342c:	6a e0       	ldi	r22, 0x0A	; 10
    342e:	ce 01       	movw	r24, r28
    3430:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3434:	8c 01       	movw	r16, r24
    3436:	64 e2       	ldi	r22, 0x24	; 36
    3438:	76 e0       	ldi	r23, 0x06	; 6
    343a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    343e:	6a e0       	ldi	r22, 0x0A	; 10
    3440:	c8 01       	movw	r24, r16
    3442:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3446:	8c 01       	movw	r16, r24
    3448:	68 e1       	ldi	r22, 0x18	; 24
    344a:	76 e0       	ldi	r23, 0x06	; 6
    344c:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3450:	6a e0       	ldi	r22, 0x0A	; 10
    3452:	c8 01       	movw	r24, r16
    3454:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3458:	8c 01       	movw	r16, r24
    345a:	62 e1       	ldi	r22, 0x12	; 18
    345c:	76 e0       	ldi	r23, 0x06	; 6
    345e:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    3462:	66 e0       	ldi	r22, 0x06	; 6
    3464:	c8 01       	movw	r24, r16
    3466:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    346a:	6a e0       	ldi	r22, 0x0A	; 10
    346c:	ce 01       	movw	r24, r28
    346e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3472:	8c 01       	movw	r16, r24
    3474:	61 e0       	ldi	r22, 0x01	; 1
    3476:	76 e0       	ldi	r23, 0x06	; 6
    3478:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    347c:	6a e0       	ldi	r22, 0x0A	; 10
    347e:	c8 01       	movw	r24, r16
    3480:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3484:	8c 01       	movw	r16, r24
    3486:	65 ef       	ldi	r22, 0xF5	; 245
    3488:	75 e0       	ldi	r23, 0x05	; 5
    348a:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    348e:	6a e0       	ldi	r22, 0x0A	; 10
    3490:	c8 01       	movw	r24, r16
    3492:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3496:	8c 01       	movw	r16, r24
    3498:	6f ee       	ldi	r22, 0xEF	; 239
    349a:	75 e0       	ldi	r23, 0x05	; 5
    349c:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    34a0:	66 e0       	ldi	r22, 0x06	; 6
    34a2:	c8 01       	movw	r24, r16
    34a4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    34a8:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <last_created_task_pointer>
    34ac:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    34b0:	00 97       	sbiw	r24, 0x00	; 0
    34b2:	19 f0       	breq	.+6      	; 0x34ba <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    34b4:	be 01       	movw	r22, r28
    34b6:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    34ba:	0e 94 36 14 	call	0x286c	; 0x286c <xTaskGetIdleTaskHandle>
    34be:	0e 94 34 17 	call	0x2e68	; 0x2e68 <uxTaskGetStackHighWaterMark>
    34c2:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    34c4:	6a e0       	ldi	r22, 0x0A	; 10
    34c6:	ce 01       	movw	r24, r28
    34c8:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    34cc:	ec 01       	movw	r28, r24
    34ce:	64 ee       	ldi	r22, 0xE4	; 228
    34d0:	75 e0       	ldi	r23, 0x05	; 5
    34d2:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    34d6:	61 2f       	mov	r22, r17
    34d8:	ce 01       	movw	r24, r28
    34da:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    34de:	6a e0       	ldi	r22, 0x0A	; 10
    34e0:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    34e4:	ec 01       	movw	r28, r24
    34e6:	62 ee       	ldi	r22, 0xE2	; 226
    34e8:	75 e0       	ldi	r23, 0x05	; 5
    34ea:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    34ee:	64 e6       	ldi	r22, 0x64	; 100
    34f0:	70 e0       	ldi	r23, 0x00	; 0
    34f2:	ce 01       	movw	r24, r28
    34f4:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    34f8:	6a e0       	ldi	r22, 0x0A	; 10
    34fa:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    34fe:	ec 01       	movw	r28, r24
    3500:	6f ed       	ldi	r22, 0xDF	; 223
    3502:	75 e0       	ldi	r23, 0x05	; 5
    3504:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3508:	66 e0       	ldi	r22, 0x06	; 6
    350a:	ce 01       	movw	r24, r28
    350c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
}
    3510:	df 91       	pop	r29
    3512:	cf 91       	pop	r28
    3514:	1f 91       	pop	r17
    3516:	0f 91       	pop	r16
    3518:	08 95       	ret

0000351a <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    351a:	0f 93       	push	r16
    351c:	cf 93       	push	r28
    351e:	df 93       	push	r29
    3520:	1f 92       	push	r1
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3526:	00 e0       	ldi	r16, 0x00	; 0
    3528:	2f ef       	ldi	r18, 0xFF	; 255
    352a:	3f ef       	ldi	r19, 0xFF	; 255
    352c:	a9 01       	movw	r20, r18
    352e:	be 01       	movw	r22, r28
    3530:	6f 5f       	subi	r22, 0xFF	; 255
    3532:	7f 4f       	sbci	r23, 0xFF	; 255
    3534:	fc 01       	movw	r30, r24
    3536:	80 85       	ldd	r24, Z+8	; 0x08
    3538:	91 85       	ldd	r25, Z+9	; 0x09
    353a:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
    353e:	81 30       	cpi	r24, 0x01	; 1
    3540:	19 f4       	brne	.+6      	; 0x3548 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3542:	89 81       	ldd	r24, Y+1	; 0x01
    3544:	90 e0       	ldi	r25, 0x00	; 0
    3546:	02 c0       	rjmp	.+4      	; 0x354c <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3548:	8f ef       	ldi	r24, 0xFF	; 255
    354a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    354c:	0f 90       	pop	r0
    354e:	df 91       	pop	r29
    3550:	cf 91       	pop	r28
    3552:	0f 91       	pop	r16
    3554:	08 95       	ret

00003556 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3556:	fc 01       	movw	r30, r24
    3558:	80 85       	ldd	r24, Z+8	; 0x08
    355a:	91 85       	ldd	r25, Z+9	; 0x09
    355c:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    3560:	91 e0       	ldi	r25, 0x01	; 1
    3562:	81 11       	cpse	r24, r1
    3564:	01 c0       	rjmp	.+2      	; 0x3568 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3566:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3568:	89 2f       	mov	r24, r25
    356a:	08 95       	ret

0000356c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    356c:	0f 93       	push	r16
    356e:	cf 93       	push	r28
    3570:	df 93       	push	r29
    3572:	1f 92       	push	r1
    3574:	cd b7       	in	r28, 0x3d	; 61
    3576:	de b7       	in	r29, 0x3e	; 62
    3578:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    357a:	fc 01       	movw	r30, r24
    357c:	22 85       	ldd	r18, Z+10	; 0x0a
    357e:	33 85       	ldd	r19, Z+11	; 0x0b
    3580:	44 85       	ldd	r20, Z+12	; 0x0c
    3582:	55 85       	ldd	r21, Z+13	; 0x0d
    3584:	00 e0       	ldi	r16, 0x00	; 0
    3586:	be 01       	movw	r22, r28
    3588:	6f 5f       	subi	r22, 0xFF	; 255
    358a:	7f 4f       	sbci	r23, 0xFF	; 255
    358c:	80 85       	ldd	r24, Z+8	; 0x08
    358e:	91 85       	ldd	r25, Z+9	; 0x09
    3590:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    3594:	91 e0       	ldi	r25, 0x01	; 1
    3596:	81 11       	cpse	r24, r1
    3598:	01 c0       	rjmp	.+2      	; 0x359c <_ZN14frt_text_queue7putcharEc+0x30>
    359a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    359c:	89 2f       	mov	r24, r25
    359e:	0f 90       	pop	r0
    35a0:	df 91       	pop	r29
    35a2:	cf 91       	pop	r28
    35a4:	0f 91       	pop	r16
    35a6:	08 95       	ret

000035a8 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    35a8:	8f 92       	push	r8
    35aa:	9f 92       	push	r9
    35ac:	bf 92       	push	r11
    35ae:	cf 92       	push	r12
    35b0:	df 92       	push	r13
    35b2:	ef 92       	push	r14
    35b4:	ff 92       	push	r15
    35b6:	0f 93       	push	r16
    35b8:	1f 93       	push	r17
    35ba:	cf 93       	push	r28
    35bc:	df 93       	push	r29
    35be:	ec 01       	movw	r28, r24
    35c0:	b6 2e       	mov	r11, r22
    35c2:	4a 01       	movw	r8, r20
    35c4:	68 01       	movw	r12, r16
    35c6:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    35c8:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <_ZN8emstreamC1Ev>
    35cc:	84 e2       	ldi	r24, 0x24	; 36
    35ce:	91 e2       	ldi	r25, 0x21	; 33
    35d0:	88 83       	st	Y, r24
    35d2:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    35d4:	8e 86       	std	Y+14, r8	; 0x0e
    35d6:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    35d8:	40 e0       	ldi	r20, 0x00	; 0
    35da:	61 e0       	ldi	r22, 0x01	; 1
    35dc:	8b 2d       	mov	r24, r11
    35de:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    35e2:	88 87       	std	Y+8, r24	; 0x08
    35e4:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    35e6:	ca 86       	std	Y+10, r12	; 0x0a
    35e8:	db 86       	std	Y+11, r13	; 0x0b
    35ea:	ec 86       	std	Y+12, r14	; 0x0c
    35ec:	fd 86       	std	Y+13, r15	; 0x0d
}
    35ee:	df 91       	pop	r29
    35f0:	cf 91       	pop	r28
    35f2:	1f 91       	pop	r17
    35f4:	0f 91       	pop	r16
    35f6:	ff 90       	pop	r15
    35f8:	ef 90       	pop	r14
    35fa:	df 90       	pop	r13
    35fc:	cf 90       	pop	r12
    35fe:	bf 90       	pop	r11
    3600:	9f 90       	pop	r9
    3602:	8f 90       	pop	r8
    3604:	08 95       	ret

00003606 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3606:	cf 92       	push	r12
    3608:	df 92       	push	r13
    360a:	ef 92       	push	r14
    360c:	ff 92       	push	r15
    360e:	cf 93       	push	r28
    3610:	df 93       	push	r29
    3612:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3614:	68 81       	ld	r22, Y
    3616:	79 81       	ldd	r23, Y+1	; 0x01
    3618:	8a 81       	ldd	r24, Y+2	; 0x02
    361a:	9b 81       	ldd	r25, Y+3	; 0x03
    361c:	0f 2e       	mov	r0, r31
    361e:	f8 ee       	ldi	r31, 0xE8	; 232
    3620:	cf 2e       	mov	r12, r31
    3622:	f3 e0       	ldi	r31, 0x03	; 3
    3624:	df 2e       	mov	r13, r31
    3626:	e1 2c       	mov	r14, r1
    3628:	f1 2c       	mov	r15, r1
    362a:	f0 2d       	mov	r31, r0
    362c:	a7 01       	movw	r20, r14
    362e:	96 01       	movw	r18, r12
    3630:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
    3634:	9b 01       	movw	r18, r22
    3636:	ac 01       	movw	r20, r24
    3638:	60 e4       	ldi	r22, 0x40	; 64
    363a:	72 e4       	ldi	r23, 0x42	; 66
    363c:	8f e0       	ldi	r24, 0x0F	; 15
    363e:	90 e0       	ldi	r25, 0x00	; 0
    3640:	0e 94 68 24 	call	0x48d0	; 0x48d0 <__mulsi3>
    3644:	a7 01       	movw	r20, r14
    3646:	96 01       	movw	r18, r12
    3648:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
    364c:	69 01       	movw	r12, r18
    364e:	7a 01       	movw	r14, r20
    3650:	ac 81       	ldd	r26, Y+4	; 0x04
    3652:	bd 81       	ldd	r27, Y+5	; 0x05
    3654:	20 e4       	ldi	r18, 0x40	; 64
    3656:	32 e4       	ldi	r19, 0x42	; 66
    3658:	4f e0       	ldi	r20, 0x0F	; 15
    365a:	50 e0       	ldi	r21, 0x00	; 0
    365c:	0e 94 c2 24 	call	0x4984	; 0x4984 <__muluhisi3>
    3660:	20 e0       	ldi	r18, 0x00	; 0
    3662:	38 e4       	ldi	r19, 0x48	; 72
    3664:	48 ee       	ldi	r20, 0xE8	; 232
    3666:	51 e0       	ldi	r21, 0x01	; 1
    3668:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
    366c:	c7 01       	movw	r24, r14
    366e:	b6 01       	movw	r22, r12
    3670:	62 0f       	add	r22, r18
    3672:	73 1f       	adc	r23, r19
    3674:	84 1f       	adc	r24, r20
    3676:	95 1f       	adc	r25, r21
}
    3678:	df 91       	pop	r29
    367a:	cf 91       	pop	r28
    367c:	ff 90       	pop	r15
    367e:	ef 90       	pop	r14
    3680:	df 90       	pop	r13
    3682:	cf 90       	pop	r12
    3684:	08 95       	ret

00003686 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3686:	cf 92       	push	r12
    3688:	df 92       	push	r13
    368a:	ef 92       	push	r14
    368c:	ff 92       	push	r15
    368e:	0f 93       	push	r16
    3690:	1f 93       	push	r17
    3692:	cf 93       	push	r28
    3694:	df 93       	push	r29
    3696:	cd b7       	in	r28, 0x3d	; 61
    3698:	de b7       	in	r29, 0x3e	; 62
    369a:	2f 97       	sbiw	r28, 0x0f	; 15
    369c:	cd bf       	out	0x3d, r28	; 61
    369e:	de bf       	out	0x3e, r29	; 62
    36a0:	6c 01       	movw	r12, r24
    36a2:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    36a4:	db 01       	movw	r26, r22
    36a6:	6d 91       	ld	r22, X+
    36a8:	7d 91       	ld	r23, X+
    36aa:	8d 91       	ld	r24, X+
    36ac:	9c 91       	ld	r25, X
    36ae:	28 ee       	ldi	r18, 0xE8	; 232
    36b0:	33 e0       	ldi	r19, 0x03	; 3
    36b2:	40 e0       	ldi	r20, 0x00	; 0
    36b4:	50 e0       	ldi	r21, 0x00	; 0
    36b6:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
    36ba:	ba 01       	movw	r22, r20
    36bc:	a9 01       	movw	r20, r18
    36be:	c6 01       	movw	r24, r12
    36c0:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    36c4:	d6 01       	movw	r26, r12
    36c6:	ed 91       	ld	r30, X+
    36c8:	fc 91       	ld	r31, X
    36ca:	02 80       	ldd	r0, Z+2	; 0x02
    36cc:	f3 81       	ldd	r31, Z+3	; 0x03
    36ce:	e0 2d       	mov	r30, r0
    36d0:	6e e2       	ldi	r22, 0x2E	; 46
    36d2:	c6 01       	movw	r24, r12
    36d4:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    36d6:	c8 01       	movw	r24, r16
    36d8:	0e 94 03 1b 	call	0x3606	; 0x3606 <_ZN10time_stamp12get_microsecEv>
    36dc:	8e 01       	movw	r16, r28
    36de:	09 5f       	subi	r16, 0xF9	; 249
    36e0:	1f 4f       	sbci	r17, 0xFF	; 255
    36e2:	fe 01       	movw	r30, r28
    36e4:	31 96       	adiw	r30, 0x01	; 1
    36e6:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    36e8:	2a e0       	ldi	r18, 0x0A	; 10
    36ea:	30 e0       	ldi	r19, 0x00	; 0
    36ec:	40 e0       	ldi	r20, 0x00	; 0
    36ee:	50 e0       	ldi	r21, 0x00	; 0
    36f0:	0e 94 9a 24 	call	0x4934	; 0x4934 <__divmodsi4>
    36f4:	e6 2f       	mov	r30, r22
    36f6:	28 87       	std	Y+8, r18	; 0x08
    36f8:	39 87       	std	Y+9, r19	; 0x09
    36fa:	4a 87       	std	Y+10, r20	; 0x0a
    36fc:	5b 87       	std	Y+11, r21	; 0x0b
    36fe:	68 85       	ldd	r22, Y+8	; 0x08
    3700:	79 85       	ldd	r23, Y+9	; 0x09
    3702:	8a 85       	ldd	r24, Y+10	; 0x0a
    3704:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3706:	20 e3       	ldi	r18, 0x30	; 48
    3708:	2e 0f       	add	r18, r30
    370a:	d8 01       	movw	r26, r16
    370c:	2e 93       	st	-X, r18
    370e:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3710:	ae 15       	cp	r26, r14
    3712:	bf 05       	cpc	r27, r15
    3714:	49 f7       	brne	.-46     	; 0x36e8 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3716:	1f 82       	std	Y+7, r1	; 0x07
    3718:	be 01       	movw	r22, r28
    371a:	6f 5f       	subi	r22, 0xFF	; 255
    371c:	7f 4f       	sbci	r23, 0xFF	; 255
    371e:	c6 01       	movw	r24, r12
    3720:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3724:	c6 01       	movw	r24, r12
    3726:	2f 96       	adiw	r28, 0x0f	; 15
    3728:	cd bf       	out	0x3d, r28	; 61
    372a:	de bf       	out	0x3e, r29	; 62
    372c:	df 91       	pop	r29
    372e:	cf 91       	pop	r28
    3730:	1f 91       	pop	r17
    3732:	0f 91       	pop	r16
    3734:	ff 90       	pop	r15
    3736:	ef 90       	pop	r14
    3738:	df 90       	pop	r13
    373a:	cf 90       	pop	r12
    373c:	08 95       	ret

0000373e <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    373e:	cf 93       	push	r28
    3740:	df 93       	push	r29
    3742:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3744:	0f b6       	in	r0, 0x3f	; 63
    3746:	f8 94       	cli
    3748:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    374a:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    374e:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3752:	8c 83       	std	Y+4, r24	; 0x04
    3754:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3756:	0e 94 20 14 	call	0x2840	; 0x2840 <xTaskGetTickCount>
    375a:	68 83       	st	Y, r22
    375c:	79 83       	std	Y+1, r23	; 0x01
    375e:	8a 83       	std	Y+2, r24	; 0x02
    3760:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3762:	0f 90       	pop	r0
    3764:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3766:	ce 01       	movw	r24, r28
    3768:	df 91       	pop	r29
    376a:	cf 91       	pop	r28
    376c:	08 95       	ret

0000376e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    376e:	5f 92       	push	r5
    3770:	6f 92       	push	r6
    3772:	7f 92       	push	r7
    3774:	8f 92       	push	r8
    3776:	9f 92       	push	r9
    3778:	af 92       	push	r10
    377a:	bf 92       	push	r11
    377c:	cf 92       	push	r12
    377e:	df 92       	push	r13
    3780:	ef 92       	push	r14
    3782:	ff 92       	push	r15
    3784:	0f 93       	push	r16
    3786:	1f 93       	push	r17
    3788:	cf 93       	push	r28
    378a:	df 93       	push	r29
    378c:	5c 01       	movw	r10, r24
    378e:	4b 01       	movw	r8, r22
    3790:	7a 01       	movw	r14, r20
    3792:	12 2f       	mov	r17, r18
    3794:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3796:	63 e0       	ldi	r22, 0x03	; 3
    3798:	ca 01       	movw	r24, r20
    379a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    379e:	a8 14       	cp	r10, r8
    37a0:	b9 04       	cpc	r11, r9
    37a2:	08 f0       	brcs	.+2      	; 0x37a6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    37a4:	7d c0       	rjmp	.+250    	; 0x38a0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    37a6:	65 01       	movw	r12, r10
    37a8:	84 e1       	ldi	r24, 0x14	; 20
    37aa:	c8 0e       	add	r12, r24
    37ac:	d1 1c       	adc	r13, r1
    37ae:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    37b0:	6a 2c       	mov	r6, r10
    37b2:	5b 2c       	mov	r5, r11
    37b4:	b5 01       	movw	r22, r10
    37b6:	c7 01       	movw	r24, r14
    37b8:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <_ZN8emstreamlsEj>
    37bc:	6a e0       	ldi	r22, 0x0A	; 10
    37be:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    37c2:	61 e6       	ldi	r22, 0x61	; 97
    37c4:	76 e0       	ldi	r23, 0x06	; 6
    37c6:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    37ca:	11 23       	and	r17, r17
    37cc:	09 f4       	brne	.+2      	; 0x37d0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    37ce:	6d c0       	rjmp	.+218    	; 0x38aa <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    37d0:	00 23       	and	r16, r16
    37d2:	09 f4       	brne	.+2      	; 0x37d6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    37d4:	6a c0       	rjmp	.+212    	; 0x38aa <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    37d6:	6a e0       	ldi	r22, 0x0A	; 10
    37d8:	c7 01       	movw	r24, r14
    37da:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    37de:	6c e5       	ldi	r22, 0x5C	; 92
    37e0:	76 e0       	ldi	r23, 0x06	; 6
    37e2:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    37e6:	61 c0       	rjmp	.+194    	; 0x38aa <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    37e8:	11 23       	and	r17, r17
    37ea:	71 f0       	breq	.+28     	; 0x3808 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37ec:	01 11       	cpse	r16, r1
    37ee:	0c c0       	rjmp	.+24     	; 0x3808 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    37f0:	88 81       	ld	r24, Y
    37f2:	87 15       	cp	r24, r7
    37f4:	49 f0       	breq	.+18     	; 0x3808 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    37f6:	6a e0       	ldi	r22, 0x0A	; 10
    37f8:	c7 01       	movw	r24, r14
    37fa:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    37fe:	67 e5       	ldi	r22, 0x57	; 87
    3800:	76 e0       	ldi	r23, 0x06	; 6
    3802:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3806:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3808:	69 91       	ld	r22, Y+
    380a:	c7 01       	movw	r24, r14
    380c:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3810:	dc 01       	movw	r26, r24
    3812:	ed 91       	ld	r30, X+
    3814:	fc 91       	ld	r31, X
    3816:	02 80       	ldd	r0, Z+2	; 0x02
    3818:	f3 81       	ldd	r31, Z+3	; 0x03
    381a:	e0 2d       	mov	r30, r0
    381c:	60 e2       	ldi	r22, 0x20	; 32
    381e:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3820:	cc 16       	cp	r12, r28
    3822:	dd 06       	cpc	r13, r29
    3824:	09 f7       	brne	.-62     	; 0x37e8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3826:	11 23       	and	r17, r17
    3828:	89 f0       	breq	.+34     	; 0x384c <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    382a:	6a e0       	ldi	r22, 0x0A	; 10
    382c:	c7 01       	movw	r24, r14
    382e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3832:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3834:	61 e5       	ldi	r22, 0x51	; 81
    3836:	76 e0       	ldi	r23, 0x06	; 6
    3838:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    383c:	e8 81       	ld	r30, Y
    383e:	f9 81       	ldd	r31, Y+1	; 0x01
    3840:	02 80       	ldd	r0, Z+2	; 0x02
    3842:	f3 81       	ldd	r31, Z+3	; 0x03
    3844:	e0 2d       	mov	r30, r0
    3846:	60 e2       	ldi	r22, 0x20	; 32
    3848:	ce 01       	movw	r24, r28
    384a:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    384c:	c6 2d       	mov	r28, r6
    384e:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3850:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3852:	80 ee       	ldi	r24, 0xE0	; 224
    3854:	86 0f       	add	r24, r22
    3856:	8f 35       	cpi	r24, 0x5F	; 95
    3858:	48 f4       	brcc	.+18     	; 0x386c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    385a:	d7 01       	movw	r26, r14
    385c:	ed 91       	ld	r30, X+
    385e:	fc 91       	ld	r31, X
    3860:	02 80       	ldd	r0, Z+2	; 0x02
    3862:	f3 81       	ldd	r31, Z+3	; 0x03
    3864:	e0 2d       	mov	r30, r0
    3866:	c7 01       	movw	r24, r14
    3868:	19 95       	eicall
    386a:	09 c0       	rjmp	.+18     	; 0x387e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    386c:	d7 01       	movw	r26, r14
    386e:	ed 91       	ld	r30, X+
    3870:	fc 91       	ld	r31, X
    3872:	02 80       	ldd	r0, Z+2	; 0x02
    3874:	f3 81       	ldd	r31, Z+3	; 0x03
    3876:	e0 2d       	mov	r30, r0
    3878:	6e e2       	ldi	r22, 0x2E	; 46
    387a:	c7 01       	movw	r24, r14
    387c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    387e:	cc 16       	cp	r12, r28
    3880:	dd 06       	cpc	r13, r29
    3882:	31 f7       	brne	.-52     	; 0x3850 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3884:	b4 e1       	ldi	r27, 0x14	; 20
    3886:	ab 0e       	add	r10, r27
    3888:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    388a:	66 e0       	ldi	r22, 0x06	; 6
    388c:	c7 01       	movw	r24, r14
    388e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    3892:	84 e1       	ldi	r24, 0x14	; 20
    3894:	c8 0e       	add	r12, r24
    3896:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3898:	a8 14       	cp	r10, r8
    389a:	b9 04       	cpc	r11, r9
    389c:	08 f4       	brcc	.+2      	; 0x38a0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    389e:	88 cf       	rjmp	.-240    	; 0x37b0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    38a0:	62 e0       	ldi	r22, 0x02	; 2
    38a2:	c7 01       	movw	r24, r14
    38a4:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
}
    38a8:	03 c0       	rjmp	.+6      	; 0x38b0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    38aa:	c6 2d       	mov	r28, r6
    38ac:	d5 2d       	mov	r29, r5
    38ae:	9c cf       	rjmp	.-200    	; 0x37e8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    38b0:	df 91       	pop	r29
    38b2:	cf 91       	pop	r28
    38b4:	1f 91       	pop	r17
    38b6:	0f 91       	pop	r16
    38b8:	ff 90       	pop	r15
    38ba:	ef 90       	pop	r14
    38bc:	df 90       	pop	r13
    38be:	cf 90       	pop	r12
    38c0:	bf 90       	pop	r11
    38c2:	af 90       	pop	r10
    38c4:	9f 90       	pop	r9
    38c6:	8f 90       	pop	r8
    38c8:	7f 90       	pop	r7
    38ca:	6f 90       	pop	r6
    38cc:	5f 90       	pop	r5
    38ce:	08 95       	ret

000038d0 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    38d0:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    38d4:	08 95       	ret

000038d6 <_Znaj>:
    38d6:	0e 94 aa 0c 	call	0x1954	; 0x1954 <pvPortMalloc>
    38da:	08 95       	ret

000038dc <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    38dc:	08 95       	ret

000038de <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    38de:	cf 93       	push	r28
    38e0:	df 93       	push	r29
    38e2:	fc 01       	movw	r30, r24
    38e4:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    38e6:	40 3a       	cpi	r20, 0xA0	; 160
    38e8:	68 e0       	ldi	r22, 0x08	; 8
    38ea:	56 07       	cpc	r21, r22
    38ec:	49 f4       	brne	.+18     	; 0x3900 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    38ee:	80 e4       	ldi	r24, 0x40	; 64
    38f0:	96 e0       	ldi	r25, 0x06	; 6
    38f2:	82 83       	std	Z+2, r24	; 0x02
    38f4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    38f6:	82 e0       	ldi	r24, 0x02	; 2
    38f8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    38fa:	83 e0       	ldi	r24, 0x03	; 3
    38fc:	85 83       	std	Z+5, r24	; 0x05
    38fe:	32 c0       	rjmp	.+100    	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3900:	40 3b       	cpi	r20, 0xB0	; 176
    3902:	78 e0       	ldi	r23, 0x08	; 8
    3904:	57 07       	cpc	r21, r23
    3906:	49 f4       	brne	.+18     	; 0x391a <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3908:	80 e4       	ldi	r24, 0x40	; 64
    390a:	96 e0       	ldi	r25, 0x06	; 6
    390c:	82 83       	std	Z+2, r24	; 0x02
    390e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3910:	86 e0       	ldi	r24, 0x06	; 6
    3912:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3914:	87 e0       	ldi	r24, 0x07	; 7
    3916:	85 83       	std	Z+5, r24	; 0x05
    3918:	25 c0       	rjmp	.+74     	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    391a:	40 3a       	cpi	r20, 0xA0	; 160
    391c:	89 e0       	ldi	r24, 0x09	; 9
    391e:	58 07       	cpc	r21, r24
    3920:	49 f4       	brne	.+18     	; 0x3934 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3922:	80 e6       	ldi	r24, 0x60	; 96
    3924:	96 e0       	ldi	r25, 0x06	; 6
    3926:	82 83       	std	Z+2, r24	; 0x02
    3928:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    392a:	82 e0       	ldi	r24, 0x02	; 2
    392c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    392e:	83 e0       	ldi	r24, 0x03	; 3
    3930:	85 83       	std	Z+5, r24	; 0x05
    3932:	18 c0       	rjmp	.+48     	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3934:	40 3b       	cpi	r20, 0xB0	; 176
    3936:	69 e0       	ldi	r22, 0x09	; 9
    3938:	56 07       	cpc	r21, r22
    393a:	49 f4       	brne	.+18     	; 0x394e <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    393c:	80 e6       	ldi	r24, 0x60	; 96
    393e:	96 e0       	ldi	r25, 0x06	; 6
    3940:	82 83       	std	Z+2, r24	; 0x02
    3942:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3944:	86 e0       	ldi	r24, 0x06	; 6
    3946:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3948:	87 e0       	ldi	r24, 0x07	; 7
    394a:	85 83       	std	Z+5, r24	; 0x05
    394c:	0b c0       	rjmp	.+22     	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    394e:	40 3a       	cpi	r20, 0xA0	; 160
    3950:	5a 40       	sbci	r21, 0x0A	; 10
    3952:	41 f4       	brne	.+16     	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3954:	80 e8       	ldi	r24, 0x80	; 128
    3956:	96 e0       	ldi	r25, 0x06	; 6
    3958:	82 83       	std	Z+2, r24	; 0x02
    395a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    395c:	82 e0       	ldi	r24, 0x02	; 2
    395e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3960:	83 e0       	ldi	r24, 0x03	; 3
    3962:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3964:	a6 83       	std	Z+6, r26	; 0x06
    3966:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3968:	cd 01       	movw	r24, r26
    396a:	01 96       	adiw	r24, 0x01	; 1
    396c:	80 87       	std	Z+8, r24	; 0x08
    396e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3970:	03 96       	adiw	r24, 0x03	; 3
    3972:	82 87       	std	Z+10, r24	; 0x0a
    3974:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3976:	25 81       	ldd	r18, Z+5	; 0x05
    3978:	c2 81       	ldd	r28, Z+2	; 0x02
    397a:	d3 81       	ldd	r29, Z+3	; 0x03
    397c:	4c 81       	ldd	r20, Y+4	; 0x04
    397e:	81 e0       	ldi	r24, 0x01	; 1
    3980:	90 e0       	ldi	r25, 0x00	; 0
    3982:	bc 01       	movw	r22, r24
    3984:	02 c0       	rjmp	.+4      	; 0x398a <_ZN7base232C1EjP12USART_struct+0xac>
    3986:	66 0f       	add	r22, r22
    3988:	77 1f       	adc	r23, r23
    398a:	2a 95       	dec	r18
    398c:	e2 f7       	brpl	.-8      	; 0x3986 <_ZN7base232C1EjP12USART_struct+0xa8>
    398e:	9b 01       	movw	r18, r22
    3990:	24 2b       	or	r18, r20
    3992:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3994:	25 81       	ldd	r18, Z+5	; 0x05
    3996:	c2 81       	ldd	r28, Z+2	; 0x02
    3998:	d3 81       	ldd	r29, Z+3	; 0x03
    399a:	48 81       	ld	r20, Y
    399c:	bc 01       	movw	r22, r24
    399e:	02 c0       	rjmp	.+4      	; 0x39a4 <_ZN7base232C1EjP12USART_struct+0xc6>
    39a0:	66 0f       	add	r22, r22
    39a2:	77 1f       	adc	r23, r23
    39a4:	2a 95       	dec	r18
    39a6:	e2 f7       	brpl	.-8      	; 0x39a0 <_ZN7base232C1EjP12USART_struct+0xc2>
    39a8:	9b 01       	movw	r18, r22
    39aa:	24 2b       	or	r18, r20
    39ac:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    39ae:	34 81       	ldd	r19, Z+4	; 0x04
    39b0:	c2 81       	ldd	r28, Z+2	; 0x02
    39b2:	d3 81       	ldd	r29, Z+3	; 0x03
    39b4:	28 81       	ld	r18, Y
    39b6:	02 c0       	rjmp	.+4      	; 0x39bc <_ZN7base232C1EjP12USART_struct+0xde>
    39b8:	88 0f       	add	r24, r24
    39ba:	99 1f       	adc	r25, r25
    39bc:	3a 95       	dec	r19
    39be:	e2 f7       	brpl	.-8      	; 0x39b8 <_ZN7base232C1EjP12USART_struct+0xda>
    39c0:	80 95       	com	r24
    39c2:	90 95       	com	r25
    39c4:	82 23       	and	r24, r18
    39c6:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    39c8:	80 e1       	ldi	r24, 0x10	; 16
    39ca:	13 96       	adiw	r26, 0x03	; 3
    39cc:	8c 93       	st	X, r24
    39ce:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    39d0:	83 e0       	ldi	r24, 0x03	; 3
    39d2:	15 96       	adiw	r26, 0x05	; 5
    39d4:	8c 93       	st	X, r24
    39d6:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    39d8:	80 ef       	ldi	r24, 0xF0	; 240
    39da:	17 96       	adiw	r26, 0x07	; 7
    39dc:	8c 93       	st	X, r24
    39de:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    39e0:	81 e2       	ldi	r24, 0x21	; 33
    39e2:	16 96       	adiw	r26, 0x06	; 6
    39e4:	8c 93       	st	X, r24
    39e6:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    39e8:	88 e1       	ldi	r24, 0x18	; 24
    39ea:	14 96       	adiw	r26, 0x04	; 4
    39ec:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    39ee:	80 e8       	ldi	r24, 0x80	; 128
    39f0:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    39f2:	80 e4       	ldi	r24, 0x40	; 64
    39f4:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    39f6:	80 e2       	ldi	r24, 0x20	; 32
    39f8:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    39fa:	06 80       	ldd	r0, Z+6	; 0x06
    39fc:	f7 81       	ldd	r31, Z+7	; 0x07
    39fe:	e0 2d       	mov	r30, r0
    3a00:	80 81       	ld	r24, Z
    3a02:	80 81       	ld	r24, Z
}
    3a04:	df 91       	pop	r29
    3a06:	cf 91       	pop	r28
    3a08:	08 95       	ret

00003a0a <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3a0a:	81 e0       	ldi	r24, 0x01	; 1
    3a0c:	08 95       	ret

00003a0e <_ZN8emstream7getcharEv>:
    3a0e:	80 e0       	ldi	r24, 0x00	; 0
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	08 95       	ret

00003a14 <_ZN8emstream14check_for_charEv>:
    3a14:	80 e0       	ldi	r24, 0x00	; 0
    3a16:	08 95       	ret

00003a18 <_ZN8emstream12transmit_nowEv>:
    3a18:	08 95       	ret

00003a1a <_ZN8emstream12clear_screenEv>:
    3a1a:	08 95       	ret

00003a1c <_ZN8emstreamC1Ev>:
    3a1c:	fc 01       	movw	r30, r24
    3a1e:	84 e3       	ldi	r24, 0x34	; 52
    3a20:	91 e2       	ldi	r25, 0x21	; 33
    3a22:	80 83       	st	Z, r24
    3a24:	91 83       	std	Z+1, r25	; 0x01
    3a26:	8a e0       	ldi	r24, 0x0A	; 10
    3a28:	82 83       	std	Z+2, r24	; 0x02
    3a2a:	13 82       	std	Z+3, r1	; 0x03
    3a2c:	83 e0       	ldi	r24, 0x03	; 3
    3a2e:	85 83       	std	Z+5, r24	; 0x05
    3a30:	14 82       	std	Z+4, r1	; 0x04
    3a32:	16 82       	std	Z+6, r1	; 0x06
    3a34:	17 82       	std	Z+7, r1	; 0x07
    3a36:	08 95       	ret

00003a38 <_ZN8emstream4putsEPKc>:
    3a38:	0f 93       	push	r16
    3a3a:	1f 93       	push	r17
    3a3c:	cf 93       	push	r28
    3a3e:	df 93       	push	r29
    3a40:	8c 01       	movw	r16, r24
    3a42:	fb 01       	movw	r30, r22
    3a44:	dc 01       	movw	r26, r24
    3a46:	14 96       	adiw	r26, 0x04	; 4
    3a48:	8c 91       	ld	r24, X
    3a4a:	81 11       	cpse	r24, r1
    3a4c:	04 c0       	rjmp	.+8      	; 0x3a56 <_ZN8emstream4putsEPKc+0x1e>
    3a4e:	60 81       	ld	r22, Z
    3a50:	61 11       	cpse	r22, r1
    3a52:	17 c0       	rjmp	.+46     	; 0x3a82 <_ZN8emstream4putsEPKc+0x4a>
    3a54:	23 c0       	rjmp	.+70     	; 0x3a9c <_ZN8emstream4putsEPKc+0x64>
    3a56:	d8 01       	movw	r26, r16
    3a58:	14 96       	adiw	r26, 0x04	; 4
    3a5a:	1c 92       	st	X, r1
    3a5c:	eb 01       	movw	r28, r22
    3a5e:	21 96       	adiw	r28, 0x01	; 1
    3a60:	64 91       	lpm	r22, Z
    3a62:	66 23       	and	r22, r22
    3a64:	d9 f0       	breq	.+54     	; 0x3a9c <_ZN8emstream4putsEPKc+0x64>
    3a66:	d8 01       	movw	r26, r16
    3a68:	ed 91       	ld	r30, X+
    3a6a:	fc 91       	ld	r31, X
    3a6c:	02 80       	ldd	r0, Z+2	; 0x02
    3a6e:	f3 81       	ldd	r31, Z+3	; 0x03
    3a70:	e0 2d       	mov	r30, r0
    3a72:	c8 01       	movw	r24, r16
    3a74:	19 95       	eicall
    3a76:	fe 01       	movw	r30, r28
    3a78:	64 91       	lpm	r22, Z
    3a7a:	21 96       	adiw	r28, 0x01	; 1
    3a7c:	61 11       	cpse	r22, r1
    3a7e:	f3 cf       	rjmp	.-26     	; 0x3a66 <_ZN8emstream4putsEPKc+0x2e>
    3a80:	0d c0       	rjmp	.+26     	; 0x3a9c <_ZN8emstream4putsEPKc+0x64>
    3a82:	ef 01       	movw	r28, r30
    3a84:	21 96       	adiw	r28, 0x01	; 1
    3a86:	d8 01       	movw	r26, r16
    3a88:	ed 91       	ld	r30, X+
    3a8a:	fc 91       	ld	r31, X
    3a8c:	02 80       	ldd	r0, Z+2	; 0x02
    3a8e:	f3 81       	ldd	r31, Z+3	; 0x03
    3a90:	e0 2d       	mov	r30, r0
    3a92:	c8 01       	movw	r24, r16
    3a94:	19 95       	eicall
    3a96:	69 91       	ld	r22, Y+
    3a98:	61 11       	cpse	r22, r1
    3a9a:	f5 cf       	rjmp	.-22     	; 0x3a86 <_ZN8emstream4putsEPKc+0x4e>
    3a9c:	df 91       	pop	r29
    3a9e:	cf 91       	pop	r28
    3aa0:	1f 91       	pop	r17
    3aa2:	0f 91       	pop	r16
    3aa4:	08 95       	ret

00003aa6 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3aa6:	cf 93       	push	r28
    3aa8:	df 93       	push	r29
    3aaa:	ec 01       	movw	r28, r24
	switch (new_manip)
    3aac:	86 2f       	mov	r24, r22
    3aae:	90 e0       	ldi	r25, 0x00	; 0
    3ab0:	8b 30       	cpi	r24, 0x0B	; 11
    3ab2:	91 05       	cpc	r25, r1
    3ab4:	d8 f5       	brcc	.+118    	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	88 27       	eor	r24, r24
    3aba:	e2 50       	subi	r30, 0x02	; 2
    3abc:	ff 4f       	sbci	r31, 0xFF	; 255
    3abe:	8f 4f       	sbci	r24, 0xFF	; 255
    3ac0:	0c 94 b9 24 	jmp	0x4972	; 0x4972 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3ac4:	82 e0       	ldi	r24, 0x02	; 2
    3ac6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ac8:	31 c0       	rjmp	.+98     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3aca:	88 e0       	ldi	r24, 0x08	; 8
    3acc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ace:	2e c0       	rjmp	.+92     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3ad0:	8a e0       	ldi	r24, 0x0A	; 10
    3ad2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ad4:	2b c0       	rjmp	.+86     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3ad6:	80 e1       	ldi	r24, 0x10	; 16
    3ad8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ada:	28 c0       	rjmp	.+80     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3adc:	81 e0       	ldi	r24, 0x01	; 1
    3ade:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3ae0:	25 c0       	rjmp	.+74     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3ae2:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3ae4:	23 c0       	rjmp	.+70     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3ae6:	e8 81       	ld	r30, Y
    3ae8:	f9 81       	ldd	r31, Y+1	; 0x01
    3aea:	02 80       	ldd	r0, Z+2	; 0x02
    3aec:	f3 81       	ldd	r31, Z+3	; 0x03
    3aee:	e0 2d       	mov	r30, r0
    3af0:	6d e0       	ldi	r22, 0x0D	; 13
    3af2:	ce 01       	movw	r24, r28
    3af4:	19 95       	eicall
    3af6:	e8 81       	ld	r30, Y
    3af8:	f9 81       	ldd	r31, Y+1	; 0x01
    3afa:	02 80       	ldd	r0, Z+2	; 0x02
    3afc:	f3 81       	ldd	r31, Z+3	; 0x03
    3afe:	e0 2d       	mov	r30, r0
    3b00:	6a e0       	ldi	r22, 0x0A	; 10
    3b02:	ce 01       	movw	r24, r28
    3b04:	19 95       	eicall
			break;
    3b06:	12 c0       	rjmp	.+36     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3b08:	e8 81       	ld	r30, Y
    3b0a:	f9 81       	ldd	r31, Y+1	; 0x01
    3b0c:	02 84       	ldd	r0, Z+10	; 0x0a
    3b0e:	f3 85       	ldd	r31, Z+11	; 0x0b
    3b10:	e0 2d       	mov	r30, r0
    3b12:	ce 01       	movw	r24, r28
    3b14:	19 95       	eicall
			break;
    3b16:	0a c0       	rjmp	.+20     	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3b18:	e8 81       	ld	r30, Y
    3b1a:	f9 81       	ldd	r31, Y+1	; 0x01
    3b1c:	00 84       	ldd	r0, Z+8	; 0x08
    3b1e:	f1 85       	ldd	r31, Z+9	; 0x09
    3b20:	e0 2d       	mov	r30, r0
    3b22:	ce 01       	movw	r24, r28
    3b24:	19 95       	eicall
			break;
    3b26:	02 c0       	rjmp	.+4      	; 0x3b2c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3b28:	81 e0       	ldi	r24, 0x01	; 1
    3b2a:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3b2c:	ce 01       	movw	r24, r28
    3b2e:	df 91       	pop	r29
    3b30:	cf 91       	pop	r28
    3b32:	08 95       	ret

00003b34 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3b34:	ff 92       	push	r15
    3b36:	0f 93       	push	r16
    3b38:	1f 93       	push	r17
    3b3a:	cf 93       	push	r28
    3b3c:	df 93       	push	r29
    3b3e:	cd b7       	in	r28, 0x3d	; 61
    3b40:	de b7       	in	r29, 0x3e	; 62
    3b42:	61 97       	sbiw	r28, 0x11	; 17
    3b44:	cd bf       	out	0x3d, r28	; 61
    3b46:	de bf       	out	0x3e, r29	; 62
    3b48:	8c 01       	movw	r16, r24
    3b4a:	f6 2e       	mov	r15, r22
    3b4c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b4e:	f8 01       	movw	r30, r16
    3b50:	42 81       	ldd	r20, Z+2	; 0x02
    3b52:	40 31       	cpi	r20, 0x10	; 16
    3b54:	21 f0       	breq	.+8      	; 0x3b5e <_ZN8emstreamlsEj+0x2a>
    3b56:	48 30       	cpi	r20, 0x08	; 8
    3b58:	11 f0       	breq	.+4      	; 0x3b5e <_ZN8emstreamlsEj+0x2a>
    3b5a:	42 30       	cpi	r20, 0x02	; 2
    3b5c:	41 f4       	brne	.+16     	; 0x3b6e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3b5e:	69 2f       	mov	r22, r25
    3b60:	c8 01       	movw	r24, r16
    3b62:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3b66:	6f 2d       	mov	r22, r15
    3b68:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3b6c:	0d c0       	rjmp	.+26     	; 0x3b88 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b6e:	50 e0       	ldi	r21, 0x00	; 0
    3b70:	be 01       	movw	r22, r28
    3b72:	6f 5f       	subi	r22, 0xFF	; 255
    3b74:	7f 4f       	sbci	r23, 0xFF	; 255
    3b76:	8f 2d       	mov	r24, r15
    3b78:	0e 94 28 25 	call	0x4a50	; 0x4a50 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b7c:	be 01       	movw	r22, r28
    3b7e:	6f 5f       	subi	r22, 0xFF	; 255
    3b80:	7f 4f       	sbci	r23, 0xFF	; 255
    3b82:	c8 01       	movw	r24, r16
    3b84:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b88:	c8 01       	movw	r24, r16
    3b8a:	61 96       	adiw	r28, 0x11	; 17
    3b8c:	cd bf       	out	0x3d, r28	; 61
    3b8e:	de bf       	out	0x3e, r29	; 62
    3b90:	df 91       	pop	r29
    3b92:	cf 91       	pop	r28
    3b94:	1f 91       	pop	r17
    3b96:	0f 91       	pop	r16
    3b98:	ff 90       	pop	r15
    3b9a:	08 95       	ret

00003b9c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3b9c:	df 92       	push	r13
    3b9e:	ef 92       	push	r14
    3ba0:	ff 92       	push	r15
    3ba2:	0f 93       	push	r16
    3ba4:	1f 93       	push	r17
    3ba6:	cf 93       	push	r28
    3ba8:	df 93       	push	r29
    3baa:	cd b7       	in	r28, 0x3d	; 61
    3bac:	de b7       	in	r29, 0x3e	; 62
    3bae:	a1 97       	sbiw	r28, 0x21	; 33
    3bb0:	cd bf       	out	0x3d, r28	; 61
    3bb2:	de bf       	out	0x3e, r29	; 62
    3bb4:	8c 01       	movw	r16, r24
    3bb6:	d4 2e       	mov	r13, r20
    3bb8:	e5 2e       	mov	r14, r21
    3bba:	f6 2e       	mov	r15, r22
    3bbc:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3bbe:	f8 01       	movw	r30, r16
    3bc0:	22 81       	ldd	r18, Z+2	; 0x02
    3bc2:	20 31       	cpi	r18, 0x10	; 16
    3bc4:	21 f0       	breq	.+8      	; 0x3bce <_ZN8emstreamlsEm+0x32>
    3bc6:	28 30       	cpi	r18, 0x08	; 8
    3bc8:	11 f0       	breq	.+4      	; 0x3bce <_ZN8emstreamlsEm+0x32>
    3bca:	22 30       	cpi	r18, 0x02	; 2
    3bcc:	71 f4       	brne	.+28     	; 0x3bea <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3bce:	69 2f       	mov	r22, r25
    3bd0:	c8 01       	movw	r24, r16
    3bd2:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3bd6:	6f 2d       	mov	r22, r15
    3bd8:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3bdc:	6e 2d       	mov	r22, r14
    3bde:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3be2:	6d 2d       	mov	r22, r13
    3be4:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <_ZN8emstreamlsEh>
    3be8:	0f c0       	rjmp	.+30     	; 0x3c08 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3bea:	30 e0       	ldi	r19, 0x00	; 0
    3bec:	ae 01       	movw	r20, r28
    3bee:	4f 5f       	subi	r20, 0xFF	; 255
    3bf0:	5f 4f       	sbci	r21, 0xFF	; 255
    3bf2:	6d 2d       	mov	r22, r13
    3bf4:	7e 2d       	mov	r23, r14
    3bf6:	8f 2d       	mov	r24, r15
    3bf8:	0e 94 fb 24 	call	0x49f6	; 0x49f6 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3bfc:	be 01       	movw	r22, r28
    3bfe:	6f 5f       	subi	r22, 0xFF	; 255
    3c00:	7f 4f       	sbci	r23, 0xFF	; 255
    3c02:	c8 01       	movw	r24, r16
    3c04:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3c08:	c8 01       	movw	r24, r16
    3c0a:	a1 96       	adiw	r28, 0x21	; 33
    3c0c:	cd bf       	out	0x3d, r28	; 61
    3c0e:	de bf       	out	0x3e, r29	; 62
    3c10:	df 91       	pop	r29
    3c12:	cf 91       	pop	r28
    3c14:	1f 91       	pop	r17
    3c16:	0f 91       	pop	r16
    3c18:	ff 90       	pop	r15
    3c1a:	ef 90       	pop	r14
    3c1c:	df 90       	pop	r13
    3c1e:	08 95       	ret

00003c20 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3c20:	cf 92       	push	r12
    3c22:	df 92       	push	r13
    3c24:	ef 92       	push	r14
    3c26:	ff 92       	push	r15
    3c28:	0f 93       	push	r16
    3c2a:	1f 93       	push	r17
    3c2c:	cf 93       	push	r28
    3c2e:	df 93       	push	r29
    3c30:	cd b7       	in	r28, 0x3d	; 61
    3c32:	de b7       	in	r29, 0x3e	; 62
    3c34:	29 97       	sbiw	r28, 0x09	; 9
    3c36:	cd bf       	out	0x3d, r28	; 61
    3c38:	de bf       	out	0x3e, r29	; 62
    3c3a:	8c 01       	movw	r16, r24
    3c3c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3c3e:	dc 01       	movw	r26, r24
    3c40:	13 96       	adiw	r26, 0x03	; 3
    3c42:	8c 91       	ld	r24, X
    3c44:	13 97       	sbiw	r26, 0x03	; 3
    3c46:	88 23       	and	r24, r24
    3c48:	41 f0       	breq	.+16     	; 0x3c5a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3c4a:	ed 91       	ld	r30, X+
    3c4c:	fc 91       	ld	r31, X
    3c4e:	02 80       	ldd	r0, Z+2	; 0x02
    3c50:	f3 81       	ldd	r31, Z+3	; 0x03
    3c52:	e0 2d       	mov	r30, r0
    3c54:	c8 01       	movw	r24, r16
    3c56:	19 95       	eicall
    3c58:	56 c0       	rjmp	.+172    	; 0x3d06 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3c5a:	f8 01       	movw	r30, r16
    3c5c:	42 81       	ldd	r20, Z+2	; 0x02
    3c5e:	42 30       	cpi	r20, 0x02	; 2
    3c60:	19 f5       	brne	.+70     	; 0x3ca8 <_ZN8emstreamlsEh+0x88>
    3c62:	68 94       	set
    3c64:	cc 24       	eor	r12, r12
    3c66:	c3 f8       	bld	r12, 3
    3c68:	d1 2c       	mov	r13, r1
    3c6a:	68 94       	set
    3c6c:	ff 24       	eor	r15, r15
    3c6e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3c70:	8e 2d       	mov	r24, r14
    3c72:	8f 21       	and	r24, r15
    3c74:	51 f0       	breq	.+20     	; 0x3c8a <_ZN8emstreamlsEh+0x6a>
    3c76:	d8 01       	movw	r26, r16
    3c78:	ed 91       	ld	r30, X+
    3c7a:	fc 91       	ld	r31, X
    3c7c:	02 80       	ldd	r0, Z+2	; 0x02
    3c7e:	f3 81       	ldd	r31, Z+3	; 0x03
    3c80:	e0 2d       	mov	r30, r0
    3c82:	61 e3       	ldi	r22, 0x31	; 49
    3c84:	c8 01       	movw	r24, r16
    3c86:	19 95       	eicall
    3c88:	09 c0       	rjmp	.+18     	; 0x3c9c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3c8a:	d8 01       	movw	r26, r16
    3c8c:	ed 91       	ld	r30, X+
    3c8e:	fc 91       	ld	r31, X
    3c90:	02 80       	ldd	r0, Z+2	; 0x02
    3c92:	f3 81       	ldd	r31, Z+3	; 0x03
    3c94:	e0 2d       	mov	r30, r0
    3c96:	60 e3       	ldi	r22, 0x30	; 48
    3c98:	c8 01       	movw	r24, r16
    3c9a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3c9c:	f6 94       	lsr	r15
    3c9e:	b1 e0       	ldi	r27, 0x01	; 1
    3ca0:	cb 1a       	sub	r12, r27
    3ca2:	d1 08       	sbc	r13, r1
    3ca4:	29 f7       	brne	.-54     	; 0x3c70 <_ZN8emstreamlsEh+0x50>
    3ca6:	2f c0       	rjmp	.+94     	; 0x3d06 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3ca8:	40 31       	cpi	r20, 0x10	; 16
    3caa:	f9 f4       	brne	.+62     	; 0x3cea <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3cac:	62 95       	swap	r22
    3cae:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cb0:	01 90       	ld	r0, Z+
    3cb2:	f0 81       	ld	r31, Z
    3cb4:	e0 2d       	mov	r30, r0
    3cb6:	02 80       	ldd	r0, Z+2	; 0x02
    3cb8:	f3 81       	ldd	r31, Z+3	; 0x03
    3cba:	e0 2d       	mov	r30, r0
    3cbc:	6a 30       	cpi	r22, 0x0A	; 10
    3cbe:	10 f0       	brcs	.+4      	; 0x3cc4 <_ZN8emstreamlsEh+0xa4>
    3cc0:	69 5c       	subi	r22, 0xC9	; 201
    3cc2:	01 c0       	rjmp	.+2      	; 0x3cc6 <_ZN8emstreamlsEh+0xa6>
    3cc4:	60 5d       	subi	r22, 0xD0	; 208
    3cc6:	c8 01       	movw	r24, r16
    3cc8:	19 95       	eicall
		temp_char = num & 0x0F;
    3cca:	6e 2d       	mov	r22, r14
    3ccc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cce:	d8 01       	movw	r26, r16
    3cd0:	ed 91       	ld	r30, X+
    3cd2:	fc 91       	ld	r31, X
    3cd4:	02 80       	ldd	r0, Z+2	; 0x02
    3cd6:	f3 81       	ldd	r31, Z+3	; 0x03
    3cd8:	e0 2d       	mov	r30, r0
    3cda:	6a 30       	cpi	r22, 0x0A	; 10
    3cdc:	10 f0       	brcs	.+4      	; 0x3ce2 <_ZN8emstreamlsEh+0xc2>
    3cde:	69 5c       	subi	r22, 0xC9	; 201
    3ce0:	01 c0       	rjmp	.+2      	; 0x3ce4 <_ZN8emstreamlsEh+0xc4>
    3ce2:	60 5d       	subi	r22, 0xD0	; 208
    3ce4:	c8 01       	movw	r24, r16
    3ce6:	19 95       	eicall
    3ce8:	0e c0       	rjmp	.+28     	; 0x3d06 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3cea:	50 e0       	ldi	r21, 0x00	; 0
    3cec:	be 01       	movw	r22, r28
    3cee:	6f 5f       	subi	r22, 0xFF	; 255
    3cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    3cf2:	8e 2d       	mov	r24, r14
    3cf4:	90 e0       	ldi	r25, 0x00	; 0
    3cf6:	0e 94 28 25 	call	0x4a50	; 0x4a50 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3cfa:	be 01       	movw	r22, r28
    3cfc:	6f 5f       	subi	r22, 0xFF	; 255
    3cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    3d00:	c8 01       	movw	r24, r16
    3d02:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3d06:	c8 01       	movw	r24, r16
    3d08:	29 96       	adiw	r28, 0x09	; 9
    3d0a:	cd bf       	out	0x3d, r28	; 61
    3d0c:	de bf       	out	0x3e, r29	; 62
    3d0e:	df 91       	pop	r29
    3d10:	cf 91       	pop	r28
    3d12:	1f 91       	pop	r17
    3d14:	0f 91       	pop	r16
    3d16:	ff 90       	pop	r15
    3d18:	ef 90       	pop	r14
    3d1a:	df 90       	pop	r13
    3d1c:	cf 90       	pop	r12
    3d1e:	08 95       	ret

00003d20 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3d20:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d22:	50 96       	adiw	r26, 0x10	; 16
    3d24:	ed 91       	ld	r30, X+
    3d26:	fc 91       	ld	r31, X
    3d28:	51 97       	sbiw	r26, 0x11	; 17
    3d2a:	80 81       	ld	r24, Z
    3d2c:	54 96       	adiw	r26, 0x14	; 20
    3d2e:	4c 91       	ld	r20, X
    3d30:	54 97       	sbiw	r26, 0x14	; 20
    3d32:	84 23       	and	r24, r20
    3d34:	29 f0       	breq	.+10     	; 0x3d40 <_ZN5rs2327putcharEc+0x20>
    3d36:	09 c0       	rjmp	.+18     	; 0x3d4a <_ZN5rs2327putcharEc+0x2a>
    3d38:	21 50       	subi	r18, 0x01	; 1
    3d3a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3d3c:	19 f4       	brne	.+6      	; 0x3d44 <_ZN5rs2327putcharEc+0x24>
    3d3e:	12 c0       	rjmp	.+36     	; 0x3d64 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d40:	21 e2       	ldi	r18, 0x21	; 33
    3d42:	3e e4       	ldi	r19, 0x4E	; 78
    3d44:	90 81       	ld	r25, Z
    3d46:	94 23       	and	r25, r20
    3d48:	b9 f3       	breq	.-18     	; 0x3d38 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3d4a:	90 81       	ld	r25, Z
    3d4c:	56 96       	adiw	r26, 0x16	; 22
    3d4e:	8c 91       	ld	r24, X
    3d50:	56 97       	sbiw	r26, 0x16	; 22
    3d52:	89 2b       	or	r24, r25
    3d54:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3d56:	1e 96       	adiw	r26, 0x0e	; 14
    3d58:	ed 91       	ld	r30, X+
    3d5a:	fc 91       	ld	r31, X
    3d5c:	1f 97       	sbiw	r26, 0x0f	; 15
    3d5e:	60 83       	st	Z, r22
	return (true);
    3d60:	81 e0       	ldi	r24, 0x01	; 1
    3d62:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3d64:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3d66:	08 95       	ret

00003d68 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3d68:	cf 93       	push	r28
    3d6a:	df 93       	push	r29
    3d6c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3d6e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3d70:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3d72:	28 81       	ld	r18, Y
    3d74:	39 81       	ldd	r19, Y+1	; 0x01
    3d76:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d78:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d7a:	4d 91       	ld	r20, X+
    3d7c:	5c 91       	ld	r21, X
    3d7e:	24 17       	cp	r18, r20
    3d80:	35 07       	cpc	r19, r21
    3d82:	e9 f3       	breq	.-6      	; 0x3d7e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3d84:	a7 89       	ldd	r26, Z+23	; 0x17
    3d86:	b0 8d       	ldd	r27, Z+24	; 0x18
    3d88:	0d 90       	ld	r0, X+
    3d8a:	bc 91       	ld	r27, X
    3d8c:	a0 2d       	mov	r26, r0
    3d8e:	a2 0f       	add	r26, r18
    3d90:	b3 1f       	adc	r27, r19
    3d92:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3d94:	2f 5f       	subi	r18, 0xFF	; 255
    3d96:	3f 4f       	sbci	r19, 0xFF	; 255
    3d98:	28 83       	st	Y, r18
    3d9a:	39 83       	std	Y+1, r19	; 0x01
    3d9c:	24 36       	cpi	r18, 0x64	; 100
    3d9e:	31 05       	cpc	r19, r1
    3da0:	28 f0       	brcs	.+10     	; 0x3dac <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3da2:	01 8c       	ldd	r0, Z+25	; 0x19
    3da4:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3da6:	e0 2d       	mov	r30, r0
    3da8:	10 82       	st	Z, r1
    3daa:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3dac:	90 e0       	ldi	r25, 0x00	; 0
    3dae:	df 91       	pop	r29
    3db0:	cf 91       	pop	r28
    3db2:	08 95       	ret

00003db4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3db4:	cf 93       	push	r28
    3db6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3db8:	ec 01       	movw	r28, r24
    3dba:	a9 8d       	ldd	r26, Y+25	; 0x19
    3dbc:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3dbe:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3dc0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3dc2:	81 e0       	ldi	r24, 0x01	; 1
    3dc4:	4d 91       	ld	r20, X+
    3dc6:	5c 91       	ld	r21, X
    3dc8:	20 81       	ld	r18, Z
    3dca:	31 81       	ldd	r19, Z+1	; 0x01
    3dcc:	42 17       	cp	r20, r18
    3dce:	53 07       	cpc	r21, r19
    3dd0:	09 f4       	brne	.+2      	; 0x3dd4 <_ZN5rs23214check_for_charEv+0x20>
    3dd2:	80 e0       	ldi	r24, 0x00	; 0
}
    3dd4:	df 91       	pop	r29
    3dd6:	cf 91       	pop	r28
    3dd8:	08 95       	ret

00003dda <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3dda:	dc 01       	movw	r26, r24
    3ddc:	ed 91       	ld	r30, X+
    3dde:	fc 91       	ld	r31, X
    3de0:	02 80       	ldd	r0, Z+2	; 0x02
    3de2:	f3 81       	ldd	r31, Z+3	; 0x03
    3de4:	e0 2d       	mov	r30, r0
    3de6:	6c e0       	ldi	r22, 0x0C	; 12
    3de8:	19 95       	eicall
    3dea:	08 95       	ret

00003dec <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3dec:	ef 92       	push	r14
    3dee:	ff 92       	push	r15
    3df0:	0f 93       	push	r16
    3df2:	1f 93       	push	r17
    3df4:	cf 93       	push	r28
    3df6:	df 93       	push	r29
    3df8:	ec 01       	movw	r28, r24
    3dfa:	7b 01       	movw	r14, r22
    3dfc:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3dfe:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <_ZN8emstreamC1Ev>
    3e02:	a8 01       	movw	r20, r16
    3e04:	b7 01       	movw	r22, r14
    3e06:	ce 01       	movw	r24, r28
    3e08:	08 96       	adiw	r24, 0x08	; 8
    3e0a:	0e 94 6f 1c 	call	0x38de	; 0x38de <_ZN7base232C1EjP12USART_struct>
    3e0e:	84 e4       	ldi	r24, 0x44	; 68
    3e10:	91 e2       	ldi	r25, 0x21	; 33
    3e12:	88 83       	st	Y, r24
    3e14:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3e16:	00 3a       	cpi	r16, 0xA0	; 160
    3e18:	88 e0       	ldi	r24, 0x08	; 8
    3e1a:	18 07       	cpc	r17, r24
    3e1c:	69 f4       	brne	.+26     	; 0x3e38 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3e1e:	8e e4       	ldi	r24, 0x4E	; 78
    3e20:	92 e3       	ldi	r25, 0x32	; 50
    3e22:	8f 8b       	std	Y+23, r24	; 0x17
    3e24:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3e26:	84 e4       	ldi	r24, 0x44	; 68
    3e28:	92 e3       	ldi	r25, 0x32	; 50
    3e2a:	89 8f       	std	Y+25, r24	; 0x19
    3e2c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3e2e:	8a e3       	ldi	r24, 0x3A	; 58
    3e30:	92 e3       	ldi	r25, 0x32	; 50
    3e32:	8b 8f       	std	Y+27, r24	; 0x1b
    3e34:	9c 8f       	std	Y+28, r25	; 0x1c
    3e36:	42 c0       	rjmp	.+132    	; 0x3ebc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3e38:	00 3b       	cpi	r16, 0xB0	; 176
    3e3a:	e8 e0       	ldi	r30, 0x08	; 8
    3e3c:	1e 07       	cpc	r17, r30
    3e3e:	69 f4       	brne	.+26     	; 0x3e5a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3e40:	8c e4       	ldi	r24, 0x4C	; 76
    3e42:	92 e3       	ldi	r25, 0x32	; 50
    3e44:	8f 8b       	std	Y+23, r24	; 0x17
    3e46:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3e48:	82 e4       	ldi	r24, 0x42	; 66
    3e4a:	92 e3       	ldi	r25, 0x32	; 50
    3e4c:	89 8f       	std	Y+25, r24	; 0x19
    3e4e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3e50:	88 e3       	ldi	r24, 0x38	; 56
    3e52:	92 e3       	ldi	r25, 0x32	; 50
    3e54:	8b 8f       	std	Y+27, r24	; 0x1b
    3e56:	9c 8f       	std	Y+28, r25	; 0x1c
    3e58:	31 c0       	rjmp	.+98     	; 0x3ebc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e5a:	00 3a       	cpi	r16, 0xA0	; 160
    3e5c:	f9 e0       	ldi	r31, 0x09	; 9
    3e5e:	1f 07       	cpc	r17, r31
    3e60:	69 f4       	brne	.+26     	; 0x3e7c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3e62:	8a e4       	ldi	r24, 0x4A	; 74
    3e64:	92 e3       	ldi	r25, 0x32	; 50
    3e66:	8f 8b       	std	Y+23, r24	; 0x17
    3e68:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3e6a:	80 e4       	ldi	r24, 0x40	; 64
    3e6c:	92 e3       	ldi	r25, 0x32	; 50
    3e6e:	89 8f       	std	Y+25, r24	; 0x19
    3e70:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3e72:	86 e3       	ldi	r24, 0x36	; 54
    3e74:	92 e3       	ldi	r25, 0x32	; 50
    3e76:	8b 8f       	std	Y+27, r24	; 0x1b
    3e78:	9c 8f       	std	Y+28, r25	; 0x1c
    3e7a:	20 c0       	rjmp	.+64     	; 0x3ebc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e7c:	00 3b       	cpi	r16, 0xB0	; 176
    3e7e:	89 e0       	ldi	r24, 0x09	; 9
    3e80:	18 07       	cpc	r17, r24
    3e82:	69 f4       	brne	.+26     	; 0x3e9e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3e84:	88 e4       	ldi	r24, 0x48	; 72
    3e86:	92 e3       	ldi	r25, 0x32	; 50
    3e88:	8f 8b       	std	Y+23, r24	; 0x17
    3e8a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3e8c:	8e e3       	ldi	r24, 0x3E	; 62
    3e8e:	92 e3       	ldi	r25, 0x32	; 50
    3e90:	89 8f       	std	Y+25, r24	; 0x19
    3e92:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3e94:	84 e3       	ldi	r24, 0x34	; 52
    3e96:	92 e3       	ldi	r25, 0x32	; 50
    3e98:	8b 8f       	std	Y+27, r24	; 0x1b
    3e9a:	9c 8f       	std	Y+28, r25	; 0x1c
    3e9c:	0f c0       	rjmp	.+30     	; 0x3ebc <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3e9e:	00 3a       	cpi	r16, 0xA0	; 160
    3ea0:	1a 40       	sbci	r17, 0x0A	; 10
    3ea2:	61 f4       	brne	.+24     	; 0x3ebc <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3ea4:	86 e4       	ldi	r24, 0x46	; 70
    3ea6:	92 e3       	ldi	r25, 0x32	; 50
    3ea8:	8f 8b       	std	Y+23, r24	; 0x17
    3eaa:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3eac:	8c e3       	ldi	r24, 0x3C	; 60
    3eae:	92 e3       	ldi	r25, 0x32	; 50
    3eb0:	89 8f       	std	Y+25, r24	; 0x19
    3eb2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3eb4:	82 e3       	ldi	r24, 0x32	; 50
    3eb6:	92 e3       	ldi	r25, 0x32	; 50
    3eb8:	8b 8f       	std	Y+27, r24	; 0x1b
    3eba:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3ebc:	0f 89       	ldd	r16, Y+23	; 0x17
    3ebe:	18 8d       	ldd	r17, Y+24	; 0x18
    3ec0:	84 e6       	ldi	r24, 0x64	; 100
    3ec2:	90 e0       	ldi	r25, 0x00	; 0
    3ec4:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <_Znaj>
    3ec8:	f8 01       	movw	r30, r16
    3eca:	80 83       	st	Z, r24
    3ecc:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3ece:	e9 8d       	ldd	r30, Y+25	; 0x19
    3ed0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3ed2:	10 82       	st	Z, r1
    3ed4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3ed6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3ed8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3eda:	10 82       	st	Z, r1
    3edc:	11 82       	std	Z+1, r1	; 0x01
}
    3ede:	df 91       	pop	r29
    3ee0:	cf 91       	pop	r28
    3ee2:	1f 91       	pop	r17
    3ee4:	0f 91       	pop	r16
    3ee6:	ff 90       	pop	r15
    3ee8:	ef 90       	pop	r14
    3eea:	08 95       	ret

00003eec <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3eec:	1f 92       	push	r1
    3eee:	0f 92       	push	r0
    3ef0:	0f b6       	in	r0, 0x3f	; 63
    3ef2:	0f 92       	push	r0
    3ef4:	11 24       	eor	r1, r1
    3ef6:	08 b6       	in	r0, 0x38	; 56
    3ef8:	0f 92       	push	r0
    3efa:	18 be       	out	0x38, r1	; 56
    3efc:	0b b6       	in	r0, 0x3b	; 59
    3efe:	0f 92       	push	r0
    3f00:	1b be       	out	0x3b, r1	; 59
    3f02:	2f 93       	push	r18
    3f04:	3f 93       	push	r19
    3f06:	8f 93       	push	r24
    3f08:	9f 93       	push	r25
    3f0a:	ef 93       	push	r30
    3f0c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3f0e:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3f12:	e0 91 4e 32 	lds	r30, 0x324E	; 0x80324e <rcvC0_buffer>
    3f16:	f0 91 4f 32 	lds	r31, 0x324F	; 0x80324f <rcvC0_buffer+0x1>
    3f1a:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    3f1e:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    3f22:	e8 0f       	add	r30, r24
    3f24:	f9 1f       	adc	r31, r25
    3f26:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3f28:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    3f2c:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    3f30:	01 96       	adiw	r24, 0x01	; 1
    3f32:	84 36       	cpi	r24, 0x64	; 100
    3f34:	91 05       	cpc	r25, r1
    3f36:	60 f4       	brcc	.+24     	; 0x3f50 <__vector_25+0x64>
    3f38:	80 93 3a 32 	sts	0x323A, r24	; 0x80323a <rcvC0_write_index>
    3f3c:	90 93 3b 32 	sts	0x323B, r25	; 0x80323b <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f40:	20 91 44 32 	lds	r18, 0x3244	; 0x803244 <rcvC0_read_index>
    3f44:	30 91 45 32 	lds	r19, 0x3245	; 0x803245 <rcvC0_read_index+0x1>
    3f48:	82 17       	cp	r24, r18
    3f4a:	93 07       	cpc	r25, r19
    3f4c:	f1 f4       	brne	.+60     	; 0x3f8a <__vector_25+0x9e>
    3f4e:	0c c0       	rjmp	.+24     	; 0x3f68 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3f50:	10 92 3a 32 	sts	0x323A, r1	; 0x80323a <rcvC0_write_index>
    3f54:	10 92 3b 32 	sts	0x323B, r1	; 0x80323b <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f58:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <rcvC0_read_index>
    3f5c:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <rcvC0_read_index+0x1>
    3f60:	18 16       	cp	r1, r24
    3f62:	19 06       	cpc	r1, r25
    3f64:	91 f4       	brne	.+36     	; 0x3f8a <__vector_25+0x9e>
    3f66:	0e c0       	rjmp	.+28     	; 0x3f84 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f68:	01 96       	adiw	r24, 0x01	; 1
    3f6a:	84 36       	cpi	r24, 0x64	; 100
    3f6c:	91 05       	cpc	r25, r1
    3f6e:	28 f4       	brcc	.+10     	; 0x3f7a <__vector_25+0x8e>
    3f70:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <rcvC0_read_index>
    3f74:	90 93 45 32 	sts	0x3245, r25	; 0x803245 <rcvC0_read_index+0x1>
    3f78:	08 c0       	rjmp	.+16     	; 0x3f8a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f7a:	10 92 44 32 	sts	0x3244, r1	; 0x803244 <rcvC0_read_index>
    3f7e:	10 92 45 32 	sts	0x3245, r1	; 0x803245 <rcvC0_read_index+0x1>
}
    3f82:	03 c0       	rjmp	.+6      	; 0x3f8a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f84:	81 e0       	ldi	r24, 0x01	; 1
    3f86:	90 e0       	ldi	r25, 0x00	; 0
    3f88:	f3 cf       	rjmp	.-26     	; 0x3f70 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3f8a:	ff 91       	pop	r31
    3f8c:	ef 91       	pop	r30
    3f8e:	9f 91       	pop	r25
    3f90:	8f 91       	pop	r24
    3f92:	3f 91       	pop	r19
    3f94:	2f 91       	pop	r18
    3f96:	0f 90       	pop	r0
    3f98:	0b be       	out	0x3b, r0	; 59
    3f9a:	0f 90       	pop	r0
    3f9c:	08 be       	out	0x38, r0	; 56
    3f9e:	0f 90       	pop	r0
    3fa0:	0f be       	out	0x3f, r0	; 63
    3fa2:	0f 90       	pop	r0
    3fa4:	1f 90       	pop	r1
    3fa6:	18 95       	reti

00003fa8 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3fa8:	1f 92       	push	r1
    3faa:	0f 92       	push	r0
    3fac:	0f b6       	in	r0, 0x3f	; 63
    3fae:	0f 92       	push	r0
    3fb0:	11 24       	eor	r1, r1
    3fb2:	08 b6       	in	r0, 0x38	; 56
    3fb4:	0f 92       	push	r0
    3fb6:	18 be       	out	0x38, r1	; 56
    3fb8:	0b b6       	in	r0, 0x3b	; 59
    3fba:	0f 92       	push	r0
    3fbc:	1b be       	out	0x3b, r1	; 59
    3fbe:	2f 93       	push	r18
    3fc0:	3f 93       	push	r19
    3fc2:	8f 93       	push	r24
    3fc4:	9f 93       	push	r25
    3fc6:	ef 93       	push	r30
    3fc8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3fca:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3fce:	e0 91 4c 32 	lds	r30, 0x324C	; 0x80324c <rcvC1_buffer>
    3fd2:	f0 91 4d 32 	lds	r31, 0x324D	; 0x80324d <rcvC1_buffer+0x1>
    3fd6:	80 91 38 32 	lds	r24, 0x3238	; 0x803238 <rcvC1_write_index>
    3fda:	90 91 39 32 	lds	r25, 0x3239	; 0x803239 <rcvC1_write_index+0x1>
    3fde:	e8 0f       	add	r30, r24
    3fe0:	f9 1f       	adc	r31, r25
    3fe2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3fe4:	80 91 38 32 	lds	r24, 0x3238	; 0x803238 <rcvC1_write_index>
    3fe8:	90 91 39 32 	lds	r25, 0x3239	; 0x803239 <rcvC1_write_index+0x1>
    3fec:	01 96       	adiw	r24, 0x01	; 1
    3fee:	84 36       	cpi	r24, 0x64	; 100
    3ff0:	91 05       	cpc	r25, r1
    3ff2:	60 f4       	brcc	.+24     	; 0x400c <__stack+0xd>
    3ff4:	80 93 38 32 	sts	0x3238, r24	; 0x803238 <rcvC1_write_index>
    3ff8:	90 93 39 32 	sts	0x3239, r25	; 0x803239 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3ffc:	20 91 42 32 	lds	r18, 0x3242	; 0x803242 <rcvC1_read_index>
    4000:	30 91 43 32 	lds	r19, 0x3243	; 0x803243 <rcvC1_read_index+0x1>
    4004:	82 17       	cp	r24, r18
    4006:	93 07       	cpc	r25, r19
    4008:	f1 f4       	brne	.+60     	; 0x4046 <__stack+0x47>
    400a:	0c c0       	rjmp	.+24     	; 0x4024 <__stack+0x25>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    400c:	10 92 38 32 	sts	0x3238, r1	; 0x803238 <rcvC1_write_index>
    4010:	10 92 39 32 	sts	0x3239, r1	; 0x803239 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4014:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <rcvC1_read_index>
    4018:	90 91 43 32 	lds	r25, 0x3243	; 0x803243 <rcvC1_read_index+0x1>
    401c:	18 16       	cp	r1, r24
    401e:	19 06       	cpc	r1, r25
    4020:	91 f4       	brne	.+36     	; 0x4046 <__stack+0x47>
    4022:	0e c0       	rjmp	.+28     	; 0x4040 <__stack+0x41>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4024:	01 96       	adiw	r24, 0x01	; 1
    4026:	84 36       	cpi	r24, 0x64	; 100
    4028:	91 05       	cpc	r25, r1
    402a:	28 f4       	brcc	.+10     	; 0x4036 <__stack+0x37>
    402c:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <rcvC1_read_index>
    4030:	90 93 43 32 	sts	0x3243, r25	; 0x803243 <rcvC1_read_index+0x1>
    4034:	08 c0       	rjmp	.+16     	; 0x4046 <__stack+0x47>
	rcvC1_read_index = 0;
    4036:	10 92 42 32 	sts	0x3242, r1	; 0x803242 <rcvC1_read_index>
    403a:	10 92 43 32 	sts	0x3243, r1	; 0x803243 <rcvC1_read_index+0x1>
}
    403e:	03 c0       	rjmp	.+6      	; 0x4046 <__stack+0x47>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4040:	81 e0       	ldi	r24, 0x01	; 1
    4042:	90 e0       	ldi	r25, 0x00	; 0
    4044:	f3 cf       	rjmp	.-26     	; 0x402c <__stack+0x2d>
	rcvC1_read_index = 0;
}
    4046:	ff 91       	pop	r31
    4048:	ef 91       	pop	r30
    404a:	9f 91       	pop	r25
    404c:	8f 91       	pop	r24
    404e:	3f 91       	pop	r19
    4050:	2f 91       	pop	r18
    4052:	0f 90       	pop	r0
    4054:	0b be       	out	0x3b, r0	; 59
    4056:	0f 90       	pop	r0
    4058:	08 be       	out	0x38, r0	; 56
    405a:	0f 90       	pop	r0
    405c:	0f be       	out	0x3f, r0	; 63
    405e:	0f 90       	pop	r0
    4060:	1f 90       	pop	r1
    4062:	18 95       	reti

00004064 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4064:	1f 92       	push	r1
    4066:	0f 92       	push	r0
    4068:	0f b6       	in	r0, 0x3f	; 63
    406a:	0f 92       	push	r0
    406c:	11 24       	eor	r1, r1
    406e:	08 b6       	in	r0, 0x38	; 56
    4070:	0f 92       	push	r0
    4072:	18 be       	out	0x38, r1	; 56
    4074:	0b b6       	in	r0, 0x3b	; 59
    4076:	0f 92       	push	r0
    4078:	1b be       	out	0x3b, r1	; 59
    407a:	2f 93       	push	r18
    407c:	3f 93       	push	r19
    407e:	8f 93       	push	r24
    4080:	9f 93       	push	r25
    4082:	ef 93       	push	r30
    4084:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4086:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    408a:	e0 91 4a 32 	lds	r30, 0x324A	; 0x80324a <rcvD0_buffer>
    408e:	f0 91 4b 32 	lds	r31, 0x324B	; 0x80324b <rcvD0_buffer+0x1>
    4092:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    4096:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    409a:	e8 0f       	add	r30, r24
    409c:	f9 1f       	adc	r31, r25
    409e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    40a0:	80 91 36 32 	lds	r24, 0x3236	; 0x803236 <rcvD0_write_index>
    40a4:	90 91 37 32 	lds	r25, 0x3237	; 0x803237 <rcvD0_write_index+0x1>
    40a8:	01 96       	adiw	r24, 0x01	; 1
    40aa:	84 36       	cpi	r24, 0x64	; 100
    40ac:	91 05       	cpc	r25, r1
    40ae:	60 f4       	brcc	.+24     	; 0x40c8 <__vector_88+0x64>
    40b0:	80 93 36 32 	sts	0x3236, r24	; 0x803236 <rcvD0_write_index>
    40b4:	90 93 37 32 	sts	0x3237, r25	; 0x803237 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40b8:	20 91 40 32 	lds	r18, 0x3240	; 0x803240 <rcvD0_read_index>
    40bc:	30 91 41 32 	lds	r19, 0x3241	; 0x803241 <rcvD0_read_index+0x1>
    40c0:	82 17       	cp	r24, r18
    40c2:	93 07       	cpc	r25, r19
    40c4:	f1 f4       	brne	.+60     	; 0x4102 <__vector_88+0x9e>
    40c6:	0c c0       	rjmp	.+24     	; 0x40e0 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    40c8:	10 92 36 32 	sts	0x3236, r1	; 0x803236 <rcvD0_write_index>
    40cc:	10 92 37 32 	sts	0x3237, r1	; 0x803237 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40d0:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <rcvD0_read_index>
    40d4:	90 91 41 32 	lds	r25, 0x3241	; 0x803241 <rcvD0_read_index+0x1>
    40d8:	18 16       	cp	r1, r24
    40da:	19 06       	cpc	r1, r25
    40dc:	91 f4       	brne	.+36     	; 0x4102 <__vector_88+0x9e>
    40de:	0e c0       	rjmp	.+28     	; 0x40fc <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    40e0:	01 96       	adiw	r24, 0x01	; 1
    40e2:	84 36       	cpi	r24, 0x64	; 100
    40e4:	91 05       	cpc	r25, r1
    40e6:	28 f4       	brcc	.+10     	; 0x40f2 <__vector_88+0x8e>
    40e8:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <rcvD0_read_index>
    40ec:	90 93 41 32 	sts	0x3241, r25	; 0x803241 <rcvD0_read_index+0x1>
    40f0:	08 c0       	rjmp	.+16     	; 0x4102 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    40f2:	10 92 40 32 	sts	0x3240, r1	; 0x803240 <rcvD0_read_index>
    40f6:	10 92 41 32 	sts	0x3241, r1	; 0x803241 <rcvD0_read_index+0x1>
}
    40fa:	03 c0       	rjmp	.+6      	; 0x4102 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    40fc:	81 e0       	ldi	r24, 0x01	; 1
    40fe:	90 e0       	ldi	r25, 0x00	; 0
    4100:	f3 cf       	rjmp	.-26     	; 0x40e8 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4102:	ff 91       	pop	r31
    4104:	ef 91       	pop	r30
    4106:	9f 91       	pop	r25
    4108:	8f 91       	pop	r24
    410a:	3f 91       	pop	r19
    410c:	2f 91       	pop	r18
    410e:	0f 90       	pop	r0
    4110:	0b be       	out	0x3b, r0	; 59
    4112:	0f 90       	pop	r0
    4114:	08 be       	out	0x38, r0	; 56
    4116:	0f 90       	pop	r0
    4118:	0f be       	out	0x3f, r0	; 63
    411a:	0f 90       	pop	r0
    411c:	1f 90       	pop	r1
    411e:	18 95       	reti

00004120 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4120:	1f 92       	push	r1
    4122:	0f 92       	push	r0
    4124:	0f b6       	in	r0, 0x3f	; 63
    4126:	0f 92       	push	r0
    4128:	11 24       	eor	r1, r1
    412a:	08 b6       	in	r0, 0x38	; 56
    412c:	0f 92       	push	r0
    412e:	18 be       	out	0x38, r1	; 56
    4130:	0b b6       	in	r0, 0x3b	; 59
    4132:	0f 92       	push	r0
    4134:	1b be       	out	0x3b, r1	; 59
    4136:	2f 93       	push	r18
    4138:	3f 93       	push	r19
    413a:	8f 93       	push	r24
    413c:	9f 93       	push	r25
    413e:	ef 93       	push	r30
    4140:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4142:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4146:	e0 91 48 32 	lds	r30, 0x3248	; 0x803248 <rcvD1_buffer>
    414a:	f0 91 49 32 	lds	r31, 0x3249	; 0x803249 <rcvD1_buffer+0x1>
    414e:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <rcvD1_write_index>
    4152:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <rcvD1_write_index+0x1>
    4156:	e8 0f       	add	r30, r24
    4158:	f9 1f       	adc	r31, r25
    415a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    415c:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <rcvD1_write_index>
    4160:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <rcvD1_write_index+0x1>
    4164:	01 96       	adiw	r24, 0x01	; 1
    4166:	84 36       	cpi	r24, 0x64	; 100
    4168:	91 05       	cpc	r25, r1
    416a:	60 f4       	brcc	.+24     	; 0x4184 <__vector_91+0x64>
    416c:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <rcvD1_write_index>
    4170:	90 93 35 32 	sts	0x3235, r25	; 0x803235 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4174:	20 91 3e 32 	lds	r18, 0x323E	; 0x80323e <rcvD1_read_index>
    4178:	30 91 3f 32 	lds	r19, 0x323F	; 0x80323f <rcvD1_read_index+0x1>
    417c:	82 17       	cp	r24, r18
    417e:	93 07       	cpc	r25, r19
    4180:	f1 f4       	brne	.+60     	; 0x41be <__vector_91+0x9e>
    4182:	0c c0       	rjmp	.+24     	; 0x419c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4184:	10 92 34 32 	sts	0x3234, r1	; 0x803234 <rcvD1_write_index>
    4188:	10 92 35 32 	sts	0x3235, r1	; 0x803235 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    418c:	80 91 3e 32 	lds	r24, 0x323E	; 0x80323e <rcvD1_read_index>
    4190:	90 91 3f 32 	lds	r25, 0x323F	; 0x80323f <rcvD1_read_index+0x1>
    4194:	18 16       	cp	r1, r24
    4196:	19 06       	cpc	r1, r25
    4198:	91 f4       	brne	.+36     	; 0x41be <__vector_91+0x9e>
    419a:	0e c0       	rjmp	.+28     	; 0x41b8 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    419c:	01 96       	adiw	r24, 0x01	; 1
    419e:	84 36       	cpi	r24, 0x64	; 100
    41a0:	91 05       	cpc	r25, r1
    41a2:	28 f4       	brcc	.+10     	; 0x41ae <__vector_91+0x8e>
    41a4:	80 93 3e 32 	sts	0x323E, r24	; 0x80323e <rcvD1_read_index>
    41a8:	90 93 3f 32 	sts	0x323F, r25	; 0x80323f <rcvD1_read_index+0x1>
    41ac:	08 c0       	rjmp	.+16     	; 0x41be <__vector_91+0x9e>
	rcvD1_read_index = 0;
    41ae:	10 92 3e 32 	sts	0x323E, r1	; 0x80323e <rcvD1_read_index>
    41b2:	10 92 3f 32 	sts	0x323F, r1	; 0x80323f <rcvD1_read_index+0x1>
}
    41b6:	03 c0       	rjmp	.+6      	; 0x41be <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41b8:	81 e0       	ldi	r24, 0x01	; 1
    41ba:	90 e0       	ldi	r25, 0x00	; 0
    41bc:	f3 cf       	rjmp	.-26     	; 0x41a4 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    41be:	ff 91       	pop	r31
    41c0:	ef 91       	pop	r30
    41c2:	9f 91       	pop	r25
    41c4:	8f 91       	pop	r24
    41c6:	3f 91       	pop	r19
    41c8:	2f 91       	pop	r18
    41ca:	0f 90       	pop	r0
    41cc:	0b be       	out	0x3b, r0	; 59
    41ce:	0f 90       	pop	r0
    41d0:	08 be       	out	0x38, r0	; 56
    41d2:	0f 90       	pop	r0
    41d4:	0f be       	out	0x3f, r0	; 63
    41d6:	0f 90       	pop	r0
    41d8:	1f 90       	pop	r1
    41da:	18 95       	reti

000041dc <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    41dc:	1f 92       	push	r1
    41de:	0f 92       	push	r0
    41e0:	0f b6       	in	r0, 0x3f	; 63
    41e2:	0f 92       	push	r0
    41e4:	11 24       	eor	r1, r1
    41e6:	08 b6       	in	r0, 0x38	; 56
    41e8:	0f 92       	push	r0
    41ea:	18 be       	out	0x38, r1	; 56
    41ec:	0b b6       	in	r0, 0x3b	; 59
    41ee:	0f 92       	push	r0
    41f0:	1b be       	out	0x3b, r1	; 59
    41f2:	2f 93       	push	r18
    41f4:	3f 93       	push	r19
    41f6:	8f 93       	push	r24
    41f8:	9f 93       	push	r25
    41fa:	ef 93       	push	r30
    41fc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    41fe:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4202:	e0 91 46 32 	lds	r30, 0x3246	; 0x803246 <rcvE0_buffer>
    4206:	f0 91 47 32 	lds	r31, 0x3247	; 0x803247 <rcvE0_buffer+0x1>
    420a:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <rcvE0_write_index>
    420e:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <rcvE0_write_index+0x1>
    4212:	e8 0f       	add	r30, r24
    4214:	f9 1f       	adc	r31, r25
    4216:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4218:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <rcvE0_write_index>
    421c:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <rcvE0_write_index+0x1>
    4220:	01 96       	adiw	r24, 0x01	; 1
    4222:	84 36       	cpi	r24, 0x64	; 100
    4224:	91 05       	cpc	r25, r1
    4226:	60 f4       	brcc	.+24     	; 0x4240 <__vector_58+0x64>
    4228:	80 93 32 32 	sts	0x3232, r24	; 0x803232 <rcvE0_write_index>
    422c:	90 93 33 32 	sts	0x3233, r25	; 0x803233 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4230:	20 91 3c 32 	lds	r18, 0x323C	; 0x80323c <rcvE0_read_index>
    4234:	30 91 3d 32 	lds	r19, 0x323D	; 0x80323d <rcvE0_read_index+0x1>
    4238:	82 17       	cp	r24, r18
    423a:	93 07       	cpc	r25, r19
    423c:	f1 f4       	brne	.+60     	; 0x427a <__vector_58+0x9e>
    423e:	0c c0       	rjmp	.+24     	; 0x4258 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4240:	10 92 32 32 	sts	0x3232, r1	; 0x803232 <rcvE0_write_index>
    4244:	10 92 33 32 	sts	0x3233, r1	; 0x803233 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4248:	80 91 3c 32 	lds	r24, 0x323C	; 0x80323c <rcvE0_read_index>
    424c:	90 91 3d 32 	lds	r25, 0x323D	; 0x80323d <rcvE0_read_index+0x1>
    4250:	18 16       	cp	r1, r24
    4252:	19 06       	cpc	r1, r25
    4254:	91 f4       	brne	.+36     	; 0x427a <__vector_58+0x9e>
    4256:	0e c0       	rjmp	.+28     	; 0x4274 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4258:	01 96       	adiw	r24, 0x01	; 1
    425a:	84 36       	cpi	r24, 0x64	; 100
    425c:	91 05       	cpc	r25, r1
    425e:	28 f4       	brcc	.+10     	; 0x426a <__vector_58+0x8e>
    4260:	80 93 3c 32 	sts	0x323C, r24	; 0x80323c <rcvE0_read_index>
    4264:	90 93 3d 32 	sts	0x323D, r25	; 0x80323d <rcvE0_read_index+0x1>
    4268:	08 c0       	rjmp	.+16     	; 0x427a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    426a:	10 92 3c 32 	sts	0x323C, r1	; 0x80323c <rcvE0_read_index>
    426e:	10 92 3d 32 	sts	0x323D, r1	; 0x80323d <rcvE0_read_index+0x1>
}
    4272:	03 c0       	rjmp	.+6      	; 0x427a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4274:	81 e0       	ldi	r24, 0x01	; 1
    4276:	90 e0       	ldi	r25, 0x00	; 0
    4278:	f3 cf       	rjmp	.-26     	; 0x4260 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    427a:	ff 91       	pop	r31
    427c:	ef 91       	pop	r30
    427e:	9f 91       	pop	r25
    4280:	8f 91       	pop	r24
    4282:	3f 91       	pop	r19
    4284:	2f 91       	pop	r18
    4286:	0f 90       	pop	r0
    4288:	0b be       	out	0x3b, r0	; 59
    428a:	0f 90       	pop	r0
    428c:	08 be       	out	0x38, r0	; 56
    428e:	0f 90       	pop	r0
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	0f 90       	pop	r0
    4294:	1f 90       	pop	r1
    4296:	18 95       	reti

00004298 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4298:	fc 01       	movw	r30, r24
    429a:	84 81       	ldd	r24, Z+4	; 0x04
    429c:	95 81       	ldd	r25, Z+5	; 0x05
    429e:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
		}
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	08 95       	ret

000042a6 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    42a6:	fc 01       	movw	r30, r24
    42a8:	84 81       	ldd	r24, Z+4	; 0x04
    42aa:	95 81       	ldd	r25, Z+5	; 0x05
    42ac:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    42b0:	91 e0       	ldi	r25, 0x01	; 1
    42b2:	81 11       	cpse	r24, r1
    42b4:	01 c0       	rjmp	.+2      	; 0x42b8 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    42b6:	90 e0       	ldi	r25, 0x00	; 0
		}
    42b8:	89 2f       	mov	r24, r25
    42ba:	08 95       	ret

000042bc <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    42bc:	fc 01       	movw	r30, r24
    42be:	84 81       	ldd	r24, Z+4	; 0x04
    42c0:	95 81       	ldd	r25, Z+5	; 0x05
    42c2:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    42c6:	91 e0       	ldi	r25, 0x01	; 1
    42c8:	81 11       	cpse	r24, r1
    42ca:	90 e0       	ldi	r25, 0x00	; 0
		}
    42cc:	89 2f       	mov	r24, r25
    42ce:	08 95       	ret

000042d0 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    42d0:	fc 01       	movw	r30, r24
    42d2:	84 81       	ldd	r24, Z+4	; 0x04
    42d4:	95 81       	ldd	r25, Z+5	; 0x05
    42d6:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
		}
    42da:	90 e0       	ldi	r25, 0x00	; 0
    42dc:	08 95       	ret

000042de <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    42de:	fc 01       	movw	r30, r24
    42e0:	84 81       	ldd	r24, Z+4	; 0x04
    42e2:	95 81       	ldd	r25, Z+5	; 0x05
    42e4:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    42e8:	91 e0       	ldi	r25, 0x01	; 1
    42ea:	81 11       	cpse	r24, r1
    42ec:	01 c0       	rjmp	.+2      	; 0x42f0 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    42ee:	90 e0       	ldi	r25, 0x00	; 0
		}
    42f0:	89 2f       	mov	r24, r25
    42f2:	08 95       	ret

000042f4 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    42f4:	fc 01       	movw	r30, r24
    42f6:	84 81       	ldd	r24, Z+4	; 0x04
    42f8:	95 81       	ldd	r25, Z+5	; 0x05
    42fa:	0e 94 7e 12 	call	0x24fc	; 0x24fc <uxQueueMessagesWaitingFromISR>
    42fe:	91 e0       	ldi	r25, 0x01	; 1
    4300:	81 11       	cpse	r24, r1
    4302:	90 e0       	ldi	r25, 0x00	; 0
		}
    4304:	89 2f       	mov	r24, r25
    4306:	08 95       	ret

00004308 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4308:	fc 01       	movw	r30, r24
    430a:	84 81       	ldd	r24, Z+4	; 0x04
    430c:	95 81       	ldd	r25, Z+5	; 0x05
    430e:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
		}
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	08 95       	ret

00004316 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4316:	fc 01       	movw	r30, r24
    4318:	84 81       	ldd	r24, Z+4	; 0x04
    431a:	95 81       	ldd	r25, Z+5	; 0x05
    431c:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    4320:	91 e0       	ldi	r25, 0x01	; 1
    4322:	81 11       	cpse	r24, r1
    4324:	01 c0       	rjmp	.+2      	; 0x4328 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4326:	90 e0       	ldi	r25, 0x00	; 0
		}
    4328:	89 2f       	mov	r24, r25
    432a:	08 95       	ret

0000432c <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    432c:	fc 01       	movw	r30, r24
    432e:	84 81       	ldd	r24, Z+4	; 0x04
    4330:	95 81       	ldd	r25, Z+5	; 0x05
    4332:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    4336:	91 e0       	ldi	r25, 0x01	; 1
    4338:	81 11       	cpse	r24, r1
    433a:	90 e0       	ldi	r25, 0x00	; 0
		}
    433c:	89 2f       	mov	r24, r25
    433e:	08 95       	ret

00004340 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4340:	fc 01       	movw	r30, r24
    4342:	84 81       	ldd	r24, Z+4	; 0x04
    4344:	95 81       	ldd	r25, Z+5	; 0x05
    4346:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
		}
    434a:	90 e0       	ldi	r25, 0x00	; 0
    434c:	08 95       	ret

0000434e <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    434e:	fc 01       	movw	r30, r24
    4350:	84 81       	ldd	r24, Z+4	; 0x04
    4352:	95 81       	ldd	r25, Z+5	; 0x05
    4354:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    4358:	91 e0       	ldi	r25, 0x01	; 1
    435a:	81 11       	cpse	r24, r1
    435c:	01 c0       	rjmp	.+2      	; 0x4360 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    435e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4360:	89 2f       	mov	r24, r25
    4362:	08 95       	ret

00004364 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4364:	fc 01       	movw	r30, r24
    4366:	84 81       	ldd	r24, Z+4	; 0x04
    4368:	95 81       	ldd	r25, Z+5	; 0x05
    436a:	0e 94 76 12 	call	0x24ec	; 0x24ec <uxQueueMessagesWaiting>
    436e:	91 e0       	ldi	r25, 0x01	; 1
    4370:	81 11       	cpse	r24, r1
    4372:	90 e0       	ldi	r25, 0x00	; 0
		}
    4374:	89 2f       	mov	r24, r25
    4376:	08 95       	ret

00004378 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4378:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    437a:	01 e0       	ldi	r16, 0x01	; 1
    437c:	2f ef       	ldi	r18, 0xFF	; 255
    437e:	3f ef       	ldi	r19, 0xFF	; 255
    4380:	a9 01       	movw	r20, r18
    4382:	fc 01       	movw	r30, r24
    4384:	84 81       	ldd	r24, Z+4	; 0x04
    4386:	95 81       	ldd	r25, Z+5	; 0x05
    4388:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
}
    438c:	0f 91       	pop	r16
    438e:	08 95       	ret

00004390 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4390:	0f 93       	push	r16
    4392:	cf 93       	push	r28
    4394:	df 93       	push	r29
    4396:	1f 92       	push	r1
    4398:	1f 92       	push	r1
    439a:	cd b7       	in	r28, 0x3d	; 61
    439c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    439e:	01 e0       	ldi	r16, 0x01	; 1
    43a0:	2f ef       	ldi	r18, 0xFF	; 255
    43a2:	3f ef       	ldi	r19, 0xFF	; 255
    43a4:	a9 01       	movw	r20, r18
    43a6:	be 01       	movw	r22, r28
    43a8:	6f 5f       	subi	r22, 0xFF	; 255
    43aa:	7f 4f       	sbci	r23, 0xFF	; 255
    43ac:	fc 01       	movw	r30, r24
    43ae:	84 81       	ldd	r24, Z+4	; 0x04
    43b0:	95 81       	ldd	r25, Z+5	; 0x05
    43b2:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
	return (recv_item);
}
    43b6:	89 81       	ldd	r24, Y+1	; 0x01
    43b8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ba:	0f 90       	pop	r0
    43bc:	0f 90       	pop	r0
    43be:	df 91       	pop	r29
    43c0:	cf 91       	pop	r28
    43c2:	0f 91       	pop	r16
    43c4:	08 95       	ret

000043c6 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    43c6:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    43c8:	00 e0       	ldi	r16, 0x00	; 0
    43ca:	2f ef       	ldi	r18, 0xFF	; 255
    43cc:	3f ef       	ldi	r19, 0xFF	; 255
    43ce:	a9 01       	movw	r20, r18
    43d0:	fc 01       	movw	r30, r24
    43d2:	84 81       	ldd	r24, Z+4	; 0x04
    43d4:	95 81       	ldd	r25, Z+5	; 0x05
    43d6:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
}
    43da:	0f 91       	pop	r16
    43dc:	08 95       	ret

000043de <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    43de:	0f 93       	push	r16
    43e0:	cf 93       	push	r28
    43e2:	df 93       	push	r29
    43e4:	1f 92       	push	r1
    43e6:	1f 92       	push	r1
    43e8:	cd b7       	in	r28, 0x3d	; 61
    43ea:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    43ec:	00 e0       	ldi	r16, 0x00	; 0
    43ee:	2f ef       	ldi	r18, 0xFF	; 255
    43f0:	3f ef       	ldi	r19, 0xFF	; 255
    43f2:	a9 01       	movw	r20, r18
    43f4:	be 01       	movw	r22, r28
    43f6:	6f 5f       	subi	r22, 0xFF	; 255
    43f8:	7f 4f       	sbci	r23, 0xFF	; 255
    43fa:	fc 01       	movw	r30, r24
    43fc:	84 81       	ldd	r24, Z+4	; 0x04
    43fe:	95 81       	ldd	r25, Z+5	; 0x05
    4400:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
	return (recv_item);
}
    4404:	89 81       	ldd	r24, Y+1	; 0x01
    4406:	9a 81       	ldd	r25, Y+2	; 0x02
    4408:	0f 90       	pop	r0
    440a:	0f 90       	pop	r0
    440c:	df 91       	pop	r29
    440e:	cf 91       	pop	r28
    4410:	0f 91       	pop	r16
    4412:	08 95       	ret

00004414 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4414:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4416:	01 e0       	ldi	r16, 0x01	; 1
    4418:	2f ef       	ldi	r18, 0xFF	; 255
    441a:	3f ef       	ldi	r19, 0xFF	; 255
    441c:	a9 01       	movw	r20, r18
    441e:	fc 01       	movw	r30, r24
    4420:	84 81       	ldd	r24, Z+4	; 0x04
    4422:	95 81       	ldd	r25, Z+5	; 0x05
    4424:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
}
    4428:	0f 91       	pop	r16
    442a:	08 95       	ret

0000442c <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    442c:	0f 93       	push	r16
    442e:	cf 93       	push	r28
    4430:	df 93       	push	r29
    4432:	1f 92       	push	r1
    4434:	1f 92       	push	r1
    4436:	cd b7       	in	r28, 0x3d	; 61
    4438:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    443a:	01 e0       	ldi	r16, 0x01	; 1
    443c:	2f ef       	ldi	r18, 0xFF	; 255
    443e:	3f ef       	ldi	r19, 0xFF	; 255
    4440:	a9 01       	movw	r20, r18
    4442:	be 01       	movw	r22, r28
    4444:	6f 5f       	subi	r22, 0xFF	; 255
    4446:	7f 4f       	sbci	r23, 0xFF	; 255
    4448:	fc 01       	movw	r30, r24
    444a:	84 81       	ldd	r24, Z+4	; 0x04
    444c:	95 81       	ldd	r25, Z+5	; 0x05
    444e:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
	return (recv_item);
}
    4452:	89 81       	ldd	r24, Y+1	; 0x01
    4454:	9a 81       	ldd	r25, Y+2	; 0x02
    4456:	0f 90       	pop	r0
    4458:	0f 90       	pop	r0
    445a:	df 91       	pop	r29
    445c:	cf 91       	pop	r28
    445e:	0f 91       	pop	r16
    4460:	08 95       	ret

00004462 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4462:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4464:	00 e0       	ldi	r16, 0x00	; 0
    4466:	2f ef       	ldi	r18, 0xFF	; 255
    4468:	3f ef       	ldi	r19, 0xFF	; 255
    446a:	a9 01       	movw	r20, r18
    446c:	fc 01       	movw	r30, r24
    446e:	84 81       	ldd	r24, Z+4	; 0x04
    4470:	95 81       	ldd	r25, Z+5	; 0x05
    4472:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
}
    4476:	0f 91       	pop	r16
    4478:	08 95       	ret

0000447a <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    447a:	0f 93       	push	r16
    447c:	cf 93       	push	r28
    447e:	df 93       	push	r29
    4480:	1f 92       	push	r1
    4482:	1f 92       	push	r1
    4484:	cd b7       	in	r28, 0x3d	; 61
    4486:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4488:	00 e0       	ldi	r16, 0x00	; 0
    448a:	2f ef       	ldi	r18, 0xFF	; 255
    448c:	3f ef       	ldi	r19, 0xFF	; 255
    448e:	a9 01       	movw	r20, r18
    4490:	be 01       	movw	r22, r28
    4492:	6f 5f       	subi	r22, 0xFF	; 255
    4494:	7f 4f       	sbci	r23, 0xFF	; 255
    4496:	fc 01       	movw	r30, r24
    4498:	84 81       	ldd	r24, Z+4	; 0x04
    449a:	95 81       	ldd	r25, Z+5	; 0x05
    449c:	0e 94 85 11 	call	0x230a	; 0x230a <xQueueGenericReceive>
	return (recv_item);
}
    44a0:	89 81       	ldd	r24, Y+1	; 0x01
    44a2:	9a 81       	ldd	r25, Y+2	; 0x02
    44a4:	0f 90       	pop	r0
    44a6:	0f 90       	pop	r0
    44a8:	df 91       	pop	r29
    44aa:	cf 91       	pop	r28
    44ac:	0f 91       	pop	r16
    44ae:	08 95       	ret

000044b0 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    44b0:	cf 93       	push	r28
    44b2:	df 93       	push	r29
    44b4:	1f 92       	push	r1
    44b6:	cd b7       	in	r28, 0x3d	; 61
    44b8:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    44ba:	ae 01       	movw	r20, r28
    44bc:	4f 5f       	subi	r20, 0xFF	; 255
    44be:	5f 4f       	sbci	r21, 0xFF	; 255
    44c0:	fc 01       	movw	r30, r24
    44c2:	84 81       	ldd	r24, Z+4	; 0x04
    44c4:	95 81       	ldd	r25, Z+5	; 0x05
    44c6:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
}
    44ca:	0f 90       	pop	r0
    44cc:	df 91       	pop	r29
    44ce:	cf 91       	pop	r28
    44d0:	08 95       	ret

000044d2 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    44d2:	cf 93       	push	r28
    44d4:	df 93       	push	r29
    44d6:	00 d0       	rcall	.+0      	; 0x44d8 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    44d8:	cd b7       	in	r28, 0x3d	; 61
    44da:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    44dc:	ae 01       	movw	r20, r28
    44de:	4d 5f       	subi	r20, 0xFD	; 253
    44e0:	5f 4f       	sbci	r21, 0xFF	; 255
    44e2:	be 01       	movw	r22, r28
    44e4:	6f 5f       	subi	r22, 0xFF	; 255
    44e6:	7f 4f       	sbci	r23, 0xFF	; 255
    44e8:	fc 01       	movw	r30, r24
    44ea:	84 81       	ldd	r24, Z+4	; 0x04
    44ec:	95 81       	ldd	r25, Z+5	; 0x05
    44ee:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
	return (recv_item);
}
    44f2:	89 81       	ldd	r24, Y+1	; 0x01
    44f4:	9a 81       	ldd	r25, Y+2	; 0x02
    44f6:	23 96       	adiw	r28, 0x03	; 3
    44f8:	cd bf       	out	0x3d, r28	; 61
    44fa:	de bf       	out	0x3e, r29	; 62
    44fc:	df 91       	pop	r29
    44fe:	cf 91       	pop	r28
    4500:	08 95       	ret

00004502 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4502:	cf 93       	push	r28
    4504:	df 93       	push	r29
    4506:	1f 92       	push	r1
    4508:	cd b7       	in	r28, 0x3d	; 61
    450a:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    450c:	ae 01       	movw	r20, r28
    450e:	4f 5f       	subi	r20, 0xFF	; 255
    4510:	5f 4f       	sbci	r21, 0xFF	; 255
    4512:	fc 01       	movw	r30, r24
    4514:	84 81       	ldd	r24, Z+4	; 0x04
    4516:	95 81       	ldd	r25, Z+5	; 0x05
    4518:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
}
    451c:	0f 90       	pop	r0
    451e:	df 91       	pop	r29
    4520:	cf 91       	pop	r28
    4522:	08 95       	ret

00004524 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4524:	cf 93       	push	r28
    4526:	df 93       	push	r29
    4528:	00 d0       	rcall	.+0      	; 0x452a <_ZN9frt_queueIiE7ISR_getEv+0x6>
    452a:	cd b7       	in	r28, 0x3d	; 61
    452c:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    452e:	ae 01       	movw	r20, r28
    4530:	4d 5f       	subi	r20, 0xFD	; 253
    4532:	5f 4f       	sbci	r21, 0xFF	; 255
    4534:	be 01       	movw	r22, r28
    4536:	6f 5f       	subi	r22, 0xFF	; 255
    4538:	7f 4f       	sbci	r23, 0xFF	; 255
    453a:	fc 01       	movw	r30, r24
    453c:	84 81       	ldd	r24, Z+4	; 0x04
    453e:	95 81       	ldd	r25, Z+5	; 0x05
    4540:	0e 94 49 12 	call	0x2492	; 0x2492 <xQueueReceiveFromISR>
	return (recv_item);
}
    4544:	89 81       	ldd	r24, Y+1	; 0x01
    4546:	9a 81       	ldd	r25, Y+2	; 0x02
    4548:	23 96       	adiw	r28, 0x03	; 3
    454a:	cd bf       	out	0x3d, r28	; 61
    454c:	de bf       	out	0x3e, r29	; 62
    454e:	df 91       	pop	r29
    4550:	cf 91       	pop	r28
    4552:	08 95       	ret

00004554 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4554:	cf 93       	push	r28
    4556:	df 93       	push	r29
    4558:	1f 92       	push	r1
    455a:	cd b7       	in	r28, 0x3d	; 61
    455c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    455e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4560:	21 e0       	ldi	r18, 0x01	; 1
    4562:	ae 01       	movw	r20, r28
    4564:	4f 5f       	subi	r20, 0xFF	; 255
    4566:	5f 4f       	sbci	r21, 0xFF	; 255
    4568:	fc 01       	movw	r30, r24
    456a:	84 81       	ldd	r24, Z+4	; 0x04
    456c:	95 81       	ldd	r25, Z+5	; 0x05
    456e:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4572:	91 e0       	ldi	r25, 0x01	; 1
    4574:	81 11       	cpse	r24, r1
    4576:	01 c0       	rjmp	.+2      	; 0x457a <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4578:	90 e0       	ldi	r25, 0x00	; 0
}
    457a:	89 2f       	mov	r24, r25
    457c:	0f 90       	pop	r0
    457e:	df 91       	pop	r29
    4580:	cf 91       	pop	r28
    4582:	08 95       	ret

00004584 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4584:	cf 93       	push	r28
    4586:	df 93       	push	r29
    4588:	1f 92       	push	r1
    458a:	cd b7       	in	r28, 0x3d	; 61
    458c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    458e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4590:	20 e0       	ldi	r18, 0x00	; 0
    4592:	ae 01       	movw	r20, r28
    4594:	4f 5f       	subi	r20, 0xFF	; 255
    4596:	5f 4f       	sbci	r21, 0xFF	; 255
    4598:	fc 01       	movw	r30, r24
    459a:	84 81       	ldd	r24, Z+4	; 0x04
    459c:	95 81       	ldd	r25, Z+5	; 0x05
    459e:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    45a2:	91 e0       	ldi	r25, 0x01	; 1
    45a4:	81 11       	cpse	r24, r1
    45a6:	01 c0       	rjmp	.+2      	; 0x45aa <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    45a8:	90 e0       	ldi	r25, 0x00	; 0
}
    45aa:	89 2f       	mov	r24, r25
    45ac:	0f 90       	pop	r0
    45ae:	df 91       	pop	r29
    45b0:	cf 91       	pop	r28
    45b2:	08 95       	ret

000045b4 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    45b4:	cf 93       	push	r28
    45b6:	df 93       	push	r29
    45b8:	1f 92       	push	r1
    45ba:	cd b7       	in	r28, 0x3d	; 61
    45bc:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    45be:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    45c0:	21 e0       	ldi	r18, 0x01	; 1
    45c2:	ae 01       	movw	r20, r28
    45c4:	4f 5f       	subi	r20, 0xFF	; 255
    45c6:	5f 4f       	sbci	r21, 0xFF	; 255
    45c8:	fc 01       	movw	r30, r24
    45ca:	84 81       	ldd	r24, Z+4	; 0x04
    45cc:	95 81       	ldd	r25, Z+5	; 0x05
    45ce:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    45d2:	91 e0       	ldi	r25, 0x01	; 1
    45d4:	81 11       	cpse	r24, r1
    45d6:	01 c0       	rjmp	.+2      	; 0x45da <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    45d8:	90 e0       	ldi	r25, 0x00	; 0
}
    45da:	89 2f       	mov	r24, r25
    45dc:	0f 90       	pop	r0
    45de:	df 91       	pop	r29
    45e0:	cf 91       	pop	r28
    45e2:	08 95       	ret

000045e4 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    45e4:	cf 93       	push	r28
    45e6:	df 93       	push	r29
    45e8:	1f 92       	push	r1
    45ea:	cd b7       	in	r28, 0x3d	; 61
    45ec:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    45ee:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    45f0:	20 e0       	ldi	r18, 0x00	; 0
    45f2:	ae 01       	movw	r20, r28
    45f4:	4f 5f       	subi	r20, 0xFF	; 255
    45f6:	5f 4f       	sbci	r21, 0xFF	; 255
    45f8:	fc 01       	movw	r30, r24
    45fa:	84 81       	ldd	r24, Z+4	; 0x04
    45fc:	95 81       	ldd	r25, Z+5	; 0x05
    45fe:	0e 94 59 11 	call	0x22b2	; 0x22b2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4602:	91 e0       	ldi	r25, 0x01	; 1
    4604:	81 11       	cpse	r24, r1
    4606:	01 c0       	rjmp	.+2      	; 0x460a <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4608:	90 e0       	ldi	r25, 0x00	; 0
}
    460a:	89 2f       	mov	r24, r25
    460c:	0f 90       	pop	r0
    460e:	df 91       	pop	r29
    4610:	cf 91       	pop	r28
    4612:	08 95       	ret

00004614 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4614:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4616:	fc 01       	movw	r30, r24
    4618:	26 81       	ldd	r18, Z+6	; 0x06
    461a:	37 81       	ldd	r19, Z+7	; 0x07
    461c:	40 85       	ldd	r20, Z+8	; 0x08
    461e:	51 85       	ldd	r21, Z+9	; 0x09
    4620:	01 e0       	ldi	r16, 0x01	; 1
    4622:	84 81       	ldd	r24, Z+4	; 0x04
    4624:	95 81       	ldd	r25, Z+5	; 0x05
    4626:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    462a:	91 e0       	ldi	r25, 0x01	; 1
    462c:	81 11       	cpse	r24, r1
    462e:	01 c0       	rjmp	.+2      	; 0x4632 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4630:	90 e0       	ldi	r25, 0x00	; 0
		}
    4632:	89 2f       	mov	r24, r25
    4634:	0f 91       	pop	r16
    4636:	08 95       	ret

00004638 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4638:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    463a:	fc 01       	movw	r30, r24
    463c:	26 81       	ldd	r18, Z+6	; 0x06
    463e:	37 81       	ldd	r19, Z+7	; 0x07
    4640:	40 85       	ldd	r20, Z+8	; 0x08
    4642:	51 85       	ldd	r21, Z+9	; 0x09
    4644:	00 e0       	ldi	r16, 0x00	; 0
    4646:	84 81       	ldd	r24, Z+4	; 0x04
    4648:	95 81       	ldd	r25, Z+5	; 0x05
    464a:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    464e:	91 e0       	ldi	r25, 0x01	; 1
    4650:	81 11       	cpse	r24, r1
    4652:	01 c0       	rjmp	.+2      	; 0x4656 <_ZN9frt_queueIjE3putERKj+0x1e>
    4654:	90 e0       	ldi	r25, 0x00	; 0
		}
    4656:	89 2f       	mov	r24, r25
    4658:	0f 91       	pop	r16
    465a:	08 95       	ret

0000465c <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    465c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    465e:	fc 01       	movw	r30, r24
    4660:	26 81       	ldd	r18, Z+6	; 0x06
    4662:	37 81       	ldd	r19, Z+7	; 0x07
    4664:	40 85       	ldd	r20, Z+8	; 0x08
    4666:	51 85       	ldd	r21, Z+9	; 0x09
    4668:	01 e0       	ldi	r16, 0x01	; 1
    466a:	84 81       	ldd	r24, Z+4	; 0x04
    466c:	95 81       	ldd	r25, Z+5	; 0x05
    466e:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    4672:	91 e0       	ldi	r25, 0x01	; 1
    4674:	81 11       	cpse	r24, r1
    4676:	01 c0       	rjmp	.+2      	; 0x467a <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4678:	90 e0       	ldi	r25, 0x00	; 0
		}
    467a:	89 2f       	mov	r24, r25
    467c:	0f 91       	pop	r16
    467e:	08 95       	ret

00004680 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4680:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4682:	fc 01       	movw	r30, r24
    4684:	26 81       	ldd	r18, Z+6	; 0x06
    4686:	37 81       	ldd	r19, Z+7	; 0x07
    4688:	40 85       	ldd	r20, Z+8	; 0x08
    468a:	51 85       	ldd	r21, Z+9	; 0x09
    468c:	00 e0       	ldi	r16, 0x00	; 0
    468e:	84 81       	ldd	r24, Z+4	; 0x04
    4690:	95 81       	ldd	r25, Z+5	; 0x05
    4692:	0e 94 be 10 	call	0x217c	; 0x217c <xQueueGenericSend>
    4696:	91 e0       	ldi	r25, 0x01	; 1
    4698:	81 11       	cpse	r24, r1
    469a:	01 c0       	rjmp	.+2      	; 0x469e <_ZN9frt_queueIiE3putERKi+0x1e>
    469c:	90 e0       	ldi	r25, 0x00	; 0
		}
    469e:	89 2f       	mov	r24, r25
    46a0:	0f 91       	pop	r16
    46a2:	08 95       	ret

000046a4 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    46a4:	0f 93       	push	r16
    46a6:	cf 93       	push	r28
    46a8:	df 93       	push	r29
    46aa:	1f 92       	push	r1
    46ac:	cd b7       	in	r28, 0x3d	; 61
    46ae:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    46b0:	2f b7       	in	r18, 0x3f	; 63
    46b2:	29 83       	std	Y+1, r18	; 0x01
	cli();
    46b4:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    46b6:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    46b8:	fc 01       	movw	r30, r24
    46ba:	08 ed       	ldi	r16, 0xD8	; 216
    46bc:	04 bf       	out	0x34, r16	; 52
    46be:	60 83       	st	Z, r22

	SREG = saved_sreg;
    46c0:	89 81       	ldd	r24, Y+1	; 0x01
    46c2:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    46c4:	0f 90       	pop	r0
    46c6:	df 91       	pop	r29
    46c8:	cf 91       	pop	r28
    46ca:	0f 91       	pop	r16
    46cc:	08 95       	ret

000046ce <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    46ce:	ef 92       	push	r14
    46d0:	ff 92       	push	r15
    46d2:	0f 93       	push	r16
    46d4:	1f 93       	push	r17
    46d6:	cf 93       	push	r28
    46d8:	df 93       	push	r29
    46da:	cd b7       	in	r28, 0x3d	; 61
    46dc:	de b7       	in	r29, 0x3e	; 62
    46de:	c5 54       	subi	r28, 0x45	; 69
    46e0:	d1 09       	sbc	r29, r1
    46e2:	cd bf       	out	0x3d, r28	; 61
    46e4:	de bf       	out	0x3e, r29	; 62
	cli();
    46e6:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    46e8:	e0 e5       	ldi	r30, 0x50	; 80
    46ea:	f0 e0       	ldi	r31, 0x00	; 0
    46ec:	80 81       	ld	r24, Z
    46ee:	82 60       	ori	r24, 0x02	; 2
    46f0:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    46f2:	81 81       	ldd	r24, Z+1	; 0x01
    46f4:	81 ff       	sbrs	r24, 1
    46f6:	fd cf       	rjmp	.-6      	; 0x46f2 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    46f8:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    46fc:	68 7f       	andi	r22, 0xF8	; 248
    46fe:	61 60       	ori	r22, 0x01	; 1
    4700:	80 e4       	ldi	r24, 0x40	; 64
    4702:	90 e0       	ldi	r25, 0x00	; 0
    4704:	0e 94 52 23 	call	0x46a4	; 0x46a4 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4708:	e0 e5       	ldi	r30, 0x50	; 80
    470a:	f0 e0       	ldi	r31, 0x00	; 0
    470c:	80 81       	ld	r24, Z
    470e:	8e 7f       	andi	r24, 0xFE	; 254
    4710:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4712:	9d ef       	ldi	r25, 0xFD	; 253
    4714:	88 ed       	ldi	r24, 0xD8	; 216
    4716:	08 b6       	in	r0, 0x38	; 56
    4718:	18 be       	out	0x38, r1	; 56
    471a:	84 bf       	out	0x34, r24	; 52
    471c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4720:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4722:	40 ea       	ldi	r20, 0xA0	; 160
    4724:	5a e0       	ldi	r21, 0x0A	; 10
    4726:	60 e0       	ldi	r22, 0x00	; 0
    4728:	70 e0       	ldi	r23, 0x00	; 0
    472a:	ce 01       	movw	r24, r28
    472c:	01 96       	adiw	r24, 0x01	; 1
    472e:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4732:	67 e0       	ldi	r22, 0x07	; 7
    4734:	ce 01       	movw	r24, r28
    4736:	01 96       	adiw	r24, 0x01	; 1
    4738:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    473c:	8c 01       	movw	r16, r24
    473e:	60 e5       	ldi	r22, 0x50	; 80
    4740:	71 e2       	ldi	r23, 0x21	; 33
    4742:	0e 94 1c 1d 	call	0x3a38	; 0x3a38 <_ZN8emstream4putsEPKc>
    4746:	66 e0       	ldi	r22, 0x06	; 6
    4748:	c8 01       	movw	r24, r16
    474a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
    474e:	66 e0       	ldi	r22, 0x06	; 6
    4750:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    4754:	20 e3       	ldi	r18, 0x30	; 48
    4756:	32 ef       	ldi	r19, 0xF2	; 242
    4758:	40 e0       	ldi	r20, 0x00	; 0
    475a:	50 e0       	ldi	r21, 0x00	; 0
    475c:	60 ea       	ldi	r22, 0xA0	; 160
    475e:	74 e0       	ldi	r23, 0x04	; 4
    4760:	ce 01       	movw	r24, r28
    4762:	4e 96       	adiw	r24, 0x1e	; 30
    4764:	0e 94 a2 07 	call	0xf44	; 0xf44 <_ZN9I2CMasterC1EP10TWI_structm>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c);
    4768:	be 01       	movw	r22, r28
    476a:	62 5e       	subi	r22, 0xE2	; 226
    476c:	7f 4f       	sbci	r23, 0xFF	; 255
    476e:	ce 01       	movw	r24, r28
    4770:	c7 96       	adiw	r24, 0x37	; 55
    4772:	0e 94 08 09 	call	0x1210	; 0x1210 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4776:	82 e1       	ldi	r24, 0x12	; 18
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
    477e:	8e 01       	movw	r16, r28
    4780:	0f 5f       	subi	r16, 0xFF	; 255
    4782:	1f 4f       	sbci	r17, 0xFF	; 255
    4784:	20 e8       	ldi	r18, 0x80	; 128
    4786:	30 e0       	ldi	r19, 0x00	; 0
    4788:	40 e0       	ldi	r20, 0x00	; 0
    478a:	6f e6       	ldi	r22, 0x6F	; 111
    478c:	71 e2       	ldi	r23, 0x21	; 33
    478e:	0e 94 3a 0a 	call	0x1474	; 0x1474 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    4792:	88 e1       	ldi	r24, 0x18	; 24
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_Znwj>
    479a:	9e 01       	movw	r18, r28
    479c:	29 5c       	subi	r18, 0xC9	; 201
    479e:	3f 4f       	sbci	r19, 0xFF	; 255
    47a0:	79 01       	movw	r14, r18
    47a2:	20 e8       	ldi	r18, 0x80	; 128
    47a4:	30 e0       	ldi	r19, 0x00	; 0
    47a6:	42 e0       	ldi	r20, 0x02	; 2
    47a8:	67 e7       	ldi	r22, 0x77	; 119
    47aa:	71 e2       	ldi	r23, 0x21	; 33
    47ac:	0e 94 1d 0a 	call	0x143a	; 0x143a <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    47b0:	87 e0       	ldi	r24, 0x07	; 7
    47b2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    47b6:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    47b8:	0e 94 e7 13 	call	0x27ce	; 0x27ce <vTaskStartScheduler>
}
    47bc:	80 e0       	ldi	r24, 0x00	; 0
    47be:	90 e0       	ldi	r25, 0x00	; 0
    47c0:	cb 5b       	subi	r28, 0xBB	; 187
    47c2:	df 4f       	sbci	r29, 0xFF	; 255
    47c4:	cd bf       	out	0x3d, r28	; 61
    47c6:	de bf       	out	0x3e, r29	; 62
    47c8:	df 91       	pop	r29
    47ca:	cf 91       	pop	r28
    47cc:	1f 91       	pop	r17
    47ce:	0f 91       	pop	r16
    47d0:	ff 90       	pop	r15
    47d2:	ef 90       	pop	r14
    47d4:	08 95       	ret

000047d6 <_GLOBAL__sub_I_counter>:
    47d6:	cf 92       	push	r12
    47d8:	df 92       	push	r13
    47da:	ef 92       	push	r14
    47dc:	ff 92       	push	r15
    47de:	0f 93       	push	r16
    47e0:	1f 93       	push	r17
    47e2:	cf 93       	push	r28
    47e4:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    47e6:	0a e0       	ldi	r16, 0x0A	; 10
    47e8:	10 e0       	ldi	r17, 0x00	; 0
    47ea:	20 e0       	ldi	r18, 0x00	; 0
    47ec:	30 e0       	ldi	r19, 0x00	; 0
    47ee:	40 e0       	ldi	r20, 0x00	; 0
    47f0:	50 e0       	ldi	r21, 0x00	; 0
    47f2:	60 e2       	ldi	r22, 0x20	; 32
    47f4:	70 e0       	ldi	r23, 0x00	; 0
    47f6:	82 e8       	ldi	r24, 0x82	; 130
    47f8:	92 e3       	ldi	r25, 0x32	; 50
    47fa:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    47fe:	c8 e7       	ldi	r28, 0x78	; 120
    4800:	d2 e3       	ldi	r29, 0x32	; 50
    4802:	1a 82       	std	Y+2, r1	; 0x02
    4804:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4806:	81 e8       	ldi	r24, 0x81	; 129
    4808:	91 e2       	ldi	r25, 0x21	; 33
    480a:	88 83       	st	Y, r24
    480c:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    480e:	40 e0       	ldi	r20, 0x00	; 0
    4810:	62 e0       	ldi	r22, 0x02	; 2
    4812:	8f ef       	ldi	r24, 0xFF	; 255
    4814:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    4818:	8c 83       	std	Y+4, r24	; 0x04
    481a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    481c:	0f 2e       	mov	r0, r31
    481e:	fa e0       	ldi	r31, 0x0A	; 10
    4820:	cf 2e       	mov	r12, r31
    4822:	d1 2c       	mov	r13, r1
    4824:	e1 2c       	mov	r14, r1
    4826:	f1 2c       	mov	r15, r1
    4828:	f0 2d       	mov	r31, r0
    482a:	ce 82       	std	Y+6, r12	; 0x06
    482c:	df 82       	std	Y+7, r13	; 0x07
    482e:	e8 86       	std	Y+8, r14	; 0x08
    4830:	f9 86       	std	Y+9, r15	; 0x09
    4832:	ce e6       	ldi	r28, 0x6E	; 110
    4834:	d2 e3       	ldi	r29, 0x32	; 50
    4836:	1a 82       	std	Y+2, r1	; 0x02
    4838:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    483a:	05 ea       	ldi	r16, 0xA5	; 165
    483c:	11 e2       	ldi	r17, 0x21	; 33
    483e:	08 83       	st	Y, r16
    4840:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4842:	40 e0       	ldi	r20, 0x00	; 0
    4844:	62 e0       	ldi	r22, 0x02	; 2
    4846:	8f ef       	ldi	r24, 0xFF	; 255
    4848:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    484c:	8c 83       	std	Y+4, r24	; 0x04
    484e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4850:	ce 82       	std	Y+6, r12	; 0x06
    4852:	df 82       	std	Y+7, r13	; 0x07
    4854:	e8 86       	std	Y+8, r14	; 0x08
    4856:	f9 86       	std	Y+9, r15	; 0x09
    4858:	c4 e6       	ldi	r28, 0x64	; 100
    485a:	d2 e3       	ldi	r29, 0x32	; 50
    485c:	1a 82       	std	Y+2, r1	; 0x02
    485e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4860:	08 83       	st	Y, r16
    4862:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4864:	40 e0       	ldi	r20, 0x00	; 0
    4866:	62 e0       	ldi	r22, 0x02	; 2
    4868:	8f ef       	ldi	r24, 0xFF	; 255
    486a:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    486e:	8c 83       	std	Y+4, r24	; 0x04
    4870:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4872:	ce 82       	std	Y+6, r12	; 0x06
    4874:	df 82       	std	Y+7, r13	; 0x07
    4876:	e8 86       	std	Y+8, r14	; 0x08
    4878:	f9 86       	std	Y+9, r15	; 0x09
    487a:	ca e5       	ldi	r28, 0x5A	; 90
    487c:	d2 e3       	ldi	r29, 0x32	; 50
    487e:	1a 82       	std	Y+2, r1	; 0x02
    4880:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4882:	08 83       	st	Y, r16
    4884:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4886:	40 e0       	ldi	r20, 0x00	; 0
    4888:	62 e0       	ldi	r22, 0x02	; 2
    488a:	8f ef       	ldi	r24, 0xFF	; 255
    488c:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    4890:	8c 83       	std	Y+4, r24	; 0x04
    4892:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4894:	ce 82       	std	Y+6, r12	; 0x06
    4896:	df 82       	std	Y+7, r13	; 0x07
    4898:	e8 86       	std	Y+8, r14	; 0x08
    489a:	f9 86       	std	Y+9, r15	; 0x09
    489c:	c0 e5       	ldi	r28, 0x50	; 80
    489e:	d2 e3       	ldi	r29, 0x32	; 50
    48a0:	1a 82       	std	Y+2, r1	; 0x02
    48a2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    48a4:	08 83       	st	Y, r16
    48a6:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    48a8:	40 e0       	ldi	r20, 0x00	; 0
    48aa:	62 e0       	ldi	r22, 0x02	; 2
    48ac:	8f ef       	ldi	r24, 0xFF	; 255
    48ae:	0e 94 90 10 	call	0x2120	; 0x2120 <xQueueGenericCreate>
    48b2:	8c 83       	std	Y+4, r24	; 0x04
    48b4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    48b6:	ce 82       	std	Y+6, r12	; 0x06
    48b8:	df 82       	std	Y+7, r13	; 0x07
    48ba:	e8 86       	std	Y+8, r14	; 0x08
    48bc:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    48be:	df 91       	pop	r29
    48c0:	cf 91       	pop	r28
    48c2:	1f 91       	pop	r17
    48c4:	0f 91       	pop	r16
    48c6:	ff 90       	pop	r15
    48c8:	ef 90       	pop	r14
    48ca:	df 90       	pop	r13
    48cc:	cf 90       	pop	r12
    48ce:	08 95       	ret

000048d0 <__mulsi3>:
    48d0:	db 01       	movw	r26, r22
    48d2:	8f 93       	push	r24
    48d4:	9f 93       	push	r25
    48d6:	0e 94 c2 24 	call	0x4984	; 0x4984 <__muluhisi3>
    48da:	bf 91       	pop	r27
    48dc:	af 91       	pop	r26
    48de:	a2 9f       	mul	r26, r18
    48e0:	80 0d       	add	r24, r0
    48e2:	91 1d       	adc	r25, r1
    48e4:	a3 9f       	mul	r26, r19
    48e6:	90 0d       	add	r25, r0
    48e8:	b2 9f       	mul	r27, r18
    48ea:	90 0d       	add	r25, r0
    48ec:	11 24       	eor	r1, r1
    48ee:	08 95       	ret

000048f0 <__udivmodsi4>:
    48f0:	a1 e2       	ldi	r26, 0x21	; 33
    48f2:	1a 2e       	mov	r1, r26
    48f4:	aa 1b       	sub	r26, r26
    48f6:	bb 1b       	sub	r27, r27
    48f8:	fd 01       	movw	r30, r26
    48fa:	0d c0       	rjmp	.+26     	; 0x4916 <__udivmodsi4_ep>

000048fc <__udivmodsi4_loop>:
    48fc:	aa 1f       	adc	r26, r26
    48fe:	bb 1f       	adc	r27, r27
    4900:	ee 1f       	adc	r30, r30
    4902:	ff 1f       	adc	r31, r31
    4904:	a2 17       	cp	r26, r18
    4906:	b3 07       	cpc	r27, r19
    4908:	e4 07       	cpc	r30, r20
    490a:	f5 07       	cpc	r31, r21
    490c:	20 f0       	brcs	.+8      	; 0x4916 <__udivmodsi4_ep>
    490e:	a2 1b       	sub	r26, r18
    4910:	b3 0b       	sbc	r27, r19
    4912:	e4 0b       	sbc	r30, r20
    4914:	f5 0b       	sbc	r31, r21

00004916 <__udivmodsi4_ep>:
    4916:	66 1f       	adc	r22, r22
    4918:	77 1f       	adc	r23, r23
    491a:	88 1f       	adc	r24, r24
    491c:	99 1f       	adc	r25, r25
    491e:	1a 94       	dec	r1
    4920:	69 f7       	brne	.-38     	; 0x48fc <__udivmodsi4_loop>
    4922:	60 95       	com	r22
    4924:	70 95       	com	r23
    4926:	80 95       	com	r24
    4928:	90 95       	com	r25
    492a:	9b 01       	movw	r18, r22
    492c:	ac 01       	movw	r20, r24
    492e:	bd 01       	movw	r22, r26
    4930:	cf 01       	movw	r24, r30
    4932:	08 95       	ret

00004934 <__divmodsi4>:
    4934:	05 2e       	mov	r0, r21
    4936:	97 fb       	bst	r25, 7
    4938:	1e f4       	brtc	.+6      	; 0x4940 <__divmodsi4+0xc>
    493a:	00 94       	com	r0
    493c:	0e 94 b1 24 	call	0x4962	; 0x4962 <__negsi2>
    4940:	57 fd       	sbrc	r21, 7
    4942:	07 d0       	rcall	.+14     	; 0x4952 <__divmodsi4_neg2>
    4944:	0e 94 78 24 	call	0x48f0	; 0x48f0 <__udivmodsi4>
    4948:	07 fc       	sbrc	r0, 7
    494a:	03 d0       	rcall	.+6      	; 0x4952 <__divmodsi4_neg2>
    494c:	4e f4       	brtc	.+18     	; 0x4960 <__divmodsi4_exit>
    494e:	0c 94 b1 24 	jmp	0x4962	; 0x4962 <__negsi2>

00004952 <__divmodsi4_neg2>:
    4952:	50 95       	com	r21
    4954:	40 95       	com	r20
    4956:	30 95       	com	r19
    4958:	21 95       	neg	r18
    495a:	3f 4f       	sbci	r19, 0xFF	; 255
    495c:	4f 4f       	sbci	r20, 0xFF	; 255
    495e:	5f 4f       	sbci	r21, 0xFF	; 255

00004960 <__divmodsi4_exit>:
    4960:	08 95       	ret

00004962 <__negsi2>:
    4962:	90 95       	com	r25
    4964:	80 95       	com	r24
    4966:	70 95       	com	r23
    4968:	61 95       	neg	r22
    496a:	7f 4f       	sbci	r23, 0xFF	; 255
    496c:	8f 4f       	sbci	r24, 0xFF	; 255
    496e:	9f 4f       	sbci	r25, 0xFF	; 255
    4970:	08 95       	ret

00004972 <__tablejump2__>:
    4972:	ee 0f       	add	r30, r30
    4974:	ff 1f       	adc	r31, r31
    4976:	88 1f       	adc	r24, r24
    4978:	8b bf       	out	0x3b, r24	; 59
    497a:	07 90       	elpm	r0, Z+
    497c:	f6 91       	elpm	r31, Z
    497e:	e0 2d       	mov	r30, r0
    4980:	1b be       	out	0x3b, r1	; 59
    4982:	19 94       	eijmp

00004984 <__muluhisi3>:
    4984:	0e 94 cd 24 	call	0x499a	; 0x499a <__umulhisi3>
    4988:	a5 9f       	mul	r26, r21
    498a:	90 0d       	add	r25, r0
    498c:	b4 9f       	mul	r27, r20
    498e:	90 0d       	add	r25, r0
    4990:	a4 9f       	mul	r26, r20
    4992:	80 0d       	add	r24, r0
    4994:	91 1d       	adc	r25, r1
    4996:	11 24       	eor	r1, r1
    4998:	08 95       	ret

0000499a <__umulhisi3>:
    499a:	a2 9f       	mul	r26, r18
    499c:	b0 01       	movw	r22, r0
    499e:	b3 9f       	mul	r27, r19
    49a0:	c0 01       	movw	r24, r0
    49a2:	a3 9f       	mul	r26, r19
    49a4:	70 0d       	add	r23, r0
    49a6:	81 1d       	adc	r24, r1
    49a8:	11 24       	eor	r1, r1
    49aa:	91 1d       	adc	r25, r1
    49ac:	b2 9f       	mul	r27, r18
    49ae:	70 0d       	add	r23, r0
    49b0:	81 1d       	adc	r24, r1
    49b2:	11 24       	eor	r1, r1
    49b4:	91 1d       	adc	r25, r1
    49b6:	08 95       	ret

000049b8 <memcpy>:
    49b8:	fb 01       	movw	r30, r22
    49ba:	dc 01       	movw	r26, r24
    49bc:	02 c0       	rjmp	.+4      	; 0x49c2 <memcpy+0xa>
    49be:	01 90       	ld	r0, Z+
    49c0:	0d 92       	st	X+, r0
    49c2:	41 50       	subi	r20, 0x01	; 1
    49c4:	50 40       	sbci	r21, 0x00	; 0
    49c6:	d8 f7       	brcc	.-10     	; 0x49be <memcpy+0x6>
    49c8:	08 95       	ret

000049ca <memset>:
    49ca:	dc 01       	movw	r26, r24
    49cc:	01 c0       	rjmp	.+2      	; 0x49d0 <memset+0x6>
    49ce:	6d 93       	st	X+, r22
    49d0:	41 50       	subi	r20, 0x01	; 1
    49d2:	50 40       	sbci	r21, 0x00	; 0
    49d4:	e0 f7       	brcc	.-8      	; 0x49ce <memset+0x4>
    49d6:	08 95       	ret

000049d8 <strncpy>:
    49d8:	fb 01       	movw	r30, r22
    49da:	dc 01       	movw	r26, r24
    49dc:	41 50       	subi	r20, 0x01	; 1
    49de:	50 40       	sbci	r21, 0x00	; 0
    49e0:	48 f0       	brcs	.+18     	; 0x49f4 <strncpy+0x1c>
    49e2:	01 90       	ld	r0, Z+
    49e4:	0d 92       	st	X+, r0
    49e6:	00 20       	and	r0, r0
    49e8:	c9 f7       	brne	.-14     	; 0x49dc <strncpy+0x4>
    49ea:	01 c0       	rjmp	.+2      	; 0x49ee <strncpy+0x16>
    49ec:	1d 92       	st	X+, r1
    49ee:	41 50       	subi	r20, 0x01	; 1
    49f0:	50 40       	sbci	r21, 0x00	; 0
    49f2:	e0 f7       	brcc	.-8      	; 0x49ec <strncpy+0x14>
    49f4:	08 95       	ret

000049f6 <ultoa>:
    49f6:	25 32       	cpi	r18, 0x25	; 37
    49f8:	31 05       	cpc	r19, r1
    49fa:	20 f4       	brcc	.+8      	; 0x4a04 <ultoa+0xe>
    49fc:	22 30       	cpi	r18, 0x02	; 2
    49fe:	10 f0       	brcs	.+4      	; 0x4a04 <ultoa+0xe>
    4a00:	0c 94 06 25 	jmp	0x4a0c	; 0x4a0c <__ultoa_ncheck>
    4a04:	fa 01       	movw	r30, r20
    4a06:	10 82       	st	Z, r1
    4a08:	ca 01       	movw	r24, r20
    4a0a:	08 95       	ret

00004a0c <__ultoa_ncheck>:
    4a0c:	bb 27       	eor	r27, r27

00004a0e <__ultoa_common>:
    4a0e:	fa 01       	movw	r30, r20
    4a10:	a6 2f       	mov	r26, r22
    4a12:	62 17       	cp	r22, r18
    4a14:	71 05       	cpc	r23, r1
    4a16:	81 05       	cpc	r24, r1
    4a18:	91 05       	cpc	r25, r1
    4a1a:	33 0b       	sbc	r19, r19
    4a1c:	30 fb       	bst	r19, 0
    4a1e:	66 f0       	brts	.+24     	; 0x4a38 <__ultoa_common+0x2a>
    4a20:	aa 27       	eor	r26, r26
    4a22:	66 0f       	add	r22, r22
    4a24:	77 1f       	adc	r23, r23
    4a26:	88 1f       	adc	r24, r24
    4a28:	99 1f       	adc	r25, r25
    4a2a:	aa 1f       	adc	r26, r26
    4a2c:	a2 17       	cp	r26, r18
    4a2e:	10 f0       	brcs	.+4      	; 0x4a34 <__ultoa_common+0x26>
    4a30:	a2 1b       	sub	r26, r18
    4a32:	63 95       	inc	r22
    4a34:	38 50       	subi	r19, 0x08	; 8
    4a36:	a9 f7       	brne	.-22     	; 0x4a22 <__ultoa_common+0x14>
    4a38:	a0 5d       	subi	r26, 0xD0	; 208
    4a3a:	aa 33       	cpi	r26, 0x3A	; 58
    4a3c:	08 f0       	brcs	.+2      	; 0x4a40 <__ultoa_common+0x32>
    4a3e:	a9 5d       	subi	r26, 0xD9	; 217
    4a40:	a1 93       	st	Z+, r26
    4a42:	36 f7       	brtc	.-52     	; 0x4a10 <__ultoa_common+0x2>
    4a44:	b1 11       	cpse	r27, r1
    4a46:	b1 93       	st	Z+, r27
    4a48:	10 82       	st	Z, r1
    4a4a:	ca 01       	movw	r24, r20
    4a4c:	0c 94 4d 25 	jmp	0x4a9a	; 0x4a9a <strrev>

00004a50 <utoa>:
    4a50:	45 32       	cpi	r20, 0x25	; 37
    4a52:	51 05       	cpc	r21, r1
    4a54:	20 f4       	brcc	.+8      	; 0x4a5e <utoa+0xe>
    4a56:	42 30       	cpi	r20, 0x02	; 2
    4a58:	10 f0       	brcs	.+4      	; 0x4a5e <utoa+0xe>
    4a5a:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__utoa_ncheck>
    4a5e:	fb 01       	movw	r30, r22
    4a60:	10 82       	st	Z, r1
    4a62:	cb 01       	movw	r24, r22
    4a64:	08 95       	ret

00004a66 <__utoa_ncheck>:
    4a66:	bb 27       	eor	r27, r27

00004a68 <__utoa_common>:
    4a68:	fb 01       	movw	r30, r22
    4a6a:	55 27       	eor	r21, r21
    4a6c:	aa 27       	eor	r26, r26
    4a6e:	88 0f       	add	r24, r24
    4a70:	99 1f       	adc	r25, r25
    4a72:	aa 1f       	adc	r26, r26
    4a74:	a4 17       	cp	r26, r20
    4a76:	10 f0       	brcs	.+4      	; 0x4a7c <__utoa_common+0x14>
    4a78:	a4 1b       	sub	r26, r20
    4a7a:	83 95       	inc	r24
    4a7c:	50 51       	subi	r21, 0x10	; 16
    4a7e:	b9 f7       	brne	.-18     	; 0x4a6e <__utoa_common+0x6>
    4a80:	a0 5d       	subi	r26, 0xD0	; 208
    4a82:	aa 33       	cpi	r26, 0x3A	; 58
    4a84:	08 f0       	brcs	.+2      	; 0x4a88 <__utoa_common+0x20>
    4a86:	a9 5d       	subi	r26, 0xD9	; 217
    4a88:	a1 93       	st	Z+, r26
    4a8a:	00 97       	sbiw	r24, 0x00	; 0
    4a8c:	79 f7       	brne	.-34     	; 0x4a6c <__utoa_common+0x4>
    4a8e:	b1 11       	cpse	r27, r1
    4a90:	b1 93       	st	Z+, r27
    4a92:	11 92       	st	Z+, r1
    4a94:	cb 01       	movw	r24, r22
    4a96:	0c 94 4d 25 	jmp	0x4a9a	; 0x4a9a <strrev>

00004a9a <strrev>:
    4a9a:	dc 01       	movw	r26, r24
    4a9c:	fc 01       	movw	r30, r24
    4a9e:	67 2f       	mov	r22, r23
    4aa0:	71 91       	ld	r23, Z+
    4aa2:	77 23       	and	r23, r23
    4aa4:	e1 f7       	brne	.-8      	; 0x4a9e <strrev+0x4>
    4aa6:	32 97       	sbiw	r30, 0x02	; 2
    4aa8:	04 c0       	rjmp	.+8      	; 0x4ab2 <strrev+0x18>
    4aaa:	7c 91       	ld	r23, X
    4aac:	6d 93       	st	X+, r22
    4aae:	70 83       	st	Z, r23
    4ab0:	62 91       	ld	r22, -Z
    4ab2:	ae 17       	cp	r26, r30
    4ab4:	bf 07       	cpc	r27, r31
    4ab6:	c8 f3       	brcs	.-14     	; 0x4aaa <strrev+0x10>
    4ab8:	08 95       	ret

00004aba <_exit>:
    4aba:	f8 94       	cli

00004abc <__stop_program>:
    4abc:	ff cf       	rjmp	.-2      	; 0x4abc <__stop_program>
