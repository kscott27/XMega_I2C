
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004f00  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000220  00802000  00004f00  00004f94  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802220  00802220  000051b4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000051b4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000051e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a78  00000000  00000000  00005224  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001c9f2  00000000  00000000  00005c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000072af  00000000  00000000  0002268e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000068d9  00000000  00000000  0002993d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001f90  00000000  00000000  00030218  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000072a2  00000000  00000000  000321a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a19c  00000000  00000000  0003944a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009d0  00000000  00000000  000435e6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 39 03 	jmp	0x672	; 0x672 <__ctors_end>
       4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      10:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      14:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      18:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      1c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      20:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      24:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      28:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      2c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      30:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      34:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      38:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      3c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      40:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      44:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      48:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      4c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      50:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      54:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      58:	0c 94 b8 11 	jmp	0x2370	; 0x2370 <__vector_22>
      5c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      60:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      64:	0c 94 8d 21 	jmp	0x431a	; 0x431a <__vector_25>
      68:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      6c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      70:	0c 94 eb 21 	jmp	0x43d6	; 0x43d6 <__vector_28>
      74:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      78:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      7c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      80:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      84:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      88:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      8c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      90:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      94:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      98:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      9c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e8:	0c 94 05 23 	jmp	0x460a	; 0x460a <__vector_58>
      ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      fc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     100:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     104:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     108:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     10c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     110:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     114:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     118:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     11c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     120:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     124:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     128:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     12c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     130:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     134:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     138:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     13c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     140:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     144:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     148:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     14c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     150:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     154:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     158:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     15c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     160:	0c 94 49 22 	jmp	0x4492	; 0x4492 <__vector_88>
     164:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     168:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     16c:	0c 94 a7 22 	jmp	0x454e	; 0x454e <__vector_91>
     170:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     174:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     178:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     17c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     180:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     184:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     188:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     18c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     190:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     194:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     198:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     19c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1fc:	79 1f       	adc	r23, r25
     1fe:	7c 1f       	adc	r23, r28
     200:	7f 1f       	adc	r23, r31
     202:	82 1f       	adc	r24, r18
     204:	85 1f       	adc	r24, r21
     206:	88 1f       	adc	r24, r24
     208:	8a 1f       	adc	r24, r26
     20a:	9b 1f       	adc	r25, r27
     20c:	a3 1f       	adc	r26, r19
     20e:	ad 1f       	adc	r26, r29
     210:	ab 1f       	adc	r26, r27

00000212 <__trampolines_start>:
     212:	0c 94 2d 24 	jmp	0x485a	; 0x485a <_ZN9frt_queueIiE10get_a_copyEv>
     216:	0c 94 f1 20 	jmp	0x41e2	; 0x41e2 <_ZN5rs23214check_for_charEv>
     21a:	0c 94 c1 24 	jmp	0x4982	; 0x4982 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     21e:	0c 94 75 23 	jmp	0x46ea	; 0x46ea <_ZN9frt_queueIjE12ISR_is_emptyEv>
     222:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <_ZN14frt_text_queue7putcharEc>
     226:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <_ZN8emstream12transmit_nowEv>
     22a:	0c 94 d9 24 	jmp	0x49b2	; 0x49b2 <_ZN9frt_queueIjE7ISR_putERKj>
     22e:	0c 94 df 23 	jmp	0x47be	; 0x47be <_ZN9frt_queueIjE10get_a_copyEv>
     232:	0c 94 c3 08 	jmp	0x1186	; 0x1186 <_ZN9frt_queueIhE7ISR_getEPh>
     236:	0c 94 ad 1f 	jmp	0x3f5a	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
     23a:	0c 94 a3 1f 	jmp	0x3f46	; 0x3f46 <_ZN8emstreamlsE15ser_manipulator+0x72>
     23e:	0c 94 63 05 	jmp	0xac6	; 0xac6 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     242:	0c 94 21 25 	jmp	0x4a42	; 0x4a42 <_ZN9frt_queueIjE7butt_inERKj>
     246:	0c 94 6f 24 	jmp	0x48de	; 0x48de <_ZN9frt_queueIjE7ISR_getEPj>
     24a:	0c 94 a4 1c 	jmp	0x3948	; 0x3948 <_ZN14frt_text_queue7getcharEv>
     24e:	0c 94 21 24 	jmp	0x4842	; 0x4842 <_ZN9frt_queueIiE10get_a_copyERi>
     252:	0c 94 ab 1f 	jmp	0x3f56	; 0x3f56 <_ZN8emstreamlsE15ser_manipulator+0x82>
     256:	0c 94 54 24 	jmp	0x48a8	; 0x48a8 <_ZN9frt_queueIiE3getEv>
     25a:	0c 94 04 21 	jmp	0x4208	; 0x4208 <_ZN5rs23212clear_screenEv>
     25e:	0c 94 f3 04 	jmp	0x9e6	; 0x9e6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     262:	0c 94 a2 23 	jmp	0x4744	; 0x4744 <_ZN9frt_queueIjE9not_emptyEv>
     266:	0c 94 24 1f 	jmp	0x3e48	; 0x3e48 <_ZN8emstream12clear_screenEv>
     26a:	0c 94 fa 23 	jmp	0x47f4	; 0x47f4 <_ZN9frt_queueIjE3getEPj>
     26e:	0c 94 c4 05 	jmp	0xb88	; 0xb88 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     272:	0c 94 0c 26 	jmp	0x4c18	; 0x4c18 <_GLOBAL__sub_I_counter>
     276:	0c 94 18 0a 	jmp	0x1430	; 0x1430 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     27a:	0c 94 71 08 	jmp	0x10e2	; 0x10e2 <_ZN9frt_queueIhE8is_emptyEv>
     27e:	0c 94 5f 08 	jmp	0x10be	; 0x10be <_ZN9frt_queueIhE12num_items_inEv>
     282:	0c 94 78 05 	jmp	0xaf0	; 0xaf0 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     286:	0c 94 a9 24 	jmp	0x4952	; 0x4952 <_ZN9frt_queueIiE7ISR_getEv>
     28a:	0c 94 7c 1f 	jmp	0x3ef8	; 0x3ef8 <_ZN8emstreamlsE15ser_manipulator+0x24>
     28e:	0c 94 8d 05 	jmp	0xb1a	; 0xb1a <_ZN9I2CMaster10StartState11serialDebugEv>
     292:	0c 94 cb 20 	jmp	0x4196	; 0x4196 <_ZN5rs2327getcharEv>
     296:	0c 94 09 25 	jmp	0x4a12	; 0x4a12 <_ZN9frt_queueIiE7ISR_putERKi>
     29a:	0c 94 36 08 	jmp	0x106c	; 0x106c <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     29e:	0c 94 0f 04 	jmp	0x81e	; 0x81e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2a2:	0c 94 7f 1f 	jmp	0x3efe	; 0x3efe <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2a6:	0c 94 ad 23 	jmp	0x475a	; 0x475a <_ZN9frt_queueIjE8is_emptyEv>
     2aa:	0c 94 7f 23 	jmp	0x46fe	; 0x46fe <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2ae:	0c 94 88 1f 	jmp	0x3f10	; 0x3f10 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2b2:	0c 94 56 04 	jmp	0x8ac	; 0x8ac <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     2b6:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <_ZN9frt_queueIjE3putERKj>
     2ba:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <_ZN11task_sensor3runEv>
     2be:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <_ZN8I2CAgent11resetPacketER6Packet>
     2c2:	0c 94 1e 1f 	jmp	0x3e3c	; 0x3e3c <_ZN8emstream7getcharEv>
     2c6:	0c 94 03 09 	jmp	0x1206	; 0x1206 <_ZN9frt_queueIhE7ISR_putERKh>
     2ca:	0c 94 94 0d 	jmp	0x1b28	; 0x1b28 <_ZN9task_user3runEv>
     2ce:	0c 94 91 03 	jmp	0x722	; 0x722 <_ZN8I2CAgent7receiveEv>
     2d2:	0c 94 66 08 	jmp	0x10cc	; 0x10cc <_ZN9frt_queueIhE9not_emptyEv>
     2d6:	0c 94 8a 1f 	jmp	0x3f14	; 0x3f14 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2da:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2de:	0c 94 06 24 	jmp	0x480c	; 0x480c <_ZN9frt_queueIjE3getEv>
     2e2:	0c 94 c9 23 	jmp	0x4792	; 0x4792 <_ZN9frt_queueIiE8is_emptyEv>
     2e6:	0c 94 5a 1b 	jmp	0x36b4	; 0x36b4 <_ZN8frt_task12print_statusER8emstream>
     2ea:	0c 94 9b 23 	jmp	0x4736	; 0x4736 <_ZN9frt_queueIjE12num_items_inEv>
     2ee:	0c 94 98 24 	jmp	0x4930	; 0x4930 <_ZN9frt_queueIiE7ISR_getEPi>
     2f2:	0c 94 79 1f 	jmp	0x3ef2	; 0x3ef2 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f6:	0c 94 05 04 	jmp	0x80a	; 0x80a <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     2fa:	0c 94 0f 05 	jmp	0xa1e	; 0xa1e <_ZN9I2CMaster10ErrorState11serialDebugEv>
     2fe:	0c 94 63 23 	jmp	0x46c6	; 0x46c6 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     302:	0c 94 48 24 	jmp	0x4890	; 0x4890 <_ZN9frt_queueIiE3getEPi>
     306:	0c 94 13 08 	jmp	0x1026	; 0x1026 <_ZN9I2CMaster10StartState7executeER6Packet>
     30a:	0c 94 9d 04 	jmp	0x93a	; 0x93a <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     30e:	0c 94 6a 23 	jmp	0x46d4	; 0x46d4 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     312:	0c 94 c2 1c 	jmp	0x3984	; 0x3984 <_ZN14frt_text_queue14check_for_charEv>
     316:	0c 94 82 1f 	jmp	0x3f04	; 0x3f04 <_ZN8emstreamlsE15ser_manipulator+0x30>
     31a:	0c 94 ab 08 	jmp	0x1156	; 0x1156 <_ZN9frt_queueIhE3getEv>
     31e:	0c 94 fe 09 	jmp	0x13fc	; 0x13fc <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     322:	0c 94 bc 03 	jmp	0x778	; 0x778 <_ZN8I2CAgent11writePacketER7Command>
     326:	0c 94 80 24 	jmp	0x4900	; 0x4900 <_ZN9frt_queueIjE7ISR_getEv>
     32a:	0c 94 0b 0a 	jmp	0x1416	; 0x1416 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     32e:	0c 94 9b 1f 	jmp	0x3f36	; 0x3f36 <_ZN8emstreamlsE15ser_manipulator+0x62>
     332:	0c 94 39 05 	jmp	0xa72	; 0xa72 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     336:	0c 94 85 1f 	jmp	0x3f0a	; 0x3f0a <_ZN8emstreamlsE15ser_manipulator+0x36>
     33a:	0c 94 b7 23 	jmp	0x476e	; 0x476e <_ZN9frt_queueIiE12num_items_inEv>
     33e:	0c 94 36 03 	jmp	0x66c	; 0x66c <_call_static_run_method>
     342:	0c 94 fb 03 	jmp	0x7f6	; 0x7f6 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     346:	0c 94 cd 04 	jmp	0x99a	; 0x99a <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     34a:	0c 94 98 14 	jmp	0x2930	; 0x2930 <prvIdleTask>
     34e:	0c 94 be 23 	jmp	0x477c	; 0x477c <_ZN9frt_queueIiE9not_emptyEv>
     352:	0c 94 87 08 	jmp	0x110e	; 0x110e <_ZN9frt_queueIhE10get_a_copyEv>
     356:	0c 94 d3 23 	jmp	0x47a6	; 0x47a6 <_ZN9frt_queueIjE10get_a_copyERj>
     35a:	0c 94 21 1f 	jmp	0x3e42	; 0x3e42 <_ZN8emstream14check_for_charEv>
     35e:	0c 94 45 25 	jmp	0x4a8a	; 0x4a8a <_ZN9frt_queueIiE7butt_inERKi>
     362:	0c 94 43 08 	jmp	0x1086	; 0x1086 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     366:	0c 94 a2 05 	jmp	0xb44	; 0xb44 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     36a:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <_ZN8I2CAgent10readPacketEv>
     36e:	0c 94 86 23 	jmp	0x470c	; 0x470c <_ZN9frt_queueIiE13ISR_not_emptyEv>
     372:	0c 94 24 05 	jmp	0xa48	; 0xa48 <_ZN9I2CMaster9DoneState11serialDebugEv>
     376:	0c 94 f1 24 	jmp	0x49e2	; 0x49e2 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     37a:	0c 94 85 1e 	jmp	0x3d0a	; 0x3d0a <__cxa_pure_virtual>
     37e:	0c 94 08 05 	jmp	0xa10	; 0xa10 <_ZN9I2CMaster9DoneState7executeER6Packet>
     382:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     386:	0c 94 9f 08 	jmp	0x113e	; 0x113e <_ZN9frt_queueIhE3getEPh>
     38a:	0c 94 4e 05 	jmp	0xa9c	; 0xa9c <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     38e:	0c 94 57 25 	jmp	0x4aae	; 0x4aae <_ZN9frt_queueIiE3putERKi>
     392:	0c 94 4a 08 	jmp	0x1094	; 0x1094 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     396:	0c 94 1b 09 	jmp	0x1236	; 0x1236 <_ZN9frt_queueIhE7butt_inERKh>
     39a:	0c 94 df 09 	jmp	0x13be	; 0x13be <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     39e:	0c 94 7b 08 	jmp	0x10f6	; 0x10f6 <_ZN9frt_queueIhE10get_a_copyERh>
     3a2:	0c 94 91 23 	jmp	0x4722	; 0x4722 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     3a6:	0c 94 a7 20 	jmp	0x414e	; 0x414e <_ZN5rs2327putcharEc>
     3aa:	0c 94 d4 08 	jmp	0x11a8	; 0x11a8 <_ZN9frt_queueIhE7ISR_getEv>
     3ae:	0c 94 2d 09 	jmp	0x125a	; 0x125a <_ZN9frt_queueIhE3putERKh>
     3b2:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <_ZN8I2CAgent8transmitER7Command>
     3b6:	0c 94 1c 1f 	jmp	0x3e38	; 0x3e38 <_ZN8emstream13ready_to_sendEv>

000003ba <__trampolines_end>:
     3ba:	2c 20       	and	r2, r12
     3bc:	54 43       	sbci	r21, 0x34	; 52
     3be:	43 30       	cpi	r20, 0x03	; 3
     3c0:	43 43       	sbci	r20, 0x33	; 51
     3c2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c5 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c5:	2f 00                                               /.

000003c7 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d5 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d5:	54 69 6d 65 3a 20 00                                Time: .

000003dc <_ZZN9task_user11show_statusEvE3__c_0>:
     3dc:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e8 <_ZZN9task_user11show_statusEvE3__c>:
     3e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000407 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     407:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000416 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     416:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     426:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000431 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     431:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     441:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46f:	6d 61 74 69 6f 6e 00                                mation.

00000476 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     476:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     486:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000497 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     497:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a7:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004af <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4af:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bf:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004cb <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4cb:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4db:	68 65 20 41 56 52 00                                he AVR.

000004e2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4e2:	20 68 65 6c 70 00                                    help.

000004e8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000507 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     507:	1b 5b 33 30 6d 00                                   .[30m.

0000050d <_ZZN9task_user18print_help_messageEvE3__c>:
     50d:	1b 5b 34 36 6d 00                                   .[46m.

00000513 <_ZZN9task_user3runEvE3__c_3>:
     513:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     523:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000530 <_ZZN9task_user3runEvE3__c_2>:
     530:	3a 57 54 46 3f 00                                   :WTF?.

00000536 <_ZZN9task_user3runEvE3__c_1>:
     536:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     546:	65 00                                               e.

00000548 <_ZZN9task_user3runEvE3__c_0>:
     548:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000556 <_ZZN9task_user3runEvE3__c>:
     556:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     566:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000574 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     574:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057e <_ZZN8frt_task15emergency_resetEvE3__c>:
     57e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000058d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     58d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     59d:	61 73 6b 20 00                                      ask .

000005a2 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     5a2:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005b0 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5b0:	20 63 72 65 61 74 65 64 00                           created.

000005b9 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b9:	54 61 73 6b 20 00                                   Task .

000005bf <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bf:	1b 5b 32 32 6d 00                                   .[22m.

000005c5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c5:	54 61 73 6b 3a 20 00                                Task: .

000005cc <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5cc:	1b 5b 31 6d 00                                      .[1m.

000005d1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5d1:	1b 5b 32 32 6d 00                                   .[22m.

000005d7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005e2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5e2:	1b 5b 31 6d 00                                      .[1m.

000005e7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e7:	09 09 00                                            ...

000005ea <_ZZ15print_task_listP8emstreamE3__c_8>:
     5ea:	2f 00                                               /.

000005ec <_ZZ15print_task_listP8emstreamE3__c_7>:
     5ec:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f7:	09 2d 2d 2d 2d 00                                   .----.

000005fd <_ZZ15print_task_listP8emstreamE3__c_5>:
     5fd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000609 <_ZZ15print_task_listP8emstreamE3__c_4>:
     609:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000061a <_ZZ15print_task_listP8emstreamE3__c_3>:
     61a:	09 52 75 6e 73 00                                   .Runs.

00000620 <_ZZ15print_task_listP8emstreamE3__c_2>:
     620:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000062c <_ZZ15print_task_listP8emstreamE3__c_1>:
     62c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000063d <_ZZ15print_task_listP8emstreamE3__c_0>:
     63d:	09 53 74 61 63 6b 00                                .Stack.

00000644 <_ZZ15print_task_listP8emstreamE3__c>:
     644:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64f:	09 00                                               ..

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     653:	2f 00                                               /.

00000655 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     655:	09 00                                               ..

00000657 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     657:	09 00                                               ..

00000659 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     659:	1b 5b 32 32 6d 00                                   .[22m.

0000065f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65f:	1b 5b 31 6d 00                                      .[1m.

00000664 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     664:	1b 5b 31 6d 00                                      .[1m.

00000669 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     669:	20 20 00                                              .

0000066c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     66c:	0e 94 f2 19 	call	0x33e4	; 0x33e4 <_ZN8frt_task22_call_users_run_methodEPS_>

00000670 <__ctors_start>:
     670:	0c 26       	eor	r0, r28

00000672 <__ctors_end>:
     672:	11 24       	eor	r1, r1
     674:	1f be       	out	0x3f, r1	; 63
     676:	cf ef       	ldi	r28, 0xFF	; 255
     678:	cd bf       	out	0x3d, r28	; 61
     67a:	df e3       	ldi	r29, 0x3F	; 63
     67c:	de bf       	out	0x3e, r29	; 62
     67e:	00 e0       	ldi	r16, 0x00	; 0
     680:	0c bf       	out	0x3c, r16	; 60
     682:	18 be       	out	0x38, r1	; 56
     684:	19 be       	out	0x39, r1	; 57
     686:	1a be       	out	0x3a, r1	; 58
     688:	1b be       	out	0x3b, r1	; 59

0000068a <__do_copy_data>:
     68a:	12 e2       	ldi	r17, 0x22	; 34
     68c:	a0 e0       	ldi	r26, 0x00	; 0
     68e:	b0 e2       	ldi	r27, 0x20	; 32
     690:	e0 e0       	ldi	r30, 0x00	; 0
     692:	ff e4       	ldi	r31, 0x4F	; 79
     694:	00 e0       	ldi	r16, 0x00	; 0
     696:	0b bf       	out	0x3b, r16	; 59
     698:	02 c0       	rjmp	.+4      	; 0x69e <__do_copy_data+0x14>
     69a:	07 90       	elpm	r0, Z+
     69c:	0d 92       	st	X+, r0
     69e:	a0 32       	cpi	r26, 0x20	; 32
     6a0:	b1 07       	cpc	r27, r17
     6a2:	d9 f7       	brne	.-10     	; 0x69a <__do_copy_data+0x10>
     6a4:	1b be       	out	0x3b, r1	; 59

000006a6 <__do_clear_bss>:
     6a6:	22 e3       	ldi	r18, 0x32	; 50
     6a8:	a0 e2       	ldi	r26, 0x20	; 32
     6aa:	b2 e2       	ldi	r27, 0x22	; 34
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <.do_clear_bss_start>

000006ae <.do_clear_bss_loop>:
     6ae:	1d 92       	st	X+, r1

000006b0 <.do_clear_bss_start>:
     6b0:	ae 3e       	cpi	r26, 0xEE	; 238
     6b2:	b2 07       	cpc	r27, r18
     6b4:	e1 f7       	brne	.-8      	; 0x6ae <.do_clear_bss_loop>

000006b6 <__do_global_ctors>:
     6b6:	13 e0       	ldi	r17, 0x03	; 3
     6b8:	c9 e3       	ldi	r28, 0x39	; 57
     6ba:	d3 e0       	ldi	r29, 0x03	; 3
     6bc:	00 e0       	ldi	r16, 0x00	; 0
     6be:	06 c0       	rjmp	.+12     	; 0x6cc <__do_global_ctors+0x16>
     6c0:	21 97       	sbiw	r28, 0x01	; 1
     6c2:	01 09       	sbc	r16, r1
     6c4:	80 2f       	mov	r24, r16
     6c6:	fe 01       	movw	r30, r28
     6c8:	0e 94 da 26 	call	0x4db4	; 0x4db4 <__tablejump2__>
     6cc:	c8 33       	cpi	r28, 0x38	; 56
     6ce:	d1 07       	cpc	r29, r17
     6d0:	80 e0       	ldi	r24, 0x00	; 0
     6d2:	08 07       	cpc	r16, r24
     6d4:	a9 f7       	brne	.-22     	; 0x6c0 <__do_global_ctors+0xa>
     6d6:	0e 94 7e 25 	call	0x4afc	; 0x4afc <main>
     6da:	0c 94 7e 27 	jmp	0x4efc	; 0x4efc <_exit>

000006de <__bad_interrupt>:
     6de:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006e2 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6e2:	bc 01       	movw	r22, r24
     6e4:	6e 5f       	subi	r22, 0xFE	; 254
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	dc 01       	movw	r26, r24
     6ea:	ed 91       	ld	r30, X+
     6ec:	fc 91       	ld	r31, X
     6ee:	00 84       	ldd	r0, Z+8	; 0x08
     6f0:	f1 85       	ldd	r31, Z+9	; 0x09
     6f2:	e0 2d       	mov	r30, r0
     6f4:	19 95       	eicall
     6f6:	08 95       	ret

000006f8 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fe:	e8 81       	ld	r30, Y
     700:	f9 81       	ldd	r31, Y+1	; 0x01
     702:	04 80       	ldd	r0, Z+4	; 0x04
     704:	f5 81       	ldd	r31, Z+5	; 0x05
     706:	e0 2d       	mov	r30, r0
     708:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     70a:	be 01       	movw	r22, r28
     70c:	62 5f       	subi	r22, 0xF2	; 242
     70e:	7f 4f       	sbci	r23, 0xFF	; 255

  };

  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     710:	ec 8d       	ldd	r30, Y+28	; 0x1c
     712:	fd 8d       	ldd	r31, Y+29	; 0x1d
     714:	80 81       	ld	r24, Z
     716:	91 81       	ldd	r25, Z+1	; 0x01
     718:	0e 94 12 07 	call	0xe24	; 0xe24 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     722:	ef 92       	push	r14
     724:	ff 92       	push	r15
     726:	0f 93       	push	r16
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72e:	7c 01       	movw	r14, r24
     730:	82 e0       	ldi	r24, 0x02	; 2
     732:	e8 0e       	add	r14, r24
     734:	f1 1c       	adc	r15, r1
     736:	e8 81       	ld	r30, Y
     738:	f9 81       	ldd	r31, Y+1	; 0x01
     73a:	00 84       	ldd	r0, Z+8	; 0x08
     73c:	f1 85       	ldd	r31, Z+9	; 0x09
     73e:	e0 2d       	mov	r30, r0
     740:	b7 01       	movw	r22, r14
     742:	ce 01       	movw	r24, r28
     744:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     746:	28 85       	ldd	r18, Y+8	; 0x08
     748:	39 85       	ldd	r19, Y+9	; 0x09
     74a:	4a 85       	ldd	r20, Y+10	; 0x0a
     74c:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74e:	be 01       	movw	r22, r28
     750:	60 5e       	subi	r22, 0xE0	; 224
     752:	7f 4f       	sbci	r23, 0xFF	; 255
     754:	00 e0       	ldi	r16, 0x00	; 0
     756:	8e 81       	ldd	r24, Y+6	; 0x06
     758:	9f 81       	ldd	r25, Y+7	; 0x07
     75a:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75e:	ec 8d       	ldd	r30, Y+28	; 0x1c
     760:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     762:	b7 01       	movw	r22, r14
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	0e 94 55 07 	call	0xeaa	; 0xeaa <_ZN9I2CMaster8Receiver3runER6Packet>
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	0f 91       	pop	r16
     772:	ff 90       	pop	r15
     774:	ef 90       	pop	r14
     776:	08 95       	ret

00000778 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     778:	cf 92       	push	r12
     77a:	df 92       	push	r13
     77c:	ef 92       	push	r14
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	ec 01       	movw	r28, r24
     788:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     78a:	6c 01       	movw	r12, r24
     78c:	8e e0       	ldi	r24, 0x0E	; 14
     78e:	c8 0e       	add	r12, r24
     790:	d1 1c       	adc	r13, r1
     792:	e8 81       	ld	r30, Y
     794:	f9 81       	ldd	r31, Y+1	; 0x01
     796:	00 84       	ldd	r0, Z+8	; 0x08
     798:	f1 85       	ldd	r31, Z+9	; 0x09
     79a:	e0 2d       	mov	r30, r0
     79c:	b6 01       	movw	r22, r12
     79e:	ce 01       	movw	r24, r28
     7a0:	19 95       	eicall
     7a2:	2c 89       	ldd	r18, Y+20	; 0x14
     7a4:	3d 89       	ldd	r19, Y+21	; 0x15
     7a6:	4e 89       	ldd	r20, Y+22	; 0x16
     7a8:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7aa:	be 01       	movw	r22, r28
     7ac:	61 5e       	subi	r22, 0xE1	; 225
     7ae:	7f 4f       	sbci	r23, 0xFF	; 255
     7b0:	00 e0       	ldi	r16, 0x00	; 0
     7b2:	8a 89       	ldd	r24, Y+18	; 0x12
     7b4:	9b 89       	ldd	r25, Y+19	; 0x13
     7b6:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7ba:	d7 01       	movw	r26, r14
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	01 90       	ld	r0, Z+
     7c2:	f0 81       	ld	r31, Z
     7c4:	e0 2d       	mov	r30, r0
     7c6:	b6 01       	movw	r22, r12
     7c8:	c7 01       	movw	r24, r14
     7ca:	19 95       	eicall
}
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	0f 91       	pop	r16
     7d2:	ff 90       	pop	r15
     7d4:	ef 90       	pop	r14
     7d6:	df 90       	pop	r13
     7d8:	cf 90       	pop	r12
     7da:	08 95       	ret

000007dc <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7dc:	cb 01       	movw	r24, r22
  packet.resetContent();
     7de:	0e 94 cd 0b 	call	0x179a	; 0x179a <_ZN6Packet12resetContentEv>
     7e2:	08 95       	ret

000007e4 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e4:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e6:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e8:	86 2f       	mov	r24, r22
     7ea:	88 0f       	add	r24, r24
     7ec:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ee:	68 2f       	mov	r22, r24
     7f0:	61 60       	ori	r22, 0x01	; 1
     7f2:	60 a3       	std	Z+32, r22	; 0x20
     7f4:	08 95       	ret

000007f6 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
  }
  else
  {
    return false;
  }
}
     7f6:	dc 01       	movw	r26, r24
     7f8:	17 96       	adiw	r26, 0x07	; 7
     7fa:	ed 91       	ld	r30, X+
     7fc:	fc 91       	ld	r31, X
     7fe:	18 97       	sbiw	r26, 0x08	; 8
     800:	04 80       	ldd	r0, Z+4	; 0x04
     802:	f5 81       	ldd	r31, Z+5	; 0x05
     804:	e0 2d       	mov	r30, r0
     806:	84 81       	ldd	r24, Z+4	; 0x04
     808:	08 95       	ret

0000080a <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     80a:	dc 01       	movw	r26, r24
     80c:	17 96       	adiw	r26, 0x07	; 7
     80e:	ed 91       	ld	r30, X+
     810:	fc 91       	ld	r31, X
     812:	18 97       	sbiw	r26, 0x08	; 8
     814:	04 80       	ldd	r0, Z+4	; 0x04
     816:	f5 81       	ldd	r31, Z+5	; 0x05
     818:	e0 2d       	mov	r30, r0
     81a:	84 81       	ldd	r24, Z+4	; 0x04
     81c:	08 95       	ret

0000081e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	cf 93       	push	r28
     824:	df 93       	push	r29
     826:	1f 92       	push	r1
     828:	1f 92       	push	r1
     82a:	cd b7       	in	r28, 0x3d	; 61
     82c:	de b7       	in	r29, 0x3e	; 62
     82e:	8c 01       	movw	r16, r24
     830:	dc 01       	movw	r26, r24
     832:	19 96       	adiw	r26, 0x09	; 9
     834:	8d 91       	ld	r24, X+
     836:	9c 91       	ld	r25, X
     838:	1a 97       	sbiw	r26, 0x0a	; 10
     83a:	89 83       	std	Y+1, r24	; 0x01
     83c:	9a 83       	std	Y+2, r25	; 0x02
     83e:	89 81       	ldd	r24, Y+1	; 0x01
     840:	9a 81       	ldd	r25, Y+2	; 0x02
     842:	01 97       	sbiw	r24, 0x01	; 1
     844:	89 83       	std	Y+1, r24	; 0x01
     846:	9a 83       	std	Y+2, r25	; 0x02
     848:	89 2b       	or	r24, r25
     84a:	59 f0       	breq	.+22     	; 0x862 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     84c:	d8 01       	movw	r26, r16
     84e:	17 96       	adiw	r26, 0x07	; 7
     850:	ed 91       	ld	r30, X+
     852:	fc 91       	ld	r31, X
     854:	18 97       	sbiw	r26, 0x08	; 8
     856:	04 80       	ldd	r0, Z+4	; 0x04
     858:	f5 81       	ldd	r31, Z+5	; 0x05
     85a:	e0 2d       	mov	r30, r0
     85c:	84 81       	ldd	r24, Z+4	; 0x04
     85e:	86 ff       	sbrs	r24, 6
     860:	ee cf       	rjmp	.-36     	; 0x83e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x20>
     862:	d8 01       	movw	r26, r16
     864:	ed 91       	ld	r30, X+
     866:	fc 91       	ld	r31, X
     868:	02 80       	ldd	r0, Z+2	; 0x02
     86a:	f3 81       	ldd	r31, Z+3	; 0x03
     86c:	e0 2d       	mov	r30, r0
     86e:	c8 01       	movw	r24, r16
     870:	19 95       	eicall
     872:	d8 01       	movw	r26, r16
     874:	17 96       	adiw	r26, 0x07	; 7
     876:	ed 91       	ld	r30, X+
     878:	fc 91       	ld	r31, X
     87a:	18 97       	sbiw	r26, 0x08	; 8
     87c:	04 80       	ldd	r0, Z+4	; 0x04
     87e:	f5 81       	ldd	r31, Z+5	; 0x05
     880:	e0 2d       	mov	r30, r0
     882:	84 81       	ldd	r24, Z+4	; 0x04
     884:	84 fd       	sbrc	r24, 4
     886:	08 c0       	rjmp	.+16     	; 0x898 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     888:	84 81       	ldd	r24, Z+4	; 0x04
     88a:	86 ff       	sbrs	r24, 6
     88c:	05 c0       	rjmp	.+10     	; 0x898 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     88e:	12 96       	adiw	r26, 0x02	; 2
     890:	8d 91       	ld	r24, X+
     892:	9c 91       	ld	r25, X
     894:	13 97       	sbiw	r26, 0x03	; 3
     896:	03 c0       	rjmp	.+6      	; 0x89e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x80>
     898:	f8 01       	movw	r30, r16
     89a:	84 81       	ldd	r24, Z+4	; 0x04
     89c:	95 81       	ldd	r25, Z+5	; 0x05
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	1f 91       	pop	r17
     8a8:	0f 91       	pop	r16
     8aa:	08 95       	ret

000008ac <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     8ac:	0f 93       	push	r16
     8ae:	1f 93       	push	r17
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
     8b4:	1f 92       	push	r1
     8b6:	1f 92       	push	r1
     8b8:	cd b7       	in	r28, 0x3d	; 61
     8ba:	de b7       	in	r29, 0x3e	; 62
     8bc:	8c 01       	movw	r16, r24
     8be:	dc 01       	movw	r26, r24
     8c0:	19 96       	adiw	r26, 0x09	; 9
     8c2:	8d 91       	ld	r24, X+
     8c4:	9c 91       	ld	r25, X
     8c6:	1a 97       	sbiw	r26, 0x0a	; 10
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	9a 83       	std	Y+2, r25	; 0x02
     8cc:	89 81       	ldd	r24, Y+1	; 0x01
     8ce:	9a 81       	ldd	r25, Y+2	; 0x02
     8d0:	01 97       	sbiw	r24, 0x01	; 1
     8d2:	89 83       	std	Y+1, r24	; 0x01
     8d4:	9a 83       	std	Y+2, r25	; 0x02
     8d6:	89 2b       	or	r24, r25
     8d8:	59 f0       	breq	.+22     	; 0x8f0 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x44>
     8da:	d8 01       	movw	r26, r16
     8dc:	17 96       	adiw	r26, 0x07	; 7
     8de:	ed 91       	ld	r30, X+
     8e0:	fc 91       	ld	r31, X
     8e2:	18 97       	sbiw	r26, 0x08	; 8
     8e4:	04 80       	ldd	r0, Z+4	; 0x04
     8e6:	f5 81       	ldd	r31, Z+5	; 0x05
     8e8:	e0 2d       	mov	r30, r0
     8ea:	84 81       	ldd	r24, Z+4	; 0x04
     8ec:	88 23       	and	r24, r24
     8ee:	74 f7       	brge	.-36     	; 0x8cc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x20>
     8f0:	d8 01       	movw	r26, r16
     8f2:	ed 91       	ld	r30, X+
     8f4:	fc 91       	ld	r31, X
     8f6:	02 80       	ldd	r0, Z+2	; 0x02
     8f8:	f3 81       	ldd	r31, Z+3	; 0x03
     8fa:	e0 2d       	mov	r30, r0
     8fc:	c8 01       	movw	r24, r16
     8fe:	19 95       	eicall
     900:	d8 01       	movw	r26, r16
     902:	17 96       	adiw	r26, 0x07	; 7
     904:	ed 91       	ld	r30, X+
     906:	fc 91       	ld	r31, X
     908:	18 97       	sbiw	r26, 0x08	; 8
     90a:	04 80       	ldd	r0, Z+4	; 0x04
     90c:	f5 81       	ldd	r31, Z+5	; 0x05
     90e:	e0 2d       	mov	r30, r0
     910:	84 81       	ldd	r24, Z+4	; 0x04
     912:	84 fd       	sbrc	r24, 4
     914:	08 c0       	rjmp	.+16     	; 0x926 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     916:	84 81       	ldd	r24, Z+4	; 0x04
     918:	88 23       	and	r24, r24
     91a:	2c f4       	brge	.+10     	; 0x926 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     91c:	12 96       	adiw	r26, 0x02	; 2
     91e:	8d 91       	ld	r24, X+
     920:	9c 91       	ld	r25, X
     922:	13 97       	sbiw	r26, 0x03	; 3
     924:	03 c0       	rjmp	.+6      	; 0x92c <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x80>
     926:	f8 01       	movw	r30, r16
     928:	84 81       	ldd	r24, Z+4	; 0x04
     92a:	95 81       	ldd	r25, Z+5	; 0x05
     92c:	0f 90       	pop	r0
     92e:	0f 90       	pop	r0
     930:	df 91       	pop	r29
     932:	cf 91       	pop	r28
     934:	1f 91       	pop	r17
     936:	0f 91       	pop	r16
     938:	08 95       	ret

0000093a <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     93a:	ef 92       	push	r14
     93c:	ff 92       	push	r15
     93e:	0f 93       	push	r16
     940:	1f 93       	push	r17
     942:	cf 93       	push	r28
     944:	df 93       	push	r29
     946:	8c 01       	movw	r16, r24
     948:	eb 01       	movw	r28, r22
     94a:	e8 81       	ld	r30, Y
     94c:	f9 81       	ldd	r31, Y+1	; 0x01
     94e:	00 8c       	ldd	r0, Z+24	; 0x18
     950:	f1 8d       	ldd	r31, Z+25	; 0x19
     952:	e0 2d       	mov	r30, r0
     954:	cb 01       	movw	r24, r22
     956:	19 95       	eicall
     958:	88 23       	and	r24, r24
     95a:	a9 f0       	breq	.+42     	; 0x986 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     95c:	e8 81       	ld	r30, Y
     95e:	f9 81       	ldd	r31, Y+1	; 0x01
     960:	02 84       	ldd	r0, Z+10	; 0x0a
     962:	f3 85       	ldd	r31, Z+11	; 0x0b
     964:	e0 2d       	mov	r30, r0
     966:	e1 2c       	mov	r14, r1
     968:	f1 2c       	mov	r15, r1
     96a:	b7 01       	movw	r22, r14
     96c:	ce 01       	movw	r24, r28
     96e:	19 95       	eicall
     970:	d8 01       	movw	r26, r16
     972:	17 96       	adiw	r26, 0x07	; 7
     974:	ed 91       	ld	r30, X+
     976:	fc 91       	ld	r31, X
     978:	18 97       	sbiw	r26, 0x08	; 8
     97a:	04 80       	ldd	r0, Z+4	; 0x04
     97c:	f5 81       	ldd	r31, Z+5	; 0x05
     97e:	e0 2d       	mov	r30, r0
     980:	d7 01       	movw	r26, r14
     982:	8c 91       	ld	r24, X
     984:	87 83       	std	Z+7, r24	; 0x07
     986:	f8 01       	movw	r30, r16
     988:	82 81       	ldd	r24, Z+2	; 0x02
     98a:	93 81       	ldd	r25, Z+3	; 0x03
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	1f 91       	pop	r17
     992:	0f 91       	pop	r16
     994:	ff 90       	pop	r15
     996:	ef 90       	pop	r14
     998:	08 95       	ret

0000099a <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     99a:	0f 93       	push	r16
     99c:	1f 93       	push	r17
     99e:	cf 93       	push	r28
     9a0:	df 93       	push	r29
     9a2:	1f 92       	push	r1
     9a4:	cd b7       	in	r28, 0x3d	; 61
     9a6:	de b7       	in	r29, 0x3e	; 62
     9a8:	8c 01       	movw	r16, r24
     9aa:	cb 01       	movw	r24, r22
     9ac:	d8 01       	movw	r26, r16
     9ae:	17 96       	adiw	r26, 0x07	; 7
     9b0:	ed 91       	ld	r30, X+
     9b2:	fc 91       	ld	r31, X
     9b4:	18 97       	sbiw	r26, 0x08	; 8
     9b6:	04 80       	ldd	r0, Z+4	; 0x04
     9b8:	f5 81       	ldd	r31, Z+5	; 0x05
     9ba:	e0 2d       	mov	r30, r0
     9bc:	27 81       	ldd	r18, Z+7	; 0x07
     9be:	29 83       	std	Y+1, r18	; 0x01
     9c0:	db 01       	movw	r26, r22
     9c2:	ed 91       	ld	r30, X+
     9c4:	fc 91       	ld	r31, X
     9c6:	01 90       	ld	r0, Z+
     9c8:	f0 81       	ld	r31, Z
     9ca:	e0 2d       	mov	r30, r0
     9cc:	be 01       	movw	r22, r28
     9ce:	6f 5f       	subi	r22, 0xFF	; 255
     9d0:	7f 4f       	sbci	r23, 0xFF	; 255
     9d2:	19 95       	eicall
     9d4:	f8 01       	movw	r30, r16
     9d6:	82 81       	ldd	r24, Z+2	; 0x02
     9d8:	93 81       	ldd	r25, Z+3	; 0x03
     9da:	0f 90       	pop	r0
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	0f 91       	pop	r16
     9e4:	08 95       	ret

000009e6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     9e6:	cf 93       	push	r28
     9e8:	df 93       	push	r29
     9ea:	ec 01       	movw	r28, r24
     9ec:	cb 01       	movw	r24, r22
     9ee:	db 01       	movw	r26, r22
     9f0:	ed 91       	ld	r30, X+
     9f2:	fc 91       	ld	r31, X
     9f4:	04 88       	ldd	r0, Z+20	; 0x14
     9f6:	f5 89       	ldd	r31, Z+21	; 0x15
     9f8:	e0 2d       	mov	r30, r0
     9fa:	19 95       	eicall
     9fc:	88 23       	and	r24, r24
     9fe:	19 f0       	breq	.+6      	; 0xa06 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     a00:	8a 81       	ldd	r24, Y+2	; 0x02
     a02:	9b 81       	ldd	r25, Y+3	; 0x03
     a04:	02 c0       	rjmp	.+4      	; 0xa0a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     a06:	8c 81       	ldd	r24, Y+4	; 0x04
     a08:	9d 81       	ldd	r25, Y+5	; 0x05
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	08 95       	ret

00000a10 <_ZN9I2CMaster9DoneState7executeER6Packet>:
     a10:	21 e0       	ldi	r18, 0x01	; 1
     a12:	fb 01       	movw	r30, r22
     a14:	23 87       	std	Z+11, r18	; 0x0b
     a16:	fc 01       	movw	r30, r24
     a18:	82 81       	ldd	r24, Z+2	; 0x02
     a1a:	93 81       	ldd	r25, Z+3	; 0x03
     a1c:	08 95       	ret

00000a1e <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     a1e:	cf 93       	push	r28
     a20:	df 93       	push	r29
     a22:	dc 01       	movw	r26, r24
     a24:	17 96       	adiw	r26, 0x07	; 7
     a26:	ed 91       	ld	r30, X+
     a28:	fc 91       	ld	r31, X
     a2a:	18 97       	sbiw	r26, 0x08	; 8
     a2c:	c6 81       	ldd	r28, Z+6	; 0x06
     a2e:	d7 81       	ldd	r29, Z+7	; 0x07
     a30:	64 e1       	ldi	r22, 0x14	; 20
     a32:	70 e2       	ldi	r23, 0x20	; 32
     a34:	ce 01       	movw	r24, r28
     a36:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     a3a:	66 e0       	ldi	r22, 0x06	; 6
     a3c:	ce 01       	movw	r24, r28
     a3e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	08 95       	ret

00000a48 <_ZN9I2CMaster9DoneState11serialDebugEv>:
     a48:	cf 93       	push	r28
     a4a:	df 93       	push	r29
     a4c:	dc 01       	movw	r26, r24
     a4e:	17 96       	adiw	r26, 0x07	; 7
     a50:	ed 91       	ld	r30, X+
     a52:	fc 91       	ld	r31, X
     a54:	18 97       	sbiw	r26, 0x08	; 8
     a56:	c6 81       	ldd	r28, Z+6	; 0x06
     a58:	d7 81       	ldd	r29, Z+7	; 0x07
     a5a:	6a e1       	ldi	r22, 0x1A	; 26
     a5c:	70 e2       	ldi	r23, 0x20	; 32
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     a64:	66 e0       	ldi	r22, 0x06	; 6
     a66:	ce 01       	movw	r24, r28
     a68:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	08 95       	ret

00000a72 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a72:	cf 93       	push	r28
     a74:	df 93       	push	r29
     a76:	dc 01       	movw	r26, r24
     a78:	17 96       	adiw	r26, 0x07	; 7
     a7a:	ed 91       	ld	r30, X+
     a7c:	fc 91       	ld	r31, X
     a7e:	18 97       	sbiw	r26, 0x08	; 8
     a80:	c6 81       	ldd	r28, Z+6	; 0x06
     a82:	d7 81       	ldd	r29, Z+7	; 0x07
     a84:	6f e1       	ldi	r22, 0x1F	; 31
     a86:	70 e2       	ldi	r23, 0x20	; 32
     a88:	ce 01       	movw	r24, r28
     a8a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     a8e:	66 e0       	ldi	r22, 0x06	; 6
     a90:	ce 01       	movw	r24, r28
     a92:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     a96:	df 91       	pop	r29
     a98:	cf 91       	pop	r28
     a9a:	08 95       	ret

00000a9c <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	dc 01       	movw	r26, r24
     aa2:	17 96       	adiw	r26, 0x07	; 7
     aa4:	ed 91       	ld	r30, X+
     aa6:	fc 91       	ld	r31, X
     aa8:	18 97       	sbiw	r26, 0x08	; 8
     aaa:	c6 81       	ldd	r28, Z+6	; 0x06
     aac:	d7 81       	ldd	r29, Z+7	; 0x07
     aae:	68 e2       	ldi	r22, 0x28	; 40
     ab0:	70 e2       	ldi	r23, 0x20	; 32
     ab2:	ce 01       	movw	r24, r28
     ab4:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     ab8:	66 e0       	ldi	r22, 0x06	; 6
     aba:	ce 01       	movw	r24, r28
     abc:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     ac0:	df 91       	pop	r29
     ac2:	cf 91       	pop	r28
     ac4:	08 95       	ret

00000ac6 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     ac6:	cf 93       	push	r28
     ac8:	df 93       	push	r29
     aca:	dc 01       	movw	r26, r24
     acc:	17 96       	adiw	r26, 0x07	; 7
     ace:	ed 91       	ld	r30, X+
     ad0:	fc 91       	ld	r31, X
     ad2:	18 97       	sbiw	r26, 0x08	; 8
     ad4:	c6 81       	ldd	r28, Z+6	; 0x06
     ad6:	d7 81       	ldd	r29, Z+7	; 0x07
     ad8:	61 e3       	ldi	r22, 0x31	; 49
     ada:	70 e2       	ldi	r23, 0x20	; 32
     adc:	ce 01       	movw	r24, r28
     ade:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     ae2:	66 e0       	ldi	r22, 0x06	; 6
     ae4:	ce 01       	movw	r24, r28
     ae6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	08 95       	ret

00000af0 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     af0:	cf 93       	push	r28
     af2:	df 93       	push	r29
     af4:	dc 01       	movw	r26, r24
     af6:	17 96       	adiw	r26, 0x07	; 7
     af8:	ed 91       	ld	r30, X+
     afa:	fc 91       	ld	r31, X
     afc:	18 97       	sbiw	r26, 0x08	; 8
     afe:	c6 81       	ldd	r28, Z+6	; 0x06
     b00:	d7 81       	ldd	r29, Z+7	; 0x07
     b02:	6c e3       	ldi	r22, 0x3C	; 60
     b04:	70 e2       	ldi	r23, 0x20	; 32
     b06:	ce 01       	movw	r24, r28
     b08:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     b0c:	66 e0       	ldi	r22, 0x06	; 6
     b0e:	ce 01       	movw	r24, r28
     b10:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     b14:	df 91       	pop	r29
     b16:	cf 91       	pop	r28
     b18:	08 95       	ret

00000b1a <_ZN9I2CMaster10StartState11serialDebugEv>:
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	dc 01       	movw	r26, r24
     b20:	17 96       	adiw	r26, 0x07	; 7
     b22:	ed 91       	ld	r30, X+
     b24:	fc 91       	ld	r31, X
     b26:	18 97       	sbiw	r26, 0x08	; 8
     b28:	c6 81       	ldd	r28, Z+6	; 0x06
     b2a:	d7 81       	ldd	r29, Z+7	; 0x07
     b2c:	67 e4       	ldi	r22, 0x47	; 71
     b2e:	70 e2       	ldi	r23, 0x20	; 32
     b30:	ce 01       	movw	r24, r28
     b32:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     b36:	66 e0       	ldi	r22, 0x06	; 6
     b38:	ce 01       	movw	r24, r28
     b3a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     b44:	ff 92       	push	r15
     b46:	0f 93       	push	r16
     b48:	1f 93       	push	r17
     b4a:	cf 93       	push	r28
     b4c:	df 93       	push	r29
     b4e:	ec 01       	movw	r28, r24
     b50:	ef 81       	ldd	r30, Y+7	; 0x07
     b52:	f8 85       	ldd	r31, Y+8	; 0x08
     b54:	a4 81       	ldd	r26, Z+4	; 0x04
     b56:	b5 81       	ldd	r27, Z+5	; 0x05
     b58:	14 96       	adiw	r26, 0x04	; 4
     b5a:	fc 90       	ld	r15, X
     b5c:	06 81       	ldd	r16, Z+6	; 0x06
     b5e:	17 81       	ldd	r17, Z+7	; 0x07
     b60:	6d e4       	ldi	r22, 0x4D	; 77
     b62:	70 e2       	ldi	r23, 0x20	; 32
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     b6a:	6f 2d       	mov	r22, r15
     b6c:	c8 01       	movw	r24, r16
     b6e:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
     b72:	66 e0       	ldi	r22, 0x06	; 6
     b74:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
     b78:	8a 81       	ldd	r24, Y+2	; 0x02
     b7a:	9b 81       	ldd	r25, Y+3	; 0x03
     b7c:	df 91       	pop	r29
     b7e:	cf 91       	pop	r28
     b80:	1f 91       	pop	r17
     b82:	0f 91       	pop	r16
     b84:	ff 90       	pop	r15
     b86:	08 95       	ret

00000b88 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     b88:	0f 93       	push	r16
     b8a:	1f 93       	push	r17
     b8c:	cf 93       	push	r28
     b8e:	df 93       	push	r29
     b90:	8c 01       	movw	r16, r24
     b92:	eb 01       	movw	r28, r22
     b94:	e8 81       	ld	r30, Y
     b96:	f9 81       	ldd	r31, Y+1	; 0x01
     b98:	04 8c       	ldd	r0, Z+28	; 0x1c
     b9a:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b9c:	e0 2d       	mov	r30, r0
     b9e:	cb 01       	movw	r24, r22
     ba0:	19 95       	eicall
     ba2:	2a 85       	ldd	r18, Y+10	; 0x0a
     ba4:	30 e0       	ldi	r19, 0x00	; 0
     ba6:	82 17       	cp	r24, r18
     ba8:	93 07       	cpc	r25, r19
     baa:	79 f4       	brne	.+30     	; 0xbca <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     bac:	d8 01       	movw	r26, r16
     bae:	17 96       	adiw	r26, 0x07	; 7
     bb0:	ed 91       	ld	r30, X+
     bb2:	fc 91       	ld	r31, X
     bb4:	18 97       	sbiw	r26, 0x08	; 8
     bb6:	04 80       	ldd	r0, Z+4	; 0x04
     bb8:	f5 81       	ldd	r31, Z+5	; 0x05
     bba:	e0 2d       	mov	r30, r0
     bbc:	87 e0       	ldi	r24, 0x07	; 7
     bbe:	83 83       	std	Z+3, r24	; 0x03
     bc0:	12 96       	adiw	r26, 0x02	; 2
     bc2:	8d 91       	ld	r24, X+
     bc4:	9c 91       	ld	r25, X
     bc6:	13 97       	sbiw	r26, 0x03	; 3
     bc8:	0e c0       	rjmp	.+28     	; 0xbe6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     bca:	d8 01       	movw	r26, r16
     bcc:	17 96       	adiw	r26, 0x07	; 7
     bce:	ed 91       	ld	r30, X+
     bd0:	fc 91       	ld	r31, X
     bd2:	18 97       	sbiw	r26, 0x08	; 8
     bd4:	04 80       	ldd	r0, Z+4	; 0x04
     bd6:	f5 81       	ldd	r31, Z+5	; 0x05
     bd8:	e0 2d       	mov	r30, r0
     bda:	82 e0       	ldi	r24, 0x02	; 2
     bdc:	83 83       	std	Z+3, r24	; 0x03
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	8d 91       	ld	r24, X+
     be2:	9c 91       	ld	r25, X
     be4:	15 97       	sbiw	r26, 0x05	; 5
     be6:	df 91       	pop	r29
     be8:	cf 91       	pop	r28
     bea:	1f 91       	pop	r17
     bec:	0f 91       	pop	r16
     bee:	08 95       	ret

00000bf0 <_ZN9I2CMaster11TransmitterC1EPS_>:
     bf0:	0f 93       	push	r16
     bf2:	1f 93       	push	r17
     bf4:	cf 93       	push	r28
     bf6:	df 93       	push	r29
     bf8:	ec 01       	movw	r28, r24
     bfa:	8b 01       	movw	r16, r22
     bfc:	68 83       	st	Y, r22
     bfe:	79 83       	std	Y+1, r23	; 0x01
     c00:	89 e0       	ldi	r24, 0x09	; 9
     c02:	90 e0       	ldi	r25, 0x00	; 0
     c04:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c08:	fc 01       	movw	r30, r24
     c0a:	16 82       	std	Z+6, r1	; 0x06
     c0c:	89 e9       	ldi	r24, 0x99	; 153
     c0e:	90 e2       	ldi	r25, 0x20	; 32
     c10:	80 83       	st	Z, r24
     c12:	91 83       	std	Z+1, r25	; 0x01
     c14:	07 83       	std	Z+7, r16	; 0x07
     c16:	10 87       	std	Z+8, r17	; 0x08
     c18:	ec 83       	std	Y+4, r30	; 0x04
     c1a:	fd 83       	std	Y+5, r31	; 0x05
     c1c:	8b e0       	ldi	r24, 0x0B	; 11
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c24:	fc 01       	movw	r30, r24
     c26:	89 89       	ldd	r24, Y+17	; 0x11
     c28:	9a 89       	ldd	r25, Y+18	; 0x12
     c2a:	16 82       	std	Z+6, r1	; 0x06
     c2c:	21 ea       	ldi	r18, 0xA1	; 161
     c2e:	30 e2       	ldi	r19, 0x20	; 32
     c30:	20 83       	st	Z, r18
     c32:	31 83       	std	Z+1, r19	; 0x01
     c34:	07 83       	std	Z+7, r16	; 0x07
     c36:	10 87       	std	Z+8, r17	; 0x08
     c38:	81 87       	std	Z+9, r24	; 0x09
     c3a:	92 87       	std	Z+10, r25	; 0x0a
     c3c:	ee 83       	std	Y+6, r30	; 0x06
     c3e:	ff 83       	std	Y+7, r31	; 0x07
     c40:	89 e0       	ldi	r24, 0x09	; 9
     c42:	90 e0       	ldi	r25, 0x00	; 0
     c44:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c48:	fc 01       	movw	r30, r24
     c4a:	16 82       	std	Z+6, r1	; 0x06
     c4c:	81 eb       	ldi	r24, 0xB1	; 177
     c4e:	90 e2       	ldi	r25, 0x20	; 32
     c50:	80 83       	st	Z, r24
     c52:	91 83       	std	Z+1, r25	; 0x01
     c54:	07 83       	std	Z+7, r16	; 0x07
     c56:	10 87       	std	Z+8, r17	; 0x08
     c58:	e8 87       	std	Y+8, r30	; 0x08
     c5a:	f9 87       	std	Y+9, r31	; 0x09
     c5c:	89 e0       	ldi	r24, 0x09	; 9
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c64:	fc 01       	movw	r30, r24
     c66:	16 82       	std	Z+6, r1	; 0x06
     c68:	81 ec       	ldi	r24, 0xC1	; 193
     c6a:	90 e2       	ldi	r25, 0x20	; 32
     c6c:	80 83       	st	Z, r24
     c6e:	91 83       	std	Z+1, r25	; 0x01
     c70:	07 83       	std	Z+7, r16	; 0x07
     c72:	10 87       	std	Z+8, r17	; 0x08
     c74:	ea 87       	std	Y+10, r30	; 0x0a
     c76:	fb 87       	std	Y+11, r31	; 0x0b
     c78:	89 e0       	ldi	r24, 0x09	; 9
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c80:	fc 01       	movw	r30, r24
     c82:	16 82       	std	Z+6, r1	; 0x06
     c84:	89 ed       	ldi	r24, 0xD9	; 217
     c86:	90 e2       	ldi	r25, 0x20	; 32
     c88:	80 83       	st	Z, r24
     c8a:	91 83       	std	Z+1, r25	; 0x01
     c8c:	07 83       	std	Z+7, r16	; 0x07
     c8e:	10 87       	std	Z+8, r17	; 0x08
     c90:	ec 87       	std	Y+12, r30	; 0x0c
     c92:	fd 87       	std	Y+13, r31	; 0x0d
     c94:	89 e0       	ldi	r24, 0x09	; 9
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     c9c:	fc 01       	movw	r30, r24
     c9e:	16 82       	std	Z+6, r1	; 0x06
     ca0:	81 ed       	ldi	r24, 0xD1	; 209
     ca2:	90 e2       	ldi	r25, 0x20	; 32
     ca4:	80 83       	st	Z, r24
     ca6:	91 83       	std	Z+1, r25	; 0x01
     ca8:	07 83       	std	Z+7, r16	; 0x07
     caa:	10 87       	std	Z+8, r17	; 0x08
     cac:	ee 87       	std	Y+14, r30	; 0x0e
     cae:	ff 87       	std	Y+15, r31	; 0x0f
     cb0:	80 e1       	ldi	r24, 0x10	; 16
     cb2:	97 e2       	ldi	r25, 0x27	; 39
     cb4:	89 8b       	std	Y+17, r24	; 0x11
     cb6:	9a 8b       	std	Y+18, r25	; 0x12
     cb8:	8e 81       	ldd	r24, Y+6	; 0x06
     cba:	9f 81       	ldd	r25, Y+7	; 0x07
     cbc:	ec 81       	ldd	r30, Y+4	; 0x04
     cbe:	fd 81       	ldd	r31, Y+5	; 0x05
     cc0:	82 83       	std	Z+2, r24	; 0x02
     cc2:	93 83       	std	Z+3, r25	; 0x03
     cc4:	84 83       	std	Z+4, r24	; 0x04
     cc6:	95 83       	std	Z+5, r25	; 0x05
     cc8:	8c 85       	ldd	r24, Y+12	; 0x0c
     cca:	9d 85       	ldd	r25, Y+13	; 0x0d
     ccc:	28 85       	ldd	r18, Y+8	; 0x08
     cce:	39 85       	ldd	r19, Y+9	; 0x09
     cd0:	ee 81       	ldd	r30, Y+6	; 0x06
     cd2:	ff 81       	ldd	r31, Y+7	; 0x07
     cd4:	22 83       	std	Z+2, r18	; 0x02
     cd6:	33 83       	std	Z+3, r19	; 0x03
     cd8:	84 83       	std	Z+4, r24	; 0x04
     cda:	95 83       	std	Z+5, r25	; 0x05
     cdc:	8a 85       	ldd	r24, Y+10	; 0x0a
     cde:	9b 85       	ldd	r25, Y+11	; 0x0b
     ce0:	e8 85       	ldd	r30, Y+8	; 0x08
     ce2:	f9 85       	ldd	r31, Y+9	; 0x09
     ce4:	82 83       	std	Z+2, r24	; 0x02
     ce6:	93 83       	std	Z+3, r25	; 0x03
     ce8:	84 83       	std	Z+4, r24	; 0x04
     cea:	95 83       	std	Z+5, r25	; 0x05
     cec:	8e 81       	ldd	r24, Y+6	; 0x06
     cee:	9f 81       	ldd	r25, Y+7	; 0x07
     cf0:	2e 85       	ldd	r18, Y+14	; 0x0e
     cf2:	3f 85       	ldd	r19, Y+15	; 0x0f
     cf4:	ea 85       	ldd	r30, Y+10	; 0x0a
     cf6:	fb 85       	ldd	r31, Y+11	; 0x0b
     cf8:	22 83       	std	Z+2, r18	; 0x02
     cfa:	33 83       	std	Z+3, r19	; 0x03
     cfc:	84 83       	std	Z+4, r24	; 0x04
     cfe:	95 83       	std	Z+5, r25	; 0x05
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	1f 91       	pop	r17
     d06:	0f 91       	pop	r16
     d08:	08 95       	ret

00000d0a <_ZN9I2CMaster8ReceiverC1EPS_>:
     d0a:	0f 93       	push	r16
     d0c:	1f 93       	push	r17
     d0e:	cf 93       	push	r28
     d10:	df 93       	push	r29
     d12:	ec 01       	movw	r28, r24
     d14:	8b 01       	movw	r16, r22
     d16:	68 83       	st	Y, r22
     d18:	79 83       	std	Y+1, r23	; 0x01
     d1a:	89 e0       	ldi	r24, 0x09	; 9
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     d22:	fc 01       	movw	r30, r24
     d24:	16 82       	std	Z+6, r1	; 0x06
     d26:	89 e9       	ldi	r24, 0x99	; 153
     d28:	90 e2       	ldi	r25, 0x20	; 32
     d2a:	80 83       	st	Z, r24
     d2c:	91 83       	std	Z+1, r25	; 0x01
     d2e:	07 83       	std	Z+7, r16	; 0x07
     d30:	10 87       	std	Z+8, r17	; 0x08
     d32:	ec 83       	std	Y+4, r30	; 0x04
     d34:	fd 83       	std	Y+5, r31	; 0x05
     d36:	8b e0       	ldi	r24, 0x0B	; 11
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     d3e:	fc 01       	movw	r30, r24
     d40:	89 89       	ldd	r24, Y+17	; 0x11
     d42:	9a 89       	ldd	r25, Y+18	; 0x12
     d44:	16 82       	std	Z+6, r1	; 0x06
     d46:	29 ea       	ldi	r18, 0xA9	; 169
     d48:	30 e2       	ldi	r19, 0x20	; 32
     d4a:	20 83       	st	Z, r18
     d4c:	31 83       	std	Z+1, r19	; 0x01
     d4e:	07 83       	std	Z+7, r16	; 0x07
     d50:	10 87       	std	Z+8, r17	; 0x08
     d52:	81 87       	std	Z+9, r24	; 0x09
     d54:	92 87       	std	Z+10, r25	; 0x0a
     d56:	ee 83       	std	Y+6, r30	; 0x06
     d58:	ff 83       	std	Y+7, r31	; 0x07
     d5a:	89 e0       	ldi	r24, 0x09	; 9
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     d62:	fc 01       	movw	r30, r24
     d64:	16 82       	std	Z+6, r1	; 0x06
     d66:	89 eb       	ldi	r24, 0xB9	; 185
     d68:	90 e2       	ldi	r25, 0x20	; 32
     d6a:	80 83       	st	Z, r24
     d6c:	91 83       	std	Z+1, r25	; 0x01
     d6e:	07 83       	std	Z+7, r16	; 0x07
     d70:	10 87       	std	Z+8, r17	; 0x08
     d72:	e8 87       	std	Y+8, r30	; 0x08
     d74:	f9 87       	std	Y+9, r31	; 0x09
     d76:	89 e0       	ldi	r24, 0x09	; 9
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     d7e:	fc 01       	movw	r30, r24
     d80:	16 82       	std	Z+6, r1	; 0x06
     d82:	89 ec       	ldi	r24, 0xC9	; 201
     d84:	90 e2       	ldi	r25, 0x20	; 32
     d86:	80 83       	st	Z, r24
     d88:	91 83       	std	Z+1, r25	; 0x01
     d8a:	07 83       	std	Z+7, r16	; 0x07
     d8c:	10 87       	std	Z+8, r17	; 0x08
     d8e:	ea 87       	std	Y+10, r30	; 0x0a
     d90:	fb 87       	std	Y+11, r31	; 0x0b
     d92:	89 e0       	ldi	r24, 0x09	; 9
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     d9a:	fc 01       	movw	r30, r24
     d9c:	16 82       	std	Z+6, r1	; 0x06
     d9e:	89 ed       	ldi	r24, 0xD9	; 217
     da0:	90 e2       	ldi	r25, 0x20	; 32
     da2:	80 83       	st	Z, r24
     da4:	91 83       	std	Z+1, r25	; 0x01
     da6:	07 83       	std	Z+7, r16	; 0x07
     da8:	10 87       	std	Z+8, r17	; 0x08
     daa:	ec 87       	std	Y+12, r30	; 0x0c
     dac:	fd 87       	std	Y+13, r31	; 0x0d
     dae:	89 e0       	ldi	r24, 0x09	; 9
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     db6:	fc 01       	movw	r30, r24
     db8:	16 82       	std	Z+6, r1	; 0x06
     dba:	81 ed       	ldi	r24, 0xD1	; 209
     dbc:	90 e2       	ldi	r25, 0x20	; 32
     dbe:	80 83       	st	Z, r24
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	07 83       	std	Z+7, r16	; 0x07
     dc4:	10 87       	std	Z+8, r17	; 0x08
     dc6:	ee 87       	std	Y+14, r30	; 0x0e
     dc8:	ff 87       	std	Y+15, r31	; 0x0f
     dca:	80 e1       	ldi	r24, 0x10	; 16
     dcc:	97 e2       	ldi	r25, 0x27	; 39
     dce:	89 8b       	std	Y+17, r24	; 0x11
     dd0:	9a 8b       	std	Y+18, r25	; 0x12
     dd2:	8e 81       	ldd	r24, Y+6	; 0x06
     dd4:	9f 81       	ldd	r25, Y+7	; 0x07
     dd6:	ec 81       	ldd	r30, Y+4	; 0x04
     dd8:	fd 81       	ldd	r31, Y+5	; 0x05
     dda:	82 83       	std	Z+2, r24	; 0x02
     ddc:	93 83       	std	Z+3, r25	; 0x03
     dde:	84 83       	std	Z+4, r24	; 0x04
     de0:	95 83       	std	Z+5, r25	; 0x05
     de2:	8c 85       	ldd	r24, Y+12	; 0x0c
     de4:	9d 85       	ldd	r25, Y+13	; 0x0d
     de6:	28 85       	ldd	r18, Y+8	; 0x08
     de8:	39 85       	ldd	r19, Y+9	; 0x09
     dea:	ee 81       	ldd	r30, Y+6	; 0x06
     dec:	ff 81       	ldd	r31, Y+7	; 0x07
     dee:	22 83       	std	Z+2, r18	; 0x02
     df0:	33 83       	std	Z+3, r19	; 0x03
     df2:	84 83       	std	Z+4, r24	; 0x04
     df4:	95 83       	std	Z+5, r25	; 0x05
     df6:	8a 85       	ldd	r24, Y+10	; 0x0a
     df8:	9b 85       	ldd	r25, Y+11	; 0x0b
     dfa:	e8 85       	ldd	r30, Y+8	; 0x08
     dfc:	f9 85       	ldd	r31, Y+9	; 0x09
     dfe:	82 83       	std	Z+2, r24	; 0x02
     e00:	93 83       	std	Z+3, r25	; 0x03
     e02:	84 83       	std	Z+4, r24	; 0x04
     e04:	95 83       	std	Z+5, r25	; 0x05
     e06:	8e 81       	ldd	r24, Y+6	; 0x06
     e08:	9f 81       	ldd	r25, Y+7	; 0x07
     e0a:	2e 85       	ldd	r18, Y+14	; 0x0e
     e0c:	3f 85       	ldd	r19, Y+15	; 0x0f
     e0e:	ea 85       	ldd	r30, Y+10	; 0x0a
     e10:	fb 85       	ldd	r31, Y+11	; 0x0b
     e12:	22 83       	std	Z+2, r18	; 0x02
     e14:	33 83       	std	Z+3, r19	; 0x03
     e16:	84 83       	std	Z+4, r24	; 0x04
     e18:	95 83       	std	Z+5, r25	; 0x05
     e1a:	df 91       	pop	r29
     e1c:	cf 91       	pop	r28
     e1e:	1f 91       	pop	r17
     e20:	0f 91       	pop	r16
     e22:	08 95       	ret

00000e24 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e24:	0f 93       	push	r16
     e26:	1f 93       	push	r17
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	ec 01       	movw	r28, r24
     e2e:	8b 01       	movw	r16, r22
     e30:	8c 81       	ldd	r24, Y+4	; 0x04
     e32:	9d 81       	ldd	r25, Y+5	; 0x05
     e34:	8a 83       	std	Y+2, r24	; 0x02
     e36:	9b 83       	std	Y+3, r25	; 0x03
     e38:	2e 85       	ldd	r18, Y+14	; 0x0e
     e3a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e3c:	82 17       	cp	r24, r18
     e3e:	93 07       	cpc	r25, r19
     e40:	d9 f0       	breq	.+54     	; 0xe78 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     e42:	2c 85       	ldd	r18, Y+12	; 0x0c
     e44:	3d 85       	ldd	r19, Y+13	; 0x0d
     e46:	82 17       	cp	r24, r18
     e48:	93 07       	cpc	r25, r19
     e4a:	31 f4       	brne	.+12     	; 0xe58 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     e4c:	17 c0       	rjmp	.+46     	; 0xe7c <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     e4e:	2c 85       	ldd	r18, Y+12	; 0x0c
     e50:	3d 85       	ldd	r19, Y+13	; 0x0d
     e52:	28 17       	cp	r18, r24
     e54:	39 07       	cpc	r19, r25
     e56:	99 f0       	breq	.+38     	; 0xe7e <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e58:	dc 01       	movw	r26, r24
     e5a:	ed 91       	ld	r30, X+
     e5c:	fc 91       	ld	r31, X
     e5e:	01 90       	ld	r0, Z+
     e60:	f0 81       	ld	r31, Z
     e62:	e0 2d       	mov	r30, r0
     e64:	b8 01       	movw	r22, r16
     e66:	19 95       	eicall
     e68:	8a 83       	std	Y+2, r24	; 0x02
     e6a:	9b 83       	std	Y+3, r25	; 0x03
     e6c:	2e 85       	ldd	r18, Y+14	; 0x0e
     e6e:	3f 85       	ldd	r19, Y+15	; 0x0f
     e70:	28 17       	cp	r18, r24
     e72:	39 07       	cpc	r19, r25
     e74:	61 f7       	brne	.-40     	; 0xe4e <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     e76:	03 c0       	rjmp	.+6      	; 0xe7e <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e78:	c9 01       	movw	r24, r18
     e7a:	01 c0       	rjmp	.+2      	; 0xe7e <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e7c:	c9 01       	movw	r24, r18
     e7e:	dc 01       	movw	r26, r24
     e80:	ed 91       	ld	r30, X+
     e82:	fc 91       	ld	r31, X
     e84:	01 90       	ld	r0, Z+
     e86:	f0 81       	ld	r31, Z
     e88:	e0 2d       	mov	r30, r0
     e8a:	b8 01       	movw	r22, r16
     e8c:	19 95       	eicall
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	4a 81       	ldd	r20, Y+2	; 0x02
     e92:	5b 81       	ldd	r21, Y+3	; 0x03
     e94:	2e 85       	ldd	r18, Y+14	; 0x0e
     e96:	3f 85       	ldd	r19, Y+15	; 0x0f
     e98:	42 17       	cp	r20, r18
     e9a:	53 07       	cpc	r21, r19
     e9c:	09 f0       	breq	.+2      	; 0xea0 <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	df 91       	pop	r29
     ea2:	cf 91       	pop	r28
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	08 95       	ret

00000eaa <_ZN9I2CMaster8Receiver3runER6Packet>:
     eaa:	0f 93       	push	r16
     eac:	1f 93       	push	r17
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
     eb2:	ec 01       	movw	r28, r24
     eb4:	8b 01       	movw	r16, r22
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	9d 81       	ldd	r25, Y+5	; 0x05
     eba:	8a 83       	std	Y+2, r24	; 0x02
     ebc:	9b 83       	std	Y+3, r25	; 0x03
     ebe:	2e 85       	ldd	r18, Y+14	; 0x0e
     ec0:	3f 85       	ldd	r19, Y+15	; 0x0f
     ec2:	82 17       	cp	r24, r18
     ec4:	93 07       	cpc	r25, r19
     ec6:	d9 f0       	breq	.+54     	; 0xefe <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     ec8:	2c 85       	ldd	r18, Y+12	; 0x0c
     eca:	3d 85       	ldd	r19, Y+13	; 0x0d
     ecc:	82 17       	cp	r24, r18
     ece:	93 07       	cpc	r25, r19
     ed0:	31 f4       	brne	.+12     	; 0xede <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     ed2:	17 c0       	rjmp	.+46     	; 0xf02 <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     ed4:	2c 85       	ldd	r18, Y+12	; 0x0c
     ed6:	3d 85       	ldd	r19, Y+13	; 0x0d
     ed8:	28 17       	cp	r18, r24
     eda:	39 07       	cpc	r19, r25
     edc:	99 f0       	breq	.+38     	; 0xf04 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     ede:	dc 01       	movw	r26, r24
     ee0:	ed 91       	ld	r30, X+
     ee2:	fc 91       	ld	r31, X
     ee4:	01 90       	ld	r0, Z+
     ee6:	f0 81       	ld	r31, Z
     ee8:	e0 2d       	mov	r30, r0
     eea:	b8 01       	movw	r22, r16
     eec:	19 95       	eicall
     eee:	8a 83       	std	Y+2, r24	; 0x02
     ef0:	9b 83       	std	Y+3, r25	; 0x03
     ef2:	2e 85       	ldd	r18, Y+14	; 0x0e
     ef4:	3f 85       	ldd	r19, Y+15	; 0x0f
     ef6:	28 17       	cp	r18, r24
     ef8:	39 07       	cpc	r19, r25
     efa:	61 f7       	brne	.-40     	; 0xed4 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     efc:	03 c0       	rjmp	.+6      	; 0xf04 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     efe:	c9 01       	movw	r24, r18
     f00:	01 c0       	rjmp	.+2      	; 0xf04 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f02:	c9 01       	movw	r24, r18
     f04:	dc 01       	movw	r26, r24
     f06:	ed 91       	ld	r30, X+
     f08:	fc 91       	ld	r31, X
     f0a:	01 90       	ld	r0, Z+
     f0c:	f0 81       	ld	r31, Z
     f0e:	e0 2d       	mov	r30, r0
     f10:	b8 01       	movw	r22, r16
     f12:	19 95       	eicall
     f14:	c8 01       	movw	r24, r16
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	1f 91       	pop	r17
     f1c:	0f 91       	pop	r16
     f1e:	08 95       	ret

00000f20 <_ZN9I2CMaster12set_baudrateEm>:
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	ec 01       	movw	r28, r24
     f26:	9a 01       	movw	r18, r20
     f28:	ab 01       	movw	r20, r22
     f2a:	22 0f       	add	r18, r18
     f2c:	33 1f       	adc	r19, r19
     f2e:	44 1f       	adc	r20, r20
     f30:	55 1f       	adc	r21, r21
     f32:	60 e0       	ldi	r22, 0x00	; 0
     f34:	78 e4       	ldi	r23, 0x48	; 72
     f36:	88 ee       	ldi	r24, 0xE8	; 232
     f38:	91 e0       	ldi	r25, 0x01	; 1
     f3a:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
     f3e:	25 50       	subi	r18, 0x05	; 5
     f40:	2a 87       	std	Y+10, r18	; 0x0a
     f42:	ec 81       	ldd	r30, Y+4	; 0x04
     f44:	fd 81       	ldd	r31, Y+5	; 0x05
     f46:	25 83       	std	Z+5, r18	; 0x05
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	08 95       	ret

00000f4e <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
     f4e:	ef 92       	push	r14
     f50:	ff 92       	push	r15
     f52:	0f 93       	push	r16
     f54:	1f 93       	push	r17
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
     f5a:	ec 01       	movw	r28, r24
     f5c:	7b 01       	movw	r14, r22
     f5e:	ba 01       	movw	r22, r20
     f60:	a9 01       	movw	r20, r18
     f62:	ec 82       	std	Y+4, r14	; 0x04
     f64:	fd 82       	std	Y+5, r15	; 0x05
     f66:	0e 83       	std	Y+6, r16	; 0x06
     f68:	1f 83       	std	Y+7, r17	; 0x07
     f6a:	4b 87       	std	Y+11, r20	; 0x0b
     f6c:	5c 87       	std	Y+12, r21	; 0x0c
     f6e:	6d 87       	std	Y+13, r22	; 0x0d
     f70:	7e 87       	std	Y+14, r23	; 0x0e
     f72:	80 e8       	ldi	r24, 0x80	; 128
     f74:	e8 16       	cp	r14, r24
     f76:	84 e0       	ldi	r24, 0x04	; 4
     f78:	f8 06       	cpc	r15, r24
     f7a:	29 f4       	brne	.+10     	; 0xf86 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
     f7c:	80 e4       	ldi	r24, 0x40	; 64
     f7e:	96 e0       	ldi	r25, 0x06	; 6
     f80:	88 87       	std	Y+8, r24	; 0x08
     f82:	99 87       	std	Y+9, r25	; 0x09
     f84:	09 c0       	rjmp	.+18     	; 0xf98 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     f86:	e0 ea       	ldi	r30, 0xA0	; 160
     f88:	ee 16       	cp	r14, r30
     f8a:	e4 e0       	ldi	r30, 0x04	; 4
     f8c:	fe 06       	cpc	r15, r30
     f8e:	21 f4       	brne	.+8      	; 0xf98 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     f90:	80 e8       	ldi	r24, 0x80	; 128
     f92:	96 e0       	ldi	r25, 0x06	; 6
     f94:	88 87       	std	Y+8, r24	; 0x08
     f96:	99 87       	std	Y+9, r25	; 0x09
     f98:	e8 85       	ldd	r30, Y+8	; 0x08
     f9a:	f9 85       	ldd	r31, Y+9	; 0x09
     f9c:	83 e0       	ldi	r24, 0x03	; 3
     f9e:	81 83       	std	Z+1, r24	; 0x01
     fa0:	e8 85       	ldd	r30, Y+8	; 0x08
     fa2:	f9 85       	ldd	r31, Y+9	; 0x09
     fa4:	88 e3       	ldi	r24, 0x38	; 56
     fa6:	80 8b       	std	Z+16, r24	; 0x10
     fa8:	e8 85       	ldd	r30, Y+8	; 0x08
     faa:	f9 85       	ldd	r31, Y+9	; 0x09
     fac:	81 8b       	std	Z+17, r24	; 0x11
     fae:	82 e0       	ldi	r24, 0x02	; 2
     fb0:	f7 01       	movw	r30, r14
     fb2:	82 83       	std	Z+2, r24	; 0x02
     fb4:	ce 01       	movw	r24, r28
     fb6:	0e 94 90 07 	call	0xf20	; 0xf20 <_ZN9I2CMaster12set_baudrateEm>
     fba:	f7 01       	movw	r30, r14
     fbc:	84 81       	ldd	r24, Z+4	; 0x04
     fbe:	8d 6c       	ori	r24, 0xCD	; 205
     fc0:	84 83       	std	Z+4, r24	; 0x04
     fc2:	88 e0       	ldi	r24, 0x08	; 8
     fc4:	81 83       	std	Z+1, r24	; 0x01
     fc6:	83 e1       	ldi	r24, 0x13	; 19
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     fce:	7c 01       	movw	r14, r24
     fd0:	be 01       	movw	r22, r28
     fd2:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <_ZN9I2CMaster11TransmitterC1EPS_>
     fd6:	e8 82       	st	Y, r14
     fd8:	f9 82       	std	Y+1, r15	; 0x01
     fda:	84 e1       	ldi	r24, 0x14	; 20
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
     fe2:	7c 01       	movw	r14, r24
     fe4:	be 01       	movw	r22, r28
     fe6:	0e 94 85 06 	call	0xd0a	; 0xd0a <_ZN9I2CMaster8ReceiverC1EPS_>
     fea:	ea 82       	std	Y+2, r14	; 0x02
     fec:	fb 82       	std	Y+3, r15	; 0x03
     fee:	0e 80       	ldd	r0, Y+6	; 0x06
     ff0:	df 81       	ldd	r29, Y+7	; 0x07
     ff2:	c0 2d       	mov	r28, r0
     ff4:	6f e6       	ldi	r22, 0x6F	; 111
     ff6:	70 e2       	ldi	r23, 0x20	; 32
     ff8:	ce 01       	movw	r24, r28
     ffa:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
     ffe:	66 e0       	ldi	r22, 0x06	; 6
    1000:	ce 01       	movw	r24, r28
    1002:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1006:	df 91       	pop	r29
    1008:	cf 91       	pop	r28
    100a:	1f 91       	pop	r17
    100c:	0f 91       	pop	r16
    100e:	ff 90       	pop	r15
    1010:	ef 90       	pop	r14
    1012:	08 95       	ret

00001014 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1014:	dc 01       	movw	r26, r24
    1016:	14 96       	adiw	r26, 0x04	; 4
    1018:	ed 91       	ld	r30, X+
    101a:	fc 91       	ld	r31, X
    101c:	15 97       	sbiw	r26, 0x05	; 5
    101e:	83 81       	ldd	r24, Z+3	; 0x03
    1020:	81 60       	ori	r24, 0x01	; 1
    1022:	83 83       	std	Z+3, r24	; 0x03
    1024:	08 95       	ret

00001026 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1026:	0f 93       	push	r16
    1028:	1f 93       	push	r17
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	ec 01       	movw	r28, r24
    1030:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    1032:	db 01       	movw	r26, r22
    1034:	ed 91       	ld	r30, X+
    1036:	fc 91       	ld	r31, X
    1038:	02 84       	ldd	r0, Z+10	; 0x0a
    103a:	f3 85       	ldd	r31, Z+11	; 0x0b
    103c:	e0 2d       	mov	r30, r0
    103e:	00 e0       	ldi	r16, 0x00	; 0
    1040:	10 e0       	ldi	r17, 0x00	; 0
    1042:	b8 01       	movw	r22, r16
    1044:	19 95       	eicall
  driver_->send_start();
    1046:	8f 81       	ldd	r24, Y+7	; 0x07
    1048:	98 85       	ldd	r25, Y+8	; 0x08
    104a:	0e 94 0a 08 	call	0x1014	; 0x1014 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    104e:	ef 81       	ldd	r30, Y+7	; 0x07
    1050:	f8 85       	ldd	r31, Y+8	; 0x08
    1052:	04 80       	ldd	r0, Z+4	; 0x04
    1054:	f5 81       	ldd	r31, Z+5	; 0x05
    1056:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1058:	d8 01       	movw	r26, r16
    105a:	8c 91       	ld	r24, X
    105c:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    105e:	8a 81       	ldd	r24, Y+2	; 0x02
    1060:	9b 81       	ldd	r25, Y+3	; 0x03
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	1f 91       	pop	r17
    1068:	0f 91       	pop	r16
    106a:	08 95       	ret

0000106c <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
		 */
		virtual bool ISR_butt_in (const data_type& item)
		{
			(void) item;                    // This just shuts up a compiler warning
			return (false);
		}
    106c:	db 01       	movw	r26, r22
    106e:	bc 01       	movw	r22, r24
    1070:	6e 5f       	subi	r22, 0xFE	; 254
    1072:	7f 4f       	sbci	r23, 0xFF	; 255
    1074:	ed 91       	ld	r30, X+
    1076:	fc 91       	ld	r31, X
    1078:	11 97       	sbiw	r26, 0x01	; 1
    107a:	01 90       	ld	r0, Z+
    107c:	f0 81       	ld	r31, Z
    107e:	e0 2d       	mov	r30, r0
    1080:	cd 01       	movw	r24, r26
    1082:	19 95       	eicall
    1084:	08 95       	ret

00001086 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    1086:	fc 01       	movw	r30, r24
    1088:	84 81       	ldd	r24, Z+4	; 0x04
    108a:	95 81       	ldd	r25, Z+5	; 0x05
    108c:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
		}
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	08 95       	ret

00001094 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    1094:	fc 01       	movw	r30, r24
    1096:	84 81       	ldd	r24, Z+4	; 0x04
    1098:	95 81       	ldd	r25, Z+5	; 0x05
    109a:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    109e:	91 e0       	ldi	r25, 0x01	; 1
    10a0:	81 11       	cpse	r24, r1
    10a2:	01 c0       	rjmp	.+2      	; 0x10a6 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    10a4:	90 e0       	ldi	r25, 0x00	; 0
		}
    10a6:	89 2f       	mov	r24, r25
    10a8:	08 95       	ret

000010aa <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    10aa:	fc 01       	movw	r30, r24
    10ac:	84 81       	ldd	r24, Z+4	; 0x04
    10ae:	95 81       	ldd	r25, Z+5	; 0x05
    10b0:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    10b4:	91 e0       	ldi	r25, 0x01	; 1
    10b6:	81 11       	cpse	r24, r1
    10b8:	90 e0       	ldi	r25, 0x00	; 0
		}
    10ba:	89 2f       	mov	r24, r25
    10bc:	08 95       	ret

000010be <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    10be:	fc 01       	movw	r30, r24
    10c0:	84 81       	ldd	r24, Z+4	; 0x04
    10c2:	95 81       	ldd	r25, Z+5	; 0x05
    10c4:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
		}
    10c8:	90 e0       	ldi	r25, 0x00	; 0
    10ca:	08 95       	ret

000010cc <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    10cc:	fc 01       	movw	r30, r24
    10ce:	84 81       	ldd	r24, Z+4	; 0x04
    10d0:	95 81       	ldd	r25, Z+5	; 0x05
    10d2:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    10d6:	91 e0       	ldi	r25, 0x01	; 1
    10d8:	81 11       	cpse	r24, r1
    10da:	01 c0       	rjmp	.+2      	; 0x10de <_ZN9frt_queueIhE9not_emptyEv+0x12>
    10dc:	90 e0       	ldi	r25, 0x00	; 0
		}
    10de:	89 2f       	mov	r24, r25
    10e0:	08 95       	ret

000010e2 <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    10e2:	fc 01       	movw	r30, r24
    10e4:	84 81       	ldd	r24, Z+4	; 0x04
    10e6:	95 81       	ldd	r25, Z+5	; 0x05
    10e8:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    10ec:	91 e0       	ldi	r25, 0x01	; 1
    10ee:	81 11       	cpse	r24, r1
    10f0:	90 e0       	ldi	r25, 0x00	; 0
		}
    10f2:	89 2f       	mov	r24, r25
    10f4:	08 95       	ret

000010f6 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    10f6:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    10f8:	01 e0       	ldi	r16, 0x01	; 1
    10fa:	2f ef       	ldi	r18, 0xFF	; 255
    10fc:	3f ef       	ldi	r19, 0xFF	; 255
    10fe:	a9 01       	movw	r20, r18
    1100:	fc 01       	movw	r30, r24
    1102:	84 81       	ldd	r24, Z+4	; 0x04
    1104:	95 81       	ldd	r25, Z+5	; 0x05
    1106:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    110a:	0f 91       	pop	r16
    110c:	08 95       	ret

0000110e <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    110e:	0f 93       	push	r16
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	1f 92       	push	r1
    1116:	cd b7       	in	r28, 0x3d	; 61
    1118:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    111a:	01 e0       	ldi	r16, 0x01	; 1
    111c:	2f ef       	ldi	r18, 0xFF	; 255
    111e:	3f ef       	ldi	r19, 0xFF	; 255
    1120:	a9 01       	movw	r20, r18
    1122:	be 01       	movw	r22, r28
    1124:	6f 5f       	subi	r22, 0xFF	; 255
    1126:	7f 4f       	sbci	r23, 0xFF	; 255
    1128:	fc 01       	movw	r30, r24
    112a:	84 81       	ldd	r24, Z+4	; 0x04
    112c:	95 81       	ldd	r25, Z+5	; 0x05
    112e:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    1132:	89 81       	ldd	r24, Y+1	; 0x01
    1134:	0f 90       	pop	r0
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	0f 91       	pop	r16
    113c:	08 95       	ret

0000113e <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    113e:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    1140:	00 e0       	ldi	r16, 0x00	; 0
    1142:	2f ef       	ldi	r18, 0xFF	; 255
    1144:	3f ef       	ldi	r19, 0xFF	; 255
    1146:	a9 01       	movw	r20, r18
    1148:	fc 01       	movw	r30, r24
    114a:	84 81       	ldd	r24, Z+4	; 0x04
    114c:	95 81       	ldd	r25, Z+5	; 0x05
    114e:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    1152:	0f 91       	pop	r16
    1154:	08 95       	ret

00001156 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    1156:	0f 93       	push	r16
    1158:	cf 93       	push	r28
    115a:	df 93       	push	r29
    115c:	1f 92       	push	r1
    115e:	cd b7       	in	r28, 0x3d	; 61
    1160:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    1162:	00 e0       	ldi	r16, 0x00	; 0
    1164:	2f ef       	ldi	r18, 0xFF	; 255
    1166:	3f ef       	ldi	r19, 0xFF	; 255
    1168:	a9 01       	movw	r20, r18
    116a:	be 01       	movw	r22, r28
    116c:	6f 5f       	subi	r22, 0xFF	; 255
    116e:	7f 4f       	sbci	r23, 0xFF	; 255
    1170:	fc 01       	movw	r30, r24
    1172:	84 81       	ldd	r24, Z+4	; 0x04
    1174:	95 81       	ldd	r25, Z+5	; 0x05
    1176:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	0f 90       	pop	r0
    117e:	df 91       	pop	r29
    1180:	cf 91       	pop	r28
    1182:	0f 91       	pop	r16
    1184:	08 95       	ret

00001186 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	1f 92       	push	r1
    118c:	cd b7       	in	r28, 0x3d	; 61
    118e:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    1190:	ae 01       	movw	r20, r28
    1192:	4f 5f       	subi	r20, 0xFF	; 255
    1194:	5f 4f       	sbci	r21, 0xFF	; 255
    1196:	fc 01       	movw	r30, r24
    1198:	84 81       	ldd	r24, Z+4	; 0x04
    119a:	95 81       	ldd	r25, Z+5	; 0x05
    119c:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
}
    11a0:	0f 90       	pop	r0
    11a2:	df 91       	pop	r29
    11a4:	cf 91       	pop	r28
    11a6:	08 95       	ret

000011a8 <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
    11ac:	1f 92       	push	r1
    11ae:	1f 92       	push	r1
    11b0:	cd b7       	in	r28, 0x3d	; 61
    11b2:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    11b4:	ae 01       	movw	r20, r28
    11b6:	4e 5f       	subi	r20, 0xFE	; 254
    11b8:	5f 4f       	sbci	r21, 0xFF	; 255
    11ba:	be 01       	movw	r22, r28
    11bc:	6f 5f       	subi	r22, 0xFF	; 255
    11be:	7f 4f       	sbci	r23, 0xFF	; 255
    11c0:	fc 01       	movw	r30, r24
    11c2:	84 81       	ldd	r24, Z+4	; 0x04
    11c4:	95 81       	ldd	r25, Z+5	; 0x05
    11c6:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
	return (recv_item);
}
    11ca:	89 81       	ldd	r24, Y+1	; 0x01
    11cc:	0f 90       	pop	r0
    11ce:	0f 90       	pop	r0
    11d0:	df 91       	pop	r29
    11d2:	cf 91       	pop	r28
    11d4:	08 95       	ret

000011d6 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    11d6:	cf 93       	push	r28
    11d8:	df 93       	push	r29
    11da:	1f 92       	push	r1
    11dc:	cd b7       	in	r28, 0x3d	; 61
    11de:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    11e0:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    11e2:	21 e0       	ldi	r18, 0x01	; 1
    11e4:	ae 01       	movw	r20, r28
    11e6:	4f 5f       	subi	r20, 0xFF	; 255
    11e8:	5f 4f       	sbci	r21, 0xFF	; 255
    11ea:	fc 01       	movw	r30, r24
    11ec:	84 81       	ldd	r24, Z+4	; 0x04
    11ee:	95 81       	ldd	r25, Z+5	; 0x05
    11f0:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    11f4:	91 e0       	ldi	r25, 0x01	; 1
    11f6:	81 11       	cpse	r24, r1
    11f8:	01 c0       	rjmp	.+2      	; 0x11fc <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    11fa:	90 e0       	ldi	r25, 0x00	; 0
}
    11fc:	89 2f       	mov	r24, r25
    11fe:	0f 90       	pop	r0
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	08 95       	ret

00001206 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    1206:	cf 93       	push	r28
    1208:	df 93       	push	r29
    120a:	1f 92       	push	r1
    120c:	cd b7       	in	r28, 0x3d	; 61
    120e:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    1210:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    1212:	20 e0       	ldi	r18, 0x00	; 0
    1214:	ae 01       	movw	r20, r28
    1216:	4f 5f       	subi	r20, 0xFF	; 255
    1218:	5f 4f       	sbci	r21, 0xFF	; 255
    121a:	fc 01       	movw	r30, r24
    121c:	84 81       	ldd	r24, Z+4	; 0x04
    121e:	95 81       	ldd	r25, Z+5	; 0x05
    1220:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1224:	91 e0       	ldi	r25, 0x01	; 1
    1226:	81 11       	cpse	r24, r1
    1228:	01 c0       	rjmp	.+2      	; 0x122c <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    122a:	90 e0       	ldi	r25, 0x00	; 0
}
    122c:	89 2f       	mov	r24, r25
    122e:	0f 90       	pop	r0
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	08 95       	ret

00001236 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    1236:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    1238:	fc 01       	movw	r30, r24
    123a:	26 81       	ldd	r18, Z+6	; 0x06
    123c:	37 81       	ldd	r19, Z+7	; 0x07
    123e:	40 85       	ldd	r20, Z+8	; 0x08
    1240:	51 85       	ldd	r21, Z+9	; 0x09
    1242:	01 e0       	ldi	r16, 0x01	; 1
    1244:	84 81       	ldd	r24, Z+4	; 0x04
    1246:	95 81       	ldd	r25, Z+5	; 0x05
    1248:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    124c:	91 e0       	ldi	r25, 0x01	; 1
    124e:	81 11       	cpse	r24, r1
    1250:	01 c0       	rjmp	.+2      	; 0x1254 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    1252:	90 e0       	ldi	r25, 0x00	; 0
		}
    1254:	89 2f       	mov	r24, r25
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    125a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    125c:	fc 01       	movw	r30, r24
    125e:	26 81       	ldd	r18, Z+6	; 0x06
    1260:	37 81       	ldd	r19, Z+7	; 0x07
    1262:	40 85       	ldd	r20, Z+8	; 0x08
    1264:	51 85       	ldd	r21, Z+9	; 0x09
    1266:	00 e0       	ldi	r16, 0x00	; 0
    1268:	84 81       	ldd	r24, Z+4	; 0x04
    126a:	95 81       	ldd	r25, Z+5	; 0x05
    126c:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    1270:	91 e0       	ldi	r25, 0x01	; 1
    1272:	81 11       	cpse	r24, r1
    1274:	01 c0       	rjmp	.+2      	; 0x1278 <_ZN9frt_queueIhE3putERKh+0x1e>
    1276:	90 e0       	ldi	r25, 0x00	; 0
		}
    1278:	89 2f       	mov	r24, r25
    127a:	0f 91       	pop	r16
    127c:	08 95       	ret

0000127e <_ZN6MB1202C1EP9I2CMasterP8emstream>:
//-------------------------------------------------------------------------------------
/** This constructor creates an object to use when interacting with the SPI registers on the MAX31855
    Thermocouple Analog to Digital Converter chip.
 *  @param SPIM A pointer to an SPI_master object
 */
MB1202::MB1202(I2CMaster * d, emstream * s)
    127e:	3f 92       	push	r3
    1280:	4f 92       	push	r4
    1282:	5f 92       	push	r5
    1284:	6f 92       	push	r6
    1286:	7f 92       	push	r7
    1288:	8f 92       	push	r8
    128a:	9f 92       	push	r9
    128c:	af 92       	push	r10
    128e:	bf 92       	push	r11
    1290:	cf 92       	push	r12
    1292:	df 92       	push	r13
    1294:	ef 92       	push	r14
    1296:	ff 92       	push	r15
    1298:	0f 93       	push	r16
    129a:	1f 93       	push	r17
    129c:	cf 93       	push	r28
    129e:	df 93       	push	r29
    12a0:	8c 01       	movw	r16, r24
    12a2:	7b 01       	movw	r14, r22
    12a4:	6a 01       	movw	r12, r20
  : driver_(d),
  	p_serial(s),
  	i2cAgent_(new I2CAgent(s, outPacketSize_, inPacketSize_)),
  	slaveAddr_(SLAVE_ADDR),
  	rangeCommand_(new RangeCommand())
    12a6:	dc 01       	movw	r26, r24
    12a8:	6d 93       	st	X+, r22
    12aa:	7c 93       	st	X, r23
    12ac:	11 97       	sbiw	r26, 0x01	; 1
    12ae:	12 96       	adiw	r26, 0x02	; 2
    12b0:	4d 93       	st	X+, r20
    12b2:	5c 93       	st	X, r21
    12b4:	13 97       	sbiw	r26, 0x03	; 3
    12b6:	81 e2       	ldi	r24, 0x21	; 33
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    12be:	ec 01       	movw	r28, r24
class CommAgent
{
public:
  CommAgent( uint8_t outPacketSize, uint8_t inPacketSize)
    : inPacket_(inPacketSize,NULL,10),
      outPacket_(outPacketSize,NULL,10)
    12c0:	89 e2       	ldi	r24, 0x29	; 41
    12c2:	91 e2       	ldi	r25, 0x21	; 33
    12c4:	88 83       	st	Y, r24
    12c6:	99 83       	std	Y+1, r25	; 0x01

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    12c8:	1c 82       	std	Y+4, r1	; 0x04
    12ca:	1d 82       	std	Y+5, r1	; 0x05
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    12cc:	0f 2e       	mov	r0, r31
    12ce:	f1 ee       	ldi	r31, 0xE1	; 225
    12d0:	af 2e       	mov	r10, r31
    12d2:	f0 e2       	ldi	r31, 0x20	; 32
    12d4:	bf 2e       	mov	r11, r31
    12d6:	f0 2d       	mov	r31, r0
    12d8:	aa 82       	std	Y+2, r10	; 0x02
    12da:	bb 82       	std	Y+3, r11	; 0x03
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    12dc:	40 e0       	ldi	r20, 0x00	; 0
    12de:	61 e0       	ldi	r22, 0x01	; 1
    12e0:	82 e0       	ldi	r24, 0x02	; 2
    12e2:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    12e6:	8e 83       	std	Y+6, r24	; 0x06
    12e8:	9f 83       	std	Y+7, r25	; 0x07

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    12ea:	0f 2e       	mov	r0, r31
    12ec:	fa e0       	ldi	r31, 0x0A	; 10
    12ee:	4f 2e       	mov	r4, r31
    12f0:	51 2c       	mov	r5, r1
    12f2:	61 2c       	mov	r6, r1
    12f4:	71 2c       	mov	r7, r1
    12f6:	f0 2d       	mov	r31, r0
    12f8:	48 86       	std	Y+8, r4	; 0x08
    12fa:	59 86       	std	Y+9, r5	; 0x09
    12fc:	6a 86       	std	Y+10, r6	; 0x0a
    12fe:	7b 86       	std	Y+11, r7	; 0x0b
  : public frt_queue< uint8_t >
{
public:
  inline Packet( uint8_t queue_size = 10, emstream * p_ser_dev = NULL, portTickType wait_time = 10 )
    : frt_queue(queue_size, p_ser_dev, wait_time),
      size_(queue_size)
    1300:	0f 2e       	mov	r0, r31
    1302:	f5 e0       	ldi	r31, 0x05	; 5
    1304:	8f 2e       	mov	r8, r31
    1306:	f1 e2       	ldi	r31, 0x21	; 33
    1308:	9f 2e       	mov	r9, r31
    130a:	f0 2d       	mov	r31, r0
    130c:	8a 82       	std	Y+2, r8	; 0x02
    130e:	9b 82       	std	Y+3, r9	; 0x03
    1310:	68 94       	set
    1312:	33 24       	eor	r3, r3
    1314:	31 f8       	bld	r3, 1
    1316:	3c 86       	std	Y+12, r3	; 0x0c
    1318:	18 8a       	std	Y+16, r1	; 0x10
    131a:	19 8a       	std	Y+17, r1	; 0x11
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    131c:	ae 86       	std	Y+14, r10	; 0x0e
    131e:	bf 86       	std	Y+15, r11	; 0x0f
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    1320:	40 e0       	ldi	r20, 0x00	; 0
    1322:	61 e0       	ldi	r22, 0x01	; 1
    1324:	82 e0       	ldi	r24, 0x02	; 2
    1326:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    132a:	8a 8b       	std	Y+18, r24	; 0x12
    132c:	9b 8b       	std	Y+19, r25	; 0x13

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    132e:	4c 8a       	std	Y+20, r4	; 0x14
    1330:	5d 8a       	std	Y+21, r5	; 0x15
    1332:	6e 8a       	std	Y+22, r6	; 0x16
    1334:	7f 8a       	std	Y+23, r7	; 0x17
    1336:	8e 86       	std	Y+14, r8	; 0x0e
    1338:	9f 86       	std	Y+15, r9	; 0x0f
    133a:	38 8e       	std	Y+24, r3	; 0x18
  inline I2CAgent( uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize)
  {}
  inline I2CAgent( emstream * s, uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize),
      p_serial(s)
    133c:	8a e0       	ldi	r24, 0x0A	; 10
    133e:	90 e2       	ldi	r25, 0x20	; 32
    1340:	88 83       	st	Y, r24
    1342:	99 83       	std	Y+1, r25	; 0x01
    1344:	ca 8e       	std	Y+26, r12	; 0x1a
    1346:	db 8e       	std	Y+27, r13	; 0x1b
    1348:	f8 01       	movw	r30, r16
    134a:	c4 83       	std	Z+4, r28	; 0x04
    134c:	d5 83       	std	Z+5, r29	; 0x05
    134e:	80 e7       	ldi	r24, 0x70	; 112
    1350:	86 83       	std	Z+6, r24	; 0x06
    1352:	10 86       	std	Z+8, r1	; 0x08
    1354:	11 86       	std	Z+9, r1	; 0x09
    1356:	12 86       	std	Z+10, r1	; 0x0a
    1358:	13 86       	std	Z+11, r1	; 0x0b
    135a:	14 86       	std	Z+12, r1	; 0x0c
    135c:	83 e0       	ldi	r24, 0x03	; 3
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
		: public Command
	{
	public:
		typedef frt_queue< uint8_t > Packet;
		inline RangeCommand()
			: commandCode_(RANGE_CMD)
    1364:	27 e3       	ldi	r18, 0x37	; 55
    1366:	31 e2       	ldi	r19, 0x21	; 33
    1368:	fc 01       	movw	r30, r24
    136a:	20 83       	st	Z, r18
    136c:	31 83       	std	Z+1, r19	; 0x01
    136e:	21 e5       	ldi	r18, 0x51	; 81
    1370:	22 83       	std	Z+2, r18	; 0x02
    1372:	d8 01       	movw	r26, r16
    1374:	1f 96       	adiw	r26, 0x0f	; 15
    1376:	8d 93       	st	X+, r24
    1378:	9c 93       	st	X, r25
    137a:	50 97       	sbiw	r26, 0x10	; 16
{
	i2cAgent_->setI2CDriver(d);
    137c:	14 96       	adiw	r26, 0x04	; 4
    137e:	ed 91       	ld	r30, X+
    1380:	fc 91       	ld	r31, X
    1382:	15 97       	sbiw	r26, 0x05	; 5
  {}
  virtual bool transmit( Command & cmd );
  virtual Packet & receive();
  void setI2CDriver( I2CMaster * d ) { driver_ = d; }
    1384:	e4 8e       	std	Z+28, r14	; 0x1c
    1386:	f5 8e       	std	Z+29, r15	; 0x1d
	i2cAgent_->setSlaveAddr(slaveAddr_);
    1388:	16 96       	adiw	r26, 0x06	; 6
    138a:	6c 91       	ld	r22, X
    138c:	16 97       	sbiw	r26, 0x06	; 6
    138e:	14 96       	adiw	r26, 0x04	; 4
    1390:	8d 91       	ld	r24, X+
    1392:	9c 91       	ld	r25, X
    1394:	15 97       	sbiw	r26, 0x05	; 5
    1396:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
}
    139a:	df 91       	pop	r29
    139c:	cf 91       	pop	r28
    139e:	1f 91       	pop	r17
    13a0:	0f 91       	pop	r16
    13a2:	ff 90       	pop	r15
    13a4:	ef 90       	pop	r14
    13a6:	df 90       	pop	r13
    13a8:	cf 90       	pop	r12
    13aa:	bf 90       	pop	r11
    13ac:	af 90       	pop	r10
    13ae:	9f 90       	pop	r9
    13b0:	8f 90       	pop	r8
    13b2:	7f 90       	pop	r7
    13b4:	6f 90       	pop	r6
    13b6:	5f 90       	pop	r5
    13b8:	4f 90       	pop	r4
    13ba:	3f 90       	pop	r3
    13bc:	08 95       	ret

000013be <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::is_ready()
{
  return driver_->is_ready(slaveAddr_);
}
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	cf 93       	push	r28
    13c4:	df 93       	push	r29
    13c6:	8c 01       	movw	r16, r24
    13c8:	eb 01       	movw	r28, r22
    13ca:	bc 01       	movw	r22, r24
    13cc:	6e 5f       	subi	r22, 0xFE	; 254
    13ce:	7f 4f       	sbci	r23, 0xFF	; 255
    13d0:	e8 81       	ld	r30, Y
    13d2:	f9 81       	ldd	r31, Y+1	; 0x01
    13d4:	01 90       	ld	r0, Z+
    13d6:	f0 81       	ld	r31, Z
    13d8:	e0 2d       	mov	r30, r0
    13da:	ce 01       	movw	r24, r28
    13dc:	19 95       	eicall
    13de:	b8 01       	movw	r22, r16
    13e0:	6d 5f       	subi	r22, 0xFD	; 253
    13e2:	7f 4f       	sbci	r23, 0xFF	; 255
    13e4:	e8 81       	ld	r30, Y
    13e6:	f9 81       	ldd	r31, Y+1	; 0x01
    13e8:	01 90       	ld	r0, Z+
    13ea:	f0 81       	ld	r31, Z
    13ec:	e0 2d       	mov	r30, r0
    13ee:	ce 01       	movw	r24, r28
    13f0:	19 95       	eicall
    13f2:	df 91       	pop	r29
    13f4:	cf 91       	pop	r28
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	08 95       	ret

000013fc <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    13fc:	db 01       	movw	r26, r22
    13fe:	bc 01       	movw	r22, r24
    1400:	6e 5f       	subi	r22, 0xFE	; 254
    1402:	7f 4f       	sbci	r23, 0xFF	; 255
    1404:	ed 91       	ld	r30, X+
    1406:	fc 91       	ld	r31, X
    1408:	11 97       	sbiw	r26, 0x01	; 1
    140a:	01 90       	ld	r0, Z+
    140c:	f0 81       	ld	r31, Z
    140e:	e0 2d       	mov	r30, r0
    1410:	cd 01       	movw	r24, r26
    1412:	19 95       	eicall
    1414:	08 95       	ret

00001416 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    1416:	db 01       	movw	r26, r22
    1418:	bc 01       	movw	r22, r24
    141a:	6e 5f       	subi	r22, 0xFE	; 254
    141c:	7f 4f       	sbci	r23, 0xFF	; 255
    141e:	ed 91       	ld	r30, X+
    1420:	fc 91       	ld	r31, X
    1422:	11 97       	sbiw	r26, 0x01	; 1
    1424:	01 90       	ld	r0, Z+
    1426:	f0 81       	ld	r31, Z
    1428:	e0 2d       	mov	r30, r0
    142a:	cd 01       	movw	r24, r26
    142c:	19 95       	eicall
    142e:	08 95       	ret

00001430 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    1430:	db 01       	movw	r26, r22
    1432:	bc 01       	movw	r22, r24
    1434:	6e 5f       	subi	r22, 0xFE	; 254
    1436:	7f 4f       	sbci	r23, 0xFF	; 255
    1438:	ed 91       	ld	r30, X+
    143a:	fc 91       	ld	r31, X
    143c:	11 97       	sbiw	r26, 0x01	; 1
    143e:	01 90       	ld	r0, Z+
    1440:	f0 81       	ld	r31, Z
    1442:	e0 2d       	mov	r30, r0
    1444:	cd 01       	movw	r24, r26
    1446:	19 95       	eicall
    1448:	08 95       	ret

0000144a <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    144a:	4f 92       	push	r4
    144c:	5f 92       	push	r5
    144e:	6f 92       	push	r6
    1450:	7f 92       	push	r7
    1452:	8f 92       	push	r8
    1454:	9f 92       	push	r9
    1456:	af 92       	push	r10
    1458:	bf 92       	push	r11
    145a:	cf 92       	push	r12
    145c:	df 92       	push	r13
    145e:	ef 92       	push	r14
    1460:	ff 92       	push	r15
    1462:	0f 93       	push	r16
    1464:	1f 93       	push	r17
    1466:	cf 93       	push	r28
    1468:	df 93       	push	r29
    146a:	8c 01       	movw	r16, r24
    146c:	7b 01       	movw	r14, r22
    146e:	6a 01       	movw	r12, r20
    1470:	dc 01       	movw	r26, r24
    1472:	6d 93       	st	X+, r22
    1474:	7c 93       	st	X, r23
    1476:	11 97       	sbiw	r26, 0x01	; 1
    1478:	12 96       	adiw	r26, 0x02	; 2
    147a:	4d 93       	st	X+, r20
    147c:	5c 93       	st	X, r21
    147e:	13 97       	sbiw	r26, 0x03	; 3
    1480:	81 e2       	ldi	r24, 0x21	; 33
    1482:	90 e0       	ldi	r25, 0x00	; 0
    1484:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    1488:	ec 01       	movw	r28, r24
    148a:	89 e2       	ldi	r24, 0x29	; 41
    148c:	91 e2       	ldi	r25, 0x21	; 33
    148e:	88 83       	st	Y, r24
    1490:	99 83       	std	Y+1, r25	; 0x01
    1492:	1c 82       	std	Y+4, r1	; 0x04
    1494:	1d 82       	std	Y+5, r1	; 0x05
    1496:	0f 2e       	mov	r0, r31
    1498:	f1 ee       	ldi	r31, 0xE1	; 225
    149a:	af 2e       	mov	r10, r31
    149c:	f0 e2       	ldi	r31, 0x20	; 32
    149e:	bf 2e       	mov	r11, r31
    14a0:	f0 2d       	mov	r31, r0
    14a2:	aa 82       	std	Y+2, r10	; 0x02
    14a4:	bb 82       	std	Y+3, r11	; 0x03
    14a6:	40 e0       	ldi	r20, 0x00	; 0
    14a8:	61 e0       	ldi	r22, 0x01	; 1
    14aa:	82 e0       	ldi	r24, 0x02	; 2
    14ac:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    14b0:	8e 83       	std	Y+6, r24	; 0x06
    14b2:	9f 83       	std	Y+7, r25	; 0x07
    14b4:	0f 2e       	mov	r0, r31
    14b6:	fa e0       	ldi	r31, 0x0A	; 10
    14b8:	4f 2e       	mov	r4, r31
    14ba:	51 2c       	mov	r5, r1
    14bc:	61 2c       	mov	r6, r1
    14be:	71 2c       	mov	r7, r1
    14c0:	f0 2d       	mov	r31, r0
    14c2:	48 86       	std	Y+8, r4	; 0x08
    14c4:	59 86       	std	Y+9, r5	; 0x09
    14c6:	6a 86       	std	Y+10, r6	; 0x0a
    14c8:	7b 86       	std	Y+11, r7	; 0x0b
    14ca:	0f 2e       	mov	r0, r31
    14cc:	f5 e0       	ldi	r31, 0x05	; 5
    14ce:	8f 2e       	mov	r8, r31
    14d0:	f1 e2       	ldi	r31, 0x21	; 33
    14d2:	9f 2e       	mov	r9, r31
    14d4:	f0 2d       	mov	r31, r0
    14d6:	8a 82       	std	Y+2, r8	; 0x02
    14d8:	9b 82       	std	Y+3, r9	; 0x03
    14da:	82 e0       	ldi	r24, 0x02	; 2
    14dc:	8c 87       	std	Y+12, r24	; 0x0c
    14de:	18 8a       	std	Y+16, r1	; 0x10
    14e0:	19 8a       	std	Y+17, r1	; 0x11
    14e2:	ae 86       	std	Y+14, r10	; 0x0e
    14e4:	bf 86       	std	Y+15, r11	; 0x0f
    14e6:	40 e0       	ldi	r20, 0x00	; 0
    14e8:	61 e0       	ldi	r22, 0x01	; 1
    14ea:	83 e0       	ldi	r24, 0x03	; 3
    14ec:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    14f0:	8a 8b       	std	Y+18, r24	; 0x12
    14f2:	9b 8b       	std	Y+19, r25	; 0x13
    14f4:	4c 8a       	std	Y+20, r4	; 0x14
    14f6:	5d 8a       	std	Y+21, r5	; 0x15
    14f8:	6e 8a       	std	Y+22, r6	; 0x16
    14fa:	7f 8a       	std	Y+23, r7	; 0x17
    14fc:	8e 86       	std	Y+14, r8	; 0x0e
    14fe:	9f 86       	std	Y+15, r9	; 0x0f
    1500:	0f 2e       	mov	r0, r31
    1502:	f3 e0       	ldi	r31, 0x03	; 3
    1504:	bf 2e       	mov	r11, r31
    1506:	f0 2d       	mov	r31, r0
    1508:	b8 8e       	std	Y+24, r11	; 0x18
    150a:	8a e0       	ldi	r24, 0x0A	; 10
    150c:	90 e2       	ldi	r25, 0x20	; 32
    150e:	88 83       	st	Y, r24
    1510:	99 83       	std	Y+1, r25	; 0x01
    1512:	ca 8e       	std	Y+26, r12	; 0x1a
    1514:	db 8e       	std	Y+27, r13	; 0x1b
    1516:	f8 01       	movw	r30, r16
    1518:	c4 83       	std	Z+4, r28	; 0x04
    151a:	d5 83       	std	Z+5, r29	; 0x05
    151c:	86 e0       	ldi	r24, 0x06	; 6
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    1524:	fc 01       	movw	r30, r24
    1526:	10 82       	st	Z, r1
    1528:	11 82       	std	Z+1, r1	; 0x01
    152a:	12 82       	std	Z+2, r1	; 0x02
    152c:	13 82       	std	Z+3, r1	; 0x03
    152e:	14 82       	std	Z+4, r1	; 0x04
    1530:	15 82       	std	Z+5, r1	; 0x05
    1532:	d8 01       	movw	r26, r16
    1534:	16 96       	adiw	r26, 0x06	; 6
    1536:	8d 93       	st	X+, r24
    1538:	9c 93       	st	X, r25
    153a:	17 97       	sbiw	r26, 0x07	; 7
    153c:	8d e1       	ldi	r24, 0x1D	; 29
    153e:	18 96       	adiw	r26, 0x08	; 8
    1540:	8c 93       	st	X, r24
    1542:	84 e0       	ldi	r24, 0x04	; 4
    1544:	90 e0       	ldi	r25, 0x00	; 0
    1546:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    154a:	fc 01       	movw	r30, r24
    154c:	8d e3       	ldi	r24, 0x3D	; 61
    154e:	91 e2       	ldi	r25, 0x21	; 33
    1550:	80 83       	st	Z, r24
    1552:	91 83       	std	Z+1, r25	; 0x01
    1554:	8a e2       	ldi	r24, 0x2A	; 42
    1556:	82 83       	std	Z+2, r24	; 0x02
    1558:	c1 e0       	ldi	r28, 0x01	; 1
    155a:	c3 83       	std	Z+3, r28	; 0x03
    155c:	d8 01       	movw	r26, r16
    155e:	1b 96       	adiw	r26, 0x0b	; 11
    1560:	ed 93       	st	X+, r30
    1562:	fc 93       	st	X, r31
    1564:	1c 97       	sbiw	r26, 0x0c	; 12
    1566:	83 e0       	ldi	r24, 0x03	; 3
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    156e:	23 e4       	ldi	r18, 0x43	; 67
    1570:	31 e2       	ldi	r19, 0x21	; 33
    1572:	fc 01       	movw	r30, r24
    1574:	20 83       	st	Z, r18
    1576:	31 83       	std	Z+1, r19	; 0x01
    1578:	c2 83       	std	Z+2, r28	; 0x02
    157a:	d8 01       	movw	r26, r16
    157c:	1d 96       	adiw	r26, 0x0d	; 13
    157e:	8d 93       	st	X+, r24
    1580:	9c 93       	st	X, r25
    1582:	1e 97       	sbiw	r26, 0x0e	; 14
    1584:	83 e0       	ldi	r24, 0x03	; 3
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    158c:	29 e4       	ldi	r18, 0x49	; 73
    158e:	31 e2       	ldi	r19, 0x21	; 33
    1590:	fc 01       	movw	r30, r24
    1592:	20 83       	st	Z, r18
    1594:	31 83       	std	Z+1, r19	; 0x01
    1596:	b2 82       	std	Z+2, r11	; 0x02
    1598:	d8 01       	movw	r26, r16
    159a:	1f 96       	adiw	r26, 0x0f	; 15
    159c:	8d 93       	st	X+, r24
    159e:	9c 93       	st	X, r25
    15a0:	50 97       	sbiw	r26, 0x10	; 16
    15a2:	83 e0       	ldi	r24, 0x03	; 3
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    15aa:	2f e4       	ldi	r18, 0x4F	; 79
    15ac:	31 e2       	ldi	r19, 0x21	; 33
    15ae:	fc 01       	movw	r30, r24
    15b0:	20 83       	st	Z, r18
    15b2:	31 83       	std	Z+1, r19	; 0x01
    15b4:	25 e0       	ldi	r18, 0x05	; 5
    15b6:	22 83       	std	Z+2, r18	; 0x02
    15b8:	d8 01       	movw	r26, r16
    15ba:	51 96       	adiw	r26, 0x11	; 17
    15bc:	8d 93       	st	X+, r24
    15be:	9c 93       	st	X, r25
    15c0:	52 97       	sbiw	r26, 0x12	; 18
    15c2:	14 96       	adiw	r26, 0x04	; 4
    15c4:	ed 91       	ld	r30, X+
    15c6:	fc 91       	ld	r31, X
    15c8:	15 97       	sbiw	r26, 0x05	; 5
    15ca:	e4 8e       	std	Z+28, r14	; 0x1c
    15cc:	f5 8e       	std	Z+29, r15	; 0x1d
    15ce:	18 96       	adiw	r26, 0x08	; 8
    15d0:	6c 91       	ld	r22, X
    15d2:	18 97       	sbiw	r26, 0x08	; 8
    15d4:	14 96       	adiw	r26, 0x04	; 4
    15d6:	8d 91       	ld	r24, X+
    15d8:	9c 91       	ld	r25, X
    15da:	15 97       	sbiw	r26, 0x05	; 5
    15dc:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	ff 90       	pop	r15
    15ea:	ef 90       	pop	r14
    15ec:	df 90       	pop	r13
    15ee:	cf 90       	pop	r12
    15f0:	bf 90       	pop	r11
    15f2:	af 90       	pop	r10
    15f4:	9f 90       	pop	r9
    15f6:	8f 90       	pop	r8
    15f8:	7f 90       	pop	r7
    15fa:	6f 90       	pop	r6
    15fc:	5f 90       	pop	r5
    15fe:	4f 90       	pop	r4
    1600:	08 95       	ret

00001602 <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    1602:	1f 93       	push	r17
    1604:	cf 93       	push	r28
    1606:	df 93       	push	r29
    1608:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    160a:	8c 81       	ldd	r24, Y+4	; 0x04
    160c:	9d 81       	ldd	r25, Y+5	; 0x05
    160e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1610:	7c 85       	ldd	r23, Y+12	; 0x0c
    1612:	dc 01       	movw	r26, r24
    1614:	ed 91       	ld	r30, X+
    1616:	fc 91       	ld	r31, X
    1618:	01 90       	ld	r0, Z+
    161a:	f0 81       	ld	r31, Z
    161c:	e0 2d       	mov	r30, r0
    161e:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    1620:	8c 81       	ldd	r24, Y+4	; 0x04
    1622:	9d 81       	ldd	r25, Y+5	; 0x05
    1624:	6d 85       	ldd	r22, Y+13	; 0x0d
    1626:	7e 85       	ldd	r23, Y+14	; 0x0e
    1628:	dc 01       	movw	r26, r24
    162a:	ed 91       	ld	r30, X+
    162c:	fc 91       	ld	r31, X
    162e:	01 90       	ld	r0, Z+
    1630:	f0 81       	ld	r31, Z
    1632:	e0 2d       	mov	r30, r0
    1634:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    1636:	8c 81       	ldd	r24, Y+4	; 0x04
    1638:	9d 81       	ldd	r25, Y+5	; 0x05
    163a:	dc 01       	movw	r26, r24
    163c:	ed 91       	ld	r30, X+
    163e:	fc 91       	ld	r31, X
    1640:	02 80       	ldd	r0, Z+2	; 0x02
    1642:	f3 81       	ldd	r31, Z+3	; 0x03
    1644:	e0 2d       	mov	r30, r0
    1646:	19 95       	eicall
    1648:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    164a:	8b 85       	ldd	r24, Y+11	; 0x0b
    164c:	88 23       	and	r24, r24
    164e:	b9 f0       	breq	.+46     	; 0x167e <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    1650:	e8 81       	ld	r30, Y
    1652:	f9 81       	ldd	r31, Y+1	; 0x01
    1654:	00 84       	ldd	r0, Z+8	; 0x08
    1656:	f1 85       	ldd	r31, Z+9	; 0x09
    1658:	e0 2d       	mov	r30, r0
    165a:	ce 01       	movw	r24, r28
    165c:	19 95       	eicall
    165e:	18 2f       	mov	r17, r24
    1660:	e8 81       	ld	r30, Y
    1662:	f9 81       	ldd	r31, Y+1	; 0x01
    1664:	00 84       	ldd	r0, Z+8	; 0x08
    1666:	f1 85       	ldd	r31, Z+9	; 0x09
    1668:	e0 2d       	mov	r30, r0
    166a:	ce 01       	movw	r24, r28
    166c:	19 95       	eicall
    166e:	21 2f       	mov	r18, r17
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	32 2f       	mov	r19, r18
    1674:	22 27       	eor	r18, r18
    1676:	a9 01       	movw	r20, r18
    1678:	48 2b       	or	r20, r24
    167a:	ca 01       	movw	r24, r20
    167c:	02 c0       	rjmp	.+4      	; 0x1682 <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	1f 91       	pop	r17
    1688:	08 95       	ret

0000168a <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    168a:	1f 93       	push	r17
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1692:	8c 81       	ldd	r24, Y+4	; 0x04
    1694:	9d 81       	ldd	r25, Y+5	; 0x05
    1696:	6b 85       	ldd	r22, Y+11	; 0x0b
    1698:	7c 85       	ldd	r23, Y+12	; 0x0c
    169a:	dc 01       	movw	r26, r24
    169c:	ed 91       	ld	r30, X+
    169e:	fc 91       	ld	r31, X
    16a0:	01 90       	ld	r0, Z+
    16a2:	f0 81       	ld	r31, Z
    16a4:	e0 2d       	mov	r30, r0
    16a6:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    16a8:	8c 81       	ldd	r24, Y+4	; 0x04
    16aa:	9d 81       	ldd	r25, Y+5	; 0x05
    16ac:	6f 85       	ldd	r22, Y+15	; 0x0f
    16ae:	78 89       	ldd	r23, Y+16	; 0x10
    16b0:	dc 01       	movw	r26, r24
    16b2:	ed 91       	ld	r30, X+
    16b4:	fc 91       	ld	r31, X
    16b6:	01 90       	ld	r0, Z+
    16b8:	f0 81       	ld	r31, Z
    16ba:	e0 2d       	mov	r30, r0
    16bc:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    16be:	8c 81       	ldd	r24, Y+4	; 0x04
    16c0:	9d 81       	ldd	r25, Y+5	; 0x05
    16c2:	dc 01       	movw	r26, r24
    16c4:	ed 91       	ld	r30, X+
    16c6:	fc 91       	ld	r31, X
    16c8:	02 80       	ldd	r0, Z+2	; 0x02
    16ca:	f3 81       	ldd	r31, Z+3	; 0x03
    16cc:	e0 2d       	mov	r30, r0
    16ce:	19 95       	eicall
    16d0:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    16d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    16d4:	88 23       	and	r24, r24
    16d6:	b9 f0       	breq	.+46     	; 0x1706 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    16d8:	e8 81       	ld	r30, Y
    16da:	f9 81       	ldd	r31, Y+1	; 0x01
    16dc:	00 84       	ldd	r0, Z+8	; 0x08
    16de:	f1 85       	ldd	r31, Z+9	; 0x09
    16e0:	e0 2d       	mov	r30, r0
    16e2:	ce 01       	movw	r24, r28
    16e4:	19 95       	eicall
    16e6:	18 2f       	mov	r17, r24
    16e8:	e8 81       	ld	r30, Y
    16ea:	f9 81       	ldd	r31, Y+1	; 0x01
    16ec:	00 84       	ldd	r0, Z+8	; 0x08
    16ee:	f1 85       	ldd	r31, Z+9	; 0x09
    16f0:	e0 2d       	mov	r30, r0
    16f2:	ce 01       	movw	r24, r28
    16f4:	19 95       	eicall
    16f6:	21 2f       	mov	r18, r17
    16f8:	30 e0       	ldi	r19, 0x00	; 0
    16fa:	32 2f       	mov	r19, r18
    16fc:	22 27       	eor	r18, r18
    16fe:	a9 01       	movw	r20, r18
    1700:	48 2b       	or	r20, r24
    1702:	ca 01       	movw	r24, r20
    1704:	02 c0       	rjmp	.+4      	; 0x170a <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    1706:	80 e0       	ldi	r24, 0x00	; 0
    1708:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	1f 91       	pop	r17
    1710:	08 95       	ret

00001712 <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    171a:	8c 81       	ldd	r24, Y+4	; 0x04
    171c:	9d 81       	ldd	r25, Y+5	; 0x05
    171e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1720:	7c 85       	ldd	r23, Y+12	; 0x0c
    1722:	dc 01       	movw	r26, r24
    1724:	ed 91       	ld	r30, X+
    1726:	fc 91       	ld	r31, X
    1728:	01 90       	ld	r0, Z+
    172a:	f0 81       	ld	r31, Z
    172c:	e0 2d       	mov	r30, r0
    172e:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    1730:	8c 81       	ldd	r24, Y+4	; 0x04
    1732:	9d 81       	ldd	r25, Y+5	; 0x05
    1734:	69 89       	ldd	r22, Y+17	; 0x11
    1736:	7a 89       	ldd	r23, Y+18	; 0x12
    1738:	dc 01       	movw	r26, r24
    173a:	ed 91       	ld	r30, X+
    173c:	fc 91       	ld	r31, X
    173e:	01 90       	ld	r0, Z+
    1740:	f0 81       	ld	r31, Z
    1742:	e0 2d       	mov	r30, r0
    1744:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    1746:	8c 81       	ldd	r24, Y+4	; 0x04
    1748:	9d 81       	ldd	r25, Y+5	; 0x05
    174a:	dc 01       	movw	r26, r24
    174c:	ed 91       	ld	r30, X+
    174e:	fc 91       	ld	r31, X
    1750:	02 80       	ldd	r0, Z+2	; 0x02
    1752:	f3 81       	ldd	r31, Z+3	; 0x03
    1754:	e0 2d       	mov	r30, r0
    1756:	19 95       	eicall
    1758:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    175a:	8b 85       	ldd	r24, Y+11	; 0x0b
    175c:	88 23       	and	r24, r24
    175e:	b9 f0       	breq	.+46     	; 0x178e <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    1760:	e8 81       	ld	r30, Y
    1762:	f9 81       	ldd	r31, Y+1	; 0x01
    1764:	00 84       	ldd	r0, Z+8	; 0x08
    1766:	f1 85       	ldd	r31, Z+9	; 0x09
    1768:	e0 2d       	mov	r30, r0
    176a:	ce 01       	movw	r24, r28
    176c:	19 95       	eicall
    176e:	18 2f       	mov	r17, r24
    1770:	e8 81       	ld	r30, Y
    1772:	f9 81       	ldd	r31, Y+1	; 0x01
    1774:	00 84       	ldd	r0, Z+8	; 0x08
    1776:	f1 85       	ldd	r31, Z+9	; 0x09
    1778:	e0 2d       	mov	r30, r0
    177a:	ce 01       	movw	r24, r28
    177c:	19 95       	eicall
    177e:	21 2f       	mov	r18, r17
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	32 2f       	mov	r19, r18
    1784:	22 27       	eor	r18, r18
    1786:	a9 01       	movw	r20, r18
    1788:	48 2b       	or	r20, r24
    178a:	ca 01       	movw	r24, r20
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	1f 91       	pop	r17
    1798:	08 95       	ret

0000179a <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    179a:	cf 93       	push	r28
    179c:	df 93       	push	r29
    179e:	ec 01       	movw	r28, r24
  success_ = false;
    17a0:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    17a2:	e8 81       	ld	r30, Y
    17a4:	f9 81       	ldd	r31, Y+1	; 0x01
    17a6:	00 8c       	ldd	r0, Z+24	; 0x18
    17a8:	f1 8d       	ldd	r31, Z+25	; 0x19
    17aa:	e0 2d       	mov	r30, r0
    17ac:	ce 01       	movw	r24, r28
    17ae:	19 95       	eicall
    17b0:	88 23       	and	r24, r24
    17b2:	41 f0       	breq	.+16     	; 0x17c4 <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    17b4:	e8 81       	ld	r30, Y
    17b6:	f9 81       	ldd	r31, Y+1	; 0x01
    17b8:	00 84       	ldd	r0, Z+8	; 0x08
    17ba:	f1 85       	ldd	r31, Z+9	; 0x09
    17bc:	e0 2d       	mov	r30, r0
    17be:	ce 01       	movw	r24, r28
    17c0:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    17c2:	ef cf       	rjmp	.-34     	; 0x17a2 <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    17c4:	df 91       	pop	r29
    17c6:	cf 91       	pop	r28
    17c8:	08 95       	ret

000017ca <_ZN11task_sensor3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sensor::run (void)
{
    17ca:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    17cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    17ce:	81 11       	cpse	r24, r1
    17d0:	39 c0       	rjmp	.+114    	; 0x1844 <_ZN11task_sensor3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    17d2:	8c 89       	ldd	r24, Y+20	; 0x14
    17d4:	9d 89       	ldd	r25, Y+21	; 0x15
    17d6:	0e 94 01 0b 	call	0x1602	; 0x1602 <_ZN7MMA845111getXReadingEv>
    17da:	7c 01       	movw	r14, r24
    17dc:	0e 81       	ldd	r16, Y+6	; 0x06
    17de:	1f 81       	ldd	r17, Y+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    17e0:	61 e5       	ldi	r22, 0x51	; 81
    17e2:	71 e2       	ldi	r23, 0x21	; 33
    17e4:	c8 01       	movw	r24, r16
    17e6:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    17ea:	b7 01       	movw	r22, r14
    17ec:	c8 01       	movw	r24, r16
    17ee:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    17f2:	66 e0       	ldi	r22, 0x06	; 6
    17f4:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    17f8:	8c 89       	ldd	r24, Y+20	; 0x14
    17fa:	9d 89       	ldd	r25, Y+21	; 0x15
    17fc:	0e 94 45 0b 	call	0x168a	; 0x168a <_ZN7MMA845111getYReadingEv>
    1800:	7c 01       	movw	r14, r24
    1802:	0e 81       	ldd	r16, Y+6	; 0x06
    1804:	1f 81       	ldd	r17, Y+7	; 0x07
    1806:	65 e5       	ldi	r22, 0x55	; 85
    1808:	71 e2       	ldi	r23, 0x21	; 33
    180a:	c8 01       	movw	r24, r16
    180c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1810:	b7 01       	movw	r22, r14
    1812:	c8 01       	movw	r24, r16
    1814:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    1818:	66 e0       	ldi	r22, 0x06	; 6
    181a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    181e:	8c 89       	ldd	r24, Y+20	; 0x14
    1820:	9d 89       	ldd	r25, Y+21	; 0x15
    1822:	0e 94 89 0b 	call	0x1712	; 0x1712 <_ZN7MMA845111getZReadingEv>
    1826:	7c 01       	movw	r14, r24
    1828:	0e 81       	ldd	r16, Y+6	; 0x06
    182a:	1f 81       	ldd	r17, Y+7	; 0x07
    182c:	69 e5       	ldi	r22, 0x59	; 89
    182e:	71 e2       	ldi	r23, 0x21	; 33
    1830:	c8 01       	movw	r24, r16
    1832:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1836:	b7 01       	movw	r22, r14
    1838:	c8 01       	movw	r24, r16
    183a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    183e:	66 e0       	ldi	r22, 0x06	; 6
    1840:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1844:	8e 85       	ldd	r24, Y+14	; 0x0e
    1846:	9f 85       	ldd	r25, Y+15	; 0x0f
    1848:	a8 89       	ldd	r26, Y+16	; 0x10
    184a:	b9 89       	ldd	r27, Y+17	; 0x11
    184c:	01 96       	adiw	r24, 0x01	; 1
    184e:	a1 1d       	adc	r26, r1
    1850:	b1 1d       	adc	r27, r1
    1852:	8e 87       	std	Y+14, r24	; 0x0e
    1854:	9f 87       	std	Y+15, r25	; 0x0f
    1856:	a8 8b       	std	Y+16, r26	; 0x10
    1858:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    185a:	68 ee       	ldi	r22, 0xE8	; 232
    185c:	73 e0       	ldi	r23, 0x03	; 3
    185e:	80 e0       	ldi	r24, 0x00	; 0
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	0e 94 d5 17 	call	0x2faa	; 0x2faa <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1866:	b2 cf       	rjmp	.-156    	; 0x17cc <_ZN11task_sensor3runEv+0x2>

00001868 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sensor::task_sensor (const char* a_name, 
    1868:	cf 92       	push	r12
    186a:	df 92       	push	r13
    186c:	ef 92       	push	r14
    186e:	ff 92       	push	r15
    1870:	0f 93       	push	r16
    1872:	1f 93       	push	r17
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	ec 01       	movw	r28, r24
    187a:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    187c:	0e 94 05 1a 	call	0x340a	; 0x340a <_ZN8frt_taskC1EPKchjP8emstream>
    1880:	81 e6       	ldi	r24, 0x61	; 97
    1882:	91 e2       	ldi	r25, 0x21	; 33
    1884:	88 83       	st	Y, r24
    1886:	99 83       	std	Y+1, r25	; 0x01
    1888:	ec 8a       	std	Y+20, r14	; 0x14
    188a:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    188c:	ce 8a       	std	Y+22, r12	; 0x16
    188e:	df 8a       	std	Y+23, r13	; 0x17
}
    1890:	df 91       	pop	r29
    1892:	cf 91       	pop	r28
    1894:	1f 91       	pop	r17
    1896:	0f 91       	pop	r16
    1898:	ff 90       	pop	r15
    189a:	ef 90       	pop	r14
    189c:	df 90       	pop	r13
    189e:	cf 90       	pop	r12
    18a0:	08 95       	ret

000018a2 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    18a2:	0f 93       	push	r16
    18a4:	1f 93       	push	r17
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    18ac:	0e 94 05 1a 	call	0x340a	; 0x340a <_ZN8frt_taskC1EPKchjP8emstream>
    18b0:	89 e6       	ldi	r24, 0x69	; 105
    18b2:	91 e2       	ldi	r25, 0x21	; 33
    18b4:	88 83       	st	Y, r24
    18b6:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    18b8:	df 91       	pop	r29
    18ba:	cf 91       	pop	r28
    18bc:	1f 91       	pop	r17
    18be:	0f 91       	pop	r16
    18c0:	08 95       	ret

000018c2 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    18cc:	6a e0       	ldi	r22, 0x0A	; 10
    18ce:	8e 81       	ldd	r24, Y+6	; 0x06
    18d0:	9f 81       	ldd	r25, Y+7	; 0x07
    18d2:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    18d6:	8c 01       	movw	r16, r24
    18d8:	6d e0       	ldi	r22, 0x0D	; 13
    18da:	75 e0       	ldi	r23, 0x05	; 5
    18dc:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    18e0:	6a e0       	ldi	r22, 0x0A	; 10
    18e2:	c8 01       	movw	r24, r16
    18e4:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    18e8:	8c 01       	movw	r16, r24
    18ea:	67 e0       	ldi	r22, 0x07	; 7
    18ec:	75 e0       	ldi	r23, 0x05	; 5
    18ee:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    18f2:	67 e0       	ldi	r22, 0x07	; 7
    18f4:	c8 01       	movw	r24, r16
    18f6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    18fa:	6a e0       	ldi	r22, 0x0A	; 10
    18fc:	8e 81       	ldd	r24, Y+6	; 0x06
    18fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1900:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1904:	8c 01       	movw	r16, r24
    1906:	68 ee       	ldi	r22, 0xE8	; 232
    1908:	74 e0       	ldi	r23, 0x04	; 4
    190a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    190e:	6a e0       	ldi	r22, 0x0A	; 10
    1910:	c8 01       	movw	r24, r16
    1912:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1916:	8c 01       	movw	r16, r24
    1918:	62 ee       	ldi	r22, 0xE2	; 226
    191a:	74 e0       	ldi	r23, 0x04	; 4
    191c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1920:	66 e0       	ldi	r22, 0x06	; 6
    1922:	c8 01       	movw	r24, r16
    1924:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1928:	6a e0       	ldi	r22, 0x0A	; 10
    192a:	8e 81       	ldd	r24, Y+6	; 0x06
    192c:	9f 81       	ldd	r25, Y+7	; 0x07
    192e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1932:	8c 01       	movw	r16, r24
    1934:	6b ec       	ldi	r22, 0xCB	; 203
    1936:	74 e0       	ldi	r23, 0x04	; 4
    1938:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    193c:	66 e0       	ldi	r22, 0x06	; 6
    193e:	c8 01       	movw	r24, r16
    1940:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1944:	6a e0       	ldi	r22, 0x0A	; 10
    1946:	8e 81       	ldd	r24, Y+6	; 0x06
    1948:	9f 81       	ldd	r25, Y+7	; 0x07
    194a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    194e:	8c 01       	movw	r16, r24
    1950:	6f ea       	ldi	r22, 0xAF	; 175
    1952:	74 e0       	ldi	r23, 0x04	; 4
    1954:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1958:	66 e0       	ldi	r22, 0x06	; 6
    195a:	c8 01       	movw	r24, r16
    195c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1960:	6a e0       	ldi	r22, 0x0A	; 10
    1962:	8e 81       	ldd	r24, Y+6	; 0x06
    1964:	9f 81       	ldd	r25, Y+7	; 0x07
    1966:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    196a:	8c 01       	movw	r16, r24
    196c:	67 e9       	ldi	r22, 0x97	; 151
    196e:	74 e0       	ldi	r23, 0x04	; 4
    1970:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1974:	66 e0       	ldi	r22, 0x06	; 6
    1976:	c8 01       	movw	r24, r16
    1978:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    197c:	6a e0       	ldi	r22, 0x0A	; 10
    197e:	8e 81       	ldd	r24, Y+6	; 0x06
    1980:	9f 81       	ldd	r25, Y+7	; 0x07
    1982:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1986:	8c 01       	movw	r16, r24
    1988:	66 e7       	ldi	r22, 0x76	; 118
    198a:	74 e0       	ldi	r23, 0x04	; 4
    198c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1990:	66 e0       	ldi	r22, 0x06	; 6
    1992:	c8 01       	movw	r24, r16
    1994:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1998:	6a e0       	ldi	r22, 0x0A	; 10
    199a:	8e 81       	ldd	r24, Y+6	; 0x06
    199c:	9f 81       	ldd	r25, Y+7	; 0x07
    199e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    19a2:	8c 01       	movw	r16, r24
    19a4:	6f e4       	ldi	r22, 0x4F	; 79
    19a6:	74 e0       	ldi	r23, 0x04	; 4
    19a8:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    19ac:	66 e0       	ldi	r22, 0x06	; 6
    19ae:	c8 01       	movw	r24, r16
    19b0:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    19b4:	6a e0       	ldi	r22, 0x0A	; 10
    19b6:	8e 81       	ldd	r24, Y+6	; 0x06
    19b8:	9f 81       	ldd	r25, Y+7	; 0x07
    19ba:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    19be:	8c 01       	movw	r16, r24
    19c0:	61 e3       	ldi	r22, 0x31	; 49
    19c2:	74 e0       	ldi	r23, 0x04	; 4
    19c4:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    19c8:	66 e0       	ldi	r22, 0x06	; 6
    19ca:	c8 01       	movw	r24, r16
    19cc:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    19d0:	6a e0       	ldi	r22, 0x0A	; 10
    19d2:	8e 81       	ldd	r24, Y+6	; 0x06
    19d4:	9f 81       	ldd	r25, Y+7	; 0x07
    19d6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    19da:	8c 01       	movw	r16, r24
    19dc:	66 e1       	ldi	r22, 0x16	; 22
    19de:	74 e0       	ldi	r23, 0x04	; 4
    19e0:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    19e4:	66 e0       	ldi	r22, 0x06	; 6
    19e6:	c8 01       	movw	r24, r16
    19e8:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    19ec:	6a e0       	ldi	r22, 0x0A	; 10
    19ee:	8e 81       	ldd	r24, Y+6	; 0x06
    19f0:	9f 81       	ldd	r25, Y+7	; 0x07
    19f2:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    19f6:	ec 01       	movw	r28, r24
    19f8:	67 e0       	ldi	r22, 0x07	; 7
    19fa:	74 e0       	ldi	r23, 0x04	; 4
    19fc:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1a00:	66 e0       	ldi	r22, 0x06	; 6
    1a02:	ce 01       	movw	r24, r28
    1a04:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
}
    1a08:	df 91       	pop	r29
    1a0a:	cf 91       	pop	r28
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	08 95       	ret

00001a12 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1a12:	af 92       	push	r10
    1a14:	bf 92       	push	r11
    1a16:	cf 92       	push	r12
    1a18:	df 92       	push	r13
    1a1a:	ef 92       	push	r14
    1a1c:	ff 92       	push	r15
    1a1e:	0f 93       	push	r16
    1a20:	1f 93       	push	r17
    1a22:	cf 93       	push	r28
    1a24:	df 93       	push	r29
    1a26:	00 d0       	rcall	.+0      	; 0x1a28 <_ZN9task_user11show_statusEv+0x16>
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <_ZN9task_user11show_statusEv+0x18>
    1a2a:	cd b7       	in	r28, 0x3d	; 61
    1a2c:	de b7       	in	r29, 0x3e	; 62
    1a2e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1a30:	19 82       	std	Y+1, r1	; 0x01
    1a32:	1a 82       	std	Y+2, r1	; 0x02
    1a34:	1b 82       	std	Y+3, r1	; 0x03
    1a36:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1a38:	1d 82       	std	Y+5, r1	; 0x05
    1a3a:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1a3c:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <xPortGetFreeHeapSize>
    1a40:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a42:	ce 01       	movw	r24, r28
    1a44:	01 96       	adiw	r24, 0x01	; 1
    1a46:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <_ZN10time_stamp10set_to_nowEv>
    1a4a:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1a4c:	66 e0       	ldi	r22, 0x06	; 6
    1a4e:	f8 01       	movw	r30, r16
    1a50:	86 81       	ldd	r24, Z+6	; 0x06
    1a52:	97 81       	ldd	r25, Z+7	; 0x07
    1a54:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1a58:	6a e0       	ldi	r22, 0x0A	; 10
    1a5a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1a5e:	7c 01       	movw	r14, r24
    1a60:	68 ee       	ldi	r22, 0xE8	; 232
    1a62:	73 e0       	ldi	r23, 0x03	; 3
    1a64:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1a68:	6a e0       	ldi	r22, 0x0A	; 10
    1a6a:	c7 01       	movw	r24, r14
    1a6c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1a70:	7c 01       	movw	r14, r24
    1a72:	6c ed       	ldi	r22, 0xDC	; 220
    1a74:	73 e0       	ldi	r23, 0x03	; 3
    1a76:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1a7a:	66 e0       	ldi	r22, 0x06	; 6
    1a7c:	c7 01       	movw	r24, r14
    1a7e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a82:	6a e0       	ldi	r22, 0x0A	; 10
    1a84:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1a88:	7c 01       	movw	r14, r24
    1a8a:	65 ed       	ldi	r22, 0xD5	; 213
    1a8c:	73 e0       	ldi	r23, 0x03	; 3
    1a8e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1a92:	b5 01       	movw	r22, r10
    1a94:	c7 01       	movw	r24, r14
    1a96:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1a9a:	6a e0       	ldi	r22, 0x0A	; 10
    1a9c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1aa0:	7c 01       	movw	r14, r24
    1aa2:	67 ec       	ldi	r22, 0xC7	; 199
    1aa4:	73 e0       	ldi	r23, 0x03	; 3
    1aa6:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1aaa:	b6 01       	movw	r22, r12
    1aac:	c7 01       	movw	r24, r14
    1aae:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    1ab2:	6a e0       	ldi	r22, 0x0A	; 10
    1ab4:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1ab8:	7c 01       	movw	r14, r24
    1aba:	65 ec       	ldi	r22, 0xC5	; 197
    1abc:	73 e0       	ldi	r23, 0x03	; 3
    1abe:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1ac2:	4f ef       	ldi	r20, 0xFF	; 255
    1ac4:	5f e0       	ldi	r21, 0x0F	; 15
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	70 e0       	ldi	r23, 0x00	; 0
    1aca:	c7 01       	movw	r24, r14
    1acc:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1ad0:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1ad4:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1ad8:	6a e0       	ldi	r22, 0x0A	; 10
    1ada:	f8 01       	movw	r30, r16
    1adc:	86 81       	ldd	r24, Z+6	; 0x06
    1ade:	97 81       	ldd	r25, Z+7	; 0x07
    1ae0:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1ae4:	7c 01       	movw	r14, r24
    1ae6:	6a eb       	ldi	r22, 0xBA	; 186
    1ae8:	73 e0       	ldi	r23, 0x03	; 3
    1aea:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1aee:	b6 01       	movw	r22, r12
    1af0:	c7 01       	movw	r24, r14
    1af2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    1af6:	66 e0       	ldi	r22, 0x06	; 6
    1af8:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1afc:	66 e0       	ldi	r22, 0x06	; 6
    1afe:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1b02:	f8 01       	movw	r30, r16
    1b04:	86 81       	ldd	r24, Z+6	; 0x06
    1b06:	97 81       	ldd	r25, Z+7	; 0x07
    1b08:	0e 94 13 1c 	call	0x3826	; 0x3826 <_Z15print_task_listP8emstream>
}
    1b0c:	26 96       	adiw	r28, 0x06	; 6
    1b0e:	cd bf       	out	0x3d, r28	; 61
    1b10:	de bf       	out	0x3e, r29	; 62
    1b12:	df 91       	pop	r29
    1b14:	cf 91       	pop	r28
    1b16:	1f 91       	pop	r17
    1b18:	0f 91       	pop	r16
    1b1a:	ff 90       	pop	r15
    1b1c:	ef 90       	pop	r14
    1b1e:	df 90       	pop	r13
    1b20:	cf 90       	pop	r12
    1b22:	bf 90       	pop	r11
    1b24:	af 90       	pop	r10
    1b26:	08 95       	ret

00001b28 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1b28:	cf 93       	push	r28
    1b2a:	df 93       	push	r29
    1b2c:	00 d0       	rcall	.+0      	; 0x1b2e <_ZN9task_user3runEv+0x6>
    1b2e:	00 d0       	rcall	.+0      	; 0x1b30 <_ZN9task_user3runEv+0x8>
    1b30:	cd b7       	in	r28, 0x3d	; 61
    1b32:	de b7       	in	r29, 0x3e	; 62
    1b34:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1b36:	19 82       	std	Y+1, r1	; 0x01
    1b38:	1a 82       	std	Y+2, r1	; 0x02
    1b3a:	1b 82       	std	Y+3, r1	; 0x03
    1b3c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1b3e:	1d 82       	std	Y+5, r1	; 0x05
    1b40:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1b42:	6a e0       	ldi	r22, 0x0A	; 10
    1b44:	dc 01       	movw	r26, r24
    1b46:	16 96       	adiw	r26, 0x06	; 6
    1b48:	8d 91       	ld	r24, X+
    1b4a:	9c 91       	ld	r25, X
    1b4c:	17 97       	sbiw	r26, 0x07	; 7
    1b4e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1b52:	7c 01       	movw	r14, r24
    1b54:	66 e5       	ldi	r22, 0x56	; 86
    1b56:	75 e0       	ldi	r23, 0x05	; 5
    1b58:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1b5c:	66 e0       	ldi	r22, 0x06	; 6
    1b5e:	c7 01       	movw	r24, r14
    1b60:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1b64:	f8 01       	movw	r30, r16
    1b66:	84 85       	ldd	r24, Z+12	; 0x0c
    1b68:	88 23       	and	r24, r24
    1b6a:	21 f0       	breq	.+8      	; 0x1b74 <_ZN9task_user3runEv+0x4c>
    1b6c:	81 30       	cpi	r24, 0x01	; 1
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <_ZN9task_user3runEv+0x4a>
    1b70:	5d c0       	rjmp	.+186    	; 0x1c2c <_ZN9task_user3runEv+0x104>
    1b72:	d8 c0       	rjmp	.+432    	; 0x1d24 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1b74:	86 81       	ldd	r24, Z+6	; 0x06
    1b76:	97 81       	ldd	r25, Z+7	; 0x07
    1b78:	dc 01       	movw	r26, r24
    1b7a:	ed 91       	ld	r30, X+
    1b7c:	fc 91       	ld	r31, X
    1b7e:	04 80       	ldd	r0, Z+4	; 0x04
    1b80:	f5 81       	ldd	r31, Z+5	; 0x05
    1b82:	e0 2d       	mov	r30, r0
    1b84:	19 95       	eicall
    1b86:	88 23       	and	r24, r24
    1b88:	a9 f1       	breq	.+106    	; 0x1bf4 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	86 81       	ldd	r24, Z+6	; 0x06
    1b8e:	97 81       	ldd	r25, Z+7	; 0x07
    1b90:	dc 01       	movw	r26, r24
    1b92:	ed 91       	ld	r30, X+
    1b94:	fc 91       	ld	r31, X
    1b96:	06 80       	ldd	r0, Z+6	; 0x06
    1b98:	f7 81       	ldd	r31, Z+7	; 0x07
    1b9a:	e0 2d       	mov	r30, r0
    1b9c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1b9e:	99 27       	eor	r25, r25
    1ba0:	81 30       	cpi	r24, 0x01	; 1
    1ba2:	91 05       	cpc	r25, r1
    1ba4:	f9 f0       	breq	.+62     	; 0x1be4 <_ZN9task_user3runEv+0xbc>
    1ba6:	03 97       	sbiw	r24, 0x03	; 3
    1ba8:	09 f0       	breq	.+2      	; 0x1bac <_ZN9task_user3runEv+0x84>
    1baa:	d8 c0       	rjmp	.+432    	; 0x1d5c <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1bac:	6a e0       	ldi	r22, 0x0A	; 10
    1bae:	f8 01       	movw	r30, r16
    1bb0:	86 81       	ldd	r24, Z+6	; 0x06
    1bb2:	97 81       	ldd	r25, Z+7	; 0x07
    1bb4:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1bb8:	8c 01       	movw	r16, r24
    1bba:	68 e4       	ldi	r22, 0x48	; 72
    1bbc:	75 e0       	ldi	r23, 0x05	; 5
    1bbe:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1bc2:	66 e0       	ldi	r22, 0x06	; 6
    1bc4:	c8 01       	movw	r24, r16
    1bc6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1bca:	93 e0       	ldi	r25, 0x03	; 3
    1bcc:	88 ed       	ldi	r24, 0xD8	; 216
    1bce:	08 b6       	in	r0, 0x38	; 56
    1bd0:	18 be       	out	0x38, r1	; 56
    1bd2:	84 bf       	out	0x34, r24	; 52
    1bd4:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1bd8:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1bdc:	81 fd       	sbrc	r24, 1
    1bde:	fc cf       	rjmp	.-8      	; 0x1bd8 <_ZN9task_user3runEv+0xb0>
    1be0:	08 be       	out	0x38, r0	; 56
    1be2:	ff cf       	rjmp	.-2      	; 0x1be2 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1be4:	c8 01       	movw	r24, r16
    1be6:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1bea:	61 e0       	ldi	r22, 0x01	; 1
    1bec:	c8 01       	movw	r24, r16
    1bee:	0e 94 01 1a 	call	0x3402	; 0x3402 <_ZN8frt_task13transition_toEh>
							break;
    1bf2:	b4 c0       	rjmp	.+360    	; 0x1d5c <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1bf4:	8c ed       	ldi	r24, 0xDC	; 220
    1bf6:	92 e3       	ldi	r25, 0x32	; 50
    1bf8:	0e 94 c2 1c 	call	0x3984	; 0x3984 <_ZN14frt_text_queue14check_for_charEv>
    1bfc:	88 23       	and	r24, r24
    1bfe:	09 f4       	brne	.+2      	; 0x1c02 <_ZN9task_user3runEv+0xda>
    1c00:	ad c0       	rjmp	.+346    	; 0x1d5c <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1c02:	d8 01       	movw	r26, r16
    1c04:	16 96       	adiw	r26, 0x06	; 6
    1c06:	ed 91       	ld	r30, X+
    1c08:	fc 91       	ld	r31, X
    1c0a:	17 97       	sbiw	r26, 0x07	; 7
    1c0c:	01 90       	ld	r0, Z+
    1c0e:	f0 81       	ld	r31, Z
    1c10:	e0 2d       	mov	r30, r0
    1c12:	e2 80       	ldd	r14, Z+2	; 0x02
    1c14:	f3 80       	ldd	r15, Z+3	; 0x03
    1c16:	8c ed       	ldi	r24, 0xDC	; 220
    1c18:	92 e3       	ldi	r25, 0x32	; 50
    1c1a:	0e 94 a4 1c 	call	0x3948	; 0x3948 <_ZN14frt_text_queue7getcharEv>
    1c1e:	68 2f       	mov	r22, r24
    1c20:	f8 01       	movw	r30, r16
    1c22:	86 81       	ldd	r24, Z+6	; 0x06
    1c24:	97 81       	ldd	r25, Z+7	; 0x07
    1c26:	f7 01       	movw	r30, r14
    1c28:	19 95       	eicall
    1c2a:	98 c0       	rjmp	.+304    	; 0x1d5c <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1c2c:	86 81       	ldd	r24, Z+6	; 0x06
    1c2e:	97 81       	ldd	r25, Z+7	; 0x07
    1c30:	dc 01       	movw	r26, r24
    1c32:	ed 91       	ld	r30, X+
    1c34:	fc 91       	ld	r31, X
    1c36:	04 80       	ldd	r0, Z+4	; 0x04
    1c38:	f5 81       	ldd	r31, Z+5	; 0x05
    1c3a:	e0 2d       	mov	r30, r0
    1c3c:	19 95       	eicall
    1c3e:	88 23       	and	r24, r24
    1c40:	09 f4       	brne	.+2      	; 0x1c44 <_ZN9task_user3runEv+0x11c>
    1c42:	8c c0       	rjmp	.+280    	; 0x1d5c <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1c44:	f8 01       	movw	r30, r16
    1c46:	86 81       	ldd	r24, Z+6	; 0x06
    1c48:	97 81       	ldd	r25, Z+7	; 0x07
    1c4a:	dc 01       	movw	r26, r24
    1c4c:	ed 91       	ld	r30, X+
    1c4e:	fc 91       	ld	r31, X
    1c50:	06 80       	ldd	r0, Z+6	; 0x06
    1c52:	f7 81       	ldd	r31, Z+7	; 0x07
    1c54:	e0 2d       	mov	r30, r0
    1c56:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1c58:	9c 01       	movw	r18, r24
    1c5a:	33 27       	eor	r19, r19
    1c5c:	28 36       	cpi	r18, 0x68	; 104
    1c5e:	31 05       	cpc	r19, r1
    1c60:	59 f1       	breq	.+86     	; 0x1cb8 <_ZN9task_user3runEv+0x190>
    1c62:	3c f4       	brge	.+14     	; 0x1c72 <_ZN9task_user3runEv+0x14a>
    1c64:	2b 31       	cpi	r18, 0x1B	; 27
    1c66:	31 05       	cpc	r19, r1
    1c68:	59 f1       	breq	.+86     	; 0x1cc0 <_ZN9task_user3runEv+0x198>
    1c6a:	25 36       	cpi	r18, 0x65	; 101
    1c6c:	31 05       	cpc	r19, r1
    1c6e:	41 f1       	breq	.+80     	; 0x1cc0 <_ZN9task_user3runEv+0x198>
    1c70:	3b c0       	rjmp	.+118    	; 0x1ce8 <_ZN9task_user3runEv+0x1c0>
    1c72:	23 37       	cpi	r18, 0x73	; 115
    1c74:	31 05       	cpc	r19, r1
    1c76:	c1 f0       	breq	.+48     	; 0x1ca8 <_ZN9task_user3runEv+0x180>
    1c78:	26 37       	cpi	r18, 0x76	; 118
    1c7a:	31 05       	cpc	r19, r1
    1c7c:	89 f0       	breq	.+34     	; 0x1ca0 <_ZN9task_user3runEv+0x178>
    1c7e:	2e 36       	cpi	r18, 0x6E	; 110
    1c80:	31 05       	cpc	r19, r1
    1c82:	91 f5       	brne	.+100    	; 0x1ce8 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1c84:	ce 01       	movw	r24, r28
    1c86:	01 96       	adiw	r24, 0x01	; 1
    1c88:	0e 94 b6 1d 	call	0x3b6c	; 0x3b6c <_ZN10time_stamp10set_to_nowEv>
    1c8c:	bc 01       	movw	r22, r24
    1c8e:	f8 01       	movw	r30, r16
    1c90:	86 81       	ldd	r24, Z+6	; 0x06
    1c92:	97 81       	ldd	r25, Z+7	; 0x07
    1c94:	0e 94 5a 1d 	call	0x3ab4	; 0x3ab4 <_ZlsR8emstreamR10time_stamp>
    1c98:	66 e0       	ldi	r22, 0x06	; 6
    1c9a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1c9e:	5e c0       	rjmp	.+188    	; 0x1d5c <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1ca0:	c8 01       	movw	r24, r16
    1ca2:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <_ZN9task_user11show_statusEv>
							break;
    1ca6:	5a c0       	rjmp	.+180    	; 0x1d5c <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1ca8:	d8 01       	movw	r26, r16
    1caa:	16 96       	adiw	r26, 0x06	; 6
    1cac:	8d 91       	ld	r24, X+
    1cae:	9c 91       	ld	r25, X
    1cb0:	17 97       	sbiw	r26, 0x07	; 7
    1cb2:	0e 94 1a 1b 	call	0x3634	; 0x3634 <_Z17print_task_stacksP8emstream>
							break;
    1cb6:	52 c0       	rjmp	.+164    	; 0x1d5c <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1cb8:	c8 01       	movw	r24, r16
    1cba:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <_ZN9task_user18print_help_messageEv>
							break;
    1cbe:	4e c0       	rjmp	.+156    	; 0x1d5c <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1cc0:	6a e0       	ldi	r22, 0x0A	; 10
    1cc2:	f8 01       	movw	r30, r16
    1cc4:	86 81       	ldd	r24, Z+6	; 0x06
    1cc6:	97 81       	ldd	r25, Z+7	; 0x07
    1cc8:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1ccc:	7c 01       	movw	r14, r24
    1cce:	66 e3       	ldi	r22, 0x36	; 54
    1cd0:	75 e0       	ldi	r23, 0x05	; 5
    1cd2:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1cd6:	66 e0       	ldi	r22, 0x06	; 6
    1cd8:	c7 01       	movw	r24, r14
    1cda:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1cde:	60 e0       	ldi	r22, 0x00	; 0
    1ce0:	c8 01       	movw	r24, r16
    1ce2:	0e 94 01 1a 	call	0x3402	; 0x3402 <_ZN8frt_task13transition_toEh>
							break;
    1ce6:	3a c0       	rjmp	.+116    	; 0x1d5c <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1ce8:	f8 01       	movw	r30, r16
    1cea:	a6 81       	ldd	r26, Z+6	; 0x06
    1cec:	b7 81       	ldd	r27, Z+7	; 0x07
    1cee:	ed 91       	ld	r30, X+
    1cf0:	fc 91       	ld	r31, X
    1cf2:	11 97       	sbiw	r26, 0x01	; 1
    1cf4:	02 80       	ldd	r0, Z+2	; 0x02
    1cf6:	f3 81       	ldd	r31, Z+3	; 0x03
    1cf8:	e0 2d       	mov	r30, r0
    1cfa:	68 2f       	mov	r22, r24
    1cfc:	cd 01       	movw	r24, r26
    1cfe:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1d00:	6a e0       	ldi	r22, 0x0A	; 10
    1d02:	d8 01       	movw	r26, r16
    1d04:	16 96       	adiw	r26, 0x06	; 6
    1d06:	8d 91       	ld	r24, X+
    1d08:	9c 91       	ld	r25, X
    1d0a:	17 97       	sbiw	r26, 0x07	; 7
    1d0c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1d10:	7c 01       	movw	r14, r24
    1d12:	60 e3       	ldi	r22, 0x30	; 48
    1d14:	75 e0       	ldi	r23, 0x05	; 5
    1d16:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1d1a:	66 e0       	ldi	r22, 0x06	; 6
    1d1c:	c7 01       	movw	r24, r14
    1d1e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1d22:	1c c0       	rjmp	.+56     	; 0x1d5c <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1d24:	6a e0       	ldi	r22, 0x0A	; 10
    1d26:	f8 01       	movw	r30, r16
    1d28:	86 81       	ldd	r24, Z+6	; 0x06
    1d2a:	97 81       	ldd	r25, Z+7	; 0x07
    1d2c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    1d30:	8c 01       	movw	r16, r24
    1d32:	63 e1       	ldi	r22, 0x13	; 19
    1d34:	75 e0       	ldi	r23, 0x05	; 5
    1d36:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    1d3a:	66 e0       	ldi	r22, 0x06	; 6
    1d3c:	c8 01       	movw	r24, r16
    1d3e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1d42:	93 e0       	ldi	r25, 0x03	; 3
    1d44:	88 ed       	ldi	r24, 0xD8	; 216
    1d46:	08 b6       	in	r0, 0x38	; 56
    1d48:	18 be       	out	0x38, r1	; 56
    1d4a:	84 bf       	out	0x34, r24	; 52
    1d4c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1d50:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1d54:	81 fd       	sbrc	r24, 1
    1d56:	fc cf       	rjmp	.-8      	; 0x1d50 <_ZN9task_user3runEv+0x228>
    1d58:	08 be       	out	0x38, r0	; 56
    1d5a:	ff cf       	rjmp	.-2      	; 0x1d5a <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1d5c:	f8 01       	movw	r30, r16
    1d5e:	86 85       	ldd	r24, Z+14	; 0x0e
    1d60:	97 85       	ldd	r25, Z+15	; 0x0f
    1d62:	a0 89       	ldd	r26, Z+16	; 0x10
    1d64:	b1 89       	ldd	r27, Z+17	; 0x11
    1d66:	01 96       	adiw	r24, 0x01	; 1
    1d68:	a1 1d       	adc	r26, r1
    1d6a:	b1 1d       	adc	r27, r1
    1d6c:	86 87       	std	Z+14, r24	; 0x0e
    1d6e:	97 87       	std	Z+15, r25	; 0x0f
    1d70:	a0 8b       	std	Z+16, r26	; 0x10
    1d72:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1d74:	68 ee       	ldi	r22, 0xE8	; 232
    1d76:	73 e0       	ldi	r23, 0x03	; 3
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	90 e0       	ldi	r25, 0x00	; 0
    1d7c:	0e 94 d5 17 	call	0x2faa	; 0x2faa <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1d80:	f1 ce       	rjmp	.-542    	; 0x1b64 <_ZN9task_user3runEv+0x3c>

00001d82 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d82:	0f 93       	push	r16
    1d84:	1f 93       	push	r17
    1d86:	cf 93       	push	r28
    1d88:	df 93       	push	r29
    1d8a:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1d8c:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1d90:	80 91 20 22 	lds	r24, 0x2220	; 0x802220 <__data_end>
    1d94:	81 11       	cpse	r24, r1
    1d96:	1d c0       	rjmp	.+58     	; 0x1dd2 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1d98:	a5 e2       	ldi	r26, 0x25	; 37
    1d9a:	b2 e2       	ldi	r27, 0x22	; 34
    1d9c:	e9 e2       	ldi	r30, 0x29	; 41
    1d9e:	f2 e2       	ldi	r31, 0x22	; 34
    1da0:	ed 93       	st	X+, r30
    1da2:	fc 93       	st	X, r31
    1da4:	11 97       	sbiw	r26, 0x01	; 1
    1da6:	12 96       	adiw	r26, 0x02	; 2
    1da8:	1d 92       	st	X+, r1
    1daa:	1c 92       	st	X, r1
    1dac:	13 97       	sbiw	r26, 0x03	; 3
    1dae:	a1 e2       	ldi	r26, 0x21	; 33
    1db0:	b2 e2       	ldi	r27, 0x22	; 34
    1db2:	8f ef       	ldi	r24, 0xFF	; 255
    1db4:	9f e0       	ldi	r25, 0x0F	; 15
    1db6:	12 96       	adiw	r26, 0x02	; 2
    1db8:	8d 93       	st	X+, r24
    1dba:	9c 93       	st	X, r25
    1dbc:	13 97       	sbiw	r26, 0x03	; 3
    1dbe:	1d 92       	st	X+, r1
    1dc0:	1c 92       	st	X, r1
    1dc2:	11 97       	sbiw	r26, 0x01	; 1
    1dc4:	82 83       	std	Z+2, r24	; 0x02
    1dc6:	93 83       	std	Z+3, r25	; 0x03
    1dc8:	a0 83       	st	Z, r26
    1dca:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	80 93 20 22 	sts	0x2220, r24	; 0x802220 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1dd2:	20 97       	sbiw	r28, 0x00	; 0
    1dd4:	09 f4       	brne	.+2      	; 0x1dd8 <pvPortMalloc+0x56>
    1dd6:	5f c0       	rjmp	.+190    	; 0x1e96 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1dd8:	9e 01       	movw	r18, r28
    1dda:	2b 5f       	subi	r18, 0xFB	; 251
    1ddc:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1dde:	24 96       	adiw	r28, 0x04	; 4
    1de0:	ce 3f       	cpi	r28, 0xFE	; 254
    1de2:	df 40       	sbci	r29, 0x0F	; 15
    1de4:	08 f0       	brcs	.+2      	; 0x1de8 <pvPortMalloc+0x66>
    1de6:	5a c0       	rjmp	.+180    	; 0x1e9c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1de8:	e0 91 25 22 	lds	r30, 0x2225	; 0x802225 <xStart>
    1dec:	f0 91 26 22 	lds	r31, 0x2226	; 0x802226 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1df0:	a5 e2       	ldi	r26, 0x25	; 37
    1df2:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1df4:	02 c0       	rjmp	.+4      	; 0x1dfa <pvPortMalloc+0x78>
    1df6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1df8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1dfa:	82 81       	ldd	r24, Z+2	; 0x02
    1dfc:	93 81       	ldd	r25, Z+3	; 0x03
    1dfe:	82 17       	cp	r24, r18
    1e00:	93 07       	cpc	r25, r19
    1e02:	20 f4       	brcc	.+8      	; 0x1e0c <pvPortMalloc+0x8a>
    1e04:	80 81       	ld	r24, Z
    1e06:	91 81       	ldd	r25, Z+1	; 0x01
    1e08:	00 97       	sbiw	r24, 0x00	; 0
    1e0a:	a9 f7       	brne	.-22     	; 0x1df6 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1e0c:	c2 e2       	ldi	r28, 0x22	; 34
    1e0e:	e1 32       	cpi	r30, 0x21	; 33
    1e10:	fc 07       	cpc	r31, r28
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <pvPortMalloc+0x94>
    1e14:	46 c0       	rjmp	.+140    	; 0x1ea2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1e16:	cd 91       	ld	r28, X+
    1e18:	dc 91       	ld	r29, X
    1e1a:	11 97       	sbiw	r26, 0x01	; 1
    1e1c:	8e 01       	movw	r16, r28
    1e1e:	0b 5f       	subi	r16, 0xFB	; 251
    1e20:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e22:	80 81       	ld	r24, Z
    1e24:	91 81       	ldd	r25, Z+1	; 0x01
    1e26:	8d 93       	st	X+, r24
    1e28:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e2a:	82 81       	ldd	r24, Z+2	; 0x02
    1e2c:	93 81       	ldd	r25, Z+3	; 0x03
    1e2e:	82 1b       	sub	r24, r18
    1e30:	93 0b       	sbc	r25, r19
    1e32:	8b 30       	cpi	r24, 0x0B	; 11
    1e34:	91 05       	cpc	r25, r1
    1e36:	10 f1       	brcs	.+68     	; 0x1e7c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1e38:	bf 01       	movw	r22, r30
    1e3a:	62 0f       	add	r22, r18
    1e3c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e3e:	db 01       	movw	r26, r22
    1e40:	12 96       	adiw	r26, 0x02	; 2
    1e42:	8d 93       	st	X+, r24
    1e44:	9c 93       	st	X, r25
    1e46:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1e48:	22 83       	std	Z+2, r18	; 0x02
    1e4a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1e4c:	12 96       	adiw	r26, 0x02	; 2
    1e4e:	4d 91       	ld	r20, X+
    1e50:	5c 91       	ld	r21, X
    1e52:	13 97       	sbiw	r26, 0x03	; 3
    1e54:	85 e2       	ldi	r24, 0x25	; 37
    1e56:	92 e2       	ldi	r25, 0x22	; 34
    1e58:	01 c0       	rjmp	.+2      	; 0x1e5c <pvPortMalloc+0xda>
    1e5a:	cd 01       	movw	r24, r26
    1e5c:	ec 01       	movw	r28, r24
    1e5e:	a8 81       	ld	r26, Y
    1e60:	b9 81       	ldd	r27, Y+1	; 0x01
    1e62:	12 96       	adiw	r26, 0x02	; 2
    1e64:	2d 91       	ld	r18, X+
    1e66:	3c 91       	ld	r19, X
    1e68:	13 97       	sbiw	r26, 0x03	; 3
    1e6a:	24 17       	cp	r18, r20
    1e6c:	35 07       	cpc	r19, r21
    1e6e:	a8 f3       	brcs	.-22     	; 0x1e5a <pvPortMalloc+0xd8>
    1e70:	eb 01       	movw	r28, r22
    1e72:	a8 83       	st	Y, r26
    1e74:	b9 83       	std	Y+1, r27	; 0x01
    1e76:	dc 01       	movw	r26, r24
    1e78:	6d 93       	st	X+, r22
    1e7a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1e7c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1e80:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1e84:	22 81       	ldd	r18, Z+2	; 0x02
    1e86:	33 81       	ldd	r19, Z+3	; 0x03
    1e88:	82 1b       	sub	r24, r18
    1e8a:	93 0b       	sbc	r25, r19
    1e8c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1e90:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1e94:	08 c0       	rjmp	.+16     	; 0x1ea6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1e96:	00 e0       	ldi	r16, 0x00	; 0
    1e98:	10 e0       	ldi	r17, 0x00	; 0
    1e9a:	05 c0       	rjmp	.+10     	; 0x1ea6 <pvPortMalloc+0x124>
    1e9c:	00 e0       	ldi	r16, 0x00	; 0
    1e9e:	10 e0       	ldi	r17, 0x00	; 0
    1ea0:	02 c0       	rjmp	.+4      	; 0x1ea6 <pvPortMalloc+0x124>
    1ea2:	00 e0       	ldi	r16, 0x00	; 0
    1ea4:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1ea6:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1eaa:	c8 01       	movw	r24, r16
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	08 95       	ret

00001eb6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1eb6:	0f 93       	push	r16
    1eb8:	1f 93       	push	r17
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1ebe:	00 97       	sbiw	r24, 0x00	; 0
    1ec0:	41 f1       	breq	.+80     	; 0x1f12 <vPortFree+0x5c>
    1ec2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1ec4:	8c 01       	movw	r16, r24
    1ec6:	05 50       	subi	r16, 0x05	; 5
    1ec8:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1eca:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1ece:	f8 01       	movw	r30, r16
    1ed0:	42 81       	ldd	r20, Z+2	; 0x02
    1ed2:	53 81       	ldd	r21, Z+3	; 0x03
    1ed4:	a5 e2       	ldi	r26, 0x25	; 37
    1ed6:	b2 e2       	ldi	r27, 0x22	; 34
    1ed8:	01 c0       	rjmp	.+2      	; 0x1edc <vPortFree+0x26>
    1eda:	df 01       	movw	r26, r30
    1edc:	ed 91       	ld	r30, X+
    1ede:	fc 91       	ld	r31, X
    1ee0:	11 97       	sbiw	r26, 0x01	; 1
    1ee2:	22 81       	ldd	r18, Z+2	; 0x02
    1ee4:	33 81       	ldd	r19, Z+3	; 0x03
    1ee6:	24 17       	cp	r18, r20
    1ee8:	35 07       	cpc	r19, r21
    1eea:	b8 f3       	brcs	.-18     	; 0x1eda <vPortFree+0x24>
    1eec:	25 97       	sbiw	r28, 0x05	; 5
    1eee:	e8 83       	st	Y, r30
    1ef0:	f9 83       	std	Y+1, r31	; 0x01
    1ef2:	0d 93       	st	X+, r16
    1ef4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1ef6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1efa:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1efe:	8a 81       	ldd	r24, Y+2	; 0x02
    1f00:	9b 81       	ldd	r25, Y+3	; 0x03
    1f02:	82 0f       	add	r24, r18
    1f04:	93 1f       	adc	r25, r19
    1f06:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f0a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1f0e:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
	}
}
    1f12:	df 91       	pop	r29
    1f14:	cf 91       	pop	r28
    1f16:	1f 91       	pop	r17
    1f18:	0f 91       	pop	r16
    1f1a:	08 95       	ret

00001f1c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1f1c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1f20:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1f24:	08 95       	ret

00001f26 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1f26:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1f28:	03 96       	adiw	r24, 0x03	; 3
    1f2a:	81 83       	std	Z+1, r24	; 0x01
    1f2c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f2e:	4f ef       	ldi	r20, 0xFF	; 255
    1f30:	5f ef       	ldi	r21, 0xFF	; 255
    1f32:	ba 01       	movw	r22, r20
    1f34:	43 83       	std	Z+3, r20	; 0x03
    1f36:	54 83       	std	Z+4, r21	; 0x04
    1f38:	65 83       	std	Z+5, r22	; 0x05
    1f3a:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1f3c:	87 83       	std	Z+7, r24	; 0x07
    1f3e:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1f40:	81 87       	std	Z+9, r24	; 0x09
    1f42:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1f44:	10 82       	st	Z, r1
    1f46:	08 95       	ret

00001f48 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f48:	fc 01       	movw	r30, r24
    1f4a:	12 86       	std	Z+10, r1	; 0x0a
    1f4c:	13 86       	std	Z+11, r1	; 0x0b
    1f4e:	08 95       	ret

00001f50 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1f50:	cf 93       	push	r28
    1f52:	df 93       	push	r29
    1f54:	fc 01       	movw	r30, r24
    1f56:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1f58:	21 81       	ldd	r18, Z+1	; 0x01
    1f5a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1f5c:	e9 01       	movw	r28, r18
    1f5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f60:	9d 81       	ldd	r25, Y+5	; 0x05
    1f62:	14 96       	adiw	r26, 0x04	; 4
    1f64:	8d 93       	st	X+, r24
    1f66:	9c 93       	st	X, r25
    1f68:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1f6a:	81 81       	ldd	r24, Z+1	; 0x01
    1f6c:	92 81       	ldd	r25, Z+2	; 0x02
    1f6e:	16 96       	adiw	r26, 0x06	; 6
    1f70:	8d 93       	st	X+, r24
    1f72:	9c 93       	st	X, r25
    1f74:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f76:	8c 81       	ldd	r24, Y+4	; 0x04
    1f78:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7a:	ec 01       	movw	r28, r24
    1f7c:	6e 83       	std	Y+6, r22	; 0x06
    1f7e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f80:	e9 01       	movw	r28, r18
    1f82:	6c 83       	std	Y+4, r22	; 0x04
    1f84:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1f86:	61 83       	std	Z+1, r22	; 0x01
    1f88:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1f8a:	1a 96       	adiw	r26, 0x0a	; 10
    1f8c:	ed 93       	st	X+, r30
    1f8e:	fc 93       	st	X, r31
    1f90:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1f92:	80 81       	ld	r24, Z
    1f94:	8f 5f       	subi	r24, 0xFF	; 255
    1f96:	80 83       	st	Z, r24
}
    1f98:	df 91       	pop	r29
    1f9a:	cf 91       	pop	r28
    1f9c:	08 95       	ret

00001f9e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1f9e:	0f 93       	push	r16
    1fa0:	1f 93       	push	r17
    1fa2:	cf 93       	push	r28
    1fa4:	df 93       	push	r29
    1fa6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1fa8:	08 81       	ld	r16, Y
    1faa:	19 81       	ldd	r17, Y+1	; 0x01
    1fac:	2a 81       	ldd	r18, Y+2	; 0x02
    1fae:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1fb0:	0f 3f       	cpi	r16, 0xFF	; 255
    1fb2:	4f ef       	ldi	r20, 0xFF	; 255
    1fb4:	14 07       	cpc	r17, r20
    1fb6:	24 07       	cpc	r18, r20
    1fb8:	34 07       	cpc	r19, r20
    1fba:	31 f4       	brne	.+12     	; 0x1fc8 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1fbc:	dc 01       	movw	r26, r24
    1fbe:	19 96       	adiw	r26, 0x09	; 9
    1fc0:	ed 91       	ld	r30, X+
    1fc2:	fc 91       	ld	r31, X
    1fc4:	1a 97       	sbiw	r26, 0x0a	; 10
    1fc6:	1f c0       	rjmp	.+62     	; 0x2006 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1fc8:	fc 01       	movw	r30, r24
    1fca:	33 96       	adiw	r30, 0x03	; 3
    1fcc:	dc 01       	movw	r26, r24
    1fce:	17 96       	adiw	r26, 0x07	; 7
    1fd0:	4d 91       	ld	r20, X+
    1fd2:	5c 91       	ld	r21, X
    1fd4:	18 97       	sbiw	r26, 0x08	; 8
    1fd6:	da 01       	movw	r26, r20
    1fd8:	4d 91       	ld	r20, X+
    1fda:	5d 91       	ld	r21, X+
    1fdc:	6d 91       	ld	r22, X+
    1fde:	7c 91       	ld	r23, X
    1fe0:	04 17       	cp	r16, r20
    1fe2:	15 07       	cpc	r17, r21
    1fe4:	26 07       	cpc	r18, r22
    1fe6:	37 07       	cpc	r19, r23
    1fe8:	70 f0       	brcs	.+28     	; 0x2006 <vListInsert+0x68>
    1fea:	04 80       	ldd	r0, Z+4	; 0x04
    1fec:	f5 81       	ldd	r31, Z+5	; 0x05
    1fee:	e0 2d       	mov	r30, r0
    1ff0:	a4 81       	ldd	r26, Z+4	; 0x04
    1ff2:	b5 81       	ldd	r27, Z+5	; 0x05
    1ff4:	4d 91       	ld	r20, X+
    1ff6:	5d 91       	ld	r21, X+
    1ff8:	6d 91       	ld	r22, X+
    1ffa:	7c 91       	ld	r23, X
    1ffc:	04 17       	cp	r16, r20
    1ffe:	15 07       	cpc	r17, r21
    2000:	26 07       	cpc	r18, r22
    2002:	37 07       	cpc	r19, r23
    2004:	90 f7       	brcc	.-28     	; 0x1fea <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2006:	a4 81       	ldd	r26, Z+4	; 0x04
    2008:	b5 81       	ldd	r27, Z+5	; 0x05
    200a:	ac 83       	std	Y+4, r26	; 0x04
    200c:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    200e:	16 96       	adiw	r26, 0x06	; 6
    2010:	cd 93       	st	X+, r28
    2012:	dc 93       	st	X, r29
    2014:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    2016:	ee 83       	std	Y+6, r30	; 0x06
    2018:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    201a:	c4 83       	std	Z+4, r28	; 0x04
    201c:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    201e:	8a 87       	std	Y+10, r24	; 0x0a
    2020:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    2022:	fc 01       	movw	r30, r24
    2024:	20 81       	ld	r18, Z
    2026:	2f 5f       	subi	r18, 0xFF	; 255
    2028:	20 83       	st	Z, r18
}
    202a:	df 91       	pop	r29
    202c:	cf 91       	pop	r28
    202e:	1f 91       	pop	r17
    2030:	0f 91       	pop	r16
    2032:	08 95       	ret

00002034 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2034:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2036:	a4 81       	ldd	r26, Z+4	; 0x04
    2038:	b5 81       	ldd	r27, Z+5	; 0x05
    203a:	86 81       	ldd	r24, Z+6	; 0x06
    203c:	97 81       	ldd	r25, Z+7	; 0x07
    203e:	16 96       	adiw	r26, 0x06	; 6
    2040:	8d 93       	st	X+, r24
    2042:	9c 93       	st	X, r25
    2044:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2046:	a6 81       	ldd	r26, Z+6	; 0x06
    2048:	b7 81       	ldd	r27, Z+7	; 0x07
    204a:	84 81       	ldd	r24, Z+4	; 0x04
    204c:	95 81       	ldd	r25, Z+5	; 0x05
    204e:	14 96       	adiw	r26, 0x04	; 4
    2050:	8d 93       	st	X+, r24
    2052:	9c 93       	st	X, r25
    2054:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2056:	a2 85       	ldd	r26, Z+10	; 0x0a
    2058:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    205a:	11 96       	adiw	r26, 0x01	; 1
    205c:	8d 91       	ld	r24, X+
    205e:	9c 91       	ld	r25, X
    2060:	12 97       	sbiw	r26, 0x02	; 2
    2062:	e8 17       	cp	r30, r24
    2064:	f9 07       	cpc	r31, r25
    2066:	31 f4       	brne	.+12     	; 0x2074 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2068:	86 81       	ldd	r24, Z+6	; 0x06
    206a:	97 81       	ldd	r25, Z+7	; 0x07
    206c:	11 96       	adiw	r26, 0x01	; 1
    206e:	8d 93       	st	X+, r24
    2070:	9c 93       	st	X, r25
    2072:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    2074:	12 86       	std	Z+10, r1	; 0x0a
    2076:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    2078:	8c 91       	ld	r24, X
    207a:	81 50       	subi	r24, 0x01	; 1
    207c:	8c 93       	st	X, r24
    207e:	08 95       	ret

00002080 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2080:	80 93 ec 32 	sts	0x32EC, r24	; 0x8032ec <portStackTopForTask>
    2084:	90 93 ed 32 	sts	0x32ED, r25	; 0x8032ed <portStackTopForTask+0x1>
    2088:	31 e1       	ldi	r19, 0x11	; 17
    208a:	fc 01       	movw	r30, r24
    208c:	30 83       	st	Z, r19
    208e:	31 97       	sbiw	r30, 0x01	; 1
    2090:	22 e2       	ldi	r18, 0x22	; 34
    2092:	20 83       	st	Z, r18
    2094:	31 97       	sbiw	r30, 0x01	; 1
    2096:	a3 e3       	ldi	r26, 0x33	; 51
    2098:	a0 83       	st	Z, r26
    209a:	31 97       	sbiw	r30, 0x01	; 1
    209c:	60 83       	st	Z, r22
    209e:	31 97       	sbiw	r30, 0x01	; 1
    20a0:	70 83       	st	Z, r23
    20a2:	31 97       	sbiw	r30, 0x01	; 1
    20a4:	10 82       	st	Z, r1
    20a6:	31 97       	sbiw	r30, 0x01	; 1
    20a8:	10 82       	st	Z, r1
    20aa:	31 97       	sbiw	r30, 0x01	; 1
    20ac:	60 e8       	ldi	r22, 0x80	; 128
    20ae:	60 83       	st	Z, r22
    20b0:	31 97       	sbiw	r30, 0x01	; 1
    20b2:	10 82       	st	Z, r1
    20b4:	31 97       	sbiw	r30, 0x01	; 1
    20b6:	10 82       	st	Z, r1
    20b8:	31 97       	sbiw	r30, 0x01	; 1
    20ba:	10 82       	st	Z, r1
    20bc:	31 97       	sbiw	r30, 0x01	; 1
    20be:	62 e0       	ldi	r22, 0x02	; 2
    20c0:	60 83       	st	Z, r22
    20c2:	31 97       	sbiw	r30, 0x01	; 1
    20c4:	63 e0       	ldi	r22, 0x03	; 3
    20c6:	60 83       	st	Z, r22
    20c8:	31 97       	sbiw	r30, 0x01	; 1
    20ca:	64 e0       	ldi	r22, 0x04	; 4
    20cc:	60 83       	st	Z, r22
    20ce:	31 97       	sbiw	r30, 0x01	; 1
    20d0:	65 e0       	ldi	r22, 0x05	; 5
    20d2:	60 83       	st	Z, r22
    20d4:	31 97       	sbiw	r30, 0x01	; 1
    20d6:	66 e0       	ldi	r22, 0x06	; 6
    20d8:	60 83       	st	Z, r22
    20da:	31 97       	sbiw	r30, 0x01	; 1
    20dc:	67 e0       	ldi	r22, 0x07	; 7
    20de:	60 83       	st	Z, r22
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	68 e0       	ldi	r22, 0x08	; 8
    20e4:	60 83       	st	Z, r22
    20e6:	31 97       	sbiw	r30, 0x01	; 1
    20e8:	69 e0       	ldi	r22, 0x09	; 9
    20ea:	60 83       	st	Z, r22
    20ec:	31 97       	sbiw	r30, 0x01	; 1
    20ee:	60 e1       	ldi	r22, 0x10	; 16
    20f0:	60 83       	st	Z, r22
    20f2:	31 97       	sbiw	r30, 0x01	; 1
    20f4:	30 83       	st	Z, r19
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	32 e1       	ldi	r19, 0x12	; 18
    20fa:	30 83       	st	Z, r19
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	33 e1       	ldi	r19, 0x13	; 19
    2100:	30 83       	st	Z, r19
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	34 e1       	ldi	r19, 0x14	; 20
    2106:	30 83       	st	Z, r19
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	35 e1       	ldi	r19, 0x15	; 21
    210c:	30 83       	st	Z, r19
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	36 e1       	ldi	r19, 0x16	; 22
    2112:	30 83       	st	Z, r19
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	37 e1       	ldi	r19, 0x17	; 23
    2118:	30 83       	st	Z, r19
    211a:	31 97       	sbiw	r30, 0x01	; 1
    211c:	38 e1       	ldi	r19, 0x18	; 24
    211e:	30 83       	st	Z, r19
    2120:	31 97       	sbiw	r30, 0x01	; 1
    2122:	39 e1       	ldi	r19, 0x19	; 25
    2124:	30 83       	st	Z, r19
    2126:	31 97       	sbiw	r30, 0x01	; 1
    2128:	30 e2       	ldi	r19, 0x20	; 32
    212a:	30 83       	st	Z, r19
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	31 e2       	ldi	r19, 0x21	; 33
    2130:	30 83       	st	Z, r19
    2132:	31 97       	sbiw	r30, 0x01	; 1
    2134:	20 83       	st	Z, r18
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	23 e2       	ldi	r18, 0x23	; 35
    213a:	20 83       	st	Z, r18
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	40 83       	st	Z, r20
    2140:	31 97       	sbiw	r30, 0x01	; 1
    2142:	50 83       	st	Z, r21
    2144:	31 97       	sbiw	r30, 0x01	; 1
    2146:	26 e2       	ldi	r18, 0x26	; 38
    2148:	20 83       	st	Z, r18
    214a:	31 97       	sbiw	r30, 0x01	; 1
    214c:	27 e2       	ldi	r18, 0x27	; 39
    214e:	20 83       	st	Z, r18
    2150:	31 97       	sbiw	r30, 0x01	; 1
    2152:	28 e2       	ldi	r18, 0x28	; 40
    2154:	20 83       	st	Z, r18
    2156:	31 97       	sbiw	r30, 0x01	; 1
    2158:	29 e2       	ldi	r18, 0x29	; 41
    215a:	20 83       	st	Z, r18
    215c:	31 97       	sbiw	r30, 0x01	; 1
    215e:	20 e3       	ldi	r18, 0x30	; 48
    2160:	20 83       	st	Z, r18
    2162:	31 97       	sbiw	r30, 0x01	; 1
    2164:	21 e3       	ldi	r18, 0x31	; 49
    2166:	20 83       	st	Z, r18
    2168:	89 97       	sbiw	r24, 0x29	; 41
    216a:	08 95       	ret

0000216c <xPortStartScheduler>:
    216c:	8c e7       	ldi	r24, 0x7C	; 124
    216e:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    2172:	8f ef       	ldi	r24, 0xFF	; 255
    2174:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    2178:	81 e0       	ldi	r24, 0x01	; 1
    217a:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    217e:	91 e1       	ldi	r25, 0x11	; 17
    2180:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    2184:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    2188:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    218c:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2190:	cd 91       	ld	r28, X+
    2192:	cd bf       	out	0x3d, r28	; 61
    2194:	dd 91       	ld	r29, X+
    2196:	de bf       	out	0x3e, r29	; 62
    2198:	ff 91       	pop	r31
    219a:	ef 91       	pop	r30
    219c:	df 91       	pop	r29
    219e:	cf 91       	pop	r28
    21a0:	bf 91       	pop	r27
    21a2:	af 91       	pop	r26
    21a4:	9f 91       	pop	r25
    21a6:	8f 91       	pop	r24
    21a8:	7f 91       	pop	r23
    21aa:	6f 91       	pop	r22
    21ac:	5f 91       	pop	r21
    21ae:	4f 91       	pop	r20
    21b0:	3f 91       	pop	r19
    21b2:	2f 91       	pop	r18
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	ff 90       	pop	r15
    21ba:	ef 90       	pop	r14
    21bc:	df 90       	pop	r13
    21be:	cf 90       	pop	r12
    21c0:	bf 90       	pop	r11
    21c2:	af 90       	pop	r10
    21c4:	9f 90       	pop	r9
    21c6:	8f 90       	pop	r8
    21c8:	7f 90       	pop	r7
    21ca:	6f 90       	pop	r6
    21cc:	5f 90       	pop	r5
    21ce:	4f 90       	pop	r4
    21d0:	3f 90       	pop	r3
    21d2:	2f 90       	pop	r2
    21d4:	1f 90       	pop	r1
    21d6:	0f 90       	pop	r0
    21d8:	0c be       	out	0x3c, r0	; 60
    21da:	0f 90       	pop	r0
    21dc:	0b be       	out	0x3b, r0	; 59
    21de:	0f 90       	pop	r0
    21e0:	0f be       	out	0x3f, r0	; 63
    21e2:	0f 90       	pop	r0
    21e4:	08 95       	ret
    21e6:	08 95       	ret

000021e8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    21e8:	0f 92       	push	r0
    21ea:	0f b6       	in	r0, 0x3f	; 63
    21ec:	f8 94       	cli
    21ee:	0f 92       	push	r0
    21f0:	0b b6       	in	r0, 0x3b	; 59
    21f2:	0f 92       	push	r0
    21f4:	0c b6       	in	r0, 0x3c	; 60
    21f6:	0f 92       	push	r0
    21f8:	1f 92       	push	r1
    21fa:	11 24       	eor	r1, r1
    21fc:	2f 92       	push	r2
    21fe:	3f 92       	push	r3
    2200:	4f 92       	push	r4
    2202:	5f 92       	push	r5
    2204:	6f 92       	push	r6
    2206:	7f 92       	push	r7
    2208:	8f 92       	push	r8
    220a:	9f 92       	push	r9
    220c:	af 92       	push	r10
    220e:	bf 92       	push	r11
    2210:	cf 92       	push	r12
    2212:	df 92       	push	r13
    2214:	ef 92       	push	r14
    2216:	ff 92       	push	r15
    2218:	0f 93       	push	r16
    221a:	1f 93       	push	r17
    221c:	2f 93       	push	r18
    221e:	3f 93       	push	r19
    2220:	4f 93       	push	r20
    2222:	5f 93       	push	r21
    2224:	6f 93       	push	r22
    2226:	7f 93       	push	r23
    2228:	8f 93       	push	r24
    222a:	9f 93       	push	r25
    222c:	af 93       	push	r26
    222e:	bf 93       	push	r27
    2230:	cf 93       	push	r28
    2232:	df 93       	push	r29
    2234:	ef 93       	push	r30
    2236:	ff 93       	push	r31
    2238:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    223c:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2240:	0d b6       	in	r0, 0x3d	; 61
    2242:	0d 92       	st	X+, r0
    2244:	0e b6       	in	r0, 0x3e	; 62
    2246:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2248:	0e 94 03 18 	call	0x3006	; 0x3006 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    224c:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    2250:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2254:	cd 91       	ld	r28, X+
    2256:	cd bf       	out	0x3d, r28	; 61
    2258:	dd 91       	ld	r29, X+
    225a:	de bf       	out	0x3e, r29	; 62
    225c:	ff 91       	pop	r31
    225e:	ef 91       	pop	r30
    2260:	df 91       	pop	r29
    2262:	cf 91       	pop	r28
    2264:	bf 91       	pop	r27
    2266:	af 91       	pop	r26
    2268:	9f 91       	pop	r25
    226a:	8f 91       	pop	r24
    226c:	7f 91       	pop	r23
    226e:	6f 91       	pop	r22
    2270:	5f 91       	pop	r21
    2272:	4f 91       	pop	r20
    2274:	3f 91       	pop	r19
    2276:	2f 91       	pop	r18
    2278:	1f 91       	pop	r17
    227a:	0f 91       	pop	r16
    227c:	ff 90       	pop	r15
    227e:	ef 90       	pop	r14
    2280:	df 90       	pop	r13
    2282:	cf 90       	pop	r12
    2284:	bf 90       	pop	r11
    2286:	af 90       	pop	r10
    2288:	9f 90       	pop	r9
    228a:	8f 90       	pop	r8
    228c:	7f 90       	pop	r7
    228e:	6f 90       	pop	r6
    2290:	5f 90       	pop	r5
    2292:	4f 90       	pop	r4
    2294:	3f 90       	pop	r3
    2296:	2f 90       	pop	r2
    2298:	1f 90       	pop	r1
    229a:	0f 90       	pop	r0
    229c:	0c be       	out	0x3c, r0	; 60
    229e:	0f 90       	pop	r0
    22a0:	0b be       	out	0x3b, r0	; 59
    22a2:	0f 90       	pop	r0
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22a8:	08 95       	ret

000022aa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22aa:	0f 92       	push	r0
    22ac:	0f b6       	in	r0, 0x3f	; 63
    22ae:	f8 94       	cli
    22b0:	0f 92       	push	r0
    22b2:	0b b6       	in	r0, 0x3b	; 59
    22b4:	0f 92       	push	r0
    22b6:	0c b6       	in	r0, 0x3c	; 60
    22b8:	0f 92       	push	r0
    22ba:	1f 92       	push	r1
    22bc:	11 24       	eor	r1, r1
    22be:	2f 92       	push	r2
    22c0:	3f 92       	push	r3
    22c2:	4f 92       	push	r4
    22c4:	5f 92       	push	r5
    22c6:	6f 92       	push	r6
    22c8:	7f 92       	push	r7
    22ca:	8f 92       	push	r8
    22cc:	9f 92       	push	r9
    22ce:	af 92       	push	r10
    22d0:	bf 92       	push	r11
    22d2:	cf 92       	push	r12
    22d4:	df 92       	push	r13
    22d6:	ef 92       	push	r14
    22d8:	ff 92       	push	r15
    22da:	0f 93       	push	r16
    22dc:	1f 93       	push	r17
    22de:	2f 93       	push	r18
    22e0:	3f 93       	push	r19
    22e2:	4f 93       	push	r20
    22e4:	5f 93       	push	r21
    22e6:	6f 93       	push	r22
    22e8:	7f 93       	push	r23
    22ea:	8f 93       	push	r24
    22ec:	9f 93       	push	r25
    22ee:	af 93       	push	r26
    22f0:	bf 93       	push	r27
    22f2:	cf 93       	push	r28
    22f4:	df 93       	push	r29
    22f6:	ef 93       	push	r30
    22f8:	ff 93       	push	r31
    22fa:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    22fe:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2302:	0d b6       	in	r0, 0x3d	; 61
    2304:	0d 92       	st	X+, r0
    2306:	0e b6       	in	r0, 0x3e	; 62
    2308:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    230a:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <vTaskIncrementTick>
	vTaskSwitchContext();
    230e:	0e 94 03 18 	call	0x3006	; 0x3006 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2312:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    2316:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    231a:	cd 91       	ld	r28, X+
    231c:	cd bf       	out	0x3d, r28	; 61
    231e:	dd 91       	ld	r29, X+
    2320:	de bf       	out	0x3e, r29	; 62
    2322:	ff 91       	pop	r31
    2324:	ef 91       	pop	r30
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	bf 91       	pop	r27
    232c:	af 91       	pop	r26
    232e:	9f 91       	pop	r25
    2330:	8f 91       	pop	r24
    2332:	7f 91       	pop	r23
    2334:	6f 91       	pop	r22
    2336:	5f 91       	pop	r21
    2338:	4f 91       	pop	r20
    233a:	3f 91       	pop	r19
    233c:	2f 91       	pop	r18
    233e:	1f 91       	pop	r17
    2340:	0f 91       	pop	r16
    2342:	ff 90       	pop	r15
    2344:	ef 90       	pop	r14
    2346:	df 90       	pop	r13
    2348:	cf 90       	pop	r12
    234a:	bf 90       	pop	r11
    234c:	af 90       	pop	r10
    234e:	9f 90       	pop	r9
    2350:	8f 90       	pop	r8
    2352:	7f 90       	pop	r7
    2354:	6f 90       	pop	r6
    2356:	5f 90       	pop	r5
    2358:	4f 90       	pop	r4
    235a:	3f 90       	pop	r3
    235c:	2f 90       	pop	r2
    235e:	1f 90       	pop	r1
    2360:	0f 90       	pop	r0
    2362:	0c be       	out	0x3c, r0	; 60
    2364:	0f 90       	pop	r0
    2366:	0b be       	out	0x3b, r0	; 59
    2368:	0f 90       	pop	r0
    236a:	0f be       	out	0x3f, r0	; 63
    236c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    236e:	08 95       	ret

00002370 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    2370:	0e 94 55 11 	call	0x22aa	; 0x22aa <vPortYieldFromTick>
		asm volatile ( "reti" );
    2374:	18 95       	reti

00002376 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2376:	cf 93       	push	r28
    2378:	df 93       	push	r29
    237a:	ec 01       	movw	r28, r24
    237c:	88 a1       	ldd	r24, Y+32	; 0x20
    237e:	81 11       	cpse	r24, r1
    2380:	0b c0       	rjmp	.+22     	; 0x2398 <prvCopyDataToQueue+0x22>
    2382:	88 81       	ld	r24, Y
    2384:	99 81       	ldd	r25, Y+1	; 0x01
    2386:	89 2b       	or	r24, r25
    2388:	e1 f5       	brne	.+120    	; 0x2402 <prvCopyDataToQueue+0x8c>
    238a:	8a 81       	ldd	r24, Y+2	; 0x02
    238c:	9b 81       	ldd	r25, Y+3	; 0x03
    238e:	0e 94 be 19 	call	0x337c	; 0x337c <vTaskPriorityDisinherit>
    2392:	1a 82       	std	Y+2, r1	; 0x02
    2394:	1b 82       	std	Y+3, r1	; 0x03
    2396:	35 c0       	rjmp	.+106    	; 0x2402 <prvCopyDataToQueue+0x8c>
    2398:	41 11       	cpse	r20, r1
    239a:	17 c0       	rjmp	.+46     	; 0x23ca <prvCopyDataToQueue+0x54>
    239c:	48 2f       	mov	r20, r24
    239e:	50 e0       	ldi	r21, 0x00	; 0
    23a0:	8c 81       	ldd	r24, Y+4	; 0x04
    23a2:	9d 81       	ldd	r25, Y+5	; 0x05
    23a4:	0e 94 fd 26 	call	0x4dfa	; 0x4dfa <memcpy>
    23a8:	28 a1       	ldd	r18, Y+32	; 0x20
    23aa:	8c 81       	ldd	r24, Y+4	; 0x04
    23ac:	9d 81       	ldd	r25, Y+5	; 0x05
    23ae:	82 0f       	add	r24, r18
    23b0:	91 1d       	adc	r25, r1
    23b2:	8c 83       	std	Y+4, r24	; 0x04
    23b4:	9d 83       	std	Y+5, r25	; 0x05
    23b6:	2a 81       	ldd	r18, Y+2	; 0x02
    23b8:	3b 81       	ldd	r19, Y+3	; 0x03
    23ba:	82 17       	cp	r24, r18
    23bc:	93 07       	cpc	r25, r19
    23be:	08 f1       	brcs	.+66     	; 0x2402 <prvCopyDataToQueue+0x8c>
    23c0:	88 81       	ld	r24, Y
    23c2:	99 81       	ldd	r25, Y+1	; 0x01
    23c4:	8c 83       	std	Y+4, r24	; 0x04
    23c6:	9d 83       	std	Y+5, r25	; 0x05
    23c8:	1c c0       	rjmp	.+56     	; 0x2402 <prvCopyDataToQueue+0x8c>
    23ca:	48 2f       	mov	r20, r24
    23cc:	50 e0       	ldi	r21, 0x00	; 0
    23ce:	8e 81       	ldd	r24, Y+6	; 0x06
    23d0:	9f 81       	ldd	r25, Y+7	; 0x07
    23d2:	0e 94 fd 26 	call	0x4dfa	; 0x4dfa <memcpy>
    23d6:	88 a1       	ldd	r24, Y+32	; 0x20
    23d8:	90 e0       	ldi	r25, 0x00	; 0
    23da:	91 95       	neg	r25
    23dc:	81 95       	neg	r24
    23de:	91 09       	sbc	r25, r1
    23e0:	2e 81       	ldd	r18, Y+6	; 0x06
    23e2:	3f 81       	ldd	r19, Y+7	; 0x07
    23e4:	28 0f       	add	r18, r24
    23e6:	39 1f       	adc	r19, r25
    23e8:	2e 83       	std	Y+6, r18	; 0x06
    23ea:	3f 83       	std	Y+7, r19	; 0x07
    23ec:	48 81       	ld	r20, Y
    23ee:	59 81       	ldd	r21, Y+1	; 0x01
    23f0:	24 17       	cp	r18, r20
    23f2:	35 07       	cpc	r19, r21
    23f4:	30 f4       	brcc	.+12     	; 0x2402 <prvCopyDataToQueue+0x8c>
    23f6:	2a 81       	ldd	r18, Y+2	; 0x02
    23f8:	3b 81       	ldd	r19, Y+3	; 0x03
    23fa:	82 0f       	add	r24, r18
    23fc:	93 1f       	adc	r25, r19
    23fe:	8e 83       	std	Y+6, r24	; 0x06
    2400:	9f 83       	std	Y+7, r25	; 0x07
    2402:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2404:	8f 5f       	subi	r24, 0xFF	; 255
    2406:	8e 8f       	std	Y+30, r24	; 0x1e
    2408:	df 91       	pop	r29
    240a:	cf 91       	pop	r28
    240c:	08 95       	ret

0000240e <prvCopyDataFromQueue>:
    240e:	fc 01       	movw	r30, r24
    2410:	80 81       	ld	r24, Z
    2412:	91 81       	ldd	r25, Z+1	; 0x01
    2414:	00 97       	sbiw	r24, 0x00	; 0
    2416:	a1 f0       	breq	.+40     	; 0x2440 <prvCopyDataFromQueue+0x32>
    2418:	40 a1       	ldd	r20, Z+32	; 0x20
    241a:	50 e0       	ldi	r21, 0x00	; 0
    241c:	26 81       	ldd	r18, Z+6	; 0x06
    241e:	37 81       	ldd	r19, Z+7	; 0x07
    2420:	24 0f       	add	r18, r20
    2422:	35 1f       	adc	r19, r21
    2424:	26 83       	std	Z+6, r18	; 0x06
    2426:	37 83       	std	Z+7, r19	; 0x07
    2428:	a2 81       	ldd	r26, Z+2	; 0x02
    242a:	b3 81       	ldd	r27, Z+3	; 0x03
    242c:	2a 17       	cp	r18, r26
    242e:	3b 07       	cpc	r19, r27
    2430:	10 f0       	brcs	.+4      	; 0x2436 <prvCopyDataFromQueue+0x28>
    2432:	86 83       	std	Z+6, r24	; 0x06
    2434:	97 83       	std	Z+7, r25	; 0x07
    2436:	cb 01       	movw	r24, r22
    2438:	66 81       	ldd	r22, Z+6	; 0x06
    243a:	77 81       	ldd	r23, Z+7	; 0x07
    243c:	0e 94 fd 26 	call	0x4dfa	; 0x4dfa <memcpy>
    2440:	08 95       	ret

00002442 <prvUnlockQueue>:
    2442:	0f 93       	push	r16
    2444:	1f 93       	push	r17
    2446:	cf 93       	push	r28
    2448:	df 93       	push	r29
    244a:	ec 01       	movw	r28, r24
    244c:	0f b6       	in	r0, 0x3f	; 63
    244e:	f8 94       	cli
    2450:	0f 92       	push	r0
    2452:	8a a1       	ldd	r24, Y+34	; 0x22
    2454:	18 16       	cp	r1, r24
    2456:	b4 f4       	brge	.+44     	; 0x2484 <prvUnlockQueue+0x42>
    2458:	8b 89       	ldd	r24, Y+19	; 0x13
    245a:	81 11       	cpse	r24, r1
    245c:	05 c0       	rjmp	.+10     	; 0x2468 <prvUnlockQueue+0x26>
    245e:	12 c0       	rjmp	.+36     	; 0x2484 <prvUnlockQueue+0x42>
    2460:	8b 89       	ldd	r24, Y+19	; 0x13
    2462:	81 11       	cpse	r24, r1
    2464:	04 c0       	rjmp	.+8      	; 0x246e <prvUnlockQueue+0x2c>
    2466:	0e c0       	rjmp	.+28     	; 0x2484 <prvUnlockQueue+0x42>
    2468:	8e 01       	movw	r16, r28
    246a:	0d 5e       	subi	r16, 0xED	; 237
    246c:	1f 4f       	sbci	r17, 0xFF	; 255
    246e:	c8 01       	movw	r24, r16
    2470:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    2474:	81 11       	cpse	r24, r1
    2476:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskMissedYield>
    247a:	8a a1       	ldd	r24, Y+34	; 0x22
    247c:	81 50       	subi	r24, 0x01	; 1
    247e:	8a a3       	std	Y+34, r24	; 0x22
    2480:	18 16       	cp	r1, r24
    2482:	74 f3       	brlt	.-36     	; 0x2460 <prvUnlockQueue+0x1e>
    2484:	8f ef       	ldi	r24, 0xFF	; 255
    2486:	8a a3       	std	Y+34, r24	; 0x22
    2488:	0f 90       	pop	r0
    248a:	0f be       	out	0x3f, r0	; 63
    248c:	0f b6       	in	r0, 0x3f	; 63
    248e:	f8 94       	cli
    2490:	0f 92       	push	r0
    2492:	89 a1       	ldd	r24, Y+33	; 0x21
    2494:	18 16       	cp	r1, r24
    2496:	b4 f4       	brge	.+44     	; 0x24c4 <prvUnlockQueue+0x82>
    2498:	88 85       	ldd	r24, Y+8	; 0x08
    249a:	81 11       	cpse	r24, r1
    249c:	05 c0       	rjmp	.+10     	; 0x24a8 <prvUnlockQueue+0x66>
    249e:	12 c0       	rjmp	.+36     	; 0x24c4 <prvUnlockQueue+0x82>
    24a0:	88 85       	ldd	r24, Y+8	; 0x08
    24a2:	81 11       	cpse	r24, r1
    24a4:	04 c0       	rjmp	.+8      	; 0x24ae <prvUnlockQueue+0x6c>
    24a6:	0e c0       	rjmp	.+28     	; 0x24c4 <prvUnlockQueue+0x82>
    24a8:	8e 01       	movw	r16, r28
    24aa:	08 5f       	subi	r16, 0xF8	; 248
    24ac:	1f 4f       	sbci	r17, 0xFF	; 255
    24ae:	c8 01       	movw	r24, r16
    24b0:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    24b4:	81 11       	cpse	r24, r1
    24b6:	0e 94 47 19 	call	0x328e	; 0x328e <vTaskMissedYield>
    24ba:	89 a1       	ldd	r24, Y+33	; 0x21
    24bc:	81 50       	subi	r24, 0x01	; 1
    24be:	89 a3       	std	Y+33, r24	; 0x21
    24c0:	18 16       	cp	r1, r24
    24c2:	74 f3       	brlt	.-36     	; 0x24a0 <prvUnlockQueue+0x5e>
    24c4:	8f ef       	ldi	r24, 0xFF	; 255
    24c6:	89 a3       	std	Y+33, r24	; 0x21
    24c8:	0f 90       	pop	r0
    24ca:	0f be       	out	0x3f, r0	; 63
    24cc:	df 91       	pop	r29
    24ce:	cf 91       	pop	r28
    24d0:	1f 91       	pop	r17
    24d2:	0f 91       	pop	r16
    24d4:	08 95       	ret

000024d6 <xQueueGenericReset>:
    24d6:	1f 93       	push	r17
    24d8:	cf 93       	push	r28
    24da:	df 93       	push	r29
    24dc:	61 30       	cpi	r22, 0x01	; 1
    24de:	59 f0       	breq	.+22     	; 0x24f6 <xQueueGenericReset+0x20>
    24e0:	fc 01       	movw	r30, r24
    24e2:	23 89       	ldd	r18, Z+19	; 0x13
    24e4:	30 85       	ldd	r19, Z+8	; 0x08
    24e6:	31 11       	cpse	r19, r1
    24e8:	2c c0       	rjmp	.+88     	; 0x2542 <xQueueGenericReset+0x6c>
    24ea:	11 e0       	ldi	r17, 0x01	; 1
    24ec:	21 11       	cpse	r18, r1
    24ee:	10 e0       	ldi	r17, 0x00	; 0
    24f0:	21 11       	cpse	r18, r1
    24f2:	28 c0       	rjmp	.+80     	; 0x2544 <xQueueGenericReset+0x6e>
    24f4:	01 c0       	rjmp	.+2      	; 0x24f8 <xQueueGenericReset+0x22>
    24f6:	11 e0       	ldi	r17, 0x01	; 1
    24f8:	ec 01       	movw	r28, r24
    24fa:	48 81       	ld	r20, Y
    24fc:	59 81       	ldd	r21, Y+1	; 0x01
    24fe:	28 a1       	ldd	r18, Y+32	; 0x20
    2500:	30 e0       	ldi	r19, 0x00	; 0
    2502:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2504:	62 9f       	mul	r22, r18
    2506:	c0 01       	movw	r24, r0
    2508:	63 9f       	mul	r22, r19
    250a:	90 0d       	add	r25, r0
    250c:	11 24       	eor	r1, r1
    250e:	ba 01       	movw	r22, r20
    2510:	68 0f       	add	r22, r24
    2512:	79 1f       	adc	r23, r25
    2514:	6a 83       	std	Y+2, r22	; 0x02
    2516:	7b 83       	std	Y+3, r23	; 0x03
    2518:	1e 8e       	std	Y+30, r1	; 0x1e
    251a:	4c 83       	std	Y+4, r20	; 0x04
    251c:	5d 83       	std	Y+5, r21	; 0x05
    251e:	82 1b       	sub	r24, r18
    2520:	93 0b       	sbc	r25, r19
    2522:	84 0f       	add	r24, r20
    2524:	95 1f       	adc	r25, r21
    2526:	8e 83       	std	Y+6, r24	; 0x06
    2528:	9f 83       	std	Y+7, r25	; 0x07
    252a:	8f ef       	ldi	r24, 0xFF	; 255
    252c:	89 a3       	std	Y+33, r24	; 0x21
    252e:	8a a3       	std	Y+34, r24	; 0x22
    2530:	ce 01       	movw	r24, r28
    2532:	08 96       	adiw	r24, 0x08	; 8
    2534:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2538:	ce 01       	movw	r24, r28
    253a:	43 96       	adiw	r24, 0x13	; 19
    253c:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2540:	01 c0       	rjmp	.+2      	; 0x2544 <xQueueGenericReset+0x6e>
    2542:	10 e0       	ldi	r17, 0x00	; 0
    2544:	81 2f       	mov	r24, r17
    2546:	df 91       	pop	r29
    2548:	cf 91       	pop	r28
    254a:	1f 91       	pop	r17
    254c:	08 95       	ret

0000254e <xQueueGenericCreate>:
    254e:	0f 93       	push	r16
    2550:	1f 93       	push	r17
    2552:	cf 93       	push	r28
    2554:	df 93       	push	r29
    2556:	88 23       	and	r24, r24
    2558:	01 f1       	breq	.+64     	; 0x259a <xQueueGenericCreate+0x4c>
    255a:	06 2f       	mov	r16, r22
    255c:	18 2f       	mov	r17, r24
    255e:	83 e2       	ldi	r24, 0x23	; 35
    2560:	90 e0       	ldi	r25, 0x00	; 0
    2562:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    2566:	ec 01       	movw	r28, r24
    2568:	89 2b       	or	r24, r25
    256a:	c9 f0       	breq	.+50     	; 0x259e <xQueueGenericCreate+0x50>
    256c:	10 9f       	mul	r17, r16
    256e:	c0 01       	movw	r24, r0
    2570:	11 24       	eor	r1, r1
    2572:	01 96       	adiw	r24, 0x01	; 1
    2574:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    2578:	88 83       	st	Y, r24
    257a:	99 83       	std	Y+1, r25	; 0x01
    257c:	89 2b       	or	r24, r25
    257e:	39 f0       	breq	.+14     	; 0x258e <xQueueGenericCreate+0x40>
    2580:	1f 8f       	std	Y+31, r17	; 0x1f
    2582:	08 a3       	std	Y+32, r16	; 0x20
    2584:	61 e0       	ldi	r22, 0x01	; 1
    2586:	ce 01       	movw	r24, r28
    2588:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <xQueueGenericReset>
    258c:	08 c0       	rjmp	.+16     	; 0x259e <xQueueGenericCreate+0x50>
    258e:	ce 01       	movw	r24, r28
    2590:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <vPortFree>
    2594:	c0 e0       	ldi	r28, 0x00	; 0
    2596:	d0 e0       	ldi	r29, 0x00	; 0
    2598:	02 c0       	rjmp	.+4      	; 0x259e <xQueueGenericCreate+0x50>
    259a:	c0 e0       	ldi	r28, 0x00	; 0
    259c:	d0 e0       	ldi	r29, 0x00	; 0
    259e:	ce 01       	movw	r24, r28
    25a0:	df 91       	pop	r29
    25a2:	cf 91       	pop	r28
    25a4:	1f 91       	pop	r17
    25a6:	0f 91       	pop	r16
    25a8:	08 95       	ret

000025aa <xQueueGenericSend>:
    25aa:	af 92       	push	r10
    25ac:	bf 92       	push	r11
    25ae:	cf 92       	push	r12
    25b0:	df 92       	push	r13
    25b2:	ef 92       	push	r14
    25b4:	ff 92       	push	r15
    25b6:	0f 93       	push	r16
    25b8:	1f 93       	push	r17
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
    25be:	cd b7       	in	r28, 0x3d	; 61
    25c0:	de b7       	in	r29, 0x3e	; 62
    25c2:	29 97       	sbiw	r28, 0x09	; 9
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	de bf       	out	0x3e, r29	; 62
    25c8:	7c 01       	movw	r14, r24
    25ca:	5b 01       	movw	r10, r22
    25cc:	2e 83       	std	Y+6, r18	; 0x06
    25ce:	3f 83       	std	Y+7, r19	; 0x07
    25d0:	48 87       	std	Y+8, r20	; 0x08
    25d2:	59 87       	std	Y+9, r21	; 0x09
    25d4:	10 e0       	ldi	r17, 0x00	; 0
    25d6:	6c 01       	movw	r12, r24
    25d8:	88 e0       	ldi	r24, 0x08	; 8
    25da:	c8 0e       	add	r12, r24
    25dc:	d1 1c       	adc	r13, r1
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	f8 94       	cli
    25e2:	0f 92       	push	r0
    25e4:	f7 01       	movw	r30, r14
    25e6:	96 8d       	ldd	r25, Z+30	; 0x1e
    25e8:	87 8d       	ldd	r24, Z+31	; 0x1f
    25ea:	98 17       	cp	r25, r24
    25ec:	a8 f4       	brcc	.+42     	; 0x2618 <xQueueGenericSend+0x6e>
    25ee:	40 2f       	mov	r20, r16
    25f0:	b5 01       	movw	r22, r10
    25f2:	c7 01       	movw	r24, r14
    25f4:	0e 94 bb 11 	call	0x2376	; 0x2376 <prvCopyDataToQueue>
    25f8:	f7 01       	movw	r30, r14
    25fa:	83 89       	ldd	r24, Z+19	; 0x13
    25fc:	88 23       	and	r24, r24
    25fe:	41 f0       	breq	.+16     	; 0x2610 <xQueueGenericSend+0x66>
    2600:	c7 01       	movw	r24, r14
    2602:	43 96       	adiw	r24, 0x13	; 19
    2604:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    2608:	81 30       	cpi	r24, 0x01	; 1
    260a:	11 f4       	brne	.+4      	; 0x2610 <xQueueGenericSend+0x66>
    260c:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    2610:	0f 90       	pop	r0
    2612:	0f be       	out	0x3f, r0	; 63
    2614:	81 e0       	ldi	r24, 0x01	; 1
    2616:	56 c0       	rjmp	.+172    	; 0x26c4 <xQueueGenericSend+0x11a>
    2618:	8e 81       	ldd	r24, Y+6	; 0x06
    261a:	9f 81       	ldd	r25, Y+7	; 0x07
    261c:	a8 85       	ldd	r26, Y+8	; 0x08
    261e:	b9 85       	ldd	r27, Y+9	; 0x09
    2620:	89 2b       	or	r24, r25
    2622:	8a 2b       	or	r24, r26
    2624:	8b 2b       	or	r24, r27
    2626:	21 f4       	brne	.+8      	; 0x2630 <xQueueGenericSend+0x86>
    2628:	0f 90       	pop	r0
    262a:	0f be       	out	0x3f, r0	; 63
    262c:	80 e0       	ldi	r24, 0x00	; 0
    262e:	4a c0       	rjmp	.+148    	; 0x26c4 <xQueueGenericSend+0x11a>
    2630:	11 11       	cpse	r17, r1
    2632:	05 c0       	rjmp	.+10     	; 0x263e <xQueueGenericSend+0x94>
    2634:	ce 01       	movw	r24, r28
    2636:	01 96       	adiw	r24, 0x01	; 1
    2638:	0e 94 c9 18 	call	0x3192	; 0x3192 <vTaskSetTimeOutState>
    263c:	11 e0       	ldi	r17, 0x01	; 1
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vTaskSuspendAll>
    2646:	0f b6       	in	r0, 0x3f	; 63
    2648:	f8 94       	cli
    264a:	0f 92       	push	r0
    264c:	f7 01       	movw	r30, r14
    264e:	81 a1       	ldd	r24, Z+33	; 0x21
    2650:	8f 3f       	cpi	r24, 0xFF	; 255
    2652:	09 f4       	brne	.+2      	; 0x2656 <xQueueGenericSend+0xac>
    2654:	11 a2       	std	Z+33, r1	; 0x21
    2656:	f7 01       	movw	r30, r14
    2658:	82 a1       	ldd	r24, Z+34	; 0x22
    265a:	8f 3f       	cpi	r24, 0xFF	; 255
    265c:	09 f4       	brne	.+2      	; 0x2660 <xQueueGenericSend+0xb6>
    265e:	12 a2       	std	Z+34, r1	; 0x22
    2660:	0f 90       	pop	r0
    2662:	0f be       	out	0x3f, r0	; 63
    2664:	be 01       	movw	r22, r28
    2666:	6a 5f       	subi	r22, 0xFA	; 250
    2668:	7f 4f       	sbci	r23, 0xFF	; 255
    266a:	ce 01       	movw	r24, r28
    266c:	01 96       	adiw	r24, 0x01	; 1
    266e:	0e 94 da 18 	call	0x31b4	; 0x31b4 <xTaskCheckForTimeOut>
    2672:	81 11       	cpse	r24, r1
    2674:	21 c0       	rjmp	.+66     	; 0x26b8 <xQueueGenericSend+0x10e>
    2676:	0f b6       	in	r0, 0x3f	; 63
    2678:	f8 94       	cli
    267a:	0f 92       	push	r0
    267c:	f7 01       	movw	r30, r14
    267e:	96 8d       	ldd	r25, Z+30	; 0x1e
    2680:	0f 90       	pop	r0
    2682:	0f be       	out	0x3f, r0	; 63
    2684:	87 8d       	ldd	r24, Z+31	; 0x1f
    2686:	98 13       	cpse	r25, r24
    2688:	11 c0       	rjmp	.+34     	; 0x26ac <xQueueGenericSend+0x102>
    268a:	4e 81       	ldd	r20, Y+6	; 0x06
    268c:	5f 81       	ldd	r21, Y+7	; 0x07
    268e:	68 85       	ldd	r22, Y+8	; 0x08
    2690:	79 85       	ldd	r23, Y+9	; 0x09
    2692:	c6 01       	movw	r24, r12
    2694:	0e 94 60 18 	call	0x30c0	; 0x30c0 <vTaskPlaceOnEventList>
    2698:	c7 01       	movw	r24, r14
    269a:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
    269e:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
    26a2:	81 11       	cpse	r24, r1
    26a4:	9c cf       	rjmp	.-200    	; 0x25de <xQueueGenericSend+0x34>
    26a6:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    26aa:	99 cf       	rjmp	.-206    	; 0x25de <xQueueGenericSend+0x34>
    26ac:	c7 01       	movw	r24, r14
    26ae:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
    26b2:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
    26b6:	93 cf       	rjmp	.-218    	; 0x25de <xQueueGenericSend+0x34>
    26b8:	c7 01       	movw	r24, r14
    26ba:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
    26be:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
    26c2:	80 e0       	ldi	r24, 0x00	; 0
    26c4:	29 96       	adiw	r28, 0x09	; 9
    26c6:	cd bf       	out	0x3d, r28	; 61
    26c8:	de bf       	out	0x3e, r29	; 62
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	0f 91       	pop	r16
    26d2:	ff 90       	pop	r15
    26d4:	ef 90       	pop	r14
    26d6:	df 90       	pop	r13
    26d8:	cf 90       	pop	r12
    26da:	bf 90       	pop	r11
    26dc:	af 90       	pop	r10
    26de:	08 95       	ret

000026e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    26e0:	0f 93       	push	r16
    26e2:	1f 93       	push	r17
    26e4:	cf 93       	push	r28
    26e6:	df 93       	push	r29
    26e8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    26ea:	fc 01       	movw	r30, r24
    26ec:	56 8d       	ldd	r21, Z+30	; 0x1e
    26ee:	37 8d       	ldd	r19, Z+31	; 0x1f
    26f0:	53 17       	cp	r21, r19
    26f2:	c0 f4       	brcc	.+48     	; 0x2724 <xQueueGenericSendFromISR+0x44>
    26f4:	42 2f       	mov	r20, r18
    26f6:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26f8:	0e 94 bb 11 	call	0x2376	; 0x2376 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    26fc:	8a a1       	ldd	r24, Y+34	; 0x22
    26fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2700:	69 f4       	brne	.+26     	; 0x271c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2702:	8b 89       	ldd	r24, Y+19	; 0x13
    2704:	88 23       	and	r24, r24
    2706:	81 f0       	breq	.+32     	; 0x2728 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2708:	ce 01       	movw	r24, r28
    270a:	43 96       	adiw	r24, 0x13	; 19
    270c:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    2710:	88 23       	and	r24, r24
    2712:	61 f0       	breq	.+24     	; 0x272c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2714:	81 e0       	ldi	r24, 0x01	; 1
    2716:	f8 01       	movw	r30, r16
    2718:	80 83       	st	Z, r24
    271a:	09 c0       	rjmp	.+18     	; 0x272e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    271c:	8f 5f       	subi	r24, 0xFF	; 255
    271e:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	05 c0       	rjmp	.+10     	; 0x272e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2724:	80 e0       	ldi	r24, 0x00	; 0
    2726:	03 c0       	rjmp	.+6      	; 0x272e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2728:	81 e0       	ldi	r24, 0x01	; 1
    272a:	01 c0       	rjmp	.+2      	; 0x272e <xQueueGenericSendFromISR+0x4e>
    272c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    272e:	df 91       	pop	r29
    2730:	cf 91       	pop	r28
    2732:	1f 91       	pop	r17
    2734:	0f 91       	pop	r16
    2736:	08 95       	ret

00002738 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2738:	af 92       	push	r10
    273a:	bf 92       	push	r11
    273c:	cf 92       	push	r12
    273e:	df 92       	push	r13
    2740:	ef 92       	push	r14
    2742:	ff 92       	push	r15
    2744:	0f 93       	push	r16
    2746:	1f 93       	push	r17
    2748:	cf 93       	push	r28
    274a:	df 93       	push	r29
    274c:	cd b7       	in	r28, 0x3d	; 61
    274e:	de b7       	in	r29, 0x3e	; 62
    2750:	29 97       	sbiw	r28, 0x09	; 9
    2752:	cd bf       	out	0x3d, r28	; 61
    2754:	de bf       	out	0x3e, r29	; 62
    2756:	7c 01       	movw	r14, r24
    2758:	5b 01       	movw	r10, r22
    275a:	2e 83       	std	Y+6, r18	; 0x06
    275c:	3f 83       	std	Y+7, r19	; 0x07
    275e:	48 87       	std	Y+8, r20	; 0x08
    2760:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2762:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2764:	6c 01       	movw	r12, r24
    2766:	83 e1       	ldi	r24, 0x13	; 19
    2768:	c8 0e       	add	r12, r24
    276a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    276c:	0f b6       	in	r0, 0x3f	; 63
    276e:	f8 94       	cli
    2770:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2772:	f7 01       	movw	r30, r14
    2774:	86 8d       	ldd	r24, Z+30	; 0x1e
    2776:	88 23       	and	r24, r24
    2778:	99 f1       	breq	.+102    	; 0x27e0 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    277a:	c6 80       	ldd	r12, Z+6	; 0x06
    277c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    277e:	b5 01       	movw	r22, r10
    2780:	c7 01       	movw	r24, r14
    2782:	0e 94 07 12 	call	0x240e	; 0x240e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2786:	01 11       	cpse	r16, r1
    2788:	1a c0       	rjmp	.+52     	; 0x27be <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    278a:	f7 01       	movw	r30, r14
    278c:	86 8d       	ldd	r24, Z+30	; 0x1e
    278e:	81 50       	subi	r24, 0x01	; 1
    2790:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2792:	80 81       	ld	r24, Z
    2794:	91 81       	ldd	r25, Z+1	; 0x01
    2796:	89 2b       	or	r24, r25
    2798:	29 f4       	brne	.+10     	; 0x27a4 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    279a:	0e 94 64 19 	call	0x32c8	; 0x32c8 <xTaskGetCurrentTaskHandle>
    279e:	f7 01       	movw	r30, r14
    27a0:	82 83       	std	Z+2, r24	; 0x02
    27a2:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27a4:	f7 01       	movw	r30, r14
    27a6:	80 85       	ldd	r24, Z+8	; 0x08
    27a8:	88 23       	and	r24, r24
    27aa:	b1 f0       	breq	.+44     	; 0x27d8 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    27ac:	c7 01       	movw	r24, r14
    27ae:	08 96       	adiw	r24, 0x08	; 8
    27b0:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    27b4:	81 30       	cpi	r24, 0x01	; 1
    27b6:	81 f4       	brne	.+32     	; 0x27d8 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    27b8:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    27bc:	0d c0       	rjmp	.+26     	; 0x27d8 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    27be:	f7 01       	movw	r30, r14
    27c0:	c6 82       	std	Z+6, r12	; 0x06
    27c2:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27c4:	83 89       	ldd	r24, Z+19	; 0x13
    27c6:	88 23       	and	r24, r24
    27c8:	39 f0       	breq	.+14     	; 0x27d8 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27ca:	c7 01       	movw	r24, r14
    27cc:	43 96       	adiw	r24, 0x13	; 19
    27ce:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    27d2:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    27d4:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    27d8:	0f 90       	pop	r0
    27da:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    27dc:	81 e0       	ldi	r24, 0x01	; 1
    27de:	62 c0       	rjmp	.+196    	; 0x28a4 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    27e0:	8e 81       	ldd	r24, Y+6	; 0x06
    27e2:	9f 81       	ldd	r25, Y+7	; 0x07
    27e4:	a8 85       	ldd	r26, Y+8	; 0x08
    27e6:	b9 85       	ldd	r27, Y+9	; 0x09
    27e8:	89 2b       	or	r24, r25
    27ea:	8a 2b       	or	r24, r26
    27ec:	8b 2b       	or	r24, r27
    27ee:	21 f4       	brne	.+8      	; 0x27f8 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    27f0:	0f 90       	pop	r0
    27f2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    27f4:	80 e0       	ldi	r24, 0x00	; 0
    27f6:	56 c0       	rjmp	.+172    	; 0x28a4 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    27f8:	11 11       	cpse	r17, r1
    27fa:	05 c0       	rjmp	.+10     	; 0x2806 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    27fc:	ce 01       	movw	r24, r28
    27fe:	01 96       	adiw	r24, 0x01	; 1
    2800:	0e 94 c9 18 	call	0x3192	; 0x3192 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2804:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2806:	0f 90       	pop	r0
    2808:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    280a:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    280e:	0f b6       	in	r0, 0x3f	; 63
    2810:	f8 94       	cli
    2812:	0f 92       	push	r0
    2814:	f7 01       	movw	r30, r14
    2816:	81 a1       	ldd	r24, Z+33	; 0x21
    2818:	8f 3f       	cpi	r24, 0xFF	; 255
    281a:	09 f4       	brne	.+2      	; 0x281e <xQueueGenericReceive+0xe6>
    281c:	11 a2       	std	Z+33, r1	; 0x21
    281e:	f7 01       	movw	r30, r14
    2820:	82 a1       	ldd	r24, Z+34	; 0x22
    2822:	8f 3f       	cpi	r24, 0xFF	; 255
    2824:	09 f4       	brne	.+2      	; 0x2828 <xQueueGenericReceive+0xf0>
    2826:	12 a2       	std	Z+34, r1	; 0x22
    2828:	0f 90       	pop	r0
    282a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    282c:	be 01       	movw	r22, r28
    282e:	6a 5f       	subi	r22, 0xFA	; 250
    2830:	7f 4f       	sbci	r23, 0xFF	; 255
    2832:	ce 01       	movw	r24, r28
    2834:	01 96       	adiw	r24, 0x01	; 1
    2836:	0e 94 da 18 	call	0x31b4	; 0x31b4 <xTaskCheckForTimeOut>
    283a:	81 11       	cpse	r24, r1
    283c:	2d c0       	rjmp	.+90     	; 0x2898 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    283e:	0f b6       	in	r0, 0x3f	; 63
    2840:	f8 94       	cli
    2842:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2844:	f7 01       	movw	r30, r14
    2846:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2848:	0f 90       	pop	r0
    284a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    284c:	81 11       	cpse	r24, r1
    284e:	1e c0       	rjmp	.+60     	; 0x288c <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2850:	80 81       	ld	r24, Z
    2852:	91 81       	ldd	r25, Z+1	; 0x01
    2854:	89 2b       	or	r24, r25
    2856:	49 f4       	brne	.+18     	; 0x286a <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2858:	0f b6       	in	r0, 0x3f	; 63
    285a:	f8 94       	cli
    285c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    285e:	82 81       	ldd	r24, Z+2	; 0x02
    2860:	93 81       	ldd	r25, Z+3	; 0x03
    2862:	0e 94 69 19 	call	0x32d2	; 0x32d2 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2866:	0f 90       	pop	r0
    2868:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    286a:	4e 81       	ldd	r20, Y+6	; 0x06
    286c:	5f 81       	ldd	r21, Y+7	; 0x07
    286e:	68 85       	ldd	r22, Y+8	; 0x08
    2870:	79 85       	ldd	r23, Y+9	; 0x09
    2872:	c6 01       	movw	r24, r12
    2874:	0e 94 60 18 	call	0x30c0	; 0x30c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2878:	c7 01       	movw	r24, r14
    287a:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    287e:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
    2882:	81 11       	cpse	r24, r1
    2884:	73 cf       	rjmp	.-282    	; 0x276c <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2886:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    288a:	70 cf       	rjmp	.-288    	; 0x276c <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    288c:	c7 01       	movw	r24, r14
    288e:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2892:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
    2896:	6a cf       	rjmp	.-300    	; 0x276c <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2898:	c7 01       	movw	r24, r14
    289a:	0e 94 21 12 	call	0x2442	; 0x2442 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    289e:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    28a2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    28a4:	29 96       	adiw	r28, 0x09	; 9
    28a6:	cd bf       	out	0x3d, r28	; 61
    28a8:	de bf       	out	0x3e, r29	; 62
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	1f 91       	pop	r17
    28b0:	0f 91       	pop	r16
    28b2:	ff 90       	pop	r15
    28b4:	ef 90       	pop	r14
    28b6:	df 90       	pop	r13
    28b8:	cf 90       	pop	r12
    28ba:	bf 90       	pop	r11
    28bc:	af 90       	pop	r10
    28be:	08 95       	ret

000028c0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    28c0:	0f 93       	push	r16
    28c2:	1f 93       	push	r17
    28c4:	cf 93       	push	r28
    28c6:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    28c8:	fc 01       	movw	r30, r24
    28ca:	26 8d       	ldd	r18, Z+30	; 0x1e
    28cc:	22 23       	and	r18, r18
    28ce:	d9 f0       	breq	.+54     	; 0x2906 <xQueueReceiveFromISR+0x46>
    28d0:	8a 01       	movw	r16, r20
    28d2:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    28d4:	0e 94 07 12 	call	0x240e	; 0x240e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    28d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    28da:	81 50       	subi	r24, 0x01	; 1
    28dc:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    28de:	89 a1       	ldd	r24, Y+33	; 0x21
    28e0:	8f 3f       	cpi	r24, 0xFF	; 255
    28e2:	69 f4       	brne	.+26     	; 0x28fe <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28e4:	88 85       	ldd	r24, Y+8	; 0x08
    28e6:	88 23       	and	r24, r24
    28e8:	81 f0       	breq	.+32     	; 0x290a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    28ea:	ce 01       	movw	r24, r28
    28ec:	08 96       	adiw	r24, 0x08	; 8
    28ee:	0e 94 8a 18 	call	0x3114	; 0x3114 <xTaskRemoveFromEventList>
    28f2:	88 23       	and	r24, r24
    28f4:	61 f0       	breq	.+24     	; 0x290e <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    28f6:	81 e0       	ldi	r24, 0x01	; 1
    28f8:	f8 01       	movw	r30, r16
    28fa:	80 83       	st	Z, r24
    28fc:	09 c0       	rjmp	.+18     	; 0x2910 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    28fe:	8f 5f       	subi	r24, 0xFF	; 255
    2900:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	05 c0       	rjmp	.+10     	; 0x2910 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2906:	80 e0       	ldi	r24, 0x00	; 0
    2908:	03 c0       	rjmp	.+6      	; 0x2910 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	01 c0       	rjmp	.+2      	; 0x2910 <xQueueReceiveFromISR+0x50>
    290e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2910:	df 91       	pop	r29
    2912:	cf 91       	pop	r28
    2914:	1f 91       	pop	r17
    2916:	0f 91       	pop	r16
    2918:	08 95       	ret

0000291a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    291a:	0f b6       	in	r0, 0x3f	; 63
    291c:	f8 94       	cli
    291e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2920:	fc 01       	movw	r30, r24
    2922:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2924:	0f 90       	pop	r0
    2926:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2928:	08 95       	ret

0000292a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    292a:	fc 01       	movw	r30, r24
    292c:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    292e:	08 95       	ret

00002930 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2930:	cc e5       	ldi	r28, 0x5C	; 92
    2932:	d2 e3       	ldi	r29, 0x32	; 50
    2934:	88 81       	ld	r24, Y
    2936:	82 30       	cpi	r24, 0x02	; 2
    2938:	e8 f3       	brcs	.-6      	; 0x2934 <prvIdleTask+0x4>
    293a:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    293e:	fa cf       	rjmp	.-12     	; 0x2934 <prvIdleTask+0x4>

00002940 <prvAddCurrentTaskToDelayedList>:
    2940:	cf 92       	push	r12
    2942:	df 92       	push	r13
    2944:	ef 92       	push	r14
    2946:	ff 92       	push	r15
    2948:	6b 01       	movw	r12, r22
    294a:	7c 01       	movw	r14, r24
    294c:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    2950:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2954:	62 83       	std	Z+2, r22	; 0x02
    2956:	73 83       	std	Z+3, r23	; 0x03
    2958:	84 83       	std	Z+4, r24	; 0x04
    295a:	95 83       	std	Z+5, r25	; 0x05
    295c:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    2960:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    2964:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    2968:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    296c:	c8 16       	cp	r12, r24
    296e:	d9 06       	cpc	r13, r25
    2970:	ea 06       	cpc	r14, r26
    2972:	fb 06       	cpc	r15, r27
    2974:	68 f4       	brcc	.+26     	; 0x2990 <prvAddCurrentTaskToDelayedList+0x50>
    2976:	60 91 88 32 	lds	r22, 0x3288	; 0x803288 <pxCurrentTCB>
    297a:	70 91 89 32 	lds	r23, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    297e:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <pxOverflowDelayedTaskList>
    2982:	90 91 43 32 	lds	r25, 0x3243	; 0x803243 <pxOverflowDelayedTaskList+0x1>
    2986:	6e 5f       	subi	r22, 0xFE	; 254
    2988:	7f 4f       	sbci	r23, 0xFF	; 255
    298a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vListInsert>
    298e:	21 c0       	rjmp	.+66     	; 0x29d2 <prvAddCurrentTaskToDelayedList+0x92>
    2990:	60 91 88 32 	lds	r22, 0x3288	; 0x803288 <pxCurrentTCB>
    2994:	70 91 89 32 	lds	r23, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2998:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <pxDelayedTaskList>
    299c:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    29a0:	6e 5f       	subi	r22, 0xFE	; 254
    29a2:	7f 4f       	sbci	r23, 0xFF	; 255
    29a4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vListInsert>
    29a8:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    29ac:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    29b0:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    29b4:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    29b8:	c8 16       	cp	r12, r24
    29ba:	d9 06       	cpc	r13, r25
    29bc:	ea 06       	cpc	r14, r26
    29be:	fb 06       	cpc	r15, r27
    29c0:	40 f4       	brcc	.+16     	; 0x29d2 <prvAddCurrentTaskToDelayedList+0x92>
    29c2:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    29c6:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    29ca:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    29ce:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    29d2:	ff 90       	pop	r15
    29d4:	ef 90       	pop	r14
    29d6:	df 90       	pop	r13
    29d8:	cf 90       	pop	r12
    29da:	08 95       	ret

000029dc <xTaskGenericCreate>:
    29dc:	4f 92       	push	r4
    29de:	5f 92       	push	r5
    29e0:	6f 92       	push	r6
    29e2:	7f 92       	push	r7
    29e4:	8f 92       	push	r8
    29e6:	9f 92       	push	r9
    29e8:	af 92       	push	r10
    29ea:	bf 92       	push	r11
    29ec:	cf 92       	push	r12
    29ee:	df 92       	push	r13
    29f0:	ef 92       	push	r14
    29f2:	ff 92       	push	r15
    29f4:	0f 93       	push	r16
    29f6:	1f 93       	push	r17
    29f8:	cf 93       	push	r28
    29fa:	df 93       	push	r29
    29fc:	5c 01       	movw	r10, r24
    29fe:	4b 01       	movw	r8, r22
    2a00:	3a 01       	movw	r6, r20
    2a02:	29 01       	movw	r4, r18
    2a04:	88 e2       	ldi	r24, 0x28	; 40
    2a06:	90 e0       	ldi	r25, 0x00	; 0
    2a08:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    2a0c:	ec 01       	movw	r28, r24
    2a0e:	89 2b       	or	r24, r25
    2a10:	09 f4       	brne	.+2      	; 0x2a14 <xTaskGenericCreate+0x38>
    2a12:	d4 c0       	rjmp	.+424    	; 0x2bbc <xTaskGenericCreate+0x1e0>
    2a14:	c1 14       	cp	r12, r1
    2a16:	d1 04       	cpc	r13, r1
    2a18:	09 f0       	breq	.+2      	; 0x2a1c <xTaskGenericCreate+0x40>
    2a1a:	cc c0       	rjmp	.+408    	; 0x2bb4 <xTaskGenericCreate+0x1d8>
    2a1c:	c3 01       	movw	r24, r6
    2a1e:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    2a22:	8b 8f       	std	Y+27, r24	; 0x1b
    2a24:	9c 8f       	std	Y+28, r25	; 0x1c
    2a26:	00 97       	sbiw	r24, 0x00	; 0
    2a28:	21 f4       	brne	.+8      	; 0x2a32 <xTaskGenericCreate+0x56>
    2a2a:	ce 01       	movw	r24, r28
    2a2c:	0e 94 5b 0f 	call	0x1eb6	; 0x1eb6 <vPortFree>
    2a30:	c5 c0       	rjmp	.+394    	; 0x2bbc <xTaskGenericCreate+0x1e0>
    2a32:	a3 01       	movw	r20, r6
    2a34:	61 e1       	ldi	r22, 0x11	; 17
    2a36:	70 e0       	ldi	r23, 0x00	; 0
    2a38:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <memset>
    2a3c:	93 01       	movw	r18, r6
    2a3e:	21 50       	subi	r18, 0x01	; 1
    2a40:	31 09       	sbc	r19, r1
    2a42:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a44:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a46:	3c 01       	movw	r6, r24
    2a48:	62 0e       	add	r6, r18
    2a4a:	73 1e       	adc	r7, r19
    2a4c:	4a e0       	ldi	r20, 0x0A	; 10
    2a4e:	50 e0       	ldi	r21, 0x00	; 0
    2a50:	b4 01       	movw	r22, r8
    2a52:	ce 01       	movw	r24, r28
    2a54:	4d 96       	adiw	r24, 0x1d	; 29
    2a56:	0e 94 0d 27 	call	0x4e1a	; 0x4e1a <strncpy>
    2a5a:	1e a2       	std	Y+38, r1	; 0x26
    2a5c:	10 2f       	mov	r17, r16
    2a5e:	04 30       	cpi	r16, 0x04	; 4
    2a60:	08 f0       	brcs	.+2      	; 0x2a64 <xTaskGenericCreate+0x88>
    2a62:	13 e0       	ldi	r17, 0x03	; 3
    2a64:	1a 8f       	std	Y+26, r17	; 0x1a
    2a66:	1f a3       	std	Y+39, r17	; 0x27
    2a68:	6e 01       	movw	r12, r28
    2a6a:	22 e0       	ldi	r18, 0x02	; 2
    2a6c:	c2 0e       	add	r12, r18
    2a6e:	d1 1c       	adc	r13, r1
    2a70:	c6 01       	movw	r24, r12
    2a72:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <vListInitialiseItem>
    2a76:	ce 01       	movw	r24, r28
    2a78:	0e 96       	adiw	r24, 0x0e	; 14
    2a7a:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <vListInitialiseItem>
    2a7e:	ca 87       	std	Y+10, r28	; 0x0a
    2a80:	db 87       	std	Y+11, r29	; 0x0b
    2a82:	84 e0       	ldi	r24, 0x04	; 4
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	a0 e0       	ldi	r26, 0x00	; 0
    2a88:	b0 e0       	ldi	r27, 0x00	; 0
    2a8a:	81 1b       	sub	r24, r17
    2a8c:	91 09       	sbc	r25, r1
    2a8e:	a1 09       	sbc	r26, r1
    2a90:	b1 09       	sbc	r27, r1
    2a92:	8e 87       	std	Y+14, r24	; 0x0e
    2a94:	9f 87       	std	Y+15, r25	; 0x0f
    2a96:	a8 8b       	std	Y+16, r26	; 0x10
    2a98:	b9 8b       	std	Y+17, r27	; 0x11
    2a9a:	ce 8b       	std	Y+22, r28	; 0x16
    2a9c:	df 8b       	std	Y+23, r29	; 0x17
    2a9e:	a2 01       	movw	r20, r4
    2aa0:	b5 01       	movw	r22, r10
    2aa2:	c3 01       	movw	r24, r6
    2aa4:	0e 94 40 10 	call	0x2080	; 0x2080 <pxPortInitialiseStack>
    2aa8:	88 83       	st	Y, r24
    2aaa:	99 83       	std	Y+1, r25	; 0x01
    2aac:	e1 14       	cp	r14, r1
    2aae:	f1 04       	cpc	r15, r1
    2ab0:	19 f0       	breq	.+6      	; 0x2ab8 <xTaskGenericCreate+0xdc>
    2ab2:	f7 01       	movw	r30, r14
    2ab4:	c0 83       	st	Z, r28
    2ab6:	d1 83       	std	Z+1, r29	; 0x01
    2ab8:	0f b6       	in	r0, 0x3f	; 63
    2aba:	f8 94       	cli
    2abc:	0f 92       	push	r0
    2abe:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <uxCurrentNumberOfTasks>
    2ac2:	8f 5f       	subi	r24, 0xFF	; 255
    2ac4:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <uxCurrentNumberOfTasks>
    2ac8:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    2acc:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2ad0:	89 2b       	or	r24, r25
    2ad2:	89 f5       	brne	.+98     	; 0x2b36 <xTaskGenericCreate+0x15a>
    2ad4:	c0 93 88 32 	sts	0x3288, r28	; 0x803288 <pxCurrentTCB>
    2ad8:	d0 93 89 32 	sts	0x3289, r29	; 0x803289 <pxCurrentTCB+0x1>
    2adc:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <uxCurrentNumberOfTasks>
    2ae0:	81 30       	cpi	r24, 0x01	; 1
    2ae2:	c1 f5       	brne	.+112    	; 0x2b54 <xTaskGenericCreate+0x178>
    2ae4:	8c e5       	ldi	r24, 0x5C	; 92
    2ae6:	92 e3       	ldi	r25, 0x32	; 50
    2ae8:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2aec:	87 e6       	ldi	r24, 0x67	; 103
    2aee:	92 e3       	ldi	r25, 0x32	; 50
    2af0:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2af4:	82 e7       	ldi	r24, 0x72	; 114
    2af6:	92 e3       	ldi	r25, 0x32	; 50
    2af8:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2afc:	8d e7       	ldi	r24, 0x7D	; 125
    2afe:	92 e3       	ldi	r25, 0x32	; 50
    2b00:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2b04:	81 e5       	ldi	r24, 0x51	; 81
    2b06:	92 e3       	ldi	r25, 0x32	; 50
    2b08:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2b0c:	86 e4       	ldi	r24, 0x46	; 70
    2b0e:	92 e3       	ldi	r25, 0x32	; 50
    2b10:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2b14:	87 e3       	ldi	r24, 0x37	; 55
    2b16:	92 e3       	ldi	r25, 0x32	; 50
    2b18:	0e 94 93 0f 	call	0x1f26	; 0x1f26 <vListInitialise>
    2b1c:	81 e5       	ldi	r24, 0x51	; 81
    2b1e:	92 e3       	ldi	r25, 0x32	; 50
    2b20:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <pxDelayedTaskList>
    2b24:	90 93 45 32 	sts	0x3245, r25	; 0x803245 <pxDelayedTaskList+0x1>
    2b28:	86 e4       	ldi	r24, 0x46	; 70
    2b2a:	92 e3       	ldi	r25, 0x32	; 50
    2b2c:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <pxOverflowDelayedTaskList>
    2b30:	90 93 43 32 	sts	0x3243, r25	; 0x803243 <pxOverflowDelayedTaskList+0x1>
    2b34:	0f c0       	rjmp	.+30     	; 0x2b54 <xTaskGenericCreate+0x178>
    2b36:	80 91 2d 32 	lds	r24, 0x322D	; 0x80322d <xSchedulerRunning>
    2b3a:	81 11       	cpse	r24, r1
    2b3c:	0b c0       	rjmp	.+22     	; 0x2b54 <xTaskGenericCreate+0x178>
    2b3e:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    2b42:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2b46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b48:	08 17       	cp	r16, r24
    2b4a:	20 f0       	brcs	.+8      	; 0x2b54 <xTaskGenericCreate+0x178>
    2b4c:	c0 93 88 32 	sts	0x3288, r28	; 0x803288 <pxCurrentTCB>
    2b50:	d0 93 89 32 	sts	0x3289, r29	; 0x803289 <pxCurrentTCB+0x1>
    2b54:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b56:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <uxTopUsedPriority>
    2b5a:	98 17       	cp	r25, r24
    2b5c:	10 f4       	brcc	.+4      	; 0x2b62 <xTaskGenericCreate+0x186>
    2b5e:	80 93 2f 32 	sts	0x322F, r24	; 0x80322f <uxTopUsedPriority>
    2b62:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTaskNumber>
    2b66:	9f 5f       	subi	r25, 0xFF	; 255
    2b68:	90 93 28 32 	sts	0x3228, r25	; 0x803228 <uxTaskNumber>
    2b6c:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    2b70:	98 17       	cp	r25, r24
    2b72:	10 f4       	brcc	.+4      	; 0x2b78 <xTaskGenericCreate+0x19c>
    2b74:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    2b78:	fb e0       	ldi	r31, 0x0B	; 11
    2b7a:	8f 9f       	mul	r24, r31
    2b7c:	c0 01       	movw	r24, r0
    2b7e:	11 24       	eor	r1, r1
    2b80:	b6 01       	movw	r22, r12
    2b82:	84 5a       	subi	r24, 0xA4	; 164
    2b84:	9d 4c       	sbci	r25, 0xCD	; 205
    2b86:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
    2b8a:	0f 90       	pop	r0
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	80 91 2d 32 	lds	r24, 0x322D	; 0x80322d <xSchedulerRunning>
    2b92:	88 23       	and	r24, r24
    2b94:	59 f0       	breq	.+22     	; 0x2bac <xTaskGenericCreate+0x1d0>
    2b96:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    2b9a:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2b9e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ba0:	80 17       	cp	r24, r16
    2ba2:	30 f4       	brcc	.+12     	; 0x2bb0 <xTaskGenericCreate+0x1d4>
    2ba4:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    2ba8:	81 e0       	ldi	r24, 0x01	; 1
    2baa:	09 c0       	rjmp	.+18     	; 0x2bbe <xTaskGenericCreate+0x1e2>
    2bac:	81 e0       	ldi	r24, 0x01	; 1
    2bae:	07 c0       	rjmp	.+14     	; 0x2bbe <xTaskGenericCreate+0x1e2>
    2bb0:	81 e0       	ldi	r24, 0x01	; 1
    2bb2:	05 c0       	rjmp	.+10     	; 0x2bbe <xTaskGenericCreate+0x1e2>
    2bb4:	cb 8e       	std	Y+27, r12	; 0x1b
    2bb6:	dc 8e       	std	Y+28, r13	; 0x1c
    2bb8:	c6 01       	movw	r24, r12
    2bba:	3b cf       	rjmp	.-394    	; 0x2a32 <xTaskGenericCreate+0x56>
    2bbc:	8f ef       	ldi	r24, 0xFF	; 255
    2bbe:	df 91       	pop	r29
    2bc0:	cf 91       	pop	r28
    2bc2:	1f 91       	pop	r17
    2bc4:	0f 91       	pop	r16
    2bc6:	ff 90       	pop	r15
    2bc8:	ef 90       	pop	r14
    2bca:	df 90       	pop	r13
    2bcc:	cf 90       	pop	r12
    2bce:	bf 90       	pop	r11
    2bd0:	af 90       	pop	r10
    2bd2:	9f 90       	pop	r9
    2bd4:	8f 90       	pop	r8
    2bd6:	7f 90       	pop	r7
    2bd8:	6f 90       	pop	r6
    2bda:	5f 90       	pop	r5
    2bdc:	4f 90       	pop	r4
    2bde:	08 95       	ret

00002be0 <uxTaskPriorityGet>:
    2be0:	0f b6       	in	r0, 0x3f	; 63
    2be2:	f8 94       	cli
    2be4:	0f 92       	push	r0
    2be6:	00 97       	sbiw	r24, 0x00	; 0
    2be8:	21 f4       	brne	.+8      	; 0x2bf2 <uxTaskPriorityGet+0x12>
    2bea:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    2bee:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2bf2:	0f 90       	pop	r0
    2bf4:	0f be       	out	0x3f, r0	; 63
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bfa:	08 95       	ret

00002bfc <vTaskStartScheduler>:
    2bfc:	af 92       	push	r10
    2bfe:	bf 92       	push	r11
    2c00:	cf 92       	push	r12
    2c02:	df 92       	push	r13
    2c04:	ef 92       	push	r14
    2c06:	ff 92       	push	r15
    2c08:	0f 93       	push	r16
    2c0a:	a1 2c       	mov	r10, r1
    2c0c:	b1 2c       	mov	r11, r1
    2c0e:	c1 2c       	mov	r12, r1
    2c10:	d1 2c       	mov	r13, r1
    2c12:	0f 2e       	mov	r0, r31
    2c14:	f5 e3       	ldi	r31, 0x35	; 53
    2c16:	ef 2e       	mov	r14, r31
    2c18:	f2 e3       	ldi	r31, 0x32	; 50
    2c1a:	ff 2e       	mov	r15, r31
    2c1c:	f0 2d       	mov	r31, r0
    2c1e:	00 e0       	ldi	r16, 0x00	; 0
    2c20:	20 e0       	ldi	r18, 0x00	; 0
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	44 e6       	ldi	r20, 0x64	; 100
    2c26:	50 e0       	ldi	r21, 0x00	; 0
    2c28:	6d e6       	ldi	r22, 0x6D	; 109
    2c2a:	71 e2       	ldi	r23, 0x21	; 33
    2c2c:	88 e9       	ldi	r24, 0x98	; 152
    2c2e:	94 e1       	ldi	r25, 0x14	; 20
    2c30:	0e 94 ee 14 	call	0x29dc	; 0x29dc <xTaskGenericCreate>
    2c34:	81 30       	cpi	r24, 0x01	; 1
    2c36:	69 f4       	brne	.+26     	; 0x2c52 <vTaskStartScheduler+0x56>
    2c38:	f8 94       	cli
    2c3a:	80 93 2d 32 	sts	0x322D, r24	; 0x80322d <xSchedulerRunning>
    2c3e:	10 92 30 32 	sts	0x3230, r1	; 0x803230 <xTickCount>
    2c42:	10 92 31 32 	sts	0x3231, r1	; 0x803231 <xTickCount+0x1>
    2c46:	10 92 32 32 	sts	0x3232, r1	; 0x803232 <xTickCount+0x2>
    2c4a:	10 92 33 32 	sts	0x3233, r1	; 0x803233 <xTickCount+0x3>
    2c4e:	0e 94 b6 10 	call	0x216c	; 0x216c <xPortStartScheduler>
    2c52:	0f 91       	pop	r16
    2c54:	ff 90       	pop	r15
    2c56:	ef 90       	pop	r14
    2c58:	df 90       	pop	r13
    2c5a:	cf 90       	pop	r12
    2c5c:	bf 90       	pop	r11
    2c5e:	af 90       	pop	r10
    2c60:	08 95       	ret

00002c62 <vTaskSuspendAll>:
    2c62:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    2c66:	8f 5f       	subi	r24, 0xFF	; 255
    2c68:	80 93 2c 32 	sts	0x322C, r24	; 0x80322c <uxSchedulerSuspended>
    2c6c:	08 95       	ret

00002c6e <xTaskGetTickCount>:
    2c6e:	0f b6       	in	r0, 0x3f	; 63
    2c70:	f8 94       	cli
    2c72:	0f 92       	push	r0
    2c74:	60 91 30 32 	lds	r22, 0x3230	; 0x803230 <xTickCount>
    2c78:	70 91 31 32 	lds	r23, 0x3231	; 0x803231 <xTickCount+0x1>
    2c7c:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <xTickCount+0x2>
    2c80:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <xTickCount+0x3>
    2c84:	0f 90       	pop	r0
    2c86:	0f be       	out	0x3f, r0	; 63
    2c88:	08 95       	ret

00002c8a <pcTaskGetTaskName>:
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	21 f4       	brne	.+8      	; 0x2c96 <pcTaskGetTaskName+0xc>
    2c8e:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    2c92:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2c96:	4d 96       	adiw	r24, 0x1d	; 29
    2c98:	08 95       	ret

00002c9a <xTaskGetIdleTaskHandle>:
    2c9a:	80 91 35 32 	lds	r24, 0x3235	; 0x803235 <xIdleTaskHandle>
    2c9e:	90 91 36 32 	lds	r25, 0x3236	; 0x803236 <xIdleTaskHandle+0x1>
    2ca2:	08 95       	ret

00002ca4 <vTaskIncrementTick>:
    2ca4:	ff 92       	push	r15
    2ca6:	0f 93       	push	r16
    2ca8:	1f 93       	push	r17
    2caa:	cf 93       	push	r28
    2cac:	df 93       	push	r29
    2cae:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    2cb2:	81 11       	cpse	r24, r1
    2cb4:	ed c0       	rjmp	.+474    	; 0x2e90 <vTaskIncrementTick+0x1ec>
    2cb6:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    2cba:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    2cbe:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    2cc2:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    2cc6:	01 96       	adiw	r24, 0x01	; 1
    2cc8:	a1 1d       	adc	r26, r1
    2cca:	b1 1d       	adc	r27, r1
    2ccc:	80 93 30 32 	sts	0x3230, r24	; 0x803230 <xTickCount>
    2cd0:	90 93 31 32 	sts	0x3231, r25	; 0x803231 <xTickCount+0x1>
    2cd4:	a0 93 32 32 	sts	0x3232, r26	; 0x803232 <xTickCount+0x2>
    2cd8:	b0 93 33 32 	sts	0x3233, r27	; 0x803233 <xTickCount+0x3>
    2cdc:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    2ce0:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    2ce4:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    2ce8:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    2cec:	89 2b       	or	r24, r25
    2cee:	8a 2b       	or	r24, r26
    2cf0:	8b 2b       	or	r24, r27
    2cf2:	f1 f5       	brne	.+124    	; 0x2d70 <vTaskIncrementTick+0xcc>
    2cf4:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <pxDelayedTaskList>
    2cf8:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2cfc:	20 91 42 32 	lds	r18, 0x3242	; 0x803242 <pxOverflowDelayedTaskList>
    2d00:	30 91 43 32 	lds	r19, 0x3243	; 0x803243 <pxOverflowDelayedTaskList+0x1>
    2d04:	20 93 44 32 	sts	0x3244, r18	; 0x803244 <pxDelayedTaskList>
    2d08:	30 93 45 32 	sts	0x3245, r19	; 0x803245 <pxDelayedTaskList+0x1>
    2d0c:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <pxOverflowDelayedTaskList>
    2d10:	90 93 43 32 	sts	0x3243, r25	; 0x803243 <pxOverflowDelayedTaskList+0x1>
    2d14:	80 91 29 32 	lds	r24, 0x3229	; 0x803229 <xNumOfOverflows>
    2d18:	8f 5f       	subi	r24, 0xFF	; 255
    2d1a:	80 93 29 32 	sts	0x3229, r24	; 0x803229 <xNumOfOverflows>
    2d1e:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2d22:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2d26:	80 81       	ld	r24, Z
    2d28:	81 11       	cpse	r24, r1
    2d2a:	0c c0       	rjmp	.+24     	; 0x2d44 <vTaskIncrementTick+0xa0>
    2d2c:	8f ef       	ldi	r24, 0xFF	; 255
    2d2e:	9f ef       	ldi	r25, 0xFF	; 255
    2d30:	dc 01       	movw	r26, r24
    2d32:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d36:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d3a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d3e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d42:	16 c0       	rjmp	.+44     	; 0x2d70 <vTaskIncrementTick+0xcc>
    2d44:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2d48:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2d4c:	07 80       	ldd	r0, Z+7	; 0x07
    2d4e:	f0 85       	ldd	r31, Z+8	; 0x08
    2d50:	e0 2d       	mov	r30, r0
    2d52:	00 84       	ldd	r0, Z+8	; 0x08
    2d54:	f1 85       	ldd	r31, Z+9	; 0x09
    2d56:	e0 2d       	mov	r30, r0
    2d58:	82 81       	ldd	r24, Z+2	; 0x02
    2d5a:	93 81       	ldd	r25, Z+3	; 0x03
    2d5c:	a4 81       	ldd	r26, Z+4	; 0x04
    2d5e:	b5 81       	ldd	r27, Z+5	; 0x05
    2d60:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d64:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d68:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d6c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d70:	40 91 30 32 	lds	r20, 0x3230	; 0x803230 <xTickCount>
    2d74:	50 91 31 32 	lds	r21, 0x3231	; 0x803231 <xTickCount+0x1>
    2d78:	60 91 32 32 	lds	r22, 0x3232	; 0x803232 <xTickCount+0x2>
    2d7c:	70 91 33 32 	lds	r23, 0x3233	; 0x803233 <xTickCount+0x3>
    2d80:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2d84:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d88:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d8c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d90:	48 17       	cp	r20, r24
    2d92:	59 07       	cpc	r21, r25
    2d94:	6a 07       	cpc	r22, r26
    2d96:	7b 07       	cpc	r23, r27
    2d98:	08 f4       	brcc	.+2      	; 0x2d9c <vTaskIncrementTick+0xf8>
    2d9a:	7f c0       	rjmp	.+254    	; 0x2e9a <vTaskIncrementTick+0x1f6>
    2d9c:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2da0:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2da4:	80 81       	ld	r24, Z
    2da6:	88 23       	and	r24, r24
    2da8:	f9 f0       	breq	.+62     	; 0x2de8 <vTaskIncrementTick+0x144>
    2daa:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2dae:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2db2:	07 80       	ldd	r0, Z+7	; 0x07
    2db4:	f0 85       	ldd	r31, Z+8	; 0x08
    2db6:	e0 2d       	mov	r30, r0
    2db8:	c0 85       	ldd	r28, Z+8	; 0x08
    2dba:	d1 85       	ldd	r29, Z+9	; 0x09
    2dbc:	8a 81       	ldd	r24, Y+2	; 0x02
    2dbe:	9b 81       	ldd	r25, Y+3	; 0x03
    2dc0:	ac 81       	ldd	r26, Y+4	; 0x04
    2dc2:	bd 81       	ldd	r27, Y+5	; 0x05
    2dc4:	40 91 30 32 	lds	r20, 0x3230	; 0x803230 <xTickCount>
    2dc8:	50 91 31 32 	lds	r21, 0x3231	; 0x803231 <xTickCount+0x1>
    2dcc:	60 91 32 32 	lds	r22, 0x3232	; 0x803232 <xTickCount+0x2>
    2dd0:	70 91 33 32 	lds	r23, 0x3233	; 0x803233 <xTickCount+0x3>
    2dd4:	48 17       	cp	r20, r24
    2dd6:	59 07       	cpc	r21, r25
    2dd8:	6a 07       	cpc	r22, r26
    2dda:	7b 07       	cpc	r23, r27
    2ddc:	58 f1       	brcs	.+86     	; 0x2e34 <vTaskIncrementTick+0x190>
    2dde:	0f 2e       	mov	r0, r31
    2de0:	fb e0       	ldi	r31, 0x0B	; 11
    2de2:	ff 2e       	mov	r15, r31
    2de4:	f0 2d       	mov	r31, r0
    2de6:	2f c0       	rjmp	.+94     	; 0x2e46 <vTaskIncrementTick+0x1a2>
    2de8:	8f ef       	ldi	r24, 0xFF	; 255
    2dea:	9f ef       	ldi	r25, 0xFF	; 255
    2dec:	dc 01       	movw	r26, r24
    2dee:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2df2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2df6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2dfa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2dfe:	4d c0       	rjmp	.+154    	; 0x2e9a <vTaskIncrementTick+0x1f6>
    2e00:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2e04:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2e08:	07 80       	ldd	r0, Z+7	; 0x07
    2e0a:	f0 85       	ldd	r31, Z+8	; 0x08
    2e0c:	e0 2d       	mov	r30, r0
    2e0e:	c0 85       	ldd	r28, Z+8	; 0x08
    2e10:	d1 85       	ldd	r29, Z+9	; 0x09
    2e12:	8a 81       	ldd	r24, Y+2	; 0x02
    2e14:	9b 81       	ldd	r25, Y+3	; 0x03
    2e16:	ac 81       	ldd	r26, Y+4	; 0x04
    2e18:	bd 81       	ldd	r27, Y+5	; 0x05
    2e1a:	40 91 30 32 	lds	r20, 0x3230	; 0x803230 <xTickCount>
    2e1e:	50 91 31 32 	lds	r21, 0x3231	; 0x803231 <xTickCount+0x1>
    2e22:	60 91 32 32 	lds	r22, 0x3232	; 0x803232 <xTickCount+0x2>
    2e26:	70 91 33 32 	lds	r23, 0x3233	; 0x803233 <xTickCount+0x3>
    2e2a:	48 17       	cp	r20, r24
    2e2c:	59 07       	cpc	r21, r25
    2e2e:	6a 07       	cpc	r22, r26
    2e30:	7b 07       	cpc	r23, r27
    2e32:	48 f4       	brcc	.+18     	; 0x2e46 <vTaskIncrementTick+0x1a2>
    2e34:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e38:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e3c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e40:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e44:	2a c0       	rjmp	.+84     	; 0x2e9a <vTaskIncrementTick+0x1f6>
    2e46:	8e 01       	movw	r16, r28
    2e48:	0e 5f       	subi	r16, 0xFE	; 254
    2e4a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e4c:	c8 01       	movw	r24, r16
    2e4e:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
    2e52:	88 8d       	ldd	r24, Y+24	; 0x18
    2e54:	99 8d       	ldd	r25, Y+25	; 0x19
    2e56:	89 2b       	or	r24, r25
    2e58:	21 f0       	breq	.+8      	; 0x2e62 <vTaskIncrementTick+0x1be>
    2e5a:	ce 01       	movw	r24, r28
    2e5c:	0e 96       	adiw	r24, 0x0e	; 14
    2e5e:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
    2e62:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e64:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    2e68:	98 17       	cp	r25, r24
    2e6a:	10 f4       	brcc	.+4      	; 0x2e70 <vTaskIncrementTick+0x1cc>
    2e6c:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    2e70:	f8 9e       	mul	r15, r24
    2e72:	c0 01       	movw	r24, r0
    2e74:	11 24       	eor	r1, r1
    2e76:	b8 01       	movw	r22, r16
    2e78:	84 5a       	subi	r24, 0xA4	; 164
    2e7a:	9d 4c       	sbci	r25, 0xCD	; 205
    2e7c:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
    2e80:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <pxDelayedTaskList>
    2e84:	f0 91 45 32 	lds	r31, 0x3245	; 0x803245 <pxDelayedTaskList+0x1>
    2e88:	80 81       	ld	r24, Z
    2e8a:	81 11       	cpse	r24, r1
    2e8c:	b9 cf       	rjmp	.-142    	; 0x2e00 <vTaskIncrementTick+0x15c>
    2e8e:	ac cf       	rjmp	.-168    	; 0x2de8 <vTaskIncrementTick+0x144>
    2e90:	80 91 2b 32 	lds	r24, 0x322B	; 0x80322b <uxMissedTicks>
    2e94:	8f 5f       	subi	r24, 0xFF	; 255
    2e96:	80 93 2b 32 	sts	0x322B, r24	; 0x80322b <uxMissedTicks>
    2e9a:	df 91       	pop	r29
    2e9c:	cf 91       	pop	r28
    2e9e:	1f 91       	pop	r17
    2ea0:	0f 91       	pop	r16
    2ea2:	ff 90       	pop	r15
    2ea4:	08 95       	ret

00002ea6 <xTaskResumeAll>:
    2ea6:	cf 92       	push	r12
    2ea8:	df 92       	push	r13
    2eaa:	ef 92       	push	r14
    2eac:	ff 92       	push	r15
    2eae:	0f 93       	push	r16
    2eb0:	1f 93       	push	r17
    2eb2:	cf 93       	push	r28
    2eb4:	df 93       	push	r29
    2eb6:	0f b6       	in	r0, 0x3f	; 63
    2eb8:	f8 94       	cli
    2eba:	0f 92       	push	r0
    2ebc:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    2ec0:	81 50       	subi	r24, 0x01	; 1
    2ec2:	80 93 2c 32 	sts	0x322C, r24	; 0x80322c <uxSchedulerSuspended>
    2ec6:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    2eca:	81 11       	cpse	r24, r1
    2ecc:	60 c0       	rjmp	.+192    	; 0x2f8e <xTaskResumeAll+0xe8>
    2ece:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <uxCurrentNumberOfTasks>
    2ed2:	81 11       	cpse	r24, r1
    2ed4:	2c c0       	rjmp	.+88     	; 0x2f2e <xTaskResumeAll+0x88>
    2ed6:	5e c0       	rjmp	.+188    	; 0x2f94 <xTaskResumeAll+0xee>
    2ed8:	d7 01       	movw	r26, r14
    2eda:	17 96       	adiw	r26, 0x07	; 7
    2edc:	ed 91       	ld	r30, X+
    2ede:	fc 91       	ld	r31, X
    2ee0:	18 97       	sbiw	r26, 0x08	; 8
    2ee2:	c0 85       	ldd	r28, Z+8	; 0x08
    2ee4:	d1 85       	ldd	r29, Z+9	; 0x09
    2ee6:	ce 01       	movw	r24, r28
    2ee8:	0e 96       	adiw	r24, 0x0e	; 14
    2eea:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
    2eee:	8e 01       	movw	r16, r28
    2ef0:	0e 5f       	subi	r16, 0xFE	; 254
    2ef2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ef4:	c8 01       	movw	r24, r16
    2ef6:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
    2efa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2efc:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    2f00:	98 17       	cp	r25, r24
    2f02:	10 f4       	brcc	.+4      	; 0x2f08 <xTaskResumeAll+0x62>
    2f04:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    2f08:	d8 9e       	mul	r13, r24
    2f0a:	c0 01       	movw	r24, r0
    2f0c:	11 24       	eor	r1, r1
    2f0e:	b8 01       	movw	r22, r16
    2f10:	84 5a       	subi	r24, 0xA4	; 164
    2f12:	9d 4c       	sbci	r25, 0xCD	; 205
    2f14:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
    2f18:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    2f1c:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2f20:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f22:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f24:	98 17       	cp	r25, r24
    2f26:	70 f0       	brcs	.+28     	; 0x2f44 <xTaskResumeAll+0x9e>
    2f28:	cc 24       	eor	r12, r12
    2f2a:	c3 94       	inc	r12
    2f2c:	0b c0       	rjmp	.+22     	; 0x2f44 <xTaskResumeAll+0x9e>
    2f2e:	c1 2c       	mov	r12, r1
    2f30:	0f 2e       	mov	r0, r31
    2f32:	f7 e3       	ldi	r31, 0x37	; 55
    2f34:	ef 2e       	mov	r14, r31
    2f36:	f2 e3       	ldi	r31, 0x32	; 50
    2f38:	ff 2e       	mov	r15, r31
    2f3a:	f0 2d       	mov	r31, r0
    2f3c:	0f 2e       	mov	r0, r31
    2f3e:	fb e0       	ldi	r31, 0x0B	; 11
    2f40:	df 2e       	mov	r13, r31
    2f42:	f0 2d       	mov	r31, r0
    2f44:	f7 01       	movw	r30, r14
    2f46:	80 81       	ld	r24, Z
    2f48:	81 11       	cpse	r24, r1
    2f4a:	c6 cf       	rjmp	.-116    	; 0x2ed8 <xTaskResumeAll+0x32>
    2f4c:	80 91 2b 32 	lds	r24, 0x322B	; 0x80322b <uxMissedTicks>
    2f50:	88 23       	and	r24, r24
    2f52:	81 f0       	breq	.+32     	; 0x2f74 <xTaskResumeAll+0xce>
    2f54:	80 91 2b 32 	lds	r24, 0x322B	; 0x80322b <uxMissedTicks>
    2f58:	88 23       	and	r24, r24
    2f5a:	99 f0       	breq	.+38     	; 0x2f82 <xTaskResumeAll+0xdc>
    2f5c:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <vTaskIncrementTick>
    2f60:	80 91 2b 32 	lds	r24, 0x322B	; 0x80322b <uxMissedTicks>
    2f64:	81 50       	subi	r24, 0x01	; 1
    2f66:	80 93 2b 32 	sts	0x322B, r24	; 0x80322b <uxMissedTicks>
    2f6a:	80 91 2b 32 	lds	r24, 0x322B	; 0x80322b <uxMissedTicks>
    2f6e:	81 11       	cpse	r24, r1
    2f70:	f5 cf       	rjmp	.-22     	; 0x2f5c <xTaskResumeAll+0xb6>
    2f72:	07 c0       	rjmp	.+14     	; 0x2f82 <xTaskResumeAll+0xdc>
    2f74:	f1 e0       	ldi	r31, 0x01	; 1
    2f76:	cf 16       	cp	r12, r31
    2f78:	21 f0       	breq	.+8      	; 0x2f82 <xTaskResumeAll+0xdc>
    2f7a:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xMissedYield>
    2f7e:	81 30       	cpi	r24, 0x01	; 1
    2f80:	41 f4       	brne	.+16     	; 0x2f92 <xTaskResumeAll+0xec>
    2f82:	10 92 2a 32 	sts	0x322A, r1	; 0x80322a <xMissedYield>
    2f86:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
    2f8a:	81 e0       	ldi	r24, 0x01	; 1
    2f8c:	03 c0       	rjmp	.+6      	; 0x2f94 <xTaskResumeAll+0xee>
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    2f90:	01 c0       	rjmp	.+2      	; 0x2f94 <xTaskResumeAll+0xee>
    2f92:	80 e0       	ldi	r24, 0x00	; 0
    2f94:	0f 90       	pop	r0
    2f96:	0f be       	out	0x3f, r0	; 63
    2f98:	df 91       	pop	r29
    2f9a:	cf 91       	pop	r28
    2f9c:	1f 91       	pop	r17
    2f9e:	0f 91       	pop	r16
    2fa0:	ff 90       	pop	r15
    2fa2:	ef 90       	pop	r14
    2fa4:	df 90       	pop	r13
    2fa6:	cf 90       	pop	r12
    2fa8:	08 95       	ret

00002faa <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2faa:	cf 92       	push	r12
    2fac:	df 92       	push	r13
    2fae:	ef 92       	push	r14
    2fb0:	ff 92       	push	r15
    2fb2:	6b 01       	movw	r12, r22
    2fb4:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2fb6:	67 2b       	or	r22, r23
    2fb8:	68 2b       	or	r22, r24
    2fba:	69 2b       	or	r22, r25
    2fbc:	e9 f0       	breq	.+58     	; 0x2ff8 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2fbe:	0e 94 31 16 	call	0x2c62	; 0x2c62 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fc2:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    2fc6:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    2fca:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    2fce:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    2fd2:	c8 0e       	add	r12, r24
    2fd4:	d9 1e       	adc	r13, r25
    2fd6:	ea 1e       	adc	r14, r26
    2fd8:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2fda:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    2fde:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    2fe2:	02 96       	adiw	r24, 0x02	; 2
    2fe4:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2fe8:	c7 01       	movw	r24, r14
    2fea:	b6 01       	movw	r22, r12
    2fec:	0e 94 a0 14 	call	0x2940	; 0x2940 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2ff0:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2ff4:	81 11       	cpse	r24, r1
    2ff6:	02 c0       	rjmp	.+4      	; 0x2ffc <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2ff8:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <vPortYield>
		}
	}
    2ffc:	ff 90       	pop	r15
    2ffe:	ef 90       	pop	r14
    3000:	df 90       	pop	r13
    3002:	cf 90       	pop	r12
    3004:	08 95       	ret

00003006 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3006:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    300a:	81 11       	cpse	r24, r1
    300c:	0c c0       	rjmp	.+24     	; 0x3026 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    300e:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <uxTopReadyPriority>
    3012:	4b e0       	ldi	r20, 0x0B	; 11
    3014:	e4 9f       	mul	r30, r20
    3016:	f0 01       	movw	r30, r0
    3018:	11 24       	eor	r1, r1
    301a:	e4 5a       	subi	r30, 0xA4	; 164
    301c:	fd 4c       	sbci	r31, 0xCD	; 205
    301e:	80 81       	ld	r24, Z
    3020:	88 23       	and	r24, r24
    3022:	29 f0       	breq	.+10     	; 0x302e <vTaskSwitchContext+0x28>
    3024:	14 c0       	rjmp	.+40     	; 0x304e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3026:	81 e0       	ldi	r24, 0x01	; 1
    3028:	80 93 2a 32 	sts	0x322A, r24	; 0x80322a <xMissedYield>
    302c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    302e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3030:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <uxTopReadyPriority>
    3034:	81 50       	subi	r24, 0x01	; 1
    3036:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    303a:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <uxTopReadyPriority>
    303e:	9e 9f       	mul	r25, r30
    3040:	f0 01       	movw	r30, r0
    3042:	11 24       	eor	r1, r1
    3044:	e4 5a       	subi	r30, 0xA4	; 164
    3046:	fd 4c       	sbci	r31, 0xCD	; 205
    3048:	80 81       	ld	r24, Z
    304a:	88 23       	and	r24, r24
    304c:	89 f3       	breq	.-30     	; 0x3030 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    304e:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <uxTopReadyPriority>
    3052:	28 2f       	mov	r18, r24
    3054:	30 e0       	ldi	r19, 0x00	; 0
    3056:	4b e0       	ldi	r20, 0x0B	; 11
    3058:	84 9f       	mul	r24, r20
    305a:	c0 01       	movw	r24, r0
    305c:	11 24       	eor	r1, r1
    305e:	dc 01       	movw	r26, r24
    3060:	a4 5a       	subi	r26, 0xA4	; 164
    3062:	bd 4c       	sbci	r27, 0xCD	; 205
    3064:	11 96       	adiw	r26, 0x01	; 1
    3066:	ed 91       	ld	r30, X+
    3068:	fc 91       	ld	r31, X
    306a:	12 97       	sbiw	r26, 0x02	; 2
    306c:	04 80       	ldd	r0, Z+4	; 0x04
    306e:	f5 81       	ldd	r31, Z+5	; 0x05
    3070:	e0 2d       	mov	r30, r0
    3072:	11 96       	adiw	r26, 0x01	; 1
    3074:	ed 93       	st	X+, r30
    3076:	fc 93       	st	X, r31
    3078:	12 97       	sbiw	r26, 0x02	; 2
    307a:	81 5a       	subi	r24, 0xA1	; 161
    307c:	9d 4c       	sbci	r25, 0xCD	; 205
    307e:	e8 17       	cp	r30, r24
    3080:	f9 07       	cpc	r31, r25
    3082:	61 f4       	brne	.+24     	; 0x309c <vTaskSwitchContext+0x96>
    3084:	84 81       	ldd	r24, Z+4	; 0x04
    3086:	95 81       	ldd	r25, Z+5	; 0x05
    3088:	4b e0       	ldi	r20, 0x0B	; 11
    308a:	42 9f       	mul	r20, r18
    308c:	f0 01       	movw	r30, r0
    308e:	43 9f       	mul	r20, r19
    3090:	f0 0d       	add	r31, r0
    3092:	11 24       	eor	r1, r1
    3094:	e4 5a       	subi	r30, 0xA4	; 164
    3096:	fd 4c       	sbci	r31, 0xCD	; 205
    3098:	81 83       	std	Z+1, r24	; 0x01
    309a:	92 83       	std	Z+2, r25	; 0x02
    309c:	8b e0       	ldi	r24, 0x0B	; 11
    309e:	82 9f       	mul	r24, r18
    30a0:	f0 01       	movw	r30, r0
    30a2:	83 9f       	mul	r24, r19
    30a4:	f0 0d       	add	r31, r0
    30a6:	11 24       	eor	r1, r1
    30a8:	e4 5a       	subi	r30, 0xA4	; 164
    30aa:	fd 4c       	sbci	r31, 0xCD	; 205
    30ac:	01 80       	ldd	r0, Z+1	; 0x01
    30ae:	f2 81       	ldd	r31, Z+2	; 0x02
    30b0:	e0 2d       	mov	r30, r0
    30b2:	80 85       	ldd	r24, Z+8	; 0x08
    30b4:	91 85       	ldd	r25, Z+9	; 0x09
    30b6:	80 93 88 32 	sts	0x3288, r24	; 0x803288 <pxCurrentTCB>
    30ba:	90 93 89 32 	sts	0x3289, r25	; 0x803289 <pxCurrentTCB+0x1>
    30be:	08 95       	ret

000030c0 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    30c0:	cf 92       	push	r12
    30c2:	df 92       	push	r13
    30c4:	ef 92       	push	r14
    30c6:	ff 92       	push	r15
    30c8:	6a 01       	movw	r12, r20
    30ca:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    30cc:	60 91 88 32 	lds	r22, 0x3288	; 0x803288 <pxCurrentTCB>
    30d0:	70 91 89 32 	lds	r23, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    30d4:	62 5f       	subi	r22, 0xF2	; 242
    30d6:	7f 4f       	sbci	r23, 0xFF	; 255
    30d8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30dc:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    30e0:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    30e4:	02 96       	adiw	r24, 0x02	; 2
    30e6:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    30ea:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    30ee:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    30f2:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    30f6:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    30fa:	bc 01       	movw	r22, r24
    30fc:	cd 01       	movw	r24, r26
    30fe:	6c 0d       	add	r22, r12
    3100:	7d 1d       	adc	r23, r13
    3102:	8e 1d       	adc	r24, r14
    3104:	9f 1d       	adc	r25, r15
    3106:	0e 94 a0 14 	call	0x2940	; 0x2940 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    310a:	ff 90       	pop	r15
    310c:	ef 90       	pop	r14
    310e:	df 90       	pop	r13
    3110:	cf 90       	pop	r12
    3112:	08 95       	ret

00003114 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3114:	0f 93       	push	r16
    3116:	1f 93       	push	r17
    3118:	cf 93       	push	r28
    311a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    311c:	dc 01       	movw	r26, r24
    311e:	17 96       	adiw	r26, 0x07	; 7
    3120:	ed 91       	ld	r30, X+
    3122:	fc 91       	ld	r31, X
    3124:	18 97       	sbiw	r26, 0x08	; 8
    3126:	c0 85       	ldd	r28, Z+8	; 0x08
    3128:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    312a:	8e 01       	movw	r16, r28
    312c:	02 5f       	subi	r16, 0xF2	; 242
    312e:	1f 4f       	sbci	r17, 0xFF	; 255
    3130:	c8 01       	movw	r24, r16
    3132:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3136:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <uxSchedulerSuspended>
    313a:	81 11       	cpse	r24, r1
    313c:	16 c0       	rjmp	.+44     	; 0x316a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    313e:	0c 50       	subi	r16, 0x0C	; 12
    3140:	11 09       	sbc	r17, r1
    3142:	c8 01       	movw	r24, r16
    3144:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3148:	8a 8d       	ldd	r24, Y+26	; 0x1a
    314a:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    314e:	98 17       	cp	r25, r24
    3150:	10 f4       	brcc	.+4      	; 0x3156 <xTaskRemoveFromEventList+0x42>
    3152:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    3156:	bb e0       	ldi	r27, 0x0B	; 11
    3158:	8b 9f       	mul	r24, r27
    315a:	c0 01       	movw	r24, r0
    315c:	11 24       	eor	r1, r1
    315e:	b8 01       	movw	r22, r16
    3160:	84 5a       	subi	r24, 0xA4	; 164
    3162:	9d 4c       	sbci	r25, 0xCD	; 205
    3164:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
    3168:	05 c0       	rjmp	.+10     	; 0x3174 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    316a:	b8 01       	movw	r22, r16
    316c:	87 e3       	ldi	r24, 0x37	; 55
    316e:	92 e3       	ldi	r25, 0x32	; 50
    3170:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3174:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    3178:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    317c:	81 e0       	ldi	r24, 0x01	; 1
    317e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    3180:	92 8d       	ldd	r25, Z+26	; 0x1a
    3182:	29 17       	cp	r18, r25
    3184:	08 f4       	brcc	.+2      	; 0x3188 <xTaskRemoveFromEventList+0x74>
    3186:	80 e0       	ldi	r24, 0x00	; 0
}
    3188:	df 91       	pop	r29
    318a:	cf 91       	pop	r28
    318c:	1f 91       	pop	r17
    318e:	0f 91       	pop	r16
    3190:	08 95       	ret

00003192 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3192:	20 91 29 32 	lds	r18, 0x3229	; 0x803229 <xNumOfOverflows>
    3196:	fc 01       	movw	r30, r24
    3198:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    319a:	40 91 30 32 	lds	r20, 0x3230	; 0x803230 <xTickCount>
    319e:	50 91 31 32 	lds	r21, 0x3231	; 0x803231 <xTickCount+0x1>
    31a2:	60 91 32 32 	lds	r22, 0x3232	; 0x803232 <xTickCount+0x2>
    31a6:	70 91 33 32 	lds	r23, 0x3233	; 0x803233 <xTickCount+0x3>
    31aa:	41 83       	std	Z+1, r20	; 0x01
    31ac:	52 83       	std	Z+2, r21	; 0x02
    31ae:	63 83       	std	Z+3, r22	; 0x03
    31b0:	74 83       	std	Z+4, r23	; 0x04
    31b2:	08 95       	ret

000031b4 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    31b4:	8f 92       	push	r8
    31b6:	9f 92       	push	r9
    31b8:	af 92       	push	r10
    31ba:	bf 92       	push	r11
    31bc:	cf 92       	push	r12
    31be:	df 92       	push	r13
    31c0:	ef 92       	push	r14
    31c2:	ff 92       	push	r15
    31c4:	0f 93       	push	r16
    31c6:	1f 93       	push	r17
    31c8:	cf 93       	push	r28
    31ca:	df 93       	push	r29
    31cc:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    31ce:	0f b6       	in	r0, 0x3f	; 63
    31d0:	f8 94       	cli
    31d2:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    31d4:	80 91 29 32 	lds	r24, 0x3229	; 0x803229 <xNumOfOverflows>
    31d8:	90 81       	ld	r25, Z
    31da:	98 17       	cp	r25, r24
    31dc:	89 f0       	breq	.+34     	; 0x3200 <xTaskCheckForTimeOut+0x4c>
    31de:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    31e2:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    31e6:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    31ea:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    31ee:	01 81       	ldd	r16, Z+1	; 0x01
    31f0:	12 81       	ldd	r17, Z+2	; 0x02
    31f2:	23 81       	ldd	r18, Z+3	; 0x03
    31f4:	34 81       	ldd	r19, Z+4	; 0x04
    31f6:	80 17       	cp	r24, r16
    31f8:	91 07       	cpc	r25, r17
    31fa:	a2 07       	cpc	r26, r18
    31fc:	b3 07       	cpc	r27, r19
    31fe:	a8 f5       	brcc	.+106    	; 0x326a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3200:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <xTickCount>
    3204:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <xTickCount+0x1>
    3208:	a0 91 32 32 	lds	r26, 0x3232	; 0x803232 <xTickCount+0x2>
    320c:	b0 91 33 32 	lds	r27, 0x3233	; 0x803233 <xTickCount+0x3>
    3210:	c1 80       	ldd	r12, Z+1	; 0x01
    3212:	d2 80       	ldd	r13, Z+2	; 0x02
    3214:	e3 80       	ldd	r14, Z+3	; 0x03
    3216:	f4 80       	ldd	r15, Z+4	; 0x04
    3218:	eb 01       	movw	r28, r22
    321a:	08 81       	ld	r16, Y
    321c:	19 81       	ldd	r17, Y+1	; 0x01
    321e:	2a 81       	ldd	r18, Y+2	; 0x02
    3220:	3b 81       	ldd	r19, Y+3	; 0x03
    3222:	8c 19       	sub	r24, r12
    3224:	9d 09       	sbc	r25, r13
    3226:	ae 09       	sbc	r26, r14
    3228:	bf 09       	sbc	r27, r15
    322a:	80 17       	cp	r24, r16
    322c:	91 07       	cpc	r25, r17
    322e:	a2 07       	cpc	r26, r18
    3230:	b3 07       	cpc	r27, r19
    3232:	e8 f4       	brcc	.+58     	; 0x326e <xTaskCheckForTimeOut+0xba>
    3234:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3236:	80 90 30 32 	lds	r8, 0x3230	; 0x803230 <xTickCount>
    323a:	90 90 31 32 	lds	r9, 0x3231	; 0x803231 <xTickCount+0x1>
    323e:	a0 90 32 32 	lds	r10, 0x3232	; 0x803232 <xTickCount+0x2>
    3242:	b0 90 33 32 	lds	r11, 0x3233	; 0x803233 <xTickCount+0x3>
    3246:	b5 01       	movw	r22, r10
    3248:	a4 01       	movw	r20, r8
    324a:	4c 19       	sub	r20, r12
    324c:	5d 09       	sbc	r21, r13
    324e:	6e 09       	sbc	r22, r14
    3250:	7f 09       	sbc	r23, r15
    3252:	04 1b       	sub	r16, r20
    3254:	15 0b       	sbc	r17, r21
    3256:	26 0b       	sbc	r18, r22
    3258:	37 0b       	sbc	r19, r23
    325a:	08 83       	st	Y, r16
    325c:	19 83       	std	Y+1, r17	; 0x01
    325e:	2a 83       	std	Y+2, r18	; 0x02
    3260:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    3262:	0e 94 c9 18 	call	0x3192	; 0x3192 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3266:	80 e0       	ldi	r24, 0x00	; 0
    3268:	03 c0       	rjmp	.+6      	; 0x3270 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    326a:	81 e0       	ldi	r24, 0x01	; 1
    326c:	01 c0       	rjmp	.+2      	; 0x3270 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    326e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    3270:	0f 90       	pop	r0
    3272:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3274:	df 91       	pop	r29
    3276:	cf 91       	pop	r28
    3278:	1f 91       	pop	r17
    327a:	0f 91       	pop	r16
    327c:	ff 90       	pop	r15
    327e:	ef 90       	pop	r14
    3280:	df 90       	pop	r13
    3282:	cf 90       	pop	r12
    3284:	bf 90       	pop	r11
    3286:	af 90       	pop	r10
    3288:	9f 90       	pop	r9
    328a:	8f 90       	pop	r8
    328c:	08 95       	ret

0000328e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    328e:	81 e0       	ldi	r24, 0x01	; 1
    3290:	80 93 2a 32 	sts	0x322A, r24	; 0x80322a <xMissedYield>
    3294:	08 95       	ret

00003296 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3296:	00 97       	sbiw	r24, 0x00	; 0
    3298:	21 f4       	brne	.+8      	; 0x32a2 <uxTaskGetStackHighWaterMark+0xc>
    329a:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    329e:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    32a2:	dc 01       	movw	r26, r24
    32a4:	5b 96       	adiw	r26, 0x1b	; 27
    32a6:	ed 91       	ld	r30, X+
    32a8:	fc 91       	ld	r31, X
    32aa:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32ac:	80 81       	ld	r24, Z
    32ae:	81 31       	cpi	r24, 0x11	; 17
    32b0:	41 f4       	brne	.+16     	; 0x32c2 <uxTaskGetStackHighWaterMark+0x2c>
    32b2:	31 96       	adiw	r30, 0x01	; 1
    32b4:	80 e0       	ldi	r24, 0x00	; 0
    32b6:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    32b8:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32ba:	21 91       	ld	r18, Z+
    32bc:	21 31       	cpi	r18, 0x11	; 17
    32be:	e1 f3       	breq	.-8      	; 0x32b8 <uxTaskGetStackHighWaterMark+0x22>
    32c0:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    32c2:	80 e0       	ldi	r24, 0x00	; 0
    32c4:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    32c6:	08 95       	ret

000032c8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    32c8:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <pxCurrentTCB>
    32cc:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <pxCurrentTCB+0x1>

		return xReturn;
	}
    32d0:	08 95       	ret

000032d2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    32d2:	0f 93       	push	r16
    32d4:	1f 93       	push	r17
    32d6:	cf 93       	push	r28
    32d8:	df 93       	push	r29
    32da:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    32dc:	22 8d       	ldd	r18, Z+26	; 0x1a
    32de:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    32e2:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    32e6:	5a 96       	adiw	r26, 0x1a	; 26
    32e8:	8c 91       	ld	r24, X
    32ea:	28 17       	cp	r18, r24
    32ec:	08 f0       	brcs	.+2      	; 0x32f0 <vTaskPriorityInherit+0x1e>
    32ee:	41 c0       	rjmp	.+130    	; 0x3372 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    32f0:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    32f4:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    32f8:	5a 96       	adiw	r26, 0x1a	; 26
    32fa:	3c 91       	ld	r19, X
    32fc:	84 e0       	ldi	r24, 0x04	; 4
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	a0 e0       	ldi	r26, 0x00	; 0
    3302:	b0 e0       	ldi	r27, 0x00	; 0
    3304:	83 1b       	sub	r24, r19
    3306:	91 09       	sbc	r25, r1
    3308:	a1 09       	sbc	r26, r1
    330a:	b1 09       	sbc	r27, r1
    330c:	86 87       	std	Z+14, r24	; 0x0e
    330e:	97 87       	std	Z+15, r25	; 0x0f
    3310:	a0 8b       	std	Z+16, r26	; 0x10
    3312:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3314:	8b e0       	ldi	r24, 0x0B	; 11
    3316:	28 9f       	mul	r18, r24
    3318:	90 01       	movw	r18, r0
    331a:	11 24       	eor	r1, r1
    331c:	24 5a       	subi	r18, 0xA4	; 164
    331e:	3d 4c       	sbci	r19, 0xCD	; 205
    3320:	84 85       	ldd	r24, Z+12	; 0x0c
    3322:	95 85       	ldd	r25, Z+13	; 0x0d
    3324:	82 17       	cp	r24, r18
    3326:	93 07       	cpc	r25, r19
    3328:	e9 f4       	brne	.+58     	; 0x3364 <vTaskPriorityInherit+0x92>
    332a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    332c:	ef 01       	movw	r28, r30
    332e:	22 96       	adiw	r28, 0x02	; 2
    3330:	ce 01       	movw	r24, r28
    3332:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3336:	e0 91 88 32 	lds	r30, 0x3288	; 0x803288 <pxCurrentTCB>
    333a:	f0 91 89 32 	lds	r31, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    333e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3340:	f8 01       	movw	r30, r16
    3342:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    3344:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    3348:	98 17       	cp	r25, r24
    334a:	10 f4       	brcc	.+4      	; 0x3350 <vTaskPriorityInherit+0x7e>
    334c:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    3350:	fb e0       	ldi	r31, 0x0B	; 11
    3352:	8f 9f       	mul	r24, r31
    3354:	c0 01       	movw	r24, r0
    3356:	11 24       	eor	r1, r1
    3358:	be 01       	movw	r22, r28
    335a:	84 5a       	subi	r24, 0xA4	; 164
    335c:	9d 4c       	sbci	r25, 0xCD	; 205
    335e:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
    3362:	07 c0       	rjmp	.+14     	; 0x3372 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3364:	a0 91 88 32 	lds	r26, 0x3288	; 0x803288 <pxCurrentTCB>
    3368:	b0 91 89 32 	lds	r27, 0x3289	; 0x803289 <pxCurrentTCB+0x1>
    336c:	5a 96       	adiw	r26, 0x1a	; 26
    336e:	8c 91       	ld	r24, X
    3370:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    3372:	df 91       	pop	r29
    3374:	cf 91       	pop	r28
    3376:	1f 91       	pop	r17
    3378:	0f 91       	pop	r16
    337a:	08 95       	ret

0000337c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    337c:	0f 93       	push	r16
    337e:	1f 93       	push	r17
    3380:	cf 93       	push	r28
    3382:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3384:	00 97       	sbiw	r24, 0x00	; 0
    3386:	49 f1       	breq	.+82     	; 0x33da <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3388:	fc 01       	movw	r30, r24
    338a:	32 8d       	ldd	r19, Z+26	; 0x1a
    338c:	27 a1       	ldd	r18, Z+39	; 0x27
    338e:	32 17       	cp	r19, r18
    3390:	21 f1       	breq	.+72     	; 0x33da <vTaskPriorityDisinherit+0x5e>
    3392:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3394:	8c 01       	movw	r16, r24
    3396:	0e 5f       	subi	r16, 0xFE	; 254
    3398:	1f 4f       	sbci	r17, 0xFF	; 255
    339a:	c8 01       	movw	r24, r16
    339c:	0e 94 1a 10 	call	0x2034	; 0x2034 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    33a0:	8f a1       	ldd	r24, Y+39	; 0x27
    33a2:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    33a4:	44 e0       	ldi	r20, 0x04	; 4
    33a6:	50 e0       	ldi	r21, 0x00	; 0
    33a8:	60 e0       	ldi	r22, 0x00	; 0
    33aa:	70 e0       	ldi	r23, 0x00	; 0
    33ac:	48 1b       	sub	r20, r24
    33ae:	51 09       	sbc	r21, r1
    33b0:	61 09       	sbc	r22, r1
    33b2:	71 09       	sbc	r23, r1
    33b4:	4e 87       	std	Y+14, r20	; 0x0e
    33b6:	5f 87       	std	Y+15, r21	; 0x0f
    33b8:	68 8b       	std	Y+16, r22	; 0x10
    33ba:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    33bc:	90 91 2e 32 	lds	r25, 0x322E	; 0x80322e <uxTopReadyPriority>
    33c0:	98 17       	cp	r25, r24
    33c2:	10 f4       	brcc	.+4      	; 0x33c8 <vTaskPriorityDisinherit+0x4c>
    33c4:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxTopReadyPriority>
    33c8:	fb e0       	ldi	r31, 0x0B	; 11
    33ca:	8f 9f       	mul	r24, r31
    33cc:	c0 01       	movw	r24, r0
    33ce:	11 24       	eor	r1, r1
    33d0:	b8 01       	movw	r22, r16
    33d2:	84 5a       	subi	r24, 0xA4	; 164
    33d4:	9d 4c       	sbci	r25, 0xCD	; 205
    33d6:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vListInsertEnd>
			}
		}
	}
    33da:	df 91       	pop	r29
    33dc:	cf 91       	pop	r28
    33de:	1f 91       	pop	r17
    33e0:	0f 91       	pop	r16
    33e2:	08 95       	ret

000033e4 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    33e4:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    33e6:	e8 81       	ld	r30, Y
    33e8:	f9 81       	ldd	r31, Y+1	; 0x01
    33ea:	01 90       	ld	r0, Z+
    33ec:	f0 81       	ld	r31, Z
    33ee:	e0 2d       	mov	r30, r0
    33f0:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    33f2:	1a 82       	std	Y+2, r1	; 0x02
    33f4:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    33f6:	6f ef       	ldi	r22, 0xFF	; 255
    33f8:	7f ef       	ldi	r23, 0xFF	; 255
    33fa:	cb 01       	movw	r24, r22
    33fc:	0e 94 d5 17 	call	0x2faa	; 0x2faa <vTaskDelay>
    3400:	fa cf       	rjmp	.-12     	; 0x33f6 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00003402 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    3402:	fc 01       	movw	r30, r24
    3404:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3406:	65 87       	std	Z+13, r22	; 0x0d
    3408:	08 95       	ret

0000340a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    340a:	4f 92       	push	r4
    340c:	5f 92       	push	r5
    340e:	6f 92       	push	r6
    3410:	7f 92       	push	r7
    3412:	8f 92       	push	r8
    3414:	9f 92       	push	r9
    3416:	af 92       	push	r10
    3418:	bf 92       	push	r11
    341a:	cf 92       	push	r12
    341c:	df 92       	push	r13
    341e:	ef 92       	push	r14
    3420:	ff 92       	push	r15
    3422:	0f 93       	push	r16
    3424:	1f 93       	push	r17
    3426:	cf 93       	push	r28
    3428:	df 93       	push	r29
    342a:	cd b7       	in	r28, 0x3d	; 61
    342c:	de b7       	in	r29, 0x3e	; 62
    342e:	2a 97       	sbiw	r28, 0x0a	; 10
    3430:	cd bf       	out	0x3d, r28	; 61
    3432:	de bf       	out	0x3e, r29	; 62
    3434:	4c 01       	movw	r8, r24
    3436:	29 01       	movw	r4, r18
    3438:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    343a:	86 e7       	ldi	r24, 0x76	; 118
    343c:	91 e2       	ldi	r25, 0x21	; 33
    343e:	f4 01       	movw	r30, r8
    3440:	80 83       	st	Z, r24
    3442:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3444:	fb 01       	movw	r30, r22
    3446:	80 81       	ld	r24, Z
    3448:	88 23       	and	r24, r24
    344a:	69 f0       	breq	.+26     	; 0x3466 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    344c:	de 01       	movw	r26, r28
    344e:	11 96       	adiw	r26, 0x01	; 1
    3450:	31 96       	adiw	r30, 0x01	; 1
    3452:	90 e0       	ldi	r25, 0x00	; 0
    3454:	02 c0       	rjmp	.+4      	; 0x345a <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3456:	99 30       	cpi	r25, 0x09	; 9
    3458:	39 f0       	breq	.+14     	; 0x3468 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    345a:	9f 5f       	subi	r25, 0xFF	; 255
    345c:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    345e:	81 91       	ld	r24, Z+
    3460:	81 11       	cpse	r24, r1
    3462:	f9 cf       	rjmp	.-14     	; 0x3456 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3464:	01 c0       	rjmp	.+2      	; 0x3468 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3466:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3468:	e1 e0       	ldi	r30, 0x01	; 1
    346a:	f0 e0       	ldi	r31, 0x00	; 0
    346c:	ec 0f       	add	r30, r28
    346e:	fd 1f       	adc	r31, r29
    3470:	e9 0f       	add	r30, r25
    3472:	f1 1d       	adc	r31, r1
    3474:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3476:	74 01       	movw	r14, r8
    3478:	f2 e0       	ldi	r31, 0x02	; 2
    347a:	ef 0e       	add	r14, r31
    347c:	f1 1c       	adc	r15, r1
    347e:	a1 2c       	mov	r10, r1
    3480:	b1 2c       	mov	r11, r1
    3482:	c1 2c       	mov	r12, r1
    3484:	d1 2c       	mov	r13, r1
    3486:	04 2f       	mov	r16, r20
    3488:	94 01       	movw	r18, r8
    348a:	a2 01       	movw	r20, r4
    348c:	be 01       	movw	r22, r28
    348e:	6f 5f       	subi	r22, 0xFF	; 255
    3490:	7f 4f       	sbci	r23, 0xFF	; 255
    3492:	86 e3       	ldi	r24, 0x36	; 54
    3494:	93 e0       	ldi	r25, 0x03	; 3
    3496:	0e 94 ee 14 	call	0x29dc	; 0x29dc <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    349a:	f4 01       	movw	r30, r8
    349c:	66 82       	std	Z+6, r6	; 0x06
    349e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    34a0:	40 86       	std	Z+8, r4	; 0x08
    34a2:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    34a4:	20 91 8a 32 	lds	r18, 0x328A	; 0x80328a <last_created_task_pointer>
    34a8:	30 91 8b 32 	lds	r19, 0x328B	; 0x80328b <last_created_task_pointer+0x1>
    34ac:	24 83       	std	Z+4, r18	; 0x04
    34ae:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    34b0:	80 92 8a 32 	sts	0x328A, r8	; 0x80328a <last_created_task_pointer>
    34b4:	90 92 8b 32 	sts	0x328B, r9	; 0x80328b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    34b8:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    34ba:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    34bc:	40 90 ec 32 	lds	r4, 0x32EC	; 0x8032ec <portStackTopForTask>
    34c0:	50 90 ed 32 	lds	r5, 0x32ED	; 0x8032ed <portStackTopForTask+0x1>
    34c4:	ff ef       	ldi	r31, 0xFF	; 255
    34c6:	4f 1a       	sub	r4, r31
    34c8:	5f 0a       	sbc	r5, r31
    34ca:	40 92 ec 32 	sts	0x32EC, r4	; 0x8032ec <portStackTopForTask>
    34ce:	50 92 ed 32 	sts	0x32ED, r5	; 0x8032ed <portStackTopForTask+0x1>
    34d2:	f4 01       	movw	r30, r8
    34d4:	42 86       	std	Z+10, r4	; 0x0a
    34d6:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    34d8:	16 86       	std	Z+14, r1	; 0x0e
    34da:	17 86       	std	Z+15, r1	; 0x0f
    34dc:	10 8a       	std	Z+16, r1	; 0x10
    34de:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    34e0:	61 14       	cp	r6, r1
    34e2:	71 04       	cpc	r7, r1
    34e4:	09 f4       	brne	.+2      	; 0x34e8 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    34e6:	44 c0       	rjmp	.+136    	; 0x3570 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    34e8:	81 30       	cpi	r24, 0x01	; 1
    34ea:	79 f5       	brne	.+94     	; 0x354a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    34ec:	6a e0       	ldi	r22, 0x0A	; 10
    34ee:	c3 01       	movw	r24, r6
    34f0:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    34f4:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    34f6:	69 eb       	ldi	r22, 0xB9	; 185
    34f8:	75 e0       	ldi	r23, 0x05	; 5
    34fa:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    34fe:	be 01       	movw	r22, r28
    3500:	6f 5f       	subi	r22, 0xFF	; 255
    3502:	7f 4f       	sbci	r23, 0xFF	; 255
    3504:	c7 01       	movw	r24, r14
    3506:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    350a:	6a e0       	ldi	r22, 0x0A	; 10
    350c:	c7 01       	movw	r24, r14
    350e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3512:	7c 01       	movw	r14, r24
    3514:	60 eb       	ldi	r22, 0xB0	; 176
    3516:	75 e0       	ldi	r23, 0x05	; 5
    3518:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    351c:	6a e0       	ldi	r22, 0x0A	; 10
    351e:	c7 01       	movw	r24, r14
    3520:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3524:	7c 01       	movw	r14, r24
    3526:	62 ea       	ldi	r22, 0xA2	; 162
    3528:	75 e0       	ldi	r23, 0x05	; 5
    352a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    352e:	63 e0       	ldi	r22, 0x03	; 3
    3530:	c7 01       	movw	r24, r14
    3532:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3536:	b2 01       	movw	r22, r4
    3538:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    353c:	62 e0       	ldi	r22, 0x02	; 2
    353e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3542:	66 e0       	ldi	r22, 0x06	; 6
    3544:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3548:	13 c0       	rjmp	.+38     	; 0x3570 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    354a:	6a e0       	ldi	r22, 0x0A	; 10
    354c:	c3 01       	movw	r24, r6
    354e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3552:	4c 01       	movw	r8, r24
    3554:	6d e8       	ldi	r22, 0x8D	; 141
    3556:	75 e0       	ldi	r23, 0x05	; 5
    3558:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    355c:	be 01       	movw	r22, r28
    355e:	6f 5f       	subi	r22, 0xFF	; 255
    3560:	7f 4f       	sbci	r23, 0xFF	; 255
    3562:	c4 01       	movw	r24, r8
    3564:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3568:	66 e0       	ldi	r22, 0x06	; 6
    356a:	c4 01       	movw	r24, r8
    356c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3570:	2a 96       	adiw	r28, 0x0a	; 10
    3572:	cd bf       	out	0x3d, r28	; 61
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	df 91       	pop	r29
    3578:	cf 91       	pop	r28
    357a:	1f 91       	pop	r17
    357c:	0f 91       	pop	r16
    357e:	ff 90       	pop	r15
    3580:	ef 90       	pop	r14
    3582:	df 90       	pop	r13
    3584:	cf 90       	pop	r12
    3586:	bf 90       	pop	r11
    3588:	af 90       	pop	r10
    358a:	9f 90       	pop	r9
    358c:	8f 90       	pop	r8
    358e:	7f 90       	pop	r7
    3590:	6f 90       	pop	r6
    3592:	5f 90       	pop	r5
    3594:	4f 90       	pop	r4
    3596:	08 95       	ret

00003598 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3598:	cf 92       	push	r12
    359a:	df 92       	push	r13
    359c:	ef 92       	push	r14
    359e:	ff 92       	push	r15
    35a0:	0f 93       	push	r16
    35a2:	1f 93       	push	r17
    35a4:	cf 93       	push	r28
    35a6:	df 93       	push	r29
    35a8:	ec 01       	movw	r28, r24
    35aa:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    35ac:	8a 81       	ldd	r24, Y+2	; 0x02
    35ae:	9b 81       	ldd	r25, Y+3	; 0x03
    35b0:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <pcTaskGetTaskName>
    35b4:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    35b6:	6a e0       	ldi	r22, 0x0A	; 10
    35b8:	c7 01       	movw	r24, r14
    35ba:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    35be:	8c 01       	movw	r16, r24
    35c0:	6c ec       	ldi	r22, 0xCC	; 204
    35c2:	75 e0       	ldi	r23, 0x05	; 5
    35c4:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    35c8:	6a e0       	ldi	r22, 0x0A	; 10
    35ca:	c8 01       	movw	r24, r16
    35cc:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    35d0:	8c 01       	movw	r16, r24
    35d2:	65 ec       	ldi	r22, 0xC5	; 197
    35d4:	75 e0       	ldi	r23, 0x05	; 5
    35d6:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    35da:	b6 01       	movw	r22, r12
    35dc:	c8 01       	movw	r24, r16
    35de:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    35e2:	6a e0       	ldi	r22, 0x0A	; 10
    35e4:	c8 01       	movw	r24, r16
    35e6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    35ea:	8c 01       	movw	r16, r24
    35ec:	6f eb       	ldi	r22, 0xBF	; 191
    35ee:	75 e0       	ldi	r23, 0x05	; 5
    35f0:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    35f4:	66 e0       	ldi	r22, 0x06	; 6
    35f6:	c8 01       	movw	r24, r16
    35f8:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    35fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    35fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    3600:	e8 85       	ldd	r30, Y+8	; 0x08
    3602:	f9 85       	ldd	r31, Y+9	; 0x09
    3604:	01 e1       	ldi	r16, 0x11	; 17
    3606:	21 e0       	ldi	r18, 0x01	; 1
    3608:	a7 01       	movw	r20, r14
    360a:	bc 01       	movw	r22, r24
    360c:	8e 1b       	sub	r24, r30
    360e:	9f 0b       	sbc	r25, r31
    3610:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3614:	8c 81       	ldd	r24, Y+4	; 0x04
    3616:	9d 81       	ldd	r25, Y+5	; 0x05
    3618:	00 97       	sbiw	r24, 0x00	; 0
    361a:	19 f0       	breq	.+6      	; 0x3622 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    361c:	b7 01       	movw	r22, r14
    361e:	0e 94 cc 1a 	call	0x3598	; 0x3598 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    3622:	df 91       	pop	r29
    3624:	cf 91       	pop	r28
    3626:	1f 91       	pop	r17
    3628:	0f 91       	pop	r16
    362a:	ff 90       	pop	r15
    362c:	ef 90       	pop	r14
    362e:	df 90       	pop	r13
    3630:	cf 90       	pop	r12
    3632:	08 95       	ret

00003634 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3634:	0f 93       	push	r16
    3636:	1f 93       	push	r17
    3638:	cf 93       	push	r28
    363a:	df 93       	push	r29
    363c:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    363e:	80 91 8a 32 	lds	r24, 0x328A	; 0x80328a <last_created_task_pointer>
    3642:	90 91 8b 32 	lds	r25, 0x328B	; 0x80328b <last_created_task_pointer+0x1>
    3646:	00 97       	sbiw	r24, 0x00	; 0
    3648:	19 f0       	breq	.+6      	; 0x3650 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    364a:	be 01       	movw	r22, r28
    364c:	0e 94 cc 1a 	call	0x3598	; 0x3598 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    3650:	6a e0       	ldi	r22, 0x0A	; 10
    3652:	ce 01       	movw	r24, r28
    3654:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3658:	8c 01       	movw	r16, r24
    365a:	62 ee       	ldi	r22, 0xE2	; 226
    365c:	75 e0       	ldi	r23, 0x05	; 5
    365e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3662:	6a e0       	ldi	r22, 0x0A	; 10
    3664:	c8 01       	movw	r24, r16
    3666:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    366a:	8c 01       	movw	r16, r24
    366c:	67 ed       	ldi	r22, 0xD7	; 215
    366e:	75 e0       	ldi	r23, 0x05	; 5
    3670:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3674:	6a e0       	ldi	r22, 0x0A	; 10
    3676:	c8 01       	movw	r24, r16
    3678:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    367c:	8c 01       	movw	r16, r24
    367e:	61 ed       	ldi	r22, 0xD1	; 209
    3680:	75 e0       	ldi	r23, 0x05	; 5
    3682:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3686:	66 e0       	ldi	r22, 0x06	; 6
    3688:	c8 01       	movw	r24, r16
    368a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    368e:	80 91 ec 32 	lds	r24, 0x32EC	; 0x8032ec <portStackTopForTask>
    3692:	90 91 ed 32 	lds	r25, 0x32ED	; 0x8032ed <portStackTopForTask+0x1>
    3696:	bc 01       	movw	r22, r24
    3698:	6f 5f       	subi	r22, 0xFF	; 255
    369a:	7f 4f       	sbci	r23, 0xFF	; 255
    369c:	01 e1       	ldi	r16, 0x11	; 17
    369e:	21 e0       	ldi	r18, 0x01	; 1
    36a0:	ae 01       	movw	r20, r28
    36a2:	83 56       	subi	r24, 0x63	; 99
    36a4:	91 09       	sbc	r25, r1
    36a6:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    36aa:	df 91       	pop	r29
    36ac:	cf 91       	pop	r28
    36ae:	1f 91       	pop	r17
    36b0:	0f 91       	pop	r16
    36b2:	08 95       	ret

000036b4 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    36b4:	8f 92       	push	r8
    36b6:	9f 92       	push	r9
    36b8:	af 92       	push	r10
    36ba:	bf 92       	push	r11
    36bc:	cf 92       	push	r12
    36be:	df 92       	push	r13
    36c0:	ef 92       	push	r14
    36c2:	ff 92       	push	r15
    36c4:	0f 93       	push	r16
    36c6:	1f 93       	push	r17
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29
    36cc:	ec 01       	movw	r28, r24
    36ce:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    36d0:	8a 81       	ldd	r24, Y+2	; 0x02
    36d2:	9b 81       	ldd	r25, Y+3	; 0x03
    36d4:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <pcTaskGetTaskName>
    36d8:	bc 01       	movw	r22, r24
    36da:	c8 01       	movw	r24, r16
    36dc:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    36e0:	d8 01       	movw	r26, r16
    36e2:	ed 91       	ld	r30, X+
    36e4:	fc 91       	ld	r31, X
    36e6:	02 80       	ldd	r0, Z+2	; 0x02
    36e8:	f3 81       	ldd	r31, Z+3	; 0x03
    36ea:	e0 2d       	mov	r30, r0
    36ec:	69 e0       	ldi	r22, 0x09	; 9
    36ee:	c8 01       	movw	r24, r16
    36f0:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    36f2:	8a 81       	ldd	r24, Y+2	; 0x02
    36f4:	9b 81       	ldd	r25, Y+3	; 0x03
    36f6:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <pcTaskGetTaskName>
    36fa:	fc 01       	movw	r30, r24
    36fc:	01 90       	ld	r0, Z+
    36fe:	00 20       	and	r0, r0
    3700:	e9 f7       	brne	.-6      	; 0x36fc <_ZN8frt_task12print_statusER8emstream+0x48>
    3702:	31 97       	sbiw	r30, 0x01	; 1
    3704:	e8 1b       	sub	r30, r24
    3706:	f9 0b       	sbc	r31, r25
    3708:	38 97       	sbiw	r30, 0x08	; 8
    370a:	48 f4       	brcc	.+18     	; 0x371e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    370c:	d8 01       	movw	r26, r16
    370e:	ed 91       	ld	r30, X+
    3710:	fc 91       	ld	r31, X
    3712:	02 80       	ldd	r0, Z+2	; 0x02
    3714:	f3 81       	ldd	r31, Z+3	; 0x03
    3716:	e0 2d       	mov	r30, r0
    3718:	69 e0       	ldi	r22, 0x09	; 9
    371a:	c8 01       	movw	r24, r16
    371c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    371e:	ce 84       	ldd	r12, Y+14	; 0x0e
    3720:	df 84       	ldd	r13, Y+15	; 0x0f
    3722:	e8 88       	ldd	r14, Y+16	; 0x10
    3724:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3726:	a8 84       	ldd	r10, Y+8	; 0x08
    3728:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    372a:	8a 81       	ldd	r24, Y+2	; 0x02
    372c:	9b 81       	ldd	r25, Y+3	; 0x03
    372e:	0e 94 4b 19 	call	0x3296	; 0x3296 <uxTaskGetStackHighWaterMark>
    3732:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3734:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3736:	8a 81       	ldd	r24, Y+2	; 0x02
    3738:	9b 81       	ldd	r25, Y+3	; 0x03
    373a:	0e 94 f0 15 	call	0x2be0	; 0x2be0 <uxTaskPriorityGet>
    373e:	68 2f       	mov	r22, r24
    3740:	c8 01       	movw	r24, r16
    3742:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    3746:	6a e0       	ldi	r22, 0x0A	; 10
    3748:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    374c:	ec 01       	movw	r28, r24
    374e:	67 e5       	ldi	r22, 0x57	; 87
    3750:	76 e0       	ldi	r23, 0x06	; 6
    3752:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3756:	68 2d       	mov	r22, r8
    3758:	ce 01       	movw	r24, r28
    375a:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    375e:	6a e0       	ldi	r22, 0x0A	; 10
    3760:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3764:	ec 01       	movw	r28, r24
    3766:	65 e5       	ldi	r22, 0x55	; 85
    3768:	76 e0       	ldi	r23, 0x06	; 6
    376a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    376e:	69 2d       	mov	r22, r9
    3770:	ce 01       	movw	r24, r28
    3772:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    3776:	6a e0       	ldi	r22, 0x0A	; 10
    3778:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    377c:	ec 01       	movw	r28, r24
    377e:	63 e5       	ldi	r22, 0x53	; 83
    3780:	76 e0       	ldi	r23, 0x06	; 6
    3782:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3786:	b5 01       	movw	r22, r10
    3788:	ce 01       	movw	r24, r28
    378a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    378e:	6a e0       	ldi	r22, 0x0A	; 10
    3790:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3794:	ec 01       	movw	r28, r24
    3796:	61 e5       	ldi	r22, 0x51	; 81
    3798:	76 e0       	ldi	r23, 0x06	; 6
    379a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    379e:	6a e0       	ldi	r22, 0x0A	; 10
    37a0:	ce 01       	movw	r24, r28
    37a2:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    37a6:	ec 01       	movw	r28, r24
    37a8:	6f e4       	ldi	r22, 0x4F	; 79
    37aa:	76 e0       	ldi	r23, 0x06	; 6
    37ac:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    37b0:	b7 01       	movw	r22, r14
    37b2:	a6 01       	movw	r20, r12
    37b4:	ce 01       	movw	r24, r28
    37b6:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <_ZN8emstreamlsEm>
}
    37ba:	df 91       	pop	r29
    37bc:	cf 91       	pop	r28
    37be:	1f 91       	pop	r17
    37c0:	0f 91       	pop	r16
    37c2:	ff 90       	pop	r15
    37c4:	ef 90       	pop	r14
    37c6:	df 90       	pop	r13
    37c8:	cf 90       	pop	r12
    37ca:	bf 90       	pop	r11
    37cc:	af 90       	pop	r10
    37ce:	9f 90       	pop	r9
    37d0:	8f 90       	pop	r8
    37d2:	08 95       	ret

000037d4 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    37d4:	cf 93       	push	r28
    37d6:	df 93       	push	r29
    37d8:	ec 01       	movw	r28, r24
    37da:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    37dc:	db 01       	movw	r26, r22
    37de:	ed 91       	ld	r30, X+
    37e0:	fc 91       	ld	r31, X
    37e2:	02 80       	ldd	r0, Z+2	; 0x02
    37e4:	f3 81       	ldd	r31, Z+3	; 0x03
    37e6:	e0 2d       	mov	r30, r0
    37e8:	be 01       	movw	r22, r28
    37ea:	19 95       	eicall
	return (ser_dev);
}
    37ec:	ce 01       	movw	r24, r28
    37ee:	df 91       	pop	r29
    37f0:	cf 91       	pop	r28
    37f2:	08 95       	ret

000037f4 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    37f4:	0f 93       	push	r16
    37f6:	1f 93       	push	r17
    37f8:	cf 93       	push	r28
    37fa:	df 93       	push	r29
    37fc:	ec 01       	movw	r28, r24
    37fe:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    3800:	bc 01       	movw	r22, r24
    3802:	c8 01       	movw	r24, r16
    3804:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <_ZlsR8emstreamR8frt_task>
    3808:	66 e0       	ldi	r22, 0x06	; 6
    380a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    380e:	8c 81       	ldd	r24, Y+4	; 0x04
    3810:	9d 81       	ldd	r25, Y+5	; 0x05
    3812:	00 97       	sbiw	r24, 0x00	; 0
    3814:	19 f0       	breq	.+6      	; 0x381c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3816:	b8 01       	movw	r22, r16
    3818:	0e 94 fa 1b 	call	0x37f4	; 0x37f4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    381c:	df 91       	pop	r29
    381e:	cf 91       	pop	r28
    3820:	1f 91       	pop	r17
    3822:	0f 91       	pop	r16
    3824:	08 95       	ret

00003826 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3826:	0f 93       	push	r16
    3828:	1f 93       	push	r17
    382a:	cf 93       	push	r28
    382c:	df 93       	push	r29
    382e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    3830:	6a e0       	ldi	r22, 0x0A	; 10
    3832:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3836:	8c 01       	movw	r16, r24
    3838:	64 e4       	ldi	r22, 0x44	; 68
    383a:	76 e0       	ldi	r23, 0x06	; 6
    383c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3840:	6a e0       	ldi	r22, 0x0A	; 10
    3842:	c8 01       	movw	r24, r16
    3844:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3848:	8c 01       	movw	r16, r24
    384a:	6d e3       	ldi	r22, 0x3D	; 61
    384c:	76 e0       	ldi	r23, 0x06	; 6
    384e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    3852:	66 e0       	ldi	r22, 0x06	; 6
    3854:	c8 01       	movw	r24, r16
    3856:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    385a:	6a e0       	ldi	r22, 0x0A	; 10
    385c:	ce 01       	movw	r24, r28
    385e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3862:	8c 01       	movw	r16, r24
    3864:	6c e2       	ldi	r22, 0x2C	; 44
    3866:	76 e0       	ldi	r23, 0x06	; 6
    3868:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    386c:	6a e0       	ldi	r22, 0x0A	; 10
    386e:	c8 01       	movw	r24, r16
    3870:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3874:	8c 01       	movw	r16, r24
    3876:	60 e2       	ldi	r22, 0x20	; 32
    3878:	76 e0       	ldi	r23, 0x06	; 6
    387a:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    387e:	6a e0       	ldi	r22, 0x0A	; 10
    3880:	c8 01       	movw	r24, r16
    3882:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3886:	8c 01       	movw	r16, r24
    3888:	6a e1       	ldi	r22, 0x1A	; 26
    388a:	76 e0       	ldi	r23, 0x06	; 6
    388c:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3890:	66 e0       	ldi	r22, 0x06	; 6
    3892:	c8 01       	movw	r24, r16
    3894:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3898:	6a e0       	ldi	r22, 0x0A	; 10
    389a:	ce 01       	movw	r24, r28
    389c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    38a0:	8c 01       	movw	r16, r24
    38a2:	69 e0       	ldi	r22, 0x09	; 9
    38a4:	76 e0       	ldi	r23, 0x06	; 6
    38a6:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    38aa:	6a e0       	ldi	r22, 0x0A	; 10
    38ac:	c8 01       	movw	r24, r16
    38ae:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    38b2:	8c 01       	movw	r16, r24
    38b4:	6d ef       	ldi	r22, 0xFD	; 253
    38b6:	75 e0       	ldi	r23, 0x05	; 5
    38b8:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    38bc:	6a e0       	ldi	r22, 0x0A	; 10
    38be:	c8 01       	movw	r24, r16
    38c0:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    38c4:	8c 01       	movw	r16, r24
    38c6:	67 ef       	ldi	r22, 0xF7	; 247
    38c8:	75 e0       	ldi	r23, 0x05	; 5
    38ca:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    38ce:	66 e0       	ldi	r22, 0x06	; 6
    38d0:	c8 01       	movw	r24, r16
    38d2:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    38d6:	80 91 8a 32 	lds	r24, 0x328A	; 0x80328a <last_created_task_pointer>
    38da:	90 91 8b 32 	lds	r25, 0x328B	; 0x80328b <last_created_task_pointer+0x1>
    38de:	00 97       	sbiw	r24, 0x00	; 0
    38e0:	19 f0       	breq	.+6      	; 0x38e8 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    38e2:	be 01       	movw	r22, r28
    38e4:	0e 94 fa 1b 	call	0x37f4	; 0x37f4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    38e8:	0e 94 4d 16 	call	0x2c9a	; 0x2c9a <xTaskGetIdleTaskHandle>
    38ec:	0e 94 4b 19 	call	0x3296	; 0x3296 <uxTaskGetStackHighWaterMark>
    38f0:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    38f2:	6a e0       	ldi	r22, 0x0A	; 10
    38f4:	ce 01       	movw	r24, r28
    38f6:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    38fa:	ec 01       	movw	r28, r24
    38fc:	6c ee       	ldi	r22, 0xEC	; 236
    38fe:	75 e0       	ldi	r23, 0x05	; 5
    3900:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3904:	61 2f       	mov	r22, r17
    3906:	ce 01       	movw	r24, r28
    3908:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    390c:	6a e0       	ldi	r22, 0x0A	; 10
    390e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3912:	ec 01       	movw	r28, r24
    3914:	6a ee       	ldi	r22, 0xEA	; 234
    3916:	75 e0       	ldi	r23, 0x05	; 5
    3918:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    391c:	64 e6       	ldi	r22, 0x64	; 100
    391e:	70 e0       	ldi	r23, 0x00	; 0
    3920:	ce 01       	movw	r24, r28
    3922:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    3926:	6a e0       	ldi	r22, 0x0A	; 10
    3928:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    392c:	ec 01       	movw	r28, r24
    392e:	67 ee       	ldi	r22, 0xE7	; 231
    3930:	75 e0       	ldi	r23, 0x05	; 5
    3932:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3936:	66 e0       	ldi	r22, 0x06	; 6
    3938:	ce 01       	movw	r24, r28
    393a:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
}
    393e:	df 91       	pop	r29
    3940:	cf 91       	pop	r28
    3942:	1f 91       	pop	r17
    3944:	0f 91       	pop	r16
    3946:	08 95       	ret

00003948 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3948:	0f 93       	push	r16
    394a:	cf 93       	push	r28
    394c:	df 93       	push	r29
    394e:	1f 92       	push	r1
    3950:	cd b7       	in	r28, 0x3d	; 61
    3952:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3954:	00 e0       	ldi	r16, 0x00	; 0
    3956:	2f ef       	ldi	r18, 0xFF	; 255
    3958:	3f ef       	ldi	r19, 0xFF	; 255
    395a:	a9 01       	movw	r20, r18
    395c:	be 01       	movw	r22, r28
    395e:	6f 5f       	subi	r22, 0xFF	; 255
    3960:	7f 4f       	sbci	r23, 0xFF	; 255
    3962:	fc 01       	movw	r30, r24
    3964:	80 85       	ldd	r24, Z+8	; 0x08
    3966:	91 85       	ldd	r25, Z+9	; 0x09
    3968:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
    396c:	81 30       	cpi	r24, 0x01	; 1
    396e:	19 f4       	brne	.+6      	; 0x3976 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3970:	89 81       	ldd	r24, Y+1	; 0x01
    3972:	90 e0       	ldi	r25, 0x00	; 0
    3974:	02 c0       	rjmp	.+4      	; 0x397a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3976:	8f ef       	ldi	r24, 0xFF	; 255
    3978:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    397a:	0f 90       	pop	r0
    397c:	df 91       	pop	r29
    397e:	cf 91       	pop	r28
    3980:	0f 91       	pop	r16
    3982:	08 95       	ret

00003984 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3984:	fc 01       	movw	r30, r24
    3986:	80 85       	ldd	r24, Z+8	; 0x08
    3988:	91 85       	ldd	r25, Z+9	; 0x09
    398a:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    398e:	91 e0       	ldi	r25, 0x01	; 1
    3990:	81 11       	cpse	r24, r1
    3992:	01 c0       	rjmp	.+2      	; 0x3996 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3994:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3996:	89 2f       	mov	r24, r25
    3998:	08 95       	ret

0000399a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    399a:	0f 93       	push	r16
    399c:	cf 93       	push	r28
    399e:	df 93       	push	r29
    39a0:	1f 92       	push	r1
    39a2:	cd b7       	in	r28, 0x3d	; 61
    39a4:	de b7       	in	r29, 0x3e	; 62
    39a6:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    39a8:	fc 01       	movw	r30, r24
    39aa:	22 85       	ldd	r18, Z+10	; 0x0a
    39ac:	33 85       	ldd	r19, Z+11	; 0x0b
    39ae:	44 85       	ldd	r20, Z+12	; 0x0c
    39b0:	55 85       	ldd	r21, Z+13	; 0x0d
    39b2:	00 e0       	ldi	r16, 0x00	; 0
    39b4:	be 01       	movw	r22, r28
    39b6:	6f 5f       	subi	r22, 0xFF	; 255
    39b8:	7f 4f       	sbci	r23, 0xFF	; 255
    39ba:	80 85       	ldd	r24, Z+8	; 0x08
    39bc:	91 85       	ldd	r25, Z+9	; 0x09
    39be:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    39c2:	91 e0       	ldi	r25, 0x01	; 1
    39c4:	81 11       	cpse	r24, r1
    39c6:	01 c0       	rjmp	.+2      	; 0x39ca <_ZN14frt_text_queue7putcharEc+0x30>
    39c8:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    39ca:	89 2f       	mov	r24, r25
    39cc:	0f 90       	pop	r0
    39ce:	df 91       	pop	r29
    39d0:	cf 91       	pop	r28
    39d2:	0f 91       	pop	r16
    39d4:	08 95       	ret

000039d6 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    39d6:	8f 92       	push	r8
    39d8:	9f 92       	push	r9
    39da:	bf 92       	push	r11
    39dc:	cf 92       	push	r12
    39de:	df 92       	push	r13
    39e0:	ef 92       	push	r14
    39e2:	ff 92       	push	r15
    39e4:	0f 93       	push	r16
    39e6:	1f 93       	push	r17
    39e8:	cf 93       	push	r28
    39ea:	df 93       	push	r29
    39ec:	ec 01       	movw	r28, r24
    39ee:	b6 2e       	mov	r11, r22
    39f0:	4a 01       	movw	r8, r20
    39f2:	68 01       	movw	r12, r16
    39f4:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    39f6:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <_ZN8emstreamC1Ev>
    39fa:	8e e7       	ldi	r24, 0x7E	; 126
    39fc:	91 e2       	ldi	r25, 0x21	; 33
    39fe:	88 83       	st	Y, r24
    3a00:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3a02:	8e 86       	std	Y+14, r8	; 0x0e
    3a04:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3a06:	40 e0       	ldi	r20, 0x00	; 0
    3a08:	61 e0       	ldi	r22, 0x01	; 1
    3a0a:	8b 2d       	mov	r24, r11
    3a0c:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    3a10:	88 87       	std	Y+8, r24	; 0x08
    3a12:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3a14:	ca 86       	std	Y+10, r12	; 0x0a
    3a16:	db 86       	std	Y+11, r13	; 0x0b
    3a18:	ec 86       	std	Y+12, r14	; 0x0c
    3a1a:	fd 86       	std	Y+13, r15	; 0x0d
}
    3a1c:	df 91       	pop	r29
    3a1e:	cf 91       	pop	r28
    3a20:	1f 91       	pop	r17
    3a22:	0f 91       	pop	r16
    3a24:	ff 90       	pop	r15
    3a26:	ef 90       	pop	r14
    3a28:	df 90       	pop	r13
    3a2a:	cf 90       	pop	r12
    3a2c:	bf 90       	pop	r11
    3a2e:	9f 90       	pop	r9
    3a30:	8f 90       	pop	r8
    3a32:	08 95       	ret

00003a34 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3a34:	cf 92       	push	r12
    3a36:	df 92       	push	r13
    3a38:	ef 92       	push	r14
    3a3a:	ff 92       	push	r15
    3a3c:	cf 93       	push	r28
    3a3e:	df 93       	push	r29
    3a40:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3a42:	68 81       	ld	r22, Y
    3a44:	79 81       	ldd	r23, Y+1	; 0x01
    3a46:	8a 81       	ldd	r24, Y+2	; 0x02
    3a48:	9b 81       	ldd	r25, Y+3	; 0x03
    3a4a:	0f 2e       	mov	r0, r31
    3a4c:	f8 ee       	ldi	r31, 0xE8	; 232
    3a4e:	cf 2e       	mov	r12, r31
    3a50:	f3 e0       	ldi	r31, 0x03	; 3
    3a52:	df 2e       	mov	r13, r31
    3a54:	e1 2c       	mov	r14, r1
    3a56:	f1 2c       	mov	r15, r1
    3a58:	f0 2d       	mov	r31, r0
    3a5a:	a7 01       	movw	r20, r14
    3a5c:	96 01       	movw	r18, r12
    3a5e:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
    3a62:	9b 01       	movw	r18, r22
    3a64:	ac 01       	movw	r20, r24
    3a66:	60 e4       	ldi	r22, 0x40	; 64
    3a68:	72 e4       	ldi	r23, 0x42	; 66
    3a6a:	8f e0       	ldi	r24, 0x0F	; 15
    3a6c:	90 e0       	ldi	r25, 0x00	; 0
    3a6e:	0e 94 89 26 	call	0x4d12	; 0x4d12 <__mulsi3>
    3a72:	a7 01       	movw	r20, r14
    3a74:	96 01       	movw	r18, r12
    3a76:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
    3a7a:	69 01       	movw	r12, r18
    3a7c:	7a 01       	movw	r14, r20
    3a7e:	ac 81       	ldd	r26, Y+4	; 0x04
    3a80:	bd 81       	ldd	r27, Y+5	; 0x05
    3a82:	20 e4       	ldi	r18, 0x40	; 64
    3a84:	32 e4       	ldi	r19, 0x42	; 66
    3a86:	4f e0       	ldi	r20, 0x0F	; 15
    3a88:	50 e0       	ldi	r21, 0x00	; 0
    3a8a:	0e 94 e3 26 	call	0x4dc6	; 0x4dc6 <__muluhisi3>
    3a8e:	20 e0       	ldi	r18, 0x00	; 0
    3a90:	38 e4       	ldi	r19, 0x48	; 72
    3a92:	48 ee       	ldi	r20, 0xE8	; 232
    3a94:	51 e0       	ldi	r21, 0x01	; 1
    3a96:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
    3a9a:	c7 01       	movw	r24, r14
    3a9c:	b6 01       	movw	r22, r12
    3a9e:	62 0f       	add	r22, r18
    3aa0:	73 1f       	adc	r23, r19
    3aa2:	84 1f       	adc	r24, r20
    3aa4:	95 1f       	adc	r25, r21
}
    3aa6:	df 91       	pop	r29
    3aa8:	cf 91       	pop	r28
    3aaa:	ff 90       	pop	r15
    3aac:	ef 90       	pop	r14
    3aae:	df 90       	pop	r13
    3ab0:	cf 90       	pop	r12
    3ab2:	08 95       	ret

00003ab4 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3ab4:	cf 92       	push	r12
    3ab6:	df 92       	push	r13
    3ab8:	ef 92       	push	r14
    3aba:	ff 92       	push	r15
    3abc:	0f 93       	push	r16
    3abe:	1f 93       	push	r17
    3ac0:	cf 93       	push	r28
    3ac2:	df 93       	push	r29
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	2f 97       	sbiw	r28, 0x0f	; 15
    3aca:	cd bf       	out	0x3d, r28	; 61
    3acc:	de bf       	out	0x3e, r29	; 62
    3ace:	6c 01       	movw	r12, r24
    3ad0:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3ad2:	db 01       	movw	r26, r22
    3ad4:	6d 91       	ld	r22, X+
    3ad6:	7d 91       	ld	r23, X+
    3ad8:	8d 91       	ld	r24, X+
    3ada:	9c 91       	ld	r25, X
    3adc:	28 ee       	ldi	r18, 0xE8	; 232
    3ade:	33 e0       	ldi	r19, 0x03	; 3
    3ae0:	40 e0       	ldi	r20, 0x00	; 0
    3ae2:	50 e0       	ldi	r21, 0x00	; 0
    3ae4:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
    3ae8:	ba 01       	movw	r22, r20
    3aea:	a9 01       	movw	r20, r18
    3aec:	c6 01       	movw	r24, r12
    3aee:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3af2:	d6 01       	movw	r26, r12
    3af4:	ed 91       	ld	r30, X+
    3af6:	fc 91       	ld	r31, X
    3af8:	02 80       	ldd	r0, Z+2	; 0x02
    3afa:	f3 81       	ldd	r31, Z+3	; 0x03
    3afc:	e0 2d       	mov	r30, r0
    3afe:	6e e2       	ldi	r22, 0x2E	; 46
    3b00:	c6 01       	movw	r24, r12
    3b02:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3b04:	c8 01       	movw	r24, r16
    3b06:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <_ZN10time_stamp12get_microsecEv>
    3b0a:	8e 01       	movw	r16, r28
    3b0c:	09 5f       	subi	r16, 0xF9	; 249
    3b0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3b10:	fe 01       	movw	r30, r28
    3b12:	31 96       	adiw	r30, 0x01	; 1
    3b14:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3b16:	2a e0       	ldi	r18, 0x0A	; 10
    3b18:	30 e0       	ldi	r19, 0x00	; 0
    3b1a:	40 e0       	ldi	r20, 0x00	; 0
    3b1c:	50 e0       	ldi	r21, 0x00	; 0
    3b1e:	0e 94 bb 26 	call	0x4d76	; 0x4d76 <__divmodsi4>
    3b22:	e6 2f       	mov	r30, r22
    3b24:	28 87       	std	Y+8, r18	; 0x08
    3b26:	39 87       	std	Y+9, r19	; 0x09
    3b28:	4a 87       	std	Y+10, r20	; 0x0a
    3b2a:	5b 87       	std	Y+11, r21	; 0x0b
    3b2c:	68 85       	ldd	r22, Y+8	; 0x08
    3b2e:	79 85       	ldd	r23, Y+9	; 0x09
    3b30:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b32:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3b34:	20 e3       	ldi	r18, 0x30	; 48
    3b36:	2e 0f       	add	r18, r30
    3b38:	d8 01       	movw	r26, r16
    3b3a:	2e 93       	st	-X, r18
    3b3c:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3b3e:	ae 15       	cp	r26, r14
    3b40:	bf 05       	cpc	r27, r15
    3b42:	49 f7       	brne	.-46     	; 0x3b16 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3b44:	1f 82       	std	Y+7, r1	; 0x07
    3b46:	be 01       	movw	r22, r28
    3b48:	6f 5f       	subi	r22, 0xFF	; 255
    3b4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b4c:	c6 01       	movw	r24, r12
    3b4e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3b52:	c6 01       	movw	r24, r12
    3b54:	2f 96       	adiw	r28, 0x0f	; 15
    3b56:	cd bf       	out	0x3d, r28	; 61
    3b58:	de bf       	out	0x3e, r29	; 62
    3b5a:	df 91       	pop	r29
    3b5c:	cf 91       	pop	r28
    3b5e:	1f 91       	pop	r17
    3b60:	0f 91       	pop	r16
    3b62:	ff 90       	pop	r15
    3b64:	ef 90       	pop	r14
    3b66:	df 90       	pop	r13
    3b68:	cf 90       	pop	r12
    3b6a:	08 95       	ret

00003b6c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3b6c:	cf 93       	push	r28
    3b6e:	df 93       	push	r29
    3b70:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	f8 94       	cli
    3b76:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3b78:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3b7c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3b80:	8c 83       	std	Y+4, r24	; 0x04
    3b82:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3b84:	0e 94 37 16 	call	0x2c6e	; 0x2c6e <xTaskGetTickCount>
    3b88:	68 83       	st	Y, r22
    3b8a:	79 83       	std	Y+1, r23	; 0x01
    3b8c:	8a 83       	std	Y+2, r24	; 0x02
    3b8e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3b90:	0f 90       	pop	r0
    3b92:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3b94:	ce 01       	movw	r24, r28
    3b96:	df 91       	pop	r29
    3b98:	cf 91       	pop	r28
    3b9a:	08 95       	ret

00003b9c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3b9c:	5f 92       	push	r5
    3b9e:	6f 92       	push	r6
    3ba0:	7f 92       	push	r7
    3ba2:	8f 92       	push	r8
    3ba4:	9f 92       	push	r9
    3ba6:	af 92       	push	r10
    3ba8:	bf 92       	push	r11
    3baa:	cf 92       	push	r12
    3bac:	df 92       	push	r13
    3bae:	ef 92       	push	r14
    3bb0:	ff 92       	push	r15
    3bb2:	0f 93       	push	r16
    3bb4:	1f 93       	push	r17
    3bb6:	cf 93       	push	r28
    3bb8:	df 93       	push	r29
    3bba:	5c 01       	movw	r10, r24
    3bbc:	4b 01       	movw	r8, r22
    3bbe:	7a 01       	movw	r14, r20
    3bc0:	12 2f       	mov	r17, r18
    3bc2:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3bc4:	63 e0       	ldi	r22, 0x03	; 3
    3bc6:	ca 01       	movw	r24, r20
    3bc8:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3bcc:	a8 14       	cp	r10, r8
    3bce:	b9 04       	cpc	r11, r9
    3bd0:	08 f0       	brcs	.+2      	; 0x3bd4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3bd2:	7d c0       	rjmp	.+250    	; 0x3cce <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3bd4:	65 01       	movw	r12, r10
    3bd6:	84 e1       	ldi	r24, 0x14	; 20
    3bd8:	c8 0e       	add	r12, r24
    3bda:	d1 1c       	adc	r13, r1
    3bdc:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3bde:	6a 2c       	mov	r6, r10
    3be0:	5b 2c       	mov	r5, r11
    3be2:	b5 01       	movw	r22, r10
    3be4:	c7 01       	movw	r24, r14
    3be6:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsEj>
    3bea:	6a e0       	ldi	r22, 0x0A	; 10
    3bec:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3bf0:	69 e6       	ldi	r22, 0x69	; 105
    3bf2:	76 e0       	ldi	r23, 0x06	; 6
    3bf4:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3bf8:	11 23       	and	r17, r17
    3bfa:	09 f4       	brne	.+2      	; 0x3bfe <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3bfc:	6d c0       	rjmp	.+218    	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3bfe:	00 23       	and	r16, r16
    3c00:	09 f4       	brne	.+2      	; 0x3c04 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3c02:	6a c0       	rjmp	.+212    	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3c04:	6a e0       	ldi	r22, 0x0A	; 10
    3c06:	c7 01       	movw	r24, r14
    3c08:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3c0c:	64 e6       	ldi	r22, 0x64	; 100
    3c0e:	76 e0       	ldi	r23, 0x06	; 6
    3c10:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    3c14:	61 c0       	rjmp	.+194    	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3c16:	11 23       	and	r17, r17
    3c18:	71 f0       	breq	.+28     	; 0x3c36 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c1a:	01 11       	cpse	r16, r1
    3c1c:	0c c0       	rjmp	.+24     	; 0x3c36 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c1e:	88 81       	ld	r24, Y
    3c20:	87 15       	cp	r24, r7
    3c22:	49 f0       	breq	.+18     	; 0x3c36 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3c24:	6a e0       	ldi	r22, 0x0A	; 10
    3c26:	c7 01       	movw	r24, r14
    3c28:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3c2c:	6f e5       	ldi	r22, 0x5F	; 95
    3c2e:	76 e0       	ldi	r23, 0x06	; 6
    3c30:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c34:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3c36:	69 91       	ld	r22, Y+
    3c38:	c7 01       	movw	r24, r14
    3c3a:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c3e:	dc 01       	movw	r26, r24
    3c40:	ed 91       	ld	r30, X+
    3c42:	fc 91       	ld	r31, X
    3c44:	02 80       	ldd	r0, Z+2	; 0x02
    3c46:	f3 81       	ldd	r31, Z+3	; 0x03
    3c48:	e0 2d       	mov	r30, r0
    3c4a:	60 e2       	ldi	r22, 0x20	; 32
    3c4c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3c4e:	cc 16       	cp	r12, r28
    3c50:	dd 06       	cpc	r13, r29
    3c52:	09 f7       	brne	.-62     	; 0x3c16 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3c54:	11 23       	and	r17, r17
    3c56:	89 f0       	breq	.+34     	; 0x3c7a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3c58:	6a e0       	ldi	r22, 0x0A	; 10
    3c5a:	c7 01       	movw	r24, r14
    3c5c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3c60:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c62:	69 e5       	ldi	r22, 0x59	; 89
    3c64:	76 e0       	ldi	r23, 0x06	; 6
    3c66:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c6a:	e8 81       	ld	r30, Y
    3c6c:	f9 81       	ldd	r31, Y+1	; 0x01
    3c6e:	02 80       	ldd	r0, Z+2	; 0x02
    3c70:	f3 81       	ldd	r31, Z+3	; 0x03
    3c72:	e0 2d       	mov	r30, r0
    3c74:	60 e2       	ldi	r22, 0x20	; 32
    3c76:	ce 01       	movw	r24, r28
    3c78:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c7a:	c6 2d       	mov	r28, r6
    3c7c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3c7e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3c80:	80 ee       	ldi	r24, 0xE0	; 224
    3c82:	86 0f       	add	r24, r22
    3c84:	8f 35       	cpi	r24, 0x5F	; 95
    3c86:	48 f4       	brcc	.+18     	; 0x3c9a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3c88:	d7 01       	movw	r26, r14
    3c8a:	ed 91       	ld	r30, X+
    3c8c:	fc 91       	ld	r31, X
    3c8e:	02 80       	ldd	r0, Z+2	; 0x02
    3c90:	f3 81       	ldd	r31, Z+3	; 0x03
    3c92:	e0 2d       	mov	r30, r0
    3c94:	c7 01       	movw	r24, r14
    3c96:	19 95       	eicall
    3c98:	09 c0       	rjmp	.+18     	; 0x3cac <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3c9a:	d7 01       	movw	r26, r14
    3c9c:	ed 91       	ld	r30, X+
    3c9e:	fc 91       	ld	r31, X
    3ca0:	02 80       	ldd	r0, Z+2	; 0x02
    3ca2:	f3 81       	ldd	r31, Z+3	; 0x03
    3ca4:	e0 2d       	mov	r30, r0
    3ca6:	6e e2       	ldi	r22, 0x2E	; 46
    3ca8:	c7 01       	movw	r24, r14
    3caa:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3cac:	cc 16       	cp	r12, r28
    3cae:	dd 06       	cpc	r13, r29
    3cb0:	31 f7       	brne	.-52     	; 0x3c7e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3cb2:	b4 e1       	ldi	r27, 0x14	; 20
    3cb4:	ab 0e       	add	r10, r27
    3cb6:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3cb8:	66 e0       	ldi	r22, 0x06	; 6
    3cba:	c7 01       	movw	r24, r14
    3cbc:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    3cc0:	84 e1       	ldi	r24, 0x14	; 20
    3cc2:	c8 0e       	add	r12, r24
    3cc4:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3cc6:	a8 14       	cp	r10, r8
    3cc8:	b9 04       	cpc	r11, r9
    3cca:	08 f4       	brcc	.+2      	; 0x3cce <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3ccc:	88 cf       	rjmp	.-240    	; 0x3bde <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3cce:	62 e0       	ldi	r22, 0x02	; 2
    3cd0:	c7 01       	movw	r24, r14
    3cd2:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
}
    3cd6:	03 c0       	rjmp	.+6      	; 0x3cde <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3cd8:	c6 2d       	mov	r28, r6
    3cda:	d5 2d       	mov	r29, r5
    3cdc:	9c cf       	rjmp	.-200    	; 0x3c16 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3cde:	df 91       	pop	r29
    3ce0:	cf 91       	pop	r28
    3ce2:	1f 91       	pop	r17
    3ce4:	0f 91       	pop	r16
    3ce6:	ff 90       	pop	r15
    3ce8:	ef 90       	pop	r14
    3cea:	df 90       	pop	r13
    3cec:	cf 90       	pop	r12
    3cee:	bf 90       	pop	r11
    3cf0:	af 90       	pop	r10
    3cf2:	9f 90       	pop	r9
    3cf4:	8f 90       	pop	r8
    3cf6:	7f 90       	pop	r7
    3cf8:	6f 90       	pop	r6
    3cfa:	5f 90       	pop	r5
    3cfc:	08 95       	ret

00003cfe <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3cfe:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    3d02:	08 95       	ret

00003d04 <_Znaj>:
    3d04:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <pvPortMalloc>
    3d08:	08 95       	ret

00003d0a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3d0a:	08 95       	ret

00003d0c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3d0c:	cf 93       	push	r28
    3d0e:	df 93       	push	r29
    3d10:	fc 01       	movw	r30, r24
    3d12:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3d14:	40 3a       	cpi	r20, 0xA0	; 160
    3d16:	68 e0       	ldi	r22, 0x08	; 8
    3d18:	56 07       	cpc	r21, r22
    3d1a:	49 f4       	brne	.+18     	; 0x3d2e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3d1c:	80 e4       	ldi	r24, 0x40	; 64
    3d1e:	96 e0       	ldi	r25, 0x06	; 6
    3d20:	82 83       	std	Z+2, r24	; 0x02
    3d22:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d24:	82 e0       	ldi	r24, 0x02	; 2
    3d26:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d28:	83 e0       	ldi	r24, 0x03	; 3
    3d2a:	85 83       	std	Z+5, r24	; 0x05
    3d2c:	32 c0       	rjmp	.+100    	; 0x3d92 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3d2e:	40 3b       	cpi	r20, 0xB0	; 176
    3d30:	78 e0       	ldi	r23, 0x08	; 8
    3d32:	57 07       	cpc	r21, r23
    3d34:	49 f4       	brne	.+18     	; 0x3d48 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3d36:	80 e4       	ldi	r24, 0x40	; 64
    3d38:	96 e0       	ldi	r25, 0x06	; 6
    3d3a:	82 83       	std	Z+2, r24	; 0x02
    3d3c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d3e:	86 e0       	ldi	r24, 0x06	; 6
    3d40:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d42:	87 e0       	ldi	r24, 0x07	; 7
    3d44:	85 83       	std	Z+5, r24	; 0x05
    3d46:	25 c0       	rjmp	.+74     	; 0x3d92 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3d48:	40 3a       	cpi	r20, 0xA0	; 160
    3d4a:	89 e0       	ldi	r24, 0x09	; 9
    3d4c:	58 07       	cpc	r21, r24
    3d4e:	49 f4       	brne	.+18     	; 0x3d62 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3d50:	80 e6       	ldi	r24, 0x60	; 96
    3d52:	96 e0       	ldi	r25, 0x06	; 6
    3d54:	82 83       	std	Z+2, r24	; 0x02
    3d56:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d58:	82 e0       	ldi	r24, 0x02	; 2
    3d5a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d5c:	83 e0       	ldi	r24, 0x03	; 3
    3d5e:	85 83       	std	Z+5, r24	; 0x05
    3d60:	18 c0       	rjmp	.+48     	; 0x3d92 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3d62:	40 3b       	cpi	r20, 0xB0	; 176
    3d64:	69 e0       	ldi	r22, 0x09	; 9
    3d66:	56 07       	cpc	r21, r22
    3d68:	49 f4       	brne	.+18     	; 0x3d7c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3d6a:	80 e6       	ldi	r24, 0x60	; 96
    3d6c:	96 e0       	ldi	r25, 0x06	; 6
    3d6e:	82 83       	std	Z+2, r24	; 0x02
    3d70:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d72:	86 e0       	ldi	r24, 0x06	; 6
    3d74:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d76:	87 e0       	ldi	r24, 0x07	; 7
    3d78:	85 83       	std	Z+5, r24	; 0x05
    3d7a:	0b c0       	rjmp	.+22     	; 0x3d92 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3d7c:	40 3a       	cpi	r20, 0xA0	; 160
    3d7e:	5a 40       	sbci	r21, 0x0A	; 10
    3d80:	41 f4       	brne	.+16     	; 0x3d92 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3d82:	80 e8       	ldi	r24, 0x80	; 128
    3d84:	96 e0       	ldi	r25, 0x06	; 6
    3d86:	82 83       	std	Z+2, r24	; 0x02
    3d88:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d8a:	82 e0       	ldi	r24, 0x02	; 2
    3d8c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d8e:	83 e0       	ldi	r24, 0x03	; 3
    3d90:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3d92:	a6 83       	std	Z+6, r26	; 0x06
    3d94:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3d96:	cd 01       	movw	r24, r26
    3d98:	01 96       	adiw	r24, 0x01	; 1
    3d9a:	80 87       	std	Z+8, r24	; 0x08
    3d9c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3d9e:	03 96       	adiw	r24, 0x03	; 3
    3da0:	82 87       	std	Z+10, r24	; 0x0a
    3da2:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3da4:	25 81       	ldd	r18, Z+5	; 0x05
    3da6:	c2 81       	ldd	r28, Z+2	; 0x02
    3da8:	d3 81       	ldd	r29, Z+3	; 0x03
    3daa:	4c 81       	ldd	r20, Y+4	; 0x04
    3dac:	81 e0       	ldi	r24, 0x01	; 1
    3dae:	90 e0       	ldi	r25, 0x00	; 0
    3db0:	bc 01       	movw	r22, r24
    3db2:	02 c0       	rjmp	.+4      	; 0x3db8 <_ZN7base232C1EjP12USART_struct+0xac>
    3db4:	66 0f       	add	r22, r22
    3db6:	77 1f       	adc	r23, r23
    3db8:	2a 95       	dec	r18
    3dba:	e2 f7       	brpl	.-8      	; 0x3db4 <_ZN7base232C1EjP12USART_struct+0xa8>
    3dbc:	9b 01       	movw	r18, r22
    3dbe:	24 2b       	or	r18, r20
    3dc0:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3dc2:	25 81       	ldd	r18, Z+5	; 0x05
    3dc4:	c2 81       	ldd	r28, Z+2	; 0x02
    3dc6:	d3 81       	ldd	r29, Z+3	; 0x03
    3dc8:	48 81       	ld	r20, Y
    3dca:	bc 01       	movw	r22, r24
    3dcc:	02 c0       	rjmp	.+4      	; 0x3dd2 <_ZN7base232C1EjP12USART_struct+0xc6>
    3dce:	66 0f       	add	r22, r22
    3dd0:	77 1f       	adc	r23, r23
    3dd2:	2a 95       	dec	r18
    3dd4:	e2 f7       	brpl	.-8      	; 0x3dce <_ZN7base232C1EjP12USART_struct+0xc2>
    3dd6:	9b 01       	movw	r18, r22
    3dd8:	24 2b       	or	r18, r20
    3dda:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3ddc:	34 81       	ldd	r19, Z+4	; 0x04
    3dde:	c2 81       	ldd	r28, Z+2	; 0x02
    3de0:	d3 81       	ldd	r29, Z+3	; 0x03
    3de2:	28 81       	ld	r18, Y
    3de4:	02 c0       	rjmp	.+4      	; 0x3dea <_ZN7base232C1EjP12USART_struct+0xde>
    3de6:	88 0f       	add	r24, r24
    3de8:	99 1f       	adc	r25, r25
    3dea:	3a 95       	dec	r19
    3dec:	e2 f7       	brpl	.-8      	; 0x3de6 <_ZN7base232C1EjP12USART_struct+0xda>
    3dee:	80 95       	com	r24
    3df0:	90 95       	com	r25
    3df2:	82 23       	and	r24, r18
    3df4:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3df6:	80 e1       	ldi	r24, 0x10	; 16
    3df8:	13 96       	adiw	r26, 0x03	; 3
    3dfa:	8c 93       	st	X, r24
    3dfc:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3dfe:	83 e0       	ldi	r24, 0x03	; 3
    3e00:	15 96       	adiw	r26, 0x05	; 5
    3e02:	8c 93       	st	X, r24
    3e04:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3e06:	80 ef       	ldi	r24, 0xF0	; 240
    3e08:	17 96       	adiw	r26, 0x07	; 7
    3e0a:	8c 93       	st	X, r24
    3e0c:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3e0e:	81 e2       	ldi	r24, 0x21	; 33
    3e10:	16 96       	adiw	r26, 0x06	; 6
    3e12:	8c 93       	st	X, r24
    3e14:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3e16:	88 e1       	ldi	r24, 0x18	; 24
    3e18:	14 96       	adiw	r26, 0x04	; 4
    3e1a:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3e1c:	80 e8       	ldi	r24, 0x80	; 128
    3e1e:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3e20:	80 e4       	ldi	r24, 0x40	; 64
    3e22:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3e24:	80 e2       	ldi	r24, 0x20	; 32
    3e26:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3e28:	06 80       	ldd	r0, Z+6	; 0x06
    3e2a:	f7 81       	ldd	r31, Z+7	; 0x07
    3e2c:	e0 2d       	mov	r30, r0
    3e2e:	80 81       	ld	r24, Z
    3e30:	80 81       	ld	r24, Z
}
    3e32:	df 91       	pop	r29
    3e34:	cf 91       	pop	r28
    3e36:	08 95       	ret

00003e38 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3e38:	81 e0       	ldi	r24, 0x01	; 1
    3e3a:	08 95       	ret

00003e3c <_ZN8emstream7getcharEv>:
    3e3c:	80 e0       	ldi	r24, 0x00	; 0
    3e3e:	90 e0       	ldi	r25, 0x00	; 0
    3e40:	08 95       	ret

00003e42 <_ZN8emstream14check_for_charEv>:
    3e42:	80 e0       	ldi	r24, 0x00	; 0
    3e44:	08 95       	ret

00003e46 <_ZN8emstream12transmit_nowEv>:
    3e46:	08 95       	ret

00003e48 <_ZN8emstream12clear_screenEv>:
    3e48:	08 95       	ret

00003e4a <_ZN8emstreamC1Ev>:
    3e4a:	fc 01       	movw	r30, r24
    3e4c:	8e e8       	ldi	r24, 0x8E	; 142
    3e4e:	91 e2       	ldi	r25, 0x21	; 33
    3e50:	80 83       	st	Z, r24
    3e52:	91 83       	std	Z+1, r25	; 0x01
    3e54:	8a e0       	ldi	r24, 0x0A	; 10
    3e56:	82 83       	std	Z+2, r24	; 0x02
    3e58:	13 82       	std	Z+3, r1	; 0x03
    3e5a:	83 e0       	ldi	r24, 0x03	; 3
    3e5c:	85 83       	std	Z+5, r24	; 0x05
    3e5e:	14 82       	std	Z+4, r1	; 0x04
    3e60:	16 82       	std	Z+6, r1	; 0x06
    3e62:	17 82       	std	Z+7, r1	; 0x07
    3e64:	08 95       	ret

00003e66 <_ZN8emstream4putsEPKc>:
    3e66:	0f 93       	push	r16
    3e68:	1f 93       	push	r17
    3e6a:	cf 93       	push	r28
    3e6c:	df 93       	push	r29
    3e6e:	8c 01       	movw	r16, r24
    3e70:	fb 01       	movw	r30, r22
    3e72:	dc 01       	movw	r26, r24
    3e74:	14 96       	adiw	r26, 0x04	; 4
    3e76:	8c 91       	ld	r24, X
    3e78:	81 11       	cpse	r24, r1
    3e7a:	04 c0       	rjmp	.+8      	; 0x3e84 <_ZN8emstream4putsEPKc+0x1e>
    3e7c:	60 81       	ld	r22, Z
    3e7e:	61 11       	cpse	r22, r1
    3e80:	17 c0       	rjmp	.+46     	; 0x3eb0 <_ZN8emstream4putsEPKc+0x4a>
    3e82:	23 c0       	rjmp	.+70     	; 0x3eca <_ZN8emstream4putsEPKc+0x64>
    3e84:	d8 01       	movw	r26, r16
    3e86:	14 96       	adiw	r26, 0x04	; 4
    3e88:	1c 92       	st	X, r1
    3e8a:	eb 01       	movw	r28, r22
    3e8c:	21 96       	adiw	r28, 0x01	; 1
    3e8e:	64 91       	lpm	r22, Z
    3e90:	66 23       	and	r22, r22
    3e92:	d9 f0       	breq	.+54     	; 0x3eca <_ZN8emstream4putsEPKc+0x64>
    3e94:	d8 01       	movw	r26, r16
    3e96:	ed 91       	ld	r30, X+
    3e98:	fc 91       	ld	r31, X
    3e9a:	02 80       	ldd	r0, Z+2	; 0x02
    3e9c:	f3 81       	ldd	r31, Z+3	; 0x03
    3e9e:	e0 2d       	mov	r30, r0
    3ea0:	c8 01       	movw	r24, r16
    3ea2:	19 95       	eicall
    3ea4:	fe 01       	movw	r30, r28
    3ea6:	64 91       	lpm	r22, Z
    3ea8:	21 96       	adiw	r28, 0x01	; 1
    3eaa:	61 11       	cpse	r22, r1
    3eac:	f3 cf       	rjmp	.-26     	; 0x3e94 <_ZN8emstream4putsEPKc+0x2e>
    3eae:	0d c0       	rjmp	.+26     	; 0x3eca <_ZN8emstream4putsEPKc+0x64>
    3eb0:	ef 01       	movw	r28, r30
    3eb2:	21 96       	adiw	r28, 0x01	; 1
    3eb4:	d8 01       	movw	r26, r16
    3eb6:	ed 91       	ld	r30, X+
    3eb8:	fc 91       	ld	r31, X
    3eba:	02 80       	ldd	r0, Z+2	; 0x02
    3ebc:	f3 81       	ldd	r31, Z+3	; 0x03
    3ebe:	e0 2d       	mov	r30, r0
    3ec0:	c8 01       	movw	r24, r16
    3ec2:	19 95       	eicall
    3ec4:	69 91       	ld	r22, Y+
    3ec6:	61 11       	cpse	r22, r1
    3ec8:	f5 cf       	rjmp	.-22     	; 0x3eb4 <_ZN8emstream4putsEPKc+0x4e>
    3eca:	df 91       	pop	r29
    3ecc:	cf 91       	pop	r28
    3ece:	1f 91       	pop	r17
    3ed0:	0f 91       	pop	r16
    3ed2:	08 95       	ret

00003ed4 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3ed4:	cf 93       	push	r28
    3ed6:	df 93       	push	r29
    3ed8:	ec 01       	movw	r28, r24
	switch (new_manip)
    3eda:	86 2f       	mov	r24, r22
    3edc:	90 e0       	ldi	r25, 0x00	; 0
    3ede:	8b 30       	cpi	r24, 0x0B	; 11
    3ee0:	91 05       	cpc	r25, r1
    3ee2:	d8 f5       	brcc	.+118    	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	88 27       	eor	r24, r24
    3ee8:	e2 50       	subi	r30, 0x02	; 2
    3eea:	ff 4f       	sbci	r31, 0xFF	; 255
    3eec:	8f 4f       	sbci	r24, 0xFF	; 255
    3eee:	0c 94 da 26 	jmp	0x4db4	; 0x4db4 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3ef2:	82 e0       	ldi	r24, 0x02	; 2
    3ef4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ef6:	31 c0       	rjmp	.+98     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3ef8:	88 e0       	ldi	r24, 0x08	; 8
    3efa:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3efc:	2e c0       	rjmp	.+92     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3efe:	8a e0       	ldi	r24, 0x0A	; 10
    3f00:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f02:	2b c0       	rjmp	.+86     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3f04:	80 e1       	ldi	r24, 0x10	; 16
    3f06:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f08:	28 c0       	rjmp	.+80     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3f0a:	81 e0       	ldi	r24, 0x01	; 1
    3f0c:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3f0e:	25 c0       	rjmp	.+74     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3f10:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3f12:	23 c0       	rjmp	.+70     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3f14:	e8 81       	ld	r30, Y
    3f16:	f9 81       	ldd	r31, Y+1	; 0x01
    3f18:	02 80       	ldd	r0, Z+2	; 0x02
    3f1a:	f3 81       	ldd	r31, Z+3	; 0x03
    3f1c:	e0 2d       	mov	r30, r0
    3f1e:	6d e0       	ldi	r22, 0x0D	; 13
    3f20:	ce 01       	movw	r24, r28
    3f22:	19 95       	eicall
    3f24:	e8 81       	ld	r30, Y
    3f26:	f9 81       	ldd	r31, Y+1	; 0x01
    3f28:	02 80       	ldd	r0, Z+2	; 0x02
    3f2a:	f3 81       	ldd	r31, Z+3	; 0x03
    3f2c:	e0 2d       	mov	r30, r0
    3f2e:	6a e0       	ldi	r22, 0x0A	; 10
    3f30:	ce 01       	movw	r24, r28
    3f32:	19 95       	eicall
			break;
    3f34:	12 c0       	rjmp	.+36     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3f36:	e8 81       	ld	r30, Y
    3f38:	f9 81       	ldd	r31, Y+1	; 0x01
    3f3a:	02 84       	ldd	r0, Z+10	; 0x0a
    3f3c:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f3e:	e0 2d       	mov	r30, r0
    3f40:	ce 01       	movw	r24, r28
    3f42:	19 95       	eicall
			break;
    3f44:	0a c0       	rjmp	.+20     	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3f46:	e8 81       	ld	r30, Y
    3f48:	f9 81       	ldd	r31, Y+1	; 0x01
    3f4a:	00 84       	ldd	r0, Z+8	; 0x08
    3f4c:	f1 85       	ldd	r31, Z+9	; 0x09
    3f4e:	e0 2d       	mov	r30, r0
    3f50:	ce 01       	movw	r24, r28
    3f52:	19 95       	eicall
			break;
    3f54:	02 c0       	rjmp	.+4      	; 0x3f5a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3f56:	81 e0       	ldi	r24, 0x01	; 1
    3f58:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3f5a:	ce 01       	movw	r24, r28
    3f5c:	df 91       	pop	r29
    3f5e:	cf 91       	pop	r28
    3f60:	08 95       	ret

00003f62 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3f62:	ff 92       	push	r15
    3f64:	0f 93       	push	r16
    3f66:	1f 93       	push	r17
    3f68:	cf 93       	push	r28
    3f6a:	df 93       	push	r29
    3f6c:	cd b7       	in	r28, 0x3d	; 61
    3f6e:	de b7       	in	r29, 0x3e	; 62
    3f70:	61 97       	sbiw	r28, 0x11	; 17
    3f72:	cd bf       	out	0x3d, r28	; 61
    3f74:	de bf       	out	0x3e, r29	; 62
    3f76:	8c 01       	movw	r16, r24
    3f78:	f6 2e       	mov	r15, r22
    3f7a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3f7c:	f8 01       	movw	r30, r16
    3f7e:	42 81       	ldd	r20, Z+2	; 0x02
    3f80:	40 31       	cpi	r20, 0x10	; 16
    3f82:	21 f0       	breq	.+8      	; 0x3f8c <_ZN8emstreamlsEj+0x2a>
    3f84:	48 30       	cpi	r20, 0x08	; 8
    3f86:	11 f0       	breq	.+4      	; 0x3f8c <_ZN8emstreamlsEj+0x2a>
    3f88:	42 30       	cpi	r20, 0x02	; 2
    3f8a:	41 f4       	brne	.+16     	; 0x3f9c <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3f8c:	69 2f       	mov	r22, r25
    3f8e:	c8 01       	movw	r24, r16
    3f90:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    3f94:	6f 2d       	mov	r22, r15
    3f96:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    3f9a:	0d c0       	rjmp	.+26     	; 0x3fb6 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3f9c:	50 e0       	ldi	r21, 0x00	; 0
    3f9e:	be 01       	movw	r22, r28
    3fa0:	6f 5f       	subi	r22, 0xFF	; 255
    3fa2:	7f 4f       	sbci	r23, 0xFF	; 255
    3fa4:	8f 2d       	mov	r24, r15
    3fa6:	0e 94 49 27 	call	0x4e92	; 0x4e92 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3faa:	be 01       	movw	r22, r28
    3fac:	6f 5f       	subi	r22, 0xFF	; 255
    3fae:	7f 4f       	sbci	r23, 0xFF	; 255
    3fb0:	c8 01       	movw	r24, r16
    3fb2:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3fb6:	c8 01       	movw	r24, r16
    3fb8:	61 96       	adiw	r28, 0x11	; 17
    3fba:	cd bf       	out	0x3d, r28	; 61
    3fbc:	de bf       	out	0x3e, r29	; 62
    3fbe:	df 91       	pop	r29
    3fc0:	cf 91       	pop	r28
    3fc2:	1f 91       	pop	r17
    3fc4:	0f 91       	pop	r16
    3fc6:	ff 90       	pop	r15
    3fc8:	08 95       	ret

00003fca <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3fca:	df 92       	push	r13
    3fcc:	ef 92       	push	r14
    3fce:	ff 92       	push	r15
    3fd0:	0f 93       	push	r16
    3fd2:	1f 93       	push	r17
    3fd4:	cf 93       	push	r28
    3fd6:	df 93       	push	r29
    3fd8:	cd b7       	in	r28, 0x3d	; 61
    3fda:	de b7       	in	r29, 0x3e	; 62
    3fdc:	a1 97       	sbiw	r28, 0x21	; 33
    3fde:	cd bf       	out	0x3d, r28	; 61
    3fe0:	de bf       	out	0x3e, r29	; 62
    3fe2:	8c 01       	movw	r16, r24
    3fe4:	d4 2e       	mov	r13, r20
    3fe6:	e5 2e       	mov	r14, r21
    3fe8:	f6 2e       	mov	r15, r22
    3fea:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3fec:	f8 01       	movw	r30, r16
    3fee:	22 81       	ldd	r18, Z+2	; 0x02
    3ff0:	20 31       	cpi	r18, 0x10	; 16
    3ff2:	21 f0       	breq	.+8      	; 0x3ffc <_ZN8emstreamlsEm+0x32>
    3ff4:	28 30       	cpi	r18, 0x08	; 8
    3ff6:	11 f0       	breq	.+4      	; 0x3ffc <_ZN8emstreamlsEm+0x32>
    3ff8:	22 30       	cpi	r18, 0x02	; 2
    3ffa:	71 f4       	brne	.+28     	; 0x4018 <__stack+0x19>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3ffc:	69 2f       	mov	r22, r25
    3ffe:	c8 01       	movw	r24, r16
    4000:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    4004:	6f 2d       	mov	r22, r15
    4006:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    400a:	6e 2d       	mov	r22, r14
    400c:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    4010:	6d 2d       	mov	r22, r13
    4012:	0e 94 27 20 	call	0x404e	; 0x404e <_ZN8emstreamlsEh>
    4016:	0f c0       	rjmp	.+30     	; 0x4036 <__stack+0x37>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    4018:	30 e0       	ldi	r19, 0x00	; 0
    401a:	ae 01       	movw	r20, r28
    401c:	4f 5f       	subi	r20, 0xFF	; 255
    401e:	5f 4f       	sbci	r21, 0xFF	; 255
    4020:	6d 2d       	mov	r22, r13
    4022:	7e 2d       	mov	r23, r14
    4024:	8f 2d       	mov	r24, r15
    4026:	0e 94 1c 27 	call	0x4e38	; 0x4e38 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    402a:	be 01       	movw	r22, r28
    402c:	6f 5f       	subi	r22, 0xFF	; 255
    402e:	7f 4f       	sbci	r23, 0xFF	; 255
    4030:	c8 01       	movw	r24, r16
    4032:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    4036:	c8 01       	movw	r24, r16
    4038:	a1 96       	adiw	r28, 0x21	; 33
    403a:	cd bf       	out	0x3d, r28	; 61
    403c:	de bf       	out	0x3e, r29	; 62
    403e:	df 91       	pop	r29
    4040:	cf 91       	pop	r28
    4042:	1f 91       	pop	r17
    4044:	0f 91       	pop	r16
    4046:	ff 90       	pop	r15
    4048:	ef 90       	pop	r14
    404a:	df 90       	pop	r13
    404c:	08 95       	ret

0000404e <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    404e:	cf 92       	push	r12
    4050:	df 92       	push	r13
    4052:	ef 92       	push	r14
    4054:	ff 92       	push	r15
    4056:	0f 93       	push	r16
    4058:	1f 93       	push	r17
    405a:	cf 93       	push	r28
    405c:	df 93       	push	r29
    405e:	cd b7       	in	r28, 0x3d	; 61
    4060:	de b7       	in	r29, 0x3e	; 62
    4062:	29 97       	sbiw	r28, 0x09	; 9
    4064:	cd bf       	out	0x3d, r28	; 61
    4066:	de bf       	out	0x3e, r29	; 62
    4068:	8c 01       	movw	r16, r24
    406a:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    406c:	dc 01       	movw	r26, r24
    406e:	13 96       	adiw	r26, 0x03	; 3
    4070:	8c 91       	ld	r24, X
    4072:	13 97       	sbiw	r26, 0x03	; 3
    4074:	88 23       	and	r24, r24
    4076:	41 f0       	breq	.+16     	; 0x4088 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    4078:	ed 91       	ld	r30, X+
    407a:	fc 91       	ld	r31, X
    407c:	02 80       	ldd	r0, Z+2	; 0x02
    407e:	f3 81       	ldd	r31, Z+3	; 0x03
    4080:	e0 2d       	mov	r30, r0
    4082:	c8 01       	movw	r24, r16
    4084:	19 95       	eicall
    4086:	56 c0       	rjmp	.+172    	; 0x4134 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    4088:	f8 01       	movw	r30, r16
    408a:	42 81       	ldd	r20, Z+2	; 0x02
    408c:	42 30       	cpi	r20, 0x02	; 2
    408e:	19 f5       	brne	.+70     	; 0x40d6 <_ZN8emstreamlsEh+0x88>
    4090:	68 94       	set
    4092:	cc 24       	eor	r12, r12
    4094:	c3 f8       	bld	r12, 3
    4096:	d1 2c       	mov	r13, r1
    4098:	68 94       	set
    409a:	ff 24       	eor	r15, r15
    409c:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    409e:	8e 2d       	mov	r24, r14
    40a0:	8f 21       	and	r24, r15
    40a2:	51 f0       	breq	.+20     	; 0x40b8 <_ZN8emstreamlsEh+0x6a>
    40a4:	d8 01       	movw	r26, r16
    40a6:	ed 91       	ld	r30, X+
    40a8:	fc 91       	ld	r31, X
    40aa:	02 80       	ldd	r0, Z+2	; 0x02
    40ac:	f3 81       	ldd	r31, Z+3	; 0x03
    40ae:	e0 2d       	mov	r30, r0
    40b0:	61 e3       	ldi	r22, 0x31	; 49
    40b2:	c8 01       	movw	r24, r16
    40b4:	19 95       	eicall
    40b6:	09 c0       	rjmp	.+18     	; 0x40ca <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    40b8:	d8 01       	movw	r26, r16
    40ba:	ed 91       	ld	r30, X+
    40bc:	fc 91       	ld	r31, X
    40be:	02 80       	ldd	r0, Z+2	; 0x02
    40c0:	f3 81       	ldd	r31, Z+3	; 0x03
    40c2:	e0 2d       	mov	r30, r0
    40c4:	60 e3       	ldi	r22, 0x30	; 48
    40c6:	c8 01       	movw	r24, r16
    40c8:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    40ca:	f6 94       	lsr	r15
    40cc:	b1 e0       	ldi	r27, 0x01	; 1
    40ce:	cb 1a       	sub	r12, r27
    40d0:	d1 08       	sbc	r13, r1
    40d2:	29 f7       	brne	.-54     	; 0x409e <_ZN8emstreamlsEh+0x50>
    40d4:	2f c0       	rjmp	.+94     	; 0x4134 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    40d6:	40 31       	cpi	r20, 0x10	; 16
    40d8:	f9 f4       	brne	.+62     	; 0x4118 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    40da:	62 95       	swap	r22
    40dc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    40de:	01 90       	ld	r0, Z+
    40e0:	f0 81       	ld	r31, Z
    40e2:	e0 2d       	mov	r30, r0
    40e4:	02 80       	ldd	r0, Z+2	; 0x02
    40e6:	f3 81       	ldd	r31, Z+3	; 0x03
    40e8:	e0 2d       	mov	r30, r0
    40ea:	6a 30       	cpi	r22, 0x0A	; 10
    40ec:	10 f0       	brcs	.+4      	; 0x40f2 <_ZN8emstreamlsEh+0xa4>
    40ee:	69 5c       	subi	r22, 0xC9	; 201
    40f0:	01 c0       	rjmp	.+2      	; 0x40f4 <_ZN8emstreamlsEh+0xa6>
    40f2:	60 5d       	subi	r22, 0xD0	; 208
    40f4:	c8 01       	movw	r24, r16
    40f6:	19 95       	eicall
		temp_char = num & 0x0F;
    40f8:	6e 2d       	mov	r22, r14
    40fa:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    40fc:	d8 01       	movw	r26, r16
    40fe:	ed 91       	ld	r30, X+
    4100:	fc 91       	ld	r31, X
    4102:	02 80       	ldd	r0, Z+2	; 0x02
    4104:	f3 81       	ldd	r31, Z+3	; 0x03
    4106:	e0 2d       	mov	r30, r0
    4108:	6a 30       	cpi	r22, 0x0A	; 10
    410a:	10 f0       	brcs	.+4      	; 0x4110 <_ZN8emstreamlsEh+0xc2>
    410c:	69 5c       	subi	r22, 0xC9	; 201
    410e:	01 c0       	rjmp	.+2      	; 0x4112 <_ZN8emstreamlsEh+0xc4>
    4110:	60 5d       	subi	r22, 0xD0	; 208
    4112:	c8 01       	movw	r24, r16
    4114:	19 95       	eicall
    4116:	0e c0       	rjmp	.+28     	; 0x4134 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4118:	50 e0       	ldi	r21, 0x00	; 0
    411a:	be 01       	movw	r22, r28
    411c:	6f 5f       	subi	r22, 0xFF	; 255
    411e:	7f 4f       	sbci	r23, 0xFF	; 255
    4120:	8e 2d       	mov	r24, r14
    4122:	90 e0       	ldi	r25, 0x00	; 0
    4124:	0e 94 49 27 	call	0x4e92	; 0x4e92 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    4128:	be 01       	movw	r22, r28
    412a:	6f 5f       	subi	r22, 0xFF	; 255
    412c:	7f 4f       	sbci	r23, 0xFF	; 255
    412e:	c8 01       	movw	r24, r16
    4130:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    4134:	c8 01       	movw	r24, r16
    4136:	29 96       	adiw	r28, 0x09	; 9
    4138:	cd bf       	out	0x3d, r28	; 61
    413a:	de bf       	out	0x3e, r29	; 62
    413c:	df 91       	pop	r29
    413e:	cf 91       	pop	r28
    4140:	1f 91       	pop	r17
    4142:	0f 91       	pop	r16
    4144:	ff 90       	pop	r15
    4146:	ef 90       	pop	r14
    4148:	df 90       	pop	r13
    414a:	cf 90       	pop	r12
    414c:	08 95       	ret

0000414e <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    414e:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4150:	50 96       	adiw	r26, 0x10	; 16
    4152:	ed 91       	ld	r30, X+
    4154:	fc 91       	ld	r31, X
    4156:	51 97       	sbiw	r26, 0x11	; 17
    4158:	80 81       	ld	r24, Z
    415a:	54 96       	adiw	r26, 0x14	; 20
    415c:	4c 91       	ld	r20, X
    415e:	54 97       	sbiw	r26, 0x14	; 20
    4160:	84 23       	and	r24, r20
    4162:	29 f0       	breq	.+10     	; 0x416e <_ZN5rs2327putcharEc+0x20>
    4164:	09 c0       	rjmp	.+18     	; 0x4178 <_ZN5rs2327putcharEc+0x2a>
    4166:	21 50       	subi	r18, 0x01	; 1
    4168:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    416a:	19 f4       	brne	.+6      	; 0x4172 <_ZN5rs2327putcharEc+0x24>
    416c:	12 c0       	rjmp	.+36     	; 0x4192 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    416e:	21 e2       	ldi	r18, 0x21	; 33
    4170:	3e e4       	ldi	r19, 0x4E	; 78
    4172:	90 81       	ld	r25, Z
    4174:	94 23       	and	r25, r20
    4176:	b9 f3       	breq	.-18     	; 0x4166 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4178:	90 81       	ld	r25, Z
    417a:	56 96       	adiw	r26, 0x16	; 22
    417c:	8c 91       	ld	r24, X
    417e:	56 97       	sbiw	r26, 0x16	; 22
    4180:	89 2b       	or	r24, r25
    4182:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    4184:	1e 96       	adiw	r26, 0x0e	; 14
    4186:	ed 91       	ld	r30, X+
    4188:	fc 91       	ld	r31, X
    418a:	1f 97       	sbiw	r26, 0x0f	; 15
    418c:	60 83       	st	Z, r22
	return (true);
    418e:	81 e0       	ldi	r24, 0x01	; 1
    4190:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    4192:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    4194:	08 95       	ret

00004196 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    4196:	cf 93       	push	r28
    4198:	df 93       	push	r29
    419a:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    419c:	c1 8d       	ldd	r28, Z+25	; 0x19
    419e:	d2 8d       	ldd	r29, Z+26	; 0x1a
    41a0:	28 81       	ld	r18, Y
    41a2:	39 81       	ldd	r19, Y+1	; 0x01
    41a4:	a3 8d       	ldd	r26, Z+27	; 0x1b
    41a6:	b4 8d       	ldd	r27, Z+28	; 0x1c
    41a8:	4d 91       	ld	r20, X+
    41aa:	5c 91       	ld	r21, X
    41ac:	24 17       	cp	r18, r20
    41ae:	35 07       	cpc	r19, r21
    41b0:	e9 f3       	breq	.-6      	; 0x41ac <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    41b2:	a7 89       	ldd	r26, Z+23	; 0x17
    41b4:	b0 8d       	ldd	r27, Z+24	; 0x18
    41b6:	0d 90       	ld	r0, X+
    41b8:	bc 91       	ld	r27, X
    41ba:	a0 2d       	mov	r26, r0
    41bc:	a2 0f       	add	r26, r18
    41be:	b3 1f       	adc	r27, r19
    41c0:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    41c2:	2f 5f       	subi	r18, 0xFF	; 255
    41c4:	3f 4f       	sbci	r19, 0xFF	; 255
    41c6:	28 83       	st	Y, r18
    41c8:	39 83       	std	Y+1, r19	; 0x01
    41ca:	24 36       	cpi	r18, 0x64	; 100
    41cc:	31 05       	cpc	r19, r1
    41ce:	28 f0       	brcs	.+10     	; 0x41da <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    41d0:	01 8c       	ldd	r0, Z+25	; 0x19
    41d2:	f2 8d       	ldd	r31, Z+26	; 0x1a
    41d4:	e0 2d       	mov	r30, r0
    41d6:	10 82       	st	Z, r1
    41d8:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    41da:	90 e0       	ldi	r25, 0x00	; 0
    41dc:	df 91       	pop	r29
    41de:	cf 91       	pop	r28
    41e0:	08 95       	ret

000041e2 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    41e2:	cf 93       	push	r28
    41e4:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    41e6:	ec 01       	movw	r28, r24
    41e8:	a9 8d       	ldd	r26, Y+25	; 0x19
    41ea:	ba 8d       	ldd	r27, Y+26	; 0x1a
    41ec:	eb 8d       	ldd	r30, Y+27	; 0x1b
    41ee:	fc 8d       	ldd	r31, Y+28	; 0x1c
    41f0:	81 e0       	ldi	r24, 0x01	; 1
    41f2:	4d 91       	ld	r20, X+
    41f4:	5c 91       	ld	r21, X
    41f6:	20 81       	ld	r18, Z
    41f8:	31 81       	ldd	r19, Z+1	; 0x01
    41fa:	42 17       	cp	r20, r18
    41fc:	53 07       	cpc	r21, r19
    41fe:	09 f4       	brne	.+2      	; 0x4202 <_ZN5rs23214check_for_charEv+0x20>
    4200:	80 e0       	ldi	r24, 0x00	; 0
}
    4202:	df 91       	pop	r29
    4204:	cf 91       	pop	r28
    4206:	08 95       	ret

00004208 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    4208:	dc 01       	movw	r26, r24
    420a:	ed 91       	ld	r30, X+
    420c:	fc 91       	ld	r31, X
    420e:	02 80       	ldd	r0, Z+2	; 0x02
    4210:	f3 81       	ldd	r31, Z+3	; 0x03
    4212:	e0 2d       	mov	r30, r0
    4214:	6c e0       	ldi	r22, 0x0C	; 12
    4216:	19 95       	eicall
    4218:	08 95       	ret

0000421a <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    421a:	ef 92       	push	r14
    421c:	ff 92       	push	r15
    421e:	0f 93       	push	r16
    4220:	1f 93       	push	r17
    4222:	cf 93       	push	r28
    4224:	df 93       	push	r29
    4226:	ec 01       	movw	r28, r24
    4228:	7b 01       	movw	r14, r22
    422a:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    422c:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <_ZN8emstreamC1Ev>
    4230:	a8 01       	movw	r20, r16
    4232:	b7 01       	movw	r22, r14
    4234:	ce 01       	movw	r24, r28
    4236:	08 96       	adiw	r24, 0x08	; 8
    4238:	0e 94 86 1e 	call	0x3d0c	; 0x3d0c <_ZN7base232C1EjP12USART_struct>
    423c:	8e e9       	ldi	r24, 0x9E	; 158
    423e:	91 e2       	ldi	r25, 0x21	; 33
    4240:	88 83       	st	Y, r24
    4242:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    4244:	00 3a       	cpi	r16, 0xA0	; 160
    4246:	88 e0       	ldi	r24, 0x08	; 8
    4248:	18 07       	cpc	r17, r24
    424a:	69 f4       	brne	.+26     	; 0x4266 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    424c:	88 ea       	ldi	r24, 0xA8	; 168
    424e:	92 e3       	ldi	r25, 0x32	; 50
    4250:	8f 8b       	std	Y+23, r24	; 0x17
    4252:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    4254:	8e e9       	ldi	r24, 0x9E	; 158
    4256:	92 e3       	ldi	r25, 0x32	; 50
    4258:	89 8f       	std	Y+25, r24	; 0x19
    425a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    425c:	84 e9       	ldi	r24, 0x94	; 148
    425e:	92 e3       	ldi	r25, 0x32	; 50
    4260:	8b 8f       	std	Y+27, r24	; 0x1b
    4262:	9c 8f       	std	Y+28, r25	; 0x1c
    4264:	42 c0       	rjmp	.+132    	; 0x42ea <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4266:	00 3b       	cpi	r16, 0xB0	; 176
    4268:	e8 e0       	ldi	r30, 0x08	; 8
    426a:	1e 07       	cpc	r17, r30
    426c:	69 f4       	brne	.+26     	; 0x4288 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    426e:	86 ea       	ldi	r24, 0xA6	; 166
    4270:	92 e3       	ldi	r25, 0x32	; 50
    4272:	8f 8b       	std	Y+23, r24	; 0x17
    4274:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4276:	8c e9       	ldi	r24, 0x9C	; 156
    4278:	92 e3       	ldi	r25, 0x32	; 50
    427a:	89 8f       	std	Y+25, r24	; 0x19
    427c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    427e:	82 e9       	ldi	r24, 0x92	; 146
    4280:	92 e3       	ldi	r25, 0x32	; 50
    4282:	8b 8f       	std	Y+27, r24	; 0x1b
    4284:	9c 8f       	std	Y+28, r25	; 0x1c
    4286:	31 c0       	rjmp	.+98     	; 0x42ea <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    4288:	00 3a       	cpi	r16, 0xA0	; 160
    428a:	f9 e0       	ldi	r31, 0x09	; 9
    428c:	1f 07       	cpc	r17, r31
    428e:	69 f4       	brne	.+26     	; 0x42aa <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    4290:	84 ea       	ldi	r24, 0xA4	; 164
    4292:	92 e3       	ldi	r25, 0x32	; 50
    4294:	8f 8b       	std	Y+23, r24	; 0x17
    4296:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    4298:	8a e9       	ldi	r24, 0x9A	; 154
    429a:	92 e3       	ldi	r25, 0x32	; 50
    429c:	89 8f       	std	Y+25, r24	; 0x19
    429e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    42a0:	80 e9       	ldi	r24, 0x90	; 144
    42a2:	92 e3       	ldi	r25, 0x32	; 50
    42a4:	8b 8f       	std	Y+27, r24	; 0x1b
    42a6:	9c 8f       	std	Y+28, r25	; 0x1c
    42a8:	20 c0       	rjmp	.+64     	; 0x42ea <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    42aa:	00 3b       	cpi	r16, 0xB0	; 176
    42ac:	89 e0       	ldi	r24, 0x09	; 9
    42ae:	18 07       	cpc	r17, r24
    42b0:	69 f4       	brne	.+26     	; 0x42cc <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    42b2:	82 ea       	ldi	r24, 0xA2	; 162
    42b4:	92 e3       	ldi	r25, 0x32	; 50
    42b6:	8f 8b       	std	Y+23, r24	; 0x17
    42b8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    42ba:	88 e9       	ldi	r24, 0x98	; 152
    42bc:	92 e3       	ldi	r25, 0x32	; 50
    42be:	89 8f       	std	Y+25, r24	; 0x19
    42c0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    42c2:	8e e8       	ldi	r24, 0x8E	; 142
    42c4:	92 e3       	ldi	r25, 0x32	; 50
    42c6:	8b 8f       	std	Y+27, r24	; 0x1b
    42c8:	9c 8f       	std	Y+28, r25	; 0x1c
    42ca:	0f c0       	rjmp	.+30     	; 0x42ea <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    42cc:	00 3a       	cpi	r16, 0xA0	; 160
    42ce:	1a 40       	sbci	r17, 0x0A	; 10
    42d0:	61 f4       	brne	.+24     	; 0x42ea <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    42d2:	80 ea       	ldi	r24, 0xA0	; 160
    42d4:	92 e3       	ldi	r25, 0x32	; 50
    42d6:	8f 8b       	std	Y+23, r24	; 0x17
    42d8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    42da:	86 e9       	ldi	r24, 0x96	; 150
    42dc:	92 e3       	ldi	r25, 0x32	; 50
    42de:	89 8f       	std	Y+25, r24	; 0x19
    42e0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    42e2:	8c e8       	ldi	r24, 0x8C	; 140
    42e4:	92 e3       	ldi	r25, 0x32	; 50
    42e6:	8b 8f       	std	Y+27, r24	; 0x1b
    42e8:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    42ea:	0f 89       	ldd	r16, Y+23	; 0x17
    42ec:	18 8d       	ldd	r17, Y+24	; 0x18
    42ee:	84 e6       	ldi	r24, 0x64	; 100
    42f0:	90 e0       	ldi	r25, 0x00	; 0
    42f2:	0e 94 82 1e 	call	0x3d04	; 0x3d04 <_Znaj>
    42f6:	f8 01       	movw	r30, r16
    42f8:	80 83       	st	Z, r24
    42fa:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    42fc:	e9 8d       	ldd	r30, Y+25	; 0x19
    42fe:	fa 8d       	ldd	r31, Y+26	; 0x1a
    4300:	10 82       	st	Z, r1
    4302:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    4304:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4306:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4308:	10 82       	st	Z, r1
    430a:	11 82       	std	Z+1, r1	; 0x01
}
    430c:	df 91       	pop	r29
    430e:	cf 91       	pop	r28
    4310:	1f 91       	pop	r17
    4312:	0f 91       	pop	r16
    4314:	ff 90       	pop	r15
    4316:	ef 90       	pop	r14
    4318:	08 95       	ret

0000431a <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    431a:	1f 92       	push	r1
    431c:	0f 92       	push	r0
    431e:	0f b6       	in	r0, 0x3f	; 63
    4320:	0f 92       	push	r0
    4322:	11 24       	eor	r1, r1
    4324:	08 b6       	in	r0, 0x38	; 56
    4326:	0f 92       	push	r0
    4328:	18 be       	out	0x38, r1	; 56
    432a:	0b b6       	in	r0, 0x3b	; 59
    432c:	0f 92       	push	r0
    432e:	1b be       	out	0x3b, r1	; 59
    4330:	2f 93       	push	r18
    4332:	3f 93       	push	r19
    4334:	8f 93       	push	r24
    4336:	9f 93       	push	r25
    4338:	ef 93       	push	r30
    433a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    433c:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    4340:	e0 91 a8 32 	lds	r30, 0x32A8	; 0x8032a8 <rcvC0_buffer>
    4344:	f0 91 a9 32 	lds	r31, 0x32A9	; 0x8032a9 <rcvC0_buffer+0x1>
    4348:	80 91 94 32 	lds	r24, 0x3294	; 0x803294 <rcvC0_write_index>
    434c:	90 91 95 32 	lds	r25, 0x3295	; 0x803295 <rcvC0_write_index+0x1>
    4350:	e8 0f       	add	r30, r24
    4352:	f9 1f       	adc	r31, r25
    4354:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    4356:	80 91 94 32 	lds	r24, 0x3294	; 0x803294 <rcvC0_write_index>
    435a:	90 91 95 32 	lds	r25, 0x3295	; 0x803295 <rcvC0_write_index+0x1>
    435e:	01 96       	adiw	r24, 0x01	; 1
    4360:	84 36       	cpi	r24, 0x64	; 100
    4362:	91 05       	cpc	r25, r1
    4364:	60 f4       	brcc	.+24     	; 0x437e <__vector_25+0x64>
    4366:	80 93 94 32 	sts	0x3294, r24	; 0x803294 <rcvC0_write_index>
    436a:	90 93 95 32 	sts	0x3295, r25	; 0x803295 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    436e:	20 91 9e 32 	lds	r18, 0x329E	; 0x80329e <rcvC0_read_index>
    4372:	30 91 9f 32 	lds	r19, 0x329F	; 0x80329f <rcvC0_read_index+0x1>
    4376:	82 17       	cp	r24, r18
    4378:	93 07       	cpc	r25, r19
    437a:	f1 f4       	brne	.+60     	; 0x43b8 <__vector_25+0x9e>
    437c:	0c c0       	rjmp	.+24     	; 0x4396 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    437e:	10 92 94 32 	sts	0x3294, r1	; 0x803294 <rcvC0_write_index>
    4382:	10 92 95 32 	sts	0x3295, r1	; 0x803295 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4386:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <rcvC0_read_index>
    438a:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <rcvC0_read_index+0x1>
    438e:	18 16       	cp	r1, r24
    4390:	19 06       	cpc	r1, r25
    4392:	91 f4       	brne	.+36     	; 0x43b8 <__vector_25+0x9e>
    4394:	0e c0       	rjmp	.+28     	; 0x43b2 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4396:	01 96       	adiw	r24, 0x01	; 1
    4398:	84 36       	cpi	r24, 0x64	; 100
    439a:	91 05       	cpc	r25, r1
    439c:	28 f4       	brcc	.+10     	; 0x43a8 <__vector_25+0x8e>
    439e:	80 93 9e 32 	sts	0x329E, r24	; 0x80329e <rcvC0_read_index>
    43a2:	90 93 9f 32 	sts	0x329F, r25	; 0x80329f <rcvC0_read_index+0x1>
    43a6:	08 c0       	rjmp	.+16     	; 0x43b8 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    43a8:	10 92 9e 32 	sts	0x329E, r1	; 0x80329e <rcvC0_read_index>
    43ac:	10 92 9f 32 	sts	0x329F, r1	; 0x80329f <rcvC0_read_index+0x1>
}
    43b0:	03 c0       	rjmp	.+6      	; 0x43b8 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    43b2:	81 e0       	ldi	r24, 0x01	; 1
    43b4:	90 e0       	ldi	r25, 0x00	; 0
    43b6:	f3 cf       	rjmp	.-26     	; 0x439e <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    43b8:	ff 91       	pop	r31
    43ba:	ef 91       	pop	r30
    43bc:	9f 91       	pop	r25
    43be:	8f 91       	pop	r24
    43c0:	3f 91       	pop	r19
    43c2:	2f 91       	pop	r18
    43c4:	0f 90       	pop	r0
    43c6:	0b be       	out	0x3b, r0	; 59
    43c8:	0f 90       	pop	r0
    43ca:	08 be       	out	0x38, r0	; 56
    43cc:	0f 90       	pop	r0
    43ce:	0f be       	out	0x3f, r0	; 63
    43d0:	0f 90       	pop	r0
    43d2:	1f 90       	pop	r1
    43d4:	18 95       	reti

000043d6 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    43d6:	1f 92       	push	r1
    43d8:	0f 92       	push	r0
    43da:	0f b6       	in	r0, 0x3f	; 63
    43dc:	0f 92       	push	r0
    43de:	11 24       	eor	r1, r1
    43e0:	08 b6       	in	r0, 0x38	; 56
    43e2:	0f 92       	push	r0
    43e4:	18 be       	out	0x38, r1	; 56
    43e6:	0b b6       	in	r0, 0x3b	; 59
    43e8:	0f 92       	push	r0
    43ea:	1b be       	out	0x3b, r1	; 59
    43ec:	2f 93       	push	r18
    43ee:	3f 93       	push	r19
    43f0:	8f 93       	push	r24
    43f2:	9f 93       	push	r25
    43f4:	ef 93       	push	r30
    43f6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    43f8:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    43fc:	e0 91 a6 32 	lds	r30, 0x32A6	; 0x8032a6 <rcvC1_buffer>
    4400:	f0 91 a7 32 	lds	r31, 0x32A7	; 0x8032a7 <rcvC1_buffer+0x1>
    4404:	80 91 92 32 	lds	r24, 0x3292	; 0x803292 <rcvC1_write_index>
    4408:	90 91 93 32 	lds	r25, 0x3293	; 0x803293 <rcvC1_write_index+0x1>
    440c:	e8 0f       	add	r30, r24
    440e:	f9 1f       	adc	r31, r25
    4410:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    4412:	80 91 92 32 	lds	r24, 0x3292	; 0x803292 <rcvC1_write_index>
    4416:	90 91 93 32 	lds	r25, 0x3293	; 0x803293 <rcvC1_write_index+0x1>
    441a:	01 96       	adiw	r24, 0x01	; 1
    441c:	84 36       	cpi	r24, 0x64	; 100
    441e:	91 05       	cpc	r25, r1
    4420:	60 f4       	brcc	.+24     	; 0x443a <__vector_28+0x64>
    4422:	80 93 92 32 	sts	0x3292, r24	; 0x803292 <rcvC1_write_index>
    4426:	90 93 93 32 	sts	0x3293, r25	; 0x803293 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    442a:	20 91 9c 32 	lds	r18, 0x329C	; 0x80329c <rcvC1_read_index>
    442e:	30 91 9d 32 	lds	r19, 0x329D	; 0x80329d <rcvC1_read_index+0x1>
    4432:	82 17       	cp	r24, r18
    4434:	93 07       	cpc	r25, r19
    4436:	f1 f4       	brne	.+60     	; 0x4474 <__vector_28+0x9e>
    4438:	0c c0       	rjmp	.+24     	; 0x4452 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    443a:	10 92 92 32 	sts	0x3292, r1	; 0x803292 <rcvC1_write_index>
    443e:	10 92 93 32 	sts	0x3293, r1	; 0x803293 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4442:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <rcvC1_read_index>
    4446:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <rcvC1_read_index+0x1>
    444a:	18 16       	cp	r1, r24
    444c:	19 06       	cpc	r1, r25
    444e:	91 f4       	brne	.+36     	; 0x4474 <__vector_28+0x9e>
    4450:	0e c0       	rjmp	.+28     	; 0x446e <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4452:	01 96       	adiw	r24, 0x01	; 1
    4454:	84 36       	cpi	r24, 0x64	; 100
    4456:	91 05       	cpc	r25, r1
    4458:	28 f4       	brcc	.+10     	; 0x4464 <__vector_28+0x8e>
    445a:	80 93 9c 32 	sts	0x329C, r24	; 0x80329c <rcvC1_read_index>
    445e:	90 93 9d 32 	sts	0x329D, r25	; 0x80329d <rcvC1_read_index+0x1>
    4462:	08 c0       	rjmp	.+16     	; 0x4474 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    4464:	10 92 9c 32 	sts	0x329C, r1	; 0x80329c <rcvC1_read_index>
    4468:	10 92 9d 32 	sts	0x329D, r1	; 0x80329d <rcvC1_read_index+0x1>
}
    446c:	03 c0       	rjmp	.+6      	; 0x4474 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    446e:	81 e0       	ldi	r24, 0x01	; 1
    4470:	90 e0       	ldi	r25, 0x00	; 0
    4472:	f3 cf       	rjmp	.-26     	; 0x445a <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    4474:	ff 91       	pop	r31
    4476:	ef 91       	pop	r30
    4478:	9f 91       	pop	r25
    447a:	8f 91       	pop	r24
    447c:	3f 91       	pop	r19
    447e:	2f 91       	pop	r18
    4480:	0f 90       	pop	r0
    4482:	0b be       	out	0x3b, r0	; 59
    4484:	0f 90       	pop	r0
    4486:	08 be       	out	0x38, r0	; 56
    4488:	0f 90       	pop	r0
    448a:	0f be       	out	0x3f, r0	; 63
    448c:	0f 90       	pop	r0
    448e:	1f 90       	pop	r1
    4490:	18 95       	reti

00004492 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4492:	1f 92       	push	r1
    4494:	0f 92       	push	r0
    4496:	0f b6       	in	r0, 0x3f	; 63
    4498:	0f 92       	push	r0
    449a:	11 24       	eor	r1, r1
    449c:	08 b6       	in	r0, 0x38	; 56
    449e:	0f 92       	push	r0
    44a0:	18 be       	out	0x38, r1	; 56
    44a2:	0b b6       	in	r0, 0x3b	; 59
    44a4:	0f 92       	push	r0
    44a6:	1b be       	out	0x3b, r1	; 59
    44a8:	2f 93       	push	r18
    44aa:	3f 93       	push	r19
    44ac:	8f 93       	push	r24
    44ae:	9f 93       	push	r25
    44b0:	ef 93       	push	r30
    44b2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    44b4:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    44b8:	e0 91 a4 32 	lds	r30, 0x32A4	; 0x8032a4 <rcvD0_buffer>
    44bc:	f0 91 a5 32 	lds	r31, 0x32A5	; 0x8032a5 <rcvD0_buffer+0x1>
    44c0:	80 91 94 32 	lds	r24, 0x3294	; 0x803294 <rcvC0_write_index>
    44c4:	90 91 95 32 	lds	r25, 0x3295	; 0x803295 <rcvC0_write_index+0x1>
    44c8:	e8 0f       	add	r30, r24
    44ca:	f9 1f       	adc	r31, r25
    44cc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    44ce:	80 91 90 32 	lds	r24, 0x3290	; 0x803290 <rcvD0_write_index>
    44d2:	90 91 91 32 	lds	r25, 0x3291	; 0x803291 <rcvD0_write_index+0x1>
    44d6:	01 96       	adiw	r24, 0x01	; 1
    44d8:	84 36       	cpi	r24, 0x64	; 100
    44da:	91 05       	cpc	r25, r1
    44dc:	60 f4       	brcc	.+24     	; 0x44f6 <__vector_88+0x64>
    44de:	80 93 90 32 	sts	0x3290, r24	; 0x803290 <rcvD0_write_index>
    44e2:	90 93 91 32 	sts	0x3291, r25	; 0x803291 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    44e6:	20 91 9a 32 	lds	r18, 0x329A	; 0x80329a <rcvD0_read_index>
    44ea:	30 91 9b 32 	lds	r19, 0x329B	; 0x80329b <rcvD0_read_index+0x1>
    44ee:	82 17       	cp	r24, r18
    44f0:	93 07       	cpc	r25, r19
    44f2:	f1 f4       	brne	.+60     	; 0x4530 <__vector_88+0x9e>
    44f4:	0c c0       	rjmp	.+24     	; 0x450e <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    44f6:	10 92 90 32 	sts	0x3290, r1	; 0x803290 <rcvD0_write_index>
    44fa:	10 92 91 32 	sts	0x3291, r1	; 0x803291 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    44fe:	80 91 9a 32 	lds	r24, 0x329A	; 0x80329a <rcvD0_read_index>
    4502:	90 91 9b 32 	lds	r25, 0x329B	; 0x80329b <rcvD0_read_index+0x1>
    4506:	18 16       	cp	r1, r24
    4508:	19 06       	cpc	r1, r25
    450a:	91 f4       	brne	.+36     	; 0x4530 <__vector_88+0x9e>
    450c:	0e c0       	rjmp	.+28     	; 0x452a <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    450e:	01 96       	adiw	r24, 0x01	; 1
    4510:	84 36       	cpi	r24, 0x64	; 100
    4512:	91 05       	cpc	r25, r1
    4514:	28 f4       	brcc	.+10     	; 0x4520 <__vector_88+0x8e>
    4516:	80 93 9a 32 	sts	0x329A, r24	; 0x80329a <rcvD0_read_index>
    451a:	90 93 9b 32 	sts	0x329B, r25	; 0x80329b <rcvD0_read_index+0x1>
    451e:	08 c0       	rjmp	.+16     	; 0x4530 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    4520:	10 92 9a 32 	sts	0x329A, r1	; 0x80329a <rcvD0_read_index>
    4524:	10 92 9b 32 	sts	0x329B, r1	; 0x80329b <rcvD0_read_index+0x1>
}
    4528:	03 c0       	rjmp	.+6      	; 0x4530 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    452a:	81 e0       	ldi	r24, 0x01	; 1
    452c:	90 e0       	ldi	r25, 0x00	; 0
    452e:	f3 cf       	rjmp	.-26     	; 0x4516 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4530:	ff 91       	pop	r31
    4532:	ef 91       	pop	r30
    4534:	9f 91       	pop	r25
    4536:	8f 91       	pop	r24
    4538:	3f 91       	pop	r19
    453a:	2f 91       	pop	r18
    453c:	0f 90       	pop	r0
    453e:	0b be       	out	0x3b, r0	; 59
    4540:	0f 90       	pop	r0
    4542:	08 be       	out	0x38, r0	; 56
    4544:	0f 90       	pop	r0
    4546:	0f be       	out	0x3f, r0	; 63
    4548:	0f 90       	pop	r0
    454a:	1f 90       	pop	r1
    454c:	18 95       	reti

0000454e <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    454e:	1f 92       	push	r1
    4550:	0f 92       	push	r0
    4552:	0f b6       	in	r0, 0x3f	; 63
    4554:	0f 92       	push	r0
    4556:	11 24       	eor	r1, r1
    4558:	08 b6       	in	r0, 0x38	; 56
    455a:	0f 92       	push	r0
    455c:	18 be       	out	0x38, r1	; 56
    455e:	0b b6       	in	r0, 0x3b	; 59
    4560:	0f 92       	push	r0
    4562:	1b be       	out	0x3b, r1	; 59
    4564:	2f 93       	push	r18
    4566:	3f 93       	push	r19
    4568:	8f 93       	push	r24
    456a:	9f 93       	push	r25
    456c:	ef 93       	push	r30
    456e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4570:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4574:	e0 91 a2 32 	lds	r30, 0x32A2	; 0x8032a2 <rcvD1_buffer>
    4578:	f0 91 a3 32 	lds	r31, 0x32A3	; 0x8032a3 <rcvD1_buffer+0x1>
    457c:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvD1_write_index>
    4580:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvD1_write_index+0x1>
    4584:	e8 0f       	add	r30, r24
    4586:	f9 1f       	adc	r31, r25
    4588:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    458a:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvD1_write_index>
    458e:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvD1_write_index+0x1>
    4592:	01 96       	adiw	r24, 0x01	; 1
    4594:	84 36       	cpi	r24, 0x64	; 100
    4596:	91 05       	cpc	r25, r1
    4598:	60 f4       	brcc	.+24     	; 0x45b2 <__vector_91+0x64>
    459a:	80 93 8e 32 	sts	0x328E, r24	; 0x80328e <rcvD1_write_index>
    459e:	90 93 8f 32 	sts	0x328F, r25	; 0x80328f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    45a2:	20 91 98 32 	lds	r18, 0x3298	; 0x803298 <rcvD1_read_index>
    45a6:	30 91 99 32 	lds	r19, 0x3299	; 0x803299 <rcvD1_read_index+0x1>
    45aa:	82 17       	cp	r24, r18
    45ac:	93 07       	cpc	r25, r19
    45ae:	f1 f4       	brne	.+60     	; 0x45ec <__vector_91+0x9e>
    45b0:	0c c0       	rjmp	.+24     	; 0x45ca <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    45b2:	10 92 8e 32 	sts	0x328E, r1	; 0x80328e <rcvD1_write_index>
    45b6:	10 92 8f 32 	sts	0x328F, r1	; 0x80328f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    45ba:	80 91 98 32 	lds	r24, 0x3298	; 0x803298 <rcvD1_read_index>
    45be:	90 91 99 32 	lds	r25, 0x3299	; 0x803299 <rcvD1_read_index+0x1>
    45c2:	18 16       	cp	r1, r24
    45c4:	19 06       	cpc	r1, r25
    45c6:	91 f4       	brne	.+36     	; 0x45ec <__vector_91+0x9e>
    45c8:	0e c0       	rjmp	.+28     	; 0x45e6 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    45ca:	01 96       	adiw	r24, 0x01	; 1
    45cc:	84 36       	cpi	r24, 0x64	; 100
    45ce:	91 05       	cpc	r25, r1
    45d0:	28 f4       	brcc	.+10     	; 0x45dc <__vector_91+0x8e>
    45d2:	80 93 98 32 	sts	0x3298, r24	; 0x803298 <rcvD1_read_index>
    45d6:	90 93 99 32 	sts	0x3299, r25	; 0x803299 <rcvD1_read_index+0x1>
    45da:	08 c0       	rjmp	.+16     	; 0x45ec <__vector_91+0x9e>
	rcvD1_read_index = 0;
    45dc:	10 92 98 32 	sts	0x3298, r1	; 0x803298 <rcvD1_read_index>
    45e0:	10 92 99 32 	sts	0x3299, r1	; 0x803299 <rcvD1_read_index+0x1>
}
    45e4:	03 c0       	rjmp	.+6      	; 0x45ec <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    45e6:	81 e0       	ldi	r24, 0x01	; 1
    45e8:	90 e0       	ldi	r25, 0x00	; 0
    45ea:	f3 cf       	rjmp	.-26     	; 0x45d2 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    45ec:	ff 91       	pop	r31
    45ee:	ef 91       	pop	r30
    45f0:	9f 91       	pop	r25
    45f2:	8f 91       	pop	r24
    45f4:	3f 91       	pop	r19
    45f6:	2f 91       	pop	r18
    45f8:	0f 90       	pop	r0
    45fa:	0b be       	out	0x3b, r0	; 59
    45fc:	0f 90       	pop	r0
    45fe:	08 be       	out	0x38, r0	; 56
    4600:	0f 90       	pop	r0
    4602:	0f be       	out	0x3f, r0	; 63
    4604:	0f 90       	pop	r0
    4606:	1f 90       	pop	r1
    4608:	18 95       	reti

0000460a <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    460a:	1f 92       	push	r1
    460c:	0f 92       	push	r0
    460e:	0f b6       	in	r0, 0x3f	; 63
    4610:	0f 92       	push	r0
    4612:	11 24       	eor	r1, r1
    4614:	08 b6       	in	r0, 0x38	; 56
    4616:	0f 92       	push	r0
    4618:	18 be       	out	0x38, r1	; 56
    461a:	0b b6       	in	r0, 0x3b	; 59
    461c:	0f 92       	push	r0
    461e:	1b be       	out	0x3b, r1	; 59
    4620:	2f 93       	push	r18
    4622:	3f 93       	push	r19
    4624:	8f 93       	push	r24
    4626:	9f 93       	push	r25
    4628:	ef 93       	push	r30
    462a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    462c:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4630:	e0 91 a0 32 	lds	r30, 0x32A0	; 0x8032a0 <rcvE0_buffer>
    4634:	f0 91 a1 32 	lds	r31, 0x32A1	; 0x8032a1 <rcvE0_buffer+0x1>
    4638:	80 91 8c 32 	lds	r24, 0x328C	; 0x80328c <rcvE0_write_index>
    463c:	90 91 8d 32 	lds	r25, 0x328D	; 0x80328d <rcvE0_write_index+0x1>
    4640:	e8 0f       	add	r30, r24
    4642:	f9 1f       	adc	r31, r25
    4644:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4646:	80 91 8c 32 	lds	r24, 0x328C	; 0x80328c <rcvE0_write_index>
    464a:	90 91 8d 32 	lds	r25, 0x328D	; 0x80328d <rcvE0_write_index+0x1>
    464e:	01 96       	adiw	r24, 0x01	; 1
    4650:	84 36       	cpi	r24, 0x64	; 100
    4652:	91 05       	cpc	r25, r1
    4654:	60 f4       	brcc	.+24     	; 0x466e <__vector_58+0x64>
    4656:	80 93 8c 32 	sts	0x328C, r24	; 0x80328c <rcvE0_write_index>
    465a:	90 93 8d 32 	sts	0x328D, r25	; 0x80328d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    465e:	20 91 96 32 	lds	r18, 0x3296	; 0x803296 <rcvE0_read_index>
    4662:	30 91 97 32 	lds	r19, 0x3297	; 0x803297 <rcvE0_read_index+0x1>
    4666:	82 17       	cp	r24, r18
    4668:	93 07       	cpc	r25, r19
    466a:	f1 f4       	brne	.+60     	; 0x46a8 <__vector_58+0x9e>
    466c:	0c c0       	rjmp	.+24     	; 0x4686 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    466e:	10 92 8c 32 	sts	0x328C, r1	; 0x80328c <rcvE0_write_index>
    4672:	10 92 8d 32 	sts	0x328D, r1	; 0x80328d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4676:	80 91 96 32 	lds	r24, 0x3296	; 0x803296 <rcvE0_read_index>
    467a:	90 91 97 32 	lds	r25, 0x3297	; 0x803297 <rcvE0_read_index+0x1>
    467e:	18 16       	cp	r1, r24
    4680:	19 06       	cpc	r1, r25
    4682:	91 f4       	brne	.+36     	; 0x46a8 <__vector_58+0x9e>
    4684:	0e c0       	rjmp	.+28     	; 0x46a2 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4686:	01 96       	adiw	r24, 0x01	; 1
    4688:	84 36       	cpi	r24, 0x64	; 100
    468a:	91 05       	cpc	r25, r1
    468c:	28 f4       	brcc	.+10     	; 0x4698 <__vector_58+0x8e>
    468e:	80 93 96 32 	sts	0x3296, r24	; 0x803296 <rcvE0_read_index>
    4692:	90 93 97 32 	sts	0x3297, r25	; 0x803297 <rcvE0_read_index+0x1>
    4696:	08 c0       	rjmp	.+16     	; 0x46a8 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    4698:	10 92 96 32 	sts	0x3296, r1	; 0x803296 <rcvE0_read_index>
    469c:	10 92 97 32 	sts	0x3297, r1	; 0x803297 <rcvE0_read_index+0x1>
}
    46a0:	03 c0       	rjmp	.+6      	; 0x46a8 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    46a2:	81 e0       	ldi	r24, 0x01	; 1
    46a4:	90 e0       	ldi	r25, 0x00	; 0
    46a6:	f3 cf       	rjmp	.-26     	; 0x468e <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    46a8:	ff 91       	pop	r31
    46aa:	ef 91       	pop	r30
    46ac:	9f 91       	pop	r25
    46ae:	8f 91       	pop	r24
    46b0:	3f 91       	pop	r19
    46b2:	2f 91       	pop	r18
    46b4:	0f 90       	pop	r0
    46b6:	0b be       	out	0x3b, r0	; 59
    46b8:	0f 90       	pop	r0
    46ba:	08 be       	out	0x38, r0	; 56
    46bc:	0f 90       	pop	r0
    46be:	0f be       	out	0x3f, r0	; 63
    46c0:	0f 90       	pop	r0
    46c2:	1f 90       	pop	r1
    46c4:	18 95       	reti

000046c6 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    46c6:	fc 01       	movw	r30, r24
    46c8:	84 81       	ldd	r24, Z+4	; 0x04
    46ca:	95 81       	ldd	r25, Z+5	; 0x05
    46cc:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
		}
    46d0:	90 e0       	ldi	r25, 0x00	; 0
    46d2:	08 95       	ret

000046d4 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    46d4:	fc 01       	movw	r30, r24
    46d6:	84 81       	ldd	r24, Z+4	; 0x04
    46d8:	95 81       	ldd	r25, Z+5	; 0x05
    46da:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    46de:	91 e0       	ldi	r25, 0x01	; 1
    46e0:	81 11       	cpse	r24, r1
    46e2:	01 c0       	rjmp	.+2      	; 0x46e6 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    46e4:	90 e0       	ldi	r25, 0x00	; 0
		}
    46e6:	89 2f       	mov	r24, r25
    46e8:	08 95       	ret

000046ea <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    46ea:	fc 01       	movw	r30, r24
    46ec:	84 81       	ldd	r24, Z+4	; 0x04
    46ee:	95 81       	ldd	r25, Z+5	; 0x05
    46f0:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    46f4:	91 e0       	ldi	r25, 0x01	; 1
    46f6:	81 11       	cpse	r24, r1
    46f8:	90 e0       	ldi	r25, 0x00	; 0
		}
    46fa:	89 2f       	mov	r24, r25
    46fc:	08 95       	ret

000046fe <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    46fe:	fc 01       	movw	r30, r24
    4700:	84 81       	ldd	r24, Z+4	; 0x04
    4702:	95 81       	ldd	r25, Z+5	; 0x05
    4704:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
		}
    4708:	90 e0       	ldi	r25, 0x00	; 0
    470a:	08 95       	ret

0000470c <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    470c:	fc 01       	movw	r30, r24
    470e:	84 81       	ldd	r24, Z+4	; 0x04
    4710:	95 81       	ldd	r25, Z+5	; 0x05
    4712:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    4716:	91 e0       	ldi	r25, 0x01	; 1
    4718:	81 11       	cpse	r24, r1
    471a:	01 c0       	rjmp	.+2      	; 0x471e <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    471c:	90 e0       	ldi	r25, 0x00	; 0
		}
    471e:	89 2f       	mov	r24, r25
    4720:	08 95       	ret

00004722 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    4722:	fc 01       	movw	r30, r24
    4724:	84 81       	ldd	r24, Z+4	; 0x04
    4726:	95 81       	ldd	r25, Z+5	; 0x05
    4728:	0e 94 95 14 	call	0x292a	; 0x292a <uxQueueMessagesWaitingFromISR>
    472c:	91 e0       	ldi	r25, 0x01	; 1
    472e:	81 11       	cpse	r24, r1
    4730:	90 e0       	ldi	r25, 0x00	; 0
		}
    4732:	89 2f       	mov	r24, r25
    4734:	08 95       	ret

00004736 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4736:	fc 01       	movw	r30, r24
    4738:	84 81       	ldd	r24, Z+4	; 0x04
    473a:	95 81       	ldd	r25, Z+5	; 0x05
    473c:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
		}
    4740:	90 e0       	ldi	r25, 0x00	; 0
    4742:	08 95       	ret

00004744 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4744:	fc 01       	movw	r30, r24
    4746:	84 81       	ldd	r24, Z+4	; 0x04
    4748:	95 81       	ldd	r25, Z+5	; 0x05
    474a:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    474e:	91 e0       	ldi	r25, 0x01	; 1
    4750:	81 11       	cpse	r24, r1
    4752:	01 c0       	rjmp	.+2      	; 0x4756 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4754:	90 e0       	ldi	r25, 0x00	; 0
		}
    4756:	89 2f       	mov	r24, r25
    4758:	08 95       	ret

0000475a <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    475a:	fc 01       	movw	r30, r24
    475c:	84 81       	ldd	r24, Z+4	; 0x04
    475e:	95 81       	ldd	r25, Z+5	; 0x05
    4760:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    4764:	91 e0       	ldi	r25, 0x01	; 1
    4766:	81 11       	cpse	r24, r1
    4768:	90 e0       	ldi	r25, 0x00	; 0
		}
    476a:	89 2f       	mov	r24, r25
    476c:	08 95       	ret

0000476e <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    476e:	fc 01       	movw	r30, r24
    4770:	84 81       	ldd	r24, Z+4	; 0x04
    4772:	95 81       	ldd	r25, Z+5	; 0x05
    4774:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
		}
    4778:	90 e0       	ldi	r25, 0x00	; 0
    477a:	08 95       	ret

0000477c <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    477c:	fc 01       	movw	r30, r24
    477e:	84 81       	ldd	r24, Z+4	; 0x04
    4780:	95 81       	ldd	r25, Z+5	; 0x05
    4782:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    4786:	91 e0       	ldi	r25, 0x01	; 1
    4788:	81 11       	cpse	r24, r1
    478a:	01 c0       	rjmp	.+2      	; 0x478e <_ZN9frt_queueIiE9not_emptyEv+0x12>
    478c:	90 e0       	ldi	r25, 0x00	; 0
		}
    478e:	89 2f       	mov	r24, r25
    4790:	08 95       	ret

00004792 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4792:	fc 01       	movw	r30, r24
    4794:	84 81       	ldd	r24, Z+4	; 0x04
    4796:	95 81       	ldd	r25, Z+5	; 0x05
    4798:	0e 94 8d 14 	call	0x291a	; 0x291a <uxQueueMessagesWaiting>
    479c:	91 e0       	ldi	r25, 0x01	; 1
    479e:	81 11       	cpse	r24, r1
    47a0:	90 e0       	ldi	r25, 0x00	; 0
		}
    47a2:	89 2f       	mov	r24, r25
    47a4:	08 95       	ret

000047a6 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    47a6:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    47a8:	01 e0       	ldi	r16, 0x01	; 1
    47aa:	2f ef       	ldi	r18, 0xFF	; 255
    47ac:	3f ef       	ldi	r19, 0xFF	; 255
    47ae:	a9 01       	movw	r20, r18
    47b0:	fc 01       	movw	r30, r24
    47b2:	84 81       	ldd	r24, Z+4	; 0x04
    47b4:	95 81       	ldd	r25, Z+5	; 0x05
    47b6:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    47ba:	0f 91       	pop	r16
    47bc:	08 95       	ret

000047be <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    47be:	0f 93       	push	r16
    47c0:	cf 93       	push	r28
    47c2:	df 93       	push	r29
    47c4:	1f 92       	push	r1
    47c6:	1f 92       	push	r1
    47c8:	cd b7       	in	r28, 0x3d	; 61
    47ca:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    47cc:	01 e0       	ldi	r16, 0x01	; 1
    47ce:	2f ef       	ldi	r18, 0xFF	; 255
    47d0:	3f ef       	ldi	r19, 0xFF	; 255
    47d2:	a9 01       	movw	r20, r18
    47d4:	be 01       	movw	r22, r28
    47d6:	6f 5f       	subi	r22, 0xFF	; 255
    47d8:	7f 4f       	sbci	r23, 0xFF	; 255
    47da:	fc 01       	movw	r30, r24
    47dc:	84 81       	ldd	r24, Z+4	; 0x04
    47de:	95 81       	ldd	r25, Z+5	; 0x05
    47e0:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    47e4:	89 81       	ldd	r24, Y+1	; 0x01
    47e6:	9a 81       	ldd	r25, Y+2	; 0x02
    47e8:	0f 90       	pop	r0
    47ea:	0f 90       	pop	r0
    47ec:	df 91       	pop	r29
    47ee:	cf 91       	pop	r28
    47f0:	0f 91       	pop	r16
    47f2:	08 95       	ret

000047f4 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    47f4:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    47f6:	00 e0       	ldi	r16, 0x00	; 0
    47f8:	2f ef       	ldi	r18, 0xFF	; 255
    47fa:	3f ef       	ldi	r19, 0xFF	; 255
    47fc:	a9 01       	movw	r20, r18
    47fe:	fc 01       	movw	r30, r24
    4800:	84 81       	ldd	r24, Z+4	; 0x04
    4802:	95 81       	ldd	r25, Z+5	; 0x05
    4804:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    4808:	0f 91       	pop	r16
    480a:	08 95       	ret

0000480c <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    480c:	0f 93       	push	r16
    480e:	cf 93       	push	r28
    4810:	df 93       	push	r29
    4812:	1f 92       	push	r1
    4814:	1f 92       	push	r1
    4816:	cd b7       	in	r28, 0x3d	; 61
    4818:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    481a:	00 e0       	ldi	r16, 0x00	; 0
    481c:	2f ef       	ldi	r18, 0xFF	; 255
    481e:	3f ef       	ldi	r19, 0xFF	; 255
    4820:	a9 01       	movw	r20, r18
    4822:	be 01       	movw	r22, r28
    4824:	6f 5f       	subi	r22, 0xFF	; 255
    4826:	7f 4f       	sbci	r23, 0xFF	; 255
    4828:	fc 01       	movw	r30, r24
    482a:	84 81       	ldd	r24, Z+4	; 0x04
    482c:	95 81       	ldd	r25, Z+5	; 0x05
    482e:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    4832:	89 81       	ldd	r24, Y+1	; 0x01
    4834:	9a 81       	ldd	r25, Y+2	; 0x02
    4836:	0f 90       	pop	r0
    4838:	0f 90       	pop	r0
    483a:	df 91       	pop	r29
    483c:	cf 91       	pop	r28
    483e:	0f 91       	pop	r16
    4840:	08 95       	ret

00004842 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4842:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4844:	01 e0       	ldi	r16, 0x01	; 1
    4846:	2f ef       	ldi	r18, 0xFF	; 255
    4848:	3f ef       	ldi	r19, 0xFF	; 255
    484a:	a9 01       	movw	r20, r18
    484c:	fc 01       	movw	r30, r24
    484e:	84 81       	ldd	r24, Z+4	; 0x04
    4850:	95 81       	ldd	r25, Z+5	; 0x05
    4852:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    4856:	0f 91       	pop	r16
    4858:	08 95       	ret

0000485a <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    485a:	0f 93       	push	r16
    485c:	cf 93       	push	r28
    485e:	df 93       	push	r29
    4860:	1f 92       	push	r1
    4862:	1f 92       	push	r1
    4864:	cd b7       	in	r28, 0x3d	; 61
    4866:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4868:	01 e0       	ldi	r16, 0x01	; 1
    486a:	2f ef       	ldi	r18, 0xFF	; 255
    486c:	3f ef       	ldi	r19, 0xFF	; 255
    486e:	a9 01       	movw	r20, r18
    4870:	be 01       	movw	r22, r28
    4872:	6f 5f       	subi	r22, 0xFF	; 255
    4874:	7f 4f       	sbci	r23, 0xFF	; 255
    4876:	fc 01       	movw	r30, r24
    4878:	84 81       	ldd	r24, Z+4	; 0x04
    487a:	95 81       	ldd	r25, Z+5	; 0x05
    487c:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    4880:	89 81       	ldd	r24, Y+1	; 0x01
    4882:	9a 81       	ldd	r25, Y+2	; 0x02
    4884:	0f 90       	pop	r0
    4886:	0f 90       	pop	r0
    4888:	df 91       	pop	r29
    488a:	cf 91       	pop	r28
    488c:	0f 91       	pop	r16
    488e:	08 95       	ret

00004890 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4890:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4892:	00 e0       	ldi	r16, 0x00	; 0
    4894:	2f ef       	ldi	r18, 0xFF	; 255
    4896:	3f ef       	ldi	r19, 0xFF	; 255
    4898:	a9 01       	movw	r20, r18
    489a:	fc 01       	movw	r30, r24
    489c:	84 81       	ldd	r24, Z+4	; 0x04
    489e:	95 81       	ldd	r25, Z+5	; 0x05
    48a0:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
}
    48a4:	0f 91       	pop	r16
    48a6:	08 95       	ret

000048a8 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    48a8:	0f 93       	push	r16
    48aa:	cf 93       	push	r28
    48ac:	df 93       	push	r29
    48ae:	1f 92       	push	r1
    48b0:	1f 92       	push	r1
    48b2:	cd b7       	in	r28, 0x3d	; 61
    48b4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    48b6:	00 e0       	ldi	r16, 0x00	; 0
    48b8:	2f ef       	ldi	r18, 0xFF	; 255
    48ba:	3f ef       	ldi	r19, 0xFF	; 255
    48bc:	a9 01       	movw	r20, r18
    48be:	be 01       	movw	r22, r28
    48c0:	6f 5f       	subi	r22, 0xFF	; 255
    48c2:	7f 4f       	sbci	r23, 0xFF	; 255
    48c4:	fc 01       	movw	r30, r24
    48c6:	84 81       	ldd	r24, Z+4	; 0x04
    48c8:	95 81       	ldd	r25, Z+5	; 0x05
    48ca:	0e 94 9c 13 	call	0x2738	; 0x2738 <xQueueGenericReceive>
	return (recv_item);
}
    48ce:	89 81       	ldd	r24, Y+1	; 0x01
    48d0:	9a 81       	ldd	r25, Y+2	; 0x02
    48d2:	0f 90       	pop	r0
    48d4:	0f 90       	pop	r0
    48d6:	df 91       	pop	r29
    48d8:	cf 91       	pop	r28
    48da:	0f 91       	pop	r16
    48dc:	08 95       	ret

000048de <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    48de:	cf 93       	push	r28
    48e0:	df 93       	push	r29
    48e2:	1f 92       	push	r1
    48e4:	cd b7       	in	r28, 0x3d	; 61
    48e6:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    48e8:	ae 01       	movw	r20, r28
    48ea:	4f 5f       	subi	r20, 0xFF	; 255
    48ec:	5f 4f       	sbci	r21, 0xFF	; 255
    48ee:	fc 01       	movw	r30, r24
    48f0:	84 81       	ldd	r24, Z+4	; 0x04
    48f2:	95 81       	ldd	r25, Z+5	; 0x05
    48f4:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
}
    48f8:	0f 90       	pop	r0
    48fa:	df 91       	pop	r29
    48fc:	cf 91       	pop	r28
    48fe:	08 95       	ret

00004900 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4900:	cf 93       	push	r28
    4902:	df 93       	push	r29
    4904:	00 d0       	rcall	.+0      	; 0x4906 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4906:	cd b7       	in	r28, 0x3d	; 61
    4908:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    490a:	ae 01       	movw	r20, r28
    490c:	4d 5f       	subi	r20, 0xFD	; 253
    490e:	5f 4f       	sbci	r21, 0xFF	; 255
    4910:	be 01       	movw	r22, r28
    4912:	6f 5f       	subi	r22, 0xFF	; 255
    4914:	7f 4f       	sbci	r23, 0xFF	; 255
    4916:	fc 01       	movw	r30, r24
    4918:	84 81       	ldd	r24, Z+4	; 0x04
    491a:	95 81       	ldd	r25, Z+5	; 0x05
    491c:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
	return (recv_item);
}
    4920:	89 81       	ldd	r24, Y+1	; 0x01
    4922:	9a 81       	ldd	r25, Y+2	; 0x02
    4924:	23 96       	adiw	r28, 0x03	; 3
    4926:	cd bf       	out	0x3d, r28	; 61
    4928:	de bf       	out	0x3e, r29	; 62
    492a:	df 91       	pop	r29
    492c:	cf 91       	pop	r28
    492e:	08 95       	ret

00004930 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4930:	cf 93       	push	r28
    4932:	df 93       	push	r29
    4934:	1f 92       	push	r1
    4936:	cd b7       	in	r28, 0x3d	; 61
    4938:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    493a:	ae 01       	movw	r20, r28
    493c:	4f 5f       	subi	r20, 0xFF	; 255
    493e:	5f 4f       	sbci	r21, 0xFF	; 255
    4940:	fc 01       	movw	r30, r24
    4942:	84 81       	ldd	r24, Z+4	; 0x04
    4944:	95 81       	ldd	r25, Z+5	; 0x05
    4946:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
}
    494a:	0f 90       	pop	r0
    494c:	df 91       	pop	r29
    494e:	cf 91       	pop	r28
    4950:	08 95       	ret

00004952 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4952:	cf 93       	push	r28
    4954:	df 93       	push	r29
    4956:	00 d0       	rcall	.+0      	; 0x4958 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4958:	cd b7       	in	r28, 0x3d	; 61
    495a:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    495c:	ae 01       	movw	r20, r28
    495e:	4d 5f       	subi	r20, 0xFD	; 253
    4960:	5f 4f       	sbci	r21, 0xFF	; 255
    4962:	be 01       	movw	r22, r28
    4964:	6f 5f       	subi	r22, 0xFF	; 255
    4966:	7f 4f       	sbci	r23, 0xFF	; 255
    4968:	fc 01       	movw	r30, r24
    496a:	84 81       	ldd	r24, Z+4	; 0x04
    496c:	95 81       	ldd	r25, Z+5	; 0x05
    496e:	0e 94 60 14 	call	0x28c0	; 0x28c0 <xQueueReceiveFromISR>
	return (recv_item);
}
    4972:	89 81       	ldd	r24, Y+1	; 0x01
    4974:	9a 81       	ldd	r25, Y+2	; 0x02
    4976:	23 96       	adiw	r28, 0x03	; 3
    4978:	cd bf       	out	0x3d, r28	; 61
    497a:	de bf       	out	0x3e, r29	; 62
    497c:	df 91       	pop	r29
    497e:	cf 91       	pop	r28
    4980:	08 95       	ret

00004982 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4982:	cf 93       	push	r28
    4984:	df 93       	push	r29
    4986:	1f 92       	push	r1
    4988:	cd b7       	in	r28, 0x3d	; 61
    498a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    498c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    498e:	21 e0       	ldi	r18, 0x01	; 1
    4990:	ae 01       	movw	r20, r28
    4992:	4f 5f       	subi	r20, 0xFF	; 255
    4994:	5f 4f       	sbci	r21, 0xFF	; 255
    4996:	fc 01       	movw	r30, r24
    4998:	84 81       	ldd	r24, Z+4	; 0x04
    499a:	95 81       	ldd	r25, Z+5	; 0x05
    499c:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49a0:	91 e0       	ldi	r25, 0x01	; 1
    49a2:	81 11       	cpse	r24, r1
    49a4:	01 c0       	rjmp	.+2      	; 0x49a8 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    49a6:	90 e0       	ldi	r25, 0x00	; 0
}
    49a8:	89 2f       	mov	r24, r25
    49aa:	0f 90       	pop	r0
    49ac:	df 91       	pop	r29
    49ae:	cf 91       	pop	r28
    49b0:	08 95       	ret

000049b2 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    49b2:	cf 93       	push	r28
    49b4:	df 93       	push	r29
    49b6:	1f 92       	push	r1
    49b8:	cd b7       	in	r28, 0x3d	; 61
    49ba:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49bc:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    49be:	20 e0       	ldi	r18, 0x00	; 0
    49c0:	ae 01       	movw	r20, r28
    49c2:	4f 5f       	subi	r20, 0xFF	; 255
    49c4:	5f 4f       	sbci	r21, 0xFF	; 255
    49c6:	fc 01       	movw	r30, r24
    49c8:	84 81       	ldd	r24, Z+4	; 0x04
    49ca:	95 81       	ldd	r25, Z+5	; 0x05
    49cc:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49d0:	91 e0       	ldi	r25, 0x01	; 1
    49d2:	81 11       	cpse	r24, r1
    49d4:	01 c0       	rjmp	.+2      	; 0x49d8 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    49d6:	90 e0       	ldi	r25, 0x00	; 0
}
    49d8:	89 2f       	mov	r24, r25
    49da:	0f 90       	pop	r0
    49dc:	df 91       	pop	r29
    49de:	cf 91       	pop	r28
    49e0:	08 95       	ret

000049e2 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    49e2:	cf 93       	push	r28
    49e4:	df 93       	push	r29
    49e6:	1f 92       	push	r1
    49e8:	cd b7       	in	r28, 0x3d	; 61
    49ea:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49ec:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    49ee:	21 e0       	ldi	r18, 0x01	; 1
    49f0:	ae 01       	movw	r20, r28
    49f2:	4f 5f       	subi	r20, 0xFF	; 255
    49f4:	5f 4f       	sbci	r21, 0xFF	; 255
    49f6:	fc 01       	movw	r30, r24
    49f8:	84 81       	ldd	r24, Z+4	; 0x04
    49fa:	95 81       	ldd	r25, Z+5	; 0x05
    49fc:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a00:	91 e0       	ldi	r25, 0x01	; 1
    4a02:	81 11       	cpse	r24, r1
    4a04:	01 c0       	rjmp	.+2      	; 0x4a08 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4a06:	90 e0       	ldi	r25, 0x00	; 0
}
    4a08:	89 2f       	mov	r24, r25
    4a0a:	0f 90       	pop	r0
    4a0c:	df 91       	pop	r29
    4a0e:	cf 91       	pop	r28
    4a10:	08 95       	ret

00004a12 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4a12:	cf 93       	push	r28
    4a14:	df 93       	push	r29
    4a16:	1f 92       	push	r1
    4a18:	cd b7       	in	r28, 0x3d	; 61
    4a1a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a1c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4a1e:	20 e0       	ldi	r18, 0x00	; 0
    4a20:	ae 01       	movw	r20, r28
    4a22:	4f 5f       	subi	r20, 0xFF	; 255
    4a24:	5f 4f       	sbci	r21, 0xFF	; 255
    4a26:	fc 01       	movw	r30, r24
    4a28:	84 81       	ldd	r24, Z+4	; 0x04
    4a2a:	95 81       	ldd	r25, Z+5	; 0x05
    4a2c:	0e 94 70 13 	call	0x26e0	; 0x26e0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a30:	91 e0       	ldi	r25, 0x01	; 1
    4a32:	81 11       	cpse	r24, r1
    4a34:	01 c0       	rjmp	.+2      	; 0x4a38 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4a36:	90 e0       	ldi	r25, 0x00	; 0
}
    4a38:	89 2f       	mov	r24, r25
    4a3a:	0f 90       	pop	r0
    4a3c:	df 91       	pop	r29
    4a3e:	cf 91       	pop	r28
    4a40:	08 95       	ret

00004a42 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4a42:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4a44:	fc 01       	movw	r30, r24
    4a46:	26 81       	ldd	r18, Z+6	; 0x06
    4a48:	37 81       	ldd	r19, Z+7	; 0x07
    4a4a:	40 85       	ldd	r20, Z+8	; 0x08
    4a4c:	51 85       	ldd	r21, Z+9	; 0x09
    4a4e:	01 e0       	ldi	r16, 0x01	; 1
    4a50:	84 81       	ldd	r24, Z+4	; 0x04
    4a52:	95 81       	ldd	r25, Z+5	; 0x05
    4a54:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    4a58:	91 e0       	ldi	r25, 0x01	; 1
    4a5a:	81 11       	cpse	r24, r1
    4a5c:	01 c0       	rjmp	.+2      	; 0x4a60 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4a5e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4a60:	89 2f       	mov	r24, r25
    4a62:	0f 91       	pop	r16
    4a64:	08 95       	ret

00004a66 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4a66:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4a68:	fc 01       	movw	r30, r24
    4a6a:	26 81       	ldd	r18, Z+6	; 0x06
    4a6c:	37 81       	ldd	r19, Z+7	; 0x07
    4a6e:	40 85       	ldd	r20, Z+8	; 0x08
    4a70:	51 85       	ldd	r21, Z+9	; 0x09
    4a72:	00 e0       	ldi	r16, 0x00	; 0
    4a74:	84 81       	ldd	r24, Z+4	; 0x04
    4a76:	95 81       	ldd	r25, Z+5	; 0x05
    4a78:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    4a7c:	91 e0       	ldi	r25, 0x01	; 1
    4a7e:	81 11       	cpse	r24, r1
    4a80:	01 c0       	rjmp	.+2      	; 0x4a84 <_ZN9frt_queueIjE3putERKj+0x1e>
    4a82:	90 e0       	ldi	r25, 0x00	; 0
		}
    4a84:	89 2f       	mov	r24, r25
    4a86:	0f 91       	pop	r16
    4a88:	08 95       	ret

00004a8a <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4a8a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4a8c:	fc 01       	movw	r30, r24
    4a8e:	26 81       	ldd	r18, Z+6	; 0x06
    4a90:	37 81       	ldd	r19, Z+7	; 0x07
    4a92:	40 85       	ldd	r20, Z+8	; 0x08
    4a94:	51 85       	ldd	r21, Z+9	; 0x09
    4a96:	01 e0       	ldi	r16, 0x01	; 1
    4a98:	84 81       	ldd	r24, Z+4	; 0x04
    4a9a:	95 81       	ldd	r25, Z+5	; 0x05
    4a9c:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    4aa0:	91 e0       	ldi	r25, 0x01	; 1
    4aa2:	81 11       	cpse	r24, r1
    4aa4:	01 c0       	rjmp	.+2      	; 0x4aa8 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4aa6:	90 e0       	ldi	r25, 0x00	; 0
		}
    4aa8:	89 2f       	mov	r24, r25
    4aaa:	0f 91       	pop	r16
    4aac:	08 95       	ret

00004aae <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4aae:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4ab0:	fc 01       	movw	r30, r24
    4ab2:	26 81       	ldd	r18, Z+6	; 0x06
    4ab4:	37 81       	ldd	r19, Z+7	; 0x07
    4ab6:	40 85       	ldd	r20, Z+8	; 0x08
    4ab8:	51 85       	ldd	r21, Z+9	; 0x09
    4aba:	00 e0       	ldi	r16, 0x00	; 0
    4abc:	84 81       	ldd	r24, Z+4	; 0x04
    4abe:	95 81       	ldd	r25, Z+5	; 0x05
    4ac0:	0e 94 d5 12 	call	0x25aa	; 0x25aa <xQueueGenericSend>
    4ac4:	91 e0       	ldi	r25, 0x01	; 1
    4ac6:	81 11       	cpse	r24, r1
    4ac8:	01 c0       	rjmp	.+2      	; 0x4acc <_ZN9frt_queueIiE3putERKi+0x1e>
    4aca:	90 e0       	ldi	r25, 0x00	; 0
		}
    4acc:	89 2f       	mov	r24, r25
    4ace:	0f 91       	pop	r16
    4ad0:	08 95       	ret

00004ad2 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4ad2:	0f 93       	push	r16
    4ad4:	cf 93       	push	r28
    4ad6:	df 93       	push	r29
    4ad8:	1f 92       	push	r1
    4ada:	cd b7       	in	r28, 0x3d	; 61
    4adc:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4ade:	2f b7       	in	r18, 0x3f	; 63
    4ae0:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4ae2:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4ae4:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4ae6:	fc 01       	movw	r30, r24
    4ae8:	08 ed       	ldi	r16, 0xD8	; 216
    4aea:	04 bf       	out	0x34, r16	; 52
    4aec:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4aee:	89 81       	ldd	r24, Y+1	; 0x01
    4af0:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4af2:	0f 90       	pop	r0
    4af4:	df 91       	pop	r29
    4af6:	cf 91       	pop	r28
    4af8:	0f 91       	pop	r16
    4afa:	08 95       	ret

00004afc <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4afc:	ef 92       	push	r14
    4afe:	ff 92       	push	r15
    4b00:	0f 93       	push	r16
    4b02:	1f 93       	push	r17
    4b04:	cf 93       	push	r28
    4b06:	df 93       	push	r29
    4b08:	cd b7       	in	r28, 0x3d	; 61
    4b0a:	de b7       	in	r29, 0x3e	; 62
    4b0c:	ca 55       	subi	r28, 0x5A	; 90
    4b0e:	d1 09       	sbc	r29, r1
    4b10:	cd bf       	out	0x3d, r28	; 61
    4b12:	de bf       	out	0x3e, r29	; 62
	cli();
    4b14:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4b16:	e0 e5       	ldi	r30, 0x50	; 80
    4b18:	f0 e0       	ldi	r31, 0x00	; 0
    4b1a:	80 81       	ld	r24, Z
    4b1c:	82 60       	ori	r24, 0x02	; 2
    4b1e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4b20:	81 81       	ldd	r24, Z+1	; 0x01
    4b22:	81 ff       	sbrs	r24, 1
    4b24:	fd cf       	rjmp	.-6      	; 0x4b20 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4b26:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4b2a:	68 7f       	andi	r22, 0xF8	; 248
    4b2c:	61 60       	ori	r22, 0x01	; 1
    4b2e:	80 e4       	ldi	r24, 0x40	; 64
    4b30:	90 e0       	ldi	r25, 0x00	; 0
    4b32:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4b36:	e0 e5       	ldi	r30, 0x50	; 80
    4b38:	f0 e0       	ldi	r31, 0x00	; 0
    4b3a:	80 81       	ld	r24, Z
    4b3c:	8e 7f       	andi	r24, 0xFE	; 254
    4b3e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4b40:	9d ef       	ldi	r25, 0xFD	; 253
    4b42:	88 ed       	ldi	r24, 0xD8	; 216
    4b44:	08 b6       	in	r0, 0x38	; 56
    4b46:	18 be       	out	0x38, r1	; 56
    4b48:	84 bf       	out	0x34, r24	; 52
    4b4a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4b4e:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4b50:	40 ea       	ldi	r20, 0xA0	; 160
    4b52:	5a e0       	ldi	r21, 0x0A	; 10
    4b54:	60 e0       	ldi	r22, 0x00	; 0
    4b56:	70 e0       	ldi	r23, 0x00	; 0
    4b58:	ce 01       	movw	r24, r28
    4b5a:	01 96       	adiw	r24, 0x01	; 1
    4b5c:	0e 94 0d 21 	call	0x421a	; 0x421a <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4b60:	67 e0       	ldi	r22, 0x07	; 7
    4b62:	ce 01       	movw	r24, r28
    4b64:	01 96       	adiw	r24, 0x01	; 1
    4b66:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    4b6a:	8c 01       	movw	r16, r24
    4b6c:	6a ea       	ldi	r22, 0xAA	; 170
    4b6e:	71 e2       	ldi	r23, 0x21	; 33
    4b70:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstream4putsEPKc>
    4b74:	66 e0       	ldi	r22, 0x06	; 6
    4b76:	c8 01       	movw	r24, r16
    4b78:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
    4b7c:	66 e0       	ldi	r22, 0x06	; 6
    4b7e:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsE15ser_manipulator>
	
	// Create instance of I2C driver to be used by sensor objects
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4b82:	8e 01       	movw	r16, r28
    4b84:	0f 5f       	subi	r16, 0xFF	; 255
    4b86:	1f 4f       	sbci	r17, 0xFF	; 255
    4b88:	20 e3       	ldi	r18, 0x30	; 48
    4b8a:	32 ef       	ldi	r19, 0xF2	; 242
    4b8c:	40 e0       	ldi	r20, 0x00	; 0
    4b8e:	50 e0       	ldi	r21, 0x00	; 0
    4b90:	60 ea       	ldi	r22, 0xA0	; 160
    4b92:	74 e0       	ldi	r23, 0x04	; 4
    4b94:	ce 01       	movw	r24, r28
    4b96:	4e 96       	adiw	r24, 0x1e	; 30
    4b98:	0e 94 a7 07 	call	0xf4e	; 0xf4e <_ZN9I2CMasterC1EP10TWI_structmP8emstream>
	
	// Create instance of IMU class and pass in a pointer to the I2C driver
	MMA8451 mma8451(&i2c, &ser_dev);
    4b9c:	a8 01       	movw	r20, r16
    4b9e:	be 01       	movw	r22, r28
    4ba0:	62 5e       	subi	r22, 0xE2	; 226
    4ba2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ba4:	ce 01       	movw	r24, r28
    4ba6:	c7 96       	adiw	r24, 0x37	; 55
    4ba8:	0e 94 25 0a 	call	0x144a	; 0x144a <_ZN7MMA8451C1EP9I2CMasterP8emstream>

	//Create instance of Sonar class and pass in a pointer to the I2C driver
	MB1202 mb1202(&i2c, &ser_dev);
    4bac:	a8 01       	movw	r20, r16
    4bae:	be 01       	movw	r22, r28
    4bb0:	62 5e       	subi	r22, 0xE2	; 226
    4bb2:	7f 4f       	sbci	r23, 0xFF	; 255
    4bb4:	ce 01       	movw	r24, r28
    4bb6:	86 5b       	subi	r24, 0xB6	; 182
    4bb8:	9f 4f       	sbci	r25, 0xFF	; 255
    4bba:	0e 94 3f 09 	call	0x127e	; 0x127e <_ZN6MB1202C1EP9I2CMasterP8emstream>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4bbe:	82 e1       	ldi	r24, 0x12	; 18
    4bc0:	90 e0       	ldi	r25, 0x00	; 0
    4bc2:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    4bc6:	20 e8       	ldi	r18, 0x80	; 128
    4bc8:	30 e0       	ldi	r19, 0x00	; 0
    4bca:	40 e0       	ldi	r20, 0x00	; 0
    4bcc:	69 ec       	ldi	r22, 0xC9	; 201
    4bce:	71 e2       	ldi	r23, 0x21	; 33
    4bd0:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <_ZN9task_userC1EPKchjP8emstream>
	// new task_sonar( "Sonar", task_priority(2), 128, &ser_dev, &mb1202 );	
	new task_sensor ("Sensor", task_priority (2), 128, &ser_dev, &mma8451);
    4bd4:	88 e1       	ldi	r24, 0x18	; 24
    4bd6:	90 e0       	ldi	r25, 0x00	; 0
    4bd8:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <_Znwj>
    4bdc:	9e 01       	movw	r18, r28
    4bde:	29 5c       	subi	r18, 0xC9	; 201
    4be0:	3f 4f       	sbci	r19, 0xFF	; 255
    4be2:	79 01       	movw	r14, r18
    4be4:	20 e8       	ldi	r18, 0x80	; 128
    4be6:	30 e0       	ldi	r19, 0x00	; 0
    4be8:	42 e0       	ldi	r20, 0x02	; 2
    4bea:	61 ed       	ldi	r22, 0xD1	; 209
    4bec:	71 e2       	ldi	r23, 0x21	; 33
    4bee:	0e 94 34 0c 	call	0x1868	; 0x1868 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4bf2:	87 e0       	ldi	r24, 0x07	; 7
    4bf4:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4bf8:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4bfa:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <vTaskStartScheduler>
}
    4bfe:	80 e0       	ldi	r24, 0x00	; 0
    4c00:	90 e0       	ldi	r25, 0x00	; 0
    4c02:	c6 5a       	subi	r28, 0xA6	; 166
    4c04:	df 4f       	sbci	r29, 0xFF	; 255
    4c06:	cd bf       	out	0x3d, r28	; 61
    4c08:	de bf       	out	0x3e, r29	; 62
    4c0a:	df 91       	pop	r29
    4c0c:	cf 91       	pop	r28
    4c0e:	1f 91       	pop	r17
    4c10:	0f 91       	pop	r16
    4c12:	ff 90       	pop	r15
    4c14:	ef 90       	pop	r14
    4c16:	08 95       	ret

00004c18 <_GLOBAL__sub_I_counter>:
    4c18:	cf 92       	push	r12
    4c1a:	df 92       	push	r13
    4c1c:	ef 92       	push	r14
    4c1e:	ff 92       	push	r15
    4c20:	0f 93       	push	r16
    4c22:	1f 93       	push	r17
    4c24:	cf 93       	push	r28
    4c26:	df 93       	push	r29
#include "task_user.h"                      // Header for user interface task
#include "task_sensor.h"
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4c28:	0a e0       	ldi	r16, 0x0A	; 10
    4c2a:	10 e0       	ldi	r17, 0x00	; 0
    4c2c:	20 e0       	ldi	r18, 0x00	; 0
    4c2e:	30 e0       	ldi	r19, 0x00	; 0
    4c30:	40 e0       	ldi	r20, 0x00	; 0
    4c32:	50 e0       	ldi	r21, 0x00	; 0
    4c34:	60 e2       	ldi	r22, 0x20	; 32
    4c36:	70 e0       	ldi	r23, 0x00	; 0
    4c38:	8c ed       	ldi	r24, 0xDC	; 220
    4c3a:	92 e3       	ldi	r25, 0x32	; 50
    4c3c:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <_ZN14frt_text_queueC1EjP8emstreamm>
    4c40:	c2 ed       	ldi	r28, 0xD2	; 210
    4c42:	d2 e3       	ldi	r29, 0x32	; 50
    4c44:	1a 82       	std	Y+2, r1	; 0x02
    4c46:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c48:	8c ed       	ldi	r24, 0xDC	; 220
    4c4a:	91 e2       	ldi	r25, 0x21	; 33
    4c4c:	88 83       	st	Y, r24
    4c4e:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4c50:	40 e0       	ldi	r20, 0x00	; 0
    4c52:	62 e0       	ldi	r22, 0x02	; 2
    4c54:	8f ef       	ldi	r24, 0xFF	; 255
    4c56:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    4c5a:	8c 83       	std	Y+4, r24	; 0x04
    4c5c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4c5e:	0f 2e       	mov	r0, r31
    4c60:	fa e0       	ldi	r31, 0x0A	; 10
    4c62:	cf 2e       	mov	r12, r31
    4c64:	d1 2c       	mov	r13, r1
    4c66:	e1 2c       	mov	r14, r1
    4c68:	f1 2c       	mov	r15, r1
    4c6a:	f0 2d       	mov	r31, r0
    4c6c:	ce 82       	std	Y+6, r12	; 0x06
    4c6e:	df 82       	std	Y+7, r13	; 0x07
    4c70:	e8 86       	std	Y+8, r14	; 0x08
    4c72:	f9 86       	std	Y+9, r15	; 0x09
    4c74:	c8 ec       	ldi	r28, 0xC8	; 200
    4c76:	d2 e3       	ldi	r29, 0x32	; 50
    4c78:	1a 82       	std	Y+2, r1	; 0x02
    4c7a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c7c:	00 e0       	ldi	r16, 0x00	; 0
    4c7e:	12 e2       	ldi	r17, 0x22	; 34
    4c80:	08 83       	st	Y, r16
    4c82:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4c84:	40 e0       	ldi	r20, 0x00	; 0
    4c86:	62 e0       	ldi	r22, 0x02	; 2
    4c88:	8f ef       	ldi	r24, 0xFF	; 255
    4c8a:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    4c8e:	8c 83       	std	Y+4, r24	; 0x04
    4c90:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4c92:	ce 82       	std	Y+6, r12	; 0x06
    4c94:	df 82       	std	Y+7, r13	; 0x07
    4c96:	e8 86       	std	Y+8, r14	; 0x08
    4c98:	f9 86       	std	Y+9, r15	; 0x09
    4c9a:	ce eb       	ldi	r28, 0xBE	; 190
    4c9c:	d2 e3       	ldi	r29, 0x32	; 50
    4c9e:	1a 82       	std	Y+2, r1	; 0x02
    4ca0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ca2:	08 83       	st	Y, r16
    4ca4:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ca6:	40 e0       	ldi	r20, 0x00	; 0
    4ca8:	62 e0       	ldi	r22, 0x02	; 2
    4caa:	8f ef       	ldi	r24, 0xFF	; 255
    4cac:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    4cb0:	8c 83       	std	Y+4, r24	; 0x04
    4cb2:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cb4:	ce 82       	std	Y+6, r12	; 0x06
    4cb6:	df 82       	std	Y+7, r13	; 0x07
    4cb8:	e8 86       	std	Y+8, r14	; 0x08
    4cba:	f9 86       	std	Y+9, r15	; 0x09
    4cbc:	c4 eb       	ldi	r28, 0xB4	; 180
    4cbe:	d2 e3       	ldi	r29, 0x32	; 50
    4cc0:	1a 82       	std	Y+2, r1	; 0x02
    4cc2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4cc4:	08 83       	st	Y, r16
    4cc6:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4cc8:	40 e0       	ldi	r20, 0x00	; 0
    4cca:	62 e0       	ldi	r22, 0x02	; 2
    4ccc:	8f ef       	ldi	r24, 0xFF	; 255
    4cce:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    4cd2:	8c 83       	std	Y+4, r24	; 0x04
    4cd4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cd6:	ce 82       	std	Y+6, r12	; 0x06
    4cd8:	df 82       	std	Y+7, r13	; 0x07
    4cda:	e8 86       	std	Y+8, r14	; 0x08
    4cdc:	f9 86       	std	Y+9, r15	; 0x09
    4cde:	ca ea       	ldi	r28, 0xAA	; 170
    4ce0:	d2 e3       	ldi	r29, 0x32	; 50
    4ce2:	1a 82       	std	Y+2, r1	; 0x02
    4ce4:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ce6:	08 83       	st	Y, r16
    4ce8:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4cea:	40 e0       	ldi	r20, 0x00	; 0
    4cec:	62 e0       	ldi	r22, 0x02	; 2
    4cee:	8f ef       	ldi	r24, 0xFF	; 255
    4cf0:	0e 94 a7 12 	call	0x254e	; 0x254e <xQueueGenericCreate>
    4cf4:	8c 83       	std	Y+4, r24	; 0x04
    4cf6:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cf8:	ce 82       	std	Y+6, r12	; 0x06
    4cfa:	df 82       	std	Y+7, r13	; 0x07
    4cfc:	e8 86       	std	Y+8, r14	; 0x08
    4cfe:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4d00:	df 91       	pop	r29
    4d02:	cf 91       	pop	r28
    4d04:	1f 91       	pop	r17
    4d06:	0f 91       	pop	r16
    4d08:	ff 90       	pop	r15
    4d0a:	ef 90       	pop	r14
    4d0c:	df 90       	pop	r13
    4d0e:	cf 90       	pop	r12
    4d10:	08 95       	ret

00004d12 <__mulsi3>:
    4d12:	db 01       	movw	r26, r22
    4d14:	8f 93       	push	r24
    4d16:	9f 93       	push	r25
    4d18:	0e 94 e3 26 	call	0x4dc6	; 0x4dc6 <__muluhisi3>
    4d1c:	bf 91       	pop	r27
    4d1e:	af 91       	pop	r26
    4d20:	a2 9f       	mul	r26, r18
    4d22:	80 0d       	add	r24, r0
    4d24:	91 1d       	adc	r25, r1
    4d26:	a3 9f       	mul	r26, r19
    4d28:	90 0d       	add	r25, r0
    4d2a:	b2 9f       	mul	r27, r18
    4d2c:	90 0d       	add	r25, r0
    4d2e:	11 24       	eor	r1, r1
    4d30:	08 95       	ret

00004d32 <__udivmodsi4>:
    4d32:	a1 e2       	ldi	r26, 0x21	; 33
    4d34:	1a 2e       	mov	r1, r26
    4d36:	aa 1b       	sub	r26, r26
    4d38:	bb 1b       	sub	r27, r27
    4d3a:	fd 01       	movw	r30, r26
    4d3c:	0d c0       	rjmp	.+26     	; 0x4d58 <__udivmodsi4_ep>

00004d3e <__udivmodsi4_loop>:
    4d3e:	aa 1f       	adc	r26, r26
    4d40:	bb 1f       	adc	r27, r27
    4d42:	ee 1f       	adc	r30, r30
    4d44:	ff 1f       	adc	r31, r31
    4d46:	a2 17       	cp	r26, r18
    4d48:	b3 07       	cpc	r27, r19
    4d4a:	e4 07       	cpc	r30, r20
    4d4c:	f5 07       	cpc	r31, r21
    4d4e:	20 f0       	brcs	.+8      	; 0x4d58 <__udivmodsi4_ep>
    4d50:	a2 1b       	sub	r26, r18
    4d52:	b3 0b       	sbc	r27, r19
    4d54:	e4 0b       	sbc	r30, r20
    4d56:	f5 0b       	sbc	r31, r21

00004d58 <__udivmodsi4_ep>:
    4d58:	66 1f       	adc	r22, r22
    4d5a:	77 1f       	adc	r23, r23
    4d5c:	88 1f       	adc	r24, r24
    4d5e:	99 1f       	adc	r25, r25
    4d60:	1a 94       	dec	r1
    4d62:	69 f7       	brne	.-38     	; 0x4d3e <__udivmodsi4_loop>
    4d64:	60 95       	com	r22
    4d66:	70 95       	com	r23
    4d68:	80 95       	com	r24
    4d6a:	90 95       	com	r25
    4d6c:	9b 01       	movw	r18, r22
    4d6e:	ac 01       	movw	r20, r24
    4d70:	bd 01       	movw	r22, r26
    4d72:	cf 01       	movw	r24, r30
    4d74:	08 95       	ret

00004d76 <__divmodsi4>:
    4d76:	05 2e       	mov	r0, r21
    4d78:	97 fb       	bst	r25, 7
    4d7a:	1e f4       	brtc	.+6      	; 0x4d82 <__divmodsi4+0xc>
    4d7c:	00 94       	com	r0
    4d7e:	0e 94 d2 26 	call	0x4da4	; 0x4da4 <__negsi2>
    4d82:	57 fd       	sbrc	r21, 7
    4d84:	07 d0       	rcall	.+14     	; 0x4d94 <__divmodsi4_neg2>
    4d86:	0e 94 99 26 	call	0x4d32	; 0x4d32 <__udivmodsi4>
    4d8a:	07 fc       	sbrc	r0, 7
    4d8c:	03 d0       	rcall	.+6      	; 0x4d94 <__divmodsi4_neg2>
    4d8e:	4e f4       	brtc	.+18     	; 0x4da2 <__divmodsi4_exit>
    4d90:	0c 94 d2 26 	jmp	0x4da4	; 0x4da4 <__negsi2>

00004d94 <__divmodsi4_neg2>:
    4d94:	50 95       	com	r21
    4d96:	40 95       	com	r20
    4d98:	30 95       	com	r19
    4d9a:	21 95       	neg	r18
    4d9c:	3f 4f       	sbci	r19, 0xFF	; 255
    4d9e:	4f 4f       	sbci	r20, 0xFF	; 255
    4da0:	5f 4f       	sbci	r21, 0xFF	; 255

00004da2 <__divmodsi4_exit>:
    4da2:	08 95       	ret

00004da4 <__negsi2>:
    4da4:	90 95       	com	r25
    4da6:	80 95       	com	r24
    4da8:	70 95       	com	r23
    4daa:	61 95       	neg	r22
    4dac:	7f 4f       	sbci	r23, 0xFF	; 255
    4dae:	8f 4f       	sbci	r24, 0xFF	; 255
    4db0:	9f 4f       	sbci	r25, 0xFF	; 255
    4db2:	08 95       	ret

00004db4 <__tablejump2__>:
    4db4:	ee 0f       	add	r30, r30
    4db6:	ff 1f       	adc	r31, r31
    4db8:	88 1f       	adc	r24, r24
    4dba:	8b bf       	out	0x3b, r24	; 59
    4dbc:	07 90       	elpm	r0, Z+
    4dbe:	f6 91       	elpm	r31, Z
    4dc0:	e0 2d       	mov	r30, r0
    4dc2:	1b be       	out	0x3b, r1	; 59
    4dc4:	19 94       	eijmp

00004dc6 <__muluhisi3>:
    4dc6:	0e 94 ee 26 	call	0x4ddc	; 0x4ddc <__umulhisi3>
    4dca:	a5 9f       	mul	r26, r21
    4dcc:	90 0d       	add	r25, r0
    4dce:	b4 9f       	mul	r27, r20
    4dd0:	90 0d       	add	r25, r0
    4dd2:	a4 9f       	mul	r26, r20
    4dd4:	80 0d       	add	r24, r0
    4dd6:	91 1d       	adc	r25, r1
    4dd8:	11 24       	eor	r1, r1
    4dda:	08 95       	ret

00004ddc <__umulhisi3>:
    4ddc:	a2 9f       	mul	r26, r18
    4dde:	b0 01       	movw	r22, r0
    4de0:	b3 9f       	mul	r27, r19
    4de2:	c0 01       	movw	r24, r0
    4de4:	a3 9f       	mul	r26, r19
    4de6:	70 0d       	add	r23, r0
    4de8:	81 1d       	adc	r24, r1
    4dea:	11 24       	eor	r1, r1
    4dec:	91 1d       	adc	r25, r1
    4dee:	b2 9f       	mul	r27, r18
    4df0:	70 0d       	add	r23, r0
    4df2:	81 1d       	adc	r24, r1
    4df4:	11 24       	eor	r1, r1
    4df6:	91 1d       	adc	r25, r1
    4df8:	08 95       	ret

00004dfa <memcpy>:
    4dfa:	fb 01       	movw	r30, r22
    4dfc:	dc 01       	movw	r26, r24
    4dfe:	02 c0       	rjmp	.+4      	; 0x4e04 <memcpy+0xa>
    4e00:	01 90       	ld	r0, Z+
    4e02:	0d 92       	st	X+, r0
    4e04:	41 50       	subi	r20, 0x01	; 1
    4e06:	50 40       	sbci	r21, 0x00	; 0
    4e08:	d8 f7       	brcc	.-10     	; 0x4e00 <memcpy+0x6>
    4e0a:	08 95       	ret

00004e0c <memset>:
    4e0c:	dc 01       	movw	r26, r24
    4e0e:	01 c0       	rjmp	.+2      	; 0x4e12 <memset+0x6>
    4e10:	6d 93       	st	X+, r22
    4e12:	41 50       	subi	r20, 0x01	; 1
    4e14:	50 40       	sbci	r21, 0x00	; 0
    4e16:	e0 f7       	brcc	.-8      	; 0x4e10 <memset+0x4>
    4e18:	08 95       	ret

00004e1a <strncpy>:
    4e1a:	fb 01       	movw	r30, r22
    4e1c:	dc 01       	movw	r26, r24
    4e1e:	41 50       	subi	r20, 0x01	; 1
    4e20:	50 40       	sbci	r21, 0x00	; 0
    4e22:	48 f0       	brcs	.+18     	; 0x4e36 <strncpy+0x1c>
    4e24:	01 90       	ld	r0, Z+
    4e26:	0d 92       	st	X+, r0
    4e28:	00 20       	and	r0, r0
    4e2a:	c9 f7       	brne	.-14     	; 0x4e1e <strncpy+0x4>
    4e2c:	01 c0       	rjmp	.+2      	; 0x4e30 <strncpy+0x16>
    4e2e:	1d 92       	st	X+, r1
    4e30:	41 50       	subi	r20, 0x01	; 1
    4e32:	50 40       	sbci	r21, 0x00	; 0
    4e34:	e0 f7       	brcc	.-8      	; 0x4e2e <strncpy+0x14>
    4e36:	08 95       	ret

00004e38 <ultoa>:
    4e38:	25 32       	cpi	r18, 0x25	; 37
    4e3a:	31 05       	cpc	r19, r1
    4e3c:	20 f4       	brcc	.+8      	; 0x4e46 <ultoa+0xe>
    4e3e:	22 30       	cpi	r18, 0x02	; 2
    4e40:	10 f0       	brcs	.+4      	; 0x4e46 <ultoa+0xe>
    4e42:	0c 94 27 27 	jmp	0x4e4e	; 0x4e4e <__ultoa_ncheck>
    4e46:	fa 01       	movw	r30, r20
    4e48:	10 82       	st	Z, r1
    4e4a:	ca 01       	movw	r24, r20
    4e4c:	08 95       	ret

00004e4e <__ultoa_ncheck>:
    4e4e:	bb 27       	eor	r27, r27

00004e50 <__ultoa_common>:
    4e50:	fa 01       	movw	r30, r20
    4e52:	a6 2f       	mov	r26, r22
    4e54:	62 17       	cp	r22, r18
    4e56:	71 05       	cpc	r23, r1
    4e58:	81 05       	cpc	r24, r1
    4e5a:	91 05       	cpc	r25, r1
    4e5c:	33 0b       	sbc	r19, r19
    4e5e:	30 fb       	bst	r19, 0
    4e60:	66 f0       	brts	.+24     	; 0x4e7a <__ultoa_common+0x2a>
    4e62:	aa 27       	eor	r26, r26
    4e64:	66 0f       	add	r22, r22
    4e66:	77 1f       	adc	r23, r23
    4e68:	88 1f       	adc	r24, r24
    4e6a:	99 1f       	adc	r25, r25
    4e6c:	aa 1f       	adc	r26, r26
    4e6e:	a2 17       	cp	r26, r18
    4e70:	10 f0       	brcs	.+4      	; 0x4e76 <__ultoa_common+0x26>
    4e72:	a2 1b       	sub	r26, r18
    4e74:	63 95       	inc	r22
    4e76:	38 50       	subi	r19, 0x08	; 8
    4e78:	a9 f7       	brne	.-22     	; 0x4e64 <__ultoa_common+0x14>
    4e7a:	a0 5d       	subi	r26, 0xD0	; 208
    4e7c:	aa 33       	cpi	r26, 0x3A	; 58
    4e7e:	08 f0       	brcs	.+2      	; 0x4e82 <__ultoa_common+0x32>
    4e80:	a9 5d       	subi	r26, 0xD9	; 217
    4e82:	a1 93       	st	Z+, r26
    4e84:	36 f7       	brtc	.-52     	; 0x4e52 <__ultoa_common+0x2>
    4e86:	b1 11       	cpse	r27, r1
    4e88:	b1 93       	st	Z+, r27
    4e8a:	10 82       	st	Z, r1
    4e8c:	ca 01       	movw	r24, r20
    4e8e:	0c 94 6e 27 	jmp	0x4edc	; 0x4edc <strrev>

00004e92 <utoa>:
    4e92:	45 32       	cpi	r20, 0x25	; 37
    4e94:	51 05       	cpc	r21, r1
    4e96:	20 f4       	brcc	.+8      	; 0x4ea0 <utoa+0xe>
    4e98:	42 30       	cpi	r20, 0x02	; 2
    4e9a:	10 f0       	brcs	.+4      	; 0x4ea0 <utoa+0xe>
    4e9c:	0c 94 54 27 	jmp	0x4ea8	; 0x4ea8 <__utoa_ncheck>
    4ea0:	fb 01       	movw	r30, r22
    4ea2:	10 82       	st	Z, r1
    4ea4:	cb 01       	movw	r24, r22
    4ea6:	08 95       	ret

00004ea8 <__utoa_ncheck>:
    4ea8:	bb 27       	eor	r27, r27

00004eaa <__utoa_common>:
    4eaa:	fb 01       	movw	r30, r22
    4eac:	55 27       	eor	r21, r21
    4eae:	aa 27       	eor	r26, r26
    4eb0:	88 0f       	add	r24, r24
    4eb2:	99 1f       	adc	r25, r25
    4eb4:	aa 1f       	adc	r26, r26
    4eb6:	a4 17       	cp	r26, r20
    4eb8:	10 f0       	brcs	.+4      	; 0x4ebe <__utoa_common+0x14>
    4eba:	a4 1b       	sub	r26, r20
    4ebc:	83 95       	inc	r24
    4ebe:	50 51       	subi	r21, 0x10	; 16
    4ec0:	b9 f7       	brne	.-18     	; 0x4eb0 <__utoa_common+0x6>
    4ec2:	a0 5d       	subi	r26, 0xD0	; 208
    4ec4:	aa 33       	cpi	r26, 0x3A	; 58
    4ec6:	08 f0       	brcs	.+2      	; 0x4eca <__utoa_common+0x20>
    4ec8:	a9 5d       	subi	r26, 0xD9	; 217
    4eca:	a1 93       	st	Z+, r26
    4ecc:	00 97       	sbiw	r24, 0x00	; 0
    4ece:	79 f7       	brne	.-34     	; 0x4eae <__utoa_common+0x4>
    4ed0:	b1 11       	cpse	r27, r1
    4ed2:	b1 93       	st	Z+, r27
    4ed4:	11 92       	st	Z+, r1
    4ed6:	cb 01       	movw	r24, r22
    4ed8:	0c 94 6e 27 	jmp	0x4edc	; 0x4edc <strrev>

00004edc <strrev>:
    4edc:	dc 01       	movw	r26, r24
    4ede:	fc 01       	movw	r30, r24
    4ee0:	67 2f       	mov	r22, r23
    4ee2:	71 91       	ld	r23, Z+
    4ee4:	77 23       	and	r23, r23
    4ee6:	e1 f7       	brne	.-8      	; 0x4ee0 <strrev+0x4>
    4ee8:	32 97       	sbiw	r30, 0x02	; 2
    4eea:	04 c0       	rjmp	.+8      	; 0x4ef4 <strrev+0x18>
    4eec:	7c 91       	ld	r23, X
    4eee:	6d 93       	st	X+, r22
    4ef0:	70 83       	st	Z, r23
    4ef2:	62 91       	ld	r22, -Z
    4ef4:	ae 17       	cp	r26, r30
    4ef6:	bf 07       	cpc	r27, r31
    4ef8:	c8 f3       	brcs	.-14     	; 0x4eec <strrev+0x10>
    4efa:	08 95       	ret

00004efc <_exit>:
    4efc:	f8 94       	cli

00004efe <__stop_program>:
    4efe:	ff cf       	rjmp	.-2      	; 0x4efe <__stop_program>
