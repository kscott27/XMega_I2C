
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000465e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000156  00802000  0000465e  000046f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802156  00802156  00004848  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004848  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004878  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000920  00000000  00000000  000048b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00018498  00000000  00000000  000051d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006a4d  00000000  00000000  0001d670  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005dbe  00000000  00000000  000240bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b44  00000000  00000000  00029e7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006cdf  00000000  00000000  0002b9c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008a2a  00000000  00000000  0003269f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000880  00000000  00000000  0003b0c9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1d 03 	jmp	0x63a	; 0x63a <__ctors_end>
       4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
       8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
       c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      10:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      14:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      18:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      1c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      20:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      24:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      28:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      2c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      30:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      34:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      38:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      3c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      40:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      44:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      48:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      4c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      50:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      54:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      58:	0c 94 71 0d 	jmp	0x1ae2	; 0x1ae2 <__vector_22>
      5c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      60:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      64:	0c 94 46 1d 	jmp	0x3a8c	; 0x3a8c <__vector_25>
      68:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      6c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      70:	0c 94 a4 1d 	jmp	0x3b48	; 0x3b48 <__vector_28>
      74:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      78:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      7c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      80:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      84:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      88:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      8c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      90:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      94:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      98:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      9c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      a0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      a4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      a8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      ac:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      b0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      b4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      b8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      bc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      c0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      c4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      c8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      cc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      d0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      d4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      d8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      dc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      e0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      e4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      e8:	0c 94 be 1e 	jmp	0x3d7c	; 0x3d7c <__vector_58>
      ec:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      f0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      f4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      f8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
      fc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     100:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     104:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     108:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     10c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     110:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     114:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     118:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     11c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     120:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     124:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     128:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     12c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     130:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     134:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     138:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     13c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     140:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     144:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     148:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     14c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     150:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     154:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     158:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     15c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     160:	0c 94 02 1e 	jmp	0x3c04	; 0x3c04 <__vector_88>
     164:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     168:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     16c:	0c 94 60 1e 	jmp	0x3cc0	; 0x3cc0 <__vector_91>
     170:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     174:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     178:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     17c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     180:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     184:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     188:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     18c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     190:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     194:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     198:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     19c:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1a0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1a4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1a8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1ac:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1b0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1b4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1b8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1bc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1c0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1c4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1c8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1cc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1d0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1d4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1d8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1dc:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1e0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1e4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1e8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1ec:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1f0:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1f4:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1f8:	0c 94 53 03 	jmp	0x6a6	; 0x6a6 <__bad_interrupt>
     1fc:	32 1b       	sub	r19, r18
     1fe:	35 1b       	sub	r19, r21
     200:	38 1b       	sub	r19, r24
     202:	3b 1b       	sub	r19, r27
     204:	3e 1b       	sub	r19, r30
     206:	41 1b       	sub	r20, r17
     208:	43 1b       	sub	r20, r19
     20a:	54 1b       	sub	r21, r20
     20c:	5c 1b       	sub	r21, r28
     20e:	66 1b       	sub	r22, r22
     210:	64 1b       	sub	r22, r20

00000212 <__trampolines_start>:
     212:	0c 94 da 20 	jmp	0x41b4	; 0x41b4 <_ZN9frt_queueIjE7butt_inERKj>
     216:	0c 94 e6 1f 	jmp	0x3fcc	; 0x3fcc <_ZN9frt_queueIiE10get_a_copyEv>
     21a:	0c 94 60 1c 	jmp	0x38c0	; 0x38c0 <_ZN5rs2327putcharEc>
     21e:	0c 94 10 21 	jmp	0x4220	; 0x4220 <_ZN9frt_queueIiE3putERKi>
     222:	0c 94 6d 06 	jmp	0xcda	; 0xcda <_ZN9frt_queueIhE7ISR_getEv>
     226:	0c 94 39 20 	jmp	0x4072	; 0x4072 <_ZN9frt_queueIjE7ISR_getEv>
     22a:	0c 94 86 18 	jmp	0x310c	; 0x310c <_ZN14frt_text_queue7putcharEc>
     22e:	0c 94 e3 05 	jmp	0xbc6	; 0xbc6 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     232:	0c 94 ee 05 	jmp	0xbdc	; 0xbdc <_ZN9frt_queueIhE12ISR_is_emptyEv>
     236:	0c 94 da 1a 	jmp	0x35b4	; 0x35b4 <_ZN8emstream14check_for_charEv>
     23a:	0c 94 b4 06 	jmp	0xd68	; 0xd68 <_ZN9frt_queueIhE7butt_inERKh>
     23e:	0c 94 01 20 	jmp	0x4002	; 0x4002 <_ZN9frt_queueIiE3getEPi>
     242:	0c 94 4d 09 	jmp	0x129a	; 0x129a <_ZN9task_user3runEv>
     246:	0c 94 20 06 	jmp	0xc40	; 0xc40 <_ZN9frt_queueIhE10get_a_copyEv>
     24a:	0c 94 5c 06 	jmp	0xcb8	; 0xcb8 <_ZN9frt_queueIhE7ISR_getEPh>
     24e:	0c 94 66 1f 	jmp	0x3ecc	; 0x3ecc <_ZN9frt_queueIjE8is_emptyEv>
     252:	0c 94 ec 20 	jmp	0x41d8	; 0x41d8 <_ZN9frt_queueIjE3putERKj>
     256:	0c 94 70 1f 	jmp	0x3ee0	; 0x3ee0 <_ZN9frt_queueIiE12num_items_inEv>
     25a:	0c 94 dc 1a 	jmp	0x35b8	; 0x35b8 <_ZN8emstream12transmit_nowEv>
     25e:	0c 94 3f 1f 	jmp	0x3e7e	; 0x3e7e <_ZN9frt_queueIiE13ISR_not_emptyEv>
     262:	0c 94 77 1f 	jmp	0x3eee	; 0x3eee <_ZN9frt_queueIiE9not_emptyEv>
     266:	0c 94 3b 04 	jmp	0x876	; 0x876 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     26a:	0c 94 44 06 	jmp	0xc88	; 0xc88 <_ZN9frt_queueIhE3getEv>
     26e:	0c 94 c2 20 	jmp	0x4184	; 0x4184 <_ZN9frt_queueIiE7ISR_putERKi>
     272:	0c 94 9c 06 	jmp	0xd38	; 0xd38 <_ZN9frt_queueIhE7ISR_putERKh>
     276:	0c 94 bb 21 	jmp	0x4376	; 0x4376 <_GLOBAL__sub_I_counter>
     27a:	0c 94 38 1b 	jmp	0x3670	; 0x3670 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     27e:	0c 94 54 1b 	jmp	0x36a8	; 0x36a8 <_ZN8emstreamlsE15ser_manipulator+0x62>
     282:	0c 94 35 1b 	jmp	0x366a	; 0x366a <_ZN8emstreamlsE15ser_manipulator+0x24>
     286:	0c 94 54 1f 	jmp	0x3ea8	; 0x3ea8 <_ZN9frt_queueIjE12num_items_inEv>
     28a:	0c 94 fe 20 	jmp	0x41fc	; 0x41fc <_ZN9frt_queueIiE7butt_inERKi>
     28e:	0c 94 5b 1f 	jmp	0x3eb6	; 0x3eb6 <_ZN9frt_queueIjE9not_emptyEv>
     292:	0c 94 c6 06 	jmp	0xd8c	; 0xd8c <_ZN9frt_queueIhE3putERKh>
     296:	0c 94 98 1f 	jmp	0x3f30	; 0x3f30 <_ZN9frt_queueIjE10get_a_copyEv>
     29a:	0c 94 b7 03 	jmp	0x76e	; 0x76e <_ZN8I2CAgent11writePacketER7Command>
     29e:	0c 94 38 1f 	jmp	0x3e70	; 0x3e70 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2a2:	0c 94 77 03 	jmp	0x6ee	; 0x6ee <_ZN8I2CAgent8transmitER7Command>
     2a6:	0c 94 aa 1c 	jmp	0x3954	; 0x3954 <_ZN5rs23214check_for_charEv>
     2aa:	0c 94 0a 04 	jmp	0x814	; 0x814 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2ae:	0c 94 82 1f 	jmp	0x3f04	; 0x3f04 <_ZN9frt_queueIiE8is_emptyEv>
     2b2:	0c 94 7b 04 	jmp	0x8f6	; 0x8f6 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>
     2b6:	0c 94 3e 1b 	jmp	0x367c	; 0x367c <_ZN8emstreamlsE15ser_manipulator+0x36>
     2ba:	0c 94 af 07 	jmp	0xf5e	; 0xf5e <_ZN10task_sonar3runEv>
     2be:	0c 94 7a 20 	jmp	0x40f4	; 0x40f4 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     2c2:	0c 94 13 17 	jmp	0x2e26	; 0x2e26 <_ZN8frt_task12print_statusER8emstream>
     2c6:	0c 94 0d 20 	jmp	0x401a	; 0x401a <_ZN9frt_queueIiE3getEv>
     2ca:	0c 94 1a 03 	jmp	0x634	; 0x634 <_call_static_run_method>
     2ce:	0c 94 ff 05 	jmp	0xbfe	; 0xbfe <_ZN9frt_queueIhE9not_emptyEv>
     2d2:	0c 94 4a 1f 	jmp	0x3e94	; 0x3e94 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     2d6:	0c 94 28 20 	jmp	0x4050	; 0x4050 <_ZN9frt_queueIjE7ISR_getEPj>
     2da:	0c 94 8c 03 	jmp	0x718	; 0x718 <_ZN8I2CAgent7receiveEv>
     2de:	0c 94 da 1f 	jmp	0x3fb4	; 0x3fb4 <_ZN9frt_queueIiE10get_a_copyERi>
     2e2:	0c 94 92 20 	jmp	0x4124	; 0x4124 <_ZN9frt_queueIjE7ISR_putERKj>
     2e6:	0c 94 51 10 	jmp	0x20a2	; 0x20a2 <prvIdleTask>
     2ea:	0c 94 bf 1f 	jmp	0x3f7e	; 0x3f7e <_ZN9frt_queueIjE3getEv>
     2ee:	0c 94 d5 1a 	jmp	0x35aa	; 0x35aa <_ZN8emstream13ready_to_sendEv>
     2f2:	0c 94 14 06 	jmp	0xc28	; 0xc28 <_ZN9frt_queueIhE10get_a_copyERh>
     2f6:	0c 94 64 1b 	jmp	0x36c8	; 0x36c8 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2fa:	0c 94 1c 1f 	jmp	0x3e38	; 0x3e38 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2fe:	0c 94 d7 1a 	jmp	0x35ae	; 0x35ae <_ZN8emstream7getcharEv>
     302:	0c 94 bd 1c 	jmp	0x397a	; 0x397a <_ZN5rs23212clear_screenEv>
     306:	0c 94 51 20 	jmp	0x40a2	; 0x40a2 <_ZN9frt_queueIiE7ISR_getEPi>
     30a:	0c 94 3e 1a 	jmp	0x347c	; 0x347c <__cxa_pure_virtual>
     30e:	0c 94 cf 05 	jmp	0xb9e	; 0xb9e <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     312:	0c 94 41 1b 	jmp	0x3682	; 0x3682 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     316:	0c 94 dd 1a 	jmp	0x35ba	; 0x35ba <_ZN8emstream12clear_screenEv>
     31a:	0c 94 77 04 	jmp	0x8ee	; 0x8ee <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>
     31e:	0c 94 43 1b 	jmp	0x3686	; 0x3686 <_ZN8emstreamlsE15ser_manipulator+0x40>
     322:	0c 94 62 20 	jmp	0x40c4	; 0x40c4 <_ZN9frt_queueIiE7ISR_getEv>
     326:	0c 94 66 1b 	jmp	0x36cc	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
     32a:	0c 94 dc 05 	jmp	0xbb8	; 0xbb8 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     32e:	0c 94 f8 05 	jmp	0xbf0	; 0xbf0 <_ZN9frt_queueIhE12num_items_inEv>
     332:	0c 94 38 06 	jmp	0xc70	; 0xc70 <_ZN9frt_queueIhE3getEPh>
     336:	0c 94 f2 03 	jmp	0x7e4	; 0x7e4 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>
     33a:	0c 94 3b 1b 	jmp	0x3676	; 0x3676 <_ZN8emstreamlsE15ser_manipulator+0x30>
     33e:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     342:	0c 94 55 03 	jmp	0x6aa	; 0x6aa <_ZN8I2CAgent10readPacketEv>
     346:	0c 94 84 06 	jmp	0xd08	; 0xd08 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     34a:	0c 94 62 04 	jmp	0x8c4	; 0x8c4 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     34e:	0c 94 84 1c 	jmp	0x3908	; 0x3908 <_ZN5rs2327getcharEv>
     352:	0c 94 8c 1f 	jmp	0x3f18	; 0x3f18 <_ZN9frt_queueIjE10get_a_copyERj>
     356:	0c 94 0a 06 	jmp	0xc14	; 0xc14 <_ZN9frt_queueIhE8is_emptyEv>
     35a:	0c 94 b3 1f 	jmp	0x3f66	; 0x3f66 <_ZN9frt_queueIjE3getEPj>
     35e:	0c 94 5d 18 	jmp	0x30ba	; 0x30ba <_ZN14frt_text_queue7getcharEv>
     362:	0c 94 5c 1b 	jmp	0x36b8	; 0x36b8 <_ZN8emstreamlsE15ser_manipulator+0x72>
     366:	0c 94 aa 20 	jmp	0x4154	; 0x4154 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     36a:	0c 94 7b 18 	jmp	0x30f6	; 0x30f6 <_ZN14frt_text_queue14check_for_charEv>
     36e:	0c 94 2e 1f 	jmp	0x3e5c	; 0x3e5c <_ZN9frt_queueIjE12ISR_is_emptyEv>
     372:	0c 94 60 03 	jmp	0x6c0	; 0x6c0 <_ZN8I2CAgent11resetPacketER6Packet>
     376:	0c 94 32 1b 	jmp	0x3664	; 0x3664 <_ZN8emstreamlsE15ser_manipulator+0x1e>

0000037a <__trampolines_end>:
     37a:	53 6f       	ori	r21, 0xF3	; 243
     37c:	6e 61       	ori	r22, 0x1E	; 30
     37e:	72 3a       	cpi	r23, 0xA2	; 162
     380:	20 00       	.word	0x0020	; ????

00000382 <_ZZN9task_user11show_statusEvE3__c_4>:
     382:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

0000038d <_ZZN9task_user11show_statusEvE3__c_3>:
     38d:	2f 00                                               /.

0000038f <_ZZN9task_user11show_statusEvE3__c_2>:
     38f:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

0000039d <_ZZN9task_user11show_statusEvE3__c_1>:
     39d:	54 69 6d 65 3a 20 00                                Time: .

000003a4 <_ZZN9task_user11show_statusEvE3__c_0>:
     3a4:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

000003b0 <_ZZN9task_user11show_statusEvE3__c>:
     3b0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3c0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003cf <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3cf:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000003de <_ZZN9task_user18print_help_messageEvE3__c_9>:
     3de:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     3ee:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

000003f9 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     3f9:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     409:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000417 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     417:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     427:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     437:	6d 61 74 69 6f 6e 00                                mation.

0000043e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     43e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     44e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000045f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     45f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     46f:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000477 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     477:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     487:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000493 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     493:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4a3:	68 65 20 41 56 52 00                                he AVR.

000004aa <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4aa:	20 68 65 6c 70 00                                    help.

000004b0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4b0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4c0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004cf <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4cf:	1b 5b 33 30 6d 00                                   .[30m.

000004d5 <_ZZN9task_user18print_help_messageEvE3__c>:
     4d5:	1b 5b 34 36 6d 00                                   .[46m.

000004db <_ZZN9task_user3runEvE3__c_3>:
     4db:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     4eb:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

000004f8 <_ZZN9task_user3runEvE3__c_2>:
     4f8:	3a 57 54 46 3f 00                                   :WTF?.

000004fe <_ZZN9task_user3runEvE3__c_1>:
     4fe:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     50e:	65 00                                               e.

00000510 <_ZZN9task_user3runEvE3__c_0>:
     510:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000051e <_ZZN9task_user3runEvE3__c>:
     51e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     52e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000053c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     53c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000546 <_ZZN8frt_task15emergency_resetEvE3__c>:
     546:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000555 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     555:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     565:	61 73 6b 20 00                                      ask .

0000056a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     56a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000578 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     578:	20 63 72 65 61 74 65 64 00                           created.

00000581 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     581:	54 61 73 6b 20 00                                   Task .

00000587 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     587:	1b 5b 32 32 6d 00                                   .[22m.

0000058d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     58d:	54 61 73 6b 3a 20 00                                Task: .

00000594 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     594:	1b 5b 31 6d 00                                      .[1m.

00000599 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     599:	1b 5b 32 32 6d 00                                   .[22m.

0000059f <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     59f:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005aa <_ZZ17print_task_stacksP8emstreamE3__c>:
     5aa:	1b 5b 31 6d 00                                      .[1m.

000005af <_ZZ15print_task_listP8emstreamE3__c_9>:
     5af:	09 09 00                                            ...

000005b2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5b2:	2f 00                                               /.

000005b4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5b4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005bf <_ZZ15print_task_listP8emstreamE3__c_6>:
     5bf:	09 2d 2d 2d 2d 00                                   .----.

000005c5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5c5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000005d1 <_ZZ15print_task_listP8emstreamE3__c_4>:
     5d1:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000005e2 <_ZZ15print_task_listP8emstreamE3__c_3>:
     5e2:	09 52 75 6e 73 00                                   .Runs.

000005e8 <_ZZ15print_task_listP8emstreamE3__c_2>:
     5e8:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000005f4 <_ZZ15print_task_listP8emstreamE3__c_1>:
     5f4:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000605 <_ZZ15print_task_listP8emstreamE3__c_0>:
     605:	09 53 74 61 63 6b 00                                .Stack.

0000060c <_ZZ15print_task_listP8emstreamE3__c>:
     60c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000617 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     617:	09 00                                               ..

00000619 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     619:	09 00                                               ..

0000061b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     61b:	2f 00                                               /.

0000061d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     61d:	09 00                                               ..

0000061f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     61f:	09 00                                               ..

00000621 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     621:	1b 5b 32 32 6d 00                                   .[22m.

00000627 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     627:	1b 5b 31 6d 00                                      .[1m.

0000062c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     62c:	1b 5b 31 6d 00                                      .[1m.

00000631 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     631:	20 20 00                                              .

00000634 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     634:	0e 94 ab 15 	call	0x2b56	; 0x2b56 <_ZN8frt_task22_call_users_run_methodEPS_>

00000638 <__ctors_start>:
     638:	bb 21       	and	r27, r11

0000063a <__ctors_end>:
     63a:	11 24       	eor	r1, r1
     63c:	1f be       	out	0x3f, r1	; 63
     63e:	cf ef       	ldi	r28, 0xFF	; 255
     640:	cd bf       	out	0x3d, r28	; 61
     642:	df e3       	ldi	r29, 0x3F	; 63
     644:	de bf       	out	0x3e, r29	; 62
     646:	00 e0       	ldi	r16, 0x00	; 0
     648:	0c bf       	out	0x3c, r16	; 60
     64a:	18 be       	out	0x38, r1	; 56
     64c:	19 be       	out	0x39, r1	; 57
     64e:	1a be       	out	0x3a, r1	; 58
     650:	1b be       	out	0x3b, r1	; 59

00000652 <__do_copy_data>:
     652:	11 e2       	ldi	r17, 0x21	; 33
     654:	a0 e0       	ldi	r26, 0x00	; 0
     656:	b0 e2       	ldi	r27, 0x20	; 32
     658:	ee e5       	ldi	r30, 0x5E	; 94
     65a:	f6 e4       	ldi	r31, 0x46	; 70
     65c:	00 e0       	ldi	r16, 0x00	; 0
     65e:	0b bf       	out	0x3b, r16	; 59
     660:	02 c0       	rjmp	.+4      	; 0x666 <__do_copy_data+0x14>
     662:	07 90       	elpm	r0, Z+
     664:	0d 92       	st	X+, r0
     666:	a6 35       	cpi	r26, 0x56	; 86
     668:	b1 07       	cpc	r27, r17
     66a:	d9 f7       	brne	.-10     	; 0x662 <__do_copy_data+0x10>
     66c:	1b be       	out	0x3b, r1	; 59

0000066e <__do_clear_bss>:
     66e:	22 e3       	ldi	r18, 0x32	; 50
     670:	a6 e5       	ldi	r26, 0x56	; 86
     672:	b1 e2       	ldi	r27, 0x21	; 33
     674:	01 c0       	rjmp	.+2      	; 0x678 <.do_clear_bss_start>

00000676 <.do_clear_bss_loop>:
     676:	1d 92       	st	X+, r1

00000678 <.do_clear_bss_start>:
     678:	a4 32       	cpi	r26, 0x24	; 36
     67a:	b2 07       	cpc	r27, r18
     67c:	e1 f7       	brne	.-8      	; 0x676 <.do_clear_bss_loop>

0000067e <__do_global_ctors>:
     67e:	13 e0       	ldi	r17, 0x03	; 3
     680:	cd e1       	ldi	r28, 0x1D	; 29
     682:	d3 e0       	ldi	r29, 0x03	; 3
     684:	00 e0       	ldi	r16, 0x00	; 0
     686:	06 c0       	rjmp	.+12     	; 0x694 <__do_global_ctors+0x16>
     688:	21 97       	sbiw	r28, 0x01	; 1
     68a:	01 09       	sbc	r16, r1
     68c:	80 2f       	mov	r24, r16
     68e:	fe 01       	movw	r30, r28
     690:	0e 94 89 22 	call	0x4512	; 0x4512 <__tablejump2__>
     694:	cc 31       	cpi	r28, 0x1C	; 28
     696:	d1 07       	cpc	r29, r17
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	08 07       	cpc	r16, r24
     69c:	a9 f7       	brne	.-22     	; 0x688 <__do_global_ctors+0xa>
     69e:	0e 94 37 21 	call	0x426e	; 0x426e <main>
     6a2:	0c 94 2d 23 	jmp	0x465a	; 0x465a <_exit>

000006a6 <__bad_interrupt>:
     6a6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006aa <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6aa:	bc 01       	movw	r22, r24
     6ac:	6e 5f       	subi	r22, 0xFE	; 254
     6ae:	7f 4f       	sbci	r23, 0xFF	; 255
     6b0:	dc 01       	movw	r26, r24
     6b2:	ed 91       	ld	r30, X+
     6b4:	fc 91       	ld	r31, X
     6b6:	00 84       	ldd	r0, Z+8	; 0x08
     6b8:	f1 85       	ldd	r31, Z+9	; 0x09
     6ba:	e0 2d       	mov	r30, r0
     6bc:	19 95       	eicall
     6be:	08 95       	ret

000006c0 <_ZN8I2CAgent11resetPacketER6Packet>:
}

void I2CAgent::resetPacket( Packet & packet )
{
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	eb 01       	movw	r28, r22
  while( packet.not_empty() )
     6c6:	e8 81       	ld	r30, Y
     6c8:	f9 81       	ldd	r31, Y+1	; 0x01
     6ca:	00 8c       	ldd	r0, Z+24	; 0x18
     6cc:	f1 8d       	ldd	r31, Z+25	; 0x19
     6ce:	e0 2d       	mov	r30, r0
     6d0:	ce 01       	movw	r24, r28
     6d2:	19 95       	eicall
     6d4:	88 23       	and	r24, r24
     6d6:	41 f0       	breq	.+16     	; 0x6e8 <_ZN8I2CAgent11resetPacketER6Packet+0x28>
  {
    packet.get();
     6d8:	e8 81       	ld	r30, Y
     6da:	f9 81       	ldd	r31, Y+1	; 0x01
     6dc:	00 84       	ldd	r0, Z+8	; 0x08
     6de:	f1 85       	ldd	r31, Z+9	; 0x09
     6e0:	e0 2d       	mov	r30, r0
     6e2:	ce 01       	movw	r24, r28
     6e4:	19 95       	eicall
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
  while( packet.not_empty() )
     6e6:	ef cf       	rjmp	.-34     	; 0x6c6 <_ZN8I2CAgent11resetPacketER6Packet+0x6>
  {
    packet.get();
  }
}
     6e8:	df 91       	pop	r29
     6ea:	cf 91       	pop	r28
     6ec:	08 95       	ret

000006ee <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6f4:	e8 81       	ld	r30, Y
     6f6:	f9 81       	ldd	r31, Y+1	; 0x01
     6f8:	04 80       	ldd	r0, Z+4	; 0x04
     6fa:	f5 81       	ldd	r31, Z+5	; 0x05
     6fc:	e0 2d       	mov	r30, r0
     6fe:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     700:	be 01       	movw	r22, r28
     702:	63 5f       	subi	r22, 0xF3	; 243
     704:	7f 4f       	sbci	r23, 0xFF	; 255

  };
  
  I2CMaster(TWI_t * interface, uint32_t i2c_freq);

  Transmitter * getTransmitter() { return transmitter_; }
     706:	e8 8d       	ldd	r30, Y+24	; 0x18
     708:	f9 8d       	ldd	r31, Y+25	; 0x19
     70a:	80 81       	ld	r24, Z
     70c:	91 81       	ldd	r25, Z+1	; 0x01
     70e:	0e 94 0a 05 	call	0xa14	; 0xa14 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     712:	df 91       	pop	r29
     714:	cf 91       	pop	r28
     716:	08 95       	ret

00000718 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     718:	ef 92       	push	r14
     71a:	ff 92       	push	r15
     71c:	0f 93       	push	r16
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     724:	7c 01       	movw	r14, r24
     726:	82 e0       	ldi	r24, 0x02	; 2
     728:	e8 0e       	add	r14, r24
     72a:	f1 1c       	adc	r15, r1
     72c:	e8 81       	ld	r30, Y
     72e:	f9 81       	ldd	r31, Y+1	; 0x01
     730:	00 84       	ldd	r0, Z+8	; 0x08
     732:	f1 85       	ldd	r31, Z+9	; 0x09
     734:	e0 2d       	mov	r30, r0
     736:	b7 01       	movw	r22, r14
     738:	ce 01       	movw	r24, r28
     73a:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     73c:	28 85       	ldd	r18, Y+8	; 0x08
     73e:	39 85       	ldd	r19, Y+9	; 0x09
     740:	4a 85       	ldd	r20, Y+10	; 0x0a
     742:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     744:	be 01       	movw	r22, r28
     746:	64 5e       	subi	r22, 0xE4	; 228
     748:	7f 4f       	sbci	r23, 0xFF	; 255
     74a:	00 e0       	ldi	r16, 0x00	; 0
     74c:	8e 81       	ldd	r24, Y+6	; 0x06
     74e:	9f 81       	ldd	r25, Y+7	; 0x07
     750:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
  Receiver *    getReceiver()    { return receiver_; }
     754:	e8 8d       	ldd	r30, Y+24	; 0x18
     756:	f9 8d       	ldd	r31, Y+25	; 0x19
  return driver_->getReceiver()->run(inPacket_);
     758:	b7 01       	movw	r22, r14
     75a:	82 81       	ldd	r24, Z+2	; 0x02
     75c:	93 81       	ldd	r25, Z+3	; 0x03
     75e:	0e 94 31 05 	call	0xa62	; 0xa62 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     762:	df 91       	pop	r29
     764:	cf 91       	pop	r28
     766:	0f 91       	pop	r16
     768:	ff 90       	pop	r15
     76a:	ef 90       	pop	r14
     76c:	08 95       	ret

0000076e <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     76e:	cf 92       	push	r12
     770:	df 92       	push	r13
     772:	ef 92       	push	r14
     774:	ff 92       	push	r15
     776:	0f 93       	push	r16
     778:	cf 93       	push	r28
     77a:	df 93       	push	r29
     77c:	ec 01       	movw	r28, r24
     77e:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     780:	6c 01       	movw	r12, r24
     782:	8d e0       	ldi	r24, 0x0D	; 13
     784:	c8 0e       	add	r12, r24
     786:	d1 1c       	adc	r13, r1
     788:	e8 81       	ld	r30, Y
     78a:	f9 81       	ldd	r31, Y+1	; 0x01
     78c:	00 84       	ldd	r0, Z+8	; 0x08
     78e:	f1 85       	ldd	r31, Z+9	; 0x09
     790:	e0 2d       	mov	r30, r0
     792:	b6 01       	movw	r22, r12
     794:	ce 01       	movw	r24, r28
     796:	19 95       	eicall
     798:	2b 89       	ldd	r18, Y+19	; 0x13
     79a:	3c 89       	ldd	r19, Y+20	; 0x14
     79c:	4d 89       	ldd	r20, Y+21	; 0x15
     79e:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7a0:	be 01       	movw	r22, r28
     7a2:	65 5e       	subi	r22, 0xE5	; 229
     7a4:	7f 4f       	sbci	r23, 0xFF	; 255
     7a6:	00 e0       	ldi	r16, 0x00	; 0
     7a8:	89 89       	ldd	r24, Y+17	; 0x11
     7aa:	9a 89       	ldd	r25, Y+18	; 0x12
     7ac:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7b0:	d7 01       	movw	r26, r14
     7b2:	ed 91       	ld	r30, X+
     7b4:	fc 91       	ld	r31, X
     7b6:	01 90       	ld	r0, Z+
     7b8:	f0 81       	ld	r31, Z
     7ba:	e0 2d       	mov	r30, r0
     7bc:	b6 01       	movw	r22, r12
     7be:	c7 01       	movw	r24, r14
     7c0:	19 95       	eicall
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	0f 91       	pop	r16
     7c8:	ff 90       	pop	r15
     7ca:	ef 90       	pop	r14
     7cc:	df 90       	pop	r13
     7ce:	cf 90       	pop	r12
     7d0:	08 95       	ret

000007d2 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7d2:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7d4:	62 8f       	std	Z+26, r22	; 0x1a
  writeCommand_ = addr << 1;
     7d6:	86 2f       	mov	r24, r22
     7d8:	88 0f       	add	r24, r24
     7da:	83 8f       	std	Z+27, r24	; 0x1b
  readCommand_ = addr << 1 | 1 << 0;
     7dc:	68 2f       	mov	r22, r24
     7de:	61 60       	ori	r22, 0x01	; 1
     7e0:	64 8f       	std	Z+28, r22	; 0x1c
     7e2:	08 95       	ret

000007e4 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>:
{
  startState_->setTransition(statusState_, statusState_);
  statusState_->setTransition(exchangeState_, errorState_);
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
  packetStatusState_->setTransition(doneState_, statusState_);
}
     7e4:	0f 93       	push	r16
     7e6:	1f 93       	push	r17
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ec 01       	movw	r28, r24
     7ee:	cb 01       	movw	r24, r22
     7f0:	0f 81       	ldd	r16, Y+7	; 0x07
     7f2:	18 85       	ldd	r17, Y+8	; 0x08
     7f4:	db 01       	movw	r26, r22
     7f6:	ed 91       	ld	r30, X+
     7f8:	fc 91       	ld	r31, X
     7fa:	00 84       	ldd	r0, Z+8	; 0x08
     7fc:	f1 85       	ldd	r31, Z+9	; 0x09
     7fe:	e0 2d       	mov	r30, r0
     800:	19 95       	eicall
     802:	f8 01       	movw	r30, r16
     804:	86 83       	std	Z+6, r24	; 0x06
     806:	8a 81       	ldd	r24, Y+2	; 0x02
     808:	9b 81       	ldd	r25, Y+3	; 0x03
     80a:	df 91       	pop	r29
     80c:	cf 91       	pop	r28
     80e:	1f 91       	pop	r17
     810:	0f 91       	pop	r16
     812:	08 95       	ret

00000814 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     814:	cf 93       	push	r28
     816:	df 93       	push	r29
     818:	1f 92       	push	r1
     81a:	1f 92       	push	r1
     81c:	cd b7       	in	r28, 0x3d	; 61
     81e:	de b7       	in	r29, 0x3e	; 62
     820:	dc 01       	movw	r26, r24
     822:	19 96       	adiw	r26, 0x09	; 9
     824:	8d 91       	ld	r24, X+
     826:	9c 91       	ld	r25, X
     828:	1a 97       	sbiw	r26, 0x0a	; 10
     82a:	89 83       	std	Y+1, r24	; 0x01
     82c:	9a 83       	std	Y+2, r25	; 0x02
     82e:	29 81       	ldd	r18, Y+1	; 0x01
     830:	3a 81       	ldd	r19, Y+2	; 0x02
     832:	21 50       	subi	r18, 0x01	; 1
     834:	31 09       	sbc	r19, r1
     836:	29 83       	std	Y+1, r18	; 0x01
     838:	3a 83       	std	Y+2, r19	; 0x02
     83a:	23 2b       	or	r18, r19
     83c:	91 f0       	breq	.+36     	; 0x862 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     83e:	17 96       	adiw	r26, 0x07	; 7
     840:	ed 91       	ld	r30, X+
     842:	fc 91       	ld	r31, X
     844:	18 97       	sbiw	r26, 0x08	; 8
     846:	94 81       	ldd	r25, Z+4	; 0x04
     848:	90 75       	andi	r25, 0x50	; 80
     84a:	89 f7       	brne	.-30     	; 0x82e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
     84c:	0a c0       	rjmp	.+20     	; 0x862 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     84e:	14 96       	adiw	r26, 0x04	; 4
     850:	8d 91       	ld	r24, X+
     852:	9c 91       	ld	r25, X
     854:	15 97       	sbiw	r26, 0x05	; 5
     856:	0a c0       	rjmp	.+20     	; 0x86c <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     858:	12 96       	adiw	r26, 0x02	; 2
     85a:	8d 91       	ld	r24, X+
     85c:	9c 91       	ld	r25, X
     85e:	13 97       	sbiw	r26, 0x03	; 3
     860:	05 c0       	rjmp	.+10     	; 0x86c <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     862:	29 81       	ldd	r18, Y+1	; 0x01
     864:	3a 81       	ldd	r19, Y+2	; 0x02
     866:	23 2b       	or	r18, r19
     868:	b9 f7       	brne	.-18     	; 0x858 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     86a:	f1 cf       	rjmp	.-30     	; 0x84e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3a>
     86c:	0f 90       	pop	r0
     86e:	0f 90       	pop	r0
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	08 95       	ret

00000876 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     876:	ef 92       	push	r14
     878:	ff 92       	push	r15
     87a:	0f 93       	push	r16
     87c:	1f 93       	push	r17
     87e:	cf 93       	push	r28
     880:	df 93       	push	r29
     882:	8c 01       	movw	r16, r24
     884:	eb 01       	movw	r28, r22
     886:	e8 81       	ld	r30, Y
     888:	f9 81       	ldd	r31, Y+1	; 0x01
     88a:	00 8c       	ldd	r0, Z+24	; 0x18
     88c:	f1 8d       	ldd	r31, Z+25	; 0x19
     88e:	e0 2d       	mov	r30, r0
     890:	cb 01       	movw	r24, r22
     892:	19 95       	eicall
     894:	88 23       	and	r24, r24
     896:	61 f0       	breq	.+24     	; 0x8b0 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x3a>
     898:	f8 01       	movw	r30, r16
     89a:	e7 80       	ldd	r14, Z+7	; 0x07
     89c:	f0 84       	ldd	r15, Z+8	; 0x08
     89e:	e8 81       	ld	r30, Y
     8a0:	f9 81       	ldd	r31, Y+1	; 0x01
     8a2:	00 84       	ldd	r0, Z+8	; 0x08
     8a4:	f1 85       	ldd	r31, Z+9	; 0x09
     8a6:	e0 2d       	mov	r30, r0
     8a8:	ce 01       	movw	r24, r28
     8aa:	19 95       	eicall
     8ac:	f7 01       	movw	r30, r14
     8ae:	87 83       	std	Z+7, r24	; 0x07
     8b0:	f8 01       	movw	r30, r16
     8b2:	82 81       	ldd	r24, Z+2	; 0x02
     8b4:	93 81       	ldd	r25, Z+3	; 0x03
     8b6:	df 91       	pop	r29
     8b8:	cf 91       	pop	r28
     8ba:	1f 91       	pop	r17
     8bc:	0f 91       	pop	r16
     8be:	ff 90       	pop	r15
     8c0:	ef 90       	pop	r14
     8c2:	08 95       	ret

000008c4 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	ec 01       	movw	r28, r24
     8ca:	cb 01       	movw	r24, r22
     8cc:	db 01       	movw	r26, r22
     8ce:	ed 91       	ld	r30, X+
     8d0:	fc 91       	ld	r31, X
     8d2:	04 88       	ldd	r0, Z+20	; 0x14
     8d4:	f5 89       	ldd	r31, Z+21	; 0x15
     8d6:	e0 2d       	mov	r30, r0
     8d8:	19 95       	eicall
     8da:	88 23       	and	r24, r24
     8dc:	19 f0       	breq	.+6      	; 0x8e4 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     8de:	8a 81       	ldd	r24, Y+2	; 0x02
     8e0:	9b 81       	ldd	r25, Y+3	; 0x03
     8e2:	02 c0       	rjmp	.+4      	; 0x8e8 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     8e4:	8c 81       	ldd	r24, Y+4	; 0x04
     8e6:	9d 81       	ldd	r25, Y+5	; 0x05
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	08 95       	ret

000008ee <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>:
     8ee:	fc 01       	movw	r30, r24
     8f0:	82 81       	ldd	r24, Z+2	; 0x02
     8f2:	93 81       	ldd	r25, Z+3	; 0x03
     8f4:	08 95       	ret

000008f6 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>:
     8f6:	fc 01       	movw	r30, r24
     8f8:	82 81       	ldd	r24, Z+2	; 0x02
     8fa:	93 81       	ldd	r25, Z+3	; 0x03
     8fc:	08 95       	ret

000008fe <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
     906:	ec 01       	movw	r28, r24
     908:	8b 01       	movw	r16, r22
     90a:	89 e0       	ldi	r24, 0x09	; 9
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     912:	fc 01       	movw	r30, r24
     914:	16 82       	std	Z+6, r1	; 0x06
     916:	88 e1       	ldi	r24, 0x18	; 24
     918:	90 e2       	ldi	r25, 0x20	; 32
     91a:	80 83       	st	Z, r24
     91c:	91 83       	std	Z+1, r25	; 0x01
     91e:	07 83       	std	Z+7, r16	; 0x07
     920:	10 87       	std	Z+8, r17	; 0x08
     922:	ea 83       	std	Y+2, r30	; 0x02
     924:	fb 83       	std	Y+3, r31	; 0x03
     926:	8b e0       	ldi	r24, 0x0B	; 11
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     92e:	fc 01       	movw	r30, r24
     930:	89 89       	ldd	r24, Y+17	; 0x11
     932:	9a 89       	ldd	r25, Y+18	; 0x12
     934:	16 82       	std	Z+6, r1	; 0x06
     936:	2e e1       	ldi	r18, 0x1E	; 30
     938:	30 e2       	ldi	r19, 0x20	; 32
     93a:	20 83       	st	Z, r18
     93c:	31 83       	std	Z+1, r19	; 0x01
     93e:	07 83       	std	Z+7, r16	; 0x07
     940:	10 87       	std	Z+8, r17	; 0x08
     942:	81 87       	std	Z+9, r24	; 0x09
     944:	92 87       	std	Z+10, r25	; 0x0a
     946:	ec 83       	std	Y+4, r30	; 0x04
     948:	fd 83       	std	Y+5, r31	; 0x05
     94a:	89 e0       	ldi	r24, 0x09	; 9
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     952:	fc 01       	movw	r30, r24
     954:	16 82       	std	Z+6, r1	; 0x06
     956:	84 e2       	ldi	r24, 0x24	; 36
     958:	90 e2       	ldi	r25, 0x20	; 32
     95a:	80 83       	st	Z, r24
     95c:	91 83       	std	Z+1, r25	; 0x01
     95e:	07 83       	std	Z+7, r16	; 0x07
     960:	10 87       	std	Z+8, r17	; 0x08
     962:	ee 83       	std	Y+6, r30	; 0x06
     964:	ff 83       	std	Y+7, r31	; 0x07
     966:	89 e0       	ldi	r24, 0x09	; 9
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     96e:	fc 01       	movw	r30, r24
     970:	16 82       	std	Z+6, r1	; 0x06
     972:	8a e2       	ldi	r24, 0x2A	; 42
     974:	90 e2       	ldi	r25, 0x20	; 32
     976:	80 83       	st	Z, r24
     978:	91 83       	std	Z+1, r25	; 0x01
     97a:	07 83       	std	Z+7, r16	; 0x07
     97c:	10 87       	std	Z+8, r17	; 0x08
     97e:	e8 87       	std	Y+8, r30	; 0x08
     980:	f9 87       	std	Y+9, r31	; 0x09
     982:	89 e0       	ldi	r24, 0x09	; 9
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     98a:	fc 01       	movw	r30, r24
     98c:	16 82       	std	Z+6, r1	; 0x06
     98e:	86 e3       	ldi	r24, 0x36	; 54
     990:	90 e2       	ldi	r25, 0x20	; 32
     992:	80 83       	st	Z, r24
     994:	91 83       	std	Z+1, r25	; 0x01
     996:	07 83       	std	Z+7, r16	; 0x07
     998:	10 87       	std	Z+8, r17	; 0x08
     99a:	ea 87       	std	Y+10, r30	; 0x0a
     99c:	fb 87       	std	Y+11, r31	; 0x0b
     99e:	89 e0       	ldi	r24, 0x09	; 9
     9a0:	90 e0       	ldi	r25, 0x00	; 0
     9a2:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     9a6:	fc 01       	movw	r30, r24
     9a8:	16 82       	std	Z+6, r1	; 0x06
     9aa:	80 e3       	ldi	r24, 0x30	; 48
     9ac:	90 e2       	ldi	r25, 0x20	; 32
     9ae:	80 83       	st	Z, r24
     9b0:	91 83       	std	Z+1, r25	; 0x01
     9b2:	07 83       	std	Z+7, r16	; 0x07
     9b4:	10 87       	std	Z+8, r17	; 0x08
     9b6:	ec 87       	std	Y+12, r30	; 0x0c
     9b8:	fd 87       	std	Y+13, r31	; 0x0d
     9ba:	80 e1       	ldi	r24, 0x10	; 16
     9bc:	97 e2       	ldi	r25, 0x27	; 39
     9be:	89 8b       	std	Y+17, r24	; 0x11
     9c0:	9a 8b       	std	Y+18, r25	; 0x12
     9c2:	8c 81       	ldd	r24, Y+4	; 0x04
     9c4:	9d 81       	ldd	r25, Y+5	; 0x05
     9c6:	ea 81       	ldd	r30, Y+2	; 0x02
     9c8:	fb 81       	ldd	r31, Y+3	; 0x03
     9ca:	82 83       	std	Z+2, r24	; 0x02
     9cc:	93 83       	std	Z+3, r25	; 0x03
     9ce:	84 83       	std	Z+4, r24	; 0x04
     9d0:	95 83       	std	Z+5, r25	; 0x05
     9d2:	8a 85       	ldd	r24, Y+10	; 0x0a
     9d4:	9b 85       	ldd	r25, Y+11	; 0x0b
     9d6:	2e 81       	ldd	r18, Y+6	; 0x06
     9d8:	3f 81       	ldd	r19, Y+7	; 0x07
     9da:	ec 81       	ldd	r30, Y+4	; 0x04
     9dc:	fd 81       	ldd	r31, Y+5	; 0x05
     9de:	22 83       	std	Z+2, r18	; 0x02
     9e0:	33 83       	std	Z+3, r19	; 0x03
     9e2:	84 83       	std	Z+4, r24	; 0x04
     9e4:	95 83       	std	Z+5, r25	; 0x05
     9e6:	88 85       	ldd	r24, Y+8	; 0x08
     9e8:	99 85       	ldd	r25, Y+9	; 0x09
     9ea:	ee 81       	ldd	r30, Y+6	; 0x06
     9ec:	ff 81       	ldd	r31, Y+7	; 0x07
     9ee:	82 83       	std	Z+2, r24	; 0x02
     9f0:	93 83       	std	Z+3, r25	; 0x03
     9f2:	84 83       	std	Z+4, r24	; 0x04
     9f4:	95 83       	std	Z+5, r25	; 0x05
     9f6:	8c 81       	ldd	r24, Y+4	; 0x04
     9f8:	9d 81       	ldd	r25, Y+5	; 0x05
     9fa:	2c 85       	ldd	r18, Y+12	; 0x0c
     9fc:	3d 85       	ldd	r19, Y+13	; 0x0d
     9fe:	e8 85       	ldd	r30, Y+8	; 0x08
     a00:	f9 85       	ldd	r31, Y+9	; 0x09
     a02:	22 83       	std	Z+2, r18	; 0x02
     a04:	33 83       	std	Z+3, r19	; 0x03
     a06:	84 83       	std	Z+4, r24	; 0x04
     a08:	95 83       	std	Z+5, r25	; 0x05
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	08 95       	ret

00000a14 <_ZN9I2CMaster11Transmitter3runER6Packet>:

bool I2CMaster::Transmitter::run( Packet & packet )
{
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	ec 01       	movw	r28, r24
     a1e:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     a20:	8a 81       	ldd	r24, Y+2	; 0x02
     a22:	9b 81       	ldd	r25, Y+3	; 0x03
     a24:	88 83       	st	Y, r24
     a26:	99 83       	std	Y+1, r25	; 0x01
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     a28:	88 81       	ld	r24, Y
     a2a:	99 81       	ldd	r25, Y+1	; 0x01
     a2c:	2c 85       	ldd	r18, Y+12	; 0x0c
     a2e:	3d 85       	ldd	r19, Y+13	; 0x0d
     a30:	82 17       	cp	r24, r18
     a32:	93 07       	cpc	r25, r19
     a34:	29 f4       	brne	.+10     	; 0xa40 <_ZN9I2CMaster11Transmitter3runER6Packet+0x2c>
     a36:	2a 85       	ldd	r18, Y+10	; 0x0a
     a38:	3b 85       	ldd	r19, Y+11	; 0x0b
     a3a:	82 17       	cp	r24, r18
     a3c:	93 07       	cpc	r25, r19
     a3e:	59 f0       	breq	.+22     	; 0xa56 <_ZN9I2CMaster11Transmitter3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     a40:	dc 01       	movw	r26, r24
     a42:	ed 91       	ld	r30, X+
     a44:	fc 91       	ld	r31, X
     a46:	01 90       	ld	r0, Z+
     a48:	f0 81       	ld	r31, Z
     a4a:	e0 2d       	mov	r30, r0
     a4c:	b8 01       	movw	r22, r16
     a4e:	19 95       	eicall
     a50:	88 83       	st	Y, r24
     a52:	99 83       	std	Y+1, r25	; 0x01

bool I2CMaster::Transmitter::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     a54:	e9 cf       	rjmp	.-46     	; 0xa28 <_ZN9I2CMaster11Transmitter3runER6Packet+0x14>
  }
  else
  {
    return false;
  }
}
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	1f 91       	pop	r17
     a5e:	0f 91       	pop	r16
     a60:	08 95       	ret

00000a62 <_ZN9I2CMaster8Receiver3runER6Packet>:

Packet & I2CMaster::Receiver::run( Packet & packet )
{
     a62:	0f 93       	push	r16
     a64:	1f 93       	push	r17
     a66:	cf 93       	push	r28
     a68:	df 93       	push	r29
     a6a:	ec 01       	movw	r28, r24
     a6c:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     a6e:	8a 81       	ldd	r24, Y+2	; 0x02
     a70:	9b 81       	ldd	r25, Y+3	; 0x03
     a72:	88 83       	st	Y, r24
     a74:	99 83       	std	Y+1, r25	; 0x01
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     a76:	88 81       	ld	r24, Y
     a78:	99 81       	ldd	r25, Y+1	; 0x01
     a7a:	2c 85       	ldd	r18, Y+12	; 0x0c
     a7c:	3d 85       	ldd	r19, Y+13	; 0x0d
     a7e:	82 17       	cp	r24, r18
     a80:	93 07       	cpc	r25, r19
     a82:	29 f4       	brne	.+10     	; 0xa8e <_ZN9I2CMaster8Receiver3runER6Packet+0x2c>
     a84:	2a 85       	ldd	r18, Y+10	; 0x0a
     a86:	3b 85       	ldd	r19, Y+11	; 0x0b
     a88:	82 17       	cp	r24, r18
     a8a:	93 07       	cpc	r25, r19
     a8c:	59 f0       	breq	.+22     	; 0xaa4 <_ZN9I2CMaster8Receiver3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     a8e:	dc 01       	movw	r26, r24
     a90:	ed 91       	ld	r30, X+
     a92:	fc 91       	ld	r31, X
     a94:	01 90       	ld	r0, Z+
     a96:	f0 81       	ld	r31, Z
     a98:	e0 2d       	mov	r30, r0
     a9a:	b8 01       	movw	r22, r16
     a9c:	19 95       	eicall
     a9e:	88 83       	st	Y, r24
     aa0:	99 83       	std	Y+1, r25	; 0x01

Packet & I2CMaster::Receiver::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     aa2:	e9 cf       	rjmp	.-46     	; 0xa76 <_ZN9I2CMaster8Receiver3runER6Packet+0x14>
  {
    currentState_ = currentState_->execute(packet);
  }

  return packet;
}
     aa4:	c8 01       	movw	r24, r16
     aa6:	df 91       	pop	r29
     aa8:	cf 91       	pop	r28
     aaa:	1f 91       	pop	r17
     aac:	0f 91       	pop	r16
     aae:	08 95       	ret

00000ab0 <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     ab0:	cf 93       	push	r28
     ab2:	df 93       	push	r29
     ab4:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     ab6:	9a 01       	movw	r18, r20
     ab8:	ab 01       	movw	r20, r22
     aba:	22 0f       	add	r18, r18
     abc:	33 1f       	adc	r19, r19
     abe:	44 1f       	adc	r20, r20
     ac0:	55 1f       	adc	r21, r21
     ac2:	60 e0       	ldi	r22, 0x00	; 0
     ac4:	78 e4       	ldi	r23, 0x48	; 72
     ac6:	88 ee       	ldi	r24, 0xE8	; 232
     ac8:	91 e0       	ldi	r25, 0x01	; 1
     aca:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
     ace:	25 50       	subi	r18, 0x05	; 5
     ad0:	28 87       	std	Y+8, r18	; 0x08
  interface->MASTER.BAUD = baudrate;
     ad2:	ec 81       	ldd	r30, Y+4	; 0x04
     ad4:	fd 81       	ldd	r31, Y+5	; 0x05
     ad6:	25 83       	std	Z+5, r18	; 0x05
}
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	08 95       	ret

00000ade <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t* interface, uint32_t i2c_freq)
     ade:	af 92       	push	r10
     ae0:	bf 92       	push	r11
     ae2:	cf 92       	push	r12
     ae4:	df 92       	push	r13
     ae6:	ef 92       	push	r14
     ae8:	ff 92       	push	r15
     aea:	0f 93       	push	r16
     aec:	1f 93       	push	r17
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	8c 01       	movw	r16, r24
     af4:	eb 01       	movw	r28, r22
     af6:	69 01       	movw	r12, r18
     af8:	7a 01       	movw	r14, r20
  : interface(interface), 
    i2c_freq(i2c_freq),
    transmitter_( new Transmitter(interface) )
     afa:	83 e1       	ldi	r24, 0x13	; 19
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     b02:	5c 01       	movw	r10, r24
     b04:	be 01       	movw	r22, r28
     b06:	0e 94 7f 04 	call	0x8fe	; 0x8fe <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     b0a:	d8 01       	movw	r26, r16
     b0c:	ad 92       	st	X+, r10
     b0e:	bc 92       	st	X, r11
     b10:	11 97       	sbiw	r26, 0x01	; 1
     b12:	14 96       	adiw	r26, 0x04	; 4
     b14:	cd 93       	st	X+, r28
     b16:	dc 93       	st	X, r29
     b18:	15 97       	sbiw	r26, 0x05	; 5
     b1a:	f8 01       	movw	r30, r16
     b1c:	c1 86       	std	Z+9, r12	; 0x09
     b1e:	d2 86       	std	Z+10, r13	; 0x0a
     b20:	e3 86       	std	Z+11, r14	; 0x0b
     b22:	f4 86       	std	Z+12, r15	; 0x0c
{ 
  if (interface == &TWIC)
     b24:	c0 38       	cpi	r28, 0x80	; 128
     b26:	f4 e0       	ldi	r31, 0x04	; 4
     b28:	df 07       	cpc	r29, r31
     b2a:	39 f4       	brne	.+14     	; 0xb3a <_ZN9I2CMasterC1EP10TWI_structm+0x5c>
  {
    bus_port = &PORTC;
     b2c:	80 e4       	ldi	r24, 0x40	; 64
     b2e:	96 e0       	ldi	r25, 0x06	; 6
     b30:	16 96       	adiw	r26, 0x06	; 6
     b32:	8d 93       	st	X+, r24
     b34:	9c 93       	st	X, r25
     b36:	17 97       	sbiw	r26, 0x07	; 7
     b38:	09 c0       	rjmp	.+18     	; 0xb4c <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  }
  if (interface == &TWIE)
     b3a:	c0 3a       	cpi	r28, 0xA0	; 160
     b3c:	b4 e0       	ldi	r27, 0x04	; 4
     b3e:	db 07       	cpc	r29, r27
     b40:	29 f4       	brne	.+10     	; 0xb4c <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  {
    bus_port = &PORTE;
     b42:	80 e8       	ldi	r24, 0x80	; 128
     b44:	96 e0       	ldi	r25, 0x06	; 6
     b46:	f8 01       	movw	r30, r16
     b48:	86 83       	std	Z+6, r24	; 0x06
     b4a:	97 83       	std	Z+7, r25	; 0x07
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     b4c:	d8 01       	movw	r26, r16
     b4e:	16 96       	adiw	r26, 0x06	; 6
     b50:	ed 91       	ld	r30, X+
     b52:	fc 91       	ld	r31, X
     b54:	17 97       	sbiw	r26, 0x07	; 7
     b56:	83 e0       	ldi	r24, 0x03	; 3
     b58:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     b5a:	16 96       	adiw	r26, 0x06	; 6
     b5c:	ed 91       	ld	r30, X+
     b5e:	fc 91       	ld	r31, X
     b60:	17 97       	sbiw	r26, 0x07	; 7
     b62:	88 e3       	ldi	r24, 0x38	; 56
     b64:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     b66:	16 96       	adiw	r26, 0x06	; 6
     b68:	ed 91       	ld	r30, X+
     b6a:	fc 91       	ld	r31, X
     b6c:	17 97       	sbiw	r26, 0x07	; 7
     b6e:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     b70:	82 e0       	ldi	r24, 0x02	; 2
     b72:	8a 83       	std	Y+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     b74:	b7 01       	movw	r22, r14
     b76:	a6 01       	movw	r20, r12
     b78:	c8 01       	movw	r24, r16
     b7a:	0e 94 58 05 	call	0xab0	; 0xab0 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     b7e:	8c 81       	ldd	r24, Y+4	; 0x04
     b80:	8d 6c       	ori	r24, 0xCD	; 205
     b82:	8c 83       	std	Y+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     b84:	88 e0       	ldi	r24, 0x08	; 8
     b86:	89 83       	std	Y+1, r24	; 0x01
}
     b88:	df 91       	pop	r29
     b8a:	cf 91       	pop	r28
     b8c:	1f 91       	pop	r17
     b8e:	0f 91       	pop	r16
     b90:	ff 90       	pop	r15
     b92:	ef 90       	pop	r14
     b94:	df 90       	pop	r13
     b96:	cf 90       	pop	r12
     b98:	bf 90       	pop	r11
     b9a:	af 90       	pop	r10
     b9c:	08 95       	ret

00000b9e <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return driver_->is_ready(slaveAddr_);
}
     b9e:	db 01       	movw	r26, r22
     ba0:	bc 01       	movw	r22, r24
     ba2:	6e 5f       	subi	r22, 0xFE	; 254
     ba4:	7f 4f       	sbci	r23, 0xFF	; 255
     ba6:	ed 91       	ld	r30, X+
     ba8:	fc 91       	ld	r31, X
     baa:	11 97       	sbiw	r26, 0x01	; 1
     bac:	01 90       	ld	r0, Z+
     bae:	f0 81       	ld	r31, Z
     bb0:	e0 2d       	mov	r30, r0
     bb2:	cd 01       	movw	r24, r26
     bb4:	19 95       	eicall
     bb6:	08 95       	ret

00000bb8 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
     bb8:	fc 01       	movw	r30, r24
     bba:	84 81       	ldd	r24, Z+4	; 0x04
     bbc:	95 81       	ldd	r25, Z+5	; 0x05
     bbe:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
     bc2:	90 e0       	ldi	r25, 0x00	; 0
     bc4:	08 95       	ret

00000bc6 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
     bc6:	fc 01       	movw	r30, r24
     bc8:	84 81       	ldd	r24, Z+4	; 0x04
     bca:	95 81       	ldd	r25, Z+5	; 0x05
     bcc:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
     bd0:	91 e0       	ldi	r25, 0x01	; 1
     bd2:	81 11       	cpse	r24, r1
     bd4:	01 c0       	rjmp	.+2      	; 0xbd8 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	89 2f       	mov	r24, r25
     bda:	08 95       	ret

00000bdc <_ZN9frt_queueIhE12ISR_is_emptyEv>:
     bdc:	fc 01       	movw	r30, r24
     bde:	84 81       	ldd	r24, Z+4	; 0x04
     be0:	95 81       	ldd	r25, Z+5	; 0x05
     be2:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
     be6:	91 e0       	ldi	r25, 0x01	; 1
     be8:	81 11       	cpse	r24, r1
     bea:	90 e0       	ldi	r25, 0x00	; 0
     bec:	89 2f       	mov	r24, r25
     bee:	08 95       	ret

00000bf0 <_ZN9frt_queueIhE12num_items_inEv>:
     bf0:	fc 01       	movw	r30, r24
     bf2:	84 81       	ldd	r24, Z+4	; 0x04
     bf4:	95 81       	ldd	r25, Z+5	; 0x05
     bf6:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	08 95       	ret

00000bfe <_ZN9frt_queueIhE9not_emptyEv>:
     bfe:	fc 01       	movw	r30, r24
     c00:	84 81       	ldd	r24, Z+4	; 0x04
     c02:	95 81       	ldd	r25, Z+5	; 0x05
     c04:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
     c08:	91 e0       	ldi	r25, 0x01	; 1
     c0a:	81 11       	cpse	r24, r1
     c0c:	01 c0       	rjmp	.+2      	; 0xc10 <_ZN9frt_queueIhE9not_emptyEv+0x12>
     c0e:	90 e0       	ldi	r25, 0x00	; 0
     c10:	89 2f       	mov	r24, r25
     c12:	08 95       	ret

00000c14 <_ZN9frt_queueIhE8is_emptyEv>:
     c14:	fc 01       	movw	r30, r24
     c16:	84 81       	ldd	r24, Z+4	; 0x04
     c18:	95 81       	ldd	r25, Z+5	; 0x05
     c1a:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
     c1e:	91 e0       	ldi	r25, 0x01	; 1
     c20:	81 11       	cpse	r24, r1
     c22:	90 e0       	ldi	r25, 0x00	; 0
     c24:	89 2f       	mov	r24, r25
     c26:	08 95       	ret

00000c28 <_ZN9frt_queueIhE10get_a_copyERh>:
     c28:	0f 93       	push	r16
     c2a:	01 e0       	ldi	r16, 0x01	; 1
     c2c:	2f ef       	ldi	r18, 0xFF	; 255
     c2e:	3f ef       	ldi	r19, 0xFF	; 255
     c30:	a9 01       	movw	r20, r18
     c32:	fc 01       	movw	r30, r24
     c34:	84 81       	ldd	r24, Z+4	; 0x04
     c36:	95 81       	ldd	r25, Z+5	; 0x05
     c38:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
     c3c:	0f 91       	pop	r16
     c3e:	08 95       	ret

00000c40 <_ZN9frt_queueIhE10get_a_copyEv>:
     c40:	0f 93       	push	r16
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
     c46:	1f 92       	push	r1
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	01 e0       	ldi	r16, 0x01	; 1
     c4e:	2f ef       	ldi	r18, 0xFF	; 255
     c50:	3f ef       	ldi	r19, 0xFF	; 255
     c52:	a9 01       	movw	r20, r18
     c54:	be 01       	movw	r22, r28
     c56:	6f 5f       	subi	r22, 0xFF	; 255
     c58:	7f 4f       	sbci	r23, 0xFF	; 255
     c5a:	fc 01       	movw	r30, r24
     c5c:	84 81       	ldd	r24, Z+4	; 0x04
     c5e:	95 81       	ldd	r25, Z+5	; 0x05
     c60:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	0f 90       	pop	r0
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	0f 91       	pop	r16
     c6e:	08 95       	ret

00000c70 <_ZN9frt_queueIhE3getEPh>:
     c70:	0f 93       	push	r16
     c72:	00 e0       	ldi	r16, 0x00	; 0
     c74:	2f ef       	ldi	r18, 0xFF	; 255
     c76:	3f ef       	ldi	r19, 0xFF	; 255
     c78:	a9 01       	movw	r20, r18
     c7a:	fc 01       	movw	r30, r24
     c7c:	84 81       	ldd	r24, Z+4	; 0x04
     c7e:	95 81       	ldd	r25, Z+5	; 0x05
     c80:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
     c84:	0f 91       	pop	r16
     c86:	08 95       	ret

00000c88 <_ZN9frt_queueIhE3getEv>:
     c88:	0f 93       	push	r16
     c8a:	cf 93       	push	r28
     c8c:	df 93       	push	r29
     c8e:	1f 92       	push	r1
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	00 e0       	ldi	r16, 0x00	; 0
     c96:	2f ef       	ldi	r18, 0xFF	; 255
     c98:	3f ef       	ldi	r19, 0xFF	; 255
     c9a:	a9 01       	movw	r20, r18
     c9c:	be 01       	movw	r22, r28
     c9e:	6f 5f       	subi	r22, 0xFF	; 255
     ca0:	7f 4f       	sbci	r23, 0xFF	; 255
     ca2:	fc 01       	movw	r30, r24
     ca4:	84 81       	ldd	r24, Z+4	; 0x04
     ca6:	95 81       	ldd	r25, Z+5	; 0x05
     ca8:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
     cac:	89 81       	ldd	r24, Y+1	; 0x01
     cae:	0f 90       	pop	r0
     cb0:	df 91       	pop	r29
     cb2:	cf 91       	pop	r28
     cb4:	0f 91       	pop	r16
     cb6:	08 95       	ret

00000cb8 <_ZN9frt_queueIhE7ISR_getEPh>:
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	1f 92       	push	r1
     cbe:	cd b7       	in	r28, 0x3d	; 61
     cc0:	de b7       	in	r29, 0x3e	; 62
     cc2:	ae 01       	movw	r20, r28
     cc4:	4f 5f       	subi	r20, 0xFF	; 255
     cc6:	5f 4f       	sbci	r21, 0xFF	; 255
     cc8:	fc 01       	movw	r30, r24
     cca:	84 81       	ldd	r24, Z+4	; 0x04
     ccc:	95 81       	ldd	r25, Z+5	; 0x05
     cce:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
     cd2:	0f 90       	pop	r0
     cd4:	df 91       	pop	r29
     cd6:	cf 91       	pop	r28
     cd8:	08 95       	ret

00000cda <_ZN9frt_queueIhE7ISR_getEv>:
     cda:	cf 93       	push	r28
     cdc:	df 93       	push	r29
     cde:	1f 92       	push	r1
     ce0:	1f 92       	push	r1
     ce2:	cd b7       	in	r28, 0x3d	; 61
     ce4:	de b7       	in	r29, 0x3e	; 62
     ce6:	ae 01       	movw	r20, r28
     ce8:	4e 5f       	subi	r20, 0xFE	; 254
     cea:	5f 4f       	sbci	r21, 0xFF	; 255
     cec:	be 01       	movw	r22, r28
     cee:	6f 5f       	subi	r22, 0xFF	; 255
     cf0:	7f 4f       	sbci	r23, 0xFF	; 255
     cf2:	fc 01       	movw	r30, r24
     cf4:	84 81       	ldd	r24, Z+4	; 0x04
     cf6:	95 81       	ldd	r25, Z+5	; 0x05
     cf8:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
     cfc:	89 81       	ldd	r24, Y+1	; 0x01
     cfe:	0f 90       	pop	r0
     d00:	0f 90       	pop	r0
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	08 95       	ret

00000d08 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
     d08:	cf 93       	push	r28
     d0a:	df 93       	push	r29
     d0c:	1f 92       	push	r1
     d0e:	cd b7       	in	r28, 0x3d	; 61
     d10:	de b7       	in	r29, 0x3e	; 62
     d12:	19 82       	std	Y+1, r1	; 0x01
     d14:	21 e0       	ldi	r18, 0x01	; 1
     d16:	ae 01       	movw	r20, r28
     d18:	4f 5f       	subi	r20, 0xFF	; 255
     d1a:	5f 4f       	sbci	r21, 0xFF	; 255
     d1c:	fc 01       	movw	r30, r24
     d1e:	84 81       	ldd	r24, Z+4	; 0x04
     d20:	95 81       	ldd	r25, Z+5	; 0x05
     d22:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
     d26:	91 e0       	ldi	r25, 0x01	; 1
     d28:	81 11       	cpse	r24, r1
     d2a:	01 c0       	rjmp	.+2      	; 0xd2e <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
     d2c:	90 e0       	ldi	r25, 0x00	; 0
     d2e:	89 2f       	mov	r24, r25
     d30:	0f 90       	pop	r0
     d32:	df 91       	pop	r29
     d34:	cf 91       	pop	r28
     d36:	08 95       	ret

00000d38 <_ZN9frt_queueIhE7ISR_putERKh>:
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	1f 92       	push	r1
     d3e:	cd b7       	in	r28, 0x3d	; 61
     d40:	de b7       	in	r29, 0x3e	; 62
     d42:	19 82       	std	Y+1, r1	; 0x01
     d44:	20 e0       	ldi	r18, 0x00	; 0
     d46:	ae 01       	movw	r20, r28
     d48:	4f 5f       	subi	r20, 0xFF	; 255
     d4a:	5f 4f       	sbci	r21, 0xFF	; 255
     d4c:	fc 01       	movw	r30, r24
     d4e:	84 81       	ldd	r24, Z+4	; 0x04
     d50:	95 81       	ldd	r25, Z+5	; 0x05
     d52:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
     d56:	91 e0       	ldi	r25, 0x01	; 1
     d58:	81 11       	cpse	r24, r1
     d5a:	01 c0       	rjmp	.+2      	; 0xd5e <_ZN9frt_queueIhE7ISR_putERKh+0x26>
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	89 2f       	mov	r24, r25
     d60:	0f 90       	pop	r0
     d62:	df 91       	pop	r29
     d64:	cf 91       	pop	r28
     d66:	08 95       	ret

00000d68 <_ZN9frt_queueIhE7butt_inERKh>:
     d68:	0f 93       	push	r16
     d6a:	fc 01       	movw	r30, r24
     d6c:	26 81       	ldd	r18, Z+6	; 0x06
     d6e:	37 81       	ldd	r19, Z+7	; 0x07
     d70:	40 85       	ldd	r20, Z+8	; 0x08
     d72:	51 85       	ldd	r21, Z+9	; 0x09
     d74:	01 e0       	ldi	r16, 0x01	; 1
     d76:	84 81       	ldd	r24, Z+4	; 0x04
     d78:	95 81       	ldd	r25, Z+5	; 0x05
     d7a:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
     d7e:	91 e0       	ldi	r25, 0x01	; 1
     d80:	81 11       	cpse	r24, r1
     d82:	01 c0       	rjmp	.+2      	; 0xd86 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	89 2f       	mov	r24, r25
     d88:	0f 91       	pop	r16
     d8a:	08 95       	ret

00000d8c <_ZN9frt_queueIhE3putERKh>:
     d8c:	0f 93       	push	r16
     d8e:	fc 01       	movw	r30, r24
     d90:	26 81       	ldd	r18, Z+6	; 0x06
     d92:	37 81       	ldd	r19, Z+7	; 0x07
     d94:	40 85       	ldd	r20, Z+8	; 0x08
     d96:	51 85       	ldd	r21, Z+9	; 0x09
     d98:	00 e0       	ldi	r16, 0x00	; 0
     d9a:	84 81       	ldd	r24, Z+4	; 0x04
     d9c:	95 81       	ldd	r25, Z+5	; 0x05
     d9e:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
     da2:	91 e0       	ldi	r25, 0x01	; 1
     da4:	81 11       	cpse	r24, r1
     da6:	01 c0       	rjmp	.+2      	; 0xdaa <_ZN9frt_queueIhE3putERKh+0x1e>
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	89 2f       	mov	r24, r25
     dac:	0f 91       	pop	r16
     dae:	08 95       	ret

00000db0 <_ZN6MB1202C1EP9I2CMaster>:
     db0:	4f 92       	push	r4
     db2:	5f 92       	push	r5
     db4:	6f 92       	push	r6
     db6:	7f 92       	push	r7
     db8:	8f 92       	push	r8
     dba:	9f 92       	push	r9
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	df 92       	push	r13
     dc2:	ef 92       	push	r14
     dc4:	ff 92       	push	r15
     dc6:	0f 93       	push	r16
     dc8:	1f 93       	push	r17
     dca:	cf 93       	push	r28
     dcc:	df 93       	push	r29
     dce:	8c 01       	movw	r16, r24
     dd0:	7b 01       	movw	r14, r22
     dd2:	dc 01       	movw	r26, r24
     dd4:	6d 93       	st	X+, r22
     dd6:	7c 93       	st	X, r23
     dd8:	8d e1       	ldi	r24, 0x1D	; 29
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     de0:	ec 01       	movw	r28, r24
     de2:	84 e8       	ldi	r24, 0x84	; 132
     de4:	90 e2       	ldi	r25, 0x20	; 32
     de6:	88 83       	st	Y, r24
     de8:	99 83       	std	Y+1, r25	; 0x01
     dea:	1c 82       	std	Y+4, r1	; 0x04
     dec:	1d 82       	std	Y+5, r1	; 0x05
     dee:	0f 2e       	mov	r0, r31
     df0:	fc e3       	ldi	r31, 0x3C	; 60
     df2:	8f 2e       	mov	r8, r31
     df4:	f0 e2       	ldi	r31, 0x20	; 32
     df6:	9f 2e       	mov	r9, r31
     df8:	f0 2d       	mov	r31, r0
     dfa:	8a 82       	std	Y+2, r8	; 0x02
     dfc:	9b 82       	std	Y+3, r9	; 0x03
     dfe:	40 e0       	ldi	r20, 0x00	; 0
     e00:	61 e0       	ldi	r22, 0x01	; 1
     e02:	82 e0       	ldi	r24, 0x02	; 2
     e04:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
     e08:	8e 83       	std	Y+6, r24	; 0x06
     e0a:	9f 83       	std	Y+7, r25	; 0x07
     e0c:	0f 2e       	mov	r0, r31
     e0e:	fa e0       	ldi	r31, 0x0A	; 10
     e10:	4f 2e       	mov	r4, r31
     e12:	51 2c       	mov	r5, r1
     e14:	61 2c       	mov	r6, r1
     e16:	71 2c       	mov	r7, r1
     e18:	f0 2d       	mov	r31, r0
     e1a:	48 86       	std	Y+8, r4	; 0x08
     e1c:	59 86       	std	Y+9, r5	; 0x09
     e1e:	6a 86       	std	Y+10, r6	; 0x0a
     e20:	7b 86       	std	Y+11, r7	; 0x0b
     e22:	0f 2e       	mov	r0, r31
     e24:	f0 e6       	ldi	r31, 0x60	; 96
     e26:	af 2e       	mov	r10, r31
     e28:	f0 e2       	ldi	r31, 0x20	; 32
     e2a:	bf 2e       	mov	r11, r31
     e2c:	f0 2d       	mov	r31, r0
     e2e:	aa 82       	std	Y+2, r10	; 0x02
     e30:	bb 82       	std	Y+3, r11	; 0x03
     e32:	68 94       	set
     e34:	dd 24       	eor	r13, r13
     e36:	d1 f8       	bld	r13, 1
     e38:	dc 86       	std	Y+12, r13	; 0x0c
     e3a:	1f 86       	std	Y+15, r1	; 0x0f
     e3c:	18 8a       	std	Y+16, r1	; 0x10
     e3e:	8d 86       	std	Y+13, r8	; 0x0d
     e40:	9e 86       	std	Y+14, r9	; 0x0e
     e42:	40 e0       	ldi	r20, 0x00	; 0
     e44:	61 e0       	ldi	r22, 0x01	; 1
     e46:	82 e0       	ldi	r24, 0x02	; 2
     e48:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
     e4c:	89 8b       	std	Y+17, r24	; 0x11
     e4e:	9a 8b       	std	Y+18, r25	; 0x12
     e50:	4b 8a       	std	Y+19, r4	; 0x13
     e52:	5c 8a       	std	Y+20, r5	; 0x14
     e54:	6d 8a       	std	Y+21, r6	; 0x15
     e56:	7e 8a       	std	Y+22, r7	; 0x16
     e58:	ad 86       	std	Y+13, r10	; 0x0d
     e5a:	be 86       	std	Y+14, r11	; 0x0e
     e5c:	df 8a       	std	Y+23, r13	; 0x17
     e5e:	8a e0       	ldi	r24, 0x0A	; 10
     e60:	90 e2       	ldi	r25, 0x20	; 32
     e62:	88 83       	st	Y, r24
     e64:	99 83       	std	Y+1, r25	; 0x01
     e66:	f8 01       	movw	r30, r16
     e68:	c2 83       	std	Z+2, r28	; 0x02
     e6a:	d3 83       	std	Z+3, r29	; 0x03
     e6c:	80 e7       	ldi	r24, 0x70	; 112
     e6e:	84 83       	std	Z+4, r24	; 0x04
     e70:	16 82       	std	Z+6, r1	; 0x06
     e72:	17 82       	std	Z+7, r1	; 0x07
     e74:	10 86       	std	Z+8, r1	; 0x08
     e76:	11 86       	std	Z+9, r1	; 0x09
     e78:	12 86       	std	Z+10, r1	; 0x0a
     e7a:	83 e0       	ldi	r24, 0x03	; 3
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
     e82:	22 e9       	ldi	r18, 0x92	; 146
     e84:	30 e2       	ldi	r19, 0x20	; 32
     e86:	fc 01       	movw	r30, r24
     e88:	20 83       	st	Z, r18
     e8a:	31 83       	std	Z+1, r19	; 0x01
     e8c:	c1 e5       	ldi	r28, 0x51	; 81
     e8e:	c2 83       	std	Z+2, r28	; 0x02
     e90:	d8 01       	movw	r26, r16
     e92:	1d 96       	adiw	r26, 0x0d	; 13
     e94:	8d 93       	st	X+, r24
     e96:	9c 93       	st	X, r25
     e98:	1e 97       	sbiw	r26, 0x0e	; 14
     e9a:	12 96       	adiw	r26, 0x02	; 2
     e9c:	ed 91       	ld	r30, X+
     e9e:	fc 91       	ld	r31, X
     ea0:	13 97       	sbiw	r26, 0x03	; 3
     ea2:	e0 8e       	std	Z+24, r14	; 0x18
     ea4:	f1 8e       	std	Z+25, r15	; 0x19
     ea6:	14 96       	adiw	r26, 0x04	; 4
     ea8:	6c 91       	ld	r22, X
     eaa:	14 97       	sbiw	r26, 0x04	; 4
     eac:	12 96       	adiw	r26, 0x02	; 2
     eae:	8d 91       	ld	r24, X+
     eb0:	9c 91       	ld	r25, X
     eb2:	13 97       	sbiw	r26, 0x03	; 3
     eb4:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <_ZN8I2CAgent12setSlaveAddrEh>
     eb8:	f8 01       	movw	r30, r16
     eba:	c5 83       	std	Z+5, r28	; 0x05
     ebc:	8a ea       	ldi	r24, 0xAA	; 170
     ebe:	86 83       	std	Z+6, r24	; 0x06
     ec0:	85 ea       	ldi	r24, 0xA5	; 165
     ec2:	87 83       	std	Z+7, r24	; 0x07
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	1f 91       	pop	r17
     eca:	0f 91       	pop	r16
     ecc:	ff 90       	pop	r15
     ece:	ef 90       	pop	r14
     ed0:	df 90       	pop	r13
     ed2:	bf 90       	pop	r11
     ed4:	af 90       	pop	r10
     ed6:	9f 90       	pop	r9
     ed8:	8f 90       	pop	r8
     eda:	7f 90       	pop	r7
     edc:	6f 90       	pop	r6
     ede:	5f 90       	pop	r5
     ee0:	4f 90       	pop	r4
     ee2:	08 95       	ret

00000ee4 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
	return i2cAgent_->transmit(*rangeCommand_);
     ee4:	fc 01       	movw	r30, r24
     ee6:	a2 81       	ldd	r26, Z+2	; 0x02
     ee8:	b3 81       	ldd	r27, Z+3	; 0x03
     eea:	65 85       	ldd	r22, Z+13	; 0x0d
     eec:	76 85       	ldd	r23, Z+14	; 0x0e
     eee:	ed 91       	ld	r30, X+
     ef0:	fc 91       	ld	r31, X
     ef2:	11 97       	sbiw	r26, 0x01	; 1
     ef4:	01 90       	ld	r0, Z+
     ef6:	f0 81       	ld	r31, Z
     ef8:	e0 2d       	mov	r30, r0
     efa:	cd 01       	movw	r24, r26
     efc:	19 95       	eicall
}
     efe:	08 95       	ret

00000f00 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     f00:	ff 92       	push	r15
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
     f0c:	8a 81       	ldd	r24, Y+2	; 0x02
     f0e:	9b 81       	ldd	r25, Y+3	; 0x03
     f10:	dc 01       	movw	r26, r24
     f12:	ed 91       	ld	r30, X+
     f14:	fc 91       	ld	r31, X
     f16:	02 80       	ldd	r0, Z+2	; 0x02
     f18:	f3 81       	ldd	r31, Z+3	; 0x03
     f1a:	e0 2d       	mov	r30, r0
     f1c:	19 95       	eicall
     f1e:	8c 01       	movw	r16, r24
	range_reading = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
     f20:	dc 01       	movw	r26, r24
     f22:	ed 91       	ld	r30, X+
     f24:	fc 91       	ld	r31, X
     f26:	00 84       	ldd	r0, Z+8	; 0x08
     f28:	f1 85       	ldd	r31, Z+9	; 0x09
     f2a:	e0 2d       	mov	r30, r0
     f2c:	19 95       	eicall
     f2e:	f8 2e       	mov	r15, r24
     f30:	d8 01       	movw	r26, r16
     f32:	ed 91       	ld	r30, X+
     f34:	fc 91       	ld	r31, X
     f36:	00 84       	ldd	r0, Z+8	; 0x08
     f38:	f1 85       	ldd	r31, Z+9	; 0x09
     f3a:	e0 2d       	mov	r30, r0
     f3c:	c8 01       	movw	r24, r16
     f3e:	19 95       	eicall
     f40:	2f 2d       	mov	r18, r15
     f42:	30 e0       	ldi	r19, 0x00	; 0
     f44:	32 2f       	mov	r19, r18
     f46:	22 27       	eor	r18, r18
     f48:	a9 01       	movw	r20, r18
     f4a:	48 2b       	or	r20, r24
     f4c:	ca 01       	movw	r24, r20
     f4e:	8b 87       	std	Y+11, r24	; 0x0b
     f50:	9c 87       	std	Y+12, r25	; 0x0c
	return range_reading;
}
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	1f 91       	pop	r17
     f58:	0f 91       	pop	r16
     f5a:	ff 90       	pop	r15
     f5c:	08 95       	ret

00000f5e <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     f5e:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     f60:	8c 85       	ldd	r24, Y+12	; 0x0c
     f62:	88 23       	and	r24, r24
     f64:	19 f0       	breq	.+6      	; 0xf6c <_ZN10task_sonar3runEv+0xe>
     f66:	81 30       	cpi	r24, 0x01	; 1
     f68:	51 f0       	breq	.+20     	; 0xf7e <_ZN10task_sonar3runEv+0x20>
     f6a:	25 c0       	rjmp	.+74     	; 0xfb6 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     f6c:	8c 89       	ldd	r24, Y+20	; 0x14
     f6e:	9d 89       	ldd	r25, Y+21	; 0x15
     f70:	0e 94 72 07 	call	0xee4	; 0xee4 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     f74:	61 e0       	ldi	r22, 0x01	; 1
     f76:	ce 01       	movw	r24, r28
     f78:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <_ZN8frt_task13transition_toEh>
			
			    break;
     f7c:	1c c0       	rjmp	.+56     	; 0xfb6 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     f7e:	8c 89       	ldd	r24, Y+20	; 0x14
     f80:	9d 89       	ldd	r25, Y+21	; 0x15
     f82:	0e 94 80 07 	call	0xf00	; 0xf00 <_ZN6MB120211get_readingEv>
     f86:	7c 01       	movw	r14, r24
     f88:	8a 8b       	std	Y+18, r24	; 0x12
     f8a:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     f8c:	6a e0       	ldi	r22, 0x0A	; 10
     f8e:	8e 81       	ldd	r24, Y+6	; 0x06
     f90:	9f 81       	ldd	r25, Y+7	; 0x07
     f92:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
     f96:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     f98:	6a e7       	ldi	r22, 0x7A	; 122
     f9a:	73 e0       	ldi	r23, 0x03	; 3
     f9c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
     fa0:	b7 01       	movw	r22, r14
     fa2:	c8 01       	movw	r24, r16
     fa4:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
     fa8:	66 e0       	ldi	r22, 0x06	; 6
     faa:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     fae:	60 e0       	ldi	r22, 0x00	; 0
     fb0:	ce 01       	movw	r24, r28
     fb2:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     fb6:	8e 85       	ldd	r24, Y+14	; 0x0e
     fb8:	9f 85       	ldd	r25, Y+15	; 0x0f
     fba:	a8 89       	ldd	r26, Y+16	; 0x10
     fbc:	b9 89       	ldd	r27, Y+17	; 0x11
     fbe:	01 96       	adiw	r24, 0x01	; 1
     fc0:	a1 1d       	adc	r26, r1
     fc2:	b1 1d       	adc	r27, r1
     fc4:	8e 87       	std	Y+14, r24	; 0x0e
     fc6:	9f 87       	std	Y+15, r25	; 0x0f
     fc8:	a8 8b       	std	Y+16, r26	; 0x10
     fca:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     fcc:	64 ef       	ldi	r22, 0xF4	; 244
     fce:	71 e0       	ldi	r23, 0x01	; 1
     fd0:	80 e0       	ldi	r24, 0x00	; 0
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	0e 94 8e 13 	call	0x271c	; 0x271c <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     fd8:	c3 cf       	rjmp	.-122    	; 0xf60 <_ZN10task_sonar3runEv+0x2>

00000fda <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     fda:	cf 92       	push	r12
     fdc:	df 92       	push	r13
     fde:	ef 92       	push	r14
     fe0:	ff 92       	push	r15
     fe2:	0f 93       	push	r16
     fe4:	1f 93       	push	r17
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	ec 01       	movw	r28, r24
     fec:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     fee:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <_ZN8frt_taskC1EPKchjP8emstream>
     ff2:	88 e9       	ldi	r24, 0x98	; 152
     ff4:	90 e2       	ldi	r25, 0x20	; 32
     ff6:	88 83       	st	Y, r24
     ff8:	99 83       	std	Y+1, r25	; 0x01
     ffa:	ec 8a       	std	Y+20, r14	; 0x14
     ffc:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     ffe:	ce 8a       	std	Y+22, r12	; 0x16
    1000:	df 8a       	std	Y+23, r13	; 0x17
}
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	ef 90       	pop	r14
    100e:	df 90       	pop	r13
    1010:	cf 90       	pop	r12
    1012:	08 95       	ret

00001014 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1014:	0f 93       	push	r16
    1016:	1f 93       	push	r17
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    101e:	0e 94 be 15 	call	0x2b7c	; 0x2b7c <_ZN8frt_taskC1EPKchjP8emstream>
    1022:	80 ea       	ldi	r24, 0xA0	; 160
    1024:	90 e2       	ldi	r25, 0x20	; 32
    1026:	88 83       	st	Y, r24
    1028:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	1f 91       	pop	r17
    1030:	0f 91       	pop	r16
    1032:	08 95       	ret

00001034 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1034:	0f 93       	push	r16
    1036:	1f 93       	push	r17
    1038:	cf 93       	push	r28
    103a:	df 93       	push	r29
    103c:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    103e:	6a e0       	ldi	r22, 0x0A	; 10
    1040:	8e 81       	ldd	r24, Y+6	; 0x06
    1042:	9f 81       	ldd	r25, Y+7	; 0x07
    1044:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1048:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    104a:	65 ed       	ldi	r22, 0xD5	; 213
    104c:	74 e0       	ldi	r23, 0x04	; 4
    104e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1052:	6a e0       	ldi	r22, 0x0A	; 10
    1054:	c8 01       	movw	r24, r16
    1056:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    105a:	8c 01       	movw	r16, r24
    105c:	6f ec       	ldi	r22, 0xCF	; 207
    105e:	74 e0       	ldi	r23, 0x04	; 4
    1060:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1064:	67 e0       	ldi	r22, 0x07	; 7
    1066:	c8 01       	movw	r24, r16
    1068:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    106c:	6a e0       	ldi	r22, 0x0A	; 10
    106e:	8e 81       	ldd	r24, Y+6	; 0x06
    1070:	9f 81       	ldd	r25, Y+7	; 0x07
    1072:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1076:	8c 01       	movw	r16, r24
    1078:	60 eb       	ldi	r22, 0xB0	; 176
    107a:	74 e0       	ldi	r23, 0x04	; 4
    107c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1080:	6a e0       	ldi	r22, 0x0A	; 10
    1082:	c8 01       	movw	r24, r16
    1084:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1088:	8c 01       	movw	r16, r24
    108a:	6a ea       	ldi	r22, 0xAA	; 170
    108c:	74 e0       	ldi	r23, 0x04	; 4
    108e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1092:	66 e0       	ldi	r22, 0x06	; 6
    1094:	c8 01       	movw	r24, r16
    1096:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    109a:	6a e0       	ldi	r22, 0x0A	; 10
    109c:	8e 81       	ldd	r24, Y+6	; 0x06
    109e:	9f 81       	ldd	r25, Y+7	; 0x07
    10a0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    10a4:	8c 01       	movw	r16, r24
    10a6:	63 e9       	ldi	r22, 0x93	; 147
    10a8:	74 e0       	ldi	r23, 0x04	; 4
    10aa:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    10ae:	66 e0       	ldi	r22, 0x06	; 6
    10b0:	c8 01       	movw	r24, r16
    10b2:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    10b6:	6a e0       	ldi	r22, 0x0A	; 10
    10b8:	8e 81       	ldd	r24, Y+6	; 0x06
    10ba:	9f 81       	ldd	r25, Y+7	; 0x07
    10bc:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    10c0:	8c 01       	movw	r16, r24
    10c2:	67 e7       	ldi	r22, 0x77	; 119
    10c4:	74 e0       	ldi	r23, 0x04	; 4
    10c6:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    10ca:	66 e0       	ldi	r22, 0x06	; 6
    10cc:	c8 01       	movw	r24, r16
    10ce:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    10d2:	6a e0       	ldi	r22, 0x0A	; 10
    10d4:	8e 81       	ldd	r24, Y+6	; 0x06
    10d6:	9f 81       	ldd	r25, Y+7	; 0x07
    10d8:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    10dc:	8c 01       	movw	r16, r24
    10de:	6f e5       	ldi	r22, 0x5F	; 95
    10e0:	74 e0       	ldi	r23, 0x04	; 4
    10e2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    10e6:	66 e0       	ldi	r22, 0x06	; 6
    10e8:	c8 01       	movw	r24, r16
    10ea:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    10ee:	6a e0       	ldi	r22, 0x0A	; 10
    10f0:	8e 81       	ldd	r24, Y+6	; 0x06
    10f2:	9f 81       	ldd	r25, Y+7	; 0x07
    10f4:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    10f8:	8c 01       	movw	r16, r24
    10fa:	6e e3       	ldi	r22, 0x3E	; 62
    10fc:	74 e0       	ldi	r23, 0x04	; 4
    10fe:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1102:	66 e0       	ldi	r22, 0x06	; 6
    1104:	c8 01       	movw	r24, r16
    1106:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    110a:	6a e0       	ldi	r22, 0x0A	; 10
    110c:	8e 81       	ldd	r24, Y+6	; 0x06
    110e:	9f 81       	ldd	r25, Y+7	; 0x07
    1110:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1114:	8c 01       	movw	r16, r24
    1116:	67 e1       	ldi	r22, 0x17	; 23
    1118:	74 e0       	ldi	r23, 0x04	; 4
    111a:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    111e:	66 e0       	ldi	r22, 0x06	; 6
    1120:	c8 01       	movw	r24, r16
    1122:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1126:	6a e0       	ldi	r22, 0x0A	; 10
    1128:	8e 81       	ldd	r24, Y+6	; 0x06
    112a:	9f 81       	ldd	r25, Y+7	; 0x07
    112c:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1130:	8c 01       	movw	r16, r24
    1132:	69 ef       	ldi	r22, 0xF9	; 249
    1134:	73 e0       	ldi	r23, 0x03	; 3
    1136:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    113a:	66 e0       	ldi	r22, 0x06	; 6
    113c:	c8 01       	movw	r24, r16
    113e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1142:	6a e0       	ldi	r22, 0x0A	; 10
    1144:	8e 81       	ldd	r24, Y+6	; 0x06
    1146:	9f 81       	ldd	r25, Y+7	; 0x07
    1148:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    114c:	8c 01       	movw	r16, r24
    114e:	6e ed       	ldi	r22, 0xDE	; 222
    1150:	73 e0       	ldi	r23, 0x03	; 3
    1152:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1156:	66 e0       	ldi	r22, 0x06	; 6
    1158:	c8 01       	movw	r24, r16
    115a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    115e:	6a e0       	ldi	r22, 0x0A	; 10
    1160:	8e 81       	ldd	r24, Y+6	; 0x06
    1162:	9f 81       	ldd	r25, Y+7	; 0x07
    1164:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1168:	ec 01       	movw	r28, r24
    116a:	6f ec       	ldi	r22, 0xCF	; 207
    116c:	73 e0       	ldi	r23, 0x03	; 3
    116e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1172:	66 e0       	ldi	r22, 0x06	; 6
    1174:	ce 01       	movw	r24, r28
    1176:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
}
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	1f 91       	pop	r17
    1180:	0f 91       	pop	r16
    1182:	08 95       	ret

00001184 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1184:	af 92       	push	r10
    1186:	bf 92       	push	r11
    1188:	cf 92       	push	r12
    118a:	df 92       	push	r13
    118c:	ef 92       	push	r14
    118e:	ff 92       	push	r15
    1190:	0f 93       	push	r16
    1192:	1f 93       	push	r17
    1194:	cf 93       	push	r28
    1196:	df 93       	push	r29
    1198:	00 d0       	rcall	.+0      	; 0x119a <_ZN9task_user11show_statusEv+0x16>
    119a:	00 d0       	rcall	.+0      	; 0x119c <_ZN9task_user11show_statusEv+0x18>
    119c:	cd b7       	in	r28, 0x3d	; 61
    119e:	de b7       	in	r29, 0x3e	; 62
    11a0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    11a2:	19 82       	std	Y+1, r1	; 0x01
    11a4:	1a 82       	std	Y+2, r1	; 0x02
    11a6:	1b 82       	std	Y+3, r1	; 0x03
    11a8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    11aa:	1d 82       	std	Y+5, r1	; 0x05
    11ac:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    11ae:	0e 94 47 0b 	call	0x168e	; 0x168e <xPortGetFreeHeapSize>
    11b2:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    11b4:	ce 01       	movw	r24, r28
    11b6:	01 96       	adiw	r24, 0x01	; 1
    11b8:	0e 94 6f 19 	call	0x32de	; 0x32de <_ZN10time_stamp10set_to_nowEv>
    11bc:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    11be:	66 e0       	ldi	r22, 0x06	; 6
    11c0:	f8 01       	movw	r30, r16
    11c2:	86 81       	ldd	r24, Z+6	; 0x06
    11c4:	97 81       	ldd	r25, Z+7	; 0x07
    11c6:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    11ca:	6a e0       	ldi	r22, 0x0A	; 10
    11cc:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    11d0:	7c 01       	movw	r14, r24
    11d2:	60 eb       	ldi	r22, 0xB0	; 176
    11d4:	73 e0       	ldi	r23, 0x03	; 3
    11d6:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    11da:	6a e0       	ldi	r22, 0x0A	; 10
    11dc:	c7 01       	movw	r24, r14
    11de:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    11e2:	7c 01       	movw	r14, r24
    11e4:	64 ea       	ldi	r22, 0xA4	; 164
    11e6:	73 e0       	ldi	r23, 0x03	; 3
    11e8:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    11ec:	66 e0       	ldi	r22, 0x06	; 6
    11ee:	c7 01       	movw	r24, r14
    11f0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    11f4:	6a e0       	ldi	r22, 0x0A	; 10
    11f6:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    11fa:	7c 01       	movw	r14, r24
    11fc:	6d e9       	ldi	r22, 0x9D	; 157
    11fe:	73 e0       	ldi	r23, 0x03	; 3
    1200:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1204:	b5 01       	movw	r22, r10
    1206:	c7 01       	movw	r24, r14
    1208:	0e 94 13 19 	call	0x3226	; 0x3226 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    120c:	6a e0       	ldi	r22, 0x0A	; 10
    120e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1212:	7c 01       	movw	r14, r24
    1214:	6f e8       	ldi	r22, 0x8F	; 143
    1216:	73 e0       	ldi	r23, 0x03	; 3
    1218:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    121c:	b6 01       	movw	r22, r12
    121e:	c7 01       	movw	r24, r14
    1220:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    1224:	6a e0       	ldi	r22, 0x0A	; 10
    1226:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    122a:	7c 01       	movw	r14, r24
    122c:	6d e8       	ldi	r22, 0x8D	; 141
    122e:	73 e0       	ldi	r23, 0x03	; 3
    1230:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1234:	4f ef       	ldi	r20, 0xFF	; 255
    1236:	5f e0       	ldi	r21, 0x0F	; 15
    1238:	60 e0       	ldi	r22, 0x00	; 0
    123a:	70 e0       	ldi	r23, 0x00	; 0
    123c:	c7 01       	movw	r24, r14
    123e:	0e 94 9e 1b 	call	0x373c	; 0x373c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1242:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1246:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    124a:	6a e0       	ldi	r22, 0x0A	; 10
    124c:	f8 01       	movw	r30, r16
    124e:	86 81       	ldd	r24, Z+6	; 0x06
    1250:	97 81       	ldd	r25, Z+7	; 0x07
    1252:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1256:	7c 01       	movw	r14, r24
    1258:	62 e8       	ldi	r22, 0x82	; 130
    125a:	73 e0       	ldi	r23, 0x03	; 3
    125c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1260:	b6 01       	movw	r22, r12
    1262:	c7 01       	movw	r24, r14
    1264:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    1268:	66 e0       	ldi	r22, 0x06	; 6
    126a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    126e:	66 e0       	ldi	r22, 0x06	; 6
    1270:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1274:	f8 01       	movw	r30, r16
    1276:	86 81       	ldd	r24, Z+6	; 0x06
    1278:	97 81       	ldd	r25, Z+7	; 0x07
    127a:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <_Z15print_task_listP8emstream>
}
    127e:	26 96       	adiw	r28, 0x06	; 6
    1280:	cd bf       	out	0x3d, r28	; 61
    1282:	de bf       	out	0x3e, r29	; 62
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	ff 90       	pop	r15
    128e:	ef 90       	pop	r14
    1290:	df 90       	pop	r13
    1292:	cf 90       	pop	r12
    1294:	bf 90       	pop	r11
    1296:	af 90       	pop	r10
    1298:	08 95       	ret

0000129a <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
    129e:	00 d0       	rcall	.+0      	; 0x12a0 <_ZN9task_user3runEv+0x6>
    12a0:	00 d0       	rcall	.+0      	; 0x12a2 <_ZN9task_user3runEv+0x8>
    12a2:	cd b7       	in	r28, 0x3d	; 61
    12a4:	de b7       	in	r29, 0x3e	; 62
    12a6:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    12a8:	19 82       	std	Y+1, r1	; 0x01
    12aa:	1a 82       	std	Y+2, r1	; 0x02
    12ac:	1b 82       	std	Y+3, r1	; 0x03
    12ae:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    12b0:	1d 82       	std	Y+5, r1	; 0x05
    12b2:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    12b4:	6a e0       	ldi	r22, 0x0A	; 10
    12b6:	dc 01       	movw	r26, r24
    12b8:	16 96       	adiw	r26, 0x06	; 6
    12ba:	8d 91       	ld	r24, X+
    12bc:	9c 91       	ld	r25, X
    12be:	17 97       	sbiw	r26, 0x07	; 7
    12c0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    12c4:	7c 01       	movw	r14, r24
    12c6:	6e e1       	ldi	r22, 0x1E	; 30
    12c8:	75 e0       	ldi	r23, 0x05	; 5
    12ca:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    12ce:	66 e0       	ldi	r22, 0x06	; 6
    12d0:	c7 01       	movw	r24, r14
    12d2:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    12d6:	f8 01       	movw	r30, r16
    12d8:	84 85       	ldd	r24, Z+12	; 0x0c
    12da:	88 23       	and	r24, r24
    12dc:	21 f0       	breq	.+8      	; 0x12e6 <_ZN9task_user3runEv+0x4c>
    12de:	81 30       	cpi	r24, 0x01	; 1
    12e0:	09 f4       	brne	.+2      	; 0x12e4 <_ZN9task_user3runEv+0x4a>
    12e2:	5d c0       	rjmp	.+186    	; 0x139e <_ZN9task_user3runEv+0x104>
    12e4:	d8 c0       	rjmp	.+432    	; 0x1496 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    12e6:	86 81       	ldd	r24, Z+6	; 0x06
    12e8:	97 81       	ldd	r25, Z+7	; 0x07
    12ea:	dc 01       	movw	r26, r24
    12ec:	ed 91       	ld	r30, X+
    12ee:	fc 91       	ld	r31, X
    12f0:	04 80       	ldd	r0, Z+4	; 0x04
    12f2:	f5 81       	ldd	r31, Z+5	; 0x05
    12f4:	e0 2d       	mov	r30, r0
    12f6:	19 95       	eicall
    12f8:	88 23       	and	r24, r24
    12fa:	a9 f1       	breq	.+106    	; 0x1366 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    12fc:	f8 01       	movw	r30, r16
    12fe:	86 81       	ldd	r24, Z+6	; 0x06
    1300:	97 81       	ldd	r25, Z+7	; 0x07
    1302:	dc 01       	movw	r26, r24
    1304:	ed 91       	ld	r30, X+
    1306:	fc 91       	ld	r31, X
    1308:	06 80       	ldd	r0, Z+6	; 0x06
    130a:	f7 81       	ldd	r31, Z+7	; 0x07
    130c:	e0 2d       	mov	r30, r0
    130e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1310:	99 27       	eor	r25, r25
    1312:	81 30       	cpi	r24, 0x01	; 1
    1314:	91 05       	cpc	r25, r1
    1316:	f9 f0       	breq	.+62     	; 0x1356 <_ZN9task_user3runEv+0xbc>
    1318:	03 97       	sbiw	r24, 0x03	; 3
    131a:	09 f0       	breq	.+2      	; 0x131e <_ZN9task_user3runEv+0x84>
    131c:	d8 c0       	rjmp	.+432    	; 0x14ce <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    131e:	6a e0       	ldi	r22, 0x0A	; 10
    1320:	f8 01       	movw	r30, r16
    1322:	86 81       	ldd	r24, Z+6	; 0x06
    1324:	97 81       	ldd	r25, Z+7	; 0x07
    1326:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    132a:	8c 01       	movw	r16, r24
    132c:	60 e1       	ldi	r22, 0x10	; 16
    132e:	75 e0       	ldi	r23, 0x05	; 5
    1330:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1334:	66 e0       	ldi	r22, 0x06	; 6
    1336:	c8 01       	movw	r24, r16
    1338:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    133c:	93 e0       	ldi	r25, 0x03	; 3
    133e:	88 ed       	ldi	r24, 0xD8	; 216
    1340:	08 b6       	in	r0, 0x38	; 56
    1342:	18 be       	out	0x38, r1	; 56
    1344:	84 bf       	out	0x34, r24	; 52
    1346:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    134a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    134e:	81 fd       	sbrc	r24, 1
    1350:	fc cf       	rjmp	.-8      	; 0x134a <_ZN9task_user3runEv+0xb0>
    1352:	08 be       	out	0x38, r0	; 56
    1354:	ff cf       	rjmp	.-2      	; 0x1354 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1356:	c8 01       	movw	r24, r16
    1358:	0e 94 1a 08 	call	0x1034	; 0x1034 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    135c:	61 e0       	ldi	r22, 0x01	; 1
    135e:	c8 01       	movw	r24, r16
    1360:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <_ZN8frt_task13transition_toEh>
							break;
    1364:	b4 c0       	rjmp	.+360    	; 0x14ce <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1366:	82 e1       	ldi	r24, 0x12	; 18
    1368:	92 e3       	ldi	r25, 0x32	; 50
    136a:	0e 94 7b 18 	call	0x30f6	; 0x30f6 <_ZN14frt_text_queue14check_for_charEv>
    136e:	88 23       	and	r24, r24
    1370:	09 f4       	brne	.+2      	; 0x1374 <_ZN9task_user3runEv+0xda>
    1372:	ad c0       	rjmp	.+346    	; 0x14ce <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1374:	d8 01       	movw	r26, r16
    1376:	16 96       	adiw	r26, 0x06	; 6
    1378:	ed 91       	ld	r30, X+
    137a:	fc 91       	ld	r31, X
    137c:	17 97       	sbiw	r26, 0x07	; 7
    137e:	01 90       	ld	r0, Z+
    1380:	f0 81       	ld	r31, Z
    1382:	e0 2d       	mov	r30, r0
    1384:	e2 80       	ldd	r14, Z+2	; 0x02
    1386:	f3 80       	ldd	r15, Z+3	; 0x03
    1388:	82 e1       	ldi	r24, 0x12	; 18
    138a:	92 e3       	ldi	r25, 0x32	; 50
    138c:	0e 94 5d 18 	call	0x30ba	; 0x30ba <_ZN14frt_text_queue7getcharEv>
    1390:	68 2f       	mov	r22, r24
    1392:	f8 01       	movw	r30, r16
    1394:	86 81       	ldd	r24, Z+6	; 0x06
    1396:	97 81       	ldd	r25, Z+7	; 0x07
    1398:	f7 01       	movw	r30, r14
    139a:	19 95       	eicall
    139c:	98 c0       	rjmp	.+304    	; 0x14ce <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    139e:	86 81       	ldd	r24, Z+6	; 0x06
    13a0:	97 81       	ldd	r25, Z+7	; 0x07
    13a2:	dc 01       	movw	r26, r24
    13a4:	ed 91       	ld	r30, X+
    13a6:	fc 91       	ld	r31, X
    13a8:	04 80       	ldd	r0, Z+4	; 0x04
    13aa:	f5 81       	ldd	r31, Z+5	; 0x05
    13ac:	e0 2d       	mov	r30, r0
    13ae:	19 95       	eicall
    13b0:	88 23       	and	r24, r24
    13b2:	09 f4       	brne	.+2      	; 0x13b6 <_ZN9task_user3runEv+0x11c>
    13b4:	8c c0       	rjmp	.+280    	; 0x14ce <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    13b6:	f8 01       	movw	r30, r16
    13b8:	86 81       	ldd	r24, Z+6	; 0x06
    13ba:	97 81       	ldd	r25, Z+7	; 0x07
    13bc:	dc 01       	movw	r26, r24
    13be:	ed 91       	ld	r30, X+
    13c0:	fc 91       	ld	r31, X
    13c2:	06 80       	ldd	r0, Z+6	; 0x06
    13c4:	f7 81       	ldd	r31, Z+7	; 0x07
    13c6:	e0 2d       	mov	r30, r0
    13c8:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    13ca:	9c 01       	movw	r18, r24
    13cc:	33 27       	eor	r19, r19
    13ce:	28 36       	cpi	r18, 0x68	; 104
    13d0:	31 05       	cpc	r19, r1
    13d2:	59 f1       	breq	.+86     	; 0x142a <_ZN9task_user3runEv+0x190>
    13d4:	3c f4       	brge	.+14     	; 0x13e4 <_ZN9task_user3runEv+0x14a>
    13d6:	2b 31       	cpi	r18, 0x1B	; 27
    13d8:	31 05       	cpc	r19, r1
    13da:	59 f1       	breq	.+86     	; 0x1432 <_ZN9task_user3runEv+0x198>
    13dc:	25 36       	cpi	r18, 0x65	; 101
    13de:	31 05       	cpc	r19, r1
    13e0:	41 f1       	breq	.+80     	; 0x1432 <_ZN9task_user3runEv+0x198>
    13e2:	3b c0       	rjmp	.+118    	; 0x145a <_ZN9task_user3runEv+0x1c0>
    13e4:	23 37       	cpi	r18, 0x73	; 115
    13e6:	31 05       	cpc	r19, r1
    13e8:	c1 f0       	breq	.+48     	; 0x141a <_ZN9task_user3runEv+0x180>
    13ea:	26 37       	cpi	r18, 0x76	; 118
    13ec:	31 05       	cpc	r19, r1
    13ee:	89 f0       	breq	.+34     	; 0x1412 <_ZN9task_user3runEv+0x178>
    13f0:	2e 36       	cpi	r18, 0x6E	; 110
    13f2:	31 05       	cpc	r19, r1
    13f4:	91 f5       	brne	.+100    	; 0x145a <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    13f6:	ce 01       	movw	r24, r28
    13f8:	01 96       	adiw	r24, 0x01	; 1
    13fa:	0e 94 6f 19 	call	0x32de	; 0x32de <_ZN10time_stamp10set_to_nowEv>
    13fe:	bc 01       	movw	r22, r24
    1400:	f8 01       	movw	r30, r16
    1402:	86 81       	ldd	r24, Z+6	; 0x06
    1404:	97 81       	ldd	r25, Z+7	; 0x07
    1406:	0e 94 13 19 	call	0x3226	; 0x3226 <_ZlsR8emstreamR10time_stamp>
    140a:	66 e0       	ldi	r22, 0x06	; 6
    140c:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1410:	5e c0       	rjmp	.+188    	; 0x14ce <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1412:	c8 01       	movw	r24, r16
    1414:	0e 94 c2 08 	call	0x1184	; 0x1184 <_ZN9task_user11show_statusEv>
							break;
    1418:	5a c0       	rjmp	.+180    	; 0x14ce <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    141a:	d8 01       	movw	r26, r16
    141c:	16 96       	adiw	r26, 0x06	; 6
    141e:	8d 91       	ld	r24, X+
    1420:	9c 91       	ld	r25, X
    1422:	17 97       	sbiw	r26, 0x07	; 7
    1424:	0e 94 d3 16 	call	0x2da6	; 0x2da6 <_Z17print_task_stacksP8emstream>
							break;
    1428:	52 c0       	rjmp	.+164    	; 0x14ce <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    142a:	c8 01       	movw	r24, r16
    142c:	0e 94 1a 08 	call	0x1034	; 0x1034 <_ZN9task_user18print_help_messageEv>
							break;
    1430:	4e c0       	rjmp	.+156    	; 0x14ce <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1432:	6a e0       	ldi	r22, 0x0A	; 10
    1434:	f8 01       	movw	r30, r16
    1436:	86 81       	ldd	r24, Z+6	; 0x06
    1438:	97 81       	ldd	r25, Z+7	; 0x07
    143a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    143e:	7c 01       	movw	r14, r24
    1440:	6e ef       	ldi	r22, 0xFE	; 254
    1442:	74 e0       	ldi	r23, 0x04	; 4
    1444:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    1448:	66 e0       	ldi	r22, 0x06	; 6
    144a:	c7 01       	movw	r24, r14
    144c:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1450:	60 e0       	ldi	r22, 0x00	; 0
    1452:	c8 01       	movw	r24, r16
    1454:	0e 94 ba 15 	call	0x2b74	; 0x2b74 <_ZN8frt_task13transition_toEh>
							break;
    1458:	3a c0       	rjmp	.+116    	; 0x14ce <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    145a:	f8 01       	movw	r30, r16
    145c:	a6 81       	ldd	r26, Z+6	; 0x06
    145e:	b7 81       	ldd	r27, Z+7	; 0x07
    1460:	ed 91       	ld	r30, X+
    1462:	fc 91       	ld	r31, X
    1464:	11 97       	sbiw	r26, 0x01	; 1
    1466:	02 80       	ldd	r0, Z+2	; 0x02
    1468:	f3 81       	ldd	r31, Z+3	; 0x03
    146a:	e0 2d       	mov	r30, r0
    146c:	68 2f       	mov	r22, r24
    146e:	cd 01       	movw	r24, r26
    1470:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1472:	6a e0       	ldi	r22, 0x0A	; 10
    1474:	d8 01       	movw	r26, r16
    1476:	16 96       	adiw	r26, 0x06	; 6
    1478:	8d 91       	ld	r24, X+
    147a:	9c 91       	ld	r25, X
    147c:	17 97       	sbiw	r26, 0x07	; 7
    147e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    1482:	7c 01       	movw	r14, r24
    1484:	68 ef       	ldi	r22, 0xF8	; 248
    1486:	74 e0       	ldi	r23, 0x04	; 4
    1488:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    148c:	66 e0       	ldi	r22, 0x06	; 6
    148e:	c7 01       	movw	r24, r14
    1490:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1494:	1c c0       	rjmp	.+56     	; 0x14ce <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1496:	6a e0       	ldi	r22, 0x0A	; 10
    1498:	f8 01       	movw	r30, r16
    149a:	86 81       	ldd	r24, Z+6	; 0x06
    149c:	97 81       	ldd	r25, Z+7	; 0x07
    149e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    14a2:	8c 01       	movw	r16, r24
    14a4:	6b ed       	ldi	r22, 0xDB	; 219
    14a6:	74 e0       	ldi	r23, 0x04	; 4
    14a8:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    14ac:	66 e0       	ldi	r22, 0x06	; 6
    14ae:	c8 01       	movw	r24, r16
    14b0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    14b4:	93 e0       	ldi	r25, 0x03	; 3
    14b6:	88 ed       	ldi	r24, 0xD8	; 216
    14b8:	08 b6       	in	r0, 0x38	; 56
    14ba:	18 be       	out	0x38, r1	; 56
    14bc:	84 bf       	out	0x34, r24	; 52
    14be:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    14c2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    14c6:	81 fd       	sbrc	r24, 1
    14c8:	fc cf       	rjmp	.-8      	; 0x14c2 <_ZN9task_user3runEv+0x228>
    14ca:	08 be       	out	0x38, r0	; 56
    14cc:	ff cf       	rjmp	.-2      	; 0x14cc <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    14ce:	f8 01       	movw	r30, r16
    14d0:	86 85       	ldd	r24, Z+14	; 0x0e
    14d2:	97 85       	ldd	r25, Z+15	; 0x0f
    14d4:	a0 89       	ldd	r26, Z+16	; 0x10
    14d6:	b1 89       	ldd	r27, Z+17	; 0x11
    14d8:	01 96       	adiw	r24, 0x01	; 1
    14da:	a1 1d       	adc	r26, r1
    14dc:	b1 1d       	adc	r27, r1
    14de:	86 87       	std	Z+14, r24	; 0x0e
    14e0:	97 87       	std	Z+15, r25	; 0x0f
    14e2:	a0 8b       	std	Z+16, r26	; 0x10
    14e4:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    14e6:	61 e0       	ldi	r22, 0x01	; 1
    14e8:	70 e0       	ldi	r23, 0x00	; 0
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	0e 94 8e 13 	call	0x271c	; 0x271c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    14f2:	f1 ce       	rjmp	.-542    	; 0x12d6 <_ZN9task_user3runEv+0x3c>

000014f4 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    14f4:	0f 93       	push	r16
    14f6:	1f 93       	push	r17
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
    14fc:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    14fe:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1502:	80 91 56 21 	lds	r24, 0x2156	; 0x802156 <__data_end>
    1506:	81 11       	cpse	r24, r1
    1508:	1d c0       	rjmp	.+58     	; 0x1544 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    150a:	ab e5       	ldi	r26, 0x5B	; 91
    150c:	b1 e2       	ldi	r27, 0x21	; 33
    150e:	ef e5       	ldi	r30, 0x5F	; 95
    1510:	f1 e2       	ldi	r31, 0x21	; 33
    1512:	ed 93       	st	X+, r30
    1514:	fc 93       	st	X, r31
    1516:	11 97       	sbiw	r26, 0x01	; 1
    1518:	12 96       	adiw	r26, 0x02	; 2
    151a:	1d 92       	st	X+, r1
    151c:	1c 92       	st	X, r1
    151e:	13 97       	sbiw	r26, 0x03	; 3
    1520:	a7 e5       	ldi	r26, 0x57	; 87
    1522:	b1 e2       	ldi	r27, 0x21	; 33
    1524:	8f ef       	ldi	r24, 0xFF	; 255
    1526:	9f e0       	ldi	r25, 0x0F	; 15
    1528:	12 96       	adiw	r26, 0x02	; 2
    152a:	8d 93       	st	X+, r24
    152c:	9c 93       	st	X, r25
    152e:	13 97       	sbiw	r26, 0x03	; 3
    1530:	1d 92       	st	X+, r1
    1532:	1c 92       	st	X, r1
    1534:	11 97       	sbiw	r26, 0x01	; 1
    1536:	82 83       	std	Z+2, r24	; 0x02
    1538:	93 83       	std	Z+3, r25	; 0x03
    153a:	a0 83       	st	Z, r26
    153c:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	80 93 56 21 	sts	0x2156, r24	; 0x802156 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1544:	20 97       	sbiw	r28, 0x00	; 0
    1546:	09 f4       	brne	.+2      	; 0x154a <pvPortMalloc+0x56>
    1548:	5f c0       	rjmp	.+190    	; 0x1608 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    154a:	9e 01       	movw	r18, r28
    154c:	2b 5f       	subi	r18, 0xFB	; 251
    154e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1550:	24 96       	adiw	r28, 0x04	; 4
    1552:	ce 3f       	cpi	r28, 0xFE	; 254
    1554:	df 40       	sbci	r29, 0x0F	; 15
    1556:	08 f0       	brcs	.+2      	; 0x155a <pvPortMalloc+0x66>
    1558:	5a c0       	rjmp	.+180    	; 0x160e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    155a:	e0 91 5b 21 	lds	r30, 0x215B	; 0x80215b <xStart>
    155e:	f0 91 5c 21 	lds	r31, 0x215C	; 0x80215c <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1562:	ab e5       	ldi	r26, 0x5B	; 91
    1564:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1566:	02 c0       	rjmp	.+4      	; 0x156c <pvPortMalloc+0x78>
    1568:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    156a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    156c:	82 81       	ldd	r24, Z+2	; 0x02
    156e:	93 81       	ldd	r25, Z+3	; 0x03
    1570:	82 17       	cp	r24, r18
    1572:	93 07       	cpc	r25, r19
    1574:	20 f4       	brcc	.+8      	; 0x157e <pvPortMalloc+0x8a>
    1576:	80 81       	ld	r24, Z
    1578:	91 81       	ldd	r25, Z+1	; 0x01
    157a:	00 97       	sbiw	r24, 0x00	; 0
    157c:	a9 f7       	brne	.-22     	; 0x1568 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    157e:	c1 e2       	ldi	r28, 0x21	; 33
    1580:	e7 35       	cpi	r30, 0x57	; 87
    1582:	fc 07       	cpc	r31, r28
    1584:	09 f4       	brne	.+2      	; 0x1588 <pvPortMalloc+0x94>
    1586:	46 c0       	rjmp	.+140    	; 0x1614 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1588:	cd 91       	ld	r28, X+
    158a:	dc 91       	ld	r29, X
    158c:	11 97       	sbiw	r26, 0x01	; 1
    158e:	8e 01       	movw	r16, r28
    1590:	0b 5f       	subi	r16, 0xFB	; 251
    1592:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1594:	80 81       	ld	r24, Z
    1596:	91 81       	ldd	r25, Z+1	; 0x01
    1598:	8d 93       	st	X+, r24
    159a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    159c:	82 81       	ldd	r24, Z+2	; 0x02
    159e:	93 81       	ldd	r25, Z+3	; 0x03
    15a0:	82 1b       	sub	r24, r18
    15a2:	93 0b       	sbc	r25, r19
    15a4:	8b 30       	cpi	r24, 0x0B	; 11
    15a6:	91 05       	cpc	r25, r1
    15a8:	10 f1       	brcs	.+68     	; 0x15ee <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    15aa:	bf 01       	movw	r22, r30
    15ac:	62 0f       	add	r22, r18
    15ae:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    15b0:	db 01       	movw	r26, r22
    15b2:	12 96       	adiw	r26, 0x02	; 2
    15b4:	8d 93       	st	X+, r24
    15b6:	9c 93       	st	X, r25
    15b8:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    15ba:	22 83       	std	Z+2, r18	; 0x02
    15bc:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    15be:	12 96       	adiw	r26, 0x02	; 2
    15c0:	4d 91       	ld	r20, X+
    15c2:	5c 91       	ld	r21, X
    15c4:	13 97       	sbiw	r26, 0x03	; 3
    15c6:	8b e5       	ldi	r24, 0x5B	; 91
    15c8:	91 e2       	ldi	r25, 0x21	; 33
    15ca:	01 c0       	rjmp	.+2      	; 0x15ce <pvPortMalloc+0xda>
    15cc:	cd 01       	movw	r24, r26
    15ce:	ec 01       	movw	r28, r24
    15d0:	a8 81       	ld	r26, Y
    15d2:	b9 81       	ldd	r27, Y+1	; 0x01
    15d4:	12 96       	adiw	r26, 0x02	; 2
    15d6:	2d 91       	ld	r18, X+
    15d8:	3c 91       	ld	r19, X
    15da:	13 97       	sbiw	r26, 0x03	; 3
    15dc:	24 17       	cp	r18, r20
    15de:	35 07       	cpc	r19, r21
    15e0:	a8 f3       	brcs	.-22     	; 0x15cc <pvPortMalloc+0xd8>
    15e2:	eb 01       	movw	r28, r22
    15e4:	a8 83       	st	Y, r26
    15e6:	b9 83       	std	Y+1, r27	; 0x01
    15e8:	dc 01       	movw	r26, r24
    15ea:	6d 93       	st	X+, r22
    15ec:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    15ee:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    15f2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    15f6:	22 81       	ldd	r18, Z+2	; 0x02
    15f8:	33 81       	ldd	r19, Z+3	; 0x03
    15fa:	82 1b       	sub	r24, r18
    15fc:	93 0b       	sbc	r25, r19
    15fe:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1602:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1606:	08 c0       	rjmp	.+16     	; 0x1618 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1608:	00 e0       	ldi	r16, 0x00	; 0
    160a:	10 e0       	ldi	r17, 0x00	; 0
    160c:	05 c0       	rjmp	.+10     	; 0x1618 <pvPortMalloc+0x124>
    160e:	00 e0       	ldi	r16, 0x00	; 0
    1610:	10 e0       	ldi	r17, 0x00	; 0
    1612:	02 c0       	rjmp	.+4      	; 0x1618 <pvPortMalloc+0x124>
    1614:	00 e0       	ldi	r16, 0x00	; 0
    1616:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1618:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    161c:	c8 01       	movw	r24, r16
    161e:	df 91       	pop	r29
    1620:	cf 91       	pop	r28
    1622:	1f 91       	pop	r17
    1624:	0f 91       	pop	r16
    1626:	08 95       	ret

00001628 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1630:	00 97       	sbiw	r24, 0x00	; 0
    1632:	41 f1       	breq	.+80     	; 0x1684 <vPortFree+0x5c>
    1634:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1636:	8c 01       	movw	r16, r24
    1638:	05 50       	subi	r16, 0x05	; 5
    163a:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    163c:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1640:	f8 01       	movw	r30, r16
    1642:	42 81       	ldd	r20, Z+2	; 0x02
    1644:	53 81       	ldd	r21, Z+3	; 0x03
    1646:	ab e5       	ldi	r26, 0x5B	; 91
    1648:	b1 e2       	ldi	r27, 0x21	; 33
    164a:	01 c0       	rjmp	.+2      	; 0x164e <vPortFree+0x26>
    164c:	df 01       	movw	r26, r30
    164e:	ed 91       	ld	r30, X+
    1650:	fc 91       	ld	r31, X
    1652:	11 97       	sbiw	r26, 0x01	; 1
    1654:	22 81       	ldd	r18, Z+2	; 0x02
    1656:	33 81       	ldd	r19, Z+3	; 0x03
    1658:	24 17       	cp	r18, r20
    165a:	35 07       	cpc	r19, r21
    165c:	b8 f3       	brcs	.-18     	; 0x164c <vPortFree+0x24>
    165e:	25 97       	sbiw	r28, 0x05	; 5
    1660:	e8 83       	st	Y, r30
    1662:	f9 83       	std	Y+1, r31	; 0x01
    1664:	0d 93       	st	X+, r16
    1666:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1668:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    166c:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1670:	8a 81       	ldd	r24, Y+2	; 0x02
    1672:	9b 81       	ldd	r25, Y+3	; 0x03
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    167c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1680:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
	}
}
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
    1688:	1f 91       	pop	r17
    168a:	0f 91       	pop	r16
    168c:	08 95       	ret

0000168e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    168e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1692:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1696:	08 95       	ret

00001698 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1698:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    169a:	03 96       	adiw	r24, 0x03	; 3
    169c:	81 83       	std	Z+1, r24	; 0x01
    169e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    16a0:	4f ef       	ldi	r20, 0xFF	; 255
    16a2:	5f ef       	ldi	r21, 0xFF	; 255
    16a4:	ba 01       	movw	r22, r20
    16a6:	43 83       	std	Z+3, r20	; 0x03
    16a8:	54 83       	std	Z+4, r21	; 0x04
    16aa:	65 83       	std	Z+5, r22	; 0x05
    16ac:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    16ae:	87 83       	std	Z+7, r24	; 0x07
    16b0:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    16b2:	81 87       	std	Z+9, r24	; 0x09
    16b4:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    16b6:	10 82       	st	Z, r1
    16b8:	08 95       	ret

000016ba <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    16ba:	fc 01       	movw	r30, r24
    16bc:	12 86       	std	Z+10, r1	; 0x0a
    16be:	13 86       	std	Z+11, r1	; 0x0b
    16c0:	08 95       	ret

000016c2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	fc 01       	movw	r30, r24
    16c8:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    16ca:	21 81       	ldd	r18, Z+1	; 0x01
    16cc:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    16ce:	e9 01       	movw	r28, r18
    16d0:	8c 81       	ldd	r24, Y+4	; 0x04
    16d2:	9d 81       	ldd	r25, Y+5	; 0x05
    16d4:	14 96       	adiw	r26, 0x04	; 4
    16d6:	8d 93       	st	X+, r24
    16d8:	9c 93       	st	X, r25
    16da:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    16dc:	81 81       	ldd	r24, Z+1	; 0x01
    16de:	92 81       	ldd	r25, Z+2	; 0x02
    16e0:	16 96       	adiw	r26, 0x06	; 6
    16e2:	8d 93       	st	X+, r24
    16e4:	9c 93       	st	X, r25
    16e6:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    16e8:	8c 81       	ldd	r24, Y+4	; 0x04
    16ea:	9d 81       	ldd	r25, Y+5	; 0x05
    16ec:	ec 01       	movw	r28, r24
    16ee:	6e 83       	std	Y+6, r22	; 0x06
    16f0:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    16f2:	e9 01       	movw	r28, r18
    16f4:	6c 83       	std	Y+4, r22	; 0x04
    16f6:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    16f8:	61 83       	std	Z+1, r22	; 0x01
    16fa:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16fc:	1a 96       	adiw	r26, 0x0a	; 10
    16fe:	ed 93       	st	X+, r30
    1700:	fc 93       	st	X, r31
    1702:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1704:	80 81       	ld	r24, Z
    1706:	8f 5f       	subi	r24, 0xFF	; 255
    1708:	80 83       	st	Z, r24
}
    170a:	df 91       	pop	r29
    170c:	cf 91       	pop	r28
    170e:	08 95       	ret

00001710 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1710:	0f 93       	push	r16
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    171a:	08 81       	ld	r16, Y
    171c:	19 81       	ldd	r17, Y+1	; 0x01
    171e:	2a 81       	ldd	r18, Y+2	; 0x02
    1720:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1722:	0f 3f       	cpi	r16, 0xFF	; 255
    1724:	4f ef       	ldi	r20, 0xFF	; 255
    1726:	14 07       	cpc	r17, r20
    1728:	24 07       	cpc	r18, r20
    172a:	34 07       	cpc	r19, r20
    172c:	31 f4       	brne	.+12     	; 0x173a <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    172e:	dc 01       	movw	r26, r24
    1730:	19 96       	adiw	r26, 0x09	; 9
    1732:	ed 91       	ld	r30, X+
    1734:	fc 91       	ld	r31, X
    1736:	1a 97       	sbiw	r26, 0x0a	; 10
    1738:	1f c0       	rjmp	.+62     	; 0x1778 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    173a:	fc 01       	movw	r30, r24
    173c:	33 96       	adiw	r30, 0x03	; 3
    173e:	dc 01       	movw	r26, r24
    1740:	17 96       	adiw	r26, 0x07	; 7
    1742:	4d 91       	ld	r20, X+
    1744:	5c 91       	ld	r21, X
    1746:	18 97       	sbiw	r26, 0x08	; 8
    1748:	da 01       	movw	r26, r20
    174a:	4d 91       	ld	r20, X+
    174c:	5d 91       	ld	r21, X+
    174e:	6d 91       	ld	r22, X+
    1750:	7c 91       	ld	r23, X
    1752:	04 17       	cp	r16, r20
    1754:	15 07       	cpc	r17, r21
    1756:	26 07       	cpc	r18, r22
    1758:	37 07       	cpc	r19, r23
    175a:	70 f0       	brcs	.+28     	; 0x1778 <vListInsert+0x68>
    175c:	04 80       	ldd	r0, Z+4	; 0x04
    175e:	f5 81       	ldd	r31, Z+5	; 0x05
    1760:	e0 2d       	mov	r30, r0
    1762:	a4 81       	ldd	r26, Z+4	; 0x04
    1764:	b5 81       	ldd	r27, Z+5	; 0x05
    1766:	4d 91       	ld	r20, X+
    1768:	5d 91       	ld	r21, X+
    176a:	6d 91       	ld	r22, X+
    176c:	7c 91       	ld	r23, X
    176e:	04 17       	cp	r16, r20
    1770:	15 07       	cpc	r17, r21
    1772:	26 07       	cpc	r18, r22
    1774:	37 07       	cpc	r19, r23
    1776:	90 f7       	brcc	.-28     	; 0x175c <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1778:	a4 81       	ldd	r26, Z+4	; 0x04
    177a:	b5 81       	ldd	r27, Z+5	; 0x05
    177c:	ac 83       	std	Y+4, r26	; 0x04
    177e:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1780:	16 96       	adiw	r26, 0x06	; 6
    1782:	cd 93       	st	X+, r28
    1784:	dc 93       	st	X, r29
    1786:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1788:	ee 83       	std	Y+6, r30	; 0x06
    178a:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    178c:	c4 83       	std	Z+4, r28	; 0x04
    178e:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1790:	8a 87       	std	Y+10, r24	; 0x0a
    1792:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1794:	fc 01       	movw	r30, r24
    1796:	20 81       	ld	r18, Z
    1798:	2f 5f       	subi	r18, 0xFF	; 255
    179a:	20 83       	st	Z, r18
}
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	08 95       	ret

000017a6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    17a6:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    17a8:	a4 81       	ldd	r26, Z+4	; 0x04
    17aa:	b5 81       	ldd	r27, Z+5	; 0x05
    17ac:	86 81       	ldd	r24, Z+6	; 0x06
    17ae:	97 81       	ldd	r25, Z+7	; 0x07
    17b0:	16 96       	adiw	r26, 0x06	; 6
    17b2:	8d 93       	st	X+, r24
    17b4:	9c 93       	st	X, r25
    17b6:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    17b8:	a6 81       	ldd	r26, Z+6	; 0x06
    17ba:	b7 81       	ldd	r27, Z+7	; 0x07
    17bc:	84 81       	ldd	r24, Z+4	; 0x04
    17be:	95 81       	ldd	r25, Z+5	; 0x05
    17c0:	14 96       	adiw	r26, 0x04	; 4
    17c2:	8d 93       	st	X+, r24
    17c4:	9c 93       	st	X, r25
    17c6:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    17c8:	a2 85       	ldd	r26, Z+10	; 0x0a
    17ca:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    17cc:	11 96       	adiw	r26, 0x01	; 1
    17ce:	8d 91       	ld	r24, X+
    17d0:	9c 91       	ld	r25, X
    17d2:	12 97       	sbiw	r26, 0x02	; 2
    17d4:	e8 17       	cp	r30, r24
    17d6:	f9 07       	cpc	r31, r25
    17d8:	31 f4       	brne	.+12     	; 0x17e6 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    17da:	86 81       	ldd	r24, Z+6	; 0x06
    17dc:	97 81       	ldd	r25, Z+7	; 0x07
    17de:	11 96       	adiw	r26, 0x01	; 1
    17e0:	8d 93       	st	X+, r24
    17e2:	9c 93       	st	X, r25
    17e4:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    17e6:	12 86       	std	Z+10, r1	; 0x0a
    17e8:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    17ea:	8c 91       	ld	r24, X
    17ec:	81 50       	subi	r24, 0x01	; 1
    17ee:	8c 93       	st	X, r24
    17f0:	08 95       	ret

000017f2 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    17f2:	80 93 22 32 	sts	0x3222, r24	; 0x803222 <portStackTopForTask>
    17f6:	90 93 23 32 	sts	0x3223, r25	; 0x803223 <portStackTopForTask+0x1>
    17fa:	31 e1       	ldi	r19, 0x11	; 17
    17fc:	fc 01       	movw	r30, r24
    17fe:	30 83       	st	Z, r19
    1800:	31 97       	sbiw	r30, 0x01	; 1
    1802:	22 e2       	ldi	r18, 0x22	; 34
    1804:	20 83       	st	Z, r18
    1806:	31 97       	sbiw	r30, 0x01	; 1
    1808:	a3 e3       	ldi	r26, 0x33	; 51
    180a:	a0 83       	st	Z, r26
    180c:	31 97       	sbiw	r30, 0x01	; 1
    180e:	60 83       	st	Z, r22
    1810:	31 97       	sbiw	r30, 0x01	; 1
    1812:	70 83       	st	Z, r23
    1814:	31 97       	sbiw	r30, 0x01	; 1
    1816:	10 82       	st	Z, r1
    1818:	31 97       	sbiw	r30, 0x01	; 1
    181a:	10 82       	st	Z, r1
    181c:	31 97       	sbiw	r30, 0x01	; 1
    181e:	60 e8       	ldi	r22, 0x80	; 128
    1820:	60 83       	st	Z, r22
    1822:	31 97       	sbiw	r30, 0x01	; 1
    1824:	10 82       	st	Z, r1
    1826:	31 97       	sbiw	r30, 0x01	; 1
    1828:	10 82       	st	Z, r1
    182a:	31 97       	sbiw	r30, 0x01	; 1
    182c:	10 82       	st	Z, r1
    182e:	31 97       	sbiw	r30, 0x01	; 1
    1830:	62 e0       	ldi	r22, 0x02	; 2
    1832:	60 83       	st	Z, r22
    1834:	31 97       	sbiw	r30, 0x01	; 1
    1836:	63 e0       	ldi	r22, 0x03	; 3
    1838:	60 83       	st	Z, r22
    183a:	31 97       	sbiw	r30, 0x01	; 1
    183c:	64 e0       	ldi	r22, 0x04	; 4
    183e:	60 83       	st	Z, r22
    1840:	31 97       	sbiw	r30, 0x01	; 1
    1842:	65 e0       	ldi	r22, 0x05	; 5
    1844:	60 83       	st	Z, r22
    1846:	31 97       	sbiw	r30, 0x01	; 1
    1848:	66 e0       	ldi	r22, 0x06	; 6
    184a:	60 83       	st	Z, r22
    184c:	31 97       	sbiw	r30, 0x01	; 1
    184e:	67 e0       	ldi	r22, 0x07	; 7
    1850:	60 83       	st	Z, r22
    1852:	31 97       	sbiw	r30, 0x01	; 1
    1854:	68 e0       	ldi	r22, 0x08	; 8
    1856:	60 83       	st	Z, r22
    1858:	31 97       	sbiw	r30, 0x01	; 1
    185a:	69 e0       	ldi	r22, 0x09	; 9
    185c:	60 83       	st	Z, r22
    185e:	31 97       	sbiw	r30, 0x01	; 1
    1860:	60 e1       	ldi	r22, 0x10	; 16
    1862:	60 83       	st	Z, r22
    1864:	31 97       	sbiw	r30, 0x01	; 1
    1866:	30 83       	st	Z, r19
    1868:	31 97       	sbiw	r30, 0x01	; 1
    186a:	32 e1       	ldi	r19, 0x12	; 18
    186c:	30 83       	st	Z, r19
    186e:	31 97       	sbiw	r30, 0x01	; 1
    1870:	33 e1       	ldi	r19, 0x13	; 19
    1872:	30 83       	st	Z, r19
    1874:	31 97       	sbiw	r30, 0x01	; 1
    1876:	34 e1       	ldi	r19, 0x14	; 20
    1878:	30 83       	st	Z, r19
    187a:	31 97       	sbiw	r30, 0x01	; 1
    187c:	35 e1       	ldi	r19, 0x15	; 21
    187e:	30 83       	st	Z, r19
    1880:	31 97       	sbiw	r30, 0x01	; 1
    1882:	36 e1       	ldi	r19, 0x16	; 22
    1884:	30 83       	st	Z, r19
    1886:	31 97       	sbiw	r30, 0x01	; 1
    1888:	37 e1       	ldi	r19, 0x17	; 23
    188a:	30 83       	st	Z, r19
    188c:	31 97       	sbiw	r30, 0x01	; 1
    188e:	38 e1       	ldi	r19, 0x18	; 24
    1890:	30 83       	st	Z, r19
    1892:	31 97       	sbiw	r30, 0x01	; 1
    1894:	39 e1       	ldi	r19, 0x19	; 25
    1896:	30 83       	st	Z, r19
    1898:	31 97       	sbiw	r30, 0x01	; 1
    189a:	30 e2       	ldi	r19, 0x20	; 32
    189c:	30 83       	st	Z, r19
    189e:	31 97       	sbiw	r30, 0x01	; 1
    18a0:	31 e2       	ldi	r19, 0x21	; 33
    18a2:	30 83       	st	Z, r19
    18a4:	31 97       	sbiw	r30, 0x01	; 1
    18a6:	20 83       	st	Z, r18
    18a8:	31 97       	sbiw	r30, 0x01	; 1
    18aa:	23 e2       	ldi	r18, 0x23	; 35
    18ac:	20 83       	st	Z, r18
    18ae:	31 97       	sbiw	r30, 0x01	; 1
    18b0:	40 83       	st	Z, r20
    18b2:	31 97       	sbiw	r30, 0x01	; 1
    18b4:	50 83       	st	Z, r21
    18b6:	31 97       	sbiw	r30, 0x01	; 1
    18b8:	26 e2       	ldi	r18, 0x26	; 38
    18ba:	20 83       	st	Z, r18
    18bc:	31 97       	sbiw	r30, 0x01	; 1
    18be:	27 e2       	ldi	r18, 0x27	; 39
    18c0:	20 83       	st	Z, r18
    18c2:	31 97       	sbiw	r30, 0x01	; 1
    18c4:	28 e2       	ldi	r18, 0x28	; 40
    18c6:	20 83       	st	Z, r18
    18c8:	31 97       	sbiw	r30, 0x01	; 1
    18ca:	29 e2       	ldi	r18, 0x29	; 41
    18cc:	20 83       	st	Z, r18
    18ce:	31 97       	sbiw	r30, 0x01	; 1
    18d0:	20 e3       	ldi	r18, 0x30	; 48
    18d2:	20 83       	st	Z, r18
    18d4:	31 97       	sbiw	r30, 0x01	; 1
    18d6:	21 e3       	ldi	r18, 0x31	; 49
    18d8:	20 83       	st	Z, r18
    18da:	89 97       	sbiw	r24, 0x29	; 41
    18dc:	08 95       	ret

000018de <xPortStartScheduler>:
    18de:	8c e7       	ldi	r24, 0x7C	; 124
    18e0:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    18e4:	8f ef       	ldi	r24, 0xFF	; 255
    18e6:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    18ea:	81 e0       	ldi	r24, 0x01	; 1
    18ec:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    18f0:	91 e1       	ldi	r25, 0x11	; 17
    18f2:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    18f6:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    18fa:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    18fe:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    1902:	cd 91       	ld	r28, X+
    1904:	cd bf       	out	0x3d, r28	; 61
    1906:	dd 91       	ld	r29, X+
    1908:	de bf       	out	0x3e, r29	; 62
    190a:	ff 91       	pop	r31
    190c:	ef 91       	pop	r30
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	bf 91       	pop	r27
    1914:	af 91       	pop	r26
    1916:	9f 91       	pop	r25
    1918:	8f 91       	pop	r24
    191a:	7f 91       	pop	r23
    191c:	6f 91       	pop	r22
    191e:	5f 91       	pop	r21
    1920:	4f 91       	pop	r20
    1922:	3f 91       	pop	r19
    1924:	2f 91       	pop	r18
    1926:	1f 91       	pop	r17
    1928:	0f 91       	pop	r16
    192a:	ff 90       	pop	r15
    192c:	ef 90       	pop	r14
    192e:	df 90       	pop	r13
    1930:	cf 90       	pop	r12
    1932:	bf 90       	pop	r11
    1934:	af 90       	pop	r10
    1936:	9f 90       	pop	r9
    1938:	8f 90       	pop	r8
    193a:	7f 90       	pop	r7
    193c:	6f 90       	pop	r6
    193e:	5f 90       	pop	r5
    1940:	4f 90       	pop	r4
    1942:	3f 90       	pop	r3
    1944:	2f 90       	pop	r2
    1946:	1f 90       	pop	r1
    1948:	0f 90       	pop	r0
    194a:	0c be       	out	0x3c, r0	; 60
    194c:	0f 90       	pop	r0
    194e:	0b be       	out	0x3b, r0	; 59
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	0f 90       	pop	r0
    1956:	08 95       	ret
    1958:	08 95       	ret

0000195a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    195a:	0f 92       	push	r0
    195c:	0f b6       	in	r0, 0x3f	; 63
    195e:	f8 94       	cli
    1960:	0f 92       	push	r0
    1962:	0b b6       	in	r0, 0x3b	; 59
    1964:	0f 92       	push	r0
    1966:	0c b6       	in	r0, 0x3c	; 60
    1968:	0f 92       	push	r0
    196a:	1f 92       	push	r1
    196c:	11 24       	eor	r1, r1
    196e:	2f 92       	push	r2
    1970:	3f 92       	push	r3
    1972:	4f 92       	push	r4
    1974:	5f 92       	push	r5
    1976:	6f 92       	push	r6
    1978:	7f 92       	push	r7
    197a:	8f 92       	push	r8
    197c:	9f 92       	push	r9
    197e:	af 92       	push	r10
    1980:	bf 92       	push	r11
    1982:	cf 92       	push	r12
    1984:	df 92       	push	r13
    1986:	ef 92       	push	r14
    1988:	ff 92       	push	r15
    198a:	0f 93       	push	r16
    198c:	1f 93       	push	r17
    198e:	2f 93       	push	r18
    1990:	3f 93       	push	r19
    1992:	4f 93       	push	r20
    1994:	5f 93       	push	r21
    1996:	6f 93       	push	r22
    1998:	7f 93       	push	r23
    199a:	8f 93       	push	r24
    199c:	9f 93       	push	r25
    199e:	af 93       	push	r26
    19a0:	bf 93       	push	r27
    19a2:	cf 93       	push	r28
    19a4:	df 93       	push	r29
    19a6:	ef 93       	push	r30
    19a8:	ff 93       	push	r31
    19aa:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    19ae:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    19b2:	0d b6       	in	r0, 0x3d	; 61
    19b4:	0d 92       	st	X+, r0
    19b6:	0e b6       	in	r0, 0x3e	; 62
    19b8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    19ba:	0e 94 bc 13 	call	0x2778	; 0x2778 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    19be:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    19c2:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    19c6:	cd 91       	ld	r28, X+
    19c8:	cd bf       	out	0x3d, r28	; 61
    19ca:	dd 91       	ld	r29, X+
    19cc:	de bf       	out	0x3e, r29	; 62
    19ce:	ff 91       	pop	r31
    19d0:	ef 91       	pop	r30
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	bf 91       	pop	r27
    19d8:	af 91       	pop	r26
    19da:	9f 91       	pop	r25
    19dc:	8f 91       	pop	r24
    19de:	7f 91       	pop	r23
    19e0:	6f 91       	pop	r22
    19e2:	5f 91       	pop	r21
    19e4:	4f 91       	pop	r20
    19e6:	3f 91       	pop	r19
    19e8:	2f 91       	pop	r18
    19ea:	1f 91       	pop	r17
    19ec:	0f 91       	pop	r16
    19ee:	ff 90       	pop	r15
    19f0:	ef 90       	pop	r14
    19f2:	df 90       	pop	r13
    19f4:	cf 90       	pop	r12
    19f6:	bf 90       	pop	r11
    19f8:	af 90       	pop	r10
    19fa:	9f 90       	pop	r9
    19fc:	8f 90       	pop	r8
    19fe:	7f 90       	pop	r7
    1a00:	6f 90       	pop	r6
    1a02:	5f 90       	pop	r5
    1a04:	4f 90       	pop	r4
    1a06:	3f 90       	pop	r3
    1a08:	2f 90       	pop	r2
    1a0a:	1f 90       	pop	r1
    1a0c:	0f 90       	pop	r0
    1a0e:	0c be       	out	0x3c, r0	; 60
    1a10:	0f 90       	pop	r0
    1a12:	0b be       	out	0x3b, r0	; 59
    1a14:	0f 90       	pop	r0
    1a16:	0f be       	out	0x3f, r0	; 63
    1a18:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1a1a:	08 95       	ret

00001a1c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1a1c:	0f 92       	push	r0
    1a1e:	0f b6       	in	r0, 0x3f	; 63
    1a20:	f8 94       	cli
    1a22:	0f 92       	push	r0
    1a24:	0b b6       	in	r0, 0x3b	; 59
    1a26:	0f 92       	push	r0
    1a28:	0c b6       	in	r0, 0x3c	; 60
    1a2a:	0f 92       	push	r0
    1a2c:	1f 92       	push	r1
    1a2e:	11 24       	eor	r1, r1
    1a30:	2f 92       	push	r2
    1a32:	3f 92       	push	r3
    1a34:	4f 92       	push	r4
    1a36:	5f 92       	push	r5
    1a38:	6f 92       	push	r6
    1a3a:	7f 92       	push	r7
    1a3c:	8f 92       	push	r8
    1a3e:	9f 92       	push	r9
    1a40:	af 92       	push	r10
    1a42:	bf 92       	push	r11
    1a44:	cf 92       	push	r12
    1a46:	df 92       	push	r13
    1a48:	ef 92       	push	r14
    1a4a:	ff 92       	push	r15
    1a4c:	0f 93       	push	r16
    1a4e:	1f 93       	push	r17
    1a50:	2f 93       	push	r18
    1a52:	3f 93       	push	r19
    1a54:	4f 93       	push	r20
    1a56:	5f 93       	push	r21
    1a58:	6f 93       	push	r22
    1a5a:	7f 93       	push	r23
    1a5c:	8f 93       	push	r24
    1a5e:	9f 93       	push	r25
    1a60:	af 93       	push	r26
    1a62:	bf 93       	push	r27
    1a64:	cf 93       	push	r28
    1a66:	df 93       	push	r29
    1a68:	ef 93       	push	r30
    1a6a:	ff 93       	push	r31
    1a6c:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    1a70:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    1a74:	0d b6       	in	r0, 0x3d	; 61
    1a76:	0d 92       	st	X+, r0
    1a78:	0e b6       	in	r0, 0x3e	; 62
    1a7a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a7c:	0e 94 0b 12 	call	0x2416	; 0x2416 <vTaskIncrementTick>
	vTaskSwitchContext();
    1a80:	0e 94 bc 13 	call	0x2778	; 0x2778 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a84:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    1a88:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    1a8c:	cd 91       	ld	r28, X+
    1a8e:	cd bf       	out	0x3d, r28	; 61
    1a90:	dd 91       	ld	r29, X+
    1a92:	de bf       	out	0x3e, r29	; 62
    1a94:	ff 91       	pop	r31
    1a96:	ef 91       	pop	r30
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	bf 91       	pop	r27
    1a9e:	af 91       	pop	r26
    1aa0:	9f 91       	pop	r25
    1aa2:	8f 91       	pop	r24
    1aa4:	7f 91       	pop	r23
    1aa6:	6f 91       	pop	r22
    1aa8:	5f 91       	pop	r21
    1aaa:	4f 91       	pop	r20
    1aac:	3f 91       	pop	r19
    1aae:	2f 91       	pop	r18
    1ab0:	1f 91       	pop	r17
    1ab2:	0f 91       	pop	r16
    1ab4:	ff 90       	pop	r15
    1ab6:	ef 90       	pop	r14
    1ab8:	df 90       	pop	r13
    1aba:	cf 90       	pop	r12
    1abc:	bf 90       	pop	r11
    1abe:	af 90       	pop	r10
    1ac0:	9f 90       	pop	r9
    1ac2:	8f 90       	pop	r8
    1ac4:	7f 90       	pop	r7
    1ac6:	6f 90       	pop	r6
    1ac8:	5f 90       	pop	r5
    1aca:	4f 90       	pop	r4
    1acc:	3f 90       	pop	r3
    1ace:	2f 90       	pop	r2
    1ad0:	1f 90       	pop	r1
    1ad2:	0f 90       	pop	r0
    1ad4:	0c be       	out	0x3c, r0	; 60
    1ad6:	0f 90       	pop	r0
    1ad8:	0b be       	out	0x3b, r0	; 59
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63
    1ade:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ae0:	08 95       	ret

00001ae2 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1ae2:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ae6:	18 95       	reti

00001ae8 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1ae8:	cf 93       	push	r28
    1aea:	df 93       	push	r29
    1aec:	ec 01       	movw	r28, r24
    1aee:	88 a1       	ldd	r24, Y+32	; 0x20
    1af0:	81 11       	cpse	r24, r1
    1af2:	0b c0       	rjmp	.+22     	; 0x1b0a <prvCopyDataToQueue+0x22>
    1af4:	88 81       	ld	r24, Y
    1af6:	99 81       	ldd	r25, Y+1	; 0x01
    1af8:	89 2b       	or	r24, r25
    1afa:	e1 f5       	brne	.+120    	; 0x1b74 <prvCopyDataToQueue+0x8c>
    1afc:	8a 81       	ldd	r24, Y+2	; 0x02
    1afe:	9b 81       	ldd	r25, Y+3	; 0x03
    1b00:	0e 94 77 15 	call	0x2aee	; 0x2aee <vTaskPriorityDisinherit>
    1b04:	1a 82       	std	Y+2, r1	; 0x02
    1b06:	1b 82       	std	Y+3, r1	; 0x03
    1b08:	35 c0       	rjmp	.+106    	; 0x1b74 <prvCopyDataToQueue+0x8c>
    1b0a:	41 11       	cpse	r20, r1
    1b0c:	17 c0       	rjmp	.+46     	; 0x1b3c <prvCopyDataToQueue+0x54>
    1b0e:	48 2f       	mov	r20, r24
    1b10:	50 e0       	ldi	r21, 0x00	; 0
    1b12:	8c 81       	ldd	r24, Y+4	; 0x04
    1b14:	9d 81       	ldd	r25, Y+5	; 0x05
    1b16:	0e 94 ac 22 	call	0x4558	; 0x4558 <memcpy>
    1b1a:	28 a1       	ldd	r18, Y+32	; 0x20
    1b1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b20:	82 0f       	add	r24, r18
    1b22:	91 1d       	adc	r25, r1
    1b24:	8c 83       	std	Y+4, r24	; 0x04
    1b26:	9d 83       	std	Y+5, r25	; 0x05
    1b28:	2a 81       	ldd	r18, Y+2	; 0x02
    1b2a:	3b 81       	ldd	r19, Y+3	; 0x03
    1b2c:	82 17       	cp	r24, r18
    1b2e:	93 07       	cpc	r25, r19
    1b30:	08 f1       	brcs	.+66     	; 0x1b74 <prvCopyDataToQueue+0x8c>
    1b32:	88 81       	ld	r24, Y
    1b34:	99 81       	ldd	r25, Y+1	; 0x01
    1b36:	8c 83       	std	Y+4, r24	; 0x04
    1b38:	9d 83       	std	Y+5, r25	; 0x05
    1b3a:	1c c0       	rjmp	.+56     	; 0x1b74 <prvCopyDataToQueue+0x8c>
    1b3c:	48 2f       	mov	r20, r24
    1b3e:	50 e0       	ldi	r21, 0x00	; 0
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
    1b42:	9f 81       	ldd	r25, Y+7	; 0x07
    1b44:	0e 94 ac 22 	call	0x4558	; 0x4558 <memcpy>
    1b48:	88 a1       	ldd	r24, Y+32	; 0x20
    1b4a:	90 e0       	ldi	r25, 0x00	; 0
    1b4c:	91 95       	neg	r25
    1b4e:	81 95       	neg	r24
    1b50:	91 09       	sbc	r25, r1
    1b52:	2e 81       	ldd	r18, Y+6	; 0x06
    1b54:	3f 81       	ldd	r19, Y+7	; 0x07
    1b56:	28 0f       	add	r18, r24
    1b58:	39 1f       	adc	r19, r25
    1b5a:	2e 83       	std	Y+6, r18	; 0x06
    1b5c:	3f 83       	std	Y+7, r19	; 0x07
    1b5e:	48 81       	ld	r20, Y
    1b60:	59 81       	ldd	r21, Y+1	; 0x01
    1b62:	24 17       	cp	r18, r20
    1b64:	35 07       	cpc	r19, r21
    1b66:	30 f4       	brcc	.+12     	; 0x1b74 <prvCopyDataToQueue+0x8c>
    1b68:	2a 81       	ldd	r18, Y+2	; 0x02
    1b6a:	3b 81       	ldd	r19, Y+3	; 0x03
    1b6c:	82 0f       	add	r24, r18
    1b6e:	93 1f       	adc	r25, r19
    1b70:	8e 83       	std	Y+6, r24	; 0x06
    1b72:	9f 83       	std	Y+7, r25	; 0x07
    1b74:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b76:	8f 5f       	subi	r24, 0xFF	; 255
    1b78:	8e 8f       	std	Y+30, r24	; 0x1e
    1b7a:	df 91       	pop	r29
    1b7c:	cf 91       	pop	r28
    1b7e:	08 95       	ret

00001b80 <prvCopyDataFromQueue>:
    1b80:	fc 01       	movw	r30, r24
    1b82:	80 81       	ld	r24, Z
    1b84:	91 81       	ldd	r25, Z+1	; 0x01
    1b86:	00 97       	sbiw	r24, 0x00	; 0
    1b88:	a1 f0       	breq	.+40     	; 0x1bb2 <prvCopyDataFromQueue+0x32>
    1b8a:	40 a1       	ldd	r20, Z+32	; 0x20
    1b8c:	50 e0       	ldi	r21, 0x00	; 0
    1b8e:	26 81       	ldd	r18, Z+6	; 0x06
    1b90:	37 81       	ldd	r19, Z+7	; 0x07
    1b92:	24 0f       	add	r18, r20
    1b94:	35 1f       	adc	r19, r21
    1b96:	26 83       	std	Z+6, r18	; 0x06
    1b98:	37 83       	std	Z+7, r19	; 0x07
    1b9a:	a2 81       	ldd	r26, Z+2	; 0x02
    1b9c:	b3 81       	ldd	r27, Z+3	; 0x03
    1b9e:	2a 17       	cp	r18, r26
    1ba0:	3b 07       	cpc	r19, r27
    1ba2:	10 f0       	brcs	.+4      	; 0x1ba8 <prvCopyDataFromQueue+0x28>
    1ba4:	86 83       	std	Z+6, r24	; 0x06
    1ba6:	97 83       	std	Z+7, r25	; 0x07
    1ba8:	cb 01       	movw	r24, r22
    1baa:	66 81       	ldd	r22, Z+6	; 0x06
    1bac:	77 81       	ldd	r23, Z+7	; 0x07
    1bae:	0e 94 ac 22 	call	0x4558	; 0x4558 <memcpy>
    1bb2:	08 95       	ret

00001bb4 <prvUnlockQueue>:
    1bb4:	0f 93       	push	r16
    1bb6:	1f 93       	push	r17
    1bb8:	cf 93       	push	r28
    1bba:	df 93       	push	r29
    1bbc:	ec 01       	movw	r28, r24
    1bbe:	0f b6       	in	r0, 0x3f	; 63
    1bc0:	f8 94       	cli
    1bc2:	0f 92       	push	r0
    1bc4:	8a a1       	ldd	r24, Y+34	; 0x22
    1bc6:	18 16       	cp	r1, r24
    1bc8:	b4 f4       	brge	.+44     	; 0x1bf6 <prvUnlockQueue+0x42>
    1bca:	8b 89       	ldd	r24, Y+19	; 0x13
    1bcc:	81 11       	cpse	r24, r1
    1bce:	05 c0       	rjmp	.+10     	; 0x1bda <prvUnlockQueue+0x26>
    1bd0:	12 c0       	rjmp	.+36     	; 0x1bf6 <prvUnlockQueue+0x42>
    1bd2:	8b 89       	ldd	r24, Y+19	; 0x13
    1bd4:	81 11       	cpse	r24, r1
    1bd6:	04 c0       	rjmp	.+8      	; 0x1be0 <prvUnlockQueue+0x2c>
    1bd8:	0e c0       	rjmp	.+28     	; 0x1bf6 <prvUnlockQueue+0x42>
    1bda:	8e 01       	movw	r16, r28
    1bdc:	0d 5e       	subi	r16, 0xED	; 237
    1bde:	1f 4f       	sbci	r17, 0xFF	; 255
    1be0:	c8 01       	movw	r24, r16
    1be2:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1be6:	81 11       	cpse	r24, r1
    1be8:	0e 94 00 15 	call	0x2a00	; 0x2a00 <vTaskMissedYield>
    1bec:	8a a1       	ldd	r24, Y+34	; 0x22
    1bee:	81 50       	subi	r24, 0x01	; 1
    1bf0:	8a a3       	std	Y+34, r24	; 0x22
    1bf2:	18 16       	cp	r1, r24
    1bf4:	74 f3       	brlt	.-36     	; 0x1bd2 <prvUnlockQueue+0x1e>
    1bf6:	8f ef       	ldi	r24, 0xFF	; 255
    1bf8:	8a a3       	std	Y+34, r24	; 0x22
    1bfa:	0f 90       	pop	r0
    1bfc:	0f be       	out	0x3f, r0	; 63
    1bfe:	0f b6       	in	r0, 0x3f	; 63
    1c00:	f8 94       	cli
    1c02:	0f 92       	push	r0
    1c04:	89 a1       	ldd	r24, Y+33	; 0x21
    1c06:	18 16       	cp	r1, r24
    1c08:	b4 f4       	brge	.+44     	; 0x1c36 <prvUnlockQueue+0x82>
    1c0a:	88 85       	ldd	r24, Y+8	; 0x08
    1c0c:	81 11       	cpse	r24, r1
    1c0e:	05 c0       	rjmp	.+10     	; 0x1c1a <prvUnlockQueue+0x66>
    1c10:	12 c0       	rjmp	.+36     	; 0x1c36 <prvUnlockQueue+0x82>
    1c12:	88 85       	ldd	r24, Y+8	; 0x08
    1c14:	81 11       	cpse	r24, r1
    1c16:	04 c0       	rjmp	.+8      	; 0x1c20 <prvUnlockQueue+0x6c>
    1c18:	0e c0       	rjmp	.+28     	; 0x1c36 <prvUnlockQueue+0x82>
    1c1a:	8e 01       	movw	r16, r28
    1c1c:	08 5f       	subi	r16, 0xF8	; 248
    1c1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c20:	c8 01       	movw	r24, r16
    1c22:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1c26:	81 11       	cpse	r24, r1
    1c28:	0e 94 00 15 	call	0x2a00	; 0x2a00 <vTaskMissedYield>
    1c2c:	89 a1       	ldd	r24, Y+33	; 0x21
    1c2e:	81 50       	subi	r24, 0x01	; 1
    1c30:	89 a3       	std	Y+33, r24	; 0x21
    1c32:	18 16       	cp	r1, r24
    1c34:	74 f3       	brlt	.-36     	; 0x1c12 <prvUnlockQueue+0x5e>
    1c36:	8f ef       	ldi	r24, 0xFF	; 255
    1c38:	89 a3       	std	Y+33, r24	; 0x21
    1c3a:	0f 90       	pop	r0
    1c3c:	0f be       	out	0x3f, r0	; 63
    1c3e:	df 91       	pop	r29
    1c40:	cf 91       	pop	r28
    1c42:	1f 91       	pop	r17
    1c44:	0f 91       	pop	r16
    1c46:	08 95       	ret

00001c48 <xQueueGenericReset>:
    1c48:	1f 93       	push	r17
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	61 30       	cpi	r22, 0x01	; 1
    1c50:	59 f0       	breq	.+22     	; 0x1c68 <xQueueGenericReset+0x20>
    1c52:	fc 01       	movw	r30, r24
    1c54:	23 89       	ldd	r18, Z+19	; 0x13
    1c56:	30 85       	ldd	r19, Z+8	; 0x08
    1c58:	31 11       	cpse	r19, r1
    1c5a:	2c c0       	rjmp	.+88     	; 0x1cb4 <xQueueGenericReset+0x6c>
    1c5c:	11 e0       	ldi	r17, 0x01	; 1
    1c5e:	21 11       	cpse	r18, r1
    1c60:	10 e0       	ldi	r17, 0x00	; 0
    1c62:	21 11       	cpse	r18, r1
    1c64:	28 c0       	rjmp	.+80     	; 0x1cb6 <xQueueGenericReset+0x6e>
    1c66:	01 c0       	rjmp	.+2      	; 0x1c6a <xQueueGenericReset+0x22>
    1c68:	11 e0       	ldi	r17, 0x01	; 1
    1c6a:	ec 01       	movw	r28, r24
    1c6c:	48 81       	ld	r20, Y
    1c6e:	59 81       	ldd	r21, Y+1	; 0x01
    1c70:	28 a1       	ldd	r18, Y+32	; 0x20
    1c72:	30 e0       	ldi	r19, 0x00	; 0
    1c74:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1c76:	62 9f       	mul	r22, r18
    1c78:	c0 01       	movw	r24, r0
    1c7a:	63 9f       	mul	r22, r19
    1c7c:	90 0d       	add	r25, r0
    1c7e:	11 24       	eor	r1, r1
    1c80:	ba 01       	movw	r22, r20
    1c82:	68 0f       	add	r22, r24
    1c84:	79 1f       	adc	r23, r25
    1c86:	6a 83       	std	Y+2, r22	; 0x02
    1c88:	7b 83       	std	Y+3, r23	; 0x03
    1c8a:	1e 8e       	std	Y+30, r1	; 0x1e
    1c8c:	4c 83       	std	Y+4, r20	; 0x04
    1c8e:	5d 83       	std	Y+5, r21	; 0x05
    1c90:	82 1b       	sub	r24, r18
    1c92:	93 0b       	sbc	r25, r19
    1c94:	84 0f       	add	r24, r20
    1c96:	95 1f       	adc	r25, r21
    1c98:	8e 83       	std	Y+6, r24	; 0x06
    1c9a:	9f 83       	std	Y+7, r25	; 0x07
    1c9c:	8f ef       	ldi	r24, 0xFF	; 255
    1c9e:	89 a3       	std	Y+33, r24	; 0x21
    1ca0:	8a a3       	std	Y+34, r24	; 0x22
    1ca2:	ce 01       	movw	r24, r28
    1ca4:	08 96       	adiw	r24, 0x08	; 8
    1ca6:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    1caa:	ce 01       	movw	r24, r28
    1cac:	43 96       	adiw	r24, 0x13	; 19
    1cae:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    1cb2:	01 c0       	rjmp	.+2      	; 0x1cb6 <xQueueGenericReset+0x6e>
    1cb4:	10 e0       	ldi	r17, 0x00	; 0
    1cb6:	81 2f       	mov	r24, r17
    1cb8:	df 91       	pop	r29
    1cba:	cf 91       	pop	r28
    1cbc:	1f 91       	pop	r17
    1cbe:	08 95       	ret

00001cc0 <xQueueGenericCreate>:
    1cc0:	0f 93       	push	r16
    1cc2:	1f 93       	push	r17
    1cc4:	cf 93       	push	r28
    1cc6:	df 93       	push	r29
    1cc8:	88 23       	and	r24, r24
    1cca:	01 f1       	breq	.+64     	; 0x1d0c <xQueueGenericCreate+0x4c>
    1ccc:	06 2f       	mov	r16, r22
    1cce:	18 2f       	mov	r17, r24
    1cd0:	83 e2       	ldi	r24, 0x23	; 35
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    1cd8:	ec 01       	movw	r28, r24
    1cda:	89 2b       	or	r24, r25
    1cdc:	c9 f0       	breq	.+50     	; 0x1d10 <xQueueGenericCreate+0x50>
    1cde:	10 9f       	mul	r17, r16
    1ce0:	c0 01       	movw	r24, r0
    1ce2:	11 24       	eor	r1, r1
    1ce4:	01 96       	adiw	r24, 0x01	; 1
    1ce6:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    1cea:	88 83       	st	Y, r24
    1cec:	99 83       	std	Y+1, r25	; 0x01
    1cee:	89 2b       	or	r24, r25
    1cf0:	39 f0       	breq	.+14     	; 0x1d00 <xQueueGenericCreate+0x40>
    1cf2:	1f 8f       	std	Y+31, r17	; 0x1f
    1cf4:	08 a3       	std	Y+32, r16	; 0x20
    1cf6:	61 e0       	ldi	r22, 0x01	; 1
    1cf8:	ce 01       	movw	r24, r28
    1cfa:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <xQueueGenericReset>
    1cfe:	08 c0       	rjmp	.+16     	; 0x1d10 <xQueueGenericCreate+0x50>
    1d00:	ce 01       	movw	r24, r28
    1d02:	0e 94 14 0b 	call	0x1628	; 0x1628 <vPortFree>
    1d06:	c0 e0       	ldi	r28, 0x00	; 0
    1d08:	d0 e0       	ldi	r29, 0x00	; 0
    1d0a:	02 c0       	rjmp	.+4      	; 0x1d10 <xQueueGenericCreate+0x50>
    1d0c:	c0 e0       	ldi	r28, 0x00	; 0
    1d0e:	d0 e0       	ldi	r29, 0x00	; 0
    1d10:	ce 01       	movw	r24, r28
    1d12:	df 91       	pop	r29
    1d14:	cf 91       	pop	r28
    1d16:	1f 91       	pop	r17
    1d18:	0f 91       	pop	r16
    1d1a:	08 95       	ret

00001d1c <xQueueGenericSend>:
    1d1c:	af 92       	push	r10
    1d1e:	bf 92       	push	r11
    1d20:	cf 92       	push	r12
    1d22:	df 92       	push	r13
    1d24:	ef 92       	push	r14
    1d26:	ff 92       	push	r15
    1d28:	0f 93       	push	r16
    1d2a:	1f 93       	push	r17
    1d2c:	cf 93       	push	r28
    1d2e:	df 93       	push	r29
    1d30:	cd b7       	in	r28, 0x3d	; 61
    1d32:	de b7       	in	r29, 0x3e	; 62
    1d34:	29 97       	sbiw	r28, 0x09	; 9
    1d36:	cd bf       	out	0x3d, r28	; 61
    1d38:	de bf       	out	0x3e, r29	; 62
    1d3a:	7c 01       	movw	r14, r24
    1d3c:	5b 01       	movw	r10, r22
    1d3e:	2e 83       	std	Y+6, r18	; 0x06
    1d40:	3f 83       	std	Y+7, r19	; 0x07
    1d42:	48 87       	std	Y+8, r20	; 0x08
    1d44:	59 87       	std	Y+9, r21	; 0x09
    1d46:	10 e0       	ldi	r17, 0x00	; 0
    1d48:	6c 01       	movw	r12, r24
    1d4a:	88 e0       	ldi	r24, 0x08	; 8
    1d4c:	c8 0e       	add	r12, r24
    1d4e:	d1 1c       	adc	r13, r1
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	0f 92       	push	r0
    1d56:	f7 01       	movw	r30, r14
    1d58:	96 8d       	ldd	r25, Z+30	; 0x1e
    1d5a:	87 8d       	ldd	r24, Z+31	; 0x1f
    1d5c:	98 17       	cp	r25, r24
    1d5e:	a8 f4       	brcc	.+42     	; 0x1d8a <xQueueGenericSend+0x6e>
    1d60:	40 2f       	mov	r20, r16
    1d62:	b5 01       	movw	r22, r10
    1d64:	c7 01       	movw	r24, r14
    1d66:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <prvCopyDataToQueue>
    1d6a:	f7 01       	movw	r30, r14
    1d6c:	83 89       	ldd	r24, Z+19	; 0x13
    1d6e:	88 23       	and	r24, r24
    1d70:	41 f0       	breq	.+16     	; 0x1d82 <xQueueGenericSend+0x66>
    1d72:	c7 01       	movw	r24, r14
    1d74:	43 96       	adiw	r24, 0x13	; 19
    1d76:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1d7a:	81 30       	cpi	r24, 0x01	; 1
    1d7c:	11 f4       	brne	.+4      	; 0x1d82 <xQueueGenericSend+0x66>
    1d7e:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    1d82:	0f 90       	pop	r0
    1d84:	0f be       	out	0x3f, r0	; 63
    1d86:	81 e0       	ldi	r24, 0x01	; 1
    1d88:	56 c0       	rjmp	.+172    	; 0x1e36 <xQueueGenericSend+0x11a>
    1d8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d8c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d8e:	a8 85       	ldd	r26, Y+8	; 0x08
    1d90:	b9 85       	ldd	r27, Y+9	; 0x09
    1d92:	89 2b       	or	r24, r25
    1d94:	8a 2b       	or	r24, r26
    1d96:	8b 2b       	or	r24, r27
    1d98:	21 f4       	brne	.+8      	; 0x1da2 <xQueueGenericSend+0x86>
    1d9a:	0f 90       	pop	r0
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	80 e0       	ldi	r24, 0x00	; 0
    1da0:	4a c0       	rjmp	.+148    	; 0x1e36 <xQueueGenericSend+0x11a>
    1da2:	11 11       	cpse	r17, r1
    1da4:	05 c0       	rjmp	.+10     	; 0x1db0 <xQueueGenericSend+0x94>
    1da6:	ce 01       	movw	r24, r28
    1da8:	01 96       	adiw	r24, 0x01	; 1
    1daa:	0e 94 82 14 	call	0x2904	; 0x2904 <vTaskSetTimeOutState>
    1dae:	11 e0       	ldi	r17, 0x01	; 1
    1db0:	0f 90       	pop	r0
    1db2:	0f be       	out	0x3f, r0	; 63
    1db4:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspendAll>
    1db8:	0f b6       	in	r0, 0x3f	; 63
    1dba:	f8 94       	cli
    1dbc:	0f 92       	push	r0
    1dbe:	f7 01       	movw	r30, r14
    1dc0:	81 a1       	ldd	r24, Z+33	; 0x21
    1dc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc4:	09 f4       	brne	.+2      	; 0x1dc8 <xQueueGenericSend+0xac>
    1dc6:	11 a2       	std	Z+33, r1	; 0x21
    1dc8:	f7 01       	movw	r30, r14
    1dca:	82 a1       	ldd	r24, Z+34	; 0x22
    1dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dce:	09 f4       	brne	.+2      	; 0x1dd2 <xQueueGenericSend+0xb6>
    1dd0:	12 a2       	std	Z+34, r1	; 0x22
    1dd2:	0f 90       	pop	r0
    1dd4:	0f be       	out	0x3f, r0	; 63
    1dd6:	be 01       	movw	r22, r28
    1dd8:	6a 5f       	subi	r22, 0xFA	; 250
    1dda:	7f 4f       	sbci	r23, 0xFF	; 255
    1ddc:	ce 01       	movw	r24, r28
    1dde:	01 96       	adiw	r24, 0x01	; 1
    1de0:	0e 94 93 14 	call	0x2926	; 0x2926 <xTaskCheckForTimeOut>
    1de4:	81 11       	cpse	r24, r1
    1de6:	21 c0       	rjmp	.+66     	; 0x1e2a <xQueueGenericSend+0x10e>
    1de8:	0f b6       	in	r0, 0x3f	; 63
    1dea:	f8 94       	cli
    1dec:	0f 92       	push	r0
    1dee:	f7 01       	movw	r30, r14
    1df0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1df2:	0f 90       	pop	r0
    1df4:	0f be       	out	0x3f, r0	; 63
    1df6:	87 8d       	ldd	r24, Z+31	; 0x1f
    1df8:	98 13       	cpse	r25, r24
    1dfa:	11 c0       	rjmp	.+34     	; 0x1e1e <xQueueGenericSend+0x102>
    1dfc:	4e 81       	ldd	r20, Y+6	; 0x06
    1dfe:	5f 81       	ldd	r21, Y+7	; 0x07
    1e00:	68 85       	ldd	r22, Y+8	; 0x08
    1e02:	79 85       	ldd	r23, Y+9	; 0x09
    1e04:	c6 01       	movw	r24, r12
    1e06:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskPlaceOnEventList>
    1e0a:	c7 01       	movw	r24, r14
    1e0c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
    1e10:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
    1e14:	81 11       	cpse	r24, r1
    1e16:	9c cf       	rjmp	.-200    	; 0x1d50 <xQueueGenericSend+0x34>
    1e18:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    1e1c:	99 cf       	rjmp	.-206    	; 0x1d50 <xQueueGenericSend+0x34>
    1e1e:	c7 01       	movw	r24, r14
    1e20:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
    1e24:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
    1e28:	93 cf       	rjmp	.-218    	; 0x1d50 <xQueueGenericSend+0x34>
    1e2a:	c7 01       	movw	r24, r14
    1e2c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
    1e30:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
    1e34:	80 e0       	ldi	r24, 0x00	; 0
    1e36:	29 96       	adiw	r28, 0x09	; 9
    1e38:	cd bf       	out	0x3d, r28	; 61
    1e3a:	de bf       	out	0x3e, r29	; 62
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	ff 90       	pop	r15
    1e46:	ef 90       	pop	r14
    1e48:	df 90       	pop	r13
    1e4a:	cf 90       	pop	r12
    1e4c:	bf 90       	pop	r11
    1e4e:	af 90       	pop	r10
    1e50:	08 95       	ret

00001e52 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1e52:	0f 93       	push	r16
    1e54:	1f 93       	push	r17
    1e56:	cf 93       	push	r28
    1e58:	df 93       	push	r29
    1e5a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e5c:	fc 01       	movw	r30, r24
    1e5e:	56 8d       	ldd	r21, Z+30	; 0x1e
    1e60:	37 8d       	ldd	r19, Z+31	; 0x1f
    1e62:	53 17       	cp	r21, r19
    1e64:	c0 f4       	brcc	.+48     	; 0x1e96 <xQueueGenericSendFromISR+0x44>
    1e66:	42 2f       	mov	r20, r18
    1e68:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e6a:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e6e:	8a a1       	ldd	r24, Y+34	; 0x22
    1e70:	8f 3f       	cpi	r24, 0xFF	; 255
    1e72:	69 f4       	brne	.+26     	; 0x1e8e <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e74:	8b 89       	ldd	r24, Y+19	; 0x13
    1e76:	88 23       	and	r24, r24
    1e78:	81 f0       	breq	.+32     	; 0x1e9a <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	43 96       	adiw	r24, 0x13	; 19
    1e7e:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1e82:	88 23       	and	r24, r24
    1e84:	61 f0       	breq	.+24     	; 0x1e9e <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1e86:	81 e0       	ldi	r24, 0x01	; 1
    1e88:	f8 01       	movw	r30, r16
    1e8a:	80 83       	st	Z, r24
    1e8c:	09 c0       	rjmp	.+18     	; 0x1ea0 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e8e:	8f 5f       	subi	r24, 0xFF	; 255
    1e90:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1e92:	81 e0       	ldi	r24, 0x01	; 1
    1e94:	05 c0       	rjmp	.+10     	; 0x1ea0 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e96:	80 e0       	ldi	r24, 0x00	; 0
    1e98:	03 c0       	rjmp	.+6      	; 0x1ea0 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1e9a:	81 e0       	ldi	r24, 0x01	; 1
    1e9c:	01 c0       	rjmp	.+2      	; 0x1ea0 <xQueueGenericSendFromISR+0x4e>
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	08 95       	ret

00001eaa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1eaa:	af 92       	push	r10
    1eac:	bf 92       	push	r11
    1eae:	cf 92       	push	r12
    1eb0:	df 92       	push	r13
    1eb2:	ef 92       	push	r14
    1eb4:	ff 92       	push	r15
    1eb6:	0f 93       	push	r16
    1eb8:	1f 93       	push	r17
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
    1ebe:	cd b7       	in	r28, 0x3d	; 61
    1ec0:	de b7       	in	r29, 0x3e	; 62
    1ec2:	29 97       	sbiw	r28, 0x09	; 9
    1ec4:	cd bf       	out	0x3d, r28	; 61
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	7c 01       	movw	r14, r24
    1eca:	5b 01       	movw	r10, r22
    1ecc:	2e 83       	std	Y+6, r18	; 0x06
    1ece:	3f 83       	std	Y+7, r19	; 0x07
    1ed0:	48 87       	std	Y+8, r20	; 0x08
    1ed2:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1ed4:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ed6:	6c 01       	movw	r12, r24
    1ed8:	83 e1       	ldi	r24, 0x13	; 19
    1eda:	c8 0e       	add	r12, r24
    1edc:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1ee4:	f7 01       	movw	r30, r14
    1ee6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ee8:	88 23       	and	r24, r24
    1eea:	99 f1       	breq	.+102    	; 0x1f52 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1eec:	c6 80       	ldd	r12, Z+6	; 0x06
    1eee:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1ef0:	b5 01       	movw	r22, r10
    1ef2:	c7 01       	movw	r24, r14
    1ef4:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ef8:	01 11       	cpse	r16, r1
    1efa:	1a c0       	rjmp	.+52     	; 0x1f30 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1efc:	f7 01       	movw	r30, r14
    1efe:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f00:	81 50       	subi	r24, 0x01	; 1
    1f02:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f04:	80 81       	ld	r24, Z
    1f06:	91 81       	ldd	r25, Z+1	; 0x01
    1f08:	89 2b       	or	r24, r25
    1f0a:	29 f4       	brne	.+10     	; 0x1f16 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1f0c:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <xTaskGetCurrentTaskHandle>
    1f10:	f7 01       	movw	r30, r14
    1f12:	82 83       	std	Z+2, r24	; 0x02
    1f14:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f16:	f7 01       	movw	r30, r14
    1f18:	80 85       	ldd	r24, Z+8	; 0x08
    1f1a:	88 23       	and	r24, r24
    1f1c:	b1 f0       	breq	.+44     	; 0x1f4a <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f1e:	c7 01       	movw	r24, r14
    1f20:	08 96       	adiw	r24, 0x08	; 8
    1f22:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1f26:	81 30       	cpi	r24, 0x01	; 1
    1f28:	81 f4       	brne	.+32     	; 0x1f4a <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1f2a:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    1f2e:	0d c0       	rjmp	.+26     	; 0x1f4a <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f30:	f7 01       	movw	r30, r14
    1f32:	c6 82       	std	Z+6, r12	; 0x06
    1f34:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f36:	83 89       	ldd	r24, Z+19	; 0x13
    1f38:	88 23       	and	r24, r24
    1f3a:	39 f0       	breq	.+14     	; 0x1f4a <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f3c:	c7 01       	movw	r24, r14
    1f3e:	43 96       	adiw	r24, 0x13	; 19
    1f40:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    1f44:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f46:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1f4a:	0f 90       	pop	r0
    1f4c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f4e:	81 e0       	ldi	r24, 0x01	; 1
    1f50:	62 c0       	rjmp	.+196    	; 0x2016 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1f52:	8e 81       	ldd	r24, Y+6	; 0x06
    1f54:	9f 81       	ldd	r25, Y+7	; 0x07
    1f56:	a8 85       	ldd	r26, Y+8	; 0x08
    1f58:	b9 85       	ldd	r27, Y+9	; 0x09
    1f5a:	89 2b       	or	r24, r25
    1f5c:	8a 2b       	or	r24, r26
    1f5e:	8b 2b       	or	r24, r27
    1f60:	21 f4       	brne	.+8      	; 0x1f6a <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f62:	0f 90       	pop	r0
    1f64:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	56 c0       	rjmp	.+172    	; 0x2016 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f6a:	11 11       	cpse	r17, r1
    1f6c:	05 c0       	rjmp	.+10     	; 0x1f78 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f6e:	ce 01       	movw	r24, r28
    1f70:	01 96       	adiw	r24, 0x01	; 1
    1f72:	0e 94 82 14 	call	0x2904	; 0x2904 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f76:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f7c:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f80:	0f b6       	in	r0, 0x3f	; 63
    1f82:	f8 94       	cli
    1f84:	0f 92       	push	r0
    1f86:	f7 01       	movw	r30, r14
    1f88:	81 a1       	ldd	r24, Z+33	; 0x21
    1f8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f8c:	09 f4       	brne	.+2      	; 0x1f90 <xQueueGenericReceive+0xe6>
    1f8e:	11 a2       	std	Z+33, r1	; 0x21
    1f90:	f7 01       	movw	r30, r14
    1f92:	82 a1       	ldd	r24, Z+34	; 0x22
    1f94:	8f 3f       	cpi	r24, 0xFF	; 255
    1f96:	09 f4       	brne	.+2      	; 0x1f9a <xQueueGenericReceive+0xf0>
    1f98:	12 a2       	std	Z+34, r1	; 0x22
    1f9a:	0f 90       	pop	r0
    1f9c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f9e:	be 01       	movw	r22, r28
    1fa0:	6a 5f       	subi	r22, 0xFA	; 250
    1fa2:	7f 4f       	sbci	r23, 0xFF	; 255
    1fa4:	ce 01       	movw	r24, r28
    1fa6:	01 96       	adiw	r24, 0x01	; 1
    1fa8:	0e 94 93 14 	call	0x2926	; 0x2926 <xTaskCheckForTimeOut>
    1fac:	81 11       	cpse	r24, r1
    1fae:	2d c0       	rjmp	.+90     	; 0x200a <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1fb0:	0f b6       	in	r0, 0x3f	; 63
    1fb2:	f8 94       	cli
    1fb4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1fb6:	f7 01       	movw	r30, r14
    1fb8:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1fba:	0f 90       	pop	r0
    1fbc:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fbe:	81 11       	cpse	r24, r1
    1fc0:	1e c0       	rjmp	.+60     	; 0x1ffe <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1fc2:	80 81       	ld	r24, Z
    1fc4:	91 81       	ldd	r25, Z+1	; 0x01
    1fc6:	89 2b       	or	r24, r25
    1fc8:	49 f4       	brne	.+18     	; 0x1fdc <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    1fca:	0f b6       	in	r0, 0x3f	; 63
    1fcc:	f8 94       	cli
    1fce:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1fd0:	82 81       	ldd	r24, Z+2	; 0x02
    1fd2:	93 81       	ldd	r25, Z+3	; 0x03
    1fd4:	0e 94 22 15 	call	0x2a44	; 0x2a44 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1fd8:	0f 90       	pop	r0
    1fda:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fdc:	4e 81       	ldd	r20, Y+6	; 0x06
    1fde:	5f 81       	ldd	r21, Y+7	; 0x07
    1fe0:	68 85       	ldd	r22, Y+8	; 0x08
    1fe2:	79 85       	ldd	r23, Y+9	; 0x09
    1fe4:	c6 01       	movw	r24, r12
    1fe6:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fea:	c7 01       	movw	r24, r14
    1fec:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ff0:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
    1ff4:	81 11       	cpse	r24, r1
    1ff6:	73 cf       	rjmp	.-282    	; 0x1ede <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1ff8:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    1ffc:	70 cf       	rjmp	.-288    	; 0x1ede <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ffe:	c7 01       	movw	r24, r14
    2000:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2004:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
    2008:	6a cf       	rjmp	.-300    	; 0x1ede <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    200a:	c7 01       	movw	r24, r14
    200c:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2010:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2014:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2016:	29 96       	adiw	r28, 0x09	; 9
    2018:	cd bf       	out	0x3d, r28	; 61
    201a:	de bf       	out	0x3e, r29	; 62
    201c:	df 91       	pop	r29
    201e:	cf 91       	pop	r28
    2020:	1f 91       	pop	r17
    2022:	0f 91       	pop	r16
    2024:	ff 90       	pop	r15
    2026:	ef 90       	pop	r14
    2028:	df 90       	pop	r13
    202a:	cf 90       	pop	r12
    202c:	bf 90       	pop	r11
    202e:	af 90       	pop	r10
    2030:	08 95       	ret

00002032 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2032:	0f 93       	push	r16
    2034:	1f 93       	push	r17
    2036:	cf 93       	push	r28
    2038:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    203a:	fc 01       	movw	r30, r24
    203c:	26 8d       	ldd	r18, Z+30	; 0x1e
    203e:	22 23       	and	r18, r18
    2040:	d9 f0       	breq	.+54     	; 0x2078 <xQueueReceiveFromISR+0x46>
    2042:	8a 01       	movw	r16, r20
    2044:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2046:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    204a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    204c:	81 50       	subi	r24, 0x01	; 1
    204e:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2050:	89 a1       	ldd	r24, Y+33	; 0x21
    2052:	8f 3f       	cpi	r24, 0xFF	; 255
    2054:	69 f4       	brne	.+26     	; 0x2070 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2056:	88 85       	ldd	r24, Y+8	; 0x08
    2058:	88 23       	and	r24, r24
    205a:	81 f0       	breq	.+32     	; 0x207c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    205c:	ce 01       	movw	r24, r28
    205e:	08 96       	adiw	r24, 0x08	; 8
    2060:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskRemoveFromEventList>
    2064:	88 23       	and	r24, r24
    2066:	61 f0       	breq	.+24     	; 0x2080 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2068:	81 e0       	ldi	r24, 0x01	; 1
    206a:	f8 01       	movw	r30, r16
    206c:	80 83       	st	Z, r24
    206e:	09 c0       	rjmp	.+18     	; 0x2082 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2070:	8f 5f       	subi	r24, 0xFF	; 255
    2072:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	05 c0       	rjmp	.+10     	; 0x2082 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2078:	80 e0       	ldi	r24, 0x00	; 0
    207a:	03 c0       	rjmp	.+6      	; 0x2082 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	01 c0       	rjmp	.+2      	; 0x2082 <xQueueReceiveFromISR+0x50>
    2080:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2082:	df 91       	pop	r29
    2084:	cf 91       	pop	r28
    2086:	1f 91       	pop	r17
    2088:	0f 91       	pop	r16
    208a:	08 95       	ret

0000208c <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	f8 94       	cli
    2090:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2092:	fc 01       	movw	r30, r24
    2094:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2096:	0f 90       	pop	r0
    2098:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    209a:	08 95       	ret

0000209c <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    209c:	fc 01       	movw	r30, r24
    209e:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    20a0:	08 95       	ret

000020a2 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    20a2:	c2 e9       	ldi	r28, 0x92	; 146
    20a4:	d1 e3       	ldi	r29, 0x31	; 49
    20a6:	88 81       	ld	r24, Y
    20a8:	82 30       	cpi	r24, 0x02	; 2
    20aa:	e8 f3       	brcs	.-6      	; 0x20a6 <prvIdleTask+0x4>
    20ac:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    20b0:	fa cf       	rjmp	.-12     	; 0x20a6 <prvIdleTask+0x4>

000020b2 <prvAddCurrentTaskToDelayedList>:
    20b2:	cf 92       	push	r12
    20b4:	df 92       	push	r13
    20b6:	ef 92       	push	r14
    20b8:	ff 92       	push	r15
    20ba:	6b 01       	movw	r12, r22
    20bc:	7c 01       	movw	r14, r24
    20be:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    20c2:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    20c6:	62 83       	std	Z+2, r22	; 0x02
    20c8:	73 83       	std	Z+3, r23	; 0x03
    20ca:	84 83       	std	Z+4, r24	; 0x04
    20cc:	95 83       	std	Z+5, r25	; 0x05
    20ce:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    20d2:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    20d6:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    20da:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    20de:	c8 16       	cp	r12, r24
    20e0:	d9 06       	cpc	r13, r25
    20e2:	ea 06       	cpc	r14, r26
    20e4:	fb 06       	cpc	r15, r27
    20e6:	68 f4       	brcc	.+26     	; 0x2102 <prvAddCurrentTaskToDelayedList+0x50>
    20e8:	60 91 be 31 	lds	r22, 0x31BE	; 0x8031be <pxCurrentTCB>
    20ec:	70 91 bf 31 	lds	r23, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    20f0:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <pxOverflowDelayedTaskList>
    20f4:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <pxOverflowDelayedTaskList+0x1>
    20f8:	6e 5f       	subi	r22, 0xFE	; 254
    20fa:	7f 4f       	sbci	r23, 0xFF	; 255
    20fc:	0e 94 88 0b 	call	0x1710	; 0x1710 <vListInsert>
    2100:	21 c0       	rjmp	.+66     	; 0x2144 <prvAddCurrentTaskToDelayedList+0x92>
    2102:	60 91 be 31 	lds	r22, 0x31BE	; 0x8031be <pxCurrentTCB>
    2106:	70 91 bf 31 	lds	r23, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    210a:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <pxDelayedTaskList>
    210e:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    2112:	6e 5f       	subi	r22, 0xFE	; 254
    2114:	7f 4f       	sbci	r23, 0xFF	; 255
    2116:	0e 94 88 0b 	call	0x1710	; 0x1710 <vListInsert>
    211a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    211e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2122:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2126:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    212a:	c8 16       	cp	r12, r24
    212c:	d9 06       	cpc	r13, r25
    212e:	ea 06       	cpc	r14, r26
    2130:	fb 06       	cpc	r15, r27
    2132:	40 f4       	brcc	.+16     	; 0x2144 <prvAddCurrentTaskToDelayedList+0x92>
    2134:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2138:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    213c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2140:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2144:	ff 90       	pop	r15
    2146:	ef 90       	pop	r14
    2148:	df 90       	pop	r13
    214a:	cf 90       	pop	r12
    214c:	08 95       	ret

0000214e <xTaskGenericCreate>:
    214e:	4f 92       	push	r4
    2150:	5f 92       	push	r5
    2152:	6f 92       	push	r6
    2154:	7f 92       	push	r7
    2156:	8f 92       	push	r8
    2158:	9f 92       	push	r9
    215a:	af 92       	push	r10
    215c:	bf 92       	push	r11
    215e:	cf 92       	push	r12
    2160:	df 92       	push	r13
    2162:	ef 92       	push	r14
    2164:	ff 92       	push	r15
    2166:	0f 93       	push	r16
    2168:	1f 93       	push	r17
    216a:	cf 93       	push	r28
    216c:	df 93       	push	r29
    216e:	5c 01       	movw	r10, r24
    2170:	4b 01       	movw	r8, r22
    2172:	3a 01       	movw	r6, r20
    2174:	29 01       	movw	r4, r18
    2176:	88 e2       	ldi	r24, 0x28	; 40
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    217e:	ec 01       	movw	r28, r24
    2180:	89 2b       	or	r24, r25
    2182:	09 f4       	brne	.+2      	; 0x2186 <xTaskGenericCreate+0x38>
    2184:	d4 c0       	rjmp	.+424    	; 0x232e <xTaskGenericCreate+0x1e0>
    2186:	c1 14       	cp	r12, r1
    2188:	d1 04       	cpc	r13, r1
    218a:	09 f0       	breq	.+2      	; 0x218e <xTaskGenericCreate+0x40>
    218c:	cc c0       	rjmp	.+408    	; 0x2326 <xTaskGenericCreate+0x1d8>
    218e:	c3 01       	movw	r24, r6
    2190:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    2194:	8b 8f       	std	Y+27, r24	; 0x1b
    2196:	9c 8f       	std	Y+28, r25	; 0x1c
    2198:	00 97       	sbiw	r24, 0x00	; 0
    219a:	21 f4       	brne	.+8      	; 0x21a4 <xTaskGenericCreate+0x56>
    219c:	ce 01       	movw	r24, r28
    219e:	0e 94 14 0b 	call	0x1628	; 0x1628 <vPortFree>
    21a2:	c5 c0       	rjmp	.+394    	; 0x232e <xTaskGenericCreate+0x1e0>
    21a4:	a3 01       	movw	r20, r6
    21a6:	61 e1       	ldi	r22, 0x11	; 17
    21a8:	70 e0       	ldi	r23, 0x00	; 0
    21aa:	0e 94 b5 22 	call	0x456a	; 0x456a <memset>
    21ae:	93 01       	movw	r18, r6
    21b0:	21 50       	subi	r18, 0x01	; 1
    21b2:	31 09       	sbc	r19, r1
    21b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21b6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    21b8:	3c 01       	movw	r6, r24
    21ba:	62 0e       	add	r6, r18
    21bc:	73 1e       	adc	r7, r19
    21be:	4a e0       	ldi	r20, 0x0A	; 10
    21c0:	50 e0       	ldi	r21, 0x00	; 0
    21c2:	b4 01       	movw	r22, r8
    21c4:	ce 01       	movw	r24, r28
    21c6:	4d 96       	adiw	r24, 0x1d	; 29
    21c8:	0e 94 bc 22 	call	0x4578	; 0x4578 <strncpy>
    21cc:	1e a2       	std	Y+38, r1	; 0x26
    21ce:	10 2f       	mov	r17, r16
    21d0:	04 30       	cpi	r16, 0x04	; 4
    21d2:	08 f0       	brcs	.+2      	; 0x21d6 <xTaskGenericCreate+0x88>
    21d4:	13 e0       	ldi	r17, 0x03	; 3
    21d6:	1a 8f       	std	Y+26, r17	; 0x1a
    21d8:	1f a3       	std	Y+39, r17	; 0x27
    21da:	6e 01       	movw	r12, r28
    21dc:	22 e0       	ldi	r18, 0x02	; 2
    21de:	c2 0e       	add	r12, r18
    21e0:	d1 1c       	adc	r13, r1
    21e2:	c6 01       	movw	r24, r12
    21e4:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <vListInitialiseItem>
    21e8:	ce 01       	movw	r24, r28
    21ea:	0e 96       	adiw	r24, 0x0e	; 14
    21ec:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <vListInitialiseItem>
    21f0:	ca 87       	std	Y+10, r28	; 0x0a
    21f2:	db 87       	std	Y+11, r29	; 0x0b
    21f4:	84 e0       	ldi	r24, 0x04	; 4
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	a0 e0       	ldi	r26, 0x00	; 0
    21fa:	b0 e0       	ldi	r27, 0x00	; 0
    21fc:	81 1b       	sub	r24, r17
    21fe:	91 09       	sbc	r25, r1
    2200:	a1 09       	sbc	r26, r1
    2202:	b1 09       	sbc	r27, r1
    2204:	8e 87       	std	Y+14, r24	; 0x0e
    2206:	9f 87       	std	Y+15, r25	; 0x0f
    2208:	a8 8b       	std	Y+16, r26	; 0x10
    220a:	b9 8b       	std	Y+17, r27	; 0x11
    220c:	ce 8b       	std	Y+22, r28	; 0x16
    220e:	df 8b       	std	Y+23, r29	; 0x17
    2210:	a2 01       	movw	r20, r4
    2212:	b5 01       	movw	r22, r10
    2214:	c3 01       	movw	r24, r6
    2216:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <pxPortInitialiseStack>
    221a:	88 83       	st	Y, r24
    221c:	99 83       	std	Y+1, r25	; 0x01
    221e:	e1 14       	cp	r14, r1
    2220:	f1 04       	cpc	r15, r1
    2222:	19 f0       	breq	.+6      	; 0x222a <xTaskGenericCreate+0xdc>
    2224:	f7 01       	movw	r30, r14
    2226:	c0 83       	st	Z, r28
    2228:	d1 83       	std	Z+1, r29	; 0x01
    222a:	0f b6       	in	r0, 0x3f	; 63
    222c:	f8 94       	cli
    222e:	0f 92       	push	r0
    2230:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <uxCurrentNumberOfTasks>
    2234:	8f 5f       	subi	r24, 0xFF	; 255
    2236:	80 93 6a 31 	sts	0x316A, r24	; 0x80316a <uxCurrentNumberOfTasks>
    223a:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    223e:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2242:	89 2b       	or	r24, r25
    2244:	89 f5       	brne	.+98     	; 0x22a8 <xTaskGenericCreate+0x15a>
    2246:	c0 93 be 31 	sts	0x31BE, r28	; 0x8031be <pxCurrentTCB>
    224a:	d0 93 bf 31 	sts	0x31BF, r29	; 0x8031bf <pxCurrentTCB+0x1>
    224e:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <uxCurrentNumberOfTasks>
    2252:	81 30       	cpi	r24, 0x01	; 1
    2254:	c1 f5       	brne	.+112    	; 0x22c6 <xTaskGenericCreate+0x178>
    2256:	82 e9       	ldi	r24, 0x92	; 146
    2258:	91 e3       	ldi	r25, 0x31	; 49
    225a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    225e:	8d e9       	ldi	r24, 0x9D	; 157
    2260:	91 e3       	ldi	r25, 0x31	; 49
    2262:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    2266:	88 ea       	ldi	r24, 0xA8	; 168
    2268:	91 e3       	ldi	r25, 0x31	; 49
    226a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    226e:	83 eb       	ldi	r24, 0xB3	; 179
    2270:	91 e3       	ldi	r25, 0x31	; 49
    2272:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    2276:	87 e8       	ldi	r24, 0x87	; 135
    2278:	91 e3       	ldi	r25, 0x31	; 49
    227a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    227e:	8c e7       	ldi	r24, 0x7C	; 124
    2280:	91 e3       	ldi	r25, 0x31	; 49
    2282:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    2286:	8d e6       	ldi	r24, 0x6D	; 109
    2288:	91 e3       	ldi	r25, 0x31	; 49
    228a:	0e 94 4c 0b 	call	0x1698	; 0x1698 <vListInitialise>
    228e:	87 e8       	ldi	r24, 0x87	; 135
    2290:	91 e3       	ldi	r25, 0x31	; 49
    2292:	80 93 7a 31 	sts	0x317A, r24	; 0x80317a <pxDelayedTaskList>
    2296:	90 93 7b 31 	sts	0x317B, r25	; 0x80317b <pxDelayedTaskList+0x1>
    229a:	8c e7       	ldi	r24, 0x7C	; 124
    229c:	91 e3       	ldi	r25, 0x31	; 49
    229e:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <pxOverflowDelayedTaskList>
    22a2:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <pxOverflowDelayedTaskList+0x1>
    22a6:	0f c0       	rjmp	.+30     	; 0x22c6 <xTaskGenericCreate+0x178>
    22a8:	80 91 63 31 	lds	r24, 0x3163	; 0x803163 <xSchedulerRunning>
    22ac:	81 11       	cpse	r24, r1
    22ae:	0b c0       	rjmp	.+22     	; 0x22c6 <xTaskGenericCreate+0x178>
    22b0:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    22b4:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    22b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22ba:	08 17       	cp	r16, r24
    22bc:	20 f0       	brcs	.+8      	; 0x22c6 <xTaskGenericCreate+0x178>
    22be:	c0 93 be 31 	sts	0x31BE, r28	; 0x8031be <pxCurrentTCB>
    22c2:	d0 93 bf 31 	sts	0x31BF, r29	; 0x8031bf <pxCurrentTCB+0x1>
    22c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22c8:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <uxTopUsedPriority>
    22cc:	98 17       	cp	r25, r24
    22ce:	10 f4       	brcc	.+4      	; 0x22d4 <xTaskGenericCreate+0x186>
    22d0:	80 93 65 31 	sts	0x3165, r24	; 0x803165 <uxTopUsedPriority>
    22d4:	90 91 5e 31 	lds	r25, 0x315E	; 0x80315e <uxTaskNumber>
    22d8:	9f 5f       	subi	r25, 0xFF	; 255
    22da:	90 93 5e 31 	sts	0x315E, r25	; 0x80315e <uxTaskNumber>
    22de:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    22e2:	98 17       	cp	r25, r24
    22e4:	10 f4       	brcc	.+4      	; 0x22ea <xTaskGenericCreate+0x19c>
    22e6:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    22ea:	fb e0       	ldi	r31, 0x0B	; 11
    22ec:	8f 9f       	mul	r24, r31
    22ee:	c0 01       	movw	r24, r0
    22f0:	11 24       	eor	r1, r1
    22f2:	b6 01       	movw	r22, r12
    22f4:	8e 56       	subi	r24, 0x6E	; 110
    22f6:	9e 4c       	sbci	r25, 0xCE	; 206
    22f8:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
    22fc:	0f 90       	pop	r0
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	80 91 63 31 	lds	r24, 0x3163	; 0x803163 <xSchedulerRunning>
    2304:	88 23       	and	r24, r24
    2306:	59 f0       	breq	.+22     	; 0x231e <xTaskGenericCreate+0x1d0>
    2308:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    230c:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2310:	82 8d       	ldd	r24, Z+26	; 0x1a
    2312:	80 17       	cp	r24, r16
    2314:	30 f4       	brcc	.+12     	; 0x2322 <xTaskGenericCreate+0x1d4>
    2316:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	09 c0       	rjmp	.+18     	; 0x2330 <xTaskGenericCreate+0x1e2>
    231e:	81 e0       	ldi	r24, 0x01	; 1
    2320:	07 c0       	rjmp	.+14     	; 0x2330 <xTaskGenericCreate+0x1e2>
    2322:	81 e0       	ldi	r24, 0x01	; 1
    2324:	05 c0       	rjmp	.+10     	; 0x2330 <xTaskGenericCreate+0x1e2>
    2326:	cb 8e       	std	Y+27, r12	; 0x1b
    2328:	dc 8e       	std	Y+28, r13	; 0x1c
    232a:	c6 01       	movw	r24, r12
    232c:	3b cf       	rjmp	.-394    	; 0x21a4 <xTaskGenericCreate+0x56>
    232e:	8f ef       	ldi	r24, 0xFF	; 255
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	df 90       	pop	r13
    233e:	cf 90       	pop	r12
    2340:	bf 90       	pop	r11
    2342:	af 90       	pop	r10
    2344:	9f 90       	pop	r9
    2346:	8f 90       	pop	r8
    2348:	7f 90       	pop	r7
    234a:	6f 90       	pop	r6
    234c:	5f 90       	pop	r5
    234e:	4f 90       	pop	r4
    2350:	08 95       	ret

00002352 <uxTaskPriorityGet>:
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	0f 92       	push	r0
    2358:	00 97       	sbiw	r24, 0x00	; 0
    235a:	21 f4       	brne	.+8      	; 0x2364 <uxTaskPriorityGet+0x12>
    235c:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2360:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2364:	0f 90       	pop	r0
    2366:	0f be       	out	0x3f, r0	; 63
    2368:	fc 01       	movw	r30, r24
    236a:	82 8d       	ldd	r24, Z+26	; 0x1a
    236c:	08 95       	ret

0000236e <vTaskStartScheduler>:
    236e:	af 92       	push	r10
    2370:	bf 92       	push	r11
    2372:	cf 92       	push	r12
    2374:	df 92       	push	r13
    2376:	ef 92       	push	r14
    2378:	ff 92       	push	r15
    237a:	0f 93       	push	r16
    237c:	a1 2c       	mov	r10, r1
    237e:	b1 2c       	mov	r11, r1
    2380:	c1 2c       	mov	r12, r1
    2382:	d1 2c       	mov	r13, r1
    2384:	0f 2e       	mov	r0, r31
    2386:	fb e6       	ldi	r31, 0x6B	; 107
    2388:	ef 2e       	mov	r14, r31
    238a:	f1 e3       	ldi	r31, 0x31	; 49
    238c:	ff 2e       	mov	r15, r31
    238e:	f0 2d       	mov	r31, r0
    2390:	00 e0       	ldi	r16, 0x00	; 0
    2392:	20 e0       	ldi	r18, 0x00	; 0
    2394:	30 e0       	ldi	r19, 0x00	; 0
    2396:	44 e6       	ldi	r20, 0x64	; 100
    2398:	50 e0       	ldi	r21, 0x00	; 0
    239a:	64 ea       	ldi	r22, 0xA4	; 164
    239c:	70 e2       	ldi	r23, 0x20	; 32
    239e:	81 e5       	ldi	r24, 0x51	; 81
    23a0:	90 e1       	ldi	r25, 0x10	; 16
    23a2:	0e 94 a7 10 	call	0x214e	; 0x214e <xTaskGenericCreate>
    23a6:	81 30       	cpi	r24, 0x01	; 1
    23a8:	69 f4       	brne	.+26     	; 0x23c4 <vTaskStartScheduler+0x56>
    23aa:	f8 94       	cli
    23ac:	80 93 63 31 	sts	0x3163, r24	; 0x803163 <xSchedulerRunning>
    23b0:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <xTickCount>
    23b4:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <xTickCount+0x1>
    23b8:	10 92 68 31 	sts	0x3168, r1	; 0x803168 <xTickCount+0x2>
    23bc:	10 92 69 31 	sts	0x3169, r1	; 0x803169 <xTickCount+0x3>
    23c0:	0e 94 6f 0c 	call	0x18de	; 0x18de <xPortStartScheduler>
    23c4:	0f 91       	pop	r16
    23c6:	ff 90       	pop	r15
    23c8:	ef 90       	pop	r14
    23ca:	df 90       	pop	r13
    23cc:	cf 90       	pop	r12
    23ce:	bf 90       	pop	r11
    23d0:	af 90       	pop	r10
    23d2:	08 95       	ret

000023d4 <vTaskSuspendAll>:
    23d4:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    23d8:	8f 5f       	subi	r24, 0xFF	; 255
    23da:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <uxSchedulerSuspended>
    23de:	08 95       	ret

000023e0 <xTaskGetTickCount>:
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	0f 92       	push	r0
    23e6:	60 91 66 31 	lds	r22, 0x3166	; 0x803166 <xTickCount>
    23ea:	70 91 67 31 	lds	r23, 0x3167	; 0x803167 <xTickCount+0x1>
    23ee:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <xTickCount+0x2>
    23f2:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <xTickCount+0x3>
    23f6:	0f 90       	pop	r0
    23f8:	0f be       	out	0x3f, r0	; 63
    23fa:	08 95       	ret

000023fc <pcTaskGetTaskName>:
    23fc:	00 97       	sbiw	r24, 0x00	; 0
    23fe:	21 f4       	brne	.+8      	; 0x2408 <pcTaskGetTaskName+0xc>
    2400:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2404:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2408:	4d 96       	adiw	r24, 0x1d	; 29
    240a:	08 95       	ret

0000240c <xTaskGetIdleTaskHandle>:
    240c:	80 91 6b 31 	lds	r24, 0x316B	; 0x80316b <xIdleTaskHandle>
    2410:	90 91 6c 31 	lds	r25, 0x316C	; 0x80316c <xIdleTaskHandle+0x1>
    2414:	08 95       	ret

00002416 <vTaskIncrementTick>:
    2416:	ff 92       	push	r15
    2418:	0f 93       	push	r16
    241a:	1f 93       	push	r17
    241c:	cf 93       	push	r28
    241e:	df 93       	push	r29
    2420:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    2424:	81 11       	cpse	r24, r1
    2426:	ed c0       	rjmp	.+474    	; 0x2602 <vTaskIncrementTick+0x1ec>
    2428:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    242c:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    2430:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    2434:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    2438:	01 96       	adiw	r24, 0x01	; 1
    243a:	a1 1d       	adc	r26, r1
    243c:	b1 1d       	adc	r27, r1
    243e:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <xTickCount>
    2442:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <xTickCount+0x1>
    2446:	a0 93 68 31 	sts	0x3168, r26	; 0x803168 <xTickCount+0x2>
    244a:	b0 93 69 31 	sts	0x3169, r27	; 0x803169 <xTickCount+0x3>
    244e:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    2452:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    2456:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    245a:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    245e:	89 2b       	or	r24, r25
    2460:	8a 2b       	or	r24, r26
    2462:	8b 2b       	or	r24, r27
    2464:	f1 f5       	brne	.+124    	; 0x24e2 <vTaskIncrementTick+0xcc>
    2466:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <pxDelayedTaskList>
    246a:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    246e:	20 91 78 31 	lds	r18, 0x3178	; 0x803178 <pxOverflowDelayedTaskList>
    2472:	30 91 79 31 	lds	r19, 0x3179	; 0x803179 <pxOverflowDelayedTaskList+0x1>
    2476:	20 93 7a 31 	sts	0x317A, r18	; 0x80317a <pxDelayedTaskList>
    247a:	30 93 7b 31 	sts	0x317B, r19	; 0x80317b <pxDelayedTaskList+0x1>
    247e:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <pxOverflowDelayedTaskList>
    2482:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <pxOverflowDelayedTaskList+0x1>
    2486:	80 91 5f 31 	lds	r24, 0x315F	; 0x80315f <xNumOfOverflows>
    248a:	8f 5f       	subi	r24, 0xFF	; 255
    248c:	80 93 5f 31 	sts	0x315F, r24	; 0x80315f <xNumOfOverflows>
    2490:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    2494:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    2498:	80 81       	ld	r24, Z
    249a:	81 11       	cpse	r24, r1
    249c:	0c c0       	rjmp	.+24     	; 0x24b6 <vTaskIncrementTick+0xa0>
    249e:	8f ef       	ldi	r24, 0xFF	; 255
    24a0:	9f ef       	ldi	r25, 0xFF	; 255
    24a2:	dc 01       	movw	r26, r24
    24a4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    24a8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    24ac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    24b0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    24b4:	16 c0       	rjmp	.+44     	; 0x24e2 <vTaskIncrementTick+0xcc>
    24b6:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    24ba:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    24be:	07 80       	ldd	r0, Z+7	; 0x07
    24c0:	f0 85       	ldd	r31, Z+8	; 0x08
    24c2:	e0 2d       	mov	r30, r0
    24c4:	00 84       	ldd	r0, Z+8	; 0x08
    24c6:	f1 85       	ldd	r31, Z+9	; 0x09
    24c8:	e0 2d       	mov	r30, r0
    24ca:	82 81       	ldd	r24, Z+2	; 0x02
    24cc:	93 81       	ldd	r25, Z+3	; 0x03
    24ce:	a4 81       	ldd	r26, Z+4	; 0x04
    24d0:	b5 81       	ldd	r27, Z+5	; 0x05
    24d2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    24d6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    24da:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    24de:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    24e2:	40 91 66 31 	lds	r20, 0x3166	; 0x803166 <xTickCount>
    24e6:	50 91 67 31 	lds	r21, 0x3167	; 0x803167 <xTickCount+0x1>
    24ea:	60 91 68 31 	lds	r22, 0x3168	; 0x803168 <xTickCount+0x2>
    24ee:	70 91 69 31 	lds	r23, 0x3169	; 0x803169 <xTickCount+0x3>
    24f2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    24f6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    24fa:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    24fe:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2502:	48 17       	cp	r20, r24
    2504:	59 07       	cpc	r21, r25
    2506:	6a 07       	cpc	r22, r26
    2508:	7b 07       	cpc	r23, r27
    250a:	08 f4       	brcc	.+2      	; 0x250e <vTaskIncrementTick+0xf8>
    250c:	7f c0       	rjmp	.+254    	; 0x260c <vTaskIncrementTick+0x1f6>
    250e:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    2512:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    2516:	80 81       	ld	r24, Z
    2518:	88 23       	and	r24, r24
    251a:	f9 f0       	breq	.+62     	; 0x255a <vTaskIncrementTick+0x144>
    251c:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    2520:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    2524:	07 80       	ldd	r0, Z+7	; 0x07
    2526:	f0 85       	ldd	r31, Z+8	; 0x08
    2528:	e0 2d       	mov	r30, r0
    252a:	c0 85       	ldd	r28, Z+8	; 0x08
    252c:	d1 85       	ldd	r29, Z+9	; 0x09
    252e:	8a 81       	ldd	r24, Y+2	; 0x02
    2530:	9b 81       	ldd	r25, Y+3	; 0x03
    2532:	ac 81       	ldd	r26, Y+4	; 0x04
    2534:	bd 81       	ldd	r27, Y+5	; 0x05
    2536:	40 91 66 31 	lds	r20, 0x3166	; 0x803166 <xTickCount>
    253a:	50 91 67 31 	lds	r21, 0x3167	; 0x803167 <xTickCount+0x1>
    253e:	60 91 68 31 	lds	r22, 0x3168	; 0x803168 <xTickCount+0x2>
    2542:	70 91 69 31 	lds	r23, 0x3169	; 0x803169 <xTickCount+0x3>
    2546:	48 17       	cp	r20, r24
    2548:	59 07       	cpc	r21, r25
    254a:	6a 07       	cpc	r22, r26
    254c:	7b 07       	cpc	r23, r27
    254e:	58 f1       	brcs	.+86     	; 0x25a6 <vTaskIncrementTick+0x190>
    2550:	0f 2e       	mov	r0, r31
    2552:	fb e0       	ldi	r31, 0x0B	; 11
    2554:	ff 2e       	mov	r15, r31
    2556:	f0 2d       	mov	r31, r0
    2558:	2f c0       	rjmp	.+94     	; 0x25b8 <vTaskIncrementTick+0x1a2>
    255a:	8f ef       	ldi	r24, 0xFF	; 255
    255c:	9f ef       	ldi	r25, 0xFF	; 255
    255e:	dc 01       	movw	r26, r24
    2560:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2564:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2568:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    256c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2570:	4d c0       	rjmp	.+154    	; 0x260c <vTaskIncrementTick+0x1f6>
    2572:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    2576:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    257a:	07 80       	ldd	r0, Z+7	; 0x07
    257c:	f0 85       	ldd	r31, Z+8	; 0x08
    257e:	e0 2d       	mov	r30, r0
    2580:	c0 85       	ldd	r28, Z+8	; 0x08
    2582:	d1 85       	ldd	r29, Z+9	; 0x09
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
    2586:	9b 81       	ldd	r25, Y+3	; 0x03
    2588:	ac 81       	ldd	r26, Y+4	; 0x04
    258a:	bd 81       	ldd	r27, Y+5	; 0x05
    258c:	40 91 66 31 	lds	r20, 0x3166	; 0x803166 <xTickCount>
    2590:	50 91 67 31 	lds	r21, 0x3167	; 0x803167 <xTickCount+0x1>
    2594:	60 91 68 31 	lds	r22, 0x3168	; 0x803168 <xTickCount+0x2>
    2598:	70 91 69 31 	lds	r23, 0x3169	; 0x803169 <xTickCount+0x3>
    259c:	48 17       	cp	r20, r24
    259e:	59 07       	cpc	r21, r25
    25a0:	6a 07       	cpc	r22, r26
    25a2:	7b 07       	cpc	r23, r27
    25a4:	48 f4       	brcc	.+18     	; 0x25b8 <vTaskIncrementTick+0x1a2>
    25a6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    25aa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    25ae:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    25b2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    25b6:	2a c0       	rjmp	.+84     	; 0x260c <vTaskIncrementTick+0x1f6>
    25b8:	8e 01       	movw	r16, r28
    25ba:	0e 5f       	subi	r16, 0xFE	; 254
    25bc:	1f 4f       	sbci	r17, 0xFF	; 255
    25be:	c8 01       	movw	r24, r16
    25c0:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
    25c4:	88 8d       	ldd	r24, Y+24	; 0x18
    25c6:	99 8d       	ldd	r25, Y+25	; 0x19
    25c8:	89 2b       	or	r24, r25
    25ca:	21 f0       	breq	.+8      	; 0x25d4 <vTaskIncrementTick+0x1be>
    25cc:	ce 01       	movw	r24, r28
    25ce:	0e 96       	adiw	r24, 0x0e	; 14
    25d0:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
    25d4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25d6:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    25da:	98 17       	cp	r25, r24
    25dc:	10 f4       	brcc	.+4      	; 0x25e2 <vTaskIncrementTick+0x1cc>
    25de:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    25e2:	f8 9e       	mul	r15, r24
    25e4:	c0 01       	movw	r24, r0
    25e6:	11 24       	eor	r1, r1
    25e8:	b8 01       	movw	r22, r16
    25ea:	8e 56       	subi	r24, 0x6E	; 110
    25ec:	9e 4c       	sbci	r25, 0xCE	; 206
    25ee:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
    25f2:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <pxDelayedTaskList>
    25f6:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <pxDelayedTaskList+0x1>
    25fa:	80 81       	ld	r24, Z
    25fc:	81 11       	cpse	r24, r1
    25fe:	b9 cf       	rjmp	.-142    	; 0x2572 <vTaskIncrementTick+0x15c>
    2600:	ac cf       	rjmp	.-168    	; 0x255a <vTaskIncrementTick+0x144>
    2602:	80 91 61 31 	lds	r24, 0x3161	; 0x803161 <uxMissedTicks>
    2606:	8f 5f       	subi	r24, 0xFF	; 255
    2608:	80 93 61 31 	sts	0x3161, r24	; 0x803161 <uxMissedTicks>
    260c:	df 91       	pop	r29
    260e:	cf 91       	pop	r28
    2610:	1f 91       	pop	r17
    2612:	0f 91       	pop	r16
    2614:	ff 90       	pop	r15
    2616:	08 95       	ret

00002618 <xTaskResumeAll>:
    2618:	cf 92       	push	r12
    261a:	df 92       	push	r13
    261c:	ef 92       	push	r14
    261e:	ff 92       	push	r15
    2620:	0f 93       	push	r16
    2622:	1f 93       	push	r17
    2624:	cf 93       	push	r28
    2626:	df 93       	push	r29
    2628:	0f b6       	in	r0, 0x3f	; 63
    262a:	f8 94       	cli
    262c:	0f 92       	push	r0
    262e:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    2632:	81 50       	subi	r24, 0x01	; 1
    2634:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <uxSchedulerSuspended>
    2638:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    263c:	81 11       	cpse	r24, r1
    263e:	60 c0       	rjmp	.+192    	; 0x2700 <xTaskResumeAll+0xe8>
    2640:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <uxCurrentNumberOfTasks>
    2644:	81 11       	cpse	r24, r1
    2646:	2c c0       	rjmp	.+88     	; 0x26a0 <xTaskResumeAll+0x88>
    2648:	5e c0       	rjmp	.+188    	; 0x2706 <xTaskResumeAll+0xee>
    264a:	d7 01       	movw	r26, r14
    264c:	17 96       	adiw	r26, 0x07	; 7
    264e:	ed 91       	ld	r30, X+
    2650:	fc 91       	ld	r31, X
    2652:	18 97       	sbiw	r26, 0x08	; 8
    2654:	c0 85       	ldd	r28, Z+8	; 0x08
    2656:	d1 85       	ldd	r29, Z+9	; 0x09
    2658:	ce 01       	movw	r24, r28
    265a:	0e 96       	adiw	r24, 0x0e	; 14
    265c:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
    2660:	8e 01       	movw	r16, r28
    2662:	0e 5f       	subi	r16, 0xFE	; 254
    2664:	1f 4f       	sbci	r17, 0xFF	; 255
    2666:	c8 01       	movw	r24, r16
    2668:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
    266c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    266e:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    2672:	98 17       	cp	r25, r24
    2674:	10 f4       	brcc	.+4      	; 0x267a <xTaskResumeAll+0x62>
    2676:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    267a:	d8 9e       	mul	r13, r24
    267c:	c0 01       	movw	r24, r0
    267e:	11 24       	eor	r1, r1
    2680:	b8 01       	movw	r22, r16
    2682:	8e 56       	subi	r24, 0x6E	; 110
    2684:	9e 4c       	sbci	r25, 0xCE	; 206
    2686:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
    268a:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    268e:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2692:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2694:	82 8d       	ldd	r24, Z+26	; 0x1a
    2696:	98 17       	cp	r25, r24
    2698:	70 f0       	brcs	.+28     	; 0x26b6 <xTaskResumeAll+0x9e>
    269a:	cc 24       	eor	r12, r12
    269c:	c3 94       	inc	r12
    269e:	0b c0       	rjmp	.+22     	; 0x26b6 <xTaskResumeAll+0x9e>
    26a0:	c1 2c       	mov	r12, r1
    26a2:	0f 2e       	mov	r0, r31
    26a4:	fd e6       	ldi	r31, 0x6D	; 109
    26a6:	ef 2e       	mov	r14, r31
    26a8:	f1 e3       	ldi	r31, 0x31	; 49
    26aa:	ff 2e       	mov	r15, r31
    26ac:	f0 2d       	mov	r31, r0
    26ae:	0f 2e       	mov	r0, r31
    26b0:	fb e0       	ldi	r31, 0x0B	; 11
    26b2:	df 2e       	mov	r13, r31
    26b4:	f0 2d       	mov	r31, r0
    26b6:	f7 01       	movw	r30, r14
    26b8:	80 81       	ld	r24, Z
    26ba:	81 11       	cpse	r24, r1
    26bc:	c6 cf       	rjmp	.-116    	; 0x264a <xTaskResumeAll+0x32>
    26be:	80 91 61 31 	lds	r24, 0x3161	; 0x803161 <uxMissedTicks>
    26c2:	88 23       	and	r24, r24
    26c4:	81 f0       	breq	.+32     	; 0x26e6 <xTaskResumeAll+0xce>
    26c6:	80 91 61 31 	lds	r24, 0x3161	; 0x803161 <uxMissedTicks>
    26ca:	88 23       	and	r24, r24
    26cc:	99 f0       	breq	.+38     	; 0x26f4 <xTaskResumeAll+0xdc>
    26ce:	0e 94 0b 12 	call	0x2416	; 0x2416 <vTaskIncrementTick>
    26d2:	80 91 61 31 	lds	r24, 0x3161	; 0x803161 <uxMissedTicks>
    26d6:	81 50       	subi	r24, 0x01	; 1
    26d8:	80 93 61 31 	sts	0x3161, r24	; 0x803161 <uxMissedTicks>
    26dc:	80 91 61 31 	lds	r24, 0x3161	; 0x803161 <uxMissedTicks>
    26e0:	81 11       	cpse	r24, r1
    26e2:	f5 cf       	rjmp	.-22     	; 0x26ce <xTaskResumeAll+0xb6>
    26e4:	07 c0       	rjmp	.+14     	; 0x26f4 <xTaskResumeAll+0xdc>
    26e6:	f1 e0       	ldi	r31, 0x01	; 1
    26e8:	cf 16       	cp	r12, r31
    26ea:	21 f0       	breq	.+8      	; 0x26f4 <xTaskResumeAll+0xdc>
    26ec:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <xMissedYield>
    26f0:	81 30       	cpi	r24, 0x01	; 1
    26f2:	41 f4       	brne	.+16     	; 0x2704 <xTaskResumeAll+0xec>
    26f4:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <xMissedYield>
    26f8:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	03 c0       	rjmp	.+6      	; 0x2706 <xTaskResumeAll+0xee>
    2700:	80 e0       	ldi	r24, 0x00	; 0
    2702:	01 c0       	rjmp	.+2      	; 0x2706 <xTaskResumeAll+0xee>
    2704:	80 e0       	ldi	r24, 0x00	; 0
    2706:	0f 90       	pop	r0
    2708:	0f be       	out	0x3f, r0	; 63
    270a:	df 91       	pop	r29
    270c:	cf 91       	pop	r28
    270e:	1f 91       	pop	r17
    2710:	0f 91       	pop	r16
    2712:	ff 90       	pop	r15
    2714:	ef 90       	pop	r14
    2716:	df 90       	pop	r13
    2718:	cf 90       	pop	r12
    271a:	08 95       	ret

0000271c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    271c:	cf 92       	push	r12
    271e:	df 92       	push	r13
    2720:	ef 92       	push	r14
    2722:	ff 92       	push	r15
    2724:	6b 01       	movw	r12, r22
    2726:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2728:	67 2b       	or	r22, r23
    272a:	68 2b       	or	r22, r24
    272c:	69 2b       	or	r22, r25
    272e:	e9 f0       	breq	.+58     	; 0x276a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2730:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2734:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    2738:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    273c:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    2740:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    2744:	c8 0e       	add	r12, r24
    2746:	d9 1e       	adc	r13, r25
    2748:	ea 1e       	adc	r14, r26
    274a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    274c:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2750:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2754:	02 96       	adiw	r24, 0x02	; 2
    2756:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    275a:	c7 01       	movw	r24, r14
    275c:	b6 01       	movw	r22, r12
    275e:	0e 94 59 10 	call	0x20b2	; 0x20b2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2762:	0e 94 0c 13 	call	0x2618	; 0x2618 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2766:	81 11       	cpse	r24, r1
    2768:	02 c0       	rjmp	.+4      	; 0x276e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    276a:	0e 94 ad 0c 	call	0x195a	; 0x195a <vPortYield>
		}
	}
    276e:	ff 90       	pop	r15
    2770:	ef 90       	pop	r14
    2772:	df 90       	pop	r13
    2774:	cf 90       	pop	r12
    2776:	08 95       	ret

00002778 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2778:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    277c:	81 11       	cpse	r24, r1
    277e:	0c c0       	rjmp	.+24     	; 0x2798 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2780:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <uxTopReadyPriority>
    2784:	4b e0       	ldi	r20, 0x0B	; 11
    2786:	e4 9f       	mul	r30, r20
    2788:	f0 01       	movw	r30, r0
    278a:	11 24       	eor	r1, r1
    278c:	ee 56       	subi	r30, 0x6E	; 110
    278e:	fe 4c       	sbci	r31, 0xCE	; 206
    2790:	80 81       	ld	r24, Z
    2792:	88 23       	and	r24, r24
    2794:	29 f0       	breq	.+10     	; 0x27a0 <vTaskSwitchContext+0x28>
    2796:	14 c0       	rjmp	.+40     	; 0x27c0 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <xMissedYield>
    279e:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    27a0:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    27a2:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <uxTopReadyPriority>
    27a6:	81 50       	subi	r24, 0x01	; 1
    27a8:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    27ac:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <uxTopReadyPriority>
    27b0:	9e 9f       	mul	r25, r30
    27b2:	f0 01       	movw	r30, r0
    27b4:	11 24       	eor	r1, r1
    27b6:	ee 56       	subi	r30, 0x6E	; 110
    27b8:	fe 4c       	sbci	r31, 0xCE	; 206
    27ba:	80 81       	ld	r24, Z
    27bc:	88 23       	and	r24, r24
    27be:	89 f3       	breq	.-30     	; 0x27a2 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    27c0:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <uxTopReadyPriority>
    27c4:	28 2f       	mov	r18, r24
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	4b e0       	ldi	r20, 0x0B	; 11
    27ca:	84 9f       	mul	r24, r20
    27cc:	c0 01       	movw	r24, r0
    27ce:	11 24       	eor	r1, r1
    27d0:	dc 01       	movw	r26, r24
    27d2:	ae 56       	subi	r26, 0x6E	; 110
    27d4:	be 4c       	sbci	r27, 0xCE	; 206
    27d6:	11 96       	adiw	r26, 0x01	; 1
    27d8:	ed 91       	ld	r30, X+
    27da:	fc 91       	ld	r31, X
    27dc:	12 97       	sbiw	r26, 0x02	; 2
    27de:	04 80       	ldd	r0, Z+4	; 0x04
    27e0:	f5 81       	ldd	r31, Z+5	; 0x05
    27e2:	e0 2d       	mov	r30, r0
    27e4:	11 96       	adiw	r26, 0x01	; 1
    27e6:	ed 93       	st	X+, r30
    27e8:	fc 93       	st	X, r31
    27ea:	12 97       	sbiw	r26, 0x02	; 2
    27ec:	8b 56       	subi	r24, 0x6B	; 107
    27ee:	9e 4c       	sbci	r25, 0xCE	; 206
    27f0:	e8 17       	cp	r30, r24
    27f2:	f9 07       	cpc	r31, r25
    27f4:	61 f4       	brne	.+24     	; 0x280e <vTaskSwitchContext+0x96>
    27f6:	84 81       	ldd	r24, Z+4	; 0x04
    27f8:	95 81       	ldd	r25, Z+5	; 0x05
    27fa:	4b e0       	ldi	r20, 0x0B	; 11
    27fc:	42 9f       	mul	r20, r18
    27fe:	f0 01       	movw	r30, r0
    2800:	43 9f       	mul	r20, r19
    2802:	f0 0d       	add	r31, r0
    2804:	11 24       	eor	r1, r1
    2806:	ee 56       	subi	r30, 0x6E	; 110
    2808:	fe 4c       	sbci	r31, 0xCE	; 206
    280a:	81 83       	std	Z+1, r24	; 0x01
    280c:	92 83       	std	Z+2, r25	; 0x02
    280e:	8b e0       	ldi	r24, 0x0B	; 11
    2810:	82 9f       	mul	r24, r18
    2812:	f0 01       	movw	r30, r0
    2814:	83 9f       	mul	r24, r19
    2816:	f0 0d       	add	r31, r0
    2818:	11 24       	eor	r1, r1
    281a:	ee 56       	subi	r30, 0x6E	; 110
    281c:	fe 4c       	sbci	r31, 0xCE	; 206
    281e:	01 80       	ldd	r0, Z+1	; 0x01
    2820:	f2 81       	ldd	r31, Z+2	; 0x02
    2822:	e0 2d       	mov	r30, r0
    2824:	80 85       	ldd	r24, Z+8	; 0x08
    2826:	91 85       	ldd	r25, Z+9	; 0x09
    2828:	80 93 be 31 	sts	0x31BE, r24	; 0x8031be <pxCurrentTCB>
    282c:	90 93 bf 31 	sts	0x31BF, r25	; 0x8031bf <pxCurrentTCB+0x1>
    2830:	08 95       	ret

00002832 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2832:	cf 92       	push	r12
    2834:	df 92       	push	r13
    2836:	ef 92       	push	r14
    2838:	ff 92       	push	r15
    283a:	6a 01       	movw	r12, r20
    283c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    283e:	60 91 be 31 	lds	r22, 0x31BE	; 0x8031be <pxCurrentTCB>
    2842:	70 91 bf 31 	lds	r23, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2846:	62 5f       	subi	r22, 0xF2	; 242
    2848:	7f 4f       	sbci	r23, 0xFF	; 255
    284a:	0e 94 88 0b 	call	0x1710	; 0x1710 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    284e:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2852:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2856:	02 96       	adiw	r24, 0x02	; 2
    2858:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    285c:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    2860:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    2864:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    2868:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    286c:	bc 01       	movw	r22, r24
    286e:	cd 01       	movw	r24, r26
    2870:	6c 0d       	add	r22, r12
    2872:	7d 1d       	adc	r23, r13
    2874:	8e 1d       	adc	r24, r14
    2876:	9f 1d       	adc	r25, r15
    2878:	0e 94 59 10 	call	0x20b2	; 0x20b2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    287c:	ff 90       	pop	r15
    287e:	ef 90       	pop	r14
    2880:	df 90       	pop	r13
    2882:	cf 90       	pop	r12
    2884:	08 95       	ret

00002886 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2886:	0f 93       	push	r16
    2888:	1f 93       	push	r17
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    288e:	dc 01       	movw	r26, r24
    2890:	17 96       	adiw	r26, 0x07	; 7
    2892:	ed 91       	ld	r30, X+
    2894:	fc 91       	ld	r31, X
    2896:	18 97       	sbiw	r26, 0x08	; 8
    2898:	c0 85       	ldd	r28, Z+8	; 0x08
    289a:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    289c:	8e 01       	movw	r16, r28
    289e:	02 5f       	subi	r16, 0xF2	; 242
    28a0:	1f 4f       	sbci	r17, 0xFF	; 255
    28a2:	c8 01       	movw	r24, r16
    28a4:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    28a8:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <uxSchedulerSuspended>
    28ac:	81 11       	cpse	r24, r1
    28ae:	16 c0       	rjmp	.+44     	; 0x28dc <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    28b0:	0c 50       	subi	r16, 0x0C	; 12
    28b2:	11 09       	sbc	r17, r1
    28b4:	c8 01       	movw	r24, r16
    28b6:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    28ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28bc:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    28c0:	98 17       	cp	r25, r24
    28c2:	10 f4       	brcc	.+4      	; 0x28c8 <xTaskRemoveFromEventList+0x42>
    28c4:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    28c8:	bb e0       	ldi	r27, 0x0B	; 11
    28ca:	8b 9f       	mul	r24, r27
    28cc:	c0 01       	movw	r24, r0
    28ce:	11 24       	eor	r1, r1
    28d0:	b8 01       	movw	r22, r16
    28d2:	8e 56       	subi	r24, 0x6E	; 110
    28d4:	9e 4c       	sbci	r25, 0xCE	; 206
    28d6:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
    28da:	05 c0       	rjmp	.+10     	; 0x28e6 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    28dc:	b8 01       	movw	r22, r16
    28de:	8d e6       	ldi	r24, 0x6D	; 109
    28e0:	91 e3       	ldi	r25, 0x31	; 49
    28e2:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    28e6:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    28ea:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    28ee:	81 e0       	ldi	r24, 0x01	; 1
    28f0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    28f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    28f4:	29 17       	cp	r18, r25
    28f6:	08 f4       	brcc	.+2      	; 0x28fa <xTaskRemoveFromEventList+0x74>
    28f8:	80 e0       	ldi	r24, 0x00	; 0
}
    28fa:	df 91       	pop	r29
    28fc:	cf 91       	pop	r28
    28fe:	1f 91       	pop	r17
    2900:	0f 91       	pop	r16
    2902:	08 95       	ret

00002904 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2904:	20 91 5f 31 	lds	r18, 0x315F	; 0x80315f <xNumOfOverflows>
    2908:	fc 01       	movw	r30, r24
    290a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    290c:	40 91 66 31 	lds	r20, 0x3166	; 0x803166 <xTickCount>
    2910:	50 91 67 31 	lds	r21, 0x3167	; 0x803167 <xTickCount+0x1>
    2914:	60 91 68 31 	lds	r22, 0x3168	; 0x803168 <xTickCount+0x2>
    2918:	70 91 69 31 	lds	r23, 0x3169	; 0x803169 <xTickCount+0x3>
    291c:	41 83       	std	Z+1, r20	; 0x01
    291e:	52 83       	std	Z+2, r21	; 0x02
    2920:	63 83       	std	Z+3, r22	; 0x03
    2922:	74 83       	std	Z+4, r23	; 0x04
    2924:	08 95       	ret

00002926 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2926:	8f 92       	push	r8
    2928:	9f 92       	push	r9
    292a:	af 92       	push	r10
    292c:	bf 92       	push	r11
    292e:	cf 92       	push	r12
    2930:	df 92       	push	r13
    2932:	ef 92       	push	r14
    2934:	ff 92       	push	r15
    2936:	0f 93       	push	r16
    2938:	1f 93       	push	r17
    293a:	cf 93       	push	r28
    293c:	df 93       	push	r29
    293e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2946:	80 91 5f 31 	lds	r24, 0x315F	; 0x80315f <xNumOfOverflows>
    294a:	90 81       	ld	r25, Z
    294c:	98 17       	cp	r25, r24
    294e:	89 f0       	breq	.+34     	; 0x2972 <xTaskCheckForTimeOut+0x4c>
    2950:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    2954:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    2958:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    295c:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    2960:	01 81       	ldd	r16, Z+1	; 0x01
    2962:	12 81       	ldd	r17, Z+2	; 0x02
    2964:	23 81       	ldd	r18, Z+3	; 0x03
    2966:	34 81       	ldd	r19, Z+4	; 0x04
    2968:	80 17       	cp	r24, r16
    296a:	91 07       	cpc	r25, r17
    296c:	a2 07       	cpc	r26, r18
    296e:	b3 07       	cpc	r27, r19
    2970:	a8 f5       	brcc	.+106    	; 0x29dc <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2972:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <xTickCount>
    2976:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <xTickCount+0x1>
    297a:	a0 91 68 31 	lds	r26, 0x3168	; 0x803168 <xTickCount+0x2>
    297e:	b0 91 69 31 	lds	r27, 0x3169	; 0x803169 <xTickCount+0x3>
    2982:	c1 80       	ldd	r12, Z+1	; 0x01
    2984:	d2 80       	ldd	r13, Z+2	; 0x02
    2986:	e3 80       	ldd	r14, Z+3	; 0x03
    2988:	f4 80       	ldd	r15, Z+4	; 0x04
    298a:	eb 01       	movw	r28, r22
    298c:	08 81       	ld	r16, Y
    298e:	19 81       	ldd	r17, Y+1	; 0x01
    2990:	2a 81       	ldd	r18, Y+2	; 0x02
    2992:	3b 81       	ldd	r19, Y+3	; 0x03
    2994:	8c 19       	sub	r24, r12
    2996:	9d 09       	sbc	r25, r13
    2998:	ae 09       	sbc	r26, r14
    299a:	bf 09       	sbc	r27, r15
    299c:	80 17       	cp	r24, r16
    299e:	91 07       	cpc	r25, r17
    29a0:	a2 07       	cpc	r26, r18
    29a2:	b3 07       	cpc	r27, r19
    29a4:	e8 f4       	brcc	.+58     	; 0x29e0 <xTaskCheckForTimeOut+0xba>
    29a6:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    29a8:	80 90 66 31 	lds	r8, 0x3166	; 0x803166 <xTickCount>
    29ac:	90 90 67 31 	lds	r9, 0x3167	; 0x803167 <xTickCount+0x1>
    29b0:	a0 90 68 31 	lds	r10, 0x3168	; 0x803168 <xTickCount+0x2>
    29b4:	b0 90 69 31 	lds	r11, 0x3169	; 0x803169 <xTickCount+0x3>
    29b8:	b5 01       	movw	r22, r10
    29ba:	a4 01       	movw	r20, r8
    29bc:	4c 19       	sub	r20, r12
    29be:	5d 09       	sbc	r21, r13
    29c0:	6e 09       	sbc	r22, r14
    29c2:	7f 09       	sbc	r23, r15
    29c4:	04 1b       	sub	r16, r20
    29c6:	15 0b       	sbc	r17, r21
    29c8:	26 0b       	sbc	r18, r22
    29ca:	37 0b       	sbc	r19, r23
    29cc:	08 83       	st	Y, r16
    29ce:	19 83       	std	Y+1, r17	; 0x01
    29d0:	2a 83       	std	Y+2, r18	; 0x02
    29d2:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    29d4:	0e 94 82 14 	call	0x2904	; 0x2904 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	03 c0       	rjmp	.+6      	; 0x29e2 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    29dc:	81 e0       	ldi	r24, 0x01	; 1
    29de:	01 c0       	rjmp	.+2      	; 0x29e2 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    29e0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    29e2:	0f 90       	pop	r0
    29e4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	1f 91       	pop	r17
    29ec:	0f 91       	pop	r16
    29ee:	ff 90       	pop	r15
    29f0:	ef 90       	pop	r14
    29f2:	df 90       	pop	r13
    29f4:	cf 90       	pop	r12
    29f6:	bf 90       	pop	r11
    29f8:	af 90       	pop	r10
    29fa:	9f 90       	pop	r9
    29fc:	8f 90       	pop	r8
    29fe:	08 95       	ret

00002a00 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2a00:	81 e0       	ldi	r24, 0x01	; 1
    2a02:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <xMissedYield>
    2a06:	08 95       	ret

00002a08 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2a08:	00 97       	sbiw	r24, 0x00	; 0
    2a0a:	21 f4       	brne	.+8      	; 0x2a14 <uxTaskGetStackHighWaterMark+0xc>
    2a0c:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2a10:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2a14:	dc 01       	movw	r26, r24
    2a16:	5b 96       	adiw	r26, 0x1b	; 27
    2a18:	ed 91       	ld	r30, X+
    2a1a:	fc 91       	ld	r31, X
    2a1c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2a1e:	80 81       	ld	r24, Z
    2a20:	81 31       	cpi	r24, 0x11	; 17
    2a22:	41 f4       	brne	.+16     	; 0x2a34 <uxTaskGetStackHighWaterMark+0x2c>
    2a24:	31 96       	adiw	r30, 0x01	; 1
    2a26:	80 e0       	ldi	r24, 0x00	; 0
    2a28:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2a2a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2a2c:	21 91       	ld	r18, Z+
    2a2e:	21 31       	cpi	r18, 0x11	; 17
    2a30:	e1 f3       	breq	.-8      	; 0x2a2a <uxTaskGetStackHighWaterMark+0x22>
    2a32:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2a38:	08 95       	ret

00002a3a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2a3a:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <pxCurrentTCB>
    2a3e:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>

		return xReturn;
	}
    2a42:	08 95       	ret

00002a44 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2a44:	0f 93       	push	r16
    2a46:	1f 93       	push	r17
    2a48:	cf 93       	push	r28
    2a4a:	df 93       	push	r29
    2a4c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2a4e:	22 8d       	ldd	r18, Z+26	; 0x1a
    2a50:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    2a54:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2a58:	5a 96       	adiw	r26, 0x1a	; 26
    2a5a:	8c 91       	ld	r24, X
    2a5c:	28 17       	cp	r18, r24
    2a5e:	08 f0       	brcs	.+2      	; 0x2a62 <vTaskPriorityInherit+0x1e>
    2a60:	41 c0       	rjmp	.+130    	; 0x2ae4 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2a62:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    2a66:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2a6a:	5a 96       	adiw	r26, 0x1a	; 26
    2a6c:	3c 91       	ld	r19, X
    2a6e:	84 e0       	ldi	r24, 0x04	; 4
    2a70:	90 e0       	ldi	r25, 0x00	; 0
    2a72:	a0 e0       	ldi	r26, 0x00	; 0
    2a74:	b0 e0       	ldi	r27, 0x00	; 0
    2a76:	83 1b       	sub	r24, r19
    2a78:	91 09       	sbc	r25, r1
    2a7a:	a1 09       	sbc	r26, r1
    2a7c:	b1 09       	sbc	r27, r1
    2a7e:	86 87       	std	Z+14, r24	; 0x0e
    2a80:	97 87       	std	Z+15, r25	; 0x0f
    2a82:	a0 8b       	std	Z+16, r26	; 0x10
    2a84:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2a86:	8b e0       	ldi	r24, 0x0B	; 11
    2a88:	28 9f       	mul	r18, r24
    2a8a:	90 01       	movw	r18, r0
    2a8c:	11 24       	eor	r1, r1
    2a8e:	2e 56       	subi	r18, 0x6E	; 110
    2a90:	3e 4c       	sbci	r19, 0xCE	; 206
    2a92:	84 85       	ldd	r24, Z+12	; 0x0c
    2a94:	95 85       	ldd	r25, Z+13	; 0x0d
    2a96:	82 17       	cp	r24, r18
    2a98:	93 07       	cpc	r25, r19
    2a9a:	e9 f4       	brne	.+58     	; 0x2ad6 <vTaskPriorityInherit+0x92>
    2a9c:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2a9e:	ef 01       	movw	r28, r30
    2aa0:	22 96       	adiw	r28, 0x02	; 2
    2aa2:	ce 01       	movw	r24, r28
    2aa4:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2aa8:	e0 91 be 31 	lds	r30, 0x31BE	; 0x8031be <pxCurrentTCB>
    2aac:	f0 91 bf 31 	lds	r31, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2ab0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ab2:	f8 01       	movw	r30, r16
    2ab4:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2ab6:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    2aba:	98 17       	cp	r25, r24
    2abc:	10 f4       	brcc	.+4      	; 0x2ac2 <vTaskPriorityInherit+0x7e>
    2abe:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    2ac2:	fb e0       	ldi	r31, 0x0B	; 11
    2ac4:	8f 9f       	mul	r24, r31
    2ac6:	c0 01       	movw	r24, r0
    2ac8:	11 24       	eor	r1, r1
    2aca:	be 01       	movw	r22, r28
    2acc:	8e 56       	subi	r24, 0x6E	; 110
    2ace:	9e 4c       	sbci	r25, 0xCE	; 206
    2ad0:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
    2ad4:	07 c0       	rjmp	.+14     	; 0x2ae4 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2ad6:	a0 91 be 31 	lds	r26, 0x31BE	; 0x8031be <pxCurrentTCB>
    2ada:	b0 91 bf 31 	lds	r27, 0x31BF	; 0x8031bf <pxCurrentTCB+0x1>
    2ade:	5a 96       	adiw	r26, 0x1a	; 26
    2ae0:	8c 91       	ld	r24, X
    2ae2:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2ae4:	df 91       	pop	r29
    2ae6:	cf 91       	pop	r28
    2ae8:	1f 91       	pop	r17
    2aea:	0f 91       	pop	r16
    2aec:	08 95       	ret

00002aee <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2aee:	0f 93       	push	r16
    2af0:	1f 93       	push	r17
    2af2:	cf 93       	push	r28
    2af4:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2af6:	00 97       	sbiw	r24, 0x00	; 0
    2af8:	49 f1       	breq	.+82     	; 0x2b4c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2afa:	fc 01       	movw	r30, r24
    2afc:	32 8d       	ldd	r19, Z+26	; 0x1a
    2afe:	27 a1       	ldd	r18, Z+39	; 0x27
    2b00:	32 17       	cp	r19, r18
    2b02:	21 f1       	breq	.+72     	; 0x2b4c <vTaskPriorityDisinherit+0x5e>
    2b04:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2b06:	8c 01       	movw	r16, r24
    2b08:	0e 5f       	subi	r16, 0xFE	; 254
    2b0a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b0c:	c8 01       	movw	r24, r16
    2b0e:	0e 94 d3 0b 	call	0x17a6	; 0x17a6 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2b12:	8f a1       	ldd	r24, Y+39	; 0x27
    2b14:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2b16:	44 e0       	ldi	r20, 0x04	; 4
    2b18:	50 e0       	ldi	r21, 0x00	; 0
    2b1a:	60 e0       	ldi	r22, 0x00	; 0
    2b1c:	70 e0       	ldi	r23, 0x00	; 0
    2b1e:	48 1b       	sub	r20, r24
    2b20:	51 09       	sbc	r21, r1
    2b22:	61 09       	sbc	r22, r1
    2b24:	71 09       	sbc	r23, r1
    2b26:	4e 87       	std	Y+14, r20	; 0x0e
    2b28:	5f 87       	std	Y+15, r21	; 0x0f
    2b2a:	68 8b       	std	Y+16, r22	; 0x10
    2b2c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2b2e:	90 91 64 31 	lds	r25, 0x3164	; 0x803164 <uxTopReadyPriority>
    2b32:	98 17       	cp	r25, r24
    2b34:	10 f4       	brcc	.+4      	; 0x2b3a <vTaskPriorityDisinherit+0x4c>
    2b36:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <uxTopReadyPriority>
    2b3a:	fb e0       	ldi	r31, 0x0B	; 11
    2b3c:	8f 9f       	mul	r24, r31
    2b3e:	c0 01       	movw	r24, r0
    2b40:	11 24       	eor	r1, r1
    2b42:	b8 01       	movw	r22, r16
    2b44:	8e 56       	subi	r24, 0x6E	; 110
    2b46:	9e 4c       	sbci	r25, 0xCE	; 206
    2b48:	0e 94 61 0b 	call	0x16c2	; 0x16c2 <vListInsertEnd>
			}
		}
	}
    2b4c:	df 91       	pop	r29
    2b4e:	cf 91       	pop	r28
    2b50:	1f 91       	pop	r17
    2b52:	0f 91       	pop	r16
    2b54:	08 95       	ret

00002b56 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2b56:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2b58:	e8 81       	ld	r30, Y
    2b5a:	f9 81       	ldd	r31, Y+1	; 0x01
    2b5c:	01 90       	ld	r0, Z+
    2b5e:	f0 81       	ld	r31, Z
    2b60:	e0 2d       	mov	r30, r0
    2b62:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2b64:	1a 82       	std	Y+2, r1	; 0x02
    2b66:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2b68:	6f ef       	ldi	r22, 0xFF	; 255
    2b6a:	7f ef       	ldi	r23, 0xFF	; 255
    2b6c:	cb 01       	movw	r24, r22
    2b6e:	0e 94 8e 13 	call	0x271c	; 0x271c <vTaskDelay>
    2b72:	fa cf       	rjmp	.-12     	; 0x2b68 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002b74 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2b74:	fc 01       	movw	r30, r24
    2b76:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2b78:	65 87       	std	Z+13, r22	; 0x0d
    2b7a:	08 95       	ret

00002b7c <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2b7c:	4f 92       	push	r4
    2b7e:	5f 92       	push	r5
    2b80:	6f 92       	push	r6
    2b82:	7f 92       	push	r7
    2b84:	8f 92       	push	r8
    2b86:	9f 92       	push	r9
    2b88:	af 92       	push	r10
    2b8a:	bf 92       	push	r11
    2b8c:	cf 92       	push	r12
    2b8e:	df 92       	push	r13
    2b90:	ef 92       	push	r14
    2b92:	ff 92       	push	r15
    2b94:	0f 93       	push	r16
    2b96:	1f 93       	push	r17
    2b98:	cf 93       	push	r28
    2b9a:	df 93       	push	r29
    2b9c:	cd b7       	in	r28, 0x3d	; 61
    2b9e:	de b7       	in	r29, 0x3e	; 62
    2ba0:	2a 97       	sbiw	r28, 0x0a	; 10
    2ba2:	cd bf       	out	0x3d, r28	; 61
    2ba4:	de bf       	out	0x3e, r29	; 62
    2ba6:	4c 01       	movw	r8, r24
    2ba8:	29 01       	movw	r4, r18
    2baa:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2bac:	8d ea       	ldi	r24, 0xAD	; 173
    2bae:	90 e2       	ldi	r25, 0x20	; 32
    2bb0:	f4 01       	movw	r30, r8
    2bb2:	80 83       	st	Z, r24
    2bb4:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2bb6:	fb 01       	movw	r30, r22
    2bb8:	80 81       	ld	r24, Z
    2bba:	88 23       	and	r24, r24
    2bbc:	69 f0       	breq	.+26     	; 0x2bd8 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2bbe:	de 01       	movw	r26, r28
    2bc0:	11 96       	adiw	r26, 0x01	; 1
    2bc2:	31 96       	adiw	r30, 0x01	; 1
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	02 c0       	rjmp	.+4      	; 0x2bcc <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2bc8:	99 30       	cpi	r25, 0x09	; 9
    2bca:	39 f0       	breq	.+14     	; 0x2bda <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2bcc:	9f 5f       	subi	r25, 0xFF	; 255
    2bce:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2bd0:	81 91       	ld	r24, Z+
    2bd2:	81 11       	cpse	r24, r1
    2bd4:	f9 cf       	rjmp	.-14     	; 0x2bc8 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2bd6:	01 c0       	rjmp	.+2      	; 0x2bda <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2bda:	e1 e0       	ldi	r30, 0x01	; 1
    2bdc:	f0 e0       	ldi	r31, 0x00	; 0
    2bde:	ec 0f       	add	r30, r28
    2be0:	fd 1f       	adc	r31, r29
    2be2:	e9 0f       	add	r30, r25
    2be4:	f1 1d       	adc	r31, r1
    2be6:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2be8:	74 01       	movw	r14, r8
    2bea:	f2 e0       	ldi	r31, 0x02	; 2
    2bec:	ef 0e       	add	r14, r31
    2bee:	f1 1c       	adc	r15, r1
    2bf0:	a1 2c       	mov	r10, r1
    2bf2:	b1 2c       	mov	r11, r1
    2bf4:	c1 2c       	mov	r12, r1
    2bf6:	d1 2c       	mov	r13, r1
    2bf8:	04 2f       	mov	r16, r20
    2bfa:	94 01       	movw	r18, r8
    2bfc:	a2 01       	movw	r20, r4
    2bfe:	be 01       	movw	r22, r28
    2c00:	6f 5f       	subi	r22, 0xFF	; 255
    2c02:	7f 4f       	sbci	r23, 0xFF	; 255
    2c04:	8a e1       	ldi	r24, 0x1A	; 26
    2c06:	93 e0       	ldi	r25, 0x03	; 3
    2c08:	0e 94 a7 10 	call	0x214e	; 0x214e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2c0c:	f4 01       	movw	r30, r8
    2c0e:	66 82       	std	Z+6, r6	; 0x06
    2c10:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2c12:	40 86       	std	Z+8, r4	; 0x08
    2c14:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2c16:	20 91 c0 31 	lds	r18, 0x31C0	; 0x8031c0 <last_created_task_pointer>
    2c1a:	30 91 c1 31 	lds	r19, 0x31C1	; 0x8031c1 <last_created_task_pointer+0x1>
    2c1e:	24 83       	std	Z+4, r18	; 0x04
    2c20:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2c22:	80 92 c0 31 	sts	0x31C0, r8	; 0x8031c0 <last_created_task_pointer>
    2c26:	90 92 c1 31 	sts	0x31C1, r9	; 0x8031c1 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2c2a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2c2c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2c2e:	40 90 22 32 	lds	r4, 0x3222	; 0x803222 <portStackTopForTask>
    2c32:	50 90 23 32 	lds	r5, 0x3223	; 0x803223 <portStackTopForTask+0x1>
    2c36:	ff ef       	ldi	r31, 0xFF	; 255
    2c38:	4f 1a       	sub	r4, r31
    2c3a:	5f 0a       	sbc	r5, r31
    2c3c:	40 92 22 32 	sts	0x3222, r4	; 0x803222 <portStackTopForTask>
    2c40:	50 92 23 32 	sts	0x3223, r5	; 0x803223 <portStackTopForTask+0x1>
    2c44:	f4 01       	movw	r30, r8
    2c46:	42 86       	std	Z+10, r4	; 0x0a
    2c48:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2c4a:	16 86       	std	Z+14, r1	; 0x0e
    2c4c:	17 86       	std	Z+15, r1	; 0x0f
    2c4e:	10 8a       	std	Z+16, r1	; 0x10
    2c50:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2c52:	61 14       	cp	r6, r1
    2c54:	71 04       	cpc	r7, r1
    2c56:	09 f4       	brne	.+2      	; 0x2c5a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2c58:	44 c0       	rjmp	.+136    	; 0x2ce2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2c5a:	81 30       	cpi	r24, 0x01	; 1
    2c5c:	79 f5       	brne	.+94     	; 0x2cbc <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2c5e:	6a e0       	ldi	r22, 0x0A	; 10
    2c60:	c3 01       	movw	r24, r6
    2c62:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2c66:	7c 01       	movw	r14, r24
    2c68:	61 e8       	ldi	r22, 0x81	; 129
    2c6a:	75 e0       	ldi	r23, 0x05	; 5
    2c6c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2c70:	be 01       	movw	r22, r28
    2c72:	6f 5f       	subi	r22, 0xFF	; 255
    2c74:	7f 4f       	sbci	r23, 0xFF	; 255
    2c76:	c7 01       	movw	r24, r14
    2c78:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2c7c:	6a e0       	ldi	r22, 0x0A	; 10
    2c7e:	c7 01       	movw	r24, r14
    2c80:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2c84:	7c 01       	movw	r14, r24
    2c86:	68 e7       	ldi	r22, 0x78	; 120
    2c88:	75 e0       	ldi	r23, 0x05	; 5
    2c8a:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2c8e:	6a e0       	ldi	r22, 0x0A	; 10
    2c90:	c7 01       	movw	r24, r14
    2c92:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2c96:	7c 01       	movw	r14, r24
    2c98:	6a e6       	ldi	r22, 0x6A	; 106
    2c9a:	75 e0       	ldi	r23, 0x05	; 5
    2c9c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2ca0:	63 e0       	ldi	r22, 0x03	; 3
    2ca2:	c7 01       	movw	r24, r14
    2ca4:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2ca8:	b2 01       	movw	r22, r4
    2caa:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    2cae:	62 e0       	ldi	r22, 0x02	; 2
    2cb0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2cb4:	66 e0       	ldi	r22, 0x06	; 6
    2cb6:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2cba:	13 c0       	rjmp	.+38     	; 0x2ce2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2cbc:	6a e0       	ldi	r22, 0x0A	; 10
    2cbe:	c3 01       	movw	r24, r6
    2cc0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2cc4:	4c 01       	movw	r8, r24
    2cc6:	65 e5       	ldi	r22, 0x55	; 85
    2cc8:	75 e0       	ldi	r23, 0x05	; 5
    2cca:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2cce:	be 01       	movw	r22, r28
    2cd0:	6f 5f       	subi	r22, 0xFF	; 255
    2cd2:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd4:	c4 01       	movw	r24, r8
    2cd6:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2cda:	66 e0       	ldi	r22, 0x06	; 6
    2cdc:	c4 01       	movw	r24, r8
    2cde:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2ce2:	2a 96       	adiw	r28, 0x0a	; 10
    2ce4:	cd bf       	out	0x3d, r28	; 61
    2ce6:	de bf       	out	0x3e, r29	; 62
    2ce8:	df 91       	pop	r29
    2cea:	cf 91       	pop	r28
    2cec:	1f 91       	pop	r17
    2cee:	0f 91       	pop	r16
    2cf0:	ff 90       	pop	r15
    2cf2:	ef 90       	pop	r14
    2cf4:	df 90       	pop	r13
    2cf6:	cf 90       	pop	r12
    2cf8:	bf 90       	pop	r11
    2cfa:	af 90       	pop	r10
    2cfc:	9f 90       	pop	r9
    2cfe:	8f 90       	pop	r8
    2d00:	7f 90       	pop	r7
    2d02:	6f 90       	pop	r6
    2d04:	5f 90       	pop	r5
    2d06:	4f 90       	pop	r4
    2d08:	08 95       	ret

00002d0a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2d0a:	cf 92       	push	r12
    2d0c:	df 92       	push	r13
    2d0e:	ef 92       	push	r14
    2d10:	ff 92       	push	r15
    2d12:	0f 93       	push	r16
    2d14:	1f 93       	push	r17
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	ec 01       	movw	r28, r24
    2d1c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d20:	9b 81       	ldd	r25, Y+3	; 0x03
    2d22:	0e 94 fe 11 	call	0x23fc	; 0x23fc <pcTaskGetTaskName>
    2d26:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2d28:	6a e0       	ldi	r22, 0x0A	; 10
    2d2a:	c7 01       	movw	r24, r14
    2d2c:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2d30:	8c 01       	movw	r16, r24
    2d32:	64 e9       	ldi	r22, 0x94	; 148
    2d34:	75 e0       	ldi	r23, 0x05	; 5
    2d36:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2d3a:	6a e0       	ldi	r22, 0x0A	; 10
    2d3c:	c8 01       	movw	r24, r16
    2d3e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2d42:	8c 01       	movw	r16, r24
    2d44:	6d e8       	ldi	r22, 0x8D	; 141
    2d46:	75 e0       	ldi	r23, 0x05	; 5
    2d48:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2d4c:	b6 01       	movw	r22, r12
    2d4e:	c8 01       	movw	r24, r16
    2d50:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2d54:	6a e0       	ldi	r22, 0x0A	; 10
    2d56:	c8 01       	movw	r24, r16
    2d58:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2d5c:	8c 01       	movw	r16, r24
    2d5e:	67 e8       	ldi	r22, 0x87	; 135
    2d60:	75 e0       	ldi	r23, 0x05	; 5
    2d62:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2d66:	66 e0       	ldi	r22, 0x06	; 6
    2d68:	c8 01       	movw	r24, r16
    2d6a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2d6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2d70:	9b 85       	ldd	r25, Y+11	; 0x0b
    2d72:	e8 85       	ldd	r30, Y+8	; 0x08
    2d74:	f9 85       	ldd	r31, Y+9	; 0x09
    2d76:	01 e1       	ldi	r16, 0x11	; 17
    2d78:	21 e0       	ldi	r18, 0x01	; 1
    2d7a:	a7 01       	movw	r20, r14
    2d7c:	bc 01       	movw	r22, r24
    2d7e:	8e 1b       	sub	r24, r30
    2d80:	9f 0b       	sbc	r25, r31
    2d82:	0e 94 87 19 	call	0x330e	; 0x330e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2d86:	8c 81       	ldd	r24, Y+4	; 0x04
    2d88:	9d 81       	ldd	r25, Y+5	; 0x05
    2d8a:	00 97       	sbiw	r24, 0x00	; 0
    2d8c:	19 f0       	breq	.+6      	; 0x2d94 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2d8e:	b7 01       	movw	r22, r14
    2d90:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2d94:	df 91       	pop	r29
    2d96:	cf 91       	pop	r28
    2d98:	1f 91       	pop	r17
    2d9a:	0f 91       	pop	r16
    2d9c:	ff 90       	pop	r15
    2d9e:	ef 90       	pop	r14
    2da0:	df 90       	pop	r13
    2da2:	cf 90       	pop	r12
    2da4:	08 95       	ret

00002da6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2da6:	0f 93       	push	r16
    2da8:	1f 93       	push	r17
    2daa:	cf 93       	push	r28
    2dac:	df 93       	push	r29
    2dae:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2db0:	80 91 c0 31 	lds	r24, 0x31C0	; 0x8031c0 <last_created_task_pointer>
    2db4:	90 91 c1 31 	lds	r25, 0x31C1	; 0x8031c1 <last_created_task_pointer+0x1>
    2db8:	00 97       	sbiw	r24, 0x00	; 0
    2dba:	19 f0       	breq	.+6      	; 0x2dc2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2dbc:	be 01       	movw	r22, r28
    2dbe:	0e 94 85 16 	call	0x2d0a	; 0x2d0a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2dc2:	6a e0       	ldi	r22, 0x0A	; 10
    2dc4:	ce 01       	movw	r24, r28
    2dc6:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2dca:	8c 01       	movw	r16, r24
    2dcc:	6a ea       	ldi	r22, 0xAA	; 170
    2dce:	75 e0       	ldi	r23, 0x05	; 5
    2dd0:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2dd4:	6a e0       	ldi	r22, 0x0A	; 10
    2dd6:	c8 01       	movw	r24, r16
    2dd8:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2ddc:	8c 01       	movw	r16, r24
    2dde:	6f e9       	ldi	r22, 0x9F	; 159
    2de0:	75 e0       	ldi	r23, 0x05	; 5
    2de2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2de6:	6a e0       	ldi	r22, 0x0A	; 10
    2de8:	c8 01       	movw	r24, r16
    2dea:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2dee:	8c 01       	movw	r16, r24
    2df0:	69 e9       	ldi	r22, 0x99	; 153
    2df2:	75 e0       	ldi	r23, 0x05	; 5
    2df4:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2df8:	66 e0       	ldi	r22, 0x06	; 6
    2dfa:	c8 01       	movw	r24, r16
    2dfc:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2e00:	80 91 22 32 	lds	r24, 0x3222	; 0x803222 <portStackTopForTask>
    2e04:	90 91 23 32 	lds	r25, 0x3223	; 0x803223 <portStackTopForTask+0x1>
    2e08:	bc 01       	movw	r22, r24
    2e0a:	6f 5f       	subi	r22, 0xFF	; 255
    2e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e0e:	01 e1       	ldi	r16, 0x11	; 17
    2e10:	21 e0       	ldi	r18, 0x01	; 1
    2e12:	ae 01       	movw	r20, r28
    2e14:	83 56       	subi	r24, 0x63	; 99
    2e16:	91 09       	sbc	r25, r1
    2e18:	0e 94 87 19 	call	0x330e	; 0x330e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2e1c:	df 91       	pop	r29
    2e1e:	cf 91       	pop	r28
    2e20:	1f 91       	pop	r17
    2e22:	0f 91       	pop	r16
    2e24:	08 95       	ret

00002e26 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2e26:	8f 92       	push	r8
    2e28:	9f 92       	push	r9
    2e2a:	af 92       	push	r10
    2e2c:	bf 92       	push	r11
    2e2e:	cf 92       	push	r12
    2e30:	df 92       	push	r13
    2e32:	ef 92       	push	r14
    2e34:	ff 92       	push	r15
    2e36:	0f 93       	push	r16
    2e38:	1f 93       	push	r17
    2e3a:	cf 93       	push	r28
    2e3c:	df 93       	push	r29
    2e3e:	ec 01       	movw	r28, r24
    2e40:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2e42:	8a 81       	ldd	r24, Y+2	; 0x02
    2e44:	9b 81       	ldd	r25, Y+3	; 0x03
    2e46:	0e 94 fe 11 	call	0x23fc	; 0x23fc <pcTaskGetTaskName>
    2e4a:	bc 01       	movw	r22, r24
    2e4c:	c8 01       	movw	r24, r16
    2e4e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2e52:	d8 01       	movw	r26, r16
    2e54:	ed 91       	ld	r30, X+
    2e56:	fc 91       	ld	r31, X
    2e58:	02 80       	ldd	r0, Z+2	; 0x02
    2e5a:	f3 81       	ldd	r31, Z+3	; 0x03
    2e5c:	e0 2d       	mov	r30, r0
    2e5e:	69 e0       	ldi	r22, 0x09	; 9
    2e60:	c8 01       	movw	r24, r16
    2e62:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2e64:	8a 81       	ldd	r24, Y+2	; 0x02
    2e66:	9b 81       	ldd	r25, Y+3	; 0x03
    2e68:	0e 94 fe 11 	call	0x23fc	; 0x23fc <pcTaskGetTaskName>
    2e6c:	fc 01       	movw	r30, r24
    2e6e:	01 90       	ld	r0, Z+
    2e70:	00 20       	and	r0, r0
    2e72:	e9 f7       	brne	.-6      	; 0x2e6e <_ZN8frt_task12print_statusER8emstream+0x48>
    2e74:	31 97       	sbiw	r30, 0x01	; 1
    2e76:	e8 1b       	sub	r30, r24
    2e78:	f9 0b       	sbc	r31, r25
    2e7a:	38 97       	sbiw	r30, 0x08	; 8
    2e7c:	48 f4       	brcc	.+18     	; 0x2e90 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2e7e:	d8 01       	movw	r26, r16
    2e80:	ed 91       	ld	r30, X+
    2e82:	fc 91       	ld	r31, X
    2e84:	02 80       	ldd	r0, Z+2	; 0x02
    2e86:	f3 81       	ldd	r31, Z+3	; 0x03
    2e88:	e0 2d       	mov	r30, r0
    2e8a:	69 e0       	ldi	r22, 0x09	; 9
    2e8c:	c8 01       	movw	r24, r16
    2e8e:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2e90:	ce 84       	ldd	r12, Y+14	; 0x0e
    2e92:	df 84       	ldd	r13, Y+15	; 0x0f
    2e94:	e8 88       	ldd	r14, Y+16	; 0x10
    2e96:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2e98:	a8 84       	ldd	r10, Y+8	; 0x08
    2e9a:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2e9c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e9e:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea0:	0e 94 04 15 	call	0x2a08	; 0x2a08 <uxTaskGetStackHighWaterMark>
    2ea4:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2ea6:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    2eac:	0e 94 a9 11 	call	0x2352	; 0x2352 <uxTaskPriorityGet>
    2eb0:	68 2f       	mov	r22, r24
    2eb2:	c8 01       	movw	r24, r16
    2eb4:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    2eb8:	6a e0       	ldi	r22, 0x0A	; 10
    2eba:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2ebe:	ec 01       	movw	r28, r24
    2ec0:	6f e1       	ldi	r22, 0x1F	; 31
    2ec2:	76 e0       	ldi	r23, 0x06	; 6
    2ec4:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2ec8:	68 2d       	mov	r22, r8
    2eca:	ce 01       	movw	r24, r28
    2ecc:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2ed0:	6a e0       	ldi	r22, 0x0A	; 10
    2ed2:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2ed6:	ec 01       	movw	r28, r24
    2ed8:	6d e1       	ldi	r22, 0x1D	; 29
    2eda:	76 e0       	ldi	r23, 0x06	; 6
    2edc:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2ee0:	69 2d       	mov	r22, r9
    2ee2:	ce 01       	movw	r24, r28
    2ee4:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    2ee8:	6a e0       	ldi	r22, 0x0A	; 10
    2eea:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2eee:	ec 01       	movw	r28, r24
    2ef0:	6b e1       	ldi	r22, 0x1B	; 27
    2ef2:	76 e0       	ldi	r23, 0x06	; 6
    2ef4:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2ef8:	b5 01       	movw	r22, r10
    2efa:	ce 01       	movw	r24, r28
    2efc:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    2f00:	6a e0       	ldi	r22, 0x0A	; 10
    2f02:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2f06:	ec 01       	movw	r28, r24
    2f08:	69 e1       	ldi	r22, 0x19	; 25
    2f0a:	76 e0       	ldi	r23, 0x06	; 6
    2f0c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2f10:	6a e0       	ldi	r22, 0x0A	; 10
    2f12:	ce 01       	movw	r24, r28
    2f14:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2f18:	ec 01       	movw	r28, r24
    2f1a:	67 e1       	ldi	r22, 0x17	; 23
    2f1c:	76 e0       	ldi	r23, 0x06	; 6
    2f1e:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    2f22:	b7 01       	movw	r22, r14
    2f24:	a6 01       	movw	r20, r12
    2f26:	ce 01       	movw	r24, r28
    2f28:	0e 94 9e 1b 	call	0x373c	; 0x373c <_ZN8emstreamlsEm>
}
    2f2c:	df 91       	pop	r29
    2f2e:	cf 91       	pop	r28
    2f30:	1f 91       	pop	r17
    2f32:	0f 91       	pop	r16
    2f34:	ff 90       	pop	r15
    2f36:	ef 90       	pop	r14
    2f38:	df 90       	pop	r13
    2f3a:	cf 90       	pop	r12
    2f3c:	bf 90       	pop	r11
    2f3e:	af 90       	pop	r10
    2f40:	9f 90       	pop	r9
    2f42:	8f 90       	pop	r8
    2f44:	08 95       	ret

00002f46 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2f46:	cf 93       	push	r28
    2f48:	df 93       	push	r29
    2f4a:	ec 01       	movw	r28, r24
    2f4c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2f4e:	db 01       	movw	r26, r22
    2f50:	ed 91       	ld	r30, X+
    2f52:	fc 91       	ld	r31, X
    2f54:	02 80       	ldd	r0, Z+2	; 0x02
    2f56:	f3 81       	ldd	r31, Z+3	; 0x03
    2f58:	e0 2d       	mov	r30, r0
    2f5a:	be 01       	movw	r22, r28
    2f5c:	19 95       	eicall
	return (ser_dev);
}
    2f5e:	ce 01       	movw	r24, r28
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	08 95       	ret

00002f66 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2f66:	0f 93       	push	r16
    2f68:	1f 93       	push	r17
    2f6a:	cf 93       	push	r28
    2f6c:	df 93       	push	r29
    2f6e:	ec 01       	movw	r28, r24
    2f70:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2f72:	bc 01       	movw	r22, r24
    2f74:	c8 01       	movw	r24, r16
    2f76:	0e 94 a3 17 	call	0x2f46	; 0x2f46 <_ZlsR8emstreamR8frt_task>
    2f7a:	66 e0       	ldi	r22, 0x06	; 6
    2f7c:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2f80:	8c 81       	ldd	r24, Y+4	; 0x04
    2f82:	9d 81       	ldd	r25, Y+5	; 0x05
    2f84:	00 97       	sbiw	r24, 0x00	; 0
    2f86:	19 f0       	breq	.+6      	; 0x2f8e <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2f88:	b8 01       	movw	r22, r16
    2f8a:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2f8e:	df 91       	pop	r29
    2f90:	cf 91       	pop	r28
    2f92:	1f 91       	pop	r17
    2f94:	0f 91       	pop	r16
    2f96:	08 95       	ret

00002f98 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2f98:	0f 93       	push	r16
    2f9a:	1f 93       	push	r17
    2f9c:	cf 93       	push	r28
    2f9e:	df 93       	push	r29
    2fa0:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2fa2:	6a e0       	ldi	r22, 0x0A	; 10
    2fa4:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2fa8:	8c 01       	movw	r16, r24
    2faa:	6c e0       	ldi	r22, 0x0C	; 12
    2fac:	76 e0       	ldi	r23, 0x06	; 6
    2fae:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2fb2:	6a e0       	ldi	r22, 0x0A	; 10
    2fb4:	c8 01       	movw	r24, r16
    2fb6:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2fba:	8c 01       	movw	r16, r24
    2fbc:	65 e0       	ldi	r22, 0x05	; 5
    2fbe:	76 e0       	ldi	r23, 0x06	; 6
    2fc0:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2fc4:	66 e0       	ldi	r22, 0x06	; 6
    2fc6:	c8 01       	movw	r24, r16
    2fc8:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2fcc:	6a e0       	ldi	r22, 0x0A	; 10
    2fce:	ce 01       	movw	r24, r28
    2fd0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2fd4:	8c 01       	movw	r16, r24
    2fd6:	64 ef       	ldi	r22, 0xF4	; 244
    2fd8:	75 e0       	ldi	r23, 0x05	; 5
    2fda:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2fde:	6a e0       	ldi	r22, 0x0A	; 10
    2fe0:	c8 01       	movw	r24, r16
    2fe2:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2fe6:	8c 01       	movw	r16, r24
    2fe8:	68 ee       	ldi	r22, 0xE8	; 232
    2fea:	75 e0       	ldi	r23, 0x05	; 5
    2fec:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2ff0:	6a e0       	ldi	r22, 0x0A	; 10
    2ff2:	c8 01       	movw	r24, r16
    2ff4:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    2ff8:	8c 01       	movw	r16, r24
    2ffa:	62 ee       	ldi	r22, 0xE2	; 226
    2ffc:	75 e0       	ldi	r23, 0x05	; 5
    2ffe:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    3002:	66 e0       	ldi	r22, 0x06	; 6
    3004:	c8 01       	movw	r24, r16
    3006:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    300a:	6a e0       	ldi	r22, 0x0A	; 10
    300c:	ce 01       	movw	r24, r28
    300e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3012:	8c 01       	movw	r16, r24
    3014:	61 ed       	ldi	r22, 0xD1	; 209
    3016:	75 e0       	ldi	r23, 0x05	; 5
    3018:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    301c:	6a e0       	ldi	r22, 0x0A	; 10
    301e:	c8 01       	movw	r24, r16
    3020:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3024:	8c 01       	movw	r16, r24
    3026:	65 ec       	ldi	r22, 0xC5	; 197
    3028:	75 e0       	ldi	r23, 0x05	; 5
    302a:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    302e:	6a e0       	ldi	r22, 0x0A	; 10
    3030:	c8 01       	movw	r24, r16
    3032:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3036:	8c 01       	movw	r16, r24
    3038:	6f eb       	ldi	r22, 0xBF	; 191
    303a:	75 e0       	ldi	r23, 0x05	; 5
    303c:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    3040:	66 e0       	ldi	r22, 0x06	; 6
    3042:	c8 01       	movw	r24, r16
    3044:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3048:	80 91 c0 31 	lds	r24, 0x31C0	; 0x8031c0 <last_created_task_pointer>
    304c:	90 91 c1 31 	lds	r25, 0x31C1	; 0x8031c1 <last_created_task_pointer+0x1>
    3050:	00 97       	sbiw	r24, 0x00	; 0
    3052:	19 f0       	breq	.+6      	; 0x305a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3054:	be 01       	movw	r22, r28
    3056:	0e 94 b3 17 	call	0x2f66	; 0x2f66 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    305a:	0e 94 06 12 	call	0x240c	; 0x240c <xTaskGetIdleTaskHandle>
    305e:	0e 94 04 15 	call	0x2a08	; 0x2a08 <uxTaskGetStackHighWaterMark>
    3062:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3064:	6a e0       	ldi	r22, 0x0A	; 10
    3066:	ce 01       	movw	r24, r28
    3068:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    306c:	ec 01       	movw	r28, r24
    306e:	64 eb       	ldi	r22, 0xB4	; 180
    3070:	75 e0       	ldi	r23, 0x05	; 5
    3072:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3076:	61 2f       	mov	r22, r17
    3078:	ce 01       	movw	r24, r28
    307a:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    307e:	6a e0       	ldi	r22, 0x0A	; 10
    3080:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3084:	ec 01       	movw	r28, r24
    3086:	62 eb       	ldi	r22, 0xB2	; 178
    3088:	75 e0       	ldi	r23, 0x05	; 5
    308a:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    308e:	64 e6       	ldi	r22, 0x64	; 100
    3090:	70 e0       	ldi	r23, 0x00	; 0
    3092:	ce 01       	movw	r24, r28
    3094:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    3098:	6a e0       	ldi	r22, 0x0A	; 10
    309a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    309e:	ec 01       	movw	r28, r24
    30a0:	6f ea       	ldi	r22, 0xAF	; 175
    30a2:	75 e0       	ldi	r23, 0x05	; 5
    30a4:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    30a8:	66 e0       	ldi	r22, 0x06	; 6
    30aa:	ce 01       	movw	r24, r28
    30ac:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
}
    30b0:	df 91       	pop	r29
    30b2:	cf 91       	pop	r28
    30b4:	1f 91       	pop	r17
    30b6:	0f 91       	pop	r16
    30b8:	08 95       	ret

000030ba <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    30ba:	0f 93       	push	r16
    30bc:	cf 93       	push	r28
    30be:	df 93       	push	r29
    30c0:	1f 92       	push	r1
    30c2:	cd b7       	in	r28, 0x3d	; 61
    30c4:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    30c6:	00 e0       	ldi	r16, 0x00	; 0
    30c8:	2f ef       	ldi	r18, 0xFF	; 255
    30ca:	3f ef       	ldi	r19, 0xFF	; 255
    30cc:	a9 01       	movw	r20, r18
    30ce:	be 01       	movw	r22, r28
    30d0:	6f 5f       	subi	r22, 0xFF	; 255
    30d2:	7f 4f       	sbci	r23, 0xFF	; 255
    30d4:	fc 01       	movw	r30, r24
    30d6:	80 85       	ldd	r24, Z+8	; 0x08
    30d8:	91 85       	ldd	r25, Z+9	; 0x09
    30da:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
    30de:	81 30       	cpi	r24, 0x01	; 1
    30e0:	19 f4       	brne	.+6      	; 0x30e8 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    30e2:	89 81       	ldd	r24, Y+1	; 0x01
    30e4:	90 e0       	ldi	r25, 0x00	; 0
    30e6:	02 c0       	rjmp	.+4      	; 0x30ec <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    30e8:	8f ef       	ldi	r24, 0xFF	; 255
    30ea:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    30ec:	0f 90       	pop	r0
    30ee:	df 91       	pop	r29
    30f0:	cf 91       	pop	r28
    30f2:	0f 91       	pop	r16
    30f4:	08 95       	ret

000030f6 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    30f6:	fc 01       	movw	r30, r24
    30f8:	80 85       	ldd	r24, Z+8	; 0x08
    30fa:	91 85       	ldd	r25, Z+9	; 0x09
    30fc:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
    3100:	91 e0       	ldi	r25, 0x01	; 1
    3102:	81 11       	cpse	r24, r1
    3104:	01 c0       	rjmp	.+2      	; 0x3108 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3106:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3108:	89 2f       	mov	r24, r25
    310a:	08 95       	ret

0000310c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    310c:	0f 93       	push	r16
    310e:	cf 93       	push	r28
    3110:	df 93       	push	r29
    3112:	1f 92       	push	r1
    3114:	cd b7       	in	r28, 0x3d	; 61
    3116:	de b7       	in	r29, 0x3e	; 62
    3118:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    311a:	fc 01       	movw	r30, r24
    311c:	22 85       	ldd	r18, Z+10	; 0x0a
    311e:	33 85       	ldd	r19, Z+11	; 0x0b
    3120:	44 85       	ldd	r20, Z+12	; 0x0c
    3122:	55 85       	ldd	r21, Z+13	; 0x0d
    3124:	00 e0       	ldi	r16, 0x00	; 0
    3126:	be 01       	movw	r22, r28
    3128:	6f 5f       	subi	r22, 0xFF	; 255
    312a:	7f 4f       	sbci	r23, 0xFF	; 255
    312c:	80 85       	ldd	r24, Z+8	; 0x08
    312e:	91 85       	ldd	r25, Z+9	; 0x09
    3130:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
    3134:	91 e0       	ldi	r25, 0x01	; 1
    3136:	81 11       	cpse	r24, r1
    3138:	01 c0       	rjmp	.+2      	; 0x313c <_ZN14frt_text_queue7putcharEc+0x30>
    313a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    313c:	89 2f       	mov	r24, r25
    313e:	0f 90       	pop	r0
    3140:	df 91       	pop	r29
    3142:	cf 91       	pop	r28
    3144:	0f 91       	pop	r16
    3146:	08 95       	ret

00003148 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3148:	8f 92       	push	r8
    314a:	9f 92       	push	r9
    314c:	bf 92       	push	r11
    314e:	cf 92       	push	r12
    3150:	df 92       	push	r13
    3152:	ef 92       	push	r14
    3154:	ff 92       	push	r15
    3156:	0f 93       	push	r16
    3158:	1f 93       	push	r17
    315a:	cf 93       	push	r28
    315c:	df 93       	push	r29
    315e:	ec 01       	movw	r28, r24
    3160:	b6 2e       	mov	r11, r22
    3162:	4a 01       	movw	r8, r20
    3164:	68 01       	movw	r12, r16
    3166:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3168:	0e 94 de 1a 	call	0x35bc	; 0x35bc <_ZN8emstreamC1Ev>
    316c:	85 eb       	ldi	r24, 0xB5	; 181
    316e:	90 e2       	ldi	r25, 0x20	; 32
    3170:	88 83       	st	Y, r24
    3172:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3174:	8e 86       	std	Y+14, r8	; 0x0e
    3176:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3178:	40 e0       	ldi	r20, 0x00	; 0
    317a:	61 e0       	ldi	r22, 0x01	; 1
    317c:	8b 2d       	mov	r24, r11
    317e:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    3182:	88 87       	std	Y+8, r24	; 0x08
    3184:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3186:	ca 86       	std	Y+10, r12	; 0x0a
    3188:	db 86       	std	Y+11, r13	; 0x0b
    318a:	ec 86       	std	Y+12, r14	; 0x0c
    318c:	fd 86       	std	Y+13, r15	; 0x0d
}
    318e:	df 91       	pop	r29
    3190:	cf 91       	pop	r28
    3192:	1f 91       	pop	r17
    3194:	0f 91       	pop	r16
    3196:	ff 90       	pop	r15
    3198:	ef 90       	pop	r14
    319a:	df 90       	pop	r13
    319c:	cf 90       	pop	r12
    319e:	bf 90       	pop	r11
    31a0:	9f 90       	pop	r9
    31a2:	8f 90       	pop	r8
    31a4:	08 95       	ret

000031a6 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    31a6:	cf 92       	push	r12
    31a8:	df 92       	push	r13
    31aa:	ef 92       	push	r14
    31ac:	ff 92       	push	r15
    31ae:	cf 93       	push	r28
    31b0:	df 93       	push	r29
    31b2:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    31b4:	68 81       	ld	r22, Y
    31b6:	79 81       	ldd	r23, Y+1	; 0x01
    31b8:	8a 81       	ldd	r24, Y+2	; 0x02
    31ba:	9b 81       	ldd	r25, Y+3	; 0x03
    31bc:	0f 2e       	mov	r0, r31
    31be:	f8 ee       	ldi	r31, 0xE8	; 232
    31c0:	cf 2e       	mov	r12, r31
    31c2:	f3 e0       	ldi	r31, 0x03	; 3
    31c4:	df 2e       	mov	r13, r31
    31c6:	e1 2c       	mov	r14, r1
    31c8:	f1 2c       	mov	r15, r1
    31ca:	f0 2d       	mov	r31, r0
    31cc:	a7 01       	movw	r20, r14
    31ce:	96 01       	movw	r18, r12
    31d0:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
    31d4:	9b 01       	movw	r18, r22
    31d6:	ac 01       	movw	r20, r24
    31d8:	60 e4       	ldi	r22, 0x40	; 64
    31da:	72 e4       	ldi	r23, 0x42	; 66
    31dc:	8f e0       	ldi	r24, 0x0F	; 15
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	0e 94 38 22 	call	0x4470	; 0x4470 <__mulsi3>
    31e4:	a7 01       	movw	r20, r14
    31e6:	96 01       	movw	r18, r12
    31e8:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
    31ec:	69 01       	movw	r12, r18
    31ee:	7a 01       	movw	r14, r20
    31f0:	ac 81       	ldd	r26, Y+4	; 0x04
    31f2:	bd 81       	ldd	r27, Y+5	; 0x05
    31f4:	20 e4       	ldi	r18, 0x40	; 64
    31f6:	32 e4       	ldi	r19, 0x42	; 66
    31f8:	4f e0       	ldi	r20, 0x0F	; 15
    31fa:	50 e0       	ldi	r21, 0x00	; 0
    31fc:	0e 94 92 22 	call	0x4524	; 0x4524 <__muluhisi3>
    3200:	20 e0       	ldi	r18, 0x00	; 0
    3202:	38 e4       	ldi	r19, 0x48	; 72
    3204:	48 ee       	ldi	r20, 0xE8	; 232
    3206:	51 e0       	ldi	r21, 0x01	; 1
    3208:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
    320c:	c7 01       	movw	r24, r14
    320e:	b6 01       	movw	r22, r12
    3210:	62 0f       	add	r22, r18
    3212:	73 1f       	adc	r23, r19
    3214:	84 1f       	adc	r24, r20
    3216:	95 1f       	adc	r25, r21
}
    3218:	df 91       	pop	r29
    321a:	cf 91       	pop	r28
    321c:	ff 90       	pop	r15
    321e:	ef 90       	pop	r14
    3220:	df 90       	pop	r13
    3222:	cf 90       	pop	r12
    3224:	08 95       	ret

00003226 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3226:	cf 92       	push	r12
    3228:	df 92       	push	r13
    322a:	ef 92       	push	r14
    322c:	ff 92       	push	r15
    322e:	0f 93       	push	r16
    3230:	1f 93       	push	r17
    3232:	cf 93       	push	r28
    3234:	df 93       	push	r29
    3236:	cd b7       	in	r28, 0x3d	; 61
    3238:	de b7       	in	r29, 0x3e	; 62
    323a:	2f 97       	sbiw	r28, 0x0f	; 15
    323c:	cd bf       	out	0x3d, r28	; 61
    323e:	de bf       	out	0x3e, r29	; 62
    3240:	6c 01       	movw	r12, r24
    3242:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3244:	db 01       	movw	r26, r22
    3246:	6d 91       	ld	r22, X+
    3248:	7d 91       	ld	r23, X+
    324a:	8d 91       	ld	r24, X+
    324c:	9c 91       	ld	r25, X
    324e:	28 ee       	ldi	r18, 0xE8	; 232
    3250:	33 e0       	ldi	r19, 0x03	; 3
    3252:	40 e0       	ldi	r20, 0x00	; 0
    3254:	50 e0       	ldi	r21, 0x00	; 0
    3256:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
    325a:	ba 01       	movw	r22, r20
    325c:	a9 01       	movw	r20, r18
    325e:	c6 01       	movw	r24, r12
    3260:	0e 94 9e 1b 	call	0x373c	; 0x373c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3264:	d6 01       	movw	r26, r12
    3266:	ed 91       	ld	r30, X+
    3268:	fc 91       	ld	r31, X
    326a:	02 80       	ldd	r0, Z+2	; 0x02
    326c:	f3 81       	ldd	r31, Z+3	; 0x03
    326e:	e0 2d       	mov	r30, r0
    3270:	6e e2       	ldi	r22, 0x2E	; 46
    3272:	c6 01       	movw	r24, r12
    3274:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3276:	c8 01       	movw	r24, r16
    3278:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <_ZN10time_stamp12get_microsecEv>
    327c:	8e 01       	movw	r16, r28
    327e:	09 5f       	subi	r16, 0xF9	; 249
    3280:	1f 4f       	sbci	r17, 0xFF	; 255
    3282:	fe 01       	movw	r30, r28
    3284:	31 96       	adiw	r30, 0x01	; 1
    3286:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3288:	2a e0       	ldi	r18, 0x0A	; 10
    328a:	30 e0       	ldi	r19, 0x00	; 0
    328c:	40 e0       	ldi	r20, 0x00	; 0
    328e:	50 e0       	ldi	r21, 0x00	; 0
    3290:	0e 94 6a 22 	call	0x44d4	; 0x44d4 <__divmodsi4>
    3294:	e6 2f       	mov	r30, r22
    3296:	28 87       	std	Y+8, r18	; 0x08
    3298:	39 87       	std	Y+9, r19	; 0x09
    329a:	4a 87       	std	Y+10, r20	; 0x0a
    329c:	5b 87       	std	Y+11, r21	; 0x0b
    329e:	68 85       	ldd	r22, Y+8	; 0x08
    32a0:	79 85       	ldd	r23, Y+9	; 0x09
    32a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    32a4:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    32a6:	20 e3       	ldi	r18, 0x30	; 48
    32a8:	2e 0f       	add	r18, r30
    32aa:	d8 01       	movw	r26, r16
    32ac:	2e 93       	st	-X, r18
    32ae:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    32b0:	ae 15       	cp	r26, r14
    32b2:	bf 05       	cpc	r27, r15
    32b4:	49 f7       	brne	.-46     	; 0x3288 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    32b6:	1f 82       	std	Y+7, r1	; 0x07
    32b8:	be 01       	movw	r22, r28
    32ba:	6f 5f       	subi	r22, 0xFF	; 255
    32bc:	7f 4f       	sbci	r23, 0xFF	; 255
    32be:	c6 01       	movw	r24, r12
    32c0:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    32c4:	c6 01       	movw	r24, r12
    32c6:	2f 96       	adiw	r28, 0x0f	; 15
    32c8:	cd bf       	out	0x3d, r28	; 61
    32ca:	de bf       	out	0x3e, r29	; 62
    32cc:	df 91       	pop	r29
    32ce:	cf 91       	pop	r28
    32d0:	1f 91       	pop	r17
    32d2:	0f 91       	pop	r16
    32d4:	ff 90       	pop	r15
    32d6:	ef 90       	pop	r14
    32d8:	df 90       	pop	r13
    32da:	cf 90       	pop	r12
    32dc:	08 95       	ret

000032de <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    32de:	cf 93       	push	r28
    32e0:	df 93       	push	r29
    32e2:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    32e4:	0f b6       	in	r0, 0x3f	; 63
    32e6:	f8 94       	cli
    32e8:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    32ea:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    32ee:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    32f2:	8c 83       	std	Y+4, r24	; 0x04
    32f4:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    32f6:	0e 94 f0 11 	call	0x23e0	; 0x23e0 <xTaskGetTickCount>
    32fa:	68 83       	st	Y, r22
    32fc:	79 83       	std	Y+1, r23	; 0x01
    32fe:	8a 83       	std	Y+2, r24	; 0x02
    3300:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3302:	0f 90       	pop	r0
    3304:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3306:	ce 01       	movw	r24, r28
    3308:	df 91       	pop	r29
    330a:	cf 91       	pop	r28
    330c:	08 95       	ret

0000330e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    330e:	5f 92       	push	r5
    3310:	6f 92       	push	r6
    3312:	7f 92       	push	r7
    3314:	8f 92       	push	r8
    3316:	9f 92       	push	r9
    3318:	af 92       	push	r10
    331a:	bf 92       	push	r11
    331c:	cf 92       	push	r12
    331e:	df 92       	push	r13
    3320:	ef 92       	push	r14
    3322:	ff 92       	push	r15
    3324:	0f 93       	push	r16
    3326:	1f 93       	push	r17
    3328:	cf 93       	push	r28
    332a:	df 93       	push	r29
    332c:	5c 01       	movw	r10, r24
    332e:	4b 01       	movw	r8, r22
    3330:	7a 01       	movw	r14, r20
    3332:	12 2f       	mov	r17, r18
    3334:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3336:	63 e0       	ldi	r22, 0x03	; 3
    3338:	ca 01       	movw	r24, r20
    333a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    333e:	a8 14       	cp	r10, r8
    3340:	b9 04       	cpc	r11, r9
    3342:	08 f0       	brcs	.+2      	; 0x3346 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3344:	7d c0       	rjmp	.+250    	; 0x3440 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3346:	65 01       	movw	r12, r10
    3348:	84 e1       	ldi	r24, 0x14	; 20
    334a:	c8 0e       	add	r12, r24
    334c:	d1 1c       	adc	r13, r1
    334e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3350:	6a 2c       	mov	r6, r10
    3352:	5b 2c       	mov	r5, r11
    3354:	b5 01       	movw	r22, r10
    3356:	c7 01       	movw	r24, r14
    3358:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8emstreamlsEj>
    335c:	6a e0       	ldi	r22, 0x0A	; 10
    335e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3362:	61 e3       	ldi	r22, 0x31	; 49
    3364:	76 e0       	ldi	r23, 0x06	; 6
    3366:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    336a:	11 23       	and	r17, r17
    336c:	09 f4       	brne	.+2      	; 0x3370 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    336e:	6d c0       	rjmp	.+218    	; 0x344a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3370:	00 23       	and	r16, r16
    3372:	09 f4       	brne	.+2      	; 0x3376 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3374:	6a c0       	rjmp	.+212    	; 0x344a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3376:	6a e0       	ldi	r22, 0x0A	; 10
    3378:	c7 01       	movw	r24, r14
    337a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    337e:	6c e2       	ldi	r22, 0x2C	; 44
    3380:	76 e0       	ldi	r23, 0x06	; 6
    3382:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    3386:	61 c0       	rjmp	.+194    	; 0x344a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3388:	11 23       	and	r17, r17
    338a:	71 f0       	breq	.+28     	; 0x33a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    338c:	01 11       	cpse	r16, r1
    338e:	0c c0       	rjmp	.+24     	; 0x33a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3390:	88 81       	ld	r24, Y
    3392:	87 15       	cp	r24, r7
    3394:	49 f0       	breq	.+18     	; 0x33a8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3396:	6a e0       	ldi	r22, 0x0A	; 10
    3398:	c7 01       	movw	r24, r14
    339a:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    339e:	67 e2       	ldi	r22, 0x27	; 39
    33a0:	76 e0       	ldi	r23, 0x06	; 6
    33a2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    33a6:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    33a8:	69 91       	ld	r22, Y+
    33aa:	c7 01       	movw	r24, r14
    33ac:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    33b0:	dc 01       	movw	r26, r24
    33b2:	ed 91       	ld	r30, X+
    33b4:	fc 91       	ld	r31, X
    33b6:	02 80       	ldd	r0, Z+2	; 0x02
    33b8:	f3 81       	ldd	r31, Z+3	; 0x03
    33ba:	e0 2d       	mov	r30, r0
    33bc:	60 e2       	ldi	r22, 0x20	; 32
    33be:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    33c0:	cc 16       	cp	r12, r28
    33c2:	dd 06       	cpc	r13, r29
    33c4:	09 f7       	brne	.-62     	; 0x3388 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    33c6:	11 23       	and	r17, r17
    33c8:	89 f0       	breq	.+34     	; 0x33ec <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    33ca:	6a e0       	ldi	r22, 0x0A	; 10
    33cc:	c7 01       	movw	r24, r14
    33ce:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    33d2:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    33d4:	61 e2       	ldi	r22, 0x21	; 33
    33d6:	76 e0       	ldi	r23, 0x06	; 6
    33d8:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    33dc:	e8 81       	ld	r30, Y
    33de:	f9 81       	ldd	r31, Y+1	; 0x01
    33e0:	02 80       	ldd	r0, Z+2	; 0x02
    33e2:	f3 81       	ldd	r31, Z+3	; 0x03
    33e4:	e0 2d       	mov	r30, r0
    33e6:	60 e2       	ldi	r22, 0x20	; 32
    33e8:	ce 01       	movw	r24, r28
    33ea:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    33ec:	c6 2d       	mov	r28, r6
    33ee:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    33f0:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    33f2:	80 ee       	ldi	r24, 0xE0	; 224
    33f4:	86 0f       	add	r24, r22
    33f6:	8f 35       	cpi	r24, 0x5F	; 95
    33f8:	48 f4       	brcc	.+18     	; 0x340c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    33fa:	d7 01       	movw	r26, r14
    33fc:	ed 91       	ld	r30, X+
    33fe:	fc 91       	ld	r31, X
    3400:	02 80       	ldd	r0, Z+2	; 0x02
    3402:	f3 81       	ldd	r31, Z+3	; 0x03
    3404:	e0 2d       	mov	r30, r0
    3406:	c7 01       	movw	r24, r14
    3408:	19 95       	eicall
    340a:	09 c0       	rjmp	.+18     	; 0x341e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    340c:	d7 01       	movw	r26, r14
    340e:	ed 91       	ld	r30, X+
    3410:	fc 91       	ld	r31, X
    3412:	02 80       	ldd	r0, Z+2	; 0x02
    3414:	f3 81       	ldd	r31, Z+3	; 0x03
    3416:	e0 2d       	mov	r30, r0
    3418:	6e e2       	ldi	r22, 0x2E	; 46
    341a:	c7 01       	movw	r24, r14
    341c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    341e:	cc 16       	cp	r12, r28
    3420:	dd 06       	cpc	r13, r29
    3422:	31 f7       	brne	.-52     	; 0x33f0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3424:	b4 e1       	ldi	r27, 0x14	; 20
    3426:	ab 0e       	add	r10, r27
    3428:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    342a:	66 e0       	ldi	r22, 0x06	; 6
    342c:	c7 01       	movw	r24, r14
    342e:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    3432:	84 e1       	ldi	r24, 0x14	; 20
    3434:	c8 0e       	add	r12, r24
    3436:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3438:	a8 14       	cp	r10, r8
    343a:	b9 04       	cpc	r11, r9
    343c:	08 f4       	brcc	.+2      	; 0x3440 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    343e:	88 cf       	rjmp	.-240    	; 0x3350 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3440:	62 e0       	ldi	r22, 0x02	; 2
    3442:	c7 01       	movw	r24, r14
    3444:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
}
    3448:	03 c0       	rjmp	.+6      	; 0x3450 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    344a:	c6 2d       	mov	r28, r6
    344c:	d5 2d       	mov	r29, r5
    344e:	9c cf       	rjmp	.-200    	; 0x3388 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3450:	df 91       	pop	r29
    3452:	cf 91       	pop	r28
    3454:	1f 91       	pop	r17
    3456:	0f 91       	pop	r16
    3458:	ff 90       	pop	r15
    345a:	ef 90       	pop	r14
    345c:	df 90       	pop	r13
    345e:	cf 90       	pop	r12
    3460:	bf 90       	pop	r11
    3462:	af 90       	pop	r10
    3464:	9f 90       	pop	r9
    3466:	8f 90       	pop	r8
    3468:	7f 90       	pop	r7
    346a:	6f 90       	pop	r6
    346c:	5f 90       	pop	r5
    346e:	08 95       	ret

00003470 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3470:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    3474:	08 95       	ret

00003476 <_Znaj>:
    3476:	0e 94 7a 0a 	call	0x14f4	; 0x14f4 <pvPortMalloc>
    347a:	08 95       	ret

0000347c <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    347c:	08 95       	ret

0000347e <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    347e:	cf 93       	push	r28
    3480:	df 93       	push	r29
    3482:	fc 01       	movw	r30, r24
    3484:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3486:	40 3a       	cpi	r20, 0xA0	; 160
    3488:	68 e0       	ldi	r22, 0x08	; 8
    348a:	56 07       	cpc	r21, r22
    348c:	49 f4       	brne	.+18     	; 0x34a0 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    348e:	80 e4       	ldi	r24, 0x40	; 64
    3490:	96 e0       	ldi	r25, 0x06	; 6
    3492:	82 83       	std	Z+2, r24	; 0x02
    3494:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3496:	82 e0       	ldi	r24, 0x02	; 2
    3498:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    349a:	83 e0       	ldi	r24, 0x03	; 3
    349c:	85 83       	std	Z+5, r24	; 0x05
    349e:	32 c0       	rjmp	.+100    	; 0x3504 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    34a0:	40 3b       	cpi	r20, 0xB0	; 176
    34a2:	78 e0       	ldi	r23, 0x08	; 8
    34a4:	57 07       	cpc	r21, r23
    34a6:	49 f4       	brne	.+18     	; 0x34ba <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    34a8:	80 e4       	ldi	r24, 0x40	; 64
    34aa:	96 e0       	ldi	r25, 0x06	; 6
    34ac:	82 83       	std	Z+2, r24	; 0x02
    34ae:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    34b0:	86 e0       	ldi	r24, 0x06	; 6
    34b2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    34b4:	87 e0       	ldi	r24, 0x07	; 7
    34b6:	85 83       	std	Z+5, r24	; 0x05
    34b8:	25 c0       	rjmp	.+74     	; 0x3504 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    34ba:	40 3a       	cpi	r20, 0xA0	; 160
    34bc:	89 e0       	ldi	r24, 0x09	; 9
    34be:	58 07       	cpc	r21, r24
    34c0:	49 f4       	brne	.+18     	; 0x34d4 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    34c2:	80 e6       	ldi	r24, 0x60	; 96
    34c4:	96 e0       	ldi	r25, 0x06	; 6
    34c6:	82 83       	std	Z+2, r24	; 0x02
    34c8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    34ca:	82 e0       	ldi	r24, 0x02	; 2
    34cc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    34ce:	83 e0       	ldi	r24, 0x03	; 3
    34d0:	85 83       	std	Z+5, r24	; 0x05
    34d2:	18 c0       	rjmp	.+48     	; 0x3504 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    34d4:	40 3b       	cpi	r20, 0xB0	; 176
    34d6:	69 e0       	ldi	r22, 0x09	; 9
    34d8:	56 07       	cpc	r21, r22
    34da:	49 f4       	brne	.+18     	; 0x34ee <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    34dc:	80 e6       	ldi	r24, 0x60	; 96
    34de:	96 e0       	ldi	r25, 0x06	; 6
    34e0:	82 83       	std	Z+2, r24	; 0x02
    34e2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    34e4:	86 e0       	ldi	r24, 0x06	; 6
    34e6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    34e8:	87 e0       	ldi	r24, 0x07	; 7
    34ea:	85 83       	std	Z+5, r24	; 0x05
    34ec:	0b c0       	rjmp	.+22     	; 0x3504 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    34ee:	40 3a       	cpi	r20, 0xA0	; 160
    34f0:	5a 40       	sbci	r21, 0x0A	; 10
    34f2:	41 f4       	brne	.+16     	; 0x3504 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    34f4:	80 e8       	ldi	r24, 0x80	; 128
    34f6:	96 e0       	ldi	r25, 0x06	; 6
    34f8:	82 83       	std	Z+2, r24	; 0x02
    34fa:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    34fc:	82 e0       	ldi	r24, 0x02	; 2
    34fe:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3500:	83 e0       	ldi	r24, 0x03	; 3
    3502:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3504:	a6 83       	std	Z+6, r26	; 0x06
    3506:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3508:	cd 01       	movw	r24, r26
    350a:	01 96       	adiw	r24, 0x01	; 1
    350c:	80 87       	std	Z+8, r24	; 0x08
    350e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3510:	03 96       	adiw	r24, 0x03	; 3
    3512:	82 87       	std	Z+10, r24	; 0x0a
    3514:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3516:	25 81       	ldd	r18, Z+5	; 0x05
    3518:	c2 81       	ldd	r28, Z+2	; 0x02
    351a:	d3 81       	ldd	r29, Z+3	; 0x03
    351c:	4c 81       	ldd	r20, Y+4	; 0x04
    351e:	81 e0       	ldi	r24, 0x01	; 1
    3520:	90 e0       	ldi	r25, 0x00	; 0
    3522:	bc 01       	movw	r22, r24
    3524:	02 c0       	rjmp	.+4      	; 0x352a <_ZN7base232C1EjP12USART_struct+0xac>
    3526:	66 0f       	add	r22, r22
    3528:	77 1f       	adc	r23, r23
    352a:	2a 95       	dec	r18
    352c:	e2 f7       	brpl	.-8      	; 0x3526 <_ZN7base232C1EjP12USART_struct+0xa8>
    352e:	9b 01       	movw	r18, r22
    3530:	24 2b       	or	r18, r20
    3532:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3534:	25 81       	ldd	r18, Z+5	; 0x05
    3536:	c2 81       	ldd	r28, Z+2	; 0x02
    3538:	d3 81       	ldd	r29, Z+3	; 0x03
    353a:	48 81       	ld	r20, Y
    353c:	bc 01       	movw	r22, r24
    353e:	02 c0       	rjmp	.+4      	; 0x3544 <_ZN7base232C1EjP12USART_struct+0xc6>
    3540:	66 0f       	add	r22, r22
    3542:	77 1f       	adc	r23, r23
    3544:	2a 95       	dec	r18
    3546:	e2 f7       	brpl	.-8      	; 0x3540 <_ZN7base232C1EjP12USART_struct+0xc2>
    3548:	9b 01       	movw	r18, r22
    354a:	24 2b       	or	r18, r20
    354c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    354e:	34 81       	ldd	r19, Z+4	; 0x04
    3550:	c2 81       	ldd	r28, Z+2	; 0x02
    3552:	d3 81       	ldd	r29, Z+3	; 0x03
    3554:	28 81       	ld	r18, Y
    3556:	02 c0       	rjmp	.+4      	; 0x355c <_ZN7base232C1EjP12USART_struct+0xde>
    3558:	88 0f       	add	r24, r24
    355a:	99 1f       	adc	r25, r25
    355c:	3a 95       	dec	r19
    355e:	e2 f7       	brpl	.-8      	; 0x3558 <_ZN7base232C1EjP12USART_struct+0xda>
    3560:	80 95       	com	r24
    3562:	90 95       	com	r25
    3564:	82 23       	and	r24, r18
    3566:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3568:	80 e1       	ldi	r24, 0x10	; 16
    356a:	13 96       	adiw	r26, 0x03	; 3
    356c:	8c 93       	st	X, r24
    356e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3570:	83 e0       	ldi	r24, 0x03	; 3
    3572:	15 96       	adiw	r26, 0x05	; 5
    3574:	8c 93       	st	X, r24
    3576:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3578:	80 ef       	ldi	r24, 0xF0	; 240
    357a:	17 96       	adiw	r26, 0x07	; 7
    357c:	8c 93       	st	X, r24
    357e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3580:	81 e2       	ldi	r24, 0x21	; 33
    3582:	16 96       	adiw	r26, 0x06	; 6
    3584:	8c 93       	st	X, r24
    3586:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3588:	88 e1       	ldi	r24, 0x18	; 24
    358a:	14 96       	adiw	r26, 0x04	; 4
    358c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    358e:	80 e8       	ldi	r24, 0x80	; 128
    3590:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3592:	80 e4       	ldi	r24, 0x40	; 64
    3594:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3596:	80 e2       	ldi	r24, 0x20	; 32
    3598:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    359a:	06 80       	ldd	r0, Z+6	; 0x06
    359c:	f7 81       	ldd	r31, Z+7	; 0x07
    359e:	e0 2d       	mov	r30, r0
    35a0:	80 81       	ld	r24, Z
    35a2:	80 81       	ld	r24, Z
}
    35a4:	df 91       	pop	r29
    35a6:	cf 91       	pop	r28
    35a8:	08 95       	ret

000035aa <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    35aa:	81 e0       	ldi	r24, 0x01	; 1
    35ac:	08 95       	ret

000035ae <_ZN8emstream7getcharEv>:
    35ae:	80 e0       	ldi	r24, 0x00	; 0
    35b0:	90 e0       	ldi	r25, 0x00	; 0
    35b2:	08 95       	ret

000035b4 <_ZN8emstream14check_for_charEv>:
    35b4:	80 e0       	ldi	r24, 0x00	; 0
    35b6:	08 95       	ret

000035b8 <_ZN8emstream12transmit_nowEv>:
    35b8:	08 95       	ret

000035ba <_ZN8emstream12clear_screenEv>:
    35ba:	08 95       	ret

000035bc <_ZN8emstreamC1Ev>:
    35bc:	fc 01       	movw	r30, r24
    35be:	85 ec       	ldi	r24, 0xC5	; 197
    35c0:	90 e2       	ldi	r25, 0x20	; 32
    35c2:	80 83       	st	Z, r24
    35c4:	91 83       	std	Z+1, r25	; 0x01
    35c6:	8a e0       	ldi	r24, 0x0A	; 10
    35c8:	82 83       	std	Z+2, r24	; 0x02
    35ca:	13 82       	std	Z+3, r1	; 0x03
    35cc:	83 e0       	ldi	r24, 0x03	; 3
    35ce:	85 83       	std	Z+5, r24	; 0x05
    35d0:	14 82       	std	Z+4, r1	; 0x04
    35d2:	16 82       	std	Z+6, r1	; 0x06
    35d4:	17 82       	std	Z+7, r1	; 0x07
    35d6:	08 95       	ret

000035d8 <_ZN8emstream4putsEPKc>:
    35d8:	0f 93       	push	r16
    35da:	1f 93       	push	r17
    35dc:	cf 93       	push	r28
    35de:	df 93       	push	r29
    35e0:	8c 01       	movw	r16, r24
    35e2:	fb 01       	movw	r30, r22
    35e4:	dc 01       	movw	r26, r24
    35e6:	14 96       	adiw	r26, 0x04	; 4
    35e8:	8c 91       	ld	r24, X
    35ea:	81 11       	cpse	r24, r1
    35ec:	04 c0       	rjmp	.+8      	; 0x35f6 <_ZN8emstream4putsEPKc+0x1e>
    35ee:	60 81       	ld	r22, Z
    35f0:	61 11       	cpse	r22, r1
    35f2:	17 c0       	rjmp	.+46     	; 0x3622 <_ZN8emstream4putsEPKc+0x4a>
    35f4:	23 c0       	rjmp	.+70     	; 0x363c <_ZN8emstream4putsEPKc+0x64>
    35f6:	d8 01       	movw	r26, r16
    35f8:	14 96       	adiw	r26, 0x04	; 4
    35fa:	1c 92       	st	X, r1
    35fc:	eb 01       	movw	r28, r22
    35fe:	21 96       	adiw	r28, 0x01	; 1
    3600:	64 91       	lpm	r22, Z
    3602:	66 23       	and	r22, r22
    3604:	d9 f0       	breq	.+54     	; 0x363c <_ZN8emstream4putsEPKc+0x64>
    3606:	d8 01       	movw	r26, r16
    3608:	ed 91       	ld	r30, X+
    360a:	fc 91       	ld	r31, X
    360c:	02 80       	ldd	r0, Z+2	; 0x02
    360e:	f3 81       	ldd	r31, Z+3	; 0x03
    3610:	e0 2d       	mov	r30, r0
    3612:	c8 01       	movw	r24, r16
    3614:	19 95       	eicall
    3616:	fe 01       	movw	r30, r28
    3618:	64 91       	lpm	r22, Z
    361a:	21 96       	adiw	r28, 0x01	; 1
    361c:	61 11       	cpse	r22, r1
    361e:	f3 cf       	rjmp	.-26     	; 0x3606 <_ZN8emstream4putsEPKc+0x2e>
    3620:	0d c0       	rjmp	.+26     	; 0x363c <_ZN8emstream4putsEPKc+0x64>
    3622:	ef 01       	movw	r28, r30
    3624:	21 96       	adiw	r28, 0x01	; 1
    3626:	d8 01       	movw	r26, r16
    3628:	ed 91       	ld	r30, X+
    362a:	fc 91       	ld	r31, X
    362c:	02 80       	ldd	r0, Z+2	; 0x02
    362e:	f3 81       	ldd	r31, Z+3	; 0x03
    3630:	e0 2d       	mov	r30, r0
    3632:	c8 01       	movw	r24, r16
    3634:	19 95       	eicall
    3636:	69 91       	ld	r22, Y+
    3638:	61 11       	cpse	r22, r1
    363a:	f5 cf       	rjmp	.-22     	; 0x3626 <_ZN8emstream4putsEPKc+0x4e>
    363c:	df 91       	pop	r29
    363e:	cf 91       	pop	r28
    3640:	1f 91       	pop	r17
    3642:	0f 91       	pop	r16
    3644:	08 95       	ret

00003646 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3646:	cf 93       	push	r28
    3648:	df 93       	push	r29
    364a:	ec 01       	movw	r28, r24
	switch (new_manip)
    364c:	86 2f       	mov	r24, r22
    364e:	90 e0       	ldi	r25, 0x00	; 0
    3650:	8b 30       	cpi	r24, 0x0B	; 11
    3652:	91 05       	cpc	r25, r1
    3654:	d8 f5       	brcc	.+118    	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
    3656:	fc 01       	movw	r30, r24
    3658:	88 27       	eor	r24, r24
    365a:	e2 50       	subi	r30, 0x02	; 2
    365c:	ff 4f       	sbci	r31, 0xFF	; 255
    365e:	8f 4f       	sbci	r24, 0xFF	; 255
    3660:	0c 94 89 22 	jmp	0x4512	; 0x4512 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3664:	82 e0       	ldi	r24, 0x02	; 2
    3666:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3668:	31 c0       	rjmp	.+98     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    366a:	88 e0       	ldi	r24, 0x08	; 8
    366c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    366e:	2e c0       	rjmp	.+92     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3670:	8a e0       	ldi	r24, 0x0A	; 10
    3672:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3674:	2b c0       	rjmp	.+86     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3676:	80 e1       	ldi	r24, 0x10	; 16
    3678:	8a 83       	std	Y+2, r24	; 0x02
			break;
    367a:	28 c0       	rjmp	.+80     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    367c:	81 e0       	ldi	r24, 0x01	; 1
    367e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3680:	25 c0       	rjmp	.+74     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3682:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3684:	23 c0       	rjmp	.+70     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3686:	e8 81       	ld	r30, Y
    3688:	f9 81       	ldd	r31, Y+1	; 0x01
    368a:	02 80       	ldd	r0, Z+2	; 0x02
    368c:	f3 81       	ldd	r31, Z+3	; 0x03
    368e:	e0 2d       	mov	r30, r0
    3690:	6d e0       	ldi	r22, 0x0D	; 13
    3692:	ce 01       	movw	r24, r28
    3694:	19 95       	eicall
    3696:	e8 81       	ld	r30, Y
    3698:	f9 81       	ldd	r31, Y+1	; 0x01
    369a:	02 80       	ldd	r0, Z+2	; 0x02
    369c:	f3 81       	ldd	r31, Z+3	; 0x03
    369e:	e0 2d       	mov	r30, r0
    36a0:	6a e0       	ldi	r22, 0x0A	; 10
    36a2:	ce 01       	movw	r24, r28
    36a4:	19 95       	eicall
			break;
    36a6:	12 c0       	rjmp	.+36     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    36a8:	e8 81       	ld	r30, Y
    36aa:	f9 81       	ldd	r31, Y+1	; 0x01
    36ac:	02 84       	ldd	r0, Z+10	; 0x0a
    36ae:	f3 85       	ldd	r31, Z+11	; 0x0b
    36b0:	e0 2d       	mov	r30, r0
    36b2:	ce 01       	movw	r24, r28
    36b4:	19 95       	eicall
			break;
    36b6:	0a c0       	rjmp	.+20     	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    36b8:	e8 81       	ld	r30, Y
    36ba:	f9 81       	ldd	r31, Y+1	; 0x01
    36bc:	00 84       	ldd	r0, Z+8	; 0x08
    36be:	f1 85       	ldd	r31, Z+9	; 0x09
    36c0:	e0 2d       	mov	r30, r0
    36c2:	ce 01       	movw	r24, r28
    36c4:	19 95       	eicall
			break;
    36c6:	02 c0       	rjmp	.+4      	; 0x36cc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    36c8:	81 e0       	ldi	r24, 0x01	; 1
    36ca:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    36cc:	ce 01       	movw	r24, r28
    36ce:	df 91       	pop	r29
    36d0:	cf 91       	pop	r28
    36d2:	08 95       	ret

000036d4 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    36d4:	ff 92       	push	r15
    36d6:	0f 93       	push	r16
    36d8:	1f 93       	push	r17
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	cd b7       	in	r28, 0x3d	; 61
    36e0:	de b7       	in	r29, 0x3e	; 62
    36e2:	61 97       	sbiw	r28, 0x11	; 17
    36e4:	cd bf       	out	0x3d, r28	; 61
    36e6:	de bf       	out	0x3e, r29	; 62
    36e8:	8c 01       	movw	r16, r24
    36ea:	f6 2e       	mov	r15, r22
    36ec:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    36ee:	f8 01       	movw	r30, r16
    36f0:	42 81       	ldd	r20, Z+2	; 0x02
    36f2:	40 31       	cpi	r20, 0x10	; 16
    36f4:	21 f0       	breq	.+8      	; 0x36fe <_ZN8emstreamlsEj+0x2a>
    36f6:	48 30       	cpi	r20, 0x08	; 8
    36f8:	11 f0       	breq	.+4      	; 0x36fe <_ZN8emstreamlsEj+0x2a>
    36fa:	42 30       	cpi	r20, 0x02	; 2
    36fc:	41 f4       	brne	.+16     	; 0x370e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    36fe:	69 2f       	mov	r22, r25
    3700:	c8 01       	movw	r24, r16
    3702:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    3706:	6f 2d       	mov	r22, r15
    3708:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    370c:	0d c0       	rjmp	.+26     	; 0x3728 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    370e:	50 e0       	ldi	r21, 0x00	; 0
    3710:	be 01       	movw	r22, r28
    3712:	6f 5f       	subi	r22, 0xFF	; 255
    3714:	7f 4f       	sbci	r23, 0xFF	; 255
    3716:	8f 2d       	mov	r24, r15
    3718:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    371c:	be 01       	movw	r22, r28
    371e:	6f 5f       	subi	r22, 0xFF	; 255
    3720:	7f 4f       	sbci	r23, 0xFF	; 255
    3722:	c8 01       	movw	r24, r16
    3724:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3728:	c8 01       	movw	r24, r16
    372a:	61 96       	adiw	r28, 0x11	; 17
    372c:	cd bf       	out	0x3d, r28	; 61
    372e:	de bf       	out	0x3e, r29	; 62
    3730:	df 91       	pop	r29
    3732:	cf 91       	pop	r28
    3734:	1f 91       	pop	r17
    3736:	0f 91       	pop	r16
    3738:	ff 90       	pop	r15
    373a:	08 95       	ret

0000373c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    373c:	df 92       	push	r13
    373e:	ef 92       	push	r14
    3740:	ff 92       	push	r15
    3742:	0f 93       	push	r16
    3744:	1f 93       	push	r17
    3746:	cf 93       	push	r28
    3748:	df 93       	push	r29
    374a:	cd b7       	in	r28, 0x3d	; 61
    374c:	de b7       	in	r29, 0x3e	; 62
    374e:	a1 97       	sbiw	r28, 0x21	; 33
    3750:	cd bf       	out	0x3d, r28	; 61
    3752:	de bf       	out	0x3e, r29	; 62
    3754:	8c 01       	movw	r16, r24
    3756:	d4 2e       	mov	r13, r20
    3758:	e5 2e       	mov	r14, r21
    375a:	f6 2e       	mov	r15, r22
    375c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    375e:	f8 01       	movw	r30, r16
    3760:	22 81       	ldd	r18, Z+2	; 0x02
    3762:	20 31       	cpi	r18, 0x10	; 16
    3764:	21 f0       	breq	.+8      	; 0x376e <_ZN8emstreamlsEm+0x32>
    3766:	28 30       	cpi	r18, 0x08	; 8
    3768:	11 f0       	breq	.+4      	; 0x376e <_ZN8emstreamlsEm+0x32>
    376a:	22 30       	cpi	r18, 0x02	; 2
    376c:	71 f4       	brne	.+28     	; 0x378a <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    376e:	69 2f       	mov	r22, r25
    3770:	c8 01       	movw	r24, r16
    3772:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    3776:	6f 2d       	mov	r22, r15
    3778:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    377c:	6e 2d       	mov	r22, r14
    377e:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    3782:	6d 2d       	mov	r22, r13
    3784:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <_ZN8emstreamlsEh>
    3788:	0f c0       	rjmp	.+30     	; 0x37a8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    378a:	30 e0       	ldi	r19, 0x00	; 0
    378c:	ae 01       	movw	r20, r28
    378e:	4f 5f       	subi	r20, 0xFF	; 255
    3790:	5f 4f       	sbci	r21, 0xFF	; 255
    3792:	6d 2d       	mov	r22, r13
    3794:	7e 2d       	mov	r23, r14
    3796:	8f 2d       	mov	r24, r15
    3798:	0e 94 cb 22 	call	0x4596	; 0x4596 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    379c:	be 01       	movw	r22, r28
    379e:	6f 5f       	subi	r22, 0xFF	; 255
    37a0:	7f 4f       	sbci	r23, 0xFF	; 255
    37a2:	c8 01       	movw	r24, r16
    37a4:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    37a8:	c8 01       	movw	r24, r16
    37aa:	a1 96       	adiw	r28, 0x21	; 33
    37ac:	cd bf       	out	0x3d, r28	; 61
    37ae:	de bf       	out	0x3e, r29	; 62
    37b0:	df 91       	pop	r29
    37b2:	cf 91       	pop	r28
    37b4:	1f 91       	pop	r17
    37b6:	0f 91       	pop	r16
    37b8:	ff 90       	pop	r15
    37ba:	ef 90       	pop	r14
    37bc:	df 90       	pop	r13
    37be:	08 95       	ret

000037c0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    37c0:	cf 92       	push	r12
    37c2:	df 92       	push	r13
    37c4:	ef 92       	push	r14
    37c6:	ff 92       	push	r15
    37c8:	0f 93       	push	r16
    37ca:	1f 93       	push	r17
    37cc:	cf 93       	push	r28
    37ce:	df 93       	push	r29
    37d0:	cd b7       	in	r28, 0x3d	; 61
    37d2:	de b7       	in	r29, 0x3e	; 62
    37d4:	29 97       	sbiw	r28, 0x09	; 9
    37d6:	cd bf       	out	0x3d, r28	; 61
    37d8:	de bf       	out	0x3e, r29	; 62
    37da:	8c 01       	movw	r16, r24
    37dc:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    37de:	dc 01       	movw	r26, r24
    37e0:	13 96       	adiw	r26, 0x03	; 3
    37e2:	8c 91       	ld	r24, X
    37e4:	13 97       	sbiw	r26, 0x03	; 3
    37e6:	88 23       	and	r24, r24
    37e8:	41 f0       	breq	.+16     	; 0x37fa <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    37ea:	ed 91       	ld	r30, X+
    37ec:	fc 91       	ld	r31, X
    37ee:	02 80       	ldd	r0, Z+2	; 0x02
    37f0:	f3 81       	ldd	r31, Z+3	; 0x03
    37f2:	e0 2d       	mov	r30, r0
    37f4:	c8 01       	movw	r24, r16
    37f6:	19 95       	eicall
    37f8:	56 c0       	rjmp	.+172    	; 0x38a6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    37fa:	f8 01       	movw	r30, r16
    37fc:	42 81       	ldd	r20, Z+2	; 0x02
    37fe:	42 30       	cpi	r20, 0x02	; 2
    3800:	19 f5       	brne	.+70     	; 0x3848 <_ZN8emstreamlsEh+0x88>
    3802:	68 94       	set
    3804:	cc 24       	eor	r12, r12
    3806:	c3 f8       	bld	r12, 3
    3808:	d1 2c       	mov	r13, r1
    380a:	68 94       	set
    380c:	ff 24       	eor	r15, r15
    380e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3810:	8e 2d       	mov	r24, r14
    3812:	8f 21       	and	r24, r15
    3814:	51 f0       	breq	.+20     	; 0x382a <_ZN8emstreamlsEh+0x6a>
    3816:	d8 01       	movw	r26, r16
    3818:	ed 91       	ld	r30, X+
    381a:	fc 91       	ld	r31, X
    381c:	02 80       	ldd	r0, Z+2	; 0x02
    381e:	f3 81       	ldd	r31, Z+3	; 0x03
    3820:	e0 2d       	mov	r30, r0
    3822:	61 e3       	ldi	r22, 0x31	; 49
    3824:	c8 01       	movw	r24, r16
    3826:	19 95       	eicall
    3828:	09 c0       	rjmp	.+18     	; 0x383c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    382a:	d8 01       	movw	r26, r16
    382c:	ed 91       	ld	r30, X+
    382e:	fc 91       	ld	r31, X
    3830:	02 80       	ldd	r0, Z+2	; 0x02
    3832:	f3 81       	ldd	r31, Z+3	; 0x03
    3834:	e0 2d       	mov	r30, r0
    3836:	60 e3       	ldi	r22, 0x30	; 48
    3838:	c8 01       	movw	r24, r16
    383a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    383c:	f6 94       	lsr	r15
    383e:	b1 e0       	ldi	r27, 0x01	; 1
    3840:	cb 1a       	sub	r12, r27
    3842:	d1 08       	sbc	r13, r1
    3844:	29 f7       	brne	.-54     	; 0x3810 <_ZN8emstreamlsEh+0x50>
    3846:	2f c0       	rjmp	.+94     	; 0x38a6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3848:	40 31       	cpi	r20, 0x10	; 16
    384a:	f9 f4       	brne	.+62     	; 0x388a <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    384c:	62 95       	swap	r22
    384e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3850:	01 90       	ld	r0, Z+
    3852:	f0 81       	ld	r31, Z
    3854:	e0 2d       	mov	r30, r0
    3856:	02 80       	ldd	r0, Z+2	; 0x02
    3858:	f3 81       	ldd	r31, Z+3	; 0x03
    385a:	e0 2d       	mov	r30, r0
    385c:	6a 30       	cpi	r22, 0x0A	; 10
    385e:	10 f0       	brcs	.+4      	; 0x3864 <_ZN8emstreamlsEh+0xa4>
    3860:	69 5c       	subi	r22, 0xC9	; 201
    3862:	01 c0       	rjmp	.+2      	; 0x3866 <_ZN8emstreamlsEh+0xa6>
    3864:	60 5d       	subi	r22, 0xD0	; 208
    3866:	c8 01       	movw	r24, r16
    3868:	19 95       	eicall
		temp_char = num & 0x0F;
    386a:	6e 2d       	mov	r22, r14
    386c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    386e:	d8 01       	movw	r26, r16
    3870:	ed 91       	ld	r30, X+
    3872:	fc 91       	ld	r31, X
    3874:	02 80       	ldd	r0, Z+2	; 0x02
    3876:	f3 81       	ldd	r31, Z+3	; 0x03
    3878:	e0 2d       	mov	r30, r0
    387a:	6a 30       	cpi	r22, 0x0A	; 10
    387c:	10 f0       	brcs	.+4      	; 0x3882 <_ZN8emstreamlsEh+0xc2>
    387e:	69 5c       	subi	r22, 0xC9	; 201
    3880:	01 c0       	rjmp	.+2      	; 0x3884 <_ZN8emstreamlsEh+0xc4>
    3882:	60 5d       	subi	r22, 0xD0	; 208
    3884:	c8 01       	movw	r24, r16
    3886:	19 95       	eicall
    3888:	0e c0       	rjmp	.+28     	; 0x38a6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    388a:	50 e0       	ldi	r21, 0x00	; 0
    388c:	be 01       	movw	r22, r28
    388e:	6f 5f       	subi	r22, 0xFF	; 255
    3890:	7f 4f       	sbci	r23, 0xFF	; 255
    3892:	8e 2d       	mov	r24, r14
    3894:	90 e0       	ldi	r25, 0x00	; 0
    3896:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    389a:	be 01       	movw	r22, r28
    389c:	6f 5f       	subi	r22, 0xFF	; 255
    389e:	7f 4f       	sbci	r23, 0xFF	; 255
    38a0:	c8 01       	movw	r24, r16
    38a2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    38a6:	c8 01       	movw	r24, r16
    38a8:	29 96       	adiw	r28, 0x09	; 9
    38aa:	cd bf       	out	0x3d, r28	; 61
    38ac:	de bf       	out	0x3e, r29	; 62
    38ae:	df 91       	pop	r29
    38b0:	cf 91       	pop	r28
    38b2:	1f 91       	pop	r17
    38b4:	0f 91       	pop	r16
    38b6:	ff 90       	pop	r15
    38b8:	ef 90       	pop	r14
    38ba:	df 90       	pop	r13
    38bc:	cf 90       	pop	r12
    38be:	08 95       	ret

000038c0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    38c0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    38c2:	50 96       	adiw	r26, 0x10	; 16
    38c4:	ed 91       	ld	r30, X+
    38c6:	fc 91       	ld	r31, X
    38c8:	51 97       	sbiw	r26, 0x11	; 17
    38ca:	80 81       	ld	r24, Z
    38cc:	54 96       	adiw	r26, 0x14	; 20
    38ce:	4c 91       	ld	r20, X
    38d0:	54 97       	sbiw	r26, 0x14	; 20
    38d2:	84 23       	and	r24, r20
    38d4:	29 f0       	breq	.+10     	; 0x38e0 <_ZN5rs2327putcharEc+0x20>
    38d6:	09 c0       	rjmp	.+18     	; 0x38ea <_ZN5rs2327putcharEc+0x2a>
    38d8:	21 50       	subi	r18, 0x01	; 1
    38da:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    38dc:	19 f4       	brne	.+6      	; 0x38e4 <_ZN5rs2327putcharEc+0x24>
    38de:	12 c0       	rjmp	.+36     	; 0x3904 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    38e0:	21 e2       	ldi	r18, 0x21	; 33
    38e2:	3e e4       	ldi	r19, 0x4E	; 78
    38e4:	90 81       	ld	r25, Z
    38e6:	94 23       	and	r25, r20
    38e8:	b9 f3       	breq	.-18     	; 0x38d8 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    38ea:	90 81       	ld	r25, Z
    38ec:	56 96       	adiw	r26, 0x16	; 22
    38ee:	8c 91       	ld	r24, X
    38f0:	56 97       	sbiw	r26, 0x16	; 22
    38f2:	89 2b       	or	r24, r25
    38f4:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    38f6:	1e 96       	adiw	r26, 0x0e	; 14
    38f8:	ed 91       	ld	r30, X+
    38fa:	fc 91       	ld	r31, X
    38fc:	1f 97       	sbiw	r26, 0x0f	; 15
    38fe:	60 83       	st	Z, r22
	return (true);
    3900:	81 e0       	ldi	r24, 0x01	; 1
    3902:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3904:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3906:	08 95       	ret

00003908 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3908:	cf 93       	push	r28
    390a:	df 93       	push	r29
    390c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    390e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3910:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3912:	28 81       	ld	r18, Y
    3914:	39 81       	ldd	r19, Y+1	; 0x01
    3916:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3918:	b4 8d       	ldd	r27, Z+28	; 0x1c
    391a:	4d 91       	ld	r20, X+
    391c:	5c 91       	ld	r21, X
    391e:	24 17       	cp	r18, r20
    3920:	35 07       	cpc	r19, r21
    3922:	e9 f3       	breq	.-6      	; 0x391e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3924:	a7 89       	ldd	r26, Z+23	; 0x17
    3926:	b0 8d       	ldd	r27, Z+24	; 0x18
    3928:	0d 90       	ld	r0, X+
    392a:	bc 91       	ld	r27, X
    392c:	a0 2d       	mov	r26, r0
    392e:	a2 0f       	add	r26, r18
    3930:	b3 1f       	adc	r27, r19
    3932:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3934:	2f 5f       	subi	r18, 0xFF	; 255
    3936:	3f 4f       	sbci	r19, 0xFF	; 255
    3938:	28 83       	st	Y, r18
    393a:	39 83       	std	Y+1, r19	; 0x01
    393c:	24 36       	cpi	r18, 0x64	; 100
    393e:	31 05       	cpc	r19, r1
    3940:	28 f0       	brcs	.+10     	; 0x394c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3942:	01 8c       	ldd	r0, Z+25	; 0x19
    3944:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3946:	e0 2d       	mov	r30, r0
    3948:	10 82       	st	Z, r1
    394a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    394c:	90 e0       	ldi	r25, 0x00	; 0
    394e:	df 91       	pop	r29
    3950:	cf 91       	pop	r28
    3952:	08 95       	ret

00003954 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3954:	cf 93       	push	r28
    3956:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3958:	ec 01       	movw	r28, r24
    395a:	a9 8d       	ldd	r26, Y+25	; 0x19
    395c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    395e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3960:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3962:	81 e0       	ldi	r24, 0x01	; 1
    3964:	4d 91       	ld	r20, X+
    3966:	5c 91       	ld	r21, X
    3968:	20 81       	ld	r18, Z
    396a:	31 81       	ldd	r19, Z+1	; 0x01
    396c:	42 17       	cp	r20, r18
    396e:	53 07       	cpc	r21, r19
    3970:	09 f4       	brne	.+2      	; 0x3974 <_ZN5rs23214check_for_charEv+0x20>
    3972:	80 e0       	ldi	r24, 0x00	; 0
}
    3974:	df 91       	pop	r29
    3976:	cf 91       	pop	r28
    3978:	08 95       	ret

0000397a <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    397a:	dc 01       	movw	r26, r24
    397c:	ed 91       	ld	r30, X+
    397e:	fc 91       	ld	r31, X
    3980:	02 80       	ldd	r0, Z+2	; 0x02
    3982:	f3 81       	ldd	r31, Z+3	; 0x03
    3984:	e0 2d       	mov	r30, r0
    3986:	6c e0       	ldi	r22, 0x0C	; 12
    3988:	19 95       	eicall
    398a:	08 95       	ret

0000398c <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    398c:	ef 92       	push	r14
    398e:	ff 92       	push	r15
    3990:	0f 93       	push	r16
    3992:	1f 93       	push	r17
    3994:	cf 93       	push	r28
    3996:	df 93       	push	r29
    3998:	ec 01       	movw	r28, r24
    399a:	7b 01       	movw	r14, r22
    399c:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    399e:	0e 94 de 1a 	call	0x35bc	; 0x35bc <_ZN8emstreamC1Ev>
    39a2:	a8 01       	movw	r20, r16
    39a4:	b7 01       	movw	r22, r14
    39a6:	ce 01       	movw	r24, r28
    39a8:	08 96       	adiw	r24, 0x08	; 8
    39aa:	0e 94 3f 1a 	call	0x347e	; 0x347e <_ZN7base232C1EjP12USART_struct>
    39ae:	85 ed       	ldi	r24, 0xD5	; 213
    39b0:	90 e2       	ldi	r25, 0x20	; 32
    39b2:	88 83       	st	Y, r24
    39b4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    39b6:	00 3a       	cpi	r16, 0xA0	; 160
    39b8:	88 e0       	ldi	r24, 0x08	; 8
    39ba:	18 07       	cpc	r17, r24
    39bc:	69 f4       	brne	.+26     	; 0x39d8 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    39be:	8e ed       	ldi	r24, 0xDE	; 222
    39c0:	91 e3       	ldi	r25, 0x31	; 49
    39c2:	8f 8b       	std	Y+23, r24	; 0x17
    39c4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    39c6:	84 ed       	ldi	r24, 0xD4	; 212
    39c8:	91 e3       	ldi	r25, 0x31	; 49
    39ca:	89 8f       	std	Y+25, r24	; 0x19
    39cc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    39ce:	8a ec       	ldi	r24, 0xCA	; 202
    39d0:	91 e3       	ldi	r25, 0x31	; 49
    39d2:	8b 8f       	std	Y+27, r24	; 0x1b
    39d4:	9c 8f       	std	Y+28, r25	; 0x1c
    39d6:	42 c0       	rjmp	.+132    	; 0x3a5c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    39d8:	00 3b       	cpi	r16, 0xB0	; 176
    39da:	e8 e0       	ldi	r30, 0x08	; 8
    39dc:	1e 07       	cpc	r17, r30
    39de:	69 f4       	brne	.+26     	; 0x39fa <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    39e0:	8c ed       	ldi	r24, 0xDC	; 220
    39e2:	91 e3       	ldi	r25, 0x31	; 49
    39e4:	8f 8b       	std	Y+23, r24	; 0x17
    39e6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    39e8:	82 ed       	ldi	r24, 0xD2	; 210
    39ea:	91 e3       	ldi	r25, 0x31	; 49
    39ec:	89 8f       	std	Y+25, r24	; 0x19
    39ee:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    39f0:	88 ec       	ldi	r24, 0xC8	; 200
    39f2:	91 e3       	ldi	r25, 0x31	; 49
    39f4:	8b 8f       	std	Y+27, r24	; 0x1b
    39f6:	9c 8f       	std	Y+28, r25	; 0x1c
    39f8:	31 c0       	rjmp	.+98     	; 0x3a5c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    39fa:	00 3a       	cpi	r16, 0xA0	; 160
    39fc:	f9 e0       	ldi	r31, 0x09	; 9
    39fe:	1f 07       	cpc	r17, r31
    3a00:	69 f4       	brne	.+26     	; 0x3a1c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3a02:	8a ed       	ldi	r24, 0xDA	; 218
    3a04:	91 e3       	ldi	r25, 0x31	; 49
    3a06:	8f 8b       	std	Y+23, r24	; 0x17
    3a08:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3a0a:	80 ed       	ldi	r24, 0xD0	; 208
    3a0c:	91 e3       	ldi	r25, 0x31	; 49
    3a0e:	89 8f       	std	Y+25, r24	; 0x19
    3a10:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3a12:	86 ec       	ldi	r24, 0xC6	; 198
    3a14:	91 e3       	ldi	r25, 0x31	; 49
    3a16:	8b 8f       	std	Y+27, r24	; 0x1b
    3a18:	9c 8f       	std	Y+28, r25	; 0x1c
    3a1a:	20 c0       	rjmp	.+64     	; 0x3a5c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3a1c:	00 3b       	cpi	r16, 0xB0	; 176
    3a1e:	89 e0       	ldi	r24, 0x09	; 9
    3a20:	18 07       	cpc	r17, r24
    3a22:	69 f4       	brne	.+26     	; 0x3a3e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3a24:	88 ed       	ldi	r24, 0xD8	; 216
    3a26:	91 e3       	ldi	r25, 0x31	; 49
    3a28:	8f 8b       	std	Y+23, r24	; 0x17
    3a2a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3a2c:	8e ec       	ldi	r24, 0xCE	; 206
    3a2e:	91 e3       	ldi	r25, 0x31	; 49
    3a30:	89 8f       	std	Y+25, r24	; 0x19
    3a32:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3a34:	84 ec       	ldi	r24, 0xC4	; 196
    3a36:	91 e3       	ldi	r25, 0x31	; 49
    3a38:	8b 8f       	std	Y+27, r24	; 0x1b
    3a3a:	9c 8f       	std	Y+28, r25	; 0x1c
    3a3c:	0f c0       	rjmp	.+30     	; 0x3a5c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3a3e:	00 3a       	cpi	r16, 0xA0	; 160
    3a40:	1a 40       	sbci	r17, 0x0A	; 10
    3a42:	61 f4       	brne	.+24     	; 0x3a5c <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3a44:	86 ed       	ldi	r24, 0xD6	; 214
    3a46:	91 e3       	ldi	r25, 0x31	; 49
    3a48:	8f 8b       	std	Y+23, r24	; 0x17
    3a4a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3a4c:	8c ec       	ldi	r24, 0xCC	; 204
    3a4e:	91 e3       	ldi	r25, 0x31	; 49
    3a50:	89 8f       	std	Y+25, r24	; 0x19
    3a52:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3a54:	82 ec       	ldi	r24, 0xC2	; 194
    3a56:	91 e3       	ldi	r25, 0x31	; 49
    3a58:	8b 8f       	std	Y+27, r24	; 0x1b
    3a5a:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3a5c:	0f 89       	ldd	r16, Y+23	; 0x17
    3a5e:	18 8d       	ldd	r17, Y+24	; 0x18
    3a60:	84 e6       	ldi	r24, 0x64	; 100
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	0e 94 3b 1a 	call	0x3476	; 0x3476 <_Znaj>
    3a68:	f8 01       	movw	r30, r16
    3a6a:	80 83       	st	Z, r24
    3a6c:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3a6e:	e9 8d       	ldd	r30, Y+25	; 0x19
    3a70:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3a72:	10 82       	st	Z, r1
    3a74:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3a76:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3a78:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3a7a:	10 82       	st	Z, r1
    3a7c:	11 82       	std	Z+1, r1	; 0x01
}
    3a7e:	df 91       	pop	r29
    3a80:	cf 91       	pop	r28
    3a82:	1f 91       	pop	r17
    3a84:	0f 91       	pop	r16
    3a86:	ff 90       	pop	r15
    3a88:	ef 90       	pop	r14
    3a8a:	08 95       	ret

00003a8c <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3a8c:	1f 92       	push	r1
    3a8e:	0f 92       	push	r0
    3a90:	0f b6       	in	r0, 0x3f	; 63
    3a92:	0f 92       	push	r0
    3a94:	11 24       	eor	r1, r1
    3a96:	08 b6       	in	r0, 0x38	; 56
    3a98:	0f 92       	push	r0
    3a9a:	18 be       	out	0x38, r1	; 56
    3a9c:	0b b6       	in	r0, 0x3b	; 59
    3a9e:	0f 92       	push	r0
    3aa0:	1b be       	out	0x3b, r1	; 59
    3aa2:	2f 93       	push	r18
    3aa4:	3f 93       	push	r19
    3aa6:	8f 93       	push	r24
    3aa8:	9f 93       	push	r25
    3aaa:	ef 93       	push	r30
    3aac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3aae:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3ab2:	e0 91 de 31 	lds	r30, 0x31DE	; 0x8031de <rcvC0_buffer>
    3ab6:	f0 91 df 31 	lds	r31, 0x31DF	; 0x8031df <rcvC0_buffer+0x1>
    3aba:	80 91 ca 31 	lds	r24, 0x31CA	; 0x8031ca <rcvC0_write_index>
    3abe:	90 91 cb 31 	lds	r25, 0x31CB	; 0x8031cb <rcvC0_write_index+0x1>
    3ac2:	e8 0f       	add	r30, r24
    3ac4:	f9 1f       	adc	r31, r25
    3ac6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3ac8:	80 91 ca 31 	lds	r24, 0x31CA	; 0x8031ca <rcvC0_write_index>
    3acc:	90 91 cb 31 	lds	r25, 0x31CB	; 0x8031cb <rcvC0_write_index+0x1>
    3ad0:	01 96       	adiw	r24, 0x01	; 1
    3ad2:	84 36       	cpi	r24, 0x64	; 100
    3ad4:	91 05       	cpc	r25, r1
    3ad6:	60 f4       	brcc	.+24     	; 0x3af0 <__vector_25+0x64>
    3ad8:	80 93 ca 31 	sts	0x31CA, r24	; 0x8031ca <rcvC0_write_index>
    3adc:	90 93 cb 31 	sts	0x31CB, r25	; 0x8031cb <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3ae0:	20 91 d4 31 	lds	r18, 0x31D4	; 0x8031d4 <rcvC0_read_index>
    3ae4:	30 91 d5 31 	lds	r19, 0x31D5	; 0x8031d5 <rcvC0_read_index+0x1>
    3ae8:	82 17       	cp	r24, r18
    3aea:	93 07       	cpc	r25, r19
    3aec:	f1 f4       	brne	.+60     	; 0x3b2a <__vector_25+0x9e>
    3aee:	0c c0       	rjmp	.+24     	; 0x3b08 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3af0:	10 92 ca 31 	sts	0x31CA, r1	; 0x8031ca <rcvC0_write_index>
    3af4:	10 92 cb 31 	sts	0x31CB, r1	; 0x8031cb <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3af8:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <rcvC0_read_index>
    3afc:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <rcvC0_read_index+0x1>
    3b00:	18 16       	cp	r1, r24
    3b02:	19 06       	cpc	r1, r25
    3b04:	91 f4       	brne	.+36     	; 0x3b2a <__vector_25+0x9e>
    3b06:	0e c0       	rjmp	.+28     	; 0x3b24 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3b08:	01 96       	adiw	r24, 0x01	; 1
    3b0a:	84 36       	cpi	r24, 0x64	; 100
    3b0c:	91 05       	cpc	r25, r1
    3b0e:	28 f4       	brcc	.+10     	; 0x3b1a <__vector_25+0x8e>
    3b10:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <rcvC0_read_index>
    3b14:	90 93 d5 31 	sts	0x31D5, r25	; 0x8031d5 <rcvC0_read_index+0x1>
    3b18:	08 c0       	rjmp	.+16     	; 0x3b2a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3b1a:	10 92 d4 31 	sts	0x31D4, r1	; 0x8031d4 <rcvC0_read_index>
    3b1e:	10 92 d5 31 	sts	0x31D5, r1	; 0x8031d5 <rcvC0_read_index+0x1>
}
    3b22:	03 c0       	rjmp	.+6      	; 0x3b2a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3b24:	81 e0       	ldi	r24, 0x01	; 1
    3b26:	90 e0       	ldi	r25, 0x00	; 0
    3b28:	f3 cf       	rjmp	.-26     	; 0x3b10 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3b2a:	ff 91       	pop	r31
    3b2c:	ef 91       	pop	r30
    3b2e:	9f 91       	pop	r25
    3b30:	8f 91       	pop	r24
    3b32:	3f 91       	pop	r19
    3b34:	2f 91       	pop	r18
    3b36:	0f 90       	pop	r0
    3b38:	0b be       	out	0x3b, r0	; 59
    3b3a:	0f 90       	pop	r0
    3b3c:	08 be       	out	0x38, r0	; 56
    3b3e:	0f 90       	pop	r0
    3b40:	0f be       	out	0x3f, r0	; 63
    3b42:	0f 90       	pop	r0
    3b44:	1f 90       	pop	r1
    3b46:	18 95       	reti

00003b48 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3b48:	1f 92       	push	r1
    3b4a:	0f 92       	push	r0
    3b4c:	0f b6       	in	r0, 0x3f	; 63
    3b4e:	0f 92       	push	r0
    3b50:	11 24       	eor	r1, r1
    3b52:	08 b6       	in	r0, 0x38	; 56
    3b54:	0f 92       	push	r0
    3b56:	18 be       	out	0x38, r1	; 56
    3b58:	0b b6       	in	r0, 0x3b	; 59
    3b5a:	0f 92       	push	r0
    3b5c:	1b be       	out	0x3b, r1	; 59
    3b5e:	2f 93       	push	r18
    3b60:	3f 93       	push	r19
    3b62:	8f 93       	push	r24
    3b64:	9f 93       	push	r25
    3b66:	ef 93       	push	r30
    3b68:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3b6a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3b6e:	e0 91 dc 31 	lds	r30, 0x31DC	; 0x8031dc <rcvC1_buffer>
    3b72:	f0 91 dd 31 	lds	r31, 0x31DD	; 0x8031dd <rcvC1_buffer+0x1>
    3b76:	80 91 c8 31 	lds	r24, 0x31C8	; 0x8031c8 <rcvC1_write_index>
    3b7a:	90 91 c9 31 	lds	r25, 0x31C9	; 0x8031c9 <rcvC1_write_index+0x1>
    3b7e:	e8 0f       	add	r30, r24
    3b80:	f9 1f       	adc	r31, r25
    3b82:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3b84:	80 91 c8 31 	lds	r24, 0x31C8	; 0x8031c8 <rcvC1_write_index>
    3b88:	90 91 c9 31 	lds	r25, 0x31C9	; 0x8031c9 <rcvC1_write_index+0x1>
    3b8c:	01 96       	adiw	r24, 0x01	; 1
    3b8e:	84 36       	cpi	r24, 0x64	; 100
    3b90:	91 05       	cpc	r25, r1
    3b92:	60 f4       	brcc	.+24     	; 0x3bac <__vector_28+0x64>
    3b94:	80 93 c8 31 	sts	0x31C8, r24	; 0x8031c8 <rcvC1_write_index>
    3b98:	90 93 c9 31 	sts	0x31C9, r25	; 0x8031c9 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3b9c:	20 91 d2 31 	lds	r18, 0x31D2	; 0x8031d2 <rcvC1_read_index>
    3ba0:	30 91 d3 31 	lds	r19, 0x31D3	; 0x8031d3 <rcvC1_read_index+0x1>
    3ba4:	82 17       	cp	r24, r18
    3ba6:	93 07       	cpc	r25, r19
    3ba8:	f1 f4       	brne	.+60     	; 0x3be6 <__vector_28+0x9e>
    3baa:	0c c0       	rjmp	.+24     	; 0x3bc4 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3bac:	10 92 c8 31 	sts	0x31C8, r1	; 0x8031c8 <rcvC1_write_index>
    3bb0:	10 92 c9 31 	sts	0x31C9, r1	; 0x8031c9 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3bb4:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <rcvC1_read_index>
    3bb8:	90 91 d3 31 	lds	r25, 0x31D3	; 0x8031d3 <rcvC1_read_index+0x1>
    3bbc:	18 16       	cp	r1, r24
    3bbe:	19 06       	cpc	r1, r25
    3bc0:	91 f4       	brne	.+36     	; 0x3be6 <__vector_28+0x9e>
    3bc2:	0e c0       	rjmp	.+28     	; 0x3be0 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3bc4:	01 96       	adiw	r24, 0x01	; 1
    3bc6:	84 36       	cpi	r24, 0x64	; 100
    3bc8:	91 05       	cpc	r25, r1
    3bca:	28 f4       	brcc	.+10     	; 0x3bd6 <__vector_28+0x8e>
    3bcc:	80 93 d2 31 	sts	0x31D2, r24	; 0x8031d2 <rcvC1_read_index>
    3bd0:	90 93 d3 31 	sts	0x31D3, r25	; 0x8031d3 <rcvC1_read_index+0x1>
    3bd4:	08 c0       	rjmp	.+16     	; 0x3be6 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3bd6:	10 92 d2 31 	sts	0x31D2, r1	; 0x8031d2 <rcvC1_read_index>
    3bda:	10 92 d3 31 	sts	0x31D3, r1	; 0x8031d3 <rcvC1_read_index+0x1>
}
    3bde:	03 c0       	rjmp	.+6      	; 0x3be6 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3be0:	81 e0       	ldi	r24, 0x01	; 1
    3be2:	90 e0       	ldi	r25, 0x00	; 0
    3be4:	f3 cf       	rjmp	.-26     	; 0x3bcc <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3be6:	ff 91       	pop	r31
    3be8:	ef 91       	pop	r30
    3bea:	9f 91       	pop	r25
    3bec:	8f 91       	pop	r24
    3bee:	3f 91       	pop	r19
    3bf0:	2f 91       	pop	r18
    3bf2:	0f 90       	pop	r0
    3bf4:	0b be       	out	0x3b, r0	; 59
    3bf6:	0f 90       	pop	r0
    3bf8:	08 be       	out	0x38, r0	; 56
    3bfa:	0f 90       	pop	r0
    3bfc:	0f be       	out	0x3f, r0	; 63
    3bfe:	0f 90       	pop	r0
    3c00:	1f 90       	pop	r1
    3c02:	18 95       	reti

00003c04 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3c04:	1f 92       	push	r1
    3c06:	0f 92       	push	r0
    3c08:	0f b6       	in	r0, 0x3f	; 63
    3c0a:	0f 92       	push	r0
    3c0c:	11 24       	eor	r1, r1
    3c0e:	08 b6       	in	r0, 0x38	; 56
    3c10:	0f 92       	push	r0
    3c12:	18 be       	out	0x38, r1	; 56
    3c14:	0b b6       	in	r0, 0x3b	; 59
    3c16:	0f 92       	push	r0
    3c18:	1b be       	out	0x3b, r1	; 59
    3c1a:	2f 93       	push	r18
    3c1c:	3f 93       	push	r19
    3c1e:	8f 93       	push	r24
    3c20:	9f 93       	push	r25
    3c22:	ef 93       	push	r30
    3c24:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3c26:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3c2a:	e0 91 da 31 	lds	r30, 0x31DA	; 0x8031da <rcvD0_buffer>
    3c2e:	f0 91 db 31 	lds	r31, 0x31DB	; 0x8031db <rcvD0_buffer+0x1>
    3c32:	80 91 ca 31 	lds	r24, 0x31CA	; 0x8031ca <rcvC0_write_index>
    3c36:	90 91 cb 31 	lds	r25, 0x31CB	; 0x8031cb <rcvC0_write_index+0x1>
    3c3a:	e8 0f       	add	r30, r24
    3c3c:	f9 1f       	adc	r31, r25
    3c3e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3c40:	80 91 c6 31 	lds	r24, 0x31C6	; 0x8031c6 <rcvD0_write_index>
    3c44:	90 91 c7 31 	lds	r25, 0x31C7	; 0x8031c7 <rcvD0_write_index+0x1>
    3c48:	01 96       	adiw	r24, 0x01	; 1
    3c4a:	84 36       	cpi	r24, 0x64	; 100
    3c4c:	91 05       	cpc	r25, r1
    3c4e:	60 f4       	brcc	.+24     	; 0x3c68 <__vector_88+0x64>
    3c50:	80 93 c6 31 	sts	0x31C6, r24	; 0x8031c6 <rcvD0_write_index>
    3c54:	90 93 c7 31 	sts	0x31C7, r25	; 0x8031c7 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3c58:	20 91 d0 31 	lds	r18, 0x31D0	; 0x8031d0 <rcvD0_read_index>
    3c5c:	30 91 d1 31 	lds	r19, 0x31D1	; 0x8031d1 <rcvD0_read_index+0x1>
    3c60:	82 17       	cp	r24, r18
    3c62:	93 07       	cpc	r25, r19
    3c64:	f1 f4       	brne	.+60     	; 0x3ca2 <__vector_88+0x9e>
    3c66:	0c c0       	rjmp	.+24     	; 0x3c80 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3c68:	10 92 c6 31 	sts	0x31C6, r1	; 0x8031c6 <rcvD0_write_index>
    3c6c:	10 92 c7 31 	sts	0x31C7, r1	; 0x8031c7 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3c70:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <rcvD0_read_index>
    3c74:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <rcvD0_read_index+0x1>
    3c78:	18 16       	cp	r1, r24
    3c7a:	19 06       	cpc	r1, r25
    3c7c:	91 f4       	brne	.+36     	; 0x3ca2 <__vector_88+0x9e>
    3c7e:	0e c0       	rjmp	.+28     	; 0x3c9c <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3c80:	01 96       	adiw	r24, 0x01	; 1
    3c82:	84 36       	cpi	r24, 0x64	; 100
    3c84:	91 05       	cpc	r25, r1
    3c86:	28 f4       	brcc	.+10     	; 0x3c92 <__vector_88+0x8e>
    3c88:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <rcvD0_read_index>
    3c8c:	90 93 d1 31 	sts	0x31D1, r25	; 0x8031d1 <rcvD0_read_index+0x1>
    3c90:	08 c0       	rjmp	.+16     	; 0x3ca2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3c92:	10 92 d0 31 	sts	0x31D0, r1	; 0x8031d0 <rcvD0_read_index>
    3c96:	10 92 d1 31 	sts	0x31D1, r1	; 0x8031d1 <rcvD0_read_index+0x1>
}
    3c9a:	03 c0       	rjmp	.+6      	; 0x3ca2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3c9c:	81 e0       	ldi	r24, 0x01	; 1
    3c9e:	90 e0       	ldi	r25, 0x00	; 0
    3ca0:	f3 cf       	rjmp	.-26     	; 0x3c88 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3ca2:	ff 91       	pop	r31
    3ca4:	ef 91       	pop	r30
    3ca6:	9f 91       	pop	r25
    3ca8:	8f 91       	pop	r24
    3caa:	3f 91       	pop	r19
    3cac:	2f 91       	pop	r18
    3cae:	0f 90       	pop	r0
    3cb0:	0b be       	out	0x3b, r0	; 59
    3cb2:	0f 90       	pop	r0
    3cb4:	08 be       	out	0x38, r0	; 56
    3cb6:	0f 90       	pop	r0
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	0f 90       	pop	r0
    3cbc:	1f 90       	pop	r1
    3cbe:	18 95       	reti

00003cc0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3cc0:	1f 92       	push	r1
    3cc2:	0f 92       	push	r0
    3cc4:	0f b6       	in	r0, 0x3f	; 63
    3cc6:	0f 92       	push	r0
    3cc8:	11 24       	eor	r1, r1
    3cca:	08 b6       	in	r0, 0x38	; 56
    3ccc:	0f 92       	push	r0
    3cce:	18 be       	out	0x38, r1	; 56
    3cd0:	0b b6       	in	r0, 0x3b	; 59
    3cd2:	0f 92       	push	r0
    3cd4:	1b be       	out	0x3b, r1	; 59
    3cd6:	2f 93       	push	r18
    3cd8:	3f 93       	push	r19
    3cda:	8f 93       	push	r24
    3cdc:	9f 93       	push	r25
    3cde:	ef 93       	push	r30
    3ce0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3ce2:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3ce6:	e0 91 d8 31 	lds	r30, 0x31D8	; 0x8031d8 <rcvD1_buffer>
    3cea:	f0 91 d9 31 	lds	r31, 0x31D9	; 0x8031d9 <rcvD1_buffer+0x1>
    3cee:	80 91 c4 31 	lds	r24, 0x31C4	; 0x8031c4 <rcvD1_write_index>
    3cf2:	90 91 c5 31 	lds	r25, 0x31C5	; 0x8031c5 <rcvD1_write_index+0x1>
    3cf6:	e8 0f       	add	r30, r24
    3cf8:	f9 1f       	adc	r31, r25
    3cfa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3cfc:	80 91 c4 31 	lds	r24, 0x31C4	; 0x8031c4 <rcvD1_write_index>
    3d00:	90 91 c5 31 	lds	r25, 0x31C5	; 0x8031c5 <rcvD1_write_index+0x1>
    3d04:	01 96       	adiw	r24, 0x01	; 1
    3d06:	84 36       	cpi	r24, 0x64	; 100
    3d08:	91 05       	cpc	r25, r1
    3d0a:	60 f4       	brcc	.+24     	; 0x3d24 <__vector_91+0x64>
    3d0c:	80 93 c4 31 	sts	0x31C4, r24	; 0x8031c4 <rcvD1_write_index>
    3d10:	90 93 c5 31 	sts	0x31C5, r25	; 0x8031c5 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3d14:	20 91 ce 31 	lds	r18, 0x31CE	; 0x8031ce <rcvD1_read_index>
    3d18:	30 91 cf 31 	lds	r19, 0x31CF	; 0x8031cf <rcvD1_read_index+0x1>
    3d1c:	82 17       	cp	r24, r18
    3d1e:	93 07       	cpc	r25, r19
    3d20:	f1 f4       	brne	.+60     	; 0x3d5e <__vector_91+0x9e>
    3d22:	0c c0       	rjmp	.+24     	; 0x3d3c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3d24:	10 92 c4 31 	sts	0x31C4, r1	; 0x8031c4 <rcvD1_write_index>
    3d28:	10 92 c5 31 	sts	0x31C5, r1	; 0x8031c5 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3d2c:	80 91 ce 31 	lds	r24, 0x31CE	; 0x8031ce <rcvD1_read_index>
    3d30:	90 91 cf 31 	lds	r25, 0x31CF	; 0x8031cf <rcvD1_read_index+0x1>
    3d34:	18 16       	cp	r1, r24
    3d36:	19 06       	cpc	r1, r25
    3d38:	91 f4       	brne	.+36     	; 0x3d5e <__vector_91+0x9e>
    3d3a:	0e c0       	rjmp	.+28     	; 0x3d58 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3d3c:	01 96       	adiw	r24, 0x01	; 1
    3d3e:	84 36       	cpi	r24, 0x64	; 100
    3d40:	91 05       	cpc	r25, r1
    3d42:	28 f4       	brcc	.+10     	; 0x3d4e <__vector_91+0x8e>
    3d44:	80 93 ce 31 	sts	0x31CE, r24	; 0x8031ce <rcvD1_read_index>
    3d48:	90 93 cf 31 	sts	0x31CF, r25	; 0x8031cf <rcvD1_read_index+0x1>
    3d4c:	08 c0       	rjmp	.+16     	; 0x3d5e <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3d4e:	10 92 ce 31 	sts	0x31CE, r1	; 0x8031ce <rcvD1_read_index>
    3d52:	10 92 cf 31 	sts	0x31CF, r1	; 0x8031cf <rcvD1_read_index+0x1>
}
    3d56:	03 c0       	rjmp	.+6      	; 0x3d5e <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3d58:	81 e0       	ldi	r24, 0x01	; 1
    3d5a:	90 e0       	ldi	r25, 0x00	; 0
    3d5c:	f3 cf       	rjmp	.-26     	; 0x3d44 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3d5e:	ff 91       	pop	r31
    3d60:	ef 91       	pop	r30
    3d62:	9f 91       	pop	r25
    3d64:	8f 91       	pop	r24
    3d66:	3f 91       	pop	r19
    3d68:	2f 91       	pop	r18
    3d6a:	0f 90       	pop	r0
    3d6c:	0b be       	out	0x3b, r0	; 59
    3d6e:	0f 90       	pop	r0
    3d70:	08 be       	out	0x38, r0	; 56
    3d72:	0f 90       	pop	r0
    3d74:	0f be       	out	0x3f, r0	; 63
    3d76:	0f 90       	pop	r0
    3d78:	1f 90       	pop	r1
    3d7a:	18 95       	reti

00003d7c <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3d7c:	1f 92       	push	r1
    3d7e:	0f 92       	push	r0
    3d80:	0f b6       	in	r0, 0x3f	; 63
    3d82:	0f 92       	push	r0
    3d84:	11 24       	eor	r1, r1
    3d86:	08 b6       	in	r0, 0x38	; 56
    3d88:	0f 92       	push	r0
    3d8a:	18 be       	out	0x38, r1	; 56
    3d8c:	0b b6       	in	r0, 0x3b	; 59
    3d8e:	0f 92       	push	r0
    3d90:	1b be       	out	0x3b, r1	; 59
    3d92:	2f 93       	push	r18
    3d94:	3f 93       	push	r19
    3d96:	8f 93       	push	r24
    3d98:	9f 93       	push	r25
    3d9a:	ef 93       	push	r30
    3d9c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3d9e:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3da2:	e0 91 d6 31 	lds	r30, 0x31D6	; 0x8031d6 <rcvE0_buffer>
    3da6:	f0 91 d7 31 	lds	r31, 0x31D7	; 0x8031d7 <rcvE0_buffer+0x1>
    3daa:	80 91 c2 31 	lds	r24, 0x31C2	; 0x8031c2 <rcvE0_write_index>
    3dae:	90 91 c3 31 	lds	r25, 0x31C3	; 0x8031c3 <rcvE0_write_index+0x1>
    3db2:	e8 0f       	add	r30, r24
    3db4:	f9 1f       	adc	r31, r25
    3db6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3db8:	80 91 c2 31 	lds	r24, 0x31C2	; 0x8031c2 <rcvE0_write_index>
    3dbc:	90 91 c3 31 	lds	r25, 0x31C3	; 0x8031c3 <rcvE0_write_index+0x1>
    3dc0:	01 96       	adiw	r24, 0x01	; 1
    3dc2:	84 36       	cpi	r24, 0x64	; 100
    3dc4:	91 05       	cpc	r25, r1
    3dc6:	60 f4       	brcc	.+24     	; 0x3de0 <__vector_58+0x64>
    3dc8:	80 93 c2 31 	sts	0x31C2, r24	; 0x8031c2 <rcvE0_write_index>
    3dcc:	90 93 c3 31 	sts	0x31C3, r25	; 0x8031c3 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3dd0:	20 91 cc 31 	lds	r18, 0x31CC	; 0x8031cc <rcvE0_read_index>
    3dd4:	30 91 cd 31 	lds	r19, 0x31CD	; 0x8031cd <rcvE0_read_index+0x1>
    3dd8:	82 17       	cp	r24, r18
    3dda:	93 07       	cpc	r25, r19
    3ddc:	f1 f4       	brne	.+60     	; 0x3e1a <__vector_58+0x9e>
    3dde:	0c c0       	rjmp	.+24     	; 0x3df8 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3de0:	10 92 c2 31 	sts	0x31C2, r1	; 0x8031c2 <rcvE0_write_index>
    3de4:	10 92 c3 31 	sts	0x31C3, r1	; 0x8031c3 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3de8:	80 91 cc 31 	lds	r24, 0x31CC	; 0x8031cc <rcvE0_read_index>
    3dec:	90 91 cd 31 	lds	r25, 0x31CD	; 0x8031cd <rcvE0_read_index+0x1>
    3df0:	18 16       	cp	r1, r24
    3df2:	19 06       	cpc	r1, r25
    3df4:	91 f4       	brne	.+36     	; 0x3e1a <__vector_58+0x9e>
    3df6:	0e c0       	rjmp	.+28     	; 0x3e14 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3df8:	01 96       	adiw	r24, 0x01	; 1
    3dfa:	84 36       	cpi	r24, 0x64	; 100
    3dfc:	91 05       	cpc	r25, r1
    3dfe:	28 f4       	brcc	.+10     	; 0x3e0a <__vector_58+0x8e>
    3e00:	80 93 cc 31 	sts	0x31CC, r24	; 0x8031cc <rcvE0_read_index>
    3e04:	90 93 cd 31 	sts	0x31CD, r25	; 0x8031cd <rcvE0_read_index+0x1>
    3e08:	08 c0       	rjmp	.+16     	; 0x3e1a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3e0a:	10 92 cc 31 	sts	0x31CC, r1	; 0x8031cc <rcvE0_read_index>
    3e0e:	10 92 cd 31 	sts	0x31CD, r1	; 0x8031cd <rcvE0_read_index+0x1>
}
    3e12:	03 c0       	rjmp	.+6      	; 0x3e1a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3e14:	81 e0       	ldi	r24, 0x01	; 1
    3e16:	90 e0       	ldi	r25, 0x00	; 0
    3e18:	f3 cf       	rjmp	.-26     	; 0x3e00 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3e1a:	ff 91       	pop	r31
    3e1c:	ef 91       	pop	r30
    3e1e:	9f 91       	pop	r25
    3e20:	8f 91       	pop	r24
    3e22:	3f 91       	pop	r19
    3e24:	2f 91       	pop	r18
    3e26:	0f 90       	pop	r0
    3e28:	0b be       	out	0x3b, r0	; 59
    3e2a:	0f 90       	pop	r0
    3e2c:	08 be       	out	0x38, r0	; 56
    3e2e:	0f 90       	pop	r0
    3e30:	0f be       	out	0x3f, r0	; 63
    3e32:	0f 90       	pop	r0
    3e34:	1f 90       	pop	r1
    3e36:	18 95       	reti

00003e38 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3e38:	fc 01       	movw	r30, r24
    3e3a:	84 81       	ldd	r24, Z+4	; 0x04
    3e3c:	95 81       	ldd	r25, Z+5	; 0x05
    3e3e:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
		}
    3e42:	90 e0       	ldi	r25, 0x00	; 0
    3e44:	08 95       	ret

00003e46 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3e46:	fc 01       	movw	r30, r24
    3e48:	84 81       	ldd	r24, Z+4	; 0x04
    3e4a:	95 81       	ldd	r25, Z+5	; 0x05
    3e4c:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
    3e50:	91 e0       	ldi	r25, 0x01	; 1
    3e52:	81 11       	cpse	r24, r1
    3e54:	01 c0       	rjmp	.+2      	; 0x3e58 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    3e56:	90 e0       	ldi	r25, 0x00	; 0
		}
    3e58:	89 2f       	mov	r24, r25
    3e5a:	08 95       	ret

00003e5c <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3e5c:	fc 01       	movw	r30, r24
    3e5e:	84 81       	ldd	r24, Z+4	; 0x04
    3e60:	95 81       	ldd	r25, Z+5	; 0x05
    3e62:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
    3e66:	91 e0       	ldi	r25, 0x01	; 1
    3e68:	81 11       	cpse	r24, r1
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
		}
    3e6c:	89 2f       	mov	r24, r25
    3e6e:	08 95       	ret

00003e70 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3e70:	fc 01       	movw	r30, r24
    3e72:	84 81       	ldd	r24, Z+4	; 0x04
    3e74:	95 81       	ldd	r25, Z+5	; 0x05
    3e76:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
		}
    3e7a:	90 e0       	ldi	r25, 0x00	; 0
    3e7c:	08 95       	ret

00003e7e <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3e7e:	fc 01       	movw	r30, r24
    3e80:	84 81       	ldd	r24, Z+4	; 0x04
    3e82:	95 81       	ldd	r25, Z+5	; 0x05
    3e84:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
    3e88:	91 e0       	ldi	r25, 0x01	; 1
    3e8a:	81 11       	cpse	r24, r1
    3e8c:	01 c0       	rjmp	.+2      	; 0x3e90 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    3e8e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3e90:	89 2f       	mov	r24, r25
    3e92:	08 95       	ret

00003e94 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3e94:	fc 01       	movw	r30, r24
    3e96:	84 81       	ldd	r24, Z+4	; 0x04
    3e98:	95 81       	ldd	r25, Z+5	; 0x05
    3e9a:	0e 94 4e 10 	call	0x209c	; 0x209c <uxQueueMessagesWaitingFromISR>
    3e9e:	91 e0       	ldi	r25, 0x01	; 1
    3ea0:	81 11       	cpse	r24, r1
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
		}
    3ea4:	89 2f       	mov	r24, r25
    3ea6:	08 95       	ret

00003ea8 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3ea8:	fc 01       	movw	r30, r24
    3eaa:	84 81       	ldd	r24, Z+4	; 0x04
    3eac:	95 81       	ldd	r25, Z+5	; 0x05
    3eae:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
		}
    3eb2:	90 e0       	ldi	r25, 0x00	; 0
    3eb4:	08 95       	ret

00003eb6 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3eb6:	fc 01       	movw	r30, r24
    3eb8:	84 81       	ldd	r24, Z+4	; 0x04
    3eba:	95 81       	ldd	r25, Z+5	; 0x05
    3ebc:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
    3ec0:	91 e0       	ldi	r25, 0x01	; 1
    3ec2:	81 11       	cpse	r24, r1
    3ec4:	01 c0       	rjmp	.+2      	; 0x3ec8 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    3ec6:	90 e0       	ldi	r25, 0x00	; 0
		}
    3ec8:	89 2f       	mov	r24, r25
    3eca:	08 95       	ret

00003ecc <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3ecc:	fc 01       	movw	r30, r24
    3ece:	84 81       	ldd	r24, Z+4	; 0x04
    3ed0:	95 81       	ldd	r25, Z+5	; 0x05
    3ed2:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
    3ed6:	91 e0       	ldi	r25, 0x01	; 1
    3ed8:	81 11       	cpse	r24, r1
    3eda:	90 e0       	ldi	r25, 0x00	; 0
		}
    3edc:	89 2f       	mov	r24, r25
    3ede:	08 95       	ret

00003ee0 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3ee0:	fc 01       	movw	r30, r24
    3ee2:	84 81       	ldd	r24, Z+4	; 0x04
    3ee4:	95 81       	ldd	r25, Z+5	; 0x05
    3ee6:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
		}
    3eea:	90 e0       	ldi	r25, 0x00	; 0
    3eec:	08 95       	ret

00003eee <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3eee:	fc 01       	movw	r30, r24
    3ef0:	84 81       	ldd	r24, Z+4	; 0x04
    3ef2:	95 81       	ldd	r25, Z+5	; 0x05
    3ef4:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
    3ef8:	91 e0       	ldi	r25, 0x01	; 1
    3efa:	81 11       	cpse	r24, r1
    3efc:	01 c0       	rjmp	.+2      	; 0x3f00 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3efe:	90 e0       	ldi	r25, 0x00	; 0
		}
    3f00:	89 2f       	mov	r24, r25
    3f02:	08 95       	ret

00003f04 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3f04:	fc 01       	movw	r30, r24
    3f06:	84 81       	ldd	r24, Z+4	; 0x04
    3f08:	95 81       	ldd	r25, Z+5	; 0x05
    3f0a:	0e 94 46 10 	call	0x208c	; 0x208c <uxQueueMessagesWaiting>
    3f0e:	91 e0       	ldi	r25, 0x01	; 1
    3f10:	81 11       	cpse	r24, r1
    3f12:	90 e0       	ldi	r25, 0x00	; 0
		}
    3f14:	89 2f       	mov	r24, r25
    3f16:	08 95       	ret

00003f18 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3f18:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3f1a:	01 e0       	ldi	r16, 0x01	; 1
    3f1c:	2f ef       	ldi	r18, 0xFF	; 255
    3f1e:	3f ef       	ldi	r19, 0xFF	; 255
    3f20:	a9 01       	movw	r20, r18
    3f22:	fc 01       	movw	r30, r24
    3f24:	84 81       	ldd	r24, Z+4	; 0x04
    3f26:	95 81       	ldd	r25, Z+5	; 0x05
    3f28:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
}
    3f2c:	0f 91       	pop	r16
    3f2e:	08 95       	ret

00003f30 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3f30:	0f 93       	push	r16
    3f32:	cf 93       	push	r28
    3f34:	df 93       	push	r29
    3f36:	1f 92       	push	r1
    3f38:	1f 92       	push	r1
    3f3a:	cd b7       	in	r28, 0x3d	; 61
    3f3c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3f3e:	01 e0       	ldi	r16, 0x01	; 1
    3f40:	2f ef       	ldi	r18, 0xFF	; 255
    3f42:	3f ef       	ldi	r19, 0xFF	; 255
    3f44:	a9 01       	movw	r20, r18
    3f46:	be 01       	movw	r22, r28
    3f48:	6f 5f       	subi	r22, 0xFF	; 255
    3f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3f4c:	fc 01       	movw	r30, r24
    3f4e:	84 81       	ldd	r24, Z+4	; 0x04
    3f50:	95 81       	ldd	r25, Z+5	; 0x05
    3f52:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
	return (recv_item);
}
    3f56:	89 81       	ldd	r24, Y+1	; 0x01
    3f58:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5a:	0f 90       	pop	r0
    3f5c:	0f 90       	pop	r0
    3f5e:	df 91       	pop	r29
    3f60:	cf 91       	pop	r28
    3f62:	0f 91       	pop	r16
    3f64:	08 95       	ret

00003f66 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3f66:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3f68:	00 e0       	ldi	r16, 0x00	; 0
    3f6a:	2f ef       	ldi	r18, 0xFF	; 255
    3f6c:	3f ef       	ldi	r19, 0xFF	; 255
    3f6e:	a9 01       	movw	r20, r18
    3f70:	fc 01       	movw	r30, r24
    3f72:	84 81       	ldd	r24, Z+4	; 0x04
    3f74:	95 81       	ldd	r25, Z+5	; 0x05
    3f76:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
}
    3f7a:	0f 91       	pop	r16
    3f7c:	08 95       	ret

00003f7e <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3f7e:	0f 93       	push	r16
    3f80:	cf 93       	push	r28
    3f82:	df 93       	push	r29
    3f84:	1f 92       	push	r1
    3f86:	1f 92       	push	r1
    3f88:	cd b7       	in	r28, 0x3d	; 61
    3f8a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3f8c:	00 e0       	ldi	r16, 0x00	; 0
    3f8e:	2f ef       	ldi	r18, 0xFF	; 255
    3f90:	3f ef       	ldi	r19, 0xFF	; 255
    3f92:	a9 01       	movw	r20, r18
    3f94:	be 01       	movw	r22, r28
    3f96:	6f 5f       	subi	r22, 0xFF	; 255
    3f98:	7f 4f       	sbci	r23, 0xFF	; 255
    3f9a:	fc 01       	movw	r30, r24
    3f9c:	84 81       	ldd	r24, Z+4	; 0x04
    3f9e:	95 81       	ldd	r25, Z+5	; 0x05
    3fa0:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
	return (recv_item);
}
    3fa4:	89 81       	ldd	r24, Y+1	; 0x01
    3fa6:	9a 81       	ldd	r25, Y+2	; 0x02
    3fa8:	0f 90       	pop	r0
    3faa:	0f 90       	pop	r0
    3fac:	df 91       	pop	r29
    3fae:	cf 91       	pop	r28
    3fb0:	0f 91       	pop	r16
    3fb2:	08 95       	ret

00003fb4 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3fb4:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3fb6:	01 e0       	ldi	r16, 0x01	; 1
    3fb8:	2f ef       	ldi	r18, 0xFF	; 255
    3fba:	3f ef       	ldi	r19, 0xFF	; 255
    3fbc:	a9 01       	movw	r20, r18
    3fbe:	fc 01       	movw	r30, r24
    3fc0:	84 81       	ldd	r24, Z+4	; 0x04
    3fc2:	95 81       	ldd	r25, Z+5	; 0x05
    3fc4:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
}
    3fc8:	0f 91       	pop	r16
    3fca:	08 95       	ret

00003fcc <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3fcc:	0f 93       	push	r16
    3fce:	cf 93       	push	r28
    3fd0:	df 93       	push	r29
    3fd2:	1f 92       	push	r1
    3fd4:	1f 92       	push	r1
    3fd6:	cd b7       	in	r28, 0x3d	; 61
    3fd8:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3fda:	01 e0       	ldi	r16, 0x01	; 1
    3fdc:	2f ef       	ldi	r18, 0xFF	; 255
    3fde:	3f ef       	ldi	r19, 0xFF	; 255
    3fe0:	a9 01       	movw	r20, r18
    3fe2:	be 01       	movw	r22, r28
    3fe4:	6f 5f       	subi	r22, 0xFF	; 255
    3fe6:	7f 4f       	sbci	r23, 0xFF	; 255
    3fe8:	fc 01       	movw	r30, r24
    3fea:	84 81       	ldd	r24, Z+4	; 0x04
    3fec:	95 81       	ldd	r25, Z+5	; 0x05
    3fee:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
	return (recv_item);
}
    3ff2:	89 81       	ldd	r24, Y+1	; 0x01
    3ff4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff6:	0f 90       	pop	r0
    3ff8:	0f 90       	pop	r0
    3ffa:	df 91       	pop	r29
    3ffc:	cf 91       	pop	r28
    3ffe:	0f 91       	pop	r16
    4000:	08 95       	ret

00004002 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4002:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4004:	00 e0       	ldi	r16, 0x00	; 0
    4006:	2f ef       	ldi	r18, 0xFF	; 255
    4008:	3f ef       	ldi	r19, 0xFF	; 255
    400a:	a9 01       	movw	r20, r18
    400c:	fc 01       	movw	r30, r24
    400e:	84 81       	ldd	r24, Z+4	; 0x04
    4010:	95 81       	ldd	r25, Z+5	; 0x05
    4012:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
}
    4016:	0f 91       	pop	r16
    4018:	08 95       	ret

0000401a <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    401a:	0f 93       	push	r16
    401c:	cf 93       	push	r28
    401e:	df 93       	push	r29
    4020:	1f 92       	push	r1
    4022:	1f 92       	push	r1
    4024:	cd b7       	in	r28, 0x3d	; 61
    4026:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4028:	00 e0       	ldi	r16, 0x00	; 0
    402a:	2f ef       	ldi	r18, 0xFF	; 255
    402c:	3f ef       	ldi	r19, 0xFF	; 255
    402e:	a9 01       	movw	r20, r18
    4030:	be 01       	movw	r22, r28
    4032:	6f 5f       	subi	r22, 0xFF	; 255
    4034:	7f 4f       	sbci	r23, 0xFF	; 255
    4036:	fc 01       	movw	r30, r24
    4038:	84 81       	ldd	r24, Z+4	; 0x04
    403a:	95 81       	ldd	r25, Z+5	; 0x05
    403c:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericReceive>
	return (recv_item);
}
    4040:	89 81       	ldd	r24, Y+1	; 0x01
    4042:	9a 81       	ldd	r25, Y+2	; 0x02
    4044:	0f 90       	pop	r0
    4046:	0f 90       	pop	r0
    4048:	df 91       	pop	r29
    404a:	cf 91       	pop	r28
    404c:	0f 91       	pop	r16
    404e:	08 95       	ret

00004050 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4050:	cf 93       	push	r28
    4052:	df 93       	push	r29
    4054:	1f 92       	push	r1
    4056:	cd b7       	in	r28, 0x3d	; 61
    4058:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    405a:	ae 01       	movw	r20, r28
    405c:	4f 5f       	subi	r20, 0xFF	; 255
    405e:	5f 4f       	sbci	r21, 0xFF	; 255
    4060:	fc 01       	movw	r30, r24
    4062:	84 81       	ldd	r24, Z+4	; 0x04
    4064:	95 81       	ldd	r25, Z+5	; 0x05
    4066:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
}
    406a:	0f 90       	pop	r0
    406c:	df 91       	pop	r29
    406e:	cf 91       	pop	r28
    4070:	08 95       	ret

00004072 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4072:	cf 93       	push	r28
    4074:	df 93       	push	r29
    4076:	00 d0       	rcall	.+0      	; 0x4078 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4078:	cd b7       	in	r28, 0x3d	; 61
    407a:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    407c:	ae 01       	movw	r20, r28
    407e:	4d 5f       	subi	r20, 0xFD	; 253
    4080:	5f 4f       	sbci	r21, 0xFF	; 255
    4082:	be 01       	movw	r22, r28
    4084:	6f 5f       	subi	r22, 0xFF	; 255
    4086:	7f 4f       	sbci	r23, 0xFF	; 255
    4088:	fc 01       	movw	r30, r24
    408a:	84 81       	ldd	r24, Z+4	; 0x04
    408c:	95 81       	ldd	r25, Z+5	; 0x05
    408e:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
	return (recv_item);
}
    4092:	89 81       	ldd	r24, Y+1	; 0x01
    4094:	9a 81       	ldd	r25, Y+2	; 0x02
    4096:	23 96       	adiw	r28, 0x03	; 3
    4098:	cd bf       	out	0x3d, r28	; 61
    409a:	de bf       	out	0x3e, r29	; 62
    409c:	df 91       	pop	r29
    409e:	cf 91       	pop	r28
    40a0:	08 95       	ret

000040a2 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    40a2:	cf 93       	push	r28
    40a4:	df 93       	push	r29
    40a6:	1f 92       	push	r1
    40a8:	cd b7       	in	r28, 0x3d	; 61
    40aa:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    40ac:	ae 01       	movw	r20, r28
    40ae:	4f 5f       	subi	r20, 0xFF	; 255
    40b0:	5f 4f       	sbci	r21, 0xFF	; 255
    40b2:	fc 01       	movw	r30, r24
    40b4:	84 81       	ldd	r24, Z+4	; 0x04
    40b6:	95 81       	ldd	r25, Z+5	; 0x05
    40b8:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
}
    40bc:	0f 90       	pop	r0
    40be:	df 91       	pop	r29
    40c0:	cf 91       	pop	r28
    40c2:	08 95       	ret

000040c4 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    40c4:	cf 93       	push	r28
    40c6:	df 93       	push	r29
    40c8:	00 d0       	rcall	.+0      	; 0x40ca <_ZN9frt_queueIiE7ISR_getEv+0x6>
    40ca:	cd b7       	in	r28, 0x3d	; 61
    40cc:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    40ce:	ae 01       	movw	r20, r28
    40d0:	4d 5f       	subi	r20, 0xFD	; 253
    40d2:	5f 4f       	sbci	r21, 0xFF	; 255
    40d4:	be 01       	movw	r22, r28
    40d6:	6f 5f       	subi	r22, 0xFF	; 255
    40d8:	7f 4f       	sbci	r23, 0xFF	; 255
    40da:	fc 01       	movw	r30, r24
    40dc:	84 81       	ldd	r24, Z+4	; 0x04
    40de:	95 81       	ldd	r25, Z+5	; 0x05
    40e0:	0e 94 19 10 	call	0x2032	; 0x2032 <xQueueReceiveFromISR>
	return (recv_item);
}
    40e4:	89 81       	ldd	r24, Y+1	; 0x01
    40e6:	9a 81       	ldd	r25, Y+2	; 0x02
    40e8:	23 96       	adiw	r28, 0x03	; 3
    40ea:	cd bf       	out	0x3d, r28	; 61
    40ec:	de bf       	out	0x3e, r29	; 62
    40ee:	df 91       	pop	r29
    40f0:	cf 91       	pop	r28
    40f2:	08 95       	ret

000040f4 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    40f4:	cf 93       	push	r28
    40f6:	df 93       	push	r29
    40f8:	1f 92       	push	r1
    40fa:	cd b7       	in	r28, 0x3d	; 61
    40fc:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    40fe:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4100:	21 e0       	ldi	r18, 0x01	; 1
    4102:	ae 01       	movw	r20, r28
    4104:	4f 5f       	subi	r20, 0xFF	; 255
    4106:	5f 4f       	sbci	r21, 0xFF	; 255
    4108:	fc 01       	movw	r30, r24
    410a:	84 81       	ldd	r24, Z+4	; 0x04
    410c:	95 81       	ldd	r25, Z+5	; 0x05
    410e:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4112:	91 e0       	ldi	r25, 0x01	; 1
    4114:	81 11       	cpse	r24, r1
    4116:	01 c0       	rjmp	.+2      	; 0x411a <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4118:	90 e0       	ldi	r25, 0x00	; 0
}
    411a:	89 2f       	mov	r24, r25
    411c:	0f 90       	pop	r0
    411e:	df 91       	pop	r29
    4120:	cf 91       	pop	r28
    4122:	08 95       	ret

00004124 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4124:	cf 93       	push	r28
    4126:	df 93       	push	r29
    4128:	1f 92       	push	r1
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    412e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4130:	20 e0       	ldi	r18, 0x00	; 0
    4132:	ae 01       	movw	r20, r28
    4134:	4f 5f       	subi	r20, 0xFF	; 255
    4136:	5f 4f       	sbci	r21, 0xFF	; 255
    4138:	fc 01       	movw	r30, r24
    413a:	84 81       	ldd	r24, Z+4	; 0x04
    413c:	95 81       	ldd	r25, Z+5	; 0x05
    413e:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4142:	91 e0       	ldi	r25, 0x01	; 1
    4144:	81 11       	cpse	r24, r1
    4146:	01 c0       	rjmp	.+2      	; 0x414a <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4148:	90 e0       	ldi	r25, 0x00	; 0
}
    414a:	89 2f       	mov	r24, r25
    414c:	0f 90       	pop	r0
    414e:	df 91       	pop	r29
    4150:	cf 91       	pop	r28
    4152:	08 95       	ret

00004154 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4154:	cf 93       	push	r28
    4156:	df 93       	push	r29
    4158:	1f 92       	push	r1
    415a:	cd b7       	in	r28, 0x3d	; 61
    415c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    415e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4160:	21 e0       	ldi	r18, 0x01	; 1
    4162:	ae 01       	movw	r20, r28
    4164:	4f 5f       	subi	r20, 0xFF	; 255
    4166:	5f 4f       	sbci	r21, 0xFF	; 255
    4168:	fc 01       	movw	r30, r24
    416a:	84 81       	ldd	r24, Z+4	; 0x04
    416c:	95 81       	ldd	r25, Z+5	; 0x05
    416e:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4172:	91 e0       	ldi	r25, 0x01	; 1
    4174:	81 11       	cpse	r24, r1
    4176:	01 c0       	rjmp	.+2      	; 0x417a <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4178:	90 e0       	ldi	r25, 0x00	; 0
}
    417a:	89 2f       	mov	r24, r25
    417c:	0f 90       	pop	r0
    417e:	df 91       	pop	r29
    4180:	cf 91       	pop	r28
    4182:	08 95       	ret

00004184 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4184:	cf 93       	push	r28
    4186:	df 93       	push	r29
    4188:	1f 92       	push	r1
    418a:	cd b7       	in	r28, 0x3d	; 61
    418c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    418e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4190:	20 e0       	ldi	r18, 0x00	; 0
    4192:	ae 01       	movw	r20, r28
    4194:	4f 5f       	subi	r20, 0xFF	; 255
    4196:	5f 4f       	sbci	r21, 0xFF	; 255
    4198:	fc 01       	movw	r30, r24
    419a:	84 81       	ldd	r24, Z+4	; 0x04
    419c:	95 81       	ldd	r25, Z+5	; 0x05
    419e:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    41a2:	91 e0       	ldi	r25, 0x01	; 1
    41a4:	81 11       	cpse	r24, r1
    41a6:	01 c0       	rjmp	.+2      	; 0x41aa <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    41a8:	90 e0       	ldi	r25, 0x00	; 0
}
    41aa:	89 2f       	mov	r24, r25
    41ac:	0f 90       	pop	r0
    41ae:	df 91       	pop	r29
    41b0:	cf 91       	pop	r28
    41b2:	08 95       	ret

000041b4 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    41b4:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    41b6:	fc 01       	movw	r30, r24
    41b8:	26 81       	ldd	r18, Z+6	; 0x06
    41ba:	37 81       	ldd	r19, Z+7	; 0x07
    41bc:	40 85       	ldd	r20, Z+8	; 0x08
    41be:	51 85       	ldd	r21, Z+9	; 0x09
    41c0:	01 e0       	ldi	r16, 0x01	; 1
    41c2:	84 81       	ldd	r24, Z+4	; 0x04
    41c4:	95 81       	ldd	r25, Z+5	; 0x05
    41c6:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
    41ca:	91 e0       	ldi	r25, 0x01	; 1
    41cc:	81 11       	cpse	r24, r1
    41ce:	01 c0       	rjmp	.+2      	; 0x41d2 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    41d0:	90 e0       	ldi	r25, 0x00	; 0
		}
    41d2:	89 2f       	mov	r24, r25
    41d4:	0f 91       	pop	r16
    41d6:	08 95       	ret

000041d8 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    41d8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    41da:	fc 01       	movw	r30, r24
    41dc:	26 81       	ldd	r18, Z+6	; 0x06
    41de:	37 81       	ldd	r19, Z+7	; 0x07
    41e0:	40 85       	ldd	r20, Z+8	; 0x08
    41e2:	51 85       	ldd	r21, Z+9	; 0x09
    41e4:	00 e0       	ldi	r16, 0x00	; 0
    41e6:	84 81       	ldd	r24, Z+4	; 0x04
    41e8:	95 81       	ldd	r25, Z+5	; 0x05
    41ea:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
    41ee:	91 e0       	ldi	r25, 0x01	; 1
    41f0:	81 11       	cpse	r24, r1
    41f2:	01 c0       	rjmp	.+2      	; 0x41f6 <_ZN9frt_queueIjE3putERKj+0x1e>
    41f4:	90 e0       	ldi	r25, 0x00	; 0
		}
    41f6:	89 2f       	mov	r24, r25
    41f8:	0f 91       	pop	r16
    41fa:	08 95       	ret

000041fc <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    41fc:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    41fe:	fc 01       	movw	r30, r24
    4200:	26 81       	ldd	r18, Z+6	; 0x06
    4202:	37 81       	ldd	r19, Z+7	; 0x07
    4204:	40 85       	ldd	r20, Z+8	; 0x08
    4206:	51 85       	ldd	r21, Z+9	; 0x09
    4208:	01 e0       	ldi	r16, 0x01	; 1
    420a:	84 81       	ldd	r24, Z+4	; 0x04
    420c:	95 81       	ldd	r25, Z+5	; 0x05
    420e:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
    4212:	91 e0       	ldi	r25, 0x01	; 1
    4214:	81 11       	cpse	r24, r1
    4216:	01 c0       	rjmp	.+2      	; 0x421a <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4218:	90 e0       	ldi	r25, 0x00	; 0
		}
    421a:	89 2f       	mov	r24, r25
    421c:	0f 91       	pop	r16
    421e:	08 95       	ret

00004220 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4220:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4222:	fc 01       	movw	r30, r24
    4224:	26 81       	ldd	r18, Z+6	; 0x06
    4226:	37 81       	ldd	r19, Z+7	; 0x07
    4228:	40 85       	ldd	r20, Z+8	; 0x08
    422a:	51 85       	ldd	r21, Z+9	; 0x09
    422c:	00 e0       	ldi	r16, 0x00	; 0
    422e:	84 81       	ldd	r24, Z+4	; 0x04
    4230:	95 81       	ldd	r25, Z+5	; 0x05
    4232:	0e 94 8e 0e 	call	0x1d1c	; 0x1d1c <xQueueGenericSend>
    4236:	91 e0       	ldi	r25, 0x01	; 1
    4238:	81 11       	cpse	r24, r1
    423a:	01 c0       	rjmp	.+2      	; 0x423e <_ZN9frt_queueIiE3putERKi+0x1e>
    423c:	90 e0       	ldi	r25, 0x00	; 0
		}
    423e:	89 2f       	mov	r24, r25
    4240:	0f 91       	pop	r16
    4242:	08 95       	ret

00004244 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4244:	0f 93       	push	r16
    4246:	cf 93       	push	r28
    4248:	df 93       	push	r29
    424a:	1f 92       	push	r1
    424c:	cd b7       	in	r28, 0x3d	; 61
    424e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4250:	2f b7       	in	r18, 0x3f	; 63
    4252:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4254:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4256:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4258:	fc 01       	movw	r30, r24
    425a:	08 ed       	ldi	r16, 0xD8	; 216
    425c:	04 bf       	out	0x34, r16	; 52
    425e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4260:	89 81       	ldd	r24, Y+1	; 0x01
    4262:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4264:	0f 90       	pop	r0
    4266:	df 91       	pop	r29
    4268:	cf 91       	pop	r28
    426a:	0f 91       	pop	r16
    426c:	08 95       	ret

0000426e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    426e:	ef 92       	push	r14
    4270:	ff 92       	push	r15
    4272:	0f 93       	push	r16
    4274:	1f 93       	push	r17
    4276:	cf 93       	push	r28
    4278:	df 93       	push	r29
    427a:	cd b7       	in	r28, 0x3d	; 61
    427c:	de b7       	in	r29, 0x3e	; 62
    427e:	c3 54       	subi	r28, 0x43	; 67
    4280:	d1 09       	sbc	r29, r1
    4282:	cd bf       	out	0x3d, r28	; 61
    4284:	de bf       	out	0x3e, r29	; 62
	cli();
    4286:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4288:	e0 e5       	ldi	r30, 0x50	; 80
    428a:	f0 e0       	ldi	r31, 0x00	; 0
    428c:	80 81       	ld	r24, Z
    428e:	82 60       	ori	r24, 0x02	; 2
    4290:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4292:	81 81       	ldd	r24, Z+1	; 0x01
    4294:	81 ff       	sbrs	r24, 1
    4296:	fd cf       	rjmp	.-6      	; 0x4292 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4298:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    429c:	68 7f       	andi	r22, 0xF8	; 248
    429e:	61 60       	ori	r22, 0x01	; 1
    42a0:	80 e4       	ldi	r24, 0x40	; 64
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	0e 94 22 21 	call	0x4244	; 0x4244 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    42a8:	e0 e5       	ldi	r30, 0x50	; 80
    42aa:	f0 e0       	ldi	r31, 0x00	; 0
    42ac:	80 81       	ld	r24, Z
    42ae:	8e 7f       	andi	r24, 0xFE	; 254
    42b0:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    42b2:	9d ef       	ldi	r25, 0xFD	; 253
    42b4:	88 ed       	ldi	r24, 0xD8	; 216
    42b6:	08 b6       	in	r0, 0x38	; 56
    42b8:	18 be       	out	0x38, r1	; 56
    42ba:	84 bf       	out	0x34, r24	; 52
    42bc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    42c0:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    42c2:	40 ea       	ldi	r20, 0xA0	; 160
    42c4:	5a e0       	ldi	r21, 0x0A	; 10
    42c6:	60 e0       	ldi	r22, 0x00	; 0
    42c8:	70 e0       	ldi	r23, 0x00	; 0
    42ca:	ce 01       	movw	r24, r28
    42cc:	01 96       	adiw	r24, 0x01	; 1
    42ce:	0e 94 c6 1c 	call	0x398c	; 0x398c <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    42d2:	67 e0       	ldi	r22, 0x07	; 7
    42d4:	ce 01       	movw	r24, r28
    42d6:	01 96       	adiw	r24, 0x01	; 1
    42d8:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    42dc:	8c 01       	movw	r16, r24
    42de:	61 ee       	ldi	r22, 0xE1	; 225
    42e0:	70 e2       	ldi	r23, 0x20	; 32
    42e2:	0e 94 ec 1a 	call	0x35d8	; 0x35d8 <_ZN8emstream4putsEPKc>
    42e6:	66 e0       	ldi	r22, 0x06	; 6
    42e8:	c8 01       	movw	r24, r16
    42ea:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
    42ee:	66 e0       	ldi	r22, 0x06	; 6
    42f0:	0e 94 23 1b 	call	0x3646	; 0x3646 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    42f4:	20 e3       	ldi	r18, 0x30	; 48
    42f6:	32 ef       	ldi	r19, 0xF2	; 242
    42f8:	40 e0       	ldi	r20, 0x00	; 0
    42fa:	50 e0       	ldi	r21, 0x00	; 0
    42fc:	60 ea       	ldi	r22, 0xA0	; 160
    42fe:	74 e0       	ldi	r23, 0x04	; 4
    4300:	ce 01       	movw	r24, r28
    4302:	4e 96       	adiw	r24, 0x1e	; 30
    4304:	0e 94 6f 05 	call	0xade	; 0xade <_ZN9I2CMasterC1EP10TWI_structm>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c);
    4308:	be 01       	movw	r22, r28
    430a:	62 5e       	subi	r22, 0xE2	; 226
    430c:	7f 4f       	sbci	r23, 0xFF	; 255
    430e:	ce 01       	movw	r24, r28
    4310:	c5 96       	adiw	r24, 0x35	; 53
    4312:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4316:	82 e1       	ldi	r24, 0x12	; 18
    4318:	90 e0       	ldi	r25, 0x00	; 0
    431a:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
    431e:	8e 01       	movw	r16, r28
    4320:	0f 5f       	subi	r16, 0xFF	; 255
    4322:	1f 4f       	sbci	r17, 0xFF	; 255
    4324:	20 e8       	ldi	r18, 0x80	; 128
    4326:	30 e0       	ldi	r19, 0x00	; 0
    4328:	40 e0       	ldi	r20, 0x00	; 0
    432a:	60 e0       	ldi	r22, 0x00	; 0
    432c:	71 e2       	ldi	r23, 0x21	; 33
    432e:	0e 94 0a 08 	call	0x1014	; 0x1014 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    4332:	88 e1       	ldi	r24, 0x18	; 24
    4334:	90 e0       	ldi	r25, 0x00	; 0
    4336:	0e 94 38 1a 	call	0x3470	; 0x3470 <_Znwj>
    433a:	9e 01       	movw	r18, r28
    433c:	2b 5c       	subi	r18, 0xCB	; 203
    433e:	3f 4f       	sbci	r19, 0xFF	; 255
    4340:	79 01       	movw	r14, r18
    4342:	20 e8       	ldi	r18, 0x80	; 128
    4344:	30 e0       	ldi	r19, 0x00	; 0
    4346:	42 e0       	ldi	r20, 0x02	; 2
    4348:	68 e0       	ldi	r22, 0x08	; 8
    434a:	71 e2       	ldi	r23, 0x21	; 33
    434c:	0e 94 ed 07 	call	0xfda	; 0xfda <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4350:	87 e0       	ldi	r24, 0x07	; 7
    4352:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4356:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4358:	0e 94 b7 11 	call	0x236e	; 0x236e <vTaskStartScheduler>
}
    435c:	80 e0       	ldi	r24, 0x00	; 0
    435e:	90 e0       	ldi	r25, 0x00	; 0
    4360:	cd 5b       	subi	r28, 0xBD	; 189
    4362:	df 4f       	sbci	r29, 0xFF	; 255
    4364:	cd bf       	out	0x3d, r28	; 61
    4366:	de bf       	out	0x3e, r29	; 62
    4368:	df 91       	pop	r29
    436a:	cf 91       	pop	r28
    436c:	1f 91       	pop	r17
    436e:	0f 91       	pop	r16
    4370:	ff 90       	pop	r15
    4372:	ef 90       	pop	r14
    4374:	08 95       	ret

00004376 <_GLOBAL__sub_I_counter>:
    4376:	cf 92       	push	r12
    4378:	df 92       	push	r13
    437a:	ef 92       	push	r14
    437c:	ff 92       	push	r15
    437e:	0f 93       	push	r16
    4380:	1f 93       	push	r17
    4382:	cf 93       	push	r28
    4384:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4386:	0a e0       	ldi	r16, 0x0A	; 10
    4388:	10 e0       	ldi	r17, 0x00	; 0
    438a:	20 e0       	ldi	r18, 0x00	; 0
    438c:	30 e0       	ldi	r19, 0x00	; 0
    438e:	40 e0       	ldi	r20, 0x00	; 0
    4390:	50 e0       	ldi	r21, 0x00	; 0
    4392:	60 e2       	ldi	r22, 0x20	; 32
    4394:	70 e0       	ldi	r23, 0x00	; 0
    4396:	82 e1       	ldi	r24, 0x12	; 18
    4398:	92 e3       	ldi	r25, 0x32	; 50
    439a:	0e 94 a4 18 	call	0x3148	; 0x3148 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    439e:	c8 e0       	ldi	r28, 0x08	; 8
    43a0:	d2 e3       	ldi	r29, 0x32	; 50
    43a2:	1a 82       	std	Y+2, r1	; 0x02
    43a4:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    43a6:	82 e1       	ldi	r24, 0x12	; 18
    43a8:	91 e2       	ldi	r25, 0x21	; 33
    43aa:	88 83       	st	Y, r24
    43ac:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    43ae:	40 e0       	ldi	r20, 0x00	; 0
    43b0:	62 e0       	ldi	r22, 0x02	; 2
    43b2:	8f ef       	ldi	r24, 0xFF	; 255
    43b4:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    43b8:	8c 83       	std	Y+4, r24	; 0x04
    43ba:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    43bc:	0f 2e       	mov	r0, r31
    43be:	fa e0       	ldi	r31, 0x0A	; 10
    43c0:	cf 2e       	mov	r12, r31
    43c2:	d1 2c       	mov	r13, r1
    43c4:	e1 2c       	mov	r14, r1
    43c6:	f1 2c       	mov	r15, r1
    43c8:	f0 2d       	mov	r31, r0
    43ca:	ce 82       	std	Y+6, r12	; 0x06
    43cc:	df 82       	std	Y+7, r13	; 0x07
    43ce:	e8 86       	std	Y+8, r14	; 0x08
    43d0:	f9 86       	std	Y+9, r15	; 0x09
    43d2:	ce ef       	ldi	r28, 0xFE	; 254
    43d4:	d1 e3       	ldi	r29, 0x31	; 49
    43d6:	1a 82       	std	Y+2, r1	; 0x02
    43d8:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    43da:	06 e3       	ldi	r16, 0x36	; 54
    43dc:	11 e2       	ldi	r17, 0x21	; 33
    43de:	08 83       	st	Y, r16
    43e0:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    43e2:	40 e0       	ldi	r20, 0x00	; 0
    43e4:	62 e0       	ldi	r22, 0x02	; 2
    43e6:	8f ef       	ldi	r24, 0xFF	; 255
    43e8:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    43ec:	8c 83       	std	Y+4, r24	; 0x04
    43ee:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    43f0:	ce 82       	std	Y+6, r12	; 0x06
    43f2:	df 82       	std	Y+7, r13	; 0x07
    43f4:	e8 86       	std	Y+8, r14	; 0x08
    43f6:	f9 86       	std	Y+9, r15	; 0x09
    43f8:	c4 ef       	ldi	r28, 0xF4	; 244
    43fa:	d1 e3       	ldi	r29, 0x31	; 49
    43fc:	1a 82       	std	Y+2, r1	; 0x02
    43fe:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4400:	08 83       	st	Y, r16
    4402:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4404:	40 e0       	ldi	r20, 0x00	; 0
    4406:	62 e0       	ldi	r22, 0x02	; 2
    4408:	8f ef       	ldi	r24, 0xFF	; 255
    440a:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    440e:	8c 83       	std	Y+4, r24	; 0x04
    4410:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4412:	ce 82       	std	Y+6, r12	; 0x06
    4414:	df 82       	std	Y+7, r13	; 0x07
    4416:	e8 86       	std	Y+8, r14	; 0x08
    4418:	f9 86       	std	Y+9, r15	; 0x09
    441a:	ca ee       	ldi	r28, 0xEA	; 234
    441c:	d1 e3       	ldi	r29, 0x31	; 49
    441e:	1a 82       	std	Y+2, r1	; 0x02
    4420:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4422:	08 83       	st	Y, r16
    4424:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4426:	40 e0       	ldi	r20, 0x00	; 0
    4428:	62 e0       	ldi	r22, 0x02	; 2
    442a:	8f ef       	ldi	r24, 0xFF	; 255
    442c:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    4430:	8c 83       	std	Y+4, r24	; 0x04
    4432:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4434:	ce 82       	std	Y+6, r12	; 0x06
    4436:	df 82       	std	Y+7, r13	; 0x07
    4438:	e8 86       	std	Y+8, r14	; 0x08
    443a:	f9 86       	std	Y+9, r15	; 0x09
    443c:	c0 ee       	ldi	r28, 0xE0	; 224
    443e:	d1 e3       	ldi	r29, 0x31	; 49
    4440:	1a 82       	std	Y+2, r1	; 0x02
    4442:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4444:	08 83       	st	Y, r16
    4446:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4448:	40 e0       	ldi	r20, 0x00	; 0
    444a:	62 e0       	ldi	r22, 0x02	; 2
    444c:	8f ef       	ldi	r24, 0xFF	; 255
    444e:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xQueueGenericCreate>
    4452:	8c 83       	std	Y+4, r24	; 0x04
    4454:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4456:	ce 82       	std	Y+6, r12	; 0x06
    4458:	df 82       	std	Y+7, r13	; 0x07
    445a:	e8 86       	std	Y+8, r14	; 0x08
    445c:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    445e:	df 91       	pop	r29
    4460:	cf 91       	pop	r28
    4462:	1f 91       	pop	r17
    4464:	0f 91       	pop	r16
    4466:	ff 90       	pop	r15
    4468:	ef 90       	pop	r14
    446a:	df 90       	pop	r13
    446c:	cf 90       	pop	r12
    446e:	08 95       	ret

00004470 <__mulsi3>:
    4470:	db 01       	movw	r26, r22
    4472:	8f 93       	push	r24
    4474:	9f 93       	push	r25
    4476:	0e 94 92 22 	call	0x4524	; 0x4524 <__muluhisi3>
    447a:	bf 91       	pop	r27
    447c:	af 91       	pop	r26
    447e:	a2 9f       	mul	r26, r18
    4480:	80 0d       	add	r24, r0
    4482:	91 1d       	adc	r25, r1
    4484:	a3 9f       	mul	r26, r19
    4486:	90 0d       	add	r25, r0
    4488:	b2 9f       	mul	r27, r18
    448a:	90 0d       	add	r25, r0
    448c:	11 24       	eor	r1, r1
    448e:	08 95       	ret

00004490 <__udivmodsi4>:
    4490:	a1 e2       	ldi	r26, 0x21	; 33
    4492:	1a 2e       	mov	r1, r26
    4494:	aa 1b       	sub	r26, r26
    4496:	bb 1b       	sub	r27, r27
    4498:	fd 01       	movw	r30, r26
    449a:	0d c0       	rjmp	.+26     	; 0x44b6 <__udivmodsi4_ep>

0000449c <__udivmodsi4_loop>:
    449c:	aa 1f       	adc	r26, r26
    449e:	bb 1f       	adc	r27, r27
    44a0:	ee 1f       	adc	r30, r30
    44a2:	ff 1f       	adc	r31, r31
    44a4:	a2 17       	cp	r26, r18
    44a6:	b3 07       	cpc	r27, r19
    44a8:	e4 07       	cpc	r30, r20
    44aa:	f5 07       	cpc	r31, r21
    44ac:	20 f0       	brcs	.+8      	; 0x44b6 <__udivmodsi4_ep>
    44ae:	a2 1b       	sub	r26, r18
    44b0:	b3 0b       	sbc	r27, r19
    44b2:	e4 0b       	sbc	r30, r20
    44b4:	f5 0b       	sbc	r31, r21

000044b6 <__udivmodsi4_ep>:
    44b6:	66 1f       	adc	r22, r22
    44b8:	77 1f       	adc	r23, r23
    44ba:	88 1f       	adc	r24, r24
    44bc:	99 1f       	adc	r25, r25
    44be:	1a 94       	dec	r1
    44c0:	69 f7       	brne	.-38     	; 0x449c <__udivmodsi4_loop>
    44c2:	60 95       	com	r22
    44c4:	70 95       	com	r23
    44c6:	80 95       	com	r24
    44c8:	90 95       	com	r25
    44ca:	9b 01       	movw	r18, r22
    44cc:	ac 01       	movw	r20, r24
    44ce:	bd 01       	movw	r22, r26
    44d0:	cf 01       	movw	r24, r30
    44d2:	08 95       	ret

000044d4 <__divmodsi4>:
    44d4:	05 2e       	mov	r0, r21
    44d6:	97 fb       	bst	r25, 7
    44d8:	1e f4       	brtc	.+6      	; 0x44e0 <__divmodsi4+0xc>
    44da:	00 94       	com	r0
    44dc:	0e 94 81 22 	call	0x4502	; 0x4502 <__negsi2>
    44e0:	57 fd       	sbrc	r21, 7
    44e2:	07 d0       	rcall	.+14     	; 0x44f2 <__divmodsi4_neg2>
    44e4:	0e 94 48 22 	call	0x4490	; 0x4490 <__udivmodsi4>
    44e8:	07 fc       	sbrc	r0, 7
    44ea:	03 d0       	rcall	.+6      	; 0x44f2 <__divmodsi4_neg2>
    44ec:	4e f4       	brtc	.+18     	; 0x4500 <__divmodsi4_exit>
    44ee:	0c 94 81 22 	jmp	0x4502	; 0x4502 <__negsi2>

000044f2 <__divmodsi4_neg2>:
    44f2:	50 95       	com	r21
    44f4:	40 95       	com	r20
    44f6:	30 95       	com	r19
    44f8:	21 95       	neg	r18
    44fa:	3f 4f       	sbci	r19, 0xFF	; 255
    44fc:	4f 4f       	sbci	r20, 0xFF	; 255
    44fe:	5f 4f       	sbci	r21, 0xFF	; 255

00004500 <__divmodsi4_exit>:
    4500:	08 95       	ret

00004502 <__negsi2>:
    4502:	90 95       	com	r25
    4504:	80 95       	com	r24
    4506:	70 95       	com	r23
    4508:	61 95       	neg	r22
    450a:	7f 4f       	sbci	r23, 0xFF	; 255
    450c:	8f 4f       	sbci	r24, 0xFF	; 255
    450e:	9f 4f       	sbci	r25, 0xFF	; 255
    4510:	08 95       	ret

00004512 <__tablejump2__>:
    4512:	ee 0f       	add	r30, r30
    4514:	ff 1f       	adc	r31, r31
    4516:	88 1f       	adc	r24, r24
    4518:	8b bf       	out	0x3b, r24	; 59
    451a:	07 90       	elpm	r0, Z+
    451c:	f6 91       	elpm	r31, Z
    451e:	e0 2d       	mov	r30, r0
    4520:	1b be       	out	0x3b, r1	; 59
    4522:	19 94       	eijmp

00004524 <__muluhisi3>:
    4524:	0e 94 9d 22 	call	0x453a	; 0x453a <__umulhisi3>
    4528:	a5 9f       	mul	r26, r21
    452a:	90 0d       	add	r25, r0
    452c:	b4 9f       	mul	r27, r20
    452e:	90 0d       	add	r25, r0
    4530:	a4 9f       	mul	r26, r20
    4532:	80 0d       	add	r24, r0
    4534:	91 1d       	adc	r25, r1
    4536:	11 24       	eor	r1, r1
    4538:	08 95       	ret

0000453a <__umulhisi3>:
    453a:	a2 9f       	mul	r26, r18
    453c:	b0 01       	movw	r22, r0
    453e:	b3 9f       	mul	r27, r19
    4540:	c0 01       	movw	r24, r0
    4542:	a3 9f       	mul	r26, r19
    4544:	70 0d       	add	r23, r0
    4546:	81 1d       	adc	r24, r1
    4548:	11 24       	eor	r1, r1
    454a:	91 1d       	adc	r25, r1
    454c:	b2 9f       	mul	r27, r18
    454e:	70 0d       	add	r23, r0
    4550:	81 1d       	adc	r24, r1
    4552:	11 24       	eor	r1, r1
    4554:	91 1d       	adc	r25, r1
    4556:	08 95       	ret

00004558 <memcpy>:
    4558:	fb 01       	movw	r30, r22
    455a:	dc 01       	movw	r26, r24
    455c:	02 c0       	rjmp	.+4      	; 0x4562 <memcpy+0xa>
    455e:	01 90       	ld	r0, Z+
    4560:	0d 92       	st	X+, r0
    4562:	41 50       	subi	r20, 0x01	; 1
    4564:	50 40       	sbci	r21, 0x00	; 0
    4566:	d8 f7       	brcc	.-10     	; 0x455e <memcpy+0x6>
    4568:	08 95       	ret

0000456a <memset>:
    456a:	dc 01       	movw	r26, r24
    456c:	01 c0       	rjmp	.+2      	; 0x4570 <memset+0x6>
    456e:	6d 93       	st	X+, r22
    4570:	41 50       	subi	r20, 0x01	; 1
    4572:	50 40       	sbci	r21, 0x00	; 0
    4574:	e0 f7       	brcc	.-8      	; 0x456e <memset+0x4>
    4576:	08 95       	ret

00004578 <strncpy>:
    4578:	fb 01       	movw	r30, r22
    457a:	dc 01       	movw	r26, r24
    457c:	41 50       	subi	r20, 0x01	; 1
    457e:	50 40       	sbci	r21, 0x00	; 0
    4580:	48 f0       	brcs	.+18     	; 0x4594 <strncpy+0x1c>
    4582:	01 90       	ld	r0, Z+
    4584:	0d 92       	st	X+, r0
    4586:	00 20       	and	r0, r0
    4588:	c9 f7       	brne	.-14     	; 0x457c <strncpy+0x4>
    458a:	01 c0       	rjmp	.+2      	; 0x458e <strncpy+0x16>
    458c:	1d 92       	st	X+, r1
    458e:	41 50       	subi	r20, 0x01	; 1
    4590:	50 40       	sbci	r21, 0x00	; 0
    4592:	e0 f7       	brcc	.-8      	; 0x458c <strncpy+0x14>
    4594:	08 95       	ret

00004596 <ultoa>:
    4596:	25 32       	cpi	r18, 0x25	; 37
    4598:	31 05       	cpc	r19, r1
    459a:	20 f4       	brcc	.+8      	; 0x45a4 <ultoa+0xe>
    459c:	22 30       	cpi	r18, 0x02	; 2
    459e:	10 f0       	brcs	.+4      	; 0x45a4 <ultoa+0xe>
    45a0:	0c 94 d6 22 	jmp	0x45ac	; 0x45ac <__ultoa_ncheck>
    45a4:	fa 01       	movw	r30, r20
    45a6:	10 82       	st	Z, r1
    45a8:	ca 01       	movw	r24, r20
    45aa:	08 95       	ret

000045ac <__ultoa_ncheck>:
    45ac:	bb 27       	eor	r27, r27

000045ae <__ultoa_common>:
    45ae:	fa 01       	movw	r30, r20
    45b0:	a6 2f       	mov	r26, r22
    45b2:	62 17       	cp	r22, r18
    45b4:	71 05       	cpc	r23, r1
    45b6:	81 05       	cpc	r24, r1
    45b8:	91 05       	cpc	r25, r1
    45ba:	33 0b       	sbc	r19, r19
    45bc:	30 fb       	bst	r19, 0
    45be:	66 f0       	brts	.+24     	; 0x45d8 <__ultoa_common+0x2a>
    45c0:	aa 27       	eor	r26, r26
    45c2:	66 0f       	add	r22, r22
    45c4:	77 1f       	adc	r23, r23
    45c6:	88 1f       	adc	r24, r24
    45c8:	99 1f       	adc	r25, r25
    45ca:	aa 1f       	adc	r26, r26
    45cc:	a2 17       	cp	r26, r18
    45ce:	10 f0       	brcs	.+4      	; 0x45d4 <__ultoa_common+0x26>
    45d0:	a2 1b       	sub	r26, r18
    45d2:	63 95       	inc	r22
    45d4:	38 50       	subi	r19, 0x08	; 8
    45d6:	a9 f7       	brne	.-22     	; 0x45c2 <__ultoa_common+0x14>
    45d8:	a0 5d       	subi	r26, 0xD0	; 208
    45da:	aa 33       	cpi	r26, 0x3A	; 58
    45dc:	08 f0       	brcs	.+2      	; 0x45e0 <__ultoa_common+0x32>
    45de:	a9 5d       	subi	r26, 0xD9	; 217
    45e0:	a1 93       	st	Z+, r26
    45e2:	36 f7       	brtc	.-52     	; 0x45b0 <__ultoa_common+0x2>
    45e4:	b1 11       	cpse	r27, r1
    45e6:	b1 93       	st	Z+, r27
    45e8:	10 82       	st	Z, r1
    45ea:	ca 01       	movw	r24, r20
    45ec:	0c 94 1d 23 	jmp	0x463a	; 0x463a <strrev>

000045f0 <utoa>:
    45f0:	45 32       	cpi	r20, 0x25	; 37
    45f2:	51 05       	cpc	r21, r1
    45f4:	20 f4       	brcc	.+8      	; 0x45fe <utoa+0xe>
    45f6:	42 30       	cpi	r20, 0x02	; 2
    45f8:	10 f0       	brcs	.+4      	; 0x45fe <utoa+0xe>
    45fa:	0c 94 03 23 	jmp	0x4606	; 0x4606 <__utoa_ncheck>
    45fe:	fb 01       	movw	r30, r22
    4600:	10 82       	st	Z, r1
    4602:	cb 01       	movw	r24, r22
    4604:	08 95       	ret

00004606 <__utoa_ncheck>:
    4606:	bb 27       	eor	r27, r27

00004608 <__utoa_common>:
    4608:	fb 01       	movw	r30, r22
    460a:	55 27       	eor	r21, r21
    460c:	aa 27       	eor	r26, r26
    460e:	88 0f       	add	r24, r24
    4610:	99 1f       	adc	r25, r25
    4612:	aa 1f       	adc	r26, r26
    4614:	a4 17       	cp	r26, r20
    4616:	10 f0       	brcs	.+4      	; 0x461c <__utoa_common+0x14>
    4618:	a4 1b       	sub	r26, r20
    461a:	83 95       	inc	r24
    461c:	50 51       	subi	r21, 0x10	; 16
    461e:	b9 f7       	brne	.-18     	; 0x460e <__utoa_common+0x6>
    4620:	a0 5d       	subi	r26, 0xD0	; 208
    4622:	aa 33       	cpi	r26, 0x3A	; 58
    4624:	08 f0       	brcs	.+2      	; 0x4628 <__utoa_common+0x20>
    4626:	a9 5d       	subi	r26, 0xD9	; 217
    4628:	a1 93       	st	Z+, r26
    462a:	00 97       	sbiw	r24, 0x00	; 0
    462c:	79 f7       	brne	.-34     	; 0x460c <__utoa_common+0x4>
    462e:	b1 11       	cpse	r27, r1
    4630:	b1 93       	st	Z+, r27
    4632:	11 92       	st	Z+, r1
    4634:	cb 01       	movw	r24, r22
    4636:	0c 94 1d 23 	jmp	0x463a	; 0x463a <strrev>

0000463a <strrev>:
    463a:	dc 01       	movw	r26, r24
    463c:	fc 01       	movw	r30, r24
    463e:	67 2f       	mov	r22, r23
    4640:	71 91       	ld	r23, Z+
    4642:	77 23       	and	r23, r23
    4644:	e1 f7       	brne	.-8      	; 0x463e <strrev+0x4>
    4646:	32 97       	sbiw	r30, 0x02	; 2
    4648:	04 c0       	rjmp	.+8      	; 0x4652 <strrev+0x18>
    464a:	7c 91       	ld	r23, X
    464c:	6d 93       	st	X+, r22
    464e:	70 83       	st	Z, r23
    4650:	62 91       	ld	r22, -Z
    4652:	ae 17       	cp	r26, r30
    4654:	bf 07       	cpc	r27, r31
    4656:	c8 f3       	brcs	.-14     	; 0x464a <strrev+0x10>
    4658:	08 95       	ret

0000465a <_exit>:
    465a:	f8 94       	cli

0000465c <__stop_program>:
    465c:	ff cf       	rjmp	.-2      	; 0x465c <__stop_program>
