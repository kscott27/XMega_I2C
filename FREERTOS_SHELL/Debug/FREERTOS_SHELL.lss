
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004ff6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000234  00802000  00004ff6  0000508a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802234  00802234  000052be  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000052be  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000052f0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ac8  00000000  00000000  00005330  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001d421  00000000  00000000  00005df8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00007576  00000000  00000000  00023219  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006b85  00000000  00000000  0002a78f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000020a0  00000000  00000000  00031314  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00007370  00000000  00000000  000333b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a883  00000000  00000000  0003a724  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a00  00000000  00000000  00044fa7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 03 	jmp	0x66e	; 0x66e <__ctors_end>
       4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      10:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      14:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      18:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      1c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      20:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      24:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      28:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      2c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      30:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      34:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      38:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      3c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      40:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      44:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      48:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      4c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      50:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      54:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      58:	0c 94 ff 11 	jmp	0x23fe	; 0x23fe <__vector_22>
      5c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      60:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      64:	0c 94 11 22 	jmp	0x4422	; 0x4422 <__vector_25>
      68:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      6c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      70:	0c 94 6f 22 	jmp	0x44de	; 0x44de <__vector_28>
      74:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      78:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      7c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      80:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      84:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      88:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      8c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      90:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      94:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      98:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      9c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e8:	0c 94 89 23 	jmp	0x4712	; 0x4712 <__vector_58>
      ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      fc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     100:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     104:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     108:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     10c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     110:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     114:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     118:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     11c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     120:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     124:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     128:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     12c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     130:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     134:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     138:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     13c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     140:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     144:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     148:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     14c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     150:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     154:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     158:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     15c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     160:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__vector_88>
     164:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     168:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     16c:	0c 94 2b 23 	jmp	0x4656	; 0x4656 <__vector_91>
     170:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     174:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     178:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     17c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     180:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     184:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     188:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     18c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     190:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     194:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     198:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     19c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1fc:	c0 1f       	adc	r28, r16
     1fe:	c3 1f       	adc	r28, r19
     200:	c6 1f       	adc	r28, r22
     202:	c9 1f       	adc	r28, r25
     204:	cc 1f       	adc	r28, r28
     206:	cf 1f       	adc	r28, r31
     208:	d1 1f       	adc	r29, r17
     20a:	e2 1f       	adc	r30, r18
     20c:	ea 1f       	adc	r30, r26
     20e:	f4 1f       	adc	r31, r20
     210:	f2 1f       	adc	r31, r18

00000212 <__trampolines_start>:
     212:	0c 94 b1 24 	jmp	0x4962	; 0x4962 <_ZN9frt_queueIiE10get_a_copyEv>
     216:	0c 94 2c 0c 	jmp	0x1858	; 0x1858 <_ZN11task_sensor3runEv>
     21a:	0c 94 a5 25 	jmp	0x4b4a	; 0x4b4a <_ZN9frt_queueIjE7butt_inERKj>
     21e:	0c 94 1f 24 	jmp	0x483e	; 0x483e <_ZN9frt_queueIjE12num_items_inEv>
     222:	0c 94 c0 1f 	jmp	0x3f80	; 0x3f80 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     226:	0c 94 92 09 	jmp	0x1324	; 0x1324 <_ZN9frt_queueIhE3getEv>
     22a:	0c 94 5f 0a 	jmp	0x14be	; 0x14be <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     22e:	0c 94 e2 1f 	jmp	0x3fc4	; 0x3fc4 <_ZN8emstreamlsE15ser_manipulator+0x62>
     232:	0c 94 c6 1f 	jmp	0x3f8c	; 0x3f8c <_ZN8emstreamlsE15ser_manipulator+0x2a>
     236:	0c 94 61 05 	jmp	0xac2	; 0xac2 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     23a:	0c 94 ea 1f 	jmp	0x3fd4	; 0x3fd4 <_ZN8emstreamlsE15ser_manipulator+0x72>
     23e:	0c 94 87 26 	jmp	0x4d0e	; 0x4d0e <_GLOBAL__sub_I_counter>
     242:	0c 94 c9 1f 	jmp	0x3f92	; 0x3f92 <_ZN8emstreamlsE15ser_manipulator+0x30>
     246:	0c 94 cf 1f 	jmp	0x3f9e	; 0x3f9e <_ZN8emstreamlsE15ser_manipulator+0x3c>
     24a:	0c 94 db 25 	jmp	0x4bb6	; 0x4bb6 <_ZN9frt_queueIiE3putERKi>
     24e:	0c 94 f1 04 	jmp	0x9e2	; 0x9e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     252:	0c 94 1c 25 	jmp	0x4a38	; 0x4a38 <_ZN9frt_queueIiE7ISR_getEPi>
     256:	0c 94 34 03 	jmp	0x668	; 0x668 <_call_static_run_method>
     25a:	0c 94 b7 25 	jmp	0x4b6e	; 0x4b6e <_ZN9frt_queueIjE3putERKj>
     25e:	0c 94 c2 05 	jmp	0xb84	; 0xb84 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     262:	0c 94 26 0a 	jmp	0x144c	; 0x144c <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     266:	0c 94 4d 09 	jmp	0x129a	; 0x129a <_ZN9frt_queueIhE9not_emptyEv>
     26a:	0c 94 c3 1f 	jmp	0x3f86	; 0x3f86 <_ZN8emstreamlsE15ser_manipulator+0x24>
     26e:	0c 94 3c 09 	jmp	0x1278	; 0x1278 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     272:	0c 94 76 05 	jmp	0xaec	; 0xaec <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     276:	0c 94 03 24 	jmp	0x4806	; 0x4806 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     27a:	0c 94 ee 23 	jmp	0x47dc	; 0x47dc <_ZN9frt_queueIjE13ISR_not_emptyEv>
     27e:	0c 94 8b 05 	jmp	0xb16	; 0xb16 <_ZN9I2CMaster10StartState11serialDebugEv>
     282:	0c 94 65 1f 	jmp	0x3eca	; 0x3eca <_ZN8emstream7getcharEv>
     286:	0c 94 14 0a 	jmp	0x1428	; 0x1428 <_ZN9frt_queueIhE3putERKh>
     28a:	0c 94 0d 04 	jmp	0x81a	; 0x81a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     28e:	0c 94 2d 25 	jmp	0x4a5a	; 0x4a5a <_ZN9frt_queueIiE7ISR_getEv>
     292:	0c 94 cc 24 	jmp	0x4998	; 0x4998 <_ZN9frt_queueIiE3getEPi>
     296:	0c 94 54 04 	jmp	0x8a8	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     29a:	0c 94 75 21 	jmp	0x42ea	; 0x42ea <_ZN5rs23214check_for_charEv>
     29e:	0c 94 ec 03 	jmp	0x7d8	; 0x7d8 <_ZN8I2CAgent11resetPacketER6Packet>
     2a2:	0c 94 d2 09 	jmp	0x13a4	; 0x13a4 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     2a6:	0c 94 8f 03 	jmp	0x71e	; 0x71e <_ZN8I2CAgent7receiveEv>
     2aa:	0c 94 0a 24 	jmp	0x4814	; 0x4814 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     2ae:	0c 94 46 09 	jmp	0x128c	; 0x128c <_ZN9frt_queueIhE12num_items_inEv>
     2b2:	0c 94 2b 21 	jmp	0x4256	; 0x4256 <_ZN5rs2327putcharEc>
     2b6:	0c 94 31 09 	jmp	0x1262	; 0x1262 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     2ba:	0c 94 c9 25 	jmp	0x4b92	; 0x4b92 <_ZN9frt_queueIiE7butt_inERKi>
     2be:	0c 94 75 25 	jmp	0x4aea	; 0x4aea <_ZN9frt_queueIiE11ISR_butt_inERKi>
     2c2:	0c 94 04 25 	jmp	0x4a08	; 0x4a08 <_ZN9frt_queueIjE7ISR_getEv>
     2c6:	0c 94 63 1f 	jmp	0x3ec6	; 0x3ec6 <_ZN8emstream13ready_to_sendEv>
     2ca:	0c 94 03 04 	jmp	0x806	; 0x806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     2ce:	0c 94 6b 1f 	jmp	0x3ed6	; 0x3ed6 <_ZN8emstream12clear_screenEv>
     2d2:	0c 94 0d 05 	jmp	0xa1a	; 0xa1a <_ZN9I2CMaster10ErrorState11serialDebugEv>
     2d6:	0c 94 8a 24 	jmp	0x4914	; 0x4914 <_ZN9frt_queueIjE3getEv>
     2da:	0c 94 cc 1e 	jmp	0x3d98	; 0x3d98 <__cxa_pure_virtual>
     2de:	0c 94 7e 24 	jmp	0x48fc	; 0x48fc <_ZN9frt_queueIjE3getEPj>
     2e2:	0c 94 db 0d 	jmp	0x1bb6	; 0x1bb6 <_ZN9task_user3runEv>
     2e6:	0c 94 e8 07 	jmp	0xfd0	; 0xfd0 <_ZN9I2CMaster10StartState7executeER6Packet>
     2ea:	0c 94 9b 04 	jmp	0x936	; 0x936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2ee:	0c 94 63 24 	jmp	0x48c6	; 0x48c6 <_ZN9frt_queueIjE10get_a_copyEv>
     2f2:	0c 94 a1 1b 	jmp	0x3742	; 0x3742 <_ZN8frt_task12print_statusER8emstream>
     2f6:	0c 94 a5 24 	jmp	0x494a	; 0x494a <_ZN9frt_queueIiE10get_a_copyERi>
     2fa:	0c 94 86 09 	jmp	0x130c	; 0x130c <_ZN9frt_queueIhE3getEPh>
     2fe:	0c 94 14 1d 	jmp	0x3a28	; 0x3a28 <_ZN14frt_text_queue7putcharEc>
     302:	0c 94 ba 03 	jmp	0x774	; 0x774 <_ZN8I2CAgent11writePacketER7Command>
     306:	0c 94 3b 24 	jmp	0x4876	; 0x4876 <_ZN9frt_queueIiE12num_items_inEv>
     30a:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     30e:	0c 94 6a 1f 	jmp	0x3ed4	; 0x3ed4 <_ZN8emstream12transmit_nowEv>
     312:	0c 94 31 24 	jmp	0x4862	; 0x4862 <_ZN9frt_queueIjE8is_emptyEv>
     316:	0c 94 df 14 	jmp	0x29be	; 0x29be <prvIdleTask>
     31a:	0c 94 09 1d 	jmp	0x3a12	; 0x3a12 <_ZN14frt_text_queue14check_for_charEv>
     31e:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <_ZN8emstreamlsE15ser_manipulator+0x36>
     322:	0c 94 45 25 	jmp	0x4a8a	; 0x4a8a <_ZN9frt_queueIjE11ISR_butt_inERKj>
     326:	0c 94 68 1f 	jmp	0x3ed0	; 0x3ed0 <_ZN8emstream14check_for_charEv>
     32a:	0c 94 26 24 	jmp	0x484c	; 0x484c <_ZN9frt_queueIjE9not_emptyEv>
     32e:	0c 94 f9 03 	jmp	0x7f2	; 0x7f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     332:	0c 94 cb 04 	jmp	0x996	; 0x996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     336:	0c 94 d1 1f 	jmp	0x3fa2	; 0x3fa2 <_ZN8emstreamlsE15ser_manipulator+0x40>
     33a:	0c 94 5d 25 	jmp	0x4aba	; 0x4aba <_ZN9frt_queueIjE7ISR_putERKj>
     33e:	0c 94 52 0a 	jmp	0x14a4	; 0x14a4 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     342:	0c 94 62 09 	jmp	0x12c4	; 0x12c4 <_ZN9frt_queueIhE10get_a_copyERh>
     346:	0c 94 8d 25 	jmp	0x4b1a	; 0x4b1a <_ZN9frt_queueIiE7ISR_putERKi>
     34a:	0c 94 42 24 	jmp	0x4884	; 0x4884 <_ZN9frt_queueIiE9not_emptyEv>
     34e:	0c 94 4d 24 	jmp	0x489a	; 0x489a <_ZN9frt_queueIiE8is_emptyEv>
     352:	0c 94 f2 1f 	jmp	0x3fe4	; 0x3fe4 <_ZN8emstreamlsE15ser_manipulator+0x82>
     356:	0c 94 f9 23 	jmp	0x47f2	; 0x47f2 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     35a:	0c 94 a0 05 	jmp	0xb40	; 0xb40 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     35e:	0c 94 e7 23 	jmp	0x47ce	; 0x47ce <_ZN9frt_queueIjE16ISR_num_items_inEv>
     362:	0c 94 6f 03 	jmp	0x6de	; 0x6de <_ZN8I2CAgent10readPacketEv>
     366:	0c 94 d8 24 	jmp	0x49b0	; 0x49b0 <_ZN9frt_queueIiE3getEv>
     36a:	0c 94 22 05 	jmp	0xa44	; 0xa44 <_ZN9I2CMaster9DoneState11serialDebugEv>
     36e:	0c 94 f4 1f 	jmp	0x3fe8	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
     372:	0c 94 eb 1c 	jmp	0x39d6	; 0x39d6 <_ZN14frt_text_queue7getcharEv>
     376:	0c 94 15 24 	jmp	0x482a	; 0x482a <_ZN9frt_queueIiE12ISR_is_emptyEv>
     37a:	0c 94 06 05 	jmp	0xa0c	; 0xa0c <_ZN9I2CMaster9DoneState7executeER6Packet>
     37e:	0c 94 4f 21 	jmp	0x429e	; 0x429e <_ZN5rs2327getcharEv>
     382:	0c 94 bb 09 	jmp	0x1376	; 0x1376 <_ZN9frt_queueIhE7ISR_getEv>
     386:	0c 94 6e 09 	jmp	0x12dc	; 0x12dc <_ZN9frt_queueIhE10get_a_copyEv>
     38a:	0c 94 4c 05 	jmp	0xa98	; 0xa98 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     38e:	0c 94 2a 09 	jmp	0x1254	; 0x1254 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     392:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <_ZN9frt_queueIhE7ISR_putERKh>
     396:	0c 94 88 21 	jmp	0x4310	; 0x4310 <_ZN5rs23212clear_screenEv>
     39a:	0c 94 45 0a 	jmp	0x148a	; 0x148a <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     39e:	0c 94 58 09 	jmp	0x12b0	; 0x12b0 <_ZN9frt_queueIhE8is_emptyEv>
     3a2:	0c 94 f3 24 	jmp	0x49e6	; 0x49e6 <_ZN9frt_queueIjE7ISR_getEPj>
     3a6:	0c 94 aa 09 	jmp	0x1354	; 0x1354 <_ZN9frt_queueIhE7ISR_getEPh>
     3aa:	0c 94 02 0a 	jmp	0x1404	; 0x1404 <_ZN9frt_queueIhE7butt_inERKh>
     3ae:	0c 94 7a 03 	jmp	0x6f4	; 0x6f4 <_ZN8I2CAgent8transmitER7Command>
     3b2:	0c 94 57 24 	jmp	0x48ae	; 0x48ae <_ZN9frt_queueIjE10get_a_copyERj>

000003b6 <__trampolines_end>:
     3b6:	2c 20       	and	r2, r12
     3b8:	54 43       	sbci	r21, 0x34	; 52
     3ba:	43 30       	cpi	r20, 0x03	; 3
     3bc:	43 43       	sbci	r20, 0x33	; 51
     3be:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c1 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c1:	2f 00                                               /.

000003c3 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d1 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d1:	54 69 6d 65 3a 20 00                                Time: .

000003d8 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d8:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e4 <_ZZN9task_user11show_statusEvE3__c>:
     3e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000403 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     403:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000412 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     412:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     422:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000042d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     42d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     43d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46b:	6d 61 74 69 6f 6e 00                                mation.

00000472 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     472:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     482:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000493 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     493:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a3:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004ab <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4ab:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bb:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d7:	68 65 20 41 56 52 00                                he AVR.

000004de <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4de:	20 68 65 6c 70 00                                    help.

000004e4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000503 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     503:	1b 5b 33 30 6d 00                                   .[30m.

00000509 <_ZZN9task_user18print_help_messageEvE3__c>:
     509:	1b 5b 34 36 6d 00                                   .[46m.

0000050f <_ZZN9task_user3runEvE3__c_3>:
     50f:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51f:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000052c <_ZZN9task_user3runEvE3__c_2>:
     52c:	3a 57 54 46 3f 00                                   :WTF?.

00000532 <_ZZN9task_user3runEvE3__c_1>:
     532:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     542:	65 00                                               e.

00000544 <_ZZN9task_user3runEvE3__c_0>:
     544:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000552 <_ZZN9task_user3runEvE3__c>:
     552:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     562:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000570 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     570:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057a <_ZZN8frt_task15emergency_resetEvE3__c>:
     57a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000589 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     589:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     599:	61 73 6b 20 00                                      ask .

0000059e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005ac <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5ac:	20 63 72 65 61 74 65 64 00                           created.

000005b5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b5:	54 61 73 6b 20 00                                   Task .

000005bb <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bb:	1b 5b 32 32 6d 00                                   .[22m.

000005c1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c1:	54 61 73 6b 3a 20 00                                Task: .

000005c8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5cd:	1b 5b 32 32 6d 00                                   .[22m.

000005d3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005de <_ZZ17print_task_stacksP8emstreamE3__c>:
     5de:	1b 5b 31 6d 00                                      .[1m.

000005e3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e3:	09 09 00                                            ...

000005e6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e6:	2f 00                                               /.

000005e8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f3:	09 2d 2d 2d 2d 00                                   .----.

000005f9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000605 <_ZZ15print_task_listP8emstreamE3__c_4>:
     605:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000616 <_ZZ15print_task_listP8emstreamE3__c_3>:
     616:	09 52 75 6e 73 00                                   .Runs.

0000061c <_ZZ15print_task_listP8emstreamE3__c_2>:
     61c:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000628 <_ZZ15print_task_listP8emstreamE3__c_1>:
     628:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000639 <_ZZ15print_task_listP8emstreamE3__c_0>:
     639:	09 53 74 61 63 6b 00                                .Stack.

00000640 <_ZZ15print_task_listP8emstreamE3__c>:
     640:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64b:	09 00                                               ..

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64f:	2f 00                                               /.

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     653:	09 00                                               ..

00000655 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     655:	1b 5b 32 32 6d 00                                   .[22m.

0000065b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65b:	1b 5b 31 6d 00                                      .[1m.

00000660 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     660:	1b 5b 31 6d 00                                      .[1m.

00000665 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     665:	20 20 00                                              .

00000668 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     668:	0e 94 39 1a 	call	0x3472	; 0x3472 <_ZN8frt_task22_call_users_run_methodEPS_>

0000066c <__ctors_start>:
     66c:	87 26       	eor	r8, r23

0000066e <__ctors_end>:
     66e:	11 24       	eor	r1, r1
     670:	1f be       	out	0x3f, r1	; 63
     672:	cf ef       	ldi	r28, 0xFF	; 255
     674:	cd bf       	out	0x3d, r28	; 61
     676:	df e3       	ldi	r29, 0x3F	; 63
     678:	de bf       	out	0x3e, r29	; 62
     67a:	00 e0       	ldi	r16, 0x00	; 0
     67c:	0c bf       	out	0x3c, r16	; 60
     67e:	18 be       	out	0x38, r1	; 56
     680:	19 be       	out	0x39, r1	; 57
     682:	1a be       	out	0x3a, r1	; 58
     684:	1b be       	out	0x3b, r1	; 59

00000686 <__do_copy_data>:
     686:	12 e2       	ldi	r17, 0x22	; 34
     688:	a0 e0       	ldi	r26, 0x00	; 0
     68a:	b0 e2       	ldi	r27, 0x20	; 32
     68c:	e6 ef       	ldi	r30, 0xF6	; 246
     68e:	ff e4       	ldi	r31, 0x4F	; 79
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	0b bf       	out	0x3b, r16	; 59
     694:	02 c0       	rjmp	.+4      	; 0x69a <__do_copy_data+0x14>
     696:	07 90       	elpm	r0, Z+
     698:	0d 92       	st	X+, r0
     69a:	a4 33       	cpi	r26, 0x34	; 52
     69c:	b1 07       	cpc	r27, r17
     69e:	d9 f7       	brne	.-10     	; 0x696 <__do_copy_data+0x10>
     6a0:	1b be       	out	0x3b, r1	; 59

000006a2 <__do_clear_bss>:
     6a2:	23 e3       	ldi	r18, 0x33	; 51
     6a4:	a4 e3       	ldi	r26, 0x34	; 52
     6a6:	b2 e2       	ldi	r27, 0x22	; 34
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <.do_clear_bss_start>

000006aa <.do_clear_bss_loop>:
     6aa:	1d 92       	st	X+, r1

000006ac <.do_clear_bss_start>:
     6ac:	a2 30       	cpi	r26, 0x02	; 2
     6ae:	b2 07       	cpc	r27, r18
     6b0:	e1 f7       	brne	.-8      	; 0x6aa <.do_clear_bss_loop>

000006b2 <__do_global_ctors>:
     6b2:	13 e0       	ldi	r17, 0x03	; 3
     6b4:	c7 e3       	ldi	r28, 0x37	; 55
     6b6:	d3 e0       	ldi	r29, 0x03	; 3
     6b8:	00 e0       	ldi	r16, 0x00	; 0
     6ba:	06 c0       	rjmp	.+12     	; 0x6c8 <__do_global_ctors+0x16>
     6bc:	21 97       	sbiw	r28, 0x01	; 1
     6be:	01 09       	sbc	r16, r1
     6c0:	80 2f       	mov	r24, r16
     6c2:	fe 01       	movw	r30, r28
     6c4:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <__tablejump2__>
     6c8:	c6 33       	cpi	r28, 0x36	; 54
     6ca:	d1 07       	cpc	r29, r17
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	08 07       	cpc	r16, r24
     6d0:	a9 f7       	brne	.-22     	; 0x6bc <__do_global_ctors+0xa>
     6d2:	0e 94 02 26 	call	0x4c04	; 0x4c04 <main>
     6d6:	0c 94 f9 27 	jmp	0x4ff2	; 0x4ff2 <_exit>

000006da <__bad_interrupt>:
     6da:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006de <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6de:	bc 01       	movw	r22, r24
     6e0:	6e 5f       	subi	r22, 0xFE	; 254
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	dc 01       	movw	r26, r24
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	00 84       	ldd	r0, Z+8	; 0x08
     6ec:	f1 85       	ldd	r31, Z+9	; 0x09
     6ee:	e0 2d       	mov	r30, r0
     6f0:	19 95       	eicall
     6f2:	08 95       	ret

000006f4 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fa:	e8 81       	ld	r30, Y
     6fc:	f9 81       	ldd	r31, Y+1	; 0x01
     6fe:	04 80       	ldd	r0, Z+4	; 0x04
     700:	f5 81       	ldd	r31, Z+5	; 0x05
     702:	e0 2d       	mov	r30, r0
     704:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     706:	be 01       	movw	r22, r28
     708:	62 5f       	subi	r22, 0xF2	; 242
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
  };

  // I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     70c:	ec 8d       	ldd	r30, Y+28	; 0x1c
     70e:	fd 8d       	ldd	r31, Y+29	; 0x1d
     710:	80 81       	ld	r24, Z
     712:	91 81       	ldd	r25, Z+1	; 0x01
     714:	0e 94 4a 07 	call	0xe94	; 0xe94 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	08 95       	ret

0000071e <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     71e:	ef 92       	push	r14
     720:	ff 92       	push	r15
     722:	0f 93       	push	r16
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72a:	7c 01       	movw	r14, r24
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	e8 0e       	add	r14, r24
     730:	f1 1c       	adc	r15, r1
     732:	e8 81       	ld	r30, Y
     734:	f9 81       	ldd	r31, Y+1	; 0x01
     736:	00 84       	ldd	r0, Z+8	; 0x08
     738:	f1 85       	ldd	r31, Z+9	; 0x09
     73a:	e0 2d       	mov	r30, r0
     73c:	b7 01       	movw	r22, r14
     73e:	ce 01       	movw	r24, r28
     740:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     742:	28 85       	ldd	r18, Y+8	; 0x08
     744:	39 85       	ldd	r19, Y+9	; 0x09
     746:	4a 85       	ldd	r20, Y+10	; 0x0a
     748:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74a:	be 01       	movw	r22, r28
     74c:	60 5e       	subi	r22, 0xE0	; 224
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	00 e0       	ldi	r16, 0x00	; 0
     752:	8e 81       	ldd	r24, Y+6	; 0x06
     754:	9f 81       	ldd	r25, Y+7	; 0x07
     756:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75a:	ec 8d       	ldd	r30, Y+28	; 0x1c
     75c:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     75e:	b7 01       	movw	r22, r14
     760:	82 81       	ldd	r24, Z+2	; 0x02
     762:	93 81       	ldd	r25, Z+3	; 0x03
     764:	0e 94 8d 07 	call	0xf1a	; 0xf1a <_ZN9I2CMaster8Receiver3runER6Packet>
}
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	0f 91       	pop	r16
     76e:	ff 90       	pop	r15
     770:	ef 90       	pop	r14
     772:	08 95       	ret

00000774 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
     784:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     786:	6c 01       	movw	r12, r24
     788:	8e e0       	ldi	r24, 0x0E	; 14
     78a:	c8 0e       	add	r12, r24
     78c:	d1 1c       	adc	r13, r1
     78e:	e8 81       	ld	r30, Y
     790:	f9 81       	ldd	r31, Y+1	; 0x01
     792:	00 84       	ldd	r0, Z+8	; 0x08
     794:	f1 85       	ldd	r31, Z+9	; 0x09
     796:	e0 2d       	mov	r30, r0
     798:	b6 01       	movw	r22, r12
     79a:	ce 01       	movw	r24, r28
     79c:	19 95       	eicall
     79e:	2c 89       	ldd	r18, Y+20	; 0x14
     7a0:	3d 89       	ldd	r19, Y+21	; 0x15
     7a2:	4e 89       	ldd	r20, Y+22	; 0x16
     7a4:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7a6:	be 01       	movw	r22, r28
     7a8:	61 5e       	subi	r22, 0xE1	; 225
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	00 e0       	ldi	r16, 0x00	; 0
     7ae:	8a 89       	ldd	r24, Y+18	; 0x12
     7b0:	9b 89       	ldd	r25, Y+19	; 0x13
     7b2:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7b6:	d7 01       	movw	r26, r14
     7b8:	ed 91       	ld	r30, X+
     7ba:	fc 91       	ld	r31, X
     7bc:	01 90       	ld	r0, Z+
     7be:	f0 81       	ld	r31, Z
     7c0:	e0 2d       	mov	r30, r0
     7c2:	b6 01       	movw	r22, r12
     7c4:	c7 01       	movw	r24, r14
     7c6:	19 95       	eicall
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	08 95       	ret

000007d8 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7d8:	cb 01       	movw	r24, r22
  packet.resetContent();
     7da:	0e 94 14 0c 	call	0x1828	; 0x1828 <_ZN6Packet12resetContentEv>
     7de:	08 95       	ret

000007e0 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e0:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e2:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e4:	86 2f       	mov	r24, r22
     7e6:	88 0f       	add	r24, r24
     7e8:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ea:	68 2f       	mov	r22, r24
     7ec:	61 60       	ori	r22, 0x01	; 1
     7ee:	60 a3       	std	Z+32, r22	; 0x20
     7f0:	08 95       	ret

000007f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
  }
  else
  {
    return false;
  }
}
     7f2:	dc 01       	movw	r26, r24
     7f4:	17 96       	adiw	r26, 0x07	; 7
     7f6:	ed 91       	ld	r30, X+
     7f8:	fc 91       	ld	r31, X
     7fa:	18 97       	sbiw	r26, 0x08	; 8
     7fc:	04 80       	ldd	r0, Z+4	; 0x04
     7fe:	f5 81       	ldd	r31, Z+5	; 0x05
     800:	e0 2d       	mov	r30, r0
     802:	84 81       	ldd	r24, Z+4	; 0x04
     804:	08 95       	ret

00000806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     806:	dc 01       	movw	r26, r24
     808:	17 96       	adiw	r26, 0x07	; 7
     80a:	ed 91       	ld	r30, X+
     80c:	fc 91       	ld	r31, X
     80e:	18 97       	sbiw	r26, 0x08	; 8
     810:	04 80       	ldd	r0, Z+4	; 0x04
     812:	f5 81       	ldd	r31, Z+5	; 0x05
     814:	e0 2d       	mov	r30, r0
     816:	84 81       	ldd	r24, Z+4	; 0x04
     818:	08 95       	ret

0000081a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	1f 92       	push	r1
     824:	1f 92       	push	r1
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	8c 01       	movw	r16, r24
     82c:	dc 01       	movw	r26, r24
     82e:	19 96       	adiw	r26, 0x09	; 9
     830:	8d 91       	ld	r24, X+
     832:	9c 91       	ld	r25, X
     834:	1a 97       	sbiw	r26, 0x0a	; 10
     836:	89 83       	std	Y+1, r24	; 0x01
     838:	9a 83       	std	Y+2, r25	; 0x02
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	01 97       	sbiw	r24, 0x01	; 1
     840:	89 83       	std	Y+1, r24	; 0x01
     842:	9a 83       	std	Y+2, r25	; 0x02
     844:	89 2b       	or	r24, r25
     846:	59 f0       	breq	.+22     	; 0x85e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     848:	d8 01       	movw	r26, r16
     84a:	17 96       	adiw	r26, 0x07	; 7
     84c:	ed 91       	ld	r30, X+
     84e:	fc 91       	ld	r31, X
     850:	18 97       	sbiw	r26, 0x08	; 8
     852:	04 80       	ldd	r0, Z+4	; 0x04
     854:	f5 81       	ldd	r31, Z+5	; 0x05
     856:	e0 2d       	mov	r30, r0
     858:	84 81       	ldd	r24, Z+4	; 0x04
     85a:	86 ff       	sbrs	r24, 6
     85c:	ee cf       	rjmp	.-36     	; 0x83a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x20>
     85e:	d8 01       	movw	r26, r16
     860:	ed 91       	ld	r30, X+
     862:	fc 91       	ld	r31, X
     864:	02 80       	ldd	r0, Z+2	; 0x02
     866:	f3 81       	ldd	r31, Z+3	; 0x03
     868:	e0 2d       	mov	r30, r0
     86a:	c8 01       	movw	r24, r16
     86c:	19 95       	eicall
     86e:	d8 01       	movw	r26, r16
     870:	17 96       	adiw	r26, 0x07	; 7
     872:	ed 91       	ld	r30, X+
     874:	fc 91       	ld	r31, X
     876:	18 97       	sbiw	r26, 0x08	; 8
     878:	04 80       	ldd	r0, Z+4	; 0x04
     87a:	f5 81       	ldd	r31, Z+5	; 0x05
     87c:	e0 2d       	mov	r30, r0
     87e:	84 81       	ldd	r24, Z+4	; 0x04
     880:	84 fd       	sbrc	r24, 4
     882:	08 c0       	rjmp	.+16     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     884:	84 81       	ldd	r24, Z+4	; 0x04
     886:	86 ff       	sbrs	r24, 6
     888:	05 c0       	rjmp	.+10     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     88a:	12 96       	adiw	r26, 0x02	; 2
     88c:	8d 91       	ld	r24, X+
     88e:	9c 91       	ld	r25, X
     890:	13 97       	sbiw	r26, 0x03	; 3
     892:	03 c0       	rjmp	.+6      	; 0x89a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x80>
     894:	f8 01       	movw	r30, r16
     896:	84 81       	ldd	r24, Z+4	; 0x04
     898:	95 81       	ldd	r25, Z+5	; 0x05
     89a:	0f 90       	pop	r0
     89c:	0f 90       	pop	r0
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	08 95       	ret

000008a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     8a8:	0f 93       	push	r16
     8aa:	1f 93       	push	r17
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	1f 92       	push	r1
     8b2:	1f 92       	push	r1
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	8c 01       	movw	r16, r24
     8ba:	dc 01       	movw	r26, r24
     8bc:	19 96       	adiw	r26, 0x09	; 9
     8be:	8d 91       	ld	r24, X+
     8c0:	9c 91       	ld	r25, X
     8c2:	1a 97       	sbiw	r26, 0x0a	; 10
     8c4:	89 83       	std	Y+1, r24	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 81       	ldd	r24, Y+1	; 0x01
     8ca:	9a 81       	ldd	r25, Y+2	; 0x02
     8cc:	01 97       	sbiw	r24, 0x01	; 1
     8ce:	89 83       	std	Y+1, r24	; 0x01
     8d0:	9a 83       	std	Y+2, r25	; 0x02
     8d2:	89 2b       	or	r24, r25
     8d4:	59 f0       	breq	.+22     	; 0x8ec <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x44>
     8d6:	d8 01       	movw	r26, r16
     8d8:	17 96       	adiw	r26, 0x07	; 7
     8da:	ed 91       	ld	r30, X+
     8dc:	fc 91       	ld	r31, X
     8de:	18 97       	sbiw	r26, 0x08	; 8
     8e0:	04 80       	ldd	r0, Z+4	; 0x04
     8e2:	f5 81       	ldd	r31, Z+5	; 0x05
     8e4:	e0 2d       	mov	r30, r0
     8e6:	84 81       	ldd	r24, Z+4	; 0x04
     8e8:	88 23       	and	r24, r24
     8ea:	74 f7       	brge	.-36     	; 0x8c8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x20>
     8ec:	d8 01       	movw	r26, r16
     8ee:	ed 91       	ld	r30, X+
     8f0:	fc 91       	ld	r31, X
     8f2:	02 80       	ldd	r0, Z+2	; 0x02
     8f4:	f3 81       	ldd	r31, Z+3	; 0x03
     8f6:	e0 2d       	mov	r30, r0
     8f8:	c8 01       	movw	r24, r16
     8fa:	19 95       	eicall
     8fc:	d8 01       	movw	r26, r16
     8fe:	17 96       	adiw	r26, 0x07	; 7
     900:	ed 91       	ld	r30, X+
     902:	fc 91       	ld	r31, X
     904:	18 97       	sbiw	r26, 0x08	; 8
     906:	04 80       	ldd	r0, Z+4	; 0x04
     908:	f5 81       	ldd	r31, Z+5	; 0x05
     90a:	e0 2d       	mov	r30, r0
     90c:	84 81       	ldd	r24, Z+4	; 0x04
     90e:	84 fd       	sbrc	r24, 4
     910:	08 c0       	rjmp	.+16     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     912:	84 81       	ldd	r24, Z+4	; 0x04
     914:	88 23       	and	r24, r24
     916:	2c f4       	brge	.+10     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     918:	12 96       	adiw	r26, 0x02	; 2
     91a:	8d 91       	ld	r24, X+
     91c:	9c 91       	ld	r25, X
     91e:	13 97       	sbiw	r26, 0x03	; 3
     920:	03 c0       	rjmp	.+6      	; 0x928 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x80>
     922:	f8 01       	movw	r30, r16
     924:	84 81       	ldd	r24, Z+4	; 0x04
     926:	95 81       	ldd	r25, Z+5	; 0x05
     928:	0f 90       	pop	r0
     92a:	0f 90       	pop	r0
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	08 95       	ret

00000936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     936:	ef 92       	push	r14
     938:	ff 92       	push	r15
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	8c 01       	movw	r16, r24
     944:	eb 01       	movw	r28, r22
     946:	e8 81       	ld	r30, Y
     948:	f9 81       	ldd	r31, Y+1	; 0x01
     94a:	00 8c       	ldd	r0, Z+24	; 0x18
     94c:	f1 8d       	ldd	r31, Z+25	; 0x19
     94e:	e0 2d       	mov	r30, r0
     950:	cb 01       	movw	r24, r22
     952:	19 95       	eicall
     954:	88 23       	and	r24, r24
     956:	a9 f0       	breq	.+42     	; 0x982 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     958:	e8 81       	ld	r30, Y
     95a:	f9 81       	ldd	r31, Y+1	; 0x01
     95c:	02 84       	ldd	r0, Z+10	; 0x0a
     95e:	f3 85       	ldd	r31, Z+11	; 0x0b
     960:	e0 2d       	mov	r30, r0
     962:	e1 2c       	mov	r14, r1
     964:	f1 2c       	mov	r15, r1
     966:	b7 01       	movw	r22, r14
     968:	ce 01       	movw	r24, r28
     96a:	19 95       	eicall
     96c:	d8 01       	movw	r26, r16
     96e:	17 96       	adiw	r26, 0x07	; 7
     970:	ed 91       	ld	r30, X+
     972:	fc 91       	ld	r31, X
     974:	18 97       	sbiw	r26, 0x08	; 8
     976:	04 80       	ldd	r0, Z+4	; 0x04
     978:	f5 81       	ldd	r31, Z+5	; 0x05
     97a:	e0 2d       	mov	r30, r0
     97c:	d7 01       	movw	r26, r14
     97e:	8c 91       	ld	r24, X
     980:	87 83       	std	Z+7, r24	; 0x07
     982:	f8 01       	movw	r30, r16
     984:	82 81       	ldd	r24, Z+2	; 0x02
     986:	93 81       	ldd	r25, Z+3	; 0x03
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	1f 91       	pop	r17
     98e:	0f 91       	pop	r16
     990:	ff 90       	pop	r15
     992:	ef 90       	pop	r14
     994:	08 95       	ret

00000996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	1f 92       	push	r1
     9a0:	cd b7       	in	r28, 0x3d	; 61
     9a2:	de b7       	in	r29, 0x3e	; 62
     9a4:	8c 01       	movw	r16, r24
     9a6:	cb 01       	movw	r24, r22
     9a8:	d8 01       	movw	r26, r16
     9aa:	17 96       	adiw	r26, 0x07	; 7
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
     9b0:	18 97       	sbiw	r26, 0x08	; 8
     9b2:	04 80       	ldd	r0, Z+4	; 0x04
     9b4:	f5 81       	ldd	r31, Z+5	; 0x05
     9b6:	e0 2d       	mov	r30, r0
     9b8:	27 81       	ldd	r18, Z+7	; 0x07
     9ba:	29 83       	std	Y+1, r18	; 0x01
     9bc:	db 01       	movw	r26, r22
     9be:	ed 91       	ld	r30, X+
     9c0:	fc 91       	ld	r31, X
     9c2:	01 90       	ld	r0, Z+
     9c4:	f0 81       	ld	r31, Z
     9c6:	e0 2d       	mov	r30, r0
     9c8:	be 01       	movw	r22, r28
     9ca:	6f 5f       	subi	r22, 0xFF	; 255
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	19 95       	eicall
     9d0:	f8 01       	movw	r30, r16
     9d2:	82 81       	ldd	r24, Z+2	; 0x02
     9d4:	93 81       	ldd	r25, Z+3	; 0x03
     9d6:	0f 90       	pop	r0
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	08 95       	ret

000009e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	ec 01       	movw	r28, r24
     9e8:	cb 01       	movw	r24, r22
     9ea:	db 01       	movw	r26, r22
     9ec:	ed 91       	ld	r30, X+
     9ee:	fc 91       	ld	r31, X
     9f0:	04 88       	ldd	r0, Z+20	; 0x14
     9f2:	f5 89       	ldd	r31, Z+21	; 0x15
     9f4:	e0 2d       	mov	r30, r0
     9f6:	19 95       	eicall
     9f8:	88 23       	and	r24, r24
     9fa:	19 f0       	breq	.+6      	; 0xa02 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     9fc:	8a 81       	ldd	r24, Y+2	; 0x02
     9fe:	9b 81       	ldd	r25, Y+3	; 0x03
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     a02:	8c 81       	ldd	r24, Y+4	; 0x04
     a04:	9d 81       	ldd	r25, Y+5	; 0x05
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_ZN9I2CMaster9DoneState7executeER6Packet>:
     a0c:	21 e0       	ldi	r18, 0x01	; 1
     a0e:	fb 01       	movw	r30, r22
     a10:	23 87       	std	Z+11, r18	; 0x0b
     a12:	fc 01       	movw	r30, r24
     a14:	82 81       	ldd	r24, Z+2	; 0x02
     a16:	93 81       	ldd	r25, Z+3	; 0x03
     a18:	08 95       	ret

00000a1a <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	dc 01       	movw	r26, r24
     a20:	17 96       	adiw	r26, 0x07	; 7
     a22:	ed 91       	ld	r30, X+
     a24:	fc 91       	ld	r31, X
     a26:	18 97       	sbiw	r26, 0x08	; 8
     a28:	c6 81       	ldd	r28, Z+6	; 0x06
     a2a:	d7 81       	ldd	r29, Z+7	; 0x07
     a2c:	64 e1       	ldi	r22, 0x14	; 20
     a2e:	70 e2       	ldi	r23, 0x20	; 32
     a30:	ce 01       	movw	r24, r28
     a32:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     a36:	66 e0       	ldi	r22, 0x06	; 6
     a38:	ce 01       	movw	r24, r28
     a3a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <_ZN9I2CMaster9DoneState11serialDebugEv>:
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	dc 01       	movw	r26, r24
     a4a:	17 96       	adiw	r26, 0x07	; 7
     a4c:	ed 91       	ld	r30, X+
     a4e:	fc 91       	ld	r31, X
     a50:	18 97       	sbiw	r26, 0x08	; 8
     a52:	c6 81       	ldd	r28, Z+6	; 0x06
     a54:	d7 81       	ldd	r29, Z+7	; 0x07
     a56:	6a e1       	ldi	r22, 0x1A	; 26
     a58:	70 e2       	ldi	r23, 0x20	; 32
     a5a:	ce 01       	movw	r24, r28
     a5c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     a60:	66 e0       	ldi	r22, 0x06	; 6
     a62:	ce 01       	movw	r24, r28
     a64:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	dc 01       	movw	r26, r24
     a74:	17 96       	adiw	r26, 0x07	; 7
     a76:	ed 91       	ld	r30, X+
     a78:	fc 91       	ld	r31, X
     a7a:	18 97       	sbiw	r26, 0x08	; 8
     a7c:	c6 81       	ldd	r28, Z+6	; 0x06
     a7e:	d7 81       	ldd	r29, Z+7	; 0x07
     a80:	6f e1       	ldi	r22, 0x1F	; 31
     a82:	70 e2       	ldi	r23, 0x20	; 32
     a84:	ce 01       	movw	r24, r28
     a86:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     a8a:	66 e0       	ldi	r22, 0x06	; 6
     a8c:	ce 01       	movw	r24, r28
     a8e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	08 95       	ret

00000a98 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	dc 01       	movw	r26, r24
     a9e:	17 96       	adiw	r26, 0x07	; 7
     aa0:	ed 91       	ld	r30, X+
     aa2:	fc 91       	ld	r31, X
     aa4:	18 97       	sbiw	r26, 0x08	; 8
     aa6:	c6 81       	ldd	r28, Z+6	; 0x06
     aa8:	d7 81       	ldd	r29, Z+7	; 0x07
     aaa:	68 e2       	ldi	r22, 0x28	; 40
     aac:	70 e2       	ldi	r23, 0x20	; 32
     aae:	ce 01       	movw	r24, r28
     ab0:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     ab4:	66 e0       	ldi	r22, 0x06	; 6
     ab6:	ce 01       	movw	r24, r28
     ab8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	08 95       	ret

00000ac2 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
     ac6:	dc 01       	movw	r26, r24
     ac8:	17 96       	adiw	r26, 0x07	; 7
     aca:	ed 91       	ld	r30, X+
     acc:	fc 91       	ld	r31, X
     ace:	18 97       	sbiw	r26, 0x08	; 8
     ad0:	c6 81       	ldd	r28, Z+6	; 0x06
     ad2:	d7 81       	ldd	r29, Z+7	; 0x07
     ad4:	61 e3       	ldi	r22, 0x31	; 49
     ad6:	70 e2       	ldi	r23, 0x20	; 32
     ad8:	ce 01       	movw	r24, r28
     ada:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     ade:	66 e0       	ldi	r22, 0x06	; 6
     ae0:	ce 01       	movw	r24, r28
     ae2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	08 95       	ret

00000aec <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	dc 01       	movw	r26, r24
     af2:	17 96       	adiw	r26, 0x07	; 7
     af4:	ed 91       	ld	r30, X+
     af6:	fc 91       	ld	r31, X
     af8:	18 97       	sbiw	r26, 0x08	; 8
     afa:	c6 81       	ldd	r28, Z+6	; 0x06
     afc:	d7 81       	ldd	r29, Z+7	; 0x07
     afe:	6c e3       	ldi	r22, 0x3C	; 60
     b00:	70 e2       	ldi	r23, 0x20	; 32
     b02:	ce 01       	movw	r24, r28
     b04:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     b08:	66 e0       	ldi	r22, 0x06	; 6
     b0a:	ce 01       	movw	r24, r28
     b0c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	08 95       	ret

00000b16 <_ZN9I2CMaster10StartState11serialDebugEv>:
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	dc 01       	movw	r26, r24
     b1c:	17 96       	adiw	r26, 0x07	; 7
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	18 97       	sbiw	r26, 0x08	; 8
     b24:	c6 81       	ldd	r28, Z+6	; 0x06
     b26:	d7 81       	ldd	r29, Z+7	; 0x07
     b28:	67 e4       	ldi	r22, 0x47	; 71
     b2a:	70 e2       	ldi	r23, 0x20	; 32
     b2c:	ce 01       	movw	r24, r28
     b2e:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     b32:	66 e0       	ldi	r22, 0x06	; 6
     b34:	ce 01       	movw	r24, r28
     b36:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	cf 93       	push	r28
     b48:	df 93       	push	r29
     b4a:	ec 01       	movw	r28, r24
     b4c:	ef 81       	ldd	r30, Y+7	; 0x07
     b4e:	f8 85       	ldd	r31, Y+8	; 0x08
     b50:	a4 81       	ldd	r26, Z+4	; 0x04
     b52:	b5 81       	ldd	r27, Z+5	; 0x05
     b54:	14 96       	adiw	r26, 0x04	; 4
     b56:	fc 90       	ld	r15, X
     b58:	06 81       	ldd	r16, Z+6	; 0x06
     b5a:	17 81       	ldd	r17, Z+7	; 0x07
     b5c:	6d e4       	ldi	r22, 0x4D	; 77
     b5e:	70 e2       	ldi	r23, 0x20	; 32
     b60:	c8 01       	movw	r24, r16
     b62:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     b66:	6f 2d       	mov	r22, r15
     b68:	c8 01       	movw	r24, r16
     b6a:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
     b6e:	66 e0       	ldi	r22, 0x06	; 6
     b70:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     b74:	8a 81       	ldd	r24, Y+2	; 0x02
     b76:	9b 81       	ldd	r25, Y+3	; 0x03
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	ff 90       	pop	r15
     b82:	08 95       	ret

00000b84 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	8c 01       	movw	r16, r24
     b8e:	eb 01       	movw	r28, r22
     b90:	e8 81       	ld	r30, Y
     b92:	f9 81       	ldd	r31, Y+1	; 0x01
     b94:	04 8c       	ldd	r0, Z+28	; 0x1c
     b96:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b98:	e0 2d       	mov	r30, r0
     b9a:	cb 01       	movw	r24, r22
     b9c:	19 95       	eicall
     b9e:	2a 85       	ldd	r18, Y+10	; 0x0a
     ba0:	30 e0       	ldi	r19, 0x00	; 0
     ba2:	82 17       	cp	r24, r18
     ba4:	93 07       	cpc	r25, r19
     ba6:	79 f4       	brne	.+30     	; 0xbc6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     ba8:	d8 01       	movw	r26, r16
     baa:	17 96       	adiw	r26, 0x07	; 7
     bac:	ed 91       	ld	r30, X+
     bae:	fc 91       	ld	r31, X
     bb0:	18 97       	sbiw	r26, 0x08	; 8
     bb2:	04 80       	ldd	r0, Z+4	; 0x04
     bb4:	f5 81       	ldd	r31, Z+5	; 0x05
     bb6:	e0 2d       	mov	r30, r0
     bb8:	87 e0       	ldi	r24, 0x07	; 7
     bba:	83 83       	std	Z+3, r24	; 0x03
     bbc:	12 96       	adiw	r26, 0x02	; 2
     bbe:	8d 91       	ld	r24, X+
     bc0:	9c 91       	ld	r25, X
     bc2:	13 97       	sbiw	r26, 0x03	; 3
     bc4:	0e c0       	rjmp	.+28     	; 0xbe2 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     bc6:	d8 01       	movw	r26, r16
     bc8:	17 96       	adiw	r26, 0x07	; 7
     bca:	ed 91       	ld	r30, X+
     bcc:	fc 91       	ld	r31, X
     bce:	18 97       	sbiw	r26, 0x08	; 8
     bd0:	04 80       	ldd	r0, Z+4	; 0x04
     bd2:	f5 81       	ldd	r31, Z+5	; 0x05
     bd4:	e0 2d       	mov	r30, r0
     bd6:	82 e0       	ldi	r24, 0x02	; 2
     bd8:	83 83       	std	Z+3, r24	; 0x03
     bda:	14 96       	adiw	r26, 0x04	; 4
     bdc:	8d 91       	ld	r24, X+
     bde:	9c 91       	ld	r25, X
     be0:	15 97       	sbiw	r26, 0x05	; 5
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	1f 91       	pop	r17
     be8:	0f 91       	pop	r16
     bea:	08 95       	ret

00000bec <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>:
     bec:	cf 92       	push	r12
     bee:	df 92       	push	r13
     bf0:	ef 92       	push	r14
     bf2:	ff 92       	push	r15
     bf4:	0f 93       	push	r16
     bf6:	1f 93       	push	r17
     bf8:	cf 93       	push	r28
     bfa:	df 93       	push	r29
     bfc:	ec 01       	movw	r28, r24
     bfe:	8b 01       	movw	r16, r22
     c00:	6a 01       	movw	r12, r20
     c02:	68 83       	st	Y, r22
     c04:	79 83       	std	Y+1, r23	; 0x01
     c06:	4a 83       	std	Y+2, r20	; 0x02
     c08:	5b 83       	std	Y+3, r21	; 0x03
     c0a:	8b e0       	ldi	r24, 0x0B	; 11
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     c12:	7c 01       	movw	r14, r24
     c14:	fc 01       	movw	r30, r24
     c16:	16 82       	std	Z+6, r1	; 0x06
     c18:	82 eb       	ldi	r24, 0xB2	; 178
     c1a:	90 e2       	ldi	r25, 0x20	; 32
     c1c:	80 83       	st	Z, r24
     c1e:	91 83       	std	Z+1, r25	; 0x01
     c20:	07 83       	std	Z+7, r16	; 0x07
     c22:	10 87       	std	Z+8, r17	; 0x08
     c24:	c1 86       	std	Z+9, r12	; 0x09
     c26:	d2 86       	std	Z+10, r13	; 0x0a
     c28:	f8 01       	movw	r30, r16
     c2a:	c6 80       	ldd	r12, Z+6	; 0x06
     c2c:	d7 80       	ldd	r13, Z+7	; 0x07
     c2e:	6f e6       	ldi	r22, 0x6F	; 111
     c30:	70 e2       	ldi	r23, 0x20	; 32
     c32:	c6 01       	movw	r24, r12
     c34:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     c38:	b6 01       	movw	r22, r12
     c3a:	c6 01       	movw	r24, r12
     c3c:	0e 94 10 20 	call	0x4020	; 0x4020 <_ZN8emstreamlsEPv>
     c40:	66 e0       	ldi	r22, 0x06	; 6
     c42:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     c46:	ee 82       	std	Y+6, r14	; 0x06
     c48:	ff 82       	std	Y+7, r15	; 0x07
     c4a:	8b e0       	ldi	r24, 0x0B	; 11
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     c52:	fc 01       	movw	r30, r24
     c54:	8d 89       	ldd	r24, Y+21	; 0x15
     c56:	9e 89       	ldd	r25, Y+22	; 0x16
     c58:	16 82       	std	Z+6, r1	; 0x06
     c5a:	2a eb       	ldi	r18, 0xBA	; 186
     c5c:	30 e2       	ldi	r19, 0x20	; 32
     c5e:	20 83       	st	Z, r18
     c60:	31 83       	std	Z+1, r19	; 0x01
     c62:	07 83       	std	Z+7, r16	; 0x07
     c64:	10 87       	std	Z+8, r17	; 0x08
     c66:	81 87       	std	Z+9, r24	; 0x09
     c68:	92 87       	std	Z+10, r25	; 0x0a
     c6a:	e8 87       	std	Y+8, r30	; 0x08
     c6c:	f9 87       	std	Y+9, r31	; 0x09
     c6e:	89 e0       	ldi	r24, 0x09	; 9
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     c76:	fc 01       	movw	r30, r24
     c78:	16 82       	std	Z+6, r1	; 0x06
     c7a:	8a ec       	ldi	r24, 0xCA	; 202
     c7c:	90 e2       	ldi	r25, 0x20	; 32
     c7e:	80 83       	st	Z, r24
     c80:	91 83       	std	Z+1, r25	; 0x01
     c82:	07 83       	std	Z+7, r16	; 0x07
     c84:	10 87       	std	Z+8, r17	; 0x08
     c86:	ea 87       	std	Y+10, r30	; 0x0a
     c88:	fb 87       	std	Y+11, r31	; 0x0b
     c8a:	89 e0       	ldi	r24, 0x09	; 9
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     c92:	fc 01       	movw	r30, r24
     c94:	16 82       	std	Z+6, r1	; 0x06
     c96:	8a ed       	ldi	r24, 0xDA	; 218
     c98:	90 e2       	ldi	r25, 0x20	; 32
     c9a:	80 83       	st	Z, r24
     c9c:	91 83       	std	Z+1, r25	; 0x01
     c9e:	07 83       	std	Z+7, r16	; 0x07
     ca0:	10 87       	std	Z+8, r17	; 0x08
     ca2:	ec 87       	std	Y+12, r30	; 0x0c
     ca4:	fd 87       	std	Y+13, r31	; 0x0d
     ca6:	89 e0       	ldi	r24, 0x09	; 9
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     cae:	fc 01       	movw	r30, r24
     cb0:	16 82       	std	Z+6, r1	; 0x06
     cb2:	82 ef       	ldi	r24, 0xF2	; 242
     cb4:	90 e2       	ldi	r25, 0x20	; 32
     cb6:	80 83       	st	Z, r24
     cb8:	91 83       	std	Z+1, r25	; 0x01
     cba:	07 83       	std	Z+7, r16	; 0x07
     cbc:	10 87       	std	Z+8, r17	; 0x08
     cbe:	ee 87       	std	Y+14, r30	; 0x0e
     cc0:	ff 87       	std	Y+15, r31	; 0x0f
     cc2:	89 e0       	ldi	r24, 0x09	; 9
     cc4:	90 e0       	ldi	r25, 0x00	; 0
     cc6:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     cca:	fc 01       	movw	r30, r24
     ccc:	16 82       	std	Z+6, r1	; 0x06
     cce:	8a ee       	ldi	r24, 0xEA	; 234
     cd0:	90 e2       	ldi	r25, 0x20	; 32
     cd2:	80 83       	st	Z, r24
     cd4:	91 83       	std	Z+1, r25	; 0x01
     cd6:	07 83       	std	Z+7, r16	; 0x07
     cd8:	10 87       	std	Z+8, r17	; 0x08
     cda:	e8 8b       	std	Y+16, r30	; 0x10
     cdc:	f9 8b       	std	Y+17, r31	; 0x11
     cde:	80 e1       	ldi	r24, 0x10	; 16
     ce0:	97 e2       	ldi	r25, 0x27	; 39
     ce2:	8d 8b       	std	Y+21, r24	; 0x15
     ce4:	9e 8b       	std	Y+22, r25	; 0x16
     ce6:	88 85       	ldd	r24, Y+8	; 0x08
     ce8:	99 85       	ldd	r25, Y+9	; 0x09
     cea:	ee 81       	ldd	r30, Y+6	; 0x06
     cec:	ff 81       	ldd	r31, Y+7	; 0x07
     cee:	82 83       	std	Z+2, r24	; 0x02
     cf0:	93 83       	std	Z+3, r25	; 0x03
     cf2:	84 83       	std	Z+4, r24	; 0x04
     cf4:	95 83       	std	Z+5, r25	; 0x05
     cf6:	8e 85       	ldd	r24, Y+14	; 0x0e
     cf8:	9f 85       	ldd	r25, Y+15	; 0x0f
     cfa:	2a 85       	ldd	r18, Y+10	; 0x0a
     cfc:	3b 85       	ldd	r19, Y+11	; 0x0b
     cfe:	e8 85       	ldd	r30, Y+8	; 0x08
     d00:	f9 85       	ldd	r31, Y+9	; 0x09
     d02:	22 83       	std	Z+2, r18	; 0x02
     d04:	33 83       	std	Z+3, r19	; 0x03
     d06:	84 83       	std	Z+4, r24	; 0x04
     d08:	95 83       	std	Z+5, r25	; 0x05
     d0a:	8c 85       	ldd	r24, Y+12	; 0x0c
     d0c:	9d 85       	ldd	r25, Y+13	; 0x0d
     d0e:	ea 85       	ldd	r30, Y+10	; 0x0a
     d10:	fb 85       	ldd	r31, Y+11	; 0x0b
     d12:	82 83       	std	Z+2, r24	; 0x02
     d14:	93 83       	std	Z+3, r25	; 0x03
     d16:	84 83       	std	Z+4, r24	; 0x04
     d18:	95 83       	std	Z+5, r25	; 0x05
     d1a:	88 85       	ldd	r24, Y+8	; 0x08
     d1c:	99 85       	ldd	r25, Y+9	; 0x09
     d1e:	28 89       	ldd	r18, Y+16	; 0x10
     d20:	39 89       	ldd	r19, Y+17	; 0x11
     d22:	ec 85       	ldd	r30, Y+12	; 0x0c
     d24:	fd 85       	ldd	r31, Y+13	; 0x0d
     d26:	22 83       	std	Z+2, r18	; 0x02
     d28:	33 83       	std	Z+3, r19	; 0x03
     d2a:	84 83       	std	Z+4, r24	; 0x04
     d2c:	95 83       	std	Z+5, r25	; 0x05
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	df 90       	pop	r13
     d3c:	cf 90       	pop	r12
     d3e:	08 95       	ret

00000d40 <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>:
     d40:	cf 92       	push	r12
     d42:	df 92       	push	r13
     d44:	ef 92       	push	r14
     d46:	ff 92       	push	r15
     d48:	0f 93       	push	r16
     d4a:	1f 93       	push	r17
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	ec 01       	movw	r28, r24
     d52:	8b 01       	movw	r16, r22
     d54:	6a 01       	movw	r12, r20
     d56:	68 83       	st	Y, r22
     d58:	79 83       	std	Y+1, r23	; 0x01
     d5a:	4a 83       	std	Y+2, r20	; 0x02
     d5c:	5b 83       	std	Y+3, r21	; 0x03
     d5e:	8b e0       	ldi	r24, 0x0B	; 11
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     d66:	7c 01       	movw	r14, r24
     d68:	fc 01       	movw	r30, r24
     d6a:	16 82       	std	Z+6, r1	; 0x06
     d6c:	82 eb       	ldi	r24, 0xB2	; 178
     d6e:	90 e2       	ldi	r25, 0x20	; 32
     d70:	80 83       	st	Z, r24
     d72:	91 83       	std	Z+1, r25	; 0x01
     d74:	07 83       	std	Z+7, r16	; 0x07
     d76:	10 87       	std	Z+8, r17	; 0x08
     d78:	c1 86       	std	Z+9, r12	; 0x09
     d7a:	d2 86       	std	Z+10, r13	; 0x0a
     d7c:	f8 01       	movw	r30, r16
     d7e:	c6 80       	ldd	r12, Z+6	; 0x06
     d80:	d7 80       	ldd	r13, Z+7	; 0x07
     d82:	6f e6       	ldi	r22, 0x6F	; 111
     d84:	70 e2       	ldi	r23, 0x20	; 32
     d86:	c6 01       	movw	r24, r12
     d88:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
     d8c:	b6 01       	movw	r22, r12
     d8e:	c6 01       	movw	r24, r12
     d90:	0e 94 10 20 	call	0x4020	; 0x4020 <_ZN8emstreamlsEPv>
     d94:	66 e0       	ldi	r22, 0x06	; 6
     d96:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
     d9a:	ee 82       	std	Y+6, r14	; 0x06
     d9c:	ff 82       	std	Y+7, r15	; 0x07
     d9e:	8b e0       	ldi	r24, 0x0B	; 11
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     da6:	fc 01       	movw	r30, r24
     da8:	8d 89       	ldd	r24, Y+21	; 0x15
     daa:	9e 89       	ldd	r25, Y+22	; 0x16
     dac:	16 82       	std	Z+6, r1	; 0x06
     dae:	22 ec       	ldi	r18, 0xC2	; 194
     db0:	30 e2       	ldi	r19, 0x20	; 32
     db2:	20 83       	st	Z, r18
     db4:	31 83       	std	Z+1, r19	; 0x01
     db6:	07 83       	std	Z+7, r16	; 0x07
     db8:	10 87       	std	Z+8, r17	; 0x08
     dba:	81 87       	std	Z+9, r24	; 0x09
     dbc:	92 87       	std	Z+10, r25	; 0x0a
     dbe:	e8 87       	std	Y+8, r30	; 0x08
     dc0:	f9 87       	std	Y+9, r31	; 0x09
     dc2:	89 e0       	ldi	r24, 0x09	; 9
     dc4:	90 e0       	ldi	r25, 0x00	; 0
     dc6:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     dca:	fc 01       	movw	r30, r24
     dcc:	16 82       	std	Z+6, r1	; 0x06
     dce:	82 ed       	ldi	r24, 0xD2	; 210
     dd0:	90 e2       	ldi	r25, 0x20	; 32
     dd2:	80 83       	st	Z, r24
     dd4:	91 83       	std	Z+1, r25	; 0x01
     dd6:	07 83       	std	Z+7, r16	; 0x07
     dd8:	10 87       	std	Z+8, r17	; 0x08
     dda:	ea 87       	std	Y+10, r30	; 0x0a
     ddc:	fb 87       	std	Y+11, r31	; 0x0b
     dde:	89 e0       	ldi	r24, 0x09	; 9
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     de6:	fc 01       	movw	r30, r24
     de8:	16 82       	std	Z+6, r1	; 0x06
     dea:	82 ee       	ldi	r24, 0xE2	; 226
     dec:	90 e2       	ldi	r25, 0x20	; 32
     dee:	80 83       	st	Z, r24
     df0:	91 83       	std	Z+1, r25	; 0x01
     df2:	07 83       	std	Z+7, r16	; 0x07
     df4:	10 87       	std	Z+8, r17	; 0x08
     df6:	ec 87       	std	Y+12, r30	; 0x0c
     df8:	fd 87       	std	Y+13, r31	; 0x0d
     dfa:	89 e0       	ldi	r24, 0x09	; 9
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     e02:	fc 01       	movw	r30, r24
     e04:	16 82       	std	Z+6, r1	; 0x06
     e06:	82 ef       	ldi	r24, 0xF2	; 242
     e08:	90 e2       	ldi	r25, 0x20	; 32
     e0a:	80 83       	st	Z, r24
     e0c:	91 83       	std	Z+1, r25	; 0x01
     e0e:	07 83       	std	Z+7, r16	; 0x07
     e10:	10 87       	std	Z+8, r17	; 0x08
     e12:	ee 87       	std	Y+14, r30	; 0x0e
     e14:	ff 87       	std	Y+15, r31	; 0x0f
     e16:	89 e0       	ldi	r24, 0x09	; 9
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
     e1e:	fc 01       	movw	r30, r24
     e20:	16 82       	std	Z+6, r1	; 0x06
     e22:	8a ee       	ldi	r24, 0xEA	; 234
     e24:	90 e2       	ldi	r25, 0x20	; 32
     e26:	80 83       	st	Z, r24
     e28:	91 83       	std	Z+1, r25	; 0x01
     e2a:	07 83       	std	Z+7, r16	; 0x07
     e2c:	10 87       	std	Z+8, r17	; 0x08
     e2e:	e8 8b       	std	Y+16, r30	; 0x10
     e30:	f9 8b       	std	Y+17, r31	; 0x11
     e32:	80 e1       	ldi	r24, 0x10	; 16
     e34:	97 e2       	ldi	r25, 0x27	; 39
     e36:	8d 8b       	std	Y+21, r24	; 0x15
     e38:	9e 8b       	std	Y+22, r25	; 0x16
     e3a:	88 85       	ldd	r24, Y+8	; 0x08
     e3c:	99 85       	ldd	r25, Y+9	; 0x09
     e3e:	ee 81       	ldd	r30, Y+6	; 0x06
     e40:	ff 81       	ldd	r31, Y+7	; 0x07
     e42:	82 83       	std	Z+2, r24	; 0x02
     e44:	93 83       	std	Z+3, r25	; 0x03
     e46:	84 83       	std	Z+4, r24	; 0x04
     e48:	95 83       	std	Z+5, r25	; 0x05
     e4a:	8e 85       	ldd	r24, Y+14	; 0x0e
     e4c:	9f 85       	ldd	r25, Y+15	; 0x0f
     e4e:	2a 85       	ldd	r18, Y+10	; 0x0a
     e50:	3b 85       	ldd	r19, Y+11	; 0x0b
     e52:	e8 85       	ldd	r30, Y+8	; 0x08
     e54:	f9 85       	ldd	r31, Y+9	; 0x09
     e56:	22 83       	std	Z+2, r18	; 0x02
     e58:	33 83       	std	Z+3, r19	; 0x03
     e5a:	84 83       	std	Z+4, r24	; 0x04
     e5c:	95 83       	std	Z+5, r25	; 0x05
     e5e:	8c 85       	ldd	r24, Y+12	; 0x0c
     e60:	9d 85       	ldd	r25, Y+13	; 0x0d
     e62:	ea 85       	ldd	r30, Y+10	; 0x0a
     e64:	fb 85       	ldd	r31, Y+11	; 0x0b
     e66:	82 83       	std	Z+2, r24	; 0x02
     e68:	93 83       	std	Z+3, r25	; 0x03
     e6a:	84 83       	std	Z+4, r24	; 0x04
     e6c:	95 83       	std	Z+5, r25	; 0x05
     e6e:	88 85       	ldd	r24, Y+8	; 0x08
     e70:	99 85       	ldd	r25, Y+9	; 0x09
     e72:	28 89       	ldd	r18, Y+16	; 0x10
     e74:	39 89       	ldd	r19, Y+17	; 0x11
     e76:	ec 85       	ldd	r30, Y+12	; 0x0c
     e78:	fd 85       	ldd	r31, Y+13	; 0x0d
     e7a:	22 83       	std	Z+2, r18	; 0x02
     e7c:	33 83       	std	Z+3, r19	; 0x03
     e7e:	84 83       	std	Z+4, r24	; 0x04
     e80:	95 83       	std	Z+5, r25	; 0x05
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	1f 91       	pop	r17
     e88:	0f 91       	pop	r16
     e8a:	ff 90       	pop	r15
     e8c:	ef 90       	pop	r14
     e8e:	df 90       	pop	r13
     e90:	cf 90       	pop	r12
     e92:	08 95       	ret

00000e94 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	ec 01       	movw	r28, r24
     e9e:	8b 01       	movw	r16, r22
     ea0:	8e 81       	ldd	r24, Y+6	; 0x06
     ea2:	9f 81       	ldd	r25, Y+7	; 0x07
     ea4:	8c 83       	std	Y+4, r24	; 0x04
     ea6:	9d 83       	std	Y+5, r25	; 0x05
     ea8:	28 89       	ldd	r18, Y+16	; 0x10
     eaa:	39 89       	ldd	r19, Y+17	; 0x11
     eac:	82 17       	cp	r24, r18
     eae:	93 07       	cpc	r25, r19
     eb0:	d9 f0       	breq	.+54     	; 0xee8 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     eb2:	2e 85       	ldd	r18, Y+14	; 0x0e
     eb4:	3f 85       	ldd	r19, Y+15	; 0x0f
     eb6:	82 17       	cp	r24, r18
     eb8:	93 07       	cpc	r25, r19
     eba:	31 f4       	brne	.+12     	; 0xec8 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     ebc:	17 c0       	rjmp	.+46     	; 0xeec <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     ebe:	2e 85       	ldd	r18, Y+14	; 0x0e
     ec0:	3f 85       	ldd	r19, Y+15	; 0x0f
     ec2:	28 17       	cp	r18, r24
     ec4:	39 07       	cpc	r19, r25
     ec6:	99 f0       	breq	.+38     	; 0xeee <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     ec8:	dc 01       	movw	r26, r24
     eca:	ed 91       	ld	r30, X+
     ecc:	fc 91       	ld	r31, X
     ece:	01 90       	ld	r0, Z+
     ed0:	f0 81       	ld	r31, Z
     ed2:	e0 2d       	mov	r30, r0
     ed4:	b8 01       	movw	r22, r16
     ed6:	19 95       	eicall
     ed8:	8c 83       	std	Y+4, r24	; 0x04
     eda:	9d 83       	std	Y+5, r25	; 0x05
     edc:	28 89       	ldd	r18, Y+16	; 0x10
     ede:	39 89       	ldd	r19, Y+17	; 0x11
     ee0:	28 17       	cp	r18, r24
     ee2:	39 07       	cpc	r19, r25
     ee4:	61 f7       	brne	.-40     	; 0xebe <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     ee6:	03 c0       	rjmp	.+6      	; 0xeee <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     ee8:	c9 01       	movw	r24, r18
     eea:	01 c0       	rjmp	.+2      	; 0xeee <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     eec:	c9 01       	movw	r24, r18
     eee:	dc 01       	movw	r26, r24
     ef0:	ed 91       	ld	r30, X+
     ef2:	fc 91       	ld	r31, X
     ef4:	01 90       	ld	r0, Z+
     ef6:	f0 81       	ld	r31, Z
     ef8:	e0 2d       	mov	r30, r0
     efa:	b8 01       	movw	r22, r16
     efc:	19 95       	eicall
     efe:	81 e0       	ldi	r24, 0x01	; 1
     f00:	4c 81       	ldd	r20, Y+4	; 0x04
     f02:	5d 81       	ldd	r21, Y+5	; 0x05
     f04:	28 89       	ldd	r18, Y+16	; 0x10
     f06:	39 89       	ldd	r19, Y+17	; 0x11
     f08:	42 17       	cp	r20, r18
     f0a:	53 07       	cpc	r21, r19
     f0c:	09 f0       	breq	.+2      	; 0xf10 <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     f0e:	80 e0       	ldi	r24, 0x00	; 0
     f10:	df 91       	pop	r29
     f12:	cf 91       	pop	r28
     f14:	1f 91       	pop	r17
     f16:	0f 91       	pop	r16
     f18:	08 95       	ret

00000f1a <_ZN9I2CMaster8Receiver3runER6Packet>:
     f1a:	0f 93       	push	r16
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	8b 01       	movw	r16, r22
     f26:	8e 81       	ldd	r24, Y+6	; 0x06
     f28:	9f 81       	ldd	r25, Y+7	; 0x07
     f2a:	8c 83       	std	Y+4, r24	; 0x04
     f2c:	9d 83       	std	Y+5, r25	; 0x05
     f2e:	28 89       	ldd	r18, Y+16	; 0x10
     f30:	39 89       	ldd	r19, Y+17	; 0x11
     f32:	82 17       	cp	r24, r18
     f34:	93 07       	cpc	r25, r19
     f36:	d9 f0       	breq	.+54     	; 0xf6e <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     f38:	2e 85       	ldd	r18, Y+14	; 0x0e
     f3a:	3f 85       	ldd	r19, Y+15	; 0x0f
     f3c:	82 17       	cp	r24, r18
     f3e:	93 07       	cpc	r25, r19
     f40:	31 f4       	brne	.+12     	; 0xf4e <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     f42:	17 c0       	rjmp	.+46     	; 0xf72 <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     f44:	2e 85       	ldd	r18, Y+14	; 0x0e
     f46:	3f 85       	ldd	r19, Y+15	; 0x0f
     f48:	28 17       	cp	r18, r24
     f4a:	39 07       	cpc	r19, r25
     f4c:	99 f0       	breq	.+38     	; 0xf74 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f4e:	dc 01       	movw	r26, r24
     f50:	ed 91       	ld	r30, X+
     f52:	fc 91       	ld	r31, X
     f54:	01 90       	ld	r0, Z+
     f56:	f0 81       	ld	r31, Z
     f58:	e0 2d       	mov	r30, r0
     f5a:	b8 01       	movw	r22, r16
     f5c:	19 95       	eicall
     f5e:	8c 83       	std	Y+4, r24	; 0x04
     f60:	9d 83       	std	Y+5, r25	; 0x05
     f62:	28 89       	ldd	r18, Y+16	; 0x10
     f64:	39 89       	ldd	r19, Y+17	; 0x11
     f66:	28 17       	cp	r18, r24
     f68:	39 07       	cpc	r19, r25
     f6a:	61 f7       	brne	.-40     	; 0xf44 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     f6c:	03 c0       	rjmp	.+6      	; 0xf74 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f6e:	c9 01       	movw	r24, r18
     f70:	01 c0       	rjmp	.+2      	; 0xf74 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f72:	c9 01       	movw	r24, r18
     f74:	dc 01       	movw	r26, r24
     f76:	ed 91       	ld	r30, X+
     f78:	fc 91       	ld	r31, X
     f7a:	01 90       	ld	r0, Z+
     f7c:	f0 81       	ld	r31, Z
     f7e:	e0 2d       	mov	r30, r0
     f80:	b8 01       	movw	r22, r16
     f82:	19 95       	eicall
     f84:	c8 01       	movw	r24, r16
     f86:	df 91       	pop	r29
     f88:	cf 91       	pop	r28
     f8a:	1f 91       	pop	r17
     f8c:	0f 91       	pop	r16
     f8e:	08 95       	ret

00000f90 <_ZN9I2CMaster12set_baudrateEm>:
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	ec 01       	movw	r28, r24
     f96:	9a 01       	movw	r18, r20
     f98:	ab 01       	movw	r20, r22
     f9a:	22 0f       	add	r18, r18
     f9c:	33 1f       	adc	r19, r19
     f9e:	44 1f       	adc	r20, r20
     fa0:	55 1f       	adc	r21, r21
     fa2:	60 e0       	ldi	r22, 0x00	; 0
     fa4:	78 e4       	ldi	r23, 0x48	; 72
     fa6:	88 ee       	ldi	r24, 0xE8	; 232
     fa8:	91 e0       	ldi	r25, 0x01	; 1
     faa:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
     fae:	25 50       	subi	r18, 0x05	; 5
     fb0:	2a 87       	std	Y+10, r18	; 0x0a
     fb2:	ec 81       	ldd	r30, Y+4	; 0x04
     fb4:	fd 81       	ldd	r31, Y+5	; 0x05
     fb6:	25 83       	std	Z+5, r18	; 0x05
     fb8:	df 91       	pop	r29
     fba:	cf 91       	pop	r28
     fbc:	08 95       	ret

00000fbe <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
     fbe:	dc 01       	movw	r26, r24
     fc0:	14 96       	adiw	r26, 0x04	; 4
     fc2:	ed 91       	ld	r30, X+
     fc4:	fc 91       	ld	r31, X
     fc6:	15 97       	sbiw	r26, 0x05	; 5
     fc8:	83 81       	ldd	r24, Z+3	; 0x03
     fca:	81 60       	ori	r24, 0x01	; 1
     fcc:	83 83       	std	Z+3, r24	; 0x03
     fce:	08 95       	ret

00000fd0 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     fd0:	0f 93       	push	r16
     fd2:	1f 93       	push	r17
     fd4:	cf 93       	push	r28
     fd6:	df 93       	push	r29
     fd8:	ec 01       	movw	r28, r24
     fda:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
     fdc:	db 01       	movw	r26, r22
     fde:	ed 91       	ld	r30, X+
     fe0:	fc 91       	ld	r31, X
     fe2:	02 84       	ldd	r0, Z+10	; 0x0a
     fe4:	f3 85       	ldd	r31, Z+11	; 0x0b
     fe6:	e0 2d       	mov	r30, r0
     fe8:	00 e0       	ldi	r16, 0x00	; 0
     fea:	10 e0       	ldi	r17, 0x00	; 0
     fec:	b8 01       	movw	r22, r16
     fee:	19 95       	eicall
  driver_->send_start();
     ff0:	8f 81       	ldd	r24, Y+7	; 0x07
     ff2:	98 85       	ldd	r25, Y+8	; 0x08
     ff4:	0e 94 df 07 	call	0xfbe	; 0xfbe <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
     ff8:	ef 81       	ldd	r30, Y+7	; 0x07
     ffa:	f8 85       	ldd	r31, Y+8	; 0x08
     ffc:	04 80       	ldd	r0, Z+4	; 0x04
     ffe:	f5 81       	ldd	r31, Z+5	; 0x05
    1000:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1002:	d8 01       	movw	r26, r16
    1004:	8c 91       	ld	r24, X
    1006:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    1008:	8a 81       	ldd	r24, Y+2	; 0x02
    100a:	9b 81       	ldd	r25, Y+3	; 0x03
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	1f 91       	pop	r17
    1012:	0f 91       	pop	r16
    1014:	08 95       	ret

00001016 <_ZN9I2CMaster8is_readyEh>:
  
  return addr_list;
}

bool I2CMaster::is_ready (uint8_t addr)
{
    1016:	ff 92       	push	r15
    1018:	0f 93       	push	r16
    101a:	1f 93       	push	r17
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	1f 92       	push	r1
    1022:	1f 92       	push	r1
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
    1028:	8c 01       	movw	r16, r24
    102a:	f6 2e       	mov	r15, r22
  volatile uint16_t counter = 500;
    102c:	84 ef       	ldi	r24, 0xF4	; 244
    102e:	91 e0       	ldi	r25, 0x01	; 1
    1030:	89 83       	std	Y+1, r24	; 0x01
    1032:	9a 83       	std	Y+2, r25	; 0x02
  send_start();
    1034:	c8 01       	movw	r24, r16
    1036:	0e 94 df 07 	call	0xfbe	; 0xfbe <_ZN9I2CMaster10send_startEv>
  interface_->MASTER.ADDR = addr << 1;
    103a:	d8 01       	movw	r26, r16
    103c:	14 96       	adiw	r26, 0x04	; 4
    103e:	ed 91       	ld	r30, X+
    1040:	fc 91       	ld	r31, X
    1042:	15 97       	sbiw	r26, 0x05	; 5
    1044:	ff 0c       	add	r15, r15
    1046:	f6 82       	std	Z+6, r15	; 0x06
  
  while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    1048:	89 81       	ldd	r24, Y+1	; 0x01
    104a:	9a 81       	ldd	r25, Y+2	; 0x02
    104c:	01 97       	sbiw	r24, 0x01	; 1
    104e:	89 83       	std	Y+1, r24	; 0x01
    1050:	9a 83       	std	Y+2, r25	; 0x02
    1052:	89 2b       	or	r24, r25
    1054:	41 f0       	breq	.+16     	; 0x1066 <_ZN9I2CMaster8is_readyEh+0x50>
    1056:	d8 01       	movw	r26, r16
    1058:	14 96       	adiw	r26, 0x04	; 4
    105a:	ed 91       	ld	r30, X+
    105c:	fc 91       	ld	r31, X
    105e:	15 97       	sbiw	r26, 0x05	; 5
    1060:	84 81       	ldd	r24, Z+4	; 0x04
    1062:	84 fd       	sbrc	r24, 4
    1064:	f1 cf       	rjmp	.-30     	; 0x1048 <_ZN9I2CMaster8is_readyEh+0x32>
  if(counter != 0)
    1066:	29 81       	ldd	r18, Y+1	; 0x01
    1068:	3a 81       	ldd	r19, Y+2	; 0x02
    106a:	81 e0       	ldi	r24, 0x01	; 1
    106c:	23 2b       	or	r18, r19
    106e:	09 f4       	brne	.+2      	; 0x1072 <_ZN9I2CMaster8is_readyEh+0x5c>
    1070:	80 e0       	ldi	r24, 0x00	; 0
  else
  {
    return false;
  }
  send_nack_stop();
}
    1072:	0f 90       	pop	r0
    1074:	0f 90       	pop	r0
    1076:	df 91       	pop	r29
    1078:	cf 91       	pop	r28
    107a:	1f 91       	pop	r17
    107c:	0f 91       	pop	r16
    107e:	ff 90       	pop	r15
    1080:	08 95       	ret

00001082 <_ZN9I2CMaster4scanEv>:
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
  interface_->MASTER.BAUD = baudrate;
}

uint8_t* I2CMaster::scan (void)
{
    1082:	8f 92       	push	r8
    1084:	9f 92       	push	r9
    1086:	af 92       	push	r10
    1088:	bf 92       	push	r11
    108a:	cf 92       	push	r12
    108c:	df 92       	push	r13
    108e:	ef 92       	push	r14
    1090:	ff 92       	push	r15
    1092:	0f 93       	push	r16
    1094:	1f 93       	push	r17
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	1f 92       	push	r1
    109c:	1f 92       	push	r1
    109e:	cd b7       	in	r28, 0x3d	; 61
    10a0:	de b7       	in	r29, 0x3e	; 62
    10a2:	8c 01       	movw	r16, r24
    10a4:	dd 24       	eor	r13, r13
    10a6:	d3 94       	inc	r13
    10a8:	b1 2c       	mov	r11, r1
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    10aa:	0f 2e       	mov	r0, r31
    10ac:	f4 e6       	ldi	r31, 0x64	; 100
    10ae:	ef 2e       	mov	r14, r31
    10b0:	f1 2c       	mov	r15, r1
    10b2:	f0 2d       	mov	r31, r0
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    10b4:	0f 2e       	mov	r0, r31
    10b6:	f7 e0       	ldi	r31, 0x07	; 7
    10b8:	cf 2e       	mov	r12, r31
    10ba:	f0 2d       	mov	r31, r0
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    10bc:	e9 82       	std	Y+1, r14	; 0x01
    10be:	fa 82       	std	Y+2, r15	; 0x02
    send_start();
    10c0:	c8 01       	movw	r24, r16
    10c2:	0e 94 df 07 	call	0xfbe	; 0xfbe <_ZN9I2CMaster10send_startEv>
    interface_->MASTER.ADDR = addr << 1;
    10c6:	d8 01       	movw	r26, r16
    10c8:	14 96       	adiw	r26, 0x04	; 4
    10ca:	ed 91       	ld	r30, X+
    10cc:	fc 91       	ld	r31, X
    10ce:	15 97       	sbiw	r26, 0x05	; 5
    10d0:	8d 2d       	mov	r24, r13
    10d2:	88 0f       	add	r24, r24
    10d4:	86 83       	std	Z+6, r24	; 0x06
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    10d6:	89 81       	ldd	r24, Y+1	; 0x01
    10d8:	9a 81       	ldd	r25, Y+2	; 0x02
    10da:	01 97       	sbiw	r24, 0x01	; 1
    10dc:	89 83       	std	Y+1, r24	; 0x01
    10de:	9a 83       	std	Y+2, r25	; 0x02
    10e0:	89 2b       	or	r24, r25
    10e2:	89 f1       	breq	.+98     	; 0x1146 <_ZN9I2CMaster4scanEv+0xc4>
    10e4:	d8 01       	movw	r26, r16
    10e6:	14 96       	adiw	r26, 0x04	; 4
    10e8:	ed 91       	ld	r30, X+
    10ea:	fc 91       	ld	r31, X
    10ec:	15 97       	sbiw	r26, 0x05	; 5
    10ee:	84 81       	ldd	r24, Z+4	; 0x04
    10f0:	84 fd       	sbrc	r24, 4
    10f2:	f1 cf       	rjmp	.-30     	; 0x10d6 <_ZN9I2CMaster4scanEv+0x54>
    10f4:	28 c0       	rjmp	.+80     	; 0x1146 <_ZN9I2CMaster4scanEv+0xc4>
    if(counter != 0)
    {
      uint8_t addr_reg = interface_->MASTER.ADDR;
    10f6:	d8 01       	movw	r26, r16
    10f8:	14 96       	adiw	r26, 0x04	; 4
    10fa:	ed 91       	ld	r30, X+
    10fc:	fc 91       	ld	r31, X
    10fe:	15 97       	sbiw	r26, 0x05	; 5
    1100:	a6 80       	ldd	r10, Z+6	; 0x06
      *p_serial << "Detected i2c addr: " << addr_reg << endl;
    1102:	16 96       	adiw	r26, 0x06	; 6
    1104:	8d 90       	ld	r8, X+
    1106:	9c 90       	ld	r9, X
    1108:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    110a:	68 e8       	ldi	r22, 0x88	; 136
    110c:	70 e2       	ldi	r23, 0x20	; 32
    110e:	c4 01       	movw	r24, r8
    1110:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1114:	6a 2d       	mov	r22, r10
    1116:	c4 01       	movw	r24, r8
    1118:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    111c:	66 e0       	ldi	r22, 0x06	; 6
    111e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
      addr_list[addr_list_index] = addr;
    1122:	f8 01       	movw	r30, r16
    1124:	eb 0d       	add	r30, r11
    1126:	f1 1d       	adc	r31, r1
    1128:	d7 86       	std	Z+15, r13	; 0x0f
      addr_list_index++;
    112a:	b3 94       	inc	r11
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    112c:	d8 01       	movw	r26, r16
    112e:	14 96       	adiw	r26, 0x04	; 4
    1130:	ed 91       	ld	r30, X+
    1132:	fc 91       	ld	r31, X
    1134:	15 97       	sbiw	r26, 0x05	; 5
    1136:	c3 82       	std	Z+3, r12	; 0x03
  volatile uint16_t counter;
  
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
    1138:	d3 94       	inc	r13
    113a:	b0 e8       	ldi	r27, 0x80	; 128
    113c:	db 12       	cpse	r13, r27
    113e:	be cf       	rjmp	.-132    	; 0x10bc <_ZN9I2CMaster4scanEv+0x3a>

    send_nack_stop();
      
  }
  
  return addr_list;
    1140:	c8 01       	movw	r24, r16
    1142:	0f 96       	adiw	r24, 0x0f	; 15
    1144:	05 c0       	rjmp	.+10     	; 0x1150 <_ZN9I2CMaster4scanEv+0xce>
    counter = 100;
    send_start();
    interface_->MASTER.ADDR = addr << 1;
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    if(counter != 0)
    1146:	89 81       	ldd	r24, Y+1	; 0x01
    1148:	9a 81       	ldd	r25, Y+2	; 0x02
    114a:	89 2b       	or	r24, r25
    114c:	79 f3       	breq	.-34     	; 0x112c <_ZN9I2CMaster4scanEv+0xaa>
    114e:	d3 cf       	rjmp	.-90     	; 0x10f6 <_ZN9I2CMaster4scanEv+0x74>
    send_nack_stop();
      
  }
  
  return addr_list;
}
    1150:	0f 90       	pop	r0
    1152:	0f 90       	pop	r0
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	ff 90       	pop	r15
    115e:	ef 90       	pop	r14
    1160:	df 90       	pop	r13
    1162:	cf 90       	pop	r12
    1164:	bf 90       	pop	r11
    1166:	af 90       	pop	r10
    1168:	9f 90       	pop	r9
    116a:	8f 90       	pop	r8
    116c:	08 95       	ret

0000116e <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
//   interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

//   interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
// }

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s)
    116e:	ef 92       	push	r14
    1170:	ff 92       	push	r15
    1172:	0f 93       	push	r16
    1174:	1f 93       	push	r17
    1176:	cf 93       	push	r28
    1178:	df 93       	push	r29
    117a:	ec 01       	movw	r28, r24
    117c:	7b 01       	movw	r14, r22
    117e:	ba 01       	movw	r22, r20
    1180:	a9 01       	movw	r20, r18
  : interface_(interface), 
    i2c_freq(i2c_freq),
    p_serial(s)
    1182:	ec 82       	std	Y+4, r14	; 0x04
    1184:	fd 82       	std	Y+5, r15	; 0x05
    1186:	0e 83       	std	Y+6, r16	; 0x06
    1188:	1f 83       	std	Y+7, r17	; 0x07
    118a:	4b 87       	std	Y+11, r20	; 0x0b
    118c:	5c 87       	std	Y+12, r21	; 0x0c
    118e:	6d 87       	std	Y+13, r22	; 0x0d
    1190:	7e 87       	std	Y+14, r23	; 0x0e
{ 
  if (interface == &TWIC)
    1192:	80 e8       	ldi	r24, 0x80	; 128
    1194:	e8 16       	cp	r14, r24
    1196:	84 e0       	ldi	r24, 0x04	; 4
    1198:	f8 06       	cpc	r15, r24
    119a:	29 f4       	brne	.+10     	; 0x11a6 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
  {
    bus_port = &PORTC;
    119c:	80 e4       	ldi	r24, 0x40	; 64
    119e:	96 e0       	ldi	r25, 0x06	; 6
    11a0:	88 87       	std	Y+8, r24	; 0x08
    11a2:	99 87       	std	Y+9, r25	; 0x09
    11a4:	09 c0       	rjmp	.+18     	; 0x11b8 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  }
  if (interface == &TWIE)
    11a6:	e0 ea       	ldi	r30, 0xA0	; 160
    11a8:	ee 16       	cp	r14, r30
    11aa:	e4 e0       	ldi	r30, 0x04	; 4
    11ac:	fe 06       	cpc	r15, r30
    11ae:	21 f4       	brne	.+8      	; 0x11b8 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  {
    bus_port = &PORTE;
    11b0:	80 e8       	ldi	r24, 0x80	; 128
    11b2:	96 e0       	ldi	r25, 0x06	; 6
    11b4:	88 87       	std	Y+8, r24	; 0x08
    11b6:	99 87       	std	Y+9, r25	; 0x09
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
    11b8:	e8 85       	ldd	r30, Y+8	; 0x08
    11ba:	f9 85       	ldd	r31, Y+9	; 0x09
    11bc:	83 e0       	ldi	r24, 0x03	; 3
    11be:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
    11c0:	e8 85       	ldd	r30, Y+8	; 0x08
    11c2:	f9 85       	ldd	r31, Y+9	; 0x09
    11c4:	88 e3       	ldi	r24, 0x38	; 56
    11c6:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
    11c8:	e8 85       	ldd	r30, Y+8	; 0x08
    11ca:	f9 85       	ldd	r31, Y+9	; 0x09
    11cc:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
    11ce:	82 e0       	ldi	r24, 0x02	; 2
    11d0:	f7 01       	movw	r30, r14
    11d2:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
    11d4:	ce 01       	movw	r24, r28
    11d6:	0e 94 c8 07 	call	0xf90	; 0xf90 <_ZN9I2CMaster12set_baudrateEm>

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
    11da:	f7 01       	movw	r30, r14
    11dc:	84 81       	ldd	r24, Z+4	; 0x04
    11de:	8d 6c       	ori	r24, 0xCD	; 205
    11e0:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
    11e2:	88 e0       	ldi	r24, 0x08	; 8
    11e4:	81 83       	std	Z+1, r24	; 0x01

  transmitter_ = new Transmitter(this, s);
    11e6:	87 e1       	ldi	r24, 0x17	; 23
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    11ee:	7c 01       	movw	r14, r24
    11f0:	a8 01       	movw	r20, r16
    11f2:	be 01       	movw	r22, r28
    11f4:	0e 94 f6 05 	call	0xbec	; 0xbec <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>
    11f8:	e8 82       	st	Y, r14
    11fa:	f9 82       	std	Y+1, r15	; 0x01
  receiver_ = new Receiver(this, s);
    11fc:	88 e1       	ldi	r24, 0x18	; 24
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    1204:	7c 01       	movw	r14, r24
    1206:	a8 01       	movw	r20, r16
    1208:	be 01       	movw	r22, r28
    120a:	0e 94 a0 06 	call	0xd40	; 0xd40 <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>
    120e:	ea 82       	std	Y+2, r14	; 0x02
    1210:	fb 82       	std	Y+3, r15	; 0x03

  scan();
    1212:	ce 01       	movw	r24, r28
    1214:	0e 94 41 08 	call	0x1082	; 0x1082 <_ZN9I2CMaster4scanEv>
  *s << is_ready(29) << endl;
    1218:	6d e1       	ldi	r22, 0x1D	; 29
    121a:	ce 01       	movw	r24, r28
    121c:	0e 94 0b 08 	call	0x1016	; 0x1016 <_ZN9I2CMaster8is_readyEh>
    1220:	68 2f       	mov	r22, r24
    1222:	c8 01       	movw	r24, r16
    1224:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <_ZN8emstreamlsEb>
    1228:	66 e0       	ldi	r22, 0x06	; 6
    122a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
  emstream *    getSerial()       { return p_serial; }
    122e:	0e 80       	ldd	r0, Y+6	; 0x06
    1230:	df 81       	ldd	r29, Y+7	; 0x07
    1232:	c0 2d       	mov	r28, r0
    1234:	6c e9       	ldi	r22, 0x9C	; 156
    1236:	70 e2       	ldi	r23, 0x20	; 32
    1238:	ce 01       	movw	r24, r28
    123a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>

  *(getSerial()) << "I2CMaster created" << endl;
    123e:	66 e0       	ldi	r22, 0x06	; 6
    1240:	ce 01       	movw	r24, r28
    1242:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
}
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	1f 91       	pop	r17
    124c:	0f 91       	pop	r16
    124e:	ff 90       	pop	r15
    1250:	ef 90       	pop	r14
    1252:	08 95       	ret

00001254 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    1254:	fc 01       	movw	r30, r24
    1256:	84 81       	ldd	r24, Z+4	; 0x04
    1258:	95 81       	ldd	r25, Z+5	; 0x05
    125a:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
		}
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	08 95       	ret

00001262 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    1262:	fc 01       	movw	r30, r24
    1264:	84 81       	ldd	r24, Z+4	; 0x04
    1266:	95 81       	ldd	r25, Z+5	; 0x05
    1268:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    126c:	91 e0       	ldi	r25, 0x01	; 1
    126e:	81 11       	cpse	r24, r1
    1270:	01 c0       	rjmp	.+2      	; 0x1274 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    1272:	90 e0       	ldi	r25, 0x00	; 0
		}
    1274:	89 2f       	mov	r24, r25
    1276:	08 95       	ret

00001278 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    1278:	fc 01       	movw	r30, r24
    127a:	84 81       	ldd	r24, Z+4	; 0x04
    127c:	95 81       	ldd	r25, Z+5	; 0x05
    127e:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    1282:	91 e0       	ldi	r25, 0x01	; 1
    1284:	81 11       	cpse	r24, r1
    1286:	90 e0       	ldi	r25, 0x00	; 0
		}
    1288:	89 2f       	mov	r24, r25
    128a:	08 95       	ret

0000128c <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    128c:	fc 01       	movw	r30, r24
    128e:	84 81       	ldd	r24, Z+4	; 0x04
    1290:	95 81       	ldd	r25, Z+5	; 0x05
    1292:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
		}
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	08 95       	ret

0000129a <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    129a:	fc 01       	movw	r30, r24
    129c:	84 81       	ldd	r24, Z+4	; 0x04
    129e:	95 81       	ldd	r25, Z+5	; 0x05
    12a0:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    12a4:	91 e0       	ldi	r25, 0x01	; 1
    12a6:	81 11       	cpse	r24, r1
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <_ZN9frt_queueIhE9not_emptyEv+0x12>
    12aa:	90 e0       	ldi	r25, 0x00	; 0
		}
    12ac:	89 2f       	mov	r24, r25
    12ae:	08 95       	ret

000012b0 <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    12b0:	fc 01       	movw	r30, r24
    12b2:	84 81       	ldd	r24, Z+4	; 0x04
    12b4:	95 81       	ldd	r25, Z+5	; 0x05
    12b6:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    12ba:	91 e0       	ldi	r25, 0x01	; 1
    12bc:	81 11       	cpse	r24, r1
    12be:	90 e0       	ldi	r25, 0x00	; 0
		}
    12c0:	89 2f       	mov	r24, r25
    12c2:	08 95       	ret

000012c4 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    12c4:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    12c6:	01 e0       	ldi	r16, 0x01	; 1
    12c8:	2f ef       	ldi	r18, 0xFF	; 255
    12ca:	3f ef       	ldi	r19, 0xFF	; 255
    12cc:	a9 01       	movw	r20, r18
    12ce:	fc 01       	movw	r30, r24
    12d0:	84 81       	ldd	r24, Z+4	; 0x04
    12d2:	95 81       	ldd	r25, Z+5	; 0x05
    12d4:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    12d8:	0f 91       	pop	r16
    12da:	08 95       	ret

000012dc <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    12dc:	0f 93       	push	r16
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	1f 92       	push	r1
    12e4:	cd b7       	in	r28, 0x3d	; 61
    12e6:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    12e8:	01 e0       	ldi	r16, 0x01	; 1
    12ea:	2f ef       	ldi	r18, 0xFF	; 255
    12ec:	3f ef       	ldi	r19, 0xFF	; 255
    12ee:	a9 01       	movw	r20, r18
    12f0:	be 01       	movw	r22, r28
    12f2:	6f 5f       	subi	r22, 0xFF	; 255
    12f4:	7f 4f       	sbci	r23, 0xFF	; 255
    12f6:	fc 01       	movw	r30, r24
    12f8:	84 81       	ldd	r24, Z+4	; 0x04
    12fa:	95 81       	ldd	r25, Z+5	; 0x05
    12fc:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    1300:	89 81       	ldd	r24, Y+1	; 0x01
    1302:	0f 90       	pop	r0
    1304:	df 91       	pop	r29
    1306:	cf 91       	pop	r28
    1308:	0f 91       	pop	r16
    130a:	08 95       	ret

0000130c <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    130c:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    130e:	00 e0       	ldi	r16, 0x00	; 0
    1310:	2f ef       	ldi	r18, 0xFF	; 255
    1312:	3f ef       	ldi	r19, 0xFF	; 255
    1314:	a9 01       	movw	r20, r18
    1316:	fc 01       	movw	r30, r24
    1318:	84 81       	ldd	r24, Z+4	; 0x04
    131a:	95 81       	ldd	r25, Z+5	; 0x05
    131c:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    1320:	0f 91       	pop	r16
    1322:	08 95       	ret

00001324 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    1324:	0f 93       	push	r16
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	1f 92       	push	r1
    132c:	cd b7       	in	r28, 0x3d	; 61
    132e:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    1330:	00 e0       	ldi	r16, 0x00	; 0
    1332:	2f ef       	ldi	r18, 0xFF	; 255
    1334:	3f ef       	ldi	r19, 0xFF	; 255
    1336:	a9 01       	movw	r20, r18
    1338:	be 01       	movw	r22, r28
    133a:	6f 5f       	subi	r22, 0xFF	; 255
    133c:	7f 4f       	sbci	r23, 0xFF	; 255
    133e:	fc 01       	movw	r30, r24
    1340:	84 81       	ldd	r24, Z+4	; 0x04
    1342:	95 81       	ldd	r25, Z+5	; 0x05
    1344:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    1348:	89 81       	ldd	r24, Y+1	; 0x01
    134a:	0f 90       	pop	r0
    134c:	df 91       	pop	r29
    134e:	cf 91       	pop	r28
    1350:	0f 91       	pop	r16
    1352:	08 95       	ret

00001354 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	1f 92       	push	r1
    135a:	cd b7       	in	r28, 0x3d	; 61
    135c:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    135e:	ae 01       	movw	r20, r28
    1360:	4f 5f       	subi	r20, 0xFF	; 255
    1362:	5f 4f       	sbci	r21, 0xFF	; 255
    1364:	fc 01       	movw	r30, r24
    1366:	84 81       	ldd	r24, Z+4	; 0x04
    1368:	95 81       	ldd	r25, Z+5	; 0x05
    136a:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
}
    136e:	0f 90       	pop	r0
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	08 95       	ret

00001376 <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    1376:	cf 93       	push	r28
    1378:	df 93       	push	r29
    137a:	1f 92       	push	r1
    137c:	1f 92       	push	r1
    137e:	cd b7       	in	r28, 0x3d	; 61
    1380:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    1382:	ae 01       	movw	r20, r28
    1384:	4e 5f       	subi	r20, 0xFE	; 254
    1386:	5f 4f       	sbci	r21, 0xFF	; 255
    1388:	be 01       	movw	r22, r28
    138a:	6f 5f       	subi	r22, 0xFF	; 255
    138c:	7f 4f       	sbci	r23, 0xFF	; 255
    138e:	fc 01       	movw	r30, r24
    1390:	84 81       	ldd	r24, Z+4	; 0x04
    1392:	95 81       	ldd	r25, Z+5	; 0x05
    1394:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
	return (recv_item);
}
    1398:	89 81       	ldd	r24, Y+1	; 0x01
    139a:	0f 90       	pop	r0
    139c:	0f 90       	pop	r0
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	08 95       	ret

000013a4 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    13a4:	cf 93       	push	r28
    13a6:	df 93       	push	r29
    13a8:	1f 92       	push	r1
    13aa:	cd b7       	in	r28, 0x3d	; 61
    13ac:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    13ae:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    13b0:	21 e0       	ldi	r18, 0x01	; 1
    13b2:	ae 01       	movw	r20, r28
    13b4:	4f 5f       	subi	r20, 0xFF	; 255
    13b6:	5f 4f       	sbci	r21, 0xFF	; 255
    13b8:	fc 01       	movw	r30, r24
    13ba:	84 81       	ldd	r24, Z+4	; 0x04
    13bc:	95 81       	ldd	r25, Z+5	; 0x05
    13be:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    13c2:	91 e0       	ldi	r25, 0x01	; 1
    13c4:	81 11       	cpse	r24, r1
    13c6:	01 c0       	rjmp	.+2      	; 0x13ca <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    13c8:	90 e0       	ldi	r25, 0x00	; 0
}
    13ca:	89 2f       	mov	r24, r25
    13cc:	0f 90       	pop	r0
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
    13d2:	08 95       	ret

000013d4 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	1f 92       	push	r1
    13da:	cd b7       	in	r28, 0x3d	; 61
    13dc:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    13de:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    13e0:	20 e0       	ldi	r18, 0x00	; 0
    13e2:	ae 01       	movw	r20, r28
    13e4:	4f 5f       	subi	r20, 0xFF	; 255
    13e6:	5f 4f       	sbci	r21, 0xFF	; 255
    13e8:	fc 01       	movw	r30, r24
    13ea:	84 81       	ldd	r24, Z+4	; 0x04
    13ec:	95 81       	ldd	r25, Z+5	; 0x05
    13ee:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    13f2:	91 e0       	ldi	r25, 0x01	; 1
    13f4:	81 11       	cpse	r24, r1
    13f6:	01 c0       	rjmp	.+2      	; 0x13fa <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    13f8:	90 e0       	ldi	r25, 0x00	; 0
}
    13fa:	89 2f       	mov	r24, r25
    13fc:	0f 90       	pop	r0
    13fe:	df 91       	pop	r29
    1400:	cf 91       	pop	r28
    1402:	08 95       	ret

00001404 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    1404:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    1406:	fc 01       	movw	r30, r24
    1408:	26 81       	ldd	r18, Z+6	; 0x06
    140a:	37 81       	ldd	r19, Z+7	; 0x07
    140c:	40 85       	ldd	r20, Z+8	; 0x08
    140e:	51 85       	ldd	r21, Z+9	; 0x09
    1410:	01 e0       	ldi	r16, 0x01	; 1
    1412:	84 81       	ldd	r24, Z+4	; 0x04
    1414:	95 81       	ldd	r25, Z+5	; 0x05
    1416:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    141a:	91 e0       	ldi	r25, 0x01	; 1
    141c:	81 11       	cpse	r24, r1
    141e:	01 c0       	rjmp	.+2      	; 0x1422 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    1420:	90 e0       	ldi	r25, 0x00	; 0
		}
    1422:	89 2f       	mov	r24, r25
    1424:	0f 91       	pop	r16
    1426:	08 95       	ret

00001428 <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    1428:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    142a:	fc 01       	movw	r30, r24
    142c:	26 81       	ldd	r18, Z+6	; 0x06
    142e:	37 81       	ldd	r19, Z+7	; 0x07
    1430:	40 85       	ldd	r20, Z+8	; 0x08
    1432:	51 85       	ldd	r21, Z+9	; 0x09
    1434:	00 e0       	ldi	r16, 0x00	; 0
    1436:	84 81       	ldd	r24, Z+4	; 0x04
    1438:	95 81       	ldd	r25, Z+5	; 0x05
    143a:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    143e:	91 e0       	ldi	r25, 0x01	; 1
    1440:	81 11       	cpse	r24, r1
    1442:	01 c0       	rjmp	.+2      	; 0x1446 <_ZN9frt_queueIhE3putERKh+0x1e>
    1444:	90 e0       	ldi	r25, 0x00	; 0
		}
    1446:	89 2f       	mov	r24, r25
    1448:	0f 91       	pop	r16
    144a:	08 95       	ret

0000144c <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::is_ready()
{
  return driver_->is_ready(slaveAddr_);
}
    144c:	0f 93       	push	r16
    144e:	1f 93       	push	r17
    1450:	cf 93       	push	r28
    1452:	df 93       	push	r29
    1454:	8c 01       	movw	r16, r24
    1456:	eb 01       	movw	r28, r22
    1458:	bc 01       	movw	r22, r24
    145a:	6e 5f       	subi	r22, 0xFE	; 254
    145c:	7f 4f       	sbci	r23, 0xFF	; 255
    145e:	e8 81       	ld	r30, Y
    1460:	f9 81       	ldd	r31, Y+1	; 0x01
    1462:	01 90       	ld	r0, Z+
    1464:	f0 81       	ld	r31, Z
    1466:	e0 2d       	mov	r30, r0
    1468:	ce 01       	movw	r24, r28
    146a:	19 95       	eicall
    146c:	b8 01       	movw	r22, r16
    146e:	6d 5f       	subi	r22, 0xFD	; 253
    1470:	7f 4f       	sbci	r23, 0xFF	; 255
    1472:	e8 81       	ld	r30, Y
    1474:	f9 81       	ldd	r31, Y+1	; 0x01
    1476:	01 90       	ld	r0, Z+
    1478:	f0 81       	ld	r31, Z
    147a:	e0 2d       	mov	r30, r0
    147c:	ce 01       	movw	r24, r28
    147e:	19 95       	eicall
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	08 95       	ret

0000148a <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    148a:	db 01       	movw	r26, r22
    148c:	bc 01       	movw	r22, r24
    148e:	6e 5f       	subi	r22, 0xFE	; 254
    1490:	7f 4f       	sbci	r23, 0xFF	; 255
    1492:	ed 91       	ld	r30, X+
    1494:	fc 91       	ld	r31, X
    1496:	11 97       	sbiw	r26, 0x01	; 1
    1498:	01 90       	ld	r0, Z+
    149a:	f0 81       	ld	r31, Z
    149c:	e0 2d       	mov	r30, r0
    149e:	cd 01       	movw	r24, r26
    14a0:	19 95       	eicall
    14a2:	08 95       	ret

000014a4 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    14a4:	db 01       	movw	r26, r22
    14a6:	bc 01       	movw	r22, r24
    14a8:	6e 5f       	subi	r22, 0xFE	; 254
    14aa:	7f 4f       	sbci	r23, 0xFF	; 255
    14ac:	ed 91       	ld	r30, X+
    14ae:	fc 91       	ld	r31, X
    14b0:	11 97       	sbiw	r26, 0x01	; 1
    14b2:	01 90       	ld	r0, Z+
    14b4:	f0 81       	ld	r31, Z
    14b6:	e0 2d       	mov	r30, r0
    14b8:	cd 01       	movw	r24, r26
    14ba:	19 95       	eicall
    14bc:	08 95       	ret

000014be <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    14be:	db 01       	movw	r26, r22
    14c0:	bc 01       	movw	r22, r24
    14c2:	6e 5f       	subi	r22, 0xFE	; 254
    14c4:	7f 4f       	sbci	r23, 0xFF	; 255
    14c6:	ed 91       	ld	r30, X+
    14c8:	fc 91       	ld	r31, X
    14ca:	11 97       	sbiw	r26, 0x01	; 1
    14cc:	01 90       	ld	r0, Z+
    14ce:	f0 81       	ld	r31, Z
    14d0:	e0 2d       	mov	r30, r0
    14d2:	cd 01       	movw	r24, r26
    14d4:	19 95       	eicall
    14d6:	08 95       	ret

000014d8 <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    14d8:	4f 92       	push	r4
    14da:	5f 92       	push	r5
    14dc:	6f 92       	push	r6
    14de:	7f 92       	push	r7
    14e0:	8f 92       	push	r8
    14e2:	9f 92       	push	r9
    14e4:	af 92       	push	r10
    14e6:	bf 92       	push	r11
    14e8:	cf 92       	push	r12
    14ea:	df 92       	push	r13
    14ec:	ef 92       	push	r14
    14ee:	ff 92       	push	r15
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	8c 01       	movw	r16, r24
    14fa:	7b 01       	movw	r14, r22
    14fc:	6a 01       	movw	r12, r20
    14fe:	dc 01       	movw	r26, r24
    1500:	6d 93       	st	X+, r22
    1502:	7c 93       	st	X, r23
    1504:	11 97       	sbiw	r26, 0x01	; 1
    1506:	12 96       	adiw	r26, 0x02	; 2
    1508:	4d 93       	st	X+, r20
    150a:	5c 93       	st	X, r21
    150c:	13 97       	sbiw	r26, 0x03	; 3
    150e:	81 e2       	ldi	r24, 0x21	; 33
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    1516:	ec 01       	movw	r28, r24
    1518:	82 e4       	ldi	r24, 0x42	; 66
    151a:	91 e2       	ldi	r25, 0x21	; 33
    151c:	88 83       	st	Y, r24
    151e:	99 83       	std	Y+1, r25	; 0x01
    1520:	1c 82       	std	Y+4, r1	; 0x04
    1522:	1d 82       	std	Y+5, r1	; 0x05
    1524:	0f 2e       	mov	r0, r31
    1526:	fa ef       	ldi	r31, 0xFA	; 250
    1528:	af 2e       	mov	r10, r31
    152a:	f0 e2       	ldi	r31, 0x20	; 32
    152c:	bf 2e       	mov	r11, r31
    152e:	f0 2d       	mov	r31, r0
    1530:	aa 82       	std	Y+2, r10	; 0x02
    1532:	bb 82       	std	Y+3, r11	; 0x03
    1534:	40 e0       	ldi	r20, 0x00	; 0
    1536:	61 e0       	ldi	r22, 0x01	; 1
    1538:	82 e0       	ldi	r24, 0x02	; 2
    153a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    153e:	8e 83       	std	Y+6, r24	; 0x06
    1540:	9f 83       	std	Y+7, r25	; 0x07
    1542:	0f 2e       	mov	r0, r31
    1544:	fa e0       	ldi	r31, 0x0A	; 10
    1546:	4f 2e       	mov	r4, r31
    1548:	51 2c       	mov	r5, r1
    154a:	61 2c       	mov	r6, r1
    154c:	71 2c       	mov	r7, r1
    154e:	f0 2d       	mov	r31, r0
    1550:	48 86       	std	Y+8, r4	; 0x08
    1552:	59 86       	std	Y+9, r5	; 0x09
    1554:	6a 86       	std	Y+10, r6	; 0x0a
    1556:	7b 86       	std	Y+11, r7	; 0x0b
    1558:	0f 2e       	mov	r0, r31
    155a:	fe e1       	ldi	r31, 0x1E	; 30
    155c:	8f 2e       	mov	r8, r31
    155e:	f1 e2       	ldi	r31, 0x21	; 33
    1560:	9f 2e       	mov	r9, r31
    1562:	f0 2d       	mov	r31, r0
    1564:	8a 82       	std	Y+2, r8	; 0x02
    1566:	9b 82       	std	Y+3, r9	; 0x03
    1568:	82 e0       	ldi	r24, 0x02	; 2
    156a:	8c 87       	std	Y+12, r24	; 0x0c
    156c:	18 8a       	std	Y+16, r1	; 0x10
    156e:	19 8a       	std	Y+17, r1	; 0x11
    1570:	ae 86       	std	Y+14, r10	; 0x0e
    1572:	bf 86       	std	Y+15, r11	; 0x0f
    1574:	40 e0       	ldi	r20, 0x00	; 0
    1576:	61 e0       	ldi	r22, 0x01	; 1
    1578:	83 e0       	ldi	r24, 0x03	; 3
    157a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    157e:	8a 8b       	std	Y+18, r24	; 0x12
    1580:	9b 8b       	std	Y+19, r25	; 0x13
    1582:	4c 8a       	std	Y+20, r4	; 0x14
    1584:	5d 8a       	std	Y+21, r5	; 0x15
    1586:	6e 8a       	std	Y+22, r6	; 0x16
    1588:	7f 8a       	std	Y+23, r7	; 0x17
    158a:	8e 86       	std	Y+14, r8	; 0x0e
    158c:	9f 86       	std	Y+15, r9	; 0x0f
    158e:	0f 2e       	mov	r0, r31
    1590:	f3 e0       	ldi	r31, 0x03	; 3
    1592:	bf 2e       	mov	r11, r31
    1594:	f0 2d       	mov	r31, r0
    1596:	b8 8e       	std	Y+24, r11	; 0x18
    1598:	8a e0       	ldi	r24, 0x0A	; 10
    159a:	90 e2       	ldi	r25, 0x20	; 32
    159c:	88 83       	st	Y, r24
    159e:	99 83       	std	Y+1, r25	; 0x01
    15a0:	ca 8e       	std	Y+26, r12	; 0x1a
    15a2:	db 8e       	std	Y+27, r13	; 0x1b
    15a4:	f8 01       	movw	r30, r16
    15a6:	c4 83       	std	Z+4, r28	; 0x04
    15a8:	d5 83       	std	Z+5, r29	; 0x05
    15aa:	86 e0       	ldi	r24, 0x06	; 6
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    15b2:	fc 01       	movw	r30, r24
    15b4:	10 82       	st	Z, r1
    15b6:	11 82       	std	Z+1, r1	; 0x01
    15b8:	12 82       	std	Z+2, r1	; 0x02
    15ba:	13 82       	std	Z+3, r1	; 0x03
    15bc:	14 82       	std	Z+4, r1	; 0x04
    15be:	15 82       	std	Z+5, r1	; 0x05
    15c0:	d8 01       	movw	r26, r16
    15c2:	16 96       	adiw	r26, 0x06	; 6
    15c4:	8d 93       	st	X+, r24
    15c6:	9c 93       	st	X, r25
    15c8:	17 97       	sbiw	r26, 0x07	; 7
    15ca:	8d e1       	ldi	r24, 0x1D	; 29
    15cc:	18 96       	adiw	r26, 0x08	; 8
    15ce:	8c 93       	st	X, r24
    15d0:	84 e0       	ldi	r24, 0x04	; 4
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    15d8:	fc 01       	movw	r30, r24
    15da:	80 e5       	ldi	r24, 0x50	; 80
    15dc:	91 e2       	ldi	r25, 0x21	; 33
    15de:	80 83       	st	Z, r24
    15e0:	91 83       	std	Z+1, r25	; 0x01
    15e2:	8a e2       	ldi	r24, 0x2A	; 42
    15e4:	82 83       	std	Z+2, r24	; 0x02
    15e6:	c1 e0       	ldi	r28, 0x01	; 1
    15e8:	c3 83       	std	Z+3, r28	; 0x03
    15ea:	d8 01       	movw	r26, r16
    15ec:	1b 96       	adiw	r26, 0x0b	; 11
    15ee:	ed 93       	st	X+, r30
    15f0:	fc 93       	st	X, r31
    15f2:	1c 97       	sbiw	r26, 0x0c	; 12
    15f4:	83 e0       	ldi	r24, 0x03	; 3
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    15fc:	26 e5       	ldi	r18, 0x56	; 86
    15fe:	31 e2       	ldi	r19, 0x21	; 33
    1600:	fc 01       	movw	r30, r24
    1602:	20 83       	st	Z, r18
    1604:	31 83       	std	Z+1, r19	; 0x01
    1606:	c2 83       	std	Z+2, r28	; 0x02
    1608:	d8 01       	movw	r26, r16
    160a:	1d 96       	adiw	r26, 0x0d	; 13
    160c:	8d 93       	st	X+, r24
    160e:	9c 93       	st	X, r25
    1610:	1e 97       	sbiw	r26, 0x0e	; 14
    1612:	83 e0       	ldi	r24, 0x03	; 3
    1614:	90 e0       	ldi	r25, 0x00	; 0
    1616:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    161a:	2c e5       	ldi	r18, 0x5C	; 92
    161c:	31 e2       	ldi	r19, 0x21	; 33
    161e:	fc 01       	movw	r30, r24
    1620:	20 83       	st	Z, r18
    1622:	31 83       	std	Z+1, r19	; 0x01
    1624:	b2 82       	std	Z+2, r11	; 0x02
    1626:	d8 01       	movw	r26, r16
    1628:	1f 96       	adiw	r26, 0x0f	; 15
    162a:	8d 93       	st	X+, r24
    162c:	9c 93       	st	X, r25
    162e:	50 97       	sbiw	r26, 0x10	; 16
    1630:	83 e0       	ldi	r24, 0x03	; 3
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    1638:	22 e6       	ldi	r18, 0x62	; 98
    163a:	31 e2       	ldi	r19, 0x21	; 33
    163c:	fc 01       	movw	r30, r24
    163e:	20 83       	st	Z, r18
    1640:	31 83       	std	Z+1, r19	; 0x01
    1642:	25 e0       	ldi	r18, 0x05	; 5
    1644:	22 83       	std	Z+2, r18	; 0x02
    1646:	d8 01       	movw	r26, r16
    1648:	51 96       	adiw	r26, 0x11	; 17
    164a:	8d 93       	st	X+, r24
    164c:	9c 93       	st	X, r25
    164e:	52 97       	sbiw	r26, 0x12	; 18
    1650:	14 96       	adiw	r26, 0x04	; 4
    1652:	ed 91       	ld	r30, X+
    1654:	fc 91       	ld	r31, X
    1656:	15 97       	sbiw	r26, 0x05	; 5
    1658:	e4 8e       	std	Z+28, r14	; 0x1c
    165a:	f5 8e       	std	Z+29, r15	; 0x1d
    165c:	18 96       	adiw	r26, 0x08	; 8
    165e:	6c 91       	ld	r22, X
    1660:	18 97       	sbiw	r26, 0x08	; 8
    1662:	14 96       	adiw	r26, 0x04	; 4
    1664:	8d 91       	ld	r24, X+
    1666:	9c 91       	ld	r25, X
    1668:	15 97       	sbiw	r26, 0x05	; 5
    166a:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <_ZN8I2CAgent12setSlaveAddrEh>
    166e:	df 91       	pop	r29
    1670:	cf 91       	pop	r28
    1672:	1f 91       	pop	r17
    1674:	0f 91       	pop	r16
    1676:	ff 90       	pop	r15
    1678:	ef 90       	pop	r14
    167a:	df 90       	pop	r13
    167c:	cf 90       	pop	r12
    167e:	bf 90       	pop	r11
    1680:	af 90       	pop	r10
    1682:	9f 90       	pop	r9
    1684:	8f 90       	pop	r8
    1686:	7f 90       	pop	r7
    1688:	6f 90       	pop	r6
    168a:	5f 90       	pop	r5
    168c:	4f 90       	pop	r4
    168e:	08 95       	ret

00001690 <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    1690:	1f 93       	push	r17
    1692:	cf 93       	push	r28
    1694:	df 93       	push	r29
    1696:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1698:	8c 81       	ldd	r24, Y+4	; 0x04
    169a:	9d 81       	ldd	r25, Y+5	; 0x05
    169c:	6b 85       	ldd	r22, Y+11	; 0x0b
    169e:	7c 85       	ldd	r23, Y+12	; 0x0c
    16a0:	dc 01       	movw	r26, r24
    16a2:	ed 91       	ld	r30, X+
    16a4:	fc 91       	ld	r31, X
    16a6:	01 90       	ld	r0, Z+
    16a8:	f0 81       	ld	r31, Z
    16aa:	e0 2d       	mov	r30, r0
    16ac:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    16ae:	8c 81       	ldd	r24, Y+4	; 0x04
    16b0:	9d 81       	ldd	r25, Y+5	; 0x05
    16b2:	6d 85       	ldd	r22, Y+13	; 0x0d
    16b4:	7e 85       	ldd	r23, Y+14	; 0x0e
    16b6:	dc 01       	movw	r26, r24
    16b8:	ed 91       	ld	r30, X+
    16ba:	fc 91       	ld	r31, X
    16bc:	01 90       	ld	r0, Z+
    16be:	f0 81       	ld	r31, Z
    16c0:	e0 2d       	mov	r30, r0
    16c2:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    16c4:	8c 81       	ldd	r24, Y+4	; 0x04
    16c6:	9d 81       	ldd	r25, Y+5	; 0x05
    16c8:	dc 01       	movw	r26, r24
    16ca:	ed 91       	ld	r30, X+
    16cc:	fc 91       	ld	r31, X
    16ce:	02 80       	ldd	r0, Z+2	; 0x02
    16d0:	f3 81       	ldd	r31, Z+3	; 0x03
    16d2:	e0 2d       	mov	r30, r0
    16d4:	19 95       	eicall
    16d6:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    16d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    16da:	88 23       	and	r24, r24
    16dc:	b9 f0       	breq	.+46     	; 0x170c <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    16de:	e8 81       	ld	r30, Y
    16e0:	f9 81       	ldd	r31, Y+1	; 0x01
    16e2:	00 84       	ldd	r0, Z+8	; 0x08
    16e4:	f1 85       	ldd	r31, Z+9	; 0x09
    16e6:	e0 2d       	mov	r30, r0
    16e8:	ce 01       	movw	r24, r28
    16ea:	19 95       	eicall
    16ec:	18 2f       	mov	r17, r24
    16ee:	e8 81       	ld	r30, Y
    16f0:	f9 81       	ldd	r31, Y+1	; 0x01
    16f2:	00 84       	ldd	r0, Z+8	; 0x08
    16f4:	f1 85       	ldd	r31, Z+9	; 0x09
    16f6:	e0 2d       	mov	r30, r0
    16f8:	ce 01       	movw	r24, r28
    16fa:	19 95       	eicall
    16fc:	21 2f       	mov	r18, r17
    16fe:	30 e0       	ldi	r19, 0x00	; 0
    1700:	32 2f       	mov	r19, r18
    1702:	22 27       	eor	r18, r18
    1704:	a9 01       	movw	r20, r18
    1706:	48 2b       	or	r20, r24
    1708:	ca 01       	movw	r24, r20
    170a:	02 c0       	rjmp	.+4      	; 0x1710 <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	1f 91       	pop	r17
    1716:	08 95       	ret

00001718 <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    1718:	1f 93       	push	r17
    171a:	cf 93       	push	r28
    171c:	df 93       	push	r29
    171e:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1720:	8c 81       	ldd	r24, Y+4	; 0x04
    1722:	9d 81       	ldd	r25, Y+5	; 0x05
    1724:	6b 85       	ldd	r22, Y+11	; 0x0b
    1726:	7c 85       	ldd	r23, Y+12	; 0x0c
    1728:	dc 01       	movw	r26, r24
    172a:	ed 91       	ld	r30, X+
    172c:	fc 91       	ld	r31, X
    172e:	01 90       	ld	r0, Z+
    1730:	f0 81       	ld	r31, Z
    1732:	e0 2d       	mov	r30, r0
    1734:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    1736:	8c 81       	ldd	r24, Y+4	; 0x04
    1738:	9d 81       	ldd	r25, Y+5	; 0x05
    173a:	6f 85       	ldd	r22, Y+15	; 0x0f
    173c:	78 89       	ldd	r23, Y+16	; 0x10
    173e:	dc 01       	movw	r26, r24
    1740:	ed 91       	ld	r30, X+
    1742:	fc 91       	ld	r31, X
    1744:	01 90       	ld	r0, Z+
    1746:	f0 81       	ld	r31, Z
    1748:	e0 2d       	mov	r30, r0
    174a:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    174c:	8c 81       	ldd	r24, Y+4	; 0x04
    174e:	9d 81       	ldd	r25, Y+5	; 0x05
    1750:	dc 01       	movw	r26, r24
    1752:	ed 91       	ld	r30, X+
    1754:	fc 91       	ld	r31, X
    1756:	02 80       	ldd	r0, Z+2	; 0x02
    1758:	f3 81       	ldd	r31, Z+3	; 0x03
    175a:	e0 2d       	mov	r30, r0
    175c:	19 95       	eicall
    175e:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    1760:	8b 85       	ldd	r24, Y+11	; 0x0b
    1762:	88 23       	and	r24, r24
    1764:	b9 f0       	breq	.+46     	; 0x1794 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    1766:	e8 81       	ld	r30, Y
    1768:	f9 81       	ldd	r31, Y+1	; 0x01
    176a:	00 84       	ldd	r0, Z+8	; 0x08
    176c:	f1 85       	ldd	r31, Z+9	; 0x09
    176e:	e0 2d       	mov	r30, r0
    1770:	ce 01       	movw	r24, r28
    1772:	19 95       	eicall
    1774:	18 2f       	mov	r17, r24
    1776:	e8 81       	ld	r30, Y
    1778:	f9 81       	ldd	r31, Y+1	; 0x01
    177a:	00 84       	ldd	r0, Z+8	; 0x08
    177c:	f1 85       	ldd	r31, Z+9	; 0x09
    177e:	e0 2d       	mov	r30, r0
    1780:	ce 01       	movw	r24, r28
    1782:	19 95       	eicall
    1784:	21 2f       	mov	r18, r17
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	32 2f       	mov	r19, r18
    178a:	22 27       	eor	r18, r18
    178c:	a9 01       	movw	r20, r18
    178e:	48 2b       	or	r20, r24
    1790:	ca 01       	movw	r24, r20
    1792:	02 c0       	rjmp	.+4      	; 0x1798 <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    1794:	80 e0       	ldi	r24, 0x00	; 0
    1796:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    1798:	df 91       	pop	r29
    179a:	cf 91       	pop	r28
    179c:	1f 91       	pop	r17
    179e:	08 95       	ret

000017a0 <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
    17a6:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    17a8:	8c 81       	ldd	r24, Y+4	; 0x04
    17aa:	9d 81       	ldd	r25, Y+5	; 0x05
    17ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    17ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    17b0:	dc 01       	movw	r26, r24
    17b2:	ed 91       	ld	r30, X+
    17b4:	fc 91       	ld	r31, X
    17b6:	01 90       	ld	r0, Z+
    17b8:	f0 81       	ld	r31, Z
    17ba:	e0 2d       	mov	r30, r0
    17bc:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    17be:	8c 81       	ldd	r24, Y+4	; 0x04
    17c0:	9d 81       	ldd	r25, Y+5	; 0x05
    17c2:	69 89       	ldd	r22, Y+17	; 0x11
    17c4:	7a 89       	ldd	r23, Y+18	; 0x12
    17c6:	dc 01       	movw	r26, r24
    17c8:	ed 91       	ld	r30, X+
    17ca:	fc 91       	ld	r31, X
    17cc:	01 90       	ld	r0, Z+
    17ce:	f0 81       	ld	r31, Z
    17d0:	e0 2d       	mov	r30, r0
    17d2:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    17d4:	8c 81       	ldd	r24, Y+4	; 0x04
    17d6:	9d 81       	ldd	r25, Y+5	; 0x05
    17d8:	dc 01       	movw	r26, r24
    17da:	ed 91       	ld	r30, X+
    17dc:	fc 91       	ld	r31, X
    17de:	02 80       	ldd	r0, Z+2	; 0x02
    17e0:	f3 81       	ldd	r31, Z+3	; 0x03
    17e2:	e0 2d       	mov	r30, r0
    17e4:	19 95       	eicall
    17e6:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    17e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    17ea:	88 23       	and	r24, r24
    17ec:	b9 f0       	breq	.+46     	; 0x181c <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    17ee:	e8 81       	ld	r30, Y
    17f0:	f9 81       	ldd	r31, Y+1	; 0x01
    17f2:	00 84       	ldd	r0, Z+8	; 0x08
    17f4:	f1 85       	ldd	r31, Z+9	; 0x09
    17f6:	e0 2d       	mov	r30, r0
    17f8:	ce 01       	movw	r24, r28
    17fa:	19 95       	eicall
    17fc:	18 2f       	mov	r17, r24
    17fe:	e8 81       	ld	r30, Y
    1800:	f9 81       	ldd	r31, Y+1	; 0x01
    1802:	00 84       	ldd	r0, Z+8	; 0x08
    1804:	f1 85       	ldd	r31, Z+9	; 0x09
    1806:	e0 2d       	mov	r30, r0
    1808:	ce 01       	movw	r24, r28
    180a:	19 95       	eicall
    180c:	21 2f       	mov	r18, r17
    180e:	30 e0       	ldi	r19, 0x00	; 0
    1810:	32 2f       	mov	r19, r18
    1812:	22 27       	eor	r18, r18
    1814:	a9 01       	movw	r20, r18
    1816:	48 2b       	or	r20, r24
    1818:	ca 01       	movw	r24, r20
    181a:	02 c0       	rjmp	.+4      	; 0x1820 <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    181c:	80 e0       	ldi	r24, 0x00	; 0
    181e:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	1f 91       	pop	r17
    1826:	08 95       	ret

00001828 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	ec 01       	movw	r28, r24
  success_ = false;
    182e:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    1830:	e8 81       	ld	r30, Y
    1832:	f9 81       	ldd	r31, Y+1	; 0x01
    1834:	00 8c       	ldd	r0, Z+24	; 0x18
    1836:	f1 8d       	ldd	r31, Z+25	; 0x19
    1838:	e0 2d       	mov	r30, r0
    183a:	ce 01       	movw	r24, r28
    183c:	19 95       	eicall
    183e:	88 23       	and	r24, r24
    1840:	41 f0       	breq	.+16     	; 0x1852 <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    1842:	e8 81       	ld	r30, Y
    1844:	f9 81       	ldd	r31, Y+1	; 0x01
    1846:	00 84       	ldd	r0, Z+8	; 0x08
    1848:	f1 85       	ldd	r31, Z+9	; 0x09
    184a:	e0 2d       	mov	r30, r0
    184c:	ce 01       	movw	r24, r28
    184e:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    1850:	ef cf       	rjmp	.-34     	; 0x1830 <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	08 95       	ret

00001858 <_ZN11task_sensor3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sensor::run (void)
{
    1858:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    185a:	8c 85       	ldd	r24, Y+12	; 0x0c
    185c:	81 11       	cpse	r24, r1
    185e:	39 c0       	rjmp	.+114    	; 0x18d2 <_ZN11task_sensor3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    1860:	8c 89       	ldd	r24, Y+20	; 0x14
    1862:	9d 89       	ldd	r25, Y+21	; 0x15
    1864:	0e 94 48 0b 	call	0x1690	; 0x1690 <_ZN7MMA845111getXReadingEv>
    1868:	7c 01       	movw	r14, r24
    186a:	0e 81       	ldd	r16, Y+6	; 0x06
    186c:	1f 81       	ldd	r17, Y+7	; 0x07
    186e:	64 e6       	ldi	r22, 0x64	; 100
    1870:	71 e2       	ldi	r23, 0x21	; 33
    1872:	c8 01       	movw	r24, r16
    1874:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1878:	b7 01       	movw	r22, r14
    187a:	c8 01       	movw	r24, r16
    187c:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    1880:	66 e0       	ldi	r22, 0x06	; 6
    1882:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    1886:	8c 89       	ldd	r24, Y+20	; 0x14
    1888:	9d 89       	ldd	r25, Y+21	; 0x15
    188a:	0e 94 8c 0b 	call	0x1718	; 0x1718 <_ZN7MMA845111getYReadingEv>
    188e:	7c 01       	movw	r14, r24
    1890:	0e 81       	ldd	r16, Y+6	; 0x06
    1892:	1f 81       	ldd	r17, Y+7	; 0x07
    1894:	68 e6       	ldi	r22, 0x68	; 104
    1896:	71 e2       	ldi	r23, 0x21	; 33
    1898:	c8 01       	movw	r24, r16
    189a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    189e:	b7 01       	movw	r22, r14
    18a0:	c8 01       	movw	r24, r16
    18a2:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    18a6:	66 e0       	ldi	r22, 0x06	; 6
    18a8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    18ac:	8c 89       	ldd	r24, Y+20	; 0x14
    18ae:	9d 89       	ldd	r25, Y+21	; 0x15
    18b0:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <_ZN7MMA845111getZReadingEv>
    18b4:	7c 01       	movw	r14, r24
    18b6:	0e 81       	ldd	r16, Y+6	; 0x06
    18b8:	1f 81       	ldd	r17, Y+7	; 0x07
    18ba:	6c e6       	ldi	r22, 0x6C	; 108
    18bc:	71 e2       	ldi	r23, 0x21	; 33
    18be:	c8 01       	movw	r24, r16
    18c0:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    18c4:	b7 01       	movw	r22, r14
    18c6:	c8 01       	movw	r24, r16
    18c8:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    18cc:	66 e0       	ldi	r22, 0x06	; 6
    18ce:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    18d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    18d4:	9f 85       	ldd	r25, Y+15	; 0x0f
    18d6:	a8 89       	ldd	r26, Y+16	; 0x10
    18d8:	b9 89       	ldd	r27, Y+17	; 0x11
    18da:	01 96       	adiw	r24, 0x01	; 1
    18dc:	a1 1d       	adc	r26, r1
    18de:	b1 1d       	adc	r27, r1
    18e0:	8e 87       	std	Y+14, r24	; 0x0e
    18e2:	9f 87       	std	Y+15, r25	; 0x0f
    18e4:	a8 8b       	std	Y+16, r26	; 0x10
    18e6:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    18e8:	68 ee       	ldi	r22, 0xE8	; 232
    18ea:	73 e0       	ldi	r23, 0x03	; 3
    18ec:	80 e0       	ldi	r24, 0x00	; 0
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	0e 94 1c 18 	call	0x3038	; 0x3038 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    18f4:	b2 cf       	rjmp	.-156    	; 0x185a <_ZN11task_sensor3runEv+0x2>

000018f6 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sensor::task_sensor (const char* a_name, 
    18f6:	cf 92       	push	r12
    18f8:	df 92       	push	r13
    18fa:	ef 92       	push	r14
    18fc:	ff 92       	push	r15
    18fe:	0f 93       	push	r16
    1900:	1f 93       	push	r17
    1902:	cf 93       	push	r28
    1904:	df 93       	push	r29
    1906:	ec 01       	movw	r28, r24
    1908:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    190a:	0e 94 4c 1a 	call	0x3498	; 0x3498 <_ZN8frt_taskC1EPKchjP8emstream>
    190e:	84 e7       	ldi	r24, 0x74	; 116
    1910:	91 e2       	ldi	r25, 0x21	; 33
    1912:	88 83       	st	Y, r24
    1914:	99 83       	std	Y+1, r25	; 0x01
    1916:	ec 8a       	std	Y+20, r14	; 0x14
    1918:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    191a:	ce 8a       	std	Y+22, r12	; 0x16
    191c:	df 8a       	std	Y+23, r13	; 0x17
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	1f 91       	pop	r17
    1924:	0f 91       	pop	r16
    1926:	ff 90       	pop	r15
    1928:	ef 90       	pop	r14
    192a:	df 90       	pop	r13
    192c:	cf 90       	pop	r12
    192e:	08 95       	ret

00001930 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    193a:	0e 94 4c 1a 	call	0x3498	; 0x3498 <_ZN8frt_taskC1EPKchjP8emstream>
    193e:	8c e7       	ldi	r24, 0x7C	; 124
    1940:	91 e2       	ldi	r25, 0x21	; 33
    1942:	88 83       	st	Y, r24
    1944:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1946:	df 91       	pop	r29
    1948:	cf 91       	pop	r28
    194a:	1f 91       	pop	r17
    194c:	0f 91       	pop	r16
    194e:	08 95       	ret

00001950 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    195a:	6a e0       	ldi	r22, 0x0A	; 10
    195c:	8e 81       	ldd	r24, Y+6	; 0x06
    195e:	9f 81       	ldd	r25, Y+7	; 0x07
    1960:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1964:	8c 01       	movw	r16, r24
    1966:	69 e0       	ldi	r22, 0x09	; 9
    1968:	75 e0       	ldi	r23, 0x05	; 5
    196a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    196e:	6a e0       	ldi	r22, 0x0A	; 10
    1970:	c8 01       	movw	r24, r16
    1972:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1976:	8c 01       	movw	r16, r24
    1978:	63 e0       	ldi	r22, 0x03	; 3
    197a:	75 e0       	ldi	r23, 0x05	; 5
    197c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1980:	67 e0       	ldi	r22, 0x07	; 7
    1982:	c8 01       	movw	r24, r16
    1984:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1988:	6a e0       	ldi	r22, 0x0A	; 10
    198a:	8e 81       	ldd	r24, Y+6	; 0x06
    198c:	9f 81       	ldd	r25, Y+7	; 0x07
    198e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1992:	8c 01       	movw	r16, r24
    1994:	64 ee       	ldi	r22, 0xE4	; 228
    1996:	74 e0       	ldi	r23, 0x04	; 4
    1998:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    199c:	6a e0       	ldi	r22, 0x0A	; 10
    199e:	c8 01       	movw	r24, r16
    19a0:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    19a4:	8c 01       	movw	r16, r24
    19a6:	6e ed       	ldi	r22, 0xDE	; 222
    19a8:	74 e0       	ldi	r23, 0x04	; 4
    19aa:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    19ae:	66 e0       	ldi	r22, 0x06	; 6
    19b0:	c8 01       	movw	r24, r16
    19b2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    19b6:	6a e0       	ldi	r22, 0x0A	; 10
    19b8:	8e 81       	ldd	r24, Y+6	; 0x06
    19ba:	9f 81       	ldd	r25, Y+7	; 0x07
    19bc:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    19c0:	8c 01       	movw	r16, r24
    19c2:	67 ec       	ldi	r22, 0xC7	; 199
    19c4:	74 e0       	ldi	r23, 0x04	; 4
    19c6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    19ca:	66 e0       	ldi	r22, 0x06	; 6
    19cc:	c8 01       	movw	r24, r16
    19ce:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    19d2:	6a e0       	ldi	r22, 0x0A	; 10
    19d4:	8e 81       	ldd	r24, Y+6	; 0x06
    19d6:	9f 81       	ldd	r25, Y+7	; 0x07
    19d8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    19dc:	8c 01       	movw	r16, r24
    19de:	6b ea       	ldi	r22, 0xAB	; 171
    19e0:	74 e0       	ldi	r23, 0x04	; 4
    19e2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    19e6:	66 e0       	ldi	r22, 0x06	; 6
    19e8:	c8 01       	movw	r24, r16
    19ea:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    19ee:	6a e0       	ldi	r22, 0x0A	; 10
    19f0:	8e 81       	ldd	r24, Y+6	; 0x06
    19f2:	9f 81       	ldd	r25, Y+7	; 0x07
    19f4:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    19f8:	8c 01       	movw	r16, r24
    19fa:	63 e9       	ldi	r22, 0x93	; 147
    19fc:	74 e0       	ldi	r23, 0x04	; 4
    19fe:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a02:	66 e0       	ldi	r22, 0x06	; 6
    1a04:	c8 01       	movw	r24, r16
    1a06:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1a0a:	6a e0       	ldi	r22, 0x0A	; 10
    1a0c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a10:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1a14:	8c 01       	movw	r16, r24
    1a16:	62 e7       	ldi	r22, 0x72	; 114
    1a18:	74 e0       	ldi	r23, 0x04	; 4
    1a1a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a1e:	66 e0       	ldi	r22, 0x06	; 6
    1a20:	c8 01       	movw	r24, r16
    1a22:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1a26:	6a e0       	ldi	r22, 0x0A	; 10
    1a28:	8e 81       	ldd	r24, Y+6	; 0x06
    1a2a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a2c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1a30:	8c 01       	movw	r16, r24
    1a32:	6b e4       	ldi	r22, 0x4B	; 75
    1a34:	74 e0       	ldi	r23, 0x04	; 4
    1a36:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a3a:	66 e0       	ldi	r22, 0x06	; 6
    1a3c:	c8 01       	movw	r24, r16
    1a3e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1a42:	6a e0       	ldi	r22, 0x0A	; 10
    1a44:	8e 81       	ldd	r24, Y+6	; 0x06
    1a46:	9f 81       	ldd	r25, Y+7	; 0x07
    1a48:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1a4c:	8c 01       	movw	r16, r24
    1a4e:	6d e2       	ldi	r22, 0x2D	; 45
    1a50:	74 e0       	ldi	r23, 0x04	; 4
    1a52:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a56:	66 e0       	ldi	r22, 0x06	; 6
    1a58:	c8 01       	movw	r24, r16
    1a5a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1a5e:	6a e0       	ldi	r22, 0x0A	; 10
    1a60:	8e 81       	ldd	r24, Y+6	; 0x06
    1a62:	9f 81       	ldd	r25, Y+7	; 0x07
    1a64:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1a68:	8c 01       	movw	r16, r24
    1a6a:	62 e1       	ldi	r22, 0x12	; 18
    1a6c:	74 e0       	ldi	r23, 0x04	; 4
    1a6e:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a72:	66 e0       	ldi	r22, 0x06	; 6
    1a74:	c8 01       	movw	r24, r16
    1a76:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1a7a:	6a e0       	ldi	r22, 0x0A	; 10
    1a7c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a7e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a80:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1a84:	ec 01       	movw	r28, r24
    1a86:	63 e0       	ldi	r22, 0x03	; 3
    1a88:	74 e0       	ldi	r23, 0x04	; 4
    1a8a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1a8e:	66 e0       	ldi	r22, 0x06	; 6
    1a90:	ce 01       	movw	r24, r28
    1a92:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
}
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	1f 91       	pop	r17
    1a9c:	0f 91       	pop	r16
    1a9e:	08 95       	ret

00001aa0 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1aa0:	af 92       	push	r10
    1aa2:	bf 92       	push	r11
    1aa4:	cf 92       	push	r12
    1aa6:	df 92       	push	r13
    1aa8:	ef 92       	push	r14
    1aaa:	ff 92       	push	r15
    1aac:	0f 93       	push	r16
    1aae:	1f 93       	push	r17
    1ab0:	cf 93       	push	r28
    1ab2:	df 93       	push	r29
    1ab4:	00 d0       	rcall	.+0      	; 0x1ab6 <_ZN9task_user11show_statusEv+0x16>
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <_ZN9task_user11show_statusEv+0x18>
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
    1abc:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1abe:	19 82       	std	Y+1, r1	; 0x01
    1ac0:	1a 82       	std	Y+2, r1	; 0x02
    1ac2:	1b 82       	std	Y+3, r1	; 0x03
    1ac4:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1ac6:	1d 82       	std	Y+5, r1	; 0x05
    1ac8:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1aca:	0e 94 d5 0f 	call	0x1faa	; 0x1faa <xPortGetFreeHeapSize>
    1ace:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1ad0:	ce 01       	movw	r24, r28
    1ad2:	01 96       	adiw	r24, 0x01	; 1
    1ad4:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <_ZN10time_stamp10set_to_nowEv>
    1ad8:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1ada:	66 e0       	ldi	r22, 0x06	; 6
    1adc:	f8 01       	movw	r30, r16
    1ade:	86 81       	ldd	r24, Z+6	; 0x06
    1ae0:	97 81       	ldd	r25, Z+7	; 0x07
    1ae2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1ae6:	6a e0       	ldi	r22, 0x0A	; 10
    1ae8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1aec:	7c 01       	movw	r14, r24
    1aee:	64 ee       	ldi	r22, 0xE4	; 228
    1af0:	73 e0       	ldi	r23, 0x03	; 3
    1af2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1af6:	6a e0       	ldi	r22, 0x0A	; 10
    1af8:	c7 01       	movw	r24, r14
    1afa:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1afe:	7c 01       	movw	r14, r24
    1b00:	68 ed       	ldi	r22, 0xD8	; 216
    1b02:	73 e0       	ldi	r23, 0x03	; 3
    1b04:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1b08:	66 e0       	ldi	r22, 0x06	; 6
    1b0a:	c7 01       	movw	r24, r14
    1b0c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1b10:	6a e0       	ldi	r22, 0x0A	; 10
    1b12:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1b16:	7c 01       	movw	r14, r24
    1b18:	61 ed       	ldi	r22, 0xD1	; 209
    1b1a:	73 e0       	ldi	r23, 0x03	; 3
    1b1c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1b20:	b5 01       	movw	r22, r10
    1b22:	c7 01       	movw	r24, r14
    1b24:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1b28:	6a e0       	ldi	r22, 0x0A	; 10
    1b2a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1b2e:	7c 01       	movw	r14, r24
    1b30:	63 ec       	ldi	r22, 0xC3	; 195
    1b32:	73 e0       	ldi	r23, 0x03	; 3
    1b34:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1b38:	b6 01       	movw	r22, r12
    1b3a:	c7 01       	movw	r24, r14
    1b3c:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    1b40:	6a e0       	ldi	r22, 0x0A	; 10
    1b42:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1b46:	7c 01       	movw	r14, r24
    1b48:	61 ec       	ldi	r22, 0xC1	; 193
    1b4a:	73 e0       	ldi	r23, 0x03	; 3
    1b4c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1b50:	4f ef       	ldi	r20, 0xFF	; 255
    1b52:	5f e0       	ldi	r21, 0x0F	; 15
    1b54:	60 e0       	ldi	r22, 0x00	; 0
    1b56:	70 e0       	ldi	r23, 0x00	; 0
    1b58:	c7 01       	movw	r24, r14
    1b5a:	0e 94 69 20 	call	0x40d2	; 0x40d2 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1b5e:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1b62:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1b66:	6a e0       	ldi	r22, 0x0A	; 10
    1b68:	f8 01       	movw	r30, r16
    1b6a:	86 81       	ldd	r24, Z+6	; 0x06
    1b6c:	97 81       	ldd	r25, Z+7	; 0x07
    1b6e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1b72:	7c 01       	movw	r14, r24
    1b74:	66 eb       	ldi	r22, 0xB6	; 182
    1b76:	73 e0       	ldi	r23, 0x03	; 3
    1b78:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1b7c:	b6 01       	movw	r22, r12
    1b7e:	c7 01       	movw	r24, r14
    1b80:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    1b84:	66 e0       	ldi	r22, 0x06	; 6
    1b86:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1b8a:	66 e0       	ldi	r22, 0x06	; 6
    1b8c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1b90:	f8 01       	movw	r30, r16
    1b92:	86 81       	ldd	r24, Z+6	; 0x06
    1b94:	97 81       	ldd	r25, Z+7	; 0x07
    1b96:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <_Z15print_task_listP8emstream>
}
    1b9a:	26 96       	adiw	r28, 0x06	; 6
    1b9c:	cd bf       	out	0x3d, r28	; 61
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	df 91       	pop	r29
    1ba2:	cf 91       	pop	r28
    1ba4:	1f 91       	pop	r17
    1ba6:	0f 91       	pop	r16
    1ba8:	ff 90       	pop	r15
    1baa:	ef 90       	pop	r14
    1bac:	df 90       	pop	r13
    1bae:	cf 90       	pop	r12
    1bb0:	bf 90       	pop	r11
    1bb2:	af 90       	pop	r10
    1bb4:	08 95       	ret

00001bb6 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	00 d0       	rcall	.+0      	; 0x1bbc <_ZN9task_user3runEv+0x6>
    1bbc:	00 d0       	rcall	.+0      	; 0x1bbe <_ZN9task_user3runEv+0x8>
    1bbe:	cd b7       	in	r28, 0x3d	; 61
    1bc0:	de b7       	in	r29, 0x3e	; 62
    1bc2:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1bc4:	19 82       	std	Y+1, r1	; 0x01
    1bc6:	1a 82       	std	Y+2, r1	; 0x02
    1bc8:	1b 82       	std	Y+3, r1	; 0x03
    1bca:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1bcc:	1d 82       	std	Y+5, r1	; 0x05
    1bce:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1bd0:	6a e0       	ldi	r22, 0x0A	; 10
    1bd2:	dc 01       	movw	r26, r24
    1bd4:	16 96       	adiw	r26, 0x06	; 6
    1bd6:	8d 91       	ld	r24, X+
    1bd8:	9c 91       	ld	r25, X
    1bda:	17 97       	sbiw	r26, 0x07	; 7
    1bdc:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1be0:	7c 01       	movw	r14, r24
    1be2:	62 e5       	ldi	r22, 0x52	; 82
    1be4:	75 e0       	ldi	r23, 0x05	; 5
    1be6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1bea:	66 e0       	ldi	r22, 0x06	; 6
    1bec:	c7 01       	movw	r24, r14
    1bee:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1bf2:	f8 01       	movw	r30, r16
    1bf4:	84 85       	ldd	r24, Z+12	; 0x0c
    1bf6:	88 23       	and	r24, r24
    1bf8:	21 f0       	breq	.+8      	; 0x1c02 <_ZN9task_user3runEv+0x4c>
    1bfa:	81 30       	cpi	r24, 0x01	; 1
    1bfc:	09 f4       	brne	.+2      	; 0x1c00 <_ZN9task_user3runEv+0x4a>
    1bfe:	5d c0       	rjmp	.+186    	; 0x1cba <_ZN9task_user3runEv+0x104>
    1c00:	d8 c0       	rjmp	.+432    	; 0x1db2 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1c02:	86 81       	ldd	r24, Z+6	; 0x06
    1c04:	97 81       	ldd	r25, Z+7	; 0x07
    1c06:	dc 01       	movw	r26, r24
    1c08:	ed 91       	ld	r30, X+
    1c0a:	fc 91       	ld	r31, X
    1c0c:	04 80       	ldd	r0, Z+4	; 0x04
    1c0e:	f5 81       	ldd	r31, Z+5	; 0x05
    1c10:	e0 2d       	mov	r30, r0
    1c12:	19 95       	eicall
    1c14:	88 23       	and	r24, r24
    1c16:	a9 f1       	breq	.+106    	; 0x1c82 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1c18:	f8 01       	movw	r30, r16
    1c1a:	86 81       	ldd	r24, Z+6	; 0x06
    1c1c:	97 81       	ldd	r25, Z+7	; 0x07
    1c1e:	dc 01       	movw	r26, r24
    1c20:	ed 91       	ld	r30, X+
    1c22:	fc 91       	ld	r31, X
    1c24:	06 80       	ldd	r0, Z+6	; 0x06
    1c26:	f7 81       	ldd	r31, Z+7	; 0x07
    1c28:	e0 2d       	mov	r30, r0
    1c2a:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1c2c:	99 27       	eor	r25, r25
    1c2e:	81 30       	cpi	r24, 0x01	; 1
    1c30:	91 05       	cpc	r25, r1
    1c32:	f9 f0       	breq	.+62     	; 0x1c72 <_ZN9task_user3runEv+0xbc>
    1c34:	03 97       	sbiw	r24, 0x03	; 3
    1c36:	09 f0       	breq	.+2      	; 0x1c3a <_ZN9task_user3runEv+0x84>
    1c38:	d8 c0       	rjmp	.+432    	; 0x1dea <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1c3a:	6a e0       	ldi	r22, 0x0A	; 10
    1c3c:	f8 01       	movw	r30, r16
    1c3e:	86 81       	ldd	r24, Z+6	; 0x06
    1c40:	97 81       	ldd	r25, Z+7	; 0x07
    1c42:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1c46:	8c 01       	movw	r16, r24
    1c48:	64 e4       	ldi	r22, 0x44	; 68
    1c4a:	75 e0       	ldi	r23, 0x05	; 5
    1c4c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1c50:	66 e0       	ldi	r22, 0x06	; 6
    1c52:	c8 01       	movw	r24, r16
    1c54:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1c58:	93 e0       	ldi	r25, 0x03	; 3
    1c5a:	88 ed       	ldi	r24, 0xD8	; 216
    1c5c:	08 b6       	in	r0, 0x38	; 56
    1c5e:	18 be       	out	0x38, r1	; 56
    1c60:	84 bf       	out	0x34, r24	; 52
    1c62:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1c66:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1c6a:	81 fd       	sbrc	r24, 1
    1c6c:	fc cf       	rjmp	.-8      	; 0x1c66 <_ZN9task_user3runEv+0xb0>
    1c6e:	08 be       	out	0x38, r0	; 56
    1c70:	ff cf       	rjmp	.-2      	; 0x1c70 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1c72:	c8 01       	movw	r24, r16
    1c74:	0e 94 a8 0c 	call	0x1950	; 0x1950 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1c78:	61 e0       	ldi	r22, 0x01	; 1
    1c7a:	c8 01       	movw	r24, r16
    1c7c:	0e 94 48 1a 	call	0x3490	; 0x3490 <_ZN8frt_task13transition_toEh>
							break;
    1c80:	b4 c0       	rjmp	.+360    	; 0x1dea <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1c82:	80 ef       	ldi	r24, 0xF0	; 240
    1c84:	92 e3       	ldi	r25, 0x32	; 50
    1c86:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <_ZN14frt_text_queue14check_for_charEv>
    1c8a:	88 23       	and	r24, r24
    1c8c:	09 f4       	brne	.+2      	; 0x1c90 <_ZN9task_user3runEv+0xda>
    1c8e:	ad c0       	rjmp	.+346    	; 0x1dea <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1c90:	d8 01       	movw	r26, r16
    1c92:	16 96       	adiw	r26, 0x06	; 6
    1c94:	ed 91       	ld	r30, X+
    1c96:	fc 91       	ld	r31, X
    1c98:	17 97       	sbiw	r26, 0x07	; 7
    1c9a:	01 90       	ld	r0, Z+
    1c9c:	f0 81       	ld	r31, Z
    1c9e:	e0 2d       	mov	r30, r0
    1ca0:	e2 80       	ldd	r14, Z+2	; 0x02
    1ca2:	f3 80       	ldd	r15, Z+3	; 0x03
    1ca4:	80 ef       	ldi	r24, 0xF0	; 240
    1ca6:	92 e3       	ldi	r25, 0x32	; 50
    1ca8:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <_ZN14frt_text_queue7getcharEv>
    1cac:	68 2f       	mov	r22, r24
    1cae:	f8 01       	movw	r30, r16
    1cb0:	86 81       	ldd	r24, Z+6	; 0x06
    1cb2:	97 81       	ldd	r25, Z+7	; 0x07
    1cb4:	f7 01       	movw	r30, r14
    1cb6:	19 95       	eicall
    1cb8:	98 c0       	rjmp	.+304    	; 0x1dea <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1cba:	86 81       	ldd	r24, Z+6	; 0x06
    1cbc:	97 81       	ldd	r25, Z+7	; 0x07
    1cbe:	dc 01       	movw	r26, r24
    1cc0:	ed 91       	ld	r30, X+
    1cc2:	fc 91       	ld	r31, X
    1cc4:	04 80       	ldd	r0, Z+4	; 0x04
    1cc6:	f5 81       	ldd	r31, Z+5	; 0x05
    1cc8:	e0 2d       	mov	r30, r0
    1cca:	19 95       	eicall
    1ccc:	88 23       	and	r24, r24
    1cce:	09 f4       	brne	.+2      	; 0x1cd2 <_ZN9task_user3runEv+0x11c>
    1cd0:	8c c0       	rjmp	.+280    	; 0x1dea <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1cd2:	f8 01       	movw	r30, r16
    1cd4:	86 81       	ldd	r24, Z+6	; 0x06
    1cd6:	97 81       	ldd	r25, Z+7	; 0x07
    1cd8:	dc 01       	movw	r26, r24
    1cda:	ed 91       	ld	r30, X+
    1cdc:	fc 91       	ld	r31, X
    1cde:	06 80       	ldd	r0, Z+6	; 0x06
    1ce0:	f7 81       	ldd	r31, Z+7	; 0x07
    1ce2:	e0 2d       	mov	r30, r0
    1ce4:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1ce6:	9c 01       	movw	r18, r24
    1ce8:	33 27       	eor	r19, r19
    1cea:	28 36       	cpi	r18, 0x68	; 104
    1cec:	31 05       	cpc	r19, r1
    1cee:	59 f1       	breq	.+86     	; 0x1d46 <_ZN9task_user3runEv+0x190>
    1cf0:	3c f4       	brge	.+14     	; 0x1d00 <_ZN9task_user3runEv+0x14a>
    1cf2:	2b 31       	cpi	r18, 0x1B	; 27
    1cf4:	31 05       	cpc	r19, r1
    1cf6:	59 f1       	breq	.+86     	; 0x1d4e <_ZN9task_user3runEv+0x198>
    1cf8:	25 36       	cpi	r18, 0x65	; 101
    1cfa:	31 05       	cpc	r19, r1
    1cfc:	41 f1       	breq	.+80     	; 0x1d4e <_ZN9task_user3runEv+0x198>
    1cfe:	3b c0       	rjmp	.+118    	; 0x1d76 <_ZN9task_user3runEv+0x1c0>
    1d00:	23 37       	cpi	r18, 0x73	; 115
    1d02:	31 05       	cpc	r19, r1
    1d04:	c1 f0       	breq	.+48     	; 0x1d36 <_ZN9task_user3runEv+0x180>
    1d06:	26 37       	cpi	r18, 0x76	; 118
    1d08:	31 05       	cpc	r19, r1
    1d0a:	89 f0       	breq	.+34     	; 0x1d2e <_ZN9task_user3runEv+0x178>
    1d0c:	2e 36       	cpi	r18, 0x6E	; 110
    1d0e:	31 05       	cpc	r19, r1
    1d10:	91 f5       	brne	.+100    	; 0x1d76 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1d12:	ce 01       	movw	r24, r28
    1d14:	01 96       	adiw	r24, 0x01	; 1
    1d16:	0e 94 fd 1d 	call	0x3bfa	; 0x3bfa <_ZN10time_stamp10set_to_nowEv>
    1d1a:	bc 01       	movw	r22, r24
    1d1c:	f8 01       	movw	r30, r16
    1d1e:	86 81       	ldd	r24, Z+6	; 0x06
    1d20:	97 81       	ldd	r25, Z+7	; 0x07
    1d22:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <_ZlsR8emstreamR10time_stamp>
    1d26:	66 e0       	ldi	r22, 0x06	; 6
    1d28:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1d2c:	5e c0       	rjmp	.+188    	; 0x1dea <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1d2e:	c8 01       	movw	r24, r16
    1d30:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <_ZN9task_user11show_statusEv>
							break;
    1d34:	5a c0       	rjmp	.+180    	; 0x1dea <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1d36:	d8 01       	movw	r26, r16
    1d38:	16 96       	adiw	r26, 0x06	; 6
    1d3a:	8d 91       	ld	r24, X+
    1d3c:	9c 91       	ld	r25, X
    1d3e:	17 97       	sbiw	r26, 0x07	; 7
    1d40:	0e 94 61 1b 	call	0x36c2	; 0x36c2 <_Z17print_task_stacksP8emstream>
							break;
    1d44:	52 c0       	rjmp	.+164    	; 0x1dea <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1d46:	c8 01       	movw	r24, r16
    1d48:	0e 94 a8 0c 	call	0x1950	; 0x1950 <_ZN9task_user18print_help_messageEv>
							break;
    1d4c:	4e c0       	rjmp	.+156    	; 0x1dea <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1d4e:	6a e0       	ldi	r22, 0x0A	; 10
    1d50:	f8 01       	movw	r30, r16
    1d52:	86 81       	ldd	r24, Z+6	; 0x06
    1d54:	97 81       	ldd	r25, Z+7	; 0x07
    1d56:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1d5a:	7c 01       	movw	r14, r24
    1d5c:	62 e3       	ldi	r22, 0x32	; 50
    1d5e:	75 e0       	ldi	r23, 0x05	; 5
    1d60:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1d64:	66 e0       	ldi	r22, 0x06	; 6
    1d66:	c7 01       	movw	r24, r14
    1d68:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1d6c:	60 e0       	ldi	r22, 0x00	; 0
    1d6e:	c8 01       	movw	r24, r16
    1d70:	0e 94 48 1a 	call	0x3490	; 0x3490 <_ZN8frt_task13transition_toEh>
							break;
    1d74:	3a c0       	rjmp	.+116    	; 0x1dea <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1d76:	f8 01       	movw	r30, r16
    1d78:	a6 81       	ldd	r26, Z+6	; 0x06
    1d7a:	b7 81       	ldd	r27, Z+7	; 0x07
    1d7c:	ed 91       	ld	r30, X+
    1d7e:	fc 91       	ld	r31, X
    1d80:	11 97       	sbiw	r26, 0x01	; 1
    1d82:	02 80       	ldd	r0, Z+2	; 0x02
    1d84:	f3 81       	ldd	r31, Z+3	; 0x03
    1d86:	e0 2d       	mov	r30, r0
    1d88:	68 2f       	mov	r22, r24
    1d8a:	cd 01       	movw	r24, r26
    1d8c:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1d8e:	6a e0       	ldi	r22, 0x0A	; 10
    1d90:	d8 01       	movw	r26, r16
    1d92:	16 96       	adiw	r26, 0x06	; 6
    1d94:	8d 91       	ld	r24, X+
    1d96:	9c 91       	ld	r25, X
    1d98:	17 97       	sbiw	r26, 0x07	; 7
    1d9a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1d9e:	7c 01       	movw	r14, r24
    1da0:	6c e2       	ldi	r22, 0x2C	; 44
    1da2:	75 e0       	ldi	r23, 0x05	; 5
    1da4:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1da8:	66 e0       	ldi	r22, 0x06	; 6
    1daa:	c7 01       	movw	r24, r14
    1dac:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1db0:	1c c0       	rjmp	.+56     	; 0x1dea <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1db2:	6a e0       	ldi	r22, 0x0A	; 10
    1db4:	f8 01       	movw	r30, r16
    1db6:	86 81       	ldd	r24, Z+6	; 0x06
    1db8:	97 81       	ldd	r25, Z+7	; 0x07
    1dba:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    1dbe:	8c 01       	movw	r16, r24
    1dc0:	6f e0       	ldi	r22, 0x0F	; 15
    1dc2:	75 e0       	ldi	r23, 0x05	; 5
    1dc4:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    1dc8:	66 e0       	ldi	r22, 0x06	; 6
    1dca:	c8 01       	movw	r24, r16
    1dcc:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1dd0:	93 e0       	ldi	r25, 0x03	; 3
    1dd2:	88 ed       	ldi	r24, 0xD8	; 216
    1dd4:	08 b6       	in	r0, 0x38	; 56
    1dd6:	18 be       	out	0x38, r1	; 56
    1dd8:	84 bf       	out	0x34, r24	; 52
    1dda:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1dde:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1de2:	81 fd       	sbrc	r24, 1
    1de4:	fc cf       	rjmp	.-8      	; 0x1dde <_ZN9task_user3runEv+0x228>
    1de6:	08 be       	out	0x38, r0	; 56
    1de8:	ff cf       	rjmp	.-2      	; 0x1de8 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1dea:	f8 01       	movw	r30, r16
    1dec:	86 85       	ldd	r24, Z+14	; 0x0e
    1dee:	97 85       	ldd	r25, Z+15	; 0x0f
    1df0:	a0 89       	ldd	r26, Z+16	; 0x10
    1df2:	b1 89       	ldd	r27, Z+17	; 0x11
    1df4:	01 96       	adiw	r24, 0x01	; 1
    1df6:	a1 1d       	adc	r26, r1
    1df8:	b1 1d       	adc	r27, r1
    1dfa:	86 87       	std	Z+14, r24	; 0x0e
    1dfc:	97 87       	std	Z+15, r25	; 0x0f
    1dfe:	a0 8b       	std	Z+16, r26	; 0x10
    1e00:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1e02:	68 ee       	ldi	r22, 0xE8	; 232
    1e04:	73 e0       	ldi	r23, 0x03	; 3
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	0e 94 1c 18 	call	0x3038	; 0x3038 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1e0e:	f1 ce       	rjmp	.-542    	; 0x1bf2 <_ZN9task_user3runEv+0x3c>

00001e10 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1e10:	0f 93       	push	r16
    1e12:	1f 93       	push	r17
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1e1a:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1e1e:	80 91 34 22 	lds	r24, 0x2234	; 0x802234 <__data_end>
    1e22:	81 11       	cpse	r24, r1
    1e24:	1d c0       	rjmp	.+58     	; 0x1e60 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1e26:	a9 e3       	ldi	r26, 0x39	; 57
    1e28:	b2 e2       	ldi	r27, 0x22	; 34
    1e2a:	ed e3       	ldi	r30, 0x3D	; 61
    1e2c:	f2 e2       	ldi	r31, 0x22	; 34
    1e2e:	ed 93       	st	X+, r30
    1e30:	fc 93       	st	X, r31
    1e32:	11 97       	sbiw	r26, 0x01	; 1
    1e34:	12 96       	adiw	r26, 0x02	; 2
    1e36:	1d 92       	st	X+, r1
    1e38:	1c 92       	st	X, r1
    1e3a:	13 97       	sbiw	r26, 0x03	; 3
    1e3c:	a5 e3       	ldi	r26, 0x35	; 53
    1e3e:	b2 e2       	ldi	r27, 0x22	; 34
    1e40:	8f ef       	ldi	r24, 0xFF	; 255
    1e42:	9f e0       	ldi	r25, 0x0F	; 15
    1e44:	12 96       	adiw	r26, 0x02	; 2
    1e46:	8d 93       	st	X+, r24
    1e48:	9c 93       	st	X, r25
    1e4a:	13 97       	sbiw	r26, 0x03	; 3
    1e4c:	1d 92       	st	X+, r1
    1e4e:	1c 92       	st	X, r1
    1e50:	11 97       	sbiw	r26, 0x01	; 1
    1e52:	82 83       	std	Z+2, r24	; 0x02
    1e54:	93 83       	std	Z+3, r25	; 0x03
    1e56:	a0 83       	st	Z, r26
    1e58:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1e5a:	81 e0       	ldi	r24, 0x01	; 1
    1e5c:	80 93 34 22 	sts	0x2234, r24	; 0x802234 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1e60:	20 97       	sbiw	r28, 0x00	; 0
    1e62:	09 f4       	brne	.+2      	; 0x1e66 <pvPortMalloc+0x56>
    1e64:	5f c0       	rjmp	.+190    	; 0x1f24 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1e66:	9e 01       	movw	r18, r28
    1e68:	2b 5f       	subi	r18, 0xFB	; 251
    1e6a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1e6c:	24 96       	adiw	r28, 0x04	; 4
    1e6e:	ce 3f       	cpi	r28, 0xFE	; 254
    1e70:	df 40       	sbci	r29, 0x0F	; 15
    1e72:	08 f0       	brcs	.+2      	; 0x1e76 <pvPortMalloc+0x66>
    1e74:	5a c0       	rjmp	.+180    	; 0x1f2a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1e76:	e0 91 39 22 	lds	r30, 0x2239	; 0x802239 <xStart>
    1e7a:	f0 91 3a 22 	lds	r31, 0x223A	; 0x80223a <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1e7e:	a9 e3       	ldi	r26, 0x39	; 57
    1e80:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e82:	02 c0       	rjmp	.+4      	; 0x1e88 <pvPortMalloc+0x78>
    1e84:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1e86:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e88:	82 81       	ldd	r24, Z+2	; 0x02
    1e8a:	93 81       	ldd	r25, Z+3	; 0x03
    1e8c:	82 17       	cp	r24, r18
    1e8e:	93 07       	cpc	r25, r19
    1e90:	20 f4       	brcc	.+8      	; 0x1e9a <pvPortMalloc+0x8a>
    1e92:	80 81       	ld	r24, Z
    1e94:	91 81       	ldd	r25, Z+1	; 0x01
    1e96:	00 97       	sbiw	r24, 0x00	; 0
    1e98:	a9 f7       	brne	.-22     	; 0x1e84 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1e9a:	c2 e2       	ldi	r28, 0x22	; 34
    1e9c:	e5 33       	cpi	r30, 0x35	; 53
    1e9e:	fc 07       	cpc	r31, r28
    1ea0:	09 f4       	brne	.+2      	; 0x1ea4 <pvPortMalloc+0x94>
    1ea2:	46 c0       	rjmp	.+140    	; 0x1f30 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1ea4:	cd 91       	ld	r28, X+
    1ea6:	dc 91       	ld	r29, X
    1ea8:	11 97       	sbiw	r26, 0x01	; 1
    1eaa:	8e 01       	movw	r16, r28
    1eac:	0b 5f       	subi	r16, 0xFB	; 251
    1eae:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1eb0:	80 81       	ld	r24, Z
    1eb2:	91 81       	ldd	r25, Z+1	; 0x01
    1eb4:	8d 93       	st	X+, r24
    1eb6:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1eb8:	82 81       	ldd	r24, Z+2	; 0x02
    1eba:	93 81       	ldd	r25, Z+3	; 0x03
    1ebc:	82 1b       	sub	r24, r18
    1ebe:	93 0b       	sbc	r25, r19
    1ec0:	8b 30       	cpi	r24, 0x0B	; 11
    1ec2:	91 05       	cpc	r25, r1
    1ec4:	10 f1       	brcs	.+68     	; 0x1f0a <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1ec6:	bf 01       	movw	r22, r30
    1ec8:	62 0f       	add	r22, r18
    1eca:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1ecc:	db 01       	movw	r26, r22
    1ece:	12 96       	adiw	r26, 0x02	; 2
    1ed0:	8d 93       	st	X+, r24
    1ed2:	9c 93       	st	X, r25
    1ed4:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1ed6:	22 83       	std	Z+2, r18	; 0x02
    1ed8:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1eda:	12 96       	adiw	r26, 0x02	; 2
    1edc:	4d 91       	ld	r20, X+
    1ede:	5c 91       	ld	r21, X
    1ee0:	13 97       	sbiw	r26, 0x03	; 3
    1ee2:	89 e3       	ldi	r24, 0x39	; 57
    1ee4:	92 e2       	ldi	r25, 0x22	; 34
    1ee6:	01 c0       	rjmp	.+2      	; 0x1eea <pvPortMalloc+0xda>
    1ee8:	cd 01       	movw	r24, r26
    1eea:	ec 01       	movw	r28, r24
    1eec:	a8 81       	ld	r26, Y
    1eee:	b9 81       	ldd	r27, Y+1	; 0x01
    1ef0:	12 96       	adiw	r26, 0x02	; 2
    1ef2:	2d 91       	ld	r18, X+
    1ef4:	3c 91       	ld	r19, X
    1ef6:	13 97       	sbiw	r26, 0x03	; 3
    1ef8:	24 17       	cp	r18, r20
    1efa:	35 07       	cpc	r19, r21
    1efc:	a8 f3       	brcs	.-22     	; 0x1ee8 <pvPortMalloc+0xd8>
    1efe:	eb 01       	movw	r28, r22
    1f00:	a8 83       	st	Y, r26
    1f02:	b9 83       	std	Y+1, r27	; 0x01
    1f04:	dc 01       	movw	r26, r24
    1f06:	6d 93       	st	X+, r22
    1f08:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1f0a:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1f0e:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1f12:	22 81       	ldd	r18, Z+2	; 0x02
    1f14:	33 81       	ldd	r19, Z+3	; 0x03
    1f16:	82 1b       	sub	r24, r18
    1f18:	93 0b       	sbc	r25, r19
    1f1a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f1e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1f22:	08 c0       	rjmp	.+16     	; 0x1f34 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1f24:	00 e0       	ldi	r16, 0x00	; 0
    1f26:	10 e0       	ldi	r17, 0x00	; 0
    1f28:	05 c0       	rjmp	.+10     	; 0x1f34 <pvPortMalloc+0x124>
    1f2a:	00 e0       	ldi	r16, 0x00	; 0
    1f2c:	10 e0       	ldi	r17, 0x00	; 0
    1f2e:	02 c0       	rjmp	.+4      	; 0x1f34 <pvPortMalloc+0x124>
    1f30:	00 e0       	ldi	r16, 0x00	; 0
    1f32:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1f34:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1f38:	c8 01       	movw	r24, r16
    1f3a:	df 91       	pop	r29
    1f3c:	cf 91       	pop	r28
    1f3e:	1f 91       	pop	r17
    1f40:	0f 91       	pop	r16
    1f42:	08 95       	ret

00001f44 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1f44:	0f 93       	push	r16
    1f46:	1f 93       	push	r17
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1f4c:	00 97       	sbiw	r24, 0x00	; 0
    1f4e:	41 f1       	breq	.+80     	; 0x1fa0 <vPortFree+0x5c>
    1f50:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1f52:	8c 01       	movw	r16, r24
    1f54:	05 50       	subi	r16, 0x05	; 5
    1f56:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1f58:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	42 81       	ldd	r20, Z+2	; 0x02
    1f60:	53 81       	ldd	r21, Z+3	; 0x03
    1f62:	a9 e3       	ldi	r26, 0x39	; 57
    1f64:	b2 e2       	ldi	r27, 0x22	; 34
    1f66:	01 c0       	rjmp	.+2      	; 0x1f6a <vPortFree+0x26>
    1f68:	df 01       	movw	r26, r30
    1f6a:	ed 91       	ld	r30, X+
    1f6c:	fc 91       	ld	r31, X
    1f6e:	11 97       	sbiw	r26, 0x01	; 1
    1f70:	22 81       	ldd	r18, Z+2	; 0x02
    1f72:	33 81       	ldd	r19, Z+3	; 0x03
    1f74:	24 17       	cp	r18, r20
    1f76:	35 07       	cpc	r19, r21
    1f78:	b8 f3       	brcs	.-18     	; 0x1f68 <vPortFree+0x24>
    1f7a:	25 97       	sbiw	r28, 0x05	; 5
    1f7c:	e8 83       	st	Y, r30
    1f7e:	f9 83       	std	Y+1, r31	; 0x01
    1f80:	0d 93       	st	X+, r16
    1f82:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1f84:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1f88:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1f90:	82 0f       	add	r24, r18
    1f92:	93 1f       	adc	r25, r19
    1f94:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f98:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1f9c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
	}
}
    1fa0:	df 91       	pop	r29
    1fa2:	cf 91       	pop	r28
    1fa4:	1f 91       	pop	r17
    1fa6:	0f 91       	pop	r16
    1fa8:	08 95       	ret

00001faa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1faa:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1fae:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1fb2:	08 95       	ret

00001fb4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1fb4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1fb6:	03 96       	adiw	r24, 0x03	; 3
    1fb8:	81 83       	std	Z+1, r24	; 0x01
    1fba:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1fbc:	4f ef       	ldi	r20, 0xFF	; 255
    1fbe:	5f ef       	ldi	r21, 0xFF	; 255
    1fc0:	ba 01       	movw	r22, r20
    1fc2:	43 83       	std	Z+3, r20	; 0x03
    1fc4:	54 83       	std	Z+4, r21	; 0x04
    1fc6:	65 83       	std	Z+5, r22	; 0x05
    1fc8:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1fca:	87 83       	std	Z+7, r24	; 0x07
    1fcc:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1fce:	81 87       	std	Z+9, r24	; 0x09
    1fd0:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1fd2:	10 82       	st	Z, r1
    1fd4:	08 95       	ret

00001fd6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1fd6:	fc 01       	movw	r30, r24
    1fd8:	12 86       	std	Z+10, r1	; 0x0a
    1fda:	13 86       	std	Z+11, r1	; 0x0b
    1fdc:	08 95       	ret

00001fde <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1fde:	cf 93       	push	r28
    1fe0:	df 93       	push	r29
    1fe2:	fc 01       	movw	r30, r24
    1fe4:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1fe6:	21 81       	ldd	r18, Z+1	; 0x01
    1fe8:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1fea:	e9 01       	movw	r28, r18
    1fec:	8c 81       	ldd	r24, Y+4	; 0x04
    1fee:	9d 81       	ldd	r25, Y+5	; 0x05
    1ff0:	14 96       	adiw	r26, 0x04	; 4
    1ff2:	8d 93       	st	X+, r24
    1ff4:	9c 93       	st	X, r25
    1ff6:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1ff8:	81 81       	ldd	r24, Z+1	; 0x01
    1ffa:	92 81       	ldd	r25, Z+2	; 0x02
    1ffc:	16 96       	adiw	r26, 0x06	; 6
    1ffe:	8d 93       	st	X+, r24
    2000:	9c 93       	st	X, r25
    2002:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2004:	8c 81       	ldd	r24, Y+4	; 0x04
    2006:	9d 81       	ldd	r25, Y+5	; 0x05
    2008:	ec 01       	movw	r28, r24
    200a:	6e 83       	std	Y+6, r22	; 0x06
    200c:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    200e:	e9 01       	movw	r28, r18
    2010:	6c 83       	std	Y+4, r22	; 0x04
    2012:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2014:	61 83       	std	Z+1, r22	; 0x01
    2016:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2018:	1a 96       	adiw	r26, 0x0a	; 10
    201a:	ed 93       	st	X+, r30
    201c:	fc 93       	st	X, r31
    201e:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    2020:	80 81       	ld	r24, Z
    2022:	8f 5f       	subi	r24, 0xFF	; 255
    2024:	80 83       	st	Z, r24
}
    2026:	df 91       	pop	r29
    2028:	cf 91       	pop	r28
    202a:	08 95       	ret

0000202c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    202c:	0f 93       	push	r16
    202e:	1f 93       	push	r17
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2036:	08 81       	ld	r16, Y
    2038:	19 81       	ldd	r17, Y+1	; 0x01
    203a:	2a 81       	ldd	r18, Y+2	; 0x02
    203c:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    203e:	0f 3f       	cpi	r16, 0xFF	; 255
    2040:	4f ef       	ldi	r20, 0xFF	; 255
    2042:	14 07       	cpc	r17, r20
    2044:	24 07       	cpc	r18, r20
    2046:	34 07       	cpc	r19, r20
    2048:	31 f4       	brne	.+12     	; 0x2056 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    204a:	dc 01       	movw	r26, r24
    204c:	19 96       	adiw	r26, 0x09	; 9
    204e:	ed 91       	ld	r30, X+
    2050:	fc 91       	ld	r31, X
    2052:	1a 97       	sbiw	r26, 0x0a	; 10
    2054:	1f c0       	rjmp	.+62     	; 0x2094 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2056:	fc 01       	movw	r30, r24
    2058:	33 96       	adiw	r30, 0x03	; 3
    205a:	dc 01       	movw	r26, r24
    205c:	17 96       	adiw	r26, 0x07	; 7
    205e:	4d 91       	ld	r20, X+
    2060:	5c 91       	ld	r21, X
    2062:	18 97       	sbiw	r26, 0x08	; 8
    2064:	da 01       	movw	r26, r20
    2066:	4d 91       	ld	r20, X+
    2068:	5d 91       	ld	r21, X+
    206a:	6d 91       	ld	r22, X+
    206c:	7c 91       	ld	r23, X
    206e:	04 17       	cp	r16, r20
    2070:	15 07       	cpc	r17, r21
    2072:	26 07       	cpc	r18, r22
    2074:	37 07       	cpc	r19, r23
    2076:	70 f0       	brcs	.+28     	; 0x2094 <vListInsert+0x68>
    2078:	04 80       	ldd	r0, Z+4	; 0x04
    207a:	f5 81       	ldd	r31, Z+5	; 0x05
    207c:	e0 2d       	mov	r30, r0
    207e:	a4 81       	ldd	r26, Z+4	; 0x04
    2080:	b5 81       	ldd	r27, Z+5	; 0x05
    2082:	4d 91       	ld	r20, X+
    2084:	5d 91       	ld	r21, X+
    2086:	6d 91       	ld	r22, X+
    2088:	7c 91       	ld	r23, X
    208a:	04 17       	cp	r16, r20
    208c:	15 07       	cpc	r17, r21
    208e:	26 07       	cpc	r18, r22
    2090:	37 07       	cpc	r19, r23
    2092:	90 f7       	brcc	.-28     	; 0x2078 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2094:	a4 81       	ldd	r26, Z+4	; 0x04
    2096:	b5 81       	ldd	r27, Z+5	; 0x05
    2098:	ac 83       	std	Y+4, r26	; 0x04
    209a:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    209c:	16 96       	adiw	r26, 0x06	; 6
    209e:	cd 93       	st	X+, r28
    20a0:	dc 93       	st	X, r29
    20a2:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    20a4:	ee 83       	std	Y+6, r30	; 0x06
    20a6:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    20a8:	c4 83       	std	Z+4, r28	; 0x04
    20aa:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    20ac:	8a 87       	std	Y+10, r24	; 0x0a
    20ae:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    20b0:	fc 01       	movw	r30, r24
    20b2:	20 81       	ld	r18, Z
    20b4:	2f 5f       	subi	r18, 0xFF	; 255
    20b6:	20 83       	st	Z, r18
}
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28
    20bc:	1f 91       	pop	r17
    20be:	0f 91       	pop	r16
    20c0:	08 95       	ret

000020c2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    20c2:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    20c4:	a4 81       	ldd	r26, Z+4	; 0x04
    20c6:	b5 81       	ldd	r27, Z+5	; 0x05
    20c8:	86 81       	ldd	r24, Z+6	; 0x06
    20ca:	97 81       	ldd	r25, Z+7	; 0x07
    20cc:	16 96       	adiw	r26, 0x06	; 6
    20ce:	8d 93       	st	X+, r24
    20d0:	9c 93       	st	X, r25
    20d2:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    20d4:	a6 81       	ldd	r26, Z+6	; 0x06
    20d6:	b7 81       	ldd	r27, Z+7	; 0x07
    20d8:	84 81       	ldd	r24, Z+4	; 0x04
    20da:	95 81       	ldd	r25, Z+5	; 0x05
    20dc:	14 96       	adiw	r26, 0x04	; 4
    20de:	8d 93       	st	X+, r24
    20e0:	9c 93       	st	X, r25
    20e2:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    20e4:	a2 85       	ldd	r26, Z+10	; 0x0a
    20e6:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    20e8:	11 96       	adiw	r26, 0x01	; 1
    20ea:	8d 91       	ld	r24, X+
    20ec:	9c 91       	ld	r25, X
    20ee:	12 97       	sbiw	r26, 0x02	; 2
    20f0:	e8 17       	cp	r30, r24
    20f2:	f9 07       	cpc	r31, r25
    20f4:	31 f4       	brne	.+12     	; 0x2102 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    20f6:	86 81       	ldd	r24, Z+6	; 0x06
    20f8:	97 81       	ldd	r25, Z+7	; 0x07
    20fa:	11 96       	adiw	r26, 0x01	; 1
    20fc:	8d 93       	st	X+, r24
    20fe:	9c 93       	st	X, r25
    2100:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    2102:	12 86       	std	Z+10, r1	; 0x0a
    2104:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    2106:	8c 91       	ld	r24, X
    2108:	81 50       	subi	r24, 0x01	; 1
    210a:	8c 93       	st	X, r24
    210c:	08 95       	ret

0000210e <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    210e:	80 93 00 33 	sts	0x3300, r24	; 0x803300 <portStackTopForTask>
    2112:	90 93 01 33 	sts	0x3301, r25	; 0x803301 <portStackTopForTask+0x1>
    2116:	31 e1       	ldi	r19, 0x11	; 17
    2118:	fc 01       	movw	r30, r24
    211a:	30 83       	st	Z, r19
    211c:	31 97       	sbiw	r30, 0x01	; 1
    211e:	22 e2       	ldi	r18, 0x22	; 34
    2120:	20 83       	st	Z, r18
    2122:	31 97       	sbiw	r30, 0x01	; 1
    2124:	a3 e3       	ldi	r26, 0x33	; 51
    2126:	a0 83       	st	Z, r26
    2128:	31 97       	sbiw	r30, 0x01	; 1
    212a:	60 83       	st	Z, r22
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	70 83       	st	Z, r23
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	10 82       	st	Z, r1
    2134:	31 97       	sbiw	r30, 0x01	; 1
    2136:	10 82       	st	Z, r1
    2138:	31 97       	sbiw	r30, 0x01	; 1
    213a:	60 e8       	ldi	r22, 0x80	; 128
    213c:	60 83       	st	Z, r22
    213e:	31 97       	sbiw	r30, 0x01	; 1
    2140:	10 82       	st	Z, r1
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	10 82       	st	Z, r1
    2146:	31 97       	sbiw	r30, 0x01	; 1
    2148:	10 82       	st	Z, r1
    214a:	31 97       	sbiw	r30, 0x01	; 1
    214c:	62 e0       	ldi	r22, 0x02	; 2
    214e:	60 83       	st	Z, r22
    2150:	31 97       	sbiw	r30, 0x01	; 1
    2152:	63 e0       	ldi	r22, 0x03	; 3
    2154:	60 83       	st	Z, r22
    2156:	31 97       	sbiw	r30, 0x01	; 1
    2158:	64 e0       	ldi	r22, 0x04	; 4
    215a:	60 83       	st	Z, r22
    215c:	31 97       	sbiw	r30, 0x01	; 1
    215e:	65 e0       	ldi	r22, 0x05	; 5
    2160:	60 83       	st	Z, r22
    2162:	31 97       	sbiw	r30, 0x01	; 1
    2164:	66 e0       	ldi	r22, 0x06	; 6
    2166:	60 83       	st	Z, r22
    2168:	31 97       	sbiw	r30, 0x01	; 1
    216a:	67 e0       	ldi	r22, 0x07	; 7
    216c:	60 83       	st	Z, r22
    216e:	31 97       	sbiw	r30, 0x01	; 1
    2170:	68 e0       	ldi	r22, 0x08	; 8
    2172:	60 83       	st	Z, r22
    2174:	31 97       	sbiw	r30, 0x01	; 1
    2176:	69 e0       	ldi	r22, 0x09	; 9
    2178:	60 83       	st	Z, r22
    217a:	31 97       	sbiw	r30, 0x01	; 1
    217c:	60 e1       	ldi	r22, 0x10	; 16
    217e:	60 83       	st	Z, r22
    2180:	31 97       	sbiw	r30, 0x01	; 1
    2182:	30 83       	st	Z, r19
    2184:	31 97       	sbiw	r30, 0x01	; 1
    2186:	32 e1       	ldi	r19, 0x12	; 18
    2188:	30 83       	st	Z, r19
    218a:	31 97       	sbiw	r30, 0x01	; 1
    218c:	33 e1       	ldi	r19, 0x13	; 19
    218e:	30 83       	st	Z, r19
    2190:	31 97       	sbiw	r30, 0x01	; 1
    2192:	34 e1       	ldi	r19, 0x14	; 20
    2194:	30 83       	st	Z, r19
    2196:	31 97       	sbiw	r30, 0x01	; 1
    2198:	35 e1       	ldi	r19, 0x15	; 21
    219a:	30 83       	st	Z, r19
    219c:	31 97       	sbiw	r30, 0x01	; 1
    219e:	36 e1       	ldi	r19, 0x16	; 22
    21a0:	30 83       	st	Z, r19
    21a2:	31 97       	sbiw	r30, 0x01	; 1
    21a4:	37 e1       	ldi	r19, 0x17	; 23
    21a6:	30 83       	st	Z, r19
    21a8:	31 97       	sbiw	r30, 0x01	; 1
    21aa:	38 e1       	ldi	r19, 0x18	; 24
    21ac:	30 83       	st	Z, r19
    21ae:	31 97       	sbiw	r30, 0x01	; 1
    21b0:	39 e1       	ldi	r19, 0x19	; 25
    21b2:	30 83       	st	Z, r19
    21b4:	31 97       	sbiw	r30, 0x01	; 1
    21b6:	30 e2       	ldi	r19, 0x20	; 32
    21b8:	30 83       	st	Z, r19
    21ba:	31 97       	sbiw	r30, 0x01	; 1
    21bc:	31 e2       	ldi	r19, 0x21	; 33
    21be:	30 83       	st	Z, r19
    21c0:	31 97       	sbiw	r30, 0x01	; 1
    21c2:	20 83       	st	Z, r18
    21c4:	31 97       	sbiw	r30, 0x01	; 1
    21c6:	23 e2       	ldi	r18, 0x23	; 35
    21c8:	20 83       	st	Z, r18
    21ca:	31 97       	sbiw	r30, 0x01	; 1
    21cc:	40 83       	st	Z, r20
    21ce:	31 97       	sbiw	r30, 0x01	; 1
    21d0:	50 83       	st	Z, r21
    21d2:	31 97       	sbiw	r30, 0x01	; 1
    21d4:	26 e2       	ldi	r18, 0x26	; 38
    21d6:	20 83       	st	Z, r18
    21d8:	31 97       	sbiw	r30, 0x01	; 1
    21da:	27 e2       	ldi	r18, 0x27	; 39
    21dc:	20 83       	st	Z, r18
    21de:	31 97       	sbiw	r30, 0x01	; 1
    21e0:	28 e2       	ldi	r18, 0x28	; 40
    21e2:	20 83       	st	Z, r18
    21e4:	31 97       	sbiw	r30, 0x01	; 1
    21e6:	29 e2       	ldi	r18, 0x29	; 41
    21e8:	20 83       	st	Z, r18
    21ea:	31 97       	sbiw	r30, 0x01	; 1
    21ec:	20 e3       	ldi	r18, 0x30	; 48
    21ee:	20 83       	st	Z, r18
    21f0:	31 97       	sbiw	r30, 0x01	; 1
    21f2:	21 e3       	ldi	r18, 0x31	; 49
    21f4:	20 83       	st	Z, r18
    21f6:	89 97       	sbiw	r24, 0x29	; 41
    21f8:	08 95       	ret

000021fa <xPortStartScheduler>:
    21fa:	8c e7       	ldi	r24, 0x7C	; 124
    21fc:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    2200:	8f ef       	ldi	r24, 0xFF	; 255
    2202:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    220c:	91 e1       	ldi	r25, 0x11	; 17
    220e:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    2212:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    2216:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    221a:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    221e:	cd 91       	ld	r28, X+
    2220:	cd bf       	out	0x3d, r28	; 61
    2222:	dd 91       	ld	r29, X+
    2224:	de bf       	out	0x3e, r29	; 62
    2226:	ff 91       	pop	r31
    2228:	ef 91       	pop	r30
    222a:	df 91       	pop	r29
    222c:	cf 91       	pop	r28
    222e:	bf 91       	pop	r27
    2230:	af 91       	pop	r26
    2232:	9f 91       	pop	r25
    2234:	8f 91       	pop	r24
    2236:	7f 91       	pop	r23
    2238:	6f 91       	pop	r22
    223a:	5f 91       	pop	r21
    223c:	4f 91       	pop	r20
    223e:	3f 91       	pop	r19
    2240:	2f 91       	pop	r18
    2242:	1f 91       	pop	r17
    2244:	0f 91       	pop	r16
    2246:	ff 90       	pop	r15
    2248:	ef 90       	pop	r14
    224a:	df 90       	pop	r13
    224c:	cf 90       	pop	r12
    224e:	bf 90       	pop	r11
    2250:	af 90       	pop	r10
    2252:	9f 90       	pop	r9
    2254:	8f 90       	pop	r8
    2256:	7f 90       	pop	r7
    2258:	6f 90       	pop	r6
    225a:	5f 90       	pop	r5
    225c:	4f 90       	pop	r4
    225e:	3f 90       	pop	r3
    2260:	2f 90       	pop	r2
    2262:	1f 90       	pop	r1
    2264:	0f 90       	pop	r0
    2266:	0c be       	out	0x3c, r0	; 60
    2268:	0f 90       	pop	r0
    226a:	0b be       	out	0x3b, r0	; 59
    226c:	0f 90       	pop	r0
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	0f 90       	pop	r0
    2272:	08 95       	ret
    2274:	08 95       	ret

00002276 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2276:	0f 92       	push	r0
    2278:	0f b6       	in	r0, 0x3f	; 63
    227a:	f8 94       	cli
    227c:	0f 92       	push	r0
    227e:	0b b6       	in	r0, 0x3b	; 59
    2280:	0f 92       	push	r0
    2282:	0c b6       	in	r0, 0x3c	; 60
    2284:	0f 92       	push	r0
    2286:	1f 92       	push	r1
    2288:	11 24       	eor	r1, r1
    228a:	2f 92       	push	r2
    228c:	3f 92       	push	r3
    228e:	4f 92       	push	r4
    2290:	5f 92       	push	r5
    2292:	6f 92       	push	r6
    2294:	7f 92       	push	r7
    2296:	8f 92       	push	r8
    2298:	9f 92       	push	r9
    229a:	af 92       	push	r10
    229c:	bf 92       	push	r11
    229e:	cf 92       	push	r12
    22a0:	df 92       	push	r13
    22a2:	ef 92       	push	r14
    22a4:	ff 92       	push	r15
    22a6:	0f 93       	push	r16
    22a8:	1f 93       	push	r17
    22aa:	2f 93       	push	r18
    22ac:	3f 93       	push	r19
    22ae:	4f 93       	push	r20
    22b0:	5f 93       	push	r21
    22b2:	6f 93       	push	r22
    22b4:	7f 93       	push	r23
    22b6:	8f 93       	push	r24
    22b8:	9f 93       	push	r25
    22ba:	af 93       	push	r26
    22bc:	bf 93       	push	r27
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
    22c2:	ef 93       	push	r30
    22c4:	ff 93       	push	r31
    22c6:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    22ca:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    22ce:	0d b6       	in	r0, 0x3d	; 61
    22d0:	0d 92       	st	X+, r0
    22d2:	0e b6       	in	r0, 0x3e	; 62
    22d4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    22d6:	0e 94 4a 18 	call	0x3094	; 0x3094 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22da:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    22de:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    22e2:	cd 91       	ld	r28, X+
    22e4:	cd bf       	out	0x3d, r28	; 61
    22e6:	dd 91       	ld	r29, X+
    22e8:	de bf       	out	0x3e, r29	; 62
    22ea:	ff 91       	pop	r31
    22ec:	ef 91       	pop	r30
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	bf 91       	pop	r27
    22f4:	af 91       	pop	r26
    22f6:	9f 91       	pop	r25
    22f8:	8f 91       	pop	r24
    22fa:	7f 91       	pop	r23
    22fc:	6f 91       	pop	r22
    22fe:	5f 91       	pop	r21
    2300:	4f 91       	pop	r20
    2302:	3f 91       	pop	r19
    2304:	2f 91       	pop	r18
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	ff 90       	pop	r15
    230c:	ef 90       	pop	r14
    230e:	df 90       	pop	r13
    2310:	cf 90       	pop	r12
    2312:	bf 90       	pop	r11
    2314:	af 90       	pop	r10
    2316:	9f 90       	pop	r9
    2318:	8f 90       	pop	r8
    231a:	7f 90       	pop	r7
    231c:	6f 90       	pop	r6
    231e:	5f 90       	pop	r5
    2320:	4f 90       	pop	r4
    2322:	3f 90       	pop	r3
    2324:	2f 90       	pop	r2
    2326:	1f 90       	pop	r1
    2328:	0f 90       	pop	r0
    232a:	0c be       	out	0x3c, r0	; 60
    232c:	0f 90       	pop	r0
    232e:	0b be       	out	0x3b, r0	; 59
    2330:	0f 90       	pop	r0
    2332:	0f be       	out	0x3f, r0	; 63
    2334:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2336:	08 95       	ret

00002338 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2338:	0f 92       	push	r0
    233a:	0f b6       	in	r0, 0x3f	; 63
    233c:	f8 94       	cli
    233e:	0f 92       	push	r0
    2340:	0b b6       	in	r0, 0x3b	; 59
    2342:	0f 92       	push	r0
    2344:	0c b6       	in	r0, 0x3c	; 60
    2346:	0f 92       	push	r0
    2348:	1f 92       	push	r1
    234a:	11 24       	eor	r1, r1
    234c:	2f 92       	push	r2
    234e:	3f 92       	push	r3
    2350:	4f 92       	push	r4
    2352:	5f 92       	push	r5
    2354:	6f 92       	push	r6
    2356:	7f 92       	push	r7
    2358:	8f 92       	push	r8
    235a:	9f 92       	push	r9
    235c:	af 92       	push	r10
    235e:	bf 92       	push	r11
    2360:	cf 92       	push	r12
    2362:	df 92       	push	r13
    2364:	ef 92       	push	r14
    2366:	ff 92       	push	r15
    2368:	0f 93       	push	r16
    236a:	1f 93       	push	r17
    236c:	2f 93       	push	r18
    236e:	3f 93       	push	r19
    2370:	4f 93       	push	r20
    2372:	5f 93       	push	r21
    2374:	6f 93       	push	r22
    2376:	7f 93       	push	r23
    2378:	8f 93       	push	r24
    237a:	9f 93       	push	r25
    237c:	af 93       	push	r26
    237e:	bf 93       	push	r27
    2380:	cf 93       	push	r28
    2382:	df 93       	push	r29
    2384:	ef 93       	push	r30
    2386:	ff 93       	push	r31
    2388:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    238c:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2390:	0d b6       	in	r0, 0x3d	; 61
    2392:	0d 92       	st	X+, r0
    2394:	0e b6       	in	r0, 0x3e	; 62
    2396:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2398:	0e 94 99 16 	call	0x2d32	; 0x2d32 <vTaskIncrementTick>
	vTaskSwitchContext();
    239c:	0e 94 4a 18 	call	0x3094	; 0x3094 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    23a0:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    23a4:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    23a8:	cd 91       	ld	r28, X+
    23aa:	cd bf       	out	0x3d, r28	; 61
    23ac:	dd 91       	ld	r29, X+
    23ae:	de bf       	out	0x3e, r29	; 62
    23b0:	ff 91       	pop	r31
    23b2:	ef 91       	pop	r30
    23b4:	df 91       	pop	r29
    23b6:	cf 91       	pop	r28
    23b8:	bf 91       	pop	r27
    23ba:	af 91       	pop	r26
    23bc:	9f 91       	pop	r25
    23be:	8f 91       	pop	r24
    23c0:	7f 91       	pop	r23
    23c2:	6f 91       	pop	r22
    23c4:	5f 91       	pop	r21
    23c6:	4f 91       	pop	r20
    23c8:	3f 91       	pop	r19
    23ca:	2f 91       	pop	r18
    23cc:	1f 91       	pop	r17
    23ce:	0f 91       	pop	r16
    23d0:	ff 90       	pop	r15
    23d2:	ef 90       	pop	r14
    23d4:	df 90       	pop	r13
    23d6:	cf 90       	pop	r12
    23d8:	bf 90       	pop	r11
    23da:	af 90       	pop	r10
    23dc:	9f 90       	pop	r9
    23de:	8f 90       	pop	r8
    23e0:	7f 90       	pop	r7
    23e2:	6f 90       	pop	r6
    23e4:	5f 90       	pop	r5
    23e6:	4f 90       	pop	r4
    23e8:	3f 90       	pop	r3
    23ea:	2f 90       	pop	r2
    23ec:	1f 90       	pop	r1
    23ee:	0f 90       	pop	r0
    23f0:	0c be       	out	0x3c, r0	; 60
    23f2:	0f 90       	pop	r0
    23f4:	0b be       	out	0x3b, r0	; 59
    23f6:	0f 90       	pop	r0
    23f8:	0f be       	out	0x3f, r0	; 63
    23fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23fc:	08 95       	ret

000023fe <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    23fe:	0e 94 9c 11 	call	0x2338	; 0x2338 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2402:	18 95       	reti

00002404 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
    2408:	ec 01       	movw	r28, r24
    240a:	88 a1       	ldd	r24, Y+32	; 0x20
    240c:	81 11       	cpse	r24, r1
    240e:	0b c0       	rjmp	.+22     	; 0x2426 <prvCopyDataToQueue+0x22>
    2410:	88 81       	ld	r24, Y
    2412:	99 81       	ldd	r25, Y+1	; 0x01
    2414:	89 2b       	or	r24, r25
    2416:	e1 f5       	brne	.+120    	; 0x2490 <prvCopyDataToQueue+0x8c>
    2418:	8a 81       	ldd	r24, Y+2	; 0x02
    241a:	9b 81       	ldd	r25, Y+3	; 0x03
    241c:	0e 94 05 1a 	call	0x340a	; 0x340a <vTaskPriorityDisinherit>
    2420:	1a 82       	std	Y+2, r1	; 0x02
    2422:	1b 82       	std	Y+3, r1	; 0x03
    2424:	35 c0       	rjmp	.+106    	; 0x2490 <prvCopyDataToQueue+0x8c>
    2426:	41 11       	cpse	r20, r1
    2428:	17 c0       	rjmp	.+46     	; 0x2458 <prvCopyDataToQueue+0x54>
    242a:	48 2f       	mov	r20, r24
    242c:	50 e0       	ldi	r21, 0x00	; 0
    242e:	8c 81       	ldd	r24, Y+4	; 0x04
    2430:	9d 81       	ldd	r25, Y+5	; 0x05
    2432:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <memcpy>
    2436:	28 a1       	ldd	r18, Y+32	; 0x20
    2438:	8c 81       	ldd	r24, Y+4	; 0x04
    243a:	9d 81       	ldd	r25, Y+5	; 0x05
    243c:	82 0f       	add	r24, r18
    243e:	91 1d       	adc	r25, r1
    2440:	8c 83       	std	Y+4, r24	; 0x04
    2442:	9d 83       	std	Y+5, r25	; 0x05
    2444:	2a 81       	ldd	r18, Y+2	; 0x02
    2446:	3b 81       	ldd	r19, Y+3	; 0x03
    2448:	82 17       	cp	r24, r18
    244a:	93 07       	cpc	r25, r19
    244c:	08 f1       	brcs	.+66     	; 0x2490 <prvCopyDataToQueue+0x8c>
    244e:	88 81       	ld	r24, Y
    2450:	99 81       	ldd	r25, Y+1	; 0x01
    2452:	8c 83       	std	Y+4, r24	; 0x04
    2454:	9d 83       	std	Y+5, r25	; 0x05
    2456:	1c c0       	rjmp	.+56     	; 0x2490 <prvCopyDataToQueue+0x8c>
    2458:	48 2f       	mov	r20, r24
    245a:	50 e0       	ldi	r21, 0x00	; 0
    245c:	8e 81       	ldd	r24, Y+6	; 0x06
    245e:	9f 81       	ldd	r25, Y+7	; 0x07
    2460:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <memcpy>
    2464:	88 a1       	ldd	r24, Y+32	; 0x20
    2466:	90 e0       	ldi	r25, 0x00	; 0
    2468:	91 95       	neg	r25
    246a:	81 95       	neg	r24
    246c:	91 09       	sbc	r25, r1
    246e:	2e 81       	ldd	r18, Y+6	; 0x06
    2470:	3f 81       	ldd	r19, Y+7	; 0x07
    2472:	28 0f       	add	r18, r24
    2474:	39 1f       	adc	r19, r25
    2476:	2e 83       	std	Y+6, r18	; 0x06
    2478:	3f 83       	std	Y+7, r19	; 0x07
    247a:	48 81       	ld	r20, Y
    247c:	59 81       	ldd	r21, Y+1	; 0x01
    247e:	24 17       	cp	r18, r20
    2480:	35 07       	cpc	r19, r21
    2482:	30 f4       	brcc	.+12     	; 0x2490 <prvCopyDataToQueue+0x8c>
    2484:	2a 81       	ldd	r18, Y+2	; 0x02
    2486:	3b 81       	ldd	r19, Y+3	; 0x03
    2488:	82 0f       	add	r24, r18
    248a:	93 1f       	adc	r25, r19
    248c:	8e 83       	std	Y+6, r24	; 0x06
    248e:	9f 83       	std	Y+7, r25	; 0x07
    2490:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2492:	8f 5f       	subi	r24, 0xFF	; 255
    2494:	8e 8f       	std	Y+30, r24	; 0x1e
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	08 95       	ret

0000249c <prvCopyDataFromQueue>:
    249c:	fc 01       	movw	r30, r24
    249e:	80 81       	ld	r24, Z
    24a0:	91 81       	ldd	r25, Z+1	; 0x01
    24a2:	00 97       	sbiw	r24, 0x00	; 0
    24a4:	a1 f0       	breq	.+40     	; 0x24ce <prvCopyDataFromQueue+0x32>
    24a6:	40 a1       	ldd	r20, Z+32	; 0x20
    24a8:	50 e0       	ldi	r21, 0x00	; 0
    24aa:	26 81       	ldd	r18, Z+6	; 0x06
    24ac:	37 81       	ldd	r19, Z+7	; 0x07
    24ae:	24 0f       	add	r18, r20
    24b0:	35 1f       	adc	r19, r21
    24b2:	26 83       	std	Z+6, r18	; 0x06
    24b4:	37 83       	std	Z+7, r19	; 0x07
    24b6:	a2 81       	ldd	r26, Z+2	; 0x02
    24b8:	b3 81       	ldd	r27, Z+3	; 0x03
    24ba:	2a 17       	cp	r18, r26
    24bc:	3b 07       	cpc	r19, r27
    24be:	10 f0       	brcs	.+4      	; 0x24c4 <prvCopyDataFromQueue+0x28>
    24c0:	86 83       	std	Z+6, r24	; 0x06
    24c2:	97 83       	std	Z+7, r25	; 0x07
    24c4:	cb 01       	movw	r24, r22
    24c6:	66 81       	ldd	r22, Z+6	; 0x06
    24c8:	77 81       	ldd	r23, Z+7	; 0x07
    24ca:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <memcpy>
    24ce:	08 95       	ret

000024d0 <prvUnlockQueue>:
    24d0:	0f 93       	push	r16
    24d2:	1f 93       	push	r17
    24d4:	cf 93       	push	r28
    24d6:	df 93       	push	r29
    24d8:	ec 01       	movw	r28, r24
    24da:	0f b6       	in	r0, 0x3f	; 63
    24dc:	f8 94       	cli
    24de:	0f 92       	push	r0
    24e0:	8a a1       	ldd	r24, Y+34	; 0x22
    24e2:	18 16       	cp	r1, r24
    24e4:	b4 f4       	brge	.+44     	; 0x2512 <prvUnlockQueue+0x42>
    24e6:	8b 89       	ldd	r24, Y+19	; 0x13
    24e8:	81 11       	cpse	r24, r1
    24ea:	05 c0       	rjmp	.+10     	; 0x24f6 <prvUnlockQueue+0x26>
    24ec:	12 c0       	rjmp	.+36     	; 0x2512 <prvUnlockQueue+0x42>
    24ee:	8b 89       	ldd	r24, Y+19	; 0x13
    24f0:	81 11       	cpse	r24, r1
    24f2:	04 c0       	rjmp	.+8      	; 0x24fc <prvUnlockQueue+0x2c>
    24f4:	0e c0       	rjmp	.+28     	; 0x2512 <prvUnlockQueue+0x42>
    24f6:	8e 01       	movw	r16, r28
    24f8:	0d 5e       	subi	r16, 0xED	; 237
    24fa:	1f 4f       	sbci	r17, 0xFF	; 255
    24fc:	c8 01       	movw	r24, r16
    24fe:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2502:	81 11       	cpse	r24, r1
    2504:	0e 94 8e 19 	call	0x331c	; 0x331c <vTaskMissedYield>
    2508:	8a a1       	ldd	r24, Y+34	; 0x22
    250a:	81 50       	subi	r24, 0x01	; 1
    250c:	8a a3       	std	Y+34, r24	; 0x22
    250e:	18 16       	cp	r1, r24
    2510:	74 f3       	brlt	.-36     	; 0x24ee <prvUnlockQueue+0x1e>
    2512:	8f ef       	ldi	r24, 0xFF	; 255
    2514:	8a a3       	std	Y+34, r24	; 0x22
    2516:	0f 90       	pop	r0
    2518:	0f be       	out	0x3f, r0	; 63
    251a:	0f b6       	in	r0, 0x3f	; 63
    251c:	f8 94       	cli
    251e:	0f 92       	push	r0
    2520:	89 a1       	ldd	r24, Y+33	; 0x21
    2522:	18 16       	cp	r1, r24
    2524:	b4 f4       	brge	.+44     	; 0x2552 <prvUnlockQueue+0x82>
    2526:	88 85       	ldd	r24, Y+8	; 0x08
    2528:	81 11       	cpse	r24, r1
    252a:	05 c0       	rjmp	.+10     	; 0x2536 <prvUnlockQueue+0x66>
    252c:	12 c0       	rjmp	.+36     	; 0x2552 <prvUnlockQueue+0x82>
    252e:	88 85       	ldd	r24, Y+8	; 0x08
    2530:	81 11       	cpse	r24, r1
    2532:	04 c0       	rjmp	.+8      	; 0x253c <prvUnlockQueue+0x6c>
    2534:	0e c0       	rjmp	.+28     	; 0x2552 <prvUnlockQueue+0x82>
    2536:	8e 01       	movw	r16, r28
    2538:	08 5f       	subi	r16, 0xF8	; 248
    253a:	1f 4f       	sbci	r17, 0xFF	; 255
    253c:	c8 01       	movw	r24, r16
    253e:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2542:	81 11       	cpse	r24, r1
    2544:	0e 94 8e 19 	call	0x331c	; 0x331c <vTaskMissedYield>
    2548:	89 a1       	ldd	r24, Y+33	; 0x21
    254a:	81 50       	subi	r24, 0x01	; 1
    254c:	89 a3       	std	Y+33, r24	; 0x21
    254e:	18 16       	cp	r1, r24
    2550:	74 f3       	brlt	.-36     	; 0x252e <prvUnlockQueue+0x5e>
    2552:	8f ef       	ldi	r24, 0xFF	; 255
    2554:	89 a3       	std	Y+33, r24	; 0x21
    2556:	0f 90       	pop	r0
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	df 91       	pop	r29
    255c:	cf 91       	pop	r28
    255e:	1f 91       	pop	r17
    2560:	0f 91       	pop	r16
    2562:	08 95       	ret

00002564 <xQueueGenericReset>:
    2564:	1f 93       	push	r17
    2566:	cf 93       	push	r28
    2568:	df 93       	push	r29
    256a:	61 30       	cpi	r22, 0x01	; 1
    256c:	59 f0       	breq	.+22     	; 0x2584 <xQueueGenericReset+0x20>
    256e:	fc 01       	movw	r30, r24
    2570:	23 89       	ldd	r18, Z+19	; 0x13
    2572:	30 85       	ldd	r19, Z+8	; 0x08
    2574:	31 11       	cpse	r19, r1
    2576:	2c c0       	rjmp	.+88     	; 0x25d0 <xQueueGenericReset+0x6c>
    2578:	11 e0       	ldi	r17, 0x01	; 1
    257a:	21 11       	cpse	r18, r1
    257c:	10 e0       	ldi	r17, 0x00	; 0
    257e:	21 11       	cpse	r18, r1
    2580:	28 c0       	rjmp	.+80     	; 0x25d2 <xQueueGenericReset+0x6e>
    2582:	01 c0       	rjmp	.+2      	; 0x2586 <xQueueGenericReset+0x22>
    2584:	11 e0       	ldi	r17, 0x01	; 1
    2586:	ec 01       	movw	r28, r24
    2588:	48 81       	ld	r20, Y
    258a:	59 81       	ldd	r21, Y+1	; 0x01
    258c:	28 a1       	ldd	r18, Y+32	; 0x20
    258e:	30 e0       	ldi	r19, 0x00	; 0
    2590:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2592:	62 9f       	mul	r22, r18
    2594:	c0 01       	movw	r24, r0
    2596:	63 9f       	mul	r22, r19
    2598:	90 0d       	add	r25, r0
    259a:	11 24       	eor	r1, r1
    259c:	ba 01       	movw	r22, r20
    259e:	68 0f       	add	r22, r24
    25a0:	79 1f       	adc	r23, r25
    25a2:	6a 83       	std	Y+2, r22	; 0x02
    25a4:	7b 83       	std	Y+3, r23	; 0x03
    25a6:	1e 8e       	std	Y+30, r1	; 0x1e
    25a8:	4c 83       	std	Y+4, r20	; 0x04
    25aa:	5d 83       	std	Y+5, r21	; 0x05
    25ac:	82 1b       	sub	r24, r18
    25ae:	93 0b       	sbc	r25, r19
    25b0:	84 0f       	add	r24, r20
    25b2:	95 1f       	adc	r25, r21
    25b4:	8e 83       	std	Y+6, r24	; 0x06
    25b6:	9f 83       	std	Y+7, r25	; 0x07
    25b8:	8f ef       	ldi	r24, 0xFF	; 255
    25ba:	89 a3       	std	Y+33, r24	; 0x21
    25bc:	8a a3       	std	Y+34, r24	; 0x22
    25be:	ce 01       	movw	r24, r28
    25c0:	08 96       	adiw	r24, 0x08	; 8
    25c2:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    25c6:	ce 01       	movw	r24, r28
    25c8:	43 96       	adiw	r24, 0x13	; 19
    25ca:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    25ce:	01 c0       	rjmp	.+2      	; 0x25d2 <xQueueGenericReset+0x6e>
    25d0:	10 e0       	ldi	r17, 0x00	; 0
    25d2:	81 2f       	mov	r24, r17
    25d4:	df 91       	pop	r29
    25d6:	cf 91       	pop	r28
    25d8:	1f 91       	pop	r17
    25da:	08 95       	ret

000025dc <xQueueGenericCreate>:
    25dc:	0f 93       	push	r16
    25de:	1f 93       	push	r17
    25e0:	cf 93       	push	r28
    25e2:	df 93       	push	r29
    25e4:	88 23       	and	r24, r24
    25e6:	01 f1       	breq	.+64     	; 0x2628 <xQueueGenericCreate+0x4c>
    25e8:	06 2f       	mov	r16, r22
    25ea:	18 2f       	mov	r17, r24
    25ec:	83 e2       	ldi	r24, 0x23	; 35
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    25f4:	ec 01       	movw	r28, r24
    25f6:	89 2b       	or	r24, r25
    25f8:	c9 f0       	breq	.+50     	; 0x262c <xQueueGenericCreate+0x50>
    25fa:	10 9f       	mul	r17, r16
    25fc:	c0 01       	movw	r24, r0
    25fe:	11 24       	eor	r1, r1
    2600:	01 96       	adiw	r24, 0x01	; 1
    2602:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    2606:	88 83       	st	Y, r24
    2608:	99 83       	std	Y+1, r25	; 0x01
    260a:	89 2b       	or	r24, r25
    260c:	39 f0       	breq	.+14     	; 0x261c <xQueueGenericCreate+0x40>
    260e:	1f 8f       	std	Y+31, r17	; 0x1f
    2610:	08 a3       	std	Y+32, r16	; 0x20
    2612:	61 e0       	ldi	r22, 0x01	; 1
    2614:	ce 01       	movw	r24, r28
    2616:	0e 94 b2 12 	call	0x2564	; 0x2564 <xQueueGenericReset>
    261a:	08 c0       	rjmp	.+16     	; 0x262c <xQueueGenericCreate+0x50>
    261c:	ce 01       	movw	r24, r28
    261e:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <vPortFree>
    2622:	c0 e0       	ldi	r28, 0x00	; 0
    2624:	d0 e0       	ldi	r29, 0x00	; 0
    2626:	02 c0       	rjmp	.+4      	; 0x262c <xQueueGenericCreate+0x50>
    2628:	c0 e0       	ldi	r28, 0x00	; 0
    262a:	d0 e0       	ldi	r29, 0x00	; 0
    262c:	ce 01       	movw	r24, r28
    262e:	df 91       	pop	r29
    2630:	cf 91       	pop	r28
    2632:	1f 91       	pop	r17
    2634:	0f 91       	pop	r16
    2636:	08 95       	ret

00002638 <xQueueGenericSend>:
    2638:	af 92       	push	r10
    263a:	bf 92       	push	r11
    263c:	cf 92       	push	r12
    263e:	df 92       	push	r13
    2640:	ef 92       	push	r14
    2642:	ff 92       	push	r15
    2644:	0f 93       	push	r16
    2646:	1f 93       	push	r17
    2648:	cf 93       	push	r28
    264a:	df 93       	push	r29
    264c:	cd b7       	in	r28, 0x3d	; 61
    264e:	de b7       	in	r29, 0x3e	; 62
    2650:	29 97       	sbiw	r28, 0x09	; 9
    2652:	cd bf       	out	0x3d, r28	; 61
    2654:	de bf       	out	0x3e, r29	; 62
    2656:	7c 01       	movw	r14, r24
    2658:	5b 01       	movw	r10, r22
    265a:	2e 83       	std	Y+6, r18	; 0x06
    265c:	3f 83       	std	Y+7, r19	; 0x07
    265e:	48 87       	std	Y+8, r20	; 0x08
    2660:	59 87       	std	Y+9, r21	; 0x09
    2662:	10 e0       	ldi	r17, 0x00	; 0
    2664:	6c 01       	movw	r12, r24
    2666:	88 e0       	ldi	r24, 0x08	; 8
    2668:	c8 0e       	add	r12, r24
    266a:	d1 1c       	adc	r13, r1
    266c:	0f b6       	in	r0, 0x3f	; 63
    266e:	f8 94       	cli
    2670:	0f 92       	push	r0
    2672:	f7 01       	movw	r30, r14
    2674:	96 8d       	ldd	r25, Z+30	; 0x1e
    2676:	87 8d       	ldd	r24, Z+31	; 0x1f
    2678:	98 17       	cp	r25, r24
    267a:	a8 f4       	brcc	.+42     	; 0x26a6 <xQueueGenericSend+0x6e>
    267c:	40 2f       	mov	r20, r16
    267e:	b5 01       	movw	r22, r10
    2680:	c7 01       	movw	r24, r14
    2682:	0e 94 02 12 	call	0x2404	; 0x2404 <prvCopyDataToQueue>
    2686:	f7 01       	movw	r30, r14
    2688:	83 89       	ldd	r24, Z+19	; 0x13
    268a:	88 23       	and	r24, r24
    268c:	41 f0       	breq	.+16     	; 0x269e <xQueueGenericSend+0x66>
    268e:	c7 01       	movw	r24, r14
    2690:	43 96       	adiw	r24, 0x13	; 19
    2692:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2696:	81 30       	cpi	r24, 0x01	; 1
    2698:	11 f4       	brne	.+4      	; 0x269e <xQueueGenericSend+0x66>
    269a:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    269e:	0f 90       	pop	r0
    26a0:	0f be       	out	0x3f, r0	; 63
    26a2:	81 e0       	ldi	r24, 0x01	; 1
    26a4:	56 c0       	rjmp	.+172    	; 0x2752 <xQueueGenericSend+0x11a>
    26a6:	8e 81       	ldd	r24, Y+6	; 0x06
    26a8:	9f 81       	ldd	r25, Y+7	; 0x07
    26aa:	a8 85       	ldd	r26, Y+8	; 0x08
    26ac:	b9 85       	ldd	r27, Y+9	; 0x09
    26ae:	89 2b       	or	r24, r25
    26b0:	8a 2b       	or	r24, r26
    26b2:	8b 2b       	or	r24, r27
    26b4:	21 f4       	brne	.+8      	; 0x26be <xQueueGenericSend+0x86>
    26b6:	0f 90       	pop	r0
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	80 e0       	ldi	r24, 0x00	; 0
    26bc:	4a c0       	rjmp	.+148    	; 0x2752 <xQueueGenericSend+0x11a>
    26be:	11 11       	cpse	r17, r1
    26c0:	05 c0       	rjmp	.+10     	; 0x26cc <xQueueGenericSend+0x94>
    26c2:	ce 01       	movw	r24, r28
    26c4:	01 96       	adiw	r24, 0x01	; 1
    26c6:	0e 94 10 19 	call	0x3220	; 0x3220 <vTaskSetTimeOutState>
    26ca:	11 e0       	ldi	r17, 0x01	; 1
    26cc:	0f 90       	pop	r0
    26ce:	0f be       	out	0x3f, r0	; 63
    26d0:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <vTaskSuspendAll>
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	0f 92       	push	r0
    26da:	f7 01       	movw	r30, r14
    26dc:	81 a1       	ldd	r24, Z+33	; 0x21
    26de:	8f 3f       	cpi	r24, 0xFF	; 255
    26e0:	09 f4       	brne	.+2      	; 0x26e4 <xQueueGenericSend+0xac>
    26e2:	11 a2       	std	Z+33, r1	; 0x21
    26e4:	f7 01       	movw	r30, r14
    26e6:	82 a1       	ldd	r24, Z+34	; 0x22
    26e8:	8f 3f       	cpi	r24, 0xFF	; 255
    26ea:	09 f4       	brne	.+2      	; 0x26ee <xQueueGenericSend+0xb6>
    26ec:	12 a2       	std	Z+34, r1	; 0x22
    26ee:	0f 90       	pop	r0
    26f0:	0f be       	out	0x3f, r0	; 63
    26f2:	be 01       	movw	r22, r28
    26f4:	6a 5f       	subi	r22, 0xFA	; 250
    26f6:	7f 4f       	sbci	r23, 0xFF	; 255
    26f8:	ce 01       	movw	r24, r28
    26fa:	01 96       	adiw	r24, 0x01	; 1
    26fc:	0e 94 21 19 	call	0x3242	; 0x3242 <xTaskCheckForTimeOut>
    2700:	81 11       	cpse	r24, r1
    2702:	21 c0       	rjmp	.+66     	; 0x2746 <xQueueGenericSend+0x10e>
    2704:	0f b6       	in	r0, 0x3f	; 63
    2706:	f8 94       	cli
    2708:	0f 92       	push	r0
    270a:	f7 01       	movw	r30, r14
    270c:	96 8d       	ldd	r25, Z+30	; 0x1e
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63
    2712:	87 8d       	ldd	r24, Z+31	; 0x1f
    2714:	98 13       	cpse	r25, r24
    2716:	11 c0       	rjmp	.+34     	; 0x273a <xQueueGenericSend+0x102>
    2718:	4e 81       	ldd	r20, Y+6	; 0x06
    271a:	5f 81       	ldd	r21, Y+7	; 0x07
    271c:	68 85       	ldd	r22, Y+8	; 0x08
    271e:	79 85       	ldd	r23, Y+9	; 0x09
    2720:	c6 01       	movw	r24, r12
    2722:	0e 94 a7 18 	call	0x314e	; 0x314e <vTaskPlaceOnEventList>
    2726:	c7 01       	movw	r24, r14
    2728:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
    272c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
    2730:	81 11       	cpse	r24, r1
    2732:	9c cf       	rjmp	.-200    	; 0x266c <xQueueGenericSend+0x34>
    2734:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    2738:	99 cf       	rjmp	.-206    	; 0x266c <xQueueGenericSend+0x34>
    273a:	c7 01       	movw	r24, r14
    273c:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
    2740:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
    2744:	93 cf       	rjmp	.-218    	; 0x266c <xQueueGenericSend+0x34>
    2746:	c7 01       	movw	r24, r14
    2748:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
    274c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
    2750:	80 e0       	ldi	r24, 0x00	; 0
    2752:	29 96       	adiw	r28, 0x09	; 9
    2754:	cd bf       	out	0x3d, r28	; 61
    2756:	de bf       	out	0x3e, r29	; 62
    2758:	df 91       	pop	r29
    275a:	cf 91       	pop	r28
    275c:	1f 91       	pop	r17
    275e:	0f 91       	pop	r16
    2760:	ff 90       	pop	r15
    2762:	ef 90       	pop	r14
    2764:	df 90       	pop	r13
    2766:	cf 90       	pop	r12
    2768:	bf 90       	pop	r11
    276a:	af 90       	pop	r10
    276c:	08 95       	ret

0000276e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    276e:	0f 93       	push	r16
    2770:	1f 93       	push	r17
    2772:	cf 93       	push	r28
    2774:	df 93       	push	r29
    2776:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2778:	fc 01       	movw	r30, r24
    277a:	56 8d       	ldd	r21, Z+30	; 0x1e
    277c:	37 8d       	ldd	r19, Z+31	; 0x1f
    277e:	53 17       	cp	r21, r19
    2780:	c0 f4       	brcc	.+48     	; 0x27b2 <xQueueGenericSendFromISR+0x44>
    2782:	42 2f       	mov	r20, r18
    2784:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2786:	0e 94 02 12 	call	0x2404	; 0x2404 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    278a:	8a a1       	ldd	r24, Y+34	; 0x22
    278c:	8f 3f       	cpi	r24, 0xFF	; 255
    278e:	69 f4       	brne	.+26     	; 0x27aa <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2790:	8b 89       	ldd	r24, Y+19	; 0x13
    2792:	88 23       	and	r24, r24
    2794:	81 f0       	breq	.+32     	; 0x27b6 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2796:	ce 01       	movw	r24, r28
    2798:	43 96       	adiw	r24, 0x13	; 19
    279a:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    279e:	88 23       	and	r24, r24
    27a0:	61 f0       	breq	.+24     	; 0x27ba <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	f8 01       	movw	r30, r16
    27a6:	80 83       	st	Z, r24
    27a8:	09 c0       	rjmp	.+18     	; 0x27bc <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    27aa:	8f 5f       	subi	r24, 0xFF	; 255
    27ac:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	05 c0       	rjmp	.+10     	; 0x27bc <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    27b2:	80 e0       	ldi	r24, 0x00	; 0
    27b4:	03 c0       	rjmp	.+6      	; 0x27bc <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	01 c0       	rjmp	.+2      	; 0x27bc <xQueueGenericSendFromISR+0x4e>
    27ba:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    27bc:	df 91       	pop	r29
    27be:	cf 91       	pop	r28
    27c0:	1f 91       	pop	r17
    27c2:	0f 91       	pop	r16
    27c4:	08 95       	ret

000027c6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    27c6:	af 92       	push	r10
    27c8:	bf 92       	push	r11
    27ca:	cf 92       	push	r12
    27cc:	df 92       	push	r13
    27ce:	ef 92       	push	r14
    27d0:	ff 92       	push	r15
    27d2:	0f 93       	push	r16
    27d4:	1f 93       	push	r17
    27d6:	cf 93       	push	r28
    27d8:	df 93       	push	r29
    27da:	cd b7       	in	r28, 0x3d	; 61
    27dc:	de b7       	in	r29, 0x3e	; 62
    27de:	29 97       	sbiw	r28, 0x09	; 9
    27e0:	cd bf       	out	0x3d, r28	; 61
    27e2:	de bf       	out	0x3e, r29	; 62
    27e4:	7c 01       	movw	r14, r24
    27e6:	5b 01       	movw	r10, r22
    27e8:	2e 83       	std	Y+6, r18	; 0x06
    27ea:	3f 83       	std	Y+7, r19	; 0x07
    27ec:	48 87       	std	Y+8, r20	; 0x08
    27ee:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    27f0:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    27f2:	6c 01       	movw	r12, r24
    27f4:	83 e1       	ldi	r24, 0x13	; 19
    27f6:	c8 0e       	add	r12, r24
    27f8:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    27fa:	0f b6       	in	r0, 0x3f	; 63
    27fc:	f8 94       	cli
    27fe:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2800:	f7 01       	movw	r30, r14
    2802:	86 8d       	ldd	r24, Z+30	; 0x1e
    2804:	88 23       	and	r24, r24
    2806:	99 f1       	breq	.+102    	; 0x286e <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2808:	c6 80       	ldd	r12, Z+6	; 0x06
    280a:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    280c:	b5 01       	movw	r22, r10
    280e:	c7 01       	movw	r24, r14
    2810:	0e 94 4e 12 	call	0x249c	; 0x249c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2814:	01 11       	cpse	r16, r1
    2816:	1a c0       	rjmp	.+52     	; 0x284c <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2818:	f7 01       	movw	r30, r14
    281a:	86 8d       	ldd	r24, Z+30	; 0x1e
    281c:	81 50       	subi	r24, 0x01	; 1
    281e:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2820:	80 81       	ld	r24, Z
    2822:	91 81       	ldd	r25, Z+1	; 0x01
    2824:	89 2b       	or	r24, r25
    2826:	29 f4       	brne	.+10     	; 0x2832 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2828:	0e 94 ab 19 	call	0x3356	; 0x3356 <xTaskGetCurrentTaskHandle>
    282c:	f7 01       	movw	r30, r14
    282e:	82 83       	std	Z+2, r24	; 0x02
    2830:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2832:	f7 01       	movw	r30, r14
    2834:	80 85       	ldd	r24, Z+8	; 0x08
    2836:	88 23       	and	r24, r24
    2838:	b1 f0       	breq	.+44     	; 0x2866 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    283a:	c7 01       	movw	r24, r14
    283c:	08 96       	adiw	r24, 0x08	; 8
    283e:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2842:	81 30       	cpi	r24, 0x01	; 1
    2844:	81 f4       	brne	.+32     	; 0x2866 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    2846:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    284a:	0d c0       	rjmp	.+26     	; 0x2866 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    284c:	f7 01       	movw	r30, r14
    284e:	c6 82       	std	Z+6, r12	; 0x06
    2850:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2852:	83 89       	ldd	r24, Z+19	; 0x13
    2854:	88 23       	and	r24, r24
    2856:	39 f0       	breq	.+14     	; 0x2866 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2858:	c7 01       	movw	r24, r14
    285a:	43 96       	adiw	r24, 0x13	; 19
    285c:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2860:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2862:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2866:	0f 90       	pop	r0
    2868:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	62 c0       	rjmp	.+196    	; 0x2932 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    286e:	8e 81       	ldd	r24, Y+6	; 0x06
    2870:	9f 81       	ldd	r25, Y+7	; 0x07
    2872:	a8 85       	ldd	r26, Y+8	; 0x08
    2874:	b9 85       	ldd	r27, Y+9	; 0x09
    2876:	89 2b       	or	r24, r25
    2878:	8a 2b       	or	r24, r26
    287a:	8b 2b       	or	r24, r27
    287c:	21 f4       	brne	.+8      	; 0x2886 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    287e:	0f 90       	pop	r0
    2880:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2882:	80 e0       	ldi	r24, 0x00	; 0
    2884:	56 c0       	rjmp	.+172    	; 0x2932 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2886:	11 11       	cpse	r17, r1
    2888:	05 c0       	rjmp	.+10     	; 0x2894 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    288a:	ce 01       	movw	r24, r28
    288c:	01 96       	adiw	r24, 0x01	; 1
    288e:	0e 94 10 19 	call	0x3220	; 0x3220 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2892:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2894:	0f 90       	pop	r0
    2896:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2898:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    289c:	0f b6       	in	r0, 0x3f	; 63
    289e:	f8 94       	cli
    28a0:	0f 92       	push	r0
    28a2:	f7 01       	movw	r30, r14
    28a4:	81 a1       	ldd	r24, Z+33	; 0x21
    28a6:	8f 3f       	cpi	r24, 0xFF	; 255
    28a8:	09 f4       	brne	.+2      	; 0x28ac <xQueueGenericReceive+0xe6>
    28aa:	11 a2       	std	Z+33, r1	; 0x21
    28ac:	f7 01       	movw	r30, r14
    28ae:	82 a1       	ldd	r24, Z+34	; 0x22
    28b0:	8f 3f       	cpi	r24, 0xFF	; 255
    28b2:	09 f4       	brne	.+2      	; 0x28b6 <xQueueGenericReceive+0xf0>
    28b4:	12 a2       	std	Z+34, r1	; 0x22
    28b6:	0f 90       	pop	r0
    28b8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    28ba:	be 01       	movw	r22, r28
    28bc:	6a 5f       	subi	r22, 0xFA	; 250
    28be:	7f 4f       	sbci	r23, 0xFF	; 255
    28c0:	ce 01       	movw	r24, r28
    28c2:	01 96       	adiw	r24, 0x01	; 1
    28c4:	0e 94 21 19 	call	0x3242	; 0x3242 <xTaskCheckForTimeOut>
    28c8:	81 11       	cpse	r24, r1
    28ca:	2d c0       	rjmp	.+90     	; 0x2926 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    28cc:	0f b6       	in	r0, 0x3f	; 63
    28ce:	f8 94       	cli
    28d0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    28d2:	f7 01       	movw	r30, r14
    28d4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    28d6:	0f 90       	pop	r0
    28d8:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    28da:	81 11       	cpse	r24, r1
    28dc:	1e c0       	rjmp	.+60     	; 0x291a <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28de:	80 81       	ld	r24, Z
    28e0:	91 81       	ldd	r25, Z+1	; 0x01
    28e2:	89 2b       	or	r24, r25
    28e4:	49 f4       	brne	.+18     	; 0x28f8 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    28e6:	0f b6       	in	r0, 0x3f	; 63
    28e8:	f8 94       	cli
    28ea:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    28ec:	82 81       	ldd	r24, Z+2	; 0x02
    28ee:	93 81       	ldd	r25, Z+3	; 0x03
    28f0:	0e 94 b0 19 	call	0x3360	; 0x3360 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    28f4:	0f 90       	pop	r0
    28f6:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28f8:	4e 81       	ldd	r20, Y+6	; 0x06
    28fa:	5f 81       	ldd	r21, Y+7	; 0x07
    28fc:	68 85       	ldd	r22, Y+8	; 0x08
    28fe:	79 85       	ldd	r23, Y+9	; 0x09
    2900:	c6 01       	movw	r24, r12
    2902:	0e 94 a7 18 	call	0x314e	; 0x314e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2906:	c7 01       	movw	r24, r14
    2908:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    290c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
    2910:	81 11       	cpse	r24, r1
    2912:	73 cf       	rjmp	.-282    	; 0x27fa <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2914:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    2918:	70 cf       	rjmp	.-288    	; 0x27fa <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    291a:	c7 01       	movw	r24, r14
    291c:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2920:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
    2924:	6a cf       	rjmp	.-300    	; 0x27fa <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2926:	c7 01       	movw	r24, r14
    2928:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    292c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2930:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2932:	29 96       	adiw	r28, 0x09	; 9
    2934:	cd bf       	out	0x3d, r28	; 61
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	df 91       	pop	r29
    293a:	cf 91       	pop	r28
    293c:	1f 91       	pop	r17
    293e:	0f 91       	pop	r16
    2940:	ff 90       	pop	r15
    2942:	ef 90       	pop	r14
    2944:	df 90       	pop	r13
    2946:	cf 90       	pop	r12
    2948:	bf 90       	pop	r11
    294a:	af 90       	pop	r10
    294c:	08 95       	ret

0000294e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2956:	fc 01       	movw	r30, r24
    2958:	26 8d       	ldd	r18, Z+30	; 0x1e
    295a:	22 23       	and	r18, r18
    295c:	d9 f0       	breq	.+54     	; 0x2994 <xQueueReceiveFromISR+0x46>
    295e:	8a 01       	movw	r16, r20
    2960:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2962:	0e 94 4e 12 	call	0x249c	; 0x249c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2966:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2968:	81 50       	subi	r24, 0x01	; 1
    296a:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    296c:	89 a1       	ldd	r24, Y+33	; 0x21
    296e:	8f 3f       	cpi	r24, 0xFF	; 255
    2970:	69 f4       	brne	.+26     	; 0x298c <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2972:	88 85       	ldd	r24, Y+8	; 0x08
    2974:	88 23       	and	r24, r24
    2976:	81 f0       	breq	.+32     	; 0x2998 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2978:	ce 01       	movw	r24, r28
    297a:	08 96       	adiw	r24, 0x08	; 8
    297c:	0e 94 d1 18 	call	0x31a2	; 0x31a2 <xTaskRemoveFromEventList>
    2980:	88 23       	and	r24, r24
    2982:	61 f0       	breq	.+24     	; 0x299c <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	f8 01       	movw	r30, r16
    2988:	80 83       	st	Z, r24
    298a:	09 c0       	rjmp	.+18     	; 0x299e <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    298c:	8f 5f       	subi	r24, 0xFF	; 255
    298e:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    2990:	81 e0       	ldi	r24, 0x01	; 1
    2992:	05 c0       	rjmp	.+10     	; 0x299e <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2994:	80 e0       	ldi	r24, 0x00	; 0
    2996:	03 c0       	rjmp	.+6      	; 0x299e <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2998:	81 e0       	ldi	r24, 0x01	; 1
    299a:	01 c0       	rjmp	.+2      	; 0x299e <xQueueReceiveFromISR+0x50>
    299c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    299e:	df 91       	pop	r29
    29a0:	cf 91       	pop	r28
    29a2:	1f 91       	pop	r17
    29a4:	0f 91       	pop	r16
    29a6:	08 95       	ret

000029a8 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    29a8:	0f b6       	in	r0, 0x3f	; 63
    29aa:	f8 94       	cli
    29ac:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    29ae:	fc 01       	movw	r30, r24
    29b0:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    29b2:	0f 90       	pop	r0
    29b4:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    29b6:	08 95       	ret

000029b8 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    29b8:	fc 01       	movw	r30, r24
    29ba:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    29bc:	08 95       	ret

000029be <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    29be:	c0 e7       	ldi	r28, 0x70	; 112
    29c0:	d2 e3       	ldi	r29, 0x32	; 50
    29c2:	88 81       	ld	r24, Y
    29c4:	82 30       	cpi	r24, 0x02	; 2
    29c6:	e8 f3       	brcs	.-6      	; 0x29c2 <prvIdleTask+0x4>
    29c8:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    29cc:	fa cf       	rjmp	.-12     	; 0x29c2 <prvIdleTask+0x4>

000029ce <prvAddCurrentTaskToDelayedList>:
    29ce:	cf 92       	push	r12
    29d0:	df 92       	push	r13
    29d2:	ef 92       	push	r14
    29d4:	ff 92       	push	r15
    29d6:	6b 01       	movw	r12, r22
    29d8:	7c 01       	movw	r14, r24
    29da:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    29de:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    29e2:	62 83       	std	Z+2, r22	; 0x02
    29e4:	73 83       	std	Z+3, r23	; 0x03
    29e6:	84 83       	std	Z+4, r24	; 0x04
    29e8:	95 83       	std	Z+5, r25	; 0x05
    29ea:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    29ee:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    29f2:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    29f6:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    29fa:	c8 16       	cp	r12, r24
    29fc:	d9 06       	cpc	r13, r25
    29fe:	ea 06       	cpc	r14, r26
    2a00:	fb 06       	cpc	r15, r27
    2a02:	68 f4       	brcc	.+26     	; 0x2a1e <prvAddCurrentTaskToDelayedList+0x50>
    2a04:	60 91 9c 32 	lds	r22, 0x329C	; 0x80329c <pxCurrentTCB>
    2a08:	70 91 9d 32 	lds	r23, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2a0c:	80 91 56 32 	lds	r24, 0x3256	; 0x803256 <pxOverflowDelayedTaskList>
    2a10:	90 91 57 32 	lds	r25, 0x3257	; 0x803257 <pxOverflowDelayedTaskList+0x1>
    2a14:	6e 5f       	subi	r22, 0xFE	; 254
    2a16:	7f 4f       	sbci	r23, 0xFF	; 255
    2a18:	0e 94 16 10 	call	0x202c	; 0x202c <vListInsert>
    2a1c:	21 c0       	rjmp	.+66     	; 0x2a60 <prvAddCurrentTaskToDelayedList+0x92>
    2a1e:	60 91 9c 32 	lds	r22, 0x329C	; 0x80329c <pxCurrentTCB>
    2a22:	70 91 9d 32 	lds	r23, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2a26:	80 91 58 32 	lds	r24, 0x3258	; 0x803258 <pxDelayedTaskList>
    2a2a:	90 91 59 32 	lds	r25, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2a2e:	6e 5f       	subi	r22, 0xFE	; 254
    2a30:	7f 4f       	sbci	r23, 0xFF	; 255
    2a32:	0e 94 16 10 	call	0x202c	; 0x202c <vListInsert>
    2a36:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2a3a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a3e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a42:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a46:	c8 16       	cp	r12, r24
    2a48:	d9 06       	cpc	r13, r25
    2a4a:	ea 06       	cpc	r14, r26
    2a4c:	fb 06       	cpc	r15, r27
    2a4e:	40 f4       	brcc	.+16     	; 0x2a60 <prvAddCurrentTaskToDelayedList+0x92>
    2a50:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2a54:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a58:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a5c:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a60:	ff 90       	pop	r15
    2a62:	ef 90       	pop	r14
    2a64:	df 90       	pop	r13
    2a66:	cf 90       	pop	r12
    2a68:	08 95       	ret

00002a6a <xTaskGenericCreate>:
    2a6a:	4f 92       	push	r4
    2a6c:	5f 92       	push	r5
    2a6e:	6f 92       	push	r6
    2a70:	7f 92       	push	r7
    2a72:	8f 92       	push	r8
    2a74:	9f 92       	push	r9
    2a76:	af 92       	push	r10
    2a78:	bf 92       	push	r11
    2a7a:	cf 92       	push	r12
    2a7c:	df 92       	push	r13
    2a7e:	ef 92       	push	r14
    2a80:	ff 92       	push	r15
    2a82:	0f 93       	push	r16
    2a84:	1f 93       	push	r17
    2a86:	cf 93       	push	r28
    2a88:	df 93       	push	r29
    2a8a:	5c 01       	movw	r10, r24
    2a8c:	4b 01       	movw	r8, r22
    2a8e:	3a 01       	movw	r6, r20
    2a90:	29 01       	movw	r4, r18
    2a92:	88 e2       	ldi	r24, 0x28	; 40
    2a94:	90 e0       	ldi	r25, 0x00	; 0
    2a96:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    2a9a:	ec 01       	movw	r28, r24
    2a9c:	89 2b       	or	r24, r25
    2a9e:	09 f4       	brne	.+2      	; 0x2aa2 <xTaskGenericCreate+0x38>
    2aa0:	d4 c0       	rjmp	.+424    	; 0x2c4a <xTaskGenericCreate+0x1e0>
    2aa2:	c1 14       	cp	r12, r1
    2aa4:	d1 04       	cpc	r13, r1
    2aa6:	09 f0       	breq	.+2      	; 0x2aaa <xTaskGenericCreate+0x40>
    2aa8:	cc c0       	rjmp	.+408    	; 0x2c42 <xTaskGenericCreate+0x1d8>
    2aaa:	c3 01       	movw	r24, r6
    2aac:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    2ab0:	8b 8f       	std	Y+27, r24	; 0x1b
    2ab2:	9c 8f       	std	Y+28, r25	; 0x1c
    2ab4:	00 97       	sbiw	r24, 0x00	; 0
    2ab6:	21 f4       	brne	.+8      	; 0x2ac0 <xTaskGenericCreate+0x56>
    2ab8:	ce 01       	movw	r24, r28
    2aba:	0e 94 a2 0f 	call	0x1f44	; 0x1f44 <vPortFree>
    2abe:	c5 c0       	rjmp	.+394    	; 0x2c4a <xTaskGenericCreate+0x1e0>
    2ac0:	a3 01       	movw	r20, r6
    2ac2:	61 e1       	ldi	r22, 0x11	; 17
    2ac4:	70 e0       	ldi	r23, 0x00	; 0
    2ac6:	0e 94 81 27 	call	0x4f02	; 0x4f02 <memset>
    2aca:	93 01       	movw	r18, r6
    2acc:	21 50       	subi	r18, 0x01	; 1
    2ace:	31 09       	sbc	r19, r1
    2ad0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ad2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ad4:	3c 01       	movw	r6, r24
    2ad6:	62 0e       	add	r6, r18
    2ad8:	73 1e       	adc	r7, r19
    2ada:	4a e0       	ldi	r20, 0x0A	; 10
    2adc:	50 e0       	ldi	r21, 0x00	; 0
    2ade:	b4 01       	movw	r22, r8
    2ae0:	ce 01       	movw	r24, r28
    2ae2:	4d 96       	adiw	r24, 0x1d	; 29
    2ae4:	0e 94 88 27 	call	0x4f10	; 0x4f10 <strncpy>
    2ae8:	1e a2       	std	Y+38, r1	; 0x26
    2aea:	10 2f       	mov	r17, r16
    2aec:	04 30       	cpi	r16, 0x04	; 4
    2aee:	08 f0       	brcs	.+2      	; 0x2af2 <xTaskGenericCreate+0x88>
    2af0:	13 e0       	ldi	r17, 0x03	; 3
    2af2:	1a 8f       	std	Y+26, r17	; 0x1a
    2af4:	1f a3       	std	Y+39, r17	; 0x27
    2af6:	6e 01       	movw	r12, r28
    2af8:	22 e0       	ldi	r18, 0x02	; 2
    2afa:	c2 0e       	add	r12, r18
    2afc:	d1 1c       	adc	r13, r1
    2afe:	c6 01       	movw	r24, r12
    2b00:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <vListInitialiseItem>
    2b04:	ce 01       	movw	r24, r28
    2b06:	0e 96       	adiw	r24, 0x0e	; 14
    2b08:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <vListInitialiseItem>
    2b0c:	ca 87       	std	Y+10, r28	; 0x0a
    2b0e:	db 87       	std	Y+11, r29	; 0x0b
    2b10:	84 e0       	ldi	r24, 0x04	; 4
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	a0 e0       	ldi	r26, 0x00	; 0
    2b16:	b0 e0       	ldi	r27, 0x00	; 0
    2b18:	81 1b       	sub	r24, r17
    2b1a:	91 09       	sbc	r25, r1
    2b1c:	a1 09       	sbc	r26, r1
    2b1e:	b1 09       	sbc	r27, r1
    2b20:	8e 87       	std	Y+14, r24	; 0x0e
    2b22:	9f 87       	std	Y+15, r25	; 0x0f
    2b24:	a8 8b       	std	Y+16, r26	; 0x10
    2b26:	b9 8b       	std	Y+17, r27	; 0x11
    2b28:	ce 8b       	std	Y+22, r28	; 0x16
    2b2a:	df 8b       	std	Y+23, r29	; 0x17
    2b2c:	a2 01       	movw	r20, r4
    2b2e:	b5 01       	movw	r22, r10
    2b30:	c3 01       	movw	r24, r6
    2b32:	0e 94 87 10 	call	0x210e	; 0x210e <pxPortInitialiseStack>
    2b36:	88 83       	st	Y, r24
    2b38:	99 83       	std	Y+1, r25	; 0x01
    2b3a:	e1 14       	cp	r14, r1
    2b3c:	f1 04       	cpc	r15, r1
    2b3e:	19 f0       	breq	.+6      	; 0x2b46 <xTaskGenericCreate+0xdc>
    2b40:	f7 01       	movw	r30, r14
    2b42:	c0 83       	st	Z, r28
    2b44:	d1 83       	std	Z+1, r29	; 0x01
    2b46:	0f b6       	in	r0, 0x3f	; 63
    2b48:	f8 94       	cli
    2b4a:	0f 92       	push	r0
    2b4c:	80 91 48 32 	lds	r24, 0x3248	; 0x803248 <uxCurrentNumberOfTasks>
    2b50:	8f 5f       	subi	r24, 0xFF	; 255
    2b52:	80 93 48 32 	sts	0x3248, r24	; 0x803248 <uxCurrentNumberOfTasks>
    2b56:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    2b5a:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2b5e:	89 2b       	or	r24, r25
    2b60:	89 f5       	brne	.+98     	; 0x2bc4 <xTaskGenericCreate+0x15a>
    2b62:	c0 93 9c 32 	sts	0x329C, r28	; 0x80329c <pxCurrentTCB>
    2b66:	d0 93 9d 32 	sts	0x329D, r29	; 0x80329d <pxCurrentTCB+0x1>
    2b6a:	80 91 48 32 	lds	r24, 0x3248	; 0x803248 <uxCurrentNumberOfTasks>
    2b6e:	81 30       	cpi	r24, 0x01	; 1
    2b70:	c1 f5       	brne	.+112    	; 0x2be2 <xTaskGenericCreate+0x178>
    2b72:	80 e7       	ldi	r24, 0x70	; 112
    2b74:	92 e3       	ldi	r25, 0x32	; 50
    2b76:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2b7a:	8b e7       	ldi	r24, 0x7B	; 123
    2b7c:	92 e3       	ldi	r25, 0x32	; 50
    2b7e:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2b82:	86 e8       	ldi	r24, 0x86	; 134
    2b84:	92 e3       	ldi	r25, 0x32	; 50
    2b86:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2b8a:	81 e9       	ldi	r24, 0x91	; 145
    2b8c:	92 e3       	ldi	r25, 0x32	; 50
    2b8e:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2b92:	85 e6       	ldi	r24, 0x65	; 101
    2b94:	92 e3       	ldi	r25, 0x32	; 50
    2b96:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2b9a:	8a e5       	ldi	r24, 0x5A	; 90
    2b9c:	92 e3       	ldi	r25, 0x32	; 50
    2b9e:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2ba2:	8b e4       	ldi	r24, 0x4B	; 75
    2ba4:	92 e3       	ldi	r25, 0x32	; 50
    2ba6:	0e 94 da 0f 	call	0x1fb4	; 0x1fb4 <vListInitialise>
    2baa:	85 e6       	ldi	r24, 0x65	; 101
    2bac:	92 e3       	ldi	r25, 0x32	; 50
    2bae:	80 93 58 32 	sts	0x3258, r24	; 0x803258 <pxDelayedTaskList>
    2bb2:	90 93 59 32 	sts	0x3259, r25	; 0x803259 <pxDelayedTaskList+0x1>
    2bb6:	8a e5       	ldi	r24, 0x5A	; 90
    2bb8:	92 e3       	ldi	r25, 0x32	; 50
    2bba:	80 93 56 32 	sts	0x3256, r24	; 0x803256 <pxOverflowDelayedTaskList>
    2bbe:	90 93 57 32 	sts	0x3257, r25	; 0x803257 <pxOverflowDelayedTaskList+0x1>
    2bc2:	0f c0       	rjmp	.+30     	; 0x2be2 <xTaskGenericCreate+0x178>
    2bc4:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <xSchedulerRunning>
    2bc8:	81 11       	cpse	r24, r1
    2bca:	0b c0       	rjmp	.+22     	; 0x2be2 <xTaskGenericCreate+0x178>
    2bcc:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    2bd0:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2bd4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bd6:	08 17       	cp	r16, r24
    2bd8:	20 f0       	brcs	.+8      	; 0x2be2 <xTaskGenericCreate+0x178>
    2bda:	c0 93 9c 32 	sts	0x329C, r28	; 0x80329c <pxCurrentTCB>
    2bde:	d0 93 9d 32 	sts	0x329D, r29	; 0x80329d <pxCurrentTCB+0x1>
    2be2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2be4:	90 91 43 32 	lds	r25, 0x3243	; 0x803243 <uxTopUsedPriority>
    2be8:	98 17       	cp	r25, r24
    2bea:	10 f4       	brcc	.+4      	; 0x2bf0 <xTaskGenericCreate+0x186>
    2bec:	80 93 43 32 	sts	0x3243, r24	; 0x803243 <uxTopUsedPriority>
    2bf0:	90 91 3c 32 	lds	r25, 0x323C	; 0x80323c <uxTaskNumber>
    2bf4:	9f 5f       	subi	r25, 0xFF	; 255
    2bf6:	90 93 3c 32 	sts	0x323C, r25	; 0x80323c <uxTaskNumber>
    2bfa:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    2bfe:	98 17       	cp	r25, r24
    2c00:	10 f4       	brcc	.+4      	; 0x2c06 <xTaskGenericCreate+0x19c>
    2c02:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    2c06:	fb e0       	ldi	r31, 0x0B	; 11
    2c08:	8f 9f       	mul	r24, r31
    2c0a:	c0 01       	movw	r24, r0
    2c0c:	11 24       	eor	r1, r1
    2c0e:	b6 01       	movw	r22, r12
    2c10:	80 59       	subi	r24, 0x90	; 144
    2c12:	9d 4c       	sbci	r25, 0xCD	; 205
    2c14:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
    2c18:	0f 90       	pop	r0
    2c1a:	0f be       	out	0x3f, r0	; 63
    2c1c:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <xSchedulerRunning>
    2c20:	88 23       	and	r24, r24
    2c22:	59 f0       	breq	.+22     	; 0x2c3a <xTaskGenericCreate+0x1d0>
    2c24:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    2c28:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2c2c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c2e:	80 17       	cp	r24, r16
    2c30:	30 f4       	brcc	.+12     	; 0x2c3e <xTaskGenericCreate+0x1d4>
    2c32:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    2c36:	81 e0       	ldi	r24, 0x01	; 1
    2c38:	09 c0       	rjmp	.+18     	; 0x2c4c <xTaskGenericCreate+0x1e2>
    2c3a:	81 e0       	ldi	r24, 0x01	; 1
    2c3c:	07 c0       	rjmp	.+14     	; 0x2c4c <xTaskGenericCreate+0x1e2>
    2c3e:	81 e0       	ldi	r24, 0x01	; 1
    2c40:	05 c0       	rjmp	.+10     	; 0x2c4c <xTaskGenericCreate+0x1e2>
    2c42:	cb 8e       	std	Y+27, r12	; 0x1b
    2c44:	dc 8e       	std	Y+28, r13	; 0x1c
    2c46:	c6 01       	movw	r24, r12
    2c48:	3b cf       	rjmp	.-394    	; 0x2ac0 <xTaskGenericCreate+0x56>
    2c4a:	8f ef       	ldi	r24, 0xFF	; 255
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	1f 91       	pop	r17
    2c52:	0f 91       	pop	r16
    2c54:	ff 90       	pop	r15
    2c56:	ef 90       	pop	r14
    2c58:	df 90       	pop	r13
    2c5a:	cf 90       	pop	r12
    2c5c:	bf 90       	pop	r11
    2c5e:	af 90       	pop	r10
    2c60:	9f 90       	pop	r9
    2c62:	8f 90       	pop	r8
    2c64:	7f 90       	pop	r7
    2c66:	6f 90       	pop	r6
    2c68:	5f 90       	pop	r5
    2c6a:	4f 90       	pop	r4
    2c6c:	08 95       	ret

00002c6e <uxTaskPriorityGet>:
    2c6e:	0f b6       	in	r0, 0x3f	; 63
    2c70:	f8 94       	cli
    2c72:	0f 92       	push	r0
    2c74:	00 97       	sbiw	r24, 0x00	; 0
    2c76:	21 f4       	brne	.+8      	; 0x2c80 <uxTaskPriorityGet+0x12>
    2c78:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    2c7c:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2c80:	0f 90       	pop	r0
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	fc 01       	movw	r30, r24
    2c86:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c88:	08 95       	ret

00002c8a <vTaskStartScheduler>:
    2c8a:	af 92       	push	r10
    2c8c:	bf 92       	push	r11
    2c8e:	cf 92       	push	r12
    2c90:	df 92       	push	r13
    2c92:	ef 92       	push	r14
    2c94:	ff 92       	push	r15
    2c96:	0f 93       	push	r16
    2c98:	a1 2c       	mov	r10, r1
    2c9a:	b1 2c       	mov	r11, r1
    2c9c:	c1 2c       	mov	r12, r1
    2c9e:	d1 2c       	mov	r13, r1
    2ca0:	0f 2e       	mov	r0, r31
    2ca2:	f9 e4       	ldi	r31, 0x49	; 73
    2ca4:	ef 2e       	mov	r14, r31
    2ca6:	f2 e3       	ldi	r31, 0x32	; 50
    2ca8:	ff 2e       	mov	r15, r31
    2caa:	f0 2d       	mov	r31, r0
    2cac:	00 e0       	ldi	r16, 0x00	; 0
    2cae:	20 e0       	ldi	r18, 0x00	; 0
    2cb0:	30 e0       	ldi	r19, 0x00	; 0
    2cb2:	44 e6       	ldi	r20, 0x64	; 100
    2cb4:	50 e0       	ldi	r21, 0x00	; 0
    2cb6:	60 e8       	ldi	r22, 0x80	; 128
    2cb8:	71 e2       	ldi	r23, 0x21	; 33
    2cba:	8f ed       	ldi	r24, 0xDF	; 223
    2cbc:	94 e1       	ldi	r25, 0x14	; 20
    2cbe:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <xTaskGenericCreate>
    2cc2:	81 30       	cpi	r24, 0x01	; 1
    2cc4:	69 f4       	brne	.+26     	; 0x2ce0 <vTaskStartScheduler+0x56>
    2cc6:	f8 94       	cli
    2cc8:	80 93 41 32 	sts	0x3241, r24	; 0x803241 <xSchedulerRunning>
    2ccc:	10 92 44 32 	sts	0x3244, r1	; 0x803244 <xTickCount>
    2cd0:	10 92 45 32 	sts	0x3245, r1	; 0x803245 <xTickCount+0x1>
    2cd4:	10 92 46 32 	sts	0x3246, r1	; 0x803246 <xTickCount+0x2>
    2cd8:	10 92 47 32 	sts	0x3247, r1	; 0x803247 <xTickCount+0x3>
    2cdc:	0e 94 fd 10 	call	0x21fa	; 0x21fa <xPortStartScheduler>
    2ce0:	0f 91       	pop	r16
    2ce2:	ff 90       	pop	r15
    2ce4:	ef 90       	pop	r14
    2ce6:	df 90       	pop	r13
    2ce8:	cf 90       	pop	r12
    2cea:	bf 90       	pop	r11
    2cec:	af 90       	pop	r10
    2cee:	08 95       	ret

00002cf0 <vTaskSuspendAll>:
    2cf0:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    2cf4:	8f 5f       	subi	r24, 0xFF	; 255
    2cf6:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <uxSchedulerSuspended>
    2cfa:	08 95       	ret

00002cfc <xTaskGetTickCount>:
    2cfc:	0f b6       	in	r0, 0x3f	; 63
    2cfe:	f8 94       	cli
    2d00:	0f 92       	push	r0
    2d02:	60 91 44 32 	lds	r22, 0x3244	; 0x803244 <xTickCount>
    2d06:	70 91 45 32 	lds	r23, 0x3245	; 0x803245 <xTickCount+0x1>
    2d0a:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount+0x2>
    2d0e:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x3>
    2d12:	0f 90       	pop	r0
    2d14:	0f be       	out	0x3f, r0	; 63
    2d16:	08 95       	ret

00002d18 <pcTaskGetTaskName>:
    2d18:	00 97       	sbiw	r24, 0x00	; 0
    2d1a:	21 f4       	brne	.+8      	; 0x2d24 <pcTaskGetTaskName+0xc>
    2d1c:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    2d20:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2d24:	4d 96       	adiw	r24, 0x1d	; 29
    2d26:	08 95       	ret

00002d28 <xTaskGetIdleTaskHandle>:
    2d28:	80 91 49 32 	lds	r24, 0x3249	; 0x803249 <xIdleTaskHandle>
    2d2c:	90 91 4a 32 	lds	r25, 0x324A	; 0x80324a <xIdleTaskHandle+0x1>
    2d30:	08 95       	ret

00002d32 <vTaskIncrementTick>:
    2d32:	ff 92       	push	r15
    2d34:	0f 93       	push	r16
    2d36:	1f 93       	push	r17
    2d38:	cf 93       	push	r28
    2d3a:	df 93       	push	r29
    2d3c:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    2d40:	81 11       	cpse	r24, r1
    2d42:	ed c0       	rjmp	.+474    	; 0x2f1e <vTaskIncrementTick+0x1ec>
    2d44:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    2d48:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    2d4c:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    2d50:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    2d54:	01 96       	adiw	r24, 0x01	; 1
    2d56:	a1 1d       	adc	r26, r1
    2d58:	b1 1d       	adc	r27, r1
    2d5a:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <xTickCount>
    2d5e:	90 93 45 32 	sts	0x3245, r25	; 0x803245 <xTickCount+0x1>
    2d62:	a0 93 46 32 	sts	0x3246, r26	; 0x803246 <xTickCount+0x2>
    2d66:	b0 93 47 32 	sts	0x3247, r27	; 0x803247 <xTickCount+0x3>
    2d6a:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    2d6e:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    2d72:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    2d76:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    2d7a:	89 2b       	or	r24, r25
    2d7c:	8a 2b       	or	r24, r26
    2d7e:	8b 2b       	or	r24, r27
    2d80:	f1 f5       	brne	.+124    	; 0x2dfe <vTaskIncrementTick+0xcc>
    2d82:	80 91 58 32 	lds	r24, 0x3258	; 0x803258 <pxDelayedTaskList>
    2d86:	90 91 59 32 	lds	r25, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2d8a:	20 91 56 32 	lds	r18, 0x3256	; 0x803256 <pxOverflowDelayedTaskList>
    2d8e:	30 91 57 32 	lds	r19, 0x3257	; 0x803257 <pxOverflowDelayedTaskList+0x1>
    2d92:	20 93 58 32 	sts	0x3258, r18	; 0x803258 <pxDelayedTaskList>
    2d96:	30 93 59 32 	sts	0x3259, r19	; 0x803259 <pxDelayedTaskList+0x1>
    2d9a:	80 93 56 32 	sts	0x3256, r24	; 0x803256 <pxOverflowDelayedTaskList>
    2d9e:	90 93 57 32 	sts	0x3257, r25	; 0x803257 <pxOverflowDelayedTaskList+0x1>
    2da2:	80 91 3d 32 	lds	r24, 0x323D	; 0x80323d <xNumOfOverflows>
    2da6:	8f 5f       	subi	r24, 0xFF	; 255
    2da8:	80 93 3d 32 	sts	0x323D, r24	; 0x80323d <xNumOfOverflows>
    2dac:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2db0:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2db4:	80 81       	ld	r24, Z
    2db6:	81 11       	cpse	r24, r1
    2db8:	0c c0       	rjmp	.+24     	; 0x2dd2 <vTaskIncrementTick+0xa0>
    2dba:	8f ef       	ldi	r24, 0xFF	; 255
    2dbc:	9f ef       	ldi	r25, 0xFF	; 255
    2dbe:	dc 01       	movw	r26, r24
    2dc0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2dc4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2dc8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2dcc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2dd0:	16 c0       	rjmp	.+44     	; 0x2dfe <vTaskIncrementTick+0xcc>
    2dd2:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2dd6:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2dda:	07 80       	ldd	r0, Z+7	; 0x07
    2ddc:	f0 85       	ldd	r31, Z+8	; 0x08
    2dde:	e0 2d       	mov	r30, r0
    2de0:	00 84       	ldd	r0, Z+8	; 0x08
    2de2:	f1 85       	ldd	r31, Z+9	; 0x09
    2de4:	e0 2d       	mov	r30, r0
    2de6:	82 81       	ldd	r24, Z+2	; 0x02
    2de8:	93 81       	ldd	r25, Z+3	; 0x03
    2dea:	a4 81       	ldd	r26, Z+4	; 0x04
    2dec:	b5 81       	ldd	r27, Z+5	; 0x05
    2dee:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2df2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2df6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2dfa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2dfe:	40 91 44 32 	lds	r20, 0x3244	; 0x803244 <xTickCount>
    2e02:	50 91 45 32 	lds	r21, 0x3245	; 0x803245 <xTickCount+0x1>
    2e06:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount+0x2>
    2e0a:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x3>
    2e0e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2e12:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e16:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e1a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e1e:	48 17       	cp	r20, r24
    2e20:	59 07       	cpc	r21, r25
    2e22:	6a 07       	cpc	r22, r26
    2e24:	7b 07       	cpc	r23, r27
    2e26:	08 f4       	brcc	.+2      	; 0x2e2a <vTaskIncrementTick+0xf8>
    2e28:	7f c0       	rjmp	.+254    	; 0x2f28 <vTaskIncrementTick+0x1f6>
    2e2a:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2e2e:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2e32:	80 81       	ld	r24, Z
    2e34:	88 23       	and	r24, r24
    2e36:	f9 f0       	breq	.+62     	; 0x2e76 <vTaskIncrementTick+0x144>
    2e38:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2e3c:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2e40:	07 80       	ldd	r0, Z+7	; 0x07
    2e42:	f0 85       	ldd	r31, Z+8	; 0x08
    2e44:	e0 2d       	mov	r30, r0
    2e46:	c0 85       	ldd	r28, Z+8	; 0x08
    2e48:	d1 85       	ldd	r29, Z+9	; 0x09
    2e4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2e4e:	ac 81       	ldd	r26, Y+4	; 0x04
    2e50:	bd 81       	ldd	r27, Y+5	; 0x05
    2e52:	40 91 44 32 	lds	r20, 0x3244	; 0x803244 <xTickCount>
    2e56:	50 91 45 32 	lds	r21, 0x3245	; 0x803245 <xTickCount+0x1>
    2e5a:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount+0x2>
    2e5e:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x3>
    2e62:	48 17       	cp	r20, r24
    2e64:	59 07       	cpc	r21, r25
    2e66:	6a 07       	cpc	r22, r26
    2e68:	7b 07       	cpc	r23, r27
    2e6a:	58 f1       	brcs	.+86     	; 0x2ec2 <vTaskIncrementTick+0x190>
    2e6c:	0f 2e       	mov	r0, r31
    2e6e:	fb e0       	ldi	r31, 0x0B	; 11
    2e70:	ff 2e       	mov	r15, r31
    2e72:	f0 2d       	mov	r31, r0
    2e74:	2f c0       	rjmp	.+94     	; 0x2ed4 <vTaskIncrementTick+0x1a2>
    2e76:	8f ef       	ldi	r24, 0xFF	; 255
    2e78:	9f ef       	ldi	r25, 0xFF	; 255
    2e7a:	dc 01       	movw	r26, r24
    2e7c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e80:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e84:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e88:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e8c:	4d c0       	rjmp	.+154    	; 0x2f28 <vTaskIncrementTick+0x1f6>
    2e8e:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2e92:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2e96:	07 80       	ldd	r0, Z+7	; 0x07
    2e98:	f0 85       	ldd	r31, Z+8	; 0x08
    2e9a:	e0 2d       	mov	r30, r0
    2e9c:	c0 85       	ldd	r28, Z+8	; 0x08
    2e9e:	d1 85       	ldd	r29, Z+9	; 0x09
    2ea0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ea2:	9b 81       	ldd	r25, Y+3	; 0x03
    2ea4:	ac 81       	ldd	r26, Y+4	; 0x04
    2ea6:	bd 81       	ldd	r27, Y+5	; 0x05
    2ea8:	40 91 44 32 	lds	r20, 0x3244	; 0x803244 <xTickCount>
    2eac:	50 91 45 32 	lds	r21, 0x3245	; 0x803245 <xTickCount+0x1>
    2eb0:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount+0x2>
    2eb4:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x3>
    2eb8:	48 17       	cp	r20, r24
    2eba:	59 07       	cpc	r21, r25
    2ebc:	6a 07       	cpc	r22, r26
    2ebe:	7b 07       	cpc	r23, r27
    2ec0:	48 f4       	brcc	.+18     	; 0x2ed4 <vTaskIncrementTick+0x1a2>
    2ec2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2ec6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2eca:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2ece:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2ed2:	2a c0       	rjmp	.+84     	; 0x2f28 <vTaskIncrementTick+0x1f6>
    2ed4:	8e 01       	movw	r16, r28
    2ed6:	0e 5f       	subi	r16, 0xFE	; 254
    2ed8:	1f 4f       	sbci	r17, 0xFF	; 255
    2eda:	c8 01       	movw	r24, r16
    2edc:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
    2ee0:	88 8d       	ldd	r24, Y+24	; 0x18
    2ee2:	99 8d       	ldd	r25, Y+25	; 0x19
    2ee4:	89 2b       	or	r24, r25
    2ee6:	21 f0       	breq	.+8      	; 0x2ef0 <vTaskIncrementTick+0x1be>
    2ee8:	ce 01       	movw	r24, r28
    2eea:	0e 96       	adiw	r24, 0x0e	; 14
    2eec:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
    2ef0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ef2:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    2ef6:	98 17       	cp	r25, r24
    2ef8:	10 f4       	brcc	.+4      	; 0x2efe <vTaskIncrementTick+0x1cc>
    2efa:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    2efe:	f8 9e       	mul	r15, r24
    2f00:	c0 01       	movw	r24, r0
    2f02:	11 24       	eor	r1, r1
    2f04:	b8 01       	movw	r22, r16
    2f06:	80 59       	subi	r24, 0x90	; 144
    2f08:	9d 4c       	sbci	r25, 0xCD	; 205
    2f0a:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
    2f0e:	e0 91 58 32 	lds	r30, 0x3258	; 0x803258 <pxDelayedTaskList>
    2f12:	f0 91 59 32 	lds	r31, 0x3259	; 0x803259 <pxDelayedTaskList+0x1>
    2f16:	80 81       	ld	r24, Z
    2f18:	81 11       	cpse	r24, r1
    2f1a:	b9 cf       	rjmp	.-142    	; 0x2e8e <vTaskIncrementTick+0x15c>
    2f1c:	ac cf       	rjmp	.-168    	; 0x2e76 <vTaskIncrementTick+0x144>
    2f1e:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <uxMissedTicks>
    2f22:	8f 5f       	subi	r24, 0xFF	; 255
    2f24:	80 93 3f 32 	sts	0x323F, r24	; 0x80323f <uxMissedTicks>
    2f28:	df 91       	pop	r29
    2f2a:	cf 91       	pop	r28
    2f2c:	1f 91       	pop	r17
    2f2e:	0f 91       	pop	r16
    2f30:	ff 90       	pop	r15
    2f32:	08 95       	ret

00002f34 <xTaskResumeAll>:
    2f34:	cf 92       	push	r12
    2f36:	df 92       	push	r13
    2f38:	ef 92       	push	r14
    2f3a:	ff 92       	push	r15
    2f3c:	0f 93       	push	r16
    2f3e:	1f 93       	push	r17
    2f40:	cf 93       	push	r28
    2f42:	df 93       	push	r29
    2f44:	0f b6       	in	r0, 0x3f	; 63
    2f46:	f8 94       	cli
    2f48:	0f 92       	push	r0
    2f4a:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    2f4e:	81 50       	subi	r24, 0x01	; 1
    2f50:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <uxSchedulerSuspended>
    2f54:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    2f58:	81 11       	cpse	r24, r1
    2f5a:	60 c0       	rjmp	.+192    	; 0x301c <xTaskResumeAll+0xe8>
    2f5c:	80 91 48 32 	lds	r24, 0x3248	; 0x803248 <uxCurrentNumberOfTasks>
    2f60:	81 11       	cpse	r24, r1
    2f62:	2c c0       	rjmp	.+88     	; 0x2fbc <xTaskResumeAll+0x88>
    2f64:	5e c0       	rjmp	.+188    	; 0x3022 <xTaskResumeAll+0xee>
    2f66:	d7 01       	movw	r26, r14
    2f68:	17 96       	adiw	r26, 0x07	; 7
    2f6a:	ed 91       	ld	r30, X+
    2f6c:	fc 91       	ld	r31, X
    2f6e:	18 97       	sbiw	r26, 0x08	; 8
    2f70:	c0 85       	ldd	r28, Z+8	; 0x08
    2f72:	d1 85       	ldd	r29, Z+9	; 0x09
    2f74:	ce 01       	movw	r24, r28
    2f76:	0e 96       	adiw	r24, 0x0e	; 14
    2f78:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
    2f7c:	8e 01       	movw	r16, r28
    2f7e:	0e 5f       	subi	r16, 0xFE	; 254
    2f80:	1f 4f       	sbci	r17, 0xFF	; 255
    2f82:	c8 01       	movw	r24, r16
    2f84:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
    2f88:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f8a:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    2f8e:	98 17       	cp	r25, r24
    2f90:	10 f4       	brcc	.+4      	; 0x2f96 <xTaskResumeAll+0x62>
    2f92:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    2f96:	d8 9e       	mul	r13, r24
    2f98:	c0 01       	movw	r24, r0
    2f9a:	11 24       	eor	r1, r1
    2f9c:	b8 01       	movw	r22, r16
    2f9e:	80 59       	subi	r24, 0x90	; 144
    2fa0:	9d 4c       	sbci	r25, 0xCD	; 205
    2fa2:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
    2fa6:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    2faa:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    2fae:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2fb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fb2:	98 17       	cp	r25, r24
    2fb4:	70 f0       	brcs	.+28     	; 0x2fd2 <xTaskResumeAll+0x9e>
    2fb6:	cc 24       	eor	r12, r12
    2fb8:	c3 94       	inc	r12
    2fba:	0b c0       	rjmp	.+22     	; 0x2fd2 <xTaskResumeAll+0x9e>
    2fbc:	c1 2c       	mov	r12, r1
    2fbe:	0f 2e       	mov	r0, r31
    2fc0:	fb e4       	ldi	r31, 0x4B	; 75
    2fc2:	ef 2e       	mov	r14, r31
    2fc4:	f2 e3       	ldi	r31, 0x32	; 50
    2fc6:	ff 2e       	mov	r15, r31
    2fc8:	f0 2d       	mov	r31, r0
    2fca:	0f 2e       	mov	r0, r31
    2fcc:	fb e0       	ldi	r31, 0x0B	; 11
    2fce:	df 2e       	mov	r13, r31
    2fd0:	f0 2d       	mov	r31, r0
    2fd2:	f7 01       	movw	r30, r14
    2fd4:	80 81       	ld	r24, Z
    2fd6:	81 11       	cpse	r24, r1
    2fd8:	c6 cf       	rjmp	.-116    	; 0x2f66 <xTaskResumeAll+0x32>
    2fda:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <uxMissedTicks>
    2fde:	88 23       	and	r24, r24
    2fe0:	81 f0       	breq	.+32     	; 0x3002 <xTaskResumeAll+0xce>
    2fe2:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <uxMissedTicks>
    2fe6:	88 23       	and	r24, r24
    2fe8:	99 f0       	breq	.+38     	; 0x3010 <xTaskResumeAll+0xdc>
    2fea:	0e 94 99 16 	call	0x2d32	; 0x2d32 <vTaskIncrementTick>
    2fee:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <uxMissedTicks>
    2ff2:	81 50       	subi	r24, 0x01	; 1
    2ff4:	80 93 3f 32 	sts	0x323F, r24	; 0x80323f <uxMissedTicks>
    2ff8:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <uxMissedTicks>
    2ffc:	81 11       	cpse	r24, r1
    2ffe:	f5 cf       	rjmp	.-22     	; 0x2fea <xTaskResumeAll+0xb6>
    3000:	07 c0       	rjmp	.+14     	; 0x3010 <xTaskResumeAll+0xdc>
    3002:	f1 e0       	ldi	r31, 0x01	; 1
    3004:	cf 16       	cp	r12, r31
    3006:	21 f0       	breq	.+8      	; 0x3010 <xTaskResumeAll+0xdc>
    3008:	80 91 3e 32 	lds	r24, 0x323E	; 0x80323e <xMissedYield>
    300c:	81 30       	cpi	r24, 0x01	; 1
    300e:	41 f4       	brne	.+16     	; 0x3020 <xTaskResumeAll+0xec>
    3010:	10 92 3e 32 	sts	0x323E, r1	; 0x80323e <xMissedYield>
    3014:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
    3018:	81 e0       	ldi	r24, 0x01	; 1
    301a:	03 c0       	rjmp	.+6      	; 0x3022 <xTaskResumeAll+0xee>
    301c:	80 e0       	ldi	r24, 0x00	; 0
    301e:	01 c0       	rjmp	.+2      	; 0x3022 <xTaskResumeAll+0xee>
    3020:	80 e0       	ldi	r24, 0x00	; 0
    3022:	0f 90       	pop	r0
    3024:	0f be       	out	0x3f, r0	; 63
    3026:	df 91       	pop	r29
    3028:	cf 91       	pop	r28
    302a:	1f 91       	pop	r17
    302c:	0f 91       	pop	r16
    302e:	ff 90       	pop	r15
    3030:	ef 90       	pop	r14
    3032:	df 90       	pop	r13
    3034:	cf 90       	pop	r12
    3036:	08 95       	ret

00003038 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3038:	cf 92       	push	r12
    303a:	df 92       	push	r13
    303c:	ef 92       	push	r14
    303e:	ff 92       	push	r15
    3040:	6b 01       	movw	r12, r22
    3042:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3044:	67 2b       	or	r22, r23
    3046:	68 2b       	or	r22, r24
    3048:	69 2b       	or	r22, r25
    304a:	e9 f0       	breq	.+58     	; 0x3086 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    304c:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3050:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    3054:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    3058:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    305c:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    3060:	c8 0e       	add	r12, r24
    3062:	d9 1e       	adc	r13, r25
    3064:	ea 1e       	adc	r14, r26
    3066:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3068:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    306c:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    3070:	02 96       	adiw	r24, 0x02	; 2
    3072:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3076:	c7 01       	movw	r24, r14
    3078:	b6 01       	movw	r22, r12
    307a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    307e:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3082:	81 11       	cpse	r24, r1
    3084:	02 c0       	rjmp	.+4      	; 0x308a <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    3086:	0e 94 3b 11 	call	0x2276	; 0x2276 <vPortYield>
		}
	}
    308a:	ff 90       	pop	r15
    308c:	ef 90       	pop	r14
    308e:	df 90       	pop	r13
    3090:	cf 90       	pop	r12
    3092:	08 95       	ret

00003094 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3094:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    3098:	81 11       	cpse	r24, r1
    309a:	0c c0       	rjmp	.+24     	; 0x30b4 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    309c:	e0 91 42 32 	lds	r30, 0x3242	; 0x803242 <uxTopReadyPriority>
    30a0:	4b e0       	ldi	r20, 0x0B	; 11
    30a2:	e4 9f       	mul	r30, r20
    30a4:	f0 01       	movw	r30, r0
    30a6:	11 24       	eor	r1, r1
    30a8:	e0 59       	subi	r30, 0x90	; 144
    30aa:	fd 4c       	sbci	r31, 0xCD	; 205
    30ac:	80 81       	ld	r24, Z
    30ae:	88 23       	and	r24, r24
    30b0:	29 f0       	breq	.+10     	; 0x30bc <vTaskSwitchContext+0x28>
    30b2:	14 c0       	rjmp	.+40     	; 0x30dc <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    30b4:	81 e0       	ldi	r24, 0x01	; 1
    30b6:	80 93 3e 32 	sts	0x323E, r24	; 0x80323e <xMissedYield>
    30ba:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    30bc:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    30be:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxTopReadyPriority>
    30c2:	81 50       	subi	r24, 0x01	; 1
    30c4:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    30c8:	e0 91 42 32 	lds	r30, 0x3242	; 0x803242 <uxTopReadyPriority>
    30cc:	9e 9f       	mul	r25, r30
    30ce:	f0 01       	movw	r30, r0
    30d0:	11 24       	eor	r1, r1
    30d2:	e0 59       	subi	r30, 0x90	; 144
    30d4:	fd 4c       	sbci	r31, 0xCD	; 205
    30d6:	80 81       	ld	r24, Z
    30d8:	88 23       	and	r24, r24
    30da:	89 f3       	breq	.-30     	; 0x30be <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    30dc:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxTopReadyPriority>
    30e0:	28 2f       	mov	r18, r24
    30e2:	30 e0       	ldi	r19, 0x00	; 0
    30e4:	4b e0       	ldi	r20, 0x0B	; 11
    30e6:	84 9f       	mul	r24, r20
    30e8:	c0 01       	movw	r24, r0
    30ea:	11 24       	eor	r1, r1
    30ec:	dc 01       	movw	r26, r24
    30ee:	a0 59       	subi	r26, 0x90	; 144
    30f0:	bd 4c       	sbci	r27, 0xCD	; 205
    30f2:	11 96       	adiw	r26, 0x01	; 1
    30f4:	ed 91       	ld	r30, X+
    30f6:	fc 91       	ld	r31, X
    30f8:	12 97       	sbiw	r26, 0x02	; 2
    30fa:	04 80       	ldd	r0, Z+4	; 0x04
    30fc:	f5 81       	ldd	r31, Z+5	; 0x05
    30fe:	e0 2d       	mov	r30, r0
    3100:	11 96       	adiw	r26, 0x01	; 1
    3102:	ed 93       	st	X+, r30
    3104:	fc 93       	st	X, r31
    3106:	12 97       	sbiw	r26, 0x02	; 2
    3108:	8d 58       	subi	r24, 0x8D	; 141
    310a:	9d 4c       	sbci	r25, 0xCD	; 205
    310c:	e8 17       	cp	r30, r24
    310e:	f9 07       	cpc	r31, r25
    3110:	61 f4       	brne	.+24     	; 0x312a <vTaskSwitchContext+0x96>
    3112:	84 81       	ldd	r24, Z+4	; 0x04
    3114:	95 81       	ldd	r25, Z+5	; 0x05
    3116:	4b e0       	ldi	r20, 0x0B	; 11
    3118:	42 9f       	mul	r20, r18
    311a:	f0 01       	movw	r30, r0
    311c:	43 9f       	mul	r20, r19
    311e:	f0 0d       	add	r31, r0
    3120:	11 24       	eor	r1, r1
    3122:	e0 59       	subi	r30, 0x90	; 144
    3124:	fd 4c       	sbci	r31, 0xCD	; 205
    3126:	81 83       	std	Z+1, r24	; 0x01
    3128:	92 83       	std	Z+2, r25	; 0x02
    312a:	8b e0       	ldi	r24, 0x0B	; 11
    312c:	82 9f       	mul	r24, r18
    312e:	f0 01       	movw	r30, r0
    3130:	83 9f       	mul	r24, r19
    3132:	f0 0d       	add	r31, r0
    3134:	11 24       	eor	r1, r1
    3136:	e0 59       	subi	r30, 0x90	; 144
    3138:	fd 4c       	sbci	r31, 0xCD	; 205
    313a:	01 80       	ldd	r0, Z+1	; 0x01
    313c:	f2 81       	ldd	r31, Z+2	; 0x02
    313e:	e0 2d       	mov	r30, r0
    3140:	80 85       	ldd	r24, Z+8	; 0x08
    3142:	91 85       	ldd	r25, Z+9	; 0x09
    3144:	80 93 9c 32 	sts	0x329C, r24	; 0x80329c <pxCurrentTCB>
    3148:	90 93 9d 32 	sts	0x329D, r25	; 0x80329d <pxCurrentTCB+0x1>
    314c:	08 95       	ret

0000314e <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    314e:	cf 92       	push	r12
    3150:	df 92       	push	r13
    3152:	ef 92       	push	r14
    3154:	ff 92       	push	r15
    3156:	6a 01       	movw	r12, r20
    3158:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    315a:	60 91 9c 32 	lds	r22, 0x329C	; 0x80329c <pxCurrentTCB>
    315e:	70 91 9d 32 	lds	r23, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    3162:	62 5f       	subi	r22, 0xF2	; 242
    3164:	7f 4f       	sbci	r23, 0xFF	; 255
    3166:	0e 94 16 10 	call	0x202c	; 0x202c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    316a:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    316e:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    3172:	02 96       	adiw	r24, 0x02	; 2
    3174:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3178:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    317c:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    3180:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    3184:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3188:	bc 01       	movw	r22, r24
    318a:	cd 01       	movw	r24, r26
    318c:	6c 0d       	add	r22, r12
    318e:	7d 1d       	adc	r23, r13
    3190:	8e 1d       	adc	r24, r14
    3192:	9f 1d       	adc	r25, r15
    3194:	0e 94 e7 14 	call	0x29ce	; 0x29ce <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3198:	ff 90       	pop	r15
    319a:	ef 90       	pop	r14
    319c:	df 90       	pop	r13
    319e:	cf 90       	pop	r12
    31a0:	08 95       	ret

000031a2 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    31a2:	0f 93       	push	r16
    31a4:	1f 93       	push	r17
    31a6:	cf 93       	push	r28
    31a8:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    31aa:	dc 01       	movw	r26, r24
    31ac:	17 96       	adiw	r26, 0x07	; 7
    31ae:	ed 91       	ld	r30, X+
    31b0:	fc 91       	ld	r31, X
    31b2:	18 97       	sbiw	r26, 0x08	; 8
    31b4:	c0 85       	ldd	r28, Z+8	; 0x08
    31b6:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    31b8:	8e 01       	movw	r16, r28
    31ba:	02 5f       	subi	r16, 0xF2	; 242
    31bc:	1f 4f       	sbci	r17, 0xFF	; 255
    31be:	c8 01       	movw	r24, r16
    31c0:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    31c4:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <uxSchedulerSuspended>
    31c8:	81 11       	cpse	r24, r1
    31ca:	16 c0       	rjmp	.+44     	; 0x31f8 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    31cc:	0c 50       	subi	r16, 0x0C	; 12
    31ce:	11 09       	sbc	r17, r1
    31d0:	c8 01       	movw	r24, r16
    31d2:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    31d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    31d8:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    31dc:	98 17       	cp	r25, r24
    31de:	10 f4       	brcc	.+4      	; 0x31e4 <xTaskRemoveFromEventList+0x42>
    31e0:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    31e4:	bb e0       	ldi	r27, 0x0B	; 11
    31e6:	8b 9f       	mul	r24, r27
    31e8:	c0 01       	movw	r24, r0
    31ea:	11 24       	eor	r1, r1
    31ec:	b8 01       	movw	r22, r16
    31ee:	80 59       	subi	r24, 0x90	; 144
    31f0:	9d 4c       	sbci	r25, 0xCD	; 205
    31f2:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
    31f6:	05 c0       	rjmp	.+10     	; 0x3202 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    31f8:	b8 01       	movw	r22, r16
    31fa:	8b e4       	ldi	r24, 0x4B	; 75
    31fc:	92 e3       	ldi	r25, 0x32	; 50
    31fe:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3202:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    3206:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    320a:	81 e0       	ldi	r24, 0x01	; 1
    320c:	2a 8d       	ldd	r18, Y+26	; 0x1a
    320e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3210:	29 17       	cp	r18, r25
    3212:	08 f4       	brcc	.+2      	; 0x3216 <xTaskRemoveFromEventList+0x74>
    3214:	80 e0       	ldi	r24, 0x00	; 0
}
    3216:	df 91       	pop	r29
    3218:	cf 91       	pop	r28
    321a:	1f 91       	pop	r17
    321c:	0f 91       	pop	r16
    321e:	08 95       	ret

00003220 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3220:	20 91 3d 32 	lds	r18, 0x323D	; 0x80323d <xNumOfOverflows>
    3224:	fc 01       	movw	r30, r24
    3226:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    3228:	40 91 44 32 	lds	r20, 0x3244	; 0x803244 <xTickCount>
    322c:	50 91 45 32 	lds	r21, 0x3245	; 0x803245 <xTickCount+0x1>
    3230:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount+0x2>
    3234:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x3>
    3238:	41 83       	std	Z+1, r20	; 0x01
    323a:	52 83       	std	Z+2, r21	; 0x02
    323c:	63 83       	std	Z+3, r22	; 0x03
    323e:	74 83       	std	Z+4, r23	; 0x04
    3240:	08 95       	ret

00003242 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3242:	8f 92       	push	r8
    3244:	9f 92       	push	r9
    3246:	af 92       	push	r10
    3248:	bf 92       	push	r11
    324a:	cf 92       	push	r12
    324c:	df 92       	push	r13
    324e:	ef 92       	push	r14
    3250:	ff 92       	push	r15
    3252:	0f 93       	push	r16
    3254:	1f 93       	push	r17
    3256:	cf 93       	push	r28
    3258:	df 93       	push	r29
    325a:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    325c:	0f b6       	in	r0, 0x3f	; 63
    325e:	f8 94       	cli
    3260:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3262:	80 91 3d 32 	lds	r24, 0x323D	; 0x80323d <xNumOfOverflows>
    3266:	90 81       	ld	r25, Z
    3268:	98 17       	cp	r25, r24
    326a:	89 f0       	breq	.+34     	; 0x328e <xTaskCheckForTimeOut+0x4c>
    326c:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    3270:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    3274:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    3278:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    327c:	01 81       	ldd	r16, Z+1	; 0x01
    327e:	12 81       	ldd	r17, Z+2	; 0x02
    3280:	23 81       	ldd	r18, Z+3	; 0x03
    3282:	34 81       	ldd	r19, Z+4	; 0x04
    3284:	80 17       	cp	r24, r16
    3286:	91 07       	cpc	r25, r17
    3288:	a2 07       	cpc	r26, r18
    328a:	b3 07       	cpc	r27, r19
    328c:	a8 f5       	brcc	.+106    	; 0x32f8 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    328e:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <xTickCount>
    3292:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <xTickCount+0x1>
    3296:	a0 91 46 32 	lds	r26, 0x3246	; 0x803246 <xTickCount+0x2>
    329a:	b0 91 47 32 	lds	r27, 0x3247	; 0x803247 <xTickCount+0x3>
    329e:	c1 80       	ldd	r12, Z+1	; 0x01
    32a0:	d2 80       	ldd	r13, Z+2	; 0x02
    32a2:	e3 80       	ldd	r14, Z+3	; 0x03
    32a4:	f4 80       	ldd	r15, Z+4	; 0x04
    32a6:	eb 01       	movw	r28, r22
    32a8:	08 81       	ld	r16, Y
    32aa:	19 81       	ldd	r17, Y+1	; 0x01
    32ac:	2a 81       	ldd	r18, Y+2	; 0x02
    32ae:	3b 81       	ldd	r19, Y+3	; 0x03
    32b0:	8c 19       	sub	r24, r12
    32b2:	9d 09       	sbc	r25, r13
    32b4:	ae 09       	sbc	r26, r14
    32b6:	bf 09       	sbc	r27, r15
    32b8:	80 17       	cp	r24, r16
    32ba:	91 07       	cpc	r25, r17
    32bc:	a2 07       	cpc	r26, r18
    32be:	b3 07       	cpc	r27, r19
    32c0:	e8 f4       	brcc	.+58     	; 0x32fc <xTaskCheckForTimeOut+0xba>
    32c2:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    32c4:	80 90 44 32 	lds	r8, 0x3244	; 0x803244 <xTickCount>
    32c8:	90 90 45 32 	lds	r9, 0x3245	; 0x803245 <xTickCount+0x1>
    32cc:	a0 90 46 32 	lds	r10, 0x3246	; 0x803246 <xTickCount+0x2>
    32d0:	b0 90 47 32 	lds	r11, 0x3247	; 0x803247 <xTickCount+0x3>
    32d4:	b5 01       	movw	r22, r10
    32d6:	a4 01       	movw	r20, r8
    32d8:	4c 19       	sub	r20, r12
    32da:	5d 09       	sbc	r21, r13
    32dc:	6e 09       	sbc	r22, r14
    32de:	7f 09       	sbc	r23, r15
    32e0:	04 1b       	sub	r16, r20
    32e2:	15 0b       	sbc	r17, r21
    32e4:	26 0b       	sbc	r18, r22
    32e6:	37 0b       	sbc	r19, r23
    32e8:	08 83       	st	Y, r16
    32ea:	19 83       	std	Y+1, r17	; 0x01
    32ec:	2a 83       	std	Y+2, r18	; 0x02
    32ee:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    32f0:	0e 94 10 19 	call	0x3220	; 0x3220 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    32f4:	80 e0       	ldi	r24, 0x00	; 0
    32f6:	03 c0       	rjmp	.+6      	; 0x32fe <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    32f8:	81 e0       	ldi	r24, 0x01	; 1
    32fa:	01 c0       	rjmp	.+2      	; 0x32fe <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    32fc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    32fe:	0f 90       	pop	r0
    3300:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3302:	df 91       	pop	r29
    3304:	cf 91       	pop	r28
    3306:	1f 91       	pop	r17
    3308:	0f 91       	pop	r16
    330a:	ff 90       	pop	r15
    330c:	ef 90       	pop	r14
    330e:	df 90       	pop	r13
    3310:	cf 90       	pop	r12
    3312:	bf 90       	pop	r11
    3314:	af 90       	pop	r10
    3316:	9f 90       	pop	r9
    3318:	8f 90       	pop	r8
    331a:	08 95       	ret

0000331c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    331c:	81 e0       	ldi	r24, 0x01	; 1
    331e:	80 93 3e 32 	sts	0x323E, r24	; 0x80323e <xMissedYield>
    3322:	08 95       	ret

00003324 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3324:	00 97       	sbiw	r24, 0x00	; 0
    3326:	21 f4       	brne	.+8      	; 0x3330 <uxTaskGetStackHighWaterMark+0xc>
    3328:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    332c:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    3330:	dc 01       	movw	r26, r24
    3332:	5b 96       	adiw	r26, 0x1b	; 27
    3334:	ed 91       	ld	r30, X+
    3336:	fc 91       	ld	r31, X
    3338:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    333a:	80 81       	ld	r24, Z
    333c:	81 31       	cpi	r24, 0x11	; 17
    333e:	41 f4       	brne	.+16     	; 0x3350 <uxTaskGetStackHighWaterMark+0x2c>
    3340:	31 96       	adiw	r30, 0x01	; 1
    3342:	80 e0       	ldi	r24, 0x00	; 0
    3344:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    3346:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    3348:	21 91       	ld	r18, Z+
    334a:	21 31       	cpi	r18, 0x11	; 17
    334c:	e1 f3       	breq	.-8      	; 0x3346 <uxTaskGetStackHighWaterMark+0x22>
    334e:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    3350:	80 e0       	ldi	r24, 0x00	; 0
    3352:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3354:	08 95       	ret

00003356 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3356:	80 91 9c 32 	lds	r24, 0x329C	; 0x80329c <pxCurrentTCB>
    335a:	90 91 9d 32 	lds	r25, 0x329D	; 0x80329d <pxCurrentTCB+0x1>

		return xReturn;
	}
    335e:	08 95       	ret

00003360 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    3360:	0f 93       	push	r16
    3362:	1f 93       	push	r17
    3364:	cf 93       	push	r28
    3366:	df 93       	push	r29
    3368:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    336a:	22 8d       	ldd	r18, Z+26	; 0x1a
    336c:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    3370:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    3374:	5a 96       	adiw	r26, 0x1a	; 26
    3376:	8c 91       	ld	r24, X
    3378:	28 17       	cp	r18, r24
    337a:	08 f0       	brcs	.+2      	; 0x337e <vTaskPriorityInherit+0x1e>
    337c:	41 c0       	rjmp	.+130    	; 0x3400 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    337e:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    3382:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    3386:	5a 96       	adiw	r26, 0x1a	; 26
    3388:	3c 91       	ld	r19, X
    338a:	84 e0       	ldi	r24, 0x04	; 4
    338c:	90 e0       	ldi	r25, 0x00	; 0
    338e:	a0 e0       	ldi	r26, 0x00	; 0
    3390:	b0 e0       	ldi	r27, 0x00	; 0
    3392:	83 1b       	sub	r24, r19
    3394:	91 09       	sbc	r25, r1
    3396:	a1 09       	sbc	r26, r1
    3398:	b1 09       	sbc	r27, r1
    339a:	86 87       	std	Z+14, r24	; 0x0e
    339c:	97 87       	std	Z+15, r25	; 0x0f
    339e:	a0 8b       	std	Z+16, r26	; 0x10
    33a0:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    33a2:	8b e0       	ldi	r24, 0x0B	; 11
    33a4:	28 9f       	mul	r18, r24
    33a6:	90 01       	movw	r18, r0
    33a8:	11 24       	eor	r1, r1
    33aa:	20 59       	subi	r18, 0x90	; 144
    33ac:	3d 4c       	sbci	r19, 0xCD	; 205
    33ae:	84 85       	ldd	r24, Z+12	; 0x0c
    33b0:	95 85       	ldd	r25, Z+13	; 0x0d
    33b2:	82 17       	cp	r24, r18
    33b4:	93 07       	cpc	r25, r19
    33b6:	e9 f4       	brne	.+58     	; 0x33f2 <vTaskPriorityInherit+0x92>
    33b8:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    33ba:	ef 01       	movw	r28, r30
    33bc:	22 96       	adiw	r28, 0x02	; 2
    33be:	ce 01       	movw	r24, r28
    33c0:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    33c4:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <pxCurrentTCB>
    33c8:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    33cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    33ce:	f8 01       	movw	r30, r16
    33d0:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    33d2:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    33d6:	98 17       	cp	r25, r24
    33d8:	10 f4       	brcc	.+4      	; 0x33de <vTaskPriorityInherit+0x7e>
    33da:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    33de:	fb e0       	ldi	r31, 0x0B	; 11
    33e0:	8f 9f       	mul	r24, r31
    33e2:	c0 01       	movw	r24, r0
    33e4:	11 24       	eor	r1, r1
    33e6:	be 01       	movw	r22, r28
    33e8:	80 59       	subi	r24, 0x90	; 144
    33ea:	9d 4c       	sbci	r25, 0xCD	; 205
    33ec:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
    33f0:	07 c0       	rjmp	.+14     	; 0x3400 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    33f2:	a0 91 9c 32 	lds	r26, 0x329C	; 0x80329c <pxCurrentTCB>
    33f6:	b0 91 9d 32 	lds	r27, 0x329D	; 0x80329d <pxCurrentTCB+0x1>
    33fa:	5a 96       	adiw	r26, 0x1a	; 26
    33fc:	8c 91       	ld	r24, X
    33fe:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    3400:	df 91       	pop	r29
    3402:	cf 91       	pop	r28
    3404:	1f 91       	pop	r17
    3406:	0f 91       	pop	r16
    3408:	08 95       	ret

0000340a <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    340a:	0f 93       	push	r16
    340c:	1f 93       	push	r17
    340e:	cf 93       	push	r28
    3410:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3412:	00 97       	sbiw	r24, 0x00	; 0
    3414:	49 f1       	breq	.+82     	; 0x3468 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3416:	fc 01       	movw	r30, r24
    3418:	32 8d       	ldd	r19, Z+26	; 0x1a
    341a:	27 a1       	ldd	r18, Z+39	; 0x27
    341c:	32 17       	cp	r19, r18
    341e:	21 f1       	breq	.+72     	; 0x3468 <vTaskPriorityDisinherit+0x5e>
    3420:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3422:	8c 01       	movw	r16, r24
    3424:	0e 5f       	subi	r16, 0xFE	; 254
    3426:	1f 4f       	sbci	r17, 0xFF	; 255
    3428:	c8 01       	movw	r24, r16
    342a:	0e 94 61 10 	call	0x20c2	; 0x20c2 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    342e:	8f a1       	ldd	r24, Y+39	; 0x27
    3430:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    3432:	44 e0       	ldi	r20, 0x04	; 4
    3434:	50 e0       	ldi	r21, 0x00	; 0
    3436:	60 e0       	ldi	r22, 0x00	; 0
    3438:	70 e0       	ldi	r23, 0x00	; 0
    343a:	48 1b       	sub	r20, r24
    343c:	51 09       	sbc	r21, r1
    343e:	61 09       	sbc	r22, r1
    3440:	71 09       	sbc	r23, r1
    3442:	4e 87       	std	Y+14, r20	; 0x0e
    3444:	5f 87       	std	Y+15, r21	; 0x0f
    3446:	68 8b       	std	Y+16, r22	; 0x10
    3448:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    344a:	90 91 42 32 	lds	r25, 0x3242	; 0x803242 <uxTopReadyPriority>
    344e:	98 17       	cp	r25, r24
    3450:	10 f4       	brcc	.+4      	; 0x3456 <vTaskPriorityDisinherit+0x4c>
    3452:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxTopReadyPriority>
    3456:	fb e0       	ldi	r31, 0x0B	; 11
    3458:	8f 9f       	mul	r24, r31
    345a:	c0 01       	movw	r24, r0
    345c:	11 24       	eor	r1, r1
    345e:	b8 01       	movw	r22, r16
    3460:	80 59       	subi	r24, 0x90	; 144
    3462:	9d 4c       	sbci	r25, 0xCD	; 205
    3464:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <vListInsertEnd>
			}
		}
	}
    3468:	df 91       	pop	r29
    346a:	cf 91       	pop	r28
    346c:	1f 91       	pop	r17
    346e:	0f 91       	pop	r16
    3470:	08 95       	ret

00003472 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    3472:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    3474:	e8 81       	ld	r30, Y
    3476:	f9 81       	ldd	r31, Y+1	; 0x01
    3478:	01 90       	ld	r0, Z+
    347a:	f0 81       	ld	r31, Z
    347c:	e0 2d       	mov	r30, r0
    347e:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    3480:	1a 82       	std	Y+2, r1	; 0x02
    3482:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    3484:	6f ef       	ldi	r22, 0xFF	; 255
    3486:	7f ef       	ldi	r23, 0xFF	; 255
    3488:	cb 01       	movw	r24, r22
    348a:	0e 94 1c 18 	call	0x3038	; 0x3038 <vTaskDelay>
    348e:	fa cf       	rjmp	.-12     	; 0x3484 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00003490 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    3490:	fc 01       	movw	r30, r24
    3492:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3494:	65 87       	std	Z+13, r22	; 0x0d
    3496:	08 95       	ret

00003498 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    3498:	4f 92       	push	r4
    349a:	5f 92       	push	r5
    349c:	6f 92       	push	r6
    349e:	7f 92       	push	r7
    34a0:	8f 92       	push	r8
    34a2:	9f 92       	push	r9
    34a4:	af 92       	push	r10
    34a6:	bf 92       	push	r11
    34a8:	cf 92       	push	r12
    34aa:	df 92       	push	r13
    34ac:	ef 92       	push	r14
    34ae:	ff 92       	push	r15
    34b0:	0f 93       	push	r16
    34b2:	1f 93       	push	r17
    34b4:	cf 93       	push	r28
    34b6:	df 93       	push	r29
    34b8:	cd b7       	in	r28, 0x3d	; 61
    34ba:	de b7       	in	r29, 0x3e	; 62
    34bc:	2a 97       	sbiw	r28, 0x0a	; 10
    34be:	cd bf       	out	0x3d, r28	; 61
    34c0:	de bf       	out	0x3e, r29	; 62
    34c2:	4c 01       	movw	r8, r24
    34c4:	29 01       	movw	r4, r18
    34c6:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    34c8:	89 e8       	ldi	r24, 0x89	; 137
    34ca:	91 e2       	ldi	r25, 0x21	; 33
    34cc:	f4 01       	movw	r30, r8
    34ce:	80 83       	st	Z, r24
    34d0:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    34d2:	fb 01       	movw	r30, r22
    34d4:	80 81       	ld	r24, Z
    34d6:	88 23       	and	r24, r24
    34d8:	69 f0       	breq	.+26     	; 0x34f4 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    34da:	de 01       	movw	r26, r28
    34dc:	11 96       	adiw	r26, 0x01	; 1
    34de:	31 96       	adiw	r30, 0x01	; 1
    34e0:	90 e0       	ldi	r25, 0x00	; 0
    34e2:	02 c0       	rjmp	.+4      	; 0x34e8 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    34e4:	99 30       	cpi	r25, 0x09	; 9
    34e6:	39 f0       	breq	.+14     	; 0x34f6 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    34e8:	9f 5f       	subi	r25, 0xFF	; 255
    34ea:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    34ec:	81 91       	ld	r24, Z+
    34ee:	81 11       	cpse	r24, r1
    34f0:	f9 cf       	rjmp	.-14     	; 0x34e4 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    34f2:	01 c0       	rjmp	.+2      	; 0x34f6 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    34f4:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    34f6:	e1 e0       	ldi	r30, 0x01	; 1
    34f8:	f0 e0       	ldi	r31, 0x00	; 0
    34fa:	ec 0f       	add	r30, r28
    34fc:	fd 1f       	adc	r31, r29
    34fe:	e9 0f       	add	r30, r25
    3500:	f1 1d       	adc	r31, r1
    3502:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3504:	74 01       	movw	r14, r8
    3506:	f2 e0       	ldi	r31, 0x02	; 2
    3508:	ef 0e       	add	r14, r31
    350a:	f1 1c       	adc	r15, r1
    350c:	a1 2c       	mov	r10, r1
    350e:	b1 2c       	mov	r11, r1
    3510:	c1 2c       	mov	r12, r1
    3512:	d1 2c       	mov	r13, r1
    3514:	04 2f       	mov	r16, r20
    3516:	94 01       	movw	r18, r8
    3518:	a2 01       	movw	r20, r4
    351a:	be 01       	movw	r22, r28
    351c:	6f 5f       	subi	r22, 0xFF	; 255
    351e:	7f 4f       	sbci	r23, 0xFF	; 255
    3520:	84 e3       	ldi	r24, 0x34	; 52
    3522:	93 e0       	ldi	r25, 0x03	; 3
    3524:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    3528:	f4 01       	movw	r30, r8
    352a:	66 82       	std	Z+6, r6	; 0x06
    352c:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    352e:	40 86       	std	Z+8, r4	; 0x08
    3530:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3532:	20 91 9e 32 	lds	r18, 0x329E	; 0x80329e <last_created_task_pointer>
    3536:	30 91 9f 32 	lds	r19, 0x329F	; 0x80329f <last_created_task_pointer+0x1>
    353a:	24 83       	std	Z+4, r18	; 0x04
    353c:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    353e:	80 92 9e 32 	sts	0x329E, r8	; 0x80329e <last_created_task_pointer>
    3542:	90 92 9f 32 	sts	0x329F, r9	; 0x80329f <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    3546:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    3548:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    354a:	40 90 00 33 	lds	r4, 0x3300	; 0x803300 <portStackTopForTask>
    354e:	50 90 01 33 	lds	r5, 0x3301	; 0x803301 <portStackTopForTask+0x1>
    3552:	ff ef       	ldi	r31, 0xFF	; 255
    3554:	4f 1a       	sub	r4, r31
    3556:	5f 0a       	sbc	r5, r31
    3558:	40 92 00 33 	sts	0x3300, r4	; 0x803300 <portStackTopForTask>
    355c:	50 92 01 33 	sts	0x3301, r5	; 0x803301 <portStackTopForTask+0x1>
    3560:	f4 01       	movw	r30, r8
    3562:	42 86       	std	Z+10, r4	; 0x0a
    3564:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3566:	16 86       	std	Z+14, r1	; 0x0e
    3568:	17 86       	std	Z+15, r1	; 0x0f
    356a:	10 8a       	std	Z+16, r1	; 0x10
    356c:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    356e:	61 14       	cp	r6, r1
    3570:	71 04       	cpc	r7, r1
    3572:	09 f4       	brne	.+2      	; 0x3576 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3574:	44 c0       	rjmp	.+136    	; 0x35fe <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3576:	81 30       	cpi	r24, 0x01	; 1
    3578:	79 f5       	brne	.+94     	; 0x35d8 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    357a:	6a e0       	ldi	r22, 0x0A	; 10
    357c:	c3 01       	movw	r24, r6
    357e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3582:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3584:	65 eb       	ldi	r22, 0xB5	; 181
    3586:	75 e0       	ldi	r23, 0x05	; 5
    3588:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    358c:	be 01       	movw	r22, r28
    358e:	6f 5f       	subi	r22, 0xFF	; 255
    3590:	7f 4f       	sbci	r23, 0xFF	; 255
    3592:	c7 01       	movw	r24, r14
    3594:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3598:	6a e0       	ldi	r22, 0x0A	; 10
    359a:	c7 01       	movw	r24, r14
    359c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35a0:	7c 01       	movw	r14, r24
    35a2:	6c ea       	ldi	r22, 0xAC	; 172
    35a4:	75 e0       	ldi	r23, 0x05	; 5
    35a6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    35aa:	6a e0       	ldi	r22, 0x0A	; 10
    35ac:	c7 01       	movw	r24, r14
    35ae:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35b2:	7c 01       	movw	r14, r24
    35b4:	6e e9       	ldi	r22, 0x9E	; 158
    35b6:	75 e0       	ldi	r23, 0x05	; 5
    35b8:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    35bc:	63 e0       	ldi	r22, 0x03	; 3
    35be:	c7 01       	movw	r24, r14
    35c0:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35c4:	b2 01       	movw	r22, r4
    35c6:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    35ca:	62 e0       	ldi	r22, 0x02	; 2
    35cc:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35d0:	66 e0       	ldi	r22, 0x06	; 6
    35d2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35d6:	13 c0       	rjmp	.+38     	; 0x35fe <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    35d8:	6a e0       	ldi	r22, 0x0A	; 10
    35da:	c3 01       	movw	r24, r6
    35dc:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    35e0:	4c 01       	movw	r8, r24
    35e2:	69 e8       	ldi	r22, 0x89	; 137
    35e4:	75 e0       	ldi	r23, 0x05	; 5
    35e6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    35ea:	be 01       	movw	r22, r28
    35ec:	6f 5f       	subi	r22, 0xFF	; 255
    35ee:	7f 4f       	sbci	r23, 0xFF	; 255
    35f0:	c4 01       	movw	r24, r8
    35f2:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    35f6:	66 e0       	ldi	r22, 0x06	; 6
    35f8:	c4 01       	movw	r24, r8
    35fa:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    35fe:	2a 96       	adiw	r28, 0x0a	; 10
    3600:	cd bf       	out	0x3d, r28	; 61
    3602:	de bf       	out	0x3e, r29	; 62
    3604:	df 91       	pop	r29
    3606:	cf 91       	pop	r28
    3608:	1f 91       	pop	r17
    360a:	0f 91       	pop	r16
    360c:	ff 90       	pop	r15
    360e:	ef 90       	pop	r14
    3610:	df 90       	pop	r13
    3612:	cf 90       	pop	r12
    3614:	bf 90       	pop	r11
    3616:	af 90       	pop	r10
    3618:	9f 90       	pop	r9
    361a:	8f 90       	pop	r8
    361c:	7f 90       	pop	r7
    361e:	6f 90       	pop	r6
    3620:	5f 90       	pop	r5
    3622:	4f 90       	pop	r4
    3624:	08 95       	ret

00003626 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3626:	cf 92       	push	r12
    3628:	df 92       	push	r13
    362a:	ef 92       	push	r14
    362c:	ff 92       	push	r15
    362e:	0f 93       	push	r16
    3630:	1f 93       	push	r17
    3632:	cf 93       	push	r28
    3634:	df 93       	push	r29
    3636:	ec 01       	movw	r28, r24
    3638:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    363a:	8a 81       	ldd	r24, Y+2	; 0x02
    363c:	9b 81       	ldd	r25, Y+3	; 0x03
    363e:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <pcTaskGetTaskName>
    3642:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3644:	6a e0       	ldi	r22, 0x0A	; 10
    3646:	c7 01       	movw	r24, r14
    3648:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    364c:	8c 01       	movw	r16, r24
    364e:	68 ec       	ldi	r22, 0xC8	; 200
    3650:	75 e0       	ldi	r23, 0x05	; 5
    3652:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3656:	6a e0       	ldi	r22, 0x0A	; 10
    3658:	c8 01       	movw	r24, r16
    365a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    365e:	8c 01       	movw	r16, r24
    3660:	61 ec       	ldi	r22, 0xC1	; 193
    3662:	75 e0       	ldi	r23, 0x05	; 5
    3664:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3668:	b6 01       	movw	r22, r12
    366a:	c8 01       	movw	r24, r16
    366c:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3670:	6a e0       	ldi	r22, 0x0A	; 10
    3672:	c8 01       	movw	r24, r16
    3674:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3678:	8c 01       	movw	r16, r24
    367a:	6b eb       	ldi	r22, 0xBB	; 187
    367c:	75 e0       	ldi	r23, 0x05	; 5
    367e:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3682:	66 e0       	ldi	r22, 0x06	; 6
    3684:	c8 01       	movw	r24, r16
    3686:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    368a:	8a 85       	ldd	r24, Y+10	; 0x0a
    368c:	9b 85       	ldd	r25, Y+11	; 0x0b
    368e:	e8 85       	ldd	r30, Y+8	; 0x08
    3690:	f9 85       	ldd	r31, Y+9	; 0x09
    3692:	01 e1       	ldi	r16, 0x11	; 17
    3694:	21 e0       	ldi	r18, 0x01	; 1
    3696:	a7 01       	movw	r20, r14
    3698:	bc 01       	movw	r22, r24
    369a:	8e 1b       	sub	r24, r30
    369c:	9f 0b       	sbc	r25, r31
    369e:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    36a2:	8c 81       	ldd	r24, Y+4	; 0x04
    36a4:	9d 81       	ldd	r25, Y+5	; 0x05
    36a6:	00 97       	sbiw	r24, 0x00	; 0
    36a8:	19 f0       	breq	.+6      	; 0x36b0 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    36aa:	b7 01       	movw	r22, r14
    36ac:	0e 94 13 1b 	call	0x3626	; 0x3626 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    36b0:	df 91       	pop	r29
    36b2:	cf 91       	pop	r28
    36b4:	1f 91       	pop	r17
    36b6:	0f 91       	pop	r16
    36b8:	ff 90       	pop	r15
    36ba:	ef 90       	pop	r14
    36bc:	df 90       	pop	r13
    36be:	cf 90       	pop	r12
    36c0:	08 95       	ret

000036c2 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    36c2:	0f 93       	push	r16
    36c4:	1f 93       	push	r17
    36c6:	cf 93       	push	r28
    36c8:	df 93       	push	r29
    36ca:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    36cc:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <last_created_task_pointer>
    36d0:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <last_created_task_pointer+0x1>
    36d4:	00 97       	sbiw	r24, 0x00	; 0
    36d6:	19 f0       	breq	.+6      	; 0x36de <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    36d8:	be 01       	movw	r22, r28
    36da:	0e 94 13 1b 	call	0x3626	; 0x3626 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    36de:	6a e0       	ldi	r22, 0x0A	; 10
    36e0:	ce 01       	movw	r24, r28
    36e2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    36e6:	8c 01       	movw	r16, r24
    36e8:	6e ed       	ldi	r22, 0xDE	; 222
    36ea:	75 e0       	ldi	r23, 0x05	; 5
    36ec:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    36f0:	6a e0       	ldi	r22, 0x0A	; 10
    36f2:	c8 01       	movw	r24, r16
    36f4:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    36f8:	8c 01       	movw	r16, r24
    36fa:	63 ed       	ldi	r22, 0xD3	; 211
    36fc:	75 e0       	ldi	r23, 0x05	; 5
    36fe:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3702:	6a e0       	ldi	r22, 0x0A	; 10
    3704:	c8 01       	movw	r24, r16
    3706:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    370a:	8c 01       	movw	r16, r24
    370c:	6d ec       	ldi	r22, 0xCD	; 205
    370e:	75 e0       	ldi	r23, 0x05	; 5
    3710:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3714:	66 e0       	ldi	r22, 0x06	; 6
    3716:	c8 01       	movw	r24, r16
    3718:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    371c:	80 91 00 33 	lds	r24, 0x3300	; 0x803300 <portStackTopForTask>
    3720:	90 91 01 33 	lds	r25, 0x3301	; 0x803301 <portStackTopForTask+0x1>
    3724:	bc 01       	movw	r22, r24
    3726:	6f 5f       	subi	r22, 0xFF	; 255
    3728:	7f 4f       	sbci	r23, 0xFF	; 255
    372a:	01 e1       	ldi	r16, 0x11	; 17
    372c:	21 e0       	ldi	r18, 0x01	; 1
    372e:	ae 01       	movw	r20, r28
    3730:	83 56       	subi	r24, 0x63	; 99
    3732:	91 09       	sbc	r25, r1
    3734:	0e 94 15 1e 	call	0x3c2a	; 0x3c2a <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3738:	df 91       	pop	r29
    373a:	cf 91       	pop	r28
    373c:	1f 91       	pop	r17
    373e:	0f 91       	pop	r16
    3740:	08 95       	ret

00003742 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3742:	8f 92       	push	r8
    3744:	9f 92       	push	r9
    3746:	af 92       	push	r10
    3748:	bf 92       	push	r11
    374a:	cf 92       	push	r12
    374c:	df 92       	push	r13
    374e:	ef 92       	push	r14
    3750:	ff 92       	push	r15
    3752:	0f 93       	push	r16
    3754:	1f 93       	push	r17
    3756:	cf 93       	push	r28
    3758:	df 93       	push	r29
    375a:	ec 01       	movw	r28, r24
    375c:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    375e:	8a 81       	ldd	r24, Y+2	; 0x02
    3760:	9b 81       	ldd	r25, Y+3	; 0x03
    3762:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <pcTaskGetTaskName>
    3766:	bc 01       	movw	r22, r24
    3768:	c8 01       	movw	r24, r16
    376a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    376e:	d8 01       	movw	r26, r16
    3770:	ed 91       	ld	r30, X+
    3772:	fc 91       	ld	r31, X
    3774:	02 80       	ldd	r0, Z+2	; 0x02
    3776:	f3 81       	ldd	r31, Z+3	; 0x03
    3778:	e0 2d       	mov	r30, r0
    377a:	69 e0       	ldi	r22, 0x09	; 9
    377c:	c8 01       	movw	r24, r16
    377e:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3780:	8a 81       	ldd	r24, Y+2	; 0x02
    3782:	9b 81       	ldd	r25, Y+3	; 0x03
    3784:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <pcTaskGetTaskName>
    3788:	fc 01       	movw	r30, r24
    378a:	01 90       	ld	r0, Z+
    378c:	00 20       	and	r0, r0
    378e:	e9 f7       	brne	.-6      	; 0x378a <_ZN8frt_task12print_statusER8emstream+0x48>
    3790:	31 97       	sbiw	r30, 0x01	; 1
    3792:	e8 1b       	sub	r30, r24
    3794:	f9 0b       	sbc	r31, r25
    3796:	38 97       	sbiw	r30, 0x08	; 8
    3798:	48 f4       	brcc	.+18     	; 0x37ac <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    379a:	d8 01       	movw	r26, r16
    379c:	ed 91       	ld	r30, X+
    379e:	fc 91       	ld	r31, X
    37a0:	02 80       	ldd	r0, Z+2	; 0x02
    37a2:	f3 81       	ldd	r31, Z+3	; 0x03
    37a4:	e0 2d       	mov	r30, r0
    37a6:	69 e0       	ldi	r22, 0x09	; 9
    37a8:	c8 01       	movw	r24, r16
    37aa:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    37ac:	ce 84       	ldd	r12, Y+14	; 0x0e
    37ae:	df 84       	ldd	r13, Y+15	; 0x0f
    37b0:	e8 88       	ldd	r14, Y+16	; 0x10
    37b2:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    37b4:	a8 84       	ldd	r10, Y+8	; 0x08
    37b6:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    37b8:	8a 81       	ldd	r24, Y+2	; 0x02
    37ba:	9b 81       	ldd	r25, Y+3	; 0x03
    37bc:	0e 94 92 19 	call	0x3324	; 0x3324 <uxTaskGetStackHighWaterMark>
    37c0:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    37c2:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    37c4:	8a 81       	ldd	r24, Y+2	; 0x02
    37c6:	9b 81       	ldd	r25, Y+3	; 0x03
    37c8:	0e 94 37 16 	call	0x2c6e	; 0x2c6e <uxTaskPriorityGet>
    37cc:	68 2f       	mov	r22, r24
    37ce:	c8 01       	movw	r24, r16
    37d0:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    37d4:	6a e0       	ldi	r22, 0x0A	; 10
    37d6:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    37da:	ec 01       	movw	r28, r24
    37dc:	63 e5       	ldi	r22, 0x53	; 83
    37de:	76 e0       	ldi	r23, 0x06	; 6
    37e0:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
			<< get_state ()
    37e4:	68 2d       	mov	r22, r8
    37e6:	ce 01       	movw	r24, r28
    37e8:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    37ec:	6a e0       	ldi	r22, 0x0A	; 10
    37ee:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    37f2:	ec 01       	movw	r28, r24
    37f4:	61 e5       	ldi	r22, 0x51	; 81
    37f6:	76 e0       	ldi	r23, 0x06	; 6
    37f8:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    37fc:	69 2d       	mov	r22, r9
    37fe:	ce 01       	movw	r24, r28
    3800:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    3804:	6a e0       	ldi	r22, 0x0A	; 10
    3806:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    380a:	ec 01       	movw	r28, r24
    380c:	6f e4       	ldi	r22, 0x4F	; 79
    380e:	76 e0       	ldi	r23, 0x06	; 6
    3810:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3814:	b5 01       	movw	r22, r10
    3816:	ce 01       	movw	r24, r28
    3818:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    381c:	6a e0       	ldi	r22, 0x0A	; 10
    381e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3822:	ec 01       	movw	r28, r24
    3824:	6d e4       	ldi	r22, 0x4D	; 77
    3826:	76 e0       	ldi	r23, 0x06	; 6
    3828:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    382c:	6a e0       	ldi	r22, 0x0A	; 10
    382e:	ce 01       	movw	r24, r28
    3830:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3834:	ec 01       	movw	r28, r24
    3836:	6b e4       	ldi	r22, 0x4B	; 75
    3838:	76 e0       	ldi	r23, 0x06	; 6
    383a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    383e:	b7 01       	movw	r22, r14
    3840:	a6 01       	movw	r20, r12
    3842:	ce 01       	movw	r24, r28
    3844:	0e 94 69 20 	call	0x40d2	; 0x40d2 <_ZN8emstreamlsEm>
}
    3848:	df 91       	pop	r29
    384a:	cf 91       	pop	r28
    384c:	1f 91       	pop	r17
    384e:	0f 91       	pop	r16
    3850:	ff 90       	pop	r15
    3852:	ef 90       	pop	r14
    3854:	df 90       	pop	r13
    3856:	cf 90       	pop	r12
    3858:	bf 90       	pop	r11
    385a:	af 90       	pop	r10
    385c:	9f 90       	pop	r9
    385e:	8f 90       	pop	r8
    3860:	08 95       	ret

00003862 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3862:	cf 93       	push	r28
    3864:	df 93       	push	r29
    3866:	ec 01       	movw	r28, r24
    3868:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    386a:	db 01       	movw	r26, r22
    386c:	ed 91       	ld	r30, X+
    386e:	fc 91       	ld	r31, X
    3870:	02 80       	ldd	r0, Z+2	; 0x02
    3872:	f3 81       	ldd	r31, Z+3	; 0x03
    3874:	e0 2d       	mov	r30, r0
    3876:	be 01       	movw	r22, r28
    3878:	19 95       	eicall
	return (ser_dev);
}
    387a:	ce 01       	movw	r24, r28
    387c:	df 91       	pop	r29
    387e:	cf 91       	pop	r28
    3880:	08 95       	ret

00003882 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3882:	0f 93       	push	r16
    3884:	1f 93       	push	r17
    3886:	cf 93       	push	r28
    3888:	df 93       	push	r29
    388a:	ec 01       	movw	r28, r24
    388c:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    388e:	bc 01       	movw	r22, r24
    3890:	c8 01       	movw	r24, r16
    3892:	0e 94 31 1c 	call	0x3862	; 0x3862 <_ZlsR8emstreamR8frt_task>
    3896:	66 e0       	ldi	r22, 0x06	; 6
    3898:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    389c:	8c 81       	ldd	r24, Y+4	; 0x04
    389e:	9d 81       	ldd	r25, Y+5	; 0x05
    38a0:	00 97       	sbiw	r24, 0x00	; 0
    38a2:	19 f0       	breq	.+6      	; 0x38aa <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    38a4:	b8 01       	movw	r22, r16
    38a6:	0e 94 41 1c 	call	0x3882	; 0x3882 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    38aa:	df 91       	pop	r29
    38ac:	cf 91       	pop	r28
    38ae:	1f 91       	pop	r17
    38b0:	0f 91       	pop	r16
    38b2:	08 95       	ret

000038b4 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    38b4:	0f 93       	push	r16
    38b6:	1f 93       	push	r17
    38b8:	cf 93       	push	r28
    38ba:	df 93       	push	r29
    38bc:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    38be:	6a e0       	ldi	r22, 0x0A	; 10
    38c0:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    38c4:	8c 01       	movw	r16, r24
    38c6:	60 e4       	ldi	r22, 0x40	; 64
    38c8:	76 e0       	ldi	r23, 0x06	; 6
    38ca:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    38ce:	6a e0       	ldi	r22, 0x0A	; 10
    38d0:	c8 01       	movw	r24, r16
    38d2:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    38d6:	8c 01       	movw	r16, r24
    38d8:	69 e3       	ldi	r22, 0x39	; 57
    38da:	76 e0       	ldi	r23, 0x06	; 6
    38dc:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    38e0:	66 e0       	ldi	r22, 0x06	; 6
    38e2:	c8 01       	movw	r24, r16
    38e4:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    38e8:	6a e0       	ldi	r22, 0x0A	; 10
    38ea:	ce 01       	movw	r24, r28
    38ec:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    38f0:	8c 01       	movw	r16, r24
    38f2:	68 e2       	ldi	r22, 0x28	; 40
    38f4:	76 e0       	ldi	r23, 0x06	; 6
    38f6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    38fa:	6a e0       	ldi	r22, 0x0A	; 10
    38fc:	c8 01       	movw	r24, r16
    38fe:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3902:	8c 01       	movw	r16, r24
    3904:	6c e1       	ldi	r22, 0x1C	; 28
    3906:	76 e0       	ldi	r23, 0x06	; 6
    3908:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    390c:	6a e0       	ldi	r22, 0x0A	; 10
    390e:	c8 01       	movw	r24, r16
    3910:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3914:	8c 01       	movw	r16, r24
    3916:	66 e1       	ldi	r22, 0x16	; 22
    3918:	76 e0       	ldi	r23, 0x06	; 6
    391a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    391e:	66 e0       	ldi	r22, 0x06	; 6
    3920:	c8 01       	movw	r24, r16
    3922:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3926:	6a e0       	ldi	r22, 0x0A	; 10
    3928:	ce 01       	movw	r24, r28
    392a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    392e:	8c 01       	movw	r16, r24
    3930:	65 e0       	ldi	r22, 0x05	; 5
    3932:	76 e0       	ldi	r23, 0x06	; 6
    3934:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3938:	6a e0       	ldi	r22, 0x0A	; 10
    393a:	c8 01       	movw	r24, r16
    393c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3940:	8c 01       	movw	r16, r24
    3942:	69 ef       	ldi	r22, 0xF9	; 249
    3944:	75 e0       	ldi	r23, 0x05	; 5
    3946:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    394a:	6a e0       	ldi	r22, 0x0A	; 10
    394c:	c8 01       	movw	r24, r16
    394e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3952:	8c 01       	movw	r16, r24
    3954:	63 ef       	ldi	r22, 0xF3	; 243
    3956:	75 e0       	ldi	r23, 0x05	; 5
    3958:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    395c:	66 e0       	ldi	r22, 0x06	; 6
    395e:	c8 01       	movw	r24, r16
    3960:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3964:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <last_created_task_pointer>
    3968:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <last_created_task_pointer+0x1>
    396c:	00 97       	sbiw	r24, 0x00	; 0
    396e:	19 f0       	breq	.+6      	; 0x3976 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3970:	be 01       	movw	r22, r28
    3972:	0e 94 41 1c 	call	0x3882	; 0x3882 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3976:	0e 94 94 16 	call	0x2d28	; 0x2d28 <xTaskGetIdleTaskHandle>
    397a:	0e 94 92 19 	call	0x3324	; 0x3324 <uxTaskGetStackHighWaterMark>
    397e:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3980:	6a e0       	ldi	r22, 0x0A	; 10
    3982:	ce 01       	movw	r24, r28
    3984:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3988:	ec 01       	movw	r28, r24
    398a:	68 ee       	ldi	r22, 0xE8	; 232
    398c:	75 e0       	ldi	r23, 0x05	; 5
    398e:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3992:	61 2f       	mov	r22, r17
    3994:	ce 01       	movw	r24, r28
    3996:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    399a:	6a e0       	ldi	r22, 0x0A	; 10
    399c:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    39a0:	ec 01       	movw	r28, r24
    39a2:	66 ee       	ldi	r22, 0xE6	; 230
    39a4:	75 e0       	ldi	r23, 0x05	; 5
    39a6:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    39aa:	64 e6       	ldi	r22, 0x64	; 100
    39ac:	70 e0       	ldi	r23, 0x00	; 0
    39ae:	ce 01       	movw	r24, r28
    39b0:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    39b4:	6a e0       	ldi	r22, 0x0A	; 10
    39b6:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    39ba:	ec 01       	movw	r28, r24
    39bc:	63 ee       	ldi	r22, 0xE3	; 227
    39be:	75 e0       	ldi	r23, 0x05	; 5
    39c0:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    39c4:	66 e0       	ldi	r22, 0x06	; 6
    39c6:	ce 01       	movw	r24, r28
    39c8:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
}
    39cc:	df 91       	pop	r29
    39ce:	cf 91       	pop	r28
    39d0:	1f 91       	pop	r17
    39d2:	0f 91       	pop	r16
    39d4:	08 95       	ret

000039d6 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    39d6:	0f 93       	push	r16
    39d8:	cf 93       	push	r28
    39da:	df 93       	push	r29
    39dc:	1f 92       	push	r1
    39de:	cd b7       	in	r28, 0x3d	; 61
    39e0:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    39e2:	00 e0       	ldi	r16, 0x00	; 0
    39e4:	2f ef       	ldi	r18, 0xFF	; 255
    39e6:	3f ef       	ldi	r19, 0xFF	; 255
    39e8:	a9 01       	movw	r20, r18
    39ea:	be 01       	movw	r22, r28
    39ec:	6f 5f       	subi	r22, 0xFF	; 255
    39ee:	7f 4f       	sbci	r23, 0xFF	; 255
    39f0:	fc 01       	movw	r30, r24
    39f2:	80 85       	ldd	r24, Z+8	; 0x08
    39f4:	91 85       	ldd	r25, Z+9	; 0x09
    39f6:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
    39fa:	81 30       	cpi	r24, 0x01	; 1
    39fc:	19 f4       	brne	.+6      	; 0x3a04 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    39fe:	89 81       	ldd	r24, Y+1	; 0x01
    3a00:	90 e0       	ldi	r25, 0x00	; 0
    3a02:	02 c0       	rjmp	.+4      	; 0x3a08 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3a04:	8f ef       	ldi	r24, 0xFF	; 255
    3a06:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3a08:	0f 90       	pop	r0
    3a0a:	df 91       	pop	r29
    3a0c:	cf 91       	pop	r28
    3a0e:	0f 91       	pop	r16
    3a10:	08 95       	ret

00003a12 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3a12:	fc 01       	movw	r30, r24
    3a14:	80 85       	ldd	r24, Z+8	; 0x08
    3a16:	91 85       	ldd	r25, Z+9	; 0x09
    3a18:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    3a1c:	91 e0       	ldi	r25, 0x01	; 1
    3a1e:	81 11       	cpse	r24, r1
    3a20:	01 c0       	rjmp	.+2      	; 0x3a24 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3a22:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3a24:	89 2f       	mov	r24, r25
    3a26:	08 95       	ret

00003a28 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3a28:	0f 93       	push	r16
    3a2a:	cf 93       	push	r28
    3a2c:	df 93       	push	r29
    3a2e:	1f 92       	push	r1
    3a30:	cd b7       	in	r28, 0x3d	; 61
    3a32:	de b7       	in	r29, 0x3e	; 62
    3a34:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3a36:	fc 01       	movw	r30, r24
    3a38:	22 85       	ldd	r18, Z+10	; 0x0a
    3a3a:	33 85       	ldd	r19, Z+11	; 0x0b
    3a3c:	44 85       	ldd	r20, Z+12	; 0x0c
    3a3e:	55 85       	ldd	r21, Z+13	; 0x0d
    3a40:	00 e0       	ldi	r16, 0x00	; 0
    3a42:	be 01       	movw	r22, r28
    3a44:	6f 5f       	subi	r22, 0xFF	; 255
    3a46:	7f 4f       	sbci	r23, 0xFF	; 255
    3a48:	80 85       	ldd	r24, Z+8	; 0x08
    3a4a:	91 85       	ldd	r25, Z+9	; 0x09
    3a4c:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    3a50:	91 e0       	ldi	r25, 0x01	; 1
    3a52:	81 11       	cpse	r24, r1
    3a54:	01 c0       	rjmp	.+2      	; 0x3a58 <_ZN14frt_text_queue7putcharEc+0x30>
    3a56:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3a58:	89 2f       	mov	r24, r25
    3a5a:	0f 90       	pop	r0
    3a5c:	df 91       	pop	r29
    3a5e:	cf 91       	pop	r28
    3a60:	0f 91       	pop	r16
    3a62:	08 95       	ret

00003a64 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3a64:	8f 92       	push	r8
    3a66:	9f 92       	push	r9
    3a68:	bf 92       	push	r11
    3a6a:	cf 92       	push	r12
    3a6c:	df 92       	push	r13
    3a6e:	ef 92       	push	r14
    3a70:	ff 92       	push	r15
    3a72:	0f 93       	push	r16
    3a74:	1f 93       	push	r17
    3a76:	cf 93       	push	r28
    3a78:	df 93       	push	r29
    3a7a:	ec 01       	movw	r28, r24
    3a7c:	b6 2e       	mov	r11, r22
    3a7e:	4a 01       	movw	r8, r20
    3a80:	68 01       	movw	r12, r16
    3a82:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3a84:	0e 94 6c 1f 	call	0x3ed8	; 0x3ed8 <_ZN8emstreamC1Ev>
    3a88:	81 e9       	ldi	r24, 0x91	; 145
    3a8a:	91 e2       	ldi	r25, 0x21	; 33
    3a8c:	88 83       	st	Y, r24
    3a8e:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3a90:	8e 86       	std	Y+14, r8	; 0x0e
    3a92:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3a94:	40 e0       	ldi	r20, 0x00	; 0
    3a96:	61 e0       	ldi	r22, 0x01	; 1
    3a98:	8b 2d       	mov	r24, r11
    3a9a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    3a9e:	88 87       	std	Y+8, r24	; 0x08
    3aa0:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3aa2:	ca 86       	std	Y+10, r12	; 0x0a
    3aa4:	db 86       	std	Y+11, r13	; 0x0b
    3aa6:	ec 86       	std	Y+12, r14	; 0x0c
    3aa8:	fd 86       	std	Y+13, r15	; 0x0d
}
    3aaa:	df 91       	pop	r29
    3aac:	cf 91       	pop	r28
    3aae:	1f 91       	pop	r17
    3ab0:	0f 91       	pop	r16
    3ab2:	ff 90       	pop	r15
    3ab4:	ef 90       	pop	r14
    3ab6:	df 90       	pop	r13
    3ab8:	cf 90       	pop	r12
    3aba:	bf 90       	pop	r11
    3abc:	9f 90       	pop	r9
    3abe:	8f 90       	pop	r8
    3ac0:	08 95       	ret

00003ac2 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3ac2:	cf 92       	push	r12
    3ac4:	df 92       	push	r13
    3ac6:	ef 92       	push	r14
    3ac8:	ff 92       	push	r15
    3aca:	cf 93       	push	r28
    3acc:	df 93       	push	r29
    3ace:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3ad0:	68 81       	ld	r22, Y
    3ad2:	79 81       	ldd	r23, Y+1	; 0x01
    3ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ad6:	9b 81       	ldd	r25, Y+3	; 0x03
    3ad8:	0f 2e       	mov	r0, r31
    3ada:	f8 ee       	ldi	r31, 0xE8	; 232
    3adc:	cf 2e       	mov	r12, r31
    3ade:	f3 e0       	ldi	r31, 0x03	; 3
    3ae0:	df 2e       	mov	r13, r31
    3ae2:	e1 2c       	mov	r14, r1
    3ae4:	f1 2c       	mov	r15, r1
    3ae6:	f0 2d       	mov	r31, r0
    3ae8:	a7 01       	movw	r20, r14
    3aea:	96 01       	movw	r18, r12
    3aec:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
    3af0:	9b 01       	movw	r18, r22
    3af2:	ac 01       	movw	r20, r24
    3af4:	60 e4       	ldi	r22, 0x40	; 64
    3af6:	72 e4       	ldi	r23, 0x42	; 66
    3af8:	8f e0       	ldi	r24, 0x0F	; 15
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	0e 94 04 27 	call	0x4e08	; 0x4e08 <__mulsi3>
    3b00:	a7 01       	movw	r20, r14
    3b02:	96 01       	movw	r18, r12
    3b04:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
    3b08:	69 01       	movw	r12, r18
    3b0a:	7a 01       	movw	r14, r20
    3b0c:	ac 81       	ldd	r26, Y+4	; 0x04
    3b0e:	bd 81       	ldd	r27, Y+5	; 0x05
    3b10:	20 e4       	ldi	r18, 0x40	; 64
    3b12:	32 e4       	ldi	r19, 0x42	; 66
    3b14:	4f e0       	ldi	r20, 0x0F	; 15
    3b16:	50 e0       	ldi	r21, 0x00	; 0
    3b18:	0e 94 5e 27 	call	0x4ebc	; 0x4ebc <__muluhisi3>
    3b1c:	20 e0       	ldi	r18, 0x00	; 0
    3b1e:	38 e4       	ldi	r19, 0x48	; 72
    3b20:	48 ee       	ldi	r20, 0xE8	; 232
    3b22:	51 e0       	ldi	r21, 0x01	; 1
    3b24:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
    3b28:	c7 01       	movw	r24, r14
    3b2a:	b6 01       	movw	r22, r12
    3b2c:	62 0f       	add	r22, r18
    3b2e:	73 1f       	adc	r23, r19
    3b30:	84 1f       	adc	r24, r20
    3b32:	95 1f       	adc	r25, r21
}
    3b34:	df 91       	pop	r29
    3b36:	cf 91       	pop	r28
    3b38:	ff 90       	pop	r15
    3b3a:	ef 90       	pop	r14
    3b3c:	df 90       	pop	r13
    3b3e:	cf 90       	pop	r12
    3b40:	08 95       	ret

00003b42 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3b42:	cf 92       	push	r12
    3b44:	df 92       	push	r13
    3b46:	ef 92       	push	r14
    3b48:	ff 92       	push	r15
    3b4a:	0f 93       	push	r16
    3b4c:	1f 93       	push	r17
    3b4e:	cf 93       	push	r28
    3b50:	df 93       	push	r29
    3b52:	cd b7       	in	r28, 0x3d	; 61
    3b54:	de b7       	in	r29, 0x3e	; 62
    3b56:	2f 97       	sbiw	r28, 0x0f	; 15
    3b58:	cd bf       	out	0x3d, r28	; 61
    3b5a:	de bf       	out	0x3e, r29	; 62
    3b5c:	6c 01       	movw	r12, r24
    3b5e:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3b60:	db 01       	movw	r26, r22
    3b62:	6d 91       	ld	r22, X+
    3b64:	7d 91       	ld	r23, X+
    3b66:	8d 91       	ld	r24, X+
    3b68:	9c 91       	ld	r25, X
    3b6a:	28 ee       	ldi	r18, 0xE8	; 232
    3b6c:	33 e0       	ldi	r19, 0x03	; 3
    3b6e:	40 e0       	ldi	r20, 0x00	; 0
    3b70:	50 e0       	ldi	r21, 0x00	; 0
    3b72:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
    3b76:	ba 01       	movw	r22, r20
    3b78:	a9 01       	movw	r20, r18
    3b7a:	c6 01       	movw	r24, r12
    3b7c:	0e 94 69 20 	call	0x40d2	; 0x40d2 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3b80:	d6 01       	movw	r26, r12
    3b82:	ed 91       	ld	r30, X+
    3b84:	fc 91       	ld	r31, X
    3b86:	02 80       	ldd	r0, Z+2	; 0x02
    3b88:	f3 81       	ldd	r31, Z+3	; 0x03
    3b8a:	e0 2d       	mov	r30, r0
    3b8c:	6e e2       	ldi	r22, 0x2E	; 46
    3b8e:	c6 01       	movw	r24, r12
    3b90:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3b92:	c8 01       	movw	r24, r16
    3b94:	0e 94 61 1d 	call	0x3ac2	; 0x3ac2 <_ZN10time_stamp12get_microsecEv>
    3b98:	8e 01       	movw	r16, r28
    3b9a:	09 5f       	subi	r16, 0xF9	; 249
    3b9c:	1f 4f       	sbci	r17, 0xFF	; 255
    3b9e:	fe 01       	movw	r30, r28
    3ba0:	31 96       	adiw	r30, 0x01	; 1
    3ba2:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3ba4:	2a e0       	ldi	r18, 0x0A	; 10
    3ba6:	30 e0       	ldi	r19, 0x00	; 0
    3ba8:	40 e0       	ldi	r20, 0x00	; 0
    3baa:	50 e0       	ldi	r21, 0x00	; 0
    3bac:	0e 94 36 27 	call	0x4e6c	; 0x4e6c <__divmodsi4>
    3bb0:	e6 2f       	mov	r30, r22
    3bb2:	28 87       	std	Y+8, r18	; 0x08
    3bb4:	39 87       	std	Y+9, r19	; 0x09
    3bb6:	4a 87       	std	Y+10, r20	; 0x0a
    3bb8:	5b 87       	std	Y+11, r21	; 0x0b
    3bba:	68 85       	ldd	r22, Y+8	; 0x08
    3bbc:	79 85       	ldd	r23, Y+9	; 0x09
    3bbe:	8a 85       	ldd	r24, Y+10	; 0x0a
    3bc0:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3bc2:	20 e3       	ldi	r18, 0x30	; 48
    3bc4:	2e 0f       	add	r18, r30
    3bc6:	d8 01       	movw	r26, r16
    3bc8:	2e 93       	st	-X, r18
    3bca:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3bcc:	ae 15       	cp	r26, r14
    3bce:	bf 05       	cpc	r27, r15
    3bd0:	49 f7       	brne	.-46     	; 0x3ba4 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3bd2:	1f 82       	std	Y+7, r1	; 0x07
    3bd4:	be 01       	movw	r22, r28
    3bd6:	6f 5f       	subi	r22, 0xFF	; 255
    3bd8:	7f 4f       	sbci	r23, 0xFF	; 255
    3bda:	c6 01       	movw	r24, r12
    3bdc:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3be0:	c6 01       	movw	r24, r12
    3be2:	2f 96       	adiw	r28, 0x0f	; 15
    3be4:	cd bf       	out	0x3d, r28	; 61
    3be6:	de bf       	out	0x3e, r29	; 62
    3be8:	df 91       	pop	r29
    3bea:	cf 91       	pop	r28
    3bec:	1f 91       	pop	r17
    3bee:	0f 91       	pop	r16
    3bf0:	ff 90       	pop	r15
    3bf2:	ef 90       	pop	r14
    3bf4:	df 90       	pop	r13
    3bf6:	cf 90       	pop	r12
    3bf8:	08 95       	ret

00003bfa <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3bfa:	cf 93       	push	r28
    3bfc:	df 93       	push	r29
    3bfe:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3c00:	0f b6       	in	r0, 0x3f	; 63
    3c02:	f8 94       	cli
    3c04:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3c06:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3c0a:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3c0e:	8c 83       	std	Y+4, r24	; 0x04
    3c10:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3c12:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskGetTickCount>
    3c16:	68 83       	st	Y, r22
    3c18:	79 83       	std	Y+1, r23	; 0x01
    3c1a:	8a 83       	std	Y+2, r24	; 0x02
    3c1c:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3c1e:	0f 90       	pop	r0
    3c20:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3c22:	ce 01       	movw	r24, r28
    3c24:	df 91       	pop	r29
    3c26:	cf 91       	pop	r28
    3c28:	08 95       	ret

00003c2a <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3c2a:	5f 92       	push	r5
    3c2c:	6f 92       	push	r6
    3c2e:	7f 92       	push	r7
    3c30:	8f 92       	push	r8
    3c32:	9f 92       	push	r9
    3c34:	af 92       	push	r10
    3c36:	bf 92       	push	r11
    3c38:	cf 92       	push	r12
    3c3a:	df 92       	push	r13
    3c3c:	ef 92       	push	r14
    3c3e:	ff 92       	push	r15
    3c40:	0f 93       	push	r16
    3c42:	1f 93       	push	r17
    3c44:	cf 93       	push	r28
    3c46:	df 93       	push	r29
    3c48:	5c 01       	movw	r10, r24
    3c4a:	4b 01       	movw	r8, r22
    3c4c:	7a 01       	movw	r14, r20
    3c4e:	12 2f       	mov	r17, r18
    3c50:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3c52:	63 e0       	ldi	r22, 0x03	; 3
    3c54:	ca 01       	movw	r24, r20
    3c56:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3c5a:	a8 14       	cp	r10, r8
    3c5c:	b9 04       	cpc	r11, r9
    3c5e:	08 f0       	brcs	.+2      	; 0x3c62 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3c60:	7d c0       	rjmp	.+250    	; 0x3d5c <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3c62:	65 01       	movw	r12, r10
    3c64:	84 e1       	ldi	r24, 0x14	; 20
    3c66:	c8 0e       	add	r12, r24
    3c68:	d1 1c       	adc	r13, r1
    3c6a:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3c6c:	6a 2c       	mov	r6, r10
    3c6e:	5b 2c       	mov	r5, r11
    3c70:	b5 01       	movw	r22, r10
    3c72:	c7 01       	movw	r24, r14
    3c74:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    3c78:	6a e0       	ldi	r22, 0x0A	; 10
    3c7a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3c7e:	65 e6       	ldi	r22, 0x65	; 101
    3c80:	76 e0       	ldi	r23, 0x06	; 6
    3c82:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3c86:	11 23       	and	r17, r17
    3c88:	09 f4       	brne	.+2      	; 0x3c8c <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3c8a:	6d c0       	rjmp	.+218    	; 0x3d66 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3c8c:	00 23       	and	r16, r16
    3c8e:	09 f4       	brne	.+2      	; 0x3c92 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3c90:	6a c0       	rjmp	.+212    	; 0x3d66 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3c92:	6a e0       	ldi	r22, 0x0A	; 10
    3c94:	c7 01       	movw	r24, r14
    3c96:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3c9a:	60 e6       	ldi	r22, 0x60	; 96
    3c9c:	76 e0       	ldi	r23, 0x06	; 6
    3c9e:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    3ca2:	61 c0       	rjmp	.+194    	; 0x3d66 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3ca4:	11 23       	and	r17, r17
    3ca6:	71 f0       	breq	.+28     	; 0x3cc4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3ca8:	01 11       	cpse	r16, r1
    3caa:	0c c0       	rjmp	.+24     	; 0x3cc4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3cac:	88 81       	ld	r24, Y
    3cae:	87 15       	cp	r24, r7
    3cb0:	49 f0       	breq	.+18     	; 0x3cc4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3cb2:	6a e0       	ldi	r22, 0x0A	; 10
    3cb4:	c7 01       	movw	r24, r14
    3cb6:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3cba:	6b e5       	ldi	r22, 0x5B	; 91
    3cbc:	76 e0       	ldi	r23, 0x06	; 6
    3cbe:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3cc2:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3cc4:	69 91       	ld	r22, Y+
    3cc6:	c7 01       	movw	r24, r14
    3cc8:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3ccc:	dc 01       	movw	r26, r24
    3cce:	ed 91       	ld	r30, X+
    3cd0:	fc 91       	ld	r31, X
    3cd2:	02 80       	ldd	r0, Z+2	; 0x02
    3cd4:	f3 81       	ldd	r31, Z+3	; 0x03
    3cd6:	e0 2d       	mov	r30, r0
    3cd8:	60 e2       	ldi	r22, 0x20	; 32
    3cda:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3cdc:	cc 16       	cp	r12, r28
    3cde:	dd 06       	cpc	r13, r29
    3ce0:	09 f7       	brne	.-62     	; 0x3ca4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3ce2:	11 23       	and	r17, r17
    3ce4:	89 f0       	breq	.+34     	; 0x3d08 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3ce6:	6a e0       	ldi	r22, 0x0A	; 10
    3ce8:	c7 01       	movw	r24, r14
    3cea:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3cee:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cf0:	65 e5       	ldi	r22, 0x55	; 85
    3cf2:	76 e0       	ldi	r23, 0x06	; 6
    3cf4:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3cf8:	e8 81       	ld	r30, Y
    3cfa:	f9 81       	ldd	r31, Y+1	; 0x01
    3cfc:	02 80       	ldd	r0, Z+2	; 0x02
    3cfe:	f3 81       	ldd	r31, Z+3	; 0x03
    3d00:	e0 2d       	mov	r30, r0
    3d02:	60 e2       	ldi	r22, 0x20	; 32
    3d04:	ce 01       	movw	r24, r28
    3d06:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3d08:	c6 2d       	mov	r28, r6
    3d0a:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3d0c:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3d0e:	80 ee       	ldi	r24, 0xE0	; 224
    3d10:	86 0f       	add	r24, r22
    3d12:	8f 35       	cpi	r24, 0x5F	; 95
    3d14:	48 f4       	brcc	.+18     	; 0x3d28 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3d16:	d7 01       	movw	r26, r14
    3d18:	ed 91       	ld	r30, X+
    3d1a:	fc 91       	ld	r31, X
    3d1c:	02 80       	ldd	r0, Z+2	; 0x02
    3d1e:	f3 81       	ldd	r31, Z+3	; 0x03
    3d20:	e0 2d       	mov	r30, r0
    3d22:	c7 01       	movw	r24, r14
    3d24:	19 95       	eicall
    3d26:	09 c0       	rjmp	.+18     	; 0x3d3a <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3d28:	d7 01       	movw	r26, r14
    3d2a:	ed 91       	ld	r30, X+
    3d2c:	fc 91       	ld	r31, X
    3d2e:	02 80       	ldd	r0, Z+2	; 0x02
    3d30:	f3 81       	ldd	r31, Z+3	; 0x03
    3d32:	e0 2d       	mov	r30, r0
    3d34:	6e e2       	ldi	r22, 0x2E	; 46
    3d36:	c7 01       	movw	r24, r14
    3d38:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3d3a:	cc 16       	cp	r12, r28
    3d3c:	dd 06       	cpc	r13, r29
    3d3e:	31 f7       	brne	.-52     	; 0x3d0c <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3d40:	b4 e1       	ldi	r27, 0x14	; 20
    3d42:	ab 0e       	add	r10, r27
    3d44:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3d46:	66 e0       	ldi	r22, 0x06	; 6
    3d48:	c7 01       	movw	r24, r14
    3d4a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    3d4e:	84 e1       	ldi	r24, 0x14	; 20
    3d50:	c8 0e       	add	r12, r24
    3d52:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3d54:	a8 14       	cp	r10, r8
    3d56:	b9 04       	cpc	r11, r9
    3d58:	08 f4       	brcc	.+2      	; 0x3d5c <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3d5a:	88 cf       	rjmp	.-240    	; 0x3c6c <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3d5c:	62 e0       	ldi	r22, 0x02	; 2
    3d5e:	c7 01       	movw	r24, r14
    3d60:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
}
    3d64:	03 c0       	rjmp	.+6      	; 0x3d6c <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3d66:	c6 2d       	mov	r28, r6
    3d68:	d5 2d       	mov	r29, r5
    3d6a:	9c cf       	rjmp	.-200    	; 0x3ca4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3d6c:	df 91       	pop	r29
    3d6e:	cf 91       	pop	r28
    3d70:	1f 91       	pop	r17
    3d72:	0f 91       	pop	r16
    3d74:	ff 90       	pop	r15
    3d76:	ef 90       	pop	r14
    3d78:	df 90       	pop	r13
    3d7a:	cf 90       	pop	r12
    3d7c:	bf 90       	pop	r11
    3d7e:	af 90       	pop	r10
    3d80:	9f 90       	pop	r9
    3d82:	8f 90       	pop	r8
    3d84:	7f 90       	pop	r7
    3d86:	6f 90       	pop	r6
    3d88:	5f 90       	pop	r5
    3d8a:	08 95       	ret

00003d8c <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3d8c:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    3d90:	08 95       	ret

00003d92 <_Znaj>:
    3d92:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <pvPortMalloc>
    3d96:	08 95       	ret

00003d98 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3d98:	08 95       	ret

00003d9a <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3d9a:	cf 93       	push	r28
    3d9c:	df 93       	push	r29
    3d9e:	fc 01       	movw	r30, r24
    3da0:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3da2:	40 3a       	cpi	r20, 0xA0	; 160
    3da4:	68 e0       	ldi	r22, 0x08	; 8
    3da6:	56 07       	cpc	r21, r22
    3da8:	49 f4       	brne	.+18     	; 0x3dbc <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3daa:	80 e4       	ldi	r24, 0x40	; 64
    3dac:	96 e0       	ldi	r25, 0x06	; 6
    3dae:	82 83       	std	Z+2, r24	; 0x02
    3db0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3db2:	82 e0       	ldi	r24, 0x02	; 2
    3db4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3db6:	83 e0       	ldi	r24, 0x03	; 3
    3db8:	85 83       	std	Z+5, r24	; 0x05
    3dba:	32 c0       	rjmp	.+100    	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3dbc:	40 3b       	cpi	r20, 0xB0	; 176
    3dbe:	78 e0       	ldi	r23, 0x08	; 8
    3dc0:	57 07       	cpc	r21, r23
    3dc2:	49 f4       	brne	.+18     	; 0x3dd6 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3dc4:	80 e4       	ldi	r24, 0x40	; 64
    3dc6:	96 e0       	ldi	r25, 0x06	; 6
    3dc8:	82 83       	std	Z+2, r24	; 0x02
    3dca:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3dcc:	86 e0       	ldi	r24, 0x06	; 6
    3dce:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3dd0:	87 e0       	ldi	r24, 0x07	; 7
    3dd2:	85 83       	std	Z+5, r24	; 0x05
    3dd4:	25 c0       	rjmp	.+74     	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3dd6:	40 3a       	cpi	r20, 0xA0	; 160
    3dd8:	89 e0       	ldi	r24, 0x09	; 9
    3dda:	58 07       	cpc	r21, r24
    3ddc:	49 f4       	brne	.+18     	; 0x3df0 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3dde:	80 e6       	ldi	r24, 0x60	; 96
    3de0:	96 e0       	ldi	r25, 0x06	; 6
    3de2:	82 83       	std	Z+2, r24	; 0x02
    3de4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3de6:	82 e0       	ldi	r24, 0x02	; 2
    3de8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3dea:	83 e0       	ldi	r24, 0x03	; 3
    3dec:	85 83       	std	Z+5, r24	; 0x05
    3dee:	18 c0       	rjmp	.+48     	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3df0:	40 3b       	cpi	r20, 0xB0	; 176
    3df2:	69 e0       	ldi	r22, 0x09	; 9
    3df4:	56 07       	cpc	r21, r22
    3df6:	49 f4       	brne	.+18     	; 0x3e0a <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3df8:	80 e6       	ldi	r24, 0x60	; 96
    3dfa:	96 e0       	ldi	r25, 0x06	; 6
    3dfc:	82 83       	std	Z+2, r24	; 0x02
    3dfe:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3e00:	86 e0       	ldi	r24, 0x06	; 6
    3e02:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3e04:	87 e0       	ldi	r24, 0x07	; 7
    3e06:	85 83       	std	Z+5, r24	; 0x05
    3e08:	0b c0       	rjmp	.+22     	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3e0a:	40 3a       	cpi	r20, 0xA0	; 160
    3e0c:	5a 40       	sbci	r21, 0x0A	; 10
    3e0e:	41 f4       	brne	.+16     	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3e10:	80 e8       	ldi	r24, 0x80	; 128
    3e12:	96 e0       	ldi	r25, 0x06	; 6
    3e14:	82 83       	std	Z+2, r24	; 0x02
    3e16:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3e18:	82 e0       	ldi	r24, 0x02	; 2
    3e1a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3e1c:	83 e0       	ldi	r24, 0x03	; 3
    3e1e:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3e20:	a6 83       	std	Z+6, r26	; 0x06
    3e22:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3e24:	cd 01       	movw	r24, r26
    3e26:	01 96       	adiw	r24, 0x01	; 1
    3e28:	80 87       	std	Z+8, r24	; 0x08
    3e2a:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3e2c:	03 96       	adiw	r24, 0x03	; 3
    3e2e:	82 87       	std	Z+10, r24	; 0x0a
    3e30:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3e32:	25 81       	ldd	r18, Z+5	; 0x05
    3e34:	c2 81       	ldd	r28, Z+2	; 0x02
    3e36:	d3 81       	ldd	r29, Z+3	; 0x03
    3e38:	4c 81       	ldd	r20, Y+4	; 0x04
    3e3a:	81 e0       	ldi	r24, 0x01	; 1
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
    3e3e:	bc 01       	movw	r22, r24
    3e40:	02 c0       	rjmp	.+4      	; 0x3e46 <_ZN7base232C1EjP12USART_struct+0xac>
    3e42:	66 0f       	add	r22, r22
    3e44:	77 1f       	adc	r23, r23
    3e46:	2a 95       	dec	r18
    3e48:	e2 f7       	brpl	.-8      	; 0x3e42 <_ZN7base232C1EjP12USART_struct+0xa8>
    3e4a:	9b 01       	movw	r18, r22
    3e4c:	24 2b       	or	r18, r20
    3e4e:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3e50:	25 81       	ldd	r18, Z+5	; 0x05
    3e52:	c2 81       	ldd	r28, Z+2	; 0x02
    3e54:	d3 81       	ldd	r29, Z+3	; 0x03
    3e56:	48 81       	ld	r20, Y
    3e58:	bc 01       	movw	r22, r24
    3e5a:	02 c0       	rjmp	.+4      	; 0x3e60 <_ZN7base232C1EjP12USART_struct+0xc6>
    3e5c:	66 0f       	add	r22, r22
    3e5e:	77 1f       	adc	r23, r23
    3e60:	2a 95       	dec	r18
    3e62:	e2 f7       	brpl	.-8      	; 0x3e5c <_ZN7base232C1EjP12USART_struct+0xc2>
    3e64:	9b 01       	movw	r18, r22
    3e66:	24 2b       	or	r18, r20
    3e68:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3e6a:	34 81       	ldd	r19, Z+4	; 0x04
    3e6c:	c2 81       	ldd	r28, Z+2	; 0x02
    3e6e:	d3 81       	ldd	r29, Z+3	; 0x03
    3e70:	28 81       	ld	r18, Y
    3e72:	02 c0       	rjmp	.+4      	; 0x3e78 <_ZN7base232C1EjP12USART_struct+0xde>
    3e74:	88 0f       	add	r24, r24
    3e76:	99 1f       	adc	r25, r25
    3e78:	3a 95       	dec	r19
    3e7a:	e2 f7       	brpl	.-8      	; 0x3e74 <_ZN7base232C1EjP12USART_struct+0xda>
    3e7c:	80 95       	com	r24
    3e7e:	90 95       	com	r25
    3e80:	82 23       	and	r24, r18
    3e82:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3e84:	80 e1       	ldi	r24, 0x10	; 16
    3e86:	13 96       	adiw	r26, 0x03	; 3
    3e88:	8c 93       	st	X, r24
    3e8a:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3e8c:	83 e0       	ldi	r24, 0x03	; 3
    3e8e:	15 96       	adiw	r26, 0x05	; 5
    3e90:	8c 93       	st	X, r24
    3e92:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3e94:	80 ef       	ldi	r24, 0xF0	; 240
    3e96:	17 96       	adiw	r26, 0x07	; 7
    3e98:	8c 93       	st	X, r24
    3e9a:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3e9c:	81 e2       	ldi	r24, 0x21	; 33
    3e9e:	16 96       	adiw	r26, 0x06	; 6
    3ea0:	8c 93       	st	X, r24
    3ea2:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3ea4:	88 e1       	ldi	r24, 0x18	; 24
    3ea6:	14 96       	adiw	r26, 0x04	; 4
    3ea8:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3eaa:	80 e8       	ldi	r24, 0x80	; 128
    3eac:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3eae:	80 e4       	ldi	r24, 0x40	; 64
    3eb0:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3eb2:	80 e2       	ldi	r24, 0x20	; 32
    3eb4:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3eb6:	06 80       	ldd	r0, Z+6	; 0x06
    3eb8:	f7 81       	ldd	r31, Z+7	; 0x07
    3eba:	e0 2d       	mov	r30, r0
    3ebc:	80 81       	ld	r24, Z
    3ebe:	80 81       	ld	r24, Z
}
    3ec0:	df 91       	pop	r29
    3ec2:	cf 91       	pop	r28
    3ec4:	08 95       	ret

00003ec6 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3ec6:	81 e0       	ldi	r24, 0x01	; 1
    3ec8:	08 95       	ret

00003eca <_ZN8emstream7getcharEv>:
    3eca:	80 e0       	ldi	r24, 0x00	; 0
    3ecc:	90 e0       	ldi	r25, 0x00	; 0
    3ece:	08 95       	ret

00003ed0 <_ZN8emstream14check_for_charEv>:
    3ed0:	80 e0       	ldi	r24, 0x00	; 0
    3ed2:	08 95       	ret

00003ed4 <_ZN8emstream12transmit_nowEv>:
    3ed4:	08 95       	ret

00003ed6 <_ZN8emstream12clear_screenEv>:
    3ed6:	08 95       	ret

00003ed8 <_ZN8emstreamC1Ev>:
    3ed8:	fc 01       	movw	r30, r24
    3eda:	81 ea       	ldi	r24, 0xA1	; 161
    3edc:	91 e2       	ldi	r25, 0x21	; 33
    3ede:	80 83       	st	Z, r24
    3ee0:	91 83       	std	Z+1, r25	; 0x01
    3ee2:	8a e0       	ldi	r24, 0x0A	; 10
    3ee4:	82 83       	std	Z+2, r24	; 0x02
    3ee6:	13 82       	std	Z+3, r1	; 0x03
    3ee8:	83 e0       	ldi	r24, 0x03	; 3
    3eea:	85 83       	std	Z+5, r24	; 0x05
    3eec:	14 82       	std	Z+4, r1	; 0x04
    3eee:	16 82       	std	Z+6, r1	; 0x06
    3ef0:	17 82       	std	Z+7, r1	; 0x07
    3ef2:	08 95       	ret

00003ef4 <_ZN8emstream4putsEPKc>:
    3ef4:	0f 93       	push	r16
    3ef6:	1f 93       	push	r17
    3ef8:	cf 93       	push	r28
    3efa:	df 93       	push	r29
    3efc:	8c 01       	movw	r16, r24
    3efe:	fb 01       	movw	r30, r22
    3f00:	dc 01       	movw	r26, r24
    3f02:	14 96       	adiw	r26, 0x04	; 4
    3f04:	8c 91       	ld	r24, X
    3f06:	81 11       	cpse	r24, r1
    3f08:	04 c0       	rjmp	.+8      	; 0x3f12 <_ZN8emstream4putsEPKc+0x1e>
    3f0a:	60 81       	ld	r22, Z
    3f0c:	61 11       	cpse	r22, r1
    3f0e:	17 c0       	rjmp	.+46     	; 0x3f3e <_ZN8emstream4putsEPKc+0x4a>
    3f10:	23 c0       	rjmp	.+70     	; 0x3f58 <_ZN8emstream4putsEPKc+0x64>
    3f12:	d8 01       	movw	r26, r16
    3f14:	14 96       	adiw	r26, 0x04	; 4
    3f16:	1c 92       	st	X, r1
    3f18:	eb 01       	movw	r28, r22
    3f1a:	21 96       	adiw	r28, 0x01	; 1
    3f1c:	64 91       	lpm	r22, Z
    3f1e:	66 23       	and	r22, r22
    3f20:	d9 f0       	breq	.+54     	; 0x3f58 <_ZN8emstream4putsEPKc+0x64>
    3f22:	d8 01       	movw	r26, r16
    3f24:	ed 91       	ld	r30, X+
    3f26:	fc 91       	ld	r31, X
    3f28:	02 80       	ldd	r0, Z+2	; 0x02
    3f2a:	f3 81       	ldd	r31, Z+3	; 0x03
    3f2c:	e0 2d       	mov	r30, r0
    3f2e:	c8 01       	movw	r24, r16
    3f30:	19 95       	eicall
    3f32:	fe 01       	movw	r30, r28
    3f34:	64 91       	lpm	r22, Z
    3f36:	21 96       	adiw	r28, 0x01	; 1
    3f38:	61 11       	cpse	r22, r1
    3f3a:	f3 cf       	rjmp	.-26     	; 0x3f22 <_ZN8emstream4putsEPKc+0x2e>
    3f3c:	0d c0       	rjmp	.+26     	; 0x3f58 <_ZN8emstream4putsEPKc+0x64>
    3f3e:	ef 01       	movw	r28, r30
    3f40:	21 96       	adiw	r28, 0x01	; 1
    3f42:	d8 01       	movw	r26, r16
    3f44:	ed 91       	ld	r30, X+
    3f46:	fc 91       	ld	r31, X
    3f48:	02 80       	ldd	r0, Z+2	; 0x02
    3f4a:	f3 81       	ldd	r31, Z+3	; 0x03
    3f4c:	e0 2d       	mov	r30, r0
    3f4e:	c8 01       	movw	r24, r16
    3f50:	19 95       	eicall
    3f52:	69 91       	ld	r22, Y+
    3f54:	61 11       	cpse	r22, r1
    3f56:	f5 cf       	rjmp	.-22     	; 0x3f42 <_ZN8emstream4putsEPKc+0x4e>
    3f58:	df 91       	pop	r29
    3f5a:	cf 91       	pop	r28
    3f5c:	1f 91       	pop	r17
    3f5e:	0f 91       	pop	r16
    3f60:	08 95       	ret

00003f62 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3f62:	cf 93       	push	r28
    3f64:	df 93       	push	r29
    3f66:	ec 01       	movw	r28, r24
	switch (new_manip)
    3f68:	86 2f       	mov	r24, r22
    3f6a:	90 e0       	ldi	r25, 0x00	; 0
    3f6c:	8b 30       	cpi	r24, 0x0B	; 11
    3f6e:	91 05       	cpc	r25, r1
    3f70:	d8 f5       	brcc	.+118    	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3f72:	fc 01       	movw	r30, r24
    3f74:	88 27       	eor	r24, r24
    3f76:	e2 50       	subi	r30, 0x02	; 2
    3f78:	ff 4f       	sbci	r31, 0xFF	; 255
    3f7a:	8f 4f       	sbci	r24, 0xFF	; 255
    3f7c:	0c 94 55 27 	jmp	0x4eaa	; 0x4eaa <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3f80:	82 e0       	ldi	r24, 0x02	; 2
    3f82:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f84:	31 c0       	rjmp	.+98     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3f86:	88 e0       	ldi	r24, 0x08	; 8
    3f88:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f8a:	2e c0       	rjmp	.+92     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3f8c:	8a e0       	ldi	r24, 0x0A	; 10
    3f8e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f90:	2b c0       	rjmp	.+86     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3f92:	80 e1       	ldi	r24, 0x10	; 16
    3f94:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f96:	28 c0       	rjmp	.+80     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3f98:	81 e0       	ldi	r24, 0x01	; 1
    3f9a:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3f9c:	25 c0       	rjmp	.+74     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3f9e:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3fa0:	23 c0       	rjmp	.+70     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3fa2:	e8 81       	ld	r30, Y
    3fa4:	f9 81       	ldd	r31, Y+1	; 0x01
    3fa6:	02 80       	ldd	r0, Z+2	; 0x02
    3fa8:	f3 81       	ldd	r31, Z+3	; 0x03
    3faa:	e0 2d       	mov	r30, r0
    3fac:	6d e0       	ldi	r22, 0x0D	; 13
    3fae:	ce 01       	movw	r24, r28
    3fb0:	19 95       	eicall
    3fb2:	e8 81       	ld	r30, Y
    3fb4:	f9 81       	ldd	r31, Y+1	; 0x01
    3fb6:	02 80       	ldd	r0, Z+2	; 0x02
    3fb8:	f3 81       	ldd	r31, Z+3	; 0x03
    3fba:	e0 2d       	mov	r30, r0
    3fbc:	6a e0       	ldi	r22, 0x0A	; 10
    3fbe:	ce 01       	movw	r24, r28
    3fc0:	19 95       	eicall
			break;
    3fc2:	12 c0       	rjmp	.+36     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3fc4:	e8 81       	ld	r30, Y
    3fc6:	f9 81       	ldd	r31, Y+1	; 0x01
    3fc8:	02 84       	ldd	r0, Z+10	; 0x0a
    3fca:	f3 85       	ldd	r31, Z+11	; 0x0b
    3fcc:	e0 2d       	mov	r30, r0
    3fce:	ce 01       	movw	r24, r28
    3fd0:	19 95       	eicall
			break;
    3fd2:	0a c0       	rjmp	.+20     	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3fd4:	e8 81       	ld	r30, Y
    3fd6:	f9 81       	ldd	r31, Y+1	; 0x01
    3fd8:	00 84       	ldd	r0, Z+8	; 0x08
    3fda:	f1 85       	ldd	r31, Z+9	; 0x09
    3fdc:	e0 2d       	mov	r30, r0
    3fde:	ce 01       	movw	r24, r28
    3fe0:	19 95       	eicall
			break;
    3fe2:	02 c0       	rjmp	.+4      	; 0x3fe8 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3fe4:	81 e0       	ldi	r24, 0x01	; 1
    3fe6:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3fe8:	ce 01       	movw	r24, r28
    3fea:	df 91       	pop	r29
    3fec:	cf 91       	pop	r28
    3fee:	08 95       	ret

00003ff0 <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    3ff0:	cf 93       	push	r28
    3ff2:	df 93       	push	r29
    3ff4:	ec 01       	movw	r28, r24
	if (value)
    3ff6:	66 23       	and	r22, r22
    3ff8:	41 f0       	breq	.+16     	; 0x400a <__stack+0xb>
		putchar ('T');
    3ffa:	e8 81       	ld	r30, Y
    3ffc:	f9 81       	ldd	r31, Y+1	; 0x01
    3ffe:	02 80       	ldd	r0, Z+2	; 0x02
    4000:	f3 81       	ldd	r31, Z+3	; 0x03
    4002:	e0 2d       	mov	r30, r0
    4004:	64 e5       	ldi	r22, 0x54	; 84
    4006:	19 95       	eicall
    4008:	07 c0       	rjmp	.+14     	; 0x4018 <__stack+0x19>
	else
		putchar ('F');
    400a:	e8 81       	ld	r30, Y
    400c:	f9 81       	ldd	r31, Y+1	; 0x01
    400e:	02 80       	ldd	r0, Z+2	; 0x02
    4010:	f3 81       	ldd	r31, Z+3	; 0x03
    4012:	e0 2d       	mov	r30, r0
    4014:	66 e4       	ldi	r22, 0x46	; 70
    4016:	19 95       	eicall

	return (*this);
}
    4018:	ce 01       	movw	r24, r28
    401a:	df 91       	pop	r29
    401c:	cf 91       	pop	r28
    401e:	08 95       	ret

00004020 <_ZN8emstreamlsEPv>:
 *          reference is used to string printable items together with "<<" operators
 *  @param ptr The pointer to be sent out
 */

emstream& emstream::operator<< (void* ptr)
{
    4020:	0f 93       	push	r16
    4022:	1f 93       	push	r17
    4024:	cf 93       	push	r28
    4026:	df 93       	push	r29
    4028:	ec 01       	movw	r28, r24
    402a:	8b 01       	movw	r16, r22
	putchar ('[');
    402c:	e8 81       	ld	r30, Y
    402e:	f9 81       	ldd	r31, Y+1	; 0x01
    4030:	02 80       	ldd	r0, Z+2	; 0x02
    4032:	f3 81       	ldd	r31, Z+3	; 0x03
    4034:	e0 2d       	mov	r30, r0
    4036:	6b e5       	ldi	r22, 0x5B	; 91
    4038:	19 95       	eicall
	*this << hex << (size_t)ptr << dec;
    403a:	63 e0       	ldi	r22, 0x03	; 3
    403c:	ce 01       	movw	r24, r28
    403e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    4042:	b8 01       	movw	r22, r16
    4044:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEj>
    4048:	62 e0       	ldi	r22, 0x02	; 2
    404a:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	putchar (']');
    404e:	e8 81       	ld	r30, Y
    4050:	f9 81       	ldd	r31, Y+1	; 0x01
    4052:	02 80       	ldd	r0, Z+2	; 0x02
    4054:	f3 81       	ldd	r31, Z+3	; 0x03
    4056:	e0 2d       	mov	r30, r0
    4058:	6d e5       	ldi	r22, 0x5D	; 93
    405a:	ce 01       	movw	r24, r28
    405c:	19 95       	eicall

	return (*this);
}
    405e:	ce 01       	movw	r24, r28
    4060:	df 91       	pop	r29
    4062:	cf 91       	pop	r28
    4064:	1f 91       	pop	r17
    4066:	0f 91       	pop	r16
    4068:	08 95       	ret

0000406a <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    406a:	ff 92       	push	r15
    406c:	0f 93       	push	r16
    406e:	1f 93       	push	r17
    4070:	cf 93       	push	r28
    4072:	df 93       	push	r29
    4074:	cd b7       	in	r28, 0x3d	; 61
    4076:	de b7       	in	r29, 0x3e	; 62
    4078:	61 97       	sbiw	r28, 0x11	; 17
    407a:	cd bf       	out	0x3d, r28	; 61
    407c:	de bf       	out	0x3e, r29	; 62
    407e:	8c 01       	movw	r16, r24
    4080:	f6 2e       	mov	r15, r22
    4082:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    4084:	f8 01       	movw	r30, r16
    4086:	42 81       	ldd	r20, Z+2	; 0x02
    4088:	40 31       	cpi	r20, 0x10	; 16
    408a:	21 f0       	breq	.+8      	; 0x4094 <_ZN8emstreamlsEj+0x2a>
    408c:	48 30       	cpi	r20, 0x08	; 8
    408e:	11 f0       	breq	.+4      	; 0x4094 <_ZN8emstreamlsEj+0x2a>
    4090:	42 30       	cpi	r20, 0x02	; 2
    4092:	41 f4       	brne	.+16     	; 0x40a4 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    4094:	69 2f       	mov	r22, r25
    4096:	c8 01       	movw	r24, r16
    4098:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    409c:	6f 2d       	mov	r22, r15
    409e:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    40a2:	0d c0       	rjmp	.+26     	; 0x40be <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    40a4:	50 e0       	ldi	r21, 0x00	; 0
    40a6:	be 01       	movw	r22, r28
    40a8:	6f 5f       	subi	r22, 0xFF	; 255
    40aa:	7f 4f       	sbci	r23, 0xFF	; 255
    40ac:	8f 2d       	mov	r24, r15
    40ae:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    40b2:	be 01       	movw	r22, r28
    40b4:	6f 5f       	subi	r22, 0xFF	; 255
    40b6:	7f 4f       	sbci	r23, 0xFF	; 255
    40b8:	c8 01       	movw	r24, r16
    40ba:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    40be:	c8 01       	movw	r24, r16
    40c0:	61 96       	adiw	r28, 0x11	; 17
    40c2:	cd bf       	out	0x3d, r28	; 61
    40c4:	de bf       	out	0x3e, r29	; 62
    40c6:	df 91       	pop	r29
    40c8:	cf 91       	pop	r28
    40ca:	1f 91       	pop	r17
    40cc:	0f 91       	pop	r16
    40ce:	ff 90       	pop	r15
    40d0:	08 95       	ret

000040d2 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    40d2:	df 92       	push	r13
    40d4:	ef 92       	push	r14
    40d6:	ff 92       	push	r15
    40d8:	0f 93       	push	r16
    40da:	1f 93       	push	r17
    40dc:	cf 93       	push	r28
    40de:	df 93       	push	r29
    40e0:	cd b7       	in	r28, 0x3d	; 61
    40e2:	de b7       	in	r29, 0x3e	; 62
    40e4:	a1 97       	sbiw	r28, 0x21	; 33
    40e6:	cd bf       	out	0x3d, r28	; 61
    40e8:	de bf       	out	0x3e, r29	; 62
    40ea:	8c 01       	movw	r16, r24
    40ec:	d4 2e       	mov	r13, r20
    40ee:	e5 2e       	mov	r14, r21
    40f0:	f6 2e       	mov	r15, r22
    40f2:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    40f4:	f8 01       	movw	r30, r16
    40f6:	22 81       	ldd	r18, Z+2	; 0x02
    40f8:	20 31       	cpi	r18, 0x10	; 16
    40fa:	21 f0       	breq	.+8      	; 0x4104 <_ZN8emstreamlsEm+0x32>
    40fc:	28 30       	cpi	r18, 0x08	; 8
    40fe:	11 f0       	breq	.+4      	; 0x4104 <_ZN8emstreamlsEm+0x32>
    4100:	22 30       	cpi	r18, 0x02	; 2
    4102:	71 f4       	brne	.+28     	; 0x4120 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    4104:	69 2f       	mov	r22, r25
    4106:	c8 01       	movw	r24, r16
    4108:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    410c:	6f 2d       	mov	r22, r15
    410e:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    4112:	6e 2d       	mov	r22, r14
    4114:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    4118:	6d 2d       	mov	r22, r13
    411a:	0e 94 ab 20 	call	0x4156	; 0x4156 <_ZN8emstreamlsEh>
    411e:	0f c0       	rjmp	.+30     	; 0x413e <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    4120:	30 e0       	ldi	r19, 0x00	; 0
    4122:	ae 01       	movw	r20, r28
    4124:	4f 5f       	subi	r20, 0xFF	; 255
    4126:	5f 4f       	sbci	r21, 0xFF	; 255
    4128:	6d 2d       	mov	r22, r13
    412a:	7e 2d       	mov	r23, r14
    412c:	8f 2d       	mov	r24, r15
    412e:	0e 94 97 27 	call	0x4f2e	; 0x4f2e <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    4132:	be 01       	movw	r22, r28
    4134:	6f 5f       	subi	r22, 0xFF	; 255
    4136:	7f 4f       	sbci	r23, 0xFF	; 255
    4138:	c8 01       	movw	r24, r16
    413a:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    413e:	c8 01       	movw	r24, r16
    4140:	a1 96       	adiw	r28, 0x21	; 33
    4142:	cd bf       	out	0x3d, r28	; 61
    4144:	de bf       	out	0x3e, r29	; 62
    4146:	df 91       	pop	r29
    4148:	cf 91       	pop	r28
    414a:	1f 91       	pop	r17
    414c:	0f 91       	pop	r16
    414e:	ff 90       	pop	r15
    4150:	ef 90       	pop	r14
    4152:	df 90       	pop	r13
    4154:	08 95       	ret

00004156 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    4156:	cf 92       	push	r12
    4158:	df 92       	push	r13
    415a:	ef 92       	push	r14
    415c:	ff 92       	push	r15
    415e:	0f 93       	push	r16
    4160:	1f 93       	push	r17
    4162:	cf 93       	push	r28
    4164:	df 93       	push	r29
    4166:	cd b7       	in	r28, 0x3d	; 61
    4168:	de b7       	in	r29, 0x3e	; 62
    416a:	29 97       	sbiw	r28, 0x09	; 9
    416c:	cd bf       	out	0x3d, r28	; 61
    416e:	de bf       	out	0x3e, r29	; 62
    4170:	8c 01       	movw	r16, r24
    4172:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    4174:	dc 01       	movw	r26, r24
    4176:	13 96       	adiw	r26, 0x03	; 3
    4178:	8c 91       	ld	r24, X
    417a:	13 97       	sbiw	r26, 0x03	; 3
    417c:	88 23       	and	r24, r24
    417e:	41 f0       	breq	.+16     	; 0x4190 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    4180:	ed 91       	ld	r30, X+
    4182:	fc 91       	ld	r31, X
    4184:	02 80       	ldd	r0, Z+2	; 0x02
    4186:	f3 81       	ldd	r31, Z+3	; 0x03
    4188:	e0 2d       	mov	r30, r0
    418a:	c8 01       	movw	r24, r16
    418c:	19 95       	eicall
    418e:	56 c0       	rjmp	.+172    	; 0x423c <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    4190:	f8 01       	movw	r30, r16
    4192:	42 81       	ldd	r20, Z+2	; 0x02
    4194:	42 30       	cpi	r20, 0x02	; 2
    4196:	19 f5       	brne	.+70     	; 0x41de <_ZN8emstreamlsEh+0x88>
    4198:	68 94       	set
    419a:	cc 24       	eor	r12, r12
    419c:	c3 f8       	bld	r12, 3
    419e:	d1 2c       	mov	r13, r1
    41a0:	68 94       	set
    41a2:	ff 24       	eor	r15, r15
    41a4:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    41a6:	8e 2d       	mov	r24, r14
    41a8:	8f 21       	and	r24, r15
    41aa:	51 f0       	breq	.+20     	; 0x41c0 <_ZN8emstreamlsEh+0x6a>
    41ac:	d8 01       	movw	r26, r16
    41ae:	ed 91       	ld	r30, X+
    41b0:	fc 91       	ld	r31, X
    41b2:	02 80       	ldd	r0, Z+2	; 0x02
    41b4:	f3 81       	ldd	r31, Z+3	; 0x03
    41b6:	e0 2d       	mov	r30, r0
    41b8:	61 e3       	ldi	r22, 0x31	; 49
    41ba:	c8 01       	movw	r24, r16
    41bc:	19 95       	eicall
    41be:	09 c0       	rjmp	.+18     	; 0x41d2 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    41c0:	d8 01       	movw	r26, r16
    41c2:	ed 91       	ld	r30, X+
    41c4:	fc 91       	ld	r31, X
    41c6:	02 80       	ldd	r0, Z+2	; 0x02
    41c8:	f3 81       	ldd	r31, Z+3	; 0x03
    41ca:	e0 2d       	mov	r30, r0
    41cc:	60 e3       	ldi	r22, 0x30	; 48
    41ce:	c8 01       	movw	r24, r16
    41d0:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    41d2:	f6 94       	lsr	r15
    41d4:	b1 e0       	ldi	r27, 0x01	; 1
    41d6:	cb 1a       	sub	r12, r27
    41d8:	d1 08       	sbc	r13, r1
    41da:	29 f7       	brne	.-54     	; 0x41a6 <_ZN8emstreamlsEh+0x50>
    41dc:	2f c0       	rjmp	.+94     	; 0x423c <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    41de:	40 31       	cpi	r20, 0x10	; 16
    41e0:	f9 f4       	brne	.+62     	; 0x4220 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    41e2:	62 95       	swap	r22
    41e4:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    41e6:	01 90       	ld	r0, Z+
    41e8:	f0 81       	ld	r31, Z
    41ea:	e0 2d       	mov	r30, r0
    41ec:	02 80       	ldd	r0, Z+2	; 0x02
    41ee:	f3 81       	ldd	r31, Z+3	; 0x03
    41f0:	e0 2d       	mov	r30, r0
    41f2:	6a 30       	cpi	r22, 0x0A	; 10
    41f4:	10 f0       	brcs	.+4      	; 0x41fa <_ZN8emstreamlsEh+0xa4>
    41f6:	69 5c       	subi	r22, 0xC9	; 201
    41f8:	01 c0       	rjmp	.+2      	; 0x41fc <_ZN8emstreamlsEh+0xa6>
    41fa:	60 5d       	subi	r22, 0xD0	; 208
    41fc:	c8 01       	movw	r24, r16
    41fe:	19 95       	eicall
		temp_char = num & 0x0F;
    4200:	6e 2d       	mov	r22, r14
    4202:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    4204:	d8 01       	movw	r26, r16
    4206:	ed 91       	ld	r30, X+
    4208:	fc 91       	ld	r31, X
    420a:	02 80       	ldd	r0, Z+2	; 0x02
    420c:	f3 81       	ldd	r31, Z+3	; 0x03
    420e:	e0 2d       	mov	r30, r0
    4210:	6a 30       	cpi	r22, 0x0A	; 10
    4212:	10 f0       	brcs	.+4      	; 0x4218 <_ZN8emstreamlsEh+0xc2>
    4214:	69 5c       	subi	r22, 0xC9	; 201
    4216:	01 c0       	rjmp	.+2      	; 0x421a <_ZN8emstreamlsEh+0xc4>
    4218:	60 5d       	subi	r22, 0xD0	; 208
    421a:	c8 01       	movw	r24, r16
    421c:	19 95       	eicall
    421e:	0e c0       	rjmp	.+28     	; 0x423c <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4220:	50 e0       	ldi	r21, 0x00	; 0
    4222:	be 01       	movw	r22, r28
    4224:	6f 5f       	subi	r22, 0xFF	; 255
    4226:	7f 4f       	sbci	r23, 0xFF	; 255
    4228:	8e 2d       	mov	r24, r14
    422a:	90 e0       	ldi	r25, 0x00	; 0
    422c:	0e 94 c4 27 	call	0x4f88	; 0x4f88 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    4230:	be 01       	movw	r22, r28
    4232:	6f 5f       	subi	r22, 0xFF	; 255
    4234:	7f 4f       	sbci	r23, 0xFF	; 255
    4236:	c8 01       	movw	r24, r16
    4238:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    423c:	c8 01       	movw	r24, r16
    423e:	29 96       	adiw	r28, 0x09	; 9
    4240:	cd bf       	out	0x3d, r28	; 61
    4242:	de bf       	out	0x3e, r29	; 62
    4244:	df 91       	pop	r29
    4246:	cf 91       	pop	r28
    4248:	1f 91       	pop	r17
    424a:	0f 91       	pop	r16
    424c:	ff 90       	pop	r15
    424e:	ef 90       	pop	r14
    4250:	df 90       	pop	r13
    4252:	cf 90       	pop	r12
    4254:	08 95       	ret

00004256 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    4256:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4258:	50 96       	adiw	r26, 0x10	; 16
    425a:	ed 91       	ld	r30, X+
    425c:	fc 91       	ld	r31, X
    425e:	51 97       	sbiw	r26, 0x11	; 17
    4260:	80 81       	ld	r24, Z
    4262:	54 96       	adiw	r26, 0x14	; 20
    4264:	4c 91       	ld	r20, X
    4266:	54 97       	sbiw	r26, 0x14	; 20
    4268:	84 23       	and	r24, r20
    426a:	29 f0       	breq	.+10     	; 0x4276 <_ZN5rs2327putcharEc+0x20>
    426c:	09 c0       	rjmp	.+18     	; 0x4280 <_ZN5rs2327putcharEc+0x2a>
    426e:	21 50       	subi	r18, 0x01	; 1
    4270:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4272:	19 f4       	brne	.+6      	; 0x427a <_ZN5rs2327putcharEc+0x24>
    4274:	12 c0       	rjmp	.+36     	; 0x429a <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4276:	21 e2       	ldi	r18, 0x21	; 33
    4278:	3e e4       	ldi	r19, 0x4E	; 78
    427a:	90 81       	ld	r25, Z
    427c:	94 23       	and	r25, r20
    427e:	b9 f3       	breq	.-18     	; 0x426e <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4280:	90 81       	ld	r25, Z
    4282:	56 96       	adiw	r26, 0x16	; 22
    4284:	8c 91       	ld	r24, X
    4286:	56 97       	sbiw	r26, 0x16	; 22
    4288:	89 2b       	or	r24, r25
    428a:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    428c:	1e 96       	adiw	r26, 0x0e	; 14
    428e:	ed 91       	ld	r30, X+
    4290:	fc 91       	ld	r31, X
    4292:	1f 97       	sbiw	r26, 0x0f	; 15
    4294:	60 83       	st	Z, r22
	return (true);
    4296:	81 e0       	ldi	r24, 0x01	; 1
    4298:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    429a:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    429c:	08 95       	ret

0000429e <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    429e:	cf 93       	push	r28
    42a0:	df 93       	push	r29
    42a2:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    42a4:	c1 8d       	ldd	r28, Z+25	; 0x19
    42a6:	d2 8d       	ldd	r29, Z+26	; 0x1a
    42a8:	28 81       	ld	r18, Y
    42aa:	39 81       	ldd	r19, Y+1	; 0x01
    42ac:	a3 8d       	ldd	r26, Z+27	; 0x1b
    42ae:	b4 8d       	ldd	r27, Z+28	; 0x1c
    42b0:	4d 91       	ld	r20, X+
    42b2:	5c 91       	ld	r21, X
    42b4:	24 17       	cp	r18, r20
    42b6:	35 07       	cpc	r19, r21
    42b8:	e9 f3       	breq	.-6      	; 0x42b4 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    42ba:	a7 89       	ldd	r26, Z+23	; 0x17
    42bc:	b0 8d       	ldd	r27, Z+24	; 0x18
    42be:	0d 90       	ld	r0, X+
    42c0:	bc 91       	ld	r27, X
    42c2:	a0 2d       	mov	r26, r0
    42c4:	a2 0f       	add	r26, r18
    42c6:	b3 1f       	adc	r27, r19
    42c8:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    42ca:	2f 5f       	subi	r18, 0xFF	; 255
    42cc:	3f 4f       	sbci	r19, 0xFF	; 255
    42ce:	28 83       	st	Y, r18
    42d0:	39 83       	std	Y+1, r19	; 0x01
    42d2:	24 36       	cpi	r18, 0x64	; 100
    42d4:	31 05       	cpc	r19, r1
    42d6:	28 f0       	brcs	.+10     	; 0x42e2 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    42d8:	01 8c       	ldd	r0, Z+25	; 0x19
    42da:	f2 8d       	ldd	r31, Z+26	; 0x1a
    42dc:	e0 2d       	mov	r30, r0
    42de:	10 82       	st	Z, r1
    42e0:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    42e2:	90 e0       	ldi	r25, 0x00	; 0
    42e4:	df 91       	pop	r29
    42e6:	cf 91       	pop	r28
    42e8:	08 95       	ret

000042ea <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    42ea:	cf 93       	push	r28
    42ec:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    42ee:	ec 01       	movw	r28, r24
    42f0:	a9 8d       	ldd	r26, Y+25	; 0x19
    42f2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    42f4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    42f6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    42f8:	81 e0       	ldi	r24, 0x01	; 1
    42fa:	4d 91       	ld	r20, X+
    42fc:	5c 91       	ld	r21, X
    42fe:	20 81       	ld	r18, Z
    4300:	31 81       	ldd	r19, Z+1	; 0x01
    4302:	42 17       	cp	r20, r18
    4304:	53 07       	cpc	r21, r19
    4306:	09 f4       	brne	.+2      	; 0x430a <_ZN5rs23214check_for_charEv+0x20>
    4308:	80 e0       	ldi	r24, 0x00	; 0
}
    430a:	df 91       	pop	r29
    430c:	cf 91       	pop	r28
    430e:	08 95       	ret

00004310 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    4310:	dc 01       	movw	r26, r24
    4312:	ed 91       	ld	r30, X+
    4314:	fc 91       	ld	r31, X
    4316:	02 80       	ldd	r0, Z+2	; 0x02
    4318:	f3 81       	ldd	r31, Z+3	; 0x03
    431a:	e0 2d       	mov	r30, r0
    431c:	6c e0       	ldi	r22, 0x0C	; 12
    431e:	19 95       	eicall
    4320:	08 95       	ret

00004322 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    4322:	ef 92       	push	r14
    4324:	ff 92       	push	r15
    4326:	0f 93       	push	r16
    4328:	1f 93       	push	r17
    432a:	cf 93       	push	r28
    432c:	df 93       	push	r29
    432e:	ec 01       	movw	r28, r24
    4330:	7b 01       	movw	r14, r22
    4332:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    4334:	0e 94 6c 1f 	call	0x3ed8	; 0x3ed8 <_ZN8emstreamC1Ev>
    4338:	a8 01       	movw	r20, r16
    433a:	b7 01       	movw	r22, r14
    433c:	ce 01       	movw	r24, r28
    433e:	08 96       	adiw	r24, 0x08	; 8
    4340:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <_ZN7base232C1EjP12USART_struct>
    4344:	81 eb       	ldi	r24, 0xB1	; 177
    4346:	91 e2       	ldi	r25, 0x21	; 33
    4348:	88 83       	st	Y, r24
    434a:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    434c:	00 3a       	cpi	r16, 0xA0	; 160
    434e:	88 e0       	ldi	r24, 0x08	; 8
    4350:	18 07       	cpc	r17, r24
    4352:	69 f4       	brne	.+26     	; 0x436e <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4354:	8c eb       	ldi	r24, 0xBC	; 188
    4356:	92 e3       	ldi	r25, 0x32	; 50
    4358:	8f 8b       	std	Y+23, r24	; 0x17
    435a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    435c:	82 eb       	ldi	r24, 0xB2	; 178
    435e:	92 e3       	ldi	r25, 0x32	; 50
    4360:	89 8f       	std	Y+25, r24	; 0x19
    4362:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4364:	88 ea       	ldi	r24, 0xA8	; 168
    4366:	92 e3       	ldi	r25, 0x32	; 50
    4368:	8b 8f       	std	Y+27, r24	; 0x1b
    436a:	9c 8f       	std	Y+28, r25	; 0x1c
    436c:	42 c0       	rjmp	.+132    	; 0x43f2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    436e:	00 3b       	cpi	r16, 0xB0	; 176
    4370:	e8 e0       	ldi	r30, 0x08	; 8
    4372:	1e 07       	cpc	r17, r30
    4374:	69 f4       	brne	.+26     	; 0x4390 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    4376:	8a eb       	ldi	r24, 0xBA	; 186
    4378:	92 e3       	ldi	r25, 0x32	; 50
    437a:	8f 8b       	std	Y+23, r24	; 0x17
    437c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    437e:	80 eb       	ldi	r24, 0xB0	; 176
    4380:	92 e3       	ldi	r25, 0x32	; 50
    4382:	89 8f       	std	Y+25, r24	; 0x19
    4384:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    4386:	86 ea       	ldi	r24, 0xA6	; 166
    4388:	92 e3       	ldi	r25, 0x32	; 50
    438a:	8b 8f       	std	Y+27, r24	; 0x1b
    438c:	9c 8f       	std	Y+28, r25	; 0x1c
    438e:	31 c0       	rjmp	.+98     	; 0x43f2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    4390:	00 3a       	cpi	r16, 0xA0	; 160
    4392:	f9 e0       	ldi	r31, 0x09	; 9
    4394:	1f 07       	cpc	r17, r31
    4396:	69 f4       	brne	.+26     	; 0x43b2 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    4398:	88 eb       	ldi	r24, 0xB8	; 184
    439a:	92 e3       	ldi	r25, 0x32	; 50
    439c:	8f 8b       	std	Y+23, r24	; 0x17
    439e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    43a0:	8e ea       	ldi	r24, 0xAE	; 174
    43a2:	92 e3       	ldi	r25, 0x32	; 50
    43a4:	89 8f       	std	Y+25, r24	; 0x19
    43a6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    43a8:	84 ea       	ldi	r24, 0xA4	; 164
    43aa:	92 e3       	ldi	r25, 0x32	; 50
    43ac:	8b 8f       	std	Y+27, r24	; 0x1b
    43ae:	9c 8f       	std	Y+28, r25	; 0x1c
    43b0:	20 c0       	rjmp	.+64     	; 0x43f2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    43b2:	00 3b       	cpi	r16, 0xB0	; 176
    43b4:	89 e0       	ldi	r24, 0x09	; 9
    43b6:	18 07       	cpc	r17, r24
    43b8:	69 f4       	brne	.+26     	; 0x43d4 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    43ba:	86 eb       	ldi	r24, 0xB6	; 182
    43bc:	92 e3       	ldi	r25, 0x32	; 50
    43be:	8f 8b       	std	Y+23, r24	; 0x17
    43c0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    43c2:	8c ea       	ldi	r24, 0xAC	; 172
    43c4:	92 e3       	ldi	r25, 0x32	; 50
    43c6:	89 8f       	std	Y+25, r24	; 0x19
    43c8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    43ca:	82 ea       	ldi	r24, 0xA2	; 162
    43cc:	92 e3       	ldi	r25, 0x32	; 50
    43ce:	8b 8f       	std	Y+27, r24	; 0x1b
    43d0:	9c 8f       	std	Y+28, r25	; 0x1c
    43d2:	0f c0       	rjmp	.+30     	; 0x43f2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    43d4:	00 3a       	cpi	r16, 0xA0	; 160
    43d6:	1a 40       	sbci	r17, 0x0A	; 10
    43d8:	61 f4       	brne	.+24     	; 0x43f2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    43da:	84 eb       	ldi	r24, 0xB4	; 180
    43dc:	92 e3       	ldi	r25, 0x32	; 50
    43de:	8f 8b       	std	Y+23, r24	; 0x17
    43e0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    43e2:	8a ea       	ldi	r24, 0xAA	; 170
    43e4:	92 e3       	ldi	r25, 0x32	; 50
    43e6:	89 8f       	std	Y+25, r24	; 0x19
    43e8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    43ea:	80 ea       	ldi	r24, 0xA0	; 160
    43ec:	92 e3       	ldi	r25, 0x32	; 50
    43ee:	8b 8f       	std	Y+27, r24	; 0x1b
    43f0:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    43f2:	0f 89       	ldd	r16, Y+23	; 0x17
    43f4:	18 8d       	ldd	r17, Y+24	; 0x18
    43f6:	84 e6       	ldi	r24, 0x64	; 100
    43f8:	90 e0       	ldi	r25, 0x00	; 0
    43fa:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <_Znaj>
    43fe:	f8 01       	movw	r30, r16
    4400:	80 83       	st	Z, r24
    4402:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    4404:	e9 8d       	ldd	r30, Y+25	; 0x19
    4406:	fa 8d       	ldd	r31, Y+26	; 0x1a
    4408:	10 82       	st	Z, r1
    440a:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    440c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    440e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4410:	10 82       	st	Z, r1
    4412:	11 82       	std	Z+1, r1	; 0x01
}
    4414:	df 91       	pop	r29
    4416:	cf 91       	pop	r28
    4418:	1f 91       	pop	r17
    441a:	0f 91       	pop	r16
    441c:	ff 90       	pop	r15
    441e:	ef 90       	pop	r14
    4420:	08 95       	ret

00004422 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    4422:	1f 92       	push	r1
    4424:	0f 92       	push	r0
    4426:	0f b6       	in	r0, 0x3f	; 63
    4428:	0f 92       	push	r0
    442a:	11 24       	eor	r1, r1
    442c:	08 b6       	in	r0, 0x38	; 56
    442e:	0f 92       	push	r0
    4430:	18 be       	out	0x38, r1	; 56
    4432:	0b b6       	in	r0, 0x3b	; 59
    4434:	0f 92       	push	r0
    4436:	1b be       	out	0x3b, r1	; 59
    4438:	2f 93       	push	r18
    443a:	3f 93       	push	r19
    443c:	8f 93       	push	r24
    443e:	9f 93       	push	r25
    4440:	ef 93       	push	r30
    4442:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    4444:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    4448:	e0 91 bc 32 	lds	r30, 0x32BC	; 0x8032bc <rcvC0_buffer>
    444c:	f0 91 bd 32 	lds	r31, 0x32BD	; 0x8032bd <rcvC0_buffer+0x1>
    4450:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC0_write_index>
    4454:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC0_write_index+0x1>
    4458:	e8 0f       	add	r30, r24
    445a:	f9 1f       	adc	r31, r25
    445c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    445e:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC0_write_index>
    4462:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC0_write_index+0x1>
    4466:	01 96       	adiw	r24, 0x01	; 1
    4468:	84 36       	cpi	r24, 0x64	; 100
    446a:	91 05       	cpc	r25, r1
    446c:	60 f4       	brcc	.+24     	; 0x4486 <__vector_25+0x64>
    446e:	80 93 a8 32 	sts	0x32A8, r24	; 0x8032a8 <rcvC0_write_index>
    4472:	90 93 a9 32 	sts	0x32A9, r25	; 0x8032a9 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4476:	20 91 b2 32 	lds	r18, 0x32B2	; 0x8032b2 <rcvC0_read_index>
    447a:	30 91 b3 32 	lds	r19, 0x32B3	; 0x8032b3 <rcvC0_read_index+0x1>
    447e:	82 17       	cp	r24, r18
    4480:	93 07       	cpc	r25, r19
    4482:	f1 f4       	brne	.+60     	; 0x44c0 <__vector_25+0x9e>
    4484:	0c c0       	rjmp	.+24     	; 0x449e <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    4486:	10 92 a8 32 	sts	0x32A8, r1	; 0x8032a8 <rcvC0_write_index>
    448a:	10 92 a9 32 	sts	0x32A9, r1	; 0x8032a9 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    448e:	80 91 b2 32 	lds	r24, 0x32B2	; 0x8032b2 <rcvC0_read_index>
    4492:	90 91 b3 32 	lds	r25, 0x32B3	; 0x8032b3 <rcvC0_read_index+0x1>
    4496:	18 16       	cp	r1, r24
    4498:	19 06       	cpc	r1, r25
    449a:	91 f4       	brne	.+36     	; 0x44c0 <__vector_25+0x9e>
    449c:	0e c0       	rjmp	.+28     	; 0x44ba <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    449e:	01 96       	adiw	r24, 0x01	; 1
    44a0:	84 36       	cpi	r24, 0x64	; 100
    44a2:	91 05       	cpc	r25, r1
    44a4:	28 f4       	brcc	.+10     	; 0x44b0 <__vector_25+0x8e>
    44a6:	80 93 b2 32 	sts	0x32B2, r24	; 0x8032b2 <rcvC0_read_index>
    44aa:	90 93 b3 32 	sts	0x32B3, r25	; 0x8032b3 <rcvC0_read_index+0x1>
    44ae:	08 c0       	rjmp	.+16     	; 0x44c0 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    44b0:	10 92 b2 32 	sts	0x32B2, r1	; 0x8032b2 <rcvC0_read_index>
    44b4:	10 92 b3 32 	sts	0x32B3, r1	; 0x8032b3 <rcvC0_read_index+0x1>
}
    44b8:	03 c0       	rjmp	.+6      	; 0x44c0 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    44ba:	81 e0       	ldi	r24, 0x01	; 1
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	f3 cf       	rjmp	.-26     	; 0x44a6 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    44c0:	ff 91       	pop	r31
    44c2:	ef 91       	pop	r30
    44c4:	9f 91       	pop	r25
    44c6:	8f 91       	pop	r24
    44c8:	3f 91       	pop	r19
    44ca:	2f 91       	pop	r18
    44cc:	0f 90       	pop	r0
    44ce:	0b be       	out	0x3b, r0	; 59
    44d0:	0f 90       	pop	r0
    44d2:	08 be       	out	0x38, r0	; 56
    44d4:	0f 90       	pop	r0
    44d6:	0f be       	out	0x3f, r0	; 63
    44d8:	0f 90       	pop	r0
    44da:	1f 90       	pop	r1
    44dc:	18 95       	reti

000044de <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    44de:	1f 92       	push	r1
    44e0:	0f 92       	push	r0
    44e2:	0f b6       	in	r0, 0x3f	; 63
    44e4:	0f 92       	push	r0
    44e6:	11 24       	eor	r1, r1
    44e8:	08 b6       	in	r0, 0x38	; 56
    44ea:	0f 92       	push	r0
    44ec:	18 be       	out	0x38, r1	; 56
    44ee:	0b b6       	in	r0, 0x3b	; 59
    44f0:	0f 92       	push	r0
    44f2:	1b be       	out	0x3b, r1	; 59
    44f4:	2f 93       	push	r18
    44f6:	3f 93       	push	r19
    44f8:	8f 93       	push	r24
    44fa:	9f 93       	push	r25
    44fc:	ef 93       	push	r30
    44fe:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    4500:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    4504:	e0 91 ba 32 	lds	r30, 0x32BA	; 0x8032ba <rcvC1_buffer>
    4508:	f0 91 bb 32 	lds	r31, 0x32BB	; 0x8032bb <rcvC1_buffer+0x1>
    450c:	80 91 a6 32 	lds	r24, 0x32A6	; 0x8032a6 <rcvC1_write_index>
    4510:	90 91 a7 32 	lds	r25, 0x32A7	; 0x8032a7 <rcvC1_write_index+0x1>
    4514:	e8 0f       	add	r30, r24
    4516:	f9 1f       	adc	r31, r25
    4518:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    451a:	80 91 a6 32 	lds	r24, 0x32A6	; 0x8032a6 <rcvC1_write_index>
    451e:	90 91 a7 32 	lds	r25, 0x32A7	; 0x8032a7 <rcvC1_write_index+0x1>
    4522:	01 96       	adiw	r24, 0x01	; 1
    4524:	84 36       	cpi	r24, 0x64	; 100
    4526:	91 05       	cpc	r25, r1
    4528:	60 f4       	brcc	.+24     	; 0x4542 <__vector_28+0x64>
    452a:	80 93 a6 32 	sts	0x32A6, r24	; 0x8032a6 <rcvC1_write_index>
    452e:	90 93 a7 32 	sts	0x32A7, r25	; 0x8032a7 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4532:	20 91 b0 32 	lds	r18, 0x32B0	; 0x8032b0 <rcvC1_read_index>
    4536:	30 91 b1 32 	lds	r19, 0x32B1	; 0x8032b1 <rcvC1_read_index+0x1>
    453a:	82 17       	cp	r24, r18
    453c:	93 07       	cpc	r25, r19
    453e:	f1 f4       	brne	.+60     	; 0x457c <__vector_28+0x9e>
    4540:	0c c0       	rjmp	.+24     	; 0x455a <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4542:	10 92 a6 32 	sts	0x32A6, r1	; 0x8032a6 <rcvC1_write_index>
    4546:	10 92 a7 32 	sts	0x32A7, r1	; 0x8032a7 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    454a:	80 91 b0 32 	lds	r24, 0x32B0	; 0x8032b0 <rcvC1_read_index>
    454e:	90 91 b1 32 	lds	r25, 0x32B1	; 0x8032b1 <rcvC1_read_index+0x1>
    4552:	18 16       	cp	r1, r24
    4554:	19 06       	cpc	r1, r25
    4556:	91 f4       	brne	.+36     	; 0x457c <__vector_28+0x9e>
    4558:	0e c0       	rjmp	.+28     	; 0x4576 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    455a:	01 96       	adiw	r24, 0x01	; 1
    455c:	84 36       	cpi	r24, 0x64	; 100
    455e:	91 05       	cpc	r25, r1
    4560:	28 f4       	brcc	.+10     	; 0x456c <__vector_28+0x8e>
    4562:	80 93 b0 32 	sts	0x32B0, r24	; 0x8032b0 <rcvC1_read_index>
    4566:	90 93 b1 32 	sts	0x32B1, r25	; 0x8032b1 <rcvC1_read_index+0x1>
    456a:	08 c0       	rjmp	.+16     	; 0x457c <__vector_28+0x9e>
	rcvC1_read_index = 0;
    456c:	10 92 b0 32 	sts	0x32B0, r1	; 0x8032b0 <rcvC1_read_index>
    4570:	10 92 b1 32 	sts	0x32B1, r1	; 0x8032b1 <rcvC1_read_index+0x1>
}
    4574:	03 c0       	rjmp	.+6      	; 0x457c <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4576:	81 e0       	ldi	r24, 0x01	; 1
    4578:	90 e0       	ldi	r25, 0x00	; 0
    457a:	f3 cf       	rjmp	.-26     	; 0x4562 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    457c:	ff 91       	pop	r31
    457e:	ef 91       	pop	r30
    4580:	9f 91       	pop	r25
    4582:	8f 91       	pop	r24
    4584:	3f 91       	pop	r19
    4586:	2f 91       	pop	r18
    4588:	0f 90       	pop	r0
    458a:	0b be       	out	0x3b, r0	; 59
    458c:	0f 90       	pop	r0
    458e:	08 be       	out	0x38, r0	; 56
    4590:	0f 90       	pop	r0
    4592:	0f be       	out	0x3f, r0	; 63
    4594:	0f 90       	pop	r0
    4596:	1f 90       	pop	r1
    4598:	18 95       	reti

0000459a <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    459a:	1f 92       	push	r1
    459c:	0f 92       	push	r0
    459e:	0f b6       	in	r0, 0x3f	; 63
    45a0:	0f 92       	push	r0
    45a2:	11 24       	eor	r1, r1
    45a4:	08 b6       	in	r0, 0x38	; 56
    45a6:	0f 92       	push	r0
    45a8:	18 be       	out	0x38, r1	; 56
    45aa:	0b b6       	in	r0, 0x3b	; 59
    45ac:	0f 92       	push	r0
    45ae:	1b be       	out	0x3b, r1	; 59
    45b0:	2f 93       	push	r18
    45b2:	3f 93       	push	r19
    45b4:	8f 93       	push	r24
    45b6:	9f 93       	push	r25
    45b8:	ef 93       	push	r30
    45ba:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    45bc:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    45c0:	e0 91 b8 32 	lds	r30, 0x32B8	; 0x8032b8 <rcvD0_buffer>
    45c4:	f0 91 b9 32 	lds	r31, 0x32B9	; 0x8032b9 <rcvD0_buffer+0x1>
    45c8:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC0_write_index>
    45cc:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC0_write_index+0x1>
    45d0:	e8 0f       	add	r30, r24
    45d2:	f9 1f       	adc	r31, r25
    45d4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    45d6:	80 91 a4 32 	lds	r24, 0x32A4	; 0x8032a4 <rcvD0_write_index>
    45da:	90 91 a5 32 	lds	r25, 0x32A5	; 0x8032a5 <rcvD0_write_index+0x1>
    45de:	01 96       	adiw	r24, 0x01	; 1
    45e0:	84 36       	cpi	r24, 0x64	; 100
    45e2:	91 05       	cpc	r25, r1
    45e4:	60 f4       	brcc	.+24     	; 0x45fe <__vector_88+0x64>
    45e6:	80 93 a4 32 	sts	0x32A4, r24	; 0x8032a4 <rcvD0_write_index>
    45ea:	90 93 a5 32 	sts	0x32A5, r25	; 0x8032a5 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    45ee:	20 91 ae 32 	lds	r18, 0x32AE	; 0x8032ae <rcvD0_read_index>
    45f2:	30 91 af 32 	lds	r19, 0x32AF	; 0x8032af <rcvD0_read_index+0x1>
    45f6:	82 17       	cp	r24, r18
    45f8:	93 07       	cpc	r25, r19
    45fa:	f1 f4       	brne	.+60     	; 0x4638 <__vector_88+0x9e>
    45fc:	0c c0       	rjmp	.+24     	; 0x4616 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    45fe:	10 92 a4 32 	sts	0x32A4, r1	; 0x8032a4 <rcvD0_write_index>
    4602:	10 92 a5 32 	sts	0x32A5, r1	; 0x8032a5 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4606:	80 91 ae 32 	lds	r24, 0x32AE	; 0x8032ae <rcvD0_read_index>
    460a:	90 91 af 32 	lds	r25, 0x32AF	; 0x8032af <rcvD0_read_index+0x1>
    460e:	18 16       	cp	r1, r24
    4610:	19 06       	cpc	r1, r25
    4612:	91 f4       	brne	.+36     	; 0x4638 <__vector_88+0x9e>
    4614:	0e c0       	rjmp	.+28     	; 0x4632 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4616:	01 96       	adiw	r24, 0x01	; 1
    4618:	84 36       	cpi	r24, 0x64	; 100
    461a:	91 05       	cpc	r25, r1
    461c:	28 f4       	brcc	.+10     	; 0x4628 <__vector_88+0x8e>
    461e:	80 93 ae 32 	sts	0x32AE, r24	; 0x8032ae <rcvD0_read_index>
    4622:	90 93 af 32 	sts	0x32AF, r25	; 0x8032af <rcvD0_read_index+0x1>
    4626:	08 c0       	rjmp	.+16     	; 0x4638 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    4628:	10 92 ae 32 	sts	0x32AE, r1	; 0x8032ae <rcvD0_read_index>
    462c:	10 92 af 32 	sts	0x32AF, r1	; 0x8032af <rcvD0_read_index+0x1>
}
    4630:	03 c0       	rjmp	.+6      	; 0x4638 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4632:	81 e0       	ldi	r24, 0x01	; 1
    4634:	90 e0       	ldi	r25, 0x00	; 0
    4636:	f3 cf       	rjmp	.-26     	; 0x461e <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4638:	ff 91       	pop	r31
    463a:	ef 91       	pop	r30
    463c:	9f 91       	pop	r25
    463e:	8f 91       	pop	r24
    4640:	3f 91       	pop	r19
    4642:	2f 91       	pop	r18
    4644:	0f 90       	pop	r0
    4646:	0b be       	out	0x3b, r0	; 59
    4648:	0f 90       	pop	r0
    464a:	08 be       	out	0x38, r0	; 56
    464c:	0f 90       	pop	r0
    464e:	0f be       	out	0x3f, r0	; 63
    4650:	0f 90       	pop	r0
    4652:	1f 90       	pop	r1
    4654:	18 95       	reti

00004656 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4656:	1f 92       	push	r1
    4658:	0f 92       	push	r0
    465a:	0f b6       	in	r0, 0x3f	; 63
    465c:	0f 92       	push	r0
    465e:	11 24       	eor	r1, r1
    4660:	08 b6       	in	r0, 0x38	; 56
    4662:	0f 92       	push	r0
    4664:	18 be       	out	0x38, r1	; 56
    4666:	0b b6       	in	r0, 0x3b	; 59
    4668:	0f 92       	push	r0
    466a:	1b be       	out	0x3b, r1	; 59
    466c:	2f 93       	push	r18
    466e:	3f 93       	push	r19
    4670:	8f 93       	push	r24
    4672:	9f 93       	push	r25
    4674:	ef 93       	push	r30
    4676:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4678:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    467c:	e0 91 b6 32 	lds	r30, 0x32B6	; 0x8032b6 <rcvD1_buffer>
    4680:	f0 91 b7 32 	lds	r31, 0x32B7	; 0x8032b7 <rcvD1_buffer+0x1>
    4684:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvD1_write_index>
    4688:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvD1_write_index+0x1>
    468c:	e8 0f       	add	r30, r24
    468e:	f9 1f       	adc	r31, r25
    4690:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4692:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvD1_write_index>
    4696:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvD1_write_index+0x1>
    469a:	01 96       	adiw	r24, 0x01	; 1
    469c:	84 36       	cpi	r24, 0x64	; 100
    469e:	91 05       	cpc	r25, r1
    46a0:	60 f4       	brcc	.+24     	; 0x46ba <__vector_91+0x64>
    46a2:	80 93 a2 32 	sts	0x32A2, r24	; 0x8032a2 <rcvD1_write_index>
    46a6:	90 93 a3 32 	sts	0x32A3, r25	; 0x8032a3 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    46aa:	20 91 ac 32 	lds	r18, 0x32AC	; 0x8032ac <rcvD1_read_index>
    46ae:	30 91 ad 32 	lds	r19, 0x32AD	; 0x8032ad <rcvD1_read_index+0x1>
    46b2:	82 17       	cp	r24, r18
    46b4:	93 07       	cpc	r25, r19
    46b6:	f1 f4       	brne	.+60     	; 0x46f4 <__vector_91+0x9e>
    46b8:	0c c0       	rjmp	.+24     	; 0x46d2 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    46ba:	10 92 a2 32 	sts	0x32A2, r1	; 0x8032a2 <rcvD1_write_index>
    46be:	10 92 a3 32 	sts	0x32A3, r1	; 0x8032a3 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    46c2:	80 91 ac 32 	lds	r24, 0x32AC	; 0x8032ac <rcvD1_read_index>
    46c6:	90 91 ad 32 	lds	r25, 0x32AD	; 0x8032ad <rcvD1_read_index+0x1>
    46ca:	18 16       	cp	r1, r24
    46cc:	19 06       	cpc	r1, r25
    46ce:	91 f4       	brne	.+36     	; 0x46f4 <__vector_91+0x9e>
    46d0:	0e c0       	rjmp	.+28     	; 0x46ee <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    46d2:	01 96       	adiw	r24, 0x01	; 1
    46d4:	84 36       	cpi	r24, 0x64	; 100
    46d6:	91 05       	cpc	r25, r1
    46d8:	28 f4       	brcc	.+10     	; 0x46e4 <__vector_91+0x8e>
    46da:	80 93 ac 32 	sts	0x32AC, r24	; 0x8032ac <rcvD1_read_index>
    46de:	90 93 ad 32 	sts	0x32AD, r25	; 0x8032ad <rcvD1_read_index+0x1>
    46e2:	08 c0       	rjmp	.+16     	; 0x46f4 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    46e4:	10 92 ac 32 	sts	0x32AC, r1	; 0x8032ac <rcvD1_read_index>
    46e8:	10 92 ad 32 	sts	0x32AD, r1	; 0x8032ad <rcvD1_read_index+0x1>
}
    46ec:	03 c0       	rjmp	.+6      	; 0x46f4 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    46ee:	81 e0       	ldi	r24, 0x01	; 1
    46f0:	90 e0       	ldi	r25, 0x00	; 0
    46f2:	f3 cf       	rjmp	.-26     	; 0x46da <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    46f4:	ff 91       	pop	r31
    46f6:	ef 91       	pop	r30
    46f8:	9f 91       	pop	r25
    46fa:	8f 91       	pop	r24
    46fc:	3f 91       	pop	r19
    46fe:	2f 91       	pop	r18
    4700:	0f 90       	pop	r0
    4702:	0b be       	out	0x3b, r0	; 59
    4704:	0f 90       	pop	r0
    4706:	08 be       	out	0x38, r0	; 56
    4708:	0f 90       	pop	r0
    470a:	0f be       	out	0x3f, r0	; 63
    470c:	0f 90       	pop	r0
    470e:	1f 90       	pop	r1
    4710:	18 95       	reti

00004712 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4712:	1f 92       	push	r1
    4714:	0f 92       	push	r0
    4716:	0f b6       	in	r0, 0x3f	; 63
    4718:	0f 92       	push	r0
    471a:	11 24       	eor	r1, r1
    471c:	08 b6       	in	r0, 0x38	; 56
    471e:	0f 92       	push	r0
    4720:	18 be       	out	0x38, r1	; 56
    4722:	0b b6       	in	r0, 0x3b	; 59
    4724:	0f 92       	push	r0
    4726:	1b be       	out	0x3b, r1	; 59
    4728:	2f 93       	push	r18
    472a:	3f 93       	push	r19
    472c:	8f 93       	push	r24
    472e:	9f 93       	push	r25
    4730:	ef 93       	push	r30
    4732:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4734:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4738:	e0 91 b4 32 	lds	r30, 0x32B4	; 0x8032b4 <rcvE0_buffer>
    473c:	f0 91 b5 32 	lds	r31, 0x32B5	; 0x8032b5 <rcvE0_buffer+0x1>
    4740:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <rcvE0_write_index>
    4744:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <rcvE0_write_index+0x1>
    4748:	e8 0f       	add	r30, r24
    474a:	f9 1f       	adc	r31, r25
    474c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    474e:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <rcvE0_write_index>
    4752:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <rcvE0_write_index+0x1>
    4756:	01 96       	adiw	r24, 0x01	; 1
    4758:	84 36       	cpi	r24, 0x64	; 100
    475a:	91 05       	cpc	r25, r1
    475c:	60 f4       	brcc	.+24     	; 0x4776 <__vector_58+0x64>
    475e:	80 93 a0 32 	sts	0x32A0, r24	; 0x8032a0 <rcvE0_write_index>
    4762:	90 93 a1 32 	sts	0x32A1, r25	; 0x8032a1 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4766:	20 91 aa 32 	lds	r18, 0x32AA	; 0x8032aa <rcvE0_read_index>
    476a:	30 91 ab 32 	lds	r19, 0x32AB	; 0x8032ab <rcvE0_read_index+0x1>
    476e:	82 17       	cp	r24, r18
    4770:	93 07       	cpc	r25, r19
    4772:	f1 f4       	brne	.+60     	; 0x47b0 <__vector_58+0x9e>
    4774:	0c c0       	rjmp	.+24     	; 0x478e <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4776:	10 92 a0 32 	sts	0x32A0, r1	; 0x8032a0 <rcvE0_write_index>
    477a:	10 92 a1 32 	sts	0x32A1, r1	; 0x8032a1 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    477e:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvE0_read_index>
    4782:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvE0_read_index+0x1>
    4786:	18 16       	cp	r1, r24
    4788:	19 06       	cpc	r1, r25
    478a:	91 f4       	brne	.+36     	; 0x47b0 <__vector_58+0x9e>
    478c:	0e c0       	rjmp	.+28     	; 0x47aa <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    478e:	01 96       	adiw	r24, 0x01	; 1
    4790:	84 36       	cpi	r24, 0x64	; 100
    4792:	91 05       	cpc	r25, r1
    4794:	28 f4       	brcc	.+10     	; 0x47a0 <__vector_58+0x8e>
    4796:	80 93 aa 32 	sts	0x32AA, r24	; 0x8032aa <rcvE0_read_index>
    479a:	90 93 ab 32 	sts	0x32AB, r25	; 0x8032ab <rcvE0_read_index+0x1>
    479e:	08 c0       	rjmp	.+16     	; 0x47b0 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    47a0:	10 92 aa 32 	sts	0x32AA, r1	; 0x8032aa <rcvE0_read_index>
    47a4:	10 92 ab 32 	sts	0x32AB, r1	; 0x8032ab <rcvE0_read_index+0x1>
}
    47a8:	03 c0       	rjmp	.+6      	; 0x47b0 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    47aa:	81 e0       	ldi	r24, 0x01	; 1
    47ac:	90 e0       	ldi	r25, 0x00	; 0
    47ae:	f3 cf       	rjmp	.-26     	; 0x4796 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    47b0:	ff 91       	pop	r31
    47b2:	ef 91       	pop	r30
    47b4:	9f 91       	pop	r25
    47b6:	8f 91       	pop	r24
    47b8:	3f 91       	pop	r19
    47ba:	2f 91       	pop	r18
    47bc:	0f 90       	pop	r0
    47be:	0b be       	out	0x3b, r0	; 59
    47c0:	0f 90       	pop	r0
    47c2:	08 be       	out	0x38, r0	; 56
    47c4:	0f 90       	pop	r0
    47c6:	0f be       	out	0x3f, r0	; 63
    47c8:	0f 90       	pop	r0
    47ca:	1f 90       	pop	r1
    47cc:	18 95       	reti

000047ce <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    47ce:	fc 01       	movw	r30, r24
    47d0:	84 81       	ldd	r24, Z+4	; 0x04
    47d2:	95 81       	ldd	r25, Z+5	; 0x05
    47d4:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
		}
    47d8:	90 e0       	ldi	r25, 0x00	; 0
    47da:	08 95       	ret

000047dc <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    47dc:	fc 01       	movw	r30, r24
    47de:	84 81       	ldd	r24, Z+4	; 0x04
    47e0:	95 81       	ldd	r25, Z+5	; 0x05
    47e2:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    47e6:	91 e0       	ldi	r25, 0x01	; 1
    47e8:	81 11       	cpse	r24, r1
    47ea:	01 c0       	rjmp	.+2      	; 0x47ee <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    47ec:	90 e0       	ldi	r25, 0x00	; 0
		}
    47ee:	89 2f       	mov	r24, r25
    47f0:	08 95       	ret

000047f2 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    47f2:	fc 01       	movw	r30, r24
    47f4:	84 81       	ldd	r24, Z+4	; 0x04
    47f6:	95 81       	ldd	r25, Z+5	; 0x05
    47f8:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    47fc:	91 e0       	ldi	r25, 0x01	; 1
    47fe:	81 11       	cpse	r24, r1
    4800:	90 e0       	ldi	r25, 0x00	; 0
		}
    4802:	89 2f       	mov	r24, r25
    4804:	08 95       	ret

00004806 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4806:	fc 01       	movw	r30, r24
    4808:	84 81       	ldd	r24, Z+4	; 0x04
    480a:	95 81       	ldd	r25, Z+5	; 0x05
    480c:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
		}
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	08 95       	ret

00004814 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4814:	fc 01       	movw	r30, r24
    4816:	84 81       	ldd	r24, Z+4	; 0x04
    4818:	95 81       	ldd	r25, Z+5	; 0x05
    481a:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    481e:	91 e0       	ldi	r25, 0x01	; 1
    4820:	81 11       	cpse	r24, r1
    4822:	01 c0       	rjmp	.+2      	; 0x4826 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    4824:	90 e0       	ldi	r25, 0x00	; 0
		}
    4826:	89 2f       	mov	r24, r25
    4828:	08 95       	ret

0000482a <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    482a:	fc 01       	movw	r30, r24
    482c:	84 81       	ldd	r24, Z+4	; 0x04
    482e:	95 81       	ldd	r25, Z+5	; 0x05
    4830:	0e 94 dc 14 	call	0x29b8	; 0x29b8 <uxQueueMessagesWaitingFromISR>
    4834:	91 e0       	ldi	r25, 0x01	; 1
    4836:	81 11       	cpse	r24, r1
    4838:	90 e0       	ldi	r25, 0x00	; 0
		}
    483a:	89 2f       	mov	r24, r25
    483c:	08 95       	ret

0000483e <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    483e:	fc 01       	movw	r30, r24
    4840:	84 81       	ldd	r24, Z+4	; 0x04
    4842:	95 81       	ldd	r25, Z+5	; 0x05
    4844:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
		}
    4848:	90 e0       	ldi	r25, 0x00	; 0
    484a:	08 95       	ret

0000484c <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    484c:	fc 01       	movw	r30, r24
    484e:	84 81       	ldd	r24, Z+4	; 0x04
    4850:	95 81       	ldd	r25, Z+5	; 0x05
    4852:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    4856:	91 e0       	ldi	r25, 0x01	; 1
    4858:	81 11       	cpse	r24, r1
    485a:	01 c0       	rjmp	.+2      	; 0x485e <_ZN9frt_queueIjE9not_emptyEv+0x12>
    485c:	90 e0       	ldi	r25, 0x00	; 0
		}
    485e:	89 2f       	mov	r24, r25
    4860:	08 95       	ret

00004862 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4862:	fc 01       	movw	r30, r24
    4864:	84 81       	ldd	r24, Z+4	; 0x04
    4866:	95 81       	ldd	r25, Z+5	; 0x05
    4868:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    486c:	91 e0       	ldi	r25, 0x01	; 1
    486e:	81 11       	cpse	r24, r1
    4870:	90 e0       	ldi	r25, 0x00	; 0
		}
    4872:	89 2f       	mov	r24, r25
    4874:	08 95       	ret

00004876 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4876:	fc 01       	movw	r30, r24
    4878:	84 81       	ldd	r24, Z+4	; 0x04
    487a:	95 81       	ldd	r25, Z+5	; 0x05
    487c:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
		}
    4880:	90 e0       	ldi	r25, 0x00	; 0
    4882:	08 95       	ret

00004884 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4884:	fc 01       	movw	r30, r24
    4886:	84 81       	ldd	r24, Z+4	; 0x04
    4888:	95 81       	ldd	r25, Z+5	; 0x05
    488a:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    488e:	91 e0       	ldi	r25, 0x01	; 1
    4890:	81 11       	cpse	r24, r1
    4892:	01 c0       	rjmp	.+2      	; 0x4896 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4894:	90 e0       	ldi	r25, 0x00	; 0
		}
    4896:	89 2f       	mov	r24, r25
    4898:	08 95       	ret

0000489a <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    489a:	fc 01       	movw	r30, r24
    489c:	84 81       	ldd	r24, Z+4	; 0x04
    489e:	95 81       	ldd	r25, Z+5	; 0x05
    48a0:	0e 94 d4 14 	call	0x29a8	; 0x29a8 <uxQueueMessagesWaiting>
    48a4:	91 e0       	ldi	r25, 0x01	; 1
    48a6:	81 11       	cpse	r24, r1
    48a8:	90 e0       	ldi	r25, 0x00	; 0
		}
    48aa:	89 2f       	mov	r24, r25
    48ac:	08 95       	ret

000048ae <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    48ae:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    48b0:	01 e0       	ldi	r16, 0x01	; 1
    48b2:	2f ef       	ldi	r18, 0xFF	; 255
    48b4:	3f ef       	ldi	r19, 0xFF	; 255
    48b6:	a9 01       	movw	r20, r18
    48b8:	fc 01       	movw	r30, r24
    48ba:	84 81       	ldd	r24, Z+4	; 0x04
    48bc:	95 81       	ldd	r25, Z+5	; 0x05
    48be:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    48c2:	0f 91       	pop	r16
    48c4:	08 95       	ret

000048c6 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    48c6:	0f 93       	push	r16
    48c8:	cf 93       	push	r28
    48ca:	df 93       	push	r29
    48cc:	1f 92       	push	r1
    48ce:	1f 92       	push	r1
    48d0:	cd b7       	in	r28, 0x3d	; 61
    48d2:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    48d4:	01 e0       	ldi	r16, 0x01	; 1
    48d6:	2f ef       	ldi	r18, 0xFF	; 255
    48d8:	3f ef       	ldi	r19, 0xFF	; 255
    48da:	a9 01       	movw	r20, r18
    48dc:	be 01       	movw	r22, r28
    48de:	6f 5f       	subi	r22, 0xFF	; 255
    48e0:	7f 4f       	sbci	r23, 0xFF	; 255
    48e2:	fc 01       	movw	r30, r24
    48e4:	84 81       	ldd	r24, Z+4	; 0x04
    48e6:	95 81       	ldd	r25, Z+5	; 0x05
    48e8:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	9a 81       	ldd	r25, Y+2	; 0x02
    48f0:	0f 90       	pop	r0
    48f2:	0f 90       	pop	r0
    48f4:	df 91       	pop	r29
    48f6:	cf 91       	pop	r28
    48f8:	0f 91       	pop	r16
    48fa:	08 95       	ret

000048fc <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    48fc:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    48fe:	00 e0       	ldi	r16, 0x00	; 0
    4900:	2f ef       	ldi	r18, 0xFF	; 255
    4902:	3f ef       	ldi	r19, 0xFF	; 255
    4904:	a9 01       	movw	r20, r18
    4906:	fc 01       	movw	r30, r24
    4908:	84 81       	ldd	r24, Z+4	; 0x04
    490a:	95 81       	ldd	r25, Z+5	; 0x05
    490c:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    4910:	0f 91       	pop	r16
    4912:	08 95       	ret

00004914 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4914:	0f 93       	push	r16
    4916:	cf 93       	push	r28
    4918:	df 93       	push	r29
    491a:	1f 92       	push	r1
    491c:	1f 92       	push	r1
    491e:	cd b7       	in	r28, 0x3d	; 61
    4920:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4922:	00 e0       	ldi	r16, 0x00	; 0
    4924:	2f ef       	ldi	r18, 0xFF	; 255
    4926:	3f ef       	ldi	r19, 0xFF	; 255
    4928:	a9 01       	movw	r20, r18
    492a:	be 01       	movw	r22, r28
    492c:	6f 5f       	subi	r22, 0xFF	; 255
    492e:	7f 4f       	sbci	r23, 0xFF	; 255
    4930:	fc 01       	movw	r30, r24
    4932:	84 81       	ldd	r24, Z+4	; 0x04
    4934:	95 81       	ldd	r25, Z+5	; 0x05
    4936:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    493a:	89 81       	ldd	r24, Y+1	; 0x01
    493c:	9a 81       	ldd	r25, Y+2	; 0x02
    493e:	0f 90       	pop	r0
    4940:	0f 90       	pop	r0
    4942:	df 91       	pop	r29
    4944:	cf 91       	pop	r28
    4946:	0f 91       	pop	r16
    4948:	08 95       	ret

0000494a <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    494a:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    494c:	01 e0       	ldi	r16, 0x01	; 1
    494e:	2f ef       	ldi	r18, 0xFF	; 255
    4950:	3f ef       	ldi	r19, 0xFF	; 255
    4952:	a9 01       	movw	r20, r18
    4954:	fc 01       	movw	r30, r24
    4956:	84 81       	ldd	r24, Z+4	; 0x04
    4958:	95 81       	ldd	r25, Z+5	; 0x05
    495a:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    495e:	0f 91       	pop	r16
    4960:	08 95       	ret

00004962 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4962:	0f 93       	push	r16
    4964:	cf 93       	push	r28
    4966:	df 93       	push	r29
    4968:	1f 92       	push	r1
    496a:	1f 92       	push	r1
    496c:	cd b7       	in	r28, 0x3d	; 61
    496e:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4970:	01 e0       	ldi	r16, 0x01	; 1
    4972:	2f ef       	ldi	r18, 0xFF	; 255
    4974:	3f ef       	ldi	r19, 0xFF	; 255
    4976:	a9 01       	movw	r20, r18
    4978:	be 01       	movw	r22, r28
    497a:	6f 5f       	subi	r22, 0xFF	; 255
    497c:	7f 4f       	sbci	r23, 0xFF	; 255
    497e:	fc 01       	movw	r30, r24
    4980:	84 81       	ldd	r24, Z+4	; 0x04
    4982:	95 81       	ldd	r25, Z+5	; 0x05
    4984:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    4988:	89 81       	ldd	r24, Y+1	; 0x01
    498a:	9a 81       	ldd	r25, Y+2	; 0x02
    498c:	0f 90       	pop	r0
    498e:	0f 90       	pop	r0
    4990:	df 91       	pop	r29
    4992:	cf 91       	pop	r28
    4994:	0f 91       	pop	r16
    4996:	08 95       	ret

00004998 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4998:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    499a:	00 e0       	ldi	r16, 0x00	; 0
    499c:	2f ef       	ldi	r18, 0xFF	; 255
    499e:	3f ef       	ldi	r19, 0xFF	; 255
    49a0:	a9 01       	movw	r20, r18
    49a2:	fc 01       	movw	r30, r24
    49a4:	84 81       	ldd	r24, Z+4	; 0x04
    49a6:	95 81       	ldd	r25, Z+5	; 0x05
    49a8:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
}
    49ac:	0f 91       	pop	r16
    49ae:	08 95       	ret

000049b0 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    49b0:	0f 93       	push	r16
    49b2:	cf 93       	push	r28
    49b4:	df 93       	push	r29
    49b6:	1f 92       	push	r1
    49b8:	1f 92       	push	r1
    49ba:	cd b7       	in	r28, 0x3d	; 61
    49bc:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    49be:	00 e0       	ldi	r16, 0x00	; 0
    49c0:	2f ef       	ldi	r18, 0xFF	; 255
    49c2:	3f ef       	ldi	r19, 0xFF	; 255
    49c4:	a9 01       	movw	r20, r18
    49c6:	be 01       	movw	r22, r28
    49c8:	6f 5f       	subi	r22, 0xFF	; 255
    49ca:	7f 4f       	sbci	r23, 0xFF	; 255
    49cc:	fc 01       	movw	r30, r24
    49ce:	84 81       	ldd	r24, Z+4	; 0x04
    49d0:	95 81       	ldd	r25, Z+5	; 0x05
    49d2:	0e 94 e3 13 	call	0x27c6	; 0x27c6 <xQueueGenericReceive>
	return (recv_item);
}
    49d6:	89 81       	ldd	r24, Y+1	; 0x01
    49d8:	9a 81       	ldd	r25, Y+2	; 0x02
    49da:	0f 90       	pop	r0
    49dc:	0f 90       	pop	r0
    49de:	df 91       	pop	r29
    49e0:	cf 91       	pop	r28
    49e2:	0f 91       	pop	r16
    49e4:	08 95       	ret

000049e6 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    49e6:	cf 93       	push	r28
    49e8:	df 93       	push	r29
    49ea:	1f 92       	push	r1
    49ec:	cd b7       	in	r28, 0x3d	; 61
    49ee:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    49f0:	ae 01       	movw	r20, r28
    49f2:	4f 5f       	subi	r20, 0xFF	; 255
    49f4:	5f 4f       	sbci	r21, 0xFF	; 255
    49f6:	fc 01       	movw	r30, r24
    49f8:	84 81       	ldd	r24, Z+4	; 0x04
    49fa:	95 81       	ldd	r25, Z+5	; 0x05
    49fc:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
}
    4a00:	0f 90       	pop	r0
    4a02:	df 91       	pop	r29
    4a04:	cf 91       	pop	r28
    4a06:	08 95       	ret

00004a08 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4a08:	cf 93       	push	r28
    4a0a:	df 93       	push	r29
    4a0c:	00 d0       	rcall	.+0      	; 0x4a0e <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4a0e:	cd b7       	in	r28, 0x3d	; 61
    4a10:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4a12:	ae 01       	movw	r20, r28
    4a14:	4d 5f       	subi	r20, 0xFD	; 253
    4a16:	5f 4f       	sbci	r21, 0xFF	; 255
    4a18:	be 01       	movw	r22, r28
    4a1a:	6f 5f       	subi	r22, 0xFF	; 255
    4a1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a1e:	fc 01       	movw	r30, r24
    4a20:	84 81       	ldd	r24, Z+4	; 0x04
    4a22:	95 81       	ldd	r25, Z+5	; 0x05
    4a24:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
	return (recv_item);
}
    4a28:	89 81       	ldd	r24, Y+1	; 0x01
    4a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4a2c:	23 96       	adiw	r28, 0x03	; 3
    4a2e:	cd bf       	out	0x3d, r28	; 61
    4a30:	de bf       	out	0x3e, r29	; 62
    4a32:	df 91       	pop	r29
    4a34:	cf 91       	pop	r28
    4a36:	08 95       	ret

00004a38 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4a38:	cf 93       	push	r28
    4a3a:	df 93       	push	r29
    4a3c:	1f 92       	push	r1
    4a3e:	cd b7       	in	r28, 0x3d	; 61
    4a40:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4a42:	ae 01       	movw	r20, r28
    4a44:	4f 5f       	subi	r20, 0xFF	; 255
    4a46:	5f 4f       	sbci	r21, 0xFF	; 255
    4a48:	fc 01       	movw	r30, r24
    4a4a:	84 81       	ldd	r24, Z+4	; 0x04
    4a4c:	95 81       	ldd	r25, Z+5	; 0x05
    4a4e:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
}
    4a52:	0f 90       	pop	r0
    4a54:	df 91       	pop	r29
    4a56:	cf 91       	pop	r28
    4a58:	08 95       	ret

00004a5a <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4a5a:	cf 93       	push	r28
    4a5c:	df 93       	push	r29
    4a5e:	00 d0       	rcall	.+0      	; 0x4a60 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4a60:	cd b7       	in	r28, 0x3d	; 61
    4a62:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4a64:	ae 01       	movw	r20, r28
    4a66:	4d 5f       	subi	r20, 0xFD	; 253
    4a68:	5f 4f       	sbci	r21, 0xFF	; 255
    4a6a:	be 01       	movw	r22, r28
    4a6c:	6f 5f       	subi	r22, 0xFF	; 255
    4a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    4a70:	fc 01       	movw	r30, r24
    4a72:	84 81       	ldd	r24, Z+4	; 0x04
    4a74:	95 81       	ldd	r25, Z+5	; 0x05
    4a76:	0e 94 a7 14 	call	0x294e	; 0x294e <xQueueReceiveFromISR>
	return (recv_item);
}
    4a7a:	89 81       	ldd	r24, Y+1	; 0x01
    4a7c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a7e:	23 96       	adiw	r28, 0x03	; 3
    4a80:	cd bf       	out	0x3d, r28	; 61
    4a82:	de bf       	out	0x3e, r29	; 62
    4a84:	df 91       	pop	r29
    4a86:	cf 91       	pop	r28
    4a88:	08 95       	ret

00004a8a <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4a8a:	cf 93       	push	r28
    4a8c:	df 93       	push	r29
    4a8e:	1f 92       	push	r1
    4a90:	cd b7       	in	r28, 0x3d	; 61
    4a92:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a94:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4a96:	21 e0       	ldi	r18, 0x01	; 1
    4a98:	ae 01       	movw	r20, r28
    4a9a:	4f 5f       	subi	r20, 0xFF	; 255
    4a9c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a9e:	fc 01       	movw	r30, r24
    4aa0:	84 81       	ldd	r24, Z+4	; 0x04
    4aa2:	95 81       	ldd	r25, Z+5	; 0x05
    4aa4:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4aa8:	91 e0       	ldi	r25, 0x01	; 1
    4aaa:	81 11       	cpse	r24, r1
    4aac:	01 c0       	rjmp	.+2      	; 0x4ab0 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4aae:	90 e0       	ldi	r25, 0x00	; 0
}
    4ab0:	89 2f       	mov	r24, r25
    4ab2:	0f 90       	pop	r0
    4ab4:	df 91       	pop	r29
    4ab6:	cf 91       	pop	r28
    4ab8:	08 95       	ret

00004aba <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4aba:	cf 93       	push	r28
    4abc:	df 93       	push	r29
    4abe:	1f 92       	push	r1
    4ac0:	cd b7       	in	r28, 0x3d	; 61
    4ac2:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4ac4:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4ac6:	20 e0       	ldi	r18, 0x00	; 0
    4ac8:	ae 01       	movw	r20, r28
    4aca:	4f 5f       	subi	r20, 0xFF	; 255
    4acc:	5f 4f       	sbci	r21, 0xFF	; 255
    4ace:	fc 01       	movw	r30, r24
    4ad0:	84 81       	ldd	r24, Z+4	; 0x04
    4ad2:	95 81       	ldd	r25, Z+5	; 0x05
    4ad4:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4ad8:	91 e0       	ldi	r25, 0x01	; 1
    4ada:	81 11       	cpse	r24, r1
    4adc:	01 c0       	rjmp	.+2      	; 0x4ae0 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4ade:	90 e0       	ldi	r25, 0x00	; 0
}
    4ae0:	89 2f       	mov	r24, r25
    4ae2:	0f 90       	pop	r0
    4ae4:	df 91       	pop	r29
    4ae6:	cf 91       	pop	r28
    4ae8:	08 95       	ret

00004aea <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4aea:	cf 93       	push	r28
    4aec:	df 93       	push	r29
    4aee:	1f 92       	push	r1
    4af0:	cd b7       	in	r28, 0x3d	; 61
    4af2:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4af4:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4af6:	21 e0       	ldi	r18, 0x01	; 1
    4af8:	ae 01       	movw	r20, r28
    4afa:	4f 5f       	subi	r20, 0xFF	; 255
    4afc:	5f 4f       	sbci	r21, 0xFF	; 255
    4afe:	fc 01       	movw	r30, r24
    4b00:	84 81       	ldd	r24, Z+4	; 0x04
    4b02:	95 81       	ldd	r25, Z+5	; 0x05
    4b04:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4b08:	91 e0       	ldi	r25, 0x01	; 1
    4b0a:	81 11       	cpse	r24, r1
    4b0c:	01 c0       	rjmp	.+2      	; 0x4b10 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4b0e:	90 e0       	ldi	r25, 0x00	; 0
}
    4b10:	89 2f       	mov	r24, r25
    4b12:	0f 90       	pop	r0
    4b14:	df 91       	pop	r29
    4b16:	cf 91       	pop	r28
    4b18:	08 95       	ret

00004b1a <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4b1a:	cf 93       	push	r28
    4b1c:	df 93       	push	r29
    4b1e:	1f 92       	push	r1
    4b20:	cd b7       	in	r28, 0x3d	; 61
    4b22:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4b24:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4b26:	20 e0       	ldi	r18, 0x00	; 0
    4b28:	ae 01       	movw	r20, r28
    4b2a:	4f 5f       	subi	r20, 0xFF	; 255
    4b2c:	5f 4f       	sbci	r21, 0xFF	; 255
    4b2e:	fc 01       	movw	r30, r24
    4b30:	84 81       	ldd	r24, Z+4	; 0x04
    4b32:	95 81       	ldd	r25, Z+5	; 0x05
    4b34:	0e 94 b7 13 	call	0x276e	; 0x276e <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4b38:	91 e0       	ldi	r25, 0x01	; 1
    4b3a:	81 11       	cpse	r24, r1
    4b3c:	01 c0       	rjmp	.+2      	; 0x4b40 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4b3e:	90 e0       	ldi	r25, 0x00	; 0
}
    4b40:	89 2f       	mov	r24, r25
    4b42:	0f 90       	pop	r0
    4b44:	df 91       	pop	r29
    4b46:	cf 91       	pop	r28
    4b48:	08 95       	ret

00004b4a <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4b4a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4b4c:	fc 01       	movw	r30, r24
    4b4e:	26 81       	ldd	r18, Z+6	; 0x06
    4b50:	37 81       	ldd	r19, Z+7	; 0x07
    4b52:	40 85       	ldd	r20, Z+8	; 0x08
    4b54:	51 85       	ldd	r21, Z+9	; 0x09
    4b56:	01 e0       	ldi	r16, 0x01	; 1
    4b58:	84 81       	ldd	r24, Z+4	; 0x04
    4b5a:	95 81       	ldd	r25, Z+5	; 0x05
    4b5c:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    4b60:	91 e0       	ldi	r25, 0x01	; 1
    4b62:	81 11       	cpse	r24, r1
    4b64:	01 c0       	rjmp	.+2      	; 0x4b68 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4b66:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b68:	89 2f       	mov	r24, r25
    4b6a:	0f 91       	pop	r16
    4b6c:	08 95       	ret

00004b6e <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4b6e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4b70:	fc 01       	movw	r30, r24
    4b72:	26 81       	ldd	r18, Z+6	; 0x06
    4b74:	37 81       	ldd	r19, Z+7	; 0x07
    4b76:	40 85       	ldd	r20, Z+8	; 0x08
    4b78:	51 85       	ldd	r21, Z+9	; 0x09
    4b7a:	00 e0       	ldi	r16, 0x00	; 0
    4b7c:	84 81       	ldd	r24, Z+4	; 0x04
    4b7e:	95 81       	ldd	r25, Z+5	; 0x05
    4b80:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    4b84:	91 e0       	ldi	r25, 0x01	; 1
    4b86:	81 11       	cpse	r24, r1
    4b88:	01 c0       	rjmp	.+2      	; 0x4b8c <_ZN9frt_queueIjE3putERKj+0x1e>
    4b8a:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b8c:	89 2f       	mov	r24, r25
    4b8e:	0f 91       	pop	r16
    4b90:	08 95       	ret

00004b92 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4b92:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4b94:	fc 01       	movw	r30, r24
    4b96:	26 81       	ldd	r18, Z+6	; 0x06
    4b98:	37 81       	ldd	r19, Z+7	; 0x07
    4b9a:	40 85       	ldd	r20, Z+8	; 0x08
    4b9c:	51 85       	ldd	r21, Z+9	; 0x09
    4b9e:	01 e0       	ldi	r16, 0x01	; 1
    4ba0:	84 81       	ldd	r24, Z+4	; 0x04
    4ba2:	95 81       	ldd	r25, Z+5	; 0x05
    4ba4:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    4ba8:	91 e0       	ldi	r25, 0x01	; 1
    4baa:	81 11       	cpse	r24, r1
    4bac:	01 c0       	rjmp	.+2      	; 0x4bb0 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4bae:	90 e0       	ldi	r25, 0x00	; 0
		}
    4bb0:	89 2f       	mov	r24, r25
    4bb2:	0f 91       	pop	r16
    4bb4:	08 95       	ret

00004bb6 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4bb6:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4bb8:	fc 01       	movw	r30, r24
    4bba:	26 81       	ldd	r18, Z+6	; 0x06
    4bbc:	37 81       	ldd	r19, Z+7	; 0x07
    4bbe:	40 85       	ldd	r20, Z+8	; 0x08
    4bc0:	51 85       	ldd	r21, Z+9	; 0x09
    4bc2:	00 e0       	ldi	r16, 0x00	; 0
    4bc4:	84 81       	ldd	r24, Z+4	; 0x04
    4bc6:	95 81       	ldd	r25, Z+5	; 0x05
    4bc8:	0e 94 1c 13 	call	0x2638	; 0x2638 <xQueueGenericSend>
    4bcc:	91 e0       	ldi	r25, 0x01	; 1
    4bce:	81 11       	cpse	r24, r1
    4bd0:	01 c0       	rjmp	.+2      	; 0x4bd4 <_ZN9frt_queueIiE3putERKi+0x1e>
    4bd2:	90 e0       	ldi	r25, 0x00	; 0
		}
    4bd4:	89 2f       	mov	r24, r25
    4bd6:	0f 91       	pop	r16
    4bd8:	08 95       	ret

00004bda <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4bda:	0f 93       	push	r16
    4bdc:	cf 93       	push	r28
    4bde:	df 93       	push	r29
    4be0:	1f 92       	push	r1
    4be2:	cd b7       	in	r28, 0x3d	; 61
    4be4:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4be6:	2f b7       	in	r18, 0x3f	; 63
    4be8:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4bea:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4bec:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4bee:	fc 01       	movw	r30, r24
    4bf0:	08 ed       	ldi	r16, 0xD8	; 216
    4bf2:	04 bf       	out	0x34, r16	; 52
    4bf4:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4bf6:	89 81       	ldd	r24, Y+1	; 0x01
    4bf8:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4bfa:	0f 90       	pop	r0
    4bfc:	df 91       	pop	r29
    4bfe:	cf 91       	pop	r28
    4c00:	0f 91       	pop	r16
    4c02:	08 95       	ret

00004c04 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4c04:	ef 92       	push	r14
    4c06:	ff 92       	push	r15
    4c08:	0f 93       	push	r16
    4c0a:	1f 93       	push	r17
    4c0c:	cf 93       	push	r28
    4c0e:	df 93       	push	r29
    4c10:	cd b7       	in	r28, 0x3d	; 61
    4c12:	de b7       	in	r29, 0x3e	; 62
    4c14:	c9 54       	subi	r28, 0x49	; 73
    4c16:	d1 09       	sbc	r29, r1
    4c18:	cd bf       	out	0x3d, r28	; 61
    4c1a:	de bf       	out	0x3e, r29	; 62
	cli();
    4c1c:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4c1e:	e0 e5       	ldi	r30, 0x50	; 80
    4c20:	f0 e0       	ldi	r31, 0x00	; 0
    4c22:	80 81       	ld	r24, Z
    4c24:	82 60       	ori	r24, 0x02	; 2
    4c26:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4c28:	81 81       	ldd	r24, Z+1	; 0x01
    4c2a:	81 ff       	sbrs	r24, 1
    4c2c:	fd cf       	rjmp	.-6      	; 0x4c28 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4c2e:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4c32:	68 7f       	andi	r22, 0xF8	; 248
    4c34:	61 60       	ori	r22, 0x01	; 1
    4c36:	80 e4       	ldi	r24, 0x40	; 64
    4c38:	90 e0       	ldi	r25, 0x00	; 0
    4c3a:	0e 94 ed 25 	call	0x4bda	; 0x4bda <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4c3e:	e0 e5       	ldi	r30, 0x50	; 80
    4c40:	f0 e0       	ldi	r31, 0x00	; 0
    4c42:	80 81       	ld	r24, Z
    4c44:	8e 7f       	andi	r24, 0xFE	; 254
    4c46:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4c48:	9d ef       	ldi	r25, 0xFD	; 253
    4c4a:	88 ed       	ldi	r24, 0xD8	; 216
    4c4c:	08 b6       	in	r0, 0x38	; 56
    4c4e:	18 be       	out	0x38, r1	; 56
    4c50:	84 bf       	out	0x34, r24	; 52
    4c52:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4c56:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4c58:	40 ea       	ldi	r20, 0xA0	; 160
    4c5a:	5a e0       	ldi	r21, 0x0A	; 10
    4c5c:	60 e0       	ldi	r22, 0x00	; 0
    4c5e:	70 e0       	ldi	r23, 0x00	; 0
    4c60:	ce 01       	movw	r24, r28
    4c62:	01 96       	adiw	r24, 0x01	; 1
    4c64:	0e 94 91 21 	call	0x4322	; 0x4322 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4c68:	67 e0       	ldi	r22, 0x07	; 7
    4c6a:	ce 01       	movw	r24, r28
    4c6c:	01 96       	adiw	r24, 0x01	; 1
    4c6e:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    4c72:	8c 01       	movw	r16, r24
    4c74:	6d eb       	ldi	r22, 0xBD	; 189
    4c76:	71 e2       	ldi	r23, 0x21	; 33
    4c78:	0e 94 7a 1f 	call	0x3ef4	; 0x3ef4 <_ZN8emstream4putsEPKc>
    4c7c:	66 e0       	ldi	r22, 0x06	; 6
    4c7e:	c8 01       	movw	r24, r16
    4c80:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
    4c84:	66 e0       	ldi	r22, 0x06	; 6
    4c86:	0e 94 b1 1f 	call	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4c8a:	8e 01       	movw	r16, r28
    4c8c:	0f 5f       	subi	r16, 0xFF	; 255
    4c8e:	1f 4f       	sbci	r17, 0xFF	; 255
    4c90:	20 e3       	ldi	r18, 0x30	; 48
    4c92:	32 ef       	ldi	r19, 0xF2	; 242
    4c94:	40 e0       	ldi	r20, 0x00	; 0
    4c96:	50 e0       	ldi	r21, 0x00	; 0
    4c98:	60 ea       	ldi	r22, 0xA0	; 160
    4c9a:	74 e0       	ldi	r23, 0x04	; 4
    4c9c:	ce 01       	movw	r24, r28
    4c9e:	4e 96       	adiw	r24, 0x1e	; 30
    4ca0:	0e 94 b7 08 	call	0x116e	; 0x116e <_ZN9I2CMasterC1EP10TWI_structmP8emstream>

	// I2CAgent i2cAgent();
	
	MMA8451 mma8451(&i2c, &ser_dev);
    4ca4:	a8 01       	movw	r20, r16
    4ca6:	be 01       	movw	r22, r28
    4ca8:	62 5e       	subi	r22, 0xE2	; 226
    4caa:	7f 4f       	sbci	r23, 0xFF	; 255
    4cac:	ce 01       	movw	r24, r28
    4cae:	c7 96       	adiw	r24, 0x37	; 55
    4cb0:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <_ZN7MMA8451C1EP9I2CMasterP8emstream>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4cb4:	82 e1       	ldi	r24, 0x12	; 18
    4cb6:	90 e0       	ldi	r25, 0x00	; 0
    4cb8:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    4cbc:	20 e8       	ldi	r18, 0x80	; 128
    4cbe:	30 e0       	ldi	r19, 0x00	; 0
    4cc0:	40 e0       	ldi	r20, 0x00	; 0
    4cc2:	6c ed       	ldi	r22, 0xDC	; 220
    4cc4:	71 e2       	ldi	r23, 0x21	; 33
    4cc6:	0e 94 98 0c 	call	0x1930	; 0x1930 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sensor ("Sensor", task_priority (2), 128, &ser_dev, &mma8451);
    4cca:	88 e1       	ldi	r24, 0x18	; 24
    4ccc:	90 e0       	ldi	r25, 0x00	; 0
    4cce:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <_Znwj>
    4cd2:	9e 01       	movw	r18, r28
    4cd4:	29 5c       	subi	r18, 0xC9	; 201
    4cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    4cd8:	79 01       	movw	r14, r18
    4cda:	20 e8       	ldi	r18, 0x80	; 128
    4cdc:	30 e0       	ldi	r19, 0x00	; 0
    4cde:	42 e0       	ldi	r20, 0x02	; 2
    4ce0:	64 ee       	ldi	r22, 0xE4	; 228
    4ce2:	71 e2       	ldi	r23, 0x21	; 33
    4ce4:	0e 94 7b 0c 	call	0x18f6	; 0x18f6 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4ce8:	87 e0       	ldi	r24, 0x07	; 7
    4cea:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4cee:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4cf0:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <vTaskStartScheduler>
}
    4cf4:	80 e0       	ldi	r24, 0x00	; 0
    4cf6:	90 e0       	ldi	r25, 0x00	; 0
    4cf8:	c7 5b       	subi	r28, 0xB7	; 183
    4cfa:	df 4f       	sbci	r29, 0xFF	; 255
    4cfc:	cd bf       	out	0x3d, r28	; 61
    4cfe:	de bf       	out	0x3e, r29	; 62
    4d00:	df 91       	pop	r29
    4d02:	cf 91       	pop	r28
    4d04:	1f 91       	pop	r17
    4d06:	0f 91       	pop	r16
    4d08:	ff 90       	pop	r15
    4d0a:	ef 90       	pop	r14
    4d0c:	08 95       	ret

00004d0e <_GLOBAL__sub_I_counter>:
    4d0e:	cf 92       	push	r12
    4d10:	df 92       	push	r13
    4d12:	ef 92       	push	r14
    4d14:	ff 92       	push	r15
    4d16:	0f 93       	push	r16
    4d18:	1f 93       	push	r17
    4d1a:	cf 93       	push	r28
    4d1c:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sensor.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4d1e:	0a e0       	ldi	r16, 0x0A	; 10
    4d20:	10 e0       	ldi	r17, 0x00	; 0
    4d22:	20 e0       	ldi	r18, 0x00	; 0
    4d24:	30 e0       	ldi	r19, 0x00	; 0
    4d26:	40 e0       	ldi	r20, 0x00	; 0
    4d28:	50 e0       	ldi	r21, 0x00	; 0
    4d2a:	60 e2       	ldi	r22, 0x20	; 32
    4d2c:	70 e0       	ldi	r23, 0x00	; 0
    4d2e:	80 ef       	ldi	r24, 0xF0	; 240
    4d30:	92 e3       	ldi	r25, 0x32	; 50
    4d32:	0e 94 32 1d 	call	0x3a64	; 0x3a64 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4d36:	c6 ee       	ldi	r28, 0xE6	; 230
    4d38:	d2 e3       	ldi	r29, 0x32	; 50
    4d3a:	1a 82       	std	Y+2, r1	; 0x02
    4d3c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d3e:	8f ee       	ldi	r24, 0xEF	; 239
    4d40:	91 e2       	ldi	r25, 0x21	; 33
    4d42:	88 83       	st	Y, r24
    4d44:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d46:	40 e0       	ldi	r20, 0x00	; 0
    4d48:	62 e0       	ldi	r22, 0x02	; 2
    4d4a:	8f ef       	ldi	r24, 0xFF	; 255
    4d4c:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    4d50:	8c 83       	std	Y+4, r24	; 0x04
    4d52:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d54:	0f 2e       	mov	r0, r31
    4d56:	fa e0       	ldi	r31, 0x0A	; 10
    4d58:	cf 2e       	mov	r12, r31
    4d5a:	d1 2c       	mov	r13, r1
    4d5c:	e1 2c       	mov	r14, r1
    4d5e:	f1 2c       	mov	r15, r1
    4d60:	f0 2d       	mov	r31, r0
    4d62:	ce 82       	std	Y+6, r12	; 0x06
    4d64:	df 82       	std	Y+7, r13	; 0x07
    4d66:	e8 86       	std	Y+8, r14	; 0x08
    4d68:	f9 86       	std	Y+9, r15	; 0x09
    4d6a:	cc ed       	ldi	r28, 0xDC	; 220
    4d6c:	d2 e3       	ldi	r29, 0x32	; 50
    4d6e:	1a 82       	std	Y+2, r1	; 0x02
    4d70:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d72:	03 e1       	ldi	r16, 0x13	; 19
    4d74:	12 e2       	ldi	r17, 0x22	; 34
    4d76:	08 83       	st	Y, r16
    4d78:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d7a:	40 e0       	ldi	r20, 0x00	; 0
    4d7c:	62 e0       	ldi	r22, 0x02	; 2
    4d7e:	8f ef       	ldi	r24, 0xFF	; 255
    4d80:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    4d84:	8c 83       	std	Y+4, r24	; 0x04
    4d86:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d88:	ce 82       	std	Y+6, r12	; 0x06
    4d8a:	df 82       	std	Y+7, r13	; 0x07
    4d8c:	e8 86       	std	Y+8, r14	; 0x08
    4d8e:	f9 86       	std	Y+9, r15	; 0x09
    4d90:	c2 ed       	ldi	r28, 0xD2	; 210
    4d92:	d2 e3       	ldi	r29, 0x32	; 50
    4d94:	1a 82       	std	Y+2, r1	; 0x02
    4d96:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d98:	08 83       	st	Y, r16
    4d9a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d9c:	40 e0       	ldi	r20, 0x00	; 0
    4d9e:	62 e0       	ldi	r22, 0x02	; 2
    4da0:	8f ef       	ldi	r24, 0xFF	; 255
    4da2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    4da6:	8c 83       	std	Y+4, r24	; 0x04
    4da8:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4daa:	ce 82       	std	Y+6, r12	; 0x06
    4dac:	df 82       	std	Y+7, r13	; 0x07
    4dae:	e8 86       	std	Y+8, r14	; 0x08
    4db0:	f9 86       	std	Y+9, r15	; 0x09
    4db2:	c8 ec       	ldi	r28, 0xC8	; 200
    4db4:	d2 e3       	ldi	r29, 0x32	; 50
    4db6:	1a 82       	std	Y+2, r1	; 0x02
    4db8:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4dba:	08 83       	st	Y, r16
    4dbc:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4dbe:	40 e0       	ldi	r20, 0x00	; 0
    4dc0:	62 e0       	ldi	r22, 0x02	; 2
    4dc2:	8f ef       	ldi	r24, 0xFF	; 255
    4dc4:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    4dc8:	8c 83       	std	Y+4, r24	; 0x04
    4dca:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4dcc:	ce 82       	std	Y+6, r12	; 0x06
    4dce:	df 82       	std	Y+7, r13	; 0x07
    4dd0:	e8 86       	std	Y+8, r14	; 0x08
    4dd2:	f9 86       	std	Y+9, r15	; 0x09
    4dd4:	ce eb       	ldi	r28, 0xBE	; 190
    4dd6:	d2 e3       	ldi	r29, 0x32	; 50
    4dd8:	1a 82       	std	Y+2, r1	; 0x02
    4dda:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ddc:	08 83       	st	Y, r16
    4dde:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4de0:	40 e0       	ldi	r20, 0x00	; 0
    4de2:	62 e0       	ldi	r22, 0x02	; 2
    4de4:	8f ef       	ldi	r24, 0xFF	; 255
    4de6:	0e 94 ee 12 	call	0x25dc	; 0x25dc <xQueueGenericCreate>
    4dea:	8c 83       	std	Y+4, r24	; 0x04
    4dec:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4dee:	ce 82       	std	Y+6, r12	; 0x06
    4df0:	df 82       	std	Y+7, r13	; 0x07
    4df2:	e8 86       	std	Y+8, r14	; 0x08
    4df4:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4df6:	df 91       	pop	r29
    4df8:	cf 91       	pop	r28
    4dfa:	1f 91       	pop	r17
    4dfc:	0f 91       	pop	r16
    4dfe:	ff 90       	pop	r15
    4e00:	ef 90       	pop	r14
    4e02:	df 90       	pop	r13
    4e04:	cf 90       	pop	r12
    4e06:	08 95       	ret

00004e08 <__mulsi3>:
    4e08:	db 01       	movw	r26, r22
    4e0a:	8f 93       	push	r24
    4e0c:	9f 93       	push	r25
    4e0e:	0e 94 5e 27 	call	0x4ebc	; 0x4ebc <__muluhisi3>
    4e12:	bf 91       	pop	r27
    4e14:	af 91       	pop	r26
    4e16:	a2 9f       	mul	r26, r18
    4e18:	80 0d       	add	r24, r0
    4e1a:	91 1d       	adc	r25, r1
    4e1c:	a3 9f       	mul	r26, r19
    4e1e:	90 0d       	add	r25, r0
    4e20:	b2 9f       	mul	r27, r18
    4e22:	90 0d       	add	r25, r0
    4e24:	11 24       	eor	r1, r1
    4e26:	08 95       	ret

00004e28 <__udivmodsi4>:
    4e28:	a1 e2       	ldi	r26, 0x21	; 33
    4e2a:	1a 2e       	mov	r1, r26
    4e2c:	aa 1b       	sub	r26, r26
    4e2e:	bb 1b       	sub	r27, r27
    4e30:	fd 01       	movw	r30, r26
    4e32:	0d c0       	rjmp	.+26     	; 0x4e4e <__udivmodsi4_ep>

00004e34 <__udivmodsi4_loop>:
    4e34:	aa 1f       	adc	r26, r26
    4e36:	bb 1f       	adc	r27, r27
    4e38:	ee 1f       	adc	r30, r30
    4e3a:	ff 1f       	adc	r31, r31
    4e3c:	a2 17       	cp	r26, r18
    4e3e:	b3 07       	cpc	r27, r19
    4e40:	e4 07       	cpc	r30, r20
    4e42:	f5 07       	cpc	r31, r21
    4e44:	20 f0       	brcs	.+8      	; 0x4e4e <__udivmodsi4_ep>
    4e46:	a2 1b       	sub	r26, r18
    4e48:	b3 0b       	sbc	r27, r19
    4e4a:	e4 0b       	sbc	r30, r20
    4e4c:	f5 0b       	sbc	r31, r21

00004e4e <__udivmodsi4_ep>:
    4e4e:	66 1f       	adc	r22, r22
    4e50:	77 1f       	adc	r23, r23
    4e52:	88 1f       	adc	r24, r24
    4e54:	99 1f       	adc	r25, r25
    4e56:	1a 94       	dec	r1
    4e58:	69 f7       	brne	.-38     	; 0x4e34 <__udivmodsi4_loop>
    4e5a:	60 95       	com	r22
    4e5c:	70 95       	com	r23
    4e5e:	80 95       	com	r24
    4e60:	90 95       	com	r25
    4e62:	9b 01       	movw	r18, r22
    4e64:	ac 01       	movw	r20, r24
    4e66:	bd 01       	movw	r22, r26
    4e68:	cf 01       	movw	r24, r30
    4e6a:	08 95       	ret

00004e6c <__divmodsi4>:
    4e6c:	05 2e       	mov	r0, r21
    4e6e:	97 fb       	bst	r25, 7
    4e70:	1e f4       	brtc	.+6      	; 0x4e78 <__divmodsi4+0xc>
    4e72:	00 94       	com	r0
    4e74:	0e 94 4d 27 	call	0x4e9a	; 0x4e9a <__negsi2>
    4e78:	57 fd       	sbrc	r21, 7
    4e7a:	07 d0       	rcall	.+14     	; 0x4e8a <__divmodsi4_neg2>
    4e7c:	0e 94 14 27 	call	0x4e28	; 0x4e28 <__udivmodsi4>
    4e80:	07 fc       	sbrc	r0, 7
    4e82:	03 d0       	rcall	.+6      	; 0x4e8a <__divmodsi4_neg2>
    4e84:	4e f4       	brtc	.+18     	; 0x4e98 <__divmodsi4_exit>
    4e86:	0c 94 4d 27 	jmp	0x4e9a	; 0x4e9a <__negsi2>

00004e8a <__divmodsi4_neg2>:
    4e8a:	50 95       	com	r21
    4e8c:	40 95       	com	r20
    4e8e:	30 95       	com	r19
    4e90:	21 95       	neg	r18
    4e92:	3f 4f       	sbci	r19, 0xFF	; 255
    4e94:	4f 4f       	sbci	r20, 0xFF	; 255
    4e96:	5f 4f       	sbci	r21, 0xFF	; 255

00004e98 <__divmodsi4_exit>:
    4e98:	08 95       	ret

00004e9a <__negsi2>:
    4e9a:	90 95       	com	r25
    4e9c:	80 95       	com	r24
    4e9e:	70 95       	com	r23
    4ea0:	61 95       	neg	r22
    4ea2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ea4:	8f 4f       	sbci	r24, 0xFF	; 255
    4ea6:	9f 4f       	sbci	r25, 0xFF	; 255
    4ea8:	08 95       	ret

00004eaa <__tablejump2__>:
    4eaa:	ee 0f       	add	r30, r30
    4eac:	ff 1f       	adc	r31, r31
    4eae:	88 1f       	adc	r24, r24
    4eb0:	8b bf       	out	0x3b, r24	; 59
    4eb2:	07 90       	elpm	r0, Z+
    4eb4:	f6 91       	elpm	r31, Z
    4eb6:	e0 2d       	mov	r30, r0
    4eb8:	1b be       	out	0x3b, r1	; 59
    4eba:	19 94       	eijmp

00004ebc <__muluhisi3>:
    4ebc:	0e 94 69 27 	call	0x4ed2	; 0x4ed2 <__umulhisi3>
    4ec0:	a5 9f       	mul	r26, r21
    4ec2:	90 0d       	add	r25, r0
    4ec4:	b4 9f       	mul	r27, r20
    4ec6:	90 0d       	add	r25, r0
    4ec8:	a4 9f       	mul	r26, r20
    4eca:	80 0d       	add	r24, r0
    4ecc:	91 1d       	adc	r25, r1
    4ece:	11 24       	eor	r1, r1
    4ed0:	08 95       	ret

00004ed2 <__umulhisi3>:
    4ed2:	a2 9f       	mul	r26, r18
    4ed4:	b0 01       	movw	r22, r0
    4ed6:	b3 9f       	mul	r27, r19
    4ed8:	c0 01       	movw	r24, r0
    4eda:	a3 9f       	mul	r26, r19
    4edc:	70 0d       	add	r23, r0
    4ede:	81 1d       	adc	r24, r1
    4ee0:	11 24       	eor	r1, r1
    4ee2:	91 1d       	adc	r25, r1
    4ee4:	b2 9f       	mul	r27, r18
    4ee6:	70 0d       	add	r23, r0
    4ee8:	81 1d       	adc	r24, r1
    4eea:	11 24       	eor	r1, r1
    4eec:	91 1d       	adc	r25, r1
    4eee:	08 95       	ret

00004ef0 <memcpy>:
    4ef0:	fb 01       	movw	r30, r22
    4ef2:	dc 01       	movw	r26, r24
    4ef4:	02 c0       	rjmp	.+4      	; 0x4efa <memcpy+0xa>
    4ef6:	01 90       	ld	r0, Z+
    4ef8:	0d 92       	st	X+, r0
    4efa:	41 50       	subi	r20, 0x01	; 1
    4efc:	50 40       	sbci	r21, 0x00	; 0
    4efe:	d8 f7       	brcc	.-10     	; 0x4ef6 <memcpy+0x6>
    4f00:	08 95       	ret

00004f02 <memset>:
    4f02:	dc 01       	movw	r26, r24
    4f04:	01 c0       	rjmp	.+2      	; 0x4f08 <memset+0x6>
    4f06:	6d 93       	st	X+, r22
    4f08:	41 50       	subi	r20, 0x01	; 1
    4f0a:	50 40       	sbci	r21, 0x00	; 0
    4f0c:	e0 f7       	brcc	.-8      	; 0x4f06 <memset+0x4>
    4f0e:	08 95       	ret

00004f10 <strncpy>:
    4f10:	fb 01       	movw	r30, r22
    4f12:	dc 01       	movw	r26, r24
    4f14:	41 50       	subi	r20, 0x01	; 1
    4f16:	50 40       	sbci	r21, 0x00	; 0
    4f18:	48 f0       	brcs	.+18     	; 0x4f2c <strncpy+0x1c>
    4f1a:	01 90       	ld	r0, Z+
    4f1c:	0d 92       	st	X+, r0
    4f1e:	00 20       	and	r0, r0
    4f20:	c9 f7       	brne	.-14     	; 0x4f14 <strncpy+0x4>
    4f22:	01 c0       	rjmp	.+2      	; 0x4f26 <strncpy+0x16>
    4f24:	1d 92       	st	X+, r1
    4f26:	41 50       	subi	r20, 0x01	; 1
    4f28:	50 40       	sbci	r21, 0x00	; 0
    4f2a:	e0 f7       	brcc	.-8      	; 0x4f24 <strncpy+0x14>
    4f2c:	08 95       	ret

00004f2e <ultoa>:
    4f2e:	25 32       	cpi	r18, 0x25	; 37
    4f30:	31 05       	cpc	r19, r1
    4f32:	20 f4       	brcc	.+8      	; 0x4f3c <ultoa+0xe>
    4f34:	22 30       	cpi	r18, 0x02	; 2
    4f36:	10 f0       	brcs	.+4      	; 0x4f3c <ultoa+0xe>
    4f38:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__ultoa_ncheck>
    4f3c:	fa 01       	movw	r30, r20
    4f3e:	10 82       	st	Z, r1
    4f40:	ca 01       	movw	r24, r20
    4f42:	08 95       	ret

00004f44 <__ultoa_ncheck>:
    4f44:	bb 27       	eor	r27, r27

00004f46 <__ultoa_common>:
    4f46:	fa 01       	movw	r30, r20
    4f48:	a6 2f       	mov	r26, r22
    4f4a:	62 17       	cp	r22, r18
    4f4c:	71 05       	cpc	r23, r1
    4f4e:	81 05       	cpc	r24, r1
    4f50:	91 05       	cpc	r25, r1
    4f52:	33 0b       	sbc	r19, r19
    4f54:	30 fb       	bst	r19, 0
    4f56:	66 f0       	brts	.+24     	; 0x4f70 <__ultoa_common+0x2a>
    4f58:	aa 27       	eor	r26, r26
    4f5a:	66 0f       	add	r22, r22
    4f5c:	77 1f       	adc	r23, r23
    4f5e:	88 1f       	adc	r24, r24
    4f60:	99 1f       	adc	r25, r25
    4f62:	aa 1f       	adc	r26, r26
    4f64:	a2 17       	cp	r26, r18
    4f66:	10 f0       	brcs	.+4      	; 0x4f6c <__ultoa_common+0x26>
    4f68:	a2 1b       	sub	r26, r18
    4f6a:	63 95       	inc	r22
    4f6c:	38 50       	subi	r19, 0x08	; 8
    4f6e:	a9 f7       	brne	.-22     	; 0x4f5a <__ultoa_common+0x14>
    4f70:	a0 5d       	subi	r26, 0xD0	; 208
    4f72:	aa 33       	cpi	r26, 0x3A	; 58
    4f74:	08 f0       	brcs	.+2      	; 0x4f78 <__ultoa_common+0x32>
    4f76:	a9 5d       	subi	r26, 0xD9	; 217
    4f78:	a1 93       	st	Z+, r26
    4f7a:	36 f7       	brtc	.-52     	; 0x4f48 <__ultoa_common+0x2>
    4f7c:	b1 11       	cpse	r27, r1
    4f7e:	b1 93       	st	Z+, r27
    4f80:	10 82       	st	Z, r1
    4f82:	ca 01       	movw	r24, r20
    4f84:	0c 94 e9 27 	jmp	0x4fd2	; 0x4fd2 <strrev>

00004f88 <utoa>:
    4f88:	45 32       	cpi	r20, 0x25	; 37
    4f8a:	51 05       	cpc	r21, r1
    4f8c:	20 f4       	brcc	.+8      	; 0x4f96 <utoa+0xe>
    4f8e:	42 30       	cpi	r20, 0x02	; 2
    4f90:	10 f0       	brcs	.+4      	; 0x4f96 <utoa+0xe>
    4f92:	0c 94 cf 27 	jmp	0x4f9e	; 0x4f9e <__utoa_ncheck>
    4f96:	fb 01       	movw	r30, r22
    4f98:	10 82       	st	Z, r1
    4f9a:	cb 01       	movw	r24, r22
    4f9c:	08 95       	ret

00004f9e <__utoa_ncheck>:
    4f9e:	bb 27       	eor	r27, r27

00004fa0 <__utoa_common>:
    4fa0:	fb 01       	movw	r30, r22
    4fa2:	55 27       	eor	r21, r21
    4fa4:	aa 27       	eor	r26, r26
    4fa6:	88 0f       	add	r24, r24
    4fa8:	99 1f       	adc	r25, r25
    4faa:	aa 1f       	adc	r26, r26
    4fac:	a4 17       	cp	r26, r20
    4fae:	10 f0       	brcs	.+4      	; 0x4fb4 <__utoa_common+0x14>
    4fb0:	a4 1b       	sub	r26, r20
    4fb2:	83 95       	inc	r24
    4fb4:	50 51       	subi	r21, 0x10	; 16
    4fb6:	b9 f7       	brne	.-18     	; 0x4fa6 <__utoa_common+0x6>
    4fb8:	a0 5d       	subi	r26, 0xD0	; 208
    4fba:	aa 33       	cpi	r26, 0x3A	; 58
    4fbc:	08 f0       	brcs	.+2      	; 0x4fc0 <__utoa_common+0x20>
    4fbe:	a9 5d       	subi	r26, 0xD9	; 217
    4fc0:	a1 93       	st	Z+, r26
    4fc2:	00 97       	sbiw	r24, 0x00	; 0
    4fc4:	79 f7       	brne	.-34     	; 0x4fa4 <__utoa_common+0x4>
    4fc6:	b1 11       	cpse	r27, r1
    4fc8:	b1 93       	st	Z+, r27
    4fca:	11 92       	st	Z+, r1
    4fcc:	cb 01       	movw	r24, r22
    4fce:	0c 94 e9 27 	jmp	0x4fd2	; 0x4fd2 <strrev>

00004fd2 <strrev>:
    4fd2:	dc 01       	movw	r26, r24
    4fd4:	fc 01       	movw	r30, r24
    4fd6:	67 2f       	mov	r22, r23
    4fd8:	71 91       	ld	r23, Z+
    4fda:	77 23       	and	r23, r23
    4fdc:	e1 f7       	brne	.-8      	; 0x4fd6 <strrev+0x4>
    4fde:	32 97       	sbiw	r30, 0x02	; 2
    4fe0:	04 c0       	rjmp	.+8      	; 0x4fea <strrev+0x18>
    4fe2:	7c 91       	ld	r23, X
    4fe4:	6d 93       	st	X+, r22
    4fe6:	70 83       	st	Z, r23
    4fe8:	62 91       	ld	r22, -Z
    4fea:	ae 17       	cp	r26, r30
    4fec:	bf 07       	cpc	r27, r31
    4fee:	c8 f3       	brcs	.-14     	; 0x4fe2 <strrev+0x10>
    4ff0:	08 95       	ret

00004ff2 <_exit>:
    4ff2:	f8 94       	cli

00004ff4 <__stop_program>:
    4ff4:	ff cf       	rjmp	.-2      	; 0x4ff4 <__stop_program>
