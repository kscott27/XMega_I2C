
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004d90  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000021a  00802000  00004d90  00004e24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  0080221a  0080221a  0000503e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000503e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005070  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a80  00000000  00000000  000050b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001cd05  00000000  00000000  00005b30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000072e6  00000000  00000000  00022835  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000069c1  00000000  00000000  00029b1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002000  00000000  00000000  000304dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000072cd  00000000  00000000  000324dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a5ab  00000000  00000000  000397a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009d8  00000000  00000000  00043d54  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 03 	jmp	0x66e	; 0x66e <__ctors_end>
       4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      10:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      14:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      18:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      1c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      20:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      24:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      28:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      2c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      30:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      34:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      38:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      3c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      40:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      44:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      48:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      4c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      50:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      54:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      58:	0c 94 09 11 	jmp	0x2212	; 0x2212 <__vector_22>
      5c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      60:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      64:	0c 94 de 20 	jmp	0x41bc	; 0x41bc <__vector_25>
      68:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      6c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      70:	0c 94 3c 21 	jmp	0x4278	; 0x4278 <__vector_28>
      74:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      78:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      7c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      80:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      84:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      88:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      8c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      90:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      94:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      98:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      9c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e8:	0c 94 56 22 	jmp	0x44ac	; 0x44ac <__vector_58>
      ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      fc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     100:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     104:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     108:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     10c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     110:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     114:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     118:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     11c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     120:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     124:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     128:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     12c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     130:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     134:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     138:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     13c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     140:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     144:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     148:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     14c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     150:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     154:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     158:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     15c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     160:	0c 94 9a 21 	jmp	0x4334	; 0x4334 <__vector_88>
     164:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     168:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     16c:	0c 94 f8 21 	jmp	0x43f0	; 0x43f0 <__vector_91>
     170:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     174:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     178:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     17c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     180:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     184:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     188:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     18c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     190:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     194:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     198:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     19c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1fc:	ca 1e       	adc	r12, r26
     1fe:	cd 1e       	adc	r12, r29
     200:	d0 1e       	adc	r13, r16
     202:	d3 1e       	adc	r13, r19
     204:	d6 1e       	adc	r13, r22
     206:	d9 1e       	adc	r13, r25
     208:	db 1e       	adc	r13, r27
     20a:	ec 1e       	adc	r14, r28
     20c:	f4 1e       	adc	r15, r20
     20e:	fe 1e       	adc	r15, r30
     210:	fc 1e       	adc	r15, r28

00000212 <__trampolines_start>:
     212:	0c 94 ab 1a 	jmp	0x3556	; 0x3556 <_ZN8frt_task12print_statusER8emstream>
     216:	0c 94 99 23 	jmp	0x4732	; 0x4732 <_ZN9frt_queueIiE3getEPi>
     21a:	0c 94 84 24 	jmp	0x4908	; 0x4908 <_ZN9frt_queueIjE3putERKj>
     21e:	0c 94 f3 22 	jmp	0x45e6	; 0x45e6 <_ZN9frt_queueIjE9not_emptyEv>
     222:	0c 94 b4 08 	jmp	0x1168	; 0x1168 <_ZN9frt_queueIhE7ISR_getEPh>
     226:	0c 94 db 1e 	jmp	0x3db6	; 0x3db6 <_ZN8emstreamlsE15ser_manipulator+0x40>
     22a:	0c 94 61 05 	jmp	0xac2	; 0xac2 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     22e:	0c 94 54 25 	jmp	0x4aa8	; 0x4aa8 <_GLOBAL__sub_I_counter>
     232:	0c 94 d3 1e 	jmp	0x3da6	; 0x3da6 <_ZN8emstreamlsE15ser_manipulator+0x30>
     236:	0c 94 f1 04 	jmp	0x9e2	; 0x9e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     23a:	0c 94 fa 23 	jmp	0x47f4	; 0x47f4 <_ZN9frt_queueIiE7ISR_getEv>
     23e:	0c 94 96 24 	jmp	0x492c	; 0x492c <_ZN9frt_queueIiE7butt_inERKi>
     242:	0c 94 c2 05 	jmp	0xb84	; 0xb84 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     246:	0c 94 4f 09 	jmp	0x129e	; 0x129e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     24a:	0c 94 62 08 	jmp	0x10c4	; 0x10c4 <_ZN9frt_queueIhE8is_emptyEv>
     24e:	0c 94 d6 1d 	jmp	0x3bac	; 0x3bac <__cxa_pure_virtual>
     252:	0c 94 f8 1f 	jmp	0x3ff0	; 0x3ff0 <_ZN5rs2327putcharEc>
     256:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <_ZN9frt_queueIhE12num_items_inEv>
     25a:	0c 94 76 05 	jmp	0xaec	; 0xaec <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     25e:	0c 94 d7 22 	jmp	0x45ae	; 0x45ae <_ZN9frt_queueIiE13ISR_not_emptyEv>
     262:	0c 94 c6 22 	jmp	0x458c	; 0x458c <_ZN9frt_queueIjE12ISR_is_emptyEv>
     266:	0c 94 8b 05 	jmp	0xb16	; 0xb16 <_ZN9I2CMaster10StartState11serialDebugEv>
     26a:	0c 94 72 1e 	jmp	0x3ce4	; 0x3ce4 <_ZN8emstream14check_for_charEv>
     26e:	0c 94 0d 04 	jmp	0x81a	; 0x81a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     272:	0c 94 cd 1e 	jmp	0x3d9a	; 0x3d9a <_ZN8emstreamlsE15ser_manipulator+0x24>
     276:	0c 94 12 24 	jmp	0x4824	; 0x4824 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     27a:	0c 94 a5 23 	jmp	0x474a	; 0x474a <_ZN9frt_queueIiE3getEv>
     27e:	0c 94 54 04 	jmp	0x8a8	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     282:	0c 94 55 20 	jmp	0x40aa	; 0x40aa <_ZN5rs23212clear_screenEv>
     286:	0c 94 ec 03 	jmp	0x7d8	; 0x7d8 <_ZN8I2CAgent11resetPacketER6Packet>
     28a:	0c 94 f4 08 	jmp	0x11e8	; 0x11e8 <_ZN9frt_queueIhE7ISR_putERKh>
     28e:	0c 94 8f 03 	jmp	0x71e	; 0x71e <_ZN8I2CAgent7receiveEv>
     292:	0c 94 e2 22 	jmp	0x45c4	; 0x45c4 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     296:	0c 94 57 08 	jmp	0x10ae	; 0x10ae <_ZN9frt_queueIhE9not_emptyEv>
     29a:	0c 94 1c 20 	jmp	0x4038	; 0x4038 <_ZN5rs2327getcharEv>
     29e:	0c 94 46 08 	jmp	0x108c	; 0x108c <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2a2:	0c 94 a8 24 	jmp	0x4950	; 0x4950 <_ZN9frt_queueIiE3putERKi>
     2a6:	0c 94 5a 24 	jmp	0x48b4	; 0x48b4 <_ZN9frt_queueIiE7ISR_putERKi>
     2aa:	0c 94 e9 23 	jmp	0x47d2	; 0x47d2 <_ZN9frt_queueIiE7ISR_getEPi>
     2ae:	0c 94 6f 1e 	jmp	0x3cde	; 0x3cde <_ZN8emstream7getcharEv>
     2b2:	0c 94 03 04 	jmp	0x806	; 0x806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     2b6:	0c 94 0d 05 	jmp	0xa1a	; 0xa1a <_ZN9I2CMaster10ErrorState11serialDebugEv>
     2ba:	0c 94 fc 1e 	jmp	0x3df8	; 0x3df8 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2be:	0c 94 f4 1e 	jmp	0x3de8	; 0x3de8 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2c2:	0c 94 d0 1e 	jmp	0x3da0	; 0x3da0 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2c6:	0c 94 72 23 	jmp	0x46e4	; 0x46e4 <_ZN9frt_queueIiE10get_a_copyERi>
     2ca:	0c 94 d6 1e 	jmp	0x3dac	; 0x3dac <_ZN8emstreamlsE15ser_manipulator+0x36>
     2ce:	0c 94 57 23 	jmp	0x46ae	; 0x46ae <_ZN9frt_queueIjE3getEv>
     2d2:	0c 94 11 08 	jmp	0x1022	; 0x1022 <_ZN9I2CMaster10StartState7executeER6Packet>
     2d6:	0c 94 36 0b 	jmp	0x166c	; 0x166c <_ZN11task_sensor3runEv>
     2da:	0c 94 9b 04 	jmp	0x936	; 0x936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2de:	0c 94 4b 23 	jmp	0x4696	; 0x4696 <_ZN9frt_queueIjE3getEPj>
     2e2:	0c 94 7e 23 	jmp	0x46fc	; 0x46fc <_ZN9frt_queueIiE10get_a_copyEv>
     2e6:	0c 94 ca 1e 	jmp	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2ea:	0c 94 9c 08 	jmp	0x1138	; 0x1138 <_ZN9frt_queueIhE3getEv>
     2ee:	0c 94 ba 03 	jmp	0x774	; 0x774 <_ZN8I2CAgent11writePacketER7Command>
     2f2:	0c 94 6d 1e 	jmp	0x3cda	; 0x3cda <_ZN8emstream13ready_to_sendEv>
     2f6:	0c 94 ec 1e 	jmp	0x3dd8	; 0x3dd8 <_ZN8emstreamlsE15ser_manipulator+0x62>
     2fa:	0c 94 30 09 	jmp	0x1260	; 0x1260 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     2fe:	0c 94 0f 23 	jmp	0x461e	; 0x461e <_ZN9frt_queueIiE9not_emptyEv>
     302:	0c 94 37 05 	jmp	0xa6e	; 0xa6e <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     306:	0c 94 75 1e 	jmp	0x3cea	; 0x3cea <_ZN8emstream12clear_screenEv>
     30a:	0c 94 08 23 	jmp	0x4610	; 0x4610 <_ZN9frt_queueIiE12num_items_inEv>
     30e:	0c 94 1e 1c 	jmp	0x383c	; 0x383c <_ZN14frt_text_queue7putcharEc>
     312:	0c 94 e9 13 	jmp	0x27d2	; 0x27d2 <prvIdleTask>
     316:	0c 94 d9 1e 	jmp	0x3db2	; 0x3db2 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     31a:	0c 94 2a 24 	jmp	0x4854	; 0x4854 <_ZN9frt_queueIjE7ISR_putERKj>
     31e:	0c 94 74 1e 	jmp	0x3ce8	; 0x3ce8 <_ZN8emstream12transmit_nowEv>
     322:	0c 94 fe 22 	jmp	0x45fc	; 0x45fc <_ZN9frt_queueIjE8is_emptyEv>
     326:	0c 94 f9 03 	jmp	0x7f2	; 0x7f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     32a:	0c 94 cb 04 	jmp	0x996	; 0x996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     32e:	0c 94 42 24 	jmp	0x4884	; 0x4884 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     332:	0c 94 69 09 	jmp	0x12d2	; 0x12d2 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     336:	0c 94 78 08 	jmp	0x10f0	; 0x10f0 <_ZN9frt_queueIhE10get_a_copyEv>
     33a:	0c 94 72 24 	jmp	0x48e4	; 0x48e4 <_ZN9frt_queueIjE7butt_inERKj>
     33e:	0c 94 1a 23 	jmp	0x4634	; 0x4634 <_ZN9frt_queueIiE8is_emptyEv>
     342:	0c 94 24 23 	jmp	0x4648	; 0x4648 <_ZN9frt_queueIjE10get_a_copyERj>
     346:	0c 94 34 08 	jmp	0x1068	; 0x1068 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     34a:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     34e:	0c 94 e5 0c 	jmp	0x19ca	; 0x19ca <_ZN9task_user3runEv>
     352:	0c 94 a0 05 	jmp	0xb40	; 0xb40 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     356:	0c 94 bb 22 	jmp	0x4576	; 0x4576 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     35a:	0c 94 6f 03 	jmp	0x6de	; 0x6de <_ZN8I2CAgent10readPacketEv>
     35e:	0c 94 c0 23 	jmp	0x4780	; 0x4780 <_ZN9frt_queueIjE7ISR_getEPj>
     362:	0c 94 22 05 	jmp	0xa44	; 0xa44 <_ZN9I2CMaster9DoneState11serialDebugEv>
     366:	0c 94 fe 1e 	jmp	0x3dfc	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
     36a:	0c 94 34 03 	jmp	0x668	; 0x668 <_call_static_run_method>
     36e:	0c 94 13 1c 	jmp	0x3826	; 0x3826 <_ZN14frt_text_queue14check_for_charEv>
     372:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <_ZN9frt_queueIjE12num_items_inEv>
     376:	0c 94 06 05 	jmp	0xa0c	; 0xa0c <_ZN9I2CMaster9DoneState7executeER6Packet>
     37a:	0c 94 42 20 	jmp	0x4084	; 0x4084 <_ZN5rs23214check_for_charEv>
     37e:	0c 94 dc 08 	jmp	0x11b8	; 0x11b8 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     382:	0c 94 90 08 	jmp	0x1120	; 0x1120 <_ZN9frt_queueIhE3getEPh>
     386:	0c 94 4c 05 	jmp	0xa98	; 0xa98 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     38a:	0c 94 3b 08 	jmp	0x1076	; 0x1076 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     38e:	0c 94 0c 09 	jmp	0x1218	; 0x1218 <_ZN9frt_queueIhE7butt_inERKh>
     392:	0c 94 5c 09 	jmp	0x12b8	; 0x12b8 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     396:	0c 94 6c 08 	jmp	0x10d8	; 0x10d8 <_ZN9frt_queueIhE10get_a_copyERh>
     39a:	0c 94 d1 23 	jmp	0x47a2	; 0x47a2 <_ZN9frt_queueIjE7ISR_getEv>
     39e:	0c 94 c5 08 	jmp	0x118a	; 0x118a <_ZN9frt_queueIhE7ISR_getEv>
     3a2:	0c 94 1e 09 	jmp	0x123c	; 0x123c <_ZN9frt_queueIhE3putERKh>
     3a6:	0c 94 7a 03 	jmp	0x6f4	; 0x6f4 <_ZN8I2CAgent8transmitER7Command>
     3aa:	0c 94 30 23 	jmp	0x4660	; 0x4660 <_ZN9frt_queueIjE10get_a_copyEv>
     3ae:	0c 94 f5 1b 	jmp	0x37ea	; 0x37ea <_ZN14frt_text_queue7getcharEv>
     3b2:	0c 94 b4 22 	jmp	0x4568	; 0x4568 <_ZN9frt_queueIjE16ISR_num_items_inEv>

000003b6 <__trampolines_end>:
     3b6:	2c 20       	and	r2, r12
     3b8:	54 43       	sbci	r21, 0x34	; 52
     3ba:	43 30       	cpi	r20, 0x03	; 3
     3bc:	43 43       	sbci	r20, 0x33	; 51
     3be:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c1 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c1:	2f 00                                               /.

000003c3 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d1 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d1:	54 69 6d 65 3a 20 00                                Time: .

000003d8 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d8:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e4 <_ZZN9task_user11show_statusEvE3__c>:
     3e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000403 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     403:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000412 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     412:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     422:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000042d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     42d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     43d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46b:	6d 61 74 69 6f 6e 00                                mation.

00000472 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     472:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     482:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000493 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     493:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a3:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004ab <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4ab:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bb:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d7:	68 65 20 41 56 52 00                                he AVR.

000004de <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4de:	20 68 65 6c 70 00                                    help.

000004e4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000503 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     503:	1b 5b 33 30 6d 00                                   .[30m.

00000509 <_ZZN9task_user18print_help_messageEvE3__c>:
     509:	1b 5b 34 36 6d 00                                   .[46m.

0000050f <_ZZN9task_user3runEvE3__c_3>:
     50f:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51f:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000052c <_ZZN9task_user3runEvE3__c_2>:
     52c:	3a 57 54 46 3f 00                                   :WTF?.

00000532 <_ZZN9task_user3runEvE3__c_1>:
     532:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     542:	65 00                                               e.

00000544 <_ZZN9task_user3runEvE3__c_0>:
     544:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000552 <_ZZN9task_user3runEvE3__c>:
     552:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     562:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000570 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     570:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057a <_ZZN8frt_task15emergency_resetEvE3__c>:
     57a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000589 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     589:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     599:	61 73 6b 20 00                                      ask .

0000059e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005ac <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5ac:	20 63 72 65 61 74 65 64 00                           created.

000005b5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b5:	54 61 73 6b 20 00                                   Task .

000005bb <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bb:	1b 5b 32 32 6d 00                                   .[22m.

000005c1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c1:	54 61 73 6b 3a 20 00                                Task: .

000005c8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5cd:	1b 5b 32 32 6d 00                                   .[22m.

000005d3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005de <_ZZ17print_task_stacksP8emstreamE3__c>:
     5de:	1b 5b 31 6d 00                                      .[1m.

000005e3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e3:	09 09 00                                            ...

000005e6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e6:	2f 00                                               /.

000005e8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f3:	09 2d 2d 2d 2d 00                                   .----.

000005f9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000605 <_ZZ15print_task_listP8emstreamE3__c_4>:
     605:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000616 <_ZZ15print_task_listP8emstreamE3__c_3>:
     616:	09 52 75 6e 73 00                                   .Runs.

0000061c <_ZZ15print_task_listP8emstreamE3__c_2>:
     61c:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000628 <_ZZ15print_task_listP8emstreamE3__c_1>:
     628:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000639 <_ZZ15print_task_listP8emstreamE3__c_0>:
     639:	09 53 74 61 63 6b 00                                .Stack.

00000640 <_ZZ15print_task_listP8emstreamE3__c>:
     640:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64b:	09 00                                               ..

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64f:	2f 00                                               /.

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     653:	09 00                                               ..

00000655 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     655:	1b 5b 32 32 6d 00                                   .[22m.

0000065b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65b:	1b 5b 31 6d 00                                      .[1m.

00000660 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     660:	1b 5b 31 6d 00                                      .[1m.

00000665 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     665:	20 20 00                                              .

00000668 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     668:	0e 94 43 19 	call	0x3286	; 0x3286 <_ZN8frt_task22_call_users_run_methodEPS_>

0000066c <__ctors_start>:
     66c:	54 25       	eor	r21, r4

0000066e <__ctors_end>:
     66e:	11 24       	eor	r1, r1
     670:	1f be       	out	0x3f, r1	; 63
     672:	cf ef       	ldi	r28, 0xFF	; 255
     674:	cd bf       	out	0x3d, r28	; 61
     676:	df e3       	ldi	r29, 0x3F	; 63
     678:	de bf       	out	0x3e, r29	; 62
     67a:	00 e0       	ldi	r16, 0x00	; 0
     67c:	0c bf       	out	0x3c, r16	; 60
     67e:	18 be       	out	0x38, r1	; 56
     680:	19 be       	out	0x39, r1	; 57
     682:	1a be       	out	0x3a, r1	; 58
     684:	1b be       	out	0x3b, r1	; 59

00000686 <__do_copy_data>:
     686:	12 e2       	ldi	r17, 0x22	; 34
     688:	a0 e0       	ldi	r26, 0x00	; 0
     68a:	b0 e2       	ldi	r27, 0x20	; 32
     68c:	e0 e9       	ldi	r30, 0x90	; 144
     68e:	fd e4       	ldi	r31, 0x4D	; 77
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	0b bf       	out	0x3b, r16	; 59
     694:	02 c0       	rjmp	.+4      	; 0x69a <__do_copy_data+0x14>
     696:	07 90       	elpm	r0, Z+
     698:	0d 92       	st	X+, r0
     69a:	aa 31       	cpi	r26, 0x1A	; 26
     69c:	b1 07       	cpc	r27, r17
     69e:	d9 f7       	brne	.-10     	; 0x696 <__do_copy_data+0x10>
     6a0:	1b be       	out	0x3b, r1	; 59

000006a2 <__do_clear_bss>:
     6a2:	22 e3       	ldi	r18, 0x32	; 50
     6a4:	aa e1       	ldi	r26, 0x1A	; 26
     6a6:	b2 e2       	ldi	r27, 0x22	; 34
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <.do_clear_bss_start>

000006aa <.do_clear_bss_loop>:
     6aa:	1d 92       	st	X+, r1

000006ac <.do_clear_bss_start>:
     6ac:	a8 3e       	cpi	r26, 0xE8	; 232
     6ae:	b2 07       	cpc	r27, r18
     6b0:	e1 f7       	brne	.-8      	; 0x6aa <.do_clear_bss_loop>

000006b2 <__do_global_ctors>:
     6b2:	13 e0       	ldi	r17, 0x03	; 3
     6b4:	c7 e3       	ldi	r28, 0x37	; 55
     6b6:	d3 e0       	ldi	r29, 0x03	; 3
     6b8:	00 e0       	ldi	r16, 0x00	; 0
     6ba:	06 c0       	rjmp	.+12     	; 0x6c8 <__do_global_ctors+0x16>
     6bc:	21 97       	sbiw	r28, 0x01	; 1
     6be:	01 09       	sbc	r16, r1
     6c0:	80 2f       	mov	r24, r16
     6c2:	fe 01       	movw	r30, r28
     6c4:	0e 94 22 26 	call	0x4c44	; 0x4c44 <__tablejump2__>
     6c8:	c6 33       	cpi	r28, 0x36	; 54
     6ca:	d1 07       	cpc	r29, r17
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	08 07       	cpc	r16, r24
     6d0:	a9 f7       	brne	.-22     	; 0x6bc <__do_global_ctors+0xa>
     6d2:	0e 94 cf 24 	call	0x499e	; 0x499e <main>
     6d6:	0c 94 c6 26 	jmp	0x4d8c	; 0x4d8c <_exit>

000006da <__bad_interrupt>:
     6da:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006de <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6de:	bc 01       	movw	r22, r24
     6e0:	6e 5f       	subi	r22, 0xFE	; 254
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	dc 01       	movw	r26, r24
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	00 84       	ldd	r0, Z+8	; 0x08
     6ec:	f1 85       	ldd	r31, Z+9	; 0x09
     6ee:	e0 2d       	mov	r30, r0
     6f0:	19 95       	eicall
     6f2:	08 95       	ret

000006f4 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fa:	e8 81       	ld	r30, Y
     6fc:	f9 81       	ldd	r31, Y+1	; 0x01
     6fe:	04 80       	ldd	r0, Z+4	; 0x04
     700:	f5 81       	ldd	r31, Z+5	; 0x05
     702:	e0 2d       	mov	r30, r0
     704:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     706:	be 01       	movw	r22, r28
     708:	62 5f       	subi	r22, 0xF2	; 242
     70a:	7f 4f       	sbci	r23, 0xFF	; 255

  };

  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     70c:	ec 8d       	ldd	r30, Y+28	; 0x1c
     70e:	fd 8d       	ldd	r31, Y+29	; 0x1d
     710:	80 81       	ld	r24, Z
     712:	91 81       	ldd	r25, Z+1	; 0x01
     714:	0e 94 10 07 	call	0xe20	; 0xe20 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	08 95       	ret

0000071e <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     71e:	ef 92       	push	r14
     720:	ff 92       	push	r15
     722:	0f 93       	push	r16
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72a:	7c 01       	movw	r14, r24
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	e8 0e       	add	r14, r24
     730:	f1 1c       	adc	r15, r1
     732:	e8 81       	ld	r30, Y
     734:	f9 81       	ldd	r31, Y+1	; 0x01
     736:	00 84       	ldd	r0, Z+8	; 0x08
     738:	f1 85       	ldd	r31, Z+9	; 0x09
     73a:	e0 2d       	mov	r30, r0
     73c:	b7 01       	movw	r22, r14
     73e:	ce 01       	movw	r24, r28
     740:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     742:	28 85       	ldd	r18, Y+8	; 0x08
     744:	39 85       	ldd	r19, Y+9	; 0x09
     746:	4a 85       	ldd	r20, Y+10	; 0x0a
     748:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74a:	be 01       	movw	r22, r28
     74c:	60 5e       	subi	r22, 0xE0	; 224
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	00 e0       	ldi	r16, 0x00	; 0
     752:	8e 81       	ldd	r24, Y+6	; 0x06
     754:	9f 81       	ldd	r25, Y+7	; 0x07
     756:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75a:	ec 8d       	ldd	r30, Y+28	; 0x1c
     75c:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     75e:	b7 01       	movw	r22, r14
     760:	82 81       	ldd	r24, Z+2	; 0x02
     762:	93 81       	ldd	r25, Z+3	; 0x03
     764:	0e 94 53 07 	call	0xea6	; 0xea6 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	0f 91       	pop	r16
     76e:	ff 90       	pop	r15
     770:	ef 90       	pop	r14
     772:	08 95       	ret

00000774 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
     784:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     786:	6c 01       	movw	r12, r24
     788:	8e e0       	ldi	r24, 0x0E	; 14
     78a:	c8 0e       	add	r12, r24
     78c:	d1 1c       	adc	r13, r1
     78e:	e8 81       	ld	r30, Y
     790:	f9 81       	ldd	r31, Y+1	; 0x01
     792:	00 84       	ldd	r0, Z+8	; 0x08
     794:	f1 85       	ldd	r31, Z+9	; 0x09
     796:	e0 2d       	mov	r30, r0
     798:	b6 01       	movw	r22, r12
     79a:	ce 01       	movw	r24, r28
     79c:	19 95       	eicall
     79e:	2c 89       	ldd	r18, Y+20	; 0x14
     7a0:	3d 89       	ldd	r19, Y+21	; 0x15
     7a2:	4e 89       	ldd	r20, Y+22	; 0x16
     7a4:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7a6:	be 01       	movw	r22, r28
     7a8:	61 5e       	subi	r22, 0xE1	; 225
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	00 e0       	ldi	r16, 0x00	; 0
     7ae:	8a 89       	ldd	r24, Y+18	; 0x12
     7b0:	9b 89       	ldd	r25, Y+19	; 0x13
     7b2:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7b6:	d7 01       	movw	r26, r14
     7b8:	ed 91       	ld	r30, X+
     7ba:	fc 91       	ld	r31, X
     7bc:	01 90       	ld	r0, Z+
     7be:	f0 81       	ld	r31, Z
     7c0:	e0 2d       	mov	r30, r0
     7c2:	b6 01       	movw	r22, r12
     7c4:	c7 01       	movw	r24, r14
     7c6:	19 95       	eicall
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	08 95       	ret

000007d8 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7d8:	cb 01       	movw	r24, r22
  packet.resetContent();
     7da:	0e 94 1e 0b 	call	0x163c	; 0x163c <_ZN6Packet12resetContentEv>
     7de:	08 95       	ret

000007e0 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e0:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e2:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e4:	86 2f       	mov	r24, r22
     7e6:	88 0f       	add	r24, r24
     7e8:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ea:	68 2f       	mov	r22, r24
     7ec:	61 60       	ori	r22, 0x01	; 1
     7ee:	60 a3       	std	Z+32, r22	; 0x20
     7f0:	08 95       	ret

000007f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
  }
  else
  {
    return false;
  }
}
     7f2:	dc 01       	movw	r26, r24
     7f4:	17 96       	adiw	r26, 0x07	; 7
     7f6:	ed 91       	ld	r30, X+
     7f8:	fc 91       	ld	r31, X
     7fa:	18 97       	sbiw	r26, 0x08	; 8
     7fc:	04 80       	ldd	r0, Z+4	; 0x04
     7fe:	f5 81       	ldd	r31, Z+5	; 0x05
     800:	e0 2d       	mov	r30, r0
     802:	84 81       	ldd	r24, Z+4	; 0x04
     804:	08 95       	ret

00000806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     806:	dc 01       	movw	r26, r24
     808:	17 96       	adiw	r26, 0x07	; 7
     80a:	ed 91       	ld	r30, X+
     80c:	fc 91       	ld	r31, X
     80e:	18 97       	sbiw	r26, 0x08	; 8
     810:	04 80       	ldd	r0, Z+4	; 0x04
     812:	f5 81       	ldd	r31, Z+5	; 0x05
     814:	e0 2d       	mov	r30, r0
     816:	84 81       	ldd	r24, Z+4	; 0x04
     818:	08 95       	ret

0000081a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	1f 92       	push	r1
     824:	1f 92       	push	r1
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	8c 01       	movw	r16, r24
     82c:	dc 01       	movw	r26, r24
     82e:	19 96       	adiw	r26, 0x09	; 9
     830:	8d 91       	ld	r24, X+
     832:	9c 91       	ld	r25, X
     834:	1a 97       	sbiw	r26, 0x0a	; 10
     836:	89 83       	std	Y+1, r24	; 0x01
     838:	9a 83       	std	Y+2, r25	; 0x02
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	01 97       	sbiw	r24, 0x01	; 1
     840:	89 83       	std	Y+1, r24	; 0x01
     842:	9a 83       	std	Y+2, r25	; 0x02
     844:	89 2b       	or	r24, r25
     846:	59 f0       	breq	.+22     	; 0x85e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     848:	d8 01       	movw	r26, r16
     84a:	17 96       	adiw	r26, 0x07	; 7
     84c:	ed 91       	ld	r30, X+
     84e:	fc 91       	ld	r31, X
     850:	18 97       	sbiw	r26, 0x08	; 8
     852:	04 80       	ldd	r0, Z+4	; 0x04
     854:	f5 81       	ldd	r31, Z+5	; 0x05
     856:	e0 2d       	mov	r30, r0
     858:	84 81       	ldd	r24, Z+4	; 0x04
     85a:	86 ff       	sbrs	r24, 6
     85c:	ee cf       	rjmp	.-36     	; 0x83a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x20>
     85e:	d8 01       	movw	r26, r16
     860:	ed 91       	ld	r30, X+
     862:	fc 91       	ld	r31, X
     864:	02 80       	ldd	r0, Z+2	; 0x02
     866:	f3 81       	ldd	r31, Z+3	; 0x03
     868:	e0 2d       	mov	r30, r0
     86a:	c8 01       	movw	r24, r16
     86c:	19 95       	eicall
     86e:	d8 01       	movw	r26, r16
     870:	17 96       	adiw	r26, 0x07	; 7
     872:	ed 91       	ld	r30, X+
     874:	fc 91       	ld	r31, X
     876:	18 97       	sbiw	r26, 0x08	; 8
     878:	04 80       	ldd	r0, Z+4	; 0x04
     87a:	f5 81       	ldd	r31, Z+5	; 0x05
     87c:	e0 2d       	mov	r30, r0
     87e:	84 81       	ldd	r24, Z+4	; 0x04
     880:	84 fd       	sbrc	r24, 4
     882:	08 c0       	rjmp	.+16     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     884:	84 81       	ldd	r24, Z+4	; 0x04
     886:	86 ff       	sbrs	r24, 6
     888:	05 c0       	rjmp	.+10     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     88a:	12 96       	adiw	r26, 0x02	; 2
     88c:	8d 91       	ld	r24, X+
     88e:	9c 91       	ld	r25, X
     890:	13 97       	sbiw	r26, 0x03	; 3
     892:	03 c0       	rjmp	.+6      	; 0x89a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x80>
     894:	f8 01       	movw	r30, r16
     896:	84 81       	ldd	r24, Z+4	; 0x04
     898:	95 81       	ldd	r25, Z+5	; 0x05
     89a:	0f 90       	pop	r0
     89c:	0f 90       	pop	r0
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	08 95       	ret

000008a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     8a8:	0f 93       	push	r16
     8aa:	1f 93       	push	r17
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	1f 92       	push	r1
     8b2:	1f 92       	push	r1
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	8c 01       	movw	r16, r24
     8ba:	dc 01       	movw	r26, r24
     8bc:	19 96       	adiw	r26, 0x09	; 9
     8be:	8d 91       	ld	r24, X+
     8c0:	9c 91       	ld	r25, X
     8c2:	1a 97       	sbiw	r26, 0x0a	; 10
     8c4:	89 83       	std	Y+1, r24	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 81       	ldd	r24, Y+1	; 0x01
     8ca:	9a 81       	ldd	r25, Y+2	; 0x02
     8cc:	01 97       	sbiw	r24, 0x01	; 1
     8ce:	89 83       	std	Y+1, r24	; 0x01
     8d0:	9a 83       	std	Y+2, r25	; 0x02
     8d2:	89 2b       	or	r24, r25
     8d4:	59 f0       	breq	.+22     	; 0x8ec <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x44>
     8d6:	d8 01       	movw	r26, r16
     8d8:	17 96       	adiw	r26, 0x07	; 7
     8da:	ed 91       	ld	r30, X+
     8dc:	fc 91       	ld	r31, X
     8de:	18 97       	sbiw	r26, 0x08	; 8
     8e0:	04 80       	ldd	r0, Z+4	; 0x04
     8e2:	f5 81       	ldd	r31, Z+5	; 0x05
     8e4:	e0 2d       	mov	r30, r0
     8e6:	84 81       	ldd	r24, Z+4	; 0x04
     8e8:	88 23       	and	r24, r24
     8ea:	74 f7       	brge	.-36     	; 0x8c8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x20>
     8ec:	d8 01       	movw	r26, r16
     8ee:	ed 91       	ld	r30, X+
     8f0:	fc 91       	ld	r31, X
     8f2:	02 80       	ldd	r0, Z+2	; 0x02
     8f4:	f3 81       	ldd	r31, Z+3	; 0x03
     8f6:	e0 2d       	mov	r30, r0
     8f8:	c8 01       	movw	r24, r16
     8fa:	19 95       	eicall
     8fc:	d8 01       	movw	r26, r16
     8fe:	17 96       	adiw	r26, 0x07	; 7
     900:	ed 91       	ld	r30, X+
     902:	fc 91       	ld	r31, X
     904:	18 97       	sbiw	r26, 0x08	; 8
     906:	04 80       	ldd	r0, Z+4	; 0x04
     908:	f5 81       	ldd	r31, Z+5	; 0x05
     90a:	e0 2d       	mov	r30, r0
     90c:	84 81       	ldd	r24, Z+4	; 0x04
     90e:	84 fd       	sbrc	r24, 4
     910:	08 c0       	rjmp	.+16     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     912:	84 81       	ldd	r24, Z+4	; 0x04
     914:	88 23       	and	r24, r24
     916:	2c f4       	brge	.+10     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     918:	12 96       	adiw	r26, 0x02	; 2
     91a:	8d 91       	ld	r24, X+
     91c:	9c 91       	ld	r25, X
     91e:	13 97       	sbiw	r26, 0x03	; 3
     920:	03 c0       	rjmp	.+6      	; 0x928 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x80>
     922:	f8 01       	movw	r30, r16
     924:	84 81       	ldd	r24, Z+4	; 0x04
     926:	95 81       	ldd	r25, Z+5	; 0x05
     928:	0f 90       	pop	r0
     92a:	0f 90       	pop	r0
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	08 95       	ret

00000936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     936:	ef 92       	push	r14
     938:	ff 92       	push	r15
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	8c 01       	movw	r16, r24
     944:	eb 01       	movw	r28, r22
     946:	e8 81       	ld	r30, Y
     948:	f9 81       	ldd	r31, Y+1	; 0x01
     94a:	00 8c       	ldd	r0, Z+24	; 0x18
     94c:	f1 8d       	ldd	r31, Z+25	; 0x19
     94e:	e0 2d       	mov	r30, r0
     950:	cb 01       	movw	r24, r22
     952:	19 95       	eicall
     954:	88 23       	and	r24, r24
     956:	a9 f0       	breq	.+42     	; 0x982 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     958:	e8 81       	ld	r30, Y
     95a:	f9 81       	ldd	r31, Y+1	; 0x01
     95c:	02 84       	ldd	r0, Z+10	; 0x0a
     95e:	f3 85       	ldd	r31, Z+11	; 0x0b
     960:	e0 2d       	mov	r30, r0
     962:	e1 2c       	mov	r14, r1
     964:	f1 2c       	mov	r15, r1
     966:	b7 01       	movw	r22, r14
     968:	ce 01       	movw	r24, r28
     96a:	19 95       	eicall
     96c:	d8 01       	movw	r26, r16
     96e:	17 96       	adiw	r26, 0x07	; 7
     970:	ed 91       	ld	r30, X+
     972:	fc 91       	ld	r31, X
     974:	18 97       	sbiw	r26, 0x08	; 8
     976:	04 80       	ldd	r0, Z+4	; 0x04
     978:	f5 81       	ldd	r31, Z+5	; 0x05
     97a:	e0 2d       	mov	r30, r0
     97c:	d7 01       	movw	r26, r14
     97e:	8c 91       	ld	r24, X
     980:	87 83       	std	Z+7, r24	; 0x07
     982:	f8 01       	movw	r30, r16
     984:	82 81       	ldd	r24, Z+2	; 0x02
     986:	93 81       	ldd	r25, Z+3	; 0x03
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	1f 91       	pop	r17
     98e:	0f 91       	pop	r16
     990:	ff 90       	pop	r15
     992:	ef 90       	pop	r14
     994:	08 95       	ret

00000996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	1f 92       	push	r1
     9a0:	cd b7       	in	r28, 0x3d	; 61
     9a2:	de b7       	in	r29, 0x3e	; 62
     9a4:	8c 01       	movw	r16, r24
     9a6:	cb 01       	movw	r24, r22
     9a8:	d8 01       	movw	r26, r16
     9aa:	17 96       	adiw	r26, 0x07	; 7
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
     9b0:	18 97       	sbiw	r26, 0x08	; 8
     9b2:	04 80       	ldd	r0, Z+4	; 0x04
     9b4:	f5 81       	ldd	r31, Z+5	; 0x05
     9b6:	e0 2d       	mov	r30, r0
     9b8:	27 81       	ldd	r18, Z+7	; 0x07
     9ba:	29 83       	std	Y+1, r18	; 0x01
     9bc:	db 01       	movw	r26, r22
     9be:	ed 91       	ld	r30, X+
     9c0:	fc 91       	ld	r31, X
     9c2:	01 90       	ld	r0, Z+
     9c4:	f0 81       	ld	r31, Z
     9c6:	e0 2d       	mov	r30, r0
     9c8:	be 01       	movw	r22, r28
     9ca:	6f 5f       	subi	r22, 0xFF	; 255
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	19 95       	eicall
     9d0:	f8 01       	movw	r30, r16
     9d2:	82 81       	ldd	r24, Z+2	; 0x02
     9d4:	93 81       	ldd	r25, Z+3	; 0x03
     9d6:	0f 90       	pop	r0
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	08 95       	ret

000009e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	ec 01       	movw	r28, r24
     9e8:	cb 01       	movw	r24, r22
     9ea:	db 01       	movw	r26, r22
     9ec:	ed 91       	ld	r30, X+
     9ee:	fc 91       	ld	r31, X
     9f0:	04 88       	ldd	r0, Z+20	; 0x14
     9f2:	f5 89       	ldd	r31, Z+21	; 0x15
     9f4:	e0 2d       	mov	r30, r0
     9f6:	19 95       	eicall
     9f8:	88 23       	and	r24, r24
     9fa:	19 f0       	breq	.+6      	; 0xa02 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     9fc:	8a 81       	ldd	r24, Y+2	; 0x02
     9fe:	9b 81       	ldd	r25, Y+3	; 0x03
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     a02:	8c 81       	ldd	r24, Y+4	; 0x04
     a04:	9d 81       	ldd	r25, Y+5	; 0x05
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_ZN9I2CMaster9DoneState7executeER6Packet>:
     a0c:	21 e0       	ldi	r18, 0x01	; 1
     a0e:	fb 01       	movw	r30, r22
     a10:	23 87       	std	Z+11, r18	; 0x0b
     a12:	fc 01       	movw	r30, r24
     a14:	82 81       	ldd	r24, Z+2	; 0x02
     a16:	93 81       	ldd	r25, Z+3	; 0x03
     a18:	08 95       	ret

00000a1a <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	dc 01       	movw	r26, r24
     a20:	17 96       	adiw	r26, 0x07	; 7
     a22:	ed 91       	ld	r30, X+
     a24:	fc 91       	ld	r31, X
     a26:	18 97       	sbiw	r26, 0x08	; 8
     a28:	c6 81       	ldd	r28, Z+6	; 0x06
     a2a:	d7 81       	ldd	r29, Z+7	; 0x07
     a2c:	64 e1       	ldi	r22, 0x14	; 20
     a2e:	70 e2       	ldi	r23, 0x20	; 32
     a30:	ce 01       	movw	r24, r28
     a32:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     a36:	66 e0       	ldi	r22, 0x06	; 6
     a38:	ce 01       	movw	r24, r28
     a3a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <_ZN9I2CMaster9DoneState11serialDebugEv>:
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	dc 01       	movw	r26, r24
     a4a:	17 96       	adiw	r26, 0x07	; 7
     a4c:	ed 91       	ld	r30, X+
     a4e:	fc 91       	ld	r31, X
     a50:	18 97       	sbiw	r26, 0x08	; 8
     a52:	c6 81       	ldd	r28, Z+6	; 0x06
     a54:	d7 81       	ldd	r29, Z+7	; 0x07
     a56:	6a e1       	ldi	r22, 0x1A	; 26
     a58:	70 e2       	ldi	r23, 0x20	; 32
     a5a:	ce 01       	movw	r24, r28
     a5c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     a60:	66 e0       	ldi	r22, 0x06	; 6
     a62:	ce 01       	movw	r24, r28
     a64:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	dc 01       	movw	r26, r24
     a74:	17 96       	adiw	r26, 0x07	; 7
     a76:	ed 91       	ld	r30, X+
     a78:	fc 91       	ld	r31, X
     a7a:	18 97       	sbiw	r26, 0x08	; 8
     a7c:	c6 81       	ldd	r28, Z+6	; 0x06
     a7e:	d7 81       	ldd	r29, Z+7	; 0x07
     a80:	6f e1       	ldi	r22, 0x1F	; 31
     a82:	70 e2       	ldi	r23, 0x20	; 32
     a84:	ce 01       	movw	r24, r28
     a86:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     a8a:	66 e0       	ldi	r22, 0x06	; 6
     a8c:	ce 01       	movw	r24, r28
     a8e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	08 95       	ret

00000a98 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	dc 01       	movw	r26, r24
     a9e:	17 96       	adiw	r26, 0x07	; 7
     aa0:	ed 91       	ld	r30, X+
     aa2:	fc 91       	ld	r31, X
     aa4:	18 97       	sbiw	r26, 0x08	; 8
     aa6:	c6 81       	ldd	r28, Z+6	; 0x06
     aa8:	d7 81       	ldd	r29, Z+7	; 0x07
     aaa:	68 e2       	ldi	r22, 0x28	; 40
     aac:	70 e2       	ldi	r23, 0x20	; 32
     aae:	ce 01       	movw	r24, r28
     ab0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     ab4:	66 e0       	ldi	r22, 0x06	; 6
     ab6:	ce 01       	movw	r24, r28
     ab8:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	08 95       	ret

00000ac2 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
     ac6:	dc 01       	movw	r26, r24
     ac8:	17 96       	adiw	r26, 0x07	; 7
     aca:	ed 91       	ld	r30, X+
     acc:	fc 91       	ld	r31, X
     ace:	18 97       	sbiw	r26, 0x08	; 8
     ad0:	c6 81       	ldd	r28, Z+6	; 0x06
     ad2:	d7 81       	ldd	r29, Z+7	; 0x07
     ad4:	61 e3       	ldi	r22, 0x31	; 49
     ad6:	70 e2       	ldi	r23, 0x20	; 32
     ad8:	ce 01       	movw	r24, r28
     ada:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     ade:	66 e0       	ldi	r22, 0x06	; 6
     ae0:	ce 01       	movw	r24, r28
     ae2:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     ae6:	df 91       	pop	r29
     ae8:	cf 91       	pop	r28
     aea:	08 95       	ret

00000aec <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	dc 01       	movw	r26, r24
     af2:	17 96       	adiw	r26, 0x07	; 7
     af4:	ed 91       	ld	r30, X+
     af6:	fc 91       	ld	r31, X
     af8:	18 97       	sbiw	r26, 0x08	; 8
     afa:	c6 81       	ldd	r28, Z+6	; 0x06
     afc:	d7 81       	ldd	r29, Z+7	; 0x07
     afe:	6c e3       	ldi	r22, 0x3C	; 60
     b00:	70 e2       	ldi	r23, 0x20	; 32
     b02:	ce 01       	movw	r24, r28
     b04:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     b08:	66 e0       	ldi	r22, 0x06	; 6
     b0a:	ce 01       	movw	r24, r28
     b0c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	08 95       	ret

00000b16 <_ZN9I2CMaster10StartState11serialDebugEv>:
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	dc 01       	movw	r26, r24
     b1c:	17 96       	adiw	r26, 0x07	; 7
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	18 97       	sbiw	r26, 0x08	; 8
     b24:	c6 81       	ldd	r28, Z+6	; 0x06
     b26:	d7 81       	ldd	r29, Z+7	; 0x07
     b28:	67 e4       	ldi	r22, 0x47	; 71
     b2a:	70 e2       	ldi	r23, 0x20	; 32
     b2c:	ce 01       	movw	r24, r28
     b2e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     b32:	66 e0       	ldi	r22, 0x06	; 6
     b34:	ce 01       	movw	r24, r28
     b36:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	08 95       	ret

00000b40 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	cf 93       	push	r28
     b48:	df 93       	push	r29
     b4a:	ec 01       	movw	r28, r24
     b4c:	ef 81       	ldd	r30, Y+7	; 0x07
     b4e:	f8 85       	ldd	r31, Y+8	; 0x08
     b50:	a4 81       	ldd	r26, Z+4	; 0x04
     b52:	b5 81       	ldd	r27, Z+5	; 0x05
     b54:	14 96       	adiw	r26, 0x04	; 4
     b56:	fc 90       	ld	r15, X
     b58:	06 81       	ldd	r16, Z+6	; 0x06
     b5a:	17 81       	ldd	r17, Z+7	; 0x07
     b5c:	6d e4       	ldi	r22, 0x4D	; 77
     b5e:	70 e2       	ldi	r23, 0x20	; 32
     b60:	c8 01       	movw	r24, r16
     b62:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     b66:	6f 2d       	mov	r22, r15
     b68:	c8 01       	movw	r24, r16
     b6a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
     b6e:	66 e0       	ldi	r22, 0x06	; 6
     b70:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
     b74:	8a 81       	ldd	r24, Y+2	; 0x02
     b76:	9b 81       	ldd	r25, Y+3	; 0x03
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	ff 90       	pop	r15
     b82:	08 95       	ret

00000b84 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     b84:	0f 93       	push	r16
     b86:	1f 93       	push	r17
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	8c 01       	movw	r16, r24
     b8e:	eb 01       	movw	r28, r22
     b90:	e8 81       	ld	r30, Y
     b92:	f9 81       	ldd	r31, Y+1	; 0x01
     b94:	04 8c       	ldd	r0, Z+28	; 0x1c
     b96:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b98:	e0 2d       	mov	r30, r0
     b9a:	cb 01       	movw	r24, r22
     b9c:	19 95       	eicall
     b9e:	2a 85       	ldd	r18, Y+10	; 0x0a
     ba0:	30 e0       	ldi	r19, 0x00	; 0
     ba2:	82 17       	cp	r24, r18
     ba4:	93 07       	cpc	r25, r19
     ba6:	79 f4       	brne	.+30     	; 0xbc6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     ba8:	d8 01       	movw	r26, r16
     baa:	17 96       	adiw	r26, 0x07	; 7
     bac:	ed 91       	ld	r30, X+
     bae:	fc 91       	ld	r31, X
     bb0:	18 97       	sbiw	r26, 0x08	; 8
     bb2:	04 80       	ldd	r0, Z+4	; 0x04
     bb4:	f5 81       	ldd	r31, Z+5	; 0x05
     bb6:	e0 2d       	mov	r30, r0
     bb8:	87 e0       	ldi	r24, 0x07	; 7
     bba:	83 83       	std	Z+3, r24	; 0x03
     bbc:	12 96       	adiw	r26, 0x02	; 2
     bbe:	8d 91       	ld	r24, X+
     bc0:	9c 91       	ld	r25, X
     bc2:	13 97       	sbiw	r26, 0x03	; 3
     bc4:	0e c0       	rjmp	.+28     	; 0xbe2 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     bc6:	d8 01       	movw	r26, r16
     bc8:	17 96       	adiw	r26, 0x07	; 7
     bca:	ed 91       	ld	r30, X+
     bcc:	fc 91       	ld	r31, X
     bce:	18 97       	sbiw	r26, 0x08	; 8
     bd0:	04 80       	ldd	r0, Z+4	; 0x04
     bd2:	f5 81       	ldd	r31, Z+5	; 0x05
     bd4:	e0 2d       	mov	r30, r0
     bd6:	82 e0       	ldi	r24, 0x02	; 2
     bd8:	83 83       	std	Z+3, r24	; 0x03
     bda:	14 96       	adiw	r26, 0x04	; 4
     bdc:	8d 91       	ld	r24, X+
     bde:	9c 91       	ld	r25, X
     be0:	15 97       	sbiw	r26, 0x05	; 5
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	1f 91       	pop	r17
     be8:	0f 91       	pop	r16
     bea:	08 95       	ret

00000bec <_ZN9I2CMaster11TransmitterC1EPS_>:
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
     bf4:	ec 01       	movw	r28, r24
     bf6:	8b 01       	movw	r16, r22
     bf8:	68 83       	st	Y, r22
     bfa:	79 83       	std	Y+1, r23	; 0x01
     bfc:	89 e0       	ldi	r24, 0x09	; 9
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c04:	fc 01       	movw	r30, r24
     c06:	16 82       	std	Z+6, r1	; 0x06
     c08:	89 e9       	ldi	r24, 0x99	; 153
     c0a:	90 e2       	ldi	r25, 0x20	; 32
     c0c:	80 83       	st	Z, r24
     c0e:	91 83       	std	Z+1, r25	; 0x01
     c10:	07 83       	std	Z+7, r16	; 0x07
     c12:	10 87       	std	Z+8, r17	; 0x08
     c14:	ec 83       	std	Y+4, r30	; 0x04
     c16:	fd 83       	std	Y+5, r31	; 0x05
     c18:	8b e0       	ldi	r24, 0x0B	; 11
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c20:	fc 01       	movw	r30, r24
     c22:	8b 89       	ldd	r24, Y+19	; 0x13
     c24:	9c 89       	ldd	r25, Y+20	; 0x14
     c26:	16 82       	std	Z+6, r1	; 0x06
     c28:	21 ea       	ldi	r18, 0xA1	; 161
     c2a:	30 e2       	ldi	r19, 0x20	; 32
     c2c:	20 83       	st	Z, r18
     c2e:	31 83       	std	Z+1, r19	; 0x01
     c30:	07 83       	std	Z+7, r16	; 0x07
     c32:	10 87       	std	Z+8, r17	; 0x08
     c34:	81 87       	std	Z+9, r24	; 0x09
     c36:	92 87       	std	Z+10, r25	; 0x0a
     c38:	ee 83       	std	Y+6, r30	; 0x06
     c3a:	ff 83       	std	Y+7, r31	; 0x07
     c3c:	89 e0       	ldi	r24, 0x09	; 9
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c44:	fc 01       	movw	r30, r24
     c46:	16 82       	std	Z+6, r1	; 0x06
     c48:	81 eb       	ldi	r24, 0xB1	; 177
     c4a:	90 e2       	ldi	r25, 0x20	; 32
     c4c:	80 83       	st	Z, r24
     c4e:	91 83       	std	Z+1, r25	; 0x01
     c50:	07 83       	std	Z+7, r16	; 0x07
     c52:	10 87       	std	Z+8, r17	; 0x08
     c54:	e8 87       	std	Y+8, r30	; 0x08
     c56:	f9 87       	std	Y+9, r31	; 0x09
     c58:	89 e0       	ldi	r24, 0x09	; 9
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c60:	fc 01       	movw	r30, r24
     c62:	16 82       	std	Z+6, r1	; 0x06
     c64:	81 ec       	ldi	r24, 0xC1	; 193
     c66:	90 e2       	ldi	r25, 0x20	; 32
     c68:	80 83       	st	Z, r24
     c6a:	91 83       	std	Z+1, r25	; 0x01
     c6c:	07 83       	std	Z+7, r16	; 0x07
     c6e:	10 87       	std	Z+8, r17	; 0x08
     c70:	ea 87       	std	Y+10, r30	; 0x0a
     c72:	fb 87       	std	Y+11, r31	; 0x0b
     c74:	89 e0       	ldi	r24, 0x09	; 9
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c7c:	fc 01       	movw	r30, r24
     c7e:	16 82       	std	Z+6, r1	; 0x06
     c80:	89 ed       	ldi	r24, 0xD9	; 217
     c82:	90 e2       	ldi	r25, 0x20	; 32
     c84:	80 83       	st	Z, r24
     c86:	91 83       	std	Z+1, r25	; 0x01
     c88:	07 83       	std	Z+7, r16	; 0x07
     c8a:	10 87       	std	Z+8, r17	; 0x08
     c8c:	ec 87       	std	Y+12, r30	; 0x0c
     c8e:	fd 87       	std	Y+13, r31	; 0x0d
     c90:	89 e0       	ldi	r24, 0x09	; 9
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     c98:	fc 01       	movw	r30, r24
     c9a:	16 82       	std	Z+6, r1	; 0x06
     c9c:	81 ed       	ldi	r24, 0xD1	; 209
     c9e:	90 e2       	ldi	r25, 0x20	; 32
     ca0:	80 83       	st	Z, r24
     ca2:	91 83       	std	Z+1, r25	; 0x01
     ca4:	07 83       	std	Z+7, r16	; 0x07
     ca6:	10 87       	std	Z+8, r17	; 0x08
     ca8:	ee 87       	std	Y+14, r30	; 0x0e
     caa:	ff 87       	std	Y+15, r31	; 0x0f
     cac:	80 e1       	ldi	r24, 0x10	; 16
     cae:	97 e2       	ldi	r25, 0x27	; 39
     cb0:	8b 8b       	std	Y+19, r24	; 0x13
     cb2:	9c 8b       	std	Y+20, r25	; 0x14
     cb4:	8e 81       	ldd	r24, Y+6	; 0x06
     cb6:	9f 81       	ldd	r25, Y+7	; 0x07
     cb8:	ec 81       	ldd	r30, Y+4	; 0x04
     cba:	fd 81       	ldd	r31, Y+5	; 0x05
     cbc:	82 83       	std	Z+2, r24	; 0x02
     cbe:	93 83       	std	Z+3, r25	; 0x03
     cc0:	84 83       	std	Z+4, r24	; 0x04
     cc2:	95 83       	std	Z+5, r25	; 0x05
     cc4:	8c 85       	ldd	r24, Y+12	; 0x0c
     cc6:	9d 85       	ldd	r25, Y+13	; 0x0d
     cc8:	28 85       	ldd	r18, Y+8	; 0x08
     cca:	39 85       	ldd	r19, Y+9	; 0x09
     ccc:	ee 81       	ldd	r30, Y+6	; 0x06
     cce:	ff 81       	ldd	r31, Y+7	; 0x07
     cd0:	22 83       	std	Z+2, r18	; 0x02
     cd2:	33 83       	std	Z+3, r19	; 0x03
     cd4:	84 83       	std	Z+4, r24	; 0x04
     cd6:	95 83       	std	Z+5, r25	; 0x05
     cd8:	8a 85       	ldd	r24, Y+10	; 0x0a
     cda:	9b 85       	ldd	r25, Y+11	; 0x0b
     cdc:	e8 85       	ldd	r30, Y+8	; 0x08
     cde:	f9 85       	ldd	r31, Y+9	; 0x09
     ce0:	82 83       	std	Z+2, r24	; 0x02
     ce2:	93 83       	std	Z+3, r25	; 0x03
     ce4:	84 83       	std	Z+4, r24	; 0x04
     ce6:	95 83       	std	Z+5, r25	; 0x05
     ce8:	8e 81       	ldd	r24, Y+6	; 0x06
     cea:	9f 81       	ldd	r25, Y+7	; 0x07
     cec:	2e 85       	ldd	r18, Y+14	; 0x0e
     cee:	3f 85       	ldd	r19, Y+15	; 0x0f
     cf0:	ea 85       	ldd	r30, Y+10	; 0x0a
     cf2:	fb 85       	ldd	r31, Y+11	; 0x0b
     cf4:	22 83       	std	Z+2, r18	; 0x02
     cf6:	33 83       	std	Z+3, r19	; 0x03
     cf8:	84 83       	std	Z+4, r24	; 0x04
     cfa:	95 83       	std	Z+5, r25	; 0x05
     cfc:	df 91       	pop	r29
     cfe:	cf 91       	pop	r28
     d00:	1f 91       	pop	r17
     d02:	0f 91       	pop	r16
     d04:	08 95       	ret

00000d06 <_ZN9I2CMaster8ReceiverC1EPS_>:
     d06:	0f 93       	push	r16
     d08:	1f 93       	push	r17
     d0a:	cf 93       	push	r28
     d0c:	df 93       	push	r29
     d0e:	ec 01       	movw	r28, r24
     d10:	8b 01       	movw	r16, r22
     d12:	68 83       	st	Y, r22
     d14:	79 83       	std	Y+1, r23	; 0x01
     d16:	89 e0       	ldi	r24, 0x09	; 9
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     d1e:	fc 01       	movw	r30, r24
     d20:	16 82       	std	Z+6, r1	; 0x06
     d22:	89 e9       	ldi	r24, 0x99	; 153
     d24:	90 e2       	ldi	r25, 0x20	; 32
     d26:	80 83       	st	Z, r24
     d28:	91 83       	std	Z+1, r25	; 0x01
     d2a:	07 83       	std	Z+7, r16	; 0x07
     d2c:	10 87       	std	Z+8, r17	; 0x08
     d2e:	ec 83       	std	Y+4, r30	; 0x04
     d30:	fd 83       	std	Y+5, r31	; 0x05
     d32:	8b e0       	ldi	r24, 0x0B	; 11
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     d3a:	fc 01       	movw	r30, r24
     d3c:	8b 89       	ldd	r24, Y+19	; 0x13
     d3e:	9c 89       	ldd	r25, Y+20	; 0x14
     d40:	16 82       	std	Z+6, r1	; 0x06
     d42:	29 ea       	ldi	r18, 0xA9	; 169
     d44:	30 e2       	ldi	r19, 0x20	; 32
     d46:	20 83       	st	Z, r18
     d48:	31 83       	std	Z+1, r19	; 0x01
     d4a:	07 83       	std	Z+7, r16	; 0x07
     d4c:	10 87       	std	Z+8, r17	; 0x08
     d4e:	81 87       	std	Z+9, r24	; 0x09
     d50:	92 87       	std	Z+10, r25	; 0x0a
     d52:	ee 83       	std	Y+6, r30	; 0x06
     d54:	ff 83       	std	Y+7, r31	; 0x07
     d56:	89 e0       	ldi	r24, 0x09	; 9
     d58:	90 e0       	ldi	r25, 0x00	; 0
     d5a:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     d5e:	fc 01       	movw	r30, r24
     d60:	16 82       	std	Z+6, r1	; 0x06
     d62:	89 eb       	ldi	r24, 0xB9	; 185
     d64:	90 e2       	ldi	r25, 0x20	; 32
     d66:	80 83       	st	Z, r24
     d68:	91 83       	std	Z+1, r25	; 0x01
     d6a:	07 83       	std	Z+7, r16	; 0x07
     d6c:	10 87       	std	Z+8, r17	; 0x08
     d6e:	e8 87       	std	Y+8, r30	; 0x08
     d70:	f9 87       	std	Y+9, r31	; 0x09
     d72:	89 e0       	ldi	r24, 0x09	; 9
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     d7a:	fc 01       	movw	r30, r24
     d7c:	16 82       	std	Z+6, r1	; 0x06
     d7e:	89 ec       	ldi	r24, 0xC9	; 201
     d80:	90 e2       	ldi	r25, 0x20	; 32
     d82:	80 83       	st	Z, r24
     d84:	91 83       	std	Z+1, r25	; 0x01
     d86:	07 83       	std	Z+7, r16	; 0x07
     d88:	10 87       	std	Z+8, r17	; 0x08
     d8a:	ea 87       	std	Y+10, r30	; 0x0a
     d8c:	fb 87       	std	Y+11, r31	; 0x0b
     d8e:	89 e0       	ldi	r24, 0x09	; 9
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     d96:	fc 01       	movw	r30, r24
     d98:	16 82       	std	Z+6, r1	; 0x06
     d9a:	89 ed       	ldi	r24, 0xD9	; 217
     d9c:	90 e2       	ldi	r25, 0x20	; 32
     d9e:	80 83       	st	Z, r24
     da0:	91 83       	std	Z+1, r25	; 0x01
     da2:	07 83       	std	Z+7, r16	; 0x07
     da4:	10 87       	std	Z+8, r17	; 0x08
     da6:	ec 87       	std	Y+12, r30	; 0x0c
     da8:	fd 87       	std	Y+13, r31	; 0x0d
     daa:	89 e0       	ldi	r24, 0x09	; 9
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     db2:	fc 01       	movw	r30, r24
     db4:	16 82       	std	Z+6, r1	; 0x06
     db6:	81 ed       	ldi	r24, 0xD1	; 209
     db8:	90 e2       	ldi	r25, 0x20	; 32
     dba:	80 83       	st	Z, r24
     dbc:	91 83       	std	Z+1, r25	; 0x01
     dbe:	07 83       	std	Z+7, r16	; 0x07
     dc0:	10 87       	std	Z+8, r17	; 0x08
     dc2:	ee 87       	std	Y+14, r30	; 0x0e
     dc4:	ff 87       	std	Y+15, r31	; 0x0f
     dc6:	80 e1       	ldi	r24, 0x10	; 16
     dc8:	97 e2       	ldi	r25, 0x27	; 39
     dca:	8b 8b       	std	Y+19, r24	; 0x13
     dcc:	9c 8b       	std	Y+20, r25	; 0x14
     dce:	8e 81       	ldd	r24, Y+6	; 0x06
     dd0:	9f 81       	ldd	r25, Y+7	; 0x07
     dd2:	ec 81       	ldd	r30, Y+4	; 0x04
     dd4:	fd 81       	ldd	r31, Y+5	; 0x05
     dd6:	82 83       	std	Z+2, r24	; 0x02
     dd8:	93 83       	std	Z+3, r25	; 0x03
     dda:	84 83       	std	Z+4, r24	; 0x04
     ddc:	95 83       	std	Z+5, r25	; 0x05
     dde:	8c 85       	ldd	r24, Y+12	; 0x0c
     de0:	9d 85       	ldd	r25, Y+13	; 0x0d
     de2:	28 85       	ldd	r18, Y+8	; 0x08
     de4:	39 85       	ldd	r19, Y+9	; 0x09
     de6:	ee 81       	ldd	r30, Y+6	; 0x06
     de8:	ff 81       	ldd	r31, Y+7	; 0x07
     dea:	22 83       	std	Z+2, r18	; 0x02
     dec:	33 83       	std	Z+3, r19	; 0x03
     dee:	84 83       	std	Z+4, r24	; 0x04
     df0:	95 83       	std	Z+5, r25	; 0x05
     df2:	8a 85       	ldd	r24, Y+10	; 0x0a
     df4:	9b 85       	ldd	r25, Y+11	; 0x0b
     df6:	e8 85       	ldd	r30, Y+8	; 0x08
     df8:	f9 85       	ldd	r31, Y+9	; 0x09
     dfa:	82 83       	std	Z+2, r24	; 0x02
     dfc:	93 83       	std	Z+3, r25	; 0x03
     dfe:	84 83       	std	Z+4, r24	; 0x04
     e00:	95 83       	std	Z+5, r25	; 0x05
     e02:	8e 81       	ldd	r24, Y+6	; 0x06
     e04:	9f 81       	ldd	r25, Y+7	; 0x07
     e06:	2e 85       	ldd	r18, Y+14	; 0x0e
     e08:	3f 85       	ldd	r19, Y+15	; 0x0f
     e0a:	ea 85       	ldd	r30, Y+10	; 0x0a
     e0c:	fb 85       	ldd	r31, Y+11	; 0x0b
     e0e:	22 83       	std	Z+2, r18	; 0x02
     e10:	33 83       	std	Z+3, r19	; 0x03
     e12:	84 83       	std	Z+4, r24	; 0x04
     e14:	95 83       	std	Z+5, r25	; 0x05
     e16:	df 91       	pop	r29
     e18:	cf 91       	pop	r28
     e1a:	1f 91       	pop	r17
     e1c:	0f 91       	pop	r16
     e1e:	08 95       	ret

00000e20 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	cf 93       	push	r28
     e26:	df 93       	push	r29
     e28:	ec 01       	movw	r28, r24
     e2a:	8b 01       	movw	r16, r22
     e2c:	8c 81       	ldd	r24, Y+4	; 0x04
     e2e:	9d 81       	ldd	r25, Y+5	; 0x05
     e30:	8a 83       	std	Y+2, r24	; 0x02
     e32:	9b 83       	std	Y+3, r25	; 0x03
     e34:	2e 85       	ldd	r18, Y+14	; 0x0e
     e36:	3f 85       	ldd	r19, Y+15	; 0x0f
     e38:	82 17       	cp	r24, r18
     e3a:	93 07       	cpc	r25, r19
     e3c:	d9 f0       	breq	.+54     	; 0xe74 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     e3e:	2c 85       	ldd	r18, Y+12	; 0x0c
     e40:	3d 85       	ldd	r19, Y+13	; 0x0d
     e42:	82 17       	cp	r24, r18
     e44:	93 07       	cpc	r25, r19
     e46:	31 f4       	brne	.+12     	; 0xe54 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     e48:	17 c0       	rjmp	.+46     	; 0xe78 <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     e4a:	2c 85       	ldd	r18, Y+12	; 0x0c
     e4c:	3d 85       	ldd	r19, Y+13	; 0x0d
     e4e:	28 17       	cp	r18, r24
     e50:	39 07       	cpc	r19, r25
     e52:	99 f0       	breq	.+38     	; 0xe7a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e54:	dc 01       	movw	r26, r24
     e56:	ed 91       	ld	r30, X+
     e58:	fc 91       	ld	r31, X
     e5a:	01 90       	ld	r0, Z+
     e5c:	f0 81       	ld	r31, Z
     e5e:	e0 2d       	mov	r30, r0
     e60:	b8 01       	movw	r22, r16
     e62:	19 95       	eicall
     e64:	8a 83       	std	Y+2, r24	; 0x02
     e66:	9b 83       	std	Y+3, r25	; 0x03
     e68:	2e 85       	ldd	r18, Y+14	; 0x0e
     e6a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e6c:	28 17       	cp	r18, r24
     e6e:	39 07       	cpc	r19, r25
     e70:	61 f7       	brne	.-40     	; 0xe4a <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     e72:	03 c0       	rjmp	.+6      	; 0xe7a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e74:	c9 01       	movw	r24, r18
     e76:	01 c0       	rjmp	.+2      	; 0xe7a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e78:	c9 01       	movw	r24, r18
     e7a:	dc 01       	movw	r26, r24
     e7c:	ed 91       	ld	r30, X+
     e7e:	fc 91       	ld	r31, X
     e80:	01 90       	ld	r0, Z+
     e82:	f0 81       	ld	r31, Z
     e84:	e0 2d       	mov	r30, r0
     e86:	b8 01       	movw	r22, r16
     e88:	19 95       	eicall
     e8a:	81 e0       	ldi	r24, 0x01	; 1
     e8c:	4a 81       	ldd	r20, Y+2	; 0x02
     e8e:	5b 81       	ldd	r21, Y+3	; 0x03
     e90:	2e 85       	ldd	r18, Y+14	; 0x0e
     e92:	3f 85       	ldd	r19, Y+15	; 0x0f
     e94:	42 17       	cp	r20, r18
     e96:	53 07       	cpc	r21, r19
     e98:	09 f0       	breq	.+2      	; 0xe9c <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	df 91       	pop	r29
     e9e:	cf 91       	pop	r28
     ea0:	1f 91       	pop	r17
     ea2:	0f 91       	pop	r16
     ea4:	08 95       	ret

00000ea6 <_ZN9I2CMaster8Receiver3runER6Packet>:
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	cf 93       	push	r28
     eac:	df 93       	push	r29
     eae:	ec 01       	movw	r28, r24
     eb0:	8b 01       	movw	r16, r22
     eb2:	8c 81       	ldd	r24, Y+4	; 0x04
     eb4:	9d 81       	ldd	r25, Y+5	; 0x05
     eb6:	8a 83       	std	Y+2, r24	; 0x02
     eb8:	9b 83       	std	Y+3, r25	; 0x03
     eba:	2e 85       	ldd	r18, Y+14	; 0x0e
     ebc:	3f 85       	ldd	r19, Y+15	; 0x0f
     ebe:	82 17       	cp	r24, r18
     ec0:	93 07       	cpc	r25, r19
     ec2:	d9 f0       	breq	.+54     	; 0xefa <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     ec4:	2c 85       	ldd	r18, Y+12	; 0x0c
     ec6:	3d 85       	ldd	r19, Y+13	; 0x0d
     ec8:	82 17       	cp	r24, r18
     eca:	93 07       	cpc	r25, r19
     ecc:	31 f4       	brne	.+12     	; 0xeda <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     ece:	17 c0       	rjmp	.+46     	; 0xefe <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     ed0:	2c 85       	ldd	r18, Y+12	; 0x0c
     ed2:	3d 85       	ldd	r19, Y+13	; 0x0d
     ed4:	28 17       	cp	r18, r24
     ed6:	39 07       	cpc	r19, r25
     ed8:	99 f0       	breq	.+38     	; 0xf00 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     eda:	dc 01       	movw	r26, r24
     edc:	ed 91       	ld	r30, X+
     ede:	fc 91       	ld	r31, X
     ee0:	01 90       	ld	r0, Z+
     ee2:	f0 81       	ld	r31, Z
     ee4:	e0 2d       	mov	r30, r0
     ee6:	b8 01       	movw	r22, r16
     ee8:	19 95       	eicall
     eea:	8a 83       	std	Y+2, r24	; 0x02
     eec:	9b 83       	std	Y+3, r25	; 0x03
     eee:	2e 85       	ldd	r18, Y+14	; 0x0e
     ef0:	3f 85       	ldd	r19, Y+15	; 0x0f
     ef2:	28 17       	cp	r18, r24
     ef4:	39 07       	cpc	r19, r25
     ef6:	61 f7       	brne	.-40     	; 0xed0 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     ef8:	03 c0       	rjmp	.+6      	; 0xf00 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     efa:	c9 01       	movw	r24, r18
     efc:	01 c0       	rjmp	.+2      	; 0xf00 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     efe:	c9 01       	movw	r24, r18
     f00:	dc 01       	movw	r26, r24
     f02:	ed 91       	ld	r30, X+
     f04:	fc 91       	ld	r31, X
     f06:	01 90       	ld	r0, Z+
     f08:	f0 81       	ld	r31, Z
     f0a:	e0 2d       	mov	r30, r0
     f0c:	b8 01       	movw	r22, r16
     f0e:	19 95       	eicall
     f10:	c8 01       	movw	r24, r16
     f12:	df 91       	pop	r29
     f14:	cf 91       	pop	r28
     f16:	1f 91       	pop	r17
     f18:	0f 91       	pop	r16
     f1a:	08 95       	ret

00000f1c <_ZN9I2CMaster12set_baudrateEm>:
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ec 01       	movw	r28, r24
     f22:	9a 01       	movw	r18, r20
     f24:	ab 01       	movw	r20, r22
     f26:	22 0f       	add	r18, r18
     f28:	33 1f       	adc	r19, r19
     f2a:	44 1f       	adc	r20, r20
     f2c:	55 1f       	adc	r21, r21
     f2e:	60 e0       	ldi	r22, 0x00	; 0
     f30:	78 e4       	ldi	r23, 0x48	; 72
     f32:	88 ee       	ldi	r24, 0xE8	; 232
     f34:	91 e0       	ldi	r25, 0x01	; 1
     f36:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
     f3a:	25 50       	subi	r18, 0x05	; 5
     f3c:	2a 87       	std	Y+10, r18	; 0x0a
     f3e:	ec 81       	ldd	r30, Y+4	; 0x04
     f40:	fd 81       	ldd	r31, Y+5	; 0x05
     f42:	25 83       	std	Z+5, r18	; 0x05
     f44:	df 91       	pop	r29
     f46:	cf 91       	pop	r28
     f48:	08 95       	ret

00000f4a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
     f4a:	ef 92       	push	r14
     f4c:	ff 92       	push	r15
     f4e:	0f 93       	push	r16
     f50:	1f 93       	push	r17
     f52:	cf 93       	push	r28
     f54:	df 93       	push	r29
     f56:	ec 01       	movw	r28, r24
     f58:	7b 01       	movw	r14, r22
     f5a:	ba 01       	movw	r22, r20
     f5c:	a9 01       	movw	r20, r18
     f5e:	ec 82       	std	Y+4, r14	; 0x04
     f60:	fd 82       	std	Y+5, r15	; 0x05
     f62:	0e 83       	std	Y+6, r16	; 0x06
     f64:	1f 83       	std	Y+7, r17	; 0x07
     f66:	4b 87       	std	Y+11, r20	; 0x0b
     f68:	5c 87       	std	Y+12, r21	; 0x0c
     f6a:	6d 87       	std	Y+13, r22	; 0x0d
     f6c:	7e 87       	std	Y+14, r23	; 0x0e
     f6e:	80 e8       	ldi	r24, 0x80	; 128
     f70:	e8 16       	cp	r14, r24
     f72:	84 e0       	ldi	r24, 0x04	; 4
     f74:	f8 06       	cpc	r15, r24
     f76:	29 f4       	brne	.+10     	; 0xf82 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
     f78:	80 e4       	ldi	r24, 0x40	; 64
     f7a:	96 e0       	ldi	r25, 0x06	; 6
     f7c:	88 87       	std	Y+8, r24	; 0x08
     f7e:	99 87       	std	Y+9, r25	; 0x09
     f80:	09 c0       	rjmp	.+18     	; 0xf94 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     f82:	e0 ea       	ldi	r30, 0xA0	; 160
     f84:	ee 16       	cp	r14, r30
     f86:	e4 e0       	ldi	r30, 0x04	; 4
     f88:	fe 06       	cpc	r15, r30
     f8a:	21 f4       	brne	.+8      	; 0xf94 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     f8c:	80 e8       	ldi	r24, 0x80	; 128
     f8e:	96 e0       	ldi	r25, 0x06	; 6
     f90:	88 87       	std	Y+8, r24	; 0x08
     f92:	99 87       	std	Y+9, r25	; 0x09
     f94:	e8 85       	ldd	r30, Y+8	; 0x08
     f96:	f9 85       	ldd	r31, Y+9	; 0x09
     f98:	83 e0       	ldi	r24, 0x03	; 3
     f9a:	81 83       	std	Z+1, r24	; 0x01
     f9c:	e8 85       	ldd	r30, Y+8	; 0x08
     f9e:	f9 85       	ldd	r31, Y+9	; 0x09
     fa0:	88 e3       	ldi	r24, 0x38	; 56
     fa2:	80 8b       	std	Z+16, r24	; 0x10
     fa4:	e8 85       	ldd	r30, Y+8	; 0x08
     fa6:	f9 85       	ldd	r31, Y+9	; 0x09
     fa8:	81 8b       	std	Z+17, r24	; 0x11
     faa:	82 e0       	ldi	r24, 0x02	; 2
     fac:	f7 01       	movw	r30, r14
     fae:	82 83       	std	Z+2, r24	; 0x02
     fb0:	ce 01       	movw	r24, r28
     fb2:	0e 94 8e 07 	call	0xf1c	; 0xf1c <_ZN9I2CMaster12set_baudrateEm>
     fb6:	f7 01       	movw	r30, r14
     fb8:	84 81       	ldd	r24, Z+4	; 0x04
     fba:	8d 6c       	ori	r24, 0xCD	; 205
     fbc:	84 83       	std	Z+4, r24	; 0x04
     fbe:	88 e0       	ldi	r24, 0x08	; 8
     fc0:	81 83       	std	Z+1, r24	; 0x01
     fc2:	85 e1       	ldi	r24, 0x15	; 21
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     fca:	7c 01       	movw	r14, r24
     fcc:	be 01       	movw	r22, r28
     fce:	0e 94 f6 05 	call	0xbec	; 0xbec <_ZN9I2CMaster11TransmitterC1EPS_>
     fd2:	e8 82       	st	Y, r14
     fd4:	f9 82       	std	Y+1, r15	; 0x01
     fd6:	86 e1       	ldi	r24, 0x16	; 22
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
     fde:	7c 01       	movw	r14, r24
     fe0:	be 01       	movw	r22, r28
     fe2:	0e 94 83 06 	call	0xd06	; 0xd06 <_ZN9I2CMaster8ReceiverC1EPS_>
     fe6:	ea 82       	std	Y+2, r14	; 0x02
     fe8:	fb 82       	std	Y+3, r15	; 0x03
     fea:	0e 80       	ldd	r0, Y+6	; 0x06
     fec:	df 81       	ldd	r29, Y+7	; 0x07
     fee:	c0 2d       	mov	r28, r0
     ff0:	6f e6       	ldi	r22, 0x6F	; 111
     ff2:	70 e2       	ldi	r23, 0x20	; 32
     ff4:	ce 01       	movw	r24, r28
     ff6:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
     ffa:	66 e0       	ldi	r22, 0x06	; 6
     ffc:	ce 01       	movw	r24, r28
     ffe:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	ef 90       	pop	r14
    100e:	08 95       	ret

00001010 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1010:	dc 01       	movw	r26, r24
    1012:	14 96       	adiw	r26, 0x04	; 4
    1014:	ed 91       	ld	r30, X+
    1016:	fc 91       	ld	r31, X
    1018:	15 97       	sbiw	r26, 0x05	; 5
    101a:	83 81       	ldd	r24, Z+3	; 0x03
    101c:	81 60       	ori	r24, 0x01	; 1
    101e:	83 83       	std	Z+3, r24	; 0x03
    1020:	08 95       	ret

00001022 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1022:	0f 93       	push	r16
    1024:	1f 93       	push	r17
    1026:	cf 93       	push	r28
    1028:	df 93       	push	r29
    102a:	ec 01       	movw	r28, r24
    102c:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    102e:	db 01       	movw	r26, r22
    1030:	ed 91       	ld	r30, X+
    1032:	fc 91       	ld	r31, X
    1034:	02 84       	ldd	r0, Z+10	; 0x0a
    1036:	f3 85       	ldd	r31, Z+11	; 0x0b
    1038:	e0 2d       	mov	r30, r0
    103a:	00 e0       	ldi	r16, 0x00	; 0
    103c:	10 e0       	ldi	r17, 0x00	; 0
    103e:	b8 01       	movw	r22, r16
    1040:	19 95       	eicall
  driver_->send_start();
    1042:	8f 81       	ldd	r24, Y+7	; 0x07
    1044:	98 85       	ldd	r25, Y+8	; 0x08
    1046:	0e 94 08 08 	call	0x1010	; 0x1010 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    104a:	ef 81       	ldd	r30, Y+7	; 0x07
    104c:	f8 85       	ldd	r31, Y+8	; 0x08
    104e:	04 80       	ldd	r0, Z+4	; 0x04
    1050:	f5 81       	ldd	r31, Z+5	; 0x05
    1052:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1054:	d8 01       	movw	r26, r16
    1056:	8c 91       	ld	r24, X
    1058:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    105a:	8a 81       	ldd	r24, Y+2	; 0x02
    105c:	9b 81       	ldd	r25, Y+3	; 0x03
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	1f 91       	pop	r17
    1064:	0f 91       	pop	r16
    1066:	08 95       	ret

00001068 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    1068:	fc 01       	movw	r30, r24
    106a:	84 81       	ldd	r24, Z+4	; 0x04
    106c:	95 81       	ldd	r25, Z+5	; 0x05
    106e:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
		}
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	08 95       	ret

00001076 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    1076:	fc 01       	movw	r30, r24
    1078:	84 81       	ldd	r24, Z+4	; 0x04
    107a:	95 81       	ldd	r25, Z+5	; 0x05
    107c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    1080:	91 e0       	ldi	r25, 0x01	; 1
    1082:	81 11       	cpse	r24, r1
    1084:	01 c0       	rjmp	.+2      	; 0x1088 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    1086:	90 e0       	ldi	r25, 0x00	; 0
		}
    1088:	89 2f       	mov	r24, r25
    108a:	08 95       	ret

0000108c <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    108c:	fc 01       	movw	r30, r24
    108e:	84 81       	ldd	r24, Z+4	; 0x04
    1090:	95 81       	ldd	r25, Z+5	; 0x05
    1092:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    1096:	91 e0       	ldi	r25, 0x01	; 1
    1098:	81 11       	cpse	r24, r1
    109a:	90 e0       	ldi	r25, 0x00	; 0
		}
    109c:	89 2f       	mov	r24, r25
    109e:	08 95       	ret

000010a0 <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    10a0:	fc 01       	movw	r30, r24
    10a2:	84 81       	ldd	r24, Z+4	; 0x04
    10a4:	95 81       	ldd	r25, Z+5	; 0x05
    10a6:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
		}
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	08 95       	ret

000010ae <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    10ae:	fc 01       	movw	r30, r24
    10b0:	84 81       	ldd	r24, Z+4	; 0x04
    10b2:	95 81       	ldd	r25, Z+5	; 0x05
    10b4:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    10b8:	91 e0       	ldi	r25, 0x01	; 1
    10ba:	81 11       	cpse	r24, r1
    10bc:	01 c0       	rjmp	.+2      	; 0x10c0 <_ZN9frt_queueIhE9not_emptyEv+0x12>
    10be:	90 e0       	ldi	r25, 0x00	; 0
		}
    10c0:	89 2f       	mov	r24, r25
    10c2:	08 95       	ret

000010c4 <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    10c4:	fc 01       	movw	r30, r24
    10c6:	84 81       	ldd	r24, Z+4	; 0x04
    10c8:	95 81       	ldd	r25, Z+5	; 0x05
    10ca:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    10ce:	91 e0       	ldi	r25, 0x01	; 1
    10d0:	81 11       	cpse	r24, r1
    10d2:	90 e0       	ldi	r25, 0x00	; 0
		}
    10d4:	89 2f       	mov	r24, r25
    10d6:	08 95       	ret

000010d8 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    10d8:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    10da:	01 e0       	ldi	r16, 0x01	; 1
    10dc:	2f ef       	ldi	r18, 0xFF	; 255
    10de:	3f ef       	ldi	r19, 0xFF	; 255
    10e0:	a9 01       	movw	r20, r18
    10e2:	fc 01       	movw	r30, r24
    10e4:	84 81       	ldd	r24, Z+4	; 0x04
    10e6:	95 81       	ldd	r25, Z+5	; 0x05
    10e8:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    10ec:	0f 91       	pop	r16
    10ee:	08 95       	ret

000010f0 <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    10f0:	0f 93       	push	r16
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
    10f6:	1f 92       	push	r1
    10f8:	cd b7       	in	r28, 0x3d	; 61
    10fa:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    10fc:	01 e0       	ldi	r16, 0x01	; 1
    10fe:	2f ef       	ldi	r18, 0xFF	; 255
    1100:	3f ef       	ldi	r19, 0xFF	; 255
    1102:	a9 01       	movw	r20, r18
    1104:	be 01       	movw	r22, r28
    1106:	6f 5f       	subi	r22, 0xFF	; 255
    1108:	7f 4f       	sbci	r23, 0xFF	; 255
    110a:	fc 01       	movw	r30, r24
    110c:	84 81       	ldd	r24, Z+4	; 0x04
    110e:	95 81       	ldd	r25, Z+5	; 0x05
    1110:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	0f 90       	pop	r0
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	0f 91       	pop	r16
    111e:	08 95       	ret

00001120 <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    1120:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    1122:	00 e0       	ldi	r16, 0x00	; 0
    1124:	2f ef       	ldi	r18, 0xFF	; 255
    1126:	3f ef       	ldi	r19, 0xFF	; 255
    1128:	a9 01       	movw	r20, r18
    112a:	fc 01       	movw	r30, r24
    112c:	84 81       	ldd	r24, Z+4	; 0x04
    112e:	95 81       	ldd	r25, Z+5	; 0x05
    1130:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    1134:	0f 91       	pop	r16
    1136:	08 95       	ret

00001138 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    1138:	0f 93       	push	r16
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	1f 92       	push	r1
    1140:	cd b7       	in	r28, 0x3d	; 61
    1142:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    1144:	00 e0       	ldi	r16, 0x00	; 0
    1146:	2f ef       	ldi	r18, 0xFF	; 255
    1148:	3f ef       	ldi	r19, 0xFF	; 255
    114a:	a9 01       	movw	r20, r18
    114c:	be 01       	movw	r22, r28
    114e:	6f 5f       	subi	r22, 0xFF	; 255
    1150:	7f 4f       	sbci	r23, 0xFF	; 255
    1152:	fc 01       	movw	r30, r24
    1154:	84 81       	ldd	r24, Z+4	; 0x04
    1156:	95 81       	ldd	r25, Z+5	; 0x05
    1158:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    115c:	89 81       	ldd	r24, Y+1	; 0x01
    115e:	0f 90       	pop	r0
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	0f 91       	pop	r16
    1166:	08 95       	ret

00001168 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	1f 92       	push	r1
    116e:	cd b7       	in	r28, 0x3d	; 61
    1170:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    1172:	ae 01       	movw	r20, r28
    1174:	4f 5f       	subi	r20, 0xFF	; 255
    1176:	5f 4f       	sbci	r21, 0xFF	; 255
    1178:	fc 01       	movw	r30, r24
    117a:	84 81       	ldd	r24, Z+4	; 0x04
    117c:	95 81       	ldd	r25, Z+5	; 0x05
    117e:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
}
    1182:	0f 90       	pop	r0
    1184:	df 91       	pop	r29
    1186:	cf 91       	pop	r28
    1188:	08 95       	ret

0000118a <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    118a:	cf 93       	push	r28
    118c:	df 93       	push	r29
    118e:	1f 92       	push	r1
    1190:	1f 92       	push	r1
    1192:	cd b7       	in	r28, 0x3d	; 61
    1194:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    1196:	ae 01       	movw	r20, r28
    1198:	4e 5f       	subi	r20, 0xFE	; 254
    119a:	5f 4f       	sbci	r21, 0xFF	; 255
    119c:	be 01       	movw	r22, r28
    119e:	6f 5f       	subi	r22, 0xFF	; 255
    11a0:	7f 4f       	sbci	r23, 0xFF	; 255
    11a2:	fc 01       	movw	r30, r24
    11a4:	84 81       	ldd	r24, Z+4	; 0x04
    11a6:	95 81       	ldd	r25, Z+5	; 0x05
    11a8:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
	return (recv_item);
}
    11ac:	89 81       	ldd	r24, Y+1	; 0x01
    11ae:	0f 90       	pop	r0
    11b0:	0f 90       	pop	r0
    11b2:	df 91       	pop	r29
    11b4:	cf 91       	pop	r28
    11b6:	08 95       	ret

000011b8 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    11b8:	cf 93       	push	r28
    11ba:	df 93       	push	r29
    11bc:	1f 92       	push	r1
    11be:	cd b7       	in	r28, 0x3d	; 61
    11c0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    11c2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    11c4:	21 e0       	ldi	r18, 0x01	; 1
    11c6:	ae 01       	movw	r20, r28
    11c8:	4f 5f       	subi	r20, 0xFF	; 255
    11ca:	5f 4f       	sbci	r21, 0xFF	; 255
    11cc:	fc 01       	movw	r30, r24
    11ce:	84 81       	ldd	r24, Z+4	; 0x04
    11d0:	95 81       	ldd	r25, Z+5	; 0x05
    11d2:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    11d6:	91 e0       	ldi	r25, 0x01	; 1
    11d8:	81 11       	cpse	r24, r1
    11da:	01 c0       	rjmp	.+2      	; 0x11de <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    11dc:	90 e0       	ldi	r25, 0x00	; 0
}
    11de:	89 2f       	mov	r24, r25
    11e0:	0f 90       	pop	r0
    11e2:	df 91       	pop	r29
    11e4:	cf 91       	pop	r28
    11e6:	08 95       	ret

000011e8 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    11e8:	cf 93       	push	r28
    11ea:	df 93       	push	r29
    11ec:	1f 92       	push	r1
    11ee:	cd b7       	in	r28, 0x3d	; 61
    11f0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    11f2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    11f4:	20 e0       	ldi	r18, 0x00	; 0
    11f6:	ae 01       	movw	r20, r28
    11f8:	4f 5f       	subi	r20, 0xFF	; 255
    11fa:	5f 4f       	sbci	r21, 0xFF	; 255
    11fc:	fc 01       	movw	r30, r24
    11fe:	84 81       	ldd	r24, Z+4	; 0x04
    1200:	95 81       	ldd	r25, Z+5	; 0x05
    1202:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1206:	91 e0       	ldi	r25, 0x01	; 1
    1208:	81 11       	cpse	r24, r1
    120a:	01 c0       	rjmp	.+2      	; 0x120e <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    120c:	90 e0       	ldi	r25, 0x00	; 0
}
    120e:	89 2f       	mov	r24, r25
    1210:	0f 90       	pop	r0
    1212:	df 91       	pop	r29
    1214:	cf 91       	pop	r28
    1216:	08 95       	ret

00001218 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    1218:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    121a:	fc 01       	movw	r30, r24
    121c:	26 81       	ldd	r18, Z+6	; 0x06
    121e:	37 81       	ldd	r19, Z+7	; 0x07
    1220:	40 85       	ldd	r20, Z+8	; 0x08
    1222:	51 85       	ldd	r21, Z+9	; 0x09
    1224:	01 e0       	ldi	r16, 0x01	; 1
    1226:	84 81       	ldd	r24, Z+4	; 0x04
    1228:	95 81       	ldd	r25, Z+5	; 0x05
    122a:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    122e:	91 e0       	ldi	r25, 0x01	; 1
    1230:	81 11       	cpse	r24, r1
    1232:	01 c0       	rjmp	.+2      	; 0x1236 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    1234:	90 e0       	ldi	r25, 0x00	; 0
		}
    1236:	89 2f       	mov	r24, r25
    1238:	0f 91       	pop	r16
    123a:	08 95       	ret

0000123c <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    123c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    123e:	fc 01       	movw	r30, r24
    1240:	26 81       	ldd	r18, Z+6	; 0x06
    1242:	37 81       	ldd	r19, Z+7	; 0x07
    1244:	40 85       	ldd	r20, Z+8	; 0x08
    1246:	51 85       	ldd	r21, Z+9	; 0x09
    1248:	00 e0       	ldi	r16, 0x00	; 0
    124a:	84 81       	ldd	r24, Z+4	; 0x04
    124c:	95 81       	ldd	r25, Z+5	; 0x05
    124e:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    1252:	91 e0       	ldi	r25, 0x01	; 1
    1254:	81 11       	cpse	r24, r1
    1256:	01 c0       	rjmp	.+2      	; 0x125a <_ZN9frt_queueIhE3putERKh+0x1e>
    1258:	90 e0       	ldi	r25, 0x00	; 0
		}
    125a:	89 2f       	mov	r24, r25
    125c:	0f 91       	pop	r16
    125e:	08 95       	ret

00001260 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::is_ready()
{
  return driver_->is_ready(slaveAddr_);
}
    1260:	0f 93       	push	r16
    1262:	1f 93       	push	r17
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	8c 01       	movw	r16, r24
    126a:	eb 01       	movw	r28, r22
    126c:	bc 01       	movw	r22, r24
    126e:	6e 5f       	subi	r22, 0xFE	; 254
    1270:	7f 4f       	sbci	r23, 0xFF	; 255
    1272:	e8 81       	ld	r30, Y
    1274:	f9 81       	ldd	r31, Y+1	; 0x01
    1276:	01 90       	ld	r0, Z+
    1278:	f0 81       	ld	r31, Z
    127a:	e0 2d       	mov	r30, r0
    127c:	ce 01       	movw	r24, r28
    127e:	19 95       	eicall
    1280:	b8 01       	movw	r22, r16
    1282:	6d 5f       	subi	r22, 0xFD	; 253
    1284:	7f 4f       	sbci	r23, 0xFF	; 255
    1286:	e8 81       	ld	r30, Y
    1288:	f9 81       	ldd	r31, Y+1	; 0x01
    128a:	01 90       	ld	r0, Z+
    128c:	f0 81       	ld	r31, Z
    128e:	e0 2d       	mov	r30, r0
    1290:	ce 01       	movw	r24, r28
    1292:	19 95       	eicall
    1294:	df 91       	pop	r29
    1296:	cf 91       	pop	r28
    1298:	1f 91       	pop	r17
    129a:	0f 91       	pop	r16
    129c:	08 95       	ret

0000129e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    129e:	db 01       	movw	r26, r22
    12a0:	bc 01       	movw	r22, r24
    12a2:	6e 5f       	subi	r22, 0xFE	; 254
    12a4:	7f 4f       	sbci	r23, 0xFF	; 255
    12a6:	ed 91       	ld	r30, X+
    12a8:	fc 91       	ld	r31, X
    12aa:	11 97       	sbiw	r26, 0x01	; 1
    12ac:	01 90       	ld	r0, Z+
    12ae:	f0 81       	ld	r31, Z
    12b0:	e0 2d       	mov	r30, r0
    12b2:	cd 01       	movw	r24, r26
    12b4:	19 95       	eicall
    12b6:	08 95       	ret

000012b8 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    12b8:	db 01       	movw	r26, r22
    12ba:	bc 01       	movw	r22, r24
    12bc:	6e 5f       	subi	r22, 0xFE	; 254
    12be:	7f 4f       	sbci	r23, 0xFF	; 255
    12c0:	ed 91       	ld	r30, X+
    12c2:	fc 91       	ld	r31, X
    12c4:	11 97       	sbiw	r26, 0x01	; 1
    12c6:	01 90       	ld	r0, Z+
    12c8:	f0 81       	ld	r31, Z
    12ca:	e0 2d       	mov	r30, r0
    12cc:	cd 01       	movw	r24, r26
    12ce:	19 95       	eicall
    12d0:	08 95       	ret

000012d2 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    12d2:	db 01       	movw	r26, r22
    12d4:	bc 01       	movw	r22, r24
    12d6:	6e 5f       	subi	r22, 0xFE	; 254
    12d8:	7f 4f       	sbci	r23, 0xFF	; 255
    12da:	ed 91       	ld	r30, X+
    12dc:	fc 91       	ld	r31, X
    12de:	11 97       	sbiw	r26, 0x01	; 1
    12e0:	01 90       	ld	r0, Z+
    12e2:	f0 81       	ld	r31, Z
    12e4:	e0 2d       	mov	r30, r0
    12e6:	cd 01       	movw	r24, r26
    12e8:	19 95       	eicall
    12ea:	08 95       	ret

000012ec <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    12ec:	4f 92       	push	r4
    12ee:	5f 92       	push	r5
    12f0:	6f 92       	push	r6
    12f2:	7f 92       	push	r7
    12f4:	8f 92       	push	r8
    12f6:	9f 92       	push	r9
    12f8:	af 92       	push	r10
    12fa:	bf 92       	push	r11
    12fc:	cf 92       	push	r12
    12fe:	df 92       	push	r13
    1300:	ef 92       	push	r14
    1302:	ff 92       	push	r15
    1304:	0f 93       	push	r16
    1306:	1f 93       	push	r17
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	8c 01       	movw	r16, r24
    130e:	7b 01       	movw	r14, r22
    1310:	6a 01       	movw	r12, r20
    1312:	dc 01       	movw	r26, r24
    1314:	6d 93       	st	X+, r22
    1316:	7c 93       	st	X, r23
    1318:	11 97       	sbiw	r26, 0x01	; 1
    131a:	12 96       	adiw	r26, 0x02	; 2
    131c:	4d 93       	st	X+, r20
    131e:	5c 93       	st	X, r21
    1320:	13 97       	sbiw	r26, 0x03	; 3
    1322:	81 e2       	ldi	r24, 0x21	; 33
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    132a:	ec 01       	movw	r28, r24
    132c:	89 e2       	ldi	r24, 0x29	; 41
    132e:	91 e2       	ldi	r25, 0x21	; 33
    1330:	88 83       	st	Y, r24
    1332:	99 83       	std	Y+1, r25	; 0x01
    1334:	1c 82       	std	Y+4, r1	; 0x04
    1336:	1d 82       	std	Y+5, r1	; 0x05
    1338:	0f 2e       	mov	r0, r31
    133a:	f1 ee       	ldi	r31, 0xE1	; 225
    133c:	af 2e       	mov	r10, r31
    133e:	f0 e2       	ldi	r31, 0x20	; 32
    1340:	bf 2e       	mov	r11, r31
    1342:	f0 2d       	mov	r31, r0
    1344:	aa 82       	std	Y+2, r10	; 0x02
    1346:	bb 82       	std	Y+3, r11	; 0x03
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	61 e0       	ldi	r22, 0x01	; 1
    134c:	82 e0       	ldi	r24, 0x02	; 2
    134e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    1352:	8e 83       	std	Y+6, r24	; 0x06
    1354:	9f 83       	std	Y+7, r25	; 0x07
    1356:	0f 2e       	mov	r0, r31
    1358:	fa e0       	ldi	r31, 0x0A	; 10
    135a:	4f 2e       	mov	r4, r31
    135c:	51 2c       	mov	r5, r1
    135e:	61 2c       	mov	r6, r1
    1360:	71 2c       	mov	r7, r1
    1362:	f0 2d       	mov	r31, r0
    1364:	48 86       	std	Y+8, r4	; 0x08
    1366:	59 86       	std	Y+9, r5	; 0x09
    1368:	6a 86       	std	Y+10, r6	; 0x0a
    136a:	7b 86       	std	Y+11, r7	; 0x0b
    136c:	0f 2e       	mov	r0, r31
    136e:	f5 e0       	ldi	r31, 0x05	; 5
    1370:	8f 2e       	mov	r8, r31
    1372:	f1 e2       	ldi	r31, 0x21	; 33
    1374:	9f 2e       	mov	r9, r31
    1376:	f0 2d       	mov	r31, r0
    1378:	8a 82       	std	Y+2, r8	; 0x02
    137a:	9b 82       	std	Y+3, r9	; 0x03
    137c:	82 e0       	ldi	r24, 0x02	; 2
    137e:	8c 87       	std	Y+12, r24	; 0x0c
    1380:	18 8a       	std	Y+16, r1	; 0x10
    1382:	19 8a       	std	Y+17, r1	; 0x11
    1384:	ae 86       	std	Y+14, r10	; 0x0e
    1386:	bf 86       	std	Y+15, r11	; 0x0f
    1388:	40 e0       	ldi	r20, 0x00	; 0
    138a:	61 e0       	ldi	r22, 0x01	; 1
    138c:	83 e0       	ldi	r24, 0x03	; 3
    138e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    1392:	8a 8b       	std	Y+18, r24	; 0x12
    1394:	9b 8b       	std	Y+19, r25	; 0x13
    1396:	4c 8a       	std	Y+20, r4	; 0x14
    1398:	5d 8a       	std	Y+21, r5	; 0x15
    139a:	6e 8a       	std	Y+22, r6	; 0x16
    139c:	7f 8a       	std	Y+23, r7	; 0x17
    139e:	8e 86       	std	Y+14, r8	; 0x0e
    13a0:	9f 86       	std	Y+15, r9	; 0x0f
    13a2:	0f 2e       	mov	r0, r31
    13a4:	f3 e0       	ldi	r31, 0x03	; 3
    13a6:	bf 2e       	mov	r11, r31
    13a8:	f0 2d       	mov	r31, r0
    13aa:	b8 8e       	std	Y+24, r11	; 0x18
    13ac:	8a e0       	ldi	r24, 0x0A	; 10
    13ae:	90 e2       	ldi	r25, 0x20	; 32
    13b0:	88 83       	st	Y, r24
    13b2:	99 83       	std	Y+1, r25	; 0x01
    13b4:	ca 8e       	std	Y+26, r12	; 0x1a
    13b6:	db 8e       	std	Y+27, r13	; 0x1b
    13b8:	f8 01       	movw	r30, r16
    13ba:	c4 83       	std	Z+4, r28	; 0x04
    13bc:	d5 83       	std	Z+5, r29	; 0x05
    13be:	86 e0       	ldi	r24, 0x06	; 6
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    13c6:	fc 01       	movw	r30, r24
    13c8:	10 82       	st	Z, r1
    13ca:	11 82       	std	Z+1, r1	; 0x01
    13cc:	12 82       	std	Z+2, r1	; 0x02
    13ce:	13 82       	std	Z+3, r1	; 0x03
    13d0:	14 82       	std	Z+4, r1	; 0x04
    13d2:	15 82       	std	Z+5, r1	; 0x05
    13d4:	d8 01       	movw	r26, r16
    13d6:	16 96       	adiw	r26, 0x06	; 6
    13d8:	8d 93       	st	X+, r24
    13da:	9c 93       	st	X, r25
    13dc:	17 97       	sbiw	r26, 0x07	; 7
    13de:	8d e1       	ldi	r24, 0x1D	; 29
    13e0:	18 96       	adiw	r26, 0x08	; 8
    13e2:	8c 93       	st	X, r24
    13e4:	84 e0       	ldi	r24, 0x04	; 4
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    13ec:	fc 01       	movw	r30, r24
    13ee:	87 e3       	ldi	r24, 0x37	; 55
    13f0:	91 e2       	ldi	r25, 0x21	; 33
    13f2:	80 83       	st	Z, r24
    13f4:	91 83       	std	Z+1, r25	; 0x01
    13f6:	8a e2       	ldi	r24, 0x2A	; 42
    13f8:	82 83       	std	Z+2, r24	; 0x02
    13fa:	c1 e0       	ldi	r28, 0x01	; 1
    13fc:	c3 83       	std	Z+3, r28	; 0x03
    13fe:	d8 01       	movw	r26, r16
    1400:	1b 96       	adiw	r26, 0x0b	; 11
    1402:	ed 93       	st	X+, r30
    1404:	fc 93       	st	X, r31
    1406:	1c 97       	sbiw	r26, 0x0c	; 12
    1408:	83 e0       	ldi	r24, 0x03	; 3
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    1410:	2d e3       	ldi	r18, 0x3D	; 61
    1412:	31 e2       	ldi	r19, 0x21	; 33
    1414:	fc 01       	movw	r30, r24
    1416:	20 83       	st	Z, r18
    1418:	31 83       	std	Z+1, r19	; 0x01
    141a:	c2 83       	std	Z+2, r28	; 0x02
    141c:	d8 01       	movw	r26, r16
    141e:	1d 96       	adiw	r26, 0x0d	; 13
    1420:	8d 93       	st	X+, r24
    1422:	9c 93       	st	X, r25
    1424:	1e 97       	sbiw	r26, 0x0e	; 14
    1426:	83 e0       	ldi	r24, 0x03	; 3
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    142e:	23 e4       	ldi	r18, 0x43	; 67
    1430:	31 e2       	ldi	r19, 0x21	; 33
    1432:	fc 01       	movw	r30, r24
    1434:	20 83       	st	Z, r18
    1436:	31 83       	std	Z+1, r19	; 0x01
    1438:	b2 82       	std	Z+2, r11	; 0x02
    143a:	d8 01       	movw	r26, r16
    143c:	1f 96       	adiw	r26, 0x0f	; 15
    143e:	8d 93       	st	X+, r24
    1440:	9c 93       	st	X, r25
    1442:	50 97       	sbiw	r26, 0x10	; 16
    1444:	83 e0       	ldi	r24, 0x03	; 3
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    144c:	29 e4       	ldi	r18, 0x49	; 73
    144e:	31 e2       	ldi	r19, 0x21	; 33
    1450:	fc 01       	movw	r30, r24
    1452:	20 83       	st	Z, r18
    1454:	31 83       	std	Z+1, r19	; 0x01
    1456:	25 e0       	ldi	r18, 0x05	; 5
    1458:	22 83       	std	Z+2, r18	; 0x02
    145a:	d8 01       	movw	r26, r16
    145c:	51 96       	adiw	r26, 0x11	; 17
    145e:	8d 93       	st	X+, r24
    1460:	9c 93       	st	X, r25
    1462:	52 97       	sbiw	r26, 0x12	; 18
    1464:	14 96       	adiw	r26, 0x04	; 4
    1466:	ed 91       	ld	r30, X+
    1468:	fc 91       	ld	r31, X
    146a:	15 97       	sbiw	r26, 0x05	; 5
    146c:	e4 8e       	std	Z+28, r14	; 0x1c
    146e:	f5 8e       	std	Z+29, r15	; 0x1d
    1470:	18 96       	adiw	r26, 0x08	; 8
    1472:	6c 91       	ld	r22, X
    1474:	18 97       	sbiw	r26, 0x08	; 8
    1476:	14 96       	adiw	r26, 0x04	; 4
    1478:	8d 91       	ld	r24, X+
    147a:	9c 91       	ld	r25, X
    147c:	15 97       	sbiw	r26, 0x05	; 5
    147e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <_ZN8I2CAgent12setSlaveAddrEh>
    1482:	df 91       	pop	r29
    1484:	cf 91       	pop	r28
    1486:	1f 91       	pop	r17
    1488:	0f 91       	pop	r16
    148a:	ff 90       	pop	r15
    148c:	ef 90       	pop	r14
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	bf 90       	pop	r11
    1494:	af 90       	pop	r10
    1496:	9f 90       	pop	r9
    1498:	8f 90       	pop	r8
    149a:	7f 90       	pop	r7
    149c:	6f 90       	pop	r6
    149e:	5f 90       	pop	r5
    14a0:	4f 90       	pop	r4
    14a2:	08 95       	ret

000014a4 <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    14ac:	8c 81       	ldd	r24, Y+4	; 0x04
    14ae:	9d 81       	ldd	r25, Y+5	; 0x05
    14b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    14b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    14b4:	dc 01       	movw	r26, r24
    14b6:	ed 91       	ld	r30, X+
    14b8:	fc 91       	ld	r31, X
    14ba:	01 90       	ld	r0, Z+
    14bc:	f0 81       	ld	r31, Z
    14be:	e0 2d       	mov	r30, r0
    14c0:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    14c2:	8c 81       	ldd	r24, Y+4	; 0x04
    14c4:	9d 81       	ldd	r25, Y+5	; 0x05
    14c6:	6d 85       	ldd	r22, Y+13	; 0x0d
    14c8:	7e 85       	ldd	r23, Y+14	; 0x0e
    14ca:	dc 01       	movw	r26, r24
    14cc:	ed 91       	ld	r30, X+
    14ce:	fc 91       	ld	r31, X
    14d0:	01 90       	ld	r0, Z+
    14d2:	f0 81       	ld	r31, Z
    14d4:	e0 2d       	mov	r30, r0
    14d6:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    14d8:	8c 81       	ldd	r24, Y+4	; 0x04
    14da:	9d 81       	ldd	r25, Y+5	; 0x05
    14dc:	dc 01       	movw	r26, r24
    14de:	ed 91       	ld	r30, X+
    14e0:	fc 91       	ld	r31, X
    14e2:	02 80       	ldd	r0, Z+2	; 0x02
    14e4:	f3 81       	ldd	r31, Z+3	; 0x03
    14e6:	e0 2d       	mov	r30, r0
    14e8:	19 95       	eicall
    14ea:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    14ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    14ee:	88 23       	and	r24, r24
    14f0:	b9 f0       	breq	.+46     	; 0x1520 <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    14f2:	e8 81       	ld	r30, Y
    14f4:	f9 81       	ldd	r31, Y+1	; 0x01
    14f6:	00 84       	ldd	r0, Z+8	; 0x08
    14f8:	f1 85       	ldd	r31, Z+9	; 0x09
    14fa:	e0 2d       	mov	r30, r0
    14fc:	ce 01       	movw	r24, r28
    14fe:	19 95       	eicall
    1500:	18 2f       	mov	r17, r24
    1502:	e8 81       	ld	r30, Y
    1504:	f9 81       	ldd	r31, Y+1	; 0x01
    1506:	00 84       	ldd	r0, Z+8	; 0x08
    1508:	f1 85       	ldd	r31, Z+9	; 0x09
    150a:	e0 2d       	mov	r30, r0
    150c:	ce 01       	movw	r24, r28
    150e:	19 95       	eicall
    1510:	21 2f       	mov	r18, r17
    1512:	30 e0       	ldi	r19, 0x00	; 0
    1514:	32 2f       	mov	r19, r18
    1516:	22 27       	eor	r18, r18
    1518:	a9 01       	movw	r20, r18
    151a:	48 2b       	or	r20, r24
    151c:	ca 01       	movw	r24, r20
    151e:	02 c0       	rjmp	.+4      	; 0x1524 <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    1520:	80 e0       	ldi	r24, 0x00	; 0
    1522:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    1524:	df 91       	pop	r29
    1526:	cf 91       	pop	r28
    1528:	1f 91       	pop	r17
    152a:	08 95       	ret

0000152c <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    152c:	1f 93       	push	r17
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
    1532:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1534:	8c 81       	ldd	r24, Y+4	; 0x04
    1536:	9d 81       	ldd	r25, Y+5	; 0x05
    1538:	6b 85       	ldd	r22, Y+11	; 0x0b
    153a:	7c 85       	ldd	r23, Y+12	; 0x0c
    153c:	dc 01       	movw	r26, r24
    153e:	ed 91       	ld	r30, X+
    1540:	fc 91       	ld	r31, X
    1542:	01 90       	ld	r0, Z+
    1544:	f0 81       	ld	r31, Z
    1546:	e0 2d       	mov	r30, r0
    1548:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    154a:	8c 81       	ldd	r24, Y+4	; 0x04
    154c:	9d 81       	ldd	r25, Y+5	; 0x05
    154e:	6f 85       	ldd	r22, Y+15	; 0x0f
    1550:	78 89       	ldd	r23, Y+16	; 0x10
    1552:	dc 01       	movw	r26, r24
    1554:	ed 91       	ld	r30, X+
    1556:	fc 91       	ld	r31, X
    1558:	01 90       	ld	r0, Z+
    155a:	f0 81       	ld	r31, Z
    155c:	e0 2d       	mov	r30, r0
    155e:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    1560:	8c 81       	ldd	r24, Y+4	; 0x04
    1562:	9d 81       	ldd	r25, Y+5	; 0x05
    1564:	dc 01       	movw	r26, r24
    1566:	ed 91       	ld	r30, X+
    1568:	fc 91       	ld	r31, X
    156a:	02 80       	ldd	r0, Z+2	; 0x02
    156c:	f3 81       	ldd	r31, Z+3	; 0x03
    156e:	e0 2d       	mov	r30, r0
    1570:	19 95       	eicall
    1572:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    1574:	8b 85       	ldd	r24, Y+11	; 0x0b
    1576:	88 23       	and	r24, r24
    1578:	b9 f0       	breq	.+46     	; 0x15a8 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    157a:	e8 81       	ld	r30, Y
    157c:	f9 81       	ldd	r31, Y+1	; 0x01
    157e:	00 84       	ldd	r0, Z+8	; 0x08
    1580:	f1 85       	ldd	r31, Z+9	; 0x09
    1582:	e0 2d       	mov	r30, r0
    1584:	ce 01       	movw	r24, r28
    1586:	19 95       	eicall
    1588:	18 2f       	mov	r17, r24
    158a:	e8 81       	ld	r30, Y
    158c:	f9 81       	ldd	r31, Y+1	; 0x01
    158e:	00 84       	ldd	r0, Z+8	; 0x08
    1590:	f1 85       	ldd	r31, Z+9	; 0x09
    1592:	e0 2d       	mov	r30, r0
    1594:	ce 01       	movw	r24, r28
    1596:	19 95       	eicall
    1598:	21 2f       	mov	r18, r17
    159a:	30 e0       	ldi	r19, 0x00	; 0
    159c:	32 2f       	mov	r19, r18
    159e:	22 27       	eor	r18, r18
    15a0:	a9 01       	movw	r20, r18
    15a2:	48 2b       	or	r20, r24
    15a4:	ca 01       	movw	r24, r20
    15a6:	02 c0       	rjmp	.+4      	; 0x15ac <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    15ac:	df 91       	pop	r29
    15ae:	cf 91       	pop	r28
    15b0:	1f 91       	pop	r17
    15b2:	08 95       	ret

000015b4 <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    15b4:	1f 93       	push	r17
    15b6:	cf 93       	push	r28
    15b8:	df 93       	push	r29
    15ba:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    15bc:	8c 81       	ldd	r24, Y+4	; 0x04
    15be:	9d 81       	ldd	r25, Y+5	; 0x05
    15c0:	6b 85       	ldd	r22, Y+11	; 0x0b
    15c2:	7c 85       	ldd	r23, Y+12	; 0x0c
    15c4:	dc 01       	movw	r26, r24
    15c6:	ed 91       	ld	r30, X+
    15c8:	fc 91       	ld	r31, X
    15ca:	01 90       	ld	r0, Z+
    15cc:	f0 81       	ld	r31, Z
    15ce:	e0 2d       	mov	r30, r0
    15d0:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    15d2:	8c 81       	ldd	r24, Y+4	; 0x04
    15d4:	9d 81       	ldd	r25, Y+5	; 0x05
    15d6:	69 89       	ldd	r22, Y+17	; 0x11
    15d8:	7a 89       	ldd	r23, Y+18	; 0x12
    15da:	dc 01       	movw	r26, r24
    15dc:	ed 91       	ld	r30, X+
    15de:	fc 91       	ld	r31, X
    15e0:	01 90       	ld	r0, Z+
    15e2:	f0 81       	ld	r31, Z
    15e4:	e0 2d       	mov	r30, r0
    15e6:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    15e8:	8c 81       	ldd	r24, Y+4	; 0x04
    15ea:	9d 81       	ldd	r25, Y+5	; 0x05
    15ec:	dc 01       	movw	r26, r24
    15ee:	ed 91       	ld	r30, X+
    15f0:	fc 91       	ld	r31, X
    15f2:	02 80       	ldd	r0, Z+2	; 0x02
    15f4:	f3 81       	ldd	r31, Z+3	; 0x03
    15f6:	e0 2d       	mov	r30, r0
    15f8:	19 95       	eicall
    15fa:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    15fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    15fe:	88 23       	and	r24, r24
    1600:	b9 f0       	breq	.+46     	; 0x1630 <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    1602:	e8 81       	ld	r30, Y
    1604:	f9 81       	ldd	r31, Y+1	; 0x01
    1606:	00 84       	ldd	r0, Z+8	; 0x08
    1608:	f1 85       	ldd	r31, Z+9	; 0x09
    160a:	e0 2d       	mov	r30, r0
    160c:	ce 01       	movw	r24, r28
    160e:	19 95       	eicall
    1610:	18 2f       	mov	r17, r24
    1612:	e8 81       	ld	r30, Y
    1614:	f9 81       	ldd	r31, Y+1	; 0x01
    1616:	00 84       	ldd	r0, Z+8	; 0x08
    1618:	f1 85       	ldd	r31, Z+9	; 0x09
    161a:	e0 2d       	mov	r30, r0
    161c:	ce 01       	movw	r24, r28
    161e:	19 95       	eicall
    1620:	21 2f       	mov	r18, r17
    1622:	30 e0       	ldi	r19, 0x00	; 0
    1624:	32 2f       	mov	r19, r18
    1626:	22 27       	eor	r18, r18
    1628:	a9 01       	movw	r20, r18
    162a:	48 2b       	or	r20, r24
    162c:	ca 01       	movw	r24, r20
    162e:	02 c0       	rjmp	.+4      	; 0x1634 <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	1f 91       	pop	r17
    163a:	08 95       	ret

0000163c <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    163c:	cf 93       	push	r28
    163e:	df 93       	push	r29
    1640:	ec 01       	movw	r28, r24
  success_ = false;
    1642:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    1644:	e8 81       	ld	r30, Y
    1646:	f9 81       	ldd	r31, Y+1	; 0x01
    1648:	00 8c       	ldd	r0, Z+24	; 0x18
    164a:	f1 8d       	ldd	r31, Z+25	; 0x19
    164c:	e0 2d       	mov	r30, r0
    164e:	ce 01       	movw	r24, r28
    1650:	19 95       	eicall
    1652:	88 23       	and	r24, r24
    1654:	41 f0       	breq	.+16     	; 0x1666 <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    1656:	e8 81       	ld	r30, Y
    1658:	f9 81       	ldd	r31, Y+1	; 0x01
    165a:	00 84       	ldd	r0, Z+8	; 0x08
    165c:	f1 85       	ldd	r31, Z+9	; 0x09
    165e:	e0 2d       	mov	r30, r0
    1660:	ce 01       	movw	r24, r28
    1662:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    1664:	ef cf       	rjmp	.-34     	; 0x1644 <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	08 95       	ret

0000166c <_ZN11task_sensor3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sensor::run (void)
{
    166c:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    166e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1670:	81 11       	cpse	r24, r1
    1672:	39 c0       	rjmp	.+114    	; 0x16e6 <_ZN11task_sensor3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    1674:	8c 89       	ldd	r24, Y+20	; 0x14
    1676:	9d 89       	ldd	r25, Y+21	; 0x15
    1678:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_ZN7MMA845111getXReadingEv>
    167c:	7c 01       	movw	r14, r24
    167e:	0e 81       	ldd	r16, Y+6	; 0x06
    1680:	1f 81       	ldd	r17, Y+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1682:	6b e4       	ldi	r22, 0x4B	; 75
    1684:	71 e2       	ldi	r23, 0x21	; 33
    1686:	c8 01       	movw	r24, r16
    1688:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    168c:	b7 01       	movw	r22, r14
    168e:	c8 01       	movw	r24, r16
    1690:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    1694:	66 e0       	ldi	r22, 0x06	; 6
    1696:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    169a:	8c 89       	ldd	r24, Y+20	; 0x14
    169c:	9d 89       	ldd	r25, Y+21	; 0x15
    169e:	0e 94 96 0a 	call	0x152c	; 0x152c <_ZN7MMA845111getYReadingEv>
    16a2:	7c 01       	movw	r14, r24
    16a4:	0e 81       	ldd	r16, Y+6	; 0x06
    16a6:	1f 81       	ldd	r17, Y+7	; 0x07
    16a8:	6f e4       	ldi	r22, 0x4F	; 79
    16aa:	71 e2       	ldi	r23, 0x21	; 33
    16ac:	c8 01       	movw	r24, r16
    16ae:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    16b2:	b7 01       	movw	r22, r14
    16b4:	c8 01       	movw	r24, r16
    16b6:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    16ba:	66 e0       	ldi	r22, 0x06	; 6
    16bc:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    16c0:	8c 89       	ldd	r24, Y+20	; 0x14
    16c2:	9d 89       	ldd	r25, Y+21	; 0x15
    16c4:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <_ZN7MMA845111getZReadingEv>
    16c8:	7c 01       	movw	r14, r24
    16ca:	0e 81       	ldd	r16, Y+6	; 0x06
    16cc:	1f 81       	ldd	r17, Y+7	; 0x07
    16ce:	63 e5       	ldi	r22, 0x53	; 83
    16d0:	71 e2       	ldi	r23, 0x21	; 33
    16d2:	c8 01       	movw	r24, r16
    16d4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    16d8:	b7 01       	movw	r22, r14
    16da:	c8 01       	movw	r24, r16
    16dc:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    16e0:	66 e0       	ldi	r22, 0x06	; 6
    16e2:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    16e6:	8e 85       	ldd	r24, Y+14	; 0x0e
    16e8:	9f 85       	ldd	r25, Y+15	; 0x0f
    16ea:	a8 89       	ldd	r26, Y+16	; 0x10
    16ec:	b9 89       	ldd	r27, Y+17	; 0x11
    16ee:	01 96       	adiw	r24, 0x01	; 1
    16f0:	a1 1d       	adc	r26, r1
    16f2:	b1 1d       	adc	r27, r1
    16f4:	8e 87       	std	Y+14, r24	; 0x0e
    16f6:	9f 87       	std	Y+15, r25	; 0x0f
    16f8:	a8 8b       	std	Y+16, r26	; 0x10
    16fa:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    16fc:	68 ee       	ldi	r22, 0xE8	; 232
    16fe:	73 e0       	ldi	r23, 0x03	; 3
    1700:	80 e0       	ldi	r24, 0x00	; 0
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	0e 94 26 17 	call	0x2e4c	; 0x2e4c <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1708:	b2 cf       	rjmp	.-156    	; 0x166e <_ZN11task_sensor3runEv+0x2>

0000170a <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sensor::task_sensor (const char* a_name, 
    170a:	cf 92       	push	r12
    170c:	df 92       	push	r13
    170e:	ef 92       	push	r14
    1710:	ff 92       	push	r15
    1712:	0f 93       	push	r16
    1714:	1f 93       	push	r17
    1716:	cf 93       	push	r28
    1718:	df 93       	push	r29
    171a:	ec 01       	movw	r28, r24
    171c:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    171e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8frt_taskC1EPKchjP8emstream>
    1722:	8b e5       	ldi	r24, 0x5B	; 91
    1724:	91 e2       	ldi	r25, 0x21	; 33
    1726:	88 83       	st	Y, r24
    1728:	99 83       	std	Y+1, r25	; 0x01
    172a:	ec 8a       	std	Y+20, r14	; 0x14
    172c:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    172e:	ce 8a       	std	Y+22, r12	; 0x16
    1730:	df 8a       	std	Y+23, r13	; 0x17
}
    1732:	df 91       	pop	r29
    1734:	cf 91       	pop	r28
    1736:	1f 91       	pop	r17
    1738:	0f 91       	pop	r16
    173a:	ff 90       	pop	r15
    173c:	ef 90       	pop	r14
    173e:	df 90       	pop	r13
    1740:	cf 90       	pop	r12
    1742:	08 95       	ret

00001744 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    174e:	0e 94 56 19 	call	0x32ac	; 0x32ac <_ZN8frt_taskC1EPKchjP8emstream>
    1752:	83 e6       	ldi	r24, 0x63	; 99
    1754:	91 e2       	ldi	r25, 0x21	; 33
    1756:	88 83       	st	Y, r24
    1758:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	1f 91       	pop	r17
    1760:	0f 91       	pop	r16
    1762:	08 95       	ret

00001764 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1764:	0f 93       	push	r16
    1766:	1f 93       	push	r17
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    176e:	6a e0       	ldi	r22, 0x0A	; 10
    1770:	8e 81       	ldd	r24, Y+6	; 0x06
    1772:	9f 81       	ldd	r25, Y+7	; 0x07
    1774:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1778:	8c 01       	movw	r16, r24
    177a:	69 e0       	ldi	r22, 0x09	; 9
    177c:	75 e0       	ldi	r23, 0x05	; 5
    177e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1782:	6a e0       	ldi	r22, 0x0A	; 10
    1784:	c8 01       	movw	r24, r16
    1786:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    178a:	8c 01       	movw	r16, r24
    178c:	63 e0       	ldi	r22, 0x03	; 3
    178e:	75 e0       	ldi	r23, 0x05	; 5
    1790:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1794:	67 e0       	ldi	r22, 0x07	; 7
    1796:	c8 01       	movw	r24, r16
    1798:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    179c:	6a e0       	ldi	r22, 0x0A	; 10
    179e:	8e 81       	ldd	r24, Y+6	; 0x06
    17a0:	9f 81       	ldd	r25, Y+7	; 0x07
    17a2:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    17a6:	8c 01       	movw	r16, r24
    17a8:	64 ee       	ldi	r22, 0xE4	; 228
    17aa:	74 e0       	ldi	r23, 0x04	; 4
    17ac:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    17b0:	6a e0       	ldi	r22, 0x0A	; 10
    17b2:	c8 01       	movw	r24, r16
    17b4:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    17b8:	8c 01       	movw	r16, r24
    17ba:	6e ed       	ldi	r22, 0xDE	; 222
    17bc:	74 e0       	ldi	r23, 0x04	; 4
    17be:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    17c2:	66 e0       	ldi	r22, 0x06	; 6
    17c4:	c8 01       	movw	r24, r16
    17c6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    17ca:	6a e0       	ldi	r22, 0x0A	; 10
    17cc:	8e 81       	ldd	r24, Y+6	; 0x06
    17ce:	9f 81       	ldd	r25, Y+7	; 0x07
    17d0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    17d4:	8c 01       	movw	r16, r24
    17d6:	67 ec       	ldi	r22, 0xC7	; 199
    17d8:	74 e0       	ldi	r23, 0x04	; 4
    17da:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    17de:	66 e0       	ldi	r22, 0x06	; 6
    17e0:	c8 01       	movw	r24, r16
    17e2:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    17e6:	6a e0       	ldi	r22, 0x0A	; 10
    17e8:	8e 81       	ldd	r24, Y+6	; 0x06
    17ea:	9f 81       	ldd	r25, Y+7	; 0x07
    17ec:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    17f0:	8c 01       	movw	r16, r24
    17f2:	6b ea       	ldi	r22, 0xAB	; 171
    17f4:	74 e0       	ldi	r23, 0x04	; 4
    17f6:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    17fa:	66 e0       	ldi	r22, 0x06	; 6
    17fc:	c8 01       	movw	r24, r16
    17fe:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1802:	6a e0       	ldi	r22, 0x0A	; 10
    1804:	8e 81       	ldd	r24, Y+6	; 0x06
    1806:	9f 81       	ldd	r25, Y+7	; 0x07
    1808:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    180c:	8c 01       	movw	r16, r24
    180e:	63 e9       	ldi	r22, 0x93	; 147
    1810:	74 e0       	ldi	r23, 0x04	; 4
    1812:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1816:	66 e0       	ldi	r22, 0x06	; 6
    1818:	c8 01       	movw	r24, r16
    181a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    181e:	6a e0       	ldi	r22, 0x0A	; 10
    1820:	8e 81       	ldd	r24, Y+6	; 0x06
    1822:	9f 81       	ldd	r25, Y+7	; 0x07
    1824:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1828:	8c 01       	movw	r16, r24
    182a:	62 e7       	ldi	r22, 0x72	; 114
    182c:	74 e0       	ldi	r23, 0x04	; 4
    182e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1832:	66 e0       	ldi	r22, 0x06	; 6
    1834:	c8 01       	movw	r24, r16
    1836:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    183a:	6a e0       	ldi	r22, 0x0A	; 10
    183c:	8e 81       	ldd	r24, Y+6	; 0x06
    183e:	9f 81       	ldd	r25, Y+7	; 0x07
    1840:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1844:	8c 01       	movw	r16, r24
    1846:	6b e4       	ldi	r22, 0x4B	; 75
    1848:	74 e0       	ldi	r23, 0x04	; 4
    184a:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    184e:	66 e0       	ldi	r22, 0x06	; 6
    1850:	c8 01       	movw	r24, r16
    1852:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1856:	6a e0       	ldi	r22, 0x0A	; 10
    1858:	8e 81       	ldd	r24, Y+6	; 0x06
    185a:	9f 81       	ldd	r25, Y+7	; 0x07
    185c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1860:	8c 01       	movw	r16, r24
    1862:	6d e2       	ldi	r22, 0x2D	; 45
    1864:	74 e0       	ldi	r23, 0x04	; 4
    1866:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    186a:	66 e0       	ldi	r22, 0x06	; 6
    186c:	c8 01       	movw	r24, r16
    186e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1872:	6a e0       	ldi	r22, 0x0A	; 10
    1874:	8e 81       	ldd	r24, Y+6	; 0x06
    1876:	9f 81       	ldd	r25, Y+7	; 0x07
    1878:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    187c:	8c 01       	movw	r16, r24
    187e:	62 e1       	ldi	r22, 0x12	; 18
    1880:	74 e0       	ldi	r23, 0x04	; 4
    1882:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1886:	66 e0       	ldi	r22, 0x06	; 6
    1888:	c8 01       	movw	r24, r16
    188a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    188e:	6a e0       	ldi	r22, 0x0A	; 10
    1890:	8e 81       	ldd	r24, Y+6	; 0x06
    1892:	9f 81       	ldd	r25, Y+7	; 0x07
    1894:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1898:	ec 01       	movw	r28, r24
    189a:	63 e0       	ldi	r22, 0x03	; 3
    189c:	74 e0       	ldi	r23, 0x04	; 4
    189e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    18a2:	66 e0       	ldi	r22, 0x06	; 6
    18a4:	ce 01       	movw	r24, r28
    18a6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
}
    18aa:	df 91       	pop	r29
    18ac:	cf 91       	pop	r28
    18ae:	1f 91       	pop	r17
    18b0:	0f 91       	pop	r16
    18b2:	08 95       	ret

000018b4 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    18b4:	af 92       	push	r10
    18b6:	bf 92       	push	r11
    18b8:	cf 92       	push	r12
    18ba:	df 92       	push	r13
    18bc:	ef 92       	push	r14
    18be:	ff 92       	push	r15
    18c0:	0f 93       	push	r16
    18c2:	1f 93       	push	r17
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
    18c8:	00 d0       	rcall	.+0      	; 0x18ca <_ZN9task_user11show_statusEv+0x16>
    18ca:	00 d0       	rcall	.+0      	; 0x18cc <_ZN9task_user11show_statusEv+0x18>
    18cc:	cd b7       	in	r28, 0x3d	; 61
    18ce:	de b7       	in	r29, 0x3e	; 62
    18d0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    18d2:	19 82       	std	Y+1, r1	; 0x01
    18d4:	1a 82       	std	Y+2, r1	; 0x02
    18d6:	1b 82       	std	Y+3, r1	; 0x03
    18d8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    18da:	1d 82       	std	Y+5, r1	; 0x05
    18dc:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    18de:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <xPortGetFreeHeapSize>
    18e2:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    18e4:	ce 01       	movw	r24, r28
    18e6:	01 96       	adiw	r24, 0x01	; 1
    18e8:	0e 94 07 1d 	call	0x3a0e	; 0x3a0e <_ZN10time_stamp10set_to_nowEv>
    18ec:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    18ee:	66 e0       	ldi	r22, 0x06	; 6
    18f0:	f8 01       	movw	r30, r16
    18f2:	86 81       	ldd	r24, Z+6	; 0x06
    18f4:	97 81       	ldd	r25, Z+7	; 0x07
    18f6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    18fa:	6a e0       	ldi	r22, 0x0A	; 10
    18fc:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1900:	7c 01       	movw	r14, r24
    1902:	64 ee       	ldi	r22, 0xE4	; 228
    1904:	73 e0       	ldi	r23, 0x03	; 3
    1906:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    190a:	6a e0       	ldi	r22, 0x0A	; 10
    190c:	c7 01       	movw	r24, r14
    190e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1912:	7c 01       	movw	r14, r24
    1914:	68 ed       	ldi	r22, 0xD8	; 216
    1916:	73 e0       	ldi	r23, 0x03	; 3
    1918:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    191c:	66 e0       	ldi	r22, 0x06	; 6
    191e:	c7 01       	movw	r24, r14
    1920:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1924:	6a e0       	ldi	r22, 0x0A	; 10
    1926:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    192a:	7c 01       	movw	r14, r24
    192c:	61 ed       	ldi	r22, 0xD1	; 209
    192e:	73 e0       	ldi	r23, 0x03	; 3
    1930:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1934:	b5 01       	movw	r22, r10
    1936:	c7 01       	movw	r24, r14
    1938:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    193c:	6a e0       	ldi	r22, 0x0A	; 10
    193e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1942:	7c 01       	movw	r14, r24
    1944:	63 ec       	ldi	r22, 0xC3	; 195
    1946:	73 e0       	ldi	r23, 0x03	; 3
    1948:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    194c:	b6 01       	movw	r22, r12
    194e:	c7 01       	movw	r24, r14
    1950:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    1954:	6a e0       	ldi	r22, 0x0A	; 10
    1956:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    195a:	7c 01       	movw	r14, r24
    195c:	61 ec       	ldi	r22, 0xC1	; 193
    195e:	73 e0       	ldi	r23, 0x03	; 3
    1960:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1964:	4f ef       	ldi	r20, 0xFF	; 255
    1966:	5f e0       	ldi	r21, 0x0F	; 15
    1968:	60 e0       	ldi	r22, 0x00	; 0
    196a:	70 e0       	ldi	r23, 0x00	; 0
    196c:	c7 01       	movw	r24, r14
    196e:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1972:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1976:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    197a:	6a e0       	ldi	r22, 0x0A	; 10
    197c:	f8 01       	movw	r30, r16
    197e:	86 81       	ldd	r24, Z+6	; 0x06
    1980:	97 81       	ldd	r25, Z+7	; 0x07
    1982:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1986:	7c 01       	movw	r14, r24
    1988:	66 eb       	ldi	r22, 0xB6	; 182
    198a:	73 e0       	ldi	r23, 0x03	; 3
    198c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1990:	b6 01       	movw	r22, r12
    1992:	c7 01       	movw	r24, r14
    1994:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    1998:	66 e0       	ldi	r22, 0x06	; 6
    199a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    199e:	66 e0       	ldi	r22, 0x06	; 6
    19a0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    19a4:	f8 01       	movw	r30, r16
    19a6:	86 81       	ldd	r24, Z+6	; 0x06
    19a8:	97 81       	ldd	r25, Z+7	; 0x07
    19aa:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <_Z15print_task_listP8emstream>
}
    19ae:	26 96       	adiw	r28, 0x06	; 6
    19b0:	cd bf       	out	0x3d, r28	; 61
    19b2:	de bf       	out	0x3e, r29	; 62
    19b4:	df 91       	pop	r29
    19b6:	cf 91       	pop	r28
    19b8:	1f 91       	pop	r17
    19ba:	0f 91       	pop	r16
    19bc:	ff 90       	pop	r15
    19be:	ef 90       	pop	r14
    19c0:	df 90       	pop	r13
    19c2:	cf 90       	pop	r12
    19c4:	bf 90       	pop	r11
    19c6:	af 90       	pop	r10
    19c8:	08 95       	ret

000019ca <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <_ZN9task_user3runEv+0x6>
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <_ZN9task_user3runEv+0x8>
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
    19d6:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    19d8:	19 82       	std	Y+1, r1	; 0x01
    19da:	1a 82       	std	Y+2, r1	; 0x02
    19dc:	1b 82       	std	Y+3, r1	; 0x03
    19de:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    19e0:	1d 82       	std	Y+5, r1	; 0x05
    19e2:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    19e4:	6a e0       	ldi	r22, 0x0A	; 10
    19e6:	dc 01       	movw	r26, r24
    19e8:	16 96       	adiw	r26, 0x06	; 6
    19ea:	8d 91       	ld	r24, X+
    19ec:	9c 91       	ld	r25, X
    19ee:	17 97       	sbiw	r26, 0x07	; 7
    19f0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    19f4:	7c 01       	movw	r14, r24
    19f6:	62 e5       	ldi	r22, 0x52	; 82
    19f8:	75 e0       	ldi	r23, 0x05	; 5
    19fa:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    19fe:	66 e0       	ldi	r22, 0x06	; 6
    1a00:	c7 01       	movw	r24, r14
    1a02:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1a06:	f8 01       	movw	r30, r16
    1a08:	84 85       	ldd	r24, Z+12	; 0x0c
    1a0a:	88 23       	and	r24, r24
    1a0c:	21 f0       	breq	.+8      	; 0x1a16 <_ZN9task_user3runEv+0x4c>
    1a0e:	81 30       	cpi	r24, 0x01	; 1
    1a10:	09 f4       	brne	.+2      	; 0x1a14 <_ZN9task_user3runEv+0x4a>
    1a12:	5d c0       	rjmp	.+186    	; 0x1ace <_ZN9task_user3runEv+0x104>
    1a14:	d8 c0       	rjmp	.+432    	; 0x1bc6 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1a16:	86 81       	ldd	r24, Z+6	; 0x06
    1a18:	97 81       	ldd	r25, Z+7	; 0x07
    1a1a:	dc 01       	movw	r26, r24
    1a1c:	ed 91       	ld	r30, X+
    1a1e:	fc 91       	ld	r31, X
    1a20:	04 80       	ldd	r0, Z+4	; 0x04
    1a22:	f5 81       	ldd	r31, Z+5	; 0x05
    1a24:	e0 2d       	mov	r30, r0
    1a26:	19 95       	eicall
    1a28:	88 23       	and	r24, r24
    1a2a:	a9 f1       	breq	.+106    	; 0x1a96 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1a2c:	f8 01       	movw	r30, r16
    1a2e:	86 81       	ldd	r24, Z+6	; 0x06
    1a30:	97 81       	ldd	r25, Z+7	; 0x07
    1a32:	dc 01       	movw	r26, r24
    1a34:	ed 91       	ld	r30, X+
    1a36:	fc 91       	ld	r31, X
    1a38:	06 80       	ldd	r0, Z+6	; 0x06
    1a3a:	f7 81       	ldd	r31, Z+7	; 0x07
    1a3c:	e0 2d       	mov	r30, r0
    1a3e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1a40:	99 27       	eor	r25, r25
    1a42:	81 30       	cpi	r24, 0x01	; 1
    1a44:	91 05       	cpc	r25, r1
    1a46:	f9 f0       	breq	.+62     	; 0x1a86 <_ZN9task_user3runEv+0xbc>
    1a48:	03 97       	sbiw	r24, 0x03	; 3
    1a4a:	09 f0       	breq	.+2      	; 0x1a4e <_ZN9task_user3runEv+0x84>
    1a4c:	d8 c0       	rjmp	.+432    	; 0x1bfe <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1a4e:	6a e0       	ldi	r22, 0x0A	; 10
    1a50:	f8 01       	movw	r30, r16
    1a52:	86 81       	ldd	r24, Z+6	; 0x06
    1a54:	97 81       	ldd	r25, Z+7	; 0x07
    1a56:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1a5a:	8c 01       	movw	r16, r24
    1a5c:	64 e4       	ldi	r22, 0x44	; 68
    1a5e:	75 e0       	ldi	r23, 0x05	; 5
    1a60:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1a64:	66 e0       	ldi	r22, 0x06	; 6
    1a66:	c8 01       	movw	r24, r16
    1a68:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1a6c:	93 e0       	ldi	r25, 0x03	; 3
    1a6e:	88 ed       	ldi	r24, 0xD8	; 216
    1a70:	08 b6       	in	r0, 0x38	; 56
    1a72:	18 be       	out	0x38, r1	; 56
    1a74:	84 bf       	out	0x34, r24	; 52
    1a76:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1a7a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1a7e:	81 fd       	sbrc	r24, 1
    1a80:	fc cf       	rjmp	.-8      	; 0x1a7a <_ZN9task_user3runEv+0xb0>
    1a82:	08 be       	out	0x38, r0	; 56
    1a84:	ff cf       	rjmp	.-2      	; 0x1a84 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1a86:	c8 01       	movw	r24, r16
    1a88:	0e 94 b2 0b 	call	0x1764	; 0x1764 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1a8c:	61 e0       	ldi	r22, 0x01	; 1
    1a8e:	c8 01       	movw	r24, r16
    1a90:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN8frt_task13transition_toEh>
							break;
    1a94:	b4 c0       	rjmp	.+360    	; 0x1bfe <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1a96:	86 ed       	ldi	r24, 0xD6	; 214
    1a98:	92 e3       	ldi	r25, 0x32	; 50
    1a9a:	0e 94 13 1c 	call	0x3826	; 0x3826 <_ZN14frt_text_queue14check_for_charEv>
    1a9e:	88 23       	and	r24, r24
    1aa0:	09 f4       	brne	.+2      	; 0x1aa4 <_ZN9task_user3runEv+0xda>
    1aa2:	ad c0       	rjmp	.+346    	; 0x1bfe <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1aa4:	d8 01       	movw	r26, r16
    1aa6:	16 96       	adiw	r26, 0x06	; 6
    1aa8:	ed 91       	ld	r30, X+
    1aaa:	fc 91       	ld	r31, X
    1aac:	17 97       	sbiw	r26, 0x07	; 7
    1aae:	01 90       	ld	r0, Z+
    1ab0:	f0 81       	ld	r31, Z
    1ab2:	e0 2d       	mov	r30, r0
    1ab4:	e2 80       	ldd	r14, Z+2	; 0x02
    1ab6:	f3 80       	ldd	r15, Z+3	; 0x03
    1ab8:	86 ed       	ldi	r24, 0xD6	; 214
    1aba:	92 e3       	ldi	r25, 0x32	; 50
    1abc:	0e 94 f5 1b 	call	0x37ea	; 0x37ea <_ZN14frt_text_queue7getcharEv>
    1ac0:	68 2f       	mov	r22, r24
    1ac2:	f8 01       	movw	r30, r16
    1ac4:	86 81       	ldd	r24, Z+6	; 0x06
    1ac6:	97 81       	ldd	r25, Z+7	; 0x07
    1ac8:	f7 01       	movw	r30, r14
    1aca:	19 95       	eicall
    1acc:	98 c0       	rjmp	.+304    	; 0x1bfe <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1ace:	86 81       	ldd	r24, Z+6	; 0x06
    1ad0:	97 81       	ldd	r25, Z+7	; 0x07
    1ad2:	dc 01       	movw	r26, r24
    1ad4:	ed 91       	ld	r30, X+
    1ad6:	fc 91       	ld	r31, X
    1ad8:	04 80       	ldd	r0, Z+4	; 0x04
    1ada:	f5 81       	ldd	r31, Z+5	; 0x05
    1adc:	e0 2d       	mov	r30, r0
    1ade:	19 95       	eicall
    1ae0:	88 23       	and	r24, r24
    1ae2:	09 f4       	brne	.+2      	; 0x1ae6 <_ZN9task_user3runEv+0x11c>
    1ae4:	8c c0       	rjmp	.+280    	; 0x1bfe <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1ae6:	f8 01       	movw	r30, r16
    1ae8:	86 81       	ldd	r24, Z+6	; 0x06
    1aea:	97 81       	ldd	r25, Z+7	; 0x07
    1aec:	dc 01       	movw	r26, r24
    1aee:	ed 91       	ld	r30, X+
    1af0:	fc 91       	ld	r31, X
    1af2:	06 80       	ldd	r0, Z+6	; 0x06
    1af4:	f7 81       	ldd	r31, Z+7	; 0x07
    1af6:	e0 2d       	mov	r30, r0
    1af8:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1afa:	9c 01       	movw	r18, r24
    1afc:	33 27       	eor	r19, r19
    1afe:	28 36       	cpi	r18, 0x68	; 104
    1b00:	31 05       	cpc	r19, r1
    1b02:	59 f1       	breq	.+86     	; 0x1b5a <_ZN9task_user3runEv+0x190>
    1b04:	3c f4       	brge	.+14     	; 0x1b14 <_ZN9task_user3runEv+0x14a>
    1b06:	2b 31       	cpi	r18, 0x1B	; 27
    1b08:	31 05       	cpc	r19, r1
    1b0a:	59 f1       	breq	.+86     	; 0x1b62 <_ZN9task_user3runEv+0x198>
    1b0c:	25 36       	cpi	r18, 0x65	; 101
    1b0e:	31 05       	cpc	r19, r1
    1b10:	41 f1       	breq	.+80     	; 0x1b62 <_ZN9task_user3runEv+0x198>
    1b12:	3b c0       	rjmp	.+118    	; 0x1b8a <_ZN9task_user3runEv+0x1c0>
    1b14:	23 37       	cpi	r18, 0x73	; 115
    1b16:	31 05       	cpc	r19, r1
    1b18:	c1 f0       	breq	.+48     	; 0x1b4a <_ZN9task_user3runEv+0x180>
    1b1a:	26 37       	cpi	r18, 0x76	; 118
    1b1c:	31 05       	cpc	r19, r1
    1b1e:	89 f0       	breq	.+34     	; 0x1b42 <_ZN9task_user3runEv+0x178>
    1b20:	2e 36       	cpi	r18, 0x6E	; 110
    1b22:	31 05       	cpc	r19, r1
    1b24:	91 f5       	brne	.+100    	; 0x1b8a <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1b26:	ce 01       	movw	r24, r28
    1b28:	01 96       	adiw	r24, 0x01	; 1
    1b2a:	0e 94 07 1d 	call	0x3a0e	; 0x3a0e <_ZN10time_stamp10set_to_nowEv>
    1b2e:	bc 01       	movw	r22, r24
    1b30:	f8 01       	movw	r30, r16
    1b32:	86 81       	ldd	r24, Z+6	; 0x06
    1b34:	97 81       	ldd	r25, Z+7	; 0x07
    1b36:	0e 94 ab 1c 	call	0x3956	; 0x3956 <_ZlsR8emstreamR10time_stamp>
    1b3a:	66 e0       	ldi	r22, 0x06	; 6
    1b3c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1b40:	5e c0       	rjmp	.+188    	; 0x1bfe <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1b42:	c8 01       	movw	r24, r16
    1b44:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <_ZN9task_user11show_statusEv>
							break;
    1b48:	5a c0       	rjmp	.+180    	; 0x1bfe <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1b4a:	d8 01       	movw	r26, r16
    1b4c:	16 96       	adiw	r26, 0x06	; 6
    1b4e:	8d 91       	ld	r24, X+
    1b50:	9c 91       	ld	r25, X
    1b52:	17 97       	sbiw	r26, 0x07	; 7
    1b54:	0e 94 6b 1a 	call	0x34d6	; 0x34d6 <_Z17print_task_stacksP8emstream>
							break;
    1b58:	52 c0       	rjmp	.+164    	; 0x1bfe <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1b5a:	c8 01       	movw	r24, r16
    1b5c:	0e 94 b2 0b 	call	0x1764	; 0x1764 <_ZN9task_user18print_help_messageEv>
							break;
    1b60:	4e c0       	rjmp	.+156    	; 0x1bfe <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1b62:	6a e0       	ldi	r22, 0x0A	; 10
    1b64:	f8 01       	movw	r30, r16
    1b66:	86 81       	ldd	r24, Z+6	; 0x06
    1b68:	97 81       	ldd	r25, Z+7	; 0x07
    1b6a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1b6e:	7c 01       	movw	r14, r24
    1b70:	62 e3       	ldi	r22, 0x32	; 50
    1b72:	75 e0       	ldi	r23, 0x05	; 5
    1b74:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1b78:	66 e0       	ldi	r22, 0x06	; 6
    1b7a:	c7 01       	movw	r24, r14
    1b7c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1b80:	60 e0       	ldi	r22, 0x00	; 0
    1b82:	c8 01       	movw	r24, r16
    1b84:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN8frt_task13transition_toEh>
							break;
    1b88:	3a c0       	rjmp	.+116    	; 0x1bfe <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	a6 81       	ldd	r26, Z+6	; 0x06
    1b8e:	b7 81       	ldd	r27, Z+7	; 0x07
    1b90:	ed 91       	ld	r30, X+
    1b92:	fc 91       	ld	r31, X
    1b94:	11 97       	sbiw	r26, 0x01	; 1
    1b96:	02 80       	ldd	r0, Z+2	; 0x02
    1b98:	f3 81       	ldd	r31, Z+3	; 0x03
    1b9a:	e0 2d       	mov	r30, r0
    1b9c:	68 2f       	mov	r22, r24
    1b9e:	cd 01       	movw	r24, r26
    1ba0:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1ba2:	6a e0       	ldi	r22, 0x0A	; 10
    1ba4:	d8 01       	movw	r26, r16
    1ba6:	16 96       	adiw	r26, 0x06	; 6
    1ba8:	8d 91       	ld	r24, X+
    1baa:	9c 91       	ld	r25, X
    1bac:	17 97       	sbiw	r26, 0x07	; 7
    1bae:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1bb2:	7c 01       	movw	r14, r24
    1bb4:	6c e2       	ldi	r22, 0x2C	; 44
    1bb6:	75 e0       	ldi	r23, 0x05	; 5
    1bb8:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1bbc:	66 e0       	ldi	r22, 0x06	; 6
    1bbe:	c7 01       	movw	r24, r14
    1bc0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1bc4:	1c c0       	rjmp	.+56     	; 0x1bfe <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1bc6:	6a e0       	ldi	r22, 0x0A	; 10
    1bc8:	f8 01       	movw	r30, r16
    1bca:	86 81       	ldd	r24, Z+6	; 0x06
    1bcc:	97 81       	ldd	r25, Z+7	; 0x07
    1bce:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    1bd2:	8c 01       	movw	r16, r24
    1bd4:	6f e0       	ldi	r22, 0x0F	; 15
    1bd6:	75 e0       	ldi	r23, 0x05	; 5
    1bd8:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    1bdc:	66 e0       	ldi	r22, 0x06	; 6
    1bde:	c8 01       	movw	r24, r16
    1be0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1be4:	93 e0       	ldi	r25, 0x03	; 3
    1be6:	88 ed       	ldi	r24, 0xD8	; 216
    1be8:	08 b6       	in	r0, 0x38	; 56
    1bea:	18 be       	out	0x38, r1	; 56
    1bec:	84 bf       	out	0x34, r24	; 52
    1bee:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1bf2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1bf6:	81 fd       	sbrc	r24, 1
    1bf8:	fc cf       	rjmp	.-8      	; 0x1bf2 <_ZN9task_user3runEv+0x228>
    1bfa:	08 be       	out	0x38, r0	; 56
    1bfc:	ff cf       	rjmp	.-2      	; 0x1bfc <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1bfe:	f8 01       	movw	r30, r16
    1c00:	86 85       	ldd	r24, Z+14	; 0x0e
    1c02:	97 85       	ldd	r25, Z+15	; 0x0f
    1c04:	a0 89       	ldd	r26, Z+16	; 0x10
    1c06:	b1 89       	ldd	r27, Z+17	; 0x11
    1c08:	01 96       	adiw	r24, 0x01	; 1
    1c0a:	a1 1d       	adc	r26, r1
    1c0c:	b1 1d       	adc	r27, r1
    1c0e:	86 87       	std	Z+14, r24	; 0x0e
    1c10:	97 87       	std	Z+15, r25	; 0x0f
    1c12:	a0 8b       	std	Z+16, r26	; 0x10
    1c14:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1c16:	68 ee       	ldi	r22, 0xE8	; 232
    1c18:	73 e0       	ldi	r23, 0x03	; 3
    1c1a:	80 e0       	ldi	r24, 0x00	; 0
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	0e 94 26 17 	call	0x2e4c	; 0x2e4c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1c22:	f1 ce       	rjmp	.-542    	; 0x1a06 <_ZN9task_user3runEv+0x3c>

00001c24 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1c24:	0f 93       	push	r16
    1c26:	1f 93       	push	r17
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1c2e:	0e 94 82 15 	call	0x2b04	; 0x2b04 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1c32:	80 91 1a 22 	lds	r24, 0x221A	; 0x80221a <__data_end>
    1c36:	81 11       	cpse	r24, r1
    1c38:	1d c0       	rjmp	.+58     	; 0x1c74 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1c3a:	af e1       	ldi	r26, 0x1F	; 31
    1c3c:	b2 e2       	ldi	r27, 0x22	; 34
    1c3e:	e3 e2       	ldi	r30, 0x23	; 35
    1c40:	f2 e2       	ldi	r31, 0x22	; 34
    1c42:	ed 93       	st	X+, r30
    1c44:	fc 93       	st	X, r31
    1c46:	11 97       	sbiw	r26, 0x01	; 1
    1c48:	12 96       	adiw	r26, 0x02	; 2
    1c4a:	1d 92       	st	X+, r1
    1c4c:	1c 92       	st	X, r1
    1c4e:	13 97       	sbiw	r26, 0x03	; 3
    1c50:	ab e1       	ldi	r26, 0x1B	; 27
    1c52:	b2 e2       	ldi	r27, 0x22	; 34
    1c54:	8f ef       	ldi	r24, 0xFF	; 255
    1c56:	9f e0       	ldi	r25, 0x0F	; 15
    1c58:	12 96       	adiw	r26, 0x02	; 2
    1c5a:	8d 93       	st	X+, r24
    1c5c:	9c 93       	st	X, r25
    1c5e:	13 97       	sbiw	r26, 0x03	; 3
    1c60:	1d 92       	st	X+, r1
    1c62:	1c 92       	st	X, r1
    1c64:	11 97       	sbiw	r26, 0x01	; 1
    1c66:	82 83       	std	Z+2, r24	; 0x02
    1c68:	93 83       	std	Z+3, r25	; 0x03
    1c6a:	a0 83       	st	Z, r26
    1c6c:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	80 93 1a 22 	sts	0x221A, r24	; 0x80221a <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1c74:	20 97       	sbiw	r28, 0x00	; 0
    1c76:	09 f4       	brne	.+2      	; 0x1c7a <pvPortMalloc+0x56>
    1c78:	5f c0       	rjmp	.+190    	; 0x1d38 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1c7a:	9e 01       	movw	r18, r28
    1c7c:	2b 5f       	subi	r18, 0xFB	; 251
    1c7e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1c80:	24 96       	adiw	r28, 0x04	; 4
    1c82:	ce 3f       	cpi	r28, 0xFE	; 254
    1c84:	df 40       	sbci	r29, 0x0F	; 15
    1c86:	08 f0       	brcs	.+2      	; 0x1c8a <pvPortMalloc+0x66>
    1c88:	5a c0       	rjmp	.+180    	; 0x1d3e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1c8a:	e0 91 1f 22 	lds	r30, 0x221F	; 0x80221f <xStart>
    1c8e:	f0 91 20 22 	lds	r31, 0x2220	; 0x802220 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1c92:	af e1       	ldi	r26, 0x1F	; 31
    1c94:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1c96:	02 c0       	rjmp	.+4      	; 0x1c9c <pvPortMalloc+0x78>
    1c98:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1c9a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1c9c:	82 81       	ldd	r24, Z+2	; 0x02
    1c9e:	93 81       	ldd	r25, Z+3	; 0x03
    1ca0:	82 17       	cp	r24, r18
    1ca2:	93 07       	cpc	r25, r19
    1ca4:	20 f4       	brcc	.+8      	; 0x1cae <pvPortMalloc+0x8a>
    1ca6:	80 81       	ld	r24, Z
    1ca8:	91 81       	ldd	r25, Z+1	; 0x01
    1caa:	00 97       	sbiw	r24, 0x00	; 0
    1cac:	a9 f7       	brne	.-22     	; 0x1c98 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1cae:	c2 e2       	ldi	r28, 0x22	; 34
    1cb0:	eb 31       	cpi	r30, 0x1B	; 27
    1cb2:	fc 07       	cpc	r31, r28
    1cb4:	09 f4       	brne	.+2      	; 0x1cb8 <pvPortMalloc+0x94>
    1cb6:	46 c0       	rjmp	.+140    	; 0x1d44 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1cb8:	cd 91       	ld	r28, X+
    1cba:	dc 91       	ld	r29, X
    1cbc:	11 97       	sbiw	r26, 0x01	; 1
    1cbe:	8e 01       	movw	r16, r28
    1cc0:	0b 5f       	subi	r16, 0xFB	; 251
    1cc2:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1cc4:	80 81       	ld	r24, Z
    1cc6:	91 81       	ldd	r25, Z+1	; 0x01
    1cc8:	8d 93       	st	X+, r24
    1cca:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1ccc:	82 81       	ldd	r24, Z+2	; 0x02
    1cce:	93 81       	ldd	r25, Z+3	; 0x03
    1cd0:	82 1b       	sub	r24, r18
    1cd2:	93 0b       	sbc	r25, r19
    1cd4:	8b 30       	cpi	r24, 0x0B	; 11
    1cd6:	91 05       	cpc	r25, r1
    1cd8:	10 f1       	brcs	.+68     	; 0x1d1e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1cda:	bf 01       	movw	r22, r30
    1cdc:	62 0f       	add	r22, r18
    1cde:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1ce0:	db 01       	movw	r26, r22
    1ce2:	12 96       	adiw	r26, 0x02	; 2
    1ce4:	8d 93       	st	X+, r24
    1ce6:	9c 93       	st	X, r25
    1ce8:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1cea:	22 83       	std	Z+2, r18	; 0x02
    1cec:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1cee:	12 96       	adiw	r26, 0x02	; 2
    1cf0:	4d 91       	ld	r20, X+
    1cf2:	5c 91       	ld	r21, X
    1cf4:	13 97       	sbiw	r26, 0x03	; 3
    1cf6:	8f e1       	ldi	r24, 0x1F	; 31
    1cf8:	92 e2       	ldi	r25, 0x22	; 34
    1cfa:	01 c0       	rjmp	.+2      	; 0x1cfe <pvPortMalloc+0xda>
    1cfc:	cd 01       	movw	r24, r26
    1cfe:	ec 01       	movw	r28, r24
    1d00:	a8 81       	ld	r26, Y
    1d02:	b9 81       	ldd	r27, Y+1	; 0x01
    1d04:	12 96       	adiw	r26, 0x02	; 2
    1d06:	2d 91       	ld	r18, X+
    1d08:	3c 91       	ld	r19, X
    1d0a:	13 97       	sbiw	r26, 0x03	; 3
    1d0c:	24 17       	cp	r18, r20
    1d0e:	35 07       	cpc	r19, r21
    1d10:	a8 f3       	brcs	.-22     	; 0x1cfc <pvPortMalloc+0xd8>
    1d12:	eb 01       	movw	r28, r22
    1d14:	a8 83       	st	Y, r26
    1d16:	b9 83       	std	Y+1, r27	; 0x01
    1d18:	dc 01       	movw	r26, r24
    1d1a:	6d 93       	st	X+, r22
    1d1c:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d1e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1d22:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1d26:	22 81       	ldd	r18, Z+2	; 0x02
    1d28:	33 81       	ldd	r19, Z+3	; 0x03
    1d2a:	82 1b       	sub	r24, r18
    1d2c:	93 0b       	sbc	r25, r19
    1d2e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1d32:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1d36:	08 c0       	rjmp	.+16     	; 0x1d48 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1d38:	00 e0       	ldi	r16, 0x00	; 0
    1d3a:	10 e0       	ldi	r17, 0x00	; 0
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <pvPortMalloc+0x124>
    1d3e:	00 e0       	ldi	r16, 0x00	; 0
    1d40:	10 e0       	ldi	r17, 0x00	; 0
    1d42:	02 c0       	rjmp	.+4      	; 0x1d48 <pvPortMalloc+0x124>
    1d44:	00 e0       	ldi	r16, 0x00	; 0
    1d46:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1d48:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1d4c:	c8 01       	movw	r24, r16
    1d4e:	df 91       	pop	r29
    1d50:	cf 91       	pop	r28
    1d52:	1f 91       	pop	r17
    1d54:	0f 91       	pop	r16
    1d56:	08 95       	ret

00001d58 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d58:	0f 93       	push	r16
    1d5a:	1f 93       	push	r17
    1d5c:	cf 93       	push	r28
    1d5e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1d60:	00 97       	sbiw	r24, 0x00	; 0
    1d62:	41 f1       	breq	.+80     	; 0x1db4 <vPortFree+0x5c>
    1d64:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1d66:	8c 01       	movw	r16, r24
    1d68:	05 50       	subi	r16, 0x05	; 5
    1d6a:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1d6c:	0e 94 82 15 	call	0x2b04	; 0x2b04 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1d70:	f8 01       	movw	r30, r16
    1d72:	42 81       	ldd	r20, Z+2	; 0x02
    1d74:	53 81       	ldd	r21, Z+3	; 0x03
    1d76:	af e1       	ldi	r26, 0x1F	; 31
    1d78:	b2 e2       	ldi	r27, 0x22	; 34
    1d7a:	01 c0       	rjmp	.+2      	; 0x1d7e <vPortFree+0x26>
    1d7c:	df 01       	movw	r26, r30
    1d7e:	ed 91       	ld	r30, X+
    1d80:	fc 91       	ld	r31, X
    1d82:	11 97       	sbiw	r26, 0x01	; 1
    1d84:	22 81       	ldd	r18, Z+2	; 0x02
    1d86:	33 81       	ldd	r19, Z+3	; 0x03
    1d88:	24 17       	cp	r18, r20
    1d8a:	35 07       	cpc	r19, r21
    1d8c:	b8 f3       	brcs	.-18     	; 0x1d7c <vPortFree+0x24>
    1d8e:	25 97       	sbiw	r28, 0x05	; 5
    1d90:	e8 83       	st	Y, r30
    1d92:	f9 83       	std	Y+1, r31	; 0x01
    1d94:	0d 93       	st	X+, r16
    1d96:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1d98:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1d9c:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1da0:	8a 81       	ldd	r24, Y+2	; 0x02
    1da2:	9b 81       	ldd	r25, Y+3	; 0x03
    1da4:	82 0f       	add	r24, r18
    1da6:	93 1f       	adc	r25, r19
    1da8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1dac:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1db0:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
	}
}
    1db4:	df 91       	pop	r29
    1db6:	cf 91       	pop	r28
    1db8:	1f 91       	pop	r17
    1dba:	0f 91       	pop	r16
    1dbc:	08 95       	ret

00001dbe <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1dbe:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1dc2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1dc6:	08 95       	ret

00001dc8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1dc8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1dca:	03 96       	adiw	r24, 0x03	; 3
    1dcc:	81 83       	std	Z+1, r24	; 0x01
    1dce:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1dd0:	4f ef       	ldi	r20, 0xFF	; 255
    1dd2:	5f ef       	ldi	r21, 0xFF	; 255
    1dd4:	ba 01       	movw	r22, r20
    1dd6:	43 83       	std	Z+3, r20	; 0x03
    1dd8:	54 83       	std	Z+4, r21	; 0x04
    1dda:	65 83       	std	Z+5, r22	; 0x05
    1ddc:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1dde:	87 83       	std	Z+7, r24	; 0x07
    1de0:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1de2:	81 87       	std	Z+9, r24	; 0x09
    1de4:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1de6:	10 82       	st	Z, r1
    1de8:	08 95       	ret

00001dea <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1dea:	fc 01       	movw	r30, r24
    1dec:	12 86       	std	Z+10, r1	; 0x0a
    1dee:	13 86       	std	Z+11, r1	; 0x0b
    1df0:	08 95       	ret

00001df2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	fc 01       	movw	r30, r24
    1df8:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1dfa:	21 81       	ldd	r18, Z+1	; 0x01
    1dfc:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1dfe:	e9 01       	movw	r28, r18
    1e00:	8c 81       	ldd	r24, Y+4	; 0x04
    1e02:	9d 81       	ldd	r25, Y+5	; 0x05
    1e04:	14 96       	adiw	r26, 0x04	; 4
    1e06:	8d 93       	st	X+, r24
    1e08:	9c 93       	st	X, r25
    1e0a:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1e0c:	81 81       	ldd	r24, Z+1	; 0x01
    1e0e:	92 81       	ldd	r25, Z+2	; 0x02
    1e10:	16 96       	adiw	r26, 0x06	; 6
    1e12:	8d 93       	st	X+, r24
    1e14:	9c 93       	st	X, r25
    1e16:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1e18:	8c 81       	ldd	r24, Y+4	; 0x04
    1e1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1e1c:	ec 01       	movw	r28, r24
    1e1e:	6e 83       	std	Y+6, r22	; 0x06
    1e20:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1e22:	e9 01       	movw	r28, r18
    1e24:	6c 83       	std	Y+4, r22	; 0x04
    1e26:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1e28:	61 83       	std	Z+1, r22	; 0x01
    1e2a:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e2c:	1a 96       	adiw	r26, 0x0a	; 10
    1e2e:	ed 93       	st	X+, r30
    1e30:	fc 93       	st	X, r31
    1e32:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1e34:	80 81       	ld	r24, Z
    1e36:	8f 5f       	subi	r24, 0xFF	; 255
    1e38:	80 83       	st	Z, r24
}
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	08 95       	ret

00001e40 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1e40:	0f 93       	push	r16
    1e42:	1f 93       	push	r17
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
    1e48:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1e4a:	08 81       	ld	r16, Y
    1e4c:	19 81       	ldd	r17, Y+1	; 0x01
    1e4e:	2a 81       	ldd	r18, Y+2	; 0x02
    1e50:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1e52:	0f 3f       	cpi	r16, 0xFF	; 255
    1e54:	4f ef       	ldi	r20, 0xFF	; 255
    1e56:	14 07       	cpc	r17, r20
    1e58:	24 07       	cpc	r18, r20
    1e5a:	34 07       	cpc	r19, r20
    1e5c:	31 f4       	brne	.+12     	; 0x1e6a <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1e5e:	dc 01       	movw	r26, r24
    1e60:	19 96       	adiw	r26, 0x09	; 9
    1e62:	ed 91       	ld	r30, X+
    1e64:	fc 91       	ld	r31, X
    1e66:	1a 97       	sbiw	r26, 0x0a	; 10
    1e68:	1f c0       	rjmp	.+62     	; 0x1ea8 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1e6a:	fc 01       	movw	r30, r24
    1e6c:	33 96       	adiw	r30, 0x03	; 3
    1e6e:	dc 01       	movw	r26, r24
    1e70:	17 96       	adiw	r26, 0x07	; 7
    1e72:	4d 91       	ld	r20, X+
    1e74:	5c 91       	ld	r21, X
    1e76:	18 97       	sbiw	r26, 0x08	; 8
    1e78:	da 01       	movw	r26, r20
    1e7a:	4d 91       	ld	r20, X+
    1e7c:	5d 91       	ld	r21, X+
    1e7e:	6d 91       	ld	r22, X+
    1e80:	7c 91       	ld	r23, X
    1e82:	04 17       	cp	r16, r20
    1e84:	15 07       	cpc	r17, r21
    1e86:	26 07       	cpc	r18, r22
    1e88:	37 07       	cpc	r19, r23
    1e8a:	70 f0       	brcs	.+28     	; 0x1ea8 <vListInsert+0x68>
    1e8c:	04 80       	ldd	r0, Z+4	; 0x04
    1e8e:	f5 81       	ldd	r31, Z+5	; 0x05
    1e90:	e0 2d       	mov	r30, r0
    1e92:	a4 81       	ldd	r26, Z+4	; 0x04
    1e94:	b5 81       	ldd	r27, Z+5	; 0x05
    1e96:	4d 91       	ld	r20, X+
    1e98:	5d 91       	ld	r21, X+
    1e9a:	6d 91       	ld	r22, X+
    1e9c:	7c 91       	ld	r23, X
    1e9e:	04 17       	cp	r16, r20
    1ea0:	15 07       	cpc	r17, r21
    1ea2:	26 07       	cpc	r18, r22
    1ea4:	37 07       	cpc	r19, r23
    1ea6:	90 f7       	brcc	.-28     	; 0x1e8c <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1ea8:	a4 81       	ldd	r26, Z+4	; 0x04
    1eaa:	b5 81       	ldd	r27, Z+5	; 0x05
    1eac:	ac 83       	std	Y+4, r26	; 0x04
    1eae:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1eb0:	16 96       	adiw	r26, 0x06	; 6
    1eb2:	cd 93       	st	X+, r28
    1eb4:	dc 93       	st	X, r29
    1eb6:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1eb8:	ee 83       	std	Y+6, r30	; 0x06
    1eba:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1ebc:	c4 83       	std	Z+4, r28	; 0x04
    1ebe:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ec0:	8a 87       	std	Y+10, r24	; 0x0a
    1ec2:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1ec4:	fc 01       	movw	r30, r24
    1ec6:	20 81       	ld	r18, Z
    1ec8:	2f 5f       	subi	r18, 0xFF	; 255
    1eca:	20 83       	st	Z, r18
}
    1ecc:	df 91       	pop	r29
    1ece:	cf 91       	pop	r28
    1ed0:	1f 91       	pop	r17
    1ed2:	0f 91       	pop	r16
    1ed4:	08 95       	ret

00001ed6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1ed6:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ed8:	a4 81       	ldd	r26, Z+4	; 0x04
    1eda:	b5 81       	ldd	r27, Z+5	; 0x05
    1edc:	86 81       	ldd	r24, Z+6	; 0x06
    1ede:	97 81       	ldd	r25, Z+7	; 0x07
    1ee0:	16 96       	adiw	r26, 0x06	; 6
    1ee2:	8d 93       	st	X+, r24
    1ee4:	9c 93       	st	X, r25
    1ee6:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1ee8:	a6 81       	ldd	r26, Z+6	; 0x06
    1eea:	b7 81       	ldd	r27, Z+7	; 0x07
    1eec:	84 81       	ldd	r24, Z+4	; 0x04
    1eee:	95 81       	ldd	r25, Z+5	; 0x05
    1ef0:	14 96       	adiw	r26, 0x04	; 4
    1ef2:	8d 93       	st	X+, r24
    1ef4:	9c 93       	st	X, r25
    1ef6:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1ef8:	a2 85       	ldd	r26, Z+10	; 0x0a
    1efa:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1efc:	11 96       	adiw	r26, 0x01	; 1
    1efe:	8d 91       	ld	r24, X+
    1f00:	9c 91       	ld	r25, X
    1f02:	12 97       	sbiw	r26, 0x02	; 2
    1f04:	e8 17       	cp	r30, r24
    1f06:	f9 07       	cpc	r31, r25
    1f08:	31 f4       	brne	.+12     	; 0x1f16 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f0a:	86 81       	ldd	r24, Z+6	; 0x06
    1f0c:	97 81       	ldd	r25, Z+7	; 0x07
    1f0e:	11 96       	adiw	r26, 0x01	; 1
    1f10:	8d 93       	st	X+, r24
    1f12:	9c 93       	st	X, r25
    1f14:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1f16:	12 86       	std	Z+10, r1	; 0x0a
    1f18:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1f1a:	8c 91       	ld	r24, X
    1f1c:	81 50       	subi	r24, 0x01	; 1
    1f1e:	8c 93       	st	X, r24
    1f20:	08 95       	ret

00001f22 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1f22:	80 93 e6 32 	sts	0x32E6, r24	; 0x8032e6 <portStackTopForTask>
    1f26:	90 93 e7 32 	sts	0x32E7, r25	; 0x8032e7 <portStackTopForTask+0x1>
    1f2a:	31 e1       	ldi	r19, 0x11	; 17
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	30 83       	st	Z, r19
    1f30:	31 97       	sbiw	r30, 0x01	; 1
    1f32:	22 e2       	ldi	r18, 0x22	; 34
    1f34:	20 83       	st	Z, r18
    1f36:	31 97       	sbiw	r30, 0x01	; 1
    1f38:	a3 e3       	ldi	r26, 0x33	; 51
    1f3a:	a0 83       	st	Z, r26
    1f3c:	31 97       	sbiw	r30, 0x01	; 1
    1f3e:	60 83       	st	Z, r22
    1f40:	31 97       	sbiw	r30, 0x01	; 1
    1f42:	70 83       	st	Z, r23
    1f44:	31 97       	sbiw	r30, 0x01	; 1
    1f46:	10 82       	st	Z, r1
    1f48:	31 97       	sbiw	r30, 0x01	; 1
    1f4a:	10 82       	st	Z, r1
    1f4c:	31 97       	sbiw	r30, 0x01	; 1
    1f4e:	60 e8       	ldi	r22, 0x80	; 128
    1f50:	60 83       	st	Z, r22
    1f52:	31 97       	sbiw	r30, 0x01	; 1
    1f54:	10 82       	st	Z, r1
    1f56:	31 97       	sbiw	r30, 0x01	; 1
    1f58:	10 82       	st	Z, r1
    1f5a:	31 97       	sbiw	r30, 0x01	; 1
    1f5c:	10 82       	st	Z, r1
    1f5e:	31 97       	sbiw	r30, 0x01	; 1
    1f60:	62 e0       	ldi	r22, 0x02	; 2
    1f62:	60 83       	st	Z, r22
    1f64:	31 97       	sbiw	r30, 0x01	; 1
    1f66:	63 e0       	ldi	r22, 0x03	; 3
    1f68:	60 83       	st	Z, r22
    1f6a:	31 97       	sbiw	r30, 0x01	; 1
    1f6c:	64 e0       	ldi	r22, 0x04	; 4
    1f6e:	60 83       	st	Z, r22
    1f70:	31 97       	sbiw	r30, 0x01	; 1
    1f72:	65 e0       	ldi	r22, 0x05	; 5
    1f74:	60 83       	st	Z, r22
    1f76:	31 97       	sbiw	r30, 0x01	; 1
    1f78:	66 e0       	ldi	r22, 0x06	; 6
    1f7a:	60 83       	st	Z, r22
    1f7c:	31 97       	sbiw	r30, 0x01	; 1
    1f7e:	67 e0       	ldi	r22, 0x07	; 7
    1f80:	60 83       	st	Z, r22
    1f82:	31 97       	sbiw	r30, 0x01	; 1
    1f84:	68 e0       	ldi	r22, 0x08	; 8
    1f86:	60 83       	st	Z, r22
    1f88:	31 97       	sbiw	r30, 0x01	; 1
    1f8a:	69 e0       	ldi	r22, 0x09	; 9
    1f8c:	60 83       	st	Z, r22
    1f8e:	31 97       	sbiw	r30, 0x01	; 1
    1f90:	60 e1       	ldi	r22, 0x10	; 16
    1f92:	60 83       	st	Z, r22
    1f94:	31 97       	sbiw	r30, 0x01	; 1
    1f96:	30 83       	st	Z, r19
    1f98:	31 97       	sbiw	r30, 0x01	; 1
    1f9a:	32 e1       	ldi	r19, 0x12	; 18
    1f9c:	30 83       	st	Z, r19
    1f9e:	31 97       	sbiw	r30, 0x01	; 1
    1fa0:	33 e1       	ldi	r19, 0x13	; 19
    1fa2:	30 83       	st	Z, r19
    1fa4:	31 97       	sbiw	r30, 0x01	; 1
    1fa6:	34 e1       	ldi	r19, 0x14	; 20
    1fa8:	30 83       	st	Z, r19
    1faa:	31 97       	sbiw	r30, 0x01	; 1
    1fac:	35 e1       	ldi	r19, 0x15	; 21
    1fae:	30 83       	st	Z, r19
    1fb0:	31 97       	sbiw	r30, 0x01	; 1
    1fb2:	36 e1       	ldi	r19, 0x16	; 22
    1fb4:	30 83       	st	Z, r19
    1fb6:	31 97       	sbiw	r30, 0x01	; 1
    1fb8:	37 e1       	ldi	r19, 0x17	; 23
    1fba:	30 83       	st	Z, r19
    1fbc:	31 97       	sbiw	r30, 0x01	; 1
    1fbe:	38 e1       	ldi	r19, 0x18	; 24
    1fc0:	30 83       	st	Z, r19
    1fc2:	31 97       	sbiw	r30, 0x01	; 1
    1fc4:	39 e1       	ldi	r19, 0x19	; 25
    1fc6:	30 83       	st	Z, r19
    1fc8:	31 97       	sbiw	r30, 0x01	; 1
    1fca:	30 e2       	ldi	r19, 0x20	; 32
    1fcc:	30 83       	st	Z, r19
    1fce:	31 97       	sbiw	r30, 0x01	; 1
    1fd0:	31 e2       	ldi	r19, 0x21	; 33
    1fd2:	30 83       	st	Z, r19
    1fd4:	31 97       	sbiw	r30, 0x01	; 1
    1fd6:	20 83       	st	Z, r18
    1fd8:	31 97       	sbiw	r30, 0x01	; 1
    1fda:	23 e2       	ldi	r18, 0x23	; 35
    1fdc:	20 83       	st	Z, r18
    1fde:	31 97       	sbiw	r30, 0x01	; 1
    1fe0:	40 83       	st	Z, r20
    1fe2:	31 97       	sbiw	r30, 0x01	; 1
    1fe4:	50 83       	st	Z, r21
    1fe6:	31 97       	sbiw	r30, 0x01	; 1
    1fe8:	26 e2       	ldi	r18, 0x26	; 38
    1fea:	20 83       	st	Z, r18
    1fec:	31 97       	sbiw	r30, 0x01	; 1
    1fee:	27 e2       	ldi	r18, 0x27	; 39
    1ff0:	20 83       	st	Z, r18
    1ff2:	31 97       	sbiw	r30, 0x01	; 1
    1ff4:	28 e2       	ldi	r18, 0x28	; 40
    1ff6:	20 83       	st	Z, r18
    1ff8:	31 97       	sbiw	r30, 0x01	; 1
    1ffa:	29 e2       	ldi	r18, 0x29	; 41
    1ffc:	20 83       	st	Z, r18
    1ffe:	31 97       	sbiw	r30, 0x01	; 1
    2000:	20 e3       	ldi	r18, 0x30	; 48
    2002:	20 83       	st	Z, r18
    2004:	31 97       	sbiw	r30, 0x01	; 1
    2006:	21 e3       	ldi	r18, 0x31	; 49
    2008:	20 83       	st	Z, r18
    200a:	89 97       	sbiw	r24, 0x29	; 41
    200c:	08 95       	ret

0000200e <xPortStartScheduler>:
    200e:	8c e7       	ldi	r24, 0x7C	; 124
    2010:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    2014:	8f ef       	ldi	r24, 0xFF	; 255
    2016:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    2020:	91 e1       	ldi	r25, 0x11	; 17
    2022:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    2026:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    202a:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    202e:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2032:	cd 91       	ld	r28, X+
    2034:	cd bf       	out	0x3d, r28	; 61
    2036:	dd 91       	ld	r29, X+
    2038:	de bf       	out	0x3e, r29	; 62
    203a:	ff 91       	pop	r31
    203c:	ef 91       	pop	r30
    203e:	df 91       	pop	r29
    2040:	cf 91       	pop	r28
    2042:	bf 91       	pop	r27
    2044:	af 91       	pop	r26
    2046:	9f 91       	pop	r25
    2048:	8f 91       	pop	r24
    204a:	7f 91       	pop	r23
    204c:	6f 91       	pop	r22
    204e:	5f 91       	pop	r21
    2050:	4f 91       	pop	r20
    2052:	3f 91       	pop	r19
    2054:	2f 91       	pop	r18
    2056:	1f 91       	pop	r17
    2058:	0f 91       	pop	r16
    205a:	ff 90       	pop	r15
    205c:	ef 90       	pop	r14
    205e:	df 90       	pop	r13
    2060:	cf 90       	pop	r12
    2062:	bf 90       	pop	r11
    2064:	af 90       	pop	r10
    2066:	9f 90       	pop	r9
    2068:	8f 90       	pop	r8
    206a:	7f 90       	pop	r7
    206c:	6f 90       	pop	r6
    206e:	5f 90       	pop	r5
    2070:	4f 90       	pop	r4
    2072:	3f 90       	pop	r3
    2074:	2f 90       	pop	r2
    2076:	1f 90       	pop	r1
    2078:	0f 90       	pop	r0
    207a:	0c be       	out	0x3c, r0	; 60
    207c:	0f 90       	pop	r0
    207e:	0b be       	out	0x3b, r0	; 59
    2080:	0f 90       	pop	r0
    2082:	0f be       	out	0x3f, r0	; 63
    2084:	0f 90       	pop	r0
    2086:	08 95       	ret
    2088:	08 95       	ret

0000208a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    208a:	0f 92       	push	r0
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	f8 94       	cli
    2090:	0f 92       	push	r0
    2092:	0b b6       	in	r0, 0x3b	; 59
    2094:	0f 92       	push	r0
    2096:	0c b6       	in	r0, 0x3c	; 60
    2098:	0f 92       	push	r0
    209a:	1f 92       	push	r1
    209c:	11 24       	eor	r1, r1
    209e:	2f 92       	push	r2
    20a0:	3f 92       	push	r3
    20a2:	4f 92       	push	r4
    20a4:	5f 92       	push	r5
    20a6:	6f 92       	push	r6
    20a8:	7f 92       	push	r7
    20aa:	8f 92       	push	r8
    20ac:	9f 92       	push	r9
    20ae:	af 92       	push	r10
    20b0:	bf 92       	push	r11
    20b2:	cf 92       	push	r12
    20b4:	df 92       	push	r13
    20b6:	ef 92       	push	r14
    20b8:	ff 92       	push	r15
    20ba:	0f 93       	push	r16
    20bc:	1f 93       	push	r17
    20be:	2f 93       	push	r18
    20c0:	3f 93       	push	r19
    20c2:	4f 93       	push	r20
    20c4:	5f 93       	push	r21
    20c6:	6f 93       	push	r22
    20c8:	7f 93       	push	r23
    20ca:	8f 93       	push	r24
    20cc:	9f 93       	push	r25
    20ce:	af 93       	push	r26
    20d0:	bf 93       	push	r27
    20d2:	cf 93       	push	r28
    20d4:	df 93       	push	r29
    20d6:	ef 93       	push	r30
    20d8:	ff 93       	push	r31
    20da:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    20de:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    20e2:	0d b6       	in	r0, 0x3d	; 61
    20e4:	0d 92       	st	X+, r0
    20e6:	0e b6       	in	r0, 0x3e	; 62
    20e8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    20ea:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    20ee:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    20f2:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    20f6:	cd 91       	ld	r28, X+
    20f8:	cd bf       	out	0x3d, r28	; 61
    20fa:	dd 91       	ld	r29, X+
    20fc:	de bf       	out	0x3e, r29	; 62
    20fe:	ff 91       	pop	r31
    2100:	ef 91       	pop	r30
    2102:	df 91       	pop	r29
    2104:	cf 91       	pop	r28
    2106:	bf 91       	pop	r27
    2108:	af 91       	pop	r26
    210a:	9f 91       	pop	r25
    210c:	8f 91       	pop	r24
    210e:	7f 91       	pop	r23
    2110:	6f 91       	pop	r22
    2112:	5f 91       	pop	r21
    2114:	4f 91       	pop	r20
    2116:	3f 91       	pop	r19
    2118:	2f 91       	pop	r18
    211a:	1f 91       	pop	r17
    211c:	0f 91       	pop	r16
    211e:	ff 90       	pop	r15
    2120:	ef 90       	pop	r14
    2122:	df 90       	pop	r13
    2124:	cf 90       	pop	r12
    2126:	bf 90       	pop	r11
    2128:	af 90       	pop	r10
    212a:	9f 90       	pop	r9
    212c:	8f 90       	pop	r8
    212e:	7f 90       	pop	r7
    2130:	6f 90       	pop	r6
    2132:	5f 90       	pop	r5
    2134:	4f 90       	pop	r4
    2136:	3f 90       	pop	r3
    2138:	2f 90       	pop	r2
    213a:	1f 90       	pop	r1
    213c:	0f 90       	pop	r0
    213e:	0c be       	out	0x3c, r0	; 60
    2140:	0f 90       	pop	r0
    2142:	0b be       	out	0x3b, r0	; 59
    2144:	0f 90       	pop	r0
    2146:	0f be       	out	0x3f, r0	; 63
    2148:	0f 90       	pop	r0

	asm volatile ( "ret" );
    214a:	08 95       	ret

0000214c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    214c:	0f 92       	push	r0
    214e:	0f b6       	in	r0, 0x3f	; 63
    2150:	f8 94       	cli
    2152:	0f 92       	push	r0
    2154:	0b b6       	in	r0, 0x3b	; 59
    2156:	0f 92       	push	r0
    2158:	0c b6       	in	r0, 0x3c	; 60
    215a:	0f 92       	push	r0
    215c:	1f 92       	push	r1
    215e:	11 24       	eor	r1, r1
    2160:	2f 92       	push	r2
    2162:	3f 92       	push	r3
    2164:	4f 92       	push	r4
    2166:	5f 92       	push	r5
    2168:	6f 92       	push	r6
    216a:	7f 92       	push	r7
    216c:	8f 92       	push	r8
    216e:	9f 92       	push	r9
    2170:	af 92       	push	r10
    2172:	bf 92       	push	r11
    2174:	cf 92       	push	r12
    2176:	df 92       	push	r13
    2178:	ef 92       	push	r14
    217a:	ff 92       	push	r15
    217c:	0f 93       	push	r16
    217e:	1f 93       	push	r17
    2180:	2f 93       	push	r18
    2182:	3f 93       	push	r19
    2184:	4f 93       	push	r20
    2186:	5f 93       	push	r21
    2188:	6f 93       	push	r22
    218a:	7f 93       	push	r23
    218c:	8f 93       	push	r24
    218e:	9f 93       	push	r25
    2190:	af 93       	push	r26
    2192:	bf 93       	push	r27
    2194:	cf 93       	push	r28
    2196:	df 93       	push	r29
    2198:	ef 93       	push	r30
    219a:	ff 93       	push	r31
    219c:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    21a0:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    21a4:	0d b6       	in	r0, 0x3d	; 61
    21a6:	0d 92       	st	X+, r0
    21a8:	0e b6       	in	r0, 0x3e	; 62
    21aa:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    21ac:	0e 94 a3 15 	call	0x2b46	; 0x2b46 <vTaskIncrementTick>
	vTaskSwitchContext();
    21b0:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21b4:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    21b8:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    21bc:	cd 91       	ld	r28, X+
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	dd 91       	ld	r29, X+
    21c2:	de bf       	out	0x3e, r29	; 62
    21c4:	ff 91       	pop	r31
    21c6:	ef 91       	pop	r30
    21c8:	df 91       	pop	r29
    21ca:	cf 91       	pop	r28
    21cc:	bf 91       	pop	r27
    21ce:	af 91       	pop	r26
    21d0:	9f 91       	pop	r25
    21d2:	8f 91       	pop	r24
    21d4:	7f 91       	pop	r23
    21d6:	6f 91       	pop	r22
    21d8:	5f 91       	pop	r21
    21da:	4f 91       	pop	r20
    21dc:	3f 91       	pop	r19
    21de:	2f 91       	pop	r18
    21e0:	1f 91       	pop	r17
    21e2:	0f 91       	pop	r16
    21e4:	ff 90       	pop	r15
    21e6:	ef 90       	pop	r14
    21e8:	df 90       	pop	r13
    21ea:	cf 90       	pop	r12
    21ec:	bf 90       	pop	r11
    21ee:	af 90       	pop	r10
    21f0:	9f 90       	pop	r9
    21f2:	8f 90       	pop	r8
    21f4:	7f 90       	pop	r7
    21f6:	6f 90       	pop	r6
    21f8:	5f 90       	pop	r5
    21fa:	4f 90       	pop	r4
    21fc:	3f 90       	pop	r3
    21fe:	2f 90       	pop	r2
    2200:	1f 90       	pop	r1
    2202:	0f 90       	pop	r0
    2204:	0c be       	out	0x3c, r0	; 60
    2206:	0f 90       	pop	r0
    2208:	0b be       	out	0x3b, r0	; 59
    220a:	0f 90       	pop	r0
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2210:	08 95       	ret

00002212 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    2212:	0e 94 a6 10 	call	0x214c	; 0x214c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2216:	18 95       	reti

00002218 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2218:	cf 93       	push	r28
    221a:	df 93       	push	r29
    221c:	ec 01       	movw	r28, r24
    221e:	88 a1       	ldd	r24, Y+32	; 0x20
    2220:	81 11       	cpse	r24, r1
    2222:	0b c0       	rjmp	.+22     	; 0x223a <prvCopyDataToQueue+0x22>
    2224:	88 81       	ld	r24, Y
    2226:	99 81       	ldd	r25, Y+1	; 0x01
    2228:	89 2b       	or	r24, r25
    222a:	e1 f5       	brne	.+120    	; 0x22a4 <prvCopyDataToQueue+0x8c>
    222c:	8a 81       	ldd	r24, Y+2	; 0x02
    222e:	9b 81       	ldd	r25, Y+3	; 0x03
    2230:	0e 94 0f 19 	call	0x321e	; 0x321e <vTaskPriorityDisinherit>
    2234:	1a 82       	std	Y+2, r1	; 0x02
    2236:	1b 82       	std	Y+3, r1	; 0x03
    2238:	35 c0       	rjmp	.+106    	; 0x22a4 <prvCopyDataToQueue+0x8c>
    223a:	41 11       	cpse	r20, r1
    223c:	17 c0       	rjmp	.+46     	; 0x226c <prvCopyDataToQueue+0x54>
    223e:	48 2f       	mov	r20, r24
    2240:	50 e0       	ldi	r21, 0x00	; 0
    2242:	8c 81       	ldd	r24, Y+4	; 0x04
    2244:	9d 81       	ldd	r25, Y+5	; 0x05
    2246:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <memcpy>
    224a:	28 a1       	ldd	r18, Y+32	; 0x20
    224c:	8c 81       	ldd	r24, Y+4	; 0x04
    224e:	9d 81       	ldd	r25, Y+5	; 0x05
    2250:	82 0f       	add	r24, r18
    2252:	91 1d       	adc	r25, r1
    2254:	8c 83       	std	Y+4, r24	; 0x04
    2256:	9d 83       	std	Y+5, r25	; 0x05
    2258:	2a 81       	ldd	r18, Y+2	; 0x02
    225a:	3b 81       	ldd	r19, Y+3	; 0x03
    225c:	82 17       	cp	r24, r18
    225e:	93 07       	cpc	r25, r19
    2260:	08 f1       	brcs	.+66     	; 0x22a4 <prvCopyDataToQueue+0x8c>
    2262:	88 81       	ld	r24, Y
    2264:	99 81       	ldd	r25, Y+1	; 0x01
    2266:	8c 83       	std	Y+4, r24	; 0x04
    2268:	9d 83       	std	Y+5, r25	; 0x05
    226a:	1c c0       	rjmp	.+56     	; 0x22a4 <prvCopyDataToQueue+0x8c>
    226c:	48 2f       	mov	r20, r24
    226e:	50 e0       	ldi	r21, 0x00	; 0
    2270:	8e 81       	ldd	r24, Y+6	; 0x06
    2272:	9f 81       	ldd	r25, Y+7	; 0x07
    2274:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <memcpy>
    2278:	88 a1       	ldd	r24, Y+32	; 0x20
    227a:	90 e0       	ldi	r25, 0x00	; 0
    227c:	91 95       	neg	r25
    227e:	81 95       	neg	r24
    2280:	91 09       	sbc	r25, r1
    2282:	2e 81       	ldd	r18, Y+6	; 0x06
    2284:	3f 81       	ldd	r19, Y+7	; 0x07
    2286:	28 0f       	add	r18, r24
    2288:	39 1f       	adc	r19, r25
    228a:	2e 83       	std	Y+6, r18	; 0x06
    228c:	3f 83       	std	Y+7, r19	; 0x07
    228e:	48 81       	ld	r20, Y
    2290:	59 81       	ldd	r21, Y+1	; 0x01
    2292:	24 17       	cp	r18, r20
    2294:	35 07       	cpc	r19, r21
    2296:	30 f4       	brcc	.+12     	; 0x22a4 <prvCopyDataToQueue+0x8c>
    2298:	2a 81       	ldd	r18, Y+2	; 0x02
    229a:	3b 81       	ldd	r19, Y+3	; 0x03
    229c:	82 0f       	add	r24, r18
    229e:	93 1f       	adc	r25, r19
    22a0:	8e 83       	std	Y+6, r24	; 0x06
    22a2:	9f 83       	std	Y+7, r25	; 0x07
    22a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22a6:	8f 5f       	subi	r24, 0xFF	; 255
    22a8:	8e 8f       	std	Y+30, r24	; 0x1e
    22aa:	df 91       	pop	r29
    22ac:	cf 91       	pop	r28
    22ae:	08 95       	ret

000022b0 <prvCopyDataFromQueue>:
    22b0:	fc 01       	movw	r30, r24
    22b2:	80 81       	ld	r24, Z
    22b4:	91 81       	ldd	r25, Z+1	; 0x01
    22b6:	00 97       	sbiw	r24, 0x00	; 0
    22b8:	a1 f0       	breq	.+40     	; 0x22e2 <prvCopyDataFromQueue+0x32>
    22ba:	40 a1       	ldd	r20, Z+32	; 0x20
    22bc:	50 e0       	ldi	r21, 0x00	; 0
    22be:	26 81       	ldd	r18, Z+6	; 0x06
    22c0:	37 81       	ldd	r19, Z+7	; 0x07
    22c2:	24 0f       	add	r18, r20
    22c4:	35 1f       	adc	r19, r21
    22c6:	26 83       	std	Z+6, r18	; 0x06
    22c8:	37 83       	std	Z+7, r19	; 0x07
    22ca:	a2 81       	ldd	r26, Z+2	; 0x02
    22cc:	b3 81       	ldd	r27, Z+3	; 0x03
    22ce:	2a 17       	cp	r18, r26
    22d0:	3b 07       	cpc	r19, r27
    22d2:	10 f0       	brcs	.+4      	; 0x22d8 <prvCopyDataFromQueue+0x28>
    22d4:	86 83       	std	Z+6, r24	; 0x06
    22d6:	97 83       	std	Z+7, r25	; 0x07
    22d8:	cb 01       	movw	r24, r22
    22da:	66 81       	ldd	r22, Z+6	; 0x06
    22dc:	77 81       	ldd	r23, Z+7	; 0x07
    22de:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <memcpy>
    22e2:	08 95       	ret

000022e4 <prvUnlockQueue>:
    22e4:	0f 93       	push	r16
    22e6:	1f 93       	push	r17
    22e8:	cf 93       	push	r28
    22ea:	df 93       	push	r29
    22ec:	ec 01       	movw	r28, r24
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	0f 92       	push	r0
    22f4:	8a a1       	ldd	r24, Y+34	; 0x22
    22f6:	18 16       	cp	r1, r24
    22f8:	b4 f4       	brge	.+44     	; 0x2326 <prvUnlockQueue+0x42>
    22fa:	8b 89       	ldd	r24, Y+19	; 0x13
    22fc:	81 11       	cpse	r24, r1
    22fe:	05 c0       	rjmp	.+10     	; 0x230a <prvUnlockQueue+0x26>
    2300:	12 c0       	rjmp	.+36     	; 0x2326 <prvUnlockQueue+0x42>
    2302:	8b 89       	ldd	r24, Y+19	; 0x13
    2304:	81 11       	cpse	r24, r1
    2306:	04 c0       	rjmp	.+8      	; 0x2310 <prvUnlockQueue+0x2c>
    2308:	0e c0       	rjmp	.+28     	; 0x2326 <prvUnlockQueue+0x42>
    230a:	8e 01       	movw	r16, r28
    230c:	0d 5e       	subi	r16, 0xED	; 237
    230e:	1f 4f       	sbci	r17, 0xFF	; 255
    2310:	c8 01       	movw	r24, r16
    2312:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    2316:	81 11       	cpse	r24, r1
    2318:	0e 94 98 18 	call	0x3130	; 0x3130 <vTaskMissedYield>
    231c:	8a a1       	ldd	r24, Y+34	; 0x22
    231e:	81 50       	subi	r24, 0x01	; 1
    2320:	8a a3       	std	Y+34, r24	; 0x22
    2322:	18 16       	cp	r1, r24
    2324:	74 f3       	brlt	.-36     	; 0x2302 <prvUnlockQueue+0x1e>
    2326:	8f ef       	ldi	r24, 0xFF	; 255
    2328:	8a a3       	std	Y+34, r24	; 0x22
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	0f 92       	push	r0
    2334:	89 a1       	ldd	r24, Y+33	; 0x21
    2336:	18 16       	cp	r1, r24
    2338:	b4 f4       	brge	.+44     	; 0x2366 <prvUnlockQueue+0x82>
    233a:	88 85       	ldd	r24, Y+8	; 0x08
    233c:	81 11       	cpse	r24, r1
    233e:	05 c0       	rjmp	.+10     	; 0x234a <prvUnlockQueue+0x66>
    2340:	12 c0       	rjmp	.+36     	; 0x2366 <prvUnlockQueue+0x82>
    2342:	88 85       	ldd	r24, Y+8	; 0x08
    2344:	81 11       	cpse	r24, r1
    2346:	04 c0       	rjmp	.+8      	; 0x2350 <prvUnlockQueue+0x6c>
    2348:	0e c0       	rjmp	.+28     	; 0x2366 <prvUnlockQueue+0x82>
    234a:	8e 01       	movw	r16, r28
    234c:	08 5f       	subi	r16, 0xF8	; 248
    234e:	1f 4f       	sbci	r17, 0xFF	; 255
    2350:	c8 01       	movw	r24, r16
    2352:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    2356:	81 11       	cpse	r24, r1
    2358:	0e 94 98 18 	call	0x3130	; 0x3130 <vTaskMissedYield>
    235c:	89 a1       	ldd	r24, Y+33	; 0x21
    235e:	81 50       	subi	r24, 0x01	; 1
    2360:	89 a3       	std	Y+33, r24	; 0x21
    2362:	18 16       	cp	r1, r24
    2364:	74 f3       	brlt	.-36     	; 0x2342 <prvUnlockQueue+0x5e>
    2366:	8f ef       	ldi	r24, 0xFF	; 255
    2368:	89 a3       	std	Y+33, r24	; 0x21
    236a:	0f 90       	pop	r0
    236c:	0f be       	out	0x3f, r0	; 63
    236e:	df 91       	pop	r29
    2370:	cf 91       	pop	r28
    2372:	1f 91       	pop	r17
    2374:	0f 91       	pop	r16
    2376:	08 95       	ret

00002378 <xQueueGenericReset>:
    2378:	1f 93       	push	r17
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	61 30       	cpi	r22, 0x01	; 1
    2380:	59 f0       	breq	.+22     	; 0x2398 <xQueueGenericReset+0x20>
    2382:	fc 01       	movw	r30, r24
    2384:	23 89       	ldd	r18, Z+19	; 0x13
    2386:	30 85       	ldd	r19, Z+8	; 0x08
    2388:	31 11       	cpse	r19, r1
    238a:	2c c0       	rjmp	.+88     	; 0x23e4 <xQueueGenericReset+0x6c>
    238c:	11 e0       	ldi	r17, 0x01	; 1
    238e:	21 11       	cpse	r18, r1
    2390:	10 e0       	ldi	r17, 0x00	; 0
    2392:	21 11       	cpse	r18, r1
    2394:	28 c0       	rjmp	.+80     	; 0x23e6 <xQueueGenericReset+0x6e>
    2396:	01 c0       	rjmp	.+2      	; 0x239a <xQueueGenericReset+0x22>
    2398:	11 e0       	ldi	r17, 0x01	; 1
    239a:	ec 01       	movw	r28, r24
    239c:	48 81       	ld	r20, Y
    239e:	59 81       	ldd	r21, Y+1	; 0x01
    23a0:	28 a1       	ldd	r18, Y+32	; 0x20
    23a2:	30 e0       	ldi	r19, 0x00	; 0
    23a4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    23a6:	62 9f       	mul	r22, r18
    23a8:	c0 01       	movw	r24, r0
    23aa:	63 9f       	mul	r22, r19
    23ac:	90 0d       	add	r25, r0
    23ae:	11 24       	eor	r1, r1
    23b0:	ba 01       	movw	r22, r20
    23b2:	68 0f       	add	r22, r24
    23b4:	79 1f       	adc	r23, r25
    23b6:	6a 83       	std	Y+2, r22	; 0x02
    23b8:	7b 83       	std	Y+3, r23	; 0x03
    23ba:	1e 8e       	std	Y+30, r1	; 0x1e
    23bc:	4c 83       	std	Y+4, r20	; 0x04
    23be:	5d 83       	std	Y+5, r21	; 0x05
    23c0:	82 1b       	sub	r24, r18
    23c2:	93 0b       	sbc	r25, r19
    23c4:	84 0f       	add	r24, r20
    23c6:	95 1f       	adc	r25, r21
    23c8:	8e 83       	std	Y+6, r24	; 0x06
    23ca:	9f 83       	std	Y+7, r25	; 0x07
    23cc:	8f ef       	ldi	r24, 0xFF	; 255
    23ce:	89 a3       	std	Y+33, r24	; 0x21
    23d0:	8a a3       	std	Y+34, r24	; 0x22
    23d2:	ce 01       	movw	r24, r28
    23d4:	08 96       	adiw	r24, 0x08	; 8
    23d6:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    23da:	ce 01       	movw	r24, r28
    23dc:	43 96       	adiw	r24, 0x13	; 19
    23de:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    23e2:	01 c0       	rjmp	.+2      	; 0x23e6 <xQueueGenericReset+0x6e>
    23e4:	10 e0       	ldi	r17, 0x00	; 0
    23e6:	81 2f       	mov	r24, r17
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	08 95       	ret

000023f0 <xQueueGenericCreate>:
    23f0:	0f 93       	push	r16
    23f2:	1f 93       	push	r17
    23f4:	cf 93       	push	r28
    23f6:	df 93       	push	r29
    23f8:	88 23       	and	r24, r24
    23fa:	01 f1       	breq	.+64     	; 0x243c <xQueueGenericCreate+0x4c>
    23fc:	06 2f       	mov	r16, r22
    23fe:	18 2f       	mov	r17, r24
    2400:	83 e2       	ldi	r24, 0x23	; 35
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    2408:	ec 01       	movw	r28, r24
    240a:	89 2b       	or	r24, r25
    240c:	c9 f0       	breq	.+50     	; 0x2440 <xQueueGenericCreate+0x50>
    240e:	10 9f       	mul	r17, r16
    2410:	c0 01       	movw	r24, r0
    2412:	11 24       	eor	r1, r1
    2414:	01 96       	adiw	r24, 0x01	; 1
    2416:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    241a:	88 83       	st	Y, r24
    241c:	99 83       	std	Y+1, r25	; 0x01
    241e:	89 2b       	or	r24, r25
    2420:	39 f0       	breq	.+14     	; 0x2430 <xQueueGenericCreate+0x40>
    2422:	1f 8f       	std	Y+31, r17	; 0x1f
    2424:	08 a3       	std	Y+32, r16	; 0x20
    2426:	61 e0       	ldi	r22, 0x01	; 1
    2428:	ce 01       	movw	r24, r28
    242a:	0e 94 bc 11 	call	0x2378	; 0x2378 <xQueueGenericReset>
    242e:	08 c0       	rjmp	.+16     	; 0x2440 <xQueueGenericCreate+0x50>
    2430:	ce 01       	movw	r24, r28
    2432:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <vPortFree>
    2436:	c0 e0       	ldi	r28, 0x00	; 0
    2438:	d0 e0       	ldi	r29, 0x00	; 0
    243a:	02 c0       	rjmp	.+4      	; 0x2440 <xQueueGenericCreate+0x50>
    243c:	c0 e0       	ldi	r28, 0x00	; 0
    243e:	d0 e0       	ldi	r29, 0x00	; 0
    2440:	ce 01       	movw	r24, r28
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	08 95       	ret

0000244c <xQueueGenericSend>:
    244c:	af 92       	push	r10
    244e:	bf 92       	push	r11
    2450:	cf 92       	push	r12
    2452:	df 92       	push	r13
    2454:	ef 92       	push	r14
    2456:	ff 92       	push	r15
    2458:	0f 93       	push	r16
    245a:	1f 93       	push	r17
    245c:	cf 93       	push	r28
    245e:	df 93       	push	r29
    2460:	cd b7       	in	r28, 0x3d	; 61
    2462:	de b7       	in	r29, 0x3e	; 62
    2464:	29 97       	sbiw	r28, 0x09	; 9
    2466:	cd bf       	out	0x3d, r28	; 61
    2468:	de bf       	out	0x3e, r29	; 62
    246a:	7c 01       	movw	r14, r24
    246c:	5b 01       	movw	r10, r22
    246e:	2e 83       	std	Y+6, r18	; 0x06
    2470:	3f 83       	std	Y+7, r19	; 0x07
    2472:	48 87       	std	Y+8, r20	; 0x08
    2474:	59 87       	std	Y+9, r21	; 0x09
    2476:	10 e0       	ldi	r17, 0x00	; 0
    2478:	6c 01       	movw	r12, r24
    247a:	88 e0       	ldi	r24, 0x08	; 8
    247c:	c8 0e       	add	r12, r24
    247e:	d1 1c       	adc	r13, r1
    2480:	0f b6       	in	r0, 0x3f	; 63
    2482:	f8 94       	cli
    2484:	0f 92       	push	r0
    2486:	f7 01       	movw	r30, r14
    2488:	96 8d       	ldd	r25, Z+30	; 0x1e
    248a:	87 8d       	ldd	r24, Z+31	; 0x1f
    248c:	98 17       	cp	r25, r24
    248e:	a8 f4       	brcc	.+42     	; 0x24ba <xQueueGenericSend+0x6e>
    2490:	40 2f       	mov	r20, r16
    2492:	b5 01       	movw	r22, r10
    2494:	c7 01       	movw	r24, r14
    2496:	0e 94 0c 11 	call	0x2218	; 0x2218 <prvCopyDataToQueue>
    249a:	f7 01       	movw	r30, r14
    249c:	83 89       	ldd	r24, Z+19	; 0x13
    249e:	88 23       	and	r24, r24
    24a0:	41 f0       	breq	.+16     	; 0x24b2 <xQueueGenericSend+0x66>
    24a2:	c7 01       	movw	r24, r14
    24a4:	43 96       	adiw	r24, 0x13	; 19
    24a6:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    24aa:	81 30       	cpi	r24, 0x01	; 1
    24ac:	11 f4       	brne	.+4      	; 0x24b2 <xQueueGenericSend+0x66>
    24ae:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    24b2:	0f 90       	pop	r0
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	81 e0       	ldi	r24, 0x01	; 1
    24b8:	56 c0       	rjmp	.+172    	; 0x2566 <xQueueGenericSend+0x11a>
    24ba:	8e 81       	ldd	r24, Y+6	; 0x06
    24bc:	9f 81       	ldd	r25, Y+7	; 0x07
    24be:	a8 85       	ldd	r26, Y+8	; 0x08
    24c0:	b9 85       	ldd	r27, Y+9	; 0x09
    24c2:	89 2b       	or	r24, r25
    24c4:	8a 2b       	or	r24, r26
    24c6:	8b 2b       	or	r24, r27
    24c8:	21 f4       	brne	.+8      	; 0x24d2 <xQueueGenericSend+0x86>
    24ca:	0f 90       	pop	r0
    24cc:	0f be       	out	0x3f, r0	; 63
    24ce:	80 e0       	ldi	r24, 0x00	; 0
    24d0:	4a c0       	rjmp	.+148    	; 0x2566 <xQueueGenericSend+0x11a>
    24d2:	11 11       	cpse	r17, r1
    24d4:	05 c0       	rjmp	.+10     	; 0x24e0 <xQueueGenericSend+0x94>
    24d6:	ce 01       	movw	r24, r28
    24d8:	01 96       	adiw	r24, 0x01	; 1
    24da:	0e 94 1a 18 	call	0x3034	; 0x3034 <vTaskSetTimeOutState>
    24de:	11 e0       	ldi	r17, 0x01	; 1
    24e0:	0f 90       	pop	r0
    24e2:	0f be       	out	0x3f, r0	; 63
    24e4:	0e 94 82 15 	call	0x2b04	; 0x2b04 <vTaskSuspendAll>
    24e8:	0f b6       	in	r0, 0x3f	; 63
    24ea:	f8 94       	cli
    24ec:	0f 92       	push	r0
    24ee:	f7 01       	movw	r30, r14
    24f0:	81 a1       	ldd	r24, Z+33	; 0x21
    24f2:	8f 3f       	cpi	r24, 0xFF	; 255
    24f4:	09 f4       	brne	.+2      	; 0x24f8 <xQueueGenericSend+0xac>
    24f6:	11 a2       	std	Z+33, r1	; 0x21
    24f8:	f7 01       	movw	r30, r14
    24fa:	82 a1       	ldd	r24, Z+34	; 0x22
    24fc:	8f 3f       	cpi	r24, 0xFF	; 255
    24fe:	09 f4       	brne	.+2      	; 0x2502 <xQueueGenericSend+0xb6>
    2500:	12 a2       	std	Z+34, r1	; 0x22
    2502:	0f 90       	pop	r0
    2504:	0f be       	out	0x3f, r0	; 63
    2506:	be 01       	movw	r22, r28
    2508:	6a 5f       	subi	r22, 0xFA	; 250
    250a:	7f 4f       	sbci	r23, 0xFF	; 255
    250c:	ce 01       	movw	r24, r28
    250e:	01 96       	adiw	r24, 0x01	; 1
    2510:	0e 94 2b 18 	call	0x3056	; 0x3056 <xTaskCheckForTimeOut>
    2514:	81 11       	cpse	r24, r1
    2516:	21 c0       	rjmp	.+66     	; 0x255a <xQueueGenericSend+0x10e>
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	f8 94       	cli
    251c:	0f 92       	push	r0
    251e:	f7 01       	movw	r30, r14
    2520:	96 8d       	ldd	r25, Z+30	; 0x1e
    2522:	0f 90       	pop	r0
    2524:	0f be       	out	0x3f, r0	; 63
    2526:	87 8d       	ldd	r24, Z+31	; 0x1f
    2528:	98 13       	cpse	r25, r24
    252a:	11 c0       	rjmp	.+34     	; 0x254e <xQueueGenericSend+0x102>
    252c:	4e 81       	ldd	r20, Y+6	; 0x06
    252e:	5f 81       	ldd	r21, Y+7	; 0x07
    2530:	68 85       	ldd	r22, Y+8	; 0x08
    2532:	79 85       	ldd	r23, Y+9	; 0x09
    2534:	c6 01       	movw	r24, r12
    2536:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <vTaskPlaceOnEventList>
    253a:	c7 01       	movw	r24, r14
    253c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
    2540:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
    2544:	81 11       	cpse	r24, r1
    2546:	9c cf       	rjmp	.-200    	; 0x2480 <xQueueGenericSend+0x34>
    2548:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    254c:	99 cf       	rjmp	.-206    	; 0x2480 <xQueueGenericSend+0x34>
    254e:	c7 01       	movw	r24, r14
    2550:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
    2554:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
    2558:	93 cf       	rjmp	.-218    	; 0x2480 <xQueueGenericSend+0x34>
    255a:	c7 01       	movw	r24, r14
    255c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
    2560:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
    2564:	80 e0       	ldi	r24, 0x00	; 0
    2566:	29 96       	adiw	r28, 0x09	; 9
    2568:	cd bf       	out	0x3d, r28	; 61
    256a:	de bf       	out	0x3e, r29	; 62
    256c:	df 91       	pop	r29
    256e:	cf 91       	pop	r28
    2570:	1f 91       	pop	r17
    2572:	0f 91       	pop	r16
    2574:	ff 90       	pop	r15
    2576:	ef 90       	pop	r14
    2578:	df 90       	pop	r13
    257a:	cf 90       	pop	r12
    257c:	bf 90       	pop	r11
    257e:	af 90       	pop	r10
    2580:	08 95       	ret

00002582 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2582:	0f 93       	push	r16
    2584:	1f 93       	push	r17
    2586:	cf 93       	push	r28
    2588:	df 93       	push	r29
    258a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    258c:	fc 01       	movw	r30, r24
    258e:	56 8d       	ldd	r21, Z+30	; 0x1e
    2590:	37 8d       	ldd	r19, Z+31	; 0x1f
    2592:	53 17       	cp	r21, r19
    2594:	c0 f4       	brcc	.+48     	; 0x25c6 <xQueueGenericSendFromISR+0x44>
    2596:	42 2f       	mov	r20, r18
    2598:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    259a:	0e 94 0c 11 	call	0x2218	; 0x2218 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    259e:	8a a1       	ldd	r24, Y+34	; 0x22
    25a0:	8f 3f       	cpi	r24, 0xFF	; 255
    25a2:	69 f4       	brne	.+26     	; 0x25be <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25a4:	8b 89       	ldd	r24, Y+19	; 0x13
    25a6:	88 23       	and	r24, r24
    25a8:	81 f0       	breq	.+32     	; 0x25ca <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25aa:	ce 01       	movw	r24, r28
    25ac:	43 96       	adiw	r24, 0x13	; 19
    25ae:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    25b2:	88 23       	and	r24, r24
    25b4:	61 f0       	breq	.+24     	; 0x25ce <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    25b6:	81 e0       	ldi	r24, 0x01	; 1
    25b8:	f8 01       	movw	r30, r16
    25ba:	80 83       	st	Z, r24
    25bc:	09 c0       	rjmp	.+18     	; 0x25d0 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    25be:	8f 5f       	subi	r24, 0xFF	; 255
    25c0:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    25c2:	81 e0       	ldi	r24, 0x01	; 1
    25c4:	05 c0       	rjmp	.+10     	; 0x25d0 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    25c6:	80 e0       	ldi	r24, 0x00	; 0
    25c8:	03 c0       	rjmp	.+6      	; 0x25d0 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    25ca:	81 e0       	ldi	r24, 0x01	; 1
    25cc:	01 c0       	rjmp	.+2      	; 0x25d0 <xQueueGenericSendFromISR+0x4e>
    25ce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    25d0:	df 91       	pop	r29
    25d2:	cf 91       	pop	r28
    25d4:	1f 91       	pop	r17
    25d6:	0f 91       	pop	r16
    25d8:	08 95       	ret

000025da <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    25da:	af 92       	push	r10
    25dc:	bf 92       	push	r11
    25de:	cf 92       	push	r12
    25e0:	df 92       	push	r13
    25e2:	ef 92       	push	r14
    25e4:	ff 92       	push	r15
    25e6:	0f 93       	push	r16
    25e8:	1f 93       	push	r17
    25ea:	cf 93       	push	r28
    25ec:	df 93       	push	r29
    25ee:	cd b7       	in	r28, 0x3d	; 61
    25f0:	de b7       	in	r29, 0x3e	; 62
    25f2:	29 97       	sbiw	r28, 0x09	; 9
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	de bf       	out	0x3e, r29	; 62
    25f8:	7c 01       	movw	r14, r24
    25fa:	5b 01       	movw	r10, r22
    25fc:	2e 83       	std	Y+6, r18	; 0x06
    25fe:	3f 83       	std	Y+7, r19	; 0x07
    2600:	48 87       	std	Y+8, r20	; 0x08
    2602:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2604:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2606:	6c 01       	movw	r12, r24
    2608:	83 e1       	ldi	r24, 0x13	; 19
    260a:	c8 0e       	add	r12, r24
    260c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    260e:	0f b6       	in	r0, 0x3f	; 63
    2610:	f8 94       	cli
    2612:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2614:	f7 01       	movw	r30, r14
    2616:	86 8d       	ldd	r24, Z+30	; 0x1e
    2618:	88 23       	and	r24, r24
    261a:	99 f1       	breq	.+102    	; 0x2682 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    261c:	c6 80       	ldd	r12, Z+6	; 0x06
    261e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2620:	b5 01       	movw	r22, r10
    2622:	c7 01       	movw	r24, r14
    2624:	0e 94 58 11 	call	0x22b0	; 0x22b0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2628:	01 11       	cpse	r16, r1
    262a:	1a c0       	rjmp	.+52     	; 0x2660 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    262c:	f7 01       	movw	r30, r14
    262e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2630:	81 50       	subi	r24, 0x01	; 1
    2632:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2634:	80 81       	ld	r24, Z
    2636:	91 81       	ldd	r25, Z+1	; 0x01
    2638:	89 2b       	or	r24, r25
    263a:	29 f4       	brne	.+10     	; 0x2646 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    263c:	0e 94 b5 18 	call	0x316a	; 0x316a <xTaskGetCurrentTaskHandle>
    2640:	f7 01       	movw	r30, r14
    2642:	82 83       	std	Z+2, r24	; 0x02
    2644:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2646:	f7 01       	movw	r30, r14
    2648:	80 85       	ldd	r24, Z+8	; 0x08
    264a:	88 23       	and	r24, r24
    264c:	b1 f0       	breq	.+44     	; 0x267a <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    264e:	c7 01       	movw	r24, r14
    2650:	08 96       	adiw	r24, 0x08	; 8
    2652:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    2656:	81 30       	cpi	r24, 0x01	; 1
    2658:	81 f4       	brne	.+32     	; 0x267a <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    265a:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    265e:	0d c0       	rjmp	.+26     	; 0x267a <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2660:	f7 01       	movw	r30, r14
    2662:	c6 82       	std	Z+6, r12	; 0x06
    2664:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2666:	83 89       	ldd	r24, Z+19	; 0x13
    2668:	88 23       	and	r24, r24
    266a:	39 f0       	breq	.+14     	; 0x267a <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    266c:	c7 01       	movw	r24, r14
    266e:	43 96       	adiw	r24, 0x13	; 19
    2670:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    2674:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2676:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    267a:	0f 90       	pop	r0
    267c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	62 c0       	rjmp	.+196    	; 0x2746 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2682:	8e 81       	ldd	r24, Y+6	; 0x06
    2684:	9f 81       	ldd	r25, Y+7	; 0x07
    2686:	a8 85       	ldd	r26, Y+8	; 0x08
    2688:	b9 85       	ldd	r27, Y+9	; 0x09
    268a:	89 2b       	or	r24, r25
    268c:	8a 2b       	or	r24, r26
    268e:	8b 2b       	or	r24, r27
    2690:	21 f4       	brne	.+8      	; 0x269a <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2692:	0f 90       	pop	r0
    2694:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2696:	80 e0       	ldi	r24, 0x00	; 0
    2698:	56 c0       	rjmp	.+172    	; 0x2746 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    269a:	11 11       	cpse	r17, r1
    269c:	05 c0       	rjmp	.+10     	; 0x26a8 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    269e:	ce 01       	movw	r24, r28
    26a0:	01 96       	adiw	r24, 0x01	; 1
    26a2:	0e 94 1a 18 	call	0x3034	; 0x3034 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26a6:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    26a8:	0f 90       	pop	r0
    26aa:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ac:	0e 94 82 15 	call	0x2b04	; 0x2b04 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	f8 94       	cli
    26b4:	0f 92       	push	r0
    26b6:	f7 01       	movw	r30, r14
    26b8:	81 a1       	ldd	r24, Z+33	; 0x21
    26ba:	8f 3f       	cpi	r24, 0xFF	; 255
    26bc:	09 f4       	brne	.+2      	; 0x26c0 <xQueueGenericReceive+0xe6>
    26be:	11 a2       	std	Z+33, r1	; 0x21
    26c0:	f7 01       	movw	r30, r14
    26c2:	82 a1       	ldd	r24, Z+34	; 0x22
    26c4:	8f 3f       	cpi	r24, 0xFF	; 255
    26c6:	09 f4       	brne	.+2      	; 0x26ca <xQueueGenericReceive+0xf0>
    26c8:	12 a2       	std	Z+34, r1	; 0x22
    26ca:	0f 90       	pop	r0
    26cc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26ce:	be 01       	movw	r22, r28
    26d0:	6a 5f       	subi	r22, 0xFA	; 250
    26d2:	7f 4f       	sbci	r23, 0xFF	; 255
    26d4:	ce 01       	movw	r24, r28
    26d6:	01 96       	adiw	r24, 0x01	; 1
    26d8:	0e 94 2b 18 	call	0x3056	; 0x3056 <xTaskCheckForTimeOut>
    26dc:	81 11       	cpse	r24, r1
    26de:	2d c0       	rjmp	.+90     	; 0x273a <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    26e0:	0f b6       	in	r0, 0x3f	; 63
    26e2:	f8 94       	cli
    26e4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    26e6:	f7 01       	movw	r30, r14
    26e8:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26ee:	81 11       	cpse	r24, r1
    26f0:	1e c0       	rjmp	.+60     	; 0x272e <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    26f2:	80 81       	ld	r24, Z
    26f4:	91 81       	ldd	r25, Z+1	; 0x01
    26f6:	89 2b       	or	r24, r25
    26f8:	49 f4       	brne	.+18     	; 0x270c <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2700:	82 81       	ldd	r24, Z+2	; 0x02
    2702:	93 81       	ldd	r25, Z+3	; 0x03
    2704:	0e 94 ba 18 	call	0x3174	; 0x3174 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    270c:	4e 81       	ldd	r20, Y+6	; 0x06
    270e:	5f 81       	ldd	r21, Y+7	; 0x07
    2710:	68 85       	ldd	r22, Y+8	; 0x08
    2712:	79 85       	ldd	r23, Y+9	; 0x09
    2714:	c6 01       	movw	r24, r12
    2716:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    271a:	c7 01       	movw	r24, r14
    271c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2720:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
    2724:	81 11       	cpse	r24, r1
    2726:	73 cf       	rjmp	.-282    	; 0x260e <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2728:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    272c:	70 cf       	rjmp	.-288    	; 0x260e <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    272e:	c7 01       	movw	r24, r14
    2730:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2734:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
    2738:	6a cf       	rjmp	.-300    	; 0x260e <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    273a:	c7 01       	movw	r24, r14
    273c:	0e 94 72 11 	call	0x22e4	; 0x22e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2740:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2744:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2746:	29 96       	adiw	r28, 0x09	; 9
    2748:	cd bf       	out	0x3d, r28	; 61
    274a:	de bf       	out	0x3e, r29	; 62
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	1f 91       	pop	r17
    2752:	0f 91       	pop	r16
    2754:	ff 90       	pop	r15
    2756:	ef 90       	pop	r14
    2758:	df 90       	pop	r13
    275a:	cf 90       	pop	r12
    275c:	bf 90       	pop	r11
    275e:	af 90       	pop	r10
    2760:	08 95       	ret

00002762 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2762:	0f 93       	push	r16
    2764:	1f 93       	push	r17
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    276a:	fc 01       	movw	r30, r24
    276c:	26 8d       	ldd	r18, Z+30	; 0x1e
    276e:	22 23       	and	r18, r18
    2770:	d9 f0       	breq	.+54     	; 0x27a8 <xQueueReceiveFromISR+0x46>
    2772:	8a 01       	movw	r16, r20
    2774:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2776:	0e 94 58 11 	call	0x22b0	; 0x22b0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    277a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    277c:	81 50       	subi	r24, 0x01	; 1
    277e:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2780:	89 a1       	ldd	r24, Y+33	; 0x21
    2782:	8f 3f       	cpi	r24, 0xFF	; 255
    2784:	69 f4       	brne	.+26     	; 0x27a0 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2786:	88 85       	ldd	r24, Y+8	; 0x08
    2788:	88 23       	and	r24, r24
    278a:	81 f0       	breq	.+32     	; 0x27ac <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    278c:	ce 01       	movw	r24, r28
    278e:	08 96       	adiw	r24, 0x08	; 8
    2790:	0e 94 db 17 	call	0x2fb6	; 0x2fb6 <xTaskRemoveFromEventList>
    2794:	88 23       	and	r24, r24
    2796:	61 f0       	breq	.+24     	; 0x27b0 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	f8 01       	movw	r30, r16
    279c:	80 83       	st	Z, r24
    279e:	09 c0       	rjmp	.+18     	; 0x27b2 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    27a0:	8f 5f       	subi	r24, 0xFF	; 255
    27a2:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    27a4:	81 e0       	ldi	r24, 0x01	; 1
    27a6:	05 c0       	rjmp	.+10     	; 0x27b2 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    27a8:	80 e0       	ldi	r24, 0x00	; 0
    27aa:	03 c0       	rjmp	.+6      	; 0x27b2 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    27ac:	81 e0       	ldi	r24, 0x01	; 1
    27ae:	01 c0       	rjmp	.+2      	; 0x27b2 <xQueueReceiveFromISR+0x50>
    27b0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    27b2:	df 91       	pop	r29
    27b4:	cf 91       	pop	r28
    27b6:	1f 91       	pop	r17
    27b8:	0f 91       	pop	r16
    27ba:	08 95       	ret

000027bc <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    27bc:	0f b6       	in	r0, 0x3f	; 63
    27be:	f8 94       	cli
    27c0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    27c2:	fc 01       	movw	r30, r24
    27c4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    27c6:	0f 90       	pop	r0
    27c8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    27ca:	08 95       	ret

000027cc <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    27cc:	fc 01       	movw	r30, r24
    27ce:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    27d0:	08 95       	ret

000027d2 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    27d2:	c6 e5       	ldi	r28, 0x56	; 86
    27d4:	d2 e3       	ldi	r29, 0x32	; 50
    27d6:	88 81       	ld	r24, Y
    27d8:	82 30       	cpi	r24, 0x02	; 2
    27da:	e8 f3       	brcs	.-6      	; 0x27d6 <prvIdleTask+0x4>
    27dc:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    27e0:	fa cf       	rjmp	.-12     	; 0x27d6 <prvIdleTask+0x4>

000027e2 <prvAddCurrentTaskToDelayedList>:
    27e2:	cf 92       	push	r12
    27e4:	df 92       	push	r13
    27e6:	ef 92       	push	r14
    27e8:	ff 92       	push	r15
    27ea:	6b 01       	movw	r12, r22
    27ec:	7c 01       	movw	r14, r24
    27ee:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    27f2:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    27f6:	62 83       	std	Z+2, r22	; 0x02
    27f8:	73 83       	std	Z+3, r23	; 0x03
    27fa:	84 83       	std	Z+4, r24	; 0x04
    27fc:	95 83       	std	Z+5, r25	; 0x05
    27fe:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    2802:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    2806:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    280a:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    280e:	c8 16       	cp	r12, r24
    2810:	d9 06       	cpc	r13, r25
    2812:	ea 06       	cpc	r14, r26
    2814:	fb 06       	cpc	r15, r27
    2816:	68 f4       	brcc	.+26     	; 0x2832 <prvAddCurrentTaskToDelayedList+0x50>
    2818:	60 91 82 32 	lds	r22, 0x3282	; 0x803282 <pxCurrentTCB>
    281c:	70 91 83 32 	lds	r23, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2820:	80 91 3c 32 	lds	r24, 0x323C	; 0x80323c <pxOverflowDelayedTaskList>
    2824:	90 91 3d 32 	lds	r25, 0x323D	; 0x80323d <pxOverflowDelayedTaskList+0x1>
    2828:	6e 5f       	subi	r22, 0xFE	; 254
    282a:	7f 4f       	sbci	r23, 0xFF	; 255
    282c:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <vListInsert>
    2830:	21 c0       	rjmp	.+66     	; 0x2874 <prvAddCurrentTaskToDelayedList+0x92>
    2832:	60 91 82 32 	lds	r22, 0x3282	; 0x803282 <pxCurrentTCB>
    2836:	70 91 83 32 	lds	r23, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    283a:	80 91 3e 32 	lds	r24, 0x323E	; 0x80323e <pxDelayedTaskList>
    283e:	90 91 3f 32 	lds	r25, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2842:	6e 5f       	subi	r22, 0xFE	; 254
    2844:	7f 4f       	sbci	r23, 0xFF	; 255
    2846:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <vListInsert>
    284a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    284e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2852:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2856:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    285a:	c8 16       	cp	r12, r24
    285c:	d9 06       	cpc	r13, r25
    285e:	ea 06       	cpc	r14, r26
    2860:	fb 06       	cpc	r15, r27
    2862:	40 f4       	brcc	.+16     	; 0x2874 <prvAddCurrentTaskToDelayedList+0x92>
    2864:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2868:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    286c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2870:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2874:	ff 90       	pop	r15
    2876:	ef 90       	pop	r14
    2878:	df 90       	pop	r13
    287a:	cf 90       	pop	r12
    287c:	08 95       	ret

0000287e <xTaskGenericCreate>:
    287e:	4f 92       	push	r4
    2880:	5f 92       	push	r5
    2882:	6f 92       	push	r6
    2884:	7f 92       	push	r7
    2886:	8f 92       	push	r8
    2888:	9f 92       	push	r9
    288a:	af 92       	push	r10
    288c:	bf 92       	push	r11
    288e:	cf 92       	push	r12
    2890:	df 92       	push	r13
    2892:	ef 92       	push	r14
    2894:	ff 92       	push	r15
    2896:	0f 93       	push	r16
    2898:	1f 93       	push	r17
    289a:	cf 93       	push	r28
    289c:	df 93       	push	r29
    289e:	5c 01       	movw	r10, r24
    28a0:	4b 01       	movw	r8, r22
    28a2:	3a 01       	movw	r6, r20
    28a4:	29 01       	movw	r4, r18
    28a6:	88 e2       	ldi	r24, 0x28	; 40
    28a8:	90 e0       	ldi	r25, 0x00	; 0
    28aa:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    28ae:	ec 01       	movw	r28, r24
    28b0:	89 2b       	or	r24, r25
    28b2:	09 f4       	brne	.+2      	; 0x28b6 <xTaskGenericCreate+0x38>
    28b4:	d4 c0       	rjmp	.+424    	; 0x2a5e <xTaskGenericCreate+0x1e0>
    28b6:	c1 14       	cp	r12, r1
    28b8:	d1 04       	cpc	r13, r1
    28ba:	09 f0       	breq	.+2      	; 0x28be <xTaskGenericCreate+0x40>
    28bc:	cc c0       	rjmp	.+408    	; 0x2a56 <xTaskGenericCreate+0x1d8>
    28be:	c3 01       	movw	r24, r6
    28c0:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    28c4:	8b 8f       	std	Y+27, r24	; 0x1b
    28c6:	9c 8f       	std	Y+28, r25	; 0x1c
    28c8:	00 97       	sbiw	r24, 0x00	; 0
    28ca:	21 f4       	brne	.+8      	; 0x28d4 <xTaskGenericCreate+0x56>
    28cc:	ce 01       	movw	r24, r28
    28ce:	0e 94 ac 0e 	call	0x1d58	; 0x1d58 <vPortFree>
    28d2:	c5 c0       	rjmp	.+394    	; 0x2a5e <xTaskGenericCreate+0x1e0>
    28d4:	a3 01       	movw	r20, r6
    28d6:	61 e1       	ldi	r22, 0x11	; 17
    28d8:	70 e0       	ldi	r23, 0x00	; 0
    28da:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <memset>
    28de:	93 01       	movw	r18, r6
    28e0:	21 50       	subi	r18, 0x01	; 1
    28e2:	31 09       	sbc	r19, r1
    28e4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    28e6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    28e8:	3c 01       	movw	r6, r24
    28ea:	62 0e       	add	r6, r18
    28ec:	73 1e       	adc	r7, r19
    28ee:	4a e0       	ldi	r20, 0x0A	; 10
    28f0:	50 e0       	ldi	r21, 0x00	; 0
    28f2:	b4 01       	movw	r22, r8
    28f4:	ce 01       	movw	r24, r28
    28f6:	4d 96       	adiw	r24, 0x1d	; 29
    28f8:	0e 94 55 26 	call	0x4caa	; 0x4caa <strncpy>
    28fc:	1e a2       	std	Y+38, r1	; 0x26
    28fe:	10 2f       	mov	r17, r16
    2900:	04 30       	cpi	r16, 0x04	; 4
    2902:	08 f0       	brcs	.+2      	; 0x2906 <xTaskGenericCreate+0x88>
    2904:	13 e0       	ldi	r17, 0x03	; 3
    2906:	1a 8f       	std	Y+26, r17	; 0x1a
    2908:	1f a3       	std	Y+39, r17	; 0x27
    290a:	6e 01       	movw	r12, r28
    290c:	22 e0       	ldi	r18, 0x02	; 2
    290e:	c2 0e       	add	r12, r18
    2910:	d1 1c       	adc	r13, r1
    2912:	c6 01       	movw	r24, r12
    2914:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <vListInitialiseItem>
    2918:	ce 01       	movw	r24, r28
    291a:	0e 96       	adiw	r24, 0x0e	; 14
    291c:	0e 94 f5 0e 	call	0x1dea	; 0x1dea <vListInitialiseItem>
    2920:	ca 87       	std	Y+10, r28	; 0x0a
    2922:	db 87       	std	Y+11, r29	; 0x0b
    2924:	84 e0       	ldi	r24, 0x04	; 4
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	a0 e0       	ldi	r26, 0x00	; 0
    292a:	b0 e0       	ldi	r27, 0x00	; 0
    292c:	81 1b       	sub	r24, r17
    292e:	91 09       	sbc	r25, r1
    2930:	a1 09       	sbc	r26, r1
    2932:	b1 09       	sbc	r27, r1
    2934:	8e 87       	std	Y+14, r24	; 0x0e
    2936:	9f 87       	std	Y+15, r25	; 0x0f
    2938:	a8 8b       	std	Y+16, r26	; 0x10
    293a:	b9 8b       	std	Y+17, r27	; 0x11
    293c:	ce 8b       	std	Y+22, r28	; 0x16
    293e:	df 8b       	std	Y+23, r29	; 0x17
    2940:	a2 01       	movw	r20, r4
    2942:	b5 01       	movw	r22, r10
    2944:	c3 01       	movw	r24, r6
    2946:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <pxPortInitialiseStack>
    294a:	88 83       	st	Y, r24
    294c:	99 83       	std	Y+1, r25	; 0x01
    294e:	e1 14       	cp	r14, r1
    2950:	f1 04       	cpc	r15, r1
    2952:	19 f0       	breq	.+6      	; 0x295a <xTaskGenericCreate+0xdc>
    2954:	f7 01       	movw	r30, r14
    2956:	c0 83       	st	Z, r28
    2958:	d1 83       	std	Z+1, r29	; 0x01
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	0f 92       	push	r0
    2960:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <uxCurrentNumberOfTasks>
    2964:	8f 5f       	subi	r24, 0xFF	; 255
    2966:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <uxCurrentNumberOfTasks>
    296a:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    296e:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2972:	89 2b       	or	r24, r25
    2974:	89 f5       	brne	.+98     	; 0x29d8 <xTaskGenericCreate+0x15a>
    2976:	c0 93 82 32 	sts	0x3282, r28	; 0x803282 <pxCurrentTCB>
    297a:	d0 93 83 32 	sts	0x3283, r29	; 0x803283 <pxCurrentTCB+0x1>
    297e:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <uxCurrentNumberOfTasks>
    2982:	81 30       	cpi	r24, 0x01	; 1
    2984:	c1 f5       	brne	.+112    	; 0x29f6 <xTaskGenericCreate+0x178>
    2986:	86 e5       	ldi	r24, 0x56	; 86
    2988:	92 e3       	ldi	r25, 0x32	; 50
    298a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    298e:	81 e6       	ldi	r24, 0x61	; 97
    2990:	92 e3       	ldi	r25, 0x32	; 50
    2992:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    2996:	8c e6       	ldi	r24, 0x6C	; 108
    2998:	92 e3       	ldi	r25, 0x32	; 50
    299a:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    299e:	87 e7       	ldi	r24, 0x77	; 119
    29a0:	92 e3       	ldi	r25, 0x32	; 50
    29a2:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    29a6:	8b e4       	ldi	r24, 0x4B	; 75
    29a8:	92 e3       	ldi	r25, 0x32	; 50
    29aa:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    29ae:	80 e4       	ldi	r24, 0x40	; 64
    29b0:	92 e3       	ldi	r25, 0x32	; 50
    29b2:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    29b6:	81 e3       	ldi	r24, 0x31	; 49
    29b8:	92 e3       	ldi	r25, 0x32	; 50
    29ba:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <vListInitialise>
    29be:	8b e4       	ldi	r24, 0x4B	; 75
    29c0:	92 e3       	ldi	r25, 0x32	; 50
    29c2:	80 93 3e 32 	sts	0x323E, r24	; 0x80323e <pxDelayedTaskList>
    29c6:	90 93 3f 32 	sts	0x323F, r25	; 0x80323f <pxDelayedTaskList+0x1>
    29ca:	80 e4       	ldi	r24, 0x40	; 64
    29cc:	92 e3       	ldi	r25, 0x32	; 50
    29ce:	80 93 3c 32 	sts	0x323C, r24	; 0x80323c <pxOverflowDelayedTaskList>
    29d2:	90 93 3d 32 	sts	0x323D, r25	; 0x80323d <pxOverflowDelayedTaskList+0x1>
    29d6:	0f c0       	rjmp	.+30     	; 0x29f6 <xTaskGenericCreate+0x178>
    29d8:	80 91 27 32 	lds	r24, 0x3227	; 0x803227 <xSchedulerRunning>
    29dc:	81 11       	cpse	r24, r1
    29de:	0b c0       	rjmp	.+22     	; 0x29f6 <xTaskGenericCreate+0x178>
    29e0:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    29e4:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    29e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    29ea:	08 17       	cp	r16, r24
    29ec:	20 f0       	brcs	.+8      	; 0x29f6 <xTaskGenericCreate+0x178>
    29ee:	c0 93 82 32 	sts	0x3282, r28	; 0x803282 <pxCurrentTCB>
    29f2:	d0 93 83 32 	sts	0x3283, r29	; 0x803283 <pxCurrentTCB+0x1>
    29f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29f8:	90 91 29 32 	lds	r25, 0x3229	; 0x803229 <uxTopUsedPriority>
    29fc:	98 17       	cp	r25, r24
    29fe:	10 f4       	brcc	.+4      	; 0x2a04 <xTaskGenericCreate+0x186>
    2a00:	80 93 29 32 	sts	0x3229, r24	; 0x803229 <uxTopUsedPriority>
    2a04:	90 91 22 32 	lds	r25, 0x3222	; 0x803222 <uxTaskNumber>
    2a08:	9f 5f       	subi	r25, 0xFF	; 255
    2a0a:	90 93 22 32 	sts	0x3222, r25	; 0x803222 <uxTaskNumber>
    2a0e:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    2a12:	98 17       	cp	r25, r24
    2a14:	10 f4       	brcc	.+4      	; 0x2a1a <xTaskGenericCreate+0x19c>
    2a16:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    2a1a:	fb e0       	ldi	r31, 0x0B	; 11
    2a1c:	8f 9f       	mul	r24, r31
    2a1e:	c0 01       	movw	r24, r0
    2a20:	11 24       	eor	r1, r1
    2a22:	b6 01       	movw	r22, r12
    2a24:	8a 5a       	subi	r24, 0xAA	; 170
    2a26:	9d 4c       	sbci	r25, 0xCD	; 205
    2a28:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
    2a2c:	0f 90       	pop	r0
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	80 91 27 32 	lds	r24, 0x3227	; 0x803227 <xSchedulerRunning>
    2a34:	88 23       	and	r24, r24
    2a36:	59 f0       	breq	.+22     	; 0x2a4e <xTaskGenericCreate+0x1d0>
    2a38:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    2a3c:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2a40:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a42:	80 17       	cp	r24, r16
    2a44:	30 f4       	brcc	.+12     	; 0x2a52 <xTaskGenericCreate+0x1d4>
    2a46:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
    2a4c:	09 c0       	rjmp	.+18     	; 0x2a60 <xTaskGenericCreate+0x1e2>
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	07 c0       	rjmp	.+14     	; 0x2a60 <xTaskGenericCreate+0x1e2>
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	05 c0       	rjmp	.+10     	; 0x2a60 <xTaskGenericCreate+0x1e2>
    2a56:	cb 8e       	std	Y+27, r12	; 0x1b
    2a58:	dc 8e       	std	Y+28, r13	; 0x1c
    2a5a:	c6 01       	movw	r24, r12
    2a5c:	3b cf       	rjmp	.-394    	; 0x28d4 <xTaskGenericCreate+0x56>
    2a5e:	8f ef       	ldi	r24, 0xFF	; 255
    2a60:	df 91       	pop	r29
    2a62:	cf 91       	pop	r28
    2a64:	1f 91       	pop	r17
    2a66:	0f 91       	pop	r16
    2a68:	ff 90       	pop	r15
    2a6a:	ef 90       	pop	r14
    2a6c:	df 90       	pop	r13
    2a6e:	cf 90       	pop	r12
    2a70:	bf 90       	pop	r11
    2a72:	af 90       	pop	r10
    2a74:	9f 90       	pop	r9
    2a76:	8f 90       	pop	r8
    2a78:	7f 90       	pop	r7
    2a7a:	6f 90       	pop	r6
    2a7c:	5f 90       	pop	r5
    2a7e:	4f 90       	pop	r4
    2a80:	08 95       	ret

00002a82 <uxTaskPriorityGet>:
    2a82:	0f b6       	in	r0, 0x3f	; 63
    2a84:	f8 94       	cli
    2a86:	0f 92       	push	r0
    2a88:	00 97       	sbiw	r24, 0x00	; 0
    2a8a:	21 f4       	brne	.+8      	; 0x2a94 <uxTaskPriorityGet+0x12>
    2a8c:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    2a90:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2a94:	0f 90       	pop	r0
    2a96:	0f be       	out	0x3f, r0	; 63
    2a98:	fc 01       	movw	r30, r24
    2a9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a9c:	08 95       	ret

00002a9e <vTaskStartScheduler>:
    2a9e:	af 92       	push	r10
    2aa0:	bf 92       	push	r11
    2aa2:	cf 92       	push	r12
    2aa4:	df 92       	push	r13
    2aa6:	ef 92       	push	r14
    2aa8:	ff 92       	push	r15
    2aaa:	0f 93       	push	r16
    2aac:	a1 2c       	mov	r10, r1
    2aae:	b1 2c       	mov	r11, r1
    2ab0:	c1 2c       	mov	r12, r1
    2ab2:	d1 2c       	mov	r13, r1
    2ab4:	0f 2e       	mov	r0, r31
    2ab6:	ff e2       	ldi	r31, 0x2F	; 47
    2ab8:	ef 2e       	mov	r14, r31
    2aba:	f2 e3       	ldi	r31, 0x32	; 50
    2abc:	ff 2e       	mov	r15, r31
    2abe:	f0 2d       	mov	r31, r0
    2ac0:	00 e0       	ldi	r16, 0x00	; 0
    2ac2:	20 e0       	ldi	r18, 0x00	; 0
    2ac4:	30 e0       	ldi	r19, 0x00	; 0
    2ac6:	44 e6       	ldi	r20, 0x64	; 100
    2ac8:	50 e0       	ldi	r21, 0x00	; 0
    2aca:	67 e6       	ldi	r22, 0x67	; 103
    2acc:	71 e2       	ldi	r23, 0x21	; 33
    2ace:	89 ee       	ldi	r24, 0xE9	; 233
    2ad0:	93 e1       	ldi	r25, 0x13	; 19
    2ad2:	0e 94 3f 14 	call	0x287e	; 0x287e <xTaskGenericCreate>
    2ad6:	81 30       	cpi	r24, 0x01	; 1
    2ad8:	69 f4       	brne	.+26     	; 0x2af4 <vTaskStartScheduler+0x56>
    2ada:	f8 94       	cli
    2adc:	80 93 27 32 	sts	0x3227, r24	; 0x803227 <xSchedulerRunning>
    2ae0:	10 92 2a 32 	sts	0x322A, r1	; 0x80322a <xTickCount>
    2ae4:	10 92 2b 32 	sts	0x322B, r1	; 0x80322b <xTickCount+0x1>
    2ae8:	10 92 2c 32 	sts	0x322C, r1	; 0x80322c <xTickCount+0x2>
    2aec:	10 92 2d 32 	sts	0x322D, r1	; 0x80322d <xTickCount+0x3>
    2af0:	0e 94 07 10 	call	0x200e	; 0x200e <xPortStartScheduler>
    2af4:	0f 91       	pop	r16
    2af6:	ff 90       	pop	r15
    2af8:	ef 90       	pop	r14
    2afa:	df 90       	pop	r13
    2afc:	cf 90       	pop	r12
    2afe:	bf 90       	pop	r11
    2b00:	af 90       	pop	r10
    2b02:	08 95       	ret

00002b04 <vTaskSuspendAll>:
    2b04:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2b08:	8f 5f       	subi	r24, 0xFF	; 255
    2b0a:	80 93 26 32 	sts	0x3226, r24	; 0x803226 <uxSchedulerSuspended>
    2b0e:	08 95       	ret

00002b10 <xTaskGetTickCount>:
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	0f 92       	push	r0
    2b16:	60 91 2a 32 	lds	r22, 0x322A	; 0x80322a <xTickCount>
    2b1a:	70 91 2b 32 	lds	r23, 0x322B	; 0x80322b <xTickCount+0x1>
    2b1e:	80 91 2c 32 	lds	r24, 0x322C	; 0x80322c <xTickCount+0x2>
    2b22:	90 91 2d 32 	lds	r25, 0x322D	; 0x80322d <xTickCount+0x3>
    2b26:	0f 90       	pop	r0
    2b28:	0f be       	out	0x3f, r0	; 63
    2b2a:	08 95       	ret

00002b2c <pcTaskGetTaskName>:
    2b2c:	00 97       	sbiw	r24, 0x00	; 0
    2b2e:	21 f4       	brne	.+8      	; 0x2b38 <pcTaskGetTaskName+0xc>
    2b30:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    2b34:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2b38:	4d 96       	adiw	r24, 0x1d	; 29
    2b3a:	08 95       	ret

00002b3c <xTaskGetIdleTaskHandle>:
    2b3c:	80 91 2f 32 	lds	r24, 0x322F	; 0x80322f <xIdleTaskHandle>
    2b40:	90 91 30 32 	lds	r25, 0x3230	; 0x803230 <xIdleTaskHandle+0x1>
    2b44:	08 95       	ret

00002b46 <vTaskIncrementTick>:
    2b46:	ff 92       	push	r15
    2b48:	0f 93       	push	r16
    2b4a:	1f 93       	push	r17
    2b4c:	cf 93       	push	r28
    2b4e:	df 93       	push	r29
    2b50:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2b54:	81 11       	cpse	r24, r1
    2b56:	ed c0       	rjmp	.+474    	; 0x2d32 <vTaskIncrementTick+0x1ec>
    2b58:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    2b5c:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    2b60:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    2b64:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    2b68:	01 96       	adiw	r24, 0x01	; 1
    2b6a:	a1 1d       	adc	r26, r1
    2b6c:	b1 1d       	adc	r27, r1
    2b6e:	80 93 2a 32 	sts	0x322A, r24	; 0x80322a <xTickCount>
    2b72:	90 93 2b 32 	sts	0x322B, r25	; 0x80322b <xTickCount+0x1>
    2b76:	a0 93 2c 32 	sts	0x322C, r26	; 0x80322c <xTickCount+0x2>
    2b7a:	b0 93 2d 32 	sts	0x322D, r27	; 0x80322d <xTickCount+0x3>
    2b7e:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    2b82:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    2b86:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    2b8a:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    2b8e:	89 2b       	or	r24, r25
    2b90:	8a 2b       	or	r24, r26
    2b92:	8b 2b       	or	r24, r27
    2b94:	f1 f5       	brne	.+124    	; 0x2c12 <vTaskIncrementTick+0xcc>
    2b96:	80 91 3e 32 	lds	r24, 0x323E	; 0x80323e <pxDelayedTaskList>
    2b9a:	90 91 3f 32 	lds	r25, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2b9e:	20 91 3c 32 	lds	r18, 0x323C	; 0x80323c <pxOverflowDelayedTaskList>
    2ba2:	30 91 3d 32 	lds	r19, 0x323D	; 0x80323d <pxOverflowDelayedTaskList+0x1>
    2ba6:	20 93 3e 32 	sts	0x323E, r18	; 0x80323e <pxDelayedTaskList>
    2baa:	30 93 3f 32 	sts	0x323F, r19	; 0x80323f <pxDelayedTaskList+0x1>
    2bae:	80 93 3c 32 	sts	0x323C, r24	; 0x80323c <pxOverflowDelayedTaskList>
    2bb2:	90 93 3d 32 	sts	0x323D, r25	; 0x80323d <pxOverflowDelayedTaskList+0x1>
    2bb6:	80 91 23 32 	lds	r24, 0x3223	; 0x803223 <xNumOfOverflows>
    2bba:	8f 5f       	subi	r24, 0xFF	; 255
    2bbc:	80 93 23 32 	sts	0x3223, r24	; 0x803223 <xNumOfOverflows>
    2bc0:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2bc4:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2bc8:	80 81       	ld	r24, Z
    2bca:	81 11       	cpse	r24, r1
    2bcc:	0c c0       	rjmp	.+24     	; 0x2be6 <vTaskIncrementTick+0xa0>
    2bce:	8f ef       	ldi	r24, 0xFF	; 255
    2bd0:	9f ef       	ldi	r25, 0xFF	; 255
    2bd2:	dc 01       	movw	r26, r24
    2bd4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2bd8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2bdc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2be0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2be4:	16 c0       	rjmp	.+44     	; 0x2c12 <vTaskIncrementTick+0xcc>
    2be6:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2bea:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2bee:	07 80       	ldd	r0, Z+7	; 0x07
    2bf0:	f0 85       	ldd	r31, Z+8	; 0x08
    2bf2:	e0 2d       	mov	r30, r0
    2bf4:	00 84       	ldd	r0, Z+8	; 0x08
    2bf6:	f1 85       	ldd	r31, Z+9	; 0x09
    2bf8:	e0 2d       	mov	r30, r0
    2bfa:	82 81       	ldd	r24, Z+2	; 0x02
    2bfc:	93 81       	ldd	r25, Z+3	; 0x03
    2bfe:	a4 81       	ldd	r26, Z+4	; 0x04
    2c00:	b5 81       	ldd	r27, Z+5	; 0x05
    2c02:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2c06:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2c0a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2c0e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2c12:	40 91 2a 32 	lds	r20, 0x322A	; 0x80322a <xTickCount>
    2c16:	50 91 2b 32 	lds	r21, 0x322B	; 0x80322b <xTickCount+0x1>
    2c1a:	60 91 2c 32 	lds	r22, 0x322C	; 0x80322c <xTickCount+0x2>
    2c1e:	70 91 2d 32 	lds	r23, 0x322D	; 0x80322d <xTickCount+0x3>
    2c22:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2c26:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2c2a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2c2e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2c32:	48 17       	cp	r20, r24
    2c34:	59 07       	cpc	r21, r25
    2c36:	6a 07       	cpc	r22, r26
    2c38:	7b 07       	cpc	r23, r27
    2c3a:	08 f4       	brcc	.+2      	; 0x2c3e <vTaskIncrementTick+0xf8>
    2c3c:	7f c0       	rjmp	.+254    	; 0x2d3c <vTaskIncrementTick+0x1f6>
    2c3e:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2c42:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2c46:	80 81       	ld	r24, Z
    2c48:	88 23       	and	r24, r24
    2c4a:	f9 f0       	breq	.+62     	; 0x2c8a <vTaskIncrementTick+0x144>
    2c4c:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2c50:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2c54:	07 80       	ldd	r0, Z+7	; 0x07
    2c56:	f0 85       	ldd	r31, Z+8	; 0x08
    2c58:	e0 2d       	mov	r30, r0
    2c5a:	c0 85       	ldd	r28, Z+8	; 0x08
    2c5c:	d1 85       	ldd	r29, Z+9	; 0x09
    2c5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2c60:	9b 81       	ldd	r25, Y+3	; 0x03
    2c62:	ac 81       	ldd	r26, Y+4	; 0x04
    2c64:	bd 81       	ldd	r27, Y+5	; 0x05
    2c66:	40 91 2a 32 	lds	r20, 0x322A	; 0x80322a <xTickCount>
    2c6a:	50 91 2b 32 	lds	r21, 0x322B	; 0x80322b <xTickCount+0x1>
    2c6e:	60 91 2c 32 	lds	r22, 0x322C	; 0x80322c <xTickCount+0x2>
    2c72:	70 91 2d 32 	lds	r23, 0x322D	; 0x80322d <xTickCount+0x3>
    2c76:	48 17       	cp	r20, r24
    2c78:	59 07       	cpc	r21, r25
    2c7a:	6a 07       	cpc	r22, r26
    2c7c:	7b 07       	cpc	r23, r27
    2c7e:	58 f1       	brcs	.+86     	; 0x2cd6 <vTaskIncrementTick+0x190>
    2c80:	0f 2e       	mov	r0, r31
    2c82:	fb e0       	ldi	r31, 0x0B	; 11
    2c84:	ff 2e       	mov	r15, r31
    2c86:	f0 2d       	mov	r31, r0
    2c88:	2f c0       	rjmp	.+94     	; 0x2ce8 <vTaskIncrementTick+0x1a2>
    2c8a:	8f ef       	ldi	r24, 0xFF	; 255
    2c8c:	9f ef       	ldi	r25, 0xFF	; 255
    2c8e:	dc 01       	movw	r26, r24
    2c90:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2c94:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2c98:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2c9c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2ca0:	4d c0       	rjmp	.+154    	; 0x2d3c <vTaskIncrementTick+0x1f6>
    2ca2:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2ca6:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2caa:	07 80       	ldd	r0, Z+7	; 0x07
    2cac:	f0 85       	ldd	r31, Z+8	; 0x08
    2cae:	e0 2d       	mov	r30, r0
    2cb0:	c0 85       	ldd	r28, Z+8	; 0x08
    2cb2:	d1 85       	ldd	r29, Z+9	; 0x09
    2cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2cb8:	ac 81       	ldd	r26, Y+4	; 0x04
    2cba:	bd 81       	ldd	r27, Y+5	; 0x05
    2cbc:	40 91 2a 32 	lds	r20, 0x322A	; 0x80322a <xTickCount>
    2cc0:	50 91 2b 32 	lds	r21, 0x322B	; 0x80322b <xTickCount+0x1>
    2cc4:	60 91 2c 32 	lds	r22, 0x322C	; 0x80322c <xTickCount+0x2>
    2cc8:	70 91 2d 32 	lds	r23, 0x322D	; 0x80322d <xTickCount+0x3>
    2ccc:	48 17       	cp	r20, r24
    2cce:	59 07       	cpc	r21, r25
    2cd0:	6a 07       	cpc	r22, r26
    2cd2:	7b 07       	cpc	r23, r27
    2cd4:	48 f4       	brcc	.+18     	; 0x2ce8 <vTaskIncrementTick+0x1a2>
    2cd6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2cda:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2cde:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2ce2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2ce6:	2a c0       	rjmp	.+84     	; 0x2d3c <vTaskIncrementTick+0x1f6>
    2ce8:	8e 01       	movw	r16, r28
    2cea:	0e 5f       	subi	r16, 0xFE	; 254
    2cec:	1f 4f       	sbci	r17, 0xFF	; 255
    2cee:	c8 01       	movw	r24, r16
    2cf0:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
    2cf4:	88 8d       	ldd	r24, Y+24	; 0x18
    2cf6:	99 8d       	ldd	r25, Y+25	; 0x19
    2cf8:	89 2b       	or	r24, r25
    2cfa:	21 f0       	breq	.+8      	; 0x2d04 <vTaskIncrementTick+0x1be>
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	0e 96       	adiw	r24, 0x0e	; 14
    2d00:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
    2d04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d06:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    2d0a:	98 17       	cp	r25, r24
    2d0c:	10 f4       	brcc	.+4      	; 0x2d12 <vTaskIncrementTick+0x1cc>
    2d0e:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    2d12:	f8 9e       	mul	r15, r24
    2d14:	c0 01       	movw	r24, r0
    2d16:	11 24       	eor	r1, r1
    2d18:	b8 01       	movw	r22, r16
    2d1a:	8a 5a       	subi	r24, 0xAA	; 170
    2d1c:	9d 4c       	sbci	r25, 0xCD	; 205
    2d1e:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
    2d22:	e0 91 3e 32 	lds	r30, 0x323E	; 0x80323e <pxDelayedTaskList>
    2d26:	f0 91 3f 32 	lds	r31, 0x323F	; 0x80323f <pxDelayedTaskList+0x1>
    2d2a:	80 81       	ld	r24, Z
    2d2c:	81 11       	cpse	r24, r1
    2d2e:	b9 cf       	rjmp	.-142    	; 0x2ca2 <vTaskIncrementTick+0x15c>
    2d30:	ac cf       	rjmp	.-168    	; 0x2c8a <vTaskIncrementTick+0x144>
    2d32:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <uxMissedTicks>
    2d36:	8f 5f       	subi	r24, 0xFF	; 255
    2d38:	80 93 25 32 	sts	0x3225, r24	; 0x803225 <uxMissedTicks>
    2d3c:	df 91       	pop	r29
    2d3e:	cf 91       	pop	r28
    2d40:	1f 91       	pop	r17
    2d42:	0f 91       	pop	r16
    2d44:	ff 90       	pop	r15
    2d46:	08 95       	ret

00002d48 <xTaskResumeAll>:
    2d48:	cf 92       	push	r12
    2d4a:	df 92       	push	r13
    2d4c:	ef 92       	push	r14
    2d4e:	ff 92       	push	r15
    2d50:	0f 93       	push	r16
    2d52:	1f 93       	push	r17
    2d54:	cf 93       	push	r28
    2d56:	df 93       	push	r29
    2d58:	0f b6       	in	r0, 0x3f	; 63
    2d5a:	f8 94       	cli
    2d5c:	0f 92       	push	r0
    2d5e:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2d62:	81 50       	subi	r24, 0x01	; 1
    2d64:	80 93 26 32 	sts	0x3226, r24	; 0x803226 <uxSchedulerSuspended>
    2d68:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2d6c:	81 11       	cpse	r24, r1
    2d6e:	60 c0       	rjmp	.+192    	; 0x2e30 <xTaskResumeAll+0xe8>
    2d70:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <uxCurrentNumberOfTasks>
    2d74:	81 11       	cpse	r24, r1
    2d76:	2c c0       	rjmp	.+88     	; 0x2dd0 <xTaskResumeAll+0x88>
    2d78:	5e c0       	rjmp	.+188    	; 0x2e36 <xTaskResumeAll+0xee>
    2d7a:	d7 01       	movw	r26, r14
    2d7c:	17 96       	adiw	r26, 0x07	; 7
    2d7e:	ed 91       	ld	r30, X+
    2d80:	fc 91       	ld	r31, X
    2d82:	18 97       	sbiw	r26, 0x08	; 8
    2d84:	c0 85       	ldd	r28, Z+8	; 0x08
    2d86:	d1 85       	ldd	r29, Z+9	; 0x09
    2d88:	ce 01       	movw	r24, r28
    2d8a:	0e 96       	adiw	r24, 0x0e	; 14
    2d8c:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
    2d90:	8e 01       	movw	r16, r28
    2d92:	0e 5f       	subi	r16, 0xFE	; 254
    2d94:	1f 4f       	sbci	r17, 0xFF	; 255
    2d96:	c8 01       	movw	r24, r16
    2d98:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
    2d9c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d9e:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    2da2:	98 17       	cp	r25, r24
    2da4:	10 f4       	brcc	.+4      	; 0x2daa <xTaskResumeAll+0x62>
    2da6:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    2daa:	d8 9e       	mul	r13, r24
    2dac:	c0 01       	movw	r24, r0
    2dae:	11 24       	eor	r1, r1
    2db0:	b8 01       	movw	r22, r16
    2db2:	8a 5a       	subi	r24, 0xAA	; 170
    2db4:	9d 4c       	sbci	r25, 0xCD	; 205
    2db6:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
    2dba:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    2dbe:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2dc2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2dc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dc6:	98 17       	cp	r25, r24
    2dc8:	70 f0       	brcs	.+28     	; 0x2de6 <xTaskResumeAll+0x9e>
    2dca:	cc 24       	eor	r12, r12
    2dcc:	c3 94       	inc	r12
    2dce:	0b c0       	rjmp	.+22     	; 0x2de6 <xTaskResumeAll+0x9e>
    2dd0:	c1 2c       	mov	r12, r1
    2dd2:	0f 2e       	mov	r0, r31
    2dd4:	f1 e3       	ldi	r31, 0x31	; 49
    2dd6:	ef 2e       	mov	r14, r31
    2dd8:	f2 e3       	ldi	r31, 0x32	; 50
    2dda:	ff 2e       	mov	r15, r31
    2ddc:	f0 2d       	mov	r31, r0
    2dde:	0f 2e       	mov	r0, r31
    2de0:	fb e0       	ldi	r31, 0x0B	; 11
    2de2:	df 2e       	mov	r13, r31
    2de4:	f0 2d       	mov	r31, r0
    2de6:	f7 01       	movw	r30, r14
    2de8:	80 81       	ld	r24, Z
    2dea:	81 11       	cpse	r24, r1
    2dec:	c6 cf       	rjmp	.-116    	; 0x2d7a <xTaskResumeAll+0x32>
    2dee:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <uxMissedTicks>
    2df2:	88 23       	and	r24, r24
    2df4:	81 f0       	breq	.+32     	; 0x2e16 <xTaskResumeAll+0xce>
    2df6:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <uxMissedTicks>
    2dfa:	88 23       	and	r24, r24
    2dfc:	99 f0       	breq	.+38     	; 0x2e24 <xTaskResumeAll+0xdc>
    2dfe:	0e 94 a3 15 	call	0x2b46	; 0x2b46 <vTaskIncrementTick>
    2e02:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <uxMissedTicks>
    2e06:	81 50       	subi	r24, 0x01	; 1
    2e08:	80 93 25 32 	sts	0x3225, r24	; 0x803225 <uxMissedTicks>
    2e0c:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <uxMissedTicks>
    2e10:	81 11       	cpse	r24, r1
    2e12:	f5 cf       	rjmp	.-22     	; 0x2dfe <xTaskResumeAll+0xb6>
    2e14:	07 c0       	rjmp	.+14     	; 0x2e24 <xTaskResumeAll+0xdc>
    2e16:	f1 e0       	ldi	r31, 0x01	; 1
    2e18:	cf 16       	cp	r12, r31
    2e1a:	21 f0       	breq	.+8      	; 0x2e24 <xTaskResumeAll+0xdc>
    2e1c:	80 91 24 32 	lds	r24, 0x3224	; 0x803224 <xMissedYield>
    2e20:	81 30       	cpi	r24, 0x01	; 1
    2e22:	41 f4       	brne	.+16     	; 0x2e34 <xTaskResumeAll+0xec>
    2e24:	10 92 24 32 	sts	0x3224, r1	; 0x803224 <xMissedYield>
    2e28:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
    2e2c:	81 e0       	ldi	r24, 0x01	; 1
    2e2e:	03 c0       	rjmp	.+6      	; 0x2e36 <xTaskResumeAll+0xee>
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	01 c0       	rjmp	.+2      	; 0x2e36 <xTaskResumeAll+0xee>
    2e34:	80 e0       	ldi	r24, 0x00	; 0
    2e36:	0f 90       	pop	r0
    2e38:	0f be       	out	0x3f, r0	; 63
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	1f 91       	pop	r17
    2e40:	0f 91       	pop	r16
    2e42:	ff 90       	pop	r15
    2e44:	ef 90       	pop	r14
    2e46:	df 90       	pop	r13
    2e48:	cf 90       	pop	r12
    2e4a:	08 95       	ret

00002e4c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2e4c:	cf 92       	push	r12
    2e4e:	df 92       	push	r13
    2e50:	ef 92       	push	r14
    2e52:	ff 92       	push	r15
    2e54:	6b 01       	movw	r12, r22
    2e56:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2e58:	67 2b       	or	r22, r23
    2e5a:	68 2b       	or	r22, r24
    2e5c:	69 2b       	or	r22, r25
    2e5e:	e9 f0       	breq	.+58     	; 0x2e9a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2e60:	0e 94 82 15 	call	0x2b04	; 0x2b04 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2e64:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    2e68:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    2e6c:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    2e70:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    2e74:	c8 0e       	add	r12, r24
    2e76:	d9 1e       	adc	r13, r25
    2e78:	ea 1e       	adc	r14, r26
    2e7a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e7c:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    2e80:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2e84:	02 96       	adiw	r24, 0x02	; 2
    2e86:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2e8a:	c7 01       	movw	r24, r14
    2e8c:	b6 01       	movw	r22, r12
    2e8e:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2e92:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2e96:	81 11       	cpse	r24, r1
    2e98:	02 c0       	rjmp	.+4      	; 0x2e9e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2e9a:	0e 94 45 10 	call	0x208a	; 0x208a <vPortYield>
		}
	}
    2e9e:	ff 90       	pop	r15
    2ea0:	ef 90       	pop	r14
    2ea2:	df 90       	pop	r13
    2ea4:	cf 90       	pop	r12
    2ea6:	08 95       	ret

00002ea8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2ea8:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2eac:	81 11       	cpse	r24, r1
    2eae:	0c c0       	rjmp	.+24     	; 0x2ec8 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2eb0:	e0 91 28 32 	lds	r30, 0x3228	; 0x803228 <uxTopReadyPriority>
    2eb4:	4b e0       	ldi	r20, 0x0B	; 11
    2eb6:	e4 9f       	mul	r30, r20
    2eb8:	f0 01       	movw	r30, r0
    2eba:	11 24       	eor	r1, r1
    2ebc:	ea 5a       	subi	r30, 0xAA	; 170
    2ebe:	fd 4c       	sbci	r31, 0xCD	; 205
    2ec0:	80 81       	ld	r24, Z
    2ec2:	88 23       	and	r24, r24
    2ec4:	29 f0       	breq	.+10     	; 0x2ed0 <vTaskSwitchContext+0x28>
    2ec6:	14 c0       	rjmp	.+40     	; 0x2ef0 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	80 93 24 32 	sts	0x3224, r24	; 0x803224 <xMissedYield>
    2ece:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2ed0:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2ed2:	80 91 28 32 	lds	r24, 0x3228	; 0x803228 <uxTopReadyPriority>
    2ed6:	81 50       	subi	r24, 0x01	; 1
    2ed8:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2edc:	e0 91 28 32 	lds	r30, 0x3228	; 0x803228 <uxTopReadyPriority>
    2ee0:	9e 9f       	mul	r25, r30
    2ee2:	f0 01       	movw	r30, r0
    2ee4:	11 24       	eor	r1, r1
    2ee6:	ea 5a       	subi	r30, 0xAA	; 170
    2ee8:	fd 4c       	sbci	r31, 0xCD	; 205
    2eea:	80 81       	ld	r24, Z
    2eec:	88 23       	and	r24, r24
    2eee:	89 f3       	breq	.-30     	; 0x2ed2 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2ef0:	80 91 28 32 	lds	r24, 0x3228	; 0x803228 <uxTopReadyPriority>
    2ef4:	28 2f       	mov	r18, r24
    2ef6:	30 e0       	ldi	r19, 0x00	; 0
    2ef8:	4b e0       	ldi	r20, 0x0B	; 11
    2efa:	84 9f       	mul	r24, r20
    2efc:	c0 01       	movw	r24, r0
    2efe:	11 24       	eor	r1, r1
    2f00:	dc 01       	movw	r26, r24
    2f02:	aa 5a       	subi	r26, 0xAA	; 170
    2f04:	bd 4c       	sbci	r27, 0xCD	; 205
    2f06:	11 96       	adiw	r26, 0x01	; 1
    2f08:	ed 91       	ld	r30, X+
    2f0a:	fc 91       	ld	r31, X
    2f0c:	12 97       	sbiw	r26, 0x02	; 2
    2f0e:	04 80       	ldd	r0, Z+4	; 0x04
    2f10:	f5 81       	ldd	r31, Z+5	; 0x05
    2f12:	e0 2d       	mov	r30, r0
    2f14:	11 96       	adiw	r26, 0x01	; 1
    2f16:	ed 93       	st	X+, r30
    2f18:	fc 93       	st	X, r31
    2f1a:	12 97       	sbiw	r26, 0x02	; 2
    2f1c:	87 5a       	subi	r24, 0xA7	; 167
    2f1e:	9d 4c       	sbci	r25, 0xCD	; 205
    2f20:	e8 17       	cp	r30, r24
    2f22:	f9 07       	cpc	r31, r25
    2f24:	61 f4       	brne	.+24     	; 0x2f3e <vTaskSwitchContext+0x96>
    2f26:	84 81       	ldd	r24, Z+4	; 0x04
    2f28:	95 81       	ldd	r25, Z+5	; 0x05
    2f2a:	4b e0       	ldi	r20, 0x0B	; 11
    2f2c:	42 9f       	mul	r20, r18
    2f2e:	f0 01       	movw	r30, r0
    2f30:	43 9f       	mul	r20, r19
    2f32:	f0 0d       	add	r31, r0
    2f34:	11 24       	eor	r1, r1
    2f36:	ea 5a       	subi	r30, 0xAA	; 170
    2f38:	fd 4c       	sbci	r31, 0xCD	; 205
    2f3a:	81 83       	std	Z+1, r24	; 0x01
    2f3c:	92 83       	std	Z+2, r25	; 0x02
    2f3e:	8b e0       	ldi	r24, 0x0B	; 11
    2f40:	82 9f       	mul	r24, r18
    2f42:	f0 01       	movw	r30, r0
    2f44:	83 9f       	mul	r24, r19
    2f46:	f0 0d       	add	r31, r0
    2f48:	11 24       	eor	r1, r1
    2f4a:	ea 5a       	subi	r30, 0xAA	; 170
    2f4c:	fd 4c       	sbci	r31, 0xCD	; 205
    2f4e:	01 80       	ldd	r0, Z+1	; 0x01
    2f50:	f2 81       	ldd	r31, Z+2	; 0x02
    2f52:	e0 2d       	mov	r30, r0
    2f54:	80 85       	ldd	r24, Z+8	; 0x08
    2f56:	91 85       	ldd	r25, Z+9	; 0x09
    2f58:	80 93 82 32 	sts	0x3282, r24	; 0x803282 <pxCurrentTCB>
    2f5c:	90 93 83 32 	sts	0x3283, r25	; 0x803283 <pxCurrentTCB+0x1>
    2f60:	08 95       	ret

00002f62 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2f62:	cf 92       	push	r12
    2f64:	df 92       	push	r13
    2f66:	ef 92       	push	r14
    2f68:	ff 92       	push	r15
    2f6a:	6a 01       	movw	r12, r20
    2f6c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2f6e:	60 91 82 32 	lds	r22, 0x3282	; 0x803282 <pxCurrentTCB>
    2f72:	70 91 83 32 	lds	r23, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2f76:	62 5f       	subi	r22, 0xF2	; 242
    2f78:	7f 4f       	sbci	r23, 0xFF	; 255
    2f7a:	0e 94 20 0f 	call	0x1e40	; 0x1e40 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2f7e:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    2f82:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    2f86:	02 96       	adiw	r24, 0x02	; 2
    2f88:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2f8c:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    2f90:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    2f94:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    2f98:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2f9c:	bc 01       	movw	r22, r24
    2f9e:	cd 01       	movw	r24, r26
    2fa0:	6c 0d       	add	r22, r12
    2fa2:	7d 1d       	adc	r23, r13
    2fa4:	8e 1d       	adc	r24, r14
    2fa6:	9f 1d       	adc	r25, r15
    2fa8:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2fac:	ff 90       	pop	r15
    2fae:	ef 90       	pop	r14
    2fb0:	df 90       	pop	r13
    2fb2:	cf 90       	pop	r12
    2fb4:	08 95       	ret

00002fb6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2fb6:	0f 93       	push	r16
    2fb8:	1f 93       	push	r17
    2fba:	cf 93       	push	r28
    2fbc:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2fbe:	dc 01       	movw	r26, r24
    2fc0:	17 96       	adiw	r26, 0x07	; 7
    2fc2:	ed 91       	ld	r30, X+
    2fc4:	fc 91       	ld	r31, X
    2fc6:	18 97       	sbiw	r26, 0x08	; 8
    2fc8:	c0 85       	ldd	r28, Z+8	; 0x08
    2fca:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2fcc:	8e 01       	movw	r16, r28
    2fce:	02 5f       	subi	r16, 0xF2	; 242
    2fd0:	1f 4f       	sbci	r17, 0xFF	; 255
    2fd2:	c8 01       	movw	r24, r16
    2fd4:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2fd8:	80 91 26 32 	lds	r24, 0x3226	; 0x803226 <uxSchedulerSuspended>
    2fdc:	81 11       	cpse	r24, r1
    2fde:	16 c0       	rjmp	.+44     	; 0x300c <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2fe0:	0c 50       	subi	r16, 0x0C	; 12
    2fe2:	11 09       	sbc	r17, r1
    2fe4:	c8 01       	movw	r24, r16
    2fe6:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2fea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2fec:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    2ff0:	98 17       	cp	r25, r24
    2ff2:	10 f4       	brcc	.+4      	; 0x2ff8 <xTaskRemoveFromEventList+0x42>
    2ff4:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    2ff8:	bb e0       	ldi	r27, 0x0B	; 11
    2ffa:	8b 9f       	mul	r24, r27
    2ffc:	c0 01       	movw	r24, r0
    2ffe:	11 24       	eor	r1, r1
    3000:	b8 01       	movw	r22, r16
    3002:	8a 5a       	subi	r24, 0xAA	; 170
    3004:	9d 4c       	sbci	r25, 0xCD	; 205
    3006:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
    300a:	05 c0       	rjmp	.+10     	; 0x3016 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    300c:	b8 01       	movw	r22, r16
    300e:	81 e3       	ldi	r24, 0x31	; 49
    3010:	92 e3       	ldi	r25, 0x32	; 50
    3012:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3016:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    301a:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    301e:	81 e0       	ldi	r24, 0x01	; 1
    3020:	2a 8d       	ldd	r18, Y+26	; 0x1a
    3022:	92 8d       	ldd	r25, Z+26	; 0x1a
    3024:	29 17       	cp	r18, r25
    3026:	08 f4       	brcc	.+2      	; 0x302a <xTaskRemoveFromEventList+0x74>
    3028:	80 e0       	ldi	r24, 0x00	; 0
}
    302a:	df 91       	pop	r29
    302c:	cf 91       	pop	r28
    302e:	1f 91       	pop	r17
    3030:	0f 91       	pop	r16
    3032:	08 95       	ret

00003034 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3034:	20 91 23 32 	lds	r18, 0x3223	; 0x803223 <xNumOfOverflows>
    3038:	fc 01       	movw	r30, r24
    303a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    303c:	40 91 2a 32 	lds	r20, 0x322A	; 0x80322a <xTickCount>
    3040:	50 91 2b 32 	lds	r21, 0x322B	; 0x80322b <xTickCount+0x1>
    3044:	60 91 2c 32 	lds	r22, 0x322C	; 0x80322c <xTickCount+0x2>
    3048:	70 91 2d 32 	lds	r23, 0x322D	; 0x80322d <xTickCount+0x3>
    304c:	41 83       	std	Z+1, r20	; 0x01
    304e:	52 83       	std	Z+2, r21	; 0x02
    3050:	63 83       	std	Z+3, r22	; 0x03
    3052:	74 83       	std	Z+4, r23	; 0x04
    3054:	08 95       	ret

00003056 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3056:	8f 92       	push	r8
    3058:	9f 92       	push	r9
    305a:	af 92       	push	r10
    305c:	bf 92       	push	r11
    305e:	cf 92       	push	r12
    3060:	df 92       	push	r13
    3062:	ef 92       	push	r14
    3064:	ff 92       	push	r15
    3066:	0f 93       	push	r16
    3068:	1f 93       	push	r17
    306a:	cf 93       	push	r28
    306c:	df 93       	push	r29
    306e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3070:	0f b6       	in	r0, 0x3f	; 63
    3072:	f8 94       	cli
    3074:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3076:	80 91 23 32 	lds	r24, 0x3223	; 0x803223 <xNumOfOverflows>
    307a:	90 81       	ld	r25, Z
    307c:	98 17       	cp	r25, r24
    307e:	89 f0       	breq	.+34     	; 0x30a2 <xTaskCheckForTimeOut+0x4c>
    3080:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    3084:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    3088:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    308c:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    3090:	01 81       	ldd	r16, Z+1	; 0x01
    3092:	12 81       	ldd	r17, Z+2	; 0x02
    3094:	23 81       	ldd	r18, Z+3	; 0x03
    3096:	34 81       	ldd	r19, Z+4	; 0x04
    3098:	80 17       	cp	r24, r16
    309a:	91 07       	cpc	r25, r17
    309c:	a2 07       	cpc	r26, r18
    309e:	b3 07       	cpc	r27, r19
    30a0:	a8 f5       	brcc	.+106    	; 0x310c <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    30a2:	80 91 2a 32 	lds	r24, 0x322A	; 0x80322a <xTickCount>
    30a6:	90 91 2b 32 	lds	r25, 0x322B	; 0x80322b <xTickCount+0x1>
    30aa:	a0 91 2c 32 	lds	r26, 0x322C	; 0x80322c <xTickCount+0x2>
    30ae:	b0 91 2d 32 	lds	r27, 0x322D	; 0x80322d <xTickCount+0x3>
    30b2:	c1 80       	ldd	r12, Z+1	; 0x01
    30b4:	d2 80       	ldd	r13, Z+2	; 0x02
    30b6:	e3 80       	ldd	r14, Z+3	; 0x03
    30b8:	f4 80       	ldd	r15, Z+4	; 0x04
    30ba:	eb 01       	movw	r28, r22
    30bc:	08 81       	ld	r16, Y
    30be:	19 81       	ldd	r17, Y+1	; 0x01
    30c0:	2a 81       	ldd	r18, Y+2	; 0x02
    30c2:	3b 81       	ldd	r19, Y+3	; 0x03
    30c4:	8c 19       	sub	r24, r12
    30c6:	9d 09       	sbc	r25, r13
    30c8:	ae 09       	sbc	r26, r14
    30ca:	bf 09       	sbc	r27, r15
    30cc:	80 17       	cp	r24, r16
    30ce:	91 07       	cpc	r25, r17
    30d0:	a2 07       	cpc	r26, r18
    30d2:	b3 07       	cpc	r27, r19
    30d4:	e8 f4       	brcc	.+58     	; 0x3110 <xTaskCheckForTimeOut+0xba>
    30d6:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    30d8:	80 90 2a 32 	lds	r8, 0x322A	; 0x80322a <xTickCount>
    30dc:	90 90 2b 32 	lds	r9, 0x322B	; 0x80322b <xTickCount+0x1>
    30e0:	a0 90 2c 32 	lds	r10, 0x322C	; 0x80322c <xTickCount+0x2>
    30e4:	b0 90 2d 32 	lds	r11, 0x322D	; 0x80322d <xTickCount+0x3>
    30e8:	b5 01       	movw	r22, r10
    30ea:	a4 01       	movw	r20, r8
    30ec:	4c 19       	sub	r20, r12
    30ee:	5d 09       	sbc	r21, r13
    30f0:	6e 09       	sbc	r22, r14
    30f2:	7f 09       	sbc	r23, r15
    30f4:	04 1b       	sub	r16, r20
    30f6:	15 0b       	sbc	r17, r21
    30f8:	26 0b       	sbc	r18, r22
    30fa:	37 0b       	sbc	r19, r23
    30fc:	08 83       	st	Y, r16
    30fe:	19 83       	std	Y+1, r17	; 0x01
    3100:	2a 83       	std	Y+2, r18	; 0x02
    3102:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    3104:	0e 94 1a 18 	call	0x3034	; 0x3034 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3108:	80 e0       	ldi	r24, 0x00	; 0
    310a:	03 c0       	rjmp	.+6      	; 0x3112 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    310c:	81 e0       	ldi	r24, 0x01	; 1
    310e:	01 c0       	rjmp	.+2      	; 0x3112 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    3110:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    3112:	0f 90       	pop	r0
    3114:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3116:	df 91       	pop	r29
    3118:	cf 91       	pop	r28
    311a:	1f 91       	pop	r17
    311c:	0f 91       	pop	r16
    311e:	ff 90       	pop	r15
    3120:	ef 90       	pop	r14
    3122:	df 90       	pop	r13
    3124:	cf 90       	pop	r12
    3126:	bf 90       	pop	r11
    3128:	af 90       	pop	r10
    312a:	9f 90       	pop	r9
    312c:	8f 90       	pop	r8
    312e:	08 95       	ret

00003130 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    3130:	81 e0       	ldi	r24, 0x01	; 1
    3132:	80 93 24 32 	sts	0x3224, r24	; 0x803224 <xMissedYield>
    3136:	08 95       	ret

00003138 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3138:	00 97       	sbiw	r24, 0x00	; 0
    313a:	21 f4       	brne	.+8      	; 0x3144 <uxTaskGetStackHighWaterMark+0xc>
    313c:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    3140:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    3144:	dc 01       	movw	r26, r24
    3146:	5b 96       	adiw	r26, 0x1b	; 27
    3148:	ed 91       	ld	r30, X+
    314a:	fc 91       	ld	r31, X
    314c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    314e:	80 81       	ld	r24, Z
    3150:	81 31       	cpi	r24, 0x11	; 17
    3152:	41 f4       	brne	.+16     	; 0x3164 <uxTaskGetStackHighWaterMark+0x2c>
    3154:	31 96       	adiw	r30, 0x01	; 1
    3156:	80 e0       	ldi	r24, 0x00	; 0
    3158:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    315a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    315c:	21 91       	ld	r18, Z+
    315e:	21 31       	cpi	r18, 0x11	; 17
    3160:	e1 f3       	breq	.-8      	; 0x315a <uxTaskGetStackHighWaterMark+0x22>
    3162:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    3164:	80 e0       	ldi	r24, 0x00	; 0
    3166:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3168:	08 95       	ret

0000316a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    316a:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <pxCurrentTCB>
    316e:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <pxCurrentTCB+0x1>

		return xReturn;
	}
    3172:	08 95       	ret

00003174 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    3174:	0f 93       	push	r16
    3176:	1f 93       	push	r17
    3178:	cf 93       	push	r28
    317a:	df 93       	push	r29
    317c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    317e:	22 8d       	ldd	r18, Z+26	; 0x1a
    3180:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    3184:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    3188:	5a 96       	adiw	r26, 0x1a	; 26
    318a:	8c 91       	ld	r24, X
    318c:	28 17       	cp	r18, r24
    318e:	08 f0       	brcs	.+2      	; 0x3192 <vTaskPriorityInherit+0x1e>
    3190:	41 c0       	rjmp	.+130    	; 0x3214 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    3192:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    3196:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    319a:	5a 96       	adiw	r26, 0x1a	; 26
    319c:	3c 91       	ld	r19, X
    319e:	84 e0       	ldi	r24, 0x04	; 4
    31a0:	90 e0       	ldi	r25, 0x00	; 0
    31a2:	a0 e0       	ldi	r26, 0x00	; 0
    31a4:	b0 e0       	ldi	r27, 0x00	; 0
    31a6:	83 1b       	sub	r24, r19
    31a8:	91 09       	sbc	r25, r1
    31aa:	a1 09       	sbc	r26, r1
    31ac:	b1 09       	sbc	r27, r1
    31ae:	86 87       	std	Z+14, r24	; 0x0e
    31b0:	97 87       	std	Z+15, r25	; 0x0f
    31b2:	a0 8b       	std	Z+16, r26	; 0x10
    31b4:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    31b6:	8b e0       	ldi	r24, 0x0B	; 11
    31b8:	28 9f       	mul	r18, r24
    31ba:	90 01       	movw	r18, r0
    31bc:	11 24       	eor	r1, r1
    31be:	2a 5a       	subi	r18, 0xAA	; 170
    31c0:	3d 4c       	sbci	r19, 0xCD	; 205
    31c2:	84 85       	ldd	r24, Z+12	; 0x0c
    31c4:	95 85       	ldd	r25, Z+13	; 0x0d
    31c6:	82 17       	cp	r24, r18
    31c8:	93 07       	cpc	r25, r19
    31ca:	e9 f4       	brne	.+58     	; 0x3206 <vTaskPriorityInherit+0x92>
    31cc:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    31ce:	ef 01       	movw	r28, r30
    31d0:	22 96       	adiw	r28, 0x02	; 2
    31d2:	ce 01       	movw	r24, r28
    31d4:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    31d8:	e0 91 82 32 	lds	r30, 0x3282	; 0x803282 <pxCurrentTCB>
    31dc:	f0 91 83 32 	lds	r31, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    31e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    31e2:	f8 01       	movw	r30, r16
    31e4:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    31e6:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    31ea:	98 17       	cp	r25, r24
    31ec:	10 f4       	brcc	.+4      	; 0x31f2 <vTaskPriorityInherit+0x7e>
    31ee:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    31f2:	fb e0       	ldi	r31, 0x0B	; 11
    31f4:	8f 9f       	mul	r24, r31
    31f6:	c0 01       	movw	r24, r0
    31f8:	11 24       	eor	r1, r1
    31fa:	be 01       	movw	r22, r28
    31fc:	8a 5a       	subi	r24, 0xAA	; 170
    31fe:	9d 4c       	sbci	r25, 0xCD	; 205
    3200:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
    3204:	07 c0       	rjmp	.+14     	; 0x3214 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3206:	a0 91 82 32 	lds	r26, 0x3282	; 0x803282 <pxCurrentTCB>
    320a:	b0 91 83 32 	lds	r27, 0x3283	; 0x803283 <pxCurrentTCB+0x1>
    320e:	5a 96       	adiw	r26, 0x1a	; 26
    3210:	8c 91       	ld	r24, X
    3212:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    3214:	df 91       	pop	r29
    3216:	cf 91       	pop	r28
    3218:	1f 91       	pop	r17
    321a:	0f 91       	pop	r16
    321c:	08 95       	ret

0000321e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    321e:	0f 93       	push	r16
    3220:	1f 93       	push	r17
    3222:	cf 93       	push	r28
    3224:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3226:	00 97       	sbiw	r24, 0x00	; 0
    3228:	49 f1       	breq	.+82     	; 0x327c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    322a:	fc 01       	movw	r30, r24
    322c:	32 8d       	ldd	r19, Z+26	; 0x1a
    322e:	27 a1       	ldd	r18, Z+39	; 0x27
    3230:	32 17       	cp	r19, r18
    3232:	21 f1       	breq	.+72     	; 0x327c <vTaskPriorityDisinherit+0x5e>
    3234:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3236:	8c 01       	movw	r16, r24
    3238:	0e 5f       	subi	r16, 0xFE	; 254
    323a:	1f 4f       	sbci	r17, 0xFF	; 255
    323c:	c8 01       	movw	r24, r16
    323e:	0e 94 6b 0f 	call	0x1ed6	; 0x1ed6 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    3242:	8f a1       	ldd	r24, Y+39	; 0x27
    3244:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    3246:	44 e0       	ldi	r20, 0x04	; 4
    3248:	50 e0       	ldi	r21, 0x00	; 0
    324a:	60 e0       	ldi	r22, 0x00	; 0
    324c:	70 e0       	ldi	r23, 0x00	; 0
    324e:	48 1b       	sub	r20, r24
    3250:	51 09       	sbc	r21, r1
    3252:	61 09       	sbc	r22, r1
    3254:	71 09       	sbc	r23, r1
    3256:	4e 87       	std	Y+14, r20	; 0x0e
    3258:	5f 87       	std	Y+15, r21	; 0x0f
    325a:	68 8b       	std	Y+16, r22	; 0x10
    325c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    325e:	90 91 28 32 	lds	r25, 0x3228	; 0x803228 <uxTopReadyPriority>
    3262:	98 17       	cp	r25, r24
    3264:	10 f4       	brcc	.+4      	; 0x326a <vTaskPriorityDisinherit+0x4c>
    3266:	80 93 28 32 	sts	0x3228, r24	; 0x803228 <uxTopReadyPriority>
    326a:	fb e0       	ldi	r31, 0x0B	; 11
    326c:	8f 9f       	mul	r24, r31
    326e:	c0 01       	movw	r24, r0
    3270:	11 24       	eor	r1, r1
    3272:	b8 01       	movw	r22, r16
    3274:	8a 5a       	subi	r24, 0xAA	; 170
    3276:	9d 4c       	sbci	r25, 0xCD	; 205
    3278:	0e 94 f9 0e 	call	0x1df2	; 0x1df2 <vListInsertEnd>
			}
		}
	}
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	1f 91       	pop	r17
    3282:	0f 91       	pop	r16
    3284:	08 95       	ret

00003286 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    3286:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    3288:	e8 81       	ld	r30, Y
    328a:	f9 81       	ldd	r31, Y+1	; 0x01
    328c:	01 90       	ld	r0, Z+
    328e:	f0 81       	ld	r31, Z
    3290:	e0 2d       	mov	r30, r0
    3292:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    3294:	1a 82       	std	Y+2, r1	; 0x02
    3296:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    3298:	6f ef       	ldi	r22, 0xFF	; 255
    329a:	7f ef       	ldi	r23, 0xFF	; 255
    329c:	cb 01       	movw	r24, r22
    329e:	0e 94 26 17 	call	0x2e4c	; 0x2e4c <vTaskDelay>
    32a2:	fa cf       	rjmp	.-12     	; 0x3298 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000032a4 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    32a4:	fc 01       	movw	r30, r24
    32a6:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    32a8:	65 87       	std	Z+13, r22	; 0x0d
    32aa:	08 95       	ret

000032ac <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    32ac:	4f 92       	push	r4
    32ae:	5f 92       	push	r5
    32b0:	6f 92       	push	r6
    32b2:	7f 92       	push	r7
    32b4:	8f 92       	push	r8
    32b6:	9f 92       	push	r9
    32b8:	af 92       	push	r10
    32ba:	bf 92       	push	r11
    32bc:	cf 92       	push	r12
    32be:	df 92       	push	r13
    32c0:	ef 92       	push	r14
    32c2:	ff 92       	push	r15
    32c4:	0f 93       	push	r16
    32c6:	1f 93       	push	r17
    32c8:	cf 93       	push	r28
    32ca:	df 93       	push	r29
    32cc:	cd b7       	in	r28, 0x3d	; 61
    32ce:	de b7       	in	r29, 0x3e	; 62
    32d0:	2a 97       	sbiw	r28, 0x0a	; 10
    32d2:	cd bf       	out	0x3d, r28	; 61
    32d4:	de bf       	out	0x3e, r29	; 62
    32d6:	4c 01       	movw	r8, r24
    32d8:	29 01       	movw	r4, r18
    32da:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    32dc:	80 e7       	ldi	r24, 0x70	; 112
    32de:	91 e2       	ldi	r25, 0x21	; 33
    32e0:	f4 01       	movw	r30, r8
    32e2:	80 83       	st	Z, r24
    32e4:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    32e6:	fb 01       	movw	r30, r22
    32e8:	80 81       	ld	r24, Z
    32ea:	88 23       	and	r24, r24
    32ec:	69 f0       	breq	.+26     	; 0x3308 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    32ee:	de 01       	movw	r26, r28
    32f0:	11 96       	adiw	r26, 0x01	; 1
    32f2:	31 96       	adiw	r30, 0x01	; 1
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	02 c0       	rjmp	.+4      	; 0x32fc <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    32f8:	99 30       	cpi	r25, 0x09	; 9
    32fa:	39 f0       	breq	.+14     	; 0x330a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    32fc:	9f 5f       	subi	r25, 0xFF	; 255
    32fe:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3300:	81 91       	ld	r24, Z+
    3302:	81 11       	cpse	r24, r1
    3304:	f9 cf       	rjmp	.-14     	; 0x32f8 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3306:	01 c0       	rjmp	.+2      	; 0x330a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3308:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    330a:	e1 e0       	ldi	r30, 0x01	; 1
    330c:	f0 e0       	ldi	r31, 0x00	; 0
    330e:	ec 0f       	add	r30, r28
    3310:	fd 1f       	adc	r31, r29
    3312:	e9 0f       	add	r30, r25
    3314:	f1 1d       	adc	r31, r1
    3316:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3318:	74 01       	movw	r14, r8
    331a:	f2 e0       	ldi	r31, 0x02	; 2
    331c:	ef 0e       	add	r14, r31
    331e:	f1 1c       	adc	r15, r1
    3320:	a1 2c       	mov	r10, r1
    3322:	b1 2c       	mov	r11, r1
    3324:	c1 2c       	mov	r12, r1
    3326:	d1 2c       	mov	r13, r1
    3328:	04 2f       	mov	r16, r20
    332a:	94 01       	movw	r18, r8
    332c:	a2 01       	movw	r20, r4
    332e:	be 01       	movw	r22, r28
    3330:	6f 5f       	subi	r22, 0xFF	; 255
    3332:	7f 4f       	sbci	r23, 0xFF	; 255
    3334:	84 e3       	ldi	r24, 0x34	; 52
    3336:	93 e0       	ldi	r25, 0x03	; 3
    3338:	0e 94 3f 14 	call	0x287e	; 0x287e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    333c:	f4 01       	movw	r30, r8
    333e:	66 82       	std	Z+6, r6	; 0x06
    3340:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3342:	40 86       	std	Z+8, r4	; 0x08
    3344:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3346:	20 91 84 32 	lds	r18, 0x3284	; 0x803284 <last_created_task_pointer>
    334a:	30 91 85 32 	lds	r19, 0x3285	; 0x803285 <last_created_task_pointer+0x1>
    334e:	24 83       	std	Z+4, r18	; 0x04
    3350:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3352:	80 92 84 32 	sts	0x3284, r8	; 0x803284 <last_created_task_pointer>
    3356:	90 92 85 32 	sts	0x3285, r9	; 0x803285 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    335a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    335c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    335e:	40 90 e6 32 	lds	r4, 0x32E6	; 0x8032e6 <portStackTopForTask>
    3362:	50 90 e7 32 	lds	r5, 0x32E7	; 0x8032e7 <portStackTopForTask+0x1>
    3366:	ff ef       	ldi	r31, 0xFF	; 255
    3368:	4f 1a       	sub	r4, r31
    336a:	5f 0a       	sbc	r5, r31
    336c:	40 92 e6 32 	sts	0x32E6, r4	; 0x8032e6 <portStackTopForTask>
    3370:	50 92 e7 32 	sts	0x32E7, r5	; 0x8032e7 <portStackTopForTask+0x1>
    3374:	f4 01       	movw	r30, r8
    3376:	42 86       	std	Z+10, r4	; 0x0a
    3378:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    337a:	16 86       	std	Z+14, r1	; 0x0e
    337c:	17 86       	std	Z+15, r1	; 0x0f
    337e:	10 8a       	std	Z+16, r1	; 0x10
    3380:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    3382:	61 14       	cp	r6, r1
    3384:	71 04       	cpc	r7, r1
    3386:	09 f4       	brne	.+2      	; 0x338a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3388:	44 c0       	rjmp	.+136    	; 0x3412 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    338a:	81 30       	cpi	r24, 0x01	; 1
    338c:	79 f5       	brne	.+94     	; 0x33ec <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    338e:	6a e0       	ldi	r22, 0x0A	; 10
    3390:	c3 01       	movw	r24, r6
    3392:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3396:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3398:	65 eb       	ldi	r22, 0xB5	; 181
    339a:	75 e0       	ldi	r23, 0x05	; 5
    339c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    33a0:	be 01       	movw	r22, r28
    33a2:	6f 5f       	subi	r22, 0xFF	; 255
    33a4:	7f 4f       	sbci	r23, 0xFF	; 255
    33a6:	c7 01       	movw	r24, r14
    33a8:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    33ac:	6a e0       	ldi	r22, 0x0A	; 10
    33ae:	c7 01       	movw	r24, r14
    33b0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33b4:	7c 01       	movw	r14, r24
    33b6:	6c ea       	ldi	r22, 0xAC	; 172
    33b8:	75 e0       	ldi	r23, 0x05	; 5
    33ba:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    33be:	6a e0       	ldi	r22, 0x0A	; 10
    33c0:	c7 01       	movw	r24, r14
    33c2:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33c6:	7c 01       	movw	r14, r24
    33c8:	6e e9       	ldi	r22, 0x9E	; 158
    33ca:	75 e0       	ldi	r23, 0x05	; 5
    33cc:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    33d0:	63 e0       	ldi	r22, 0x03	; 3
    33d2:	c7 01       	movw	r24, r14
    33d4:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33d8:	b2 01       	movw	r22, r4
    33da:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    33de:	62 e0       	ldi	r22, 0x02	; 2
    33e0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33e4:	66 e0       	ldi	r22, 0x06	; 6
    33e6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33ea:	13 c0       	rjmp	.+38     	; 0x3412 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    33ec:	6a e0       	ldi	r22, 0x0A	; 10
    33ee:	c3 01       	movw	r24, r6
    33f0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    33f4:	4c 01       	movw	r8, r24
    33f6:	69 e8       	ldi	r22, 0x89	; 137
    33f8:	75 e0       	ldi	r23, 0x05	; 5
    33fa:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    33fe:	be 01       	movw	r22, r28
    3400:	6f 5f       	subi	r22, 0xFF	; 255
    3402:	7f 4f       	sbci	r23, 0xFF	; 255
    3404:	c4 01       	movw	r24, r8
    3406:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    340a:	66 e0       	ldi	r22, 0x06	; 6
    340c:	c4 01       	movw	r24, r8
    340e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3412:	2a 96       	adiw	r28, 0x0a	; 10
    3414:	cd bf       	out	0x3d, r28	; 61
    3416:	de bf       	out	0x3e, r29	; 62
    3418:	df 91       	pop	r29
    341a:	cf 91       	pop	r28
    341c:	1f 91       	pop	r17
    341e:	0f 91       	pop	r16
    3420:	ff 90       	pop	r15
    3422:	ef 90       	pop	r14
    3424:	df 90       	pop	r13
    3426:	cf 90       	pop	r12
    3428:	bf 90       	pop	r11
    342a:	af 90       	pop	r10
    342c:	9f 90       	pop	r9
    342e:	8f 90       	pop	r8
    3430:	7f 90       	pop	r7
    3432:	6f 90       	pop	r6
    3434:	5f 90       	pop	r5
    3436:	4f 90       	pop	r4
    3438:	08 95       	ret

0000343a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    343a:	cf 92       	push	r12
    343c:	df 92       	push	r13
    343e:	ef 92       	push	r14
    3440:	ff 92       	push	r15
    3442:	0f 93       	push	r16
    3444:	1f 93       	push	r17
    3446:	cf 93       	push	r28
    3448:	df 93       	push	r29
    344a:	ec 01       	movw	r28, r24
    344c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    344e:	8a 81       	ldd	r24, Y+2	; 0x02
    3450:	9b 81       	ldd	r25, Y+3	; 0x03
    3452:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <pcTaskGetTaskName>
    3456:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3458:	6a e0       	ldi	r22, 0x0A	; 10
    345a:	c7 01       	movw	r24, r14
    345c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3460:	8c 01       	movw	r16, r24
    3462:	68 ec       	ldi	r22, 0xC8	; 200
    3464:	75 e0       	ldi	r23, 0x05	; 5
    3466:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    346a:	6a e0       	ldi	r22, 0x0A	; 10
    346c:	c8 01       	movw	r24, r16
    346e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3472:	8c 01       	movw	r16, r24
    3474:	61 ec       	ldi	r22, 0xC1	; 193
    3476:	75 e0       	ldi	r23, 0x05	; 5
    3478:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    347c:	b6 01       	movw	r22, r12
    347e:	c8 01       	movw	r24, r16
    3480:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3484:	6a e0       	ldi	r22, 0x0A	; 10
    3486:	c8 01       	movw	r24, r16
    3488:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    348c:	8c 01       	movw	r16, r24
    348e:	6b eb       	ldi	r22, 0xBB	; 187
    3490:	75 e0       	ldi	r23, 0x05	; 5
    3492:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3496:	66 e0       	ldi	r22, 0x06	; 6
    3498:	c8 01       	movw	r24, r16
    349a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    349e:	8a 85       	ldd	r24, Y+10	; 0x0a
    34a0:	9b 85       	ldd	r25, Y+11	; 0x0b
    34a2:	e8 85       	ldd	r30, Y+8	; 0x08
    34a4:	f9 85       	ldd	r31, Y+9	; 0x09
    34a6:	01 e1       	ldi	r16, 0x11	; 17
    34a8:	21 e0       	ldi	r18, 0x01	; 1
    34aa:	a7 01       	movw	r20, r14
    34ac:	bc 01       	movw	r22, r24
    34ae:	8e 1b       	sub	r24, r30
    34b0:	9f 0b       	sbc	r25, r31
    34b2:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    34b6:	8c 81       	ldd	r24, Y+4	; 0x04
    34b8:	9d 81       	ldd	r25, Y+5	; 0x05
    34ba:	00 97       	sbiw	r24, 0x00	; 0
    34bc:	19 f0       	breq	.+6      	; 0x34c4 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    34be:	b7 01       	movw	r22, r14
    34c0:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    34c4:	df 91       	pop	r29
    34c6:	cf 91       	pop	r28
    34c8:	1f 91       	pop	r17
    34ca:	0f 91       	pop	r16
    34cc:	ff 90       	pop	r15
    34ce:	ef 90       	pop	r14
    34d0:	df 90       	pop	r13
    34d2:	cf 90       	pop	r12
    34d4:	08 95       	ret

000034d6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    34d6:	0f 93       	push	r16
    34d8:	1f 93       	push	r17
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    34e0:	80 91 84 32 	lds	r24, 0x3284	; 0x803284 <last_created_task_pointer>
    34e4:	90 91 85 32 	lds	r25, 0x3285	; 0x803285 <last_created_task_pointer+0x1>
    34e8:	00 97       	sbiw	r24, 0x00	; 0
    34ea:	19 f0       	breq	.+6      	; 0x34f2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    34ec:	be 01       	movw	r22, r28
    34ee:	0e 94 1d 1a 	call	0x343a	; 0x343a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    34f2:	6a e0       	ldi	r22, 0x0A	; 10
    34f4:	ce 01       	movw	r24, r28
    34f6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    34fa:	8c 01       	movw	r16, r24
    34fc:	6e ed       	ldi	r22, 0xDE	; 222
    34fe:	75 e0       	ldi	r23, 0x05	; 5
    3500:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3504:	6a e0       	ldi	r22, 0x0A	; 10
    3506:	c8 01       	movw	r24, r16
    3508:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    350c:	8c 01       	movw	r16, r24
    350e:	63 ed       	ldi	r22, 0xD3	; 211
    3510:	75 e0       	ldi	r23, 0x05	; 5
    3512:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3516:	6a e0       	ldi	r22, 0x0A	; 10
    3518:	c8 01       	movw	r24, r16
    351a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    351e:	8c 01       	movw	r16, r24
    3520:	6d ec       	ldi	r22, 0xCD	; 205
    3522:	75 e0       	ldi	r23, 0x05	; 5
    3524:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3528:	66 e0       	ldi	r22, 0x06	; 6
    352a:	c8 01       	movw	r24, r16
    352c:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3530:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <portStackTopForTask>
    3534:	90 91 e7 32 	lds	r25, 0x32E7	; 0x8032e7 <portStackTopForTask+0x1>
    3538:	bc 01       	movw	r22, r24
    353a:	6f 5f       	subi	r22, 0xFF	; 255
    353c:	7f 4f       	sbci	r23, 0xFF	; 255
    353e:	01 e1       	ldi	r16, 0x11	; 17
    3540:	21 e0       	ldi	r18, 0x01	; 1
    3542:	ae 01       	movw	r20, r28
    3544:	83 56       	subi	r24, 0x63	; 99
    3546:	91 09       	sbc	r25, r1
    3548:	0e 94 1f 1d 	call	0x3a3e	; 0x3a3e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    354c:	df 91       	pop	r29
    354e:	cf 91       	pop	r28
    3550:	1f 91       	pop	r17
    3552:	0f 91       	pop	r16
    3554:	08 95       	ret

00003556 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3556:	8f 92       	push	r8
    3558:	9f 92       	push	r9
    355a:	af 92       	push	r10
    355c:	bf 92       	push	r11
    355e:	cf 92       	push	r12
    3560:	df 92       	push	r13
    3562:	ef 92       	push	r14
    3564:	ff 92       	push	r15
    3566:	0f 93       	push	r16
    3568:	1f 93       	push	r17
    356a:	cf 93       	push	r28
    356c:	df 93       	push	r29
    356e:	ec 01       	movw	r28, r24
    3570:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3572:	8a 81       	ldd	r24, Y+2	; 0x02
    3574:	9b 81       	ldd	r25, Y+3	; 0x03
    3576:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <pcTaskGetTaskName>
    357a:	bc 01       	movw	r22, r24
    357c:	c8 01       	movw	r24, r16
    357e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    3582:	d8 01       	movw	r26, r16
    3584:	ed 91       	ld	r30, X+
    3586:	fc 91       	ld	r31, X
    3588:	02 80       	ldd	r0, Z+2	; 0x02
    358a:	f3 81       	ldd	r31, Z+3	; 0x03
    358c:	e0 2d       	mov	r30, r0
    358e:	69 e0       	ldi	r22, 0x09	; 9
    3590:	c8 01       	movw	r24, r16
    3592:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3594:	8a 81       	ldd	r24, Y+2	; 0x02
    3596:	9b 81       	ldd	r25, Y+3	; 0x03
    3598:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <pcTaskGetTaskName>
    359c:	fc 01       	movw	r30, r24
    359e:	01 90       	ld	r0, Z+
    35a0:	00 20       	and	r0, r0
    35a2:	e9 f7       	brne	.-6      	; 0x359e <_ZN8frt_task12print_statusER8emstream+0x48>
    35a4:	31 97       	sbiw	r30, 0x01	; 1
    35a6:	e8 1b       	sub	r30, r24
    35a8:	f9 0b       	sbc	r31, r25
    35aa:	38 97       	sbiw	r30, 0x08	; 8
    35ac:	48 f4       	brcc	.+18     	; 0x35c0 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    35ae:	d8 01       	movw	r26, r16
    35b0:	ed 91       	ld	r30, X+
    35b2:	fc 91       	ld	r31, X
    35b4:	02 80       	ldd	r0, Z+2	; 0x02
    35b6:	f3 81       	ldd	r31, Z+3	; 0x03
    35b8:	e0 2d       	mov	r30, r0
    35ba:	69 e0       	ldi	r22, 0x09	; 9
    35bc:	c8 01       	movw	r24, r16
    35be:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    35c0:	ce 84       	ldd	r12, Y+14	; 0x0e
    35c2:	df 84       	ldd	r13, Y+15	; 0x0f
    35c4:	e8 88       	ldd	r14, Y+16	; 0x10
    35c6:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    35c8:	a8 84       	ldd	r10, Y+8	; 0x08
    35ca:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    35cc:	8a 81       	ldd	r24, Y+2	; 0x02
    35ce:	9b 81       	ldd	r25, Y+3	; 0x03
    35d0:	0e 94 9c 18 	call	0x3138	; 0x3138 <uxTaskGetStackHighWaterMark>
    35d4:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    35d6:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    35d8:	8a 81       	ldd	r24, Y+2	; 0x02
    35da:	9b 81       	ldd	r25, Y+3	; 0x03
    35dc:	0e 94 41 15 	call	0x2a82	; 0x2a82 <uxTaskPriorityGet>
    35e0:	68 2f       	mov	r22, r24
    35e2:	c8 01       	movw	r24, r16
    35e4:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    35e8:	6a e0       	ldi	r22, 0x0A	; 10
    35ea:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    35ee:	ec 01       	movw	r28, r24
    35f0:	63 e5       	ldi	r22, 0x53	; 83
    35f2:	76 e0       	ldi	r23, 0x06	; 6
    35f4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
			<< get_state ()
    35f8:	68 2d       	mov	r22, r8
    35fa:	ce 01       	movw	r24, r28
    35fc:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3600:	6a e0       	ldi	r22, 0x0A	; 10
    3602:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3606:	ec 01       	movw	r28, r24
    3608:	61 e5       	ldi	r22, 0x51	; 81
    360a:	76 e0       	ldi	r23, 0x06	; 6
    360c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3610:	69 2d       	mov	r22, r9
    3612:	ce 01       	movw	r24, r28
    3614:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3618:	6a e0       	ldi	r22, 0x0A	; 10
    361a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    361e:	ec 01       	movw	r28, r24
    3620:	6f e4       	ldi	r22, 0x4F	; 79
    3622:	76 e0       	ldi	r23, 0x06	; 6
    3624:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3628:	b5 01       	movw	r22, r10
    362a:	ce 01       	movw	r24, r28
    362c:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    3630:	6a e0       	ldi	r22, 0x0A	; 10
    3632:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3636:	ec 01       	movw	r28, r24
    3638:	6d e4       	ldi	r22, 0x4D	; 77
    363a:	76 e0       	ldi	r23, 0x06	; 6
    363c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    3640:	6a e0       	ldi	r22, 0x0A	; 10
    3642:	ce 01       	movw	r24, r28
    3644:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3648:	ec 01       	movw	r28, r24
    364a:	6b e4       	ldi	r22, 0x4B	; 75
    364c:	76 e0       	ldi	r23, 0x06	; 6
    364e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3652:	b7 01       	movw	r22, r14
    3654:	a6 01       	movw	r20, r12
    3656:	ce 01       	movw	r24, r28
    3658:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEm>
}
    365c:	df 91       	pop	r29
    365e:	cf 91       	pop	r28
    3660:	1f 91       	pop	r17
    3662:	0f 91       	pop	r16
    3664:	ff 90       	pop	r15
    3666:	ef 90       	pop	r14
    3668:	df 90       	pop	r13
    366a:	cf 90       	pop	r12
    366c:	bf 90       	pop	r11
    366e:	af 90       	pop	r10
    3670:	9f 90       	pop	r9
    3672:	8f 90       	pop	r8
    3674:	08 95       	ret

00003676 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3676:	cf 93       	push	r28
    3678:	df 93       	push	r29
    367a:	ec 01       	movw	r28, r24
    367c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    367e:	db 01       	movw	r26, r22
    3680:	ed 91       	ld	r30, X+
    3682:	fc 91       	ld	r31, X
    3684:	02 80       	ldd	r0, Z+2	; 0x02
    3686:	f3 81       	ldd	r31, Z+3	; 0x03
    3688:	e0 2d       	mov	r30, r0
    368a:	be 01       	movw	r22, r28
    368c:	19 95       	eicall
	return (ser_dev);
}
    368e:	ce 01       	movw	r24, r28
    3690:	df 91       	pop	r29
    3692:	cf 91       	pop	r28
    3694:	08 95       	ret

00003696 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3696:	0f 93       	push	r16
    3698:	1f 93       	push	r17
    369a:	cf 93       	push	r28
    369c:	df 93       	push	r29
    369e:	ec 01       	movw	r28, r24
    36a0:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    36a2:	bc 01       	movw	r22, r24
    36a4:	c8 01       	movw	r24, r16
    36a6:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_ZlsR8emstreamR8frt_task>
    36aa:	66 e0       	ldi	r22, 0x06	; 6
    36ac:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    36b0:	8c 81       	ldd	r24, Y+4	; 0x04
    36b2:	9d 81       	ldd	r25, Y+5	; 0x05
    36b4:	00 97       	sbiw	r24, 0x00	; 0
    36b6:	19 f0       	breq	.+6      	; 0x36be <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    36b8:	b8 01       	movw	r22, r16
    36ba:	0e 94 4b 1b 	call	0x3696	; 0x3696 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    36be:	df 91       	pop	r29
    36c0:	cf 91       	pop	r28
    36c2:	1f 91       	pop	r17
    36c4:	0f 91       	pop	r16
    36c6:	08 95       	ret

000036c8 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    36c8:	0f 93       	push	r16
    36ca:	1f 93       	push	r17
    36cc:	cf 93       	push	r28
    36ce:	df 93       	push	r29
    36d0:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    36d2:	6a e0       	ldi	r22, 0x0A	; 10
    36d4:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    36d8:	8c 01       	movw	r16, r24
    36da:	60 e4       	ldi	r22, 0x40	; 64
    36dc:	76 e0       	ldi	r23, 0x06	; 6
    36de:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    36e2:	6a e0       	ldi	r22, 0x0A	; 10
    36e4:	c8 01       	movw	r24, r16
    36e6:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    36ea:	8c 01       	movw	r16, r24
    36ec:	69 e3       	ldi	r22, 0x39	; 57
    36ee:	76 e0       	ldi	r23, 0x06	; 6
    36f0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    36f4:	66 e0       	ldi	r22, 0x06	; 6
    36f6:	c8 01       	movw	r24, r16
    36f8:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    36fc:	6a e0       	ldi	r22, 0x0A	; 10
    36fe:	ce 01       	movw	r24, r28
    3700:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3704:	8c 01       	movw	r16, r24
    3706:	68 e2       	ldi	r22, 0x28	; 40
    3708:	76 e0       	ldi	r23, 0x06	; 6
    370a:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    370e:	6a e0       	ldi	r22, 0x0A	; 10
    3710:	c8 01       	movw	r24, r16
    3712:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3716:	8c 01       	movw	r16, r24
    3718:	6c e1       	ldi	r22, 0x1C	; 28
    371a:	76 e0       	ldi	r23, 0x06	; 6
    371c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3720:	6a e0       	ldi	r22, 0x0A	; 10
    3722:	c8 01       	movw	r24, r16
    3724:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3728:	8c 01       	movw	r16, r24
    372a:	66 e1       	ldi	r22, 0x16	; 22
    372c:	76 e0       	ldi	r23, 0x06	; 6
    372e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3732:	66 e0       	ldi	r22, 0x06	; 6
    3734:	c8 01       	movw	r24, r16
    3736:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    373a:	6a e0       	ldi	r22, 0x0A	; 10
    373c:	ce 01       	movw	r24, r28
    373e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3742:	8c 01       	movw	r16, r24
    3744:	65 e0       	ldi	r22, 0x05	; 5
    3746:	76 e0       	ldi	r23, 0x06	; 6
    3748:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    374c:	6a e0       	ldi	r22, 0x0A	; 10
    374e:	c8 01       	movw	r24, r16
    3750:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3754:	8c 01       	movw	r16, r24
    3756:	69 ef       	ldi	r22, 0xF9	; 249
    3758:	75 e0       	ldi	r23, 0x05	; 5
    375a:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    375e:	6a e0       	ldi	r22, 0x0A	; 10
    3760:	c8 01       	movw	r24, r16
    3762:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3766:	8c 01       	movw	r16, r24
    3768:	63 ef       	ldi	r22, 0xF3	; 243
    376a:	75 e0       	ldi	r23, 0x05	; 5
    376c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3770:	66 e0       	ldi	r22, 0x06	; 6
    3772:	c8 01       	movw	r24, r16
    3774:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3778:	80 91 84 32 	lds	r24, 0x3284	; 0x803284 <last_created_task_pointer>
    377c:	90 91 85 32 	lds	r25, 0x3285	; 0x803285 <last_created_task_pointer+0x1>
    3780:	00 97       	sbiw	r24, 0x00	; 0
    3782:	19 f0       	breq	.+6      	; 0x378a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3784:	be 01       	movw	r22, r28
    3786:	0e 94 4b 1b 	call	0x3696	; 0x3696 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    378a:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <xTaskGetIdleTaskHandle>
    378e:	0e 94 9c 18 	call	0x3138	; 0x3138 <uxTaskGetStackHighWaterMark>
    3792:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3794:	6a e0       	ldi	r22, 0x0A	; 10
    3796:	ce 01       	movw	r24, r28
    3798:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    379c:	ec 01       	movw	r28, r24
    379e:	68 ee       	ldi	r22, 0xE8	; 232
    37a0:	75 e0       	ldi	r23, 0x05	; 5
    37a2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    37a6:	61 2f       	mov	r22, r17
    37a8:	ce 01       	movw	r24, r28
    37aa:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    37ae:	6a e0       	ldi	r22, 0x0A	; 10
    37b0:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    37b4:	ec 01       	movw	r28, r24
    37b6:	66 ee       	ldi	r22, 0xE6	; 230
    37b8:	75 e0       	ldi	r23, 0x05	; 5
    37ba:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    37be:	64 e6       	ldi	r22, 0x64	; 100
    37c0:	70 e0       	ldi	r23, 0x00	; 0
    37c2:	ce 01       	movw	r24, r28
    37c4:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    37c8:	6a e0       	ldi	r22, 0x0A	; 10
    37ca:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    37ce:	ec 01       	movw	r28, r24
    37d0:	63 ee       	ldi	r22, 0xE3	; 227
    37d2:	75 e0       	ldi	r23, 0x05	; 5
    37d4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    37d8:	66 e0       	ldi	r22, 0x06	; 6
    37da:	ce 01       	movw	r24, r28
    37dc:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
}
    37e0:	df 91       	pop	r29
    37e2:	cf 91       	pop	r28
    37e4:	1f 91       	pop	r17
    37e6:	0f 91       	pop	r16
    37e8:	08 95       	ret

000037ea <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    37ea:	0f 93       	push	r16
    37ec:	cf 93       	push	r28
    37ee:	df 93       	push	r29
    37f0:	1f 92       	push	r1
    37f2:	cd b7       	in	r28, 0x3d	; 61
    37f4:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    37f6:	00 e0       	ldi	r16, 0x00	; 0
    37f8:	2f ef       	ldi	r18, 0xFF	; 255
    37fa:	3f ef       	ldi	r19, 0xFF	; 255
    37fc:	a9 01       	movw	r20, r18
    37fe:	be 01       	movw	r22, r28
    3800:	6f 5f       	subi	r22, 0xFF	; 255
    3802:	7f 4f       	sbci	r23, 0xFF	; 255
    3804:	fc 01       	movw	r30, r24
    3806:	80 85       	ldd	r24, Z+8	; 0x08
    3808:	91 85       	ldd	r25, Z+9	; 0x09
    380a:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
    380e:	81 30       	cpi	r24, 0x01	; 1
    3810:	19 f4       	brne	.+6      	; 0x3818 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3812:	89 81       	ldd	r24, Y+1	; 0x01
    3814:	90 e0       	ldi	r25, 0x00	; 0
    3816:	02 c0       	rjmp	.+4      	; 0x381c <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3818:	8f ef       	ldi	r24, 0xFF	; 255
    381a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    381c:	0f 90       	pop	r0
    381e:	df 91       	pop	r29
    3820:	cf 91       	pop	r28
    3822:	0f 91       	pop	r16
    3824:	08 95       	ret

00003826 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3826:	fc 01       	movw	r30, r24
    3828:	80 85       	ldd	r24, Z+8	; 0x08
    382a:	91 85       	ldd	r25, Z+9	; 0x09
    382c:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    3830:	91 e0       	ldi	r25, 0x01	; 1
    3832:	81 11       	cpse	r24, r1
    3834:	01 c0       	rjmp	.+2      	; 0x3838 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3836:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3838:	89 2f       	mov	r24, r25
    383a:	08 95       	ret

0000383c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    383c:	0f 93       	push	r16
    383e:	cf 93       	push	r28
    3840:	df 93       	push	r29
    3842:	1f 92       	push	r1
    3844:	cd b7       	in	r28, 0x3d	; 61
    3846:	de b7       	in	r29, 0x3e	; 62
    3848:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    384a:	fc 01       	movw	r30, r24
    384c:	22 85       	ldd	r18, Z+10	; 0x0a
    384e:	33 85       	ldd	r19, Z+11	; 0x0b
    3850:	44 85       	ldd	r20, Z+12	; 0x0c
    3852:	55 85       	ldd	r21, Z+13	; 0x0d
    3854:	00 e0       	ldi	r16, 0x00	; 0
    3856:	be 01       	movw	r22, r28
    3858:	6f 5f       	subi	r22, 0xFF	; 255
    385a:	7f 4f       	sbci	r23, 0xFF	; 255
    385c:	80 85       	ldd	r24, Z+8	; 0x08
    385e:	91 85       	ldd	r25, Z+9	; 0x09
    3860:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    3864:	91 e0       	ldi	r25, 0x01	; 1
    3866:	81 11       	cpse	r24, r1
    3868:	01 c0       	rjmp	.+2      	; 0x386c <_ZN14frt_text_queue7putcharEc+0x30>
    386a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    386c:	89 2f       	mov	r24, r25
    386e:	0f 90       	pop	r0
    3870:	df 91       	pop	r29
    3872:	cf 91       	pop	r28
    3874:	0f 91       	pop	r16
    3876:	08 95       	ret

00003878 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3878:	8f 92       	push	r8
    387a:	9f 92       	push	r9
    387c:	bf 92       	push	r11
    387e:	cf 92       	push	r12
    3880:	df 92       	push	r13
    3882:	ef 92       	push	r14
    3884:	ff 92       	push	r15
    3886:	0f 93       	push	r16
    3888:	1f 93       	push	r17
    388a:	cf 93       	push	r28
    388c:	df 93       	push	r29
    388e:	ec 01       	movw	r28, r24
    3890:	b6 2e       	mov	r11, r22
    3892:	4a 01       	movw	r8, r20
    3894:	68 01       	movw	r12, r16
    3896:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3898:	0e 94 76 1e 	call	0x3cec	; 0x3cec <_ZN8emstreamC1Ev>
    389c:	88 e7       	ldi	r24, 0x78	; 120
    389e:	91 e2       	ldi	r25, 0x21	; 33
    38a0:	88 83       	st	Y, r24
    38a2:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    38a4:	8e 86       	std	Y+14, r8	; 0x0e
    38a6:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    38a8:	40 e0       	ldi	r20, 0x00	; 0
    38aa:	61 e0       	ldi	r22, 0x01	; 1
    38ac:	8b 2d       	mov	r24, r11
    38ae:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    38b2:	88 87       	std	Y+8, r24	; 0x08
    38b4:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    38b6:	ca 86       	std	Y+10, r12	; 0x0a
    38b8:	db 86       	std	Y+11, r13	; 0x0b
    38ba:	ec 86       	std	Y+12, r14	; 0x0c
    38bc:	fd 86       	std	Y+13, r15	; 0x0d
}
    38be:	df 91       	pop	r29
    38c0:	cf 91       	pop	r28
    38c2:	1f 91       	pop	r17
    38c4:	0f 91       	pop	r16
    38c6:	ff 90       	pop	r15
    38c8:	ef 90       	pop	r14
    38ca:	df 90       	pop	r13
    38cc:	cf 90       	pop	r12
    38ce:	bf 90       	pop	r11
    38d0:	9f 90       	pop	r9
    38d2:	8f 90       	pop	r8
    38d4:	08 95       	ret

000038d6 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    38d6:	cf 92       	push	r12
    38d8:	df 92       	push	r13
    38da:	ef 92       	push	r14
    38dc:	ff 92       	push	r15
    38de:	cf 93       	push	r28
    38e0:	df 93       	push	r29
    38e2:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    38e4:	68 81       	ld	r22, Y
    38e6:	79 81       	ldd	r23, Y+1	; 0x01
    38e8:	8a 81       	ldd	r24, Y+2	; 0x02
    38ea:	9b 81       	ldd	r25, Y+3	; 0x03
    38ec:	0f 2e       	mov	r0, r31
    38ee:	f8 ee       	ldi	r31, 0xE8	; 232
    38f0:	cf 2e       	mov	r12, r31
    38f2:	f3 e0       	ldi	r31, 0x03	; 3
    38f4:	df 2e       	mov	r13, r31
    38f6:	e1 2c       	mov	r14, r1
    38f8:	f1 2c       	mov	r15, r1
    38fa:	f0 2d       	mov	r31, r0
    38fc:	a7 01       	movw	r20, r14
    38fe:	96 01       	movw	r18, r12
    3900:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
    3904:	9b 01       	movw	r18, r22
    3906:	ac 01       	movw	r20, r24
    3908:	60 e4       	ldi	r22, 0x40	; 64
    390a:	72 e4       	ldi	r23, 0x42	; 66
    390c:	8f e0       	ldi	r24, 0x0F	; 15
    390e:	90 e0       	ldi	r25, 0x00	; 0
    3910:	0e 94 d1 25 	call	0x4ba2	; 0x4ba2 <__mulsi3>
    3914:	a7 01       	movw	r20, r14
    3916:	96 01       	movw	r18, r12
    3918:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
    391c:	69 01       	movw	r12, r18
    391e:	7a 01       	movw	r14, r20
    3920:	ac 81       	ldd	r26, Y+4	; 0x04
    3922:	bd 81       	ldd	r27, Y+5	; 0x05
    3924:	20 e4       	ldi	r18, 0x40	; 64
    3926:	32 e4       	ldi	r19, 0x42	; 66
    3928:	4f e0       	ldi	r20, 0x0F	; 15
    392a:	50 e0       	ldi	r21, 0x00	; 0
    392c:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <__muluhisi3>
    3930:	20 e0       	ldi	r18, 0x00	; 0
    3932:	38 e4       	ldi	r19, 0x48	; 72
    3934:	48 ee       	ldi	r20, 0xE8	; 232
    3936:	51 e0       	ldi	r21, 0x01	; 1
    3938:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
    393c:	c7 01       	movw	r24, r14
    393e:	b6 01       	movw	r22, r12
    3940:	62 0f       	add	r22, r18
    3942:	73 1f       	adc	r23, r19
    3944:	84 1f       	adc	r24, r20
    3946:	95 1f       	adc	r25, r21
}
    3948:	df 91       	pop	r29
    394a:	cf 91       	pop	r28
    394c:	ff 90       	pop	r15
    394e:	ef 90       	pop	r14
    3950:	df 90       	pop	r13
    3952:	cf 90       	pop	r12
    3954:	08 95       	ret

00003956 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3956:	cf 92       	push	r12
    3958:	df 92       	push	r13
    395a:	ef 92       	push	r14
    395c:	ff 92       	push	r15
    395e:	0f 93       	push	r16
    3960:	1f 93       	push	r17
    3962:	cf 93       	push	r28
    3964:	df 93       	push	r29
    3966:	cd b7       	in	r28, 0x3d	; 61
    3968:	de b7       	in	r29, 0x3e	; 62
    396a:	2f 97       	sbiw	r28, 0x0f	; 15
    396c:	cd bf       	out	0x3d, r28	; 61
    396e:	de bf       	out	0x3e, r29	; 62
    3970:	6c 01       	movw	r12, r24
    3972:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3974:	db 01       	movw	r26, r22
    3976:	6d 91       	ld	r22, X+
    3978:	7d 91       	ld	r23, X+
    397a:	8d 91       	ld	r24, X+
    397c:	9c 91       	ld	r25, X
    397e:	28 ee       	ldi	r18, 0xE8	; 232
    3980:	33 e0       	ldi	r19, 0x03	; 3
    3982:	40 e0       	ldi	r20, 0x00	; 0
    3984:	50 e0       	ldi	r21, 0x00	; 0
    3986:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
    398a:	ba 01       	movw	r22, r20
    398c:	a9 01       	movw	r20, r18
    398e:	c6 01       	movw	r24, r12
    3990:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3994:	d6 01       	movw	r26, r12
    3996:	ed 91       	ld	r30, X+
    3998:	fc 91       	ld	r31, X
    399a:	02 80       	ldd	r0, Z+2	; 0x02
    399c:	f3 81       	ldd	r31, Z+3	; 0x03
    399e:	e0 2d       	mov	r30, r0
    39a0:	6e e2       	ldi	r22, 0x2E	; 46
    39a2:	c6 01       	movw	r24, r12
    39a4:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    39a6:	c8 01       	movw	r24, r16
    39a8:	0e 94 6b 1c 	call	0x38d6	; 0x38d6 <_ZN10time_stamp12get_microsecEv>
    39ac:	8e 01       	movw	r16, r28
    39ae:	09 5f       	subi	r16, 0xF9	; 249
    39b0:	1f 4f       	sbci	r17, 0xFF	; 255
    39b2:	fe 01       	movw	r30, r28
    39b4:	31 96       	adiw	r30, 0x01	; 1
    39b6:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    39b8:	2a e0       	ldi	r18, 0x0A	; 10
    39ba:	30 e0       	ldi	r19, 0x00	; 0
    39bc:	40 e0       	ldi	r20, 0x00	; 0
    39be:	50 e0       	ldi	r21, 0x00	; 0
    39c0:	0e 94 03 26 	call	0x4c06	; 0x4c06 <__divmodsi4>
    39c4:	e6 2f       	mov	r30, r22
    39c6:	28 87       	std	Y+8, r18	; 0x08
    39c8:	39 87       	std	Y+9, r19	; 0x09
    39ca:	4a 87       	std	Y+10, r20	; 0x0a
    39cc:	5b 87       	std	Y+11, r21	; 0x0b
    39ce:	68 85       	ldd	r22, Y+8	; 0x08
    39d0:	79 85       	ldd	r23, Y+9	; 0x09
    39d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    39d4:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    39d6:	20 e3       	ldi	r18, 0x30	; 48
    39d8:	2e 0f       	add	r18, r30
    39da:	d8 01       	movw	r26, r16
    39dc:	2e 93       	st	-X, r18
    39de:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    39e0:	ae 15       	cp	r26, r14
    39e2:	bf 05       	cpc	r27, r15
    39e4:	49 f7       	brne	.-46     	; 0x39b8 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    39e6:	1f 82       	std	Y+7, r1	; 0x07
    39e8:	be 01       	movw	r22, r28
    39ea:	6f 5f       	subi	r22, 0xFF	; 255
    39ec:	7f 4f       	sbci	r23, 0xFF	; 255
    39ee:	c6 01       	movw	r24, r12
    39f0:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    39f4:	c6 01       	movw	r24, r12
    39f6:	2f 96       	adiw	r28, 0x0f	; 15
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	df 91       	pop	r29
    39fe:	cf 91       	pop	r28
    3a00:	1f 91       	pop	r17
    3a02:	0f 91       	pop	r16
    3a04:	ff 90       	pop	r15
    3a06:	ef 90       	pop	r14
    3a08:	df 90       	pop	r13
    3a0a:	cf 90       	pop	r12
    3a0c:	08 95       	ret

00003a0e <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3a0e:	cf 93       	push	r28
    3a10:	df 93       	push	r29
    3a12:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	f8 94       	cli
    3a18:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3a1a:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3a1e:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3a22:	8c 83       	std	Y+4, r24	; 0x04
    3a24:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3a26:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskGetTickCount>
    3a2a:	68 83       	st	Y, r22
    3a2c:	79 83       	std	Y+1, r23	; 0x01
    3a2e:	8a 83       	std	Y+2, r24	; 0x02
    3a30:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3a32:	0f 90       	pop	r0
    3a34:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3a36:	ce 01       	movw	r24, r28
    3a38:	df 91       	pop	r29
    3a3a:	cf 91       	pop	r28
    3a3c:	08 95       	ret

00003a3e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3a3e:	5f 92       	push	r5
    3a40:	6f 92       	push	r6
    3a42:	7f 92       	push	r7
    3a44:	8f 92       	push	r8
    3a46:	9f 92       	push	r9
    3a48:	af 92       	push	r10
    3a4a:	bf 92       	push	r11
    3a4c:	cf 92       	push	r12
    3a4e:	df 92       	push	r13
    3a50:	ef 92       	push	r14
    3a52:	ff 92       	push	r15
    3a54:	0f 93       	push	r16
    3a56:	1f 93       	push	r17
    3a58:	cf 93       	push	r28
    3a5a:	df 93       	push	r29
    3a5c:	5c 01       	movw	r10, r24
    3a5e:	4b 01       	movw	r8, r22
    3a60:	7a 01       	movw	r14, r20
    3a62:	12 2f       	mov	r17, r18
    3a64:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3a66:	63 e0       	ldi	r22, 0x03	; 3
    3a68:	ca 01       	movw	r24, r20
    3a6a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3a6e:	a8 14       	cp	r10, r8
    3a70:	b9 04       	cpc	r11, r9
    3a72:	08 f0       	brcs	.+2      	; 0x3a76 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3a74:	7d c0       	rjmp	.+250    	; 0x3b70 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3a76:	65 01       	movw	r12, r10
    3a78:	84 e1       	ldi	r24, 0x14	; 20
    3a7a:	c8 0e       	add	r12, r24
    3a7c:	d1 1c       	adc	r13, r1
    3a7e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3a80:	6a 2c       	mov	r6, r10
    3a82:	5b 2c       	mov	r5, r11
    3a84:	b5 01       	movw	r22, r10
    3a86:	c7 01       	movw	r24, r14
    3a88:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <_ZN8emstreamlsEj>
    3a8c:	6a e0       	ldi	r22, 0x0A	; 10
    3a8e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3a92:	65 e6       	ldi	r22, 0x65	; 101
    3a94:	76 e0       	ldi	r23, 0x06	; 6
    3a96:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3a9a:	11 23       	and	r17, r17
    3a9c:	09 f4       	brne	.+2      	; 0x3aa0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3a9e:	6d c0       	rjmp	.+218    	; 0x3b7a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3aa0:	00 23       	and	r16, r16
    3aa2:	09 f4       	brne	.+2      	; 0x3aa6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3aa4:	6a c0       	rjmp	.+212    	; 0x3b7a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3aa6:	6a e0       	ldi	r22, 0x0A	; 10
    3aa8:	c7 01       	movw	r24, r14
    3aaa:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3aae:	60 e6       	ldi	r22, 0x60	; 96
    3ab0:	76 e0       	ldi	r23, 0x06	; 6
    3ab2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    3ab6:	61 c0       	rjmp	.+194    	; 0x3b7a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3ab8:	11 23       	and	r17, r17
    3aba:	71 f0       	breq	.+28     	; 0x3ad8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3abc:	01 11       	cpse	r16, r1
    3abe:	0c c0       	rjmp	.+24     	; 0x3ad8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3ac0:	88 81       	ld	r24, Y
    3ac2:	87 15       	cp	r24, r7
    3ac4:	49 f0       	breq	.+18     	; 0x3ad8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3ac6:	6a e0       	ldi	r22, 0x0A	; 10
    3ac8:	c7 01       	movw	r24, r14
    3aca:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3ace:	6b e5       	ldi	r22, 0x5B	; 91
    3ad0:	76 e0       	ldi	r23, 0x06	; 6
    3ad2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3ad6:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3ad8:	69 91       	ld	r22, Y+
    3ada:	c7 01       	movw	r24, r14
    3adc:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3ae0:	dc 01       	movw	r26, r24
    3ae2:	ed 91       	ld	r30, X+
    3ae4:	fc 91       	ld	r31, X
    3ae6:	02 80       	ldd	r0, Z+2	; 0x02
    3ae8:	f3 81       	ldd	r31, Z+3	; 0x03
    3aea:	e0 2d       	mov	r30, r0
    3aec:	60 e2       	ldi	r22, 0x20	; 32
    3aee:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3af0:	cc 16       	cp	r12, r28
    3af2:	dd 06       	cpc	r13, r29
    3af4:	09 f7       	brne	.-62     	; 0x3ab8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3af6:	11 23       	and	r17, r17
    3af8:	89 f0       	breq	.+34     	; 0x3b1c <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3afa:	6a e0       	ldi	r22, 0x0A	; 10
    3afc:	c7 01       	movw	r24, r14
    3afe:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3b02:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3b04:	65 e5       	ldi	r22, 0x55	; 85
    3b06:	76 e0       	ldi	r23, 0x06	; 6
    3b08:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3b0c:	e8 81       	ld	r30, Y
    3b0e:	f9 81       	ldd	r31, Y+1	; 0x01
    3b10:	02 80       	ldd	r0, Z+2	; 0x02
    3b12:	f3 81       	ldd	r31, Z+3	; 0x03
    3b14:	e0 2d       	mov	r30, r0
    3b16:	60 e2       	ldi	r22, 0x20	; 32
    3b18:	ce 01       	movw	r24, r28
    3b1a:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3b1c:	c6 2d       	mov	r28, r6
    3b1e:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3b20:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3b22:	80 ee       	ldi	r24, 0xE0	; 224
    3b24:	86 0f       	add	r24, r22
    3b26:	8f 35       	cpi	r24, 0x5F	; 95
    3b28:	48 f4       	brcc	.+18     	; 0x3b3c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3b2a:	d7 01       	movw	r26, r14
    3b2c:	ed 91       	ld	r30, X+
    3b2e:	fc 91       	ld	r31, X
    3b30:	02 80       	ldd	r0, Z+2	; 0x02
    3b32:	f3 81       	ldd	r31, Z+3	; 0x03
    3b34:	e0 2d       	mov	r30, r0
    3b36:	c7 01       	movw	r24, r14
    3b38:	19 95       	eicall
    3b3a:	09 c0       	rjmp	.+18     	; 0x3b4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3b3c:	d7 01       	movw	r26, r14
    3b3e:	ed 91       	ld	r30, X+
    3b40:	fc 91       	ld	r31, X
    3b42:	02 80       	ldd	r0, Z+2	; 0x02
    3b44:	f3 81       	ldd	r31, Z+3	; 0x03
    3b46:	e0 2d       	mov	r30, r0
    3b48:	6e e2       	ldi	r22, 0x2E	; 46
    3b4a:	c7 01       	movw	r24, r14
    3b4c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3b4e:	cc 16       	cp	r12, r28
    3b50:	dd 06       	cpc	r13, r29
    3b52:	31 f7       	brne	.-52     	; 0x3b20 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3b54:	b4 e1       	ldi	r27, 0x14	; 20
    3b56:	ab 0e       	add	r10, r27
    3b58:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3b5a:	66 e0       	ldi	r22, 0x06	; 6
    3b5c:	c7 01       	movw	r24, r14
    3b5e:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    3b62:	84 e1       	ldi	r24, 0x14	; 20
    3b64:	c8 0e       	add	r12, r24
    3b66:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3b68:	a8 14       	cp	r10, r8
    3b6a:	b9 04       	cpc	r11, r9
    3b6c:	08 f4       	brcc	.+2      	; 0x3b70 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3b6e:	88 cf       	rjmp	.-240    	; 0x3a80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3b70:	62 e0       	ldi	r22, 0x02	; 2
    3b72:	c7 01       	movw	r24, r14
    3b74:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
}
    3b78:	03 c0       	rjmp	.+6      	; 0x3b80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3b7a:	c6 2d       	mov	r28, r6
    3b7c:	d5 2d       	mov	r29, r5
    3b7e:	9c cf       	rjmp	.-200    	; 0x3ab8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3b80:	df 91       	pop	r29
    3b82:	cf 91       	pop	r28
    3b84:	1f 91       	pop	r17
    3b86:	0f 91       	pop	r16
    3b88:	ff 90       	pop	r15
    3b8a:	ef 90       	pop	r14
    3b8c:	df 90       	pop	r13
    3b8e:	cf 90       	pop	r12
    3b90:	bf 90       	pop	r11
    3b92:	af 90       	pop	r10
    3b94:	9f 90       	pop	r9
    3b96:	8f 90       	pop	r8
    3b98:	7f 90       	pop	r7
    3b9a:	6f 90       	pop	r6
    3b9c:	5f 90       	pop	r5
    3b9e:	08 95       	ret

00003ba0 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3ba0:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    3ba4:	08 95       	ret

00003ba6 <_Znaj>:
    3ba6:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <pvPortMalloc>
    3baa:	08 95       	ret

00003bac <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3bac:	08 95       	ret

00003bae <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3bae:	cf 93       	push	r28
    3bb0:	df 93       	push	r29
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3bb6:	40 3a       	cpi	r20, 0xA0	; 160
    3bb8:	68 e0       	ldi	r22, 0x08	; 8
    3bba:	56 07       	cpc	r21, r22
    3bbc:	49 f4       	brne	.+18     	; 0x3bd0 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3bbe:	80 e4       	ldi	r24, 0x40	; 64
    3bc0:	96 e0       	ldi	r25, 0x06	; 6
    3bc2:	82 83       	std	Z+2, r24	; 0x02
    3bc4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3bc6:	82 e0       	ldi	r24, 0x02	; 2
    3bc8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3bca:	83 e0       	ldi	r24, 0x03	; 3
    3bcc:	85 83       	std	Z+5, r24	; 0x05
    3bce:	32 c0       	rjmp	.+100    	; 0x3c34 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3bd0:	40 3b       	cpi	r20, 0xB0	; 176
    3bd2:	78 e0       	ldi	r23, 0x08	; 8
    3bd4:	57 07       	cpc	r21, r23
    3bd6:	49 f4       	brne	.+18     	; 0x3bea <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3bd8:	80 e4       	ldi	r24, 0x40	; 64
    3bda:	96 e0       	ldi	r25, 0x06	; 6
    3bdc:	82 83       	std	Z+2, r24	; 0x02
    3bde:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3be0:	86 e0       	ldi	r24, 0x06	; 6
    3be2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3be4:	87 e0       	ldi	r24, 0x07	; 7
    3be6:	85 83       	std	Z+5, r24	; 0x05
    3be8:	25 c0       	rjmp	.+74     	; 0x3c34 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3bea:	40 3a       	cpi	r20, 0xA0	; 160
    3bec:	89 e0       	ldi	r24, 0x09	; 9
    3bee:	58 07       	cpc	r21, r24
    3bf0:	49 f4       	brne	.+18     	; 0x3c04 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3bf2:	80 e6       	ldi	r24, 0x60	; 96
    3bf4:	96 e0       	ldi	r25, 0x06	; 6
    3bf6:	82 83       	std	Z+2, r24	; 0x02
    3bf8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3bfa:	82 e0       	ldi	r24, 0x02	; 2
    3bfc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3bfe:	83 e0       	ldi	r24, 0x03	; 3
    3c00:	85 83       	std	Z+5, r24	; 0x05
    3c02:	18 c0       	rjmp	.+48     	; 0x3c34 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3c04:	40 3b       	cpi	r20, 0xB0	; 176
    3c06:	69 e0       	ldi	r22, 0x09	; 9
    3c08:	56 07       	cpc	r21, r22
    3c0a:	49 f4       	brne	.+18     	; 0x3c1e <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3c0c:	80 e6       	ldi	r24, 0x60	; 96
    3c0e:	96 e0       	ldi	r25, 0x06	; 6
    3c10:	82 83       	std	Z+2, r24	; 0x02
    3c12:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3c14:	86 e0       	ldi	r24, 0x06	; 6
    3c16:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3c18:	87 e0       	ldi	r24, 0x07	; 7
    3c1a:	85 83       	std	Z+5, r24	; 0x05
    3c1c:	0b c0       	rjmp	.+22     	; 0x3c34 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3c1e:	40 3a       	cpi	r20, 0xA0	; 160
    3c20:	5a 40       	sbci	r21, 0x0A	; 10
    3c22:	41 f4       	brne	.+16     	; 0x3c34 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3c24:	80 e8       	ldi	r24, 0x80	; 128
    3c26:	96 e0       	ldi	r25, 0x06	; 6
    3c28:	82 83       	std	Z+2, r24	; 0x02
    3c2a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3c2c:	82 e0       	ldi	r24, 0x02	; 2
    3c2e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3c30:	83 e0       	ldi	r24, 0x03	; 3
    3c32:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3c34:	a6 83       	std	Z+6, r26	; 0x06
    3c36:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3c38:	cd 01       	movw	r24, r26
    3c3a:	01 96       	adiw	r24, 0x01	; 1
    3c3c:	80 87       	std	Z+8, r24	; 0x08
    3c3e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3c40:	03 96       	adiw	r24, 0x03	; 3
    3c42:	82 87       	std	Z+10, r24	; 0x0a
    3c44:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3c46:	25 81       	ldd	r18, Z+5	; 0x05
    3c48:	c2 81       	ldd	r28, Z+2	; 0x02
    3c4a:	d3 81       	ldd	r29, Z+3	; 0x03
    3c4c:	4c 81       	ldd	r20, Y+4	; 0x04
    3c4e:	81 e0       	ldi	r24, 0x01	; 1
    3c50:	90 e0       	ldi	r25, 0x00	; 0
    3c52:	bc 01       	movw	r22, r24
    3c54:	02 c0       	rjmp	.+4      	; 0x3c5a <_ZN7base232C1EjP12USART_struct+0xac>
    3c56:	66 0f       	add	r22, r22
    3c58:	77 1f       	adc	r23, r23
    3c5a:	2a 95       	dec	r18
    3c5c:	e2 f7       	brpl	.-8      	; 0x3c56 <_ZN7base232C1EjP12USART_struct+0xa8>
    3c5e:	9b 01       	movw	r18, r22
    3c60:	24 2b       	or	r18, r20
    3c62:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3c64:	25 81       	ldd	r18, Z+5	; 0x05
    3c66:	c2 81       	ldd	r28, Z+2	; 0x02
    3c68:	d3 81       	ldd	r29, Z+3	; 0x03
    3c6a:	48 81       	ld	r20, Y
    3c6c:	bc 01       	movw	r22, r24
    3c6e:	02 c0       	rjmp	.+4      	; 0x3c74 <_ZN7base232C1EjP12USART_struct+0xc6>
    3c70:	66 0f       	add	r22, r22
    3c72:	77 1f       	adc	r23, r23
    3c74:	2a 95       	dec	r18
    3c76:	e2 f7       	brpl	.-8      	; 0x3c70 <_ZN7base232C1EjP12USART_struct+0xc2>
    3c78:	9b 01       	movw	r18, r22
    3c7a:	24 2b       	or	r18, r20
    3c7c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3c7e:	34 81       	ldd	r19, Z+4	; 0x04
    3c80:	c2 81       	ldd	r28, Z+2	; 0x02
    3c82:	d3 81       	ldd	r29, Z+3	; 0x03
    3c84:	28 81       	ld	r18, Y
    3c86:	02 c0       	rjmp	.+4      	; 0x3c8c <_ZN7base232C1EjP12USART_struct+0xde>
    3c88:	88 0f       	add	r24, r24
    3c8a:	99 1f       	adc	r25, r25
    3c8c:	3a 95       	dec	r19
    3c8e:	e2 f7       	brpl	.-8      	; 0x3c88 <_ZN7base232C1EjP12USART_struct+0xda>
    3c90:	80 95       	com	r24
    3c92:	90 95       	com	r25
    3c94:	82 23       	and	r24, r18
    3c96:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3c98:	80 e1       	ldi	r24, 0x10	; 16
    3c9a:	13 96       	adiw	r26, 0x03	; 3
    3c9c:	8c 93       	st	X, r24
    3c9e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3ca0:	83 e0       	ldi	r24, 0x03	; 3
    3ca2:	15 96       	adiw	r26, 0x05	; 5
    3ca4:	8c 93       	st	X, r24
    3ca6:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3ca8:	80 ef       	ldi	r24, 0xF0	; 240
    3caa:	17 96       	adiw	r26, 0x07	; 7
    3cac:	8c 93       	st	X, r24
    3cae:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3cb0:	81 e2       	ldi	r24, 0x21	; 33
    3cb2:	16 96       	adiw	r26, 0x06	; 6
    3cb4:	8c 93       	st	X, r24
    3cb6:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3cb8:	88 e1       	ldi	r24, 0x18	; 24
    3cba:	14 96       	adiw	r26, 0x04	; 4
    3cbc:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3cbe:	80 e8       	ldi	r24, 0x80	; 128
    3cc0:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3cc2:	80 e4       	ldi	r24, 0x40	; 64
    3cc4:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3cc6:	80 e2       	ldi	r24, 0x20	; 32
    3cc8:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3cca:	06 80       	ldd	r0, Z+6	; 0x06
    3ccc:	f7 81       	ldd	r31, Z+7	; 0x07
    3cce:	e0 2d       	mov	r30, r0
    3cd0:	80 81       	ld	r24, Z
    3cd2:	80 81       	ld	r24, Z
}
    3cd4:	df 91       	pop	r29
    3cd6:	cf 91       	pop	r28
    3cd8:	08 95       	ret

00003cda <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3cda:	81 e0       	ldi	r24, 0x01	; 1
    3cdc:	08 95       	ret

00003cde <_ZN8emstream7getcharEv>:
    3cde:	80 e0       	ldi	r24, 0x00	; 0
    3ce0:	90 e0       	ldi	r25, 0x00	; 0
    3ce2:	08 95       	ret

00003ce4 <_ZN8emstream14check_for_charEv>:
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
    3ce6:	08 95       	ret

00003ce8 <_ZN8emstream12transmit_nowEv>:
    3ce8:	08 95       	ret

00003cea <_ZN8emstream12clear_screenEv>:
    3cea:	08 95       	ret

00003cec <_ZN8emstreamC1Ev>:
    3cec:	fc 01       	movw	r30, r24
    3cee:	88 e8       	ldi	r24, 0x88	; 136
    3cf0:	91 e2       	ldi	r25, 0x21	; 33
    3cf2:	80 83       	st	Z, r24
    3cf4:	91 83       	std	Z+1, r25	; 0x01
    3cf6:	8a e0       	ldi	r24, 0x0A	; 10
    3cf8:	82 83       	std	Z+2, r24	; 0x02
    3cfa:	13 82       	std	Z+3, r1	; 0x03
    3cfc:	83 e0       	ldi	r24, 0x03	; 3
    3cfe:	85 83       	std	Z+5, r24	; 0x05
    3d00:	14 82       	std	Z+4, r1	; 0x04
    3d02:	16 82       	std	Z+6, r1	; 0x06
    3d04:	17 82       	std	Z+7, r1	; 0x07
    3d06:	08 95       	ret

00003d08 <_ZN8emstream4putsEPKc>:
    3d08:	0f 93       	push	r16
    3d0a:	1f 93       	push	r17
    3d0c:	cf 93       	push	r28
    3d0e:	df 93       	push	r29
    3d10:	8c 01       	movw	r16, r24
    3d12:	fb 01       	movw	r30, r22
    3d14:	dc 01       	movw	r26, r24
    3d16:	14 96       	adiw	r26, 0x04	; 4
    3d18:	8c 91       	ld	r24, X
    3d1a:	81 11       	cpse	r24, r1
    3d1c:	04 c0       	rjmp	.+8      	; 0x3d26 <_ZN8emstream4putsEPKc+0x1e>
    3d1e:	60 81       	ld	r22, Z
    3d20:	61 11       	cpse	r22, r1
    3d22:	17 c0       	rjmp	.+46     	; 0x3d52 <_ZN8emstream4putsEPKc+0x4a>
    3d24:	23 c0       	rjmp	.+70     	; 0x3d6c <_ZN8emstream4putsEPKc+0x64>
    3d26:	d8 01       	movw	r26, r16
    3d28:	14 96       	adiw	r26, 0x04	; 4
    3d2a:	1c 92       	st	X, r1
    3d2c:	eb 01       	movw	r28, r22
    3d2e:	21 96       	adiw	r28, 0x01	; 1
    3d30:	64 91       	lpm	r22, Z
    3d32:	66 23       	and	r22, r22
    3d34:	d9 f0       	breq	.+54     	; 0x3d6c <_ZN8emstream4putsEPKc+0x64>
    3d36:	d8 01       	movw	r26, r16
    3d38:	ed 91       	ld	r30, X+
    3d3a:	fc 91       	ld	r31, X
    3d3c:	02 80       	ldd	r0, Z+2	; 0x02
    3d3e:	f3 81       	ldd	r31, Z+3	; 0x03
    3d40:	e0 2d       	mov	r30, r0
    3d42:	c8 01       	movw	r24, r16
    3d44:	19 95       	eicall
    3d46:	fe 01       	movw	r30, r28
    3d48:	64 91       	lpm	r22, Z
    3d4a:	21 96       	adiw	r28, 0x01	; 1
    3d4c:	61 11       	cpse	r22, r1
    3d4e:	f3 cf       	rjmp	.-26     	; 0x3d36 <_ZN8emstream4putsEPKc+0x2e>
    3d50:	0d c0       	rjmp	.+26     	; 0x3d6c <_ZN8emstream4putsEPKc+0x64>
    3d52:	ef 01       	movw	r28, r30
    3d54:	21 96       	adiw	r28, 0x01	; 1
    3d56:	d8 01       	movw	r26, r16
    3d58:	ed 91       	ld	r30, X+
    3d5a:	fc 91       	ld	r31, X
    3d5c:	02 80       	ldd	r0, Z+2	; 0x02
    3d5e:	f3 81       	ldd	r31, Z+3	; 0x03
    3d60:	e0 2d       	mov	r30, r0
    3d62:	c8 01       	movw	r24, r16
    3d64:	19 95       	eicall
    3d66:	69 91       	ld	r22, Y+
    3d68:	61 11       	cpse	r22, r1
    3d6a:	f5 cf       	rjmp	.-22     	; 0x3d56 <_ZN8emstream4putsEPKc+0x4e>
    3d6c:	df 91       	pop	r29
    3d6e:	cf 91       	pop	r28
    3d70:	1f 91       	pop	r17
    3d72:	0f 91       	pop	r16
    3d74:	08 95       	ret

00003d76 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3d76:	cf 93       	push	r28
    3d78:	df 93       	push	r29
    3d7a:	ec 01       	movw	r28, r24
	switch (new_manip)
    3d7c:	86 2f       	mov	r24, r22
    3d7e:	90 e0       	ldi	r25, 0x00	; 0
    3d80:	8b 30       	cpi	r24, 0x0B	; 11
    3d82:	91 05       	cpc	r25, r1
    3d84:	d8 f5       	brcc	.+118    	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
    3d86:	fc 01       	movw	r30, r24
    3d88:	88 27       	eor	r24, r24
    3d8a:	e2 50       	subi	r30, 0x02	; 2
    3d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    3d8e:	8f 4f       	sbci	r24, 0xFF	; 255
    3d90:	0c 94 22 26 	jmp	0x4c44	; 0x4c44 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3d94:	82 e0       	ldi	r24, 0x02	; 2
    3d96:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3d98:	31 c0       	rjmp	.+98     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3d9a:	88 e0       	ldi	r24, 0x08	; 8
    3d9c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3d9e:	2e c0       	rjmp	.+92     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3da0:	8a e0       	ldi	r24, 0x0A	; 10
    3da2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3da4:	2b c0       	rjmp	.+86     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3da6:	80 e1       	ldi	r24, 0x10	; 16
    3da8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3daa:	28 c0       	rjmp	.+80     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3dac:	81 e0       	ldi	r24, 0x01	; 1
    3dae:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3db0:	25 c0       	rjmp	.+74     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3db2:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3db4:	23 c0       	rjmp	.+70     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3db6:	e8 81       	ld	r30, Y
    3db8:	f9 81       	ldd	r31, Y+1	; 0x01
    3dba:	02 80       	ldd	r0, Z+2	; 0x02
    3dbc:	f3 81       	ldd	r31, Z+3	; 0x03
    3dbe:	e0 2d       	mov	r30, r0
    3dc0:	6d e0       	ldi	r22, 0x0D	; 13
    3dc2:	ce 01       	movw	r24, r28
    3dc4:	19 95       	eicall
    3dc6:	e8 81       	ld	r30, Y
    3dc8:	f9 81       	ldd	r31, Y+1	; 0x01
    3dca:	02 80       	ldd	r0, Z+2	; 0x02
    3dcc:	f3 81       	ldd	r31, Z+3	; 0x03
    3dce:	e0 2d       	mov	r30, r0
    3dd0:	6a e0       	ldi	r22, 0x0A	; 10
    3dd2:	ce 01       	movw	r24, r28
    3dd4:	19 95       	eicall
			break;
    3dd6:	12 c0       	rjmp	.+36     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3dd8:	e8 81       	ld	r30, Y
    3dda:	f9 81       	ldd	r31, Y+1	; 0x01
    3ddc:	02 84       	ldd	r0, Z+10	; 0x0a
    3dde:	f3 85       	ldd	r31, Z+11	; 0x0b
    3de0:	e0 2d       	mov	r30, r0
    3de2:	ce 01       	movw	r24, r28
    3de4:	19 95       	eicall
			break;
    3de6:	0a c0       	rjmp	.+20     	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3de8:	e8 81       	ld	r30, Y
    3dea:	f9 81       	ldd	r31, Y+1	; 0x01
    3dec:	00 84       	ldd	r0, Z+8	; 0x08
    3dee:	f1 85       	ldd	r31, Z+9	; 0x09
    3df0:	e0 2d       	mov	r30, r0
    3df2:	ce 01       	movw	r24, r28
    3df4:	19 95       	eicall
			break;
    3df6:	02 c0       	rjmp	.+4      	; 0x3dfc <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3df8:	81 e0       	ldi	r24, 0x01	; 1
    3dfa:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3dfc:	ce 01       	movw	r24, r28
    3dfe:	df 91       	pop	r29
    3e00:	cf 91       	pop	r28
    3e02:	08 95       	ret

00003e04 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3e04:	ff 92       	push	r15
    3e06:	0f 93       	push	r16
    3e08:	1f 93       	push	r17
    3e0a:	cf 93       	push	r28
    3e0c:	df 93       	push	r29
    3e0e:	cd b7       	in	r28, 0x3d	; 61
    3e10:	de b7       	in	r29, 0x3e	; 62
    3e12:	61 97       	sbiw	r28, 0x11	; 17
    3e14:	cd bf       	out	0x3d, r28	; 61
    3e16:	de bf       	out	0x3e, r29	; 62
    3e18:	8c 01       	movw	r16, r24
    3e1a:	f6 2e       	mov	r15, r22
    3e1c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3e1e:	f8 01       	movw	r30, r16
    3e20:	42 81       	ldd	r20, Z+2	; 0x02
    3e22:	40 31       	cpi	r20, 0x10	; 16
    3e24:	21 f0       	breq	.+8      	; 0x3e2e <_ZN8emstreamlsEj+0x2a>
    3e26:	48 30       	cpi	r20, 0x08	; 8
    3e28:	11 f0       	breq	.+4      	; 0x3e2e <_ZN8emstreamlsEj+0x2a>
    3e2a:	42 30       	cpi	r20, 0x02	; 2
    3e2c:	41 f4       	brne	.+16     	; 0x3e3e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3e2e:	69 2f       	mov	r22, r25
    3e30:	c8 01       	movw	r24, r16
    3e32:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3e36:	6f 2d       	mov	r22, r15
    3e38:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3e3c:	0d c0       	rjmp	.+26     	; 0x3e58 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3e3e:	50 e0       	ldi	r21, 0x00	; 0
    3e40:	be 01       	movw	r22, r28
    3e42:	6f 5f       	subi	r22, 0xFF	; 255
    3e44:	7f 4f       	sbci	r23, 0xFF	; 255
    3e46:	8f 2d       	mov	r24, r15
    3e48:	0e 94 91 26 	call	0x4d22	; 0x4d22 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3e4c:	be 01       	movw	r22, r28
    3e4e:	6f 5f       	subi	r22, 0xFF	; 255
    3e50:	7f 4f       	sbci	r23, 0xFF	; 255
    3e52:	c8 01       	movw	r24, r16
    3e54:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3e58:	c8 01       	movw	r24, r16
    3e5a:	61 96       	adiw	r28, 0x11	; 17
    3e5c:	cd bf       	out	0x3d, r28	; 61
    3e5e:	de bf       	out	0x3e, r29	; 62
    3e60:	df 91       	pop	r29
    3e62:	cf 91       	pop	r28
    3e64:	1f 91       	pop	r17
    3e66:	0f 91       	pop	r16
    3e68:	ff 90       	pop	r15
    3e6a:	08 95       	ret

00003e6c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3e6c:	df 92       	push	r13
    3e6e:	ef 92       	push	r14
    3e70:	ff 92       	push	r15
    3e72:	0f 93       	push	r16
    3e74:	1f 93       	push	r17
    3e76:	cf 93       	push	r28
    3e78:	df 93       	push	r29
    3e7a:	cd b7       	in	r28, 0x3d	; 61
    3e7c:	de b7       	in	r29, 0x3e	; 62
    3e7e:	a1 97       	sbiw	r28, 0x21	; 33
    3e80:	cd bf       	out	0x3d, r28	; 61
    3e82:	de bf       	out	0x3e, r29	; 62
    3e84:	8c 01       	movw	r16, r24
    3e86:	d4 2e       	mov	r13, r20
    3e88:	e5 2e       	mov	r14, r21
    3e8a:	f6 2e       	mov	r15, r22
    3e8c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3e8e:	f8 01       	movw	r30, r16
    3e90:	22 81       	ldd	r18, Z+2	; 0x02
    3e92:	20 31       	cpi	r18, 0x10	; 16
    3e94:	21 f0       	breq	.+8      	; 0x3e9e <_ZN8emstreamlsEm+0x32>
    3e96:	28 30       	cpi	r18, 0x08	; 8
    3e98:	11 f0       	breq	.+4      	; 0x3e9e <_ZN8emstreamlsEm+0x32>
    3e9a:	22 30       	cpi	r18, 0x02	; 2
    3e9c:	71 f4       	brne	.+28     	; 0x3eba <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3e9e:	69 2f       	mov	r22, r25
    3ea0:	c8 01       	movw	r24, r16
    3ea2:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3ea6:	6f 2d       	mov	r22, r15
    3ea8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3eac:	6e 2d       	mov	r22, r14
    3eae:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3eb2:	6d 2d       	mov	r22, r13
    3eb4:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsEh>
    3eb8:	0f c0       	rjmp	.+30     	; 0x3ed8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3eba:	30 e0       	ldi	r19, 0x00	; 0
    3ebc:	ae 01       	movw	r20, r28
    3ebe:	4f 5f       	subi	r20, 0xFF	; 255
    3ec0:	5f 4f       	sbci	r21, 0xFF	; 255
    3ec2:	6d 2d       	mov	r22, r13
    3ec4:	7e 2d       	mov	r23, r14
    3ec6:	8f 2d       	mov	r24, r15
    3ec8:	0e 94 64 26 	call	0x4cc8	; 0x4cc8 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3ecc:	be 01       	movw	r22, r28
    3ece:	6f 5f       	subi	r22, 0xFF	; 255
    3ed0:	7f 4f       	sbci	r23, 0xFF	; 255
    3ed2:	c8 01       	movw	r24, r16
    3ed4:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3ed8:	c8 01       	movw	r24, r16
    3eda:	a1 96       	adiw	r28, 0x21	; 33
    3edc:	cd bf       	out	0x3d, r28	; 61
    3ede:	de bf       	out	0x3e, r29	; 62
    3ee0:	df 91       	pop	r29
    3ee2:	cf 91       	pop	r28
    3ee4:	1f 91       	pop	r17
    3ee6:	0f 91       	pop	r16
    3ee8:	ff 90       	pop	r15
    3eea:	ef 90       	pop	r14
    3eec:	df 90       	pop	r13
    3eee:	08 95       	ret

00003ef0 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3ef0:	cf 92       	push	r12
    3ef2:	df 92       	push	r13
    3ef4:	ef 92       	push	r14
    3ef6:	ff 92       	push	r15
    3ef8:	0f 93       	push	r16
    3efa:	1f 93       	push	r17
    3efc:	cf 93       	push	r28
    3efe:	df 93       	push	r29
    3f00:	cd b7       	in	r28, 0x3d	; 61
    3f02:	de b7       	in	r29, 0x3e	; 62
    3f04:	29 97       	sbiw	r28, 0x09	; 9
    3f06:	cd bf       	out	0x3d, r28	; 61
    3f08:	de bf       	out	0x3e, r29	; 62
    3f0a:	8c 01       	movw	r16, r24
    3f0c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3f0e:	dc 01       	movw	r26, r24
    3f10:	13 96       	adiw	r26, 0x03	; 3
    3f12:	8c 91       	ld	r24, X
    3f14:	13 97       	sbiw	r26, 0x03	; 3
    3f16:	88 23       	and	r24, r24
    3f18:	41 f0       	breq	.+16     	; 0x3f2a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3f1a:	ed 91       	ld	r30, X+
    3f1c:	fc 91       	ld	r31, X
    3f1e:	02 80       	ldd	r0, Z+2	; 0x02
    3f20:	f3 81       	ldd	r31, Z+3	; 0x03
    3f22:	e0 2d       	mov	r30, r0
    3f24:	c8 01       	movw	r24, r16
    3f26:	19 95       	eicall
    3f28:	56 c0       	rjmp	.+172    	; 0x3fd6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3f2a:	f8 01       	movw	r30, r16
    3f2c:	42 81       	ldd	r20, Z+2	; 0x02
    3f2e:	42 30       	cpi	r20, 0x02	; 2
    3f30:	19 f5       	brne	.+70     	; 0x3f78 <_ZN8emstreamlsEh+0x88>
    3f32:	68 94       	set
    3f34:	cc 24       	eor	r12, r12
    3f36:	c3 f8       	bld	r12, 3
    3f38:	d1 2c       	mov	r13, r1
    3f3a:	68 94       	set
    3f3c:	ff 24       	eor	r15, r15
    3f3e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3f40:	8e 2d       	mov	r24, r14
    3f42:	8f 21       	and	r24, r15
    3f44:	51 f0       	breq	.+20     	; 0x3f5a <_ZN8emstreamlsEh+0x6a>
    3f46:	d8 01       	movw	r26, r16
    3f48:	ed 91       	ld	r30, X+
    3f4a:	fc 91       	ld	r31, X
    3f4c:	02 80       	ldd	r0, Z+2	; 0x02
    3f4e:	f3 81       	ldd	r31, Z+3	; 0x03
    3f50:	e0 2d       	mov	r30, r0
    3f52:	61 e3       	ldi	r22, 0x31	; 49
    3f54:	c8 01       	movw	r24, r16
    3f56:	19 95       	eicall
    3f58:	09 c0       	rjmp	.+18     	; 0x3f6c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3f5a:	d8 01       	movw	r26, r16
    3f5c:	ed 91       	ld	r30, X+
    3f5e:	fc 91       	ld	r31, X
    3f60:	02 80       	ldd	r0, Z+2	; 0x02
    3f62:	f3 81       	ldd	r31, Z+3	; 0x03
    3f64:	e0 2d       	mov	r30, r0
    3f66:	60 e3       	ldi	r22, 0x30	; 48
    3f68:	c8 01       	movw	r24, r16
    3f6a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3f6c:	f6 94       	lsr	r15
    3f6e:	b1 e0       	ldi	r27, 0x01	; 1
    3f70:	cb 1a       	sub	r12, r27
    3f72:	d1 08       	sbc	r13, r1
    3f74:	29 f7       	brne	.-54     	; 0x3f40 <_ZN8emstreamlsEh+0x50>
    3f76:	2f c0       	rjmp	.+94     	; 0x3fd6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3f78:	40 31       	cpi	r20, 0x10	; 16
    3f7a:	f9 f4       	brne	.+62     	; 0x3fba <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3f7c:	62 95       	swap	r22
    3f7e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3f80:	01 90       	ld	r0, Z+
    3f82:	f0 81       	ld	r31, Z
    3f84:	e0 2d       	mov	r30, r0
    3f86:	02 80       	ldd	r0, Z+2	; 0x02
    3f88:	f3 81       	ldd	r31, Z+3	; 0x03
    3f8a:	e0 2d       	mov	r30, r0
    3f8c:	6a 30       	cpi	r22, 0x0A	; 10
    3f8e:	10 f0       	brcs	.+4      	; 0x3f94 <_ZN8emstreamlsEh+0xa4>
    3f90:	69 5c       	subi	r22, 0xC9	; 201
    3f92:	01 c0       	rjmp	.+2      	; 0x3f96 <_ZN8emstreamlsEh+0xa6>
    3f94:	60 5d       	subi	r22, 0xD0	; 208
    3f96:	c8 01       	movw	r24, r16
    3f98:	19 95       	eicall
		temp_char = num & 0x0F;
    3f9a:	6e 2d       	mov	r22, r14
    3f9c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3f9e:	d8 01       	movw	r26, r16
    3fa0:	ed 91       	ld	r30, X+
    3fa2:	fc 91       	ld	r31, X
    3fa4:	02 80       	ldd	r0, Z+2	; 0x02
    3fa6:	f3 81       	ldd	r31, Z+3	; 0x03
    3fa8:	e0 2d       	mov	r30, r0
    3faa:	6a 30       	cpi	r22, 0x0A	; 10
    3fac:	10 f0       	brcs	.+4      	; 0x3fb2 <_ZN8emstreamlsEh+0xc2>
    3fae:	69 5c       	subi	r22, 0xC9	; 201
    3fb0:	01 c0       	rjmp	.+2      	; 0x3fb4 <_ZN8emstreamlsEh+0xc4>
    3fb2:	60 5d       	subi	r22, 0xD0	; 208
    3fb4:	c8 01       	movw	r24, r16
    3fb6:	19 95       	eicall
    3fb8:	0e c0       	rjmp	.+28     	; 0x3fd6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3fba:	50 e0       	ldi	r21, 0x00	; 0
    3fbc:	be 01       	movw	r22, r28
    3fbe:	6f 5f       	subi	r22, 0xFF	; 255
    3fc0:	7f 4f       	sbci	r23, 0xFF	; 255
    3fc2:	8e 2d       	mov	r24, r14
    3fc4:	90 e0       	ldi	r25, 0x00	; 0
    3fc6:	0e 94 91 26 	call	0x4d22	; 0x4d22 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3fca:	be 01       	movw	r22, r28
    3fcc:	6f 5f       	subi	r22, 0xFF	; 255
    3fce:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd0:	c8 01       	movw	r24, r16
    3fd2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3fd6:	c8 01       	movw	r24, r16
    3fd8:	29 96       	adiw	r28, 0x09	; 9
    3fda:	cd bf       	out	0x3d, r28	; 61
    3fdc:	de bf       	out	0x3e, r29	; 62
    3fde:	df 91       	pop	r29
    3fe0:	cf 91       	pop	r28
    3fe2:	1f 91       	pop	r17
    3fe4:	0f 91       	pop	r16
    3fe6:	ff 90       	pop	r15
    3fe8:	ef 90       	pop	r14
    3fea:	df 90       	pop	r13
    3fec:	cf 90       	pop	r12
    3fee:	08 95       	ret

00003ff0 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3ff0:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3ff2:	50 96       	adiw	r26, 0x10	; 16
    3ff4:	ed 91       	ld	r30, X+
    3ff6:	fc 91       	ld	r31, X
    3ff8:	51 97       	sbiw	r26, 0x11	; 17
    3ffa:	80 81       	ld	r24, Z
    3ffc:	54 96       	adiw	r26, 0x14	; 20
    3ffe:	4c 91       	ld	r20, X
    4000:	54 97       	sbiw	r26, 0x14	; 20
    4002:	84 23       	and	r24, r20
    4004:	29 f0       	breq	.+10     	; 0x4010 <__stack+0x11>
    4006:	09 c0       	rjmp	.+18     	; 0x401a <__stack+0x1b>
    4008:	21 50       	subi	r18, 0x01	; 1
    400a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    400c:	19 f4       	brne	.+6      	; 0x4014 <__stack+0x15>
    400e:	12 c0       	rjmp	.+36     	; 0x4034 <__stack+0x35>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4010:	21 e2       	ldi	r18, 0x21	; 33
    4012:	3e e4       	ldi	r19, 0x4E	; 78
    4014:	90 81       	ld	r25, Z
    4016:	94 23       	and	r25, r20
    4018:	b9 f3       	breq	.-18     	; 0x4008 <__stack+0x9>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    401a:	90 81       	ld	r25, Z
    401c:	56 96       	adiw	r26, 0x16	; 22
    401e:	8c 91       	ld	r24, X
    4020:	56 97       	sbiw	r26, 0x16	; 22
    4022:	89 2b       	or	r24, r25
    4024:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    4026:	1e 96       	adiw	r26, 0x0e	; 14
    4028:	ed 91       	ld	r30, X+
    402a:	fc 91       	ld	r31, X
    402c:	1f 97       	sbiw	r26, 0x0f	; 15
    402e:	60 83       	st	Z, r22
	return (true);
    4030:	81 e0       	ldi	r24, 0x01	; 1
    4032:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    4034:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    4036:	08 95       	ret

00004038 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    4038:	cf 93       	push	r28
    403a:	df 93       	push	r29
    403c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    403e:	c1 8d       	ldd	r28, Z+25	; 0x19
    4040:	d2 8d       	ldd	r29, Z+26	; 0x1a
    4042:	28 81       	ld	r18, Y
    4044:	39 81       	ldd	r19, Y+1	; 0x01
    4046:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4048:	b4 8d       	ldd	r27, Z+28	; 0x1c
    404a:	4d 91       	ld	r20, X+
    404c:	5c 91       	ld	r21, X
    404e:	24 17       	cp	r18, r20
    4050:	35 07       	cpc	r19, r21
    4052:	e9 f3       	breq	.-6      	; 0x404e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    4054:	a7 89       	ldd	r26, Z+23	; 0x17
    4056:	b0 8d       	ldd	r27, Z+24	; 0x18
    4058:	0d 90       	ld	r0, X+
    405a:	bc 91       	ld	r27, X
    405c:	a0 2d       	mov	r26, r0
    405e:	a2 0f       	add	r26, r18
    4060:	b3 1f       	adc	r27, r19
    4062:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    4064:	2f 5f       	subi	r18, 0xFF	; 255
    4066:	3f 4f       	sbci	r19, 0xFF	; 255
    4068:	28 83       	st	Y, r18
    406a:	39 83       	std	Y+1, r19	; 0x01
    406c:	24 36       	cpi	r18, 0x64	; 100
    406e:	31 05       	cpc	r19, r1
    4070:	28 f0       	brcs	.+10     	; 0x407c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    4072:	01 8c       	ldd	r0, Z+25	; 0x19
    4074:	f2 8d       	ldd	r31, Z+26	; 0x1a
    4076:	e0 2d       	mov	r30, r0
    4078:	10 82       	st	Z, r1
    407a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	df 91       	pop	r29
    4080:	cf 91       	pop	r28
    4082:	08 95       	ret

00004084 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    4084:	cf 93       	push	r28
    4086:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    4088:	ec 01       	movw	r28, r24
    408a:	a9 8d       	ldd	r26, Y+25	; 0x19
    408c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    408e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4090:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	4d 91       	ld	r20, X+
    4096:	5c 91       	ld	r21, X
    4098:	20 81       	ld	r18, Z
    409a:	31 81       	ldd	r19, Z+1	; 0x01
    409c:	42 17       	cp	r20, r18
    409e:	53 07       	cpc	r21, r19
    40a0:	09 f4       	brne	.+2      	; 0x40a4 <_ZN5rs23214check_for_charEv+0x20>
    40a2:	80 e0       	ldi	r24, 0x00	; 0
}
    40a4:	df 91       	pop	r29
    40a6:	cf 91       	pop	r28
    40a8:	08 95       	ret

000040aa <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    40aa:	dc 01       	movw	r26, r24
    40ac:	ed 91       	ld	r30, X+
    40ae:	fc 91       	ld	r31, X
    40b0:	02 80       	ldd	r0, Z+2	; 0x02
    40b2:	f3 81       	ldd	r31, Z+3	; 0x03
    40b4:	e0 2d       	mov	r30, r0
    40b6:	6c e0       	ldi	r22, 0x0C	; 12
    40b8:	19 95       	eicall
    40ba:	08 95       	ret

000040bc <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    40bc:	ef 92       	push	r14
    40be:	ff 92       	push	r15
    40c0:	0f 93       	push	r16
    40c2:	1f 93       	push	r17
    40c4:	cf 93       	push	r28
    40c6:	df 93       	push	r29
    40c8:	ec 01       	movw	r28, r24
    40ca:	7b 01       	movw	r14, r22
    40cc:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    40ce:	0e 94 76 1e 	call	0x3cec	; 0x3cec <_ZN8emstreamC1Ev>
    40d2:	a8 01       	movw	r20, r16
    40d4:	b7 01       	movw	r22, r14
    40d6:	ce 01       	movw	r24, r28
    40d8:	08 96       	adiw	r24, 0x08	; 8
    40da:	0e 94 d7 1d 	call	0x3bae	; 0x3bae <_ZN7base232C1EjP12USART_struct>
    40de:	88 e9       	ldi	r24, 0x98	; 152
    40e0:	91 e2       	ldi	r25, 0x21	; 33
    40e2:	88 83       	st	Y, r24
    40e4:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    40e6:	00 3a       	cpi	r16, 0xA0	; 160
    40e8:	88 e0       	ldi	r24, 0x08	; 8
    40ea:	18 07       	cpc	r17, r24
    40ec:	69 f4       	brne	.+26     	; 0x4108 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    40ee:	82 ea       	ldi	r24, 0xA2	; 162
    40f0:	92 e3       	ldi	r25, 0x32	; 50
    40f2:	8f 8b       	std	Y+23, r24	; 0x17
    40f4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    40f6:	88 e9       	ldi	r24, 0x98	; 152
    40f8:	92 e3       	ldi	r25, 0x32	; 50
    40fa:	89 8f       	std	Y+25, r24	; 0x19
    40fc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    40fe:	8e e8       	ldi	r24, 0x8E	; 142
    4100:	92 e3       	ldi	r25, 0x32	; 50
    4102:	8b 8f       	std	Y+27, r24	; 0x1b
    4104:	9c 8f       	std	Y+28, r25	; 0x1c
    4106:	42 c0       	rjmp	.+132    	; 0x418c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4108:	00 3b       	cpi	r16, 0xB0	; 176
    410a:	e8 e0       	ldi	r30, 0x08	; 8
    410c:	1e 07       	cpc	r17, r30
    410e:	69 f4       	brne	.+26     	; 0x412a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    4110:	80 ea       	ldi	r24, 0xA0	; 160
    4112:	92 e3       	ldi	r25, 0x32	; 50
    4114:	8f 8b       	std	Y+23, r24	; 0x17
    4116:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4118:	86 e9       	ldi	r24, 0x96	; 150
    411a:	92 e3       	ldi	r25, 0x32	; 50
    411c:	89 8f       	std	Y+25, r24	; 0x19
    411e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    4120:	8c e8       	ldi	r24, 0x8C	; 140
    4122:	92 e3       	ldi	r25, 0x32	; 50
    4124:	8b 8f       	std	Y+27, r24	; 0x1b
    4126:	9c 8f       	std	Y+28, r25	; 0x1c
    4128:	31 c0       	rjmp	.+98     	; 0x418c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    412a:	00 3a       	cpi	r16, 0xA0	; 160
    412c:	f9 e0       	ldi	r31, 0x09	; 9
    412e:	1f 07       	cpc	r17, r31
    4130:	69 f4       	brne	.+26     	; 0x414c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    4132:	8e e9       	ldi	r24, 0x9E	; 158
    4134:	92 e3       	ldi	r25, 0x32	; 50
    4136:	8f 8b       	std	Y+23, r24	; 0x17
    4138:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    413a:	84 e9       	ldi	r24, 0x94	; 148
    413c:	92 e3       	ldi	r25, 0x32	; 50
    413e:	89 8f       	std	Y+25, r24	; 0x19
    4140:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    4142:	8a e8       	ldi	r24, 0x8A	; 138
    4144:	92 e3       	ldi	r25, 0x32	; 50
    4146:	8b 8f       	std	Y+27, r24	; 0x1b
    4148:	9c 8f       	std	Y+28, r25	; 0x1c
    414a:	20 c0       	rjmp	.+64     	; 0x418c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    414c:	00 3b       	cpi	r16, 0xB0	; 176
    414e:	89 e0       	ldi	r24, 0x09	; 9
    4150:	18 07       	cpc	r17, r24
    4152:	69 f4       	brne	.+26     	; 0x416e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    4154:	8c e9       	ldi	r24, 0x9C	; 156
    4156:	92 e3       	ldi	r25, 0x32	; 50
    4158:	8f 8b       	std	Y+23, r24	; 0x17
    415a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    415c:	82 e9       	ldi	r24, 0x92	; 146
    415e:	92 e3       	ldi	r25, 0x32	; 50
    4160:	89 8f       	std	Y+25, r24	; 0x19
    4162:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    4164:	88 e8       	ldi	r24, 0x88	; 136
    4166:	92 e3       	ldi	r25, 0x32	; 50
    4168:	8b 8f       	std	Y+27, r24	; 0x1b
    416a:	9c 8f       	std	Y+28, r25	; 0x1c
    416c:	0f c0       	rjmp	.+30     	; 0x418c <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    416e:	00 3a       	cpi	r16, 0xA0	; 160
    4170:	1a 40       	sbci	r17, 0x0A	; 10
    4172:	61 f4       	brne	.+24     	; 0x418c <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    4174:	8a e9       	ldi	r24, 0x9A	; 154
    4176:	92 e3       	ldi	r25, 0x32	; 50
    4178:	8f 8b       	std	Y+23, r24	; 0x17
    417a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    417c:	80 e9       	ldi	r24, 0x90	; 144
    417e:	92 e3       	ldi	r25, 0x32	; 50
    4180:	89 8f       	std	Y+25, r24	; 0x19
    4182:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    4184:	86 e8       	ldi	r24, 0x86	; 134
    4186:	92 e3       	ldi	r25, 0x32	; 50
    4188:	8b 8f       	std	Y+27, r24	; 0x1b
    418a:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    418c:	0f 89       	ldd	r16, Y+23	; 0x17
    418e:	18 8d       	ldd	r17, Y+24	; 0x18
    4190:	84 e6       	ldi	r24, 0x64	; 100
    4192:	90 e0       	ldi	r25, 0x00	; 0
    4194:	0e 94 d3 1d 	call	0x3ba6	; 0x3ba6 <_Znaj>
    4198:	f8 01       	movw	r30, r16
    419a:	80 83       	st	Z, r24
    419c:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    419e:	e9 8d       	ldd	r30, Y+25	; 0x19
    41a0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    41a2:	10 82       	st	Z, r1
    41a4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    41a6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    41a8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    41aa:	10 82       	st	Z, r1
    41ac:	11 82       	std	Z+1, r1	; 0x01
}
    41ae:	df 91       	pop	r29
    41b0:	cf 91       	pop	r28
    41b2:	1f 91       	pop	r17
    41b4:	0f 91       	pop	r16
    41b6:	ff 90       	pop	r15
    41b8:	ef 90       	pop	r14
    41ba:	08 95       	ret

000041bc <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    41bc:	1f 92       	push	r1
    41be:	0f 92       	push	r0
    41c0:	0f b6       	in	r0, 0x3f	; 63
    41c2:	0f 92       	push	r0
    41c4:	11 24       	eor	r1, r1
    41c6:	08 b6       	in	r0, 0x38	; 56
    41c8:	0f 92       	push	r0
    41ca:	18 be       	out	0x38, r1	; 56
    41cc:	0b b6       	in	r0, 0x3b	; 59
    41ce:	0f 92       	push	r0
    41d0:	1b be       	out	0x3b, r1	; 59
    41d2:	2f 93       	push	r18
    41d4:	3f 93       	push	r19
    41d6:	8f 93       	push	r24
    41d8:	9f 93       	push	r25
    41da:	ef 93       	push	r30
    41dc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    41de:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    41e2:	e0 91 a2 32 	lds	r30, 0x32A2	; 0x8032a2 <rcvC0_buffer>
    41e6:	f0 91 a3 32 	lds	r31, 0x32A3	; 0x8032a3 <rcvC0_buffer+0x1>
    41ea:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvC0_write_index>
    41ee:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvC0_write_index+0x1>
    41f2:	e8 0f       	add	r30, r24
    41f4:	f9 1f       	adc	r31, r25
    41f6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    41f8:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvC0_write_index>
    41fc:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvC0_write_index+0x1>
    4200:	01 96       	adiw	r24, 0x01	; 1
    4202:	84 36       	cpi	r24, 0x64	; 100
    4204:	91 05       	cpc	r25, r1
    4206:	60 f4       	brcc	.+24     	; 0x4220 <__vector_25+0x64>
    4208:	80 93 8e 32 	sts	0x328E, r24	; 0x80328e <rcvC0_write_index>
    420c:	90 93 8f 32 	sts	0x328F, r25	; 0x80328f <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4210:	20 91 98 32 	lds	r18, 0x3298	; 0x803298 <rcvC0_read_index>
    4214:	30 91 99 32 	lds	r19, 0x3299	; 0x803299 <rcvC0_read_index+0x1>
    4218:	82 17       	cp	r24, r18
    421a:	93 07       	cpc	r25, r19
    421c:	f1 f4       	brne	.+60     	; 0x425a <__vector_25+0x9e>
    421e:	0c c0       	rjmp	.+24     	; 0x4238 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    4220:	10 92 8e 32 	sts	0x328E, r1	; 0x80328e <rcvC0_write_index>
    4224:	10 92 8f 32 	sts	0x328F, r1	; 0x80328f <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4228:	80 91 98 32 	lds	r24, 0x3298	; 0x803298 <rcvC0_read_index>
    422c:	90 91 99 32 	lds	r25, 0x3299	; 0x803299 <rcvC0_read_index+0x1>
    4230:	18 16       	cp	r1, r24
    4232:	19 06       	cpc	r1, r25
    4234:	91 f4       	brne	.+36     	; 0x425a <__vector_25+0x9e>
    4236:	0e c0       	rjmp	.+28     	; 0x4254 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4238:	01 96       	adiw	r24, 0x01	; 1
    423a:	84 36       	cpi	r24, 0x64	; 100
    423c:	91 05       	cpc	r25, r1
    423e:	28 f4       	brcc	.+10     	; 0x424a <__vector_25+0x8e>
    4240:	80 93 98 32 	sts	0x3298, r24	; 0x803298 <rcvC0_read_index>
    4244:	90 93 99 32 	sts	0x3299, r25	; 0x803299 <rcvC0_read_index+0x1>
    4248:	08 c0       	rjmp	.+16     	; 0x425a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    424a:	10 92 98 32 	sts	0x3298, r1	; 0x803298 <rcvC0_read_index>
    424e:	10 92 99 32 	sts	0x3299, r1	; 0x803299 <rcvC0_read_index+0x1>
}
    4252:	03 c0       	rjmp	.+6      	; 0x425a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4254:	81 e0       	ldi	r24, 0x01	; 1
    4256:	90 e0       	ldi	r25, 0x00	; 0
    4258:	f3 cf       	rjmp	.-26     	; 0x4240 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    425a:	ff 91       	pop	r31
    425c:	ef 91       	pop	r30
    425e:	9f 91       	pop	r25
    4260:	8f 91       	pop	r24
    4262:	3f 91       	pop	r19
    4264:	2f 91       	pop	r18
    4266:	0f 90       	pop	r0
    4268:	0b be       	out	0x3b, r0	; 59
    426a:	0f 90       	pop	r0
    426c:	08 be       	out	0x38, r0	; 56
    426e:	0f 90       	pop	r0
    4270:	0f be       	out	0x3f, r0	; 63
    4272:	0f 90       	pop	r0
    4274:	1f 90       	pop	r1
    4276:	18 95       	reti

00004278 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    4278:	1f 92       	push	r1
    427a:	0f 92       	push	r0
    427c:	0f b6       	in	r0, 0x3f	; 63
    427e:	0f 92       	push	r0
    4280:	11 24       	eor	r1, r1
    4282:	08 b6       	in	r0, 0x38	; 56
    4284:	0f 92       	push	r0
    4286:	18 be       	out	0x38, r1	; 56
    4288:	0b b6       	in	r0, 0x3b	; 59
    428a:	0f 92       	push	r0
    428c:	1b be       	out	0x3b, r1	; 59
    428e:	2f 93       	push	r18
    4290:	3f 93       	push	r19
    4292:	8f 93       	push	r24
    4294:	9f 93       	push	r25
    4296:	ef 93       	push	r30
    4298:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    429a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    429e:	e0 91 a0 32 	lds	r30, 0x32A0	; 0x8032a0 <rcvC1_buffer>
    42a2:	f0 91 a1 32 	lds	r31, 0x32A1	; 0x8032a1 <rcvC1_buffer+0x1>
    42a6:	80 91 8c 32 	lds	r24, 0x328C	; 0x80328c <rcvC1_write_index>
    42aa:	90 91 8d 32 	lds	r25, 0x328D	; 0x80328d <rcvC1_write_index+0x1>
    42ae:	e8 0f       	add	r30, r24
    42b0:	f9 1f       	adc	r31, r25
    42b2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    42b4:	80 91 8c 32 	lds	r24, 0x328C	; 0x80328c <rcvC1_write_index>
    42b8:	90 91 8d 32 	lds	r25, 0x328D	; 0x80328d <rcvC1_write_index+0x1>
    42bc:	01 96       	adiw	r24, 0x01	; 1
    42be:	84 36       	cpi	r24, 0x64	; 100
    42c0:	91 05       	cpc	r25, r1
    42c2:	60 f4       	brcc	.+24     	; 0x42dc <__vector_28+0x64>
    42c4:	80 93 8c 32 	sts	0x328C, r24	; 0x80328c <rcvC1_write_index>
    42c8:	90 93 8d 32 	sts	0x328D, r25	; 0x80328d <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    42cc:	20 91 96 32 	lds	r18, 0x3296	; 0x803296 <rcvC1_read_index>
    42d0:	30 91 97 32 	lds	r19, 0x3297	; 0x803297 <rcvC1_read_index+0x1>
    42d4:	82 17       	cp	r24, r18
    42d6:	93 07       	cpc	r25, r19
    42d8:	f1 f4       	brne	.+60     	; 0x4316 <__vector_28+0x9e>
    42da:	0c c0       	rjmp	.+24     	; 0x42f4 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    42dc:	10 92 8c 32 	sts	0x328C, r1	; 0x80328c <rcvC1_write_index>
    42e0:	10 92 8d 32 	sts	0x328D, r1	; 0x80328d <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    42e4:	80 91 96 32 	lds	r24, 0x3296	; 0x803296 <rcvC1_read_index>
    42e8:	90 91 97 32 	lds	r25, 0x3297	; 0x803297 <rcvC1_read_index+0x1>
    42ec:	18 16       	cp	r1, r24
    42ee:	19 06       	cpc	r1, r25
    42f0:	91 f4       	brne	.+36     	; 0x4316 <__vector_28+0x9e>
    42f2:	0e c0       	rjmp	.+28     	; 0x4310 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    42f4:	01 96       	adiw	r24, 0x01	; 1
    42f6:	84 36       	cpi	r24, 0x64	; 100
    42f8:	91 05       	cpc	r25, r1
    42fa:	28 f4       	brcc	.+10     	; 0x4306 <__vector_28+0x8e>
    42fc:	80 93 96 32 	sts	0x3296, r24	; 0x803296 <rcvC1_read_index>
    4300:	90 93 97 32 	sts	0x3297, r25	; 0x803297 <rcvC1_read_index+0x1>
    4304:	08 c0       	rjmp	.+16     	; 0x4316 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    4306:	10 92 96 32 	sts	0x3296, r1	; 0x803296 <rcvC1_read_index>
    430a:	10 92 97 32 	sts	0x3297, r1	; 0x803297 <rcvC1_read_index+0x1>
}
    430e:	03 c0       	rjmp	.+6      	; 0x4316 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4310:	81 e0       	ldi	r24, 0x01	; 1
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	f3 cf       	rjmp	.-26     	; 0x42fc <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    4316:	ff 91       	pop	r31
    4318:	ef 91       	pop	r30
    431a:	9f 91       	pop	r25
    431c:	8f 91       	pop	r24
    431e:	3f 91       	pop	r19
    4320:	2f 91       	pop	r18
    4322:	0f 90       	pop	r0
    4324:	0b be       	out	0x3b, r0	; 59
    4326:	0f 90       	pop	r0
    4328:	08 be       	out	0x38, r0	; 56
    432a:	0f 90       	pop	r0
    432c:	0f be       	out	0x3f, r0	; 63
    432e:	0f 90       	pop	r0
    4330:	1f 90       	pop	r1
    4332:	18 95       	reti

00004334 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4334:	1f 92       	push	r1
    4336:	0f 92       	push	r0
    4338:	0f b6       	in	r0, 0x3f	; 63
    433a:	0f 92       	push	r0
    433c:	11 24       	eor	r1, r1
    433e:	08 b6       	in	r0, 0x38	; 56
    4340:	0f 92       	push	r0
    4342:	18 be       	out	0x38, r1	; 56
    4344:	0b b6       	in	r0, 0x3b	; 59
    4346:	0f 92       	push	r0
    4348:	1b be       	out	0x3b, r1	; 59
    434a:	2f 93       	push	r18
    434c:	3f 93       	push	r19
    434e:	8f 93       	push	r24
    4350:	9f 93       	push	r25
    4352:	ef 93       	push	r30
    4354:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4356:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    435a:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <rcvD0_buffer>
    435e:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <rcvD0_buffer+0x1>
    4362:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvC0_write_index>
    4366:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvC0_write_index+0x1>
    436a:	e8 0f       	add	r30, r24
    436c:	f9 1f       	adc	r31, r25
    436e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    4370:	80 91 8a 32 	lds	r24, 0x328A	; 0x80328a <rcvD0_write_index>
    4374:	90 91 8b 32 	lds	r25, 0x328B	; 0x80328b <rcvD0_write_index+0x1>
    4378:	01 96       	adiw	r24, 0x01	; 1
    437a:	84 36       	cpi	r24, 0x64	; 100
    437c:	91 05       	cpc	r25, r1
    437e:	60 f4       	brcc	.+24     	; 0x4398 <__vector_88+0x64>
    4380:	80 93 8a 32 	sts	0x328A, r24	; 0x80328a <rcvD0_write_index>
    4384:	90 93 8b 32 	sts	0x328B, r25	; 0x80328b <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4388:	20 91 94 32 	lds	r18, 0x3294	; 0x803294 <rcvD0_read_index>
    438c:	30 91 95 32 	lds	r19, 0x3295	; 0x803295 <rcvD0_read_index+0x1>
    4390:	82 17       	cp	r24, r18
    4392:	93 07       	cpc	r25, r19
    4394:	f1 f4       	brne	.+60     	; 0x43d2 <__vector_88+0x9e>
    4396:	0c c0       	rjmp	.+24     	; 0x43b0 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    4398:	10 92 8a 32 	sts	0x328A, r1	; 0x80328a <rcvD0_write_index>
    439c:	10 92 8b 32 	sts	0x328B, r1	; 0x80328b <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    43a0:	80 91 94 32 	lds	r24, 0x3294	; 0x803294 <rcvD0_read_index>
    43a4:	90 91 95 32 	lds	r25, 0x3295	; 0x803295 <rcvD0_read_index+0x1>
    43a8:	18 16       	cp	r1, r24
    43aa:	19 06       	cpc	r1, r25
    43ac:	91 f4       	brne	.+36     	; 0x43d2 <__vector_88+0x9e>
    43ae:	0e c0       	rjmp	.+28     	; 0x43cc <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    43b0:	01 96       	adiw	r24, 0x01	; 1
    43b2:	84 36       	cpi	r24, 0x64	; 100
    43b4:	91 05       	cpc	r25, r1
    43b6:	28 f4       	brcc	.+10     	; 0x43c2 <__vector_88+0x8e>
    43b8:	80 93 94 32 	sts	0x3294, r24	; 0x803294 <rcvD0_read_index>
    43bc:	90 93 95 32 	sts	0x3295, r25	; 0x803295 <rcvD0_read_index+0x1>
    43c0:	08 c0       	rjmp	.+16     	; 0x43d2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    43c2:	10 92 94 32 	sts	0x3294, r1	; 0x803294 <rcvD0_read_index>
    43c6:	10 92 95 32 	sts	0x3295, r1	; 0x803295 <rcvD0_read_index+0x1>
}
    43ca:	03 c0       	rjmp	.+6      	; 0x43d2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    43cc:	81 e0       	ldi	r24, 0x01	; 1
    43ce:	90 e0       	ldi	r25, 0x00	; 0
    43d0:	f3 cf       	rjmp	.-26     	; 0x43b8 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    43d2:	ff 91       	pop	r31
    43d4:	ef 91       	pop	r30
    43d6:	9f 91       	pop	r25
    43d8:	8f 91       	pop	r24
    43da:	3f 91       	pop	r19
    43dc:	2f 91       	pop	r18
    43de:	0f 90       	pop	r0
    43e0:	0b be       	out	0x3b, r0	; 59
    43e2:	0f 90       	pop	r0
    43e4:	08 be       	out	0x38, r0	; 56
    43e6:	0f 90       	pop	r0
    43e8:	0f be       	out	0x3f, r0	; 63
    43ea:	0f 90       	pop	r0
    43ec:	1f 90       	pop	r1
    43ee:	18 95       	reti

000043f0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    43f0:	1f 92       	push	r1
    43f2:	0f 92       	push	r0
    43f4:	0f b6       	in	r0, 0x3f	; 63
    43f6:	0f 92       	push	r0
    43f8:	11 24       	eor	r1, r1
    43fa:	08 b6       	in	r0, 0x38	; 56
    43fc:	0f 92       	push	r0
    43fe:	18 be       	out	0x38, r1	; 56
    4400:	0b b6       	in	r0, 0x3b	; 59
    4402:	0f 92       	push	r0
    4404:	1b be       	out	0x3b, r1	; 59
    4406:	2f 93       	push	r18
    4408:	3f 93       	push	r19
    440a:	8f 93       	push	r24
    440c:	9f 93       	push	r25
    440e:	ef 93       	push	r30
    4410:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4412:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4416:	e0 91 9c 32 	lds	r30, 0x329C	; 0x80329c <rcvD1_buffer>
    441a:	f0 91 9d 32 	lds	r31, 0x329D	; 0x80329d <rcvD1_buffer+0x1>
    441e:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <rcvD1_write_index>
    4422:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <rcvD1_write_index+0x1>
    4426:	e8 0f       	add	r30, r24
    4428:	f9 1f       	adc	r31, r25
    442a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    442c:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <rcvD1_write_index>
    4430:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <rcvD1_write_index+0x1>
    4434:	01 96       	adiw	r24, 0x01	; 1
    4436:	84 36       	cpi	r24, 0x64	; 100
    4438:	91 05       	cpc	r25, r1
    443a:	60 f4       	brcc	.+24     	; 0x4454 <__vector_91+0x64>
    443c:	80 93 88 32 	sts	0x3288, r24	; 0x803288 <rcvD1_write_index>
    4440:	90 93 89 32 	sts	0x3289, r25	; 0x803289 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4444:	20 91 92 32 	lds	r18, 0x3292	; 0x803292 <rcvD1_read_index>
    4448:	30 91 93 32 	lds	r19, 0x3293	; 0x803293 <rcvD1_read_index+0x1>
    444c:	82 17       	cp	r24, r18
    444e:	93 07       	cpc	r25, r19
    4450:	f1 f4       	brne	.+60     	; 0x448e <__vector_91+0x9e>
    4452:	0c c0       	rjmp	.+24     	; 0x446c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4454:	10 92 88 32 	sts	0x3288, r1	; 0x803288 <rcvD1_write_index>
    4458:	10 92 89 32 	sts	0x3289, r1	; 0x803289 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    445c:	80 91 92 32 	lds	r24, 0x3292	; 0x803292 <rcvD1_read_index>
    4460:	90 91 93 32 	lds	r25, 0x3293	; 0x803293 <rcvD1_read_index+0x1>
    4464:	18 16       	cp	r1, r24
    4466:	19 06       	cpc	r1, r25
    4468:	91 f4       	brne	.+36     	; 0x448e <__vector_91+0x9e>
    446a:	0e c0       	rjmp	.+28     	; 0x4488 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    446c:	01 96       	adiw	r24, 0x01	; 1
    446e:	84 36       	cpi	r24, 0x64	; 100
    4470:	91 05       	cpc	r25, r1
    4472:	28 f4       	brcc	.+10     	; 0x447e <__vector_91+0x8e>
    4474:	80 93 92 32 	sts	0x3292, r24	; 0x803292 <rcvD1_read_index>
    4478:	90 93 93 32 	sts	0x3293, r25	; 0x803293 <rcvD1_read_index+0x1>
    447c:	08 c0       	rjmp	.+16     	; 0x448e <__vector_91+0x9e>
	rcvD1_read_index = 0;
    447e:	10 92 92 32 	sts	0x3292, r1	; 0x803292 <rcvD1_read_index>
    4482:	10 92 93 32 	sts	0x3293, r1	; 0x803293 <rcvD1_read_index+0x1>
}
    4486:	03 c0       	rjmp	.+6      	; 0x448e <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4488:	81 e0       	ldi	r24, 0x01	; 1
    448a:	90 e0       	ldi	r25, 0x00	; 0
    448c:	f3 cf       	rjmp	.-26     	; 0x4474 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    448e:	ff 91       	pop	r31
    4490:	ef 91       	pop	r30
    4492:	9f 91       	pop	r25
    4494:	8f 91       	pop	r24
    4496:	3f 91       	pop	r19
    4498:	2f 91       	pop	r18
    449a:	0f 90       	pop	r0
    449c:	0b be       	out	0x3b, r0	; 59
    449e:	0f 90       	pop	r0
    44a0:	08 be       	out	0x38, r0	; 56
    44a2:	0f 90       	pop	r0
    44a4:	0f be       	out	0x3f, r0	; 63
    44a6:	0f 90       	pop	r0
    44a8:	1f 90       	pop	r1
    44aa:	18 95       	reti

000044ac <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    44ac:	1f 92       	push	r1
    44ae:	0f 92       	push	r0
    44b0:	0f b6       	in	r0, 0x3f	; 63
    44b2:	0f 92       	push	r0
    44b4:	11 24       	eor	r1, r1
    44b6:	08 b6       	in	r0, 0x38	; 56
    44b8:	0f 92       	push	r0
    44ba:	18 be       	out	0x38, r1	; 56
    44bc:	0b b6       	in	r0, 0x3b	; 59
    44be:	0f 92       	push	r0
    44c0:	1b be       	out	0x3b, r1	; 59
    44c2:	2f 93       	push	r18
    44c4:	3f 93       	push	r19
    44c6:	8f 93       	push	r24
    44c8:	9f 93       	push	r25
    44ca:	ef 93       	push	r30
    44cc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    44ce:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    44d2:	e0 91 9a 32 	lds	r30, 0x329A	; 0x80329a <rcvE0_buffer>
    44d6:	f0 91 9b 32 	lds	r31, 0x329B	; 0x80329b <rcvE0_buffer+0x1>
    44da:	80 91 86 32 	lds	r24, 0x3286	; 0x803286 <rcvE0_write_index>
    44de:	90 91 87 32 	lds	r25, 0x3287	; 0x803287 <rcvE0_write_index+0x1>
    44e2:	e8 0f       	add	r30, r24
    44e4:	f9 1f       	adc	r31, r25
    44e6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    44e8:	80 91 86 32 	lds	r24, 0x3286	; 0x803286 <rcvE0_write_index>
    44ec:	90 91 87 32 	lds	r25, 0x3287	; 0x803287 <rcvE0_write_index+0x1>
    44f0:	01 96       	adiw	r24, 0x01	; 1
    44f2:	84 36       	cpi	r24, 0x64	; 100
    44f4:	91 05       	cpc	r25, r1
    44f6:	60 f4       	brcc	.+24     	; 0x4510 <__vector_58+0x64>
    44f8:	80 93 86 32 	sts	0x3286, r24	; 0x803286 <rcvE0_write_index>
    44fc:	90 93 87 32 	sts	0x3287, r25	; 0x803287 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4500:	20 91 90 32 	lds	r18, 0x3290	; 0x803290 <rcvE0_read_index>
    4504:	30 91 91 32 	lds	r19, 0x3291	; 0x803291 <rcvE0_read_index+0x1>
    4508:	82 17       	cp	r24, r18
    450a:	93 07       	cpc	r25, r19
    450c:	f1 f4       	brne	.+60     	; 0x454a <__vector_58+0x9e>
    450e:	0c c0       	rjmp	.+24     	; 0x4528 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4510:	10 92 86 32 	sts	0x3286, r1	; 0x803286 <rcvE0_write_index>
    4514:	10 92 87 32 	sts	0x3287, r1	; 0x803287 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4518:	80 91 90 32 	lds	r24, 0x3290	; 0x803290 <rcvE0_read_index>
    451c:	90 91 91 32 	lds	r25, 0x3291	; 0x803291 <rcvE0_read_index+0x1>
    4520:	18 16       	cp	r1, r24
    4522:	19 06       	cpc	r1, r25
    4524:	91 f4       	brne	.+36     	; 0x454a <__vector_58+0x9e>
    4526:	0e c0       	rjmp	.+28     	; 0x4544 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4528:	01 96       	adiw	r24, 0x01	; 1
    452a:	84 36       	cpi	r24, 0x64	; 100
    452c:	91 05       	cpc	r25, r1
    452e:	28 f4       	brcc	.+10     	; 0x453a <__vector_58+0x8e>
    4530:	80 93 90 32 	sts	0x3290, r24	; 0x803290 <rcvE0_read_index>
    4534:	90 93 91 32 	sts	0x3291, r25	; 0x803291 <rcvE0_read_index+0x1>
    4538:	08 c0       	rjmp	.+16     	; 0x454a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    453a:	10 92 90 32 	sts	0x3290, r1	; 0x803290 <rcvE0_read_index>
    453e:	10 92 91 32 	sts	0x3291, r1	; 0x803291 <rcvE0_read_index+0x1>
}
    4542:	03 c0       	rjmp	.+6      	; 0x454a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4544:	81 e0       	ldi	r24, 0x01	; 1
    4546:	90 e0       	ldi	r25, 0x00	; 0
    4548:	f3 cf       	rjmp	.-26     	; 0x4530 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    454a:	ff 91       	pop	r31
    454c:	ef 91       	pop	r30
    454e:	9f 91       	pop	r25
    4550:	8f 91       	pop	r24
    4552:	3f 91       	pop	r19
    4554:	2f 91       	pop	r18
    4556:	0f 90       	pop	r0
    4558:	0b be       	out	0x3b, r0	; 59
    455a:	0f 90       	pop	r0
    455c:	08 be       	out	0x38, r0	; 56
    455e:	0f 90       	pop	r0
    4560:	0f be       	out	0x3f, r0	; 63
    4562:	0f 90       	pop	r0
    4564:	1f 90       	pop	r1
    4566:	18 95       	reti

00004568 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4568:	fc 01       	movw	r30, r24
    456a:	84 81       	ldd	r24, Z+4	; 0x04
    456c:	95 81       	ldd	r25, Z+5	; 0x05
    456e:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
		}
    4572:	90 e0       	ldi	r25, 0x00	; 0
    4574:	08 95       	ret

00004576 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4576:	fc 01       	movw	r30, r24
    4578:	84 81       	ldd	r24, Z+4	; 0x04
    457a:	95 81       	ldd	r25, Z+5	; 0x05
    457c:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    4580:	91 e0       	ldi	r25, 0x01	; 1
    4582:	81 11       	cpse	r24, r1
    4584:	01 c0       	rjmp	.+2      	; 0x4588 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    4586:	90 e0       	ldi	r25, 0x00	; 0
		}
    4588:	89 2f       	mov	r24, r25
    458a:	08 95       	ret

0000458c <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    458c:	fc 01       	movw	r30, r24
    458e:	84 81       	ldd	r24, Z+4	; 0x04
    4590:	95 81       	ldd	r25, Z+5	; 0x05
    4592:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    4596:	91 e0       	ldi	r25, 0x01	; 1
    4598:	81 11       	cpse	r24, r1
    459a:	90 e0       	ldi	r25, 0x00	; 0
		}
    459c:	89 2f       	mov	r24, r25
    459e:	08 95       	ret

000045a0 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    45a0:	fc 01       	movw	r30, r24
    45a2:	84 81       	ldd	r24, Z+4	; 0x04
    45a4:	95 81       	ldd	r25, Z+5	; 0x05
    45a6:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
		}
    45aa:	90 e0       	ldi	r25, 0x00	; 0
    45ac:	08 95       	ret

000045ae <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    45ae:	fc 01       	movw	r30, r24
    45b0:	84 81       	ldd	r24, Z+4	; 0x04
    45b2:	95 81       	ldd	r25, Z+5	; 0x05
    45b4:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    45b8:	91 e0       	ldi	r25, 0x01	; 1
    45ba:	81 11       	cpse	r24, r1
    45bc:	01 c0       	rjmp	.+2      	; 0x45c0 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    45be:	90 e0       	ldi	r25, 0x00	; 0
		}
    45c0:	89 2f       	mov	r24, r25
    45c2:	08 95       	ret

000045c4 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    45c4:	fc 01       	movw	r30, r24
    45c6:	84 81       	ldd	r24, Z+4	; 0x04
    45c8:	95 81       	ldd	r25, Z+5	; 0x05
    45ca:	0e 94 e6 13 	call	0x27cc	; 0x27cc <uxQueueMessagesWaitingFromISR>
    45ce:	91 e0       	ldi	r25, 0x01	; 1
    45d0:	81 11       	cpse	r24, r1
    45d2:	90 e0       	ldi	r25, 0x00	; 0
		}
    45d4:	89 2f       	mov	r24, r25
    45d6:	08 95       	ret

000045d8 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    45d8:	fc 01       	movw	r30, r24
    45da:	84 81       	ldd	r24, Z+4	; 0x04
    45dc:	95 81       	ldd	r25, Z+5	; 0x05
    45de:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
		}
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	08 95       	ret

000045e6 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    45e6:	fc 01       	movw	r30, r24
    45e8:	84 81       	ldd	r24, Z+4	; 0x04
    45ea:	95 81       	ldd	r25, Z+5	; 0x05
    45ec:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    45f0:	91 e0       	ldi	r25, 0x01	; 1
    45f2:	81 11       	cpse	r24, r1
    45f4:	01 c0       	rjmp	.+2      	; 0x45f8 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    45f6:	90 e0       	ldi	r25, 0x00	; 0
		}
    45f8:	89 2f       	mov	r24, r25
    45fa:	08 95       	ret

000045fc <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    45fc:	fc 01       	movw	r30, r24
    45fe:	84 81       	ldd	r24, Z+4	; 0x04
    4600:	95 81       	ldd	r25, Z+5	; 0x05
    4602:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    4606:	91 e0       	ldi	r25, 0x01	; 1
    4608:	81 11       	cpse	r24, r1
    460a:	90 e0       	ldi	r25, 0x00	; 0
		}
    460c:	89 2f       	mov	r24, r25
    460e:	08 95       	ret

00004610 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4610:	fc 01       	movw	r30, r24
    4612:	84 81       	ldd	r24, Z+4	; 0x04
    4614:	95 81       	ldd	r25, Z+5	; 0x05
    4616:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
		}
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	08 95       	ret

0000461e <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    461e:	fc 01       	movw	r30, r24
    4620:	84 81       	ldd	r24, Z+4	; 0x04
    4622:	95 81       	ldd	r25, Z+5	; 0x05
    4624:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    4628:	91 e0       	ldi	r25, 0x01	; 1
    462a:	81 11       	cpse	r24, r1
    462c:	01 c0       	rjmp	.+2      	; 0x4630 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    462e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4630:	89 2f       	mov	r24, r25
    4632:	08 95       	ret

00004634 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4634:	fc 01       	movw	r30, r24
    4636:	84 81       	ldd	r24, Z+4	; 0x04
    4638:	95 81       	ldd	r25, Z+5	; 0x05
    463a:	0e 94 de 13 	call	0x27bc	; 0x27bc <uxQueueMessagesWaiting>
    463e:	91 e0       	ldi	r25, 0x01	; 1
    4640:	81 11       	cpse	r24, r1
    4642:	90 e0       	ldi	r25, 0x00	; 0
		}
    4644:	89 2f       	mov	r24, r25
    4646:	08 95       	ret

00004648 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4648:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    464a:	01 e0       	ldi	r16, 0x01	; 1
    464c:	2f ef       	ldi	r18, 0xFF	; 255
    464e:	3f ef       	ldi	r19, 0xFF	; 255
    4650:	a9 01       	movw	r20, r18
    4652:	fc 01       	movw	r30, r24
    4654:	84 81       	ldd	r24, Z+4	; 0x04
    4656:	95 81       	ldd	r25, Z+5	; 0x05
    4658:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    465c:	0f 91       	pop	r16
    465e:	08 95       	ret

00004660 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4660:	0f 93       	push	r16
    4662:	cf 93       	push	r28
    4664:	df 93       	push	r29
    4666:	1f 92       	push	r1
    4668:	1f 92       	push	r1
    466a:	cd b7       	in	r28, 0x3d	; 61
    466c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    466e:	01 e0       	ldi	r16, 0x01	; 1
    4670:	2f ef       	ldi	r18, 0xFF	; 255
    4672:	3f ef       	ldi	r19, 0xFF	; 255
    4674:	a9 01       	movw	r20, r18
    4676:	be 01       	movw	r22, r28
    4678:	6f 5f       	subi	r22, 0xFF	; 255
    467a:	7f 4f       	sbci	r23, 0xFF	; 255
    467c:	fc 01       	movw	r30, r24
    467e:	84 81       	ldd	r24, Z+4	; 0x04
    4680:	95 81       	ldd	r25, Z+5	; 0x05
    4682:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    4686:	89 81       	ldd	r24, Y+1	; 0x01
    4688:	9a 81       	ldd	r25, Y+2	; 0x02
    468a:	0f 90       	pop	r0
    468c:	0f 90       	pop	r0
    468e:	df 91       	pop	r29
    4690:	cf 91       	pop	r28
    4692:	0f 91       	pop	r16
    4694:	08 95       	ret

00004696 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4696:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4698:	00 e0       	ldi	r16, 0x00	; 0
    469a:	2f ef       	ldi	r18, 0xFF	; 255
    469c:	3f ef       	ldi	r19, 0xFF	; 255
    469e:	a9 01       	movw	r20, r18
    46a0:	fc 01       	movw	r30, r24
    46a2:	84 81       	ldd	r24, Z+4	; 0x04
    46a4:	95 81       	ldd	r25, Z+5	; 0x05
    46a6:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    46aa:	0f 91       	pop	r16
    46ac:	08 95       	ret

000046ae <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    46ae:	0f 93       	push	r16
    46b0:	cf 93       	push	r28
    46b2:	df 93       	push	r29
    46b4:	1f 92       	push	r1
    46b6:	1f 92       	push	r1
    46b8:	cd b7       	in	r28, 0x3d	; 61
    46ba:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    46bc:	00 e0       	ldi	r16, 0x00	; 0
    46be:	2f ef       	ldi	r18, 0xFF	; 255
    46c0:	3f ef       	ldi	r19, 0xFF	; 255
    46c2:	a9 01       	movw	r20, r18
    46c4:	be 01       	movw	r22, r28
    46c6:	6f 5f       	subi	r22, 0xFF	; 255
    46c8:	7f 4f       	sbci	r23, 0xFF	; 255
    46ca:	fc 01       	movw	r30, r24
    46cc:	84 81       	ldd	r24, Z+4	; 0x04
    46ce:	95 81       	ldd	r25, Z+5	; 0x05
    46d0:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    46d4:	89 81       	ldd	r24, Y+1	; 0x01
    46d6:	9a 81       	ldd	r25, Y+2	; 0x02
    46d8:	0f 90       	pop	r0
    46da:	0f 90       	pop	r0
    46dc:	df 91       	pop	r29
    46de:	cf 91       	pop	r28
    46e0:	0f 91       	pop	r16
    46e2:	08 95       	ret

000046e4 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    46e4:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    46e6:	01 e0       	ldi	r16, 0x01	; 1
    46e8:	2f ef       	ldi	r18, 0xFF	; 255
    46ea:	3f ef       	ldi	r19, 0xFF	; 255
    46ec:	a9 01       	movw	r20, r18
    46ee:	fc 01       	movw	r30, r24
    46f0:	84 81       	ldd	r24, Z+4	; 0x04
    46f2:	95 81       	ldd	r25, Z+5	; 0x05
    46f4:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    46f8:	0f 91       	pop	r16
    46fa:	08 95       	ret

000046fc <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    46fc:	0f 93       	push	r16
    46fe:	cf 93       	push	r28
    4700:	df 93       	push	r29
    4702:	1f 92       	push	r1
    4704:	1f 92       	push	r1
    4706:	cd b7       	in	r28, 0x3d	; 61
    4708:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    470a:	01 e0       	ldi	r16, 0x01	; 1
    470c:	2f ef       	ldi	r18, 0xFF	; 255
    470e:	3f ef       	ldi	r19, 0xFF	; 255
    4710:	a9 01       	movw	r20, r18
    4712:	be 01       	movw	r22, r28
    4714:	6f 5f       	subi	r22, 0xFF	; 255
    4716:	7f 4f       	sbci	r23, 0xFF	; 255
    4718:	fc 01       	movw	r30, r24
    471a:	84 81       	ldd	r24, Z+4	; 0x04
    471c:	95 81       	ldd	r25, Z+5	; 0x05
    471e:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    4722:	89 81       	ldd	r24, Y+1	; 0x01
    4724:	9a 81       	ldd	r25, Y+2	; 0x02
    4726:	0f 90       	pop	r0
    4728:	0f 90       	pop	r0
    472a:	df 91       	pop	r29
    472c:	cf 91       	pop	r28
    472e:	0f 91       	pop	r16
    4730:	08 95       	ret

00004732 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4732:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4734:	00 e0       	ldi	r16, 0x00	; 0
    4736:	2f ef       	ldi	r18, 0xFF	; 255
    4738:	3f ef       	ldi	r19, 0xFF	; 255
    473a:	a9 01       	movw	r20, r18
    473c:	fc 01       	movw	r30, r24
    473e:	84 81       	ldd	r24, Z+4	; 0x04
    4740:	95 81       	ldd	r25, Z+5	; 0x05
    4742:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
}
    4746:	0f 91       	pop	r16
    4748:	08 95       	ret

0000474a <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    474a:	0f 93       	push	r16
    474c:	cf 93       	push	r28
    474e:	df 93       	push	r29
    4750:	1f 92       	push	r1
    4752:	1f 92       	push	r1
    4754:	cd b7       	in	r28, 0x3d	; 61
    4756:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4758:	00 e0       	ldi	r16, 0x00	; 0
    475a:	2f ef       	ldi	r18, 0xFF	; 255
    475c:	3f ef       	ldi	r19, 0xFF	; 255
    475e:	a9 01       	movw	r20, r18
    4760:	be 01       	movw	r22, r28
    4762:	6f 5f       	subi	r22, 0xFF	; 255
    4764:	7f 4f       	sbci	r23, 0xFF	; 255
    4766:	fc 01       	movw	r30, r24
    4768:	84 81       	ldd	r24, Z+4	; 0x04
    476a:	95 81       	ldd	r25, Z+5	; 0x05
    476c:	0e 94 ed 12 	call	0x25da	; 0x25da <xQueueGenericReceive>
	return (recv_item);
}
    4770:	89 81       	ldd	r24, Y+1	; 0x01
    4772:	9a 81       	ldd	r25, Y+2	; 0x02
    4774:	0f 90       	pop	r0
    4776:	0f 90       	pop	r0
    4778:	df 91       	pop	r29
    477a:	cf 91       	pop	r28
    477c:	0f 91       	pop	r16
    477e:	08 95       	ret

00004780 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4780:	cf 93       	push	r28
    4782:	df 93       	push	r29
    4784:	1f 92       	push	r1
    4786:	cd b7       	in	r28, 0x3d	; 61
    4788:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    478a:	ae 01       	movw	r20, r28
    478c:	4f 5f       	subi	r20, 0xFF	; 255
    478e:	5f 4f       	sbci	r21, 0xFF	; 255
    4790:	fc 01       	movw	r30, r24
    4792:	84 81       	ldd	r24, Z+4	; 0x04
    4794:	95 81       	ldd	r25, Z+5	; 0x05
    4796:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
}
    479a:	0f 90       	pop	r0
    479c:	df 91       	pop	r29
    479e:	cf 91       	pop	r28
    47a0:	08 95       	ret

000047a2 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    47a2:	cf 93       	push	r28
    47a4:	df 93       	push	r29
    47a6:	00 d0       	rcall	.+0      	; 0x47a8 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    47a8:	cd b7       	in	r28, 0x3d	; 61
    47aa:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    47ac:	ae 01       	movw	r20, r28
    47ae:	4d 5f       	subi	r20, 0xFD	; 253
    47b0:	5f 4f       	sbci	r21, 0xFF	; 255
    47b2:	be 01       	movw	r22, r28
    47b4:	6f 5f       	subi	r22, 0xFF	; 255
    47b6:	7f 4f       	sbci	r23, 0xFF	; 255
    47b8:	fc 01       	movw	r30, r24
    47ba:	84 81       	ldd	r24, Z+4	; 0x04
    47bc:	95 81       	ldd	r25, Z+5	; 0x05
    47be:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
	return (recv_item);
}
    47c2:	89 81       	ldd	r24, Y+1	; 0x01
    47c4:	9a 81       	ldd	r25, Y+2	; 0x02
    47c6:	23 96       	adiw	r28, 0x03	; 3
    47c8:	cd bf       	out	0x3d, r28	; 61
    47ca:	de bf       	out	0x3e, r29	; 62
    47cc:	df 91       	pop	r29
    47ce:	cf 91       	pop	r28
    47d0:	08 95       	ret

000047d2 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    47d2:	cf 93       	push	r28
    47d4:	df 93       	push	r29
    47d6:	1f 92       	push	r1
    47d8:	cd b7       	in	r28, 0x3d	; 61
    47da:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    47dc:	ae 01       	movw	r20, r28
    47de:	4f 5f       	subi	r20, 0xFF	; 255
    47e0:	5f 4f       	sbci	r21, 0xFF	; 255
    47e2:	fc 01       	movw	r30, r24
    47e4:	84 81       	ldd	r24, Z+4	; 0x04
    47e6:	95 81       	ldd	r25, Z+5	; 0x05
    47e8:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
}
    47ec:	0f 90       	pop	r0
    47ee:	df 91       	pop	r29
    47f0:	cf 91       	pop	r28
    47f2:	08 95       	ret

000047f4 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    47f4:	cf 93       	push	r28
    47f6:	df 93       	push	r29
    47f8:	00 d0       	rcall	.+0      	; 0x47fa <_ZN9frt_queueIiE7ISR_getEv+0x6>
    47fa:	cd b7       	in	r28, 0x3d	; 61
    47fc:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    47fe:	ae 01       	movw	r20, r28
    4800:	4d 5f       	subi	r20, 0xFD	; 253
    4802:	5f 4f       	sbci	r21, 0xFF	; 255
    4804:	be 01       	movw	r22, r28
    4806:	6f 5f       	subi	r22, 0xFF	; 255
    4808:	7f 4f       	sbci	r23, 0xFF	; 255
    480a:	fc 01       	movw	r30, r24
    480c:	84 81       	ldd	r24, Z+4	; 0x04
    480e:	95 81       	ldd	r25, Z+5	; 0x05
    4810:	0e 94 b1 13 	call	0x2762	; 0x2762 <xQueueReceiveFromISR>
	return (recv_item);
}
    4814:	89 81       	ldd	r24, Y+1	; 0x01
    4816:	9a 81       	ldd	r25, Y+2	; 0x02
    4818:	23 96       	adiw	r28, 0x03	; 3
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	de bf       	out	0x3e, r29	; 62
    481e:	df 91       	pop	r29
    4820:	cf 91       	pop	r28
    4822:	08 95       	ret

00004824 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4824:	cf 93       	push	r28
    4826:	df 93       	push	r29
    4828:	1f 92       	push	r1
    482a:	cd b7       	in	r28, 0x3d	; 61
    482c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    482e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4830:	21 e0       	ldi	r18, 0x01	; 1
    4832:	ae 01       	movw	r20, r28
    4834:	4f 5f       	subi	r20, 0xFF	; 255
    4836:	5f 4f       	sbci	r21, 0xFF	; 255
    4838:	fc 01       	movw	r30, r24
    483a:	84 81       	ldd	r24, Z+4	; 0x04
    483c:	95 81       	ldd	r25, Z+5	; 0x05
    483e:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4842:	91 e0       	ldi	r25, 0x01	; 1
    4844:	81 11       	cpse	r24, r1
    4846:	01 c0       	rjmp	.+2      	; 0x484a <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4848:	90 e0       	ldi	r25, 0x00	; 0
}
    484a:	89 2f       	mov	r24, r25
    484c:	0f 90       	pop	r0
    484e:	df 91       	pop	r29
    4850:	cf 91       	pop	r28
    4852:	08 95       	ret

00004854 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4854:	cf 93       	push	r28
    4856:	df 93       	push	r29
    4858:	1f 92       	push	r1
    485a:	cd b7       	in	r28, 0x3d	; 61
    485c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    485e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4860:	20 e0       	ldi	r18, 0x00	; 0
    4862:	ae 01       	movw	r20, r28
    4864:	4f 5f       	subi	r20, 0xFF	; 255
    4866:	5f 4f       	sbci	r21, 0xFF	; 255
    4868:	fc 01       	movw	r30, r24
    486a:	84 81       	ldd	r24, Z+4	; 0x04
    486c:	95 81       	ldd	r25, Z+5	; 0x05
    486e:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4872:	91 e0       	ldi	r25, 0x01	; 1
    4874:	81 11       	cpse	r24, r1
    4876:	01 c0       	rjmp	.+2      	; 0x487a <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4878:	90 e0       	ldi	r25, 0x00	; 0
}
    487a:	89 2f       	mov	r24, r25
    487c:	0f 90       	pop	r0
    487e:	df 91       	pop	r29
    4880:	cf 91       	pop	r28
    4882:	08 95       	ret

00004884 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4884:	cf 93       	push	r28
    4886:	df 93       	push	r29
    4888:	1f 92       	push	r1
    488a:	cd b7       	in	r28, 0x3d	; 61
    488c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    488e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4890:	21 e0       	ldi	r18, 0x01	; 1
    4892:	ae 01       	movw	r20, r28
    4894:	4f 5f       	subi	r20, 0xFF	; 255
    4896:	5f 4f       	sbci	r21, 0xFF	; 255
    4898:	fc 01       	movw	r30, r24
    489a:	84 81       	ldd	r24, Z+4	; 0x04
    489c:	95 81       	ldd	r25, Z+5	; 0x05
    489e:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    48a2:	91 e0       	ldi	r25, 0x01	; 1
    48a4:	81 11       	cpse	r24, r1
    48a6:	01 c0       	rjmp	.+2      	; 0x48aa <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    48a8:	90 e0       	ldi	r25, 0x00	; 0
}
    48aa:	89 2f       	mov	r24, r25
    48ac:	0f 90       	pop	r0
    48ae:	df 91       	pop	r29
    48b0:	cf 91       	pop	r28
    48b2:	08 95       	ret

000048b4 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    48b4:	cf 93       	push	r28
    48b6:	df 93       	push	r29
    48b8:	1f 92       	push	r1
    48ba:	cd b7       	in	r28, 0x3d	; 61
    48bc:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    48be:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    48c0:	20 e0       	ldi	r18, 0x00	; 0
    48c2:	ae 01       	movw	r20, r28
    48c4:	4f 5f       	subi	r20, 0xFF	; 255
    48c6:	5f 4f       	sbci	r21, 0xFF	; 255
    48c8:	fc 01       	movw	r30, r24
    48ca:	84 81       	ldd	r24, Z+4	; 0x04
    48cc:	95 81       	ldd	r25, Z+5	; 0x05
    48ce:	0e 94 c1 12 	call	0x2582	; 0x2582 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    48d2:	91 e0       	ldi	r25, 0x01	; 1
    48d4:	81 11       	cpse	r24, r1
    48d6:	01 c0       	rjmp	.+2      	; 0x48da <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    48d8:	90 e0       	ldi	r25, 0x00	; 0
}
    48da:	89 2f       	mov	r24, r25
    48dc:	0f 90       	pop	r0
    48de:	df 91       	pop	r29
    48e0:	cf 91       	pop	r28
    48e2:	08 95       	ret

000048e4 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    48e4:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    48e6:	fc 01       	movw	r30, r24
    48e8:	26 81       	ldd	r18, Z+6	; 0x06
    48ea:	37 81       	ldd	r19, Z+7	; 0x07
    48ec:	40 85       	ldd	r20, Z+8	; 0x08
    48ee:	51 85       	ldd	r21, Z+9	; 0x09
    48f0:	01 e0       	ldi	r16, 0x01	; 1
    48f2:	84 81       	ldd	r24, Z+4	; 0x04
    48f4:	95 81       	ldd	r25, Z+5	; 0x05
    48f6:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    48fa:	91 e0       	ldi	r25, 0x01	; 1
    48fc:	81 11       	cpse	r24, r1
    48fe:	01 c0       	rjmp	.+2      	; 0x4902 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4900:	90 e0       	ldi	r25, 0x00	; 0
		}
    4902:	89 2f       	mov	r24, r25
    4904:	0f 91       	pop	r16
    4906:	08 95       	ret

00004908 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4908:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    490a:	fc 01       	movw	r30, r24
    490c:	26 81       	ldd	r18, Z+6	; 0x06
    490e:	37 81       	ldd	r19, Z+7	; 0x07
    4910:	40 85       	ldd	r20, Z+8	; 0x08
    4912:	51 85       	ldd	r21, Z+9	; 0x09
    4914:	00 e0       	ldi	r16, 0x00	; 0
    4916:	84 81       	ldd	r24, Z+4	; 0x04
    4918:	95 81       	ldd	r25, Z+5	; 0x05
    491a:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    491e:	91 e0       	ldi	r25, 0x01	; 1
    4920:	81 11       	cpse	r24, r1
    4922:	01 c0       	rjmp	.+2      	; 0x4926 <_ZN9frt_queueIjE3putERKj+0x1e>
    4924:	90 e0       	ldi	r25, 0x00	; 0
		}
    4926:	89 2f       	mov	r24, r25
    4928:	0f 91       	pop	r16
    492a:	08 95       	ret

0000492c <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    492c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    492e:	fc 01       	movw	r30, r24
    4930:	26 81       	ldd	r18, Z+6	; 0x06
    4932:	37 81       	ldd	r19, Z+7	; 0x07
    4934:	40 85       	ldd	r20, Z+8	; 0x08
    4936:	51 85       	ldd	r21, Z+9	; 0x09
    4938:	01 e0       	ldi	r16, 0x01	; 1
    493a:	84 81       	ldd	r24, Z+4	; 0x04
    493c:	95 81       	ldd	r25, Z+5	; 0x05
    493e:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    4942:	91 e0       	ldi	r25, 0x01	; 1
    4944:	81 11       	cpse	r24, r1
    4946:	01 c0       	rjmp	.+2      	; 0x494a <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4948:	90 e0       	ldi	r25, 0x00	; 0
		}
    494a:	89 2f       	mov	r24, r25
    494c:	0f 91       	pop	r16
    494e:	08 95       	ret

00004950 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4950:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4952:	fc 01       	movw	r30, r24
    4954:	26 81       	ldd	r18, Z+6	; 0x06
    4956:	37 81       	ldd	r19, Z+7	; 0x07
    4958:	40 85       	ldd	r20, Z+8	; 0x08
    495a:	51 85       	ldd	r21, Z+9	; 0x09
    495c:	00 e0       	ldi	r16, 0x00	; 0
    495e:	84 81       	ldd	r24, Z+4	; 0x04
    4960:	95 81       	ldd	r25, Z+5	; 0x05
    4962:	0e 94 26 12 	call	0x244c	; 0x244c <xQueueGenericSend>
    4966:	91 e0       	ldi	r25, 0x01	; 1
    4968:	81 11       	cpse	r24, r1
    496a:	01 c0       	rjmp	.+2      	; 0x496e <_ZN9frt_queueIiE3putERKi+0x1e>
    496c:	90 e0       	ldi	r25, 0x00	; 0
		}
    496e:	89 2f       	mov	r24, r25
    4970:	0f 91       	pop	r16
    4972:	08 95       	ret

00004974 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4974:	0f 93       	push	r16
    4976:	cf 93       	push	r28
    4978:	df 93       	push	r29
    497a:	1f 92       	push	r1
    497c:	cd b7       	in	r28, 0x3d	; 61
    497e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4980:	2f b7       	in	r18, 0x3f	; 63
    4982:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4984:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4986:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4988:	fc 01       	movw	r30, r24
    498a:	08 ed       	ldi	r16, 0xD8	; 216
    498c:	04 bf       	out	0x34, r16	; 52
    498e:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4990:	89 81       	ldd	r24, Y+1	; 0x01
    4992:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4994:	0f 90       	pop	r0
    4996:	df 91       	pop	r29
    4998:	cf 91       	pop	r28
    499a:	0f 91       	pop	r16
    499c:	08 95       	ret

0000499e <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    499e:	ef 92       	push	r14
    49a0:	ff 92       	push	r15
    49a2:	0f 93       	push	r16
    49a4:	1f 93       	push	r17
    49a6:	cf 93       	push	r28
    49a8:	df 93       	push	r29
    49aa:	cd b7       	in	r28, 0x3d	; 61
    49ac:	de b7       	in	r29, 0x3e	; 62
    49ae:	c9 54       	subi	r28, 0x49	; 73
    49b0:	d1 09       	sbc	r29, r1
    49b2:	cd bf       	out	0x3d, r28	; 61
    49b4:	de bf       	out	0x3e, r29	; 62
	cli();
    49b6:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    49b8:	e0 e5       	ldi	r30, 0x50	; 80
    49ba:	f0 e0       	ldi	r31, 0x00	; 0
    49bc:	80 81       	ld	r24, Z
    49be:	82 60       	ori	r24, 0x02	; 2
    49c0:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    49c2:	81 81       	ldd	r24, Z+1	; 0x01
    49c4:	81 ff       	sbrs	r24, 1
    49c6:	fd cf       	rjmp	.-6      	; 0x49c2 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    49c8:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    49cc:	68 7f       	andi	r22, 0xF8	; 248
    49ce:	61 60       	ori	r22, 0x01	; 1
    49d0:	80 e4       	ldi	r24, 0x40	; 64
    49d2:	90 e0       	ldi	r25, 0x00	; 0
    49d4:	0e 94 ba 24 	call	0x4974	; 0x4974 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    49d8:	e0 e5       	ldi	r30, 0x50	; 80
    49da:	f0 e0       	ldi	r31, 0x00	; 0
    49dc:	80 81       	ld	r24, Z
    49de:	8e 7f       	andi	r24, 0xFE	; 254
    49e0:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    49e2:	9d ef       	ldi	r25, 0xFD	; 253
    49e4:	88 ed       	ldi	r24, 0xD8	; 216
    49e6:	08 b6       	in	r0, 0x38	; 56
    49e8:	18 be       	out	0x38, r1	; 56
    49ea:	84 bf       	out	0x34, r24	; 52
    49ec:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    49f0:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    49f2:	40 ea       	ldi	r20, 0xA0	; 160
    49f4:	5a e0       	ldi	r21, 0x0A	; 10
    49f6:	60 e0       	ldi	r22, 0x00	; 0
    49f8:	70 e0       	ldi	r23, 0x00	; 0
    49fa:	ce 01       	movw	r24, r28
    49fc:	01 96       	adiw	r24, 0x01	; 1
    49fe:	0e 94 5e 20 	call	0x40bc	; 0x40bc <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4a02:	67 e0       	ldi	r22, 0x07	; 7
    4a04:	ce 01       	movw	r24, r28
    4a06:	01 96       	adiw	r24, 0x01	; 1
    4a08:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    4a0c:	8c 01       	movw	r16, r24
    4a0e:	64 ea       	ldi	r22, 0xA4	; 164
    4a10:	71 e2       	ldi	r23, 0x21	; 33
    4a12:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_ZN8emstream4putsEPKc>
    4a16:	66 e0       	ldi	r22, 0x06	; 6
    4a18:	c8 01       	movw	r24, r16
    4a1a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
    4a1e:	66 e0       	ldi	r22, 0x06	; 6
    4a20:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <_ZN8emstreamlsE15ser_manipulator>
	
	// Create instance of I2C driver to be used by sensor objects
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4a24:	8e 01       	movw	r16, r28
    4a26:	0f 5f       	subi	r16, 0xFF	; 255
    4a28:	1f 4f       	sbci	r17, 0xFF	; 255
    4a2a:	20 e3       	ldi	r18, 0x30	; 48
    4a2c:	32 ef       	ldi	r19, 0xF2	; 242
    4a2e:	40 e0       	ldi	r20, 0x00	; 0
    4a30:	50 e0       	ldi	r21, 0x00	; 0
    4a32:	60 ea       	ldi	r22, 0xA0	; 160
    4a34:	74 e0       	ldi	r23, 0x04	; 4
    4a36:	ce 01       	movw	r24, r28
    4a38:	4e 96       	adiw	r24, 0x1e	; 30
    4a3a:	0e 94 a5 07 	call	0xf4a	; 0xf4a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>
	
	// Create instance of IMU class and pass in a pointer to the I2C driver
	MMA8451 mma8451(&i2c, &ser_dev);
    4a3e:	a8 01       	movw	r20, r16
    4a40:	be 01       	movw	r22, r28
    4a42:	62 5e       	subi	r22, 0xE2	; 226
    4a44:	7f 4f       	sbci	r23, 0xFF	; 255
    4a46:	ce 01       	movw	r24, r28
    4a48:	c7 96       	adiw	r24, 0x37	; 55
    4a4a:	0e 94 76 09 	call	0x12ec	; 0x12ec <_ZN7MMA8451C1EP9I2CMasterP8emstream>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4a4e:	82 e1       	ldi	r24, 0x12	; 18
    4a50:	90 e0       	ldi	r25, 0x00	; 0
    4a52:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    4a56:	20 e8       	ldi	r18, 0x80	; 128
    4a58:	30 e0       	ldi	r19, 0x00	; 0
    4a5a:	40 e0       	ldi	r20, 0x00	; 0
    4a5c:	63 ec       	ldi	r22, 0xC3	; 195
    4a5e:	71 e2       	ldi	r23, 0x21	; 33
    4a60:	0e 94 a2 0b 	call	0x1744	; 0x1744 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sensor ("Sensor", task_priority (2), 128, &ser_dev, &mma8451);
    4a64:	88 e1       	ldi	r24, 0x18	; 24
    4a66:	90 e0       	ldi	r25, 0x00	; 0
    4a68:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <_Znwj>
    4a6c:	9e 01       	movw	r18, r28
    4a6e:	29 5c       	subi	r18, 0xC9	; 201
    4a70:	3f 4f       	sbci	r19, 0xFF	; 255
    4a72:	79 01       	movw	r14, r18
    4a74:	20 e8       	ldi	r18, 0x80	; 128
    4a76:	30 e0       	ldi	r19, 0x00	; 0
    4a78:	42 e0       	ldi	r20, 0x02	; 2
    4a7a:	6b ec       	ldi	r22, 0xCB	; 203
    4a7c:	71 e2       	ldi	r23, 0x21	; 33
    4a7e:	0e 94 85 0b 	call	0x170a	; 0x170a <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4a82:	87 e0       	ldi	r24, 0x07	; 7
    4a84:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4a88:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4a8a:	0e 94 4f 15 	call	0x2a9e	; 0x2a9e <vTaskStartScheduler>
}
    4a8e:	80 e0       	ldi	r24, 0x00	; 0
    4a90:	90 e0       	ldi	r25, 0x00	; 0
    4a92:	c7 5b       	subi	r28, 0xB7	; 183
    4a94:	df 4f       	sbci	r29, 0xFF	; 255
    4a96:	cd bf       	out	0x3d, r28	; 61
    4a98:	de bf       	out	0x3e, r29	; 62
    4a9a:	df 91       	pop	r29
    4a9c:	cf 91       	pop	r28
    4a9e:	1f 91       	pop	r17
    4aa0:	0f 91       	pop	r16
    4aa2:	ff 90       	pop	r15
    4aa4:	ef 90       	pop	r14
    4aa6:	08 95       	ret

00004aa8 <_GLOBAL__sub_I_counter>:
    4aa8:	cf 92       	push	r12
    4aaa:	df 92       	push	r13
    4aac:	ef 92       	push	r14
    4aae:	ff 92       	push	r15
    4ab0:	0f 93       	push	r16
    4ab2:	1f 93       	push	r17
    4ab4:	cf 93       	push	r28
    4ab6:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sensor.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4ab8:	0a e0       	ldi	r16, 0x0A	; 10
    4aba:	10 e0       	ldi	r17, 0x00	; 0
    4abc:	20 e0       	ldi	r18, 0x00	; 0
    4abe:	30 e0       	ldi	r19, 0x00	; 0
    4ac0:	40 e0       	ldi	r20, 0x00	; 0
    4ac2:	50 e0       	ldi	r21, 0x00	; 0
    4ac4:	60 e2       	ldi	r22, 0x20	; 32
    4ac6:	70 e0       	ldi	r23, 0x00	; 0
    4ac8:	86 ed       	ldi	r24, 0xD6	; 214
    4aca:	92 e3       	ldi	r25, 0x32	; 50
    4acc:	0e 94 3c 1c 	call	0x3878	; 0x3878 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4ad0:	cc ec       	ldi	r28, 0xCC	; 204
    4ad2:	d2 e3       	ldi	r29, 0x32	; 50
    4ad4:	1a 82       	std	Y+2, r1	; 0x02
    4ad6:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ad8:	86 ed       	ldi	r24, 0xD6	; 214
    4ada:	91 e2       	ldi	r25, 0x21	; 33
    4adc:	88 83       	st	Y, r24
    4ade:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ae0:	40 e0       	ldi	r20, 0x00	; 0
    4ae2:	62 e0       	ldi	r22, 0x02	; 2
    4ae4:	8f ef       	ldi	r24, 0xFF	; 255
    4ae6:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    4aea:	8c 83       	std	Y+4, r24	; 0x04
    4aec:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4aee:	0f 2e       	mov	r0, r31
    4af0:	fa e0       	ldi	r31, 0x0A	; 10
    4af2:	cf 2e       	mov	r12, r31
    4af4:	d1 2c       	mov	r13, r1
    4af6:	e1 2c       	mov	r14, r1
    4af8:	f1 2c       	mov	r15, r1
    4afa:	f0 2d       	mov	r31, r0
    4afc:	ce 82       	std	Y+6, r12	; 0x06
    4afe:	df 82       	std	Y+7, r13	; 0x07
    4b00:	e8 86       	std	Y+8, r14	; 0x08
    4b02:	f9 86       	std	Y+9, r15	; 0x09
    4b04:	c2 ec       	ldi	r28, 0xC2	; 194
    4b06:	d2 e3       	ldi	r29, 0x32	; 50
    4b08:	1a 82       	std	Y+2, r1	; 0x02
    4b0a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b0c:	0a ef       	ldi	r16, 0xFA	; 250
    4b0e:	11 e2       	ldi	r17, 0x21	; 33
    4b10:	08 83       	st	Y, r16
    4b12:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b14:	40 e0       	ldi	r20, 0x00	; 0
    4b16:	62 e0       	ldi	r22, 0x02	; 2
    4b18:	8f ef       	ldi	r24, 0xFF	; 255
    4b1a:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    4b1e:	8c 83       	std	Y+4, r24	; 0x04
    4b20:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b22:	ce 82       	std	Y+6, r12	; 0x06
    4b24:	df 82       	std	Y+7, r13	; 0x07
    4b26:	e8 86       	std	Y+8, r14	; 0x08
    4b28:	f9 86       	std	Y+9, r15	; 0x09
    4b2a:	c8 eb       	ldi	r28, 0xB8	; 184
    4b2c:	d2 e3       	ldi	r29, 0x32	; 50
    4b2e:	1a 82       	std	Y+2, r1	; 0x02
    4b30:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b32:	08 83       	st	Y, r16
    4b34:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b36:	40 e0       	ldi	r20, 0x00	; 0
    4b38:	62 e0       	ldi	r22, 0x02	; 2
    4b3a:	8f ef       	ldi	r24, 0xFF	; 255
    4b3c:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    4b40:	8c 83       	std	Y+4, r24	; 0x04
    4b42:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b44:	ce 82       	std	Y+6, r12	; 0x06
    4b46:	df 82       	std	Y+7, r13	; 0x07
    4b48:	e8 86       	std	Y+8, r14	; 0x08
    4b4a:	f9 86       	std	Y+9, r15	; 0x09
    4b4c:	ce ea       	ldi	r28, 0xAE	; 174
    4b4e:	d2 e3       	ldi	r29, 0x32	; 50
    4b50:	1a 82       	std	Y+2, r1	; 0x02
    4b52:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b54:	08 83       	st	Y, r16
    4b56:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b58:	40 e0       	ldi	r20, 0x00	; 0
    4b5a:	62 e0       	ldi	r22, 0x02	; 2
    4b5c:	8f ef       	ldi	r24, 0xFF	; 255
    4b5e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    4b62:	8c 83       	std	Y+4, r24	; 0x04
    4b64:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b66:	ce 82       	std	Y+6, r12	; 0x06
    4b68:	df 82       	std	Y+7, r13	; 0x07
    4b6a:	e8 86       	std	Y+8, r14	; 0x08
    4b6c:	f9 86       	std	Y+9, r15	; 0x09
    4b6e:	c4 ea       	ldi	r28, 0xA4	; 164
    4b70:	d2 e3       	ldi	r29, 0x32	; 50
    4b72:	1a 82       	std	Y+2, r1	; 0x02
    4b74:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b76:	08 83       	st	Y, r16
    4b78:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b7a:	40 e0       	ldi	r20, 0x00	; 0
    4b7c:	62 e0       	ldi	r22, 0x02	; 2
    4b7e:	8f ef       	ldi	r24, 0xFF	; 255
    4b80:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <xQueueGenericCreate>
    4b84:	8c 83       	std	Y+4, r24	; 0x04
    4b86:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b88:	ce 82       	std	Y+6, r12	; 0x06
    4b8a:	df 82       	std	Y+7, r13	; 0x07
    4b8c:	e8 86       	std	Y+8, r14	; 0x08
    4b8e:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4b90:	df 91       	pop	r29
    4b92:	cf 91       	pop	r28
    4b94:	1f 91       	pop	r17
    4b96:	0f 91       	pop	r16
    4b98:	ff 90       	pop	r15
    4b9a:	ef 90       	pop	r14
    4b9c:	df 90       	pop	r13
    4b9e:	cf 90       	pop	r12
    4ba0:	08 95       	ret

00004ba2 <__mulsi3>:
    4ba2:	db 01       	movw	r26, r22
    4ba4:	8f 93       	push	r24
    4ba6:	9f 93       	push	r25
    4ba8:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <__muluhisi3>
    4bac:	bf 91       	pop	r27
    4bae:	af 91       	pop	r26
    4bb0:	a2 9f       	mul	r26, r18
    4bb2:	80 0d       	add	r24, r0
    4bb4:	91 1d       	adc	r25, r1
    4bb6:	a3 9f       	mul	r26, r19
    4bb8:	90 0d       	add	r25, r0
    4bba:	b2 9f       	mul	r27, r18
    4bbc:	90 0d       	add	r25, r0
    4bbe:	11 24       	eor	r1, r1
    4bc0:	08 95       	ret

00004bc2 <__udivmodsi4>:
    4bc2:	a1 e2       	ldi	r26, 0x21	; 33
    4bc4:	1a 2e       	mov	r1, r26
    4bc6:	aa 1b       	sub	r26, r26
    4bc8:	bb 1b       	sub	r27, r27
    4bca:	fd 01       	movw	r30, r26
    4bcc:	0d c0       	rjmp	.+26     	; 0x4be8 <__udivmodsi4_ep>

00004bce <__udivmodsi4_loop>:
    4bce:	aa 1f       	adc	r26, r26
    4bd0:	bb 1f       	adc	r27, r27
    4bd2:	ee 1f       	adc	r30, r30
    4bd4:	ff 1f       	adc	r31, r31
    4bd6:	a2 17       	cp	r26, r18
    4bd8:	b3 07       	cpc	r27, r19
    4bda:	e4 07       	cpc	r30, r20
    4bdc:	f5 07       	cpc	r31, r21
    4bde:	20 f0       	brcs	.+8      	; 0x4be8 <__udivmodsi4_ep>
    4be0:	a2 1b       	sub	r26, r18
    4be2:	b3 0b       	sbc	r27, r19
    4be4:	e4 0b       	sbc	r30, r20
    4be6:	f5 0b       	sbc	r31, r21

00004be8 <__udivmodsi4_ep>:
    4be8:	66 1f       	adc	r22, r22
    4bea:	77 1f       	adc	r23, r23
    4bec:	88 1f       	adc	r24, r24
    4bee:	99 1f       	adc	r25, r25
    4bf0:	1a 94       	dec	r1
    4bf2:	69 f7       	brne	.-38     	; 0x4bce <__udivmodsi4_loop>
    4bf4:	60 95       	com	r22
    4bf6:	70 95       	com	r23
    4bf8:	80 95       	com	r24
    4bfa:	90 95       	com	r25
    4bfc:	9b 01       	movw	r18, r22
    4bfe:	ac 01       	movw	r20, r24
    4c00:	bd 01       	movw	r22, r26
    4c02:	cf 01       	movw	r24, r30
    4c04:	08 95       	ret

00004c06 <__divmodsi4>:
    4c06:	05 2e       	mov	r0, r21
    4c08:	97 fb       	bst	r25, 7
    4c0a:	1e f4       	brtc	.+6      	; 0x4c12 <__divmodsi4+0xc>
    4c0c:	00 94       	com	r0
    4c0e:	0e 94 1a 26 	call	0x4c34	; 0x4c34 <__negsi2>
    4c12:	57 fd       	sbrc	r21, 7
    4c14:	07 d0       	rcall	.+14     	; 0x4c24 <__divmodsi4_neg2>
    4c16:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <__udivmodsi4>
    4c1a:	07 fc       	sbrc	r0, 7
    4c1c:	03 d0       	rcall	.+6      	; 0x4c24 <__divmodsi4_neg2>
    4c1e:	4e f4       	brtc	.+18     	; 0x4c32 <__divmodsi4_exit>
    4c20:	0c 94 1a 26 	jmp	0x4c34	; 0x4c34 <__negsi2>

00004c24 <__divmodsi4_neg2>:
    4c24:	50 95       	com	r21
    4c26:	40 95       	com	r20
    4c28:	30 95       	com	r19
    4c2a:	21 95       	neg	r18
    4c2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4c2e:	4f 4f       	sbci	r20, 0xFF	; 255
    4c30:	5f 4f       	sbci	r21, 0xFF	; 255

00004c32 <__divmodsi4_exit>:
    4c32:	08 95       	ret

00004c34 <__negsi2>:
    4c34:	90 95       	com	r25
    4c36:	80 95       	com	r24
    4c38:	70 95       	com	r23
    4c3a:	61 95       	neg	r22
    4c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c3e:	8f 4f       	sbci	r24, 0xFF	; 255
    4c40:	9f 4f       	sbci	r25, 0xFF	; 255
    4c42:	08 95       	ret

00004c44 <__tablejump2__>:
    4c44:	ee 0f       	add	r30, r30
    4c46:	ff 1f       	adc	r31, r31
    4c48:	88 1f       	adc	r24, r24
    4c4a:	8b bf       	out	0x3b, r24	; 59
    4c4c:	07 90       	elpm	r0, Z+
    4c4e:	f6 91       	elpm	r31, Z
    4c50:	e0 2d       	mov	r30, r0
    4c52:	1b be       	out	0x3b, r1	; 59
    4c54:	19 94       	eijmp

00004c56 <__muluhisi3>:
    4c56:	0e 94 36 26 	call	0x4c6c	; 0x4c6c <__umulhisi3>
    4c5a:	a5 9f       	mul	r26, r21
    4c5c:	90 0d       	add	r25, r0
    4c5e:	b4 9f       	mul	r27, r20
    4c60:	90 0d       	add	r25, r0
    4c62:	a4 9f       	mul	r26, r20
    4c64:	80 0d       	add	r24, r0
    4c66:	91 1d       	adc	r25, r1
    4c68:	11 24       	eor	r1, r1
    4c6a:	08 95       	ret

00004c6c <__umulhisi3>:
    4c6c:	a2 9f       	mul	r26, r18
    4c6e:	b0 01       	movw	r22, r0
    4c70:	b3 9f       	mul	r27, r19
    4c72:	c0 01       	movw	r24, r0
    4c74:	a3 9f       	mul	r26, r19
    4c76:	70 0d       	add	r23, r0
    4c78:	81 1d       	adc	r24, r1
    4c7a:	11 24       	eor	r1, r1
    4c7c:	91 1d       	adc	r25, r1
    4c7e:	b2 9f       	mul	r27, r18
    4c80:	70 0d       	add	r23, r0
    4c82:	81 1d       	adc	r24, r1
    4c84:	11 24       	eor	r1, r1
    4c86:	91 1d       	adc	r25, r1
    4c88:	08 95       	ret

00004c8a <memcpy>:
    4c8a:	fb 01       	movw	r30, r22
    4c8c:	dc 01       	movw	r26, r24
    4c8e:	02 c0       	rjmp	.+4      	; 0x4c94 <memcpy+0xa>
    4c90:	01 90       	ld	r0, Z+
    4c92:	0d 92       	st	X+, r0
    4c94:	41 50       	subi	r20, 0x01	; 1
    4c96:	50 40       	sbci	r21, 0x00	; 0
    4c98:	d8 f7       	brcc	.-10     	; 0x4c90 <memcpy+0x6>
    4c9a:	08 95       	ret

00004c9c <memset>:
    4c9c:	dc 01       	movw	r26, r24
    4c9e:	01 c0       	rjmp	.+2      	; 0x4ca2 <memset+0x6>
    4ca0:	6d 93       	st	X+, r22
    4ca2:	41 50       	subi	r20, 0x01	; 1
    4ca4:	50 40       	sbci	r21, 0x00	; 0
    4ca6:	e0 f7       	brcc	.-8      	; 0x4ca0 <memset+0x4>
    4ca8:	08 95       	ret

00004caa <strncpy>:
    4caa:	fb 01       	movw	r30, r22
    4cac:	dc 01       	movw	r26, r24
    4cae:	41 50       	subi	r20, 0x01	; 1
    4cb0:	50 40       	sbci	r21, 0x00	; 0
    4cb2:	48 f0       	brcs	.+18     	; 0x4cc6 <strncpy+0x1c>
    4cb4:	01 90       	ld	r0, Z+
    4cb6:	0d 92       	st	X+, r0
    4cb8:	00 20       	and	r0, r0
    4cba:	c9 f7       	brne	.-14     	; 0x4cae <strncpy+0x4>
    4cbc:	01 c0       	rjmp	.+2      	; 0x4cc0 <strncpy+0x16>
    4cbe:	1d 92       	st	X+, r1
    4cc0:	41 50       	subi	r20, 0x01	; 1
    4cc2:	50 40       	sbci	r21, 0x00	; 0
    4cc4:	e0 f7       	brcc	.-8      	; 0x4cbe <strncpy+0x14>
    4cc6:	08 95       	ret

00004cc8 <ultoa>:
    4cc8:	25 32       	cpi	r18, 0x25	; 37
    4cca:	31 05       	cpc	r19, r1
    4ccc:	20 f4       	brcc	.+8      	; 0x4cd6 <ultoa+0xe>
    4cce:	22 30       	cpi	r18, 0x02	; 2
    4cd0:	10 f0       	brcs	.+4      	; 0x4cd6 <ultoa+0xe>
    4cd2:	0c 94 6f 26 	jmp	0x4cde	; 0x4cde <__ultoa_ncheck>
    4cd6:	fa 01       	movw	r30, r20
    4cd8:	10 82       	st	Z, r1
    4cda:	ca 01       	movw	r24, r20
    4cdc:	08 95       	ret

00004cde <__ultoa_ncheck>:
    4cde:	bb 27       	eor	r27, r27

00004ce0 <__ultoa_common>:
    4ce0:	fa 01       	movw	r30, r20
    4ce2:	a6 2f       	mov	r26, r22
    4ce4:	62 17       	cp	r22, r18
    4ce6:	71 05       	cpc	r23, r1
    4ce8:	81 05       	cpc	r24, r1
    4cea:	91 05       	cpc	r25, r1
    4cec:	33 0b       	sbc	r19, r19
    4cee:	30 fb       	bst	r19, 0
    4cf0:	66 f0       	brts	.+24     	; 0x4d0a <__ultoa_common+0x2a>
    4cf2:	aa 27       	eor	r26, r26
    4cf4:	66 0f       	add	r22, r22
    4cf6:	77 1f       	adc	r23, r23
    4cf8:	88 1f       	adc	r24, r24
    4cfa:	99 1f       	adc	r25, r25
    4cfc:	aa 1f       	adc	r26, r26
    4cfe:	a2 17       	cp	r26, r18
    4d00:	10 f0       	brcs	.+4      	; 0x4d06 <__ultoa_common+0x26>
    4d02:	a2 1b       	sub	r26, r18
    4d04:	63 95       	inc	r22
    4d06:	38 50       	subi	r19, 0x08	; 8
    4d08:	a9 f7       	brne	.-22     	; 0x4cf4 <__ultoa_common+0x14>
    4d0a:	a0 5d       	subi	r26, 0xD0	; 208
    4d0c:	aa 33       	cpi	r26, 0x3A	; 58
    4d0e:	08 f0       	brcs	.+2      	; 0x4d12 <__ultoa_common+0x32>
    4d10:	a9 5d       	subi	r26, 0xD9	; 217
    4d12:	a1 93       	st	Z+, r26
    4d14:	36 f7       	brtc	.-52     	; 0x4ce2 <__ultoa_common+0x2>
    4d16:	b1 11       	cpse	r27, r1
    4d18:	b1 93       	st	Z+, r27
    4d1a:	10 82       	st	Z, r1
    4d1c:	ca 01       	movw	r24, r20
    4d1e:	0c 94 b6 26 	jmp	0x4d6c	; 0x4d6c <strrev>

00004d22 <utoa>:
    4d22:	45 32       	cpi	r20, 0x25	; 37
    4d24:	51 05       	cpc	r21, r1
    4d26:	20 f4       	brcc	.+8      	; 0x4d30 <utoa+0xe>
    4d28:	42 30       	cpi	r20, 0x02	; 2
    4d2a:	10 f0       	brcs	.+4      	; 0x4d30 <utoa+0xe>
    4d2c:	0c 94 9c 26 	jmp	0x4d38	; 0x4d38 <__utoa_ncheck>
    4d30:	fb 01       	movw	r30, r22
    4d32:	10 82       	st	Z, r1
    4d34:	cb 01       	movw	r24, r22
    4d36:	08 95       	ret

00004d38 <__utoa_ncheck>:
    4d38:	bb 27       	eor	r27, r27

00004d3a <__utoa_common>:
    4d3a:	fb 01       	movw	r30, r22
    4d3c:	55 27       	eor	r21, r21
    4d3e:	aa 27       	eor	r26, r26
    4d40:	88 0f       	add	r24, r24
    4d42:	99 1f       	adc	r25, r25
    4d44:	aa 1f       	adc	r26, r26
    4d46:	a4 17       	cp	r26, r20
    4d48:	10 f0       	brcs	.+4      	; 0x4d4e <__utoa_common+0x14>
    4d4a:	a4 1b       	sub	r26, r20
    4d4c:	83 95       	inc	r24
    4d4e:	50 51       	subi	r21, 0x10	; 16
    4d50:	b9 f7       	brne	.-18     	; 0x4d40 <__utoa_common+0x6>
    4d52:	a0 5d       	subi	r26, 0xD0	; 208
    4d54:	aa 33       	cpi	r26, 0x3A	; 58
    4d56:	08 f0       	brcs	.+2      	; 0x4d5a <__utoa_common+0x20>
    4d58:	a9 5d       	subi	r26, 0xD9	; 217
    4d5a:	a1 93       	st	Z+, r26
    4d5c:	00 97       	sbiw	r24, 0x00	; 0
    4d5e:	79 f7       	brne	.-34     	; 0x4d3e <__utoa_common+0x4>
    4d60:	b1 11       	cpse	r27, r1
    4d62:	b1 93       	st	Z+, r27
    4d64:	11 92       	st	Z+, r1
    4d66:	cb 01       	movw	r24, r22
    4d68:	0c 94 b6 26 	jmp	0x4d6c	; 0x4d6c <strrev>

00004d6c <strrev>:
    4d6c:	dc 01       	movw	r26, r24
    4d6e:	fc 01       	movw	r30, r24
    4d70:	67 2f       	mov	r22, r23
    4d72:	71 91       	ld	r23, Z+
    4d74:	77 23       	and	r23, r23
    4d76:	e1 f7       	brne	.-8      	; 0x4d70 <strrev+0x4>
    4d78:	32 97       	sbiw	r30, 0x02	; 2
    4d7a:	04 c0       	rjmp	.+8      	; 0x4d84 <strrev+0x18>
    4d7c:	7c 91       	ld	r23, X
    4d7e:	6d 93       	st	X+, r22
    4d80:	70 83       	st	Z, r23
    4d82:	62 91       	ld	r22, -Z
    4d84:	ae 17       	cp	r26, r30
    4d86:	bf 07       	cpc	r27, r31
    4d88:	c8 f3       	brcs	.-14     	; 0x4d7c <strrev+0x10>
    4d8a:	08 95       	ret

00004d8c <_exit>:
    4d8c:	f8 94       	cli

00004d8e <__stop_program>:
    4d8e:	ff cf       	rjmp	.-2      	; 0x4d8e <__stop_program>
