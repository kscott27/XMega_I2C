
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004ad4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001c6  00802000  00004ad4  00004b68  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008021c6  008021c6  00004d2e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004d2e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004d60  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000998  00000000  00000000  00004da0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00019b38  00000000  00000000  00005738  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006d37  00000000  00000000  0001f270  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000624d  00000000  00000000  00025fa7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001cc4  00000000  00000000  0002c1f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006e18  00000000  00000000  0002deb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000909d  00000000  00000000  00034cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008e8  00000000  00000000  0003dd6d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 03 	jmp	0x66a	; 0x66a <__ctors_end>
       4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      10:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      14:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      18:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      1c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      20:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      24:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      28:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      2c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      30:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      34:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      38:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      3c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      40:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      44:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      48:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      4c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      50:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      54:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      58:	0c 94 ac 0f 	jmp	0x1f58	; 0x1f58 <__vector_22>
      5c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      60:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      64:	0c 94 81 1f 	jmp	0x3f02	; 0x3f02 <__vector_25>
      68:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      6c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      70:	0c 94 df 1f 	jmp	0x3fbe	; 0x3fbe <__vector_28>
      74:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      78:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      7c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      80:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      84:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      88:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      8c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      90:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      94:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      98:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      9c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e8:	0c 94 f9 20 	jmp	0x41f2	; 0x41f2 <__vector_58>
      ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      fc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     100:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     104:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     108:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     10c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     110:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     114:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     118:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     11c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     120:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     124:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     128:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     12c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     130:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     134:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     138:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     13c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     140:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     144:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     148:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     14c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     150:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     154:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     158:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     15c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     160:	0c 94 3d 20 	jmp	0x407a	; 0x407a <__vector_88>
     164:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     168:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     16c:	0c 94 9b 20 	jmp	0x4136	; 0x4136 <__vector_91>
     170:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     174:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     178:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     17c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     180:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     184:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     188:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     18c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     190:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     194:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     198:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     19c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1fc:	6d 1d       	adc	r22, r13
     1fe:	70 1d       	adc	r23, r0
     200:	73 1d       	adc	r23, r3
     202:	76 1d       	adc	r23, r6
     204:	79 1d       	adc	r23, r9
     206:	7c 1d       	adc	r23, r12
     208:	7e 1d       	adc	r23, r14
     20a:	8f 1d       	adc	r24, r15
     20c:	97 1d       	adc	r25, r7
     20e:	a1 1d       	adc	r26, r1
     210:	9f 1d       	adc	r25, r15

00000212 <__trampolines_start>:
     212:	0c 94 5e 21 	jmp	0x42bc	; 0x42bc <_ZN9frt_queueIjE13ISR_not_emptyEv>
     216:	0c 94 98 1a 	jmp	0x3530	; 0x3530 <_ZN14frt_text_queue7getcharEv>
     21a:	0c 94 7a 21 	jmp	0x42f4	; 0x42f4 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     21e:	0c 94 88 0b 	jmp	0x1710	; 0x1710 <_ZN9task_user3runEv>
     222:	0c 94 76 1d 	jmp	0x3aec	; 0x3aec <_ZN8emstreamlsE15ser_manipulator+0x30>
     226:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <_ZN8emstream12transmit_nowEv>
     22a:	0c 94 bf 1e 	jmp	0x3d7e	; 0x3d7e <_ZN5rs2327getcharEv>
     22e:	0c 94 85 21 	jmp	0x430a	; 0x430a <_ZN9frt_queueIiE12ISR_is_emptyEv>
     232:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <_ZN8emstreamlsE15ser_manipulator+0x40>
     236:	0c 94 38 08 	jmp	0x1070	; 0x1070 <_ZN9frt_queueIhE10get_a_copyERh>
     23a:	0c 94 4e 19 	jmp	0x329c	; 0x329c <_ZN8frt_task12print_statusER8emstream>
     23e:	0c 94 9b 1e 	jmp	0x3d36	; 0x3d36 <_ZN5rs2327putcharEc>
     242:	0c 94 96 21 	jmp	0x432c	; 0x432c <_ZN9frt_queueIjE9not_emptyEv>
     246:	0c 94 15 23 	jmp	0x462a	; 0x462a <_ZN9frt_queueIjE7butt_inERKj>
     24a:	0c 94 fd 04 	jmp	0x9fa	; 0x9fa <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     24e:	0c 94 12 1d 	jmp	0x3a24	; 0x3a24 <_ZN8emstream7getcharEv>
     252:	0c 94 15 22 	jmp	0x442a	; 0x442a <_ZN9frt_queueIiE10get_a_copyERi>
     256:	0c 94 8c 12 	jmp	0x2518	; 0x2518 <prvIdleTask>
     25a:	0c 94 a1 1d 	jmp	0x3b42	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
     25e:	0c 94 d8 08 	jmp	0x11b0	; 0x11b0 <_ZN9frt_queueIhE7butt_inERKh>
     262:	0c 94 69 21 	jmp	0x42d2	; 0x42d2 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     266:	0c 94 b2 21 	jmp	0x4364	; 0x4364 <_ZN9frt_queueIiE9not_emptyEv>
     26a:	0c 94 a1 04 	jmp	0x942	; 0x942 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     26e:	0c 94 d0 07 	jmp	0xfa0	; 0xfa0 <_ZN9I2CMaster10StartState7executeER6Packet>
     272:	0c 94 51 05 	jmp	0xaa2	; 0xaa2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     276:	0c 94 66 05 	jmp	0xacc	; 0xacc <_ZN9I2CMaster10StartState11serialDebugEv>
     27a:	0c 94 07 08 	jmp	0x100e	; 0x100e <_ZN9frt_queueIhE13ISR_not_emptyEv>
     27e:	0c 94 c0 08 	jmp	0x1180	; 0x1180 <_ZN9frt_queueIhE7ISR_putERKh>
     282:	0c 94 27 23 	jmp	0x464e	; 0x464e <_ZN9frt_queueIjE3putERKj>
     286:	0c 94 12 05 	jmp	0xa24	; 0xa24 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     28a:	0c 94 d3 21 	jmp	0x43a6	; 0x43a6 <_ZN9frt_queueIjE10get_a_copyEv>
     28e:	0c 94 48 22 	jmp	0x4490	; 0x4490 <_ZN9frt_queueIiE3getEv>
     292:	0c 94 73 1d 	jmp	0x3ae6	; 0x3ae6 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     296:	0c 94 39 23 	jmp	0x4672	; 0x4672 <_ZN9frt_queueIiE7butt_inERKi>
     29a:	0c 94 27 05 	jmp	0xa4e	; 0xa4e <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     29e:	0c 94 8f 1d 	jmp	0x3b1e	; 0x3b1e <_ZN8emstreamlsE15ser_manipulator+0x62>
     2a2:	0c 94 57 21 	jmp	0x42ae	; 0x42ae <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2a6:	0c 94 a8 08 	jmp	0x1150	; 0x1150 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     2aa:	0c 94 f7 03 	jmp	0x7ee	; 0x7ee <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2ae:	0c 94 8c 22 	jmp	0x4518	; 0x4518 <_ZN9frt_queueIiE7ISR_getEPi>
     2b2:	0c 94 a1 21 	jmp	0x4342	; 0x4342 <_ZN9frt_queueIjE8is_emptyEv>
     2b6:	0c 94 21 04 	jmp	0x842	; 0x842 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     2ba:	0c 94 b6 1a 	jmp	0x356c	; 0x356c <_ZN14frt_text_queue14check_for_charEv>
     2be:	0c 94 73 21 	jmp	0x42e6	; 0x42e6 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2c2:	0c 94 ea 03 	jmp	0x7d4	; 0x7d4 <_ZN8I2CAgent11resetPacketER6Packet>
     2c6:	0c 94 68 08 	jmp	0x10d0	; 0x10d0 <_ZN9frt_queueIhE3getEv>
     2ca:	0c 94 8d 03 	jmp	0x71a	; 0x71a <_ZN8I2CAgent7receiveEv>
     2ce:	0c 94 ee 21 	jmp	0x43dc	; 0x43dc <_ZN9frt_queueIjE3getEPj>
     2d2:	0c 94 00 08 	jmp	0x1000	; 0x1000 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     2d6:	0c 94 bd 21 	jmp	0x437a	; 0x437a <_ZN9frt_queueIiE8is_emptyEv>
     2da:	0c 94 3c 22 	jmp	0x4478	; 0x4478 <_ZN9frt_queueIiE3getEPi>
     2de:	0c 94 f6 23 	jmp	0x47ec	; 0x47ec <_GLOBAL__sub_I_counter>
     2e2:	0c 94 9f 1d 	jmp	0x3b3e	; 0x3b3e <_ZN8emstreamlsE15ser_manipulator+0x82>
     2e6:	0c 94 c1 1a 	jmp	0x3582	; 0x3582 <_ZN14frt_text_queue7putcharEc>
     2ea:	0c 94 74 22 	jmp	0x44e8	; 0x44e8 <_ZN9frt_queueIjE7ISR_getEv>
     2ee:	0c 94 4b 04 	jmp	0x896	; 0x896 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2f2:	0c 94 ea 08 	jmp	0x11d4	; 0x11d4 <_ZN9frt_queueIhE3putERKh>
     2f6:	0c 94 6d 1d 	jmp	0x3ada	; 0x3ada <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2fa:	0c 94 2e 08 	jmp	0x105c	; 0x105c <_ZN9frt_queueIhE8is_emptyEv>
     2fe:	0c 94 b8 03 	jmp	0x770	; 0x770 <_ZN8I2CAgent11writePacketER7Command>
     302:	0c 94 7c 1d 	jmp	0x3af8	; 0x3af8 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     306:	0c 94 18 1d 	jmp	0x3a30	; 0x3a30 <_ZN8emstream12clear_screenEv>
     30a:	0c 94 9d 22 	jmp	0x453a	; 0x453a <_ZN9frt_queueIiE7ISR_getEv>
     30e:	0c 94 e5 22 	jmp	0x45ca	; 0x45ca <_ZN9frt_queueIiE11ISR_butt_inERKi>
     312:	0c 94 d3 04 	jmp	0x9a6	; 0x9a6 <_ZN9I2CMaster9DoneState11serialDebugEv>
     316:	0c 94 f8 1e 	jmp	0x3df0	; 0x3df0 <_ZN5rs23212clear_screenEv>
     31a:	0c 94 97 1d 	jmp	0x3b2e	; 0x3b2e <_ZN8emstreamlsE15ser_manipulator+0x72>
     31e:	0c 94 79 1d 	jmp	0x3af2	; 0x3af2 <_ZN8emstreamlsE15ser_manipulator+0x36>
     322:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <_ZN8emstream14check_for_charEv>
     326:	0c 94 7b 04 	jmp	0x8f6	; 0x8f6 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     32a:	0c 94 21 22 	jmp	0x4442	; 0x4442 <_ZN9frt_queueIiE10get_a_copyEv>
     32e:	0c 94 1c 08 	jmp	0x1038	; 0x1038 <_ZN9frt_queueIhE12num_items_inEv>
     332:	0c 94 b5 22 	jmp	0x456a	; 0x456a <_ZN9frt_queueIjE11ISR_butt_inERKj>
     336:	0c 94 ab 21 	jmp	0x4356	; 0x4356 <_ZN9frt_queueIiE12num_items_inEv>
     33a:	0c 94 c7 21 	jmp	0x438e	; 0x438e <_ZN9frt_queueIjE10get_a_copyERj>
     33e:	0c 94 3c 05 	jmp	0xa78	; 0xa78 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     342:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_ZN8I2CAgent10readPacketEv>
     346:	0c 94 70 1d 	jmp	0x3ae0	; 0x3ae0 <_ZN8emstreamlsE15ser_manipulator+0x24>
     34a:	0c 94 10 1d 	jmp	0x3a20	; 0x3a20 <_ZN8emstream13ready_to_sendEv>
     34e:	0c 94 cd 22 	jmp	0x459a	; 0x459a <_ZN9frt_queueIjE7ISR_putERKj>
     352:	0c 94 be 04 	jmp	0x97c	; 0x97c <_ZN9I2CMaster10ErrorState11serialDebugEv>
     356:	0c 94 32 03 	jmp	0x664	; 0x664 <_call_static_run_method>
     35a:	0c 94 8f 21 	jmp	0x431e	; 0x431e <_ZN9frt_queueIjE12num_items_inEv>
     35e:	0c 94 4b 23 	jmp	0x4696	; 0x4696 <_ZN9frt_queueIiE3putERKi>
     362:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <_ZN10task_sonar3runEv>
     366:	0c 94 7b 05 	jmp	0xaf6	; 0xaf6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     36a:	0c 94 b6 04 	jmp	0x96c	; 0x96c <_ZN9I2CMaster9DoneState7executeER6Packet>
     36e:	0c 94 79 1c 	jmp	0x38f2	; 0x38f2 <__cxa_pure_virtual>
     372:	0c 94 5c 08 	jmp	0x10b8	; 0x10b8 <_ZN9frt_queueIhE3getEPh>
     376:	0c 94 23 08 	jmp	0x1046	; 0x1046 <_ZN9frt_queueIhE9not_emptyEv>
     37a:	0c 94 ba 04 	jmp	0x974	; 0x974 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     37e:	0c 94 fd 22 	jmp	0x45fa	; 0x45fa <_ZN9frt_queueIiE7ISR_putERKi>
     382:	0c 94 e8 04 	jmp	0x9d0	; 0x9d0 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     386:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     38a:	0c 94 80 08 	jmp	0x1100	; 0x1100 <_ZN9frt_queueIhE7ISR_getEPh>
     38e:	0c 94 e5 1e 	jmp	0x3dca	; 0x3dca <_ZN5rs23214check_for_charEv>
     392:	0c 94 12 08 	jmp	0x1024	; 0x1024 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     396:	0c 94 fa 21 	jmp	0x43f4	; 0x43f4 <_ZN9frt_queueIjE3getEv>
     39a:	0c 94 44 08 	jmp	0x1088	; 0x1088 <_ZN9frt_queueIhE10get_a_copyEv>
     39e:	0c 94 91 08 	jmp	0x1122	; 0x1122 <_ZN9frt_queueIhE7ISR_getEv>
     3a2:	0c 94 78 03 	jmp	0x6f0	; 0x6f0 <_ZN8I2CAgent8transmitER7Command>
     3a6:	0c 94 63 22 	jmp	0x44c6	; 0x44c6 <_ZN9frt_queueIjE7ISR_getEPj>

000003aa <__trampolines_end>:
     3aa:	53 6f       	ori	r21, 0xF3	; 243
     3ac:	6e 61       	ori	r22, 0x1E	; 30
     3ae:	72 3a       	cpi	r23, 0xA2	; 162
     3b0:	20 00       	.word	0x0020	; ????

000003b2 <_ZZN9task_user11show_statusEvE3__c_4>:
     3b2:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

000003bd <_ZZN9task_user11show_statusEvE3__c_3>:
     3bd:	2f 00                                               /.

000003bf <_ZZN9task_user11show_statusEvE3__c_2>:
     3bf:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003cd <_ZZN9task_user11show_statusEvE3__c_1>:
     3cd:	54 69 6d 65 3a 20 00                                Time: .

000003d4 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d4:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

000003e0 <_ZZN9task_user11show_statusEvE3__c>:
     3e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003ff <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3ff:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000040e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     40e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     41e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000429 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     429:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     439:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000447 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     447:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     457:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     467:	6d 61 74 69 6f 6e 00                                mation.

0000046e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     46e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     47e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000048f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     48f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     49f:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004a7 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4a7:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4b7:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c3 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c3:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d3:	68 65 20 41 56 52 00                                he AVR.

000004da <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4da:	20 68 65 6c 70 00                                    help.

000004e0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004ff <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4ff:	1b 5b 33 30 6d 00                                   .[30m.

00000505 <_ZZN9task_user18print_help_messageEvE3__c>:
     505:	1b 5b 34 36 6d 00                                   .[46m.

0000050b <_ZZN9task_user3runEvE3__c_3>:
     50b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000528 <_ZZN9task_user3runEvE3__c_2>:
     528:	3a 57 54 46 3f 00                                   :WTF?.

0000052e <_ZZN9task_user3runEvE3__c_1>:
     52e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     53e:	65 00                                               e.

00000540 <_ZZN9task_user3runEvE3__c_0>:
     540:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000054e <_ZZN9task_user3runEvE3__c>:
     54e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     55e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000056c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     56c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000576 <_ZZN8frt_task15emergency_resetEvE3__c>:
     576:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000585 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     585:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     595:	61 73 6b 20 00                                      ask .

0000059a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005a8 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5a8:	20 63 72 65 61 74 65 64 00                           created.

000005b1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b1:	54 61 73 6b 20 00                                   Task .

000005b7 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5b7:	1b 5b 32 32 6d 00                                   .[22m.

000005bd <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5bd:	54 61 73 6b 3a 20 00                                Task: .

000005c4 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c4:	1b 5b 31 6d 00                                      .[1m.

000005c9 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5c9:	1b 5b 32 32 6d 00                                   .[22m.

000005cf <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5cf:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005da <_ZZ17print_task_stacksP8emstreamE3__c>:
     5da:	1b 5b 31 6d 00                                      .[1m.

000005df <_ZZ15print_task_listP8emstreamE3__c_9>:
     5df:	09 09 00                                            ...

000005e2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e2:	2f 00                                               /.

000005e4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005ef <_ZZ15print_task_listP8emstreamE3__c_6>:
     5ef:	09 2d 2d 2d 2d 00                                   .----.

000005f5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000601 <_ZZ15print_task_listP8emstreamE3__c_4>:
     601:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000612 <_ZZ15print_task_listP8emstreamE3__c_3>:
     612:	09 52 75 6e 73 00                                   .Runs.

00000618 <_ZZ15print_task_listP8emstreamE3__c_2>:
     618:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000624 <_ZZ15print_task_listP8emstreamE3__c_1>:
     624:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000635 <_ZZ15print_task_listP8emstreamE3__c_0>:
     635:	09 53 74 61 63 6b 00                                .Stack.

0000063c <_ZZ15print_task_listP8emstreamE3__c>:
     63c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000647 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     647:	09 00                                               ..

00000649 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     649:	09 00                                               ..

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64b:	2f 00                                               /.

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     64f:	09 00                                               ..

00000651 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     651:	1b 5b 32 32 6d 00                                   .[22m.

00000657 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     657:	1b 5b 31 6d 00                                      .[1m.

0000065c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     65c:	1b 5b 31 6d 00                                      .[1m.

00000661 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     661:	20 20 00                                              .

00000664 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     664:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <_ZN8frt_task22_call_users_run_methodEPS_>

00000668 <__ctors_start>:
     668:	f6 23       	and	r31, r22

0000066a <__ctors_end>:
     66a:	11 24       	eor	r1, r1
     66c:	1f be       	out	0x3f, r1	; 63
     66e:	cf ef       	ldi	r28, 0xFF	; 255
     670:	cd bf       	out	0x3d, r28	; 61
     672:	df e3       	ldi	r29, 0x3F	; 63
     674:	de bf       	out	0x3e, r29	; 62
     676:	00 e0       	ldi	r16, 0x00	; 0
     678:	0c bf       	out	0x3c, r16	; 60
     67a:	18 be       	out	0x38, r1	; 56
     67c:	19 be       	out	0x39, r1	; 57
     67e:	1a be       	out	0x3a, r1	; 58
     680:	1b be       	out	0x3b, r1	; 59

00000682 <__do_copy_data>:
     682:	11 e2       	ldi	r17, 0x21	; 33
     684:	a0 e0       	ldi	r26, 0x00	; 0
     686:	b0 e2       	ldi	r27, 0x20	; 32
     688:	e4 ed       	ldi	r30, 0xD4	; 212
     68a:	fa e4       	ldi	r31, 0x4A	; 74
     68c:	00 e0       	ldi	r16, 0x00	; 0
     68e:	0b bf       	out	0x3b, r16	; 59
     690:	02 c0       	rjmp	.+4      	; 0x696 <__do_copy_data+0x14>
     692:	07 90       	elpm	r0, Z+
     694:	0d 92       	st	X+, r0
     696:	a6 3c       	cpi	r26, 0xC6	; 198
     698:	b1 07       	cpc	r27, r17
     69a:	d9 f7       	brne	.-10     	; 0x692 <__do_copy_data+0x10>
     69c:	1b be       	out	0x3b, r1	; 59

0000069e <__do_clear_bss>:
     69e:	22 e3       	ldi	r18, 0x32	; 50
     6a0:	a6 ec       	ldi	r26, 0xC6	; 198
     6a2:	b1 e2       	ldi	r27, 0x21	; 33
     6a4:	01 c0       	rjmp	.+2      	; 0x6a8 <.do_clear_bss_start>

000006a6 <.do_clear_bss_loop>:
     6a6:	1d 92       	st	X+, r1

000006a8 <.do_clear_bss_start>:
     6a8:	a4 39       	cpi	r26, 0x94	; 148
     6aa:	b2 07       	cpc	r27, r18
     6ac:	e1 f7       	brne	.-8      	; 0x6a6 <.do_clear_bss_loop>

000006ae <__do_global_ctors>:
     6ae:	13 e0       	ldi	r17, 0x03	; 3
     6b0:	c5 e3       	ldi	r28, 0x35	; 53
     6b2:	d3 e0       	ldi	r29, 0x03	; 3
     6b4:	00 e0       	ldi	r16, 0x00	; 0
     6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <__do_global_ctors+0x16>
     6b8:	21 97       	sbiw	r28, 0x01	; 1
     6ba:	01 09       	sbc	r16, r1
     6bc:	80 2f       	mov	r24, r16
     6be:	fe 01       	movw	r30, r28
     6c0:	0e 94 c4 24 	call	0x4988	; 0x4988 <__tablejump2__>
     6c4:	c4 33       	cpi	r28, 0x34	; 52
     6c6:	d1 07       	cpc	r29, r17
     6c8:	80 e0       	ldi	r24, 0x00	; 0
     6ca:	08 07       	cpc	r16, r24
     6cc:	a9 f7       	brne	.-22     	; 0x6b8 <__do_global_ctors+0xa>
     6ce:	0e 94 72 23 	call	0x46e4	; 0x46e4 <main>
     6d2:	0c 94 68 25 	jmp	0x4ad0	; 0x4ad0 <_exit>

000006d6 <__bad_interrupt>:
     6d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006da <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6da:	bc 01       	movw	r22, r24
     6dc:	6e 5f       	subi	r22, 0xFE	; 254
     6de:	7f 4f       	sbci	r23, 0xFF	; 255
     6e0:	dc 01       	movw	r26, r24
     6e2:	ed 91       	ld	r30, X+
     6e4:	fc 91       	ld	r31, X
     6e6:	00 84       	ldd	r0, Z+8	; 0x08
     6e8:	f1 85       	ldd	r31, Z+9	; 0x09
     6ea:	e0 2d       	mov	r30, r0
     6ec:	19 95       	eicall
     6ee:	08 95       	ret

000006f0 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6f6:	e8 81       	ld	r30, Y
     6f8:	f9 81       	ldd	r31, Y+1	; 0x01
     6fa:	04 80       	ldd	r0, Z+4	; 0x04
     6fc:	f5 81       	ldd	r31, Z+5	; 0x05
     6fe:	e0 2d       	mov	r30, r0
     700:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     702:	be 01       	movw	r22, r28
     704:	63 5f       	subi	r22, 0xF3	; 243
     706:	7f 4f       	sbci	r23, 0xFF	; 255
  };
  
  I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     708:	e8 8d       	ldd	r30, Y+24	; 0x18
     70a:	f9 8d       	ldd	r31, Y+25	; 0x19
     70c:	80 81       	ld	r24, Z
     70e:	91 81       	ldd	r25, Z+1	; 0x01
     710:	0e 94 c9 06 	call	0xd92	; 0xd92 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     714:	df 91       	pop	r29
     716:	cf 91       	pop	r28
     718:	08 95       	ret

0000071a <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     71a:	ef 92       	push	r14
     71c:	ff 92       	push	r15
     71e:	0f 93       	push	r16
     720:	cf 93       	push	r28
     722:	df 93       	push	r29
     724:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     726:	7c 01       	movw	r14, r24
     728:	82 e0       	ldi	r24, 0x02	; 2
     72a:	e8 0e       	add	r14, r24
     72c:	f1 1c       	adc	r15, r1
     72e:	e8 81       	ld	r30, Y
     730:	f9 81       	ldd	r31, Y+1	; 0x01
     732:	00 84       	ldd	r0, Z+8	; 0x08
     734:	f1 85       	ldd	r31, Z+9	; 0x09
     736:	e0 2d       	mov	r30, r0
     738:	b7 01       	movw	r22, r14
     73a:	ce 01       	movw	r24, r28
     73c:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     73e:	28 85       	ldd	r18, Y+8	; 0x08
     740:	39 85       	ldd	r19, Y+9	; 0x09
     742:	4a 85       	ldd	r20, Y+10	; 0x0a
     744:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     746:	be 01       	movw	r22, r28
     748:	64 5e       	subi	r22, 0xE4	; 228
     74a:	7f 4f       	sbci	r23, 0xFF	; 255
     74c:	00 e0       	ldi	r16, 0x00	; 0
     74e:	8e 81       	ldd	r24, Y+6	; 0x06
     750:	9f 81       	ldd	r25, Y+7	; 0x07
     752:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     756:	e8 8d       	ldd	r30, Y+24	; 0x18
     758:	f9 8d       	ldd	r31, Y+25	; 0x19
  return driver_->getReceiver()->run(inPacket_);
     75a:	b7 01       	movw	r22, r14
     75c:	82 81       	ldd	r24, Z+2	; 0x02
     75e:	93 81       	ldd	r25, Z+3	; 0x03
     760:	0e 94 0e 07 	call	0xe1c	; 0xe1c <_ZN9I2CMaster8Receiver3runER6Packet>
}
     764:	df 91       	pop	r29
     766:	cf 91       	pop	r28
     768:	0f 91       	pop	r16
     76a:	ff 90       	pop	r15
     76c:	ef 90       	pop	r14
     76e:	08 95       	ret

00000770 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     770:	cf 92       	push	r12
     772:	df 92       	push	r13
     774:	ef 92       	push	r14
     776:	ff 92       	push	r15
     778:	0f 93       	push	r16
     77a:	cf 93       	push	r28
     77c:	df 93       	push	r29
     77e:	ec 01       	movw	r28, r24
     780:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     782:	6c 01       	movw	r12, r24
     784:	8d e0       	ldi	r24, 0x0D	; 13
     786:	c8 0e       	add	r12, r24
     788:	d1 1c       	adc	r13, r1
     78a:	e8 81       	ld	r30, Y
     78c:	f9 81       	ldd	r31, Y+1	; 0x01
     78e:	00 84       	ldd	r0, Z+8	; 0x08
     790:	f1 85       	ldd	r31, Z+9	; 0x09
     792:	e0 2d       	mov	r30, r0
     794:	b6 01       	movw	r22, r12
     796:	ce 01       	movw	r24, r28
     798:	19 95       	eicall
     79a:	2b 89       	ldd	r18, Y+19	; 0x13
     79c:	3c 89       	ldd	r19, Y+20	; 0x14
     79e:	4d 89       	ldd	r20, Y+21	; 0x15
     7a0:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7a2:	be 01       	movw	r22, r28
     7a4:	65 5e       	subi	r22, 0xE5	; 229
     7a6:	7f 4f       	sbci	r23, 0xFF	; 255
     7a8:	00 e0       	ldi	r16, 0x00	; 0
     7aa:	89 89       	ldd	r24, Y+17	; 0x11
     7ac:	9a 89       	ldd	r25, Y+18	; 0x12
     7ae:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7b2:	d7 01       	movw	r26, r14
     7b4:	ed 91       	ld	r30, X+
     7b6:	fc 91       	ld	r31, X
     7b8:	01 90       	ld	r0, Z+
     7ba:	f0 81       	ld	r31, Z
     7bc:	e0 2d       	mov	r30, r0
     7be:	b6 01       	movw	r22, r12
     7c0:	c7 01       	movw	r24, r14
     7c2:	19 95       	eicall
}
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	0f 91       	pop	r16
     7ca:	ff 90       	pop	r15
     7cc:	ef 90       	pop	r14
     7ce:	df 90       	pop	r13
     7d0:	cf 90       	pop	r12
     7d2:	08 95       	ret

000007d4 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7d4:	cb 01       	movw	r24, r22
  packet.resetContent();
     7d6:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <_ZN6Packet12resetContentEv>
     7da:	08 95       	ret

000007dc <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7dc:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7de:	62 8f       	std	Z+26, r22	; 0x1a
  writeCommand_ = addr << 1;
     7e0:	86 2f       	mov	r24, r22
     7e2:	88 0f       	add	r24, r24
     7e4:	83 8f       	std	Z+27, r24	; 0x1b
  readCommand_ = addr << 1 | 1 << 0;
     7e6:	68 2f       	mov	r22, r24
     7e8:	61 60       	ori	r22, 0x01	; 1
     7ea:	64 8f       	std	Z+28, r22	; 0x1c
     7ec:	08 95       	ret

000007ee <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     7ee:	cf 93       	push	r28
     7f0:	df 93       	push	r29
     7f2:	1f 92       	push	r1
     7f4:	1f 92       	push	r1
     7f6:	cd b7       	in	r28, 0x3d	; 61
     7f8:	de b7       	in	r29, 0x3e	; 62
     7fa:	fc 01       	movw	r30, r24
     7fc:	81 85       	ldd	r24, Z+9	; 0x09
     7fe:	92 85       	ldd	r25, Z+10	; 0x0a
     800:	89 83       	std	Y+1, r24	; 0x01
     802:	9a 83       	std	Y+2, r25	; 0x02
     804:	29 81       	ldd	r18, Y+1	; 0x01
     806:	3a 81       	ldd	r19, Y+2	; 0x02
     808:	21 50       	subi	r18, 0x01	; 1
     80a:	31 09       	sbc	r19, r1
     80c:	29 83       	std	Y+1, r18	; 0x01
     80e:	3a 83       	std	Y+2, r19	; 0x02
     810:	23 2b       	or	r18, r19
     812:	41 f0       	breq	.+16     	; 0x824 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x36>
     814:	a7 81       	ldd	r26, Z+7	; 0x07
     816:	b0 85       	ldd	r27, Z+8	; 0x08
     818:	14 96       	adiw	r26, 0x04	; 4
     81a:	0d 90       	ld	r0, X+
     81c:	bc 91       	ld	r27, X
     81e:	a0 2d       	mov	r26, r0
     820:	14 96       	adiw	r26, 0x04	; 4
     822:	8c 91       	ld	r24, X
     824:	a7 81       	ldd	r26, Z+7	; 0x07
     826:	b0 85       	ldd	r27, Z+8	; 0x08
     828:	14 96       	adiw	r26, 0x04	; 4
     82a:	0d 90       	ld	r0, X+
     82c:	bc 91       	ld	r27, X
     82e:	a0 2d       	mov	r26, r0
     830:	14 96       	adiw	r26, 0x04	; 4
     832:	8c 91       	ld	r24, X
     834:	84 81       	ldd	r24, Z+4	; 0x04
     836:	95 81       	ldd	r25, Z+5	; 0x05
     838:	0f 90       	pop	r0
     83a:	0f 90       	pop	r0
     83c:	df 91       	pop	r29
     83e:	cf 91       	pop	r28
     840:	08 95       	ret

00000842 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     842:	cf 93       	push	r28
     844:	df 93       	push	r29
     846:	1f 92       	push	r1
     848:	1f 92       	push	r1
     84a:	cd b7       	in	r28, 0x3d	; 61
     84c:	de b7       	in	r29, 0x3e	; 62
     84e:	fc 01       	movw	r30, r24
     850:	81 85       	ldd	r24, Z+9	; 0x09
     852:	92 85       	ldd	r25, Z+10	; 0x0a
     854:	89 83       	std	Y+1, r24	; 0x01
     856:	9a 83       	std	Y+2, r25	; 0x02
     858:	29 81       	ldd	r18, Y+1	; 0x01
     85a:	3a 81       	ldd	r19, Y+2	; 0x02
     85c:	21 50       	subi	r18, 0x01	; 1
     85e:	31 09       	sbc	r19, r1
     860:	29 83       	std	Y+1, r18	; 0x01
     862:	3a 83       	std	Y+2, r19	; 0x02
     864:	23 2b       	or	r18, r19
     866:	41 f0       	breq	.+16     	; 0x878 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x36>
     868:	a7 81       	ldd	r26, Z+7	; 0x07
     86a:	b0 85       	ldd	r27, Z+8	; 0x08
     86c:	14 96       	adiw	r26, 0x04	; 4
     86e:	0d 90       	ld	r0, X+
     870:	bc 91       	ld	r27, X
     872:	a0 2d       	mov	r26, r0
     874:	14 96       	adiw	r26, 0x04	; 4
     876:	8c 91       	ld	r24, X
     878:	a7 81       	ldd	r26, Z+7	; 0x07
     87a:	b0 85       	ldd	r27, Z+8	; 0x08
     87c:	14 96       	adiw	r26, 0x04	; 4
     87e:	0d 90       	ld	r0, X+
     880:	bc 91       	ld	r27, X
     882:	a0 2d       	mov	r26, r0
     884:	14 96       	adiw	r26, 0x04	; 4
     886:	8c 91       	ld	r24, X
     888:	84 81       	ldd	r24, Z+4	; 0x04
     88a:	95 81       	ldd	r25, Z+5	; 0x05
     88c:	0f 90       	pop	r0
     88e:	0f 90       	pop	r0
     890:	df 91       	pop	r29
     892:	cf 91       	pop	r28
     894:	08 95       	ret

00000896 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     896:	ef 92       	push	r14
     898:	ff 92       	push	r15
     89a:	0f 93       	push	r16
     89c:	1f 93       	push	r17
     89e:	cf 93       	push	r28
     8a0:	df 93       	push	r29
     8a2:	8c 01       	movw	r16, r24
     8a4:	eb 01       	movw	r28, r22
     8a6:	e8 81       	ld	r30, Y
     8a8:	f9 81       	ldd	r31, Y+1	; 0x01
     8aa:	00 8c       	ldd	r0, Z+24	; 0x18
     8ac:	f1 8d       	ldd	r31, Z+25	; 0x19
     8ae:	e0 2d       	mov	r30, r0
     8b0:	cb 01       	movw	r24, r22
     8b2:	19 95       	eicall
     8b4:	88 23       	and	r24, r24
     8b6:	a9 f0       	breq	.+42     	; 0x8e2 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     8b8:	e8 81       	ld	r30, Y
     8ba:	f9 81       	ldd	r31, Y+1	; 0x01
     8bc:	02 84       	ldd	r0, Z+10	; 0x0a
     8be:	f3 85       	ldd	r31, Z+11	; 0x0b
     8c0:	e0 2d       	mov	r30, r0
     8c2:	e1 2c       	mov	r14, r1
     8c4:	f1 2c       	mov	r15, r1
     8c6:	b7 01       	movw	r22, r14
     8c8:	ce 01       	movw	r24, r28
     8ca:	19 95       	eicall
     8cc:	d8 01       	movw	r26, r16
     8ce:	17 96       	adiw	r26, 0x07	; 7
     8d0:	ed 91       	ld	r30, X+
     8d2:	fc 91       	ld	r31, X
     8d4:	18 97       	sbiw	r26, 0x08	; 8
     8d6:	04 80       	ldd	r0, Z+4	; 0x04
     8d8:	f5 81       	ldd	r31, Z+5	; 0x05
     8da:	e0 2d       	mov	r30, r0
     8dc:	d7 01       	movw	r26, r14
     8de:	8c 91       	ld	r24, X
     8e0:	87 83       	std	Z+7, r24	; 0x07
     8e2:	f8 01       	movw	r30, r16
     8e4:	82 81       	ldd	r24, Z+2	; 0x02
     8e6:	93 81       	ldd	r25, Z+3	; 0x03
     8e8:	df 91       	pop	r29
     8ea:	cf 91       	pop	r28
     8ec:	1f 91       	pop	r17
     8ee:	0f 91       	pop	r16
     8f0:	ff 90       	pop	r15
     8f2:	ef 90       	pop	r14
     8f4:	08 95       	ret

000008f6 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	1f 92       	push	r1
     900:	cd b7       	in	r28, 0x3d	; 61
     902:	de b7       	in	r29, 0x3e	; 62
     904:	8c 01       	movw	r16, r24
     906:	cb 01       	movw	r24, r22
     908:	d8 01       	movw	r26, r16
     90a:	17 96       	adiw	r26, 0x07	; 7
     90c:	ed 91       	ld	r30, X+
     90e:	fc 91       	ld	r31, X
     910:	18 97       	sbiw	r26, 0x08	; 8
     912:	04 80       	ldd	r0, Z+4	; 0x04
     914:	f5 81       	ldd	r31, Z+5	; 0x05
     916:	e0 2d       	mov	r30, r0
     918:	27 81       	ldd	r18, Z+7	; 0x07
     91a:	29 83       	std	Y+1, r18	; 0x01
     91c:	db 01       	movw	r26, r22
     91e:	ed 91       	ld	r30, X+
     920:	fc 91       	ld	r31, X
     922:	01 90       	ld	r0, Z+
     924:	f0 81       	ld	r31, Z
     926:	e0 2d       	mov	r30, r0
     928:	be 01       	movw	r22, r28
     92a:	6f 5f       	subi	r22, 0xFF	; 255
     92c:	7f 4f       	sbci	r23, 0xFF	; 255
     92e:	19 95       	eicall
     930:	f8 01       	movw	r30, r16
     932:	82 81       	ldd	r24, Z+2	; 0x02
     934:	93 81       	ldd	r25, Z+3	; 0x03
     936:	0f 90       	pop	r0
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	1f 91       	pop	r17
     93e:	0f 91       	pop	r16
     940:	08 95       	ret

00000942 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     942:	cf 93       	push	r28
     944:	df 93       	push	r29
     946:	ec 01       	movw	r28, r24
     948:	cb 01       	movw	r24, r22
     94a:	db 01       	movw	r26, r22
     94c:	ed 91       	ld	r30, X+
     94e:	fc 91       	ld	r31, X
     950:	04 88       	ldd	r0, Z+20	; 0x14
     952:	f5 89       	ldd	r31, Z+21	; 0x15
     954:	e0 2d       	mov	r30, r0
     956:	19 95       	eicall
     958:	88 23       	and	r24, r24
     95a:	19 f0       	breq	.+6      	; 0x962 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     95c:	8a 81       	ldd	r24, Y+2	; 0x02
     95e:	9b 81       	ldd	r25, Y+3	; 0x03
     960:	02 c0       	rjmp	.+4      	; 0x966 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     962:	8c 81       	ldd	r24, Y+4	; 0x04
     964:	9d 81       	ldd	r25, Y+5	; 0x05
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN9I2CMaster9DoneState7executeER6Packet>:
     96c:	fc 01       	movw	r30, r24
     96e:	82 81       	ldd	r24, Z+2	; 0x02
     970:	93 81       	ldd	r25, Z+3	; 0x03
     972:	08 95       	ret

00000974 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     974:	fc 01       	movw	r30, r24
     976:	82 81       	ldd	r24, Z+2	; 0x02
     978:	93 81       	ldd	r25, Z+3	; 0x03
     97a:	08 95       	ret

0000097c <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	dc 01       	movw	r26, r24
     982:	17 96       	adiw	r26, 0x07	; 7
     984:	ed 91       	ld	r30, X+
     986:	fc 91       	ld	r31, X
     988:	18 97       	sbiw	r26, 0x08	; 8
     98a:	c6 81       	ldd	r28, Z+6	; 0x06
     98c:	d7 81       	ldd	r29, Z+7	; 0x07
     98e:	64 e1       	ldi	r22, 0x14	; 20
     990:	70 e2       	ldi	r23, 0x20	; 32
     992:	ce 01       	movw	r24, r28
     994:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     998:	66 e0       	ldi	r22, 0x06	; 6
     99a:	ce 01       	movw	r24, r28
     99c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     9a0:	df 91       	pop	r29
     9a2:	cf 91       	pop	r28
     9a4:	08 95       	ret

000009a6 <_ZN9I2CMaster9DoneState11serialDebugEv>:
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	dc 01       	movw	r26, r24
     9ac:	17 96       	adiw	r26, 0x07	; 7
     9ae:	ed 91       	ld	r30, X+
     9b0:	fc 91       	ld	r31, X
     9b2:	18 97       	sbiw	r26, 0x08	; 8
     9b4:	c6 81       	ldd	r28, Z+6	; 0x06
     9b6:	d7 81       	ldd	r29, Z+7	; 0x07
     9b8:	6a e1       	ldi	r22, 0x1A	; 26
     9ba:	70 e2       	ldi	r23, 0x20	; 32
     9bc:	ce 01       	movw	r24, r28
     9be:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     9c2:	66 e0       	ldi	r22, 0x06	; 6
     9c4:	ce 01       	movw	r24, r28
     9c6:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	08 95       	ret

000009d0 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     9d0:	cf 93       	push	r28
     9d2:	df 93       	push	r29
     9d4:	dc 01       	movw	r26, r24
     9d6:	17 96       	adiw	r26, 0x07	; 7
     9d8:	ed 91       	ld	r30, X+
     9da:	fc 91       	ld	r31, X
     9dc:	18 97       	sbiw	r26, 0x08	; 8
     9de:	c6 81       	ldd	r28, Z+6	; 0x06
     9e0:	d7 81       	ldd	r29, Z+7	; 0x07
     9e2:	6f e1       	ldi	r22, 0x1F	; 31
     9e4:	70 e2       	ldi	r23, 0x20	; 32
     9e6:	ce 01       	movw	r24, r28
     9e8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     9ec:	66 e0       	ldi	r22, 0x06	; 6
     9ee:	ce 01       	movw	r24, r28
     9f0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	08 95       	ret

000009fa <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
     9fe:	dc 01       	movw	r26, r24
     a00:	17 96       	adiw	r26, 0x07	; 7
     a02:	ed 91       	ld	r30, X+
     a04:	fc 91       	ld	r31, X
     a06:	18 97       	sbiw	r26, 0x08	; 8
     a08:	c6 81       	ldd	r28, Z+6	; 0x06
     a0a:	d7 81       	ldd	r29, Z+7	; 0x07
     a0c:	68 e2       	ldi	r22, 0x28	; 40
     a0e:	70 e2       	ldi	r23, 0x20	; 32
     a10:	ce 01       	movw	r24, r28
     a12:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     a16:	66 e0       	ldi	r22, 0x06	; 6
     a18:	ce 01       	movw	r24, r28
     a1a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     a1e:	df 91       	pop	r29
     a20:	cf 91       	pop	r28
     a22:	08 95       	ret

00000a24 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	dc 01       	movw	r26, r24
     a2a:	17 96       	adiw	r26, 0x07	; 7
     a2c:	ed 91       	ld	r30, X+
     a2e:	fc 91       	ld	r31, X
     a30:	18 97       	sbiw	r26, 0x08	; 8
     a32:	c6 81       	ldd	r28, Z+6	; 0x06
     a34:	d7 81       	ldd	r29, Z+7	; 0x07
     a36:	61 e3       	ldi	r22, 0x31	; 49
     a38:	70 e2       	ldi	r23, 0x20	; 32
     a3a:	ce 01       	movw	r24, r28
     a3c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     a40:	66 e0       	ldi	r22, 0x06	; 6
     a42:	ce 01       	movw	r24, r28
     a44:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	08 95       	ret

00000a4e <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	dc 01       	movw	r26, r24
     a54:	17 96       	adiw	r26, 0x07	; 7
     a56:	ed 91       	ld	r30, X+
     a58:	fc 91       	ld	r31, X
     a5a:	18 97       	sbiw	r26, 0x08	; 8
     a5c:	c6 81       	ldd	r28, Z+6	; 0x06
     a5e:	d7 81       	ldd	r29, Z+7	; 0x07
     a60:	6c e3       	ldi	r22, 0x3C	; 60
     a62:	70 e2       	ldi	r23, 0x20	; 32
     a64:	ce 01       	movw	r24, r28
     a66:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     a6a:	66 e0       	ldi	r22, 0x06	; 6
     a6c:	ce 01       	movw	r24, r28
     a6e:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	08 95       	ret

00000a78 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     a78:	cf 93       	push	r28
     a7a:	df 93       	push	r29
     a7c:	dc 01       	movw	r26, r24
     a7e:	17 96       	adiw	r26, 0x07	; 7
     a80:	ed 91       	ld	r30, X+
     a82:	fc 91       	ld	r31, X
     a84:	18 97       	sbiw	r26, 0x08	; 8
     a86:	c6 81       	ldd	r28, Z+6	; 0x06
     a88:	d7 81       	ldd	r29, Z+7	; 0x07
     a8a:	67 e4       	ldi	r22, 0x47	; 71
     a8c:	70 e2       	ldi	r23, 0x20	; 32
     a8e:	ce 01       	movw	r24, r28
     a90:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     a94:	66 e0       	ldi	r22, 0x06	; 6
     a96:	ce 01       	movw	r24, r28
     a98:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     a9c:	df 91       	pop	r29
     a9e:	cf 91       	pop	r28
     aa0:	08 95       	ret

00000aa2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	dc 01       	movw	r26, r24
     aa8:	17 96       	adiw	r26, 0x07	; 7
     aaa:	ed 91       	ld	r30, X+
     aac:	fc 91       	ld	r31, X
     aae:	18 97       	sbiw	r26, 0x08	; 8
     ab0:	c6 81       	ldd	r28, Z+6	; 0x06
     ab2:	d7 81       	ldd	r29, Z+7	; 0x07
     ab4:	60 e5       	ldi	r22, 0x50	; 80
     ab6:	70 e2       	ldi	r23, 0x20	; 32
     ab8:	ce 01       	movw	r24, r28
     aba:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     abe:	66 e0       	ldi	r22, 0x06	; 6
     ac0:	ce 01       	movw	r24, r28
     ac2:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     ac6:	df 91       	pop	r29
     ac8:	cf 91       	pop	r28
     aca:	08 95       	ret

00000acc <_ZN9I2CMaster10StartState11serialDebugEv>:
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	dc 01       	movw	r26, r24
     ad2:	17 96       	adiw	r26, 0x07	; 7
     ad4:	ed 91       	ld	r30, X+
     ad6:	fc 91       	ld	r31, X
     ad8:	18 97       	sbiw	r26, 0x08	; 8
     ada:	c6 81       	ldd	r28, Z+6	; 0x06
     adc:	d7 81       	ldd	r29, Z+7	; 0x07
     ade:	69 e5       	ldi	r22, 0x59	; 89
     ae0:	70 e2       	ldi	r23, 0x20	; 32
     ae2:	ce 01       	movw	r24, r28
     ae4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
     ae8:	66 e0       	ldi	r22, 0x06	; 6
     aea:	ce 01       	movw	r24, r28
     aec:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
     af0:	df 91       	pop	r29
     af2:	cf 91       	pop	r28
     af4:	08 95       	ret

00000af6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     af6:	0f 93       	push	r16
     af8:	1f 93       	push	r17
     afa:	cf 93       	push	r28
     afc:	df 93       	push	r29
     afe:	8c 01       	movw	r16, r24
     b00:	eb 01       	movw	r28, r22
     b02:	e8 81       	ld	r30, Y
     b04:	f9 81       	ldd	r31, Y+1	; 0x01
     b06:	04 8c       	ldd	r0, Z+28	; 0x1c
     b08:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b0a:	e0 2d       	mov	r30, r0
     b0c:	cb 01       	movw	r24, r22
     b0e:	19 95       	eicall
     b10:	2a 85       	ldd	r18, Y+10	; 0x0a
     b12:	30 e0       	ldi	r19, 0x00	; 0
     b14:	82 17       	cp	r24, r18
     b16:	93 07       	cpc	r25, r19
     b18:	79 f4       	brne	.+30     	; 0xb38 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     b1a:	d8 01       	movw	r26, r16
     b1c:	17 96       	adiw	r26, 0x07	; 7
     b1e:	ed 91       	ld	r30, X+
     b20:	fc 91       	ld	r31, X
     b22:	18 97       	sbiw	r26, 0x08	; 8
     b24:	04 80       	ldd	r0, Z+4	; 0x04
     b26:	f5 81       	ldd	r31, Z+5	; 0x05
     b28:	e0 2d       	mov	r30, r0
     b2a:	87 e0       	ldi	r24, 0x07	; 7
     b2c:	83 83       	std	Z+3, r24	; 0x03
     b2e:	12 96       	adiw	r26, 0x02	; 2
     b30:	8d 91       	ld	r24, X+
     b32:	9c 91       	ld	r25, X
     b34:	13 97       	sbiw	r26, 0x03	; 3
     b36:	0e c0       	rjmp	.+28     	; 0xb54 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     b38:	d8 01       	movw	r26, r16
     b3a:	17 96       	adiw	r26, 0x07	; 7
     b3c:	ed 91       	ld	r30, X+
     b3e:	fc 91       	ld	r31, X
     b40:	18 97       	sbiw	r26, 0x08	; 8
     b42:	04 80       	ldd	r0, Z+4	; 0x04
     b44:	f5 81       	ldd	r31, Z+5	; 0x05
     b46:	e0 2d       	mov	r30, r0
     b48:	82 e0       	ldi	r24, 0x02	; 2
     b4a:	83 83       	std	Z+3, r24	; 0x03
     b4c:	14 96       	adiw	r26, 0x04	; 4
     b4e:	8d 91       	ld	r24, X+
     b50:	9c 91       	ld	r25, X
     b52:	15 97       	sbiw	r26, 0x05	; 5
     b54:	df 91       	pop	r29
     b56:	cf 91       	pop	r28
     b58:	1f 91       	pop	r17
     b5a:	0f 91       	pop	r16
     b5c:	08 95       	ret

00000b5e <_ZN9I2CMaster11TransmitterC1EPS_>:
     b5e:	0f 93       	push	r16
     b60:	1f 93       	push	r17
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
     b66:	ec 01       	movw	r28, r24
     b68:	8b 01       	movw	r16, r22
     b6a:	68 83       	st	Y, r22
     b6c:	79 83       	std	Y+1, r23	; 0x01
     b6e:	89 e0       	ldi	r24, 0x09	; 9
     b70:	90 e0       	ldi	r25, 0x00	; 0
     b72:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     b76:	fc 01       	movw	r30, r24
     b78:	16 82       	std	Z+6, r1	; 0x06
     b7a:	83 e6       	ldi	r24, 0x63	; 99
     b7c:	90 e2       	ldi	r25, 0x20	; 32
     b7e:	80 83       	st	Z, r24
     b80:	91 83       	std	Z+1, r25	; 0x01
     b82:	07 83       	std	Z+7, r16	; 0x07
     b84:	10 87       	std	Z+8, r17	; 0x08
     b86:	ec 83       	std	Y+4, r30	; 0x04
     b88:	fd 83       	std	Y+5, r31	; 0x05
     b8a:	8b e0       	ldi	r24, 0x0B	; 11
     b8c:	90 e0       	ldi	r25, 0x00	; 0
     b8e:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     b92:	fc 01       	movw	r30, r24
     b94:	8b 89       	ldd	r24, Y+19	; 0x13
     b96:	9c 89       	ldd	r25, Y+20	; 0x14
     b98:	16 82       	std	Z+6, r1	; 0x06
     b9a:	2b e6       	ldi	r18, 0x6B	; 107
     b9c:	30 e2       	ldi	r19, 0x20	; 32
     b9e:	20 83       	st	Z, r18
     ba0:	31 83       	std	Z+1, r19	; 0x01
     ba2:	07 83       	std	Z+7, r16	; 0x07
     ba4:	10 87       	std	Z+8, r17	; 0x08
     ba6:	81 87       	std	Z+9, r24	; 0x09
     ba8:	92 87       	std	Z+10, r25	; 0x0a
     baa:	ee 83       	std	Y+6, r30	; 0x06
     bac:	ff 83       	std	Y+7, r31	; 0x07
     bae:	89 e0       	ldi	r24, 0x09	; 9
     bb0:	90 e0       	ldi	r25, 0x00	; 0
     bb2:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     bb6:	fc 01       	movw	r30, r24
     bb8:	16 82       	std	Z+6, r1	; 0x06
     bba:	8b e7       	ldi	r24, 0x7B	; 123
     bbc:	90 e2       	ldi	r25, 0x20	; 32
     bbe:	80 83       	st	Z, r24
     bc0:	91 83       	std	Z+1, r25	; 0x01
     bc2:	07 83       	std	Z+7, r16	; 0x07
     bc4:	10 87       	std	Z+8, r17	; 0x08
     bc6:	e8 87       	std	Y+8, r30	; 0x08
     bc8:	f9 87       	std	Y+9, r31	; 0x09
     bca:	89 e0       	ldi	r24, 0x09	; 9
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     bd2:	fc 01       	movw	r30, r24
     bd4:	16 82       	std	Z+6, r1	; 0x06
     bd6:	8b e8       	ldi	r24, 0x8B	; 139
     bd8:	90 e2       	ldi	r25, 0x20	; 32
     bda:	80 83       	st	Z, r24
     bdc:	91 83       	std	Z+1, r25	; 0x01
     bde:	07 83       	std	Z+7, r16	; 0x07
     be0:	10 87       	std	Z+8, r17	; 0x08
     be2:	ea 87       	std	Y+10, r30	; 0x0a
     be4:	fb 87       	std	Y+11, r31	; 0x0b
     be6:	89 e0       	ldi	r24, 0x09	; 9
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     bee:	fc 01       	movw	r30, r24
     bf0:	16 82       	std	Z+6, r1	; 0x06
     bf2:	83 ea       	ldi	r24, 0xA3	; 163
     bf4:	90 e2       	ldi	r25, 0x20	; 32
     bf6:	80 83       	st	Z, r24
     bf8:	91 83       	std	Z+1, r25	; 0x01
     bfa:	07 83       	std	Z+7, r16	; 0x07
     bfc:	10 87       	std	Z+8, r17	; 0x08
     bfe:	ec 87       	std	Y+12, r30	; 0x0c
     c00:	fd 87       	std	Y+13, r31	; 0x0d
     c02:	89 e0       	ldi	r24, 0x09	; 9
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     c0a:	fc 01       	movw	r30, r24
     c0c:	16 82       	std	Z+6, r1	; 0x06
     c0e:	8b e9       	ldi	r24, 0x9B	; 155
     c10:	90 e2       	ldi	r25, 0x20	; 32
     c12:	80 83       	st	Z, r24
     c14:	91 83       	std	Z+1, r25	; 0x01
     c16:	07 83       	std	Z+7, r16	; 0x07
     c18:	10 87       	std	Z+8, r17	; 0x08
     c1a:	ee 87       	std	Y+14, r30	; 0x0e
     c1c:	ff 87       	std	Y+15, r31	; 0x0f
     c1e:	80 e1       	ldi	r24, 0x10	; 16
     c20:	97 e2       	ldi	r25, 0x27	; 39
     c22:	8b 8b       	std	Y+19, r24	; 0x13
     c24:	9c 8b       	std	Y+20, r25	; 0x14
     c26:	8e 81       	ldd	r24, Y+6	; 0x06
     c28:	9f 81       	ldd	r25, Y+7	; 0x07
     c2a:	ec 81       	ldd	r30, Y+4	; 0x04
     c2c:	fd 81       	ldd	r31, Y+5	; 0x05
     c2e:	82 83       	std	Z+2, r24	; 0x02
     c30:	93 83       	std	Z+3, r25	; 0x03
     c32:	84 83       	std	Z+4, r24	; 0x04
     c34:	95 83       	std	Z+5, r25	; 0x05
     c36:	8c 85       	ldd	r24, Y+12	; 0x0c
     c38:	9d 85       	ldd	r25, Y+13	; 0x0d
     c3a:	28 85       	ldd	r18, Y+8	; 0x08
     c3c:	39 85       	ldd	r19, Y+9	; 0x09
     c3e:	ee 81       	ldd	r30, Y+6	; 0x06
     c40:	ff 81       	ldd	r31, Y+7	; 0x07
     c42:	22 83       	std	Z+2, r18	; 0x02
     c44:	33 83       	std	Z+3, r19	; 0x03
     c46:	84 83       	std	Z+4, r24	; 0x04
     c48:	95 83       	std	Z+5, r25	; 0x05
     c4a:	8a 85       	ldd	r24, Y+10	; 0x0a
     c4c:	9b 85       	ldd	r25, Y+11	; 0x0b
     c4e:	e8 85       	ldd	r30, Y+8	; 0x08
     c50:	f9 85       	ldd	r31, Y+9	; 0x09
     c52:	82 83       	std	Z+2, r24	; 0x02
     c54:	93 83       	std	Z+3, r25	; 0x03
     c56:	84 83       	std	Z+4, r24	; 0x04
     c58:	95 83       	std	Z+5, r25	; 0x05
     c5a:	8e 81       	ldd	r24, Y+6	; 0x06
     c5c:	9f 81       	ldd	r25, Y+7	; 0x07
     c5e:	2e 85       	ldd	r18, Y+14	; 0x0e
     c60:	3f 85       	ldd	r19, Y+15	; 0x0f
     c62:	ea 85       	ldd	r30, Y+10	; 0x0a
     c64:	fb 85       	ldd	r31, Y+11	; 0x0b
     c66:	22 83       	std	Z+2, r18	; 0x02
     c68:	33 83       	std	Z+3, r19	; 0x03
     c6a:	84 83       	std	Z+4, r24	; 0x04
     c6c:	95 83       	std	Z+5, r25	; 0x05
     c6e:	df 91       	pop	r29
     c70:	cf 91       	pop	r28
     c72:	1f 91       	pop	r17
     c74:	0f 91       	pop	r16
     c76:	08 95       	ret

00000c78 <_ZN9I2CMaster8ReceiverC1EPS_>:
     c78:	0f 93       	push	r16
     c7a:	1f 93       	push	r17
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	ec 01       	movw	r28, r24
     c82:	8b 01       	movw	r16, r22
     c84:	68 83       	st	Y, r22
     c86:	79 83       	std	Y+1, r23	; 0x01
     c88:	89 e0       	ldi	r24, 0x09	; 9
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     c90:	fc 01       	movw	r30, r24
     c92:	16 82       	std	Z+6, r1	; 0x06
     c94:	83 e6       	ldi	r24, 0x63	; 99
     c96:	90 e2       	ldi	r25, 0x20	; 32
     c98:	80 83       	st	Z, r24
     c9a:	91 83       	std	Z+1, r25	; 0x01
     c9c:	07 83       	std	Z+7, r16	; 0x07
     c9e:	10 87       	std	Z+8, r17	; 0x08
     ca0:	ec 83       	std	Y+4, r30	; 0x04
     ca2:	fd 83       	std	Y+5, r31	; 0x05
     ca4:	8b e0       	ldi	r24, 0x0B	; 11
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     cac:	fc 01       	movw	r30, r24
     cae:	8b 89       	ldd	r24, Y+19	; 0x13
     cb0:	9c 89       	ldd	r25, Y+20	; 0x14
     cb2:	16 82       	std	Z+6, r1	; 0x06
     cb4:	23 e7       	ldi	r18, 0x73	; 115
     cb6:	30 e2       	ldi	r19, 0x20	; 32
     cb8:	20 83       	st	Z, r18
     cba:	31 83       	std	Z+1, r19	; 0x01
     cbc:	07 83       	std	Z+7, r16	; 0x07
     cbe:	10 87       	std	Z+8, r17	; 0x08
     cc0:	81 87       	std	Z+9, r24	; 0x09
     cc2:	92 87       	std	Z+10, r25	; 0x0a
     cc4:	ee 83       	std	Y+6, r30	; 0x06
     cc6:	ff 83       	std	Y+7, r31	; 0x07
     cc8:	89 e0       	ldi	r24, 0x09	; 9
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     cd0:	fc 01       	movw	r30, r24
     cd2:	16 82       	std	Z+6, r1	; 0x06
     cd4:	83 e8       	ldi	r24, 0x83	; 131
     cd6:	90 e2       	ldi	r25, 0x20	; 32
     cd8:	80 83       	st	Z, r24
     cda:	91 83       	std	Z+1, r25	; 0x01
     cdc:	07 83       	std	Z+7, r16	; 0x07
     cde:	10 87       	std	Z+8, r17	; 0x08
     ce0:	e8 87       	std	Y+8, r30	; 0x08
     ce2:	f9 87       	std	Y+9, r31	; 0x09
     ce4:	89 e0       	ldi	r24, 0x09	; 9
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     cec:	fc 01       	movw	r30, r24
     cee:	16 82       	std	Z+6, r1	; 0x06
     cf0:	83 e9       	ldi	r24, 0x93	; 147
     cf2:	90 e2       	ldi	r25, 0x20	; 32
     cf4:	80 83       	st	Z, r24
     cf6:	91 83       	std	Z+1, r25	; 0x01
     cf8:	07 83       	std	Z+7, r16	; 0x07
     cfa:	10 87       	std	Z+8, r17	; 0x08
     cfc:	ea 87       	std	Y+10, r30	; 0x0a
     cfe:	fb 87       	std	Y+11, r31	; 0x0b
     d00:	89 e0       	ldi	r24, 0x09	; 9
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     d08:	fc 01       	movw	r30, r24
     d0a:	16 82       	std	Z+6, r1	; 0x06
     d0c:	83 ea       	ldi	r24, 0xA3	; 163
     d0e:	90 e2       	ldi	r25, 0x20	; 32
     d10:	80 83       	st	Z, r24
     d12:	91 83       	std	Z+1, r25	; 0x01
     d14:	07 83       	std	Z+7, r16	; 0x07
     d16:	10 87       	std	Z+8, r17	; 0x08
     d18:	ec 87       	std	Y+12, r30	; 0x0c
     d1a:	fd 87       	std	Y+13, r31	; 0x0d
     d1c:	89 e0       	ldi	r24, 0x09	; 9
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     d24:	fc 01       	movw	r30, r24
     d26:	16 82       	std	Z+6, r1	; 0x06
     d28:	8b e9       	ldi	r24, 0x9B	; 155
     d2a:	90 e2       	ldi	r25, 0x20	; 32
     d2c:	80 83       	st	Z, r24
     d2e:	91 83       	std	Z+1, r25	; 0x01
     d30:	07 83       	std	Z+7, r16	; 0x07
     d32:	10 87       	std	Z+8, r17	; 0x08
     d34:	ee 87       	std	Y+14, r30	; 0x0e
     d36:	ff 87       	std	Y+15, r31	; 0x0f
     d38:	80 e1       	ldi	r24, 0x10	; 16
     d3a:	97 e2       	ldi	r25, 0x27	; 39
     d3c:	8b 8b       	std	Y+19, r24	; 0x13
     d3e:	9c 8b       	std	Y+20, r25	; 0x14
     d40:	8e 81       	ldd	r24, Y+6	; 0x06
     d42:	9f 81       	ldd	r25, Y+7	; 0x07
     d44:	ec 81       	ldd	r30, Y+4	; 0x04
     d46:	fd 81       	ldd	r31, Y+5	; 0x05
     d48:	82 83       	std	Z+2, r24	; 0x02
     d4a:	93 83       	std	Z+3, r25	; 0x03
     d4c:	84 83       	std	Z+4, r24	; 0x04
     d4e:	95 83       	std	Z+5, r25	; 0x05
     d50:	8c 85       	ldd	r24, Y+12	; 0x0c
     d52:	9d 85       	ldd	r25, Y+13	; 0x0d
     d54:	28 85       	ldd	r18, Y+8	; 0x08
     d56:	39 85       	ldd	r19, Y+9	; 0x09
     d58:	ee 81       	ldd	r30, Y+6	; 0x06
     d5a:	ff 81       	ldd	r31, Y+7	; 0x07
     d5c:	22 83       	std	Z+2, r18	; 0x02
     d5e:	33 83       	std	Z+3, r19	; 0x03
     d60:	84 83       	std	Z+4, r24	; 0x04
     d62:	95 83       	std	Z+5, r25	; 0x05
     d64:	8a 85       	ldd	r24, Y+10	; 0x0a
     d66:	9b 85       	ldd	r25, Y+11	; 0x0b
     d68:	e8 85       	ldd	r30, Y+8	; 0x08
     d6a:	f9 85       	ldd	r31, Y+9	; 0x09
     d6c:	82 83       	std	Z+2, r24	; 0x02
     d6e:	93 83       	std	Z+3, r25	; 0x03
     d70:	84 83       	std	Z+4, r24	; 0x04
     d72:	95 83       	std	Z+5, r25	; 0x05
     d74:	8e 81       	ldd	r24, Y+6	; 0x06
     d76:	9f 81       	ldd	r25, Y+7	; 0x07
     d78:	2e 85       	ldd	r18, Y+14	; 0x0e
     d7a:	3f 85       	ldd	r19, Y+15	; 0x0f
     d7c:	ea 85       	ldd	r30, Y+10	; 0x0a
     d7e:	fb 85       	ldd	r31, Y+11	; 0x0b
     d80:	22 83       	std	Z+2, r18	; 0x02
     d82:	33 83       	std	Z+3, r19	; 0x03
     d84:	84 83       	std	Z+4, r24	; 0x04
     d86:	95 83       	std	Z+5, r25	; 0x05
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	1f 91       	pop	r17
     d8e:	0f 91       	pop	r16
     d90:	08 95       	ret

00000d92 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     d92:	ef 92       	push	r14
     d94:	ff 92       	push	r15
     d96:	0f 93       	push	r16
     d98:	1f 93       	push	r17
     d9a:	cf 93       	push	r28
     d9c:	df 93       	push	r29
     d9e:	ec 01       	movw	r28, r24
     da0:	7b 01       	movw	r14, r22
     da2:	8c 81       	ldd	r24, Y+4	; 0x04
     da4:	9d 81       	ldd	r25, Y+5	; 0x05
     da6:	8a 83       	std	Y+2, r24	; 0x02
     da8:	9b 83       	std	Y+3, r25	; 0x03
     daa:	8a 81       	ldd	r24, Y+2	; 0x02
     dac:	9b 81       	ldd	r25, Y+3	; 0x03
     dae:	2e 85       	ldd	r18, Y+14	; 0x0e
     db0:	3f 85       	ldd	r19, Y+15	; 0x0f
     db2:	82 17       	cp	r24, r18
     db4:	93 07       	cpc	r25, r19
     db6:	29 f4       	brne	.+10     	; 0xdc2 <_ZN9I2CMaster11Transmitter3runER6Packet+0x30>
     db8:	ac 85       	ldd	r26, Y+12	; 0x0c
     dba:	bd 85       	ldd	r27, Y+13	; 0x0d
     dbc:	8a 17       	cp	r24, r26
     dbe:	9b 07       	cpc	r25, r27
     dc0:	a9 f0       	breq	.+42     	; 0xdec <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     dc2:	dc 01       	movw	r26, r24
     dc4:	ed 91       	ld	r30, X+
     dc6:	fc 91       	ld	r31, X
     dc8:	01 90       	ld	r0, Z+
     dca:	f0 81       	ld	r31, Z
     dcc:	e0 2d       	mov	r30, r0
     dce:	b7 01       	movw	r22, r14
     dd0:	19 95       	eicall
     dd2:	8c 01       	movw	r16, r24
     dd4:	8a 81       	ldd	r24, Y+2	; 0x02
     dd6:	9b 81       	ldd	r25, Y+3	; 0x03
     dd8:	dc 01       	movw	r26, r24
     dda:	ed 91       	ld	r30, X+
     ddc:	fc 91       	ld	r31, X
     dde:	02 80       	ldd	r0, Z+2	; 0x02
     de0:	f3 81       	ldd	r31, Z+3	; 0x03
     de2:	e0 2d       	mov	r30, r0
     de4:	19 95       	eicall
     de6:	0a 83       	std	Y+2, r16	; 0x02
     de8:	1b 83       	std	Y+3, r17	; 0x03
     dea:	df cf       	rjmp	.-66     	; 0xdaa <_ZN9I2CMaster11Transmitter3runER6Packet+0x18>
     dec:	ed 91       	ld	r30, X+
     dee:	fc 91       	ld	r31, X
     df0:	11 97       	sbiw	r26, 0x01	; 1
     df2:	02 80       	ldd	r0, Z+2	; 0x02
     df4:	f3 81       	ldd	r31, Z+3	; 0x03
     df6:	e0 2d       	mov	r30, r0
     df8:	cd 01       	movw	r24, r26
     dfa:	19 95       	eicall
     dfc:	81 e0       	ldi	r24, 0x01	; 1
     dfe:	4a 81       	ldd	r20, Y+2	; 0x02
     e00:	5b 81       	ldd	r21, Y+3	; 0x03
     e02:	2e 85       	ldd	r18, Y+14	; 0x0e
     e04:	3f 85       	ldd	r19, Y+15	; 0x0f
     e06:	42 17       	cp	r20, r18
     e08:	53 07       	cpc	r21, r19
     e0a:	09 f0       	breq	.+2      	; 0xe0e <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	ff 90       	pop	r15
     e18:	ef 90       	pop	r14
     e1a:	08 95       	ret

00000e1c <_ZN9I2CMaster8Receiver3runER6Packet>:
     e1c:	ef 92       	push	r14
     e1e:	ff 92       	push	r15
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	cf 93       	push	r28
     e26:	df 93       	push	r29
     e28:	ec 01       	movw	r28, r24
     e2a:	7b 01       	movw	r14, r22
     e2c:	8c 81       	ldd	r24, Y+4	; 0x04
     e2e:	9d 81       	ldd	r25, Y+5	; 0x05
     e30:	8a 83       	std	Y+2, r24	; 0x02
     e32:	9b 83       	std	Y+3, r25	; 0x03
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	9b 81       	ldd	r25, Y+3	; 0x03
     e38:	2e 85       	ldd	r18, Y+14	; 0x0e
     e3a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e3c:	82 17       	cp	r24, r18
     e3e:	93 07       	cpc	r25, r19
     e40:	29 f4       	brne	.+10     	; 0xe4c <_ZN9I2CMaster8Receiver3runER6Packet+0x30>
     e42:	ac 85       	ldd	r26, Y+12	; 0x0c
     e44:	bd 85       	ldd	r27, Y+13	; 0x0d
     e46:	8a 17       	cp	r24, r26
     e48:	9b 07       	cpc	r25, r27
     e4a:	a9 f0       	breq	.+42     	; 0xe76 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     e4c:	dc 01       	movw	r26, r24
     e4e:	ed 91       	ld	r30, X+
     e50:	fc 91       	ld	r31, X
     e52:	01 90       	ld	r0, Z+
     e54:	f0 81       	ld	r31, Z
     e56:	e0 2d       	mov	r30, r0
     e58:	b7 01       	movw	r22, r14
     e5a:	19 95       	eicall
     e5c:	8c 01       	movw	r16, r24
     e5e:	8a 81       	ldd	r24, Y+2	; 0x02
     e60:	9b 81       	ldd	r25, Y+3	; 0x03
     e62:	dc 01       	movw	r26, r24
     e64:	ed 91       	ld	r30, X+
     e66:	fc 91       	ld	r31, X
     e68:	02 80       	ldd	r0, Z+2	; 0x02
     e6a:	f3 81       	ldd	r31, Z+3	; 0x03
     e6c:	e0 2d       	mov	r30, r0
     e6e:	19 95       	eicall
     e70:	0a 83       	std	Y+2, r16	; 0x02
     e72:	1b 83       	std	Y+3, r17	; 0x03
     e74:	df cf       	rjmp	.-66     	; 0xe34 <_ZN9I2CMaster8Receiver3runER6Packet+0x18>
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	11 97       	sbiw	r26, 0x01	; 1
     e7c:	02 80       	ldd	r0, Z+2	; 0x02
     e7e:	f3 81       	ldd	r31, Z+3	; 0x03
     e80:	e0 2d       	mov	r30, r0
     e82:	cd 01       	movw	r24, r26
     e84:	19 95       	eicall
     e86:	c7 01       	movw	r24, r14
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	1f 91       	pop	r17
     e8e:	0f 91       	pop	r16
     e90:	ff 90       	pop	r15
     e92:	ef 90       	pop	r14
     e94:	08 95       	ret

00000e96 <_ZN9I2CMaster12set_baudrateEm>:
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	ec 01       	movw	r28, r24
     e9c:	9a 01       	movw	r18, r20
     e9e:	ab 01       	movw	r20, r22
     ea0:	22 0f       	add	r18, r18
     ea2:	33 1f       	adc	r19, r19
     ea4:	44 1f       	adc	r20, r20
     ea6:	55 1f       	adc	r21, r21
     ea8:	60 e0       	ldi	r22, 0x00	; 0
     eaa:	78 e4       	ldi	r23, 0x48	; 72
     eac:	88 ee       	ldi	r24, 0xE8	; 232
     eae:	91 e0       	ldi	r25, 0x01	; 1
     eb0:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
     eb4:	25 50       	subi	r18, 0x05	; 5
     eb6:	2a 87       	std	Y+10, r18	; 0x0a
     eb8:	ec 81       	ldd	r30, Y+4	; 0x04
     eba:	fd 81       	ldd	r31, Y+5	; 0x05
     ebc:	25 83       	std	Z+5, r18	; 0x05
     ebe:	df 91       	pop	r29
     ec0:	cf 91       	pop	r28
     ec2:	08 95       	ret

00000ec4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
     ec4:	8f 92       	push	r8
     ec6:	9f 92       	push	r9
     ec8:	af 92       	push	r10
     eca:	bf 92       	push	r11
     ecc:	cf 92       	push	r12
     ece:	df 92       	push	r13
     ed0:	ef 92       	push	r14
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	1f 93       	push	r17
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	ec 01       	movw	r28, r24
     ede:	7b 01       	movw	r14, r22
     ee0:	49 01       	movw	r8, r18
     ee2:	5a 01       	movw	r10, r20
     ee4:	85 e1       	ldi	r24, 0x15	; 21
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     eec:	6c 01       	movw	r12, r24
     eee:	be 01       	movw	r22, r28
     ef0:	0e 94 af 05 	call	0xb5e	; 0xb5e <_ZN9I2CMaster11TransmitterC1EPS_>
     ef4:	c8 82       	st	Y, r12
     ef6:	d9 82       	std	Y+1, r13	; 0x01
     ef8:	86 e1       	ldi	r24, 0x16	; 22
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
     f00:	6c 01       	movw	r12, r24
     f02:	be 01       	movw	r22, r28
     f04:	0e 94 3c 06 	call	0xc78	; 0xc78 <_ZN9I2CMaster8ReceiverC1EPS_>
     f08:	ca 82       	std	Y+2, r12	; 0x02
     f0a:	db 82       	std	Y+3, r13	; 0x03
     f0c:	ec 82       	std	Y+4, r14	; 0x04
     f0e:	fd 82       	std	Y+5, r15	; 0x05
     f10:	0e 83       	std	Y+6, r16	; 0x06
     f12:	1f 83       	std	Y+7, r17	; 0x07
     f14:	8b 86       	std	Y+11, r8	; 0x0b
     f16:	9c 86       	std	Y+12, r9	; 0x0c
     f18:	ad 86       	std	Y+13, r10	; 0x0d
     f1a:	be 86       	std	Y+14, r11	; 0x0e
     f1c:	80 e8       	ldi	r24, 0x80	; 128
     f1e:	e8 16       	cp	r14, r24
     f20:	84 e0       	ldi	r24, 0x04	; 4
     f22:	f8 06       	cpc	r15, r24
     f24:	29 f4       	brne	.+10     	; 0xf30 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x6c>
     f26:	80 e4       	ldi	r24, 0x40	; 64
     f28:	96 e0       	ldi	r25, 0x06	; 6
     f2a:	88 87       	std	Y+8, r24	; 0x08
     f2c:	99 87       	std	Y+9, r25	; 0x09
     f2e:	09 c0       	rjmp	.+18     	; 0xf42 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x7e>
     f30:	e0 ea       	ldi	r30, 0xA0	; 160
     f32:	ee 16       	cp	r14, r30
     f34:	e4 e0       	ldi	r30, 0x04	; 4
     f36:	fe 06       	cpc	r15, r30
     f38:	21 f4       	brne	.+8      	; 0xf42 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x7e>
     f3a:	80 e8       	ldi	r24, 0x80	; 128
     f3c:	96 e0       	ldi	r25, 0x06	; 6
     f3e:	88 87       	std	Y+8, r24	; 0x08
     f40:	99 87       	std	Y+9, r25	; 0x09
     f42:	e8 85       	ldd	r30, Y+8	; 0x08
     f44:	f9 85       	ldd	r31, Y+9	; 0x09
     f46:	83 e0       	ldi	r24, 0x03	; 3
     f48:	81 83       	std	Z+1, r24	; 0x01
     f4a:	e8 85       	ldd	r30, Y+8	; 0x08
     f4c:	f9 85       	ldd	r31, Y+9	; 0x09
     f4e:	88 e3       	ldi	r24, 0x38	; 56
     f50:	80 8b       	std	Z+16, r24	; 0x10
     f52:	e8 85       	ldd	r30, Y+8	; 0x08
     f54:	f9 85       	ldd	r31, Y+9	; 0x09
     f56:	81 8b       	std	Z+17, r24	; 0x11
     f58:	82 e0       	ldi	r24, 0x02	; 2
     f5a:	f7 01       	movw	r30, r14
     f5c:	82 83       	std	Z+2, r24	; 0x02
     f5e:	b5 01       	movw	r22, r10
     f60:	a4 01       	movw	r20, r8
     f62:	ce 01       	movw	r24, r28
     f64:	0e 94 4b 07 	call	0xe96	; 0xe96 <_ZN9I2CMaster12set_baudrateEm>
     f68:	f7 01       	movw	r30, r14
     f6a:	84 81       	ldd	r24, Z+4	; 0x04
     f6c:	8d 6c       	ori	r24, 0xCD	; 205
     f6e:	84 83       	std	Z+4, r24	; 0x04
     f70:	88 e0       	ldi	r24, 0x08	; 8
     f72:	81 83       	std	Z+1, r24	; 0x01
     f74:	df 91       	pop	r29
     f76:	cf 91       	pop	r28
     f78:	1f 91       	pop	r17
     f7a:	0f 91       	pop	r16
     f7c:	ff 90       	pop	r15
     f7e:	ef 90       	pop	r14
     f80:	df 90       	pop	r13
     f82:	cf 90       	pop	r12
     f84:	bf 90       	pop	r11
     f86:	af 90       	pop	r10
     f88:	9f 90       	pop	r9
     f8a:	8f 90       	pop	r8
     f8c:	08 95       	ret

00000f8e <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
     f8e:	dc 01       	movw	r26, r24
     f90:	14 96       	adiw	r26, 0x04	; 4
     f92:	ed 91       	ld	r30, X+
     f94:	fc 91       	ld	r31, X
     f96:	15 97       	sbiw	r26, 0x05	; 5
     f98:	83 81       	ldd	r24, Z+3	; 0x03
     f9a:	81 60       	ori	r24, 0x01	; 1
     f9c:	83 83       	std	Z+3, r24	; 0x03
     f9e:	08 95       	ret

00000fa0 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	ec 01       	movw	r28, r24
     faa:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
     fac:	db 01       	movw	r26, r22
     fae:	ed 91       	ld	r30, X+
     fb0:	fc 91       	ld	r31, X
     fb2:	02 84       	ldd	r0, Z+10	; 0x0a
     fb4:	f3 85       	ldd	r31, Z+11	; 0x0b
     fb6:	e0 2d       	mov	r30, r0
     fb8:	00 e0       	ldi	r16, 0x00	; 0
     fba:	10 e0       	ldi	r17, 0x00	; 0
     fbc:	b8 01       	movw	r22, r16
     fbe:	19 95       	eicall
  driver_->send_start();
     fc0:	8f 81       	ldd	r24, Y+7	; 0x07
     fc2:	98 85       	ldd	r25, Y+8	; 0x08
     fc4:	0e 94 c7 07 	call	0xf8e	; 0xf8e <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
     fc8:	ef 81       	ldd	r30, Y+7	; 0x07
     fca:	f8 85       	ldd	r31, Y+8	; 0x08
     fcc:	04 80       	ldd	r0, Z+4	; 0x04
     fce:	f5 81       	ldd	r31, Z+5	; 0x05
     fd0:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
     fd2:	d8 01       	movw	r26, r16
     fd4:	8c 91       	ld	r24, X
     fd6:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
     fd8:	8a 81       	ldd	r24, Y+2	; 0x02
     fda:	9b 81       	ldd	r25, Y+3	; 0x03
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	0f 91       	pop	r16
     fe4:	08 95       	ret

00000fe6 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready()
{
	return driver_->is_ready(slaveAddr_);
}
     fe6:	db 01       	movw	r26, r22
     fe8:	bc 01       	movw	r22, r24
     fea:	6e 5f       	subi	r22, 0xFE	; 254
     fec:	7f 4f       	sbci	r23, 0xFF	; 255
     fee:	ed 91       	ld	r30, X+
     ff0:	fc 91       	ld	r31, X
     ff2:	11 97       	sbiw	r26, 0x01	; 1
     ff4:	01 90       	ld	r0, Z+
     ff6:	f0 81       	ld	r31, Z
     ff8:	e0 2d       	mov	r30, r0
     ffa:	cd 01       	movw	r24, r26
     ffc:	19 95       	eicall
     ffe:	08 95       	ret

00001000 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
    1000:	fc 01       	movw	r30, r24
    1002:	84 81       	ldd	r24, Z+4	; 0x04
    1004:	95 81       	ldd	r25, Z+5	; 0x05
    1006:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	08 95       	ret

0000100e <_ZN9frt_queueIhE13ISR_not_emptyEv>:
    100e:	fc 01       	movw	r30, r24
    1010:	84 81       	ldd	r24, Z+4	; 0x04
    1012:	95 81       	ldd	r25, Z+5	; 0x05
    1014:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    1018:	91 e0       	ldi	r25, 0x01	; 1
    101a:	81 11       	cpse	r24, r1
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	89 2f       	mov	r24, r25
    1022:	08 95       	ret

00001024 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
    1024:	fc 01       	movw	r30, r24
    1026:	84 81       	ldd	r24, Z+4	; 0x04
    1028:	95 81       	ldd	r25, Z+5	; 0x05
    102a:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    102e:	91 e0       	ldi	r25, 0x01	; 1
    1030:	81 11       	cpse	r24, r1
    1032:	90 e0       	ldi	r25, 0x00	; 0
    1034:	89 2f       	mov	r24, r25
    1036:	08 95       	ret

00001038 <_ZN9frt_queueIhE12num_items_inEv>:
    1038:	fc 01       	movw	r30, r24
    103a:	84 81       	ldd	r24, Z+4	; 0x04
    103c:	95 81       	ldd	r25, Z+5	; 0x05
    103e:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	08 95       	ret

00001046 <_ZN9frt_queueIhE9not_emptyEv>:
    1046:	fc 01       	movw	r30, r24
    1048:	84 81       	ldd	r24, Z+4	; 0x04
    104a:	95 81       	ldd	r25, Z+5	; 0x05
    104c:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    1050:	91 e0       	ldi	r25, 0x01	; 1
    1052:	81 11       	cpse	r24, r1
    1054:	01 c0       	rjmp	.+2      	; 0x1058 <_ZN9frt_queueIhE9not_emptyEv+0x12>
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	89 2f       	mov	r24, r25
    105a:	08 95       	ret

0000105c <_ZN9frt_queueIhE8is_emptyEv>:
    105c:	fc 01       	movw	r30, r24
    105e:	84 81       	ldd	r24, Z+4	; 0x04
    1060:	95 81       	ldd	r25, Z+5	; 0x05
    1062:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    1066:	91 e0       	ldi	r25, 0x01	; 1
    1068:	81 11       	cpse	r24, r1
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	89 2f       	mov	r24, r25
    106e:	08 95       	ret

00001070 <_ZN9frt_queueIhE10get_a_copyERh>:
    1070:	0f 93       	push	r16
    1072:	01 e0       	ldi	r16, 0x01	; 1
    1074:	2f ef       	ldi	r18, 0xFF	; 255
    1076:	3f ef       	ldi	r19, 0xFF	; 255
    1078:	a9 01       	movw	r20, r18
    107a:	fc 01       	movw	r30, r24
    107c:	84 81       	ldd	r24, Z+4	; 0x04
    107e:	95 81       	ldd	r25, Z+5	; 0x05
    1080:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
    1084:	0f 91       	pop	r16
    1086:	08 95       	ret

00001088 <_ZN9frt_queueIhE10get_a_copyEv>:
    1088:	0f 93       	push	r16
    108a:	cf 93       	push	r28
    108c:	df 93       	push	r29
    108e:	1f 92       	push	r1
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
    1094:	01 e0       	ldi	r16, 0x01	; 1
    1096:	2f ef       	ldi	r18, 0xFF	; 255
    1098:	3f ef       	ldi	r19, 0xFF	; 255
    109a:	a9 01       	movw	r20, r18
    109c:	be 01       	movw	r22, r28
    109e:	6f 5f       	subi	r22, 0xFF	; 255
    10a0:	7f 4f       	sbci	r23, 0xFF	; 255
    10a2:	fc 01       	movw	r30, r24
    10a4:	84 81       	ldd	r24, Z+4	; 0x04
    10a6:	95 81       	ldd	r25, Z+5	; 0x05
    10a8:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
    10ac:	89 81       	ldd	r24, Y+1	; 0x01
    10ae:	0f 90       	pop	r0
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	0f 91       	pop	r16
    10b6:	08 95       	ret

000010b8 <_ZN9frt_queueIhE3getEPh>:
    10b8:	0f 93       	push	r16
    10ba:	00 e0       	ldi	r16, 0x00	; 0
    10bc:	2f ef       	ldi	r18, 0xFF	; 255
    10be:	3f ef       	ldi	r19, 0xFF	; 255
    10c0:	a9 01       	movw	r20, r18
    10c2:	fc 01       	movw	r30, r24
    10c4:	84 81       	ldd	r24, Z+4	; 0x04
    10c6:	95 81       	ldd	r25, Z+5	; 0x05
    10c8:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
    10cc:	0f 91       	pop	r16
    10ce:	08 95       	ret

000010d0 <_ZN9frt_queueIhE3getEv>:
    10d0:	0f 93       	push	r16
    10d2:	cf 93       	push	r28
    10d4:	df 93       	push	r29
    10d6:	1f 92       	push	r1
    10d8:	cd b7       	in	r28, 0x3d	; 61
    10da:	de b7       	in	r29, 0x3e	; 62
    10dc:	00 e0       	ldi	r16, 0x00	; 0
    10de:	2f ef       	ldi	r18, 0xFF	; 255
    10e0:	3f ef       	ldi	r19, 0xFF	; 255
    10e2:	a9 01       	movw	r20, r18
    10e4:	be 01       	movw	r22, r28
    10e6:	6f 5f       	subi	r22, 0xFF	; 255
    10e8:	7f 4f       	sbci	r23, 0xFF	; 255
    10ea:	fc 01       	movw	r30, r24
    10ec:	84 81       	ldd	r24, Z+4	; 0x04
    10ee:	95 81       	ldd	r25, Z+5	; 0x05
    10f0:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
    10f4:	89 81       	ldd	r24, Y+1	; 0x01
    10f6:	0f 90       	pop	r0
    10f8:	df 91       	pop	r29
    10fa:	cf 91       	pop	r28
    10fc:	0f 91       	pop	r16
    10fe:	08 95       	ret

00001100 <_ZN9frt_queueIhE7ISR_getEPh>:
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	1f 92       	push	r1
    1106:	cd b7       	in	r28, 0x3d	; 61
    1108:	de b7       	in	r29, 0x3e	; 62
    110a:	ae 01       	movw	r20, r28
    110c:	4f 5f       	subi	r20, 0xFF	; 255
    110e:	5f 4f       	sbci	r21, 0xFF	; 255
    1110:	fc 01       	movw	r30, r24
    1112:	84 81       	ldd	r24, Z+4	; 0x04
    1114:	95 81       	ldd	r25, Z+5	; 0x05
    1116:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
    111a:	0f 90       	pop	r0
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	08 95       	ret

00001122 <_ZN9frt_queueIhE7ISR_getEv>:
    1122:	cf 93       	push	r28
    1124:	df 93       	push	r29
    1126:	1f 92       	push	r1
    1128:	1f 92       	push	r1
    112a:	cd b7       	in	r28, 0x3d	; 61
    112c:	de b7       	in	r29, 0x3e	; 62
    112e:	ae 01       	movw	r20, r28
    1130:	4e 5f       	subi	r20, 0xFE	; 254
    1132:	5f 4f       	sbci	r21, 0xFF	; 255
    1134:	be 01       	movw	r22, r28
    1136:	6f 5f       	subi	r22, 0xFF	; 255
    1138:	7f 4f       	sbci	r23, 0xFF	; 255
    113a:	fc 01       	movw	r30, r24
    113c:	84 81       	ldd	r24, Z+4	; 0x04
    113e:	95 81       	ldd	r25, Z+5	; 0x05
    1140:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
    1144:	89 81       	ldd	r24, Y+1	; 0x01
    1146:	0f 90       	pop	r0
    1148:	0f 90       	pop	r0
    114a:	df 91       	pop	r29
    114c:	cf 91       	pop	r28
    114e:	08 95       	ret

00001150 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
    1154:	1f 92       	push	r1
    1156:	cd b7       	in	r28, 0x3d	; 61
    1158:	de b7       	in	r29, 0x3e	; 62
    115a:	19 82       	std	Y+1, r1	; 0x01
    115c:	21 e0       	ldi	r18, 0x01	; 1
    115e:	ae 01       	movw	r20, r28
    1160:	4f 5f       	subi	r20, 0xFF	; 255
    1162:	5f 4f       	sbci	r21, 0xFF	; 255
    1164:	fc 01       	movw	r30, r24
    1166:	84 81       	ldd	r24, Z+4	; 0x04
    1168:	95 81       	ldd	r25, Z+5	; 0x05
    116a:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
    116e:	91 e0       	ldi	r25, 0x01	; 1
    1170:	81 11       	cpse	r24, r1
    1172:	01 c0       	rjmp	.+2      	; 0x1176 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	89 2f       	mov	r24, r25
    1178:	0f 90       	pop	r0
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <_ZN9frt_queueIhE7ISR_putERKh>:
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	1f 92       	push	r1
    1186:	cd b7       	in	r28, 0x3d	; 61
    1188:	de b7       	in	r29, 0x3e	; 62
    118a:	19 82       	std	Y+1, r1	; 0x01
    118c:	20 e0       	ldi	r18, 0x00	; 0
    118e:	ae 01       	movw	r20, r28
    1190:	4f 5f       	subi	r20, 0xFF	; 255
    1192:	5f 4f       	sbci	r21, 0xFF	; 255
    1194:	fc 01       	movw	r30, r24
    1196:	84 81       	ldd	r24, Z+4	; 0x04
    1198:	95 81       	ldd	r25, Z+5	; 0x05
    119a:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
    119e:	91 e0       	ldi	r25, 0x01	; 1
    11a0:	81 11       	cpse	r24, r1
    11a2:	01 c0       	rjmp	.+2      	; 0x11a6 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	89 2f       	mov	r24, r25
    11a8:	0f 90       	pop	r0
    11aa:	df 91       	pop	r29
    11ac:	cf 91       	pop	r28
    11ae:	08 95       	ret

000011b0 <_ZN9frt_queueIhE7butt_inERKh>:
    11b0:	0f 93       	push	r16
    11b2:	fc 01       	movw	r30, r24
    11b4:	26 81       	ldd	r18, Z+6	; 0x06
    11b6:	37 81       	ldd	r19, Z+7	; 0x07
    11b8:	40 85       	ldd	r20, Z+8	; 0x08
    11ba:	51 85       	ldd	r21, Z+9	; 0x09
    11bc:	01 e0       	ldi	r16, 0x01	; 1
    11be:	84 81       	ldd	r24, Z+4	; 0x04
    11c0:	95 81       	ldd	r25, Z+5	; 0x05
    11c2:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    11c6:	91 e0       	ldi	r25, 0x01	; 1
    11c8:	81 11       	cpse	r24, r1
    11ca:	01 c0       	rjmp	.+2      	; 0x11ce <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	89 2f       	mov	r24, r25
    11d0:	0f 91       	pop	r16
    11d2:	08 95       	ret

000011d4 <_ZN9frt_queueIhE3putERKh>:
    11d4:	0f 93       	push	r16
    11d6:	fc 01       	movw	r30, r24
    11d8:	26 81       	ldd	r18, Z+6	; 0x06
    11da:	37 81       	ldd	r19, Z+7	; 0x07
    11dc:	40 85       	ldd	r20, Z+8	; 0x08
    11de:	51 85       	ldd	r21, Z+9	; 0x09
    11e0:	00 e0       	ldi	r16, 0x00	; 0
    11e2:	84 81       	ldd	r24, Z+4	; 0x04
    11e4:	95 81       	ldd	r25, Z+5	; 0x05
    11e6:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    11ea:	91 e0       	ldi	r25, 0x01	; 1
    11ec:	81 11       	cpse	r24, r1
    11ee:	01 c0       	rjmp	.+2      	; 0x11f2 <_ZN9frt_queueIhE3putERKh+0x1e>
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	89 2f       	mov	r24, r25
    11f4:	0f 91       	pop	r16
    11f6:	08 95       	ret

000011f8 <_ZN6MB1202C1EP9I2CMaster>:
    11f8:	4f 92       	push	r4
    11fa:	5f 92       	push	r5
    11fc:	6f 92       	push	r6
    11fe:	7f 92       	push	r7
    1200:	8f 92       	push	r8
    1202:	9f 92       	push	r9
    1204:	af 92       	push	r10
    1206:	bf 92       	push	r11
    1208:	df 92       	push	r13
    120a:	ef 92       	push	r14
    120c:	ff 92       	push	r15
    120e:	0f 93       	push	r16
    1210:	1f 93       	push	r17
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	8c 01       	movw	r16, r24
    1218:	7b 01       	movw	r14, r22
    121a:	dc 01       	movw	r26, r24
    121c:	6d 93       	st	X+, r22
    121e:	7c 93       	st	X, r23
    1220:	8d e1       	ldi	r24, 0x1D	; 29
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
    1228:	ec 01       	movw	r28, r24
    122a:	83 ef       	ldi	r24, 0xF3	; 243
    122c:	90 e2       	ldi	r25, 0x20	; 32
    122e:	88 83       	st	Y, r24
    1230:	99 83       	std	Y+1, r25	; 0x01
    1232:	1c 82       	std	Y+4, r1	; 0x04
    1234:	1d 82       	std	Y+5, r1	; 0x05
    1236:	0f 2e       	mov	r0, r31
    1238:	fb ea       	ldi	r31, 0xAB	; 171
    123a:	8f 2e       	mov	r8, r31
    123c:	f0 e2       	ldi	r31, 0x20	; 32
    123e:	9f 2e       	mov	r9, r31
    1240:	f0 2d       	mov	r31, r0
    1242:	8a 82       	std	Y+2, r8	; 0x02
    1244:	9b 82       	std	Y+3, r9	; 0x03
    1246:	40 e0       	ldi	r20, 0x00	; 0
    1248:	61 e0       	ldi	r22, 0x01	; 1
    124a:	82 e0       	ldi	r24, 0x02	; 2
    124c:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    1250:	8e 83       	std	Y+6, r24	; 0x06
    1252:	9f 83       	std	Y+7, r25	; 0x07
    1254:	0f 2e       	mov	r0, r31
    1256:	fa e0       	ldi	r31, 0x0A	; 10
    1258:	4f 2e       	mov	r4, r31
    125a:	51 2c       	mov	r5, r1
    125c:	61 2c       	mov	r6, r1
    125e:	71 2c       	mov	r7, r1
    1260:	f0 2d       	mov	r31, r0
    1262:	48 86       	std	Y+8, r4	; 0x08
    1264:	59 86       	std	Y+9, r5	; 0x09
    1266:	6a 86       	std	Y+10, r6	; 0x0a
    1268:	7b 86       	std	Y+11, r7	; 0x0b
    126a:	0f 2e       	mov	r0, r31
    126c:	ff ec       	ldi	r31, 0xCF	; 207
    126e:	af 2e       	mov	r10, r31
    1270:	f0 e2       	ldi	r31, 0x20	; 32
    1272:	bf 2e       	mov	r11, r31
    1274:	f0 2d       	mov	r31, r0
    1276:	aa 82       	std	Y+2, r10	; 0x02
    1278:	bb 82       	std	Y+3, r11	; 0x03
    127a:	68 94       	set
    127c:	dd 24       	eor	r13, r13
    127e:	d1 f8       	bld	r13, 1
    1280:	dc 86       	std	Y+12, r13	; 0x0c
    1282:	1f 86       	std	Y+15, r1	; 0x0f
    1284:	18 8a       	std	Y+16, r1	; 0x10
    1286:	8d 86       	std	Y+13, r8	; 0x0d
    1288:	9e 86       	std	Y+14, r9	; 0x0e
    128a:	40 e0       	ldi	r20, 0x00	; 0
    128c:	61 e0       	ldi	r22, 0x01	; 1
    128e:	82 e0       	ldi	r24, 0x02	; 2
    1290:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    1294:	89 8b       	std	Y+17, r24	; 0x11
    1296:	9a 8b       	std	Y+18, r25	; 0x12
    1298:	4b 8a       	std	Y+19, r4	; 0x13
    129a:	5c 8a       	std	Y+20, r5	; 0x14
    129c:	6d 8a       	std	Y+21, r6	; 0x15
    129e:	7e 8a       	std	Y+22, r7	; 0x16
    12a0:	ad 86       	std	Y+13, r10	; 0x0d
    12a2:	be 86       	std	Y+14, r11	; 0x0e
    12a4:	df 8a       	std	Y+23, r13	; 0x17
    12a6:	8a e0       	ldi	r24, 0x0A	; 10
    12a8:	90 e2       	ldi	r25, 0x20	; 32
    12aa:	88 83       	st	Y, r24
    12ac:	99 83       	std	Y+1, r25	; 0x01
    12ae:	f8 01       	movw	r30, r16
    12b0:	c2 83       	std	Z+2, r28	; 0x02
    12b2:	d3 83       	std	Z+3, r29	; 0x03
    12b4:	80 e7       	ldi	r24, 0x70	; 112
    12b6:	84 83       	std	Z+4, r24	; 0x04
    12b8:	16 82       	std	Z+6, r1	; 0x06
    12ba:	17 82       	std	Z+7, r1	; 0x07
    12bc:	10 86       	std	Z+8, r1	; 0x08
    12be:	11 86       	std	Z+9, r1	; 0x09
    12c0:	12 86       	std	Z+10, r1	; 0x0a
    12c2:	83 e0       	ldi	r24, 0x03	; 3
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
    12ca:	21 e0       	ldi	r18, 0x01	; 1
    12cc:	31 e2       	ldi	r19, 0x21	; 33
    12ce:	fc 01       	movw	r30, r24
    12d0:	20 83       	st	Z, r18
    12d2:	31 83       	std	Z+1, r19	; 0x01
    12d4:	c1 e5       	ldi	r28, 0x51	; 81
    12d6:	c2 83       	std	Z+2, r28	; 0x02
    12d8:	d8 01       	movw	r26, r16
    12da:	1d 96       	adiw	r26, 0x0d	; 13
    12dc:	8d 93       	st	X+, r24
    12de:	9c 93       	st	X, r25
    12e0:	1e 97       	sbiw	r26, 0x0e	; 14
    12e2:	12 96       	adiw	r26, 0x02	; 2
    12e4:	ed 91       	ld	r30, X+
    12e6:	fc 91       	ld	r31, X
    12e8:	13 97       	sbiw	r26, 0x03	; 3
    12ea:	e0 8e       	std	Z+24, r14	; 0x18
    12ec:	f1 8e       	std	Z+25, r15	; 0x19
    12ee:	14 96       	adiw	r26, 0x04	; 4
    12f0:	6c 91       	ld	r22, X
    12f2:	14 97       	sbiw	r26, 0x04	; 4
    12f4:	12 96       	adiw	r26, 0x02	; 2
    12f6:	8d 91       	ld	r24, X+
    12f8:	9c 91       	ld	r25, X
    12fa:	13 97       	sbiw	r26, 0x03	; 3
    12fc:	0e 94 ee 03 	call	0x7dc	; 0x7dc <_ZN8I2CAgent12setSlaveAddrEh>
    1300:	f8 01       	movw	r30, r16
    1302:	c5 83       	std	Z+5, r28	; 0x05
    1304:	8a ea       	ldi	r24, 0xAA	; 170
    1306:	86 83       	std	Z+6, r24	; 0x06
    1308:	85 ea       	ldi	r24, 0xA5	; 165
    130a:	87 83       	std	Z+7, r24	; 0x07
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	1f 91       	pop	r17
    1312:	0f 91       	pop	r16
    1314:	ff 90       	pop	r15
    1316:	ef 90       	pop	r14
    1318:	df 90       	pop	r13
    131a:	bf 90       	pop	r11
    131c:	af 90       	pop	r10
    131e:	9f 90       	pop	r9
    1320:	8f 90       	pop	r8
    1322:	7f 90       	pop	r7
    1324:	6f 90       	pop	r6
    1326:	5f 90       	pop	r5
    1328:	4f 90       	pop	r4
    132a:	08 95       	ret

0000132c <_ZN6MB120211takeReadingEv>:

bool MB1202::takeReading()
{
	return i2cAgent_->transmit(*rangeCommand_);
    132c:	fc 01       	movw	r30, r24
    132e:	a2 81       	ldd	r26, Z+2	; 0x02
    1330:	b3 81       	ldd	r27, Z+3	; 0x03
    1332:	65 85       	ldd	r22, Z+13	; 0x0d
    1334:	76 85       	ldd	r23, Z+14	; 0x0e
    1336:	ed 91       	ld	r30, X+
    1338:	fc 91       	ld	r31, X
    133a:	11 97       	sbiw	r26, 0x01	; 1
    133c:	01 90       	ld	r0, Z+
    133e:	f0 81       	ld	r31, Z
    1340:	e0 2d       	mov	r30, r0
    1342:	cd 01       	movw	r24, r26
    1344:	19 95       	eicall
}
    1346:	08 95       	ret

00001348 <_ZN6MB120210getReadingEv>:

uint16_t MB1202::getReading()
{
    1348:	ff 92       	push	r15
    134a:	0f 93       	push	r16
    134c:	1f 93       	push	r17
    134e:	cf 93       	push	r28
    1350:	df 93       	push	r29
    1352:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
    1354:	8a 81       	ldd	r24, Y+2	; 0x02
    1356:	9b 81       	ldd	r25, Y+3	; 0x03
    1358:	dc 01       	movw	r26, r24
    135a:	ed 91       	ld	r30, X+
    135c:	fc 91       	ld	r31, X
    135e:	02 80       	ldd	r0, Z+2	; 0x02
    1360:	f3 81       	ldd	r31, Z+3	; 0x03
    1362:	e0 2d       	mov	r30, r0
    1364:	19 95       	eicall
    1366:	8c 01       	movw	r16, r24
	rangeReading_ = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
    1368:	dc 01       	movw	r26, r24
    136a:	ed 91       	ld	r30, X+
    136c:	fc 91       	ld	r31, X
    136e:	00 84       	ldd	r0, Z+8	; 0x08
    1370:	f1 85       	ldd	r31, Z+9	; 0x09
    1372:	e0 2d       	mov	r30, r0
    1374:	19 95       	eicall
    1376:	f8 2e       	mov	r15, r24
    1378:	d8 01       	movw	r26, r16
    137a:	ed 91       	ld	r30, X+
    137c:	fc 91       	ld	r31, X
    137e:	00 84       	ldd	r0, Z+8	; 0x08
    1380:	f1 85       	ldd	r31, Z+9	; 0x09
    1382:	e0 2d       	mov	r30, r0
    1384:	c8 01       	movw	r24, r16
    1386:	19 95       	eicall
    1388:	2f 2d       	mov	r18, r15
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	32 2f       	mov	r19, r18
    138e:	22 27       	eor	r18, r18
    1390:	a9 01       	movw	r20, r18
    1392:	48 2b       	or	r20, r24
    1394:	ca 01       	movw	r24, r20
    1396:	8b 87       	std	Y+11, r24	; 0x0b
    1398:	9c 87       	std	Y+12, r25	; 0x0c
	return rangeReading_;
}
    139a:	df 91       	pop	r29
    139c:	cf 91       	pop	r28
    139e:	1f 91       	pop	r17
    13a0:	0f 91       	pop	r16
    13a2:	ff 90       	pop	r15
    13a4:	08 95       	ret

000013a6 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	ec 01       	movw	r28, r24
  while( not_empty() )
    13ac:	e8 81       	ld	r30, Y
    13ae:	f9 81       	ldd	r31, Y+1	; 0x01
    13b0:	00 8c       	ldd	r0, Z+24	; 0x18
    13b2:	f1 8d       	ldd	r31, Z+25	; 0x19
    13b4:	e0 2d       	mov	r30, r0
    13b6:	ce 01       	movw	r24, r28
    13b8:	19 95       	eicall
    13ba:	88 23       	and	r24, r24
    13bc:	41 f0       	breq	.+16     	; 0x13ce <_ZN6Packet12resetContentEv+0x28>
  {
    get();
    13be:	e8 81       	ld	r30, Y
    13c0:	f9 81       	ldd	r31, Y+1	; 0x01
    13c2:	00 84       	ldd	r0, Z+8	; 0x08
    13c4:	f1 85       	ldd	r31, Z+9	; 0x09
    13c6:	e0 2d       	mov	r30, r0
    13c8:	ce 01       	movw	r24, r28
    13ca:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  while( not_empty() )
    13cc:	ef cf       	rjmp	.-34     	; 0x13ac <_ZN6Packet12resetContentEv+0x6>
  {
    get();
  }
    13ce:	df 91       	pop	r29
    13d0:	cf 91       	pop	r28
    13d2:	08 95       	ret

000013d4 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    13d4:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    13d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    13d8:	88 23       	and	r24, r24
    13da:	19 f0       	breq	.+6      	; 0x13e2 <_ZN10task_sonar3runEv+0xe>
    13dc:	81 30       	cpi	r24, 0x01	; 1
    13de:	51 f0       	breq	.+20     	; 0x13f4 <_ZN10task_sonar3runEv+0x20>
    13e0:	25 c0       	rjmp	.+74     	; 0x142c <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202_->takeReading();	
    13e2:	8c 89       	ldd	r24, Y+20	; 0x14
    13e4:	9d 89       	ldd	r25, Y+21	; 0x15
    13e6:	0e 94 96 09 	call	0x132c	; 0x132c <_ZN6MB120211takeReadingEv>
				
				transition_to(1);			
    13ea:	61 e0       	ldi	r22, 0x01	; 1
    13ec:	ce 01       	movw	r24, r28
    13ee:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8frt_task13transition_toEh>
			
			    break;
    13f2:	1c c0       	rjmp	.+56     	; 0x142c <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				rangeReading_ = mb1202_->getReading();
    13f4:	8c 89       	ldd	r24, Y+20	; 0x14
    13f6:	9d 89       	ldd	r25, Y+21	; 0x15
    13f8:	0e 94 a4 09 	call	0x1348	; 0x1348 <_ZN6MB120210getReadingEv>
    13fc:	7c 01       	movw	r14, r24
    13fe:	8a 8b       	std	Y+18, r24	; 0x12
    1400:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << rangeReading_ << endl;
    1402:	6a e0       	ldi	r22, 0x0A	; 10
    1404:	8e 81       	ldd	r24, Y+6	; 0x06
    1406:	9f 81       	ldd	r25, Y+7	; 0x07
    1408:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    140c:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    140e:	6a ea       	ldi	r22, 0xAA	; 170
    1410:	73 e0       	ldi	r23, 0x03	; 3
    1412:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1416:	b7 01       	movw	r22, r14
    1418:	c8 01       	movw	r24, r16
    141a:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    141e:	66 e0       	ldi	r22, 0x06	; 6
    1420:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	ce 01       	movw	r24, r28
    1428:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    142c:	8e 85       	ldd	r24, Y+14	; 0x0e
    142e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1430:	a8 89       	ldd	r26, Y+16	; 0x10
    1432:	b9 89       	ldd	r27, Y+17	; 0x11
    1434:	01 96       	adiw	r24, 0x01	; 1
    1436:	a1 1d       	adc	r26, r1
    1438:	b1 1d       	adc	r27, r1
    143a:	8e 87       	std	Y+14, r24	; 0x0e
    143c:	9f 87       	std	Y+15, r25	; 0x0f
    143e:	a8 8b       	std	Y+16, r26	; 0x10
    1440:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
    1442:	64 ef       	ldi	r22, 0xF4	; 244
    1444:	71 e0       	ldi	r23, 0x01	; 1
    1446:	80 e0       	ldi	r24, 0x00	; 0
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    144e:	c3 cf       	rjmp	.-122    	; 0x13d6 <_ZN10task_sonar3runEv+0x2>

00001450 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    1450:	cf 92       	push	r12
    1452:	df 92       	push	r13
    1454:	ef 92       	push	r14
    1456:	ff 92       	push	r15
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	ec 01       	movw	r28, r24
    1462:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mb1202_(mb1202)
    1464:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <_ZN8frt_taskC1EPKchjP8emstream>
    1468:	87 e0       	ldi	r24, 0x07	; 7
    146a:	91 e2       	ldi	r25, 0x21	; 33
    146c:	88 83       	st	Y, r24
    146e:	99 83       	std	Y+1, r25	; 0x01
    1470:	ec 8a       	std	Y+20, r14	; 0x14
    1472:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    1474:	ce 8a       	std	Y+22, r12	; 0x16
    1476:	df 8a       	std	Y+23, r13	; 0x17
}
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	ff 90       	pop	r15
    1482:	ef 90       	pop	r14
    1484:	df 90       	pop	r13
    1486:	cf 90       	pop	r12
    1488:	08 95       	ret

0000148a <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    148a:	0f 93       	push	r16
    148c:	1f 93       	push	r17
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1494:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <_ZN8frt_taskC1EPKchjP8emstream>
    1498:	8f e0       	ldi	r24, 0x0F	; 15
    149a:	91 e2       	ldi	r25, 0x21	; 33
    149c:	88 83       	st	Y, r24
    149e:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	1f 91       	pop	r17
    14a6:	0f 91       	pop	r16
    14a8:	08 95       	ret

000014aa <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    14aa:	0f 93       	push	r16
    14ac:	1f 93       	push	r17
    14ae:	cf 93       	push	r28
    14b0:	df 93       	push	r29
    14b2:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    14b4:	6a e0       	ldi	r22, 0x0A	; 10
    14b6:	8e 81       	ldd	r24, Y+6	; 0x06
    14b8:	9f 81       	ldd	r25, Y+7	; 0x07
    14ba:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    14be:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    14c0:	65 e0       	ldi	r22, 0x05	; 5
    14c2:	75 e0       	ldi	r23, 0x05	; 5
    14c4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    14c8:	6a e0       	ldi	r22, 0x0A	; 10
    14ca:	c8 01       	movw	r24, r16
    14cc:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    14d0:	8c 01       	movw	r16, r24
    14d2:	6f ef       	ldi	r22, 0xFF	; 255
    14d4:	74 e0       	ldi	r23, 0x04	; 4
    14d6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    14da:	67 e0       	ldi	r22, 0x07	; 7
    14dc:	c8 01       	movw	r24, r16
    14de:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    14e2:	6a e0       	ldi	r22, 0x0A	; 10
    14e4:	8e 81       	ldd	r24, Y+6	; 0x06
    14e6:	9f 81       	ldd	r25, Y+7	; 0x07
    14e8:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    14ec:	8c 01       	movw	r16, r24
    14ee:	60 ee       	ldi	r22, 0xE0	; 224
    14f0:	74 e0       	ldi	r23, 0x04	; 4
    14f2:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    14f6:	6a e0       	ldi	r22, 0x0A	; 10
    14f8:	c8 01       	movw	r24, r16
    14fa:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    14fe:	8c 01       	movw	r16, r24
    1500:	6a ed       	ldi	r22, 0xDA	; 218
    1502:	74 e0       	ldi	r23, 0x04	; 4
    1504:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1508:	66 e0       	ldi	r22, 0x06	; 6
    150a:	c8 01       	movw	r24, r16
    150c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1510:	6a e0       	ldi	r22, 0x0A	; 10
    1512:	8e 81       	ldd	r24, Y+6	; 0x06
    1514:	9f 81       	ldd	r25, Y+7	; 0x07
    1516:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    151a:	8c 01       	movw	r16, r24
    151c:	63 ec       	ldi	r22, 0xC3	; 195
    151e:	74 e0       	ldi	r23, 0x04	; 4
    1520:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1524:	66 e0       	ldi	r22, 0x06	; 6
    1526:	c8 01       	movw	r24, r16
    1528:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    152c:	6a e0       	ldi	r22, 0x0A	; 10
    152e:	8e 81       	ldd	r24, Y+6	; 0x06
    1530:	9f 81       	ldd	r25, Y+7	; 0x07
    1532:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1536:	8c 01       	movw	r16, r24
    1538:	67 ea       	ldi	r22, 0xA7	; 167
    153a:	74 e0       	ldi	r23, 0x04	; 4
    153c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1540:	66 e0       	ldi	r22, 0x06	; 6
    1542:	c8 01       	movw	r24, r16
    1544:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1548:	6a e0       	ldi	r22, 0x0A	; 10
    154a:	8e 81       	ldd	r24, Y+6	; 0x06
    154c:	9f 81       	ldd	r25, Y+7	; 0x07
    154e:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1552:	8c 01       	movw	r16, r24
    1554:	6f e8       	ldi	r22, 0x8F	; 143
    1556:	74 e0       	ldi	r23, 0x04	; 4
    1558:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    155c:	66 e0       	ldi	r22, 0x06	; 6
    155e:	c8 01       	movw	r24, r16
    1560:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1564:	6a e0       	ldi	r22, 0x0A	; 10
    1566:	8e 81       	ldd	r24, Y+6	; 0x06
    1568:	9f 81       	ldd	r25, Y+7	; 0x07
    156a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    156e:	8c 01       	movw	r16, r24
    1570:	6e e6       	ldi	r22, 0x6E	; 110
    1572:	74 e0       	ldi	r23, 0x04	; 4
    1574:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1578:	66 e0       	ldi	r22, 0x06	; 6
    157a:	c8 01       	movw	r24, r16
    157c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1580:	6a e0       	ldi	r22, 0x0A	; 10
    1582:	8e 81       	ldd	r24, Y+6	; 0x06
    1584:	9f 81       	ldd	r25, Y+7	; 0x07
    1586:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    158a:	8c 01       	movw	r16, r24
    158c:	67 e4       	ldi	r22, 0x47	; 71
    158e:	74 e0       	ldi	r23, 0x04	; 4
    1590:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1594:	66 e0       	ldi	r22, 0x06	; 6
    1596:	c8 01       	movw	r24, r16
    1598:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    159c:	6a e0       	ldi	r22, 0x0A	; 10
    159e:	8e 81       	ldd	r24, Y+6	; 0x06
    15a0:	9f 81       	ldd	r25, Y+7	; 0x07
    15a2:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    15a6:	8c 01       	movw	r16, r24
    15a8:	69 e2       	ldi	r22, 0x29	; 41
    15aa:	74 e0       	ldi	r23, 0x04	; 4
    15ac:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    15b0:	66 e0       	ldi	r22, 0x06	; 6
    15b2:	c8 01       	movw	r24, r16
    15b4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    15b8:	6a e0       	ldi	r22, 0x0A	; 10
    15ba:	8e 81       	ldd	r24, Y+6	; 0x06
    15bc:	9f 81       	ldd	r25, Y+7	; 0x07
    15be:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    15c2:	8c 01       	movw	r16, r24
    15c4:	6e e0       	ldi	r22, 0x0E	; 14
    15c6:	74 e0       	ldi	r23, 0x04	; 4
    15c8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    15cc:	66 e0       	ldi	r22, 0x06	; 6
    15ce:	c8 01       	movw	r24, r16
    15d0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    15d4:	6a e0       	ldi	r22, 0x0A	; 10
    15d6:	8e 81       	ldd	r24, Y+6	; 0x06
    15d8:	9f 81       	ldd	r25, Y+7	; 0x07
    15da:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    15de:	ec 01       	movw	r28, r24
    15e0:	6f ef       	ldi	r22, 0xFF	; 255
    15e2:	73 e0       	ldi	r23, 0x03	; 3
    15e4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    15e8:	66 e0       	ldi	r22, 0x06	; 6
    15ea:	ce 01       	movw	r24, r28
    15ec:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
}
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	1f 91       	pop	r17
    15f6:	0f 91       	pop	r16
    15f8:	08 95       	ret

000015fa <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    15fa:	af 92       	push	r10
    15fc:	bf 92       	push	r11
    15fe:	cf 92       	push	r12
    1600:	df 92       	push	r13
    1602:	ef 92       	push	r14
    1604:	ff 92       	push	r15
    1606:	0f 93       	push	r16
    1608:	1f 93       	push	r17
    160a:	cf 93       	push	r28
    160c:	df 93       	push	r29
    160e:	00 d0       	rcall	.+0      	; 0x1610 <_ZN9task_user11show_statusEv+0x16>
    1610:	00 d0       	rcall	.+0      	; 0x1612 <_ZN9task_user11show_statusEv+0x18>
    1612:	cd b7       	in	r28, 0x3d	; 61
    1614:	de b7       	in	r29, 0x3e	; 62
    1616:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1618:	19 82       	std	Y+1, r1	; 0x01
    161a:	1a 82       	std	Y+2, r1	; 0x02
    161c:	1b 82       	std	Y+3, r1	; 0x03
    161e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1620:	1d 82       	std	Y+5, r1	; 0x05
    1622:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1624:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <xPortGetFreeHeapSize>
    1628:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    162a:	ce 01       	movw	r24, r28
    162c:	01 96       	adiw	r24, 0x01	; 1
    162e:	0e 94 aa 1b 	call	0x3754	; 0x3754 <_ZN10time_stamp10set_to_nowEv>
    1632:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1634:	66 e0       	ldi	r22, 0x06	; 6
    1636:	f8 01       	movw	r30, r16
    1638:	86 81       	ldd	r24, Z+6	; 0x06
    163a:	97 81       	ldd	r25, Z+7	; 0x07
    163c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1640:	6a e0       	ldi	r22, 0x0A	; 10
    1642:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1646:	7c 01       	movw	r14, r24
    1648:	60 ee       	ldi	r22, 0xE0	; 224
    164a:	73 e0       	ldi	r23, 0x03	; 3
    164c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1650:	6a e0       	ldi	r22, 0x0A	; 10
    1652:	c7 01       	movw	r24, r14
    1654:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1658:	7c 01       	movw	r14, r24
    165a:	64 ed       	ldi	r22, 0xD4	; 212
    165c:	73 e0       	ldi	r23, 0x03	; 3
    165e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1662:	66 e0       	ldi	r22, 0x06	; 6
    1664:	c7 01       	movw	r24, r14
    1666:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    166a:	6a e0       	ldi	r22, 0x0A	; 10
    166c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1670:	7c 01       	movw	r14, r24
    1672:	6d ec       	ldi	r22, 0xCD	; 205
    1674:	73 e0       	ldi	r23, 0x03	; 3
    1676:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    167a:	b5 01       	movw	r22, r10
    167c:	c7 01       	movw	r24, r14
    167e:	0e 94 4e 1b 	call	0x369c	; 0x369c <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1682:	6a e0       	ldi	r22, 0x0A	; 10
    1684:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1688:	7c 01       	movw	r14, r24
    168a:	6f eb       	ldi	r22, 0xBF	; 191
    168c:	73 e0       	ldi	r23, 0x03	; 3
    168e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1692:	b6 01       	movw	r22, r12
    1694:	c7 01       	movw	r24, r14
    1696:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    169a:	6a e0       	ldi	r22, 0x0A	; 10
    169c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    16a0:	7c 01       	movw	r14, r24
    16a2:	6d eb       	ldi	r22, 0xBD	; 189
    16a4:	73 e0       	ldi	r23, 0x03	; 3
    16a6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    16aa:	4f ef       	ldi	r20, 0xFF	; 255
    16ac:	5f e0       	ldi	r21, 0x0F	; 15
    16ae:	60 e0       	ldi	r22, 0x00	; 0
    16b0:	70 e0       	ldi	r23, 0x00	; 0
    16b2:	c7 01       	movw	r24, r14
    16b4:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    16b8:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    16bc:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    16c0:	6a e0       	ldi	r22, 0x0A	; 10
    16c2:	f8 01       	movw	r30, r16
    16c4:	86 81       	ldd	r24, Z+6	; 0x06
    16c6:	97 81       	ldd	r25, Z+7	; 0x07
    16c8:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    16cc:	7c 01       	movw	r14, r24
    16ce:	62 eb       	ldi	r22, 0xB2	; 178
    16d0:	73 e0       	ldi	r23, 0x03	; 3
    16d2:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    16d6:	b6 01       	movw	r22, r12
    16d8:	c7 01       	movw	r24, r14
    16da:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    16de:	66 e0       	ldi	r22, 0x06	; 6
    16e0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    16e4:	66 e0       	ldi	r22, 0x06	; 6
    16e6:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    16ea:	f8 01       	movw	r30, r16
    16ec:	86 81       	ldd	r24, Z+6	; 0x06
    16ee:	97 81       	ldd	r25, Z+7	; 0x07
    16f0:	0e 94 07 1a 	call	0x340e	; 0x340e <_Z15print_task_listP8emstream>
}
    16f4:	26 96       	adiw	r28, 0x06	; 6
    16f6:	cd bf       	out	0x3d, r28	; 61
    16f8:	de bf       	out	0x3e, r29	; 62
    16fa:	df 91       	pop	r29
    16fc:	cf 91       	pop	r28
    16fe:	1f 91       	pop	r17
    1700:	0f 91       	pop	r16
    1702:	ff 90       	pop	r15
    1704:	ef 90       	pop	r14
    1706:	df 90       	pop	r13
    1708:	cf 90       	pop	r12
    170a:	bf 90       	pop	r11
    170c:	af 90       	pop	r10
    170e:	08 95       	ret

00001710 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	00 d0       	rcall	.+0      	; 0x1716 <_ZN9task_user3runEv+0x6>
    1716:	00 d0       	rcall	.+0      	; 0x1718 <_ZN9task_user3runEv+0x8>
    1718:	cd b7       	in	r28, 0x3d	; 61
    171a:	de b7       	in	r29, 0x3e	; 62
    171c:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    171e:	19 82       	std	Y+1, r1	; 0x01
    1720:	1a 82       	std	Y+2, r1	; 0x02
    1722:	1b 82       	std	Y+3, r1	; 0x03
    1724:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1726:	1d 82       	std	Y+5, r1	; 0x05
    1728:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    172a:	6a e0       	ldi	r22, 0x0A	; 10
    172c:	dc 01       	movw	r26, r24
    172e:	16 96       	adiw	r26, 0x06	; 6
    1730:	8d 91       	ld	r24, X+
    1732:	9c 91       	ld	r25, X
    1734:	17 97       	sbiw	r26, 0x07	; 7
    1736:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    173a:	7c 01       	movw	r14, r24
    173c:	6e e4       	ldi	r22, 0x4E	; 78
    173e:	75 e0       	ldi	r23, 0x05	; 5
    1740:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1744:	66 e0       	ldi	r22, 0x06	; 6
    1746:	c7 01       	movw	r24, r14
    1748:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    174c:	f8 01       	movw	r30, r16
    174e:	84 85       	ldd	r24, Z+12	; 0x0c
    1750:	88 23       	and	r24, r24
    1752:	21 f0       	breq	.+8      	; 0x175c <_ZN9task_user3runEv+0x4c>
    1754:	81 30       	cpi	r24, 0x01	; 1
    1756:	09 f4       	brne	.+2      	; 0x175a <_ZN9task_user3runEv+0x4a>
    1758:	5d c0       	rjmp	.+186    	; 0x1814 <_ZN9task_user3runEv+0x104>
    175a:	d8 c0       	rjmp	.+432    	; 0x190c <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    175c:	86 81       	ldd	r24, Z+6	; 0x06
    175e:	97 81       	ldd	r25, Z+7	; 0x07
    1760:	dc 01       	movw	r26, r24
    1762:	ed 91       	ld	r30, X+
    1764:	fc 91       	ld	r31, X
    1766:	04 80       	ldd	r0, Z+4	; 0x04
    1768:	f5 81       	ldd	r31, Z+5	; 0x05
    176a:	e0 2d       	mov	r30, r0
    176c:	19 95       	eicall
    176e:	88 23       	and	r24, r24
    1770:	a9 f1       	breq	.+106    	; 0x17dc <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1772:	f8 01       	movw	r30, r16
    1774:	86 81       	ldd	r24, Z+6	; 0x06
    1776:	97 81       	ldd	r25, Z+7	; 0x07
    1778:	dc 01       	movw	r26, r24
    177a:	ed 91       	ld	r30, X+
    177c:	fc 91       	ld	r31, X
    177e:	06 80       	ldd	r0, Z+6	; 0x06
    1780:	f7 81       	ldd	r31, Z+7	; 0x07
    1782:	e0 2d       	mov	r30, r0
    1784:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1786:	99 27       	eor	r25, r25
    1788:	81 30       	cpi	r24, 0x01	; 1
    178a:	91 05       	cpc	r25, r1
    178c:	f9 f0       	breq	.+62     	; 0x17cc <_ZN9task_user3runEv+0xbc>
    178e:	03 97       	sbiw	r24, 0x03	; 3
    1790:	09 f0       	breq	.+2      	; 0x1794 <_ZN9task_user3runEv+0x84>
    1792:	d8 c0       	rjmp	.+432    	; 0x1944 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1794:	6a e0       	ldi	r22, 0x0A	; 10
    1796:	f8 01       	movw	r30, r16
    1798:	86 81       	ldd	r24, Z+6	; 0x06
    179a:	97 81       	ldd	r25, Z+7	; 0x07
    179c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    17a0:	8c 01       	movw	r16, r24
    17a2:	60 e4       	ldi	r22, 0x40	; 64
    17a4:	75 e0       	ldi	r23, 0x05	; 5
    17a6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    17aa:	66 e0       	ldi	r22, 0x06	; 6
    17ac:	c8 01       	movw	r24, r16
    17ae:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    17b2:	93 e0       	ldi	r25, 0x03	; 3
    17b4:	88 ed       	ldi	r24, 0xD8	; 216
    17b6:	08 b6       	in	r0, 0x38	; 56
    17b8:	18 be       	out	0x38, r1	; 56
    17ba:	84 bf       	out	0x34, r24	; 52
    17bc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    17c0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    17c4:	81 fd       	sbrc	r24, 1
    17c6:	fc cf       	rjmp	.-8      	; 0x17c0 <_ZN9task_user3runEv+0xb0>
    17c8:	08 be       	out	0x38, r0	; 56
    17ca:	ff cf       	rjmp	.-2      	; 0x17ca <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    17cc:	c8 01       	movw	r24, r16
    17ce:	0e 94 55 0a 	call	0x14aa	; 0x14aa <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    17d2:	61 e0       	ldi	r22, 0x01	; 1
    17d4:	c8 01       	movw	r24, r16
    17d6:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8frt_task13transition_toEh>
							break;
    17da:	b4 c0       	rjmp	.+360    	; 0x1944 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    17dc:	82 e8       	ldi	r24, 0x82	; 130
    17de:	92 e3       	ldi	r25, 0x32	; 50
    17e0:	0e 94 b6 1a 	call	0x356c	; 0x356c <_ZN14frt_text_queue14check_for_charEv>
    17e4:	88 23       	and	r24, r24
    17e6:	09 f4       	brne	.+2      	; 0x17ea <_ZN9task_user3runEv+0xda>
    17e8:	ad c0       	rjmp	.+346    	; 0x1944 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    17ea:	d8 01       	movw	r26, r16
    17ec:	16 96       	adiw	r26, 0x06	; 6
    17ee:	ed 91       	ld	r30, X+
    17f0:	fc 91       	ld	r31, X
    17f2:	17 97       	sbiw	r26, 0x07	; 7
    17f4:	01 90       	ld	r0, Z+
    17f6:	f0 81       	ld	r31, Z
    17f8:	e0 2d       	mov	r30, r0
    17fa:	e2 80       	ldd	r14, Z+2	; 0x02
    17fc:	f3 80       	ldd	r15, Z+3	; 0x03
    17fe:	82 e8       	ldi	r24, 0x82	; 130
    1800:	92 e3       	ldi	r25, 0x32	; 50
    1802:	0e 94 98 1a 	call	0x3530	; 0x3530 <_ZN14frt_text_queue7getcharEv>
    1806:	68 2f       	mov	r22, r24
    1808:	f8 01       	movw	r30, r16
    180a:	86 81       	ldd	r24, Z+6	; 0x06
    180c:	97 81       	ldd	r25, Z+7	; 0x07
    180e:	f7 01       	movw	r30, r14
    1810:	19 95       	eicall
    1812:	98 c0       	rjmp	.+304    	; 0x1944 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1814:	86 81       	ldd	r24, Z+6	; 0x06
    1816:	97 81       	ldd	r25, Z+7	; 0x07
    1818:	dc 01       	movw	r26, r24
    181a:	ed 91       	ld	r30, X+
    181c:	fc 91       	ld	r31, X
    181e:	04 80       	ldd	r0, Z+4	; 0x04
    1820:	f5 81       	ldd	r31, Z+5	; 0x05
    1822:	e0 2d       	mov	r30, r0
    1824:	19 95       	eicall
    1826:	88 23       	and	r24, r24
    1828:	09 f4       	brne	.+2      	; 0x182c <_ZN9task_user3runEv+0x11c>
    182a:	8c c0       	rjmp	.+280    	; 0x1944 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    182c:	f8 01       	movw	r30, r16
    182e:	86 81       	ldd	r24, Z+6	; 0x06
    1830:	97 81       	ldd	r25, Z+7	; 0x07
    1832:	dc 01       	movw	r26, r24
    1834:	ed 91       	ld	r30, X+
    1836:	fc 91       	ld	r31, X
    1838:	06 80       	ldd	r0, Z+6	; 0x06
    183a:	f7 81       	ldd	r31, Z+7	; 0x07
    183c:	e0 2d       	mov	r30, r0
    183e:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1840:	9c 01       	movw	r18, r24
    1842:	33 27       	eor	r19, r19
    1844:	28 36       	cpi	r18, 0x68	; 104
    1846:	31 05       	cpc	r19, r1
    1848:	59 f1       	breq	.+86     	; 0x18a0 <_ZN9task_user3runEv+0x190>
    184a:	3c f4       	brge	.+14     	; 0x185a <_ZN9task_user3runEv+0x14a>
    184c:	2b 31       	cpi	r18, 0x1B	; 27
    184e:	31 05       	cpc	r19, r1
    1850:	59 f1       	breq	.+86     	; 0x18a8 <_ZN9task_user3runEv+0x198>
    1852:	25 36       	cpi	r18, 0x65	; 101
    1854:	31 05       	cpc	r19, r1
    1856:	41 f1       	breq	.+80     	; 0x18a8 <_ZN9task_user3runEv+0x198>
    1858:	3b c0       	rjmp	.+118    	; 0x18d0 <_ZN9task_user3runEv+0x1c0>
    185a:	23 37       	cpi	r18, 0x73	; 115
    185c:	31 05       	cpc	r19, r1
    185e:	c1 f0       	breq	.+48     	; 0x1890 <_ZN9task_user3runEv+0x180>
    1860:	26 37       	cpi	r18, 0x76	; 118
    1862:	31 05       	cpc	r19, r1
    1864:	89 f0       	breq	.+34     	; 0x1888 <_ZN9task_user3runEv+0x178>
    1866:	2e 36       	cpi	r18, 0x6E	; 110
    1868:	31 05       	cpc	r19, r1
    186a:	91 f5       	brne	.+100    	; 0x18d0 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    186c:	ce 01       	movw	r24, r28
    186e:	01 96       	adiw	r24, 0x01	; 1
    1870:	0e 94 aa 1b 	call	0x3754	; 0x3754 <_ZN10time_stamp10set_to_nowEv>
    1874:	bc 01       	movw	r22, r24
    1876:	f8 01       	movw	r30, r16
    1878:	86 81       	ldd	r24, Z+6	; 0x06
    187a:	97 81       	ldd	r25, Z+7	; 0x07
    187c:	0e 94 4e 1b 	call	0x369c	; 0x369c <_ZlsR8emstreamR10time_stamp>
    1880:	66 e0       	ldi	r22, 0x06	; 6
    1882:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
							break;
    1886:	5e c0       	rjmp	.+188    	; 0x1944 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1888:	c8 01       	movw	r24, r16
    188a:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <_ZN9task_user11show_statusEv>
							break;
    188e:	5a c0       	rjmp	.+180    	; 0x1944 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1890:	d8 01       	movw	r26, r16
    1892:	16 96       	adiw	r26, 0x06	; 6
    1894:	8d 91       	ld	r24, X+
    1896:	9c 91       	ld	r25, X
    1898:	17 97       	sbiw	r26, 0x07	; 7
    189a:	0e 94 0e 19 	call	0x321c	; 0x321c <_Z17print_task_stacksP8emstream>
							break;
    189e:	52 c0       	rjmp	.+164    	; 0x1944 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    18a0:	c8 01       	movw	r24, r16
    18a2:	0e 94 55 0a 	call	0x14aa	; 0x14aa <_ZN9task_user18print_help_messageEv>
							break;
    18a6:	4e c0       	rjmp	.+156    	; 0x1944 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    18a8:	6a e0       	ldi	r22, 0x0A	; 10
    18aa:	f8 01       	movw	r30, r16
    18ac:	86 81       	ldd	r24, Z+6	; 0x06
    18ae:	97 81       	ldd	r25, Z+7	; 0x07
    18b0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    18b4:	7c 01       	movw	r14, r24
    18b6:	6e e2       	ldi	r22, 0x2E	; 46
    18b8:	75 e0       	ldi	r23, 0x05	; 5
    18ba:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    18be:	66 e0       	ldi	r22, 0x06	; 6
    18c0:	c7 01       	movw	r24, r14
    18c2:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    18c6:	60 e0       	ldi	r22, 0x00	; 0
    18c8:	c8 01       	movw	r24, r16
    18ca:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8frt_task13transition_toEh>
							break;
    18ce:	3a c0       	rjmp	.+116    	; 0x1944 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    18d0:	f8 01       	movw	r30, r16
    18d2:	a6 81       	ldd	r26, Z+6	; 0x06
    18d4:	b7 81       	ldd	r27, Z+7	; 0x07
    18d6:	ed 91       	ld	r30, X+
    18d8:	fc 91       	ld	r31, X
    18da:	11 97       	sbiw	r26, 0x01	; 1
    18dc:	02 80       	ldd	r0, Z+2	; 0x02
    18de:	f3 81       	ldd	r31, Z+3	; 0x03
    18e0:	e0 2d       	mov	r30, r0
    18e2:	68 2f       	mov	r22, r24
    18e4:	cd 01       	movw	r24, r26
    18e6:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    18e8:	6a e0       	ldi	r22, 0x0A	; 10
    18ea:	d8 01       	movw	r26, r16
    18ec:	16 96       	adiw	r26, 0x06	; 6
    18ee:	8d 91       	ld	r24, X+
    18f0:	9c 91       	ld	r25, X
    18f2:	17 97       	sbiw	r26, 0x07	; 7
    18f4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    18f8:	7c 01       	movw	r14, r24
    18fa:	68 e2       	ldi	r22, 0x28	; 40
    18fc:	75 e0       	ldi	r23, 0x05	; 5
    18fe:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1902:	66 e0       	ldi	r22, 0x06	; 6
    1904:	c7 01       	movw	r24, r14
    1906:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
							break;
    190a:	1c c0       	rjmp	.+56     	; 0x1944 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    190c:	6a e0       	ldi	r22, 0x0A	; 10
    190e:	f8 01       	movw	r30, r16
    1910:	86 81       	ldd	r24, Z+6	; 0x06
    1912:	97 81       	ldd	r25, Z+7	; 0x07
    1914:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    1918:	8c 01       	movw	r16, r24
    191a:	6b e0       	ldi	r22, 0x0B	; 11
    191c:	75 e0       	ldi	r23, 0x05	; 5
    191e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    1922:	66 e0       	ldi	r22, 0x06	; 6
    1924:	c8 01       	movw	r24, r16
    1926:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    192a:	93 e0       	ldi	r25, 0x03	; 3
    192c:	88 ed       	ldi	r24, 0xD8	; 216
    192e:	08 b6       	in	r0, 0x38	; 56
    1930:	18 be       	out	0x38, r1	; 56
    1932:	84 bf       	out	0x34, r24	; 52
    1934:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1938:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    193c:	81 fd       	sbrc	r24, 1
    193e:	fc cf       	rjmp	.-8      	; 0x1938 <_ZN9task_user3runEv+0x228>
    1940:	08 be       	out	0x38, r0	; 56
    1942:	ff cf       	rjmp	.-2      	; 0x1942 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1944:	f8 01       	movw	r30, r16
    1946:	86 85       	ldd	r24, Z+14	; 0x0e
    1948:	97 85       	ldd	r25, Z+15	; 0x0f
    194a:	a0 89       	ldd	r26, Z+16	; 0x10
    194c:	b1 89       	ldd	r27, Z+17	; 0x11
    194e:	01 96       	adiw	r24, 0x01	; 1
    1950:	a1 1d       	adc	r26, r1
    1952:	b1 1d       	adc	r27, r1
    1954:	86 87       	std	Z+14, r24	; 0x0e
    1956:	97 87       	std	Z+15, r25	; 0x0f
    1958:	a0 8b       	std	Z+16, r26	; 0x10
    195a:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    195c:	61 e0       	ldi	r22, 0x01	; 1
    195e:	70 e0       	ldi	r23, 0x00	; 0
    1960:	80 e0       	ldi	r24, 0x00	; 0
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1968:	f1 ce       	rjmp	.-542    	; 0x174c <_ZN9task_user3runEv+0x3c>

0000196a <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    196a:	0f 93       	push	r16
    196c:	1f 93       	push	r17
    196e:	cf 93       	push	r28
    1970:	df 93       	push	r29
    1972:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1974:	0e 94 25 14 	call	0x284a	; 0x284a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1978:	80 91 c6 21 	lds	r24, 0x21C6	; 0x8021c6 <__data_end>
    197c:	81 11       	cpse	r24, r1
    197e:	1d c0       	rjmp	.+58     	; 0x19ba <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1980:	ab ec       	ldi	r26, 0xCB	; 203
    1982:	b1 e2       	ldi	r27, 0x21	; 33
    1984:	ef ec       	ldi	r30, 0xCF	; 207
    1986:	f1 e2       	ldi	r31, 0x21	; 33
    1988:	ed 93       	st	X+, r30
    198a:	fc 93       	st	X, r31
    198c:	11 97       	sbiw	r26, 0x01	; 1
    198e:	12 96       	adiw	r26, 0x02	; 2
    1990:	1d 92       	st	X+, r1
    1992:	1c 92       	st	X, r1
    1994:	13 97       	sbiw	r26, 0x03	; 3
    1996:	a7 ec       	ldi	r26, 0xC7	; 199
    1998:	b1 e2       	ldi	r27, 0x21	; 33
    199a:	8f ef       	ldi	r24, 0xFF	; 255
    199c:	9f e0       	ldi	r25, 0x0F	; 15
    199e:	12 96       	adiw	r26, 0x02	; 2
    19a0:	8d 93       	st	X+, r24
    19a2:	9c 93       	st	X, r25
    19a4:	13 97       	sbiw	r26, 0x03	; 3
    19a6:	1d 92       	st	X+, r1
    19a8:	1c 92       	st	X, r1
    19aa:	11 97       	sbiw	r26, 0x01	; 1
    19ac:	82 83       	std	Z+2, r24	; 0x02
    19ae:	93 83       	std	Z+3, r25	; 0x03
    19b0:	a0 83       	st	Z, r26
    19b2:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	80 93 c6 21 	sts	0x21C6, r24	; 0x8021c6 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    19ba:	20 97       	sbiw	r28, 0x00	; 0
    19bc:	09 f4       	brne	.+2      	; 0x19c0 <pvPortMalloc+0x56>
    19be:	5f c0       	rjmp	.+190    	; 0x1a7e <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    19c0:	9e 01       	movw	r18, r28
    19c2:	2b 5f       	subi	r18, 0xFB	; 251
    19c4:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    19c6:	24 96       	adiw	r28, 0x04	; 4
    19c8:	ce 3f       	cpi	r28, 0xFE	; 254
    19ca:	df 40       	sbci	r29, 0x0F	; 15
    19cc:	08 f0       	brcs	.+2      	; 0x19d0 <pvPortMalloc+0x66>
    19ce:	5a c0       	rjmp	.+180    	; 0x1a84 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    19d0:	e0 91 cb 21 	lds	r30, 0x21CB	; 0x8021cb <xStart>
    19d4:	f0 91 cc 21 	lds	r31, 0x21CC	; 0x8021cc <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    19d8:	ab ec       	ldi	r26, 0xCB	; 203
    19da:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19dc:	02 c0       	rjmp	.+4      	; 0x19e2 <pvPortMalloc+0x78>
    19de:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    19e0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19e2:	82 81       	ldd	r24, Z+2	; 0x02
    19e4:	93 81       	ldd	r25, Z+3	; 0x03
    19e6:	82 17       	cp	r24, r18
    19e8:	93 07       	cpc	r25, r19
    19ea:	20 f4       	brcc	.+8      	; 0x19f4 <pvPortMalloc+0x8a>
    19ec:	80 81       	ld	r24, Z
    19ee:	91 81       	ldd	r25, Z+1	; 0x01
    19f0:	00 97       	sbiw	r24, 0x00	; 0
    19f2:	a9 f7       	brne	.-22     	; 0x19de <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    19f4:	c1 e2       	ldi	r28, 0x21	; 33
    19f6:	e7 3c       	cpi	r30, 0xC7	; 199
    19f8:	fc 07       	cpc	r31, r28
    19fa:	09 f4       	brne	.+2      	; 0x19fe <pvPortMalloc+0x94>
    19fc:	46 c0       	rjmp	.+140    	; 0x1a8a <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    19fe:	cd 91       	ld	r28, X+
    1a00:	dc 91       	ld	r29, X
    1a02:	11 97       	sbiw	r26, 0x01	; 1
    1a04:	8e 01       	movw	r16, r28
    1a06:	0b 5f       	subi	r16, 0xFB	; 251
    1a08:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1a0a:	80 81       	ld	r24, Z
    1a0c:	91 81       	ldd	r25, Z+1	; 0x01
    1a0e:	8d 93       	st	X+, r24
    1a10:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1a12:	82 81       	ldd	r24, Z+2	; 0x02
    1a14:	93 81       	ldd	r25, Z+3	; 0x03
    1a16:	82 1b       	sub	r24, r18
    1a18:	93 0b       	sbc	r25, r19
    1a1a:	8b 30       	cpi	r24, 0x0B	; 11
    1a1c:	91 05       	cpc	r25, r1
    1a1e:	10 f1       	brcs	.+68     	; 0x1a64 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1a20:	bf 01       	movw	r22, r30
    1a22:	62 0f       	add	r22, r18
    1a24:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1a26:	db 01       	movw	r26, r22
    1a28:	12 96       	adiw	r26, 0x02	; 2
    1a2a:	8d 93       	st	X+, r24
    1a2c:	9c 93       	st	X, r25
    1a2e:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1a30:	22 83       	std	Z+2, r18	; 0x02
    1a32:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1a34:	12 96       	adiw	r26, 0x02	; 2
    1a36:	4d 91       	ld	r20, X+
    1a38:	5c 91       	ld	r21, X
    1a3a:	13 97       	sbiw	r26, 0x03	; 3
    1a3c:	8b ec       	ldi	r24, 0xCB	; 203
    1a3e:	91 e2       	ldi	r25, 0x21	; 33
    1a40:	01 c0       	rjmp	.+2      	; 0x1a44 <pvPortMalloc+0xda>
    1a42:	cd 01       	movw	r24, r26
    1a44:	ec 01       	movw	r28, r24
    1a46:	a8 81       	ld	r26, Y
    1a48:	b9 81       	ldd	r27, Y+1	; 0x01
    1a4a:	12 96       	adiw	r26, 0x02	; 2
    1a4c:	2d 91       	ld	r18, X+
    1a4e:	3c 91       	ld	r19, X
    1a50:	13 97       	sbiw	r26, 0x03	; 3
    1a52:	24 17       	cp	r18, r20
    1a54:	35 07       	cpc	r19, r21
    1a56:	a8 f3       	brcs	.-22     	; 0x1a42 <pvPortMalloc+0xd8>
    1a58:	eb 01       	movw	r28, r22
    1a5a:	a8 83       	st	Y, r26
    1a5c:	b9 83       	std	Y+1, r27	; 0x01
    1a5e:	dc 01       	movw	r26, r24
    1a60:	6d 93       	st	X+, r22
    1a62:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1a64:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1a68:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1a6c:	22 81       	ldd	r18, Z+2	; 0x02
    1a6e:	33 81       	ldd	r19, Z+3	; 0x03
    1a70:	82 1b       	sub	r24, r18
    1a72:	93 0b       	sbc	r25, r19
    1a74:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1a78:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1a7c:	08 c0       	rjmp	.+16     	; 0x1a8e <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1a7e:	00 e0       	ldi	r16, 0x00	; 0
    1a80:	10 e0       	ldi	r17, 0x00	; 0
    1a82:	05 c0       	rjmp	.+10     	; 0x1a8e <pvPortMalloc+0x124>
    1a84:	00 e0       	ldi	r16, 0x00	; 0
    1a86:	10 e0       	ldi	r17, 0x00	; 0
    1a88:	02 c0       	rjmp	.+4      	; 0x1a8e <pvPortMalloc+0x124>
    1a8a:	00 e0       	ldi	r16, 0x00	; 0
    1a8c:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1a8e:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a92:	c8 01       	movw	r24, r16
    1a94:	df 91       	pop	r29
    1a96:	cf 91       	pop	r28
    1a98:	1f 91       	pop	r17
    1a9a:	0f 91       	pop	r16
    1a9c:	08 95       	ret

00001a9e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1aa6:	00 97       	sbiw	r24, 0x00	; 0
    1aa8:	41 f1       	breq	.+80     	; 0x1afa <vPortFree+0x5c>
    1aaa:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1aac:	8c 01       	movw	r16, r24
    1aae:	05 50       	subi	r16, 0x05	; 5
    1ab0:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1ab2:	0e 94 25 14 	call	0x284a	; 0x284a <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	42 81       	ldd	r20, Z+2	; 0x02
    1aba:	53 81       	ldd	r21, Z+3	; 0x03
    1abc:	ab ec       	ldi	r26, 0xCB	; 203
    1abe:	b1 e2       	ldi	r27, 0x21	; 33
    1ac0:	01 c0       	rjmp	.+2      	; 0x1ac4 <vPortFree+0x26>
    1ac2:	df 01       	movw	r26, r30
    1ac4:	ed 91       	ld	r30, X+
    1ac6:	fc 91       	ld	r31, X
    1ac8:	11 97       	sbiw	r26, 0x01	; 1
    1aca:	22 81       	ldd	r18, Z+2	; 0x02
    1acc:	33 81       	ldd	r19, Z+3	; 0x03
    1ace:	24 17       	cp	r18, r20
    1ad0:	35 07       	cpc	r19, r21
    1ad2:	b8 f3       	brcs	.-18     	; 0x1ac2 <vPortFree+0x24>
    1ad4:	25 97       	sbiw	r28, 0x05	; 5
    1ad6:	e8 83       	st	Y, r30
    1ad8:	f9 83       	std	Y+1, r31	; 0x01
    1ada:	0d 93       	st	X+, r16
    1adc:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1ade:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1ae2:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aea:	82 0f       	add	r24, r18
    1aec:	93 1f       	adc	r25, r19
    1aee:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1af2:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1af6:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
	}
}
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	08 95       	ret

00001b04 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1b04:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1b08:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1b0c:	08 95       	ret

00001b0e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1b0e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1b10:	03 96       	adiw	r24, 0x03	; 3
    1b12:	81 83       	std	Z+1, r24	; 0x01
    1b14:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b16:	4f ef       	ldi	r20, 0xFF	; 255
    1b18:	5f ef       	ldi	r21, 0xFF	; 255
    1b1a:	ba 01       	movw	r22, r20
    1b1c:	43 83       	std	Z+3, r20	; 0x03
    1b1e:	54 83       	std	Z+4, r21	; 0x04
    1b20:	65 83       	std	Z+5, r22	; 0x05
    1b22:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1b24:	87 83       	std	Z+7, r24	; 0x07
    1b26:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1b28:	81 87       	std	Z+9, r24	; 0x09
    1b2a:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1b2c:	10 82       	st	Z, r1
    1b2e:	08 95       	ret

00001b30 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b30:	fc 01       	movw	r30, r24
    1b32:	12 86       	std	Z+10, r1	; 0x0a
    1b34:	13 86       	std	Z+11, r1	; 0x0b
    1b36:	08 95       	ret

00001b38 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1b38:	cf 93       	push	r28
    1b3a:	df 93       	push	r29
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1b40:	21 81       	ldd	r18, Z+1	; 0x01
    1b42:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1b44:	e9 01       	movw	r28, r18
    1b46:	8c 81       	ldd	r24, Y+4	; 0x04
    1b48:	9d 81       	ldd	r25, Y+5	; 0x05
    1b4a:	14 96       	adiw	r26, 0x04	; 4
    1b4c:	8d 93       	st	X+, r24
    1b4e:	9c 93       	st	X, r25
    1b50:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1b52:	81 81       	ldd	r24, Z+1	; 0x01
    1b54:	92 81       	ldd	r25, Z+2	; 0x02
    1b56:	16 96       	adiw	r26, 0x06	; 6
    1b58:	8d 93       	st	X+, r24
    1b5a:	9c 93       	st	X, r25
    1b5c:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1b5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b60:	9d 81       	ldd	r25, Y+5	; 0x05
    1b62:	ec 01       	movw	r28, r24
    1b64:	6e 83       	std	Y+6, r22	; 0x06
    1b66:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1b68:	e9 01       	movw	r28, r18
    1b6a:	6c 83       	std	Y+4, r22	; 0x04
    1b6c:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1b6e:	61 83       	std	Z+1, r22	; 0x01
    1b70:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1b72:	1a 96       	adiw	r26, 0x0a	; 10
    1b74:	ed 93       	st	X+, r30
    1b76:	fc 93       	st	X, r31
    1b78:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1b7a:	80 81       	ld	r24, Z
    1b7c:	8f 5f       	subi	r24, 0xFF	; 255
    1b7e:	80 83       	st	Z, r24
}
    1b80:	df 91       	pop	r29
    1b82:	cf 91       	pop	r28
    1b84:	08 95       	ret

00001b86 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1b86:	0f 93       	push	r16
    1b88:	1f 93       	push	r17
    1b8a:	cf 93       	push	r28
    1b8c:	df 93       	push	r29
    1b8e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1b90:	08 81       	ld	r16, Y
    1b92:	19 81       	ldd	r17, Y+1	; 0x01
    1b94:	2a 81       	ldd	r18, Y+2	; 0x02
    1b96:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1b98:	0f 3f       	cpi	r16, 0xFF	; 255
    1b9a:	4f ef       	ldi	r20, 0xFF	; 255
    1b9c:	14 07       	cpc	r17, r20
    1b9e:	24 07       	cpc	r18, r20
    1ba0:	34 07       	cpc	r19, r20
    1ba2:	31 f4       	brne	.+12     	; 0x1bb0 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1ba4:	dc 01       	movw	r26, r24
    1ba6:	19 96       	adiw	r26, 0x09	; 9
    1ba8:	ed 91       	ld	r30, X+
    1baa:	fc 91       	ld	r31, X
    1bac:	1a 97       	sbiw	r26, 0x0a	; 10
    1bae:	1f c0       	rjmp	.+62     	; 0x1bee <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1bb0:	fc 01       	movw	r30, r24
    1bb2:	33 96       	adiw	r30, 0x03	; 3
    1bb4:	dc 01       	movw	r26, r24
    1bb6:	17 96       	adiw	r26, 0x07	; 7
    1bb8:	4d 91       	ld	r20, X+
    1bba:	5c 91       	ld	r21, X
    1bbc:	18 97       	sbiw	r26, 0x08	; 8
    1bbe:	da 01       	movw	r26, r20
    1bc0:	4d 91       	ld	r20, X+
    1bc2:	5d 91       	ld	r21, X+
    1bc4:	6d 91       	ld	r22, X+
    1bc6:	7c 91       	ld	r23, X
    1bc8:	04 17       	cp	r16, r20
    1bca:	15 07       	cpc	r17, r21
    1bcc:	26 07       	cpc	r18, r22
    1bce:	37 07       	cpc	r19, r23
    1bd0:	70 f0       	brcs	.+28     	; 0x1bee <vListInsert+0x68>
    1bd2:	04 80       	ldd	r0, Z+4	; 0x04
    1bd4:	f5 81       	ldd	r31, Z+5	; 0x05
    1bd6:	e0 2d       	mov	r30, r0
    1bd8:	a4 81       	ldd	r26, Z+4	; 0x04
    1bda:	b5 81       	ldd	r27, Z+5	; 0x05
    1bdc:	4d 91       	ld	r20, X+
    1bde:	5d 91       	ld	r21, X+
    1be0:	6d 91       	ld	r22, X+
    1be2:	7c 91       	ld	r23, X
    1be4:	04 17       	cp	r16, r20
    1be6:	15 07       	cpc	r17, r21
    1be8:	26 07       	cpc	r18, r22
    1bea:	37 07       	cpc	r19, r23
    1bec:	90 f7       	brcc	.-28     	; 0x1bd2 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1bee:	a4 81       	ldd	r26, Z+4	; 0x04
    1bf0:	b5 81       	ldd	r27, Z+5	; 0x05
    1bf2:	ac 83       	std	Y+4, r26	; 0x04
    1bf4:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1bf6:	16 96       	adiw	r26, 0x06	; 6
    1bf8:	cd 93       	st	X+, r28
    1bfa:	dc 93       	st	X, r29
    1bfc:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1bfe:	ee 83       	std	Y+6, r30	; 0x06
    1c00:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1c02:	c4 83       	std	Z+4, r28	; 0x04
    1c04:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c06:	8a 87       	std	Y+10, r24	; 0x0a
    1c08:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1c0a:	fc 01       	movw	r30, r24
    1c0c:	20 81       	ld	r18, Z
    1c0e:	2f 5f       	subi	r18, 0xFF	; 255
    1c10:	20 83       	st	Z, r18
}
    1c12:	df 91       	pop	r29
    1c14:	cf 91       	pop	r28
    1c16:	1f 91       	pop	r17
    1c18:	0f 91       	pop	r16
    1c1a:	08 95       	ret

00001c1c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1c1c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c1e:	a4 81       	ldd	r26, Z+4	; 0x04
    1c20:	b5 81       	ldd	r27, Z+5	; 0x05
    1c22:	86 81       	ldd	r24, Z+6	; 0x06
    1c24:	97 81       	ldd	r25, Z+7	; 0x07
    1c26:	16 96       	adiw	r26, 0x06	; 6
    1c28:	8d 93       	st	X+, r24
    1c2a:	9c 93       	st	X, r25
    1c2c:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c2e:	a6 81       	ldd	r26, Z+6	; 0x06
    1c30:	b7 81       	ldd	r27, Z+7	; 0x07
    1c32:	84 81       	ldd	r24, Z+4	; 0x04
    1c34:	95 81       	ldd	r25, Z+5	; 0x05
    1c36:	14 96       	adiw	r26, 0x04	; 4
    1c38:	8d 93       	st	X+, r24
    1c3a:	9c 93       	st	X, r25
    1c3c:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1c3e:	a2 85       	ldd	r26, Z+10	; 0x0a
    1c40:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c42:	11 96       	adiw	r26, 0x01	; 1
    1c44:	8d 91       	ld	r24, X+
    1c46:	9c 91       	ld	r25, X
    1c48:	12 97       	sbiw	r26, 0x02	; 2
    1c4a:	e8 17       	cp	r30, r24
    1c4c:	f9 07       	cpc	r31, r25
    1c4e:	31 f4       	brne	.+12     	; 0x1c5c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c50:	86 81       	ldd	r24, Z+6	; 0x06
    1c52:	97 81       	ldd	r25, Z+7	; 0x07
    1c54:	11 96       	adiw	r26, 0x01	; 1
    1c56:	8d 93       	st	X+, r24
    1c58:	9c 93       	st	X, r25
    1c5a:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1c5c:	12 86       	std	Z+10, r1	; 0x0a
    1c5e:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1c60:	8c 91       	ld	r24, X
    1c62:	81 50       	subi	r24, 0x01	; 1
    1c64:	8c 93       	st	X, r24
    1c66:	08 95       	ret

00001c68 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c68:	80 93 92 32 	sts	0x3292, r24	; 0x803292 <portStackTopForTask>
    1c6c:	90 93 93 32 	sts	0x3293, r25	; 0x803293 <portStackTopForTask+0x1>
    1c70:	31 e1       	ldi	r19, 0x11	; 17
    1c72:	fc 01       	movw	r30, r24
    1c74:	30 83       	st	Z, r19
    1c76:	31 97       	sbiw	r30, 0x01	; 1
    1c78:	22 e2       	ldi	r18, 0x22	; 34
    1c7a:	20 83       	st	Z, r18
    1c7c:	31 97       	sbiw	r30, 0x01	; 1
    1c7e:	a3 e3       	ldi	r26, 0x33	; 51
    1c80:	a0 83       	st	Z, r26
    1c82:	31 97       	sbiw	r30, 0x01	; 1
    1c84:	60 83       	st	Z, r22
    1c86:	31 97       	sbiw	r30, 0x01	; 1
    1c88:	70 83       	st	Z, r23
    1c8a:	31 97       	sbiw	r30, 0x01	; 1
    1c8c:	10 82       	st	Z, r1
    1c8e:	31 97       	sbiw	r30, 0x01	; 1
    1c90:	10 82       	st	Z, r1
    1c92:	31 97       	sbiw	r30, 0x01	; 1
    1c94:	60 e8       	ldi	r22, 0x80	; 128
    1c96:	60 83       	st	Z, r22
    1c98:	31 97       	sbiw	r30, 0x01	; 1
    1c9a:	10 82       	st	Z, r1
    1c9c:	31 97       	sbiw	r30, 0x01	; 1
    1c9e:	10 82       	st	Z, r1
    1ca0:	31 97       	sbiw	r30, 0x01	; 1
    1ca2:	10 82       	st	Z, r1
    1ca4:	31 97       	sbiw	r30, 0x01	; 1
    1ca6:	62 e0       	ldi	r22, 0x02	; 2
    1ca8:	60 83       	st	Z, r22
    1caa:	31 97       	sbiw	r30, 0x01	; 1
    1cac:	63 e0       	ldi	r22, 0x03	; 3
    1cae:	60 83       	st	Z, r22
    1cb0:	31 97       	sbiw	r30, 0x01	; 1
    1cb2:	64 e0       	ldi	r22, 0x04	; 4
    1cb4:	60 83       	st	Z, r22
    1cb6:	31 97       	sbiw	r30, 0x01	; 1
    1cb8:	65 e0       	ldi	r22, 0x05	; 5
    1cba:	60 83       	st	Z, r22
    1cbc:	31 97       	sbiw	r30, 0x01	; 1
    1cbe:	66 e0       	ldi	r22, 0x06	; 6
    1cc0:	60 83       	st	Z, r22
    1cc2:	31 97       	sbiw	r30, 0x01	; 1
    1cc4:	67 e0       	ldi	r22, 0x07	; 7
    1cc6:	60 83       	st	Z, r22
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	68 e0       	ldi	r22, 0x08	; 8
    1ccc:	60 83       	st	Z, r22
    1cce:	31 97       	sbiw	r30, 0x01	; 1
    1cd0:	69 e0       	ldi	r22, 0x09	; 9
    1cd2:	60 83       	st	Z, r22
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	60 e1       	ldi	r22, 0x10	; 16
    1cd8:	60 83       	st	Z, r22
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	30 83       	st	Z, r19
    1cde:	31 97       	sbiw	r30, 0x01	; 1
    1ce0:	32 e1       	ldi	r19, 0x12	; 18
    1ce2:	30 83       	st	Z, r19
    1ce4:	31 97       	sbiw	r30, 0x01	; 1
    1ce6:	33 e1       	ldi	r19, 0x13	; 19
    1ce8:	30 83       	st	Z, r19
    1cea:	31 97       	sbiw	r30, 0x01	; 1
    1cec:	34 e1       	ldi	r19, 0x14	; 20
    1cee:	30 83       	st	Z, r19
    1cf0:	31 97       	sbiw	r30, 0x01	; 1
    1cf2:	35 e1       	ldi	r19, 0x15	; 21
    1cf4:	30 83       	st	Z, r19
    1cf6:	31 97       	sbiw	r30, 0x01	; 1
    1cf8:	36 e1       	ldi	r19, 0x16	; 22
    1cfa:	30 83       	st	Z, r19
    1cfc:	31 97       	sbiw	r30, 0x01	; 1
    1cfe:	37 e1       	ldi	r19, 0x17	; 23
    1d00:	30 83       	st	Z, r19
    1d02:	31 97       	sbiw	r30, 0x01	; 1
    1d04:	38 e1       	ldi	r19, 0x18	; 24
    1d06:	30 83       	st	Z, r19
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	39 e1       	ldi	r19, 0x19	; 25
    1d0c:	30 83       	st	Z, r19
    1d0e:	31 97       	sbiw	r30, 0x01	; 1
    1d10:	30 e2       	ldi	r19, 0x20	; 32
    1d12:	30 83       	st	Z, r19
    1d14:	31 97       	sbiw	r30, 0x01	; 1
    1d16:	31 e2       	ldi	r19, 0x21	; 33
    1d18:	30 83       	st	Z, r19
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	20 83       	st	Z, r18
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	23 e2       	ldi	r18, 0x23	; 35
    1d22:	20 83       	st	Z, r18
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	40 83       	st	Z, r20
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	50 83       	st	Z, r21
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	26 e2       	ldi	r18, 0x26	; 38
    1d30:	20 83       	st	Z, r18
    1d32:	31 97       	sbiw	r30, 0x01	; 1
    1d34:	27 e2       	ldi	r18, 0x27	; 39
    1d36:	20 83       	st	Z, r18
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	28 e2       	ldi	r18, 0x28	; 40
    1d3c:	20 83       	st	Z, r18
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	29 e2       	ldi	r18, 0x29	; 41
    1d42:	20 83       	st	Z, r18
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	20 e3       	ldi	r18, 0x30	; 48
    1d48:	20 83       	st	Z, r18
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	21 e3       	ldi	r18, 0x31	; 49
    1d4e:	20 83       	st	Z, r18
    1d50:	89 97       	sbiw	r24, 0x29	; 41
    1d52:	08 95       	ret

00001d54 <xPortStartScheduler>:
    1d54:	8c e7       	ldi	r24, 0x7C	; 124
    1d56:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1d5a:	8f ef       	ldi	r24, 0xFF	; 255
    1d5c:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    1d60:	81 e0       	ldi	r24, 0x01	; 1
    1d62:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1d66:	91 e1       	ldi	r25, 0x11	; 17
    1d68:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1d6c:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    1d70:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1d74:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1d78:	cd 91       	ld	r28, X+
    1d7a:	cd bf       	out	0x3d, r28	; 61
    1d7c:	dd 91       	ld	r29, X+
    1d7e:	de bf       	out	0x3e, r29	; 62
    1d80:	ff 91       	pop	r31
    1d82:	ef 91       	pop	r30
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	bf 91       	pop	r27
    1d8a:	af 91       	pop	r26
    1d8c:	9f 91       	pop	r25
    1d8e:	8f 91       	pop	r24
    1d90:	7f 91       	pop	r23
    1d92:	6f 91       	pop	r22
    1d94:	5f 91       	pop	r21
    1d96:	4f 91       	pop	r20
    1d98:	3f 91       	pop	r19
    1d9a:	2f 91       	pop	r18
    1d9c:	1f 91       	pop	r17
    1d9e:	0f 91       	pop	r16
    1da0:	ff 90       	pop	r15
    1da2:	ef 90       	pop	r14
    1da4:	df 90       	pop	r13
    1da6:	cf 90       	pop	r12
    1da8:	bf 90       	pop	r11
    1daa:	af 90       	pop	r10
    1dac:	9f 90       	pop	r9
    1dae:	8f 90       	pop	r8
    1db0:	7f 90       	pop	r7
    1db2:	6f 90       	pop	r6
    1db4:	5f 90       	pop	r5
    1db6:	4f 90       	pop	r4
    1db8:	3f 90       	pop	r3
    1dba:	2f 90       	pop	r2
    1dbc:	1f 90       	pop	r1
    1dbe:	0f 90       	pop	r0
    1dc0:	0c be       	out	0x3c, r0	; 60
    1dc2:	0f 90       	pop	r0
    1dc4:	0b be       	out	0x3b, r0	; 59
    1dc6:	0f 90       	pop	r0
    1dc8:	0f be       	out	0x3f, r0	; 63
    1dca:	0f 90       	pop	r0
    1dcc:	08 95       	ret
    1dce:	08 95       	ret

00001dd0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1dd0:	0f 92       	push	r0
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	0f 92       	push	r0
    1dd8:	0b b6       	in	r0, 0x3b	; 59
    1dda:	0f 92       	push	r0
    1ddc:	0c b6       	in	r0, 0x3c	; 60
    1dde:	0f 92       	push	r0
    1de0:	1f 92       	push	r1
    1de2:	11 24       	eor	r1, r1
    1de4:	2f 92       	push	r2
    1de6:	3f 92       	push	r3
    1de8:	4f 92       	push	r4
    1dea:	5f 92       	push	r5
    1dec:	6f 92       	push	r6
    1dee:	7f 92       	push	r7
    1df0:	8f 92       	push	r8
    1df2:	9f 92       	push	r9
    1df4:	af 92       	push	r10
    1df6:	bf 92       	push	r11
    1df8:	cf 92       	push	r12
    1dfa:	df 92       	push	r13
    1dfc:	ef 92       	push	r14
    1dfe:	ff 92       	push	r15
    1e00:	0f 93       	push	r16
    1e02:	1f 93       	push	r17
    1e04:	2f 93       	push	r18
    1e06:	3f 93       	push	r19
    1e08:	4f 93       	push	r20
    1e0a:	5f 93       	push	r21
    1e0c:	6f 93       	push	r22
    1e0e:	7f 93       	push	r23
    1e10:	8f 93       	push	r24
    1e12:	9f 93       	push	r25
    1e14:	af 93       	push	r26
    1e16:	bf 93       	push	r27
    1e18:	cf 93       	push	r28
    1e1a:	df 93       	push	r29
    1e1c:	ef 93       	push	r30
    1e1e:	ff 93       	push	r31
    1e20:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1e24:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1e28:	0d b6       	in	r0, 0x3d	; 61
    1e2a:	0d 92       	st	X+, r0
    1e2c:	0e b6       	in	r0, 0x3e	; 62
    1e2e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1e30:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e34:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1e38:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1e3c:	cd 91       	ld	r28, X+
    1e3e:	cd bf       	out	0x3d, r28	; 61
    1e40:	dd 91       	ld	r29, X+
    1e42:	de bf       	out	0x3e, r29	; 62
    1e44:	ff 91       	pop	r31
    1e46:	ef 91       	pop	r30
    1e48:	df 91       	pop	r29
    1e4a:	cf 91       	pop	r28
    1e4c:	bf 91       	pop	r27
    1e4e:	af 91       	pop	r26
    1e50:	9f 91       	pop	r25
    1e52:	8f 91       	pop	r24
    1e54:	7f 91       	pop	r23
    1e56:	6f 91       	pop	r22
    1e58:	5f 91       	pop	r21
    1e5a:	4f 91       	pop	r20
    1e5c:	3f 91       	pop	r19
    1e5e:	2f 91       	pop	r18
    1e60:	1f 91       	pop	r17
    1e62:	0f 91       	pop	r16
    1e64:	ff 90       	pop	r15
    1e66:	ef 90       	pop	r14
    1e68:	df 90       	pop	r13
    1e6a:	cf 90       	pop	r12
    1e6c:	bf 90       	pop	r11
    1e6e:	af 90       	pop	r10
    1e70:	9f 90       	pop	r9
    1e72:	8f 90       	pop	r8
    1e74:	7f 90       	pop	r7
    1e76:	6f 90       	pop	r6
    1e78:	5f 90       	pop	r5
    1e7a:	4f 90       	pop	r4
    1e7c:	3f 90       	pop	r3
    1e7e:	2f 90       	pop	r2
    1e80:	1f 90       	pop	r1
    1e82:	0f 90       	pop	r0
    1e84:	0c be       	out	0x3c, r0	; 60
    1e86:	0f 90       	pop	r0
    1e88:	0b be       	out	0x3b, r0	; 59
    1e8a:	0f 90       	pop	r0
    1e8c:	0f be       	out	0x3f, r0	; 63
    1e8e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1e90:	08 95       	ret

00001e92 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e92:	0f 92       	push	r0
    1e94:	0f b6       	in	r0, 0x3f	; 63
    1e96:	f8 94       	cli
    1e98:	0f 92       	push	r0
    1e9a:	0b b6       	in	r0, 0x3b	; 59
    1e9c:	0f 92       	push	r0
    1e9e:	0c b6       	in	r0, 0x3c	; 60
    1ea0:	0f 92       	push	r0
    1ea2:	1f 92       	push	r1
    1ea4:	11 24       	eor	r1, r1
    1ea6:	2f 92       	push	r2
    1ea8:	3f 92       	push	r3
    1eaa:	4f 92       	push	r4
    1eac:	5f 92       	push	r5
    1eae:	6f 92       	push	r6
    1eb0:	7f 92       	push	r7
    1eb2:	8f 92       	push	r8
    1eb4:	9f 92       	push	r9
    1eb6:	af 92       	push	r10
    1eb8:	bf 92       	push	r11
    1eba:	cf 92       	push	r12
    1ebc:	df 92       	push	r13
    1ebe:	ef 92       	push	r14
    1ec0:	ff 92       	push	r15
    1ec2:	0f 93       	push	r16
    1ec4:	1f 93       	push	r17
    1ec6:	2f 93       	push	r18
    1ec8:	3f 93       	push	r19
    1eca:	4f 93       	push	r20
    1ecc:	5f 93       	push	r21
    1ece:	6f 93       	push	r22
    1ed0:	7f 93       	push	r23
    1ed2:	8f 93       	push	r24
    1ed4:	9f 93       	push	r25
    1ed6:	af 93       	push	r26
    1ed8:	bf 93       	push	r27
    1eda:	cf 93       	push	r28
    1edc:	df 93       	push	r29
    1ede:	ef 93       	push	r30
    1ee0:	ff 93       	push	r31
    1ee2:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1ee6:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1eea:	0d b6       	in	r0, 0x3d	; 61
    1eec:	0d 92       	st	X+, r0
    1eee:	0e b6       	in	r0, 0x3e	; 62
    1ef0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1ef2:	0e 94 46 14 	call	0x288c	; 0x288c <vTaskIncrementTick>
	vTaskSwitchContext();
    1ef6:	0e 94 f7 15 	call	0x2bee	; 0x2bee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1efa:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    1efe:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    1f02:	cd 91       	ld	r28, X+
    1f04:	cd bf       	out	0x3d, r28	; 61
    1f06:	dd 91       	ld	r29, X+
    1f08:	de bf       	out	0x3e, r29	; 62
    1f0a:	ff 91       	pop	r31
    1f0c:	ef 91       	pop	r30
    1f0e:	df 91       	pop	r29
    1f10:	cf 91       	pop	r28
    1f12:	bf 91       	pop	r27
    1f14:	af 91       	pop	r26
    1f16:	9f 91       	pop	r25
    1f18:	8f 91       	pop	r24
    1f1a:	7f 91       	pop	r23
    1f1c:	6f 91       	pop	r22
    1f1e:	5f 91       	pop	r21
    1f20:	4f 91       	pop	r20
    1f22:	3f 91       	pop	r19
    1f24:	2f 91       	pop	r18
    1f26:	1f 91       	pop	r17
    1f28:	0f 91       	pop	r16
    1f2a:	ff 90       	pop	r15
    1f2c:	ef 90       	pop	r14
    1f2e:	df 90       	pop	r13
    1f30:	cf 90       	pop	r12
    1f32:	bf 90       	pop	r11
    1f34:	af 90       	pop	r10
    1f36:	9f 90       	pop	r9
    1f38:	8f 90       	pop	r8
    1f3a:	7f 90       	pop	r7
    1f3c:	6f 90       	pop	r6
    1f3e:	5f 90       	pop	r5
    1f40:	4f 90       	pop	r4
    1f42:	3f 90       	pop	r3
    1f44:	2f 90       	pop	r2
    1f46:	1f 90       	pop	r1
    1f48:	0f 90       	pop	r0
    1f4a:	0c be       	out	0x3c, r0	; 60
    1f4c:	0f 90       	pop	r0
    1f4e:	0b be       	out	0x3b, r0	; 59
    1f50:	0f 90       	pop	r0
    1f52:	0f be       	out	0x3f, r0	; 63
    1f54:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1f56:	08 95       	ret

00001f58 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1f58:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f5c:	18 95       	reti

00001f5e <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1f5e:	cf 93       	push	r28
    1f60:	df 93       	push	r29
    1f62:	ec 01       	movw	r28, r24
    1f64:	88 a1       	ldd	r24, Y+32	; 0x20
    1f66:	81 11       	cpse	r24, r1
    1f68:	0b c0       	rjmp	.+22     	; 0x1f80 <prvCopyDataToQueue+0x22>
    1f6a:	88 81       	ld	r24, Y
    1f6c:	99 81       	ldd	r25, Y+1	; 0x01
    1f6e:	89 2b       	or	r24, r25
    1f70:	e1 f5       	brne	.+120    	; 0x1fea <prvCopyDataToQueue+0x8c>
    1f72:	8a 81       	ldd	r24, Y+2	; 0x02
    1f74:	9b 81       	ldd	r25, Y+3	; 0x03
    1f76:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <vTaskPriorityDisinherit>
    1f7a:	1a 82       	std	Y+2, r1	; 0x02
    1f7c:	1b 82       	std	Y+3, r1	; 0x03
    1f7e:	35 c0       	rjmp	.+106    	; 0x1fea <prvCopyDataToQueue+0x8c>
    1f80:	41 11       	cpse	r20, r1
    1f82:	17 c0       	rjmp	.+46     	; 0x1fb2 <prvCopyDataToQueue+0x54>
    1f84:	48 2f       	mov	r20, r24
    1f86:	50 e0       	ldi	r21, 0x00	; 0
    1f88:	8c 81       	ldd	r24, Y+4	; 0x04
    1f8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8c:	0e 94 e7 24 	call	0x49ce	; 0x49ce <memcpy>
    1f90:	28 a1       	ldd	r18, Y+32	; 0x20
    1f92:	8c 81       	ldd	r24, Y+4	; 0x04
    1f94:	9d 81       	ldd	r25, Y+5	; 0x05
    1f96:	82 0f       	add	r24, r18
    1f98:	91 1d       	adc	r25, r1
    1f9a:	8c 83       	std	Y+4, r24	; 0x04
    1f9c:	9d 83       	std	Y+5, r25	; 0x05
    1f9e:	2a 81       	ldd	r18, Y+2	; 0x02
    1fa0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fa2:	82 17       	cp	r24, r18
    1fa4:	93 07       	cpc	r25, r19
    1fa6:	08 f1       	brcs	.+66     	; 0x1fea <prvCopyDataToQueue+0x8c>
    1fa8:	88 81       	ld	r24, Y
    1faa:	99 81       	ldd	r25, Y+1	; 0x01
    1fac:	8c 83       	std	Y+4, r24	; 0x04
    1fae:	9d 83       	std	Y+5, r25	; 0x05
    1fb0:	1c c0       	rjmp	.+56     	; 0x1fea <prvCopyDataToQueue+0x8c>
    1fb2:	48 2f       	mov	r20, r24
    1fb4:	50 e0       	ldi	r21, 0x00	; 0
    1fb6:	8e 81       	ldd	r24, Y+6	; 0x06
    1fb8:	9f 81       	ldd	r25, Y+7	; 0x07
    1fba:	0e 94 e7 24 	call	0x49ce	; 0x49ce <memcpy>
    1fbe:	88 a1       	ldd	r24, Y+32	; 0x20
    1fc0:	90 e0       	ldi	r25, 0x00	; 0
    1fc2:	91 95       	neg	r25
    1fc4:	81 95       	neg	r24
    1fc6:	91 09       	sbc	r25, r1
    1fc8:	2e 81       	ldd	r18, Y+6	; 0x06
    1fca:	3f 81       	ldd	r19, Y+7	; 0x07
    1fcc:	28 0f       	add	r18, r24
    1fce:	39 1f       	adc	r19, r25
    1fd0:	2e 83       	std	Y+6, r18	; 0x06
    1fd2:	3f 83       	std	Y+7, r19	; 0x07
    1fd4:	48 81       	ld	r20, Y
    1fd6:	59 81       	ldd	r21, Y+1	; 0x01
    1fd8:	24 17       	cp	r18, r20
    1fda:	35 07       	cpc	r19, r21
    1fdc:	30 f4       	brcc	.+12     	; 0x1fea <prvCopyDataToQueue+0x8c>
    1fde:	2a 81       	ldd	r18, Y+2	; 0x02
    1fe0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fe2:	82 0f       	add	r24, r18
    1fe4:	93 1f       	adc	r25, r19
    1fe6:	8e 83       	std	Y+6, r24	; 0x06
    1fe8:	9f 83       	std	Y+7, r25	; 0x07
    1fea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fec:	8f 5f       	subi	r24, 0xFF	; 255
    1fee:	8e 8f       	std	Y+30, r24	; 0x1e
    1ff0:	df 91       	pop	r29
    1ff2:	cf 91       	pop	r28
    1ff4:	08 95       	ret

00001ff6 <prvCopyDataFromQueue>:
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	80 81       	ld	r24, Z
    1ffa:	91 81       	ldd	r25, Z+1	; 0x01
    1ffc:	00 97       	sbiw	r24, 0x00	; 0
    1ffe:	a1 f0       	breq	.+40     	; 0x2028 <prvCopyDataFromQueue+0x32>
    2000:	40 a1       	ldd	r20, Z+32	; 0x20
    2002:	50 e0       	ldi	r21, 0x00	; 0
    2004:	26 81       	ldd	r18, Z+6	; 0x06
    2006:	37 81       	ldd	r19, Z+7	; 0x07
    2008:	24 0f       	add	r18, r20
    200a:	35 1f       	adc	r19, r21
    200c:	26 83       	std	Z+6, r18	; 0x06
    200e:	37 83       	std	Z+7, r19	; 0x07
    2010:	a2 81       	ldd	r26, Z+2	; 0x02
    2012:	b3 81       	ldd	r27, Z+3	; 0x03
    2014:	2a 17       	cp	r18, r26
    2016:	3b 07       	cpc	r19, r27
    2018:	10 f0       	brcs	.+4      	; 0x201e <prvCopyDataFromQueue+0x28>
    201a:	86 83       	std	Z+6, r24	; 0x06
    201c:	97 83       	std	Z+7, r25	; 0x07
    201e:	cb 01       	movw	r24, r22
    2020:	66 81       	ldd	r22, Z+6	; 0x06
    2022:	77 81       	ldd	r23, Z+7	; 0x07
    2024:	0e 94 e7 24 	call	0x49ce	; 0x49ce <memcpy>
    2028:	08 95       	ret

0000202a <prvUnlockQueue>:
    202a:	0f 93       	push	r16
    202c:	1f 93       	push	r17
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	ec 01       	movw	r28, r24
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	f8 94       	cli
    2038:	0f 92       	push	r0
    203a:	8a a1       	ldd	r24, Y+34	; 0x22
    203c:	18 16       	cp	r1, r24
    203e:	b4 f4       	brge	.+44     	; 0x206c <prvUnlockQueue+0x42>
    2040:	8b 89       	ldd	r24, Y+19	; 0x13
    2042:	81 11       	cpse	r24, r1
    2044:	05 c0       	rjmp	.+10     	; 0x2050 <prvUnlockQueue+0x26>
    2046:	12 c0       	rjmp	.+36     	; 0x206c <prvUnlockQueue+0x42>
    2048:	8b 89       	ldd	r24, Y+19	; 0x13
    204a:	81 11       	cpse	r24, r1
    204c:	04 c0       	rjmp	.+8      	; 0x2056 <prvUnlockQueue+0x2c>
    204e:	0e c0       	rjmp	.+28     	; 0x206c <prvUnlockQueue+0x42>
    2050:	8e 01       	movw	r16, r28
    2052:	0d 5e       	subi	r16, 0xED	; 237
    2054:	1f 4f       	sbci	r17, 0xFF	; 255
    2056:	c8 01       	movw	r24, r16
    2058:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    205c:	81 11       	cpse	r24, r1
    205e:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <vTaskMissedYield>
    2062:	8a a1       	ldd	r24, Y+34	; 0x22
    2064:	81 50       	subi	r24, 0x01	; 1
    2066:	8a a3       	std	Y+34, r24	; 0x22
    2068:	18 16       	cp	r1, r24
    206a:	74 f3       	brlt	.-36     	; 0x2048 <prvUnlockQueue+0x1e>
    206c:	8f ef       	ldi	r24, 0xFF	; 255
    206e:	8a a3       	std	Y+34, r24	; 0x22
    2070:	0f 90       	pop	r0
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	0f b6       	in	r0, 0x3f	; 63
    2076:	f8 94       	cli
    2078:	0f 92       	push	r0
    207a:	89 a1       	ldd	r24, Y+33	; 0x21
    207c:	18 16       	cp	r1, r24
    207e:	b4 f4       	brge	.+44     	; 0x20ac <prvUnlockQueue+0x82>
    2080:	88 85       	ldd	r24, Y+8	; 0x08
    2082:	81 11       	cpse	r24, r1
    2084:	05 c0       	rjmp	.+10     	; 0x2090 <prvUnlockQueue+0x66>
    2086:	12 c0       	rjmp	.+36     	; 0x20ac <prvUnlockQueue+0x82>
    2088:	88 85       	ldd	r24, Y+8	; 0x08
    208a:	81 11       	cpse	r24, r1
    208c:	04 c0       	rjmp	.+8      	; 0x2096 <prvUnlockQueue+0x6c>
    208e:	0e c0       	rjmp	.+28     	; 0x20ac <prvUnlockQueue+0x82>
    2090:	8e 01       	movw	r16, r28
    2092:	08 5f       	subi	r16, 0xF8	; 248
    2094:	1f 4f       	sbci	r17, 0xFF	; 255
    2096:	c8 01       	movw	r24, r16
    2098:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    209c:	81 11       	cpse	r24, r1
    209e:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <vTaskMissedYield>
    20a2:	89 a1       	ldd	r24, Y+33	; 0x21
    20a4:	81 50       	subi	r24, 0x01	; 1
    20a6:	89 a3       	std	Y+33, r24	; 0x21
    20a8:	18 16       	cp	r1, r24
    20aa:	74 f3       	brlt	.-36     	; 0x2088 <prvUnlockQueue+0x5e>
    20ac:	8f ef       	ldi	r24, 0xFF	; 255
    20ae:	89 a3       	std	Y+33, r24	; 0x21
    20b0:	0f 90       	pop	r0
    20b2:	0f be       	out	0x3f, r0	; 63
    20b4:	df 91       	pop	r29
    20b6:	cf 91       	pop	r28
    20b8:	1f 91       	pop	r17
    20ba:	0f 91       	pop	r16
    20bc:	08 95       	ret

000020be <xQueueGenericReset>:
    20be:	1f 93       	push	r17
    20c0:	cf 93       	push	r28
    20c2:	df 93       	push	r29
    20c4:	61 30       	cpi	r22, 0x01	; 1
    20c6:	59 f0       	breq	.+22     	; 0x20de <xQueueGenericReset+0x20>
    20c8:	fc 01       	movw	r30, r24
    20ca:	23 89       	ldd	r18, Z+19	; 0x13
    20cc:	30 85       	ldd	r19, Z+8	; 0x08
    20ce:	31 11       	cpse	r19, r1
    20d0:	2c c0       	rjmp	.+88     	; 0x212a <xQueueGenericReset+0x6c>
    20d2:	11 e0       	ldi	r17, 0x01	; 1
    20d4:	21 11       	cpse	r18, r1
    20d6:	10 e0       	ldi	r17, 0x00	; 0
    20d8:	21 11       	cpse	r18, r1
    20da:	28 c0       	rjmp	.+80     	; 0x212c <xQueueGenericReset+0x6e>
    20dc:	01 c0       	rjmp	.+2      	; 0x20e0 <xQueueGenericReset+0x22>
    20de:	11 e0       	ldi	r17, 0x01	; 1
    20e0:	ec 01       	movw	r28, r24
    20e2:	48 81       	ld	r20, Y
    20e4:	59 81       	ldd	r21, Y+1	; 0x01
    20e6:	28 a1       	ldd	r18, Y+32	; 0x20
    20e8:	30 e0       	ldi	r19, 0x00	; 0
    20ea:	6f 8d       	ldd	r22, Y+31	; 0x1f
    20ec:	62 9f       	mul	r22, r18
    20ee:	c0 01       	movw	r24, r0
    20f0:	63 9f       	mul	r22, r19
    20f2:	90 0d       	add	r25, r0
    20f4:	11 24       	eor	r1, r1
    20f6:	ba 01       	movw	r22, r20
    20f8:	68 0f       	add	r22, r24
    20fa:	79 1f       	adc	r23, r25
    20fc:	6a 83       	std	Y+2, r22	; 0x02
    20fe:	7b 83       	std	Y+3, r23	; 0x03
    2100:	1e 8e       	std	Y+30, r1	; 0x1e
    2102:	4c 83       	std	Y+4, r20	; 0x04
    2104:	5d 83       	std	Y+5, r21	; 0x05
    2106:	82 1b       	sub	r24, r18
    2108:	93 0b       	sbc	r25, r19
    210a:	84 0f       	add	r24, r20
    210c:	95 1f       	adc	r25, r21
    210e:	8e 83       	std	Y+6, r24	; 0x06
    2110:	9f 83       	std	Y+7, r25	; 0x07
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	89 a3       	std	Y+33, r24	; 0x21
    2116:	8a a3       	std	Y+34, r24	; 0x22
    2118:	ce 01       	movw	r24, r28
    211a:	08 96       	adiw	r24, 0x08	; 8
    211c:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    2120:	ce 01       	movw	r24, r28
    2122:	43 96       	adiw	r24, 0x13	; 19
    2124:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    2128:	01 c0       	rjmp	.+2      	; 0x212c <xQueueGenericReset+0x6e>
    212a:	10 e0       	ldi	r17, 0x00	; 0
    212c:	81 2f       	mov	r24, r17
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	1f 91       	pop	r17
    2134:	08 95       	ret

00002136 <xQueueGenericCreate>:
    2136:	0f 93       	push	r16
    2138:	1f 93       	push	r17
    213a:	cf 93       	push	r28
    213c:	df 93       	push	r29
    213e:	88 23       	and	r24, r24
    2140:	01 f1       	breq	.+64     	; 0x2182 <xQueueGenericCreate+0x4c>
    2142:	06 2f       	mov	r16, r22
    2144:	18 2f       	mov	r17, r24
    2146:	83 e2       	ldi	r24, 0x23	; 35
    2148:	90 e0       	ldi	r25, 0x00	; 0
    214a:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    214e:	ec 01       	movw	r28, r24
    2150:	89 2b       	or	r24, r25
    2152:	c9 f0       	breq	.+50     	; 0x2186 <xQueueGenericCreate+0x50>
    2154:	10 9f       	mul	r17, r16
    2156:	c0 01       	movw	r24, r0
    2158:	11 24       	eor	r1, r1
    215a:	01 96       	adiw	r24, 0x01	; 1
    215c:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    2160:	88 83       	st	Y, r24
    2162:	99 83       	std	Y+1, r25	; 0x01
    2164:	89 2b       	or	r24, r25
    2166:	39 f0       	breq	.+14     	; 0x2176 <xQueueGenericCreate+0x40>
    2168:	1f 8f       	std	Y+31, r17	; 0x1f
    216a:	08 a3       	std	Y+32, r16	; 0x20
    216c:	61 e0       	ldi	r22, 0x01	; 1
    216e:	ce 01       	movw	r24, r28
    2170:	0e 94 5f 10 	call	0x20be	; 0x20be <xQueueGenericReset>
    2174:	08 c0       	rjmp	.+16     	; 0x2186 <xQueueGenericCreate+0x50>
    2176:	ce 01       	movw	r24, r28
    2178:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
    217c:	c0 e0       	ldi	r28, 0x00	; 0
    217e:	d0 e0       	ldi	r29, 0x00	; 0
    2180:	02 c0       	rjmp	.+4      	; 0x2186 <xQueueGenericCreate+0x50>
    2182:	c0 e0       	ldi	r28, 0x00	; 0
    2184:	d0 e0       	ldi	r29, 0x00	; 0
    2186:	ce 01       	movw	r24, r28
    2188:	df 91       	pop	r29
    218a:	cf 91       	pop	r28
    218c:	1f 91       	pop	r17
    218e:	0f 91       	pop	r16
    2190:	08 95       	ret

00002192 <xQueueGenericSend>:
    2192:	af 92       	push	r10
    2194:	bf 92       	push	r11
    2196:	cf 92       	push	r12
    2198:	df 92       	push	r13
    219a:	ef 92       	push	r14
    219c:	ff 92       	push	r15
    219e:	0f 93       	push	r16
    21a0:	1f 93       	push	r17
    21a2:	cf 93       	push	r28
    21a4:	df 93       	push	r29
    21a6:	cd b7       	in	r28, 0x3d	; 61
    21a8:	de b7       	in	r29, 0x3e	; 62
    21aa:	29 97       	sbiw	r28, 0x09	; 9
    21ac:	cd bf       	out	0x3d, r28	; 61
    21ae:	de bf       	out	0x3e, r29	; 62
    21b0:	7c 01       	movw	r14, r24
    21b2:	5b 01       	movw	r10, r22
    21b4:	2e 83       	std	Y+6, r18	; 0x06
    21b6:	3f 83       	std	Y+7, r19	; 0x07
    21b8:	48 87       	std	Y+8, r20	; 0x08
    21ba:	59 87       	std	Y+9, r21	; 0x09
    21bc:	10 e0       	ldi	r17, 0x00	; 0
    21be:	6c 01       	movw	r12, r24
    21c0:	88 e0       	ldi	r24, 0x08	; 8
    21c2:	c8 0e       	add	r12, r24
    21c4:	d1 1c       	adc	r13, r1
    21c6:	0f b6       	in	r0, 0x3f	; 63
    21c8:	f8 94       	cli
    21ca:	0f 92       	push	r0
    21cc:	f7 01       	movw	r30, r14
    21ce:	96 8d       	ldd	r25, Z+30	; 0x1e
    21d0:	87 8d       	ldd	r24, Z+31	; 0x1f
    21d2:	98 17       	cp	r25, r24
    21d4:	a8 f4       	brcc	.+42     	; 0x2200 <xQueueGenericSend+0x6e>
    21d6:	40 2f       	mov	r20, r16
    21d8:	b5 01       	movw	r22, r10
    21da:	c7 01       	movw	r24, r14
    21dc:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <prvCopyDataToQueue>
    21e0:	f7 01       	movw	r30, r14
    21e2:	83 89       	ldd	r24, Z+19	; 0x13
    21e4:	88 23       	and	r24, r24
    21e6:	41 f0       	breq	.+16     	; 0x21f8 <xQueueGenericSend+0x66>
    21e8:	c7 01       	movw	r24, r14
    21ea:	43 96       	adiw	r24, 0x13	; 19
    21ec:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    21f0:	81 30       	cpi	r24, 0x01	; 1
    21f2:	11 f4       	brne	.+4      	; 0x21f8 <xQueueGenericSend+0x66>
    21f4:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    21f8:	0f 90       	pop	r0
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	81 e0       	ldi	r24, 0x01	; 1
    21fe:	56 c0       	rjmp	.+172    	; 0x22ac <xQueueGenericSend+0x11a>
    2200:	8e 81       	ldd	r24, Y+6	; 0x06
    2202:	9f 81       	ldd	r25, Y+7	; 0x07
    2204:	a8 85       	ldd	r26, Y+8	; 0x08
    2206:	b9 85       	ldd	r27, Y+9	; 0x09
    2208:	89 2b       	or	r24, r25
    220a:	8a 2b       	or	r24, r26
    220c:	8b 2b       	or	r24, r27
    220e:	21 f4       	brne	.+8      	; 0x2218 <xQueueGenericSend+0x86>
    2210:	0f 90       	pop	r0
    2212:	0f be       	out	0x3f, r0	; 63
    2214:	80 e0       	ldi	r24, 0x00	; 0
    2216:	4a c0       	rjmp	.+148    	; 0x22ac <xQueueGenericSend+0x11a>
    2218:	11 11       	cpse	r17, r1
    221a:	05 c0       	rjmp	.+10     	; 0x2226 <xQueueGenericSend+0x94>
    221c:	ce 01       	movw	r24, r28
    221e:	01 96       	adiw	r24, 0x01	; 1
    2220:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <vTaskSetTimeOutState>
    2224:	11 e0       	ldi	r17, 0x01	; 1
    2226:	0f 90       	pop	r0
    2228:	0f be       	out	0x3f, r0	; 63
    222a:	0e 94 25 14 	call	0x284a	; 0x284a <vTaskSuspendAll>
    222e:	0f b6       	in	r0, 0x3f	; 63
    2230:	f8 94       	cli
    2232:	0f 92       	push	r0
    2234:	f7 01       	movw	r30, r14
    2236:	81 a1       	ldd	r24, Z+33	; 0x21
    2238:	8f 3f       	cpi	r24, 0xFF	; 255
    223a:	09 f4       	brne	.+2      	; 0x223e <xQueueGenericSend+0xac>
    223c:	11 a2       	std	Z+33, r1	; 0x21
    223e:	f7 01       	movw	r30, r14
    2240:	82 a1       	ldd	r24, Z+34	; 0x22
    2242:	8f 3f       	cpi	r24, 0xFF	; 255
    2244:	09 f4       	brne	.+2      	; 0x2248 <xQueueGenericSend+0xb6>
    2246:	12 a2       	std	Z+34, r1	; 0x22
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	be 01       	movw	r22, r28
    224e:	6a 5f       	subi	r22, 0xFA	; 250
    2250:	7f 4f       	sbci	r23, 0xFF	; 255
    2252:	ce 01       	movw	r24, r28
    2254:	01 96       	adiw	r24, 0x01	; 1
    2256:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <xTaskCheckForTimeOut>
    225a:	81 11       	cpse	r24, r1
    225c:	21 c0       	rjmp	.+66     	; 0x22a0 <xQueueGenericSend+0x10e>
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	0f 92       	push	r0
    2264:	f7 01       	movw	r30, r14
    2266:	96 8d       	ldd	r25, Z+30	; 0x1e
    2268:	0f 90       	pop	r0
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	87 8d       	ldd	r24, Z+31	; 0x1f
    226e:	98 13       	cpse	r25, r24
    2270:	11 c0       	rjmp	.+34     	; 0x2294 <xQueueGenericSend+0x102>
    2272:	4e 81       	ldd	r20, Y+6	; 0x06
    2274:	5f 81       	ldd	r21, Y+7	; 0x07
    2276:	68 85       	ldd	r22, Y+8	; 0x08
    2278:	79 85       	ldd	r23, Y+9	; 0x09
    227a:	c6 01       	movw	r24, r12
    227c:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <vTaskPlaceOnEventList>
    2280:	c7 01       	movw	r24, r14
    2282:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
    2286:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
    228a:	81 11       	cpse	r24, r1
    228c:	9c cf       	rjmp	.-200    	; 0x21c6 <xQueueGenericSend+0x34>
    228e:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    2292:	99 cf       	rjmp	.-206    	; 0x21c6 <xQueueGenericSend+0x34>
    2294:	c7 01       	movw	r24, r14
    2296:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
    229a:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
    229e:	93 cf       	rjmp	.-218    	; 0x21c6 <xQueueGenericSend+0x34>
    22a0:	c7 01       	movw	r24, r14
    22a2:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
    22a6:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	29 96       	adiw	r28, 0x09	; 9
    22ae:	cd bf       	out	0x3d, r28	; 61
    22b0:	de bf       	out	0x3e, r29	; 62
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	bf 90       	pop	r11
    22c4:	af 90       	pop	r10
    22c6:	08 95       	ret

000022c8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    22c8:	0f 93       	push	r16
    22ca:	1f 93       	push	r17
    22cc:	cf 93       	push	r28
    22ce:	df 93       	push	r29
    22d0:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    22d2:	fc 01       	movw	r30, r24
    22d4:	56 8d       	ldd	r21, Z+30	; 0x1e
    22d6:	37 8d       	ldd	r19, Z+31	; 0x1f
    22d8:	53 17       	cp	r21, r19
    22da:	c0 f4       	brcc	.+48     	; 0x230c <xQueueGenericSendFromISR+0x44>
    22dc:	42 2f       	mov	r20, r18
    22de:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    22e0:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    22e4:	8a a1       	ldd	r24, Y+34	; 0x22
    22e6:	8f 3f       	cpi	r24, 0xFF	; 255
    22e8:	69 f4       	brne	.+26     	; 0x2304 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22ea:	8b 89       	ldd	r24, Y+19	; 0x13
    22ec:	88 23       	and	r24, r24
    22ee:	81 f0       	breq	.+32     	; 0x2310 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22f0:	ce 01       	movw	r24, r28
    22f2:	43 96       	adiw	r24, 0x13	; 19
    22f4:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    22f8:	88 23       	and	r24, r24
    22fa:	61 f0       	breq	.+24     	; 0x2314 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    22fc:	81 e0       	ldi	r24, 0x01	; 1
    22fe:	f8 01       	movw	r30, r16
    2300:	80 83       	st	Z, r24
    2302:	09 c0       	rjmp	.+18     	; 0x2316 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2304:	8f 5f       	subi	r24, 0xFF	; 255
    2306:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    2308:	81 e0       	ldi	r24, 0x01	; 1
    230a:	05 c0       	rjmp	.+10     	; 0x2316 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    230c:	80 e0       	ldi	r24, 0x00	; 0
    230e:	03 c0       	rjmp	.+6      	; 0x2316 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2310:	81 e0       	ldi	r24, 0x01	; 1
    2312:	01 c0       	rjmp	.+2      	; 0x2316 <xQueueGenericSendFromISR+0x4e>
    2314:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2316:	df 91       	pop	r29
    2318:	cf 91       	pop	r28
    231a:	1f 91       	pop	r17
    231c:	0f 91       	pop	r16
    231e:	08 95       	ret

00002320 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2320:	af 92       	push	r10
    2322:	bf 92       	push	r11
    2324:	cf 92       	push	r12
    2326:	df 92       	push	r13
    2328:	ef 92       	push	r14
    232a:	ff 92       	push	r15
    232c:	0f 93       	push	r16
    232e:	1f 93       	push	r17
    2330:	cf 93       	push	r28
    2332:	df 93       	push	r29
    2334:	cd b7       	in	r28, 0x3d	; 61
    2336:	de b7       	in	r29, 0x3e	; 62
    2338:	29 97       	sbiw	r28, 0x09	; 9
    233a:	cd bf       	out	0x3d, r28	; 61
    233c:	de bf       	out	0x3e, r29	; 62
    233e:	7c 01       	movw	r14, r24
    2340:	5b 01       	movw	r10, r22
    2342:	2e 83       	std	Y+6, r18	; 0x06
    2344:	3f 83       	std	Y+7, r19	; 0x07
    2346:	48 87       	std	Y+8, r20	; 0x08
    2348:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    234a:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    234c:	6c 01       	movw	r12, r24
    234e:	83 e1       	ldi	r24, 0x13	; 19
    2350:	c8 0e       	add	r12, r24
    2352:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2354:	0f b6       	in	r0, 0x3f	; 63
    2356:	f8 94       	cli
    2358:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    235a:	f7 01       	movw	r30, r14
    235c:	86 8d       	ldd	r24, Z+30	; 0x1e
    235e:	88 23       	and	r24, r24
    2360:	99 f1       	breq	.+102    	; 0x23c8 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2362:	c6 80       	ldd	r12, Z+6	; 0x06
    2364:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2366:	b5 01       	movw	r22, r10
    2368:	c7 01       	movw	r24, r14
    236a:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    236e:	01 11       	cpse	r16, r1
    2370:	1a c0       	rjmp	.+52     	; 0x23a6 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2372:	f7 01       	movw	r30, r14
    2374:	86 8d       	ldd	r24, Z+30	; 0x1e
    2376:	81 50       	subi	r24, 0x01	; 1
    2378:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    237a:	80 81       	ld	r24, Z
    237c:	91 81       	ldd	r25, Z+1	; 0x01
    237e:	89 2b       	or	r24, r25
    2380:	29 f4       	brne	.+10     	; 0x238c <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2382:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <xTaskGetCurrentTaskHandle>
    2386:	f7 01       	movw	r30, r14
    2388:	82 83       	std	Z+2, r24	; 0x02
    238a:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    238c:	f7 01       	movw	r30, r14
    238e:	80 85       	ldd	r24, Z+8	; 0x08
    2390:	88 23       	and	r24, r24
    2392:	b1 f0       	breq	.+44     	; 0x23c0 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2394:	c7 01       	movw	r24, r14
    2396:	08 96       	adiw	r24, 0x08	; 8
    2398:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    239c:	81 30       	cpi	r24, 0x01	; 1
    239e:	81 f4       	brne	.+32     	; 0x23c0 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    23a0:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    23a4:	0d c0       	rjmp	.+26     	; 0x23c0 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    23a6:	f7 01       	movw	r30, r14
    23a8:	c6 82       	std	Z+6, r12	; 0x06
    23aa:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23ac:	83 89       	ldd	r24, Z+19	; 0x13
    23ae:	88 23       	and	r24, r24
    23b0:	39 f0       	breq	.+14     	; 0x23c0 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23b2:	c7 01       	movw	r24, r14
    23b4:	43 96       	adiw	r24, 0x13	; 19
    23b6:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    23ba:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    23bc:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    23c0:	0f 90       	pop	r0
    23c2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    23c4:	81 e0       	ldi	r24, 0x01	; 1
    23c6:	62 c0       	rjmp	.+196    	; 0x248c <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    23c8:	8e 81       	ldd	r24, Y+6	; 0x06
    23ca:	9f 81       	ldd	r25, Y+7	; 0x07
    23cc:	a8 85       	ldd	r26, Y+8	; 0x08
    23ce:	b9 85       	ldd	r27, Y+9	; 0x09
    23d0:	89 2b       	or	r24, r25
    23d2:	8a 2b       	or	r24, r26
    23d4:	8b 2b       	or	r24, r27
    23d6:	21 f4       	brne	.+8      	; 0x23e0 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23d8:	0f 90       	pop	r0
    23da:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23dc:	80 e0       	ldi	r24, 0x00	; 0
    23de:	56 c0       	rjmp	.+172    	; 0x248c <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    23e0:	11 11       	cpse	r17, r1
    23e2:	05 c0       	rjmp	.+10     	; 0x23ee <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23e4:	ce 01       	movw	r24, r28
    23e6:	01 96       	adiw	r24, 0x01	; 1
    23e8:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    23ec:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    23ee:	0f 90       	pop	r0
    23f0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23f2:	0e 94 25 14 	call	0x284a	; 0x284a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    23f6:	0f b6       	in	r0, 0x3f	; 63
    23f8:	f8 94       	cli
    23fa:	0f 92       	push	r0
    23fc:	f7 01       	movw	r30, r14
    23fe:	81 a1       	ldd	r24, Z+33	; 0x21
    2400:	8f 3f       	cpi	r24, 0xFF	; 255
    2402:	09 f4       	brne	.+2      	; 0x2406 <xQueueGenericReceive+0xe6>
    2404:	11 a2       	std	Z+33, r1	; 0x21
    2406:	f7 01       	movw	r30, r14
    2408:	82 a1       	ldd	r24, Z+34	; 0x22
    240a:	8f 3f       	cpi	r24, 0xFF	; 255
    240c:	09 f4       	brne	.+2      	; 0x2410 <xQueueGenericReceive+0xf0>
    240e:	12 a2       	std	Z+34, r1	; 0x22
    2410:	0f 90       	pop	r0
    2412:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2414:	be 01       	movw	r22, r28
    2416:	6a 5f       	subi	r22, 0xFA	; 250
    2418:	7f 4f       	sbci	r23, 0xFF	; 255
    241a:	ce 01       	movw	r24, r28
    241c:	01 96       	adiw	r24, 0x01	; 1
    241e:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <xTaskCheckForTimeOut>
    2422:	81 11       	cpse	r24, r1
    2424:	2d c0       	rjmp	.+90     	; 0x2480 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	f8 94       	cli
    242a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    242c:	f7 01       	movw	r30, r14
    242e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2430:	0f 90       	pop	r0
    2432:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2434:	81 11       	cpse	r24, r1
    2436:	1e c0       	rjmp	.+60     	; 0x2474 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2438:	80 81       	ld	r24, Z
    243a:	91 81       	ldd	r25, Z+1	; 0x01
    243c:	89 2b       	or	r24, r25
    243e:	49 f4       	brne	.+18     	; 0x2452 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2440:	0f b6       	in	r0, 0x3f	; 63
    2442:	f8 94       	cli
    2444:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2446:	82 81       	ldd	r24, Z+2	; 0x02
    2448:	93 81       	ldd	r25, Z+3	; 0x03
    244a:	0e 94 5d 17 	call	0x2eba	; 0x2eba <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    244e:	0f 90       	pop	r0
    2450:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2452:	4e 81       	ldd	r20, Y+6	; 0x06
    2454:	5f 81       	ldd	r21, Y+7	; 0x07
    2456:	68 85       	ldd	r22, Y+8	; 0x08
    2458:	79 85       	ldd	r23, Y+9	; 0x09
    245a:	c6 01       	movw	r24, r12
    245c:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2460:	c7 01       	movw	r24, r14
    2462:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2466:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
    246a:	81 11       	cpse	r24, r1
    246c:	73 cf       	rjmp	.-282    	; 0x2354 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    246e:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    2472:	70 cf       	rjmp	.-288    	; 0x2354 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2474:	c7 01       	movw	r24, r14
    2476:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    247a:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
    247e:	6a cf       	rjmp	.-300    	; 0x2354 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2480:	c7 01       	movw	r24, r14
    2482:	0e 94 15 10 	call	0x202a	; 0x202a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2486:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    248a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    248c:	29 96       	adiw	r28, 0x09	; 9
    248e:	cd bf       	out	0x3d, r28	; 61
    2490:	de bf       	out	0x3e, r29	; 62
    2492:	df 91       	pop	r29
    2494:	cf 91       	pop	r28
    2496:	1f 91       	pop	r17
    2498:	0f 91       	pop	r16
    249a:	ff 90       	pop	r15
    249c:	ef 90       	pop	r14
    249e:	df 90       	pop	r13
    24a0:	cf 90       	pop	r12
    24a2:	bf 90       	pop	r11
    24a4:	af 90       	pop	r10
    24a6:	08 95       	ret

000024a8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    24a8:	0f 93       	push	r16
    24aa:	1f 93       	push	r17
    24ac:	cf 93       	push	r28
    24ae:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    24b0:	fc 01       	movw	r30, r24
    24b2:	26 8d       	ldd	r18, Z+30	; 0x1e
    24b4:	22 23       	and	r18, r18
    24b6:	d9 f0       	breq	.+54     	; 0x24ee <xQueueReceiveFromISR+0x46>
    24b8:	8a 01       	movw	r16, r20
    24ba:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    24bc:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    24c0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24c2:	81 50       	subi	r24, 0x01	; 1
    24c4:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    24c6:	89 a1       	ldd	r24, Y+33	; 0x21
    24c8:	8f 3f       	cpi	r24, 0xFF	; 255
    24ca:	69 f4       	brne	.+26     	; 0x24e6 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24cc:	88 85       	ldd	r24, Y+8	; 0x08
    24ce:	88 23       	and	r24, r24
    24d0:	81 f0       	breq	.+32     	; 0x24f2 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d2:	ce 01       	movw	r24, r28
    24d4:	08 96       	adiw	r24, 0x08	; 8
    24d6:	0e 94 7e 16 	call	0x2cfc	; 0x2cfc <xTaskRemoveFromEventList>
    24da:	88 23       	and	r24, r24
    24dc:	61 f0       	breq	.+24     	; 0x24f6 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	f8 01       	movw	r30, r16
    24e2:	80 83       	st	Z, r24
    24e4:	09 c0       	rjmp	.+18     	; 0x24f8 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    24e6:	8f 5f       	subi	r24, 0xFF	; 255
    24e8:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    24ea:	81 e0       	ldi	r24, 0x01	; 1
    24ec:	05 c0       	rjmp	.+10     	; 0x24f8 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    24ee:	80 e0       	ldi	r24, 0x00	; 0
    24f0:	03 c0       	rjmp	.+6      	; 0x24f8 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	01 c0       	rjmp	.+2      	; 0x24f8 <xQueueReceiveFromISR+0x50>
    24f6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24f8:	df 91       	pop	r29
    24fa:	cf 91       	pop	r28
    24fc:	1f 91       	pop	r17
    24fe:	0f 91       	pop	r16
    2500:	08 95       	ret

00002502 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2502:	0f b6       	in	r0, 0x3f	; 63
    2504:	f8 94       	cli
    2506:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2508:	fc 01       	movw	r30, r24
    250a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    250c:	0f 90       	pop	r0
    250e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2510:	08 95       	ret

00002512 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2512:	fc 01       	movw	r30, r24
    2514:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    2516:	08 95       	ret

00002518 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2518:	c2 e0       	ldi	r28, 0x02	; 2
    251a:	d2 e3       	ldi	r29, 0x32	; 50
    251c:	88 81       	ld	r24, Y
    251e:	82 30       	cpi	r24, 0x02	; 2
    2520:	e8 f3       	brcs	.-6      	; 0x251c <prvIdleTask+0x4>
    2522:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    2526:	fa cf       	rjmp	.-12     	; 0x251c <prvIdleTask+0x4>

00002528 <prvAddCurrentTaskToDelayedList>:
    2528:	cf 92       	push	r12
    252a:	df 92       	push	r13
    252c:	ef 92       	push	r14
    252e:	ff 92       	push	r15
    2530:	6b 01       	movw	r12, r22
    2532:	7c 01       	movw	r14, r24
    2534:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2538:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    253c:	62 83       	std	Z+2, r22	; 0x02
    253e:	73 83       	std	Z+3, r23	; 0x03
    2540:	84 83       	std	Z+4, r24	; 0x04
    2542:	95 83       	std	Z+5, r25	; 0x05
    2544:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2548:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    254c:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2550:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2554:	c8 16       	cp	r12, r24
    2556:	d9 06       	cpc	r13, r25
    2558:	ea 06       	cpc	r14, r26
    255a:	fb 06       	cpc	r15, r27
    255c:	68 f4       	brcc	.+26     	; 0x2578 <prvAddCurrentTaskToDelayedList+0x50>
    255e:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    2562:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2566:	80 91 e8 31 	lds	r24, 0x31E8	; 0x8031e8 <pxOverflowDelayedTaskList>
    256a:	90 91 e9 31 	lds	r25, 0x31E9	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    256e:	6e 5f       	subi	r22, 0xFE	; 254
    2570:	7f 4f       	sbci	r23, 0xFF	; 255
    2572:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vListInsert>
    2576:	21 c0       	rjmp	.+66     	; 0x25ba <prvAddCurrentTaskToDelayedList+0x92>
    2578:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    257c:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2580:	80 91 ea 31 	lds	r24, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2584:	90 91 eb 31 	lds	r25, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2588:	6e 5f       	subi	r22, 0xFE	; 254
    258a:	7f 4f       	sbci	r23, 0xFF	; 255
    258c:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vListInsert>
    2590:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2594:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2598:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    259c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    25a0:	c8 16       	cp	r12, r24
    25a2:	d9 06       	cpc	r13, r25
    25a4:	ea 06       	cpc	r14, r26
    25a6:	fb 06       	cpc	r15, r27
    25a8:	40 f4       	brcc	.+16     	; 0x25ba <prvAddCurrentTaskToDelayedList+0x92>
    25aa:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    25ae:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    25b2:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    25b6:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    25ba:	ff 90       	pop	r15
    25bc:	ef 90       	pop	r14
    25be:	df 90       	pop	r13
    25c0:	cf 90       	pop	r12
    25c2:	08 95       	ret

000025c4 <xTaskGenericCreate>:
    25c4:	4f 92       	push	r4
    25c6:	5f 92       	push	r5
    25c8:	6f 92       	push	r6
    25ca:	7f 92       	push	r7
    25cc:	8f 92       	push	r8
    25ce:	9f 92       	push	r9
    25d0:	af 92       	push	r10
    25d2:	bf 92       	push	r11
    25d4:	cf 92       	push	r12
    25d6:	df 92       	push	r13
    25d8:	ef 92       	push	r14
    25da:	ff 92       	push	r15
    25dc:	0f 93       	push	r16
    25de:	1f 93       	push	r17
    25e0:	cf 93       	push	r28
    25e2:	df 93       	push	r29
    25e4:	5c 01       	movw	r10, r24
    25e6:	4b 01       	movw	r8, r22
    25e8:	3a 01       	movw	r6, r20
    25ea:	29 01       	movw	r4, r18
    25ec:	88 e2       	ldi	r24, 0x28	; 40
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    25f4:	ec 01       	movw	r28, r24
    25f6:	89 2b       	or	r24, r25
    25f8:	09 f4       	brne	.+2      	; 0x25fc <xTaskGenericCreate+0x38>
    25fa:	d4 c0       	rjmp	.+424    	; 0x27a4 <xTaskGenericCreate+0x1e0>
    25fc:	c1 14       	cp	r12, r1
    25fe:	d1 04       	cpc	r13, r1
    2600:	09 f0       	breq	.+2      	; 0x2604 <xTaskGenericCreate+0x40>
    2602:	cc c0       	rjmp	.+408    	; 0x279c <xTaskGenericCreate+0x1d8>
    2604:	c3 01       	movw	r24, r6
    2606:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    260a:	8b 8f       	std	Y+27, r24	; 0x1b
    260c:	9c 8f       	std	Y+28, r25	; 0x1c
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	21 f4       	brne	.+8      	; 0x261a <xTaskGenericCreate+0x56>
    2612:	ce 01       	movw	r24, r28
    2614:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
    2618:	c5 c0       	rjmp	.+394    	; 0x27a4 <xTaskGenericCreate+0x1e0>
    261a:	a3 01       	movw	r20, r6
    261c:	61 e1       	ldi	r22, 0x11	; 17
    261e:	70 e0       	ldi	r23, 0x00	; 0
    2620:	0e 94 f0 24 	call	0x49e0	; 0x49e0 <memset>
    2624:	93 01       	movw	r18, r6
    2626:	21 50       	subi	r18, 0x01	; 1
    2628:	31 09       	sbc	r19, r1
    262a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    262c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    262e:	3c 01       	movw	r6, r24
    2630:	62 0e       	add	r6, r18
    2632:	73 1e       	adc	r7, r19
    2634:	4a e0       	ldi	r20, 0x0A	; 10
    2636:	50 e0       	ldi	r21, 0x00	; 0
    2638:	b4 01       	movw	r22, r8
    263a:	ce 01       	movw	r24, r28
    263c:	4d 96       	adiw	r24, 0x1d	; 29
    263e:	0e 94 f7 24 	call	0x49ee	; 0x49ee <strncpy>
    2642:	1e a2       	std	Y+38, r1	; 0x26
    2644:	10 2f       	mov	r17, r16
    2646:	04 30       	cpi	r16, 0x04	; 4
    2648:	08 f0       	brcs	.+2      	; 0x264c <xTaskGenericCreate+0x88>
    264a:	13 e0       	ldi	r17, 0x03	; 3
    264c:	1a 8f       	std	Y+26, r17	; 0x1a
    264e:	1f a3       	std	Y+39, r17	; 0x27
    2650:	6e 01       	movw	r12, r28
    2652:	22 e0       	ldi	r18, 0x02	; 2
    2654:	c2 0e       	add	r12, r18
    2656:	d1 1c       	adc	r13, r1
    2658:	c6 01       	movw	r24, r12
    265a:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>
    265e:	ce 01       	movw	r24, r28
    2660:	0e 96       	adiw	r24, 0x0e	; 14
    2662:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <vListInitialiseItem>
    2666:	ca 87       	std	Y+10, r28	; 0x0a
    2668:	db 87       	std	Y+11, r29	; 0x0b
    266a:	84 e0       	ldi	r24, 0x04	; 4
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	a0 e0       	ldi	r26, 0x00	; 0
    2670:	b0 e0       	ldi	r27, 0x00	; 0
    2672:	81 1b       	sub	r24, r17
    2674:	91 09       	sbc	r25, r1
    2676:	a1 09       	sbc	r26, r1
    2678:	b1 09       	sbc	r27, r1
    267a:	8e 87       	std	Y+14, r24	; 0x0e
    267c:	9f 87       	std	Y+15, r25	; 0x0f
    267e:	a8 8b       	std	Y+16, r26	; 0x10
    2680:	b9 8b       	std	Y+17, r27	; 0x11
    2682:	ce 8b       	std	Y+22, r28	; 0x16
    2684:	df 8b       	std	Y+23, r29	; 0x17
    2686:	a2 01       	movw	r20, r4
    2688:	b5 01       	movw	r22, r10
    268a:	c3 01       	movw	r24, r6
    268c:	0e 94 34 0e 	call	0x1c68	; 0x1c68 <pxPortInitialiseStack>
    2690:	88 83       	st	Y, r24
    2692:	99 83       	std	Y+1, r25	; 0x01
    2694:	e1 14       	cp	r14, r1
    2696:	f1 04       	cpc	r15, r1
    2698:	19 f0       	breq	.+6      	; 0x26a0 <xTaskGenericCreate+0xdc>
    269a:	f7 01       	movw	r30, r14
    269c:	c0 83       	st	Z, r28
    269e:	d1 83       	std	Z+1, r29	; 0x01
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	0f 92       	push	r0
    26a6:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    26aa:	8f 5f       	subi	r24, 0xFF	; 255
    26ac:	80 93 da 31 	sts	0x31DA, r24	; 0x8031da <uxCurrentNumberOfTasks>
    26b0:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    26b4:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    26b8:	89 2b       	or	r24, r25
    26ba:	89 f5       	brne	.+98     	; 0x271e <xTaskGenericCreate+0x15a>
    26bc:	c0 93 2e 32 	sts	0x322E, r28	; 0x80322e <pxCurrentTCB>
    26c0:	d0 93 2f 32 	sts	0x322F, r29	; 0x80322f <pxCurrentTCB+0x1>
    26c4:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    26c8:	81 30       	cpi	r24, 0x01	; 1
    26ca:	c1 f5       	brne	.+112    	; 0x273c <xTaskGenericCreate+0x178>
    26cc:	82 e0       	ldi	r24, 0x02	; 2
    26ce:	92 e3       	ldi	r25, 0x32	; 50
    26d0:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26d4:	8d e0       	ldi	r24, 0x0D	; 13
    26d6:	92 e3       	ldi	r25, 0x32	; 50
    26d8:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26dc:	88 e1       	ldi	r24, 0x18	; 24
    26de:	92 e3       	ldi	r25, 0x32	; 50
    26e0:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26e4:	83 e2       	ldi	r24, 0x23	; 35
    26e6:	92 e3       	ldi	r25, 0x32	; 50
    26e8:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26ec:	87 ef       	ldi	r24, 0xF7	; 247
    26ee:	91 e3       	ldi	r25, 0x31	; 49
    26f0:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26f4:	8c ee       	ldi	r24, 0xEC	; 236
    26f6:	91 e3       	ldi	r25, 0x31	; 49
    26f8:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    26fc:	8d ed       	ldi	r24, 0xDD	; 221
    26fe:	91 e3       	ldi	r25, 0x31	; 49
    2700:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <vListInitialise>
    2704:	87 ef       	ldi	r24, 0xF7	; 247
    2706:	91 e3       	ldi	r25, 0x31	; 49
    2708:	80 93 ea 31 	sts	0x31EA, r24	; 0x8031ea <pxDelayedTaskList>
    270c:	90 93 eb 31 	sts	0x31EB, r25	; 0x8031eb <pxDelayedTaskList+0x1>
    2710:	8c ee       	ldi	r24, 0xEC	; 236
    2712:	91 e3       	ldi	r25, 0x31	; 49
    2714:	80 93 e8 31 	sts	0x31E8, r24	; 0x8031e8 <pxOverflowDelayedTaskList>
    2718:	90 93 e9 31 	sts	0x31E9, r25	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    271c:	0f c0       	rjmp	.+30     	; 0x273c <xTaskGenericCreate+0x178>
    271e:	80 91 d3 31 	lds	r24, 0x31D3	; 0x8031d3 <xSchedulerRunning>
    2722:	81 11       	cpse	r24, r1
    2724:	0b c0       	rjmp	.+22     	; 0x273c <xTaskGenericCreate+0x178>
    2726:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    272a:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    272e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2730:	08 17       	cp	r16, r24
    2732:	20 f0       	brcs	.+8      	; 0x273c <xTaskGenericCreate+0x178>
    2734:	c0 93 2e 32 	sts	0x322E, r28	; 0x80322e <pxCurrentTCB>
    2738:	d0 93 2f 32 	sts	0x322F, r29	; 0x80322f <pxCurrentTCB+0x1>
    273c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    273e:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <uxTopUsedPriority>
    2742:	98 17       	cp	r25, r24
    2744:	10 f4       	brcc	.+4      	; 0x274a <xTaskGenericCreate+0x186>
    2746:	80 93 d5 31 	sts	0x31D5, r24	; 0x8031d5 <uxTopUsedPriority>
    274a:	90 91 ce 31 	lds	r25, 0x31CE	; 0x8031ce <uxTaskNumber>
    274e:	9f 5f       	subi	r25, 0xFF	; 255
    2750:	90 93 ce 31 	sts	0x31CE, r25	; 0x8031ce <uxTaskNumber>
    2754:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2758:	98 17       	cp	r25, r24
    275a:	10 f4       	brcc	.+4      	; 0x2760 <xTaskGenericCreate+0x19c>
    275c:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2760:	fb e0       	ldi	r31, 0x0B	; 11
    2762:	8f 9f       	mul	r24, r31
    2764:	c0 01       	movw	r24, r0
    2766:	11 24       	eor	r1, r1
    2768:	b6 01       	movw	r22, r12
    276a:	8e 5f       	subi	r24, 0xFE	; 254
    276c:	9d 4c       	sbci	r25, 0xCD	; 205
    276e:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    2772:	0f 90       	pop	r0
    2774:	0f be       	out	0x3f, r0	; 63
    2776:	80 91 d3 31 	lds	r24, 0x31D3	; 0x8031d3 <xSchedulerRunning>
    277a:	88 23       	and	r24, r24
    277c:	59 f0       	breq	.+22     	; 0x2794 <xTaskGenericCreate+0x1d0>
    277e:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2782:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2786:	82 8d       	ldd	r24, Z+26	; 0x1a
    2788:	80 17       	cp	r24, r16
    278a:	30 f4       	brcc	.+12     	; 0x2798 <xTaskGenericCreate+0x1d4>
    278c:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	09 c0       	rjmp	.+18     	; 0x27a6 <xTaskGenericCreate+0x1e2>
    2794:	81 e0       	ldi	r24, 0x01	; 1
    2796:	07 c0       	rjmp	.+14     	; 0x27a6 <xTaskGenericCreate+0x1e2>
    2798:	81 e0       	ldi	r24, 0x01	; 1
    279a:	05 c0       	rjmp	.+10     	; 0x27a6 <xTaskGenericCreate+0x1e2>
    279c:	cb 8e       	std	Y+27, r12	; 0x1b
    279e:	dc 8e       	std	Y+28, r13	; 0x1c
    27a0:	c6 01       	movw	r24, r12
    27a2:	3b cf       	rjmp	.-394    	; 0x261a <xTaskGenericCreate+0x56>
    27a4:	8f ef       	ldi	r24, 0xFF	; 255
    27a6:	df 91       	pop	r29
    27a8:	cf 91       	pop	r28
    27aa:	1f 91       	pop	r17
    27ac:	0f 91       	pop	r16
    27ae:	ff 90       	pop	r15
    27b0:	ef 90       	pop	r14
    27b2:	df 90       	pop	r13
    27b4:	cf 90       	pop	r12
    27b6:	bf 90       	pop	r11
    27b8:	af 90       	pop	r10
    27ba:	9f 90       	pop	r9
    27bc:	8f 90       	pop	r8
    27be:	7f 90       	pop	r7
    27c0:	6f 90       	pop	r6
    27c2:	5f 90       	pop	r5
    27c4:	4f 90       	pop	r4
    27c6:	08 95       	ret

000027c8 <uxTaskPriorityGet>:
    27c8:	0f b6       	in	r0, 0x3f	; 63
    27ca:	f8 94       	cli
    27cc:	0f 92       	push	r0
    27ce:	00 97       	sbiw	r24, 0x00	; 0
    27d0:	21 f4       	brne	.+8      	; 0x27da <uxTaskPriorityGet+0x12>
    27d2:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    27d6:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    27da:	0f 90       	pop	r0
    27dc:	0f be       	out	0x3f, r0	; 63
    27de:	fc 01       	movw	r30, r24
    27e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27e2:	08 95       	ret

000027e4 <vTaskStartScheduler>:
    27e4:	af 92       	push	r10
    27e6:	bf 92       	push	r11
    27e8:	cf 92       	push	r12
    27ea:	df 92       	push	r13
    27ec:	ef 92       	push	r14
    27ee:	ff 92       	push	r15
    27f0:	0f 93       	push	r16
    27f2:	a1 2c       	mov	r10, r1
    27f4:	b1 2c       	mov	r11, r1
    27f6:	c1 2c       	mov	r12, r1
    27f8:	d1 2c       	mov	r13, r1
    27fa:	0f 2e       	mov	r0, r31
    27fc:	fb ed       	ldi	r31, 0xDB	; 219
    27fe:	ef 2e       	mov	r14, r31
    2800:	f1 e3       	ldi	r31, 0x31	; 49
    2802:	ff 2e       	mov	r15, r31
    2804:	f0 2d       	mov	r31, r0
    2806:	00 e0       	ldi	r16, 0x00	; 0
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	30 e0       	ldi	r19, 0x00	; 0
    280c:	44 e6       	ldi	r20, 0x64	; 100
    280e:	50 e0       	ldi	r21, 0x00	; 0
    2810:	63 e1       	ldi	r22, 0x13	; 19
    2812:	71 e2       	ldi	r23, 0x21	; 33
    2814:	8c e8       	ldi	r24, 0x8C	; 140
    2816:	92 e1       	ldi	r25, 0x12	; 18
    2818:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <xTaskGenericCreate>
    281c:	81 30       	cpi	r24, 0x01	; 1
    281e:	69 f4       	brne	.+26     	; 0x283a <vTaskStartScheduler+0x56>
    2820:	f8 94       	cli
    2822:	80 93 d3 31 	sts	0x31D3, r24	; 0x8031d3 <xSchedulerRunning>
    2826:	10 92 d6 31 	sts	0x31D6, r1	; 0x8031d6 <xTickCount>
    282a:	10 92 d7 31 	sts	0x31D7, r1	; 0x8031d7 <xTickCount+0x1>
    282e:	10 92 d8 31 	sts	0x31D8, r1	; 0x8031d8 <xTickCount+0x2>
    2832:	10 92 d9 31 	sts	0x31D9, r1	; 0x8031d9 <xTickCount+0x3>
    2836:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <xPortStartScheduler>
    283a:	0f 91       	pop	r16
    283c:	ff 90       	pop	r15
    283e:	ef 90       	pop	r14
    2840:	df 90       	pop	r13
    2842:	cf 90       	pop	r12
    2844:	bf 90       	pop	r11
    2846:	af 90       	pop	r10
    2848:	08 95       	ret

0000284a <vTaskSuspendAll>:
    284a:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    284e:	8f 5f       	subi	r24, 0xFF	; 255
    2850:	80 93 d2 31 	sts	0x31D2, r24	; 0x8031d2 <uxSchedulerSuspended>
    2854:	08 95       	ret

00002856 <xTaskGetTickCount>:
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	0f 92       	push	r0
    285c:	60 91 d6 31 	lds	r22, 0x31D6	; 0x8031d6 <xTickCount>
    2860:	70 91 d7 31 	lds	r23, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2864:	80 91 d8 31 	lds	r24, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2868:	90 91 d9 31 	lds	r25, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    286c:	0f 90       	pop	r0
    286e:	0f be       	out	0x3f, r0	; 63
    2870:	08 95       	ret

00002872 <pcTaskGetTaskName>:
    2872:	00 97       	sbiw	r24, 0x00	; 0
    2874:	21 f4       	brne	.+8      	; 0x287e <pcTaskGetTaskName+0xc>
    2876:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    287a:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    287e:	4d 96       	adiw	r24, 0x1d	; 29
    2880:	08 95       	ret

00002882 <xTaskGetIdleTaskHandle>:
    2882:	80 91 db 31 	lds	r24, 0x31DB	; 0x8031db <xIdleTaskHandle>
    2886:	90 91 dc 31 	lds	r25, 0x31DC	; 0x8031dc <xIdleTaskHandle+0x1>
    288a:	08 95       	ret

0000288c <vTaskIncrementTick>:
    288c:	ff 92       	push	r15
    288e:	0f 93       	push	r16
    2890:	1f 93       	push	r17
    2892:	cf 93       	push	r28
    2894:	df 93       	push	r29
    2896:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    289a:	81 11       	cpse	r24, r1
    289c:	ed c0       	rjmp	.+474    	; 0x2a78 <vTaskIncrementTick+0x1ec>
    289e:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    28a2:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    28a6:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    28aa:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    28ae:	01 96       	adiw	r24, 0x01	; 1
    28b0:	a1 1d       	adc	r26, r1
    28b2:	b1 1d       	adc	r27, r1
    28b4:	80 93 d6 31 	sts	0x31D6, r24	; 0x8031d6 <xTickCount>
    28b8:	90 93 d7 31 	sts	0x31D7, r25	; 0x8031d7 <xTickCount+0x1>
    28bc:	a0 93 d8 31 	sts	0x31D8, r26	; 0x8031d8 <xTickCount+0x2>
    28c0:	b0 93 d9 31 	sts	0x31D9, r27	; 0x8031d9 <xTickCount+0x3>
    28c4:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    28c8:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    28cc:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    28d0:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    28d4:	89 2b       	or	r24, r25
    28d6:	8a 2b       	or	r24, r26
    28d8:	8b 2b       	or	r24, r27
    28da:	f1 f5       	brne	.+124    	; 0x2958 <vTaskIncrementTick+0xcc>
    28dc:	80 91 ea 31 	lds	r24, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    28e0:	90 91 eb 31 	lds	r25, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    28e4:	20 91 e8 31 	lds	r18, 0x31E8	; 0x8031e8 <pxOverflowDelayedTaskList>
    28e8:	30 91 e9 31 	lds	r19, 0x31E9	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    28ec:	20 93 ea 31 	sts	0x31EA, r18	; 0x8031ea <pxDelayedTaskList>
    28f0:	30 93 eb 31 	sts	0x31EB, r19	; 0x8031eb <pxDelayedTaskList+0x1>
    28f4:	80 93 e8 31 	sts	0x31E8, r24	; 0x8031e8 <pxOverflowDelayedTaskList>
    28f8:	90 93 e9 31 	sts	0x31E9, r25	; 0x8031e9 <pxOverflowDelayedTaskList+0x1>
    28fc:	80 91 cf 31 	lds	r24, 0x31CF	; 0x8031cf <xNumOfOverflows>
    2900:	8f 5f       	subi	r24, 0xFF	; 255
    2902:	80 93 cf 31 	sts	0x31CF, r24	; 0x8031cf <xNumOfOverflows>
    2906:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    290a:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    290e:	80 81       	ld	r24, Z
    2910:	81 11       	cpse	r24, r1
    2912:	0c c0       	rjmp	.+24     	; 0x292c <vTaskIncrementTick+0xa0>
    2914:	8f ef       	ldi	r24, 0xFF	; 255
    2916:	9f ef       	ldi	r25, 0xFF	; 255
    2918:	dc 01       	movw	r26, r24
    291a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    291e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2922:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2926:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    292a:	16 c0       	rjmp	.+44     	; 0x2958 <vTaskIncrementTick+0xcc>
    292c:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2930:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2934:	07 80       	ldd	r0, Z+7	; 0x07
    2936:	f0 85       	ldd	r31, Z+8	; 0x08
    2938:	e0 2d       	mov	r30, r0
    293a:	00 84       	ldd	r0, Z+8	; 0x08
    293c:	f1 85       	ldd	r31, Z+9	; 0x09
    293e:	e0 2d       	mov	r30, r0
    2940:	82 81       	ldd	r24, Z+2	; 0x02
    2942:	93 81       	ldd	r25, Z+3	; 0x03
    2944:	a4 81       	ldd	r26, Z+4	; 0x04
    2946:	b5 81       	ldd	r27, Z+5	; 0x05
    2948:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    294c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2950:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2954:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2958:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    295c:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2960:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2964:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2968:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    296c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2970:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2974:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2978:	48 17       	cp	r20, r24
    297a:	59 07       	cpc	r21, r25
    297c:	6a 07       	cpc	r22, r26
    297e:	7b 07       	cpc	r23, r27
    2980:	08 f4       	brcc	.+2      	; 0x2984 <vTaskIncrementTick+0xf8>
    2982:	7f c0       	rjmp	.+254    	; 0x2a82 <vTaskIncrementTick+0x1f6>
    2984:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2988:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    298c:	80 81       	ld	r24, Z
    298e:	88 23       	and	r24, r24
    2990:	f9 f0       	breq	.+62     	; 0x29d0 <vTaskIncrementTick+0x144>
    2992:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2996:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    299a:	07 80       	ldd	r0, Z+7	; 0x07
    299c:	f0 85       	ldd	r31, Z+8	; 0x08
    299e:	e0 2d       	mov	r30, r0
    29a0:	c0 85       	ldd	r28, Z+8	; 0x08
    29a2:	d1 85       	ldd	r29, Z+9	; 0x09
    29a4:	8a 81       	ldd	r24, Y+2	; 0x02
    29a6:	9b 81       	ldd	r25, Y+3	; 0x03
    29a8:	ac 81       	ldd	r26, Y+4	; 0x04
    29aa:	bd 81       	ldd	r27, Y+5	; 0x05
    29ac:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    29b0:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    29b4:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    29b8:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    29bc:	48 17       	cp	r20, r24
    29be:	59 07       	cpc	r21, r25
    29c0:	6a 07       	cpc	r22, r26
    29c2:	7b 07       	cpc	r23, r27
    29c4:	58 f1       	brcs	.+86     	; 0x2a1c <vTaskIncrementTick+0x190>
    29c6:	0f 2e       	mov	r0, r31
    29c8:	fb e0       	ldi	r31, 0x0B	; 11
    29ca:	ff 2e       	mov	r15, r31
    29cc:	f0 2d       	mov	r31, r0
    29ce:	2f c0       	rjmp	.+94     	; 0x2a2e <vTaskIncrementTick+0x1a2>
    29d0:	8f ef       	ldi	r24, 0xFF	; 255
    29d2:	9f ef       	ldi	r25, 0xFF	; 255
    29d4:	dc 01       	movw	r26, r24
    29d6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    29da:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    29de:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    29e2:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    29e6:	4d c0       	rjmp	.+154    	; 0x2a82 <vTaskIncrementTick+0x1f6>
    29e8:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    29ec:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    29f0:	07 80       	ldd	r0, Z+7	; 0x07
    29f2:	f0 85       	ldd	r31, Z+8	; 0x08
    29f4:	e0 2d       	mov	r30, r0
    29f6:	c0 85       	ldd	r28, Z+8	; 0x08
    29f8:	d1 85       	ldd	r29, Z+9	; 0x09
    29fa:	8a 81       	ldd	r24, Y+2	; 0x02
    29fc:	9b 81       	ldd	r25, Y+3	; 0x03
    29fe:	ac 81       	ldd	r26, Y+4	; 0x04
    2a00:	bd 81       	ldd	r27, Y+5	; 0x05
    2a02:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    2a06:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2a0a:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2a0e:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2a12:	48 17       	cp	r20, r24
    2a14:	59 07       	cpc	r21, r25
    2a16:	6a 07       	cpc	r22, r26
    2a18:	7b 07       	cpc	r23, r27
    2a1a:	48 f4       	brcc	.+18     	; 0x2a2e <vTaskIncrementTick+0x1a2>
    2a1c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2a20:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a24:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a28:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a2c:	2a c0       	rjmp	.+84     	; 0x2a82 <vTaskIncrementTick+0x1f6>
    2a2e:	8e 01       	movw	r16, r28
    2a30:	0e 5f       	subi	r16, 0xFE	; 254
    2a32:	1f 4f       	sbci	r17, 0xFF	; 255
    2a34:	c8 01       	movw	r24, r16
    2a36:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
    2a3a:	88 8d       	ldd	r24, Y+24	; 0x18
    2a3c:	99 8d       	ldd	r25, Y+25	; 0x19
    2a3e:	89 2b       	or	r24, r25
    2a40:	21 f0       	breq	.+8      	; 0x2a4a <vTaskIncrementTick+0x1be>
    2a42:	ce 01       	movw	r24, r28
    2a44:	0e 96       	adiw	r24, 0x0e	; 14
    2a46:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
    2a4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2a4c:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2a50:	98 17       	cp	r25, r24
    2a52:	10 f4       	brcc	.+4      	; 0x2a58 <vTaskIncrementTick+0x1cc>
    2a54:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2a58:	f8 9e       	mul	r15, r24
    2a5a:	c0 01       	movw	r24, r0
    2a5c:	11 24       	eor	r1, r1
    2a5e:	b8 01       	movw	r22, r16
    2a60:	8e 5f       	subi	r24, 0xFE	; 254
    2a62:	9d 4c       	sbci	r25, 0xCD	; 205
    2a64:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    2a68:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <pxDelayedTaskList>
    2a6c:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <pxDelayedTaskList+0x1>
    2a70:	80 81       	ld	r24, Z
    2a72:	81 11       	cpse	r24, r1
    2a74:	b9 cf       	rjmp	.-142    	; 0x29e8 <vTaskIncrementTick+0x15c>
    2a76:	ac cf       	rjmp	.-168    	; 0x29d0 <vTaskIncrementTick+0x144>
    2a78:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2a7c:	8f 5f       	subi	r24, 0xFF	; 255
    2a7e:	80 93 d1 31 	sts	0x31D1, r24	; 0x8031d1 <uxMissedTicks>
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	1f 91       	pop	r17
    2a88:	0f 91       	pop	r16
    2a8a:	ff 90       	pop	r15
    2a8c:	08 95       	ret

00002a8e <xTaskResumeAll>:
    2a8e:	cf 92       	push	r12
    2a90:	df 92       	push	r13
    2a92:	ef 92       	push	r14
    2a94:	ff 92       	push	r15
    2a96:	0f 93       	push	r16
    2a98:	1f 93       	push	r17
    2a9a:	cf 93       	push	r28
    2a9c:	df 93       	push	r29
    2a9e:	0f b6       	in	r0, 0x3f	; 63
    2aa0:	f8 94       	cli
    2aa2:	0f 92       	push	r0
    2aa4:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2aa8:	81 50       	subi	r24, 0x01	; 1
    2aaa:	80 93 d2 31 	sts	0x31D2, r24	; 0x8031d2 <uxSchedulerSuspended>
    2aae:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2ab2:	81 11       	cpse	r24, r1
    2ab4:	60 c0       	rjmp	.+192    	; 0x2b76 <xTaskResumeAll+0xe8>
    2ab6:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <uxCurrentNumberOfTasks>
    2aba:	81 11       	cpse	r24, r1
    2abc:	2c c0       	rjmp	.+88     	; 0x2b16 <xTaskResumeAll+0x88>
    2abe:	5e c0       	rjmp	.+188    	; 0x2b7c <xTaskResumeAll+0xee>
    2ac0:	d7 01       	movw	r26, r14
    2ac2:	17 96       	adiw	r26, 0x07	; 7
    2ac4:	ed 91       	ld	r30, X+
    2ac6:	fc 91       	ld	r31, X
    2ac8:	18 97       	sbiw	r26, 0x08	; 8
    2aca:	c0 85       	ldd	r28, Z+8	; 0x08
    2acc:	d1 85       	ldd	r29, Z+9	; 0x09
    2ace:	ce 01       	movw	r24, r28
    2ad0:	0e 96       	adiw	r24, 0x0e	; 14
    2ad2:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
    2ad6:	8e 01       	movw	r16, r28
    2ad8:	0e 5f       	subi	r16, 0xFE	; 254
    2ada:	1f 4f       	sbci	r17, 0xFF	; 255
    2adc:	c8 01       	movw	r24, r16
    2ade:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
    2ae2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ae4:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2ae8:	98 17       	cp	r25, r24
    2aea:	10 f4       	brcc	.+4      	; 0x2af0 <xTaskResumeAll+0x62>
    2aec:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2af0:	d8 9e       	mul	r13, r24
    2af2:	c0 01       	movw	r24, r0
    2af4:	11 24       	eor	r1, r1
    2af6:	b8 01       	movw	r22, r16
    2af8:	8e 5f       	subi	r24, 0xFE	; 254
    2afa:	9d 4c       	sbci	r25, 0xCD	; 205
    2afc:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    2b00:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2b04:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2b08:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2b0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b0c:	98 17       	cp	r25, r24
    2b0e:	70 f0       	brcs	.+28     	; 0x2b2c <xTaskResumeAll+0x9e>
    2b10:	cc 24       	eor	r12, r12
    2b12:	c3 94       	inc	r12
    2b14:	0b c0       	rjmp	.+22     	; 0x2b2c <xTaskResumeAll+0x9e>
    2b16:	c1 2c       	mov	r12, r1
    2b18:	0f 2e       	mov	r0, r31
    2b1a:	fd ed       	ldi	r31, 0xDD	; 221
    2b1c:	ef 2e       	mov	r14, r31
    2b1e:	f1 e3       	ldi	r31, 0x31	; 49
    2b20:	ff 2e       	mov	r15, r31
    2b22:	f0 2d       	mov	r31, r0
    2b24:	0f 2e       	mov	r0, r31
    2b26:	fb e0       	ldi	r31, 0x0B	; 11
    2b28:	df 2e       	mov	r13, r31
    2b2a:	f0 2d       	mov	r31, r0
    2b2c:	f7 01       	movw	r30, r14
    2b2e:	80 81       	ld	r24, Z
    2b30:	81 11       	cpse	r24, r1
    2b32:	c6 cf       	rjmp	.-116    	; 0x2ac0 <xTaskResumeAll+0x32>
    2b34:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b38:	88 23       	and	r24, r24
    2b3a:	81 f0       	breq	.+32     	; 0x2b5c <xTaskResumeAll+0xce>
    2b3c:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b40:	88 23       	and	r24, r24
    2b42:	99 f0       	breq	.+38     	; 0x2b6a <xTaskResumeAll+0xdc>
    2b44:	0e 94 46 14 	call	0x288c	; 0x288c <vTaskIncrementTick>
    2b48:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b4c:	81 50       	subi	r24, 0x01	; 1
    2b4e:	80 93 d1 31 	sts	0x31D1, r24	; 0x8031d1 <uxMissedTicks>
    2b52:	80 91 d1 31 	lds	r24, 0x31D1	; 0x8031d1 <uxMissedTicks>
    2b56:	81 11       	cpse	r24, r1
    2b58:	f5 cf       	rjmp	.-22     	; 0x2b44 <xTaskResumeAll+0xb6>
    2b5a:	07 c0       	rjmp	.+14     	; 0x2b6a <xTaskResumeAll+0xdc>
    2b5c:	f1 e0       	ldi	r31, 0x01	; 1
    2b5e:	cf 16       	cp	r12, r31
    2b60:	21 f0       	breq	.+8      	; 0x2b6a <xTaskResumeAll+0xdc>
    2b62:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <xMissedYield>
    2b66:	81 30       	cpi	r24, 0x01	; 1
    2b68:	41 f4       	brne	.+16     	; 0x2b7a <xTaskResumeAll+0xec>
    2b6a:	10 92 d0 31 	sts	0x31D0, r1	; 0x8031d0 <xMissedYield>
    2b6e:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
    2b72:	81 e0       	ldi	r24, 0x01	; 1
    2b74:	03 c0       	rjmp	.+6      	; 0x2b7c <xTaskResumeAll+0xee>
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	01 c0       	rjmp	.+2      	; 0x2b7c <xTaskResumeAll+0xee>
    2b7a:	80 e0       	ldi	r24, 0x00	; 0
    2b7c:	0f 90       	pop	r0
    2b7e:	0f be       	out	0x3f, r0	; 63
    2b80:	df 91       	pop	r29
    2b82:	cf 91       	pop	r28
    2b84:	1f 91       	pop	r17
    2b86:	0f 91       	pop	r16
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	df 90       	pop	r13
    2b8e:	cf 90       	pop	r12
    2b90:	08 95       	ret

00002b92 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2b92:	cf 92       	push	r12
    2b94:	df 92       	push	r13
    2b96:	ef 92       	push	r14
    2b98:	ff 92       	push	r15
    2b9a:	6b 01       	movw	r12, r22
    2b9c:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2b9e:	67 2b       	or	r22, r23
    2ba0:	68 2b       	or	r22, r24
    2ba2:	69 2b       	or	r22, r25
    2ba4:	e9 f0       	breq	.+58     	; 0x2be0 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2ba6:	0e 94 25 14 	call	0x284a	; 0x284a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2baa:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2bae:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2bb2:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2bb6:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2bba:	c8 0e       	add	r12, r24
    2bbc:	d9 1e       	adc	r13, r25
    2bbe:	ea 1e       	adc	r14, r26
    2bc0:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2bc2:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2bc6:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2bca:	02 96       	adiw	r24, 0x02	; 2
    2bcc:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2bd0:	c7 01       	movw	r24, r14
    2bd2:	b6 01       	movw	r22, r12
    2bd4:	0e 94 94 12 	call	0x2528	; 0x2528 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2bd8:	0e 94 47 15 	call	0x2a8e	; 0x2a8e <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2bdc:	81 11       	cpse	r24, r1
    2bde:	02 c0       	rjmp	.+4      	; 0x2be4 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2be0:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <vPortYield>
		}
	}
    2be4:	ff 90       	pop	r15
    2be6:	ef 90       	pop	r14
    2be8:	df 90       	pop	r13
    2bea:	cf 90       	pop	r12
    2bec:	08 95       	ret

00002bee <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2bee:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2bf2:	81 11       	cpse	r24, r1
    2bf4:	0c c0       	rjmp	.+24     	; 0x2c0e <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2bf6:	e0 91 d4 31 	lds	r30, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2bfa:	4b e0       	ldi	r20, 0x0B	; 11
    2bfc:	e4 9f       	mul	r30, r20
    2bfe:	f0 01       	movw	r30, r0
    2c00:	11 24       	eor	r1, r1
    2c02:	ee 5f       	subi	r30, 0xFE	; 254
    2c04:	fd 4c       	sbci	r31, 0xCD	; 205
    2c06:	80 81       	ld	r24, Z
    2c08:	88 23       	and	r24, r24
    2c0a:	29 f0       	breq	.+10     	; 0x2c16 <vTaskSwitchContext+0x28>
    2c0c:	14 c0       	rjmp	.+40     	; 0x2c36 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
    2c10:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <xMissedYield>
    2c14:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c16:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2c18:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c1c:	81 50       	subi	r24, 0x01	; 1
    2c1e:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2c22:	e0 91 d4 31 	lds	r30, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c26:	9e 9f       	mul	r25, r30
    2c28:	f0 01       	movw	r30, r0
    2c2a:	11 24       	eor	r1, r1
    2c2c:	ee 5f       	subi	r30, 0xFE	; 254
    2c2e:	fd 4c       	sbci	r31, 0xCD	; 205
    2c30:	80 81       	ld	r24, Z
    2c32:	88 23       	and	r24, r24
    2c34:	89 f3       	breq	.-30     	; 0x2c18 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2c36:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2c3a:	28 2f       	mov	r18, r24
    2c3c:	30 e0       	ldi	r19, 0x00	; 0
    2c3e:	4b e0       	ldi	r20, 0x0B	; 11
    2c40:	84 9f       	mul	r24, r20
    2c42:	c0 01       	movw	r24, r0
    2c44:	11 24       	eor	r1, r1
    2c46:	dc 01       	movw	r26, r24
    2c48:	ae 5f       	subi	r26, 0xFE	; 254
    2c4a:	bd 4c       	sbci	r27, 0xCD	; 205
    2c4c:	11 96       	adiw	r26, 0x01	; 1
    2c4e:	ed 91       	ld	r30, X+
    2c50:	fc 91       	ld	r31, X
    2c52:	12 97       	sbiw	r26, 0x02	; 2
    2c54:	04 80       	ldd	r0, Z+4	; 0x04
    2c56:	f5 81       	ldd	r31, Z+5	; 0x05
    2c58:	e0 2d       	mov	r30, r0
    2c5a:	11 96       	adiw	r26, 0x01	; 1
    2c5c:	ed 93       	st	X+, r30
    2c5e:	fc 93       	st	X, r31
    2c60:	12 97       	sbiw	r26, 0x02	; 2
    2c62:	8b 5f       	subi	r24, 0xFB	; 251
    2c64:	9d 4c       	sbci	r25, 0xCD	; 205
    2c66:	e8 17       	cp	r30, r24
    2c68:	f9 07       	cpc	r31, r25
    2c6a:	61 f4       	brne	.+24     	; 0x2c84 <vTaskSwitchContext+0x96>
    2c6c:	84 81       	ldd	r24, Z+4	; 0x04
    2c6e:	95 81       	ldd	r25, Z+5	; 0x05
    2c70:	4b e0       	ldi	r20, 0x0B	; 11
    2c72:	42 9f       	mul	r20, r18
    2c74:	f0 01       	movw	r30, r0
    2c76:	43 9f       	mul	r20, r19
    2c78:	f0 0d       	add	r31, r0
    2c7a:	11 24       	eor	r1, r1
    2c7c:	ee 5f       	subi	r30, 0xFE	; 254
    2c7e:	fd 4c       	sbci	r31, 0xCD	; 205
    2c80:	81 83       	std	Z+1, r24	; 0x01
    2c82:	92 83       	std	Z+2, r25	; 0x02
    2c84:	8b e0       	ldi	r24, 0x0B	; 11
    2c86:	82 9f       	mul	r24, r18
    2c88:	f0 01       	movw	r30, r0
    2c8a:	83 9f       	mul	r24, r19
    2c8c:	f0 0d       	add	r31, r0
    2c8e:	11 24       	eor	r1, r1
    2c90:	ee 5f       	subi	r30, 0xFE	; 254
    2c92:	fd 4c       	sbci	r31, 0xCD	; 205
    2c94:	01 80       	ldd	r0, Z+1	; 0x01
    2c96:	f2 81       	ldd	r31, Z+2	; 0x02
    2c98:	e0 2d       	mov	r30, r0
    2c9a:	80 85       	ldd	r24, Z+8	; 0x08
    2c9c:	91 85       	ldd	r25, Z+9	; 0x09
    2c9e:	80 93 2e 32 	sts	0x322E, r24	; 0x80322e <pxCurrentTCB>
    2ca2:	90 93 2f 32 	sts	0x322F, r25	; 0x80322f <pxCurrentTCB+0x1>
    2ca6:	08 95       	ret

00002ca8 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2ca8:	cf 92       	push	r12
    2caa:	df 92       	push	r13
    2cac:	ef 92       	push	r14
    2cae:	ff 92       	push	r15
    2cb0:	6a 01       	movw	r12, r20
    2cb2:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2cb4:	60 91 2e 32 	lds	r22, 0x322E	; 0x80322e <pxCurrentTCB>
    2cb8:	70 91 2f 32 	lds	r23, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2cbc:	62 5f       	subi	r22, 0xF2	; 242
    2cbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc0:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2cc4:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2cc8:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2ccc:	02 96       	adiw	r24, 0x02	; 2
    2cce:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2cd2:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2cd6:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2cda:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2cde:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ce2:	bc 01       	movw	r22, r24
    2ce4:	cd 01       	movw	r24, r26
    2ce6:	6c 0d       	add	r22, r12
    2ce8:	7d 1d       	adc	r23, r13
    2cea:	8e 1d       	adc	r24, r14
    2cec:	9f 1d       	adc	r25, r15
    2cee:	0e 94 94 12 	call	0x2528	; 0x2528 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2cf2:	ff 90       	pop	r15
    2cf4:	ef 90       	pop	r14
    2cf6:	df 90       	pop	r13
    2cf8:	cf 90       	pop	r12
    2cfa:	08 95       	ret

00002cfc <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2cfc:	0f 93       	push	r16
    2cfe:	1f 93       	push	r17
    2d00:	cf 93       	push	r28
    2d02:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d04:	dc 01       	movw	r26, r24
    2d06:	17 96       	adiw	r26, 0x07	; 7
    2d08:	ed 91       	ld	r30, X+
    2d0a:	fc 91       	ld	r31, X
    2d0c:	18 97       	sbiw	r26, 0x08	; 8
    2d0e:	c0 85       	ldd	r28, Z+8	; 0x08
    2d10:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d12:	8e 01       	movw	r16, r28
    2d14:	02 5f       	subi	r16, 0xF2	; 242
    2d16:	1f 4f       	sbci	r17, 0xFF	; 255
    2d18:	c8 01       	movw	r24, r16
    2d1a:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d1e:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <uxSchedulerSuspended>
    2d22:	81 11       	cpse	r24, r1
    2d24:	16 c0       	rjmp	.+44     	; 0x2d52 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d26:	0c 50       	subi	r16, 0x0C	; 12
    2d28:	11 09       	sbc	r17, r1
    2d2a:	c8 01       	movw	r24, r16
    2d2c:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2d30:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d32:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2d36:	98 17       	cp	r25, r24
    2d38:	10 f4       	brcc	.+4      	; 0x2d3e <xTaskRemoveFromEventList+0x42>
    2d3a:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2d3e:	bb e0       	ldi	r27, 0x0B	; 11
    2d40:	8b 9f       	mul	r24, r27
    2d42:	c0 01       	movw	r24, r0
    2d44:	11 24       	eor	r1, r1
    2d46:	b8 01       	movw	r22, r16
    2d48:	8e 5f       	subi	r24, 0xFE	; 254
    2d4a:	9d 4c       	sbci	r25, 0xCD	; 205
    2d4c:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    2d50:	05 c0       	rjmp	.+10     	; 0x2d5c <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2d52:	b8 01       	movw	r22, r16
    2d54:	8d ed       	ldi	r24, 0xDD	; 221
    2d56:	91 e3       	ldi	r25, 0x31	; 49
    2d58:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2d5c:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2d60:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2d64:	81 e0       	ldi	r24, 0x01	; 1
    2d66:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d68:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d6a:	29 17       	cp	r18, r25
    2d6c:	08 f4       	brcc	.+2      	; 0x2d70 <xTaskRemoveFromEventList+0x74>
    2d6e:	80 e0       	ldi	r24, 0x00	; 0
}
    2d70:	df 91       	pop	r29
    2d72:	cf 91       	pop	r28
    2d74:	1f 91       	pop	r17
    2d76:	0f 91       	pop	r16
    2d78:	08 95       	ret

00002d7a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2d7a:	20 91 cf 31 	lds	r18, 0x31CF	; 0x8031cf <xNumOfOverflows>
    2d7e:	fc 01       	movw	r30, r24
    2d80:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d82:	40 91 d6 31 	lds	r20, 0x31D6	; 0x8031d6 <xTickCount>
    2d86:	50 91 d7 31 	lds	r21, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2d8a:	60 91 d8 31 	lds	r22, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2d8e:	70 91 d9 31 	lds	r23, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2d92:	41 83       	std	Z+1, r20	; 0x01
    2d94:	52 83       	std	Z+2, r21	; 0x02
    2d96:	63 83       	std	Z+3, r22	; 0x03
    2d98:	74 83       	std	Z+4, r23	; 0x04
    2d9a:	08 95       	ret

00002d9c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2d9c:	8f 92       	push	r8
    2d9e:	9f 92       	push	r9
    2da0:	af 92       	push	r10
    2da2:	bf 92       	push	r11
    2da4:	cf 92       	push	r12
    2da6:	df 92       	push	r13
    2da8:	ef 92       	push	r14
    2daa:	ff 92       	push	r15
    2dac:	0f 93       	push	r16
    2dae:	1f 93       	push	r17
    2db0:	cf 93       	push	r28
    2db2:	df 93       	push	r29
    2db4:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2db6:	0f b6       	in	r0, 0x3f	; 63
    2db8:	f8 94       	cli
    2dba:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2dbc:	80 91 cf 31 	lds	r24, 0x31CF	; 0x8031cf <xNumOfOverflows>
    2dc0:	90 81       	ld	r25, Z
    2dc2:	98 17       	cp	r25, r24
    2dc4:	89 f0       	breq	.+34     	; 0x2de8 <xTaskCheckForTimeOut+0x4c>
    2dc6:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2dca:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2dce:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2dd2:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2dd6:	01 81       	ldd	r16, Z+1	; 0x01
    2dd8:	12 81       	ldd	r17, Z+2	; 0x02
    2dda:	23 81       	ldd	r18, Z+3	; 0x03
    2ddc:	34 81       	ldd	r19, Z+4	; 0x04
    2dde:	80 17       	cp	r24, r16
    2de0:	91 07       	cpc	r25, r17
    2de2:	a2 07       	cpc	r26, r18
    2de4:	b3 07       	cpc	r27, r19
    2de6:	a8 f5       	brcc	.+106    	; 0x2e52 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2de8:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <xTickCount>
    2dec:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2df0:	a0 91 d8 31 	lds	r26, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2df4:	b0 91 d9 31 	lds	r27, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2df8:	c1 80       	ldd	r12, Z+1	; 0x01
    2dfa:	d2 80       	ldd	r13, Z+2	; 0x02
    2dfc:	e3 80       	ldd	r14, Z+3	; 0x03
    2dfe:	f4 80       	ldd	r15, Z+4	; 0x04
    2e00:	eb 01       	movw	r28, r22
    2e02:	08 81       	ld	r16, Y
    2e04:	19 81       	ldd	r17, Y+1	; 0x01
    2e06:	2a 81       	ldd	r18, Y+2	; 0x02
    2e08:	3b 81       	ldd	r19, Y+3	; 0x03
    2e0a:	8c 19       	sub	r24, r12
    2e0c:	9d 09       	sbc	r25, r13
    2e0e:	ae 09       	sbc	r26, r14
    2e10:	bf 09       	sbc	r27, r15
    2e12:	80 17       	cp	r24, r16
    2e14:	91 07       	cpc	r25, r17
    2e16:	a2 07       	cpc	r26, r18
    2e18:	b3 07       	cpc	r27, r19
    2e1a:	e8 f4       	brcc	.+58     	; 0x2e56 <xTaskCheckForTimeOut+0xba>
    2e1c:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2e1e:	80 90 d6 31 	lds	r8, 0x31D6	; 0x8031d6 <xTickCount>
    2e22:	90 90 d7 31 	lds	r9, 0x31D7	; 0x8031d7 <xTickCount+0x1>
    2e26:	a0 90 d8 31 	lds	r10, 0x31D8	; 0x8031d8 <xTickCount+0x2>
    2e2a:	b0 90 d9 31 	lds	r11, 0x31D9	; 0x8031d9 <xTickCount+0x3>
    2e2e:	b5 01       	movw	r22, r10
    2e30:	a4 01       	movw	r20, r8
    2e32:	4c 19       	sub	r20, r12
    2e34:	5d 09       	sbc	r21, r13
    2e36:	6e 09       	sbc	r22, r14
    2e38:	7f 09       	sbc	r23, r15
    2e3a:	04 1b       	sub	r16, r20
    2e3c:	15 0b       	sbc	r17, r21
    2e3e:	26 0b       	sbc	r18, r22
    2e40:	37 0b       	sbc	r19, r23
    2e42:	08 83       	st	Y, r16
    2e44:	19 83       	std	Y+1, r17	; 0x01
    2e46:	2a 83       	std	Y+2, r18	; 0x02
    2e48:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2e4a:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2e4e:	80 e0       	ldi	r24, 0x00	; 0
    2e50:	03 c0       	rjmp	.+6      	; 0x2e58 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2e52:	81 e0       	ldi	r24, 0x01	; 1
    2e54:	01 c0       	rjmp	.+2      	; 0x2e58 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2e56:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2e58:	0f 90       	pop	r0
    2e5a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2e5c:	df 91       	pop	r29
    2e5e:	cf 91       	pop	r28
    2e60:	1f 91       	pop	r17
    2e62:	0f 91       	pop	r16
    2e64:	ff 90       	pop	r15
    2e66:	ef 90       	pop	r14
    2e68:	df 90       	pop	r13
    2e6a:	cf 90       	pop	r12
    2e6c:	bf 90       	pop	r11
    2e6e:	af 90       	pop	r10
    2e70:	9f 90       	pop	r9
    2e72:	8f 90       	pop	r8
    2e74:	08 95       	ret

00002e76 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <xMissedYield>
    2e7c:	08 95       	ret

00002e7e <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2e7e:	00 97       	sbiw	r24, 0x00	; 0
    2e80:	21 f4       	brne	.+8      	; 0x2e8a <uxTaskGetStackHighWaterMark+0xc>
    2e82:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2e86:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2e8a:	dc 01       	movw	r26, r24
    2e8c:	5b 96       	adiw	r26, 0x1b	; 27
    2e8e:	ed 91       	ld	r30, X+
    2e90:	fc 91       	ld	r31, X
    2e92:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2e94:	80 81       	ld	r24, Z
    2e96:	81 31       	cpi	r24, 0x11	; 17
    2e98:	41 f4       	brne	.+16     	; 0x2eaa <uxTaskGetStackHighWaterMark+0x2c>
    2e9a:	31 96       	adiw	r30, 0x01	; 1
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2ea0:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2ea2:	21 91       	ld	r18, Z+
    2ea4:	21 31       	cpi	r18, 0x11	; 17
    2ea6:	e1 f3       	breq	.-8      	; 0x2ea0 <uxTaskGetStackHighWaterMark+0x22>
    2ea8:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2eaa:	80 e0       	ldi	r24, 0x00	; 0
    2eac:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2eae:	08 95       	ret

00002eb0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2eb0:	80 91 2e 32 	lds	r24, 0x322E	; 0x80322e <pxCurrentTCB>
    2eb4:	90 91 2f 32 	lds	r25, 0x322F	; 0x80322f <pxCurrentTCB+0x1>

		return xReturn;
	}
    2eb8:	08 95       	ret

00002eba <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2eba:	0f 93       	push	r16
    2ebc:	1f 93       	push	r17
    2ebe:	cf 93       	push	r28
    2ec0:	df 93       	push	r29
    2ec2:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2ec4:	22 8d       	ldd	r18, Z+26	; 0x1a
    2ec6:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2eca:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2ece:	5a 96       	adiw	r26, 0x1a	; 26
    2ed0:	8c 91       	ld	r24, X
    2ed2:	28 17       	cp	r18, r24
    2ed4:	08 f0       	brcs	.+2      	; 0x2ed8 <vTaskPriorityInherit+0x1e>
    2ed6:	41 c0       	rjmp	.+130    	; 0x2f5a <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2ed8:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2edc:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2ee0:	5a 96       	adiw	r26, 0x1a	; 26
    2ee2:	3c 91       	ld	r19, X
    2ee4:	84 e0       	ldi	r24, 0x04	; 4
    2ee6:	90 e0       	ldi	r25, 0x00	; 0
    2ee8:	a0 e0       	ldi	r26, 0x00	; 0
    2eea:	b0 e0       	ldi	r27, 0x00	; 0
    2eec:	83 1b       	sub	r24, r19
    2eee:	91 09       	sbc	r25, r1
    2ef0:	a1 09       	sbc	r26, r1
    2ef2:	b1 09       	sbc	r27, r1
    2ef4:	86 87       	std	Z+14, r24	; 0x0e
    2ef6:	97 87       	std	Z+15, r25	; 0x0f
    2ef8:	a0 8b       	std	Z+16, r26	; 0x10
    2efa:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2efc:	8b e0       	ldi	r24, 0x0B	; 11
    2efe:	28 9f       	mul	r18, r24
    2f00:	90 01       	movw	r18, r0
    2f02:	11 24       	eor	r1, r1
    2f04:	2e 5f       	subi	r18, 0xFE	; 254
    2f06:	3d 4c       	sbci	r19, 0xCD	; 205
    2f08:	84 85       	ldd	r24, Z+12	; 0x0c
    2f0a:	95 85       	ldd	r25, Z+13	; 0x0d
    2f0c:	82 17       	cp	r24, r18
    2f0e:	93 07       	cpc	r25, r19
    2f10:	e9 f4       	brne	.+58     	; 0x2f4c <vTaskPriorityInherit+0x92>
    2f12:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2f14:	ef 01       	movw	r28, r30
    2f16:	22 96       	adiw	r28, 0x02	; 2
    2f18:	ce 01       	movw	r24, r28
    2f1a:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f1e:	e0 91 2e 32 	lds	r30, 0x322E	; 0x80322e <pxCurrentTCB>
    2f22:	f0 91 2f 32 	lds	r31, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2f26:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f28:	f8 01       	movw	r30, r16
    2f2a:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2f2c:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2f30:	98 17       	cp	r25, r24
    2f32:	10 f4       	brcc	.+4      	; 0x2f38 <vTaskPriorityInherit+0x7e>
    2f34:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2f38:	fb e0       	ldi	r31, 0x0B	; 11
    2f3a:	8f 9f       	mul	r24, r31
    2f3c:	c0 01       	movw	r24, r0
    2f3e:	11 24       	eor	r1, r1
    2f40:	be 01       	movw	r22, r28
    2f42:	8e 5f       	subi	r24, 0xFE	; 254
    2f44:	9d 4c       	sbci	r25, 0xCD	; 205
    2f46:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
    2f4a:	07 c0       	rjmp	.+14     	; 0x2f5a <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2f4c:	a0 91 2e 32 	lds	r26, 0x322E	; 0x80322e <pxCurrentTCB>
    2f50:	b0 91 2f 32 	lds	r27, 0x322F	; 0x80322f <pxCurrentTCB+0x1>
    2f54:	5a 96       	adiw	r26, 0x1a	; 26
    2f56:	8c 91       	ld	r24, X
    2f58:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2f5a:	df 91       	pop	r29
    2f5c:	cf 91       	pop	r28
    2f5e:	1f 91       	pop	r17
    2f60:	0f 91       	pop	r16
    2f62:	08 95       	ret

00002f64 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2f64:	0f 93       	push	r16
    2f66:	1f 93       	push	r17
    2f68:	cf 93       	push	r28
    2f6a:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2f6c:	00 97       	sbiw	r24, 0x00	; 0
    2f6e:	49 f1       	breq	.+82     	; 0x2fc2 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2f70:	fc 01       	movw	r30, r24
    2f72:	32 8d       	ldd	r19, Z+26	; 0x1a
    2f74:	27 a1       	ldd	r18, Z+39	; 0x27
    2f76:	32 17       	cp	r19, r18
    2f78:	21 f1       	breq	.+72     	; 0x2fc2 <vTaskPriorityDisinherit+0x5e>
    2f7a:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2f7c:	8c 01       	movw	r16, r24
    2f7e:	0e 5f       	subi	r16, 0xFE	; 254
    2f80:	1f 4f       	sbci	r17, 0xFF	; 255
    2f82:	c8 01       	movw	r24, r16
    2f84:	0e 94 0e 0e 	call	0x1c1c	; 0x1c1c <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2f88:	8f a1       	ldd	r24, Y+39	; 0x27
    2f8a:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2f8c:	44 e0       	ldi	r20, 0x04	; 4
    2f8e:	50 e0       	ldi	r21, 0x00	; 0
    2f90:	60 e0       	ldi	r22, 0x00	; 0
    2f92:	70 e0       	ldi	r23, 0x00	; 0
    2f94:	48 1b       	sub	r20, r24
    2f96:	51 09       	sbc	r21, r1
    2f98:	61 09       	sbc	r22, r1
    2f9a:	71 09       	sbc	r23, r1
    2f9c:	4e 87       	std	Y+14, r20	; 0x0e
    2f9e:	5f 87       	std	Y+15, r21	; 0x0f
    2fa0:	68 8b       	std	Y+16, r22	; 0x10
    2fa2:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2fa4:	90 91 d4 31 	lds	r25, 0x31D4	; 0x8031d4 <uxTopReadyPriority>
    2fa8:	98 17       	cp	r25, r24
    2faa:	10 f4       	brcc	.+4      	; 0x2fb0 <vTaskPriorityDisinherit+0x4c>
    2fac:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <uxTopReadyPriority>
    2fb0:	fb e0       	ldi	r31, 0x0B	; 11
    2fb2:	8f 9f       	mul	r24, r31
    2fb4:	c0 01       	movw	r24, r0
    2fb6:	11 24       	eor	r1, r1
    2fb8:	b8 01       	movw	r22, r16
    2fba:	8e 5f       	subi	r24, 0xFE	; 254
    2fbc:	9d 4c       	sbci	r25, 0xCD	; 205
    2fbe:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vListInsertEnd>
			}
		}
	}
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	1f 91       	pop	r17
    2fc8:	0f 91       	pop	r16
    2fca:	08 95       	ret

00002fcc <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2fcc:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2fce:	e8 81       	ld	r30, Y
    2fd0:	f9 81       	ldd	r31, Y+1	; 0x01
    2fd2:	01 90       	ld	r0, Z+
    2fd4:	f0 81       	ld	r31, Z
    2fd6:	e0 2d       	mov	r30, r0
    2fd8:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2fda:	1a 82       	std	Y+2, r1	; 0x02
    2fdc:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2fde:	6f ef       	ldi	r22, 0xFF	; 255
    2fe0:	7f ef       	ldi	r23, 0xFF	; 255
    2fe2:	cb 01       	movw	r24, r22
    2fe4:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <vTaskDelay>
    2fe8:	fa cf       	rjmp	.-12     	; 0x2fde <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002fea <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2fea:	fc 01       	movw	r30, r24
    2fec:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2fee:	65 87       	std	Z+13, r22	; 0x0d
    2ff0:	08 95       	ret

00002ff2 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2ff2:	4f 92       	push	r4
    2ff4:	5f 92       	push	r5
    2ff6:	6f 92       	push	r6
    2ff8:	7f 92       	push	r7
    2ffa:	8f 92       	push	r8
    2ffc:	9f 92       	push	r9
    2ffe:	af 92       	push	r10
    3000:	bf 92       	push	r11
    3002:	cf 92       	push	r12
    3004:	df 92       	push	r13
    3006:	ef 92       	push	r14
    3008:	ff 92       	push	r15
    300a:	0f 93       	push	r16
    300c:	1f 93       	push	r17
    300e:	cf 93       	push	r28
    3010:	df 93       	push	r29
    3012:	cd b7       	in	r28, 0x3d	; 61
    3014:	de b7       	in	r29, 0x3e	; 62
    3016:	2a 97       	sbiw	r28, 0x0a	; 10
    3018:	cd bf       	out	0x3d, r28	; 61
    301a:	de bf       	out	0x3e, r29	; 62
    301c:	4c 01       	movw	r8, r24
    301e:	29 01       	movw	r4, r18
    3020:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    3022:	8c e1       	ldi	r24, 0x1C	; 28
    3024:	91 e2       	ldi	r25, 0x21	; 33
    3026:	f4 01       	movw	r30, r8
    3028:	80 83       	st	Z, r24
    302a:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    302c:	fb 01       	movw	r30, r22
    302e:	80 81       	ld	r24, Z
    3030:	88 23       	and	r24, r24
    3032:	69 f0       	breq	.+26     	; 0x304e <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    3034:	de 01       	movw	r26, r28
    3036:	11 96       	adiw	r26, 0x01	; 1
    3038:	31 96       	adiw	r30, 0x01	; 1
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	02 c0       	rjmp	.+4      	; 0x3042 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    303e:	99 30       	cpi	r25, 0x09	; 9
    3040:	39 f0       	breq	.+14     	; 0x3050 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    3042:	9f 5f       	subi	r25, 0xFF	; 255
    3044:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3046:	81 91       	ld	r24, Z+
    3048:	81 11       	cpse	r24, r1
    304a:	f9 cf       	rjmp	.-14     	; 0x303e <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    304c:	01 c0       	rjmp	.+2      	; 0x3050 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    304e:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3050:	e1 e0       	ldi	r30, 0x01	; 1
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	ec 0f       	add	r30, r28
    3056:	fd 1f       	adc	r31, r29
    3058:	e9 0f       	add	r30, r25
    305a:	f1 1d       	adc	r31, r1
    305c:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    305e:	74 01       	movw	r14, r8
    3060:	f2 e0       	ldi	r31, 0x02	; 2
    3062:	ef 0e       	add	r14, r31
    3064:	f1 1c       	adc	r15, r1
    3066:	a1 2c       	mov	r10, r1
    3068:	b1 2c       	mov	r11, r1
    306a:	c1 2c       	mov	r12, r1
    306c:	d1 2c       	mov	r13, r1
    306e:	04 2f       	mov	r16, r20
    3070:	94 01       	movw	r18, r8
    3072:	a2 01       	movw	r20, r4
    3074:	be 01       	movw	r22, r28
    3076:	6f 5f       	subi	r22, 0xFF	; 255
    3078:	7f 4f       	sbci	r23, 0xFF	; 255
    307a:	82 e3       	ldi	r24, 0x32	; 50
    307c:	93 e0       	ldi	r25, 0x03	; 3
    307e:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    3082:	f4 01       	movw	r30, r8
    3084:	66 82       	std	Z+6, r6	; 0x06
    3086:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3088:	40 86       	std	Z+8, r4	; 0x08
    308a:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    308c:	20 91 30 32 	lds	r18, 0x3230	; 0x803230 <last_created_task_pointer>
    3090:	30 91 31 32 	lds	r19, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    3094:	24 83       	std	Z+4, r18	; 0x04
    3096:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3098:	80 92 30 32 	sts	0x3230, r8	; 0x803230 <last_created_task_pointer>
    309c:	90 92 31 32 	sts	0x3231, r9	; 0x803231 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    30a0:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    30a2:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    30a4:	40 90 92 32 	lds	r4, 0x3292	; 0x803292 <portStackTopForTask>
    30a8:	50 90 93 32 	lds	r5, 0x3293	; 0x803293 <portStackTopForTask+0x1>
    30ac:	ff ef       	ldi	r31, 0xFF	; 255
    30ae:	4f 1a       	sub	r4, r31
    30b0:	5f 0a       	sbc	r5, r31
    30b2:	40 92 92 32 	sts	0x3292, r4	; 0x803292 <portStackTopForTask>
    30b6:	50 92 93 32 	sts	0x3293, r5	; 0x803293 <portStackTopForTask+0x1>
    30ba:	f4 01       	movw	r30, r8
    30bc:	42 86       	std	Z+10, r4	; 0x0a
    30be:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    30c0:	16 86       	std	Z+14, r1	; 0x0e
    30c2:	17 86       	std	Z+15, r1	; 0x0f
    30c4:	10 8a       	std	Z+16, r1	; 0x10
    30c6:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    30c8:	61 14       	cp	r6, r1
    30ca:	71 04       	cpc	r7, r1
    30cc:	09 f4       	brne	.+2      	; 0x30d0 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    30ce:	44 c0       	rjmp	.+136    	; 0x3158 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    30d0:	81 30       	cpi	r24, 0x01	; 1
    30d2:	79 f5       	brne	.+94     	; 0x3132 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    30d4:	6a e0       	ldi	r22, 0x0A	; 10
    30d6:	c3 01       	movw	r24, r6
    30d8:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    30dc:	7c 01       	movw	r14, r24
    30de:	61 eb       	ldi	r22, 0xB1	; 177
    30e0:	75 e0       	ldi	r23, 0x05	; 5
    30e2:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    30e6:	be 01       	movw	r22, r28
    30e8:	6f 5f       	subi	r22, 0xFF	; 255
    30ea:	7f 4f       	sbci	r23, 0xFF	; 255
    30ec:	c7 01       	movw	r24, r14
    30ee:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    30f2:	6a e0       	ldi	r22, 0x0A	; 10
    30f4:	c7 01       	movw	r24, r14
    30f6:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    30fa:	7c 01       	movw	r14, r24
    30fc:	68 ea       	ldi	r22, 0xA8	; 168
    30fe:	75 e0       	ldi	r23, 0x05	; 5
    3100:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3104:	6a e0       	ldi	r22, 0x0A	; 10
    3106:	c7 01       	movw	r24, r14
    3108:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    310c:	7c 01       	movw	r14, r24
    310e:	6a e9       	ldi	r22, 0x9A	; 154
    3110:	75 e0       	ldi	r23, 0x05	; 5
    3112:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3116:	63 e0       	ldi	r22, 0x03	; 3
    3118:	c7 01       	movw	r24, r14
    311a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    311e:	b2 01       	movw	r22, r4
    3120:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    3124:	62 e0       	ldi	r22, 0x02	; 2
    3126:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    312a:	66 e0       	ldi	r22, 0x06	; 6
    312c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3130:	13 c0       	rjmp	.+38     	; 0x3158 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    3132:	6a e0       	ldi	r22, 0x0A	; 10
    3134:	c3 01       	movw	r24, r6
    3136:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    313a:	4c 01       	movw	r8, r24
    313c:	65 e8       	ldi	r22, 0x85	; 133
    313e:	75 e0       	ldi	r23, 0x05	; 5
    3140:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3144:	be 01       	movw	r22, r28
    3146:	6f 5f       	subi	r22, 0xFF	; 255
    3148:	7f 4f       	sbci	r23, 0xFF	; 255
    314a:	c4 01       	movw	r24, r8
    314c:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3150:	66 e0       	ldi	r22, 0x06	; 6
    3152:	c4 01       	movw	r24, r8
    3154:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3158:	2a 96       	adiw	r28, 0x0a	; 10
    315a:	cd bf       	out	0x3d, r28	; 61
    315c:	de bf       	out	0x3e, r29	; 62
    315e:	df 91       	pop	r29
    3160:	cf 91       	pop	r28
    3162:	1f 91       	pop	r17
    3164:	0f 91       	pop	r16
    3166:	ff 90       	pop	r15
    3168:	ef 90       	pop	r14
    316a:	df 90       	pop	r13
    316c:	cf 90       	pop	r12
    316e:	bf 90       	pop	r11
    3170:	af 90       	pop	r10
    3172:	9f 90       	pop	r9
    3174:	8f 90       	pop	r8
    3176:	7f 90       	pop	r7
    3178:	6f 90       	pop	r6
    317a:	5f 90       	pop	r5
    317c:	4f 90       	pop	r4
    317e:	08 95       	ret

00003180 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3180:	cf 92       	push	r12
    3182:	df 92       	push	r13
    3184:	ef 92       	push	r14
    3186:	ff 92       	push	r15
    3188:	0f 93       	push	r16
    318a:	1f 93       	push	r17
    318c:	cf 93       	push	r28
    318e:	df 93       	push	r29
    3190:	ec 01       	movw	r28, r24
    3192:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    3194:	8a 81       	ldd	r24, Y+2	; 0x02
    3196:	9b 81       	ldd	r25, Y+3	; 0x03
    3198:	0e 94 39 14 	call	0x2872	; 0x2872 <pcTaskGetTaskName>
    319c:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    319e:	6a e0       	ldi	r22, 0x0A	; 10
    31a0:	c7 01       	movw	r24, r14
    31a2:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    31a6:	8c 01       	movw	r16, r24
    31a8:	64 ec       	ldi	r22, 0xC4	; 196
    31aa:	75 e0       	ldi	r23, 0x05	; 5
    31ac:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    31b0:	6a e0       	ldi	r22, 0x0A	; 10
    31b2:	c8 01       	movw	r24, r16
    31b4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    31b8:	8c 01       	movw	r16, r24
    31ba:	6d eb       	ldi	r22, 0xBD	; 189
    31bc:	75 e0       	ldi	r23, 0x05	; 5
    31be:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    31c2:	b6 01       	movw	r22, r12
    31c4:	c8 01       	movw	r24, r16
    31c6:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    31ca:	6a e0       	ldi	r22, 0x0A	; 10
    31cc:	c8 01       	movw	r24, r16
    31ce:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    31d2:	8c 01       	movw	r16, r24
    31d4:	67 eb       	ldi	r22, 0xB7	; 183
    31d6:	75 e0       	ldi	r23, 0x05	; 5
    31d8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    31dc:	66 e0       	ldi	r22, 0x06	; 6
    31de:	c8 01       	movw	r24, r16
    31e0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    31e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    31e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    31e8:	e8 85       	ldd	r30, Y+8	; 0x08
    31ea:	f9 85       	ldd	r31, Y+9	; 0x09
    31ec:	01 e1       	ldi	r16, 0x11	; 17
    31ee:	21 e0       	ldi	r18, 0x01	; 1
    31f0:	a7 01       	movw	r20, r14
    31f2:	bc 01       	movw	r22, r24
    31f4:	8e 1b       	sub	r24, r30
    31f6:	9f 0b       	sbc	r25, r31
    31f8:	0e 94 c2 1b 	call	0x3784	; 0x3784 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    31fc:	8c 81       	ldd	r24, Y+4	; 0x04
    31fe:	9d 81       	ldd	r25, Y+5	; 0x05
    3200:	00 97       	sbiw	r24, 0x00	; 0
    3202:	19 f0       	breq	.+6      	; 0x320a <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3204:	b7 01       	movw	r22, r14
    3206:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    320a:	df 91       	pop	r29
    320c:	cf 91       	pop	r28
    320e:	1f 91       	pop	r17
    3210:	0f 91       	pop	r16
    3212:	ff 90       	pop	r15
    3214:	ef 90       	pop	r14
    3216:	df 90       	pop	r13
    3218:	cf 90       	pop	r12
    321a:	08 95       	ret

0000321c <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    321c:	0f 93       	push	r16
    321e:	1f 93       	push	r17
    3220:	cf 93       	push	r28
    3222:	df 93       	push	r29
    3224:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    3226:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <last_created_task_pointer>
    322a:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    322e:	00 97       	sbiw	r24, 0x00	; 0
    3230:	19 f0       	breq	.+6      	; 0x3238 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3232:	be 01       	movw	r22, r28
    3234:	0e 94 c0 18 	call	0x3180	; 0x3180 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    3238:	6a e0       	ldi	r22, 0x0A	; 10
    323a:	ce 01       	movw	r24, r28
    323c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3240:	8c 01       	movw	r16, r24
    3242:	6a ed       	ldi	r22, 0xDA	; 218
    3244:	75 e0       	ldi	r23, 0x05	; 5
    3246:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    324a:	6a e0       	ldi	r22, 0x0A	; 10
    324c:	c8 01       	movw	r24, r16
    324e:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3252:	8c 01       	movw	r16, r24
    3254:	6f ec       	ldi	r22, 0xCF	; 207
    3256:	75 e0       	ldi	r23, 0x05	; 5
    3258:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    325c:	6a e0       	ldi	r22, 0x0A	; 10
    325e:	c8 01       	movw	r24, r16
    3260:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3264:	8c 01       	movw	r16, r24
    3266:	69 ec       	ldi	r22, 0xC9	; 201
    3268:	75 e0       	ldi	r23, 0x05	; 5
    326a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    326e:	66 e0       	ldi	r22, 0x06	; 6
    3270:	c8 01       	movw	r24, r16
    3272:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    3276:	80 91 92 32 	lds	r24, 0x3292	; 0x803292 <portStackTopForTask>
    327a:	90 91 93 32 	lds	r25, 0x3293	; 0x803293 <portStackTopForTask+0x1>
    327e:	bc 01       	movw	r22, r24
    3280:	6f 5f       	subi	r22, 0xFF	; 255
    3282:	7f 4f       	sbci	r23, 0xFF	; 255
    3284:	01 e1       	ldi	r16, 0x11	; 17
    3286:	21 e0       	ldi	r18, 0x01	; 1
    3288:	ae 01       	movw	r20, r28
    328a:	83 56       	subi	r24, 0x63	; 99
    328c:	91 09       	sbc	r25, r1
    328e:	0e 94 c2 1b 	call	0x3784	; 0x3784 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3292:	df 91       	pop	r29
    3294:	cf 91       	pop	r28
    3296:	1f 91       	pop	r17
    3298:	0f 91       	pop	r16
    329a:	08 95       	ret

0000329c <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    329c:	8f 92       	push	r8
    329e:	9f 92       	push	r9
    32a0:	af 92       	push	r10
    32a2:	bf 92       	push	r11
    32a4:	cf 92       	push	r12
    32a6:	df 92       	push	r13
    32a8:	ef 92       	push	r14
    32aa:	ff 92       	push	r15
    32ac:	0f 93       	push	r16
    32ae:	1f 93       	push	r17
    32b0:	cf 93       	push	r28
    32b2:	df 93       	push	r29
    32b4:	ec 01       	movw	r28, r24
    32b6:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    32b8:	8a 81       	ldd	r24, Y+2	; 0x02
    32ba:	9b 81       	ldd	r25, Y+3	; 0x03
    32bc:	0e 94 39 14 	call	0x2872	; 0x2872 <pcTaskGetTaskName>
    32c0:	bc 01       	movw	r22, r24
    32c2:	c8 01       	movw	r24, r16
    32c4:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    32c8:	d8 01       	movw	r26, r16
    32ca:	ed 91       	ld	r30, X+
    32cc:	fc 91       	ld	r31, X
    32ce:	02 80       	ldd	r0, Z+2	; 0x02
    32d0:	f3 81       	ldd	r31, Z+3	; 0x03
    32d2:	e0 2d       	mov	r30, r0
    32d4:	69 e0       	ldi	r22, 0x09	; 9
    32d6:	c8 01       	movw	r24, r16
    32d8:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    32da:	8a 81       	ldd	r24, Y+2	; 0x02
    32dc:	9b 81       	ldd	r25, Y+3	; 0x03
    32de:	0e 94 39 14 	call	0x2872	; 0x2872 <pcTaskGetTaskName>
    32e2:	fc 01       	movw	r30, r24
    32e4:	01 90       	ld	r0, Z+
    32e6:	00 20       	and	r0, r0
    32e8:	e9 f7       	brne	.-6      	; 0x32e4 <_ZN8frt_task12print_statusER8emstream+0x48>
    32ea:	31 97       	sbiw	r30, 0x01	; 1
    32ec:	e8 1b       	sub	r30, r24
    32ee:	f9 0b       	sbc	r31, r25
    32f0:	38 97       	sbiw	r30, 0x08	; 8
    32f2:	48 f4       	brcc	.+18     	; 0x3306 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    32f4:	d8 01       	movw	r26, r16
    32f6:	ed 91       	ld	r30, X+
    32f8:	fc 91       	ld	r31, X
    32fa:	02 80       	ldd	r0, Z+2	; 0x02
    32fc:	f3 81       	ldd	r31, Z+3	; 0x03
    32fe:	e0 2d       	mov	r30, r0
    3300:	69 e0       	ldi	r22, 0x09	; 9
    3302:	c8 01       	movw	r24, r16
    3304:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    3306:	ce 84       	ldd	r12, Y+14	; 0x0e
    3308:	df 84       	ldd	r13, Y+15	; 0x0f
    330a:	e8 88       	ldd	r14, Y+16	; 0x10
    330c:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    330e:	a8 84       	ldd	r10, Y+8	; 0x08
    3310:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3312:	8a 81       	ldd	r24, Y+2	; 0x02
    3314:	9b 81       	ldd	r25, Y+3	; 0x03
    3316:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <uxTaskGetStackHighWaterMark>
    331a:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    331c:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    331e:	8a 81       	ldd	r24, Y+2	; 0x02
    3320:	9b 81       	ldd	r25, Y+3	; 0x03
    3322:	0e 94 e4 13 	call	0x27c8	; 0x27c8 <uxTaskPriorityGet>
    3326:	68 2f       	mov	r22, r24
    3328:	c8 01       	movw	r24, r16
    332a:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    332e:	6a e0       	ldi	r22, 0x0A	; 10
    3330:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3334:	ec 01       	movw	r28, r24
    3336:	6f e4       	ldi	r22, 0x4F	; 79
    3338:	76 e0       	ldi	r23, 0x06	; 6
    333a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
			<< get_state ()
    333e:	68 2d       	mov	r22, r8
    3340:	ce 01       	movw	r24, r28
    3342:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3346:	6a e0       	ldi	r22, 0x0A	; 10
    3348:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    334c:	ec 01       	movw	r28, r24
    334e:	6d e4       	ldi	r22, 0x4D	; 77
    3350:	76 e0       	ldi	r23, 0x06	; 6
    3352:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3356:	69 2d       	mov	r22, r9
    3358:	ce 01       	movw	r24, r28
    335a:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    335e:	6a e0       	ldi	r22, 0x0A	; 10
    3360:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3364:	ec 01       	movw	r28, r24
    3366:	6b e4       	ldi	r22, 0x4B	; 75
    3368:	76 e0       	ldi	r23, 0x06	; 6
    336a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    336e:	b5 01       	movw	r22, r10
    3370:	ce 01       	movw	r24, r28
    3372:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    3376:	6a e0       	ldi	r22, 0x0A	; 10
    3378:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    337c:	ec 01       	movw	r28, r24
    337e:	69 e4       	ldi	r22, 0x49	; 73
    3380:	76 e0       	ldi	r23, 0x06	; 6
    3382:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    3386:	6a e0       	ldi	r22, 0x0A	; 10
    3388:	ce 01       	movw	r24, r28
    338a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    338e:	ec 01       	movw	r28, r24
    3390:	67 e4       	ldi	r22, 0x47	; 71
    3392:	76 e0       	ldi	r23, 0x06	; 6
    3394:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3398:	b7 01       	movw	r22, r14
    339a:	a6 01       	movw	r20, r12
    339c:	ce 01       	movw	r24, r28
    339e:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <_ZN8emstreamlsEm>
}
    33a2:	df 91       	pop	r29
    33a4:	cf 91       	pop	r28
    33a6:	1f 91       	pop	r17
    33a8:	0f 91       	pop	r16
    33aa:	ff 90       	pop	r15
    33ac:	ef 90       	pop	r14
    33ae:	df 90       	pop	r13
    33b0:	cf 90       	pop	r12
    33b2:	bf 90       	pop	r11
    33b4:	af 90       	pop	r10
    33b6:	9f 90       	pop	r9
    33b8:	8f 90       	pop	r8
    33ba:	08 95       	ret

000033bc <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    33bc:	cf 93       	push	r28
    33be:	df 93       	push	r29
    33c0:	ec 01       	movw	r28, r24
    33c2:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    33c4:	db 01       	movw	r26, r22
    33c6:	ed 91       	ld	r30, X+
    33c8:	fc 91       	ld	r31, X
    33ca:	02 80       	ldd	r0, Z+2	; 0x02
    33cc:	f3 81       	ldd	r31, Z+3	; 0x03
    33ce:	e0 2d       	mov	r30, r0
    33d0:	be 01       	movw	r22, r28
    33d2:	19 95       	eicall
	return (ser_dev);
}
    33d4:	ce 01       	movw	r24, r28
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
    33da:	08 95       	ret

000033dc <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    33dc:	0f 93       	push	r16
    33de:	1f 93       	push	r17
    33e0:	cf 93       	push	r28
    33e2:	df 93       	push	r29
    33e4:	ec 01       	movw	r28, r24
    33e6:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    33e8:	bc 01       	movw	r22, r24
    33ea:	c8 01       	movw	r24, r16
    33ec:	0e 94 de 19 	call	0x33bc	; 0x33bc <_ZlsR8emstreamR8frt_task>
    33f0:	66 e0       	ldi	r22, 0x06	; 6
    33f2:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    33f6:	8c 81       	ldd	r24, Y+4	; 0x04
    33f8:	9d 81       	ldd	r25, Y+5	; 0x05
    33fa:	00 97       	sbiw	r24, 0x00	; 0
    33fc:	19 f0       	breq	.+6      	; 0x3404 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    33fe:	b8 01       	movw	r22, r16
    3400:	0e 94 ee 19 	call	0x33dc	; 0x33dc <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3404:	df 91       	pop	r29
    3406:	cf 91       	pop	r28
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	08 95       	ret

0000340e <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    340e:	0f 93       	push	r16
    3410:	1f 93       	push	r17
    3412:	cf 93       	push	r28
    3414:	df 93       	push	r29
    3416:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    3418:	6a e0       	ldi	r22, 0x0A	; 10
    341a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    341e:	8c 01       	movw	r16, r24
    3420:	6c e3       	ldi	r22, 0x3C	; 60
    3422:	76 e0       	ldi	r23, 0x06	; 6
    3424:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3428:	6a e0       	ldi	r22, 0x0A	; 10
    342a:	c8 01       	movw	r24, r16
    342c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3430:	8c 01       	movw	r16, r24
    3432:	65 e3       	ldi	r22, 0x35	; 53
    3434:	76 e0       	ldi	r23, 0x06	; 6
    3436:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    343a:	66 e0       	ldi	r22, 0x06	; 6
    343c:	c8 01       	movw	r24, r16
    343e:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3442:	6a e0       	ldi	r22, 0x0A	; 10
    3444:	ce 01       	movw	r24, r28
    3446:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    344a:	8c 01       	movw	r16, r24
    344c:	64 e2       	ldi	r22, 0x24	; 36
    344e:	76 e0       	ldi	r23, 0x06	; 6
    3450:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3454:	6a e0       	ldi	r22, 0x0A	; 10
    3456:	c8 01       	movw	r24, r16
    3458:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    345c:	8c 01       	movw	r16, r24
    345e:	68 e1       	ldi	r22, 0x18	; 24
    3460:	76 e0       	ldi	r23, 0x06	; 6
    3462:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    3466:	6a e0       	ldi	r22, 0x0A	; 10
    3468:	c8 01       	movw	r24, r16
    346a:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    346e:	8c 01       	movw	r16, r24
    3470:	62 e1       	ldi	r22, 0x12	; 18
    3472:	76 e0       	ldi	r23, 0x06	; 6
    3474:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3478:	66 e0       	ldi	r22, 0x06	; 6
    347a:	c8 01       	movw	r24, r16
    347c:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3480:	6a e0       	ldi	r22, 0x0A	; 10
    3482:	ce 01       	movw	r24, r28
    3484:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3488:	8c 01       	movw	r16, r24
    348a:	61 e0       	ldi	r22, 0x01	; 1
    348c:	76 e0       	ldi	r23, 0x06	; 6
    348e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3492:	6a e0       	ldi	r22, 0x0A	; 10
    3494:	c8 01       	movw	r24, r16
    3496:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    349a:	8c 01       	movw	r16, r24
    349c:	65 ef       	ldi	r22, 0xF5	; 245
    349e:	75 e0       	ldi	r23, 0x05	; 5
    34a0:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    34a4:	6a e0       	ldi	r22, 0x0A	; 10
    34a6:	c8 01       	movw	r24, r16
    34a8:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    34ac:	8c 01       	movw	r16, r24
    34ae:	6f ee       	ldi	r22, 0xEF	; 239
    34b0:	75 e0       	ldi	r23, 0x05	; 5
    34b2:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    34b6:	66 e0       	ldi	r22, 0x06	; 6
    34b8:	c8 01       	movw	r24, r16
    34ba:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    34be:	80 91 30 32 	lds	r24, 0x3230	; 0x803230 <last_created_task_pointer>
    34c2:	90 91 31 32 	lds	r25, 0x3231	; 0x803231 <last_created_task_pointer+0x1>
    34c6:	00 97       	sbiw	r24, 0x00	; 0
    34c8:	19 f0       	breq	.+6      	; 0x34d0 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    34ca:	be 01       	movw	r22, r28
    34cc:	0e 94 ee 19 	call	0x33dc	; 0x33dc <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    34d0:	0e 94 41 14 	call	0x2882	; 0x2882 <xTaskGetIdleTaskHandle>
    34d4:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <uxTaskGetStackHighWaterMark>
    34d8:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    34da:	6a e0       	ldi	r22, 0x0A	; 10
    34dc:	ce 01       	movw	r24, r28
    34de:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    34e2:	ec 01       	movw	r28, r24
    34e4:	64 ee       	ldi	r22, 0xE4	; 228
    34e6:	75 e0       	ldi	r23, 0x05	; 5
    34e8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    34ec:	61 2f       	mov	r22, r17
    34ee:	ce 01       	movw	r24, r28
    34f0:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    34f4:	6a e0       	ldi	r22, 0x0A	; 10
    34f6:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    34fa:	ec 01       	movw	r28, r24
    34fc:	62 ee       	ldi	r22, 0xE2	; 226
    34fe:	75 e0       	ldi	r23, 0x05	; 5
    3500:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    3504:	64 e6       	ldi	r22, 0x64	; 100
    3506:	70 e0       	ldi	r23, 0x00	; 0
    3508:	ce 01       	movw	r24, r28
    350a:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    350e:	6a e0       	ldi	r22, 0x0A	; 10
    3510:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3514:	ec 01       	movw	r28, r24
    3516:	6f ed       	ldi	r22, 0xDF	; 223
    3518:	75 e0       	ldi	r23, 0x05	; 5
    351a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    351e:	66 e0       	ldi	r22, 0x06	; 6
    3520:	ce 01       	movw	r24, r28
    3522:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
}
    3526:	df 91       	pop	r29
    3528:	cf 91       	pop	r28
    352a:	1f 91       	pop	r17
    352c:	0f 91       	pop	r16
    352e:	08 95       	ret

00003530 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3530:	0f 93       	push	r16
    3532:	cf 93       	push	r28
    3534:	df 93       	push	r29
    3536:	1f 92       	push	r1
    3538:	cd b7       	in	r28, 0x3d	; 61
    353a:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    353c:	00 e0       	ldi	r16, 0x00	; 0
    353e:	2f ef       	ldi	r18, 0xFF	; 255
    3540:	3f ef       	ldi	r19, 0xFF	; 255
    3542:	a9 01       	movw	r20, r18
    3544:	be 01       	movw	r22, r28
    3546:	6f 5f       	subi	r22, 0xFF	; 255
    3548:	7f 4f       	sbci	r23, 0xFF	; 255
    354a:	fc 01       	movw	r30, r24
    354c:	80 85       	ldd	r24, Z+8	; 0x08
    354e:	91 85       	ldd	r25, Z+9	; 0x09
    3550:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
    3554:	81 30       	cpi	r24, 0x01	; 1
    3556:	19 f4       	brne	.+6      	; 0x355e <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3558:	89 81       	ldd	r24, Y+1	; 0x01
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	02 c0       	rjmp	.+4      	; 0x3562 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    355e:	8f ef       	ldi	r24, 0xFF	; 255
    3560:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3562:	0f 90       	pop	r0
    3564:	df 91       	pop	r29
    3566:	cf 91       	pop	r28
    3568:	0f 91       	pop	r16
    356a:	08 95       	ret

0000356c <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    356c:	fc 01       	movw	r30, r24
    356e:	80 85       	ldd	r24, Z+8	; 0x08
    3570:	91 85       	ldd	r25, Z+9	; 0x09
    3572:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    3576:	91 e0       	ldi	r25, 0x01	; 1
    3578:	81 11       	cpse	r24, r1
    357a:	01 c0       	rjmp	.+2      	; 0x357e <_ZN14frt_text_queue14check_for_charEv+0x12>
    357c:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    357e:	89 2f       	mov	r24, r25
    3580:	08 95       	ret

00003582 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3582:	0f 93       	push	r16
    3584:	cf 93       	push	r28
    3586:	df 93       	push	r29
    3588:	1f 92       	push	r1
    358a:	cd b7       	in	r28, 0x3d	; 61
    358c:	de b7       	in	r29, 0x3e	; 62
    358e:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3590:	fc 01       	movw	r30, r24
    3592:	22 85       	ldd	r18, Z+10	; 0x0a
    3594:	33 85       	ldd	r19, Z+11	; 0x0b
    3596:	44 85       	ldd	r20, Z+12	; 0x0c
    3598:	55 85       	ldd	r21, Z+13	; 0x0d
    359a:	00 e0       	ldi	r16, 0x00	; 0
    359c:	be 01       	movw	r22, r28
    359e:	6f 5f       	subi	r22, 0xFF	; 255
    35a0:	7f 4f       	sbci	r23, 0xFF	; 255
    35a2:	80 85       	ldd	r24, Z+8	; 0x08
    35a4:	91 85       	ldd	r25, Z+9	; 0x09
    35a6:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    35aa:	91 e0       	ldi	r25, 0x01	; 1
    35ac:	81 11       	cpse	r24, r1
    35ae:	01 c0       	rjmp	.+2      	; 0x35b2 <_ZN14frt_text_queue7putcharEc+0x30>
    35b0:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    35b2:	89 2f       	mov	r24, r25
    35b4:	0f 90       	pop	r0
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	0f 91       	pop	r16
    35bc:	08 95       	ret

000035be <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    35be:	8f 92       	push	r8
    35c0:	9f 92       	push	r9
    35c2:	bf 92       	push	r11
    35c4:	cf 92       	push	r12
    35c6:	df 92       	push	r13
    35c8:	ef 92       	push	r14
    35ca:	ff 92       	push	r15
    35cc:	0f 93       	push	r16
    35ce:	1f 93       	push	r17
    35d0:	cf 93       	push	r28
    35d2:	df 93       	push	r29
    35d4:	ec 01       	movw	r28, r24
    35d6:	b6 2e       	mov	r11, r22
    35d8:	4a 01       	movw	r8, r20
    35da:	68 01       	movw	r12, r16
    35dc:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    35de:	0e 94 19 1d 	call	0x3a32	; 0x3a32 <_ZN8emstreamC1Ev>
    35e2:	84 e2       	ldi	r24, 0x24	; 36
    35e4:	91 e2       	ldi	r25, 0x21	; 33
    35e6:	88 83       	st	Y, r24
    35e8:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    35ea:	8e 86       	std	Y+14, r8	; 0x0e
    35ec:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    35ee:	40 e0       	ldi	r20, 0x00	; 0
    35f0:	61 e0       	ldi	r22, 0x01	; 1
    35f2:	8b 2d       	mov	r24, r11
    35f4:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    35f8:	88 87       	std	Y+8, r24	; 0x08
    35fa:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    35fc:	ca 86       	std	Y+10, r12	; 0x0a
    35fe:	db 86       	std	Y+11, r13	; 0x0b
    3600:	ec 86       	std	Y+12, r14	; 0x0c
    3602:	fd 86       	std	Y+13, r15	; 0x0d
}
    3604:	df 91       	pop	r29
    3606:	cf 91       	pop	r28
    3608:	1f 91       	pop	r17
    360a:	0f 91       	pop	r16
    360c:	ff 90       	pop	r15
    360e:	ef 90       	pop	r14
    3610:	df 90       	pop	r13
    3612:	cf 90       	pop	r12
    3614:	bf 90       	pop	r11
    3616:	9f 90       	pop	r9
    3618:	8f 90       	pop	r8
    361a:	08 95       	ret

0000361c <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    361c:	cf 92       	push	r12
    361e:	df 92       	push	r13
    3620:	ef 92       	push	r14
    3622:	ff 92       	push	r15
    3624:	cf 93       	push	r28
    3626:	df 93       	push	r29
    3628:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    362a:	68 81       	ld	r22, Y
    362c:	79 81       	ldd	r23, Y+1	; 0x01
    362e:	8a 81       	ldd	r24, Y+2	; 0x02
    3630:	9b 81       	ldd	r25, Y+3	; 0x03
    3632:	0f 2e       	mov	r0, r31
    3634:	f8 ee       	ldi	r31, 0xE8	; 232
    3636:	cf 2e       	mov	r12, r31
    3638:	f3 e0       	ldi	r31, 0x03	; 3
    363a:	df 2e       	mov	r13, r31
    363c:	e1 2c       	mov	r14, r1
    363e:	f1 2c       	mov	r15, r1
    3640:	f0 2d       	mov	r31, r0
    3642:	a7 01       	movw	r20, r14
    3644:	96 01       	movw	r18, r12
    3646:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
    364a:	9b 01       	movw	r18, r22
    364c:	ac 01       	movw	r20, r24
    364e:	60 e4       	ldi	r22, 0x40	; 64
    3650:	72 e4       	ldi	r23, 0x42	; 66
    3652:	8f e0       	ldi	r24, 0x0F	; 15
    3654:	90 e0       	ldi	r25, 0x00	; 0
    3656:	0e 94 73 24 	call	0x48e6	; 0x48e6 <__mulsi3>
    365a:	a7 01       	movw	r20, r14
    365c:	96 01       	movw	r18, r12
    365e:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
    3662:	69 01       	movw	r12, r18
    3664:	7a 01       	movw	r14, r20
    3666:	ac 81       	ldd	r26, Y+4	; 0x04
    3668:	bd 81       	ldd	r27, Y+5	; 0x05
    366a:	20 e4       	ldi	r18, 0x40	; 64
    366c:	32 e4       	ldi	r19, 0x42	; 66
    366e:	4f e0       	ldi	r20, 0x0F	; 15
    3670:	50 e0       	ldi	r21, 0x00	; 0
    3672:	0e 94 cd 24 	call	0x499a	; 0x499a <__muluhisi3>
    3676:	20 e0       	ldi	r18, 0x00	; 0
    3678:	38 e4       	ldi	r19, 0x48	; 72
    367a:	48 ee       	ldi	r20, 0xE8	; 232
    367c:	51 e0       	ldi	r21, 0x01	; 1
    367e:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
    3682:	c7 01       	movw	r24, r14
    3684:	b6 01       	movw	r22, r12
    3686:	62 0f       	add	r22, r18
    3688:	73 1f       	adc	r23, r19
    368a:	84 1f       	adc	r24, r20
    368c:	95 1f       	adc	r25, r21
}
    368e:	df 91       	pop	r29
    3690:	cf 91       	pop	r28
    3692:	ff 90       	pop	r15
    3694:	ef 90       	pop	r14
    3696:	df 90       	pop	r13
    3698:	cf 90       	pop	r12
    369a:	08 95       	ret

0000369c <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    369c:	cf 92       	push	r12
    369e:	df 92       	push	r13
    36a0:	ef 92       	push	r14
    36a2:	ff 92       	push	r15
    36a4:	0f 93       	push	r16
    36a6:	1f 93       	push	r17
    36a8:	cf 93       	push	r28
    36aa:	df 93       	push	r29
    36ac:	cd b7       	in	r28, 0x3d	; 61
    36ae:	de b7       	in	r29, 0x3e	; 62
    36b0:	2f 97       	sbiw	r28, 0x0f	; 15
    36b2:	cd bf       	out	0x3d, r28	; 61
    36b4:	de bf       	out	0x3e, r29	; 62
    36b6:	6c 01       	movw	r12, r24
    36b8:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    36ba:	db 01       	movw	r26, r22
    36bc:	6d 91       	ld	r22, X+
    36be:	7d 91       	ld	r23, X+
    36c0:	8d 91       	ld	r24, X+
    36c2:	9c 91       	ld	r25, X
    36c4:	28 ee       	ldi	r18, 0xE8	; 232
    36c6:	33 e0       	ldi	r19, 0x03	; 3
    36c8:	40 e0       	ldi	r20, 0x00	; 0
    36ca:	50 e0       	ldi	r21, 0x00	; 0
    36cc:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
    36d0:	ba 01       	movw	r22, r20
    36d2:	a9 01       	movw	r20, r18
    36d4:	c6 01       	movw	r24, r12
    36d6:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    36da:	d6 01       	movw	r26, r12
    36dc:	ed 91       	ld	r30, X+
    36de:	fc 91       	ld	r31, X
    36e0:	02 80       	ldd	r0, Z+2	; 0x02
    36e2:	f3 81       	ldd	r31, Z+3	; 0x03
    36e4:	e0 2d       	mov	r30, r0
    36e6:	6e e2       	ldi	r22, 0x2E	; 46
    36e8:	c6 01       	movw	r24, r12
    36ea:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    36ec:	c8 01       	movw	r24, r16
    36ee:	0e 94 0e 1b 	call	0x361c	; 0x361c <_ZN10time_stamp12get_microsecEv>
    36f2:	8e 01       	movw	r16, r28
    36f4:	09 5f       	subi	r16, 0xF9	; 249
    36f6:	1f 4f       	sbci	r17, 0xFF	; 255
    36f8:	fe 01       	movw	r30, r28
    36fa:	31 96       	adiw	r30, 0x01	; 1
    36fc:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    36fe:	2a e0       	ldi	r18, 0x0A	; 10
    3700:	30 e0       	ldi	r19, 0x00	; 0
    3702:	40 e0       	ldi	r20, 0x00	; 0
    3704:	50 e0       	ldi	r21, 0x00	; 0
    3706:	0e 94 a5 24 	call	0x494a	; 0x494a <__divmodsi4>
    370a:	e6 2f       	mov	r30, r22
    370c:	28 87       	std	Y+8, r18	; 0x08
    370e:	39 87       	std	Y+9, r19	; 0x09
    3710:	4a 87       	std	Y+10, r20	; 0x0a
    3712:	5b 87       	std	Y+11, r21	; 0x0b
    3714:	68 85       	ldd	r22, Y+8	; 0x08
    3716:	79 85       	ldd	r23, Y+9	; 0x09
    3718:	8a 85       	ldd	r24, Y+10	; 0x0a
    371a:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    371c:	20 e3       	ldi	r18, 0x30	; 48
    371e:	2e 0f       	add	r18, r30
    3720:	d8 01       	movw	r26, r16
    3722:	2e 93       	st	-X, r18
    3724:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3726:	ae 15       	cp	r26, r14
    3728:	bf 05       	cpc	r27, r15
    372a:	49 f7       	brne	.-46     	; 0x36fe <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    372c:	1f 82       	std	Y+7, r1	; 0x07
    372e:	be 01       	movw	r22, r28
    3730:	6f 5f       	subi	r22, 0xFF	; 255
    3732:	7f 4f       	sbci	r23, 0xFF	; 255
    3734:	c6 01       	movw	r24, r12
    3736:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    373a:	c6 01       	movw	r24, r12
    373c:	2f 96       	adiw	r28, 0x0f	; 15
    373e:	cd bf       	out	0x3d, r28	; 61
    3740:	de bf       	out	0x3e, r29	; 62
    3742:	df 91       	pop	r29
    3744:	cf 91       	pop	r28
    3746:	1f 91       	pop	r17
    3748:	0f 91       	pop	r16
    374a:	ff 90       	pop	r15
    374c:	ef 90       	pop	r14
    374e:	df 90       	pop	r13
    3750:	cf 90       	pop	r12
    3752:	08 95       	ret

00003754 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3754:	cf 93       	push	r28
    3756:	df 93       	push	r29
    3758:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    375a:	0f b6       	in	r0, 0x3f	; 63
    375c:	f8 94       	cli
    375e:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3760:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3764:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3768:	8c 83       	std	Y+4, r24	; 0x04
    376a:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    376c:	0e 94 2b 14 	call	0x2856	; 0x2856 <xTaskGetTickCount>
    3770:	68 83       	st	Y, r22
    3772:	79 83       	std	Y+1, r23	; 0x01
    3774:	8a 83       	std	Y+2, r24	; 0x02
    3776:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3778:	0f 90       	pop	r0
    377a:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    377c:	ce 01       	movw	r24, r28
    377e:	df 91       	pop	r29
    3780:	cf 91       	pop	r28
    3782:	08 95       	ret

00003784 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3784:	5f 92       	push	r5
    3786:	6f 92       	push	r6
    3788:	7f 92       	push	r7
    378a:	8f 92       	push	r8
    378c:	9f 92       	push	r9
    378e:	af 92       	push	r10
    3790:	bf 92       	push	r11
    3792:	cf 92       	push	r12
    3794:	df 92       	push	r13
    3796:	ef 92       	push	r14
    3798:	ff 92       	push	r15
    379a:	0f 93       	push	r16
    379c:	1f 93       	push	r17
    379e:	cf 93       	push	r28
    37a0:	df 93       	push	r29
    37a2:	5c 01       	movw	r10, r24
    37a4:	4b 01       	movw	r8, r22
    37a6:	7a 01       	movw	r14, r20
    37a8:	12 2f       	mov	r17, r18
    37aa:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    37ac:	63 e0       	ldi	r22, 0x03	; 3
    37ae:	ca 01       	movw	r24, r20
    37b0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    37b4:	a8 14       	cp	r10, r8
    37b6:	b9 04       	cpc	r11, r9
    37b8:	08 f0       	brcs	.+2      	; 0x37bc <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    37ba:	7d c0       	rjmp	.+250    	; 0x38b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    37bc:	65 01       	movw	r12, r10
    37be:	84 e1       	ldi	r24, 0x14	; 20
    37c0:	c8 0e       	add	r12, r24
    37c2:	d1 1c       	adc	r13, r1
    37c4:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    37c6:	6a 2c       	mov	r6, r10
    37c8:	5b 2c       	mov	r5, r11
    37ca:	b5 01       	movw	r22, r10
    37cc:	c7 01       	movw	r24, r14
    37ce:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <_ZN8emstreamlsEj>
    37d2:	6a e0       	ldi	r22, 0x0A	; 10
    37d4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    37d8:	61 e6       	ldi	r22, 0x61	; 97
    37da:	76 e0       	ldi	r23, 0x06	; 6
    37dc:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    37e0:	11 23       	and	r17, r17
    37e2:	09 f4       	brne	.+2      	; 0x37e6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    37e4:	6d c0       	rjmp	.+218    	; 0x38c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    37e6:	00 23       	and	r16, r16
    37e8:	09 f4       	brne	.+2      	; 0x37ec <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    37ea:	6a c0       	rjmp	.+212    	; 0x38c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    37ec:	6a e0       	ldi	r22, 0x0A	; 10
    37ee:	c7 01       	movw	r24, r14
    37f0:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    37f4:	6c e5       	ldi	r22, 0x5C	; 92
    37f6:	76 e0       	ldi	r23, 0x06	; 6
    37f8:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    37fc:	61 c0       	rjmp	.+194    	; 0x38c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    37fe:	11 23       	and	r17, r17
    3800:	71 f0       	breq	.+28     	; 0x381e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3802:	01 11       	cpse	r16, r1
    3804:	0c c0       	rjmp	.+24     	; 0x381e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3806:	88 81       	ld	r24, Y
    3808:	87 15       	cp	r24, r7
    380a:	49 f0       	breq	.+18     	; 0x381e <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    380c:	6a e0       	ldi	r22, 0x0A	; 10
    380e:	c7 01       	movw	r24, r14
    3810:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3814:	67 e5       	ldi	r22, 0x57	; 87
    3816:	76 e0       	ldi	r23, 0x06	; 6
    3818:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    381c:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    381e:	69 91       	ld	r22, Y+
    3820:	c7 01       	movw	r24, r14
    3822:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3826:	dc 01       	movw	r26, r24
    3828:	ed 91       	ld	r30, X+
    382a:	fc 91       	ld	r31, X
    382c:	02 80       	ldd	r0, Z+2	; 0x02
    382e:	f3 81       	ldd	r31, Z+3	; 0x03
    3830:	e0 2d       	mov	r30, r0
    3832:	60 e2       	ldi	r22, 0x20	; 32
    3834:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3836:	cc 16       	cp	r12, r28
    3838:	dd 06       	cpc	r13, r29
    383a:	09 f7       	brne	.-62     	; 0x37fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    383c:	11 23       	and	r17, r17
    383e:	89 f0       	breq	.+34     	; 0x3862 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3840:	6a e0       	ldi	r22, 0x0A	; 10
    3842:	c7 01       	movw	r24, r14
    3844:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    3848:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    384a:	61 e5       	ldi	r22, 0x51	; 81
    384c:	76 e0       	ldi	r23, 0x06	; 6
    384e:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3852:	e8 81       	ld	r30, Y
    3854:	f9 81       	ldd	r31, Y+1	; 0x01
    3856:	02 80       	ldd	r0, Z+2	; 0x02
    3858:	f3 81       	ldd	r31, Z+3	; 0x03
    385a:	e0 2d       	mov	r30, r0
    385c:	60 e2       	ldi	r22, 0x20	; 32
    385e:	ce 01       	movw	r24, r28
    3860:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3862:	c6 2d       	mov	r28, r6
    3864:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3866:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3868:	80 ee       	ldi	r24, 0xE0	; 224
    386a:	86 0f       	add	r24, r22
    386c:	8f 35       	cpi	r24, 0x5F	; 95
    386e:	48 f4       	brcc	.+18     	; 0x3882 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3870:	d7 01       	movw	r26, r14
    3872:	ed 91       	ld	r30, X+
    3874:	fc 91       	ld	r31, X
    3876:	02 80       	ldd	r0, Z+2	; 0x02
    3878:	f3 81       	ldd	r31, Z+3	; 0x03
    387a:	e0 2d       	mov	r30, r0
    387c:	c7 01       	movw	r24, r14
    387e:	19 95       	eicall
    3880:	09 c0       	rjmp	.+18     	; 0x3894 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3882:	d7 01       	movw	r26, r14
    3884:	ed 91       	ld	r30, X+
    3886:	fc 91       	ld	r31, X
    3888:	02 80       	ldd	r0, Z+2	; 0x02
    388a:	f3 81       	ldd	r31, Z+3	; 0x03
    388c:	e0 2d       	mov	r30, r0
    388e:	6e e2       	ldi	r22, 0x2E	; 46
    3890:	c7 01       	movw	r24, r14
    3892:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3894:	cc 16       	cp	r12, r28
    3896:	dd 06       	cpc	r13, r29
    3898:	31 f7       	brne	.-52     	; 0x3866 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    389a:	b4 e1       	ldi	r27, 0x14	; 20
    389c:	ab 0e       	add	r10, r27
    389e:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    38a0:	66 e0       	ldi	r22, 0x06	; 6
    38a2:	c7 01       	movw	r24, r14
    38a4:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    38a8:	84 e1       	ldi	r24, 0x14	; 20
    38aa:	c8 0e       	add	r12, r24
    38ac:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    38ae:	a8 14       	cp	r10, r8
    38b0:	b9 04       	cpc	r11, r9
    38b2:	08 f4       	brcc	.+2      	; 0x38b6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    38b4:	88 cf       	rjmp	.-240    	; 0x37c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    38b6:	62 e0       	ldi	r22, 0x02	; 2
    38b8:	c7 01       	movw	r24, r14
    38ba:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
}
    38be:	03 c0       	rjmp	.+6      	; 0x38c6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    38c0:	c6 2d       	mov	r28, r6
    38c2:	d5 2d       	mov	r29, r5
    38c4:	9c cf       	rjmp	.-200    	; 0x37fe <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    38c6:	df 91       	pop	r29
    38c8:	cf 91       	pop	r28
    38ca:	1f 91       	pop	r17
    38cc:	0f 91       	pop	r16
    38ce:	ff 90       	pop	r15
    38d0:	ef 90       	pop	r14
    38d2:	df 90       	pop	r13
    38d4:	cf 90       	pop	r12
    38d6:	bf 90       	pop	r11
    38d8:	af 90       	pop	r10
    38da:	9f 90       	pop	r9
    38dc:	8f 90       	pop	r8
    38de:	7f 90       	pop	r7
    38e0:	6f 90       	pop	r6
    38e2:	5f 90       	pop	r5
    38e4:	08 95       	ret

000038e6 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    38e6:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    38ea:	08 95       	ret

000038ec <_Znaj>:
    38ec:	0e 94 b5 0c 	call	0x196a	; 0x196a <pvPortMalloc>
    38f0:	08 95       	ret

000038f2 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    38f2:	08 95       	ret

000038f4 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    38f4:	cf 93       	push	r28
    38f6:	df 93       	push	r29
    38f8:	fc 01       	movw	r30, r24
    38fa:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    38fc:	40 3a       	cpi	r20, 0xA0	; 160
    38fe:	68 e0       	ldi	r22, 0x08	; 8
    3900:	56 07       	cpc	r21, r22
    3902:	49 f4       	brne	.+18     	; 0x3916 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3904:	80 e4       	ldi	r24, 0x40	; 64
    3906:	96 e0       	ldi	r25, 0x06	; 6
    3908:	82 83       	std	Z+2, r24	; 0x02
    390a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    390c:	82 e0       	ldi	r24, 0x02	; 2
    390e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3910:	83 e0       	ldi	r24, 0x03	; 3
    3912:	85 83       	std	Z+5, r24	; 0x05
    3914:	32 c0       	rjmp	.+100    	; 0x397a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3916:	40 3b       	cpi	r20, 0xB0	; 176
    3918:	78 e0       	ldi	r23, 0x08	; 8
    391a:	57 07       	cpc	r21, r23
    391c:	49 f4       	brne	.+18     	; 0x3930 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    391e:	80 e4       	ldi	r24, 0x40	; 64
    3920:	96 e0       	ldi	r25, 0x06	; 6
    3922:	82 83       	std	Z+2, r24	; 0x02
    3924:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3926:	86 e0       	ldi	r24, 0x06	; 6
    3928:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    392a:	87 e0       	ldi	r24, 0x07	; 7
    392c:	85 83       	std	Z+5, r24	; 0x05
    392e:	25 c0       	rjmp	.+74     	; 0x397a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3930:	40 3a       	cpi	r20, 0xA0	; 160
    3932:	89 e0       	ldi	r24, 0x09	; 9
    3934:	58 07       	cpc	r21, r24
    3936:	49 f4       	brne	.+18     	; 0x394a <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3938:	80 e6       	ldi	r24, 0x60	; 96
    393a:	96 e0       	ldi	r25, 0x06	; 6
    393c:	82 83       	std	Z+2, r24	; 0x02
    393e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3940:	82 e0       	ldi	r24, 0x02	; 2
    3942:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3944:	83 e0       	ldi	r24, 0x03	; 3
    3946:	85 83       	std	Z+5, r24	; 0x05
    3948:	18 c0       	rjmp	.+48     	; 0x397a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    394a:	40 3b       	cpi	r20, 0xB0	; 176
    394c:	69 e0       	ldi	r22, 0x09	; 9
    394e:	56 07       	cpc	r21, r22
    3950:	49 f4       	brne	.+18     	; 0x3964 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3952:	80 e6       	ldi	r24, 0x60	; 96
    3954:	96 e0       	ldi	r25, 0x06	; 6
    3956:	82 83       	std	Z+2, r24	; 0x02
    3958:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    395a:	86 e0       	ldi	r24, 0x06	; 6
    395c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    395e:	87 e0       	ldi	r24, 0x07	; 7
    3960:	85 83       	std	Z+5, r24	; 0x05
    3962:	0b c0       	rjmp	.+22     	; 0x397a <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3964:	40 3a       	cpi	r20, 0xA0	; 160
    3966:	5a 40       	sbci	r21, 0x0A	; 10
    3968:	41 f4       	brne	.+16     	; 0x397a <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    396a:	80 e8       	ldi	r24, 0x80	; 128
    396c:	96 e0       	ldi	r25, 0x06	; 6
    396e:	82 83       	std	Z+2, r24	; 0x02
    3970:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3972:	82 e0       	ldi	r24, 0x02	; 2
    3974:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3976:	83 e0       	ldi	r24, 0x03	; 3
    3978:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    397a:	a6 83       	std	Z+6, r26	; 0x06
    397c:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    397e:	cd 01       	movw	r24, r26
    3980:	01 96       	adiw	r24, 0x01	; 1
    3982:	80 87       	std	Z+8, r24	; 0x08
    3984:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3986:	03 96       	adiw	r24, 0x03	; 3
    3988:	82 87       	std	Z+10, r24	; 0x0a
    398a:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    398c:	25 81       	ldd	r18, Z+5	; 0x05
    398e:	c2 81       	ldd	r28, Z+2	; 0x02
    3990:	d3 81       	ldd	r29, Z+3	; 0x03
    3992:	4c 81       	ldd	r20, Y+4	; 0x04
    3994:	81 e0       	ldi	r24, 0x01	; 1
    3996:	90 e0       	ldi	r25, 0x00	; 0
    3998:	bc 01       	movw	r22, r24
    399a:	02 c0       	rjmp	.+4      	; 0x39a0 <_ZN7base232C1EjP12USART_struct+0xac>
    399c:	66 0f       	add	r22, r22
    399e:	77 1f       	adc	r23, r23
    39a0:	2a 95       	dec	r18
    39a2:	e2 f7       	brpl	.-8      	; 0x399c <_ZN7base232C1EjP12USART_struct+0xa8>
    39a4:	9b 01       	movw	r18, r22
    39a6:	24 2b       	or	r18, r20
    39a8:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    39aa:	25 81       	ldd	r18, Z+5	; 0x05
    39ac:	c2 81       	ldd	r28, Z+2	; 0x02
    39ae:	d3 81       	ldd	r29, Z+3	; 0x03
    39b0:	48 81       	ld	r20, Y
    39b2:	bc 01       	movw	r22, r24
    39b4:	02 c0       	rjmp	.+4      	; 0x39ba <_ZN7base232C1EjP12USART_struct+0xc6>
    39b6:	66 0f       	add	r22, r22
    39b8:	77 1f       	adc	r23, r23
    39ba:	2a 95       	dec	r18
    39bc:	e2 f7       	brpl	.-8      	; 0x39b6 <_ZN7base232C1EjP12USART_struct+0xc2>
    39be:	9b 01       	movw	r18, r22
    39c0:	24 2b       	or	r18, r20
    39c2:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    39c4:	34 81       	ldd	r19, Z+4	; 0x04
    39c6:	c2 81       	ldd	r28, Z+2	; 0x02
    39c8:	d3 81       	ldd	r29, Z+3	; 0x03
    39ca:	28 81       	ld	r18, Y
    39cc:	02 c0       	rjmp	.+4      	; 0x39d2 <_ZN7base232C1EjP12USART_struct+0xde>
    39ce:	88 0f       	add	r24, r24
    39d0:	99 1f       	adc	r25, r25
    39d2:	3a 95       	dec	r19
    39d4:	e2 f7       	brpl	.-8      	; 0x39ce <_ZN7base232C1EjP12USART_struct+0xda>
    39d6:	80 95       	com	r24
    39d8:	90 95       	com	r25
    39da:	82 23       	and	r24, r18
    39dc:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    39de:	80 e1       	ldi	r24, 0x10	; 16
    39e0:	13 96       	adiw	r26, 0x03	; 3
    39e2:	8c 93       	st	X, r24
    39e4:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    39e6:	83 e0       	ldi	r24, 0x03	; 3
    39e8:	15 96       	adiw	r26, 0x05	; 5
    39ea:	8c 93       	st	X, r24
    39ec:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    39ee:	80 ef       	ldi	r24, 0xF0	; 240
    39f0:	17 96       	adiw	r26, 0x07	; 7
    39f2:	8c 93       	st	X, r24
    39f4:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    39f6:	81 e2       	ldi	r24, 0x21	; 33
    39f8:	16 96       	adiw	r26, 0x06	; 6
    39fa:	8c 93       	st	X, r24
    39fc:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    39fe:	88 e1       	ldi	r24, 0x18	; 24
    3a00:	14 96       	adiw	r26, 0x04	; 4
    3a02:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3a04:	80 e8       	ldi	r24, 0x80	; 128
    3a06:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3a08:	80 e4       	ldi	r24, 0x40	; 64
    3a0a:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3a0c:	80 e2       	ldi	r24, 0x20	; 32
    3a0e:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3a10:	06 80       	ldd	r0, Z+6	; 0x06
    3a12:	f7 81       	ldd	r31, Z+7	; 0x07
    3a14:	e0 2d       	mov	r30, r0
    3a16:	80 81       	ld	r24, Z
    3a18:	80 81       	ld	r24, Z
}
    3a1a:	df 91       	pop	r29
    3a1c:	cf 91       	pop	r28
    3a1e:	08 95       	ret

00003a20 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3a20:	81 e0       	ldi	r24, 0x01	; 1
    3a22:	08 95       	ret

00003a24 <_ZN8emstream7getcharEv>:
    3a24:	80 e0       	ldi	r24, 0x00	; 0
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	08 95       	ret

00003a2a <_ZN8emstream14check_for_charEv>:
    3a2a:	80 e0       	ldi	r24, 0x00	; 0
    3a2c:	08 95       	ret

00003a2e <_ZN8emstream12transmit_nowEv>:
    3a2e:	08 95       	ret

00003a30 <_ZN8emstream12clear_screenEv>:
    3a30:	08 95       	ret

00003a32 <_ZN8emstreamC1Ev>:
    3a32:	fc 01       	movw	r30, r24
    3a34:	84 e3       	ldi	r24, 0x34	; 52
    3a36:	91 e2       	ldi	r25, 0x21	; 33
    3a38:	80 83       	st	Z, r24
    3a3a:	91 83       	std	Z+1, r25	; 0x01
    3a3c:	8a e0       	ldi	r24, 0x0A	; 10
    3a3e:	82 83       	std	Z+2, r24	; 0x02
    3a40:	13 82       	std	Z+3, r1	; 0x03
    3a42:	83 e0       	ldi	r24, 0x03	; 3
    3a44:	85 83       	std	Z+5, r24	; 0x05
    3a46:	14 82       	std	Z+4, r1	; 0x04
    3a48:	16 82       	std	Z+6, r1	; 0x06
    3a4a:	17 82       	std	Z+7, r1	; 0x07
    3a4c:	08 95       	ret

00003a4e <_ZN8emstream4putsEPKc>:
    3a4e:	0f 93       	push	r16
    3a50:	1f 93       	push	r17
    3a52:	cf 93       	push	r28
    3a54:	df 93       	push	r29
    3a56:	8c 01       	movw	r16, r24
    3a58:	fb 01       	movw	r30, r22
    3a5a:	dc 01       	movw	r26, r24
    3a5c:	14 96       	adiw	r26, 0x04	; 4
    3a5e:	8c 91       	ld	r24, X
    3a60:	81 11       	cpse	r24, r1
    3a62:	04 c0       	rjmp	.+8      	; 0x3a6c <_ZN8emstream4putsEPKc+0x1e>
    3a64:	60 81       	ld	r22, Z
    3a66:	61 11       	cpse	r22, r1
    3a68:	17 c0       	rjmp	.+46     	; 0x3a98 <_ZN8emstream4putsEPKc+0x4a>
    3a6a:	23 c0       	rjmp	.+70     	; 0x3ab2 <_ZN8emstream4putsEPKc+0x64>
    3a6c:	d8 01       	movw	r26, r16
    3a6e:	14 96       	adiw	r26, 0x04	; 4
    3a70:	1c 92       	st	X, r1
    3a72:	eb 01       	movw	r28, r22
    3a74:	21 96       	adiw	r28, 0x01	; 1
    3a76:	64 91       	lpm	r22, Z
    3a78:	66 23       	and	r22, r22
    3a7a:	d9 f0       	breq	.+54     	; 0x3ab2 <_ZN8emstream4putsEPKc+0x64>
    3a7c:	d8 01       	movw	r26, r16
    3a7e:	ed 91       	ld	r30, X+
    3a80:	fc 91       	ld	r31, X
    3a82:	02 80       	ldd	r0, Z+2	; 0x02
    3a84:	f3 81       	ldd	r31, Z+3	; 0x03
    3a86:	e0 2d       	mov	r30, r0
    3a88:	c8 01       	movw	r24, r16
    3a8a:	19 95       	eicall
    3a8c:	fe 01       	movw	r30, r28
    3a8e:	64 91       	lpm	r22, Z
    3a90:	21 96       	adiw	r28, 0x01	; 1
    3a92:	61 11       	cpse	r22, r1
    3a94:	f3 cf       	rjmp	.-26     	; 0x3a7c <_ZN8emstream4putsEPKc+0x2e>
    3a96:	0d c0       	rjmp	.+26     	; 0x3ab2 <_ZN8emstream4putsEPKc+0x64>
    3a98:	ef 01       	movw	r28, r30
    3a9a:	21 96       	adiw	r28, 0x01	; 1
    3a9c:	d8 01       	movw	r26, r16
    3a9e:	ed 91       	ld	r30, X+
    3aa0:	fc 91       	ld	r31, X
    3aa2:	02 80       	ldd	r0, Z+2	; 0x02
    3aa4:	f3 81       	ldd	r31, Z+3	; 0x03
    3aa6:	e0 2d       	mov	r30, r0
    3aa8:	c8 01       	movw	r24, r16
    3aaa:	19 95       	eicall
    3aac:	69 91       	ld	r22, Y+
    3aae:	61 11       	cpse	r22, r1
    3ab0:	f5 cf       	rjmp	.-22     	; 0x3a9c <_ZN8emstream4putsEPKc+0x4e>
    3ab2:	df 91       	pop	r29
    3ab4:	cf 91       	pop	r28
    3ab6:	1f 91       	pop	r17
    3ab8:	0f 91       	pop	r16
    3aba:	08 95       	ret

00003abc <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3abc:	cf 93       	push	r28
    3abe:	df 93       	push	r29
    3ac0:	ec 01       	movw	r28, r24
	switch (new_manip)
    3ac2:	86 2f       	mov	r24, r22
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
    3ac6:	8b 30       	cpi	r24, 0x0B	; 11
    3ac8:	91 05       	cpc	r25, r1
    3aca:	d8 f5       	brcc	.+118    	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3acc:	fc 01       	movw	r30, r24
    3ace:	88 27       	eor	r24, r24
    3ad0:	e2 50       	subi	r30, 0x02	; 2
    3ad2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ad4:	8f 4f       	sbci	r24, 0xFF	; 255
    3ad6:	0c 94 c4 24 	jmp	0x4988	; 0x4988 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3ada:	82 e0       	ldi	r24, 0x02	; 2
    3adc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ade:	31 c0       	rjmp	.+98     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3ae0:	88 e0       	ldi	r24, 0x08	; 8
    3ae2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3ae4:	2e c0       	rjmp	.+92     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3ae6:	8a e0       	ldi	r24, 0x0A	; 10
    3ae8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3aea:	2b c0       	rjmp	.+86     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3aec:	80 e1       	ldi	r24, 0x10	; 16
    3aee:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3af0:	28 c0       	rjmp	.+80     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3af2:	81 e0       	ldi	r24, 0x01	; 1
    3af4:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3af6:	25 c0       	rjmp	.+74     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3af8:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3afa:	23 c0       	rjmp	.+70     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3afc:	e8 81       	ld	r30, Y
    3afe:	f9 81       	ldd	r31, Y+1	; 0x01
    3b00:	02 80       	ldd	r0, Z+2	; 0x02
    3b02:	f3 81       	ldd	r31, Z+3	; 0x03
    3b04:	e0 2d       	mov	r30, r0
    3b06:	6d e0       	ldi	r22, 0x0D	; 13
    3b08:	ce 01       	movw	r24, r28
    3b0a:	19 95       	eicall
    3b0c:	e8 81       	ld	r30, Y
    3b0e:	f9 81       	ldd	r31, Y+1	; 0x01
    3b10:	02 80       	ldd	r0, Z+2	; 0x02
    3b12:	f3 81       	ldd	r31, Z+3	; 0x03
    3b14:	e0 2d       	mov	r30, r0
    3b16:	6a e0       	ldi	r22, 0x0A	; 10
    3b18:	ce 01       	movw	r24, r28
    3b1a:	19 95       	eicall
			break;
    3b1c:	12 c0       	rjmp	.+36     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3b1e:	e8 81       	ld	r30, Y
    3b20:	f9 81       	ldd	r31, Y+1	; 0x01
    3b22:	02 84       	ldd	r0, Z+10	; 0x0a
    3b24:	f3 85       	ldd	r31, Z+11	; 0x0b
    3b26:	e0 2d       	mov	r30, r0
    3b28:	ce 01       	movw	r24, r28
    3b2a:	19 95       	eicall
			break;
    3b2c:	0a c0       	rjmp	.+20     	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3b2e:	e8 81       	ld	r30, Y
    3b30:	f9 81       	ldd	r31, Y+1	; 0x01
    3b32:	00 84       	ldd	r0, Z+8	; 0x08
    3b34:	f1 85       	ldd	r31, Z+9	; 0x09
    3b36:	e0 2d       	mov	r30, r0
    3b38:	ce 01       	movw	r24, r28
    3b3a:	19 95       	eicall
			break;
    3b3c:	02 c0       	rjmp	.+4      	; 0x3b42 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3b3e:	81 e0       	ldi	r24, 0x01	; 1
    3b40:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3b42:	ce 01       	movw	r24, r28
    3b44:	df 91       	pop	r29
    3b46:	cf 91       	pop	r28
    3b48:	08 95       	ret

00003b4a <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3b4a:	ff 92       	push	r15
    3b4c:	0f 93       	push	r16
    3b4e:	1f 93       	push	r17
    3b50:	cf 93       	push	r28
    3b52:	df 93       	push	r29
    3b54:	cd b7       	in	r28, 0x3d	; 61
    3b56:	de b7       	in	r29, 0x3e	; 62
    3b58:	61 97       	sbiw	r28, 0x11	; 17
    3b5a:	cd bf       	out	0x3d, r28	; 61
    3b5c:	de bf       	out	0x3e, r29	; 62
    3b5e:	8c 01       	movw	r16, r24
    3b60:	f6 2e       	mov	r15, r22
    3b62:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3b64:	f8 01       	movw	r30, r16
    3b66:	42 81       	ldd	r20, Z+2	; 0x02
    3b68:	40 31       	cpi	r20, 0x10	; 16
    3b6a:	21 f0       	breq	.+8      	; 0x3b74 <_ZN8emstreamlsEj+0x2a>
    3b6c:	48 30       	cpi	r20, 0x08	; 8
    3b6e:	11 f0       	breq	.+4      	; 0x3b74 <_ZN8emstreamlsEj+0x2a>
    3b70:	42 30       	cpi	r20, 0x02	; 2
    3b72:	41 f4       	brne	.+16     	; 0x3b84 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3b74:	69 2f       	mov	r22, r25
    3b76:	c8 01       	movw	r24, r16
    3b78:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3b7c:	6f 2d       	mov	r22, r15
    3b7e:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3b82:	0d c0       	rjmp	.+26     	; 0x3b9e <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3b84:	50 e0       	ldi	r21, 0x00	; 0
    3b86:	be 01       	movw	r22, r28
    3b88:	6f 5f       	subi	r22, 0xFF	; 255
    3b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b8c:	8f 2d       	mov	r24, r15
    3b8e:	0e 94 33 25 	call	0x4a66	; 0x4a66 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3b92:	be 01       	movw	r22, r28
    3b94:	6f 5f       	subi	r22, 0xFF	; 255
    3b96:	7f 4f       	sbci	r23, 0xFF	; 255
    3b98:	c8 01       	movw	r24, r16
    3b9a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3b9e:	c8 01       	movw	r24, r16
    3ba0:	61 96       	adiw	r28, 0x11	; 17
    3ba2:	cd bf       	out	0x3d, r28	; 61
    3ba4:	de bf       	out	0x3e, r29	; 62
    3ba6:	df 91       	pop	r29
    3ba8:	cf 91       	pop	r28
    3baa:	1f 91       	pop	r17
    3bac:	0f 91       	pop	r16
    3bae:	ff 90       	pop	r15
    3bb0:	08 95       	ret

00003bb2 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3bb2:	df 92       	push	r13
    3bb4:	ef 92       	push	r14
    3bb6:	ff 92       	push	r15
    3bb8:	0f 93       	push	r16
    3bba:	1f 93       	push	r17
    3bbc:	cf 93       	push	r28
    3bbe:	df 93       	push	r29
    3bc0:	cd b7       	in	r28, 0x3d	; 61
    3bc2:	de b7       	in	r29, 0x3e	; 62
    3bc4:	a1 97       	sbiw	r28, 0x21	; 33
    3bc6:	cd bf       	out	0x3d, r28	; 61
    3bc8:	de bf       	out	0x3e, r29	; 62
    3bca:	8c 01       	movw	r16, r24
    3bcc:	d4 2e       	mov	r13, r20
    3bce:	e5 2e       	mov	r14, r21
    3bd0:	f6 2e       	mov	r15, r22
    3bd2:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3bd4:	f8 01       	movw	r30, r16
    3bd6:	22 81       	ldd	r18, Z+2	; 0x02
    3bd8:	20 31       	cpi	r18, 0x10	; 16
    3bda:	21 f0       	breq	.+8      	; 0x3be4 <_ZN8emstreamlsEm+0x32>
    3bdc:	28 30       	cpi	r18, 0x08	; 8
    3bde:	11 f0       	breq	.+4      	; 0x3be4 <_ZN8emstreamlsEm+0x32>
    3be0:	22 30       	cpi	r18, 0x02	; 2
    3be2:	71 f4       	brne	.+28     	; 0x3c00 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3be4:	69 2f       	mov	r22, r25
    3be6:	c8 01       	movw	r24, r16
    3be8:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3bec:	6f 2d       	mov	r22, r15
    3bee:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3bf2:	6e 2d       	mov	r22, r14
    3bf4:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3bf8:	6d 2d       	mov	r22, r13
    3bfa:	0e 94 1b 1e 	call	0x3c36	; 0x3c36 <_ZN8emstreamlsEh>
    3bfe:	0f c0       	rjmp	.+30     	; 0x3c1e <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3c00:	30 e0       	ldi	r19, 0x00	; 0
    3c02:	ae 01       	movw	r20, r28
    3c04:	4f 5f       	subi	r20, 0xFF	; 255
    3c06:	5f 4f       	sbci	r21, 0xFF	; 255
    3c08:	6d 2d       	mov	r22, r13
    3c0a:	7e 2d       	mov	r23, r14
    3c0c:	8f 2d       	mov	r24, r15
    3c0e:	0e 94 06 25 	call	0x4a0c	; 0x4a0c <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3c12:	be 01       	movw	r22, r28
    3c14:	6f 5f       	subi	r22, 0xFF	; 255
    3c16:	7f 4f       	sbci	r23, 0xFF	; 255
    3c18:	c8 01       	movw	r24, r16
    3c1a:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3c1e:	c8 01       	movw	r24, r16
    3c20:	a1 96       	adiw	r28, 0x21	; 33
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	de bf       	out	0x3e, r29	; 62
    3c26:	df 91       	pop	r29
    3c28:	cf 91       	pop	r28
    3c2a:	1f 91       	pop	r17
    3c2c:	0f 91       	pop	r16
    3c2e:	ff 90       	pop	r15
    3c30:	ef 90       	pop	r14
    3c32:	df 90       	pop	r13
    3c34:	08 95       	ret

00003c36 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3c36:	cf 92       	push	r12
    3c38:	df 92       	push	r13
    3c3a:	ef 92       	push	r14
    3c3c:	ff 92       	push	r15
    3c3e:	0f 93       	push	r16
    3c40:	1f 93       	push	r17
    3c42:	cf 93       	push	r28
    3c44:	df 93       	push	r29
    3c46:	cd b7       	in	r28, 0x3d	; 61
    3c48:	de b7       	in	r29, 0x3e	; 62
    3c4a:	29 97       	sbiw	r28, 0x09	; 9
    3c4c:	cd bf       	out	0x3d, r28	; 61
    3c4e:	de bf       	out	0x3e, r29	; 62
    3c50:	8c 01       	movw	r16, r24
    3c52:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3c54:	dc 01       	movw	r26, r24
    3c56:	13 96       	adiw	r26, 0x03	; 3
    3c58:	8c 91       	ld	r24, X
    3c5a:	13 97       	sbiw	r26, 0x03	; 3
    3c5c:	88 23       	and	r24, r24
    3c5e:	41 f0       	breq	.+16     	; 0x3c70 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3c60:	ed 91       	ld	r30, X+
    3c62:	fc 91       	ld	r31, X
    3c64:	02 80       	ldd	r0, Z+2	; 0x02
    3c66:	f3 81       	ldd	r31, Z+3	; 0x03
    3c68:	e0 2d       	mov	r30, r0
    3c6a:	c8 01       	movw	r24, r16
    3c6c:	19 95       	eicall
    3c6e:	56 c0       	rjmp	.+172    	; 0x3d1c <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3c70:	f8 01       	movw	r30, r16
    3c72:	42 81       	ldd	r20, Z+2	; 0x02
    3c74:	42 30       	cpi	r20, 0x02	; 2
    3c76:	19 f5       	brne	.+70     	; 0x3cbe <_ZN8emstreamlsEh+0x88>
    3c78:	68 94       	set
    3c7a:	cc 24       	eor	r12, r12
    3c7c:	c3 f8       	bld	r12, 3
    3c7e:	d1 2c       	mov	r13, r1
    3c80:	68 94       	set
    3c82:	ff 24       	eor	r15, r15
    3c84:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3c86:	8e 2d       	mov	r24, r14
    3c88:	8f 21       	and	r24, r15
    3c8a:	51 f0       	breq	.+20     	; 0x3ca0 <_ZN8emstreamlsEh+0x6a>
    3c8c:	d8 01       	movw	r26, r16
    3c8e:	ed 91       	ld	r30, X+
    3c90:	fc 91       	ld	r31, X
    3c92:	02 80       	ldd	r0, Z+2	; 0x02
    3c94:	f3 81       	ldd	r31, Z+3	; 0x03
    3c96:	e0 2d       	mov	r30, r0
    3c98:	61 e3       	ldi	r22, 0x31	; 49
    3c9a:	c8 01       	movw	r24, r16
    3c9c:	19 95       	eicall
    3c9e:	09 c0       	rjmp	.+18     	; 0x3cb2 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3ca0:	d8 01       	movw	r26, r16
    3ca2:	ed 91       	ld	r30, X+
    3ca4:	fc 91       	ld	r31, X
    3ca6:	02 80       	ldd	r0, Z+2	; 0x02
    3ca8:	f3 81       	ldd	r31, Z+3	; 0x03
    3caa:	e0 2d       	mov	r30, r0
    3cac:	60 e3       	ldi	r22, 0x30	; 48
    3cae:	c8 01       	movw	r24, r16
    3cb0:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3cb2:	f6 94       	lsr	r15
    3cb4:	b1 e0       	ldi	r27, 0x01	; 1
    3cb6:	cb 1a       	sub	r12, r27
    3cb8:	d1 08       	sbc	r13, r1
    3cba:	29 f7       	brne	.-54     	; 0x3c86 <_ZN8emstreamlsEh+0x50>
    3cbc:	2f c0       	rjmp	.+94     	; 0x3d1c <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3cbe:	40 31       	cpi	r20, 0x10	; 16
    3cc0:	f9 f4       	brne	.+62     	; 0x3d00 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3cc2:	62 95       	swap	r22
    3cc4:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3cc6:	01 90       	ld	r0, Z+
    3cc8:	f0 81       	ld	r31, Z
    3cca:	e0 2d       	mov	r30, r0
    3ccc:	02 80       	ldd	r0, Z+2	; 0x02
    3cce:	f3 81       	ldd	r31, Z+3	; 0x03
    3cd0:	e0 2d       	mov	r30, r0
    3cd2:	6a 30       	cpi	r22, 0x0A	; 10
    3cd4:	10 f0       	brcs	.+4      	; 0x3cda <_ZN8emstreamlsEh+0xa4>
    3cd6:	69 5c       	subi	r22, 0xC9	; 201
    3cd8:	01 c0       	rjmp	.+2      	; 0x3cdc <_ZN8emstreamlsEh+0xa6>
    3cda:	60 5d       	subi	r22, 0xD0	; 208
    3cdc:	c8 01       	movw	r24, r16
    3cde:	19 95       	eicall
		temp_char = num & 0x0F;
    3ce0:	6e 2d       	mov	r22, r14
    3ce2:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3ce4:	d8 01       	movw	r26, r16
    3ce6:	ed 91       	ld	r30, X+
    3ce8:	fc 91       	ld	r31, X
    3cea:	02 80       	ldd	r0, Z+2	; 0x02
    3cec:	f3 81       	ldd	r31, Z+3	; 0x03
    3cee:	e0 2d       	mov	r30, r0
    3cf0:	6a 30       	cpi	r22, 0x0A	; 10
    3cf2:	10 f0       	brcs	.+4      	; 0x3cf8 <_ZN8emstreamlsEh+0xc2>
    3cf4:	69 5c       	subi	r22, 0xC9	; 201
    3cf6:	01 c0       	rjmp	.+2      	; 0x3cfa <_ZN8emstreamlsEh+0xc4>
    3cf8:	60 5d       	subi	r22, 0xD0	; 208
    3cfa:	c8 01       	movw	r24, r16
    3cfc:	19 95       	eicall
    3cfe:	0e c0       	rjmp	.+28     	; 0x3d1c <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3d00:	50 e0       	ldi	r21, 0x00	; 0
    3d02:	be 01       	movw	r22, r28
    3d04:	6f 5f       	subi	r22, 0xFF	; 255
    3d06:	7f 4f       	sbci	r23, 0xFF	; 255
    3d08:	8e 2d       	mov	r24, r14
    3d0a:	90 e0       	ldi	r25, 0x00	; 0
    3d0c:	0e 94 33 25 	call	0x4a66	; 0x4a66 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3d10:	be 01       	movw	r22, r28
    3d12:	6f 5f       	subi	r22, 0xFF	; 255
    3d14:	7f 4f       	sbci	r23, 0xFF	; 255
    3d16:	c8 01       	movw	r24, r16
    3d18:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3d1c:	c8 01       	movw	r24, r16
    3d1e:	29 96       	adiw	r28, 0x09	; 9
    3d20:	cd bf       	out	0x3d, r28	; 61
    3d22:	de bf       	out	0x3e, r29	; 62
    3d24:	df 91       	pop	r29
    3d26:	cf 91       	pop	r28
    3d28:	1f 91       	pop	r17
    3d2a:	0f 91       	pop	r16
    3d2c:	ff 90       	pop	r15
    3d2e:	ef 90       	pop	r14
    3d30:	df 90       	pop	r13
    3d32:	cf 90       	pop	r12
    3d34:	08 95       	ret

00003d36 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3d36:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d38:	50 96       	adiw	r26, 0x10	; 16
    3d3a:	ed 91       	ld	r30, X+
    3d3c:	fc 91       	ld	r31, X
    3d3e:	51 97       	sbiw	r26, 0x11	; 17
    3d40:	80 81       	ld	r24, Z
    3d42:	54 96       	adiw	r26, 0x14	; 20
    3d44:	4c 91       	ld	r20, X
    3d46:	54 97       	sbiw	r26, 0x14	; 20
    3d48:	84 23       	and	r24, r20
    3d4a:	29 f0       	breq	.+10     	; 0x3d56 <_ZN5rs2327putcharEc+0x20>
    3d4c:	09 c0       	rjmp	.+18     	; 0x3d60 <_ZN5rs2327putcharEc+0x2a>
    3d4e:	21 50       	subi	r18, 0x01	; 1
    3d50:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3d52:	19 f4       	brne	.+6      	; 0x3d5a <_ZN5rs2327putcharEc+0x24>
    3d54:	12 c0       	rjmp	.+36     	; 0x3d7a <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3d56:	21 e2       	ldi	r18, 0x21	; 33
    3d58:	3e e4       	ldi	r19, 0x4E	; 78
    3d5a:	90 81       	ld	r25, Z
    3d5c:	94 23       	and	r25, r20
    3d5e:	b9 f3       	breq	.-18     	; 0x3d4e <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3d60:	90 81       	ld	r25, Z
    3d62:	56 96       	adiw	r26, 0x16	; 22
    3d64:	8c 91       	ld	r24, X
    3d66:	56 97       	sbiw	r26, 0x16	; 22
    3d68:	89 2b       	or	r24, r25
    3d6a:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3d6c:	1e 96       	adiw	r26, 0x0e	; 14
    3d6e:	ed 91       	ld	r30, X+
    3d70:	fc 91       	ld	r31, X
    3d72:	1f 97       	sbiw	r26, 0x0f	; 15
    3d74:	60 83       	st	Z, r22
	return (true);
    3d76:	81 e0       	ldi	r24, 0x01	; 1
    3d78:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3d7a:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3d7c:	08 95       	ret

00003d7e <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3d7e:	cf 93       	push	r28
    3d80:	df 93       	push	r29
    3d82:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3d84:	c1 8d       	ldd	r28, Z+25	; 0x19
    3d86:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3d88:	28 81       	ld	r18, Y
    3d8a:	39 81       	ldd	r19, Y+1	; 0x01
    3d8c:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3d8e:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3d90:	4d 91       	ld	r20, X+
    3d92:	5c 91       	ld	r21, X
    3d94:	24 17       	cp	r18, r20
    3d96:	35 07       	cpc	r19, r21
    3d98:	e9 f3       	breq	.-6      	; 0x3d94 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3d9a:	a7 89       	ldd	r26, Z+23	; 0x17
    3d9c:	b0 8d       	ldd	r27, Z+24	; 0x18
    3d9e:	0d 90       	ld	r0, X+
    3da0:	bc 91       	ld	r27, X
    3da2:	a0 2d       	mov	r26, r0
    3da4:	a2 0f       	add	r26, r18
    3da6:	b3 1f       	adc	r27, r19
    3da8:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3daa:	2f 5f       	subi	r18, 0xFF	; 255
    3dac:	3f 4f       	sbci	r19, 0xFF	; 255
    3dae:	28 83       	st	Y, r18
    3db0:	39 83       	std	Y+1, r19	; 0x01
    3db2:	24 36       	cpi	r18, 0x64	; 100
    3db4:	31 05       	cpc	r19, r1
    3db6:	28 f0       	brcs	.+10     	; 0x3dc2 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3db8:	01 8c       	ldd	r0, Z+25	; 0x19
    3dba:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3dbc:	e0 2d       	mov	r30, r0
    3dbe:	10 82       	st	Z, r1
    3dc0:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3dc2:	90 e0       	ldi	r25, 0x00	; 0
    3dc4:	df 91       	pop	r29
    3dc6:	cf 91       	pop	r28
    3dc8:	08 95       	ret

00003dca <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3dca:	cf 93       	push	r28
    3dcc:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3dce:	ec 01       	movw	r28, r24
    3dd0:	a9 8d       	ldd	r26, Y+25	; 0x19
    3dd2:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3dd4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3dd6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3dd8:	81 e0       	ldi	r24, 0x01	; 1
    3dda:	4d 91       	ld	r20, X+
    3ddc:	5c 91       	ld	r21, X
    3dde:	20 81       	ld	r18, Z
    3de0:	31 81       	ldd	r19, Z+1	; 0x01
    3de2:	42 17       	cp	r20, r18
    3de4:	53 07       	cpc	r21, r19
    3de6:	09 f4       	brne	.+2      	; 0x3dea <_ZN5rs23214check_for_charEv+0x20>
    3de8:	80 e0       	ldi	r24, 0x00	; 0
}
    3dea:	df 91       	pop	r29
    3dec:	cf 91       	pop	r28
    3dee:	08 95       	ret

00003df0 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3df0:	dc 01       	movw	r26, r24
    3df2:	ed 91       	ld	r30, X+
    3df4:	fc 91       	ld	r31, X
    3df6:	02 80       	ldd	r0, Z+2	; 0x02
    3df8:	f3 81       	ldd	r31, Z+3	; 0x03
    3dfa:	e0 2d       	mov	r30, r0
    3dfc:	6c e0       	ldi	r22, 0x0C	; 12
    3dfe:	19 95       	eicall
    3e00:	08 95       	ret

00003e02 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3e02:	ef 92       	push	r14
    3e04:	ff 92       	push	r15
    3e06:	0f 93       	push	r16
    3e08:	1f 93       	push	r17
    3e0a:	cf 93       	push	r28
    3e0c:	df 93       	push	r29
    3e0e:	ec 01       	movw	r28, r24
    3e10:	7b 01       	movw	r14, r22
    3e12:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3e14:	0e 94 19 1d 	call	0x3a32	; 0x3a32 <_ZN8emstreamC1Ev>
    3e18:	a8 01       	movw	r20, r16
    3e1a:	b7 01       	movw	r22, r14
    3e1c:	ce 01       	movw	r24, r28
    3e1e:	08 96       	adiw	r24, 0x08	; 8
    3e20:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <_ZN7base232C1EjP12USART_struct>
    3e24:	84 e4       	ldi	r24, 0x44	; 68
    3e26:	91 e2       	ldi	r25, 0x21	; 33
    3e28:	88 83       	st	Y, r24
    3e2a:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3e2c:	00 3a       	cpi	r16, 0xA0	; 160
    3e2e:	88 e0       	ldi	r24, 0x08	; 8
    3e30:	18 07       	cpc	r17, r24
    3e32:	69 f4       	brne	.+26     	; 0x3e4e <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3e34:	8e e4       	ldi	r24, 0x4E	; 78
    3e36:	92 e3       	ldi	r25, 0x32	; 50
    3e38:	8f 8b       	std	Y+23, r24	; 0x17
    3e3a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3e3c:	84 e4       	ldi	r24, 0x44	; 68
    3e3e:	92 e3       	ldi	r25, 0x32	; 50
    3e40:	89 8f       	std	Y+25, r24	; 0x19
    3e42:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3e44:	8a e3       	ldi	r24, 0x3A	; 58
    3e46:	92 e3       	ldi	r25, 0x32	; 50
    3e48:	8b 8f       	std	Y+27, r24	; 0x1b
    3e4a:	9c 8f       	std	Y+28, r25	; 0x1c
    3e4c:	42 c0       	rjmp	.+132    	; 0x3ed2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3e4e:	00 3b       	cpi	r16, 0xB0	; 176
    3e50:	e8 e0       	ldi	r30, 0x08	; 8
    3e52:	1e 07       	cpc	r17, r30
    3e54:	69 f4       	brne	.+26     	; 0x3e70 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3e56:	8c e4       	ldi	r24, 0x4C	; 76
    3e58:	92 e3       	ldi	r25, 0x32	; 50
    3e5a:	8f 8b       	std	Y+23, r24	; 0x17
    3e5c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3e5e:	82 e4       	ldi	r24, 0x42	; 66
    3e60:	92 e3       	ldi	r25, 0x32	; 50
    3e62:	89 8f       	std	Y+25, r24	; 0x19
    3e64:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3e66:	88 e3       	ldi	r24, 0x38	; 56
    3e68:	92 e3       	ldi	r25, 0x32	; 50
    3e6a:	8b 8f       	std	Y+27, r24	; 0x1b
    3e6c:	9c 8f       	std	Y+28, r25	; 0x1c
    3e6e:	31 c0       	rjmp	.+98     	; 0x3ed2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e70:	00 3a       	cpi	r16, 0xA0	; 160
    3e72:	f9 e0       	ldi	r31, 0x09	; 9
    3e74:	1f 07       	cpc	r17, r31
    3e76:	69 f4       	brne	.+26     	; 0x3e92 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3e78:	8a e4       	ldi	r24, 0x4A	; 74
    3e7a:	92 e3       	ldi	r25, 0x32	; 50
    3e7c:	8f 8b       	std	Y+23, r24	; 0x17
    3e7e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3e80:	80 e4       	ldi	r24, 0x40	; 64
    3e82:	92 e3       	ldi	r25, 0x32	; 50
    3e84:	89 8f       	std	Y+25, r24	; 0x19
    3e86:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3e88:	86 e3       	ldi	r24, 0x36	; 54
    3e8a:	92 e3       	ldi	r25, 0x32	; 50
    3e8c:	8b 8f       	std	Y+27, r24	; 0x1b
    3e8e:	9c 8f       	std	Y+28, r25	; 0x1c
    3e90:	20 c0       	rjmp	.+64     	; 0x3ed2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3e92:	00 3b       	cpi	r16, 0xB0	; 176
    3e94:	89 e0       	ldi	r24, 0x09	; 9
    3e96:	18 07       	cpc	r17, r24
    3e98:	69 f4       	brne	.+26     	; 0x3eb4 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3e9a:	88 e4       	ldi	r24, 0x48	; 72
    3e9c:	92 e3       	ldi	r25, 0x32	; 50
    3e9e:	8f 8b       	std	Y+23, r24	; 0x17
    3ea0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3ea2:	8e e3       	ldi	r24, 0x3E	; 62
    3ea4:	92 e3       	ldi	r25, 0x32	; 50
    3ea6:	89 8f       	std	Y+25, r24	; 0x19
    3ea8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3eaa:	84 e3       	ldi	r24, 0x34	; 52
    3eac:	92 e3       	ldi	r25, 0x32	; 50
    3eae:	8b 8f       	std	Y+27, r24	; 0x1b
    3eb0:	9c 8f       	std	Y+28, r25	; 0x1c
    3eb2:	0f c0       	rjmp	.+30     	; 0x3ed2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3eb4:	00 3a       	cpi	r16, 0xA0	; 160
    3eb6:	1a 40       	sbci	r17, 0x0A	; 10
    3eb8:	61 f4       	brne	.+24     	; 0x3ed2 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3eba:	86 e4       	ldi	r24, 0x46	; 70
    3ebc:	92 e3       	ldi	r25, 0x32	; 50
    3ebe:	8f 8b       	std	Y+23, r24	; 0x17
    3ec0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3ec2:	8c e3       	ldi	r24, 0x3C	; 60
    3ec4:	92 e3       	ldi	r25, 0x32	; 50
    3ec6:	89 8f       	std	Y+25, r24	; 0x19
    3ec8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3eca:	82 e3       	ldi	r24, 0x32	; 50
    3ecc:	92 e3       	ldi	r25, 0x32	; 50
    3ece:	8b 8f       	std	Y+27, r24	; 0x1b
    3ed0:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3ed2:	0f 89       	ldd	r16, Y+23	; 0x17
    3ed4:	18 8d       	ldd	r17, Y+24	; 0x18
    3ed6:	84 e6       	ldi	r24, 0x64	; 100
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	0e 94 76 1c 	call	0x38ec	; 0x38ec <_Znaj>
    3ede:	f8 01       	movw	r30, r16
    3ee0:	80 83       	st	Z, r24
    3ee2:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3ee4:	e9 8d       	ldd	r30, Y+25	; 0x19
    3ee6:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3ee8:	10 82       	st	Z, r1
    3eea:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3eec:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3eee:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3ef0:	10 82       	st	Z, r1
    3ef2:	11 82       	std	Z+1, r1	; 0x01
}
    3ef4:	df 91       	pop	r29
    3ef6:	cf 91       	pop	r28
    3ef8:	1f 91       	pop	r17
    3efa:	0f 91       	pop	r16
    3efc:	ff 90       	pop	r15
    3efe:	ef 90       	pop	r14
    3f00:	08 95       	ret

00003f02 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3f02:	1f 92       	push	r1
    3f04:	0f 92       	push	r0
    3f06:	0f b6       	in	r0, 0x3f	; 63
    3f08:	0f 92       	push	r0
    3f0a:	11 24       	eor	r1, r1
    3f0c:	08 b6       	in	r0, 0x38	; 56
    3f0e:	0f 92       	push	r0
    3f10:	18 be       	out	0x38, r1	; 56
    3f12:	0b b6       	in	r0, 0x3b	; 59
    3f14:	0f 92       	push	r0
    3f16:	1b be       	out	0x3b, r1	; 59
    3f18:	2f 93       	push	r18
    3f1a:	3f 93       	push	r19
    3f1c:	8f 93       	push	r24
    3f1e:	9f 93       	push	r25
    3f20:	ef 93       	push	r30
    3f22:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3f24:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3f28:	e0 91 4e 32 	lds	r30, 0x324E	; 0x80324e <rcvC0_buffer>
    3f2c:	f0 91 4f 32 	lds	r31, 0x324F	; 0x80324f <rcvC0_buffer+0x1>
    3f30:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    3f34:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    3f38:	e8 0f       	add	r30, r24
    3f3a:	f9 1f       	adc	r31, r25
    3f3c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3f3e:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    3f42:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    3f46:	01 96       	adiw	r24, 0x01	; 1
    3f48:	84 36       	cpi	r24, 0x64	; 100
    3f4a:	91 05       	cpc	r25, r1
    3f4c:	60 f4       	brcc	.+24     	; 0x3f66 <__vector_25+0x64>
    3f4e:	80 93 3a 32 	sts	0x323A, r24	; 0x80323a <rcvC0_write_index>
    3f52:	90 93 3b 32 	sts	0x323B, r25	; 0x80323b <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f56:	20 91 44 32 	lds	r18, 0x3244	; 0x803244 <rcvC0_read_index>
    3f5a:	30 91 45 32 	lds	r19, 0x3245	; 0x803245 <rcvC0_read_index+0x1>
    3f5e:	82 17       	cp	r24, r18
    3f60:	93 07       	cpc	r25, r19
    3f62:	f1 f4       	brne	.+60     	; 0x3fa0 <__vector_25+0x9e>
    3f64:	0c c0       	rjmp	.+24     	; 0x3f7e <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3f66:	10 92 3a 32 	sts	0x323A, r1	; 0x80323a <rcvC0_write_index>
    3f6a:	10 92 3b 32 	sts	0x323B, r1	; 0x80323b <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3f6e:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <rcvC0_read_index>
    3f72:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <rcvC0_read_index+0x1>
    3f76:	18 16       	cp	r1, r24
    3f78:	19 06       	cpc	r1, r25
    3f7a:	91 f4       	brne	.+36     	; 0x3fa0 <__vector_25+0x9e>
    3f7c:	0e c0       	rjmp	.+28     	; 0x3f9a <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f7e:	01 96       	adiw	r24, 0x01	; 1
    3f80:	84 36       	cpi	r24, 0x64	; 100
    3f82:	91 05       	cpc	r25, r1
    3f84:	28 f4       	brcc	.+10     	; 0x3f90 <__vector_25+0x8e>
    3f86:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <rcvC0_read_index>
    3f8a:	90 93 45 32 	sts	0x3245, r25	; 0x803245 <rcvC0_read_index+0x1>
    3f8e:	08 c0       	rjmp	.+16     	; 0x3fa0 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3f90:	10 92 44 32 	sts	0x3244, r1	; 0x803244 <rcvC0_read_index>
    3f94:	10 92 45 32 	sts	0x3245, r1	; 0x803245 <rcvC0_read_index+0x1>
}
    3f98:	03 c0       	rjmp	.+6      	; 0x3fa0 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3f9a:	81 e0       	ldi	r24, 0x01	; 1
    3f9c:	90 e0       	ldi	r25, 0x00	; 0
    3f9e:	f3 cf       	rjmp	.-26     	; 0x3f86 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3fa0:	ff 91       	pop	r31
    3fa2:	ef 91       	pop	r30
    3fa4:	9f 91       	pop	r25
    3fa6:	8f 91       	pop	r24
    3fa8:	3f 91       	pop	r19
    3faa:	2f 91       	pop	r18
    3fac:	0f 90       	pop	r0
    3fae:	0b be       	out	0x3b, r0	; 59
    3fb0:	0f 90       	pop	r0
    3fb2:	08 be       	out	0x38, r0	; 56
    3fb4:	0f 90       	pop	r0
    3fb6:	0f be       	out	0x3f, r0	; 63
    3fb8:	0f 90       	pop	r0
    3fba:	1f 90       	pop	r1
    3fbc:	18 95       	reti

00003fbe <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3fbe:	1f 92       	push	r1
    3fc0:	0f 92       	push	r0
    3fc2:	0f b6       	in	r0, 0x3f	; 63
    3fc4:	0f 92       	push	r0
    3fc6:	11 24       	eor	r1, r1
    3fc8:	08 b6       	in	r0, 0x38	; 56
    3fca:	0f 92       	push	r0
    3fcc:	18 be       	out	0x38, r1	; 56
    3fce:	0b b6       	in	r0, 0x3b	; 59
    3fd0:	0f 92       	push	r0
    3fd2:	1b be       	out	0x3b, r1	; 59
    3fd4:	2f 93       	push	r18
    3fd6:	3f 93       	push	r19
    3fd8:	8f 93       	push	r24
    3fda:	9f 93       	push	r25
    3fdc:	ef 93       	push	r30
    3fde:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3fe0:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3fe4:	e0 91 4c 32 	lds	r30, 0x324C	; 0x80324c <rcvC1_buffer>
    3fe8:	f0 91 4d 32 	lds	r31, 0x324D	; 0x80324d <rcvC1_buffer+0x1>
    3fec:	80 91 38 32 	lds	r24, 0x3238	; 0x803238 <rcvC1_write_index>
    3ff0:	90 91 39 32 	lds	r25, 0x3239	; 0x803239 <rcvC1_write_index+0x1>
    3ff4:	e8 0f       	add	r30, r24
    3ff6:	f9 1f       	adc	r31, r25
    3ff8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3ffa:	80 91 38 32 	lds	r24, 0x3238	; 0x803238 <rcvC1_write_index>
    3ffe:	90 91 39 32 	lds	r25, 0x3239	; 0x803239 <rcvC1_write_index+0x1>
    4002:	01 96       	adiw	r24, 0x01	; 1
    4004:	84 36       	cpi	r24, 0x64	; 100
    4006:	91 05       	cpc	r25, r1
    4008:	60 f4       	brcc	.+24     	; 0x4022 <__stack+0x23>
    400a:	80 93 38 32 	sts	0x3238, r24	; 0x803238 <rcvC1_write_index>
    400e:	90 93 39 32 	sts	0x3239, r25	; 0x803239 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4012:	20 91 42 32 	lds	r18, 0x3242	; 0x803242 <rcvC1_read_index>
    4016:	30 91 43 32 	lds	r19, 0x3243	; 0x803243 <rcvC1_read_index+0x1>
    401a:	82 17       	cp	r24, r18
    401c:	93 07       	cpc	r25, r19
    401e:	f1 f4       	brne	.+60     	; 0x405c <__stack+0x5d>
    4020:	0c c0       	rjmp	.+24     	; 0x403a <__stack+0x3b>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4022:	10 92 38 32 	sts	0x3238, r1	; 0x803238 <rcvC1_write_index>
    4026:	10 92 39 32 	sts	0x3239, r1	; 0x803239 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    402a:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <rcvC1_read_index>
    402e:	90 91 43 32 	lds	r25, 0x3243	; 0x803243 <rcvC1_read_index+0x1>
    4032:	18 16       	cp	r1, r24
    4034:	19 06       	cpc	r1, r25
    4036:	91 f4       	brne	.+36     	; 0x405c <__stack+0x5d>
    4038:	0e c0       	rjmp	.+28     	; 0x4056 <__stack+0x57>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    403a:	01 96       	adiw	r24, 0x01	; 1
    403c:	84 36       	cpi	r24, 0x64	; 100
    403e:	91 05       	cpc	r25, r1
    4040:	28 f4       	brcc	.+10     	; 0x404c <__stack+0x4d>
    4042:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <rcvC1_read_index>
    4046:	90 93 43 32 	sts	0x3243, r25	; 0x803243 <rcvC1_read_index+0x1>
    404a:	08 c0       	rjmp	.+16     	; 0x405c <__stack+0x5d>
	rcvC1_read_index = 0;
    404c:	10 92 42 32 	sts	0x3242, r1	; 0x803242 <rcvC1_read_index>
    4050:	10 92 43 32 	sts	0x3243, r1	; 0x803243 <rcvC1_read_index+0x1>
}
    4054:	03 c0       	rjmp	.+6      	; 0x405c <__stack+0x5d>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4056:	81 e0       	ldi	r24, 0x01	; 1
    4058:	90 e0       	ldi	r25, 0x00	; 0
    405a:	f3 cf       	rjmp	.-26     	; 0x4042 <__stack+0x43>
	rcvC1_read_index = 0;
}
    405c:	ff 91       	pop	r31
    405e:	ef 91       	pop	r30
    4060:	9f 91       	pop	r25
    4062:	8f 91       	pop	r24
    4064:	3f 91       	pop	r19
    4066:	2f 91       	pop	r18
    4068:	0f 90       	pop	r0
    406a:	0b be       	out	0x3b, r0	; 59
    406c:	0f 90       	pop	r0
    406e:	08 be       	out	0x38, r0	; 56
    4070:	0f 90       	pop	r0
    4072:	0f be       	out	0x3f, r0	; 63
    4074:	0f 90       	pop	r0
    4076:	1f 90       	pop	r1
    4078:	18 95       	reti

0000407a <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    407a:	1f 92       	push	r1
    407c:	0f 92       	push	r0
    407e:	0f b6       	in	r0, 0x3f	; 63
    4080:	0f 92       	push	r0
    4082:	11 24       	eor	r1, r1
    4084:	08 b6       	in	r0, 0x38	; 56
    4086:	0f 92       	push	r0
    4088:	18 be       	out	0x38, r1	; 56
    408a:	0b b6       	in	r0, 0x3b	; 59
    408c:	0f 92       	push	r0
    408e:	1b be       	out	0x3b, r1	; 59
    4090:	2f 93       	push	r18
    4092:	3f 93       	push	r19
    4094:	8f 93       	push	r24
    4096:	9f 93       	push	r25
    4098:	ef 93       	push	r30
    409a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    409c:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    40a0:	e0 91 4a 32 	lds	r30, 0x324A	; 0x80324a <rcvD0_buffer>
    40a4:	f0 91 4b 32 	lds	r31, 0x324B	; 0x80324b <rcvD0_buffer+0x1>
    40a8:	80 91 3a 32 	lds	r24, 0x323A	; 0x80323a <rcvC0_write_index>
    40ac:	90 91 3b 32 	lds	r25, 0x323B	; 0x80323b <rcvC0_write_index+0x1>
    40b0:	e8 0f       	add	r30, r24
    40b2:	f9 1f       	adc	r31, r25
    40b4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    40b6:	80 91 36 32 	lds	r24, 0x3236	; 0x803236 <rcvD0_write_index>
    40ba:	90 91 37 32 	lds	r25, 0x3237	; 0x803237 <rcvD0_write_index+0x1>
    40be:	01 96       	adiw	r24, 0x01	; 1
    40c0:	84 36       	cpi	r24, 0x64	; 100
    40c2:	91 05       	cpc	r25, r1
    40c4:	60 f4       	brcc	.+24     	; 0x40de <__vector_88+0x64>
    40c6:	80 93 36 32 	sts	0x3236, r24	; 0x803236 <rcvD0_write_index>
    40ca:	90 93 37 32 	sts	0x3237, r25	; 0x803237 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40ce:	20 91 40 32 	lds	r18, 0x3240	; 0x803240 <rcvD0_read_index>
    40d2:	30 91 41 32 	lds	r19, 0x3241	; 0x803241 <rcvD0_read_index+0x1>
    40d6:	82 17       	cp	r24, r18
    40d8:	93 07       	cpc	r25, r19
    40da:	f1 f4       	brne	.+60     	; 0x4118 <__vector_88+0x9e>
    40dc:	0c c0       	rjmp	.+24     	; 0x40f6 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    40de:	10 92 36 32 	sts	0x3236, r1	; 0x803236 <rcvD0_write_index>
    40e2:	10 92 37 32 	sts	0x3237, r1	; 0x803237 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    40e6:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <rcvD0_read_index>
    40ea:	90 91 41 32 	lds	r25, 0x3241	; 0x803241 <rcvD0_read_index+0x1>
    40ee:	18 16       	cp	r1, r24
    40f0:	19 06       	cpc	r1, r25
    40f2:	91 f4       	brne	.+36     	; 0x4118 <__vector_88+0x9e>
    40f4:	0e c0       	rjmp	.+28     	; 0x4112 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    40f6:	01 96       	adiw	r24, 0x01	; 1
    40f8:	84 36       	cpi	r24, 0x64	; 100
    40fa:	91 05       	cpc	r25, r1
    40fc:	28 f4       	brcc	.+10     	; 0x4108 <__vector_88+0x8e>
    40fe:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <rcvD0_read_index>
    4102:	90 93 41 32 	sts	0x3241, r25	; 0x803241 <rcvD0_read_index+0x1>
    4106:	08 c0       	rjmp	.+16     	; 0x4118 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    4108:	10 92 40 32 	sts	0x3240, r1	; 0x803240 <rcvD0_read_index>
    410c:	10 92 41 32 	sts	0x3241, r1	; 0x803241 <rcvD0_read_index+0x1>
}
    4110:	03 c0       	rjmp	.+6      	; 0x4118 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4112:	81 e0       	ldi	r24, 0x01	; 1
    4114:	90 e0       	ldi	r25, 0x00	; 0
    4116:	f3 cf       	rjmp	.-26     	; 0x40fe <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    4118:	ff 91       	pop	r31
    411a:	ef 91       	pop	r30
    411c:	9f 91       	pop	r25
    411e:	8f 91       	pop	r24
    4120:	3f 91       	pop	r19
    4122:	2f 91       	pop	r18
    4124:	0f 90       	pop	r0
    4126:	0b be       	out	0x3b, r0	; 59
    4128:	0f 90       	pop	r0
    412a:	08 be       	out	0x38, r0	; 56
    412c:	0f 90       	pop	r0
    412e:	0f be       	out	0x3f, r0	; 63
    4130:	0f 90       	pop	r0
    4132:	1f 90       	pop	r1
    4134:	18 95       	reti

00004136 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4136:	1f 92       	push	r1
    4138:	0f 92       	push	r0
    413a:	0f b6       	in	r0, 0x3f	; 63
    413c:	0f 92       	push	r0
    413e:	11 24       	eor	r1, r1
    4140:	08 b6       	in	r0, 0x38	; 56
    4142:	0f 92       	push	r0
    4144:	18 be       	out	0x38, r1	; 56
    4146:	0b b6       	in	r0, 0x3b	; 59
    4148:	0f 92       	push	r0
    414a:	1b be       	out	0x3b, r1	; 59
    414c:	2f 93       	push	r18
    414e:	3f 93       	push	r19
    4150:	8f 93       	push	r24
    4152:	9f 93       	push	r25
    4154:	ef 93       	push	r30
    4156:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4158:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    415c:	e0 91 48 32 	lds	r30, 0x3248	; 0x803248 <rcvD1_buffer>
    4160:	f0 91 49 32 	lds	r31, 0x3249	; 0x803249 <rcvD1_buffer+0x1>
    4164:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <rcvD1_write_index>
    4168:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <rcvD1_write_index+0x1>
    416c:	e8 0f       	add	r30, r24
    416e:	f9 1f       	adc	r31, r25
    4170:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4172:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <rcvD1_write_index>
    4176:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <rcvD1_write_index+0x1>
    417a:	01 96       	adiw	r24, 0x01	; 1
    417c:	84 36       	cpi	r24, 0x64	; 100
    417e:	91 05       	cpc	r25, r1
    4180:	60 f4       	brcc	.+24     	; 0x419a <__vector_91+0x64>
    4182:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <rcvD1_write_index>
    4186:	90 93 35 32 	sts	0x3235, r25	; 0x803235 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    418a:	20 91 3e 32 	lds	r18, 0x323E	; 0x80323e <rcvD1_read_index>
    418e:	30 91 3f 32 	lds	r19, 0x323F	; 0x80323f <rcvD1_read_index+0x1>
    4192:	82 17       	cp	r24, r18
    4194:	93 07       	cpc	r25, r19
    4196:	f1 f4       	brne	.+60     	; 0x41d4 <__vector_91+0x9e>
    4198:	0c c0       	rjmp	.+24     	; 0x41b2 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    419a:	10 92 34 32 	sts	0x3234, r1	; 0x803234 <rcvD1_write_index>
    419e:	10 92 35 32 	sts	0x3235, r1	; 0x803235 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    41a2:	80 91 3e 32 	lds	r24, 0x323E	; 0x80323e <rcvD1_read_index>
    41a6:	90 91 3f 32 	lds	r25, 0x323F	; 0x80323f <rcvD1_read_index+0x1>
    41aa:	18 16       	cp	r1, r24
    41ac:	19 06       	cpc	r1, r25
    41ae:	91 f4       	brne	.+36     	; 0x41d4 <__vector_91+0x9e>
    41b0:	0e c0       	rjmp	.+28     	; 0x41ce <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41b2:	01 96       	adiw	r24, 0x01	; 1
    41b4:	84 36       	cpi	r24, 0x64	; 100
    41b6:	91 05       	cpc	r25, r1
    41b8:	28 f4       	brcc	.+10     	; 0x41c4 <__vector_91+0x8e>
    41ba:	80 93 3e 32 	sts	0x323E, r24	; 0x80323e <rcvD1_read_index>
    41be:	90 93 3f 32 	sts	0x323F, r25	; 0x80323f <rcvD1_read_index+0x1>
    41c2:	08 c0       	rjmp	.+16     	; 0x41d4 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    41c4:	10 92 3e 32 	sts	0x323E, r1	; 0x80323e <rcvD1_read_index>
    41c8:	10 92 3f 32 	sts	0x323F, r1	; 0x80323f <rcvD1_read_index+0x1>
}
    41cc:	03 c0       	rjmp	.+6      	; 0x41d4 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	90 e0       	ldi	r25, 0x00	; 0
    41d2:	f3 cf       	rjmp	.-26     	; 0x41ba <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    41d4:	ff 91       	pop	r31
    41d6:	ef 91       	pop	r30
    41d8:	9f 91       	pop	r25
    41da:	8f 91       	pop	r24
    41dc:	3f 91       	pop	r19
    41de:	2f 91       	pop	r18
    41e0:	0f 90       	pop	r0
    41e2:	0b be       	out	0x3b, r0	; 59
    41e4:	0f 90       	pop	r0
    41e6:	08 be       	out	0x38, r0	; 56
    41e8:	0f 90       	pop	r0
    41ea:	0f be       	out	0x3f, r0	; 63
    41ec:	0f 90       	pop	r0
    41ee:	1f 90       	pop	r1
    41f0:	18 95       	reti

000041f2 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    41f2:	1f 92       	push	r1
    41f4:	0f 92       	push	r0
    41f6:	0f b6       	in	r0, 0x3f	; 63
    41f8:	0f 92       	push	r0
    41fa:	11 24       	eor	r1, r1
    41fc:	08 b6       	in	r0, 0x38	; 56
    41fe:	0f 92       	push	r0
    4200:	18 be       	out	0x38, r1	; 56
    4202:	0b b6       	in	r0, 0x3b	; 59
    4204:	0f 92       	push	r0
    4206:	1b be       	out	0x3b, r1	; 59
    4208:	2f 93       	push	r18
    420a:	3f 93       	push	r19
    420c:	8f 93       	push	r24
    420e:	9f 93       	push	r25
    4210:	ef 93       	push	r30
    4212:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4214:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    4218:	e0 91 46 32 	lds	r30, 0x3246	; 0x803246 <rcvE0_buffer>
    421c:	f0 91 47 32 	lds	r31, 0x3247	; 0x803247 <rcvE0_buffer+0x1>
    4220:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <rcvE0_write_index>
    4224:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <rcvE0_write_index+0x1>
    4228:	e8 0f       	add	r30, r24
    422a:	f9 1f       	adc	r31, r25
    422c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    422e:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <rcvE0_write_index>
    4232:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <rcvE0_write_index+0x1>
    4236:	01 96       	adiw	r24, 0x01	; 1
    4238:	84 36       	cpi	r24, 0x64	; 100
    423a:	91 05       	cpc	r25, r1
    423c:	60 f4       	brcc	.+24     	; 0x4256 <__vector_58+0x64>
    423e:	80 93 32 32 	sts	0x3232, r24	; 0x803232 <rcvE0_write_index>
    4242:	90 93 33 32 	sts	0x3233, r25	; 0x803233 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4246:	20 91 3c 32 	lds	r18, 0x323C	; 0x80323c <rcvE0_read_index>
    424a:	30 91 3d 32 	lds	r19, 0x323D	; 0x80323d <rcvE0_read_index+0x1>
    424e:	82 17       	cp	r24, r18
    4250:	93 07       	cpc	r25, r19
    4252:	f1 f4       	brne	.+60     	; 0x4290 <__vector_58+0x9e>
    4254:	0c c0       	rjmp	.+24     	; 0x426e <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4256:	10 92 32 32 	sts	0x3232, r1	; 0x803232 <rcvE0_write_index>
    425a:	10 92 33 32 	sts	0x3233, r1	; 0x803233 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    425e:	80 91 3c 32 	lds	r24, 0x323C	; 0x80323c <rcvE0_read_index>
    4262:	90 91 3d 32 	lds	r25, 0x323D	; 0x80323d <rcvE0_read_index+0x1>
    4266:	18 16       	cp	r1, r24
    4268:	19 06       	cpc	r1, r25
    426a:	91 f4       	brne	.+36     	; 0x4290 <__vector_58+0x9e>
    426c:	0e c0       	rjmp	.+28     	; 0x428a <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    426e:	01 96       	adiw	r24, 0x01	; 1
    4270:	84 36       	cpi	r24, 0x64	; 100
    4272:	91 05       	cpc	r25, r1
    4274:	28 f4       	brcc	.+10     	; 0x4280 <__vector_58+0x8e>
    4276:	80 93 3c 32 	sts	0x323C, r24	; 0x80323c <rcvE0_read_index>
    427a:	90 93 3d 32 	sts	0x323D, r25	; 0x80323d <rcvE0_read_index+0x1>
    427e:	08 c0       	rjmp	.+16     	; 0x4290 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    4280:	10 92 3c 32 	sts	0x323C, r1	; 0x80323c <rcvE0_read_index>
    4284:	10 92 3d 32 	sts	0x323D, r1	; 0x80323d <rcvE0_read_index+0x1>
}
    4288:	03 c0       	rjmp	.+6      	; 0x4290 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    428a:	81 e0       	ldi	r24, 0x01	; 1
    428c:	90 e0       	ldi	r25, 0x00	; 0
    428e:	f3 cf       	rjmp	.-26     	; 0x4276 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    4290:	ff 91       	pop	r31
    4292:	ef 91       	pop	r30
    4294:	9f 91       	pop	r25
    4296:	8f 91       	pop	r24
    4298:	3f 91       	pop	r19
    429a:	2f 91       	pop	r18
    429c:	0f 90       	pop	r0
    429e:	0b be       	out	0x3b, r0	; 59
    42a0:	0f 90       	pop	r0
    42a2:	08 be       	out	0x38, r0	; 56
    42a4:	0f 90       	pop	r0
    42a6:	0f be       	out	0x3f, r0	; 63
    42a8:	0f 90       	pop	r0
    42aa:	1f 90       	pop	r1
    42ac:	18 95       	reti

000042ae <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    42ae:	fc 01       	movw	r30, r24
    42b0:	84 81       	ldd	r24, Z+4	; 0x04
    42b2:	95 81       	ldd	r25, Z+5	; 0x05
    42b4:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
		}
    42b8:	90 e0       	ldi	r25, 0x00	; 0
    42ba:	08 95       	ret

000042bc <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    42bc:	fc 01       	movw	r30, r24
    42be:	84 81       	ldd	r24, Z+4	; 0x04
    42c0:	95 81       	ldd	r25, Z+5	; 0x05
    42c2:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    42c6:	91 e0       	ldi	r25, 0x01	; 1
    42c8:	81 11       	cpse	r24, r1
    42ca:	01 c0       	rjmp	.+2      	; 0x42ce <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    42cc:	90 e0       	ldi	r25, 0x00	; 0
		}
    42ce:	89 2f       	mov	r24, r25
    42d0:	08 95       	ret

000042d2 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    42d2:	fc 01       	movw	r30, r24
    42d4:	84 81       	ldd	r24, Z+4	; 0x04
    42d6:	95 81       	ldd	r25, Z+5	; 0x05
    42d8:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    42dc:	91 e0       	ldi	r25, 0x01	; 1
    42de:	81 11       	cpse	r24, r1
    42e0:	90 e0       	ldi	r25, 0x00	; 0
		}
    42e2:	89 2f       	mov	r24, r25
    42e4:	08 95       	ret

000042e6 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    42e6:	fc 01       	movw	r30, r24
    42e8:	84 81       	ldd	r24, Z+4	; 0x04
    42ea:	95 81       	ldd	r25, Z+5	; 0x05
    42ec:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
		}
    42f0:	90 e0       	ldi	r25, 0x00	; 0
    42f2:	08 95       	ret

000042f4 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    42f4:	fc 01       	movw	r30, r24
    42f6:	84 81       	ldd	r24, Z+4	; 0x04
    42f8:	95 81       	ldd	r25, Z+5	; 0x05
    42fa:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    42fe:	91 e0       	ldi	r25, 0x01	; 1
    4300:	81 11       	cpse	r24, r1
    4302:	01 c0       	rjmp	.+2      	; 0x4306 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    4304:	90 e0       	ldi	r25, 0x00	; 0
		}
    4306:	89 2f       	mov	r24, r25
    4308:	08 95       	ret

0000430a <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    430a:	fc 01       	movw	r30, r24
    430c:	84 81       	ldd	r24, Z+4	; 0x04
    430e:	95 81       	ldd	r25, Z+5	; 0x05
    4310:	0e 94 89 12 	call	0x2512	; 0x2512 <uxQueueMessagesWaitingFromISR>
    4314:	91 e0       	ldi	r25, 0x01	; 1
    4316:	81 11       	cpse	r24, r1
    4318:	90 e0       	ldi	r25, 0x00	; 0
		}
    431a:	89 2f       	mov	r24, r25
    431c:	08 95       	ret

0000431e <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    431e:	fc 01       	movw	r30, r24
    4320:	84 81       	ldd	r24, Z+4	; 0x04
    4322:	95 81       	ldd	r25, Z+5	; 0x05
    4324:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
		}
    4328:	90 e0       	ldi	r25, 0x00	; 0
    432a:	08 95       	ret

0000432c <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    432c:	fc 01       	movw	r30, r24
    432e:	84 81       	ldd	r24, Z+4	; 0x04
    4330:	95 81       	ldd	r25, Z+5	; 0x05
    4332:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    4336:	91 e0       	ldi	r25, 0x01	; 1
    4338:	81 11       	cpse	r24, r1
    433a:	01 c0       	rjmp	.+2      	; 0x433e <_ZN9frt_queueIjE9not_emptyEv+0x12>
    433c:	90 e0       	ldi	r25, 0x00	; 0
		}
    433e:	89 2f       	mov	r24, r25
    4340:	08 95       	ret

00004342 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4342:	fc 01       	movw	r30, r24
    4344:	84 81       	ldd	r24, Z+4	; 0x04
    4346:	95 81       	ldd	r25, Z+5	; 0x05
    4348:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    434c:	91 e0       	ldi	r25, 0x01	; 1
    434e:	81 11       	cpse	r24, r1
    4350:	90 e0       	ldi	r25, 0x00	; 0
		}
    4352:	89 2f       	mov	r24, r25
    4354:	08 95       	ret

00004356 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4356:	fc 01       	movw	r30, r24
    4358:	84 81       	ldd	r24, Z+4	; 0x04
    435a:	95 81       	ldd	r25, Z+5	; 0x05
    435c:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
		}
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	08 95       	ret

00004364 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4364:	fc 01       	movw	r30, r24
    4366:	84 81       	ldd	r24, Z+4	; 0x04
    4368:	95 81       	ldd	r25, Z+5	; 0x05
    436a:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    436e:	91 e0       	ldi	r25, 0x01	; 1
    4370:	81 11       	cpse	r24, r1
    4372:	01 c0       	rjmp	.+2      	; 0x4376 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4374:	90 e0       	ldi	r25, 0x00	; 0
		}
    4376:	89 2f       	mov	r24, r25
    4378:	08 95       	ret

0000437a <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    437a:	fc 01       	movw	r30, r24
    437c:	84 81       	ldd	r24, Z+4	; 0x04
    437e:	95 81       	ldd	r25, Z+5	; 0x05
    4380:	0e 94 81 12 	call	0x2502	; 0x2502 <uxQueueMessagesWaiting>
    4384:	91 e0       	ldi	r25, 0x01	; 1
    4386:	81 11       	cpse	r24, r1
    4388:	90 e0       	ldi	r25, 0x00	; 0
		}
    438a:	89 2f       	mov	r24, r25
    438c:	08 95       	ret

0000438e <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    438e:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4390:	01 e0       	ldi	r16, 0x01	; 1
    4392:	2f ef       	ldi	r18, 0xFF	; 255
    4394:	3f ef       	ldi	r19, 0xFF	; 255
    4396:	a9 01       	movw	r20, r18
    4398:	fc 01       	movw	r30, r24
    439a:	84 81       	ldd	r24, Z+4	; 0x04
    439c:	95 81       	ldd	r25, Z+5	; 0x05
    439e:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
}
    43a2:	0f 91       	pop	r16
    43a4:	08 95       	ret

000043a6 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    43a6:	0f 93       	push	r16
    43a8:	cf 93       	push	r28
    43aa:	df 93       	push	r29
    43ac:	1f 92       	push	r1
    43ae:	1f 92       	push	r1
    43b0:	cd b7       	in	r28, 0x3d	; 61
    43b2:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    43b4:	01 e0       	ldi	r16, 0x01	; 1
    43b6:	2f ef       	ldi	r18, 0xFF	; 255
    43b8:	3f ef       	ldi	r19, 0xFF	; 255
    43ba:	a9 01       	movw	r20, r18
    43bc:	be 01       	movw	r22, r28
    43be:	6f 5f       	subi	r22, 0xFF	; 255
    43c0:	7f 4f       	sbci	r23, 0xFF	; 255
    43c2:	fc 01       	movw	r30, r24
    43c4:	84 81       	ldd	r24, Z+4	; 0x04
    43c6:	95 81       	ldd	r25, Z+5	; 0x05
    43c8:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
	return (recv_item);
}
    43cc:	89 81       	ldd	r24, Y+1	; 0x01
    43ce:	9a 81       	ldd	r25, Y+2	; 0x02
    43d0:	0f 90       	pop	r0
    43d2:	0f 90       	pop	r0
    43d4:	df 91       	pop	r29
    43d6:	cf 91       	pop	r28
    43d8:	0f 91       	pop	r16
    43da:	08 95       	ret

000043dc <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    43dc:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    43de:	00 e0       	ldi	r16, 0x00	; 0
    43e0:	2f ef       	ldi	r18, 0xFF	; 255
    43e2:	3f ef       	ldi	r19, 0xFF	; 255
    43e4:	a9 01       	movw	r20, r18
    43e6:	fc 01       	movw	r30, r24
    43e8:	84 81       	ldd	r24, Z+4	; 0x04
    43ea:	95 81       	ldd	r25, Z+5	; 0x05
    43ec:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
}
    43f0:	0f 91       	pop	r16
    43f2:	08 95       	ret

000043f4 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    43f4:	0f 93       	push	r16
    43f6:	cf 93       	push	r28
    43f8:	df 93       	push	r29
    43fa:	1f 92       	push	r1
    43fc:	1f 92       	push	r1
    43fe:	cd b7       	in	r28, 0x3d	; 61
    4400:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4402:	00 e0       	ldi	r16, 0x00	; 0
    4404:	2f ef       	ldi	r18, 0xFF	; 255
    4406:	3f ef       	ldi	r19, 0xFF	; 255
    4408:	a9 01       	movw	r20, r18
    440a:	be 01       	movw	r22, r28
    440c:	6f 5f       	subi	r22, 0xFF	; 255
    440e:	7f 4f       	sbci	r23, 0xFF	; 255
    4410:	fc 01       	movw	r30, r24
    4412:	84 81       	ldd	r24, Z+4	; 0x04
    4414:	95 81       	ldd	r25, Z+5	; 0x05
    4416:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
	return (recv_item);
}
    441a:	89 81       	ldd	r24, Y+1	; 0x01
    441c:	9a 81       	ldd	r25, Y+2	; 0x02
    441e:	0f 90       	pop	r0
    4420:	0f 90       	pop	r0
    4422:	df 91       	pop	r29
    4424:	cf 91       	pop	r28
    4426:	0f 91       	pop	r16
    4428:	08 95       	ret

0000442a <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    442a:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    442c:	01 e0       	ldi	r16, 0x01	; 1
    442e:	2f ef       	ldi	r18, 0xFF	; 255
    4430:	3f ef       	ldi	r19, 0xFF	; 255
    4432:	a9 01       	movw	r20, r18
    4434:	fc 01       	movw	r30, r24
    4436:	84 81       	ldd	r24, Z+4	; 0x04
    4438:	95 81       	ldd	r25, Z+5	; 0x05
    443a:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
}
    443e:	0f 91       	pop	r16
    4440:	08 95       	ret

00004442 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4442:	0f 93       	push	r16
    4444:	cf 93       	push	r28
    4446:	df 93       	push	r29
    4448:	1f 92       	push	r1
    444a:	1f 92       	push	r1
    444c:	cd b7       	in	r28, 0x3d	; 61
    444e:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4450:	01 e0       	ldi	r16, 0x01	; 1
    4452:	2f ef       	ldi	r18, 0xFF	; 255
    4454:	3f ef       	ldi	r19, 0xFF	; 255
    4456:	a9 01       	movw	r20, r18
    4458:	be 01       	movw	r22, r28
    445a:	6f 5f       	subi	r22, 0xFF	; 255
    445c:	7f 4f       	sbci	r23, 0xFF	; 255
    445e:	fc 01       	movw	r30, r24
    4460:	84 81       	ldd	r24, Z+4	; 0x04
    4462:	95 81       	ldd	r25, Z+5	; 0x05
    4464:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
	return (recv_item);
}
    4468:	89 81       	ldd	r24, Y+1	; 0x01
    446a:	9a 81       	ldd	r25, Y+2	; 0x02
    446c:	0f 90       	pop	r0
    446e:	0f 90       	pop	r0
    4470:	df 91       	pop	r29
    4472:	cf 91       	pop	r28
    4474:	0f 91       	pop	r16
    4476:	08 95       	ret

00004478 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4478:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    447a:	00 e0       	ldi	r16, 0x00	; 0
    447c:	2f ef       	ldi	r18, 0xFF	; 255
    447e:	3f ef       	ldi	r19, 0xFF	; 255
    4480:	a9 01       	movw	r20, r18
    4482:	fc 01       	movw	r30, r24
    4484:	84 81       	ldd	r24, Z+4	; 0x04
    4486:	95 81       	ldd	r25, Z+5	; 0x05
    4488:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
}
    448c:	0f 91       	pop	r16
    448e:	08 95       	ret

00004490 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4490:	0f 93       	push	r16
    4492:	cf 93       	push	r28
    4494:	df 93       	push	r29
    4496:	1f 92       	push	r1
    4498:	1f 92       	push	r1
    449a:	cd b7       	in	r28, 0x3d	; 61
    449c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    449e:	00 e0       	ldi	r16, 0x00	; 0
    44a0:	2f ef       	ldi	r18, 0xFF	; 255
    44a2:	3f ef       	ldi	r19, 0xFF	; 255
    44a4:	a9 01       	movw	r20, r18
    44a6:	be 01       	movw	r22, r28
    44a8:	6f 5f       	subi	r22, 0xFF	; 255
    44aa:	7f 4f       	sbci	r23, 0xFF	; 255
    44ac:	fc 01       	movw	r30, r24
    44ae:	84 81       	ldd	r24, Z+4	; 0x04
    44b0:	95 81       	ldd	r25, Z+5	; 0x05
    44b2:	0e 94 90 11 	call	0x2320	; 0x2320 <xQueueGenericReceive>
	return (recv_item);
}
    44b6:	89 81       	ldd	r24, Y+1	; 0x01
    44b8:	9a 81       	ldd	r25, Y+2	; 0x02
    44ba:	0f 90       	pop	r0
    44bc:	0f 90       	pop	r0
    44be:	df 91       	pop	r29
    44c0:	cf 91       	pop	r28
    44c2:	0f 91       	pop	r16
    44c4:	08 95       	ret

000044c6 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    44c6:	cf 93       	push	r28
    44c8:	df 93       	push	r29
    44ca:	1f 92       	push	r1
    44cc:	cd b7       	in	r28, 0x3d	; 61
    44ce:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    44d0:	ae 01       	movw	r20, r28
    44d2:	4f 5f       	subi	r20, 0xFF	; 255
    44d4:	5f 4f       	sbci	r21, 0xFF	; 255
    44d6:	fc 01       	movw	r30, r24
    44d8:	84 81       	ldd	r24, Z+4	; 0x04
    44da:	95 81       	ldd	r25, Z+5	; 0x05
    44dc:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
}
    44e0:	0f 90       	pop	r0
    44e2:	df 91       	pop	r29
    44e4:	cf 91       	pop	r28
    44e6:	08 95       	ret

000044e8 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    44e8:	cf 93       	push	r28
    44ea:	df 93       	push	r29
    44ec:	00 d0       	rcall	.+0      	; 0x44ee <_ZN9frt_queueIjE7ISR_getEv+0x6>
    44ee:	cd b7       	in	r28, 0x3d	; 61
    44f0:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    44f2:	ae 01       	movw	r20, r28
    44f4:	4d 5f       	subi	r20, 0xFD	; 253
    44f6:	5f 4f       	sbci	r21, 0xFF	; 255
    44f8:	be 01       	movw	r22, r28
    44fa:	6f 5f       	subi	r22, 0xFF	; 255
    44fc:	7f 4f       	sbci	r23, 0xFF	; 255
    44fe:	fc 01       	movw	r30, r24
    4500:	84 81       	ldd	r24, Z+4	; 0x04
    4502:	95 81       	ldd	r25, Z+5	; 0x05
    4504:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
	return (recv_item);
}
    4508:	89 81       	ldd	r24, Y+1	; 0x01
    450a:	9a 81       	ldd	r25, Y+2	; 0x02
    450c:	23 96       	adiw	r28, 0x03	; 3
    450e:	cd bf       	out	0x3d, r28	; 61
    4510:	de bf       	out	0x3e, r29	; 62
    4512:	df 91       	pop	r29
    4514:	cf 91       	pop	r28
    4516:	08 95       	ret

00004518 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4518:	cf 93       	push	r28
    451a:	df 93       	push	r29
    451c:	1f 92       	push	r1
    451e:	cd b7       	in	r28, 0x3d	; 61
    4520:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4522:	ae 01       	movw	r20, r28
    4524:	4f 5f       	subi	r20, 0xFF	; 255
    4526:	5f 4f       	sbci	r21, 0xFF	; 255
    4528:	fc 01       	movw	r30, r24
    452a:	84 81       	ldd	r24, Z+4	; 0x04
    452c:	95 81       	ldd	r25, Z+5	; 0x05
    452e:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
}
    4532:	0f 90       	pop	r0
    4534:	df 91       	pop	r29
    4536:	cf 91       	pop	r28
    4538:	08 95       	ret

0000453a <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    453a:	cf 93       	push	r28
    453c:	df 93       	push	r29
    453e:	00 d0       	rcall	.+0      	; 0x4540 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4540:	cd b7       	in	r28, 0x3d	; 61
    4542:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4544:	ae 01       	movw	r20, r28
    4546:	4d 5f       	subi	r20, 0xFD	; 253
    4548:	5f 4f       	sbci	r21, 0xFF	; 255
    454a:	be 01       	movw	r22, r28
    454c:	6f 5f       	subi	r22, 0xFF	; 255
    454e:	7f 4f       	sbci	r23, 0xFF	; 255
    4550:	fc 01       	movw	r30, r24
    4552:	84 81       	ldd	r24, Z+4	; 0x04
    4554:	95 81       	ldd	r25, Z+5	; 0x05
    4556:	0e 94 54 12 	call	0x24a8	; 0x24a8 <xQueueReceiveFromISR>
	return (recv_item);
}
    455a:	89 81       	ldd	r24, Y+1	; 0x01
    455c:	9a 81       	ldd	r25, Y+2	; 0x02
    455e:	23 96       	adiw	r28, 0x03	; 3
    4560:	cd bf       	out	0x3d, r28	; 61
    4562:	de bf       	out	0x3e, r29	; 62
    4564:	df 91       	pop	r29
    4566:	cf 91       	pop	r28
    4568:	08 95       	ret

0000456a <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    456a:	cf 93       	push	r28
    456c:	df 93       	push	r29
    456e:	1f 92       	push	r1
    4570:	cd b7       	in	r28, 0x3d	; 61
    4572:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4574:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4576:	21 e0       	ldi	r18, 0x01	; 1
    4578:	ae 01       	movw	r20, r28
    457a:	4f 5f       	subi	r20, 0xFF	; 255
    457c:	5f 4f       	sbci	r21, 0xFF	; 255
    457e:	fc 01       	movw	r30, r24
    4580:	84 81       	ldd	r24, Z+4	; 0x04
    4582:	95 81       	ldd	r25, Z+5	; 0x05
    4584:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4588:	91 e0       	ldi	r25, 0x01	; 1
    458a:	81 11       	cpse	r24, r1
    458c:	01 c0       	rjmp	.+2      	; 0x4590 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    458e:	90 e0       	ldi	r25, 0x00	; 0
}
    4590:	89 2f       	mov	r24, r25
    4592:	0f 90       	pop	r0
    4594:	df 91       	pop	r29
    4596:	cf 91       	pop	r28
    4598:	08 95       	ret

0000459a <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    459a:	cf 93       	push	r28
    459c:	df 93       	push	r29
    459e:	1f 92       	push	r1
    45a0:	cd b7       	in	r28, 0x3d	; 61
    45a2:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    45a4:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    45a6:	20 e0       	ldi	r18, 0x00	; 0
    45a8:	ae 01       	movw	r20, r28
    45aa:	4f 5f       	subi	r20, 0xFF	; 255
    45ac:	5f 4f       	sbci	r21, 0xFF	; 255
    45ae:	fc 01       	movw	r30, r24
    45b0:	84 81       	ldd	r24, Z+4	; 0x04
    45b2:	95 81       	ldd	r25, Z+5	; 0x05
    45b4:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    45b8:	91 e0       	ldi	r25, 0x01	; 1
    45ba:	81 11       	cpse	r24, r1
    45bc:	01 c0       	rjmp	.+2      	; 0x45c0 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    45be:	90 e0       	ldi	r25, 0x00	; 0
}
    45c0:	89 2f       	mov	r24, r25
    45c2:	0f 90       	pop	r0
    45c4:	df 91       	pop	r29
    45c6:	cf 91       	pop	r28
    45c8:	08 95       	ret

000045ca <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    45ca:	cf 93       	push	r28
    45cc:	df 93       	push	r29
    45ce:	1f 92       	push	r1
    45d0:	cd b7       	in	r28, 0x3d	; 61
    45d2:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    45d4:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    45d6:	21 e0       	ldi	r18, 0x01	; 1
    45d8:	ae 01       	movw	r20, r28
    45da:	4f 5f       	subi	r20, 0xFF	; 255
    45dc:	5f 4f       	sbci	r21, 0xFF	; 255
    45de:	fc 01       	movw	r30, r24
    45e0:	84 81       	ldd	r24, Z+4	; 0x04
    45e2:	95 81       	ldd	r25, Z+5	; 0x05
    45e4:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    45e8:	91 e0       	ldi	r25, 0x01	; 1
    45ea:	81 11       	cpse	r24, r1
    45ec:	01 c0       	rjmp	.+2      	; 0x45f0 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    45ee:	90 e0       	ldi	r25, 0x00	; 0
}
    45f0:	89 2f       	mov	r24, r25
    45f2:	0f 90       	pop	r0
    45f4:	df 91       	pop	r29
    45f6:	cf 91       	pop	r28
    45f8:	08 95       	ret

000045fa <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    45fa:	cf 93       	push	r28
    45fc:	df 93       	push	r29
    45fe:	1f 92       	push	r1
    4600:	cd b7       	in	r28, 0x3d	; 61
    4602:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4604:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4606:	20 e0       	ldi	r18, 0x00	; 0
    4608:	ae 01       	movw	r20, r28
    460a:	4f 5f       	subi	r20, 0xFF	; 255
    460c:	5f 4f       	sbci	r21, 0xFF	; 255
    460e:	fc 01       	movw	r30, r24
    4610:	84 81       	ldd	r24, Z+4	; 0x04
    4612:	95 81       	ldd	r25, Z+5	; 0x05
    4614:	0e 94 64 11 	call	0x22c8	; 0x22c8 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4618:	91 e0       	ldi	r25, 0x01	; 1
    461a:	81 11       	cpse	r24, r1
    461c:	01 c0       	rjmp	.+2      	; 0x4620 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    461e:	90 e0       	ldi	r25, 0x00	; 0
}
    4620:	89 2f       	mov	r24, r25
    4622:	0f 90       	pop	r0
    4624:	df 91       	pop	r29
    4626:	cf 91       	pop	r28
    4628:	08 95       	ret

0000462a <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    462a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    462c:	fc 01       	movw	r30, r24
    462e:	26 81       	ldd	r18, Z+6	; 0x06
    4630:	37 81       	ldd	r19, Z+7	; 0x07
    4632:	40 85       	ldd	r20, Z+8	; 0x08
    4634:	51 85       	ldd	r21, Z+9	; 0x09
    4636:	01 e0       	ldi	r16, 0x01	; 1
    4638:	84 81       	ldd	r24, Z+4	; 0x04
    463a:	95 81       	ldd	r25, Z+5	; 0x05
    463c:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    4640:	91 e0       	ldi	r25, 0x01	; 1
    4642:	81 11       	cpse	r24, r1
    4644:	01 c0       	rjmp	.+2      	; 0x4648 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4646:	90 e0       	ldi	r25, 0x00	; 0
		}
    4648:	89 2f       	mov	r24, r25
    464a:	0f 91       	pop	r16
    464c:	08 95       	ret

0000464e <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    464e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4650:	fc 01       	movw	r30, r24
    4652:	26 81       	ldd	r18, Z+6	; 0x06
    4654:	37 81       	ldd	r19, Z+7	; 0x07
    4656:	40 85       	ldd	r20, Z+8	; 0x08
    4658:	51 85       	ldd	r21, Z+9	; 0x09
    465a:	00 e0       	ldi	r16, 0x00	; 0
    465c:	84 81       	ldd	r24, Z+4	; 0x04
    465e:	95 81       	ldd	r25, Z+5	; 0x05
    4660:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    4664:	91 e0       	ldi	r25, 0x01	; 1
    4666:	81 11       	cpse	r24, r1
    4668:	01 c0       	rjmp	.+2      	; 0x466c <_ZN9frt_queueIjE3putERKj+0x1e>
    466a:	90 e0       	ldi	r25, 0x00	; 0
		}
    466c:	89 2f       	mov	r24, r25
    466e:	0f 91       	pop	r16
    4670:	08 95       	ret

00004672 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4672:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4674:	fc 01       	movw	r30, r24
    4676:	26 81       	ldd	r18, Z+6	; 0x06
    4678:	37 81       	ldd	r19, Z+7	; 0x07
    467a:	40 85       	ldd	r20, Z+8	; 0x08
    467c:	51 85       	ldd	r21, Z+9	; 0x09
    467e:	01 e0       	ldi	r16, 0x01	; 1
    4680:	84 81       	ldd	r24, Z+4	; 0x04
    4682:	95 81       	ldd	r25, Z+5	; 0x05
    4684:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    4688:	91 e0       	ldi	r25, 0x01	; 1
    468a:	81 11       	cpse	r24, r1
    468c:	01 c0       	rjmp	.+2      	; 0x4690 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    468e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4690:	89 2f       	mov	r24, r25
    4692:	0f 91       	pop	r16
    4694:	08 95       	ret

00004696 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4696:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4698:	fc 01       	movw	r30, r24
    469a:	26 81       	ldd	r18, Z+6	; 0x06
    469c:	37 81       	ldd	r19, Z+7	; 0x07
    469e:	40 85       	ldd	r20, Z+8	; 0x08
    46a0:	51 85       	ldd	r21, Z+9	; 0x09
    46a2:	00 e0       	ldi	r16, 0x00	; 0
    46a4:	84 81       	ldd	r24, Z+4	; 0x04
    46a6:	95 81       	ldd	r25, Z+5	; 0x05
    46a8:	0e 94 c9 10 	call	0x2192	; 0x2192 <xQueueGenericSend>
    46ac:	91 e0       	ldi	r25, 0x01	; 1
    46ae:	81 11       	cpse	r24, r1
    46b0:	01 c0       	rjmp	.+2      	; 0x46b4 <_ZN9frt_queueIiE3putERKi+0x1e>
    46b2:	90 e0       	ldi	r25, 0x00	; 0
		}
    46b4:	89 2f       	mov	r24, r25
    46b6:	0f 91       	pop	r16
    46b8:	08 95       	ret

000046ba <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    46ba:	0f 93       	push	r16
    46bc:	cf 93       	push	r28
    46be:	df 93       	push	r29
    46c0:	1f 92       	push	r1
    46c2:	cd b7       	in	r28, 0x3d	; 61
    46c4:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    46c6:	2f b7       	in	r18, 0x3f	; 63
    46c8:	29 83       	std	Y+1, r18	; 0x01
	cli();
    46ca:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    46cc:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    46ce:	fc 01       	movw	r30, r24
    46d0:	08 ed       	ldi	r16, 0xD8	; 216
    46d2:	04 bf       	out	0x34, r16	; 52
    46d4:	60 83       	st	Z, r22

	SREG = saved_sreg;
    46d6:	89 81       	ldd	r24, Y+1	; 0x01
    46d8:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    46da:	0f 90       	pop	r0
    46dc:	df 91       	pop	r29
    46de:	cf 91       	pop	r28
    46e0:	0f 91       	pop	r16
    46e2:	08 95       	ret

000046e4 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    46e4:	ef 92       	push	r14
    46e6:	ff 92       	push	r15
    46e8:	0f 93       	push	r16
    46ea:	1f 93       	push	r17
    46ec:	cf 93       	push	r28
    46ee:	df 93       	push	r29
    46f0:	cd b7       	in	r28, 0x3d	; 61
    46f2:	de b7       	in	r29, 0x3e	; 62
    46f4:	c5 54       	subi	r28, 0x45	; 69
    46f6:	d1 09       	sbc	r29, r1
    46f8:	cd bf       	out	0x3d, r28	; 61
    46fa:	de bf       	out	0x3e, r29	; 62
	cli();
    46fc:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    46fe:	e0 e5       	ldi	r30, 0x50	; 80
    4700:	f0 e0       	ldi	r31, 0x00	; 0
    4702:	80 81       	ld	r24, Z
    4704:	82 60       	ori	r24, 0x02	; 2
    4706:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4708:	81 81       	ldd	r24, Z+1	; 0x01
    470a:	81 ff       	sbrs	r24, 1
    470c:	fd cf       	rjmp	.-6      	; 0x4708 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    470e:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4712:	68 7f       	andi	r22, 0xF8	; 248
    4714:	61 60       	ori	r22, 0x01	; 1
    4716:	80 e4       	ldi	r24, 0x40	; 64
    4718:	90 e0       	ldi	r25, 0x00	; 0
    471a:	0e 94 5d 23 	call	0x46ba	; 0x46ba <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    471e:	e0 e5       	ldi	r30, 0x50	; 80
    4720:	f0 e0       	ldi	r31, 0x00	; 0
    4722:	80 81       	ld	r24, Z
    4724:	8e 7f       	andi	r24, 0xFE	; 254
    4726:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4728:	9d ef       	ldi	r25, 0xFD	; 253
    472a:	88 ed       	ldi	r24, 0xD8	; 216
    472c:	08 b6       	in	r0, 0x38	; 56
    472e:	18 be       	out	0x38, r1	; 56
    4730:	84 bf       	out	0x34, r24	; 52
    4732:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4736:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4738:	40 ea       	ldi	r20, 0xA0	; 160
    473a:	5a e0       	ldi	r21, 0x0A	; 10
    473c:	60 e0       	ldi	r22, 0x00	; 0
    473e:	70 e0       	ldi	r23, 0x00	; 0
    4740:	ce 01       	movw	r24, r28
    4742:	01 96       	adiw	r24, 0x01	; 1
    4744:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4748:	67 e0       	ldi	r22, 0x07	; 7
    474a:	ce 01       	movw	r24, r28
    474c:	01 96       	adiw	r24, 0x01	; 1
    474e:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    4752:	8c 01       	movw	r16, r24
    4754:	60 e5       	ldi	r22, 0x50	; 80
    4756:	71 e2       	ldi	r23, 0x21	; 33
    4758:	0e 94 27 1d 	call	0x3a4e	; 0x3a4e <_ZN8emstream4putsEPKc>
    475c:	66 e0       	ldi	r22, 0x06	; 6
    475e:	c8 01       	movw	r24, r16
    4760:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
    4764:	66 e0       	ldi	r22, 0x06	; 6
    4766:	0e 94 5e 1d 	call	0x3abc	; 0x3abc <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    476a:	8e 01       	movw	r16, r28
    476c:	0f 5f       	subi	r16, 0xFF	; 255
    476e:	1f 4f       	sbci	r17, 0xFF	; 255
    4770:	20 e3       	ldi	r18, 0x30	; 48
    4772:	32 ef       	ldi	r19, 0xF2	; 242
    4774:	40 e0       	ldi	r20, 0x00	; 0
    4776:	50 e0       	ldi	r21, 0x00	; 0
    4778:	60 ea       	ldi	r22, 0xA0	; 160
    477a:	74 e0       	ldi	r23, 0x04	; 4
    477c:	ce 01       	movw	r24, r28
    477e:	4e 96       	adiw	r24, 0x1e	; 30
    4780:	0e 94 62 07 	call	0xec4	; 0xec4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c);
    4784:	be 01       	movw	r22, r28
    4786:	62 5e       	subi	r22, 0xE2	; 226
    4788:	7f 4f       	sbci	r23, 0xFF	; 255
    478a:	ce 01       	movw	r24, r28
    478c:	c7 96       	adiw	r24, 0x37	; 55
    478e:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4792:	82 e1       	ldi	r24, 0x12	; 18
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
    479a:	20 e8       	ldi	r18, 0x80	; 128
    479c:	30 e0       	ldi	r19, 0x00	; 0
    479e:	40 e0       	ldi	r20, 0x00	; 0
    47a0:	6f e6       	ldi	r22, 0x6F	; 111
    47a2:	71 e2       	ldi	r23, 0x21	; 33
    47a4:	0e 94 45 0a 	call	0x148a	; 0x148a <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    47a8:	88 e1       	ldi	r24, 0x18	; 24
    47aa:	90 e0       	ldi	r25, 0x00	; 0
    47ac:	0e 94 73 1c 	call	0x38e6	; 0x38e6 <_Znwj>
    47b0:	9e 01       	movw	r18, r28
    47b2:	29 5c       	subi	r18, 0xC9	; 201
    47b4:	3f 4f       	sbci	r19, 0xFF	; 255
    47b6:	79 01       	movw	r14, r18
    47b8:	20 e8       	ldi	r18, 0x80	; 128
    47ba:	30 e0       	ldi	r19, 0x00	; 0
    47bc:	42 e0       	ldi	r20, 0x02	; 2
    47be:	67 e7       	ldi	r22, 0x77	; 119
    47c0:	71 e2       	ldi	r23, 0x21	; 33
    47c2:	0e 94 28 0a 	call	0x1450	; 0x1450 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    47c6:	87 e0       	ldi	r24, 0x07	; 7
    47c8:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    47cc:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    47ce:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <vTaskStartScheduler>
}
    47d2:	80 e0       	ldi	r24, 0x00	; 0
    47d4:	90 e0       	ldi	r25, 0x00	; 0
    47d6:	cb 5b       	subi	r28, 0xBB	; 187
    47d8:	df 4f       	sbci	r29, 0xFF	; 255
    47da:	cd bf       	out	0x3d, r28	; 61
    47dc:	de bf       	out	0x3e, r29	; 62
    47de:	df 91       	pop	r29
    47e0:	cf 91       	pop	r28
    47e2:	1f 91       	pop	r17
    47e4:	0f 91       	pop	r16
    47e6:	ff 90       	pop	r15
    47e8:	ef 90       	pop	r14
    47ea:	08 95       	ret

000047ec <_GLOBAL__sub_I_counter>:
    47ec:	cf 92       	push	r12
    47ee:	df 92       	push	r13
    47f0:	ef 92       	push	r14
    47f2:	ff 92       	push	r15
    47f4:	0f 93       	push	r16
    47f6:	1f 93       	push	r17
    47f8:	cf 93       	push	r28
    47fa:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    47fc:	0a e0       	ldi	r16, 0x0A	; 10
    47fe:	10 e0       	ldi	r17, 0x00	; 0
    4800:	20 e0       	ldi	r18, 0x00	; 0
    4802:	30 e0       	ldi	r19, 0x00	; 0
    4804:	40 e0       	ldi	r20, 0x00	; 0
    4806:	50 e0       	ldi	r21, 0x00	; 0
    4808:	60 e2       	ldi	r22, 0x20	; 32
    480a:	70 e0       	ldi	r23, 0x00	; 0
    480c:	82 e8       	ldi	r24, 0x82	; 130
    480e:	92 e3       	ldi	r25, 0x32	; 50
    4810:	0e 94 df 1a 	call	0x35be	; 0x35be <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4814:	c8 e7       	ldi	r28, 0x78	; 120
    4816:	d2 e3       	ldi	r29, 0x32	; 50
    4818:	1a 82       	std	Y+2, r1	; 0x02
    481a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    481c:	81 e8       	ldi	r24, 0x81	; 129
    481e:	91 e2       	ldi	r25, 0x21	; 33
    4820:	88 83       	st	Y, r24
    4822:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4824:	40 e0       	ldi	r20, 0x00	; 0
    4826:	62 e0       	ldi	r22, 0x02	; 2
    4828:	8f ef       	ldi	r24, 0xFF	; 255
    482a:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    482e:	8c 83       	std	Y+4, r24	; 0x04
    4830:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4832:	0f 2e       	mov	r0, r31
    4834:	fa e0       	ldi	r31, 0x0A	; 10
    4836:	cf 2e       	mov	r12, r31
    4838:	d1 2c       	mov	r13, r1
    483a:	e1 2c       	mov	r14, r1
    483c:	f1 2c       	mov	r15, r1
    483e:	f0 2d       	mov	r31, r0
    4840:	ce 82       	std	Y+6, r12	; 0x06
    4842:	df 82       	std	Y+7, r13	; 0x07
    4844:	e8 86       	std	Y+8, r14	; 0x08
    4846:	f9 86       	std	Y+9, r15	; 0x09
    4848:	ce e6       	ldi	r28, 0x6E	; 110
    484a:	d2 e3       	ldi	r29, 0x32	; 50
    484c:	1a 82       	std	Y+2, r1	; 0x02
    484e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4850:	05 ea       	ldi	r16, 0xA5	; 165
    4852:	11 e2       	ldi	r17, 0x21	; 33
    4854:	08 83       	st	Y, r16
    4856:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4858:	40 e0       	ldi	r20, 0x00	; 0
    485a:	62 e0       	ldi	r22, 0x02	; 2
    485c:	8f ef       	ldi	r24, 0xFF	; 255
    485e:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    4862:	8c 83       	std	Y+4, r24	; 0x04
    4864:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4866:	ce 82       	std	Y+6, r12	; 0x06
    4868:	df 82       	std	Y+7, r13	; 0x07
    486a:	e8 86       	std	Y+8, r14	; 0x08
    486c:	f9 86       	std	Y+9, r15	; 0x09
    486e:	c4 e6       	ldi	r28, 0x64	; 100
    4870:	d2 e3       	ldi	r29, 0x32	; 50
    4872:	1a 82       	std	Y+2, r1	; 0x02
    4874:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4876:	08 83       	st	Y, r16
    4878:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    487a:	40 e0       	ldi	r20, 0x00	; 0
    487c:	62 e0       	ldi	r22, 0x02	; 2
    487e:	8f ef       	ldi	r24, 0xFF	; 255
    4880:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    4884:	8c 83       	std	Y+4, r24	; 0x04
    4886:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4888:	ce 82       	std	Y+6, r12	; 0x06
    488a:	df 82       	std	Y+7, r13	; 0x07
    488c:	e8 86       	std	Y+8, r14	; 0x08
    488e:	f9 86       	std	Y+9, r15	; 0x09
    4890:	ca e5       	ldi	r28, 0x5A	; 90
    4892:	d2 e3       	ldi	r29, 0x32	; 50
    4894:	1a 82       	std	Y+2, r1	; 0x02
    4896:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4898:	08 83       	st	Y, r16
    489a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    489c:	40 e0       	ldi	r20, 0x00	; 0
    489e:	62 e0       	ldi	r22, 0x02	; 2
    48a0:	8f ef       	ldi	r24, 0xFF	; 255
    48a2:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    48a6:	8c 83       	std	Y+4, r24	; 0x04
    48a8:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    48aa:	ce 82       	std	Y+6, r12	; 0x06
    48ac:	df 82       	std	Y+7, r13	; 0x07
    48ae:	e8 86       	std	Y+8, r14	; 0x08
    48b0:	f9 86       	std	Y+9, r15	; 0x09
    48b2:	c0 e5       	ldi	r28, 0x50	; 80
    48b4:	d2 e3       	ldi	r29, 0x32	; 50
    48b6:	1a 82       	std	Y+2, r1	; 0x02
    48b8:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    48ba:	08 83       	st	Y, r16
    48bc:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    48be:	40 e0       	ldi	r20, 0x00	; 0
    48c0:	62 e0       	ldi	r22, 0x02	; 2
    48c2:	8f ef       	ldi	r24, 0xFF	; 255
    48c4:	0e 94 9b 10 	call	0x2136	; 0x2136 <xQueueGenericCreate>
    48c8:	8c 83       	std	Y+4, r24	; 0x04
    48ca:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    48cc:	ce 82       	std	Y+6, r12	; 0x06
    48ce:	df 82       	std	Y+7, r13	; 0x07
    48d0:	e8 86       	std	Y+8, r14	; 0x08
    48d2:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    48d4:	df 91       	pop	r29
    48d6:	cf 91       	pop	r28
    48d8:	1f 91       	pop	r17
    48da:	0f 91       	pop	r16
    48dc:	ff 90       	pop	r15
    48de:	ef 90       	pop	r14
    48e0:	df 90       	pop	r13
    48e2:	cf 90       	pop	r12
    48e4:	08 95       	ret

000048e6 <__mulsi3>:
    48e6:	db 01       	movw	r26, r22
    48e8:	8f 93       	push	r24
    48ea:	9f 93       	push	r25
    48ec:	0e 94 cd 24 	call	0x499a	; 0x499a <__muluhisi3>
    48f0:	bf 91       	pop	r27
    48f2:	af 91       	pop	r26
    48f4:	a2 9f       	mul	r26, r18
    48f6:	80 0d       	add	r24, r0
    48f8:	91 1d       	adc	r25, r1
    48fa:	a3 9f       	mul	r26, r19
    48fc:	90 0d       	add	r25, r0
    48fe:	b2 9f       	mul	r27, r18
    4900:	90 0d       	add	r25, r0
    4902:	11 24       	eor	r1, r1
    4904:	08 95       	ret

00004906 <__udivmodsi4>:
    4906:	a1 e2       	ldi	r26, 0x21	; 33
    4908:	1a 2e       	mov	r1, r26
    490a:	aa 1b       	sub	r26, r26
    490c:	bb 1b       	sub	r27, r27
    490e:	fd 01       	movw	r30, r26
    4910:	0d c0       	rjmp	.+26     	; 0x492c <__udivmodsi4_ep>

00004912 <__udivmodsi4_loop>:
    4912:	aa 1f       	adc	r26, r26
    4914:	bb 1f       	adc	r27, r27
    4916:	ee 1f       	adc	r30, r30
    4918:	ff 1f       	adc	r31, r31
    491a:	a2 17       	cp	r26, r18
    491c:	b3 07       	cpc	r27, r19
    491e:	e4 07       	cpc	r30, r20
    4920:	f5 07       	cpc	r31, r21
    4922:	20 f0       	brcs	.+8      	; 0x492c <__udivmodsi4_ep>
    4924:	a2 1b       	sub	r26, r18
    4926:	b3 0b       	sbc	r27, r19
    4928:	e4 0b       	sbc	r30, r20
    492a:	f5 0b       	sbc	r31, r21

0000492c <__udivmodsi4_ep>:
    492c:	66 1f       	adc	r22, r22
    492e:	77 1f       	adc	r23, r23
    4930:	88 1f       	adc	r24, r24
    4932:	99 1f       	adc	r25, r25
    4934:	1a 94       	dec	r1
    4936:	69 f7       	brne	.-38     	; 0x4912 <__udivmodsi4_loop>
    4938:	60 95       	com	r22
    493a:	70 95       	com	r23
    493c:	80 95       	com	r24
    493e:	90 95       	com	r25
    4940:	9b 01       	movw	r18, r22
    4942:	ac 01       	movw	r20, r24
    4944:	bd 01       	movw	r22, r26
    4946:	cf 01       	movw	r24, r30
    4948:	08 95       	ret

0000494a <__divmodsi4>:
    494a:	05 2e       	mov	r0, r21
    494c:	97 fb       	bst	r25, 7
    494e:	1e f4       	brtc	.+6      	; 0x4956 <__divmodsi4+0xc>
    4950:	00 94       	com	r0
    4952:	0e 94 bc 24 	call	0x4978	; 0x4978 <__negsi2>
    4956:	57 fd       	sbrc	r21, 7
    4958:	07 d0       	rcall	.+14     	; 0x4968 <__divmodsi4_neg2>
    495a:	0e 94 83 24 	call	0x4906	; 0x4906 <__udivmodsi4>
    495e:	07 fc       	sbrc	r0, 7
    4960:	03 d0       	rcall	.+6      	; 0x4968 <__divmodsi4_neg2>
    4962:	4e f4       	brtc	.+18     	; 0x4976 <__divmodsi4_exit>
    4964:	0c 94 bc 24 	jmp	0x4978	; 0x4978 <__negsi2>

00004968 <__divmodsi4_neg2>:
    4968:	50 95       	com	r21
    496a:	40 95       	com	r20
    496c:	30 95       	com	r19
    496e:	21 95       	neg	r18
    4970:	3f 4f       	sbci	r19, 0xFF	; 255
    4972:	4f 4f       	sbci	r20, 0xFF	; 255
    4974:	5f 4f       	sbci	r21, 0xFF	; 255

00004976 <__divmodsi4_exit>:
    4976:	08 95       	ret

00004978 <__negsi2>:
    4978:	90 95       	com	r25
    497a:	80 95       	com	r24
    497c:	70 95       	com	r23
    497e:	61 95       	neg	r22
    4980:	7f 4f       	sbci	r23, 0xFF	; 255
    4982:	8f 4f       	sbci	r24, 0xFF	; 255
    4984:	9f 4f       	sbci	r25, 0xFF	; 255
    4986:	08 95       	ret

00004988 <__tablejump2__>:
    4988:	ee 0f       	add	r30, r30
    498a:	ff 1f       	adc	r31, r31
    498c:	88 1f       	adc	r24, r24
    498e:	8b bf       	out	0x3b, r24	; 59
    4990:	07 90       	elpm	r0, Z+
    4992:	f6 91       	elpm	r31, Z
    4994:	e0 2d       	mov	r30, r0
    4996:	1b be       	out	0x3b, r1	; 59
    4998:	19 94       	eijmp

0000499a <__muluhisi3>:
    499a:	0e 94 d8 24 	call	0x49b0	; 0x49b0 <__umulhisi3>
    499e:	a5 9f       	mul	r26, r21
    49a0:	90 0d       	add	r25, r0
    49a2:	b4 9f       	mul	r27, r20
    49a4:	90 0d       	add	r25, r0
    49a6:	a4 9f       	mul	r26, r20
    49a8:	80 0d       	add	r24, r0
    49aa:	91 1d       	adc	r25, r1
    49ac:	11 24       	eor	r1, r1
    49ae:	08 95       	ret

000049b0 <__umulhisi3>:
    49b0:	a2 9f       	mul	r26, r18
    49b2:	b0 01       	movw	r22, r0
    49b4:	b3 9f       	mul	r27, r19
    49b6:	c0 01       	movw	r24, r0
    49b8:	a3 9f       	mul	r26, r19
    49ba:	70 0d       	add	r23, r0
    49bc:	81 1d       	adc	r24, r1
    49be:	11 24       	eor	r1, r1
    49c0:	91 1d       	adc	r25, r1
    49c2:	b2 9f       	mul	r27, r18
    49c4:	70 0d       	add	r23, r0
    49c6:	81 1d       	adc	r24, r1
    49c8:	11 24       	eor	r1, r1
    49ca:	91 1d       	adc	r25, r1
    49cc:	08 95       	ret

000049ce <memcpy>:
    49ce:	fb 01       	movw	r30, r22
    49d0:	dc 01       	movw	r26, r24
    49d2:	02 c0       	rjmp	.+4      	; 0x49d8 <memcpy+0xa>
    49d4:	01 90       	ld	r0, Z+
    49d6:	0d 92       	st	X+, r0
    49d8:	41 50       	subi	r20, 0x01	; 1
    49da:	50 40       	sbci	r21, 0x00	; 0
    49dc:	d8 f7       	brcc	.-10     	; 0x49d4 <memcpy+0x6>
    49de:	08 95       	ret

000049e0 <memset>:
    49e0:	dc 01       	movw	r26, r24
    49e2:	01 c0       	rjmp	.+2      	; 0x49e6 <memset+0x6>
    49e4:	6d 93       	st	X+, r22
    49e6:	41 50       	subi	r20, 0x01	; 1
    49e8:	50 40       	sbci	r21, 0x00	; 0
    49ea:	e0 f7       	brcc	.-8      	; 0x49e4 <memset+0x4>
    49ec:	08 95       	ret

000049ee <strncpy>:
    49ee:	fb 01       	movw	r30, r22
    49f0:	dc 01       	movw	r26, r24
    49f2:	41 50       	subi	r20, 0x01	; 1
    49f4:	50 40       	sbci	r21, 0x00	; 0
    49f6:	48 f0       	brcs	.+18     	; 0x4a0a <strncpy+0x1c>
    49f8:	01 90       	ld	r0, Z+
    49fa:	0d 92       	st	X+, r0
    49fc:	00 20       	and	r0, r0
    49fe:	c9 f7       	brne	.-14     	; 0x49f2 <strncpy+0x4>
    4a00:	01 c0       	rjmp	.+2      	; 0x4a04 <strncpy+0x16>
    4a02:	1d 92       	st	X+, r1
    4a04:	41 50       	subi	r20, 0x01	; 1
    4a06:	50 40       	sbci	r21, 0x00	; 0
    4a08:	e0 f7       	brcc	.-8      	; 0x4a02 <strncpy+0x14>
    4a0a:	08 95       	ret

00004a0c <ultoa>:
    4a0c:	25 32       	cpi	r18, 0x25	; 37
    4a0e:	31 05       	cpc	r19, r1
    4a10:	20 f4       	brcc	.+8      	; 0x4a1a <ultoa+0xe>
    4a12:	22 30       	cpi	r18, 0x02	; 2
    4a14:	10 f0       	brcs	.+4      	; 0x4a1a <ultoa+0xe>
    4a16:	0c 94 11 25 	jmp	0x4a22	; 0x4a22 <__ultoa_ncheck>
    4a1a:	fa 01       	movw	r30, r20
    4a1c:	10 82       	st	Z, r1
    4a1e:	ca 01       	movw	r24, r20
    4a20:	08 95       	ret

00004a22 <__ultoa_ncheck>:
    4a22:	bb 27       	eor	r27, r27

00004a24 <__ultoa_common>:
    4a24:	fa 01       	movw	r30, r20
    4a26:	a6 2f       	mov	r26, r22
    4a28:	62 17       	cp	r22, r18
    4a2a:	71 05       	cpc	r23, r1
    4a2c:	81 05       	cpc	r24, r1
    4a2e:	91 05       	cpc	r25, r1
    4a30:	33 0b       	sbc	r19, r19
    4a32:	30 fb       	bst	r19, 0
    4a34:	66 f0       	brts	.+24     	; 0x4a4e <__ultoa_common+0x2a>
    4a36:	aa 27       	eor	r26, r26
    4a38:	66 0f       	add	r22, r22
    4a3a:	77 1f       	adc	r23, r23
    4a3c:	88 1f       	adc	r24, r24
    4a3e:	99 1f       	adc	r25, r25
    4a40:	aa 1f       	adc	r26, r26
    4a42:	a2 17       	cp	r26, r18
    4a44:	10 f0       	brcs	.+4      	; 0x4a4a <__ultoa_common+0x26>
    4a46:	a2 1b       	sub	r26, r18
    4a48:	63 95       	inc	r22
    4a4a:	38 50       	subi	r19, 0x08	; 8
    4a4c:	a9 f7       	brne	.-22     	; 0x4a38 <__ultoa_common+0x14>
    4a4e:	a0 5d       	subi	r26, 0xD0	; 208
    4a50:	aa 33       	cpi	r26, 0x3A	; 58
    4a52:	08 f0       	brcs	.+2      	; 0x4a56 <__ultoa_common+0x32>
    4a54:	a9 5d       	subi	r26, 0xD9	; 217
    4a56:	a1 93       	st	Z+, r26
    4a58:	36 f7       	brtc	.-52     	; 0x4a26 <__ultoa_common+0x2>
    4a5a:	b1 11       	cpse	r27, r1
    4a5c:	b1 93       	st	Z+, r27
    4a5e:	10 82       	st	Z, r1
    4a60:	ca 01       	movw	r24, r20
    4a62:	0c 94 58 25 	jmp	0x4ab0	; 0x4ab0 <strrev>

00004a66 <utoa>:
    4a66:	45 32       	cpi	r20, 0x25	; 37
    4a68:	51 05       	cpc	r21, r1
    4a6a:	20 f4       	brcc	.+8      	; 0x4a74 <utoa+0xe>
    4a6c:	42 30       	cpi	r20, 0x02	; 2
    4a6e:	10 f0       	brcs	.+4      	; 0x4a74 <utoa+0xe>
    4a70:	0c 94 3e 25 	jmp	0x4a7c	; 0x4a7c <__utoa_ncheck>
    4a74:	fb 01       	movw	r30, r22
    4a76:	10 82       	st	Z, r1
    4a78:	cb 01       	movw	r24, r22
    4a7a:	08 95       	ret

00004a7c <__utoa_ncheck>:
    4a7c:	bb 27       	eor	r27, r27

00004a7e <__utoa_common>:
    4a7e:	fb 01       	movw	r30, r22
    4a80:	55 27       	eor	r21, r21
    4a82:	aa 27       	eor	r26, r26
    4a84:	88 0f       	add	r24, r24
    4a86:	99 1f       	adc	r25, r25
    4a88:	aa 1f       	adc	r26, r26
    4a8a:	a4 17       	cp	r26, r20
    4a8c:	10 f0       	brcs	.+4      	; 0x4a92 <__utoa_common+0x14>
    4a8e:	a4 1b       	sub	r26, r20
    4a90:	83 95       	inc	r24
    4a92:	50 51       	subi	r21, 0x10	; 16
    4a94:	b9 f7       	brne	.-18     	; 0x4a84 <__utoa_common+0x6>
    4a96:	a0 5d       	subi	r26, 0xD0	; 208
    4a98:	aa 33       	cpi	r26, 0x3A	; 58
    4a9a:	08 f0       	brcs	.+2      	; 0x4a9e <__utoa_common+0x20>
    4a9c:	a9 5d       	subi	r26, 0xD9	; 217
    4a9e:	a1 93       	st	Z+, r26
    4aa0:	00 97       	sbiw	r24, 0x00	; 0
    4aa2:	79 f7       	brne	.-34     	; 0x4a82 <__utoa_common+0x4>
    4aa4:	b1 11       	cpse	r27, r1
    4aa6:	b1 93       	st	Z+, r27
    4aa8:	11 92       	st	Z+, r1
    4aaa:	cb 01       	movw	r24, r22
    4aac:	0c 94 58 25 	jmp	0x4ab0	; 0x4ab0 <strrev>

00004ab0 <strrev>:
    4ab0:	dc 01       	movw	r26, r24
    4ab2:	fc 01       	movw	r30, r24
    4ab4:	67 2f       	mov	r22, r23
    4ab6:	71 91       	ld	r23, Z+
    4ab8:	77 23       	and	r23, r23
    4aba:	e1 f7       	brne	.-8      	; 0x4ab4 <strrev+0x4>
    4abc:	32 97       	sbiw	r30, 0x02	; 2
    4abe:	04 c0       	rjmp	.+8      	; 0x4ac8 <strrev+0x18>
    4ac0:	7c 91       	ld	r23, X
    4ac2:	6d 93       	st	X+, r22
    4ac4:	70 83       	st	Z, r23
    4ac6:	62 91       	ld	r22, -Z
    4ac8:	ae 17       	cp	r26, r30
    4aca:	bf 07       	cpc	r27, r31
    4acc:	c8 f3       	brcs	.-14     	; 0x4ac0 <strrev+0x10>
    4ace:	08 95       	ret

00004ad0 <_exit>:
    4ad0:	f8 94       	cli

00004ad2 <__stop_program>:
    4ad2:	ff cf       	rjmp	.-2      	; 0x4ad2 <__stop_program>
