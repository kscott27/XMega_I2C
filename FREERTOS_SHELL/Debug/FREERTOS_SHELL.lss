
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004fba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000210  00802000  00004fba  0000504e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802210  00802210  0000525e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000525e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005290  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ae0  00000000  00000000  000052d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001d82d  00000000  00000000  00005db0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000075a5  00000000  00000000  000235dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006c70  00000000  00000000  0002ab82  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002130  00000000  00000000  000317f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000073b8  00000000  00000000  00033924  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000acee  00000000  00000000  0003acdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a18  00000000  00000000  000459ca  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 03 	jmp	0x66e	; 0x66e <__ctors_end>
       4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
       c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      10:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      14:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      18:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      1c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      20:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      24:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      28:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      2c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      30:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      34:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      38:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      3c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      40:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      44:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      48:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      4c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      50:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      54:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      58:	0c 94 e1 11 	jmp	0x23c2	; 0x23c2 <__vector_22>
      5c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      60:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      64:	0c 94 f3 21 	jmp	0x43e6	; 0x43e6 <__vector_25>
      68:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      6c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      70:	0c 94 51 22 	jmp	0x44a2	; 0x44a2 <__vector_28>
      74:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      78:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      7c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      80:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      84:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      88:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      8c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      90:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      94:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      98:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      9c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      e8:	0c 94 6b 23 	jmp	0x46d6	; 0x46d6 <__vector_58>
      ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
      fc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     100:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     104:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     108:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     10c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     110:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     114:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     118:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     11c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     120:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     124:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     128:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     12c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     130:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     134:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     138:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     13c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     140:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     144:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     148:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     14c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     150:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     154:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     158:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     15c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     160:	0c 94 af 22 	jmp	0x455e	; 0x455e <__vector_88>
     164:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     168:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     16c:	0c 94 0d 23 	jmp	0x461a	; 0x461a <__vector_91>
     170:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     174:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     178:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     17c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     180:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     184:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     188:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     18c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     190:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     194:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     198:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     19c:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1a8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ac:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1b8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1bc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1c8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1cc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1d8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1dc:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1e8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1ec:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f0:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f4:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1f8:	0c 94 6d 03 	jmp	0x6da	; 0x6da <__bad_interrupt>
     1fc:	a2 1f       	adc	r26, r18
     1fe:	a5 1f       	adc	r26, r21
     200:	a8 1f       	adc	r26, r24
     202:	ab 1f       	adc	r26, r27
     204:	ae 1f       	adc	r26, r30
     206:	b1 1f       	adc	r27, r17
     208:	b3 1f       	adc	r27, r19
     20a:	c4 1f       	adc	r28, r20
     20c:	cc 1f       	adc	r28, r28
     20e:	d6 1f       	adc	r29, r22
     210:	d4 1f       	adc	r29, r20

00000212 <__trampolines_start>:
     212:	0c 94 99 25 	jmp	0x4b32	; 0x4b32 <_ZN9frt_queueIjE3putERKj>
     216:	0c 94 6a 21 	jmp	0x42d4	; 0x42d4 <_ZN5rs23212clear_screenEv>
     21a:	0c 94 60 24 	jmp	0x48c0	; 0x48c0 <_ZN9frt_queueIjE3getEPj>
     21e:	0c 94 cd 1c 	jmp	0x399a	; 0x399a <_ZN14frt_text_queue7getcharEv>
     222:	0c 94 eb 1c 	jmp	0x39d6	; 0x39d6 <_ZN14frt_text_queue14check_for_charEv>
     226:	0c 94 3f 25 	jmp	0x4a7e	; 0x4a7e <_ZN9frt_queueIjE7ISR_putERKj>
     22a:	0c 94 d4 1f 	jmp	0x3fa8	; 0x3fa8 <_ZN8emstreamlsE15ser_manipulator+0x82>
     22e:	0c 94 34 03 	jmp	0x668	; 0x668 <_call_static_run_method>
     232:	0c 94 e5 23 	jmp	0x47ca	; 0x47ca <_ZN9frt_queueIiE16ISR_num_items_inEv>
     236:	0c 94 4c 1f 	jmp	0x3e98	; 0x3e98 <_ZN8emstream12transmit_nowEv>
     23a:	0c 94 74 09 	jmp	0x12e8	; 0x12e8 <_ZN9frt_queueIhE3getEv>
     23e:	0c 94 41 0a 	jmp	0x1482	; 0x1482 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     242:	0c 94 50 05 	jmp	0xaa0	; 0xaa0 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     246:	0c 94 87 25 	jmp	0x4b0e	; 0x4b0e <_ZN9frt_queueIjE7butt_inERKj>
     24a:	0c 94 bd 25 	jmp	0x4b7a	; 0x4b7a <_ZN9frt_queueIiE3putERKi>
     24e:	0c 94 f1 04 	jmp	0x9e2	; 0x9e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     252:	0c 94 ba 24 	jmp	0x4974	; 0x4974 <_ZN9frt_queueIiE3getEv>
     256:	0c 94 57 25 	jmp	0x4aae	; 0x4aae <_ZN9frt_queueIiE11ISR_butt_inERKi>
     25a:	0c 94 a4 05 	jmp	0xb48	; 0xb48 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     25e:	0c 94 08 0a 	jmp	0x1410	; 0x1410 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     262:	0c 94 2f 09 	jmp	0x125e	; 0x125e <_ZN9frt_queueIhE9not_emptyEv>
     266:	0c 94 1e 09 	jmp	0x123c	; 0x123c <_ZN9frt_queueIhE12ISR_is_emptyEv>
     26a:	0c 94 65 05 	jmp	0xaca	; 0xaca <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     26e:	0c 94 c9 23 	jmp	0x4792	; 0x4792 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     272:	0c 94 69 26 	jmp	0x4cd2	; 0x4cd2 <_GLOBAL__sub_I_counter>
     276:	0c 94 7a 05 	jmp	0xaf4	; 0xaf4 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     27a:	0c 94 d6 1f 	jmp	0x3fac	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
     27e:	0c 94 f6 09 	jmp	0x13ec	; 0x13ec <_ZN9frt_queueIhE3putERKh>
     282:	0c 94 0d 04 	jmp	0x81a	; 0x81a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     286:	0c 94 d5 24 	jmp	0x49aa	; 0x49aa <_ZN9frt_queueIjE7ISR_getEPj>
     28a:	0c 94 6c 24 	jmp	0x48d8	; 0x48d8 <_ZN9frt_queueIjE3getEv>
     28e:	0c 94 ae 1f 	jmp	0x3f5c	; 0x3f5c <_ZN8emstreamlsE15ser_manipulator+0x36>
     292:	0c 94 54 04 	jmp	0x8a8	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     296:	0c 94 b1 1f 	jmp	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     29a:	0c 94 ec 03 	jmp	0x7d8	; 0x7d8 <_ZN8I2CAgent11resetPacketER6Packet>
     29e:	0c 94 b4 09 	jmp	0x1368	; 0x1368 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     2a2:	0c 94 c1 14 	jmp	0x2982	; 0x2982 <prvIdleTask>
     2a6:	0c 94 8f 03 	jmp	0x71e	; 0x71e <_ZN8I2CAgent7receiveEv>
     2aa:	0c 94 d0 23 	jmp	0x47a0	; 0x47a0 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2ae:	0c 94 28 09 	jmp	0x1250	; 0x1250 <_ZN9frt_queueIhE12num_items_inEv>
     2b2:	0c 94 a2 1f 	jmp	0x3f44	; 0x3f44 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2b6:	0c 94 13 09 	jmp	0x1226	; 0x1226 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     2ba:	0c 94 c4 1f 	jmp	0x3f88	; 0x3f88 <_ZN8emstreamlsE15ser_manipulator+0x62>
     2be:	0c 94 6f 25 	jmp	0x4ade	; 0x4ade <_ZN9frt_queueIiE7ISR_putERKi>
     2c2:	0c 94 0f 25 	jmp	0x4a1e	; 0x4a1e <_ZN9frt_queueIiE7ISR_getEv>
     2c6:	0c 94 ae 24 	jmp	0x495c	; 0x495c <_ZN9frt_queueIiE3getEPi>
     2ca:	0c 94 03 04 	jmp	0x806	; 0x806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     2ce:	0c 94 47 1f 	jmp	0x3e8e	; 0x3e8e <_ZN8emstream7getcharEv>
     2d2:	0c 94 83 1b 	jmp	0x3706	; 0x3706 <_ZN8frt_task12print_statusER8emstream>
     2d6:	0c 94 39 24 	jmp	0x4872	; 0x4872 <_ZN9frt_queueIjE10get_a_copyERj>
     2da:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <_ZN9task_user3runEv>
     2de:	0c 94 ab 25 	jmp	0x4b56	; 0x4b56 <_ZN9frt_queueIiE7butt_inERKi>
     2e2:	0c 94 2f 24 	jmp	0x485e	; 0x485e <_ZN9frt_queueIiE8is_emptyEv>
     2e6:	0c 94 0e 0c 	jmp	0x181c	; 0x181c <_ZN10task_sonar3runEv>
     2ea:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <_ZN9I2CMaster10StartState7executeER6Packet>
     2ee:	0c 94 9b 04 	jmp	0x936	; 0x936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2f2:	0c 94 24 24 	jmp	0x4848	; 0x4848 <_ZN9frt_queueIiE9not_emptyEv>
     2f6:	0c 94 45 24 	jmp	0x488a	; 0x488a <_ZN9frt_queueIjE10get_a_copyEv>
     2fa:	0c 94 4a 1f 	jmp	0x3e94	; 0x3e94 <_ZN8emstream14check_for_charEv>
     2fe:	0c 94 b3 1f 	jmp	0x3f66	; 0x3f66 <_ZN8emstreamlsE15ser_manipulator+0x40>
     302:	0c 94 68 09 	jmp	0x12d0	; 0x12d0 <_ZN9frt_queueIhE3getEPh>
     306:	0c 94 ba 03 	jmp	0x774	; 0x774 <_ZN8I2CAgent11writePacketER7Command>
     30a:	0c 94 57 21 	jmp	0x42ae	; 0x42ae <_ZN5rs23214check_for_charEv>
     30e:	0c 94 31 21 	jmp	0x4262	; 0x4262 <_ZN5rs2327getcharEv>
     312:	0c 94 01 24 	jmp	0x4802	; 0x4802 <_ZN9frt_queueIjE12num_items_inEv>
     316:	0c 94 26 05 	jmp	0xa4c	; 0xa4c <_ZN9I2CMaster9DoneState11serialDebugEv>
     31a:	0c 94 ab 1f 	jmp	0x3f56	; 0x3f56 <_ZN8emstreamlsE15ser_manipulator+0x30>
     31e:	0c 94 45 1f 	jmp	0x3e8a	; 0x3e8a <_ZN8emstream13ready_to_sendEv>
     322:	0c 94 f7 23 	jmp	0x47ee	; 0x47ee <_ZN9frt_queueIiE12ISR_is_emptyEv>
     326:	0c 94 ae 1e 	jmp	0x3d5c	; 0x3d5c <__cxa_pure_virtual>
     32a:	0c 94 e6 24 	jmp	0x49cc	; 0x49cc <_ZN9frt_queueIjE7ISR_getEv>
     32e:	0c 94 f6 1c 	jmp	0x39ec	; 0x39ec <_ZN14frt_text_queue7putcharEc>
     332:	0c 94 a5 1f 	jmp	0x3f4a	; 0x3f4a <_ZN8emstreamlsE15ser_manipulator+0x24>
     336:	0c 94 ec 23 	jmp	0x47d8	; 0x47d8 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     33a:	0c 94 f9 03 	jmp	0x7f2	; 0x7f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     33e:	0c 94 cb 04 	jmp	0x996	; 0x996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     342:	0c 94 fe 24 	jmp	0x49fc	; 0x49fc <_ZN9frt_queueIiE7ISR_getEPi>
     346:	0c 94 34 0a 	jmp	0x1468	; 0x1468 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     34a:	0c 94 44 09 	jmp	0x1288	; 0x1288 <_ZN9frt_queueIhE10get_a_copyERh>
     34e:	0c 94 27 25 	jmp	0x4a4e	; 0x4a4e <_ZN9frt_queueIjE11ISR_butt_inERKj>
     352:	0c 94 08 24 	jmp	0x4810	; 0x4810 <_ZN9frt_queueIjE9not_emptyEv>
     356:	0c 94 13 24 	jmp	0x4826	; 0x4826 <_ZN9frt_queueIjE8is_emptyEv>
     35a:	0c 94 8f 05 	jmp	0xb1e	; 0xb1e <_ZN9I2CMaster10StartState11serialDebugEv>
     35e:	0c 94 6f 03 	jmp	0x6de	; 0x6de <_ZN8I2CAgent10readPacketEv>
     362:	0c 94 cc 1f 	jmp	0x3f98	; 0x3f98 <_ZN8emstreamlsE15ser_manipulator+0x72>
     366:	0c 94 87 24 	jmp	0x490e	; 0x490e <_ZN9frt_queueIiE10get_a_copyERi>
     36a:	0c 94 11 05 	jmp	0xa22	; 0xa22 <_ZN9I2CMaster10ErrorState11serialDebugEv>
     36e:	0c 94 4d 1f 	jmp	0x3e9a	; 0x3e9a <_ZN8emstream12clear_screenEv>
     372:	0c 94 db 23 	jmp	0x47b6	; 0x47b6 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     376:	0c 94 06 05 	jmp	0xa0c	; 0xa0c <_ZN9I2CMaster9DoneState7executeER6Packet>
     37a:	0c 94 9d 09 	jmp	0x133a	; 0x133a <_ZN9frt_queueIhE7ISR_getEv>
     37e:	0c 94 50 09 	jmp	0x12a0	; 0x12a0 <_ZN9frt_queueIhE10get_a_copyEv>
     382:	0c 94 0d 05 	jmp	0xa1a	; 0xa1a <_ZN9I2CMaster10ErrorState7executeER6Packet>
     386:	0c 94 3b 05 	jmp	0xa76	; 0xa76 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     38a:	0c 94 0c 09 	jmp	0x1218	; 0x1218 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     38e:	0c 94 cc 09 	jmp	0x1398	; 0x1398 <_ZN9frt_queueIhE7ISR_putERKh>
     392:	0c 94 0d 21 	jmp	0x421a	; 0x421a <_ZN5rs2327putcharEc>
     396:	0c 94 27 0a 	jmp	0x144e	; 0x144e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     39a:	0c 94 3a 09 	jmp	0x1274	; 0x1274 <_ZN9frt_queueIhE8is_emptyEv>
     39e:	0c 94 a8 1f 	jmp	0x3f50	; 0x3f50 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     3a2:	0c 94 93 24 	jmp	0x4926	; 0x4926 <_ZN9frt_queueIiE10get_a_copyEv>
     3a6:	0c 94 8c 09 	jmp	0x1318	; 0x1318 <_ZN9frt_queueIhE7ISR_getEPh>
     3aa:	0c 94 e4 09 	jmp	0x13c8	; 0x13c8 <_ZN9frt_queueIhE7butt_inERKh>
     3ae:	0c 94 7a 03 	jmp	0x6f4	; 0x6f4 <_ZN8I2CAgent8transmitER7Command>
     3b2:	0c 94 1d 24 	jmp	0x483a	; 0x483a <_ZN9frt_queueIiE12num_items_inEv>

000003b6 <__trampolines_end>:
     3b6:	2c 20       	and	r2, r12
     3b8:	54 43       	sbci	r21, 0x34	; 52
     3ba:	43 30       	cpi	r20, 0x03	; 3
     3bc:	43 43       	sbci	r20, 0x33	; 51
     3be:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c1 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c1:	2f 00                                               /.

000003c3 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c3:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d1 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d1:	54 69 6d 65 3a 20 00                                Time: .

000003d8 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d8:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e4 <_ZZN9task_user11show_statusEvE3__c>:
     3e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000403 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     403:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000412 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     412:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     422:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000042d <_ZZN9task_user18print_help_messageEvE3__c_8>:
     42d:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     43d:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044b <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44b:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45b:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46b:	6d 61 74 69 6f 6e 00                                mation.

00000472 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     472:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     482:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000493 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     493:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a3:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004ab <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4ab:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bb:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c7 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c7:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d7:	68 65 20 41 56 52 00                                he AVR.

000004de <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4de:	20 68 65 6c 70 00                                    help.

000004e4 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e4:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f4:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000503 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     503:	1b 5b 33 30 6d 00                                   .[30m.

00000509 <_ZZN9task_user18print_help_messageEvE3__c>:
     509:	1b 5b 34 36 6d 00                                   .[46m.

0000050f <_ZZN9task_user3runEvE3__c_3>:
     50f:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51f:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000052c <_ZZN9task_user3runEvE3__c_2>:
     52c:	3a 57 54 46 3f 00                                   :WTF?.

00000532 <_ZZN9task_user3runEvE3__c_1>:
     532:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     542:	65 00                                               e.

00000544 <_ZZN9task_user3runEvE3__c_0>:
     544:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000552 <_ZZN9task_user3runEvE3__c>:
     552:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     562:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000570 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     570:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057a <_ZZN8frt_task15emergency_resetEvE3__c>:
     57a:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000589 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     589:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     599:	61 73 6b 20 00                                      ask .

0000059e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59e:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005ac <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5ac:	20 63 72 65 61 74 65 64 00                           created.

000005b5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b5:	54 61 73 6b 20 00                                   Task .

000005bb <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bb:	1b 5b 32 32 6d 00                                   .[22m.

000005c1 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c1:	54 61 73 6b 3a 20 00                                Task: .

000005c8 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5cd:	1b 5b 32 32 6d 00                                   .[22m.

000005d3 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d3:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005de <_ZZ17print_task_stacksP8emstreamE3__c>:
     5de:	1b 5b 31 6d 00                                      .[1m.

000005e3 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e3:	09 09 00                                            ...

000005e6 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e6:	2f 00                                               /.

000005e8 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e8:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f3 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f3:	09 2d 2d 2d 2d 00                                   .----.

000005f9 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f9:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000605 <_ZZ15print_task_listP8emstreamE3__c_4>:
     605:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000616 <_ZZ15print_task_listP8emstreamE3__c_3>:
     616:	09 52 75 6e 73 00                                   .Runs.

0000061c <_ZZ15print_task_listP8emstreamE3__c_2>:
     61c:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000628 <_ZZ15print_task_listP8emstreamE3__c_1>:
     628:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000639 <_ZZ15print_task_listP8emstreamE3__c_0>:
     639:	09 53 74 61 63 6b 00                                .Stack.

00000640 <_ZZ15print_task_listP8emstreamE3__c>:
     640:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64b:	09 00                                               ..

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64f:	2f 00                                               /.

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     653:	09 00                                               ..

00000655 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     655:	1b 5b 32 32 6d 00                                   .[22m.

0000065b <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65b:	1b 5b 31 6d 00                                      .[1m.

00000660 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     660:	1b 5b 31 6d 00                                      .[1m.

00000665 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     665:	20 20 00                                              .

00000668 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     668:	0e 94 1b 1a 	call	0x3436	; 0x3436 <_ZN8frt_task22_call_users_run_methodEPS_>

0000066c <__ctors_start>:
     66c:	69 26       	eor	r6, r25

0000066e <__ctors_end>:
     66e:	11 24       	eor	r1, r1
     670:	1f be       	out	0x3f, r1	; 63
     672:	cf ef       	ldi	r28, 0xFF	; 255
     674:	cd bf       	out	0x3d, r28	; 61
     676:	df e3       	ldi	r29, 0x3F	; 63
     678:	de bf       	out	0x3e, r29	; 62
     67a:	00 e0       	ldi	r16, 0x00	; 0
     67c:	0c bf       	out	0x3c, r16	; 60
     67e:	18 be       	out	0x38, r1	; 56
     680:	19 be       	out	0x39, r1	; 57
     682:	1a be       	out	0x3a, r1	; 58
     684:	1b be       	out	0x3b, r1	; 59

00000686 <__do_copy_data>:
     686:	12 e2       	ldi	r17, 0x22	; 34
     688:	a0 e0       	ldi	r26, 0x00	; 0
     68a:	b0 e2       	ldi	r27, 0x20	; 32
     68c:	ea eb       	ldi	r30, 0xBA	; 186
     68e:	ff e4       	ldi	r31, 0x4F	; 79
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	0b bf       	out	0x3b, r16	; 59
     694:	02 c0       	rjmp	.+4      	; 0x69a <__do_copy_data+0x14>
     696:	07 90       	elpm	r0, Z+
     698:	0d 92       	st	X+, r0
     69a:	a0 31       	cpi	r26, 0x10	; 16
     69c:	b1 07       	cpc	r27, r17
     69e:	d9 f7       	brne	.-10     	; 0x696 <__do_copy_data+0x10>
     6a0:	1b be       	out	0x3b, r1	; 59

000006a2 <__do_clear_bss>:
     6a2:	22 e3       	ldi	r18, 0x32	; 50
     6a4:	a0 e1       	ldi	r26, 0x10	; 16
     6a6:	b2 e2       	ldi	r27, 0x22	; 34
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <.do_clear_bss_start>

000006aa <.do_clear_bss_loop>:
     6aa:	1d 92       	st	X+, r1

000006ac <.do_clear_bss_start>:
     6ac:	ae 3d       	cpi	r26, 0xDE	; 222
     6ae:	b2 07       	cpc	r27, r18
     6b0:	e1 f7       	brne	.-8      	; 0x6aa <.do_clear_bss_loop>

000006b2 <__do_global_ctors>:
     6b2:	13 e0       	ldi	r17, 0x03	; 3
     6b4:	c7 e3       	ldi	r28, 0x37	; 55
     6b6:	d3 e0       	ldi	r29, 0x03	; 3
     6b8:	00 e0       	ldi	r16, 0x00	; 0
     6ba:	06 c0       	rjmp	.+12     	; 0x6c8 <__do_global_ctors+0x16>
     6bc:	21 97       	sbiw	r28, 0x01	; 1
     6be:	01 09       	sbc	r16, r1
     6c0:	80 2f       	mov	r24, r16
     6c2:	fe 01       	movw	r30, r28
     6c4:	0e 94 37 27 	call	0x4e6e	; 0x4e6e <__tablejump2__>
     6c8:	c6 33       	cpi	r28, 0x36	; 54
     6ca:	d1 07       	cpc	r29, r17
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	08 07       	cpc	r16, r24
     6d0:	a9 f7       	brne	.-22     	; 0x6bc <__do_global_ctors+0xa>
     6d2:	0e 94 e4 25 	call	0x4bc8	; 0x4bc8 <main>
     6d6:	0c 94 db 27 	jmp	0x4fb6	; 0x4fb6 <_exit>

000006da <__bad_interrupt>:
     6da:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006de <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6de:	bc 01       	movw	r22, r24
     6e0:	6e 5f       	subi	r22, 0xFE	; 254
     6e2:	7f 4f       	sbci	r23, 0xFF	; 255
     6e4:	dc 01       	movw	r26, r24
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	00 84       	ldd	r0, Z+8	; 0x08
     6ec:	f1 85       	ldd	r31, Z+9	; 0x09
     6ee:	e0 2d       	mov	r30, r0
     6f0:	19 95       	eicall
     6f2:	08 95       	ret

000006f4 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fa:	e8 81       	ld	r30, Y
     6fc:	f9 81       	ldd	r31, Y+1	; 0x01
     6fe:	04 80       	ldd	r0, Z+4	; 0x04
     700:	f5 81       	ldd	r31, Z+5	; 0x05
     702:	e0 2d       	mov	r30, r0
     704:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     706:	be 01       	movw	r22, r28
     708:	62 5f       	subi	r22, 0xF2	; 242
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
  };

  // I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     70c:	ec 8d       	ldd	r30, Y+28	; 0x1c
     70e:	fd 8d       	ldd	r31, Y+29	; 0x1d
     710:	80 81       	ld	r24, Z
     712:	91 81       	ldd	r25, Z+1	; 0x01
     714:	0e 94 2c 07 	call	0xe58	; 0xe58 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	08 95       	ret

0000071e <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     71e:	ef 92       	push	r14
     720:	ff 92       	push	r15
     722:	0f 93       	push	r16
     724:	cf 93       	push	r28
     726:	df 93       	push	r29
     728:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72a:	7c 01       	movw	r14, r24
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	e8 0e       	add	r14, r24
     730:	f1 1c       	adc	r15, r1
     732:	e8 81       	ld	r30, Y
     734:	f9 81       	ldd	r31, Y+1	; 0x01
     736:	00 84       	ldd	r0, Z+8	; 0x08
     738:	f1 85       	ldd	r31, Z+9	; 0x09
     73a:	e0 2d       	mov	r30, r0
     73c:	b7 01       	movw	r22, r14
     73e:	ce 01       	movw	r24, r28
     740:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     742:	28 85       	ldd	r18, Y+8	; 0x08
     744:	39 85       	ldd	r19, Y+9	; 0x09
     746:	4a 85       	ldd	r20, Y+10	; 0x0a
     748:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74a:	be 01       	movw	r22, r28
     74c:	60 5e       	subi	r22, 0xE0	; 224
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	00 e0       	ldi	r16, 0x00	; 0
     752:	8e 81       	ldd	r24, Y+6	; 0x06
     754:	9f 81       	ldd	r25, Y+7	; 0x07
     756:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75a:	ec 8d       	ldd	r30, Y+28	; 0x1c
     75c:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     75e:	b7 01       	movw	r22, r14
     760:	82 81       	ldd	r24, Z+2	; 0x02
     762:	93 81       	ldd	r25, Z+3	; 0x03
     764:	0e 94 6f 07 	call	0xede	; 0xede <_ZN9I2CMaster8Receiver3runER6Packet>
}
     768:	df 91       	pop	r29
     76a:	cf 91       	pop	r28
     76c:	0f 91       	pop	r16
     76e:	ff 90       	pop	r15
     770:	ef 90       	pop	r14
     772:	08 95       	ret

00000774 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
     784:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     786:	6c 01       	movw	r12, r24
     788:	8e e0       	ldi	r24, 0x0E	; 14
     78a:	c8 0e       	add	r12, r24
     78c:	d1 1c       	adc	r13, r1
     78e:	e8 81       	ld	r30, Y
     790:	f9 81       	ldd	r31, Y+1	; 0x01
     792:	00 84       	ldd	r0, Z+8	; 0x08
     794:	f1 85       	ldd	r31, Z+9	; 0x09
     796:	e0 2d       	mov	r30, r0
     798:	b6 01       	movw	r22, r12
     79a:	ce 01       	movw	r24, r28
     79c:	19 95       	eicall
     79e:	2c 89       	ldd	r18, Y+20	; 0x14
     7a0:	3d 89       	ldd	r19, Y+21	; 0x15
     7a2:	4e 89       	ldd	r20, Y+22	; 0x16
     7a4:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7a6:	be 01       	movw	r22, r28
     7a8:	61 5e       	subi	r22, 0xE1	; 225
     7aa:	7f 4f       	sbci	r23, 0xFF	; 255
     7ac:	00 e0       	ldi	r16, 0x00	; 0
     7ae:	8a 89       	ldd	r24, Y+18	; 0x12
     7b0:	9b 89       	ldd	r25, Y+19	; 0x13
     7b2:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7b6:	d7 01       	movw	r26, r14
     7b8:	ed 91       	ld	r30, X+
     7ba:	fc 91       	ld	r31, X
     7bc:	01 90       	ld	r0, Z+
     7be:	f0 81       	ld	r31, Z
     7c0:	e0 2d       	mov	r30, r0
     7c2:	b6 01       	movw	r22, r12
     7c4:	c7 01       	movw	r24, r14
     7c6:	19 95       	eicall
}
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	08 95       	ret

000007d8 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7d8:	cb 01       	movw	r24, r22
  packet.resetContent();
     7da:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <_ZN6Packet12resetContentEv>
     7de:	08 95       	ret

000007e0 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e0:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e2:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e4:	86 2f       	mov	r24, r22
     7e6:	88 0f       	add	r24, r24
     7e8:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ea:	68 2f       	mov	r22, r24
     7ec:	61 60       	ori	r22, 0x01	; 1
     7ee:	60 a3       	std	Z+32, r22	; 0x20
     7f0:	08 95       	ret

000007f2 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
  }
  else
  {
    return false;
  }
}
     7f2:	dc 01       	movw	r26, r24
     7f4:	17 96       	adiw	r26, 0x07	; 7
     7f6:	ed 91       	ld	r30, X+
     7f8:	fc 91       	ld	r31, X
     7fa:	18 97       	sbiw	r26, 0x08	; 8
     7fc:	04 80       	ldd	r0, Z+4	; 0x04
     7fe:	f5 81       	ldd	r31, Z+5	; 0x05
     800:	e0 2d       	mov	r30, r0
     802:	84 81       	ldd	r24, Z+4	; 0x04
     804:	08 95       	ret

00000806 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     806:	dc 01       	movw	r26, r24
     808:	17 96       	adiw	r26, 0x07	; 7
     80a:	ed 91       	ld	r30, X+
     80c:	fc 91       	ld	r31, X
     80e:	18 97       	sbiw	r26, 0x08	; 8
     810:	04 80       	ldd	r0, Z+4	; 0x04
     812:	f5 81       	ldd	r31, Z+5	; 0x05
     814:	e0 2d       	mov	r30, r0
     816:	84 81       	ldd	r24, Z+4	; 0x04
     818:	08 95       	ret

0000081a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     81a:	0f 93       	push	r16
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	1f 92       	push	r1
     824:	1f 92       	push	r1
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	8c 01       	movw	r16, r24
     82c:	dc 01       	movw	r26, r24
     82e:	19 96       	adiw	r26, 0x09	; 9
     830:	8d 91       	ld	r24, X+
     832:	9c 91       	ld	r25, X
     834:	1a 97       	sbiw	r26, 0x0a	; 10
     836:	89 83       	std	Y+1, r24	; 0x01
     838:	9a 83       	std	Y+2, r25	; 0x02
     83a:	89 81       	ldd	r24, Y+1	; 0x01
     83c:	9a 81       	ldd	r25, Y+2	; 0x02
     83e:	01 97       	sbiw	r24, 0x01	; 1
     840:	89 83       	std	Y+1, r24	; 0x01
     842:	9a 83       	std	Y+2, r25	; 0x02
     844:	89 2b       	or	r24, r25
     846:	59 f0       	breq	.+22     	; 0x85e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     848:	d8 01       	movw	r26, r16
     84a:	17 96       	adiw	r26, 0x07	; 7
     84c:	ed 91       	ld	r30, X+
     84e:	fc 91       	ld	r31, X
     850:	18 97       	sbiw	r26, 0x08	; 8
     852:	04 80       	ldd	r0, Z+4	; 0x04
     854:	f5 81       	ldd	r31, Z+5	; 0x05
     856:	e0 2d       	mov	r30, r0
     858:	84 81       	ldd	r24, Z+4	; 0x04
     85a:	86 ff       	sbrs	r24, 6
     85c:	ee cf       	rjmp	.-36     	; 0x83a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x20>
     85e:	d8 01       	movw	r26, r16
     860:	ed 91       	ld	r30, X+
     862:	fc 91       	ld	r31, X
     864:	02 80       	ldd	r0, Z+2	; 0x02
     866:	f3 81       	ldd	r31, Z+3	; 0x03
     868:	e0 2d       	mov	r30, r0
     86a:	c8 01       	movw	r24, r16
     86c:	19 95       	eicall
     86e:	d8 01       	movw	r26, r16
     870:	17 96       	adiw	r26, 0x07	; 7
     872:	ed 91       	ld	r30, X+
     874:	fc 91       	ld	r31, X
     876:	18 97       	sbiw	r26, 0x08	; 8
     878:	04 80       	ldd	r0, Z+4	; 0x04
     87a:	f5 81       	ldd	r31, Z+5	; 0x05
     87c:	e0 2d       	mov	r30, r0
     87e:	84 81       	ldd	r24, Z+4	; 0x04
     880:	84 fd       	sbrc	r24, 4
     882:	08 c0       	rjmp	.+16     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     884:	84 81       	ldd	r24, Z+4	; 0x04
     886:	86 ff       	sbrs	r24, 6
     888:	05 c0       	rjmp	.+10     	; 0x894 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x7a>
     88a:	12 96       	adiw	r26, 0x02	; 2
     88c:	8d 91       	ld	r24, X+
     88e:	9c 91       	ld	r25, X
     890:	13 97       	sbiw	r26, 0x03	; 3
     892:	03 c0       	rjmp	.+6      	; 0x89a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x80>
     894:	f8 01       	movw	r30, r16
     896:	84 81       	ldd	r24, Z+4	; 0x04
     898:	95 81       	ldd	r25, Z+5	; 0x05
     89a:	0f 90       	pop	r0
     89c:	0f 90       	pop	r0
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	1f 91       	pop	r17
     8a4:	0f 91       	pop	r16
     8a6:	08 95       	ret

000008a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     8a8:	0f 93       	push	r16
     8aa:	1f 93       	push	r17
     8ac:	cf 93       	push	r28
     8ae:	df 93       	push	r29
     8b0:	1f 92       	push	r1
     8b2:	1f 92       	push	r1
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	8c 01       	movw	r16, r24
     8ba:	dc 01       	movw	r26, r24
     8bc:	19 96       	adiw	r26, 0x09	; 9
     8be:	8d 91       	ld	r24, X+
     8c0:	9c 91       	ld	r25, X
     8c2:	1a 97       	sbiw	r26, 0x0a	; 10
     8c4:	89 83       	std	Y+1, r24	; 0x01
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 81       	ldd	r24, Y+1	; 0x01
     8ca:	9a 81       	ldd	r25, Y+2	; 0x02
     8cc:	01 97       	sbiw	r24, 0x01	; 1
     8ce:	89 83       	std	Y+1, r24	; 0x01
     8d0:	9a 83       	std	Y+2, r25	; 0x02
     8d2:	89 2b       	or	r24, r25
     8d4:	59 f0       	breq	.+22     	; 0x8ec <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x44>
     8d6:	d8 01       	movw	r26, r16
     8d8:	17 96       	adiw	r26, 0x07	; 7
     8da:	ed 91       	ld	r30, X+
     8dc:	fc 91       	ld	r31, X
     8de:	18 97       	sbiw	r26, 0x08	; 8
     8e0:	04 80       	ldd	r0, Z+4	; 0x04
     8e2:	f5 81       	ldd	r31, Z+5	; 0x05
     8e4:	e0 2d       	mov	r30, r0
     8e6:	84 81       	ldd	r24, Z+4	; 0x04
     8e8:	88 23       	and	r24, r24
     8ea:	74 f7       	brge	.-36     	; 0x8c8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x20>
     8ec:	d8 01       	movw	r26, r16
     8ee:	ed 91       	ld	r30, X+
     8f0:	fc 91       	ld	r31, X
     8f2:	02 80       	ldd	r0, Z+2	; 0x02
     8f4:	f3 81       	ldd	r31, Z+3	; 0x03
     8f6:	e0 2d       	mov	r30, r0
     8f8:	c8 01       	movw	r24, r16
     8fa:	19 95       	eicall
     8fc:	d8 01       	movw	r26, r16
     8fe:	17 96       	adiw	r26, 0x07	; 7
     900:	ed 91       	ld	r30, X+
     902:	fc 91       	ld	r31, X
     904:	18 97       	sbiw	r26, 0x08	; 8
     906:	04 80       	ldd	r0, Z+4	; 0x04
     908:	f5 81       	ldd	r31, Z+5	; 0x05
     90a:	e0 2d       	mov	r30, r0
     90c:	84 81       	ldd	r24, Z+4	; 0x04
     90e:	84 fd       	sbrc	r24, 4
     910:	08 c0       	rjmp	.+16     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     912:	84 81       	ldd	r24, Z+4	; 0x04
     914:	88 23       	and	r24, r24
     916:	2c f4       	brge	.+10     	; 0x922 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x7a>
     918:	12 96       	adiw	r26, 0x02	; 2
     91a:	8d 91       	ld	r24, X+
     91c:	9c 91       	ld	r25, X
     91e:	13 97       	sbiw	r26, 0x03	; 3
     920:	03 c0       	rjmp	.+6      	; 0x928 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x80>
     922:	f8 01       	movw	r30, r16
     924:	84 81       	ldd	r24, Z+4	; 0x04
     926:	95 81       	ldd	r25, Z+5	; 0x05
     928:	0f 90       	pop	r0
     92a:	0f 90       	pop	r0
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	1f 91       	pop	r17
     932:	0f 91       	pop	r16
     934:	08 95       	ret

00000936 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     936:	ef 92       	push	r14
     938:	ff 92       	push	r15
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	8c 01       	movw	r16, r24
     944:	eb 01       	movw	r28, r22
     946:	e8 81       	ld	r30, Y
     948:	f9 81       	ldd	r31, Y+1	; 0x01
     94a:	00 8c       	ldd	r0, Z+24	; 0x18
     94c:	f1 8d       	ldd	r31, Z+25	; 0x19
     94e:	e0 2d       	mov	r30, r0
     950:	cb 01       	movw	r24, r22
     952:	19 95       	eicall
     954:	88 23       	and	r24, r24
     956:	a9 f0       	breq	.+42     	; 0x982 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     958:	e8 81       	ld	r30, Y
     95a:	f9 81       	ldd	r31, Y+1	; 0x01
     95c:	02 84       	ldd	r0, Z+10	; 0x0a
     95e:	f3 85       	ldd	r31, Z+11	; 0x0b
     960:	e0 2d       	mov	r30, r0
     962:	e1 2c       	mov	r14, r1
     964:	f1 2c       	mov	r15, r1
     966:	b7 01       	movw	r22, r14
     968:	ce 01       	movw	r24, r28
     96a:	19 95       	eicall
     96c:	d8 01       	movw	r26, r16
     96e:	17 96       	adiw	r26, 0x07	; 7
     970:	ed 91       	ld	r30, X+
     972:	fc 91       	ld	r31, X
     974:	18 97       	sbiw	r26, 0x08	; 8
     976:	04 80       	ldd	r0, Z+4	; 0x04
     978:	f5 81       	ldd	r31, Z+5	; 0x05
     97a:	e0 2d       	mov	r30, r0
     97c:	d7 01       	movw	r26, r14
     97e:	8c 91       	ld	r24, X
     980:	87 83       	std	Z+7, r24	; 0x07
     982:	f8 01       	movw	r30, r16
     984:	82 81       	ldd	r24, Z+2	; 0x02
     986:	93 81       	ldd	r25, Z+3	; 0x03
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	1f 91       	pop	r17
     98e:	0f 91       	pop	r16
     990:	ff 90       	pop	r15
     992:	ef 90       	pop	r14
     994:	08 95       	ret

00000996 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	1f 92       	push	r1
     9a0:	cd b7       	in	r28, 0x3d	; 61
     9a2:	de b7       	in	r29, 0x3e	; 62
     9a4:	8c 01       	movw	r16, r24
     9a6:	cb 01       	movw	r24, r22
     9a8:	d8 01       	movw	r26, r16
     9aa:	17 96       	adiw	r26, 0x07	; 7
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
     9b0:	18 97       	sbiw	r26, 0x08	; 8
     9b2:	04 80       	ldd	r0, Z+4	; 0x04
     9b4:	f5 81       	ldd	r31, Z+5	; 0x05
     9b6:	e0 2d       	mov	r30, r0
     9b8:	27 81       	ldd	r18, Z+7	; 0x07
     9ba:	29 83       	std	Y+1, r18	; 0x01
     9bc:	db 01       	movw	r26, r22
     9be:	ed 91       	ld	r30, X+
     9c0:	fc 91       	ld	r31, X
     9c2:	01 90       	ld	r0, Z+
     9c4:	f0 81       	ld	r31, Z
     9c6:	e0 2d       	mov	r30, r0
     9c8:	be 01       	movw	r22, r28
     9ca:	6f 5f       	subi	r22, 0xFF	; 255
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	19 95       	eicall
     9d0:	f8 01       	movw	r30, r16
     9d2:	82 81       	ldd	r24, Z+2	; 0x02
     9d4:	93 81       	ldd	r25, Z+3	; 0x03
     9d6:	0f 90       	pop	r0
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	08 95       	ret

000009e2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     9e2:	cf 93       	push	r28
     9e4:	df 93       	push	r29
     9e6:	ec 01       	movw	r28, r24
     9e8:	cb 01       	movw	r24, r22
     9ea:	db 01       	movw	r26, r22
     9ec:	ed 91       	ld	r30, X+
     9ee:	fc 91       	ld	r31, X
     9f0:	04 88       	ldd	r0, Z+20	; 0x14
     9f2:	f5 89       	ldd	r31, Z+21	; 0x15
     9f4:	e0 2d       	mov	r30, r0
     9f6:	19 95       	eicall
     9f8:	88 23       	and	r24, r24
     9fa:	19 f0       	breq	.+6      	; 0xa02 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     9fc:	8a 81       	ldd	r24, Y+2	; 0x02
     9fe:	9b 81       	ldd	r25, Y+3	; 0x03
     a00:	02 c0       	rjmp	.+4      	; 0xa06 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     a02:	8c 81       	ldd	r24, Y+4	; 0x04
     a04:	9d 81       	ldd	r25, Y+5	; 0x05
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	08 95       	ret

00000a0c <_ZN9I2CMaster9DoneState7executeER6Packet>:
     a0c:	21 e0       	ldi	r18, 0x01	; 1
     a0e:	fb 01       	movw	r30, r22
     a10:	23 87       	std	Z+11, r18	; 0x0b
     a12:	fc 01       	movw	r30, r24
     a14:	82 81       	ldd	r24, Z+2	; 0x02
     a16:	93 81       	ldd	r25, Z+3	; 0x03
     a18:	08 95       	ret

00000a1a <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     a1a:	fc 01       	movw	r30, r24
     a1c:	82 81       	ldd	r24, Z+2	; 0x02
     a1e:	93 81       	ldd	r25, Z+3	; 0x03
     a20:	08 95       	ret

00000a22 <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     a22:	cf 93       	push	r28
     a24:	df 93       	push	r29
     a26:	dc 01       	movw	r26, r24
     a28:	17 96       	adiw	r26, 0x07	; 7
     a2a:	ed 91       	ld	r30, X+
     a2c:	fc 91       	ld	r31, X
     a2e:	18 97       	sbiw	r26, 0x08	; 8
     a30:	c6 81       	ldd	r28, Z+6	; 0x06
     a32:	d7 81       	ldd	r29, Z+7	; 0x07
     a34:	64 e1       	ldi	r22, 0x14	; 20
     a36:	70 e2       	ldi	r23, 0x20	; 32
     a38:	ce 01       	movw	r24, r28
     a3a:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     a3e:	66 e0       	ldi	r22, 0x06	; 6
     a40:	ce 01       	movw	r24, r28
     a42:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	08 95       	ret

00000a4c <_ZN9I2CMaster9DoneState11serialDebugEv>:
     a4c:	cf 93       	push	r28
     a4e:	df 93       	push	r29
     a50:	dc 01       	movw	r26, r24
     a52:	17 96       	adiw	r26, 0x07	; 7
     a54:	ed 91       	ld	r30, X+
     a56:	fc 91       	ld	r31, X
     a58:	18 97       	sbiw	r26, 0x08	; 8
     a5a:	c6 81       	ldd	r28, Z+6	; 0x06
     a5c:	d7 81       	ldd	r29, Z+7	; 0x07
     a5e:	6a e1       	ldi	r22, 0x1A	; 26
     a60:	70 e2       	ldi	r23, 0x20	; 32
     a62:	ce 01       	movw	r24, r28
     a64:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     a68:	66 e0       	ldi	r22, 0x06	; 6
     a6a:	ce 01       	movw	r24, r28
     a6c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	08 95       	ret

00000a76 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	dc 01       	movw	r26, r24
     a7c:	17 96       	adiw	r26, 0x07	; 7
     a7e:	ed 91       	ld	r30, X+
     a80:	fc 91       	ld	r31, X
     a82:	18 97       	sbiw	r26, 0x08	; 8
     a84:	c6 81       	ldd	r28, Z+6	; 0x06
     a86:	d7 81       	ldd	r29, Z+7	; 0x07
     a88:	6f e1       	ldi	r22, 0x1F	; 31
     a8a:	70 e2       	ldi	r23, 0x20	; 32
     a8c:	ce 01       	movw	r24, r28
     a8e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     a92:	66 e0       	ldi	r22, 0x06	; 6
     a94:	ce 01       	movw	r24, r28
     a96:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	08 95       	ret

00000aa0 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	dc 01       	movw	r26, r24
     aa6:	17 96       	adiw	r26, 0x07	; 7
     aa8:	ed 91       	ld	r30, X+
     aaa:	fc 91       	ld	r31, X
     aac:	18 97       	sbiw	r26, 0x08	; 8
     aae:	c6 81       	ldd	r28, Z+6	; 0x06
     ab0:	d7 81       	ldd	r29, Z+7	; 0x07
     ab2:	68 e2       	ldi	r22, 0x28	; 40
     ab4:	70 e2       	ldi	r23, 0x20	; 32
     ab6:	ce 01       	movw	r24, r28
     ab8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     abc:	66 e0       	ldi	r22, 0x06	; 6
     abe:	ce 01       	movw	r24, r28
     ac0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     ac4:	df 91       	pop	r29
     ac6:	cf 91       	pop	r28
     ac8:	08 95       	ret

00000aca <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     aca:	cf 93       	push	r28
     acc:	df 93       	push	r29
     ace:	dc 01       	movw	r26, r24
     ad0:	17 96       	adiw	r26, 0x07	; 7
     ad2:	ed 91       	ld	r30, X+
     ad4:	fc 91       	ld	r31, X
     ad6:	18 97       	sbiw	r26, 0x08	; 8
     ad8:	c6 81       	ldd	r28, Z+6	; 0x06
     ada:	d7 81       	ldd	r29, Z+7	; 0x07
     adc:	61 e3       	ldi	r22, 0x31	; 49
     ade:	70 e2       	ldi	r23, 0x20	; 32
     ae0:	ce 01       	movw	r24, r28
     ae2:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     ae6:	66 e0       	ldi	r22, 0x06	; 6
     ae8:	ce 01       	movw	r24, r28
     aea:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     aee:	df 91       	pop	r29
     af0:	cf 91       	pop	r28
     af2:	08 95       	ret

00000af4 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     af4:	cf 93       	push	r28
     af6:	df 93       	push	r29
     af8:	dc 01       	movw	r26, r24
     afa:	17 96       	adiw	r26, 0x07	; 7
     afc:	ed 91       	ld	r30, X+
     afe:	fc 91       	ld	r31, X
     b00:	18 97       	sbiw	r26, 0x08	; 8
     b02:	c6 81       	ldd	r28, Z+6	; 0x06
     b04:	d7 81       	ldd	r29, Z+7	; 0x07
     b06:	6c e3       	ldi	r22, 0x3C	; 60
     b08:	70 e2       	ldi	r23, 0x20	; 32
     b0a:	ce 01       	movw	r24, r28
     b0c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     b10:	66 e0       	ldi	r22, 0x06	; 6
     b12:	ce 01       	movw	r24, r28
     b14:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
     b1c:	08 95       	ret

00000b1e <_ZN9I2CMaster10StartState11serialDebugEv>:
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	dc 01       	movw	r26, r24
     b24:	17 96       	adiw	r26, 0x07	; 7
     b26:	ed 91       	ld	r30, X+
     b28:	fc 91       	ld	r31, X
     b2a:	18 97       	sbiw	r26, 0x08	; 8
     b2c:	c6 81       	ldd	r28, Z+6	; 0x06
     b2e:	d7 81       	ldd	r29, Z+7	; 0x07
     b30:	67 e4       	ldi	r22, 0x47	; 71
     b32:	70 e2       	ldi	r23, 0x20	; 32
     b34:	ce 01       	movw	r24, r28
     b36:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     b3a:	66 e0       	ldi	r22, 0x06	; 6
     b3c:	ce 01       	movw	r24, r28
     b3e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     b42:	df 91       	pop	r29
     b44:	cf 91       	pop	r28
     b46:	08 95       	ret

00000b48 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     b48:	0f 93       	push	r16
     b4a:	1f 93       	push	r17
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
     b50:	8c 01       	movw	r16, r24
     b52:	eb 01       	movw	r28, r22
     b54:	e8 81       	ld	r30, Y
     b56:	f9 81       	ldd	r31, Y+1	; 0x01
     b58:	04 8c       	ldd	r0, Z+28	; 0x1c
     b5a:	f5 8d       	ldd	r31, Z+29	; 0x1d
     b5c:	e0 2d       	mov	r30, r0
     b5e:	cb 01       	movw	r24, r22
     b60:	19 95       	eicall
     b62:	2a 85       	ldd	r18, Y+10	; 0x0a
     b64:	30 e0       	ldi	r19, 0x00	; 0
     b66:	82 17       	cp	r24, r18
     b68:	93 07       	cpc	r25, r19
     b6a:	79 f4       	brne	.+30     	; 0xb8a <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     b6c:	d8 01       	movw	r26, r16
     b6e:	17 96       	adiw	r26, 0x07	; 7
     b70:	ed 91       	ld	r30, X+
     b72:	fc 91       	ld	r31, X
     b74:	18 97       	sbiw	r26, 0x08	; 8
     b76:	04 80       	ldd	r0, Z+4	; 0x04
     b78:	f5 81       	ldd	r31, Z+5	; 0x05
     b7a:	e0 2d       	mov	r30, r0
     b7c:	87 e0       	ldi	r24, 0x07	; 7
     b7e:	83 83       	std	Z+3, r24	; 0x03
     b80:	12 96       	adiw	r26, 0x02	; 2
     b82:	8d 91       	ld	r24, X+
     b84:	9c 91       	ld	r25, X
     b86:	13 97       	sbiw	r26, 0x03	; 3
     b88:	0e c0       	rjmp	.+28     	; 0xba6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     b8a:	d8 01       	movw	r26, r16
     b8c:	17 96       	adiw	r26, 0x07	; 7
     b8e:	ed 91       	ld	r30, X+
     b90:	fc 91       	ld	r31, X
     b92:	18 97       	sbiw	r26, 0x08	; 8
     b94:	04 80       	ldd	r0, Z+4	; 0x04
     b96:	f5 81       	ldd	r31, Z+5	; 0x05
     b98:	e0 2d       	mov	r30, r0
     b9a:	82 e0       	ldi	r24, 0x02	; 2
     b9c:	83 83       	std	Z+3, r24	; 0x03
     b9e:	14 96       	adiw	r26, 0x04	; 4
     ba0:	8d 91       	ld	r24, X+
     ba2:	9c 91       	ld	r25, X
     ba4:	15 97       	sbiw	r26, 0x05	; 5
     ba6:	df 91       	pop	r29
     ba8:	cf 91       	pop	r28
     baa:	1f 91       	pop	r17
     bac:	0f 91       	pop	r16
     bae:	08 95       	ret

00000bb0 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>:
     bb0:	cf 92       	push	r12
     bb2:	df 92       	push	r13
     bb4:	ef 92       	push	r14
     bb6:	ff 92       	push	r15
     bb8:	0f 93       	push	r16
     bba:	1f 93       	push	r17
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ec 01       	movw	r28, r24
     bc2:	8b 01       	movw	r16, r22
     bc4:	6a 01       	movw	r12, r20
     bc6:	68 83       	st	Y, r22
     bc8:	79 83       	std	Y+1, r23	; 0x01
     bca:	4a 83       	std	Y+2, r20	; 0x02
     bcc:	5b 83       	std	Y+3, r21	; 0x03
     bce:	8b e0       	ldi	r24, 0x0B	; 11
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     bd6:	7c 01       	movw	r14, r24
     bd8:	fc 01       	movw	r30, r24
     bda:	16 82       	std	Z+6, r1	; 0x06
     bdc:	80 e9       	ldi	r24, 0x90	; 144
     bde:	90 e2       	ldi	r25, 0x20	; 32
     be0:	80 83       	st	Z, r24
     be2:	91 83       	std	Z+1, r25	; 0x01
     be4:	07 83       	std	Z+7, r16	; 0x07
     be6:	10 87       	std	Z+8, r17	; 0x08
     be8:	c1 86       	std	Z+9, r12	; 0x09
     bea:	d2 86       	std	Z+10, r13	; 0x0a
     bec:	f8 01       	movw	r30, r16
     bee:	c6 80       	ldd	r12, Z+6	; 0x06
     bf0:	d7 80       	ldd	r13, Z+7	; 0x07
     bf2:	6d e4       	ldi	r22, 0x4D	; 77
     bf4:	70 e2       	ldi	r23, 0x20	; 32
     bf6:	c6 01       	movw	r24, r12
     bf8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     bfc:	b6 01       	movw	r22, r12
     bfe:	c6 01       	movw	r24, r12
     c00:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <_ZN8emstreamlsEPv>
     c04:	66 e0       	ldi	r22, 0x06	; 6
     c06:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     c0a:	ee 82       	std	Y+6, r14	; 0x06
     c0c:	ff 82       	std	Y+7, r15	; 0x07
     c0e:	8b e0       	ldi	r24, 0x0B	; 11
     c10:	90 e0       	ldi	r25, 0x00	; 0
     c12:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     c16:	fc 01       	movw	r30, r24
     c18:	8d 89       	ldd	r24, Y+21	; 0x15
     c1a:	9e 89       	ldd	r25, Y+22	; 0x16
     c1c:	16 82       	std	Z+6, r1	; 0x06
     c1e:	28 e9       	ldi	r18, 0x98	; 152
     c20:	30 e2       	ldi	r19, 0x20	; 32
     c22:	20 83       	st	Z, r18
     c24:	31 83       	std	Z+1, r19	; 0x01
     c26:	07 83       	std	Z+7, r16	; 0x07
     c28:	10 87       	std	Z+8, r17	; 0x08
     c2a:	81 87       	std	Z+9, r24	; 0x09
     c2c:	92 87       	std	Z+10, r25	; 0x0a
     c2e:	e8 87       	std	Y+8, r30	; 0x08
     c30:	f9 87       	std	Y+9, r31	; 0x09
     c32:	89 e0       	ldi	r24, 0x09	; 9
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     c3a:	fc 01       	movw	r30, r24
     c3c:	16 82       	std	Z+6, r1	; 0x06
     c3e:	88 ea       	ldi	r24, 0xA8	; 168
     c40:	90 e2       	ldi	r25, 0x20	; 32
     c42:	80 83       	st	Z, r24
     c44:	91 83       	std	Z+1, r25	; 0x01
     c46:	07 83       	std	Z+7, r16	; 0x07
     c48:	10 87       	std	Z+8, r17	; 0x08
     c4a:	ea 87       	std	Y+10, r30	; 0x0a
     c4c:	fb 87       	std	Y+11, r31	; 0x0b
     c4e:	89 e0       	ldi	r24, 0x09	; 9
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     c56:	fc 01       	movw	r30, r24
     c58:	16 82       	std	Z+6, r1	; 0x06
     c5a:	88 eb       	ldi	r24, 0xB8	; 184
     c5c:	90 e2       	ldi	r25, 0x20	; 32
     c5e:	80 83       	st	Z, r24
     c60:	91 83       	std	Z+1, r25	; 0x01
     c62:	07 83       	std	Z+7, r16	; 0x07
     c64:	10 87       	std	Z+8, r17	; 0x08
     c66:	ec 87       	std	Y+12, r30	; 0x0c
     c68:	fd 87       	std	Y+13, r31	; 0x0d
     c6a:	89 e0       	ldi	r24, 0x09	; 9
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     c72:	fc 01       	movw	r30, r24
     c74:	16 82       	std	Z+6, r1	; 0x06
     c76:	80 ed       	ldi	r24, 0xD0	; 208
     c78:	90 e2       	ldi	r25, 0x20	; 32
     c7a:	80 83       	st	Z, r24
     c7c:	91 83       	std	Z+1, r25	; 0x01
     c7e:	07 83       	std	Z+7, r16	; 0x07
     c80:	10 87       	std	Z+8, r17	; 0x08
     c82:	ee 87       	std	Y+14, r30	; 0x0e
     c84:	ff 87       	std	Y+15, r31	; 0x0f
     c86:	89 e0       	ldi	r24, 0x09	; 9
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     c8e:	fc 01       	movw	r30, r24
     c90:	16 82       	std	Z+6, r1	; 0x06
     c92:	88 ec       	ldi	r24, 0xC8	; 200
     c94:	90 e2       	ldi	r25, 0x20	; 32
     c96:	80 83       	st	Z, r24
     c98:	91 83       	std	Z+1, r25	; 0x01
     c9a:	07 83       	std	Z+7, r16	; 0x07
     c9c:	10 87       	std	Z+8, r17	; 0x08
     c9e:	e8 8b       	std	Y+16, r30	; 0x10
     ca0:	f9 8b       	std	Y+17, r31	; 0x11
     ca2:	80 e1       	ldi	r24, 0x10	; 16
     ca4:	97 e2       	ldi	r25, 0x27	; 39
     ca6:	8d 8b       	std	Y+21, r24	; 0x15
     ca8:	9e 8b       	std	Y+22, r25	; 0x16
     caa:	88 85       	ldd	r24, Y+8	; 0x08
     cac:	99 85       	ldd	r25, Y+9	; 0x09
     cae:	ee 81       	ldd	r30, Y+6	; 0x06
     cb0:	ff 81       	ldd	r31, Y+7	; 0x07
     cb2:	82 83       	std	Z+2, r24	; 0x02
     cb4:	93 83       	std	Z+3, r25	; 0x03
     cb6:	84 83       	std	Z+4, r24	; 0x04
     cb8:	95 83       	std	Z+5, r25	; 0x05
     cba:	8e 85       	ldd	r24, Y+14	; 0x0e
     cbc:	9f 85       	ldd	r25, Y+15	; 0x0f
     cbe:	2a 85       	ldd	r18, Y+10	; 0x0a
     cc0:	3b 85       	ldd	r19, Y+11	; 0x0b
     cc2:	e8 85       	ldd	r30, Y+8	; 0x08
     cc4:	f9 85       	ldd	r31, Y+9	; 0x09
     cc6:	22 83       	std	Z+2, r18	; 0x02
     cc8:	33 83       	std	Z+3, r19	; 0x03
     cca:	84 83       	std	Z+4, r24	; 0x04
     ccc:	95 83       	std	Z+5, r25	; 0x05
     cce:	8c 85       	ldd	r24, Y+12	; 0x0c
     cd0:	9d 85       	ldd	r25, Y+13	; 0x0d
     cd2:	ea 85       	ldd	r30, Y+10	; 0x0a
     cd4:	fb 85       	ldd	r31, Y+11	; 0x0b
     cd6:	82 83       	std	Z+2, r24	; 0x02
     cd8:	93 83       	std	Z+3, r25	; 0x03
     cda:	84 83       	std	Z+4, r24	; 0x04
     cdc:	95 83       	std	Z+5, r25	; 0x05
     cde:	88 85       	ldd	r24, Y+8	; 0x08
     ce0:	99 85       	ldd	r25, Y+9	; 0x09
     ce2:	28 89       	ldd	r18, Y+16	; 0x10
     ce4:	39 89       	ldd	r19, Y+17	; 0x11
     ce6:	ec 85       	ldd	r30, Y+12	; 0x0c
     ce8:	fd 85       	ldd	r31, Y+13	; 0x0d
     cea:	22 83       	std	Z+2, r18	; 0x02
     cec:	33 83       	std	Z+3, r19	; 0x03
     cee:	84 83       	std	Z+4, r24	; 0x04
     cf0:	95 83       	std	Z+5, r25	; 0x05
     cf2:	df 91       	pop	r29
     cf4:	cf 91       	pop	r28
     cf6:	1f 91       	pop	r17
     cf8:	0f 91       	pop	r16
     cfa:	ff 90       	pop	r15
     cfc:	ef 90       	pop	r14
     cfe:	df 90       	pop	r13
     d00:	cf 90       	pop	r12
     d02:	08 95       	ret

00000d04 <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>:
     d04:	cf 92       	push	r12
     d06:	df 92       	push	r13
     d08:	ef 92       	push	r14
     d0a:	ff 92       	push	r15
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	ec 01       	movw	r28, r24
     d16:	8b 01       	movw	r16, r22
     d18:	6a 01       	movw	r12, r20
     d1a:	68 83       	st	Y, r22
     d1c:	79 83       	std	Y+1, r23	; 0x01
     d1e:	4a 83       	std	Y+2, r20	; 0x02
     d20:	5b 83       	std	Y+3, r21	; 0x03
     d22:	8b e0       	ldi	r24, 0x0B	; 11
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     d2a:	7c 01       	movw	r14, r24
     d2c:	fc 01       	movw	r30, r24
     d2e:	16 82       	std	Z+6, r1	; 0x06
     d30:	80 e9       	ldi	r24, 0x90	; 144
     d32:	90 e2       	ldi	r25, 0x20	; 32
     d34:	80 83       	st	Z, r24
     d36:	91 83       	std	Z+1, r25	; 0x01
     d38:	07 83       	std	Z+7, r16	; 0x07
     d3a:	10 87       	std	Z+8, r17	; 0x08
     d3c:	c1 86       	std	Z+9, r12	; 0x09
     d3e:	d2 86       	std	Z+10, r13	; 0x0a
     d40:	f8 01       	movw	r30, r16
     d42:	c6 80       	ldd	r12, Z+6	; 0x06
     d44:	d7 80       	ldd	r13, Z+7	; 0x07
     d46:	6d e4       	ldi	r22, 0x4D	; 77
     d48:	70 e2       	ldi	r23, 0x20	; 32
     d4a:	c6 01       	movw	r24, r12
     d4c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
     d50:	b6 01       	movw	r22, r12
     d52:	c6 01       	movw	r24, r12
     d54:	0e 94 f2 1f 	call	0x3fe4	; 0x3fe4 <_ZN8emstreamlsEPv>
     d58:	66 e0       	ldi	r22, 0x06	; 6
     d5a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
     d5e:	ee 82       	std	Y+6, r14	; 0x06
     d60:	ff 82       	std	Y+7, r15	; 0x07
     d62:	8b e0       	ldi	r24, 0x0B	; 11
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     d6a:	fc 01       	movw	r30, r24
     d6c:	8d 89       	ldd	r24, Y+21	; 0x15
     d6e:	9e 89       	ldd	r25, Y+22	; 0x16
     d70:	16 82       	std	Z+6, r1	; 0x06
     d72:	20 ea       	ldi	r18, 0xA0	; 160
     d74:	30 e2       	ldi	r19, 0x20	; 32
     d76:	20 83       	st	Z, r18
     d78:	31 83       	std	Z+1, r19	; 0x01
     d7a:	07 83       	std	Z+7, r16	; 0x07
     d7c:	10 87       	std	Z+8, r17	; 0x08
     d7e:	81 87       	std	Z+9, r24	; 0x09
     d80:	92 87       	std	Z+10, r25	; 0x0a
     d82:	e8 87       	std	Y+8, r30	; 0x08
     d84:	f9 87       	std	Y+9, r31	; 0x09
     d86:	89 e0       	ldi	r24, 0x09	; 9
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     d8e:	fc 01       	movw	r30, r24
     d90:	16 82       	std	Z+6, r1	; 0x06
     d92:	80 eb       	ldi	r24, 0xB0	; 176
     d94:	90 e2       	ldi	r25, 0x20	; 32
     d96:	80 83       	st	Z, r24
     d98:	91 83       	std	Z+1, r25	; 0x01
     d9a:	07 83       	std	Z+7, r16	; 0x07
     d9c:	10 87       	std	Z+8, r17	; 0x08
     d9e:	ea 87       	std	Y+10, r30	; 0x0a
     da0:	fb 87       	std	Y+11, r31	; 0x0b
     da2:	89 e0       	ldi	r24, 0x09	; 9
     da4:	90 e0       	ldi	r25, 0x00	; 0
     da6:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     daa:	fc 01       	movw	r30, r24
     dac:	16 82       	std	Z+6, r1	; 0x06
     dae:	80 ec       	ldi	r24, 0xC0	; 192
     db0:	90 e2       	ldi	r25, 0x20	; 32
     db2:	80 83       	st	Z, r24
     db4:	91 83       	std	Z+1, r25	; 0x01
     db6:	07 83       	std	Z+7, r16	; 0x07
     db8:	10 87       	std	Z+8, r17	; 0x08
     dba:	ec 87       	std	Y+12, r30	; 0x0c
     dbc:	fd 87       	std	Y+13, r31	; 0x0d
     dbe:	89 e0       	ldi	r24, 0x09	; 9
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     dc6:	fc 01       	movw	r30, r24
     dc8:	16 82       	std	Z+6, r1	; 0x06
     dca:	80 ed       	ldi	r24, 0xD0	; 208
     dcc:	90 e2       	ldi	r25, 0x20	; 32
     dce:	80 83       	st	Z, r24
     dd0:	91 83       	std	Z+1, r25	; 0x01
     dd2:	07 83       	std	Z+7, r16	; 0x07
     dd4:	10 87       	std	Z+8, r17	; 0x08
     dd6:	ee 87       	std	Y+14, r30	; 0x0e
     dd8:	ff 87       	std	Y+15, r31	; 0x0f
     dda:	89 e0       	ldi	r24, 0x09	; 9
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
     de2:	fc 01       	movw	r30, r24
     de4:	16 82       	std	Z+6, r1	; 0x06
     de6:	88 ec       	ldi	r24, 0xC8	; 200
     de8:	90 e2       	ldi	r25, 0x20	; 32
     dea:	80 83       	st	Z, r24
     dec:	91 83       	std	Z+1, r25	; 0x01
     dee:	07 83       	std	Z+7, r16	; 0x07
     df0:	10 87       	std	Z+8, r17	; 0x08
     df2:	e8 8b       	std	Y+16, r30	; 0x10
     df4:	f9 8b       	std	Y+17, r31	; 0x11
     df6:	80 e1       	ldi	r24, 0x10	; 16
     df8:	97 e2       	ldi	r25, 0x27	; 39
     dfa:	8d 8b       	std	Y+21, r24	; 0x15
     dfc:	9e 8b       	std	Y+22, r25	; 0x16
     dfe:	88 85       	ldd	r24, Y+8	; 0x08
     e00:	99 85       	ldd	r25, Y+9	; 0x09
     e02:	ee 81       	ldd	r30, Y+6	; 0x06
     e04:	ff 81       	ldd	r31, Y+7	; 0x07
     e06:	82 83       	std	Z+2, r24	; 0x02
     e08:	93 83       	std	Z+3, r25	; 0x03
     e0a:	84 83       	std	Z+4, r24	; 0x04
     e0c:	95 83       	std	Z+5, r25	; 0x05
     e0e:	8e 85       	ldd	r24, Y+14	; 0x0e
     e10:	9f 85       	ldd	r25, Y+15	; 0x0f
     e12:	2a 85       	ldd	r18, Y+10	; 0x0a
     e14:	3b 85       	ldd	r19, Y+11	; 0x0b
     e16:	e8 85       	ldd	r30, Y+8	; 0x08
     e18:	f9 85       	ldd	r31, Y+9	; 0x09
     e1a:	22 83       	std	Z+2, r18	; 0x02
     e1c:	33 83       	std	Z+3, r19	; 0x03
     e1e:	84 83       	std	Z+4, r24	; 0x04
     e20:	95 83       	std	Z+5, r25	; 0x05
     e22:	8c 85       	ldd	r24, Y+12	; 0x0c
     e24:	9d 85       	ldd	r25, Y+13	; 0x0d
     e26:	ea 85       	ldd	r30, Y+10	; 0x0a
     e28:	fb 85       	ldd	r31, Y+11	; 0x0b
     e2a:	82 83       	std	Z+2, r24	; 0x02
     e2c:	93 83       	std	Z+3, r25	; 0x03
     e2e:	84 83       	std	Z+4, r24	; 0x04
     e30:	95 83       	std	Z+5, r25	; 0x05
     e32:	88 85       	ldd	r24, Y+8	; 0x08
     e34:	99 85       	ldd	r25, Y+9	; 0x09
     e36:	28 89       	ldd	r18, Y+16	; 0x10
     e38:	39 89       	ldd	r19, Y+17	; 0x11
     e3a:	ec 85       	ldd	r30, Y+12	; 0x0c
     e3c:	fd 85       	ldd	r31, Y+13	; 0x0d
     e3e:	22 83       	std	Z+2, r18	; 0x02
     e40:	33 83       	std	Z+3, r19	; 0x03
     e42:	84 83       	std	Z+4, r24	; 0x04
     e44:	95 83       	std	Z+5, r25	; 0x05
     e46:	df 91       	pop	r29
     e48:	cf 91       	pop	r28
     e4a:	1f 91       	pop	r17
     e4c:	0f 91       	pop	r16
     e4e:	ff 90       	pop	r15
     e50:	ef 90       	pop	r14
     e52:	df 90       	pop	r13
     e54:	cf 90       	pop	r12
     e56:	08 95       	ret

00000e58 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e58:	0f 93       	push	r16
     e5a:	1f 93       	push	r17
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
     e60:	ec 01       	movw	r28, r24
     e62:	8b 01       	movw	r16, r22
     e64:	8e 81       	ldd	r24, Y+6	; 0x06
     e66:	9f 81       	ldd	r25, Y+7	; 0x07
     e68:	8c 83       	std	Y+4, r24	; 0x04
     e6a:	9d 83       	std	Y+5, r25	; 0x05
     e6c:	28 89       	ldd	r18, Y+16	; 0x10
     e6e:	39 89       	ldd	r19, Y+17	; 0x11
     e70:	82 17       	cp	r24, r18
     e72:	93 07       	cpc	r25, r19
     e74:	d9 f0       	breq	.+54     	; 0xeac <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     e76:	2e 85       	ldd	r18, Y+14	; 0x0e
     e78:	3f 85       	ldd	r19, Y+15	; 0x0f
     e7a:	82 17       	cp	r24, r18
     e7c:	93 07       	cpc	r25, r19
     e7e:	31 f4       	brne	.+12     	; 0xe8c <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     e80:	17 c0       	rjmp	.+46     	; 0xeb0 <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     e82:	2e 85       	ldd	r18, Y+14	; 0x0e
     e84:	3f 85       	ldd	r19, Y+15	; 0x0f
     e86:	28 17       	cp	r18, r24
     e88:	39 07       	cpc	r19, r25
     e8a:	99 f0       	breq	.+38     	; 0xeb2 <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e8c:	dc 01       	movw	r26, r24
     e8e:	ed 91       	ld	r30, X+
     e90:	fc 91       	ld	r31, X
     e92:	01 90       	ld	r0, Z+
     e94:	f0 81       	ld	r31, Z
     e96:	e0 2d       	mov	r30, r0
     e98:	b8 01       	movw	r22, r16
     e9a:	19 95       	eicall
     e9c:	8c 83       	std	Y+4, r24	; 0x04
     e9e:	9d 83       	std	Y+5, r25	; 0x05
     ea0:	28 89       	ldd	r18, Y+16	; 0x10
     ea2:	39 89       	ldd	r19, Y+17	; 0x11
     ea4:	28 17       	cp	r18, r24
     ea6:	39 07       	cpc	r19, r25
     ea8:	61 f7       	brne	.-40     	; 0xe82 <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     eaa:	03 c0       	rjmp	.+6      	; 0xeb2 <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     eac:	c9 01       	movw	r24, r18
     eae:	01 c0       	rjmp	.+2      	; 0xeb2 <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     eb0:	c9 01       	movw	r24, r18
     eb2:	dc 01       	movw	r26, r24
     eb4:	ed 91       	ld	r30, X+
     eb6:	fc 91       	ld	r31, X
     eb8:	01 90       	ld	r0, Z+
     eba:	f0 81       	ld	r31, Z
     ebc:	e0 2d       	mov	r30, r0
     ebe:	b8 01       	movw	r22, r16
     ec0:	19 95       	eicall
     ec2:	81 e0       	ldi	r24, 0x01	; 1
     ec4:	4c 81       	ldd	r20, Y+4	; 0x04
     ec6:	5d 81       	ldd	r21, Y+5	; 0x05
     ec8:	28 89       	ldd	r18, Y+16	; 0x10
     eca:	39 89       	ldd	r19, Y+17	; 0x11
     ecc:	42 17       	cp	r20, r18
     ece:	53 07       	cpc	r21, r19
     ed0:	09 f0       	breq	.+2      	; 0xed4 <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     ed2:	80 e0       	ldi	r24, 0x00	; 0
     ed4:	df 91       	pop	r29
     ed6:	cf 91       	pop	r28
     ed8:	1f 91       	pop	r17
     eda:	0f 91       	pop	r16
     edc:	08 95       	ret

00000ede <_ZN9I2CMaster8Receiver3runER6Packet>:
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	ec 01       	movw	r28, r24
     ee8:	8b 01       	movw	r16, r22
     eea:	8e 81       	ldd	r24, Y+6	; 0x06
     eec:	9f 81       	ldd	r25, Y+7	; 0x07
     eee:	8c 83       	std	Y+4, r24	; 0x04
     ef0:	9d 83       	std	Y+5, r25	; 0x05
     ef2:	28 89       	ldd	r18, Y+16	; 0x10
     ef4:	39 89       	ldd	r19, Y+17	; 0x11
     ef6:	82 17       	cp	r24, r18
     ef8:	93 07       	cpc	r25, r19
     efa:	d9 f0       	breq	.+54     	; 0xf32 <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     efc:	2e 85       	ldd	r18, Y+14	; 0x0e
     efe:	3f 85       	ldd	r19, Y+15	; 0x0f
     f00:	82 17       	cp	r24, r18
     f02:	93 07       	cpc	r25, r19
     f04:	31 f4       	brne	.+12     	; 0xf12 <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     f06:	17 c0       	rjmp	.+46     	; 0xf36 <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     f08:	2e 85       	ldd	r18, Y+14	; 0x0e
     f0a:	3f 85       	ldd	r19, Y+15	; 0x0f
     f0c:	28 17       	cp	r18, r24
     f0e:	39 07       	cpc	r19, r25
     f10:	99 f0       	breq	.+38     	; 0xf38 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f12:	dc 01       	movw	r26, r24
     f14:	ed 91       	ld	r30, X+
     f16:	fc 91       	ld	r31, X
     f18:	01 90       	ld	r0, Z+
     f1a:	f0 81       	ld	r31, Z
     f1c:	e0 2d       	mov	r30, r0
     f1e:	b8 01       	movw	r22, r16
     f20:	19 95       	eicall
     f22:	8c 83       	std	Y+4, r24	; 0x04
     f24:	9d 83       	std	Y+5, r25	; 0x05
     f26:	28 89       	ldd	r18, Y+16	; 0x10
     f28:	39 89       	ldd	r19, Y+17	; 0x11
     f2a:	28 17       	cp	r18, r24
     f2c:	39 07       	cpc	r19, r25
     f2e:	61 f7       	brne	.-40     	; 0xf08 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     f30:	03 c0       	rjmp	.+6      	; 0xf38 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f32:	c9 01       	movw	r24, r18
     f34:	01 c0       	rjmp	.+2      	; 0xf38 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f36:	c9 01       	movw	r24, r18
     f38:	dc 01       	movw	r26, r24
     f3a:	ed 91       	ld	r30, X+
     f3c:	fc 91       	ld	r31, X
     f3e:	01 90       	ld	r0, Z+
     f40:	f0 81       	ld	r31, Z
     f42:	e0 2d       	mov	r30, r0
     f44:	b8 01       	movw	r22, r16
     f46:	19 95       	eicall
     f48:	c8 01       	movw	r24, r16
     f4a:	df 91       	pop	r29
     f4c:	cf 91       	pop	r28
     f4e:	1f 91       	pop	r17
     f50:	0f 91       	pop	r16
     f52:	08 95       	ret

00000f54 <_ZN9I2CMaster12set_baudrateEm>:
     f54:	cf 93       	push	r28
     f56:	df 93       	push	r29
     f58:	ec 01       	movw	r28, r24
     f5a:	9a 01       	movw	r18, r20
     f5c:	ab 01       	movw	r20, r22
     f5e:	22 0f       	add	r18, r18
     f60:	33 1f       	adc	r19, r19
     f62:	44 1f       	adc	r20, r20
     f64:	55 1f       	adc	r21, r21
     f66:	60 e0       	ldi	r22, 0x00	; 0
     f68:	78 e4       	ldi	r23, 0x48	; 72
     f6a:	88 ee       	ldi	r24, 0xE8	; 232
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
     f72:	25 50       	subi	r18, 0x05	; 5
     f74:	2a 87       	std	Y+10, r18	; 0x0a
     f76:	ec 81       	ldd	r30, Y+4	; 0x04
     f78:	fd 81       	ldd	r31, Y+5	; 0x05
     f7a:	25 83       	std	Z+5, r18	; 0x05
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	08 95       	ret

00000f82 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
     f82:	dc 01       	movw	r26, r24
     f84:	14 96       	adiw	r26, 0x04	; 4
     f86:	ed 91       	ld	r30, X+
     f88:	fc 91       	ld	r31, X
     f8a:	15 97       	sbiw	r26, 0x05	; 5
     f8c:	83 81       	ldd	r24, Z+3	; 0x03
     f8e:	81 60       	ori	r24, 0x01	; 1
     f90:	83 83       	std	Z+3, r24	; 0x03
     f92:	08 95       	ret

00000f94 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	cf 93       	push	r28
     f9a:	df 93       	push	r29
     f9c:	ec 01       	movw	r28, r24
     f9e:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
     fa0:	db 01       	movw	r26, r22
     fa2:	ed 91       	ld	r30, X+
     fa4:	fc 91       	ld	r31, X
     fa6:	02 84       	ldd	r0, Z+10	; 0x0a
     fa8:	f3 85       	ldd	r31, Z+11	; 0x0b
     faa:	e0 2d       	mov	r30, r0
     fac:	00 e0       	ldi	r16, 0x00	; 0
     fae:	10 e0       	ldi	r17, 0x00	; 0
     fb0:	b8 01       	movw	r22, r16
     fb2:	19 95       	eicall
  driver_->send_start();
     fb4:	8f 81       	ldd	r24, Y+7	; 0x07
     fb6:	98 85       	ldd	r25, Y+8	; 0x08
     fb8:	0e 94 c1 07 	call	0xf82	; 0xf82 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
     fbc:	ef 81       	ldd	r30, Y+7	; 0x07
     fbe:	f8 85       	ldd	r31, Y+8	; 0x08
     fc0:	04 80       	ldd	r0, Z+4	; 0x04
     fc2:	f5 81       	ldd	r31, Z+5	; 0x05
     fc4:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
     fc6:	d8 01       	movw	r26, r16
     fc8:	8c 91       	ld	r24, X
     fca:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
     fcc:	8a 81       	ldd	r24, Y+2	; 0x02
     fce:	9b 81       	ldd	r25, Y+3	; 0x03
     fd0:	df 91       	pop	r29
     fd2:	cf 91       	pop	r28
     fd4:	1f 91       	pop	r17
     fd6:	0f 91       	pop	r16
     fd8:	08 95       	ret

00000fda <_ZN9I2CMaster8is_readyEh>:
  
  return addr_list;
}

bool I2CMaster::is_ready (uint8_t addr)
{
     fda:	ff 92       	push	r15
     fdc:	0f 93       	push	r16
     fde:	1f 93       	push	r17
     fe0:	cf 93       	push	r28
     fe2:	df 93       	push	r29
     fe4:	1f 92       	push	r1
     fe6:	1f 92       	push	r1
     fe8:	cd b7       	in	r28, 0x3d	; 61
     fea:	de b7       	in	r29, 0x3e	; 62
     fec:	8c 01       	movw	r16, r24
     fee:	f6 2e       	mov	r15, r22
  volatile uint16_t counter = 500;
     ff0:	84 ef       	ldi	r24, 0xF4	; 244
     ff2:	91 e0       	ldi	r25, 0x01	; 1
     ff4:	89 83       	std	Y+1, r24	; 0x01
     ff6:	9a 83       	std	Y+2, r25	; 0x02
  send_start();
     ff8:	c8 01       	movw	r24, r16
     ffa:	0e 94 c1 07 	call	0xf82	; 0xf82 <_ZN9I2CMaster10send_startEv>
  interface_->MASTER.ADDR = addr << 1;
     ffe:	d8 01       	movw	r26, r16
    1000:	14 96       	adiw	r26, 0x04	; 4
    1002:	ed 91       	ld	r30, X+
    1004:	fc 91       	ld	r31, X
    1006:	15 97       	sbiw	r26, 0x05	; 5
    1008:	ff 0c       	add	r15, r15
    100a:	f6 82       	std	Z+6, r15	; 0x06
  
  while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	9a 81       	ldd	r25, Y+2	; 0x02
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	89 83       	std	Y+1, r24	; 0x01
    1014:	9a 83       	std	Y+2, r25	; 0x02
    1016:	89 2b       	or	r24, r25
    1018:	41 f0       	breq	.+16     	; 0x102a <_ZN9I2CMaster8is_readyEh+0x50>
    101a:	d8 01       	movw	r26, r16
    101c:	14 96       	adiw	r26, 0x04	; 4
    101e:	ed 91       	ld	r30, X+
    1020:	fc 91       	ld	r31, X
    1022:	15 97       	sbiw	r26, 0x05	; 5
    1024:	84 81       	ldd	r24, Z+4	; 0x04
    1026:	84 fd       	sbrc	r24, 4
    1028:	f1 cf       	rjmp	.-30     	; 0x100c <_ZN9I2CMaster8is_readyEh+0x32>
  if(counter != 0)
    102a:	29 81       	ldd	r18, Y+1	; 0x01
    102c:	3a 81       	ldd	r19, Y+2	; 0x02
    102e:	81 e0       	ldi	r24, 0x01	; 1
    1030:	23 2b       	or	r18, r19
    1032:	09 f4       	brne	.+2      	; 0x1036 <_ZN9I2CMaster8is_readyEh+0x5c>
    1034:	80 e0       	ldi	r24, 0x00	; 0
  else
  {
    return false;
  }
  send_nack_stop();
}
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	08 95       	ret

00001046 <_ZN9I2CMaster4scanEv>:
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
  interface_->MASTER.BAUD = baudrate;
}

uint8_t* I2CMaster::scan (void)
{
    1046:	8f 92       	push	r8
    1048:	9f 92       	push	r9
    104a:	af 92       	push	r10
    104c:	bf 92       	push	r11
    104e:	cf 92       	push	r12
    1050:	df 92       	push	r13
    1052:	ef 92       	push	r14
    1054:	ff 92       	push	r15
    1056:	0f 93       	push	r16
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	1f 92       	push	r1
    1060:	1f 92       	push	r1
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
    1066:	8c 01       	movw	r16, r24
    1068:	dd 24       	eor	r13, r13
    106a:	d3 94       	inc	r13
    106c:	b1 2c       	mov	r11, r1
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    106e:	0f 2e       	mov	r0, r31
    1070:	f4 e6       	ldi	r31, 0x64	; 100
    1072:	ef 2e       	mov	r14, r31
    1074:	f1 2c       	mov	r15, r1
    1076:	f0 2d       	mov	r31, r0
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    1078:	0f 2e       	mov	r0, r31
    107a:	f7 e0       	ldi	r31, 0x07	; 7
    107c:	cf 2e       	mov	r12, r31
    107e:	f0 2d       	mov	r31, r0
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    1080:	e9 82       	std	Y+1, r14	; 0x01
    1082:	fa 82       	std	Y+2, r15	; 0x02
    send_start();
    1084:	c8 01       	movw	r24, r16
    1086:	0e 94 c1 07 	call	0xf82	; 0xf82 <_ZN9I2CMaster10send_startEv>
    interface_->MASTER.ADDR = addr << 1;
    108a:	d8 01       	movw	r26, r16
    108c:	14 96       	adiw	r26, 0x04	; 4
    108e:	ed 91       	ld	r30, X+
    1090:	fc 91       	ld	r31, X
    1092:	15 97       	sbiw	r26, 0x05	; 5
    1094:	8d 2d       	mov	r24, r13
    1096:	88 0f       	add	r24, r24
    1098:	86 83       	std	Z+6, r24	; 0x06
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    109a:	89 81       	ldd	r24, Y+1	; 0x01
    109c:	9a 81       	ldd	r25, Y+2	; 0x02
    109e:	01 97       	sbiw	r24, 0x01	; 1
    10a0:	89 83       	std	Y+1, r24	; 0x01
    10a2:	9a 83       	std	Y+2, r25	; 0x02
    10a4:	89 2b       	or	r24, r25
    10a6:	89 f1       	breq	.+98     	; 0x110a <_ZN9I2CMaster4scanEv+0xc4>
    10a8:	d8 01       	movw	r26, r16
    10aa:	14 96       	adiw	r26, 0x04	; 4
    10ac:	ed 91       	ld	r30, X+
    10ae:	fc 91       	ld	r31, X
    10b0:	15 97       	sbiw	r26, 0x05	; 5
    10b2:	84 81       	ldd	r24, Z+4	; 0x04
    10b4:	84 fd       	sbrc	r24, 4
    10b6:	f1 cf       	rjmp	.-30     	; 0x109a <_ZN9I2CMaster4scanEv+0x54>
    10b8:	28 c0       	rjmp	.+80     	; 0x110a <_ZN9I2CMaster4scanEv+0xc4>
    if(counter != 0)
    {
      uint8_t addr_reg = interface_->MASTER.ADDR;
    10ba:	d8 01       	movw	r26, r16
    10bc:	14 96       	adiw	r26, 0x04	; 4
    10be:	ed 91       	ld	r30, X+
    10c0:	fc 91       	ld	r31, X
    10c2:	15 97       	sbiw	r26, 0x05	; 5
    10c4:	a6 80       	ldd	r10, Z+6	; 0x06
      *p_serial << "Detected i2c addr: " << addr_reg << endl;
    10c6:	16 96       	adiw	r26, 0x06	; 6
    10c8:	8d 90       	ld	r8, X+
    10ca:	9c 90       	ld	r9, X
    10cc:	17 97       	sbiw	r26, 0x07	; 7
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    10ce:	66 e6       	ldi	r22, 0x66	; 102
    10d0:	70 e2       	ldi	r23, 0x20	; 32
    10d2:	c4 01       	movw	r24, r8
    10d4:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    10d8:	6a 2d       	mov	r22, r10
    10da:	c4 01       	movw	r24, r8
    10dc:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    10e0:	66 e0       	ldi	r22, 0x06	; 6
    10e2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
      addr_list[addr_list_index] = addr;
    10e6:	f8 01       	movw	r30, r16
    10e8:	eb 0d       	add	r30, r11
    10ea:	f1 1d       	adc	r31, r1
    10ec:	d7 86       	std	Z+15, r13	; 0x0f
      addr_list_index++;
    10ee:	b3 94       	inc	r11
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    10f0:	d8 01       	movw	r26, r16
    10f2:	14 96       	adiw	r26, 0x04	; 4
    10f4:	ed 91       	ld	r30, X+
    10f6:	fc 91       	ld	r31, X
    10f8:	15 97       	sbiw	r26, 0x05	; 5
    10fa:	c3 82       	std	Z+3, r12	; 0x03
  volatile uint16_t counter;
  
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
    10fc:	d3 94       	inc	r13
    10fe:	b0 e8       	ldi	r27, 0x80	; 128
    1100:	db 12       	cpse	r13, r27
    1102:	be cf       	rjmp	.-132    	; 0x1080 <_ZN9I2CMaster4scanEv+0x3a>

    send_nack_stop();
      
  }
  
  return addr_list;
    1104:	c8 01       	movw	r24, r16
    1106:	0f 96       	adiw	r24, 0x0f	; 15
    1108:	05 c0       	rjmp	.+10     	; 0x1114 <_ZN9I2CMaster4scanEv+0xce>
    counter = 100;
    send_start();
    interface_->MASTER.ADDR = addr << 1;
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    if(counter != 0)
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	89 2b       	or	r24, r25
    1110:	79 f3       	breq	.-34     	; 0x10f0 <_ZN9I2CMaster4scanEv+0xaa>
    1112:	d3 cf       	rjmp	.-90     	; 0x10ba <_ZN9I2CMaster4scanEv+0x74>
    send_nack_stop();
      
  }
  
  return addr_list;
}
    1114:	0f 90       	pop	r0
    1116:	0f 90       	pop	r0
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	1f 91       	pop	r17
    111e:	0f 91       	pop	r16
    1120:	ff 90       	pop	r15
    1122:	ef 90       	pop	r14
    1124:	df 90       	pop	r13
    1126:	cf 90       	pop	r12
    1128:	bf 90       	pop	r11
    112a:	af 90       	pop	r10
    112c:	9f 90       	pop	r9
    112e:	8f 90       	pop	r8
    1130:	08 95       	ret

00001132 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
//   interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

//   interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
// }

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s)
    1132:	ef 92       	push	r14
    1134:	ff 92       	push	r15
    1136:	0f 93       	push	r16
    1138:	1f 93       	push	r17
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	ec 01       	movw	r28, r24
    1140:	7b 01       	movw	r14, r22
    1142:	ba 01       	movw	r22, r20
    1144:	a9 01       	movw	r20, r18
  : interface_(interface), 
    i2c_freq(i2c_freq),
    p_serial(s)
    1146:	ec 82       	std	Y+4, r14	; 0x04
    1148:	fd 82       	std	Y+5, r15	; 0x05
    114a:	0e 83       	std	Y+6, r16	; 0x06
    114c:	1f 83       	std	Y+7, r17	; 0x07
    114e:	4b 87       	std	Y+11, r20	; 0x0b
    1150:	5c 87       	std	Y+12, r21	; 0x0c
    1152:	6d 87       	std	Y+13, r22	; 0x0d
    1154:	7e 87       	std	Y+14, r23	; 0x0e
{ 
  if (interface == &TWIC)
    1156:	80 e8       	ldi	r24, 0x80	; 128
    1158:	e8 16       	cp	r14, r24
    115a:	84 e0       	ldi	r24, 0x04	; 4
    115c:	f8 06       	cpc	r15, r24
    115e:	29 f4       	brne	.+10     	; 0x116a <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
  {
    bus_port = &PORTC;
    1160:	80 e4       	ldi	r24, 0x40	; 64
    1162:	96 e0       	ldi	r25, 0x06	; 6
    1164:	88 87       	std	Y+8, r24	; 0x08
    1166:	99 87       	std	Y+9, r25	; 0x09
    1168:	09 c0       	rjmp	.+18     	; 0x117c <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  }
  if (interface == &TWIE)
    116a:	e0 ea       	ldi	r30, 0xA0	; 160
    116c:	ee 16       	cp	r14, r30
    116e:	e4 e0       	ldi	r30, 0x04	; 4
    1170:	fe 06       	cpc	r15, r30
    1172:	21 f4       	brne	.+8      	; 0x117c <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  {
    bus_port = &PORTE;
    1174:	80 e8       	ldi	r24, 0x80	; 128
    1176:	96 e0       	ldi	r25, 0x06	; 6
    1178:	88 87       	std	Y+8, r24	; 0x08
    117a:	99 87       	std	Y+9, r25	; 0x09
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
    117c:	e8 85       	ldd	r30, Y+8	; 0x08
    117e:	f9 85       	ldd	r31, Y+9	; 0x09
    1180:	83 e0       	ldi	r24, 0x03	; 3
    1182:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
    1184:	e8 85       	ldd	r30, Y+8	; 0x08
    1186:	f9 85       	ldd	r31, Y+9	; 0x09
    1188:	88 e3       	ldi	r24, 0x38	; 56
    118a:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
    118c:	e8 85       	ldd	r30, Y+8	; 0x08
    118e:	f9 85       	ldd	r31, Y+9	; 0x09
    1190:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
    1192:	82 e0       	ldi	r24, 0x02	; 2
    1194:	f7 01       	movw	r30, r14
    1196:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
    1198:	ce 01       	movw	r24, r28
    119a:	0e 94 aa 07 	call	0xf54	; 0xf54 <_ZN9I2CMaster12set_baudrateEm>

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
    119e:	f7 01       	movw	r30, r14
    11a0:	84 81       	ldd	r24, Z+4	; 0x04
    11a2:	8d 6c       	ori	r24, 0xCD	; 205
    11a4:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
    11a6:	88 e0       	ldi	r24, 0x08	; 8
    11a8:	81 83       	std	Z+1, r24	; 0x01

  transmitter_ = new Transmitter(this, s);
    11aa:	87 e1       	ldi	r24, 0x17	; 23
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    11b2:	7c 01       	movw	r14, r24
    11b4:	a8 01       	movw	r20, r16
    11b6:	be 01       	movw	r22, r28
    11b8:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>
    11bc:	e8 82       	st	Y, r14
    11be:	f9 82       	std	Y+1, r15	; 0x01
  receiver_ = new Receiver(this, s);
    11c0:	88 e1       	ldi	r24, 0x18	; 24
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    11c8:	7c 01       	movw	r14, r24
    11ca:	a8 01       	movw	r20, r16
    11cc:	be 01       	movw	r22, r28
    11ce:	0e 94 82 06 	call	0xd04	; 0xd04 <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>
    11d2:	ea 82       	std	Y+2, r14	; 0x02
    11d4:	fb 82       	std	Y+3, r15	; 0x03

  scan();
    11d6:	ce 01       	movw	r24, r28
    11d8:	0e 94 23 08 	call	0x1046	; 0x1046 <_ZN9I2CMaster4scanEv>
  *s << is_ready(29) << endl;
    11dc:	6d e1       	ldi	r22, 0x1D	; 29
    11de:	ce 01       	movw	r24, r28
    11e0:	0e 94 ed 07 	call	0xfda	; 0xfda <_ZN9I2CMaster8is_readyEh>
    11e4:	68 2f       	mov	r22, r24
    11e6:	c8 01       	movw	r24, r16
    11e8:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <_ZN8emstreamlsEb>
    11ec:	66 e0       	ldi	r22, 0x06	; 6
    11ee:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
  emstream *    getSerial()       { return p_serial; }
    11f2:	0e 80       	ldd	r0, Y+6	; 0x06
    11f4:	df 81       	ldd	r29, Y+7	; 0x07
    11f6:	c0 2d       	mov	r28, r0
    11f8:	6a e7       	ldi	r22, 0x7A	; 122
    11fa:	70 e2       	ldi	r23, 0x20	; 32
    11fc:	ce 01       	movw	r24, r28
    11fe:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>

  *(getSerial()) << "I2CMaster created" << endl;
    1202:	66 e0       	ldi	r22, 0x06	; 6
    1204:	ce 01       	movw	r24, r28
    1206:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
}
    120a:	df 91       	pop	r29
    120c:	cf 91       	pop	r28
    120e:	1f 91       	pop	r17
    1210:	0f 91       	pop	r16
    1212:	ff 90       	pop	r15
    1214:	ef 90       	pop	r14
    1216:	08 95       	ret

00001218 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    1218:	fc 01       	movw	r30, r24
    121a:	84 81       	ldd	r24, Z+4	; 0x04
    121c:	95 81       	ldd	r25, Z+5	; 0x05
    121e:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
		}
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	08 95       	ret

00001226 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    1226:	fc 01       	movw	r30, r24
    1228:	84 81       	ldd	r24, Z+4	; 0x04
    122a:	95 81       	ldd	r25, Z+5	; 0x05
    122c:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    1230:	91 e0       	ldi	r25, 0x01	; 1
    1232:	81 11       	cpse	r24, r1
    1234:	01 c0       	rjmp	.+2      	; 0x1238 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    1236:	90 e0       	ldi	r25, 0x00	; 0
		}
    1238:	89 2f       	mov	r24, r25
    123a:	08 95       	ret

0000123c <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    123c:	fc 01       	movw	r30, r24
    123e:	84 81       	ldd	r24, Z+4	; 0x04
    1240:	95 81       	ldd	r25, Z+5	; 0x05
    1242:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    1246:	91 e0       	ldi	r25, 0x01	; 1
    1248:	81 11       	cpse	r24, r1
    124a:	90 e0       	ldi	r25, 0x00	; 0
		}
    124c:	89 2f       	mov	r24, r25
    124e:	08 95       	ret

00001250 <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    1250:	fc 01       	movw	r30, r24
    1252:	84 81       	ldd	r24, Z+4	; 0x04
    1254:	95 81       	ldd	r25, Z+5	; 0x05
    1256:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
		}
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	08 95       	ret

0000125e <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    125e:	fc 01       	movw	r30, r24
    1260:	84 81       	ldd	r24, Z+4	; 0x04
    1262:	95 81       	ldd	r25, Z+5	; 0x05
    1264:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    1268:	91 e0       	ldi	r25, 0x01	; 1
    126a:	81 11       	cpse	r24, r1
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <_ZN9frt_queueIhE9not_emptyEv+0x12>
    126e:	90 e0       	ldi	r25, 0x00	; 0
		}
    1270:	89 2f       	mov	r24, r25
    1272:	08 95       	ret

00001274 <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    1274:	fc 01       	movw	r30, r24
    1276:	84 81       	ldd	r24, Z+4	; 0x04
    1278:	95 81       	ldd	r25, Z+5	; 0x05
    127a:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    127e:	91 e0       	ldi	r25, 0x01	; 1
    1280:	81 11       	cpse	r24, r1
    1282:	90 e0       	ldi	r25, 0x00	; 0
		}
    1284:	89 2f       	mov	r24, r25
    1286:	08 95       	ret

00001288 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    1288:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    128a:	01 e0       	ldi	r16, 0x01	; 1
    128c:	2f ef       	ldi	r18, 0xFF	; 255
    128e:	3f ef       	ldi	r19, 0xFF	; 255
    1290:	a9 01       	movw	r20, r18
    1292:	fc 01       	movw	r30, r24
    1294:	84 81       	ldd	r24, Z+4	; 0x04
    1296:	95 81       	ldd	r25, Z+5	; 0x05
    1298:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    129c:	0f 91       	pop	r16
    129e:	08 95       	ret

000012a0 <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    12a0:	0f 93       	push	r16
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	1f 92       	push	r1
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    12ac:	01 e0       	ldi	r16, 0x01	; 1
    12ae:	2f ef       	ldi	r18, 0xFF	; 255
    12b0:	3f ef       	ldi	r19, 0xFF	; 255
    12b2:	a9 01       	movw	r20, r18
    12b4:	be 01       	movw	r22, r28
    12b6:	6f 5f       	subi	r22, 0xFF	; 255
    12b8:	7f 4f       	sbci	r23, 0xFF	; 255
    12ba:	fc 01       	movw	r30, r24
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	95 81       	ldd	r25, Z+5	; 0x05
    12c0:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	0f 90       	pop	r0
    12c8:	df 91       	pop	r29
    12ca:	cf 91       	pop	r28
    12cc:	0f 91       	pop	r16
    12ce:	08 95       	ret

000012d0 <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    12d0:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    12d2:	00 e0       	ldi	r16, 0x00	; 0
    12d4:	2f ef       	ldi	r18, 0xFF	; 255
    12d6:	3f ef       	ldi	r19, 0xFF	; 255
    12d8:	a9 01       	movw	r20, r18
    12da:	fc 01       	movw	r30, r24
    12dc:	84 81       	ldd	r24, Z+4	; 0x04
    12de:	95 81       	ldd	r25, Z+5	; 0x05
    12e0:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    12e4:	0f 91       	pop	r16
    12e6:	08 95       	ret

000012e8 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    12e8:	0f 93       	push	r16
    12ea:	cf 93       	push	r28
    12ec:	df 93       	push	r29
    12ee:	1f 92       	push	r1
    12f0:	cd b7       	in	r28, 0x3d	; 61
    12f2:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    12f4:	00 e0       	ldi	r16, 0x00	; 0
    12f6:	2f ef       	ldi	r18, 0xFF	; 255
    12f8:	3f ef       	ldi	r19, 0xFF	; 255
    12fa:	a9 01       	movw	r20, r18
    12fc:	be 01       	movw	r22, r28
    12fe:	6f 5f       	subi	r22, 0xFF	; 255
    1300:	7f 4f       	sbci	r23, 0xFF	; 255
    1302:	fc 01       	movw	r30, r24
    1304:	84 81       	ldd	r24, Z+4	; 0x04
    1306:	95 81       	ldd	r25, Z+5	; 0x05
    1308:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    130c:	89 81       	ldd	r24, Y+1	; 0x01
    130e:	0f 90       	pop	r0
    1310:	df 91       	pop	r29
    1312:	cf 91       	pop	r28
    1314:	0f 91       	pop	r16
    1316:	08 95       	ret

00001318 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    1318:	cf 93       	push	r28
    131a:	df 93       	push	r29
    131c:	1f 92       	push	r1
    131e:	cd b7       	in	r28, 0x3d	; 61
    1320:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    1322:	ae 01       	movw	r20, r28
    1324:	4f 5f       	subi	r20, 0xFF	; 255
    1326:	5f 4f       	sbci	r21, 0xFF	; 255
    1328:	fc 01       	movw	r30, r24
    132a:	84 81       	ldd	r24, Z+4	; 0x04
    132c:	95 81       	ldd	r25, Z+5	; 0x05
    132e:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
}
    1332:	0f 90       	pop	r0
    1334:	df 91       	pop	r29
    1336:	cf 91       	pop	r28
    1338:	08 95       	ret

0000133a <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	1f 92       	push	r1
    1340:	1f 92       	push	r1
    1342:	cd b7       	in	r28, 0x3d	; 61
    1344:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    1346:	ae 01       	movw	r20, r28
    1348:	4e 5f       	subi	r20, 0xFE	; 254
    134a:	5f 4f       	sbci	r21, 0xFF	; 255
    134c:	be 01       	movw	r22, r28
    134e:	6f 5f       	subi	r22, 0xFF	; 255
    1350:	7f 4f       	sbci	r23, 0xFF	; 255
    1352:	fc 01       	movw	r30, r24
    1354:	84 81       	ldd	r24, Z+4	; 0x04
    1356:	95 81       	ldd	r25, Z+5	; 0x05
    1358:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
	return (recv_item);
}
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	0f 90       	pop	r0
    1360:	0f 90       	pop	r0
    1362:	df 91       	pop	r29
    1364:	cf 91       	pop	r28
    1366:	08 95       	ret

00001368 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    1368:	cf 93       	push	r28
    136a:	df 93       	push	r29
    136c:	1f 92       	push	r1
    136e:	cd b7       	in	r28, 0x3d	; 61
    1370:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    1372:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    1374:	21 e0       	ldi	r18, 0x01	; 1
    1376:	ae 01       	movw	r20, r28
    1378:	4f 5f       	subi	r20, 0xFF	; 255
    137a:	5f 4f       	sbci	r21, 0xFF	; 255
    137c:	fc 01       	movw	r30, r24
    137e:	84 81       	ldd	r24, Z+4	; 0x04
    1380:	95 81       	ldd	r25, Z+5	; 0x05
    1382:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1386:	91 e0       	ldi	r25, 0x01	; 1
    1388:	81 11       	cpse	r24, r1
    138a:	01 c0       	rjmp	.+2      	; 0x138e <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    138c:	90 e0       	ldi	r25, 0x00	; 0
}
    138e:	89 2f       	mov	r24, r25
    1390:	0f 90       	pop	r0
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	08 95       	ret

00001398 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	1f 92       	push	r1
    139e:	cd b7       	in	r28, 0x3d	; 61
    13a0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    13a2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    13a4:	20 e0       	ldi	r18, 0x00	; 0
    13a6:	ae 01       	movw	r20, r28
    13a8:	4f 5f       	subi	r20, 0xFF	; 255
    13aa:	5f 4f       	sbci	r21, 0xFF	; 255
    13ac:	fc 01       	movw	r30, r24
    13ae:	84 81       	ldd	r24, Z+4	; 0x04
    13b0:	95 81       	ldd	r25, Z+5	; 0x05
    13b2:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    13b6:	91 e0       	ldi	r25, 0x01	; 1
    13b8:	81 11       	cpse	r24, r1
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    13bc:	90 e0       	ldi	r25, 0x00	; 0
}
    13be:	89 2f       	mov	r24, r25
    13c0:	0f 90       	pop	r0
    13c2:	df 91       	pop	r29
    13c4:	cf 91       	pop	r28
    13c6:	08 95       	ret

000013c8 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    13c8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    13ca:	fc 01       	movw	r30, r24
    13cc:	26 81       	ldd	r18, Z+6	; 0x06
    13ce:	37 81       	ldd	r19, Z+7	; 0x07
    13d0:	40 85       	ldd	r20, Z+8	; 0x08
    13d2:	51 85       	ldd	r21, Z+9	; 0x09
    13d4:	01 e0       	ldi	r16, 0x01	; 1
    13d6:	84 81       	ldd	r24, Z+4	; 0x04
    13d8:	95 81       	ldd	r25, Z+5	; 0x05
    13da:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    13de:	91 e0       	ldi	r25, 0x01	; 1
    13e0:	81 11       	cpse	r24, r1
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    13e4:	90 e0       	ldi	r25, 0x00	; 0
		}
    13e6:	89 2f       	mov	r24, r25
    13e8:	0f 91       	pop	r16
    13ea:	08 95       	ret

000013ec <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    13ec:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    13ee:	fc 01       	movw	r30, r24
    13f0:	26 81       	ldd	r18, Z+6	; 0x06
    13f2:	37 81       	ldd	r19, Z+7	; 0x07
    13f4:	40 85       	ldd	r20, Z+8	; 0x08
    13f6:	51 85       	ldd	r21, Z+9	; 0x09
    13f8:	00 e0       	ldi	r16, 0x00	; 0
    13fa:	84 81       	ldd	r24, Z+4	; 0x04
    13fc:	95 81       	ldd	r25, Z+5	; 0x05
    13fe:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    1402:	91 e0       	ldi	r25, 0x01	; 1
    1404:	81 11       	cpse	r24, r1
    1406:	01 c0       	rjmp	.+2      	; 0x140a <_ZN9frt_queueIhE3putERKh+0x1e>
    1408:	90 e0       	ldi	r25, 0x00	; 0
		}
    140a:	89 2f       	mov	r24, r25
    140c:	0f 91       	pop	r16
    140e:	08 95       	ret

00001410 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::takeReading()
{
  return i2cAgent_->transmit(*queryX_);
}
    1410:	0f 93       	push	r16
    1412:	1f 93       	push	r17
    1414:	cf 93       	push	r28
    1416:	df 93       	push	r29
    1418:	8c 01       	movw	r16, r24
    141a:	eb 01       	movw	r28, r22
    141c:	bc 01       	movw	r22, r24
    141e:	6e 5f       	subi	r22, 0xFE	; 254
    1420:	7f 4f       	sbci	r23, 0xFF	; 255
    1422:	e8 81       	ld	r30, Y
    1424:	f9 81       	ldd	r31, Y+1	; 0x01
    1426:	01 90       	ld	r0, Z+
    1428:	f0 81       	ld	r31, Z
    142a:	e0 2d       	mov	r30, r0
    142c:	ce 01       	movw	r24, r28
    142e:	19 95       	eicall
    1430:	b8 01       	movw	r22, r16
    1432:	6d 5f       	subi	r22, 0xFD	; 253
    1434:	7f 4f       	sbci	r23, 0xFF	; 255
    1436:	e8 81       	ld	r30, Y
    1438:	f9 81       	ldd	r31, Y+1	; 0x01
    143a:	01 90       	ld	r0, Z+
    143c:	f0 81       	ld	r31, Z
    143e:	e0 2d       	mov	r30, r0
    1440:	ce 01       	movw	r24, r28
    1442:	19 95       	eicall
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	1f 91       	pop	r17
    144a:	0f 91       	pop	r16
    144c:	08 95       	ret

0000144e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    144e:	db 01       	movw	r26, r22
    1450:	bc 01       	movw	r22, r24
    1452:	6e 5f       	subi	r22, 0xFE	; 254
    1454:	7f 4f       	sbci	r23, 0xFF	; 255
    1456:	ed 91       	ld	r30, X+
    1458:	fc 91       	ld	r31, X
    145a:	11 97       	sbiw	r26, 0x01	; 1
    145c:	01 90       	ld	r0, Z+
    145e:	f0 81       	ld	r31, Z
    1460:	e0 2d       	mov	r30, r0
    1462:	cd 01       	movw	r24, r26
    1464:	19 95       	eicall
    1466:	08 95       	ret

00001468 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    1468:	db 01       	movw	r26, r22
    146a:	bc 01       	movw	r22, r24
    146c:	6e 5f       	subi	r22, 0xFE	; 254
    146e:	7f 4f       	sbci	r23, 0xFF	; 255
    1470:	ed 91       	ld	r30, X+
    1472:	fc 91       	ld	r31, X
    1474:	11 97       	sbiw	r26, 0x01	; 1
    1476:	01 90       	ld	r0, Z+
    1478:	f0 81       	ld	r31, Z
    147a:	e0 2d       	mov	r30, r0
    147c:	cd 01       	movw	r24, r26
    147e:	19 95       	eicall
    1480:	08 95       	ret

00001482 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    1482:	db 01       	movw	r26, r22
    1484:	bc 01       	movw	r22, r24
    1486:	6e 5f       	subi	r22, 0xFE	; 254
    1488:	7f 4f       	sbci	r23, 0xFF	; 255
    148a:	ed 91       	ld	r30, X+
    148c:	fc 91       	ld	r31, X
    148e:	11 97       	sbiw	r26, 0x01	; 1
    1490:	01 90       	ld	r0, Z+
    1492:	f0 81       	ld	r31, Z
    1494:	e0 2d       	mov	r30, r0
    1496:	cd 01       	movw	r24, r26
    1498:	19 95       	eicall
    149a:	08 95       	ret

0000149c <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    149c:	4f 92       	push	r4
    149e:	5f 92       	push	r5
    14a0:	6f 92       	push	r6
    14a2:	7f 92       	push	r7
    14a4:	8f 92       	push	r8
    14a6:	9f 92       	push	r9
    14a8:	af 92       	push	r10
    14aa:	bf 92       	push	r11
    14ac:	cf 92       	push	r12
    14ae:	df 92       	push	r13
    14b0:	ef 92       	push	r14
    14b2:	ff 92       	push	r15
    14b4:	0f 93       	push	r16
    14b6:	1f 93       	push	r17
    14b8:	cf 93       	push	r28
    14ba:	df 93       	push	r29
    14bc:	8c 01       	movw	r16, r24
    14be:	7b 01       	movw	r14, r22
    14c0:	6a 01       	movw	r12, r20
    14c2:	dc 01       	movw	r26, r24
    14c4:	6d 93       	st	X+, r22
    14c6:	7c 93       	st	X, r23
    14c8:	11 97       	sbiw	r26, 0x01	; 1
    14ca:	12 96       	adiw	r26, 0x02	; 2
    14cc:	4d 93       	st	X+, r20
    14ce:	5c 93       	st	X, r21
    14d0:	13 97       	sbiw	r26, 0x03	; 3
    14d2:	81 e2       	ldi	r24, 0x21	; 33
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    14da:	ec 01       	movw	r28, r24
    14dc:	80 e2       	ldi	r24, 0x20	; 32
    14de:	91 e2       	ldi	r25, 0x21	; 33
    14e0:	88 83       	st	Y, r24
    14e2:	99 83       	std	Y+1, r25	; 0x01
    14e4:	1c 82       	std	Y+4, r1	; 0x04
    14e6:	1d 82       	std	Y+5, r1	; 0x05
    14e8:	0f 2e       	mov	r0, r31
    14ea:	f8 ed       	ldi	r31, 0xD8	; 216
    14ec:	af 2e       	mov	r10, r31
    14ee:	f0 e2       	ldi	r31, 0x20	; 32
    14f0:	bf 2e       	mov	r11, r31
    14f2:	f0 2d       	mov	r31, r0
    14f4:	aa 82       	std	Y+2, r10	; 0x02
    14f6:	bb 82       	std	Y+3, r11	; 0x03
    14f8:	40 e0       	ldi	r20, 0x00	; 0
    14fa:	61 e0       	ldi	r22, 0x01	; 1
    14fc:	82 e0       	ldi	r24, 0x02	; 2
    14fe:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    1502:	8e 83       	std	Y+6, r24	; 0x06
    1504:	9f 83       	std	Y+7, r25	; 0x07
    1506:	0f 2e       	mov	r0, r31
    1508:	fa e0       	ldi	r31, 0x0A	; 10
    150a:	4f 2e       	mov	r4, r31
    150c:	51 2c       	mov	r5, r1
    150e:	61 2c       	mov	r6, r1
    1510:	71 2c       	mov	r7, r1
    1512:	f0 2d       	mov	r31, r0
    1514:	48 86       	std	Y+8, r4	; 0x08
    1516:	59 86       	std	Y+9, r5	; 0x09
    1518:	6a 86       	std	Y+10, r6	; 0x0a
    151a:	7b 86       	std	Y+11, r7	; 0x0b
    151c:	0f 2e       	mov	r0, r31
    151e:	fc ef       	ldi	r31, 0xFC	; 252
    1520:	8f 2e       	mov	r8, r31
    1522:	f0 e2       	ldi	r31, 0x20	; 32
    1524:	9f 2e       	mov	r9, r31
    1526:	f0 2d       	mov	r31, r0
    1528:	8a 82       	std	Y+2, r8	; 0x02
    152a:	9b 82       	std	Y+3, r9	; 0x03
    152c:	82 e0       	ldi	r24, 0x02	; 2
    152e:	8c 87       	std	Y+12, r24	; 0x0c
    1530:	18 8a       	std	Y+16, r1	; 0x10
    1532:	19 8a       	std	Y+17, r1	; 0x11
    1534:	ae 86       	std	Y+14, r10	; 0x0e
    1536:	bf 86       	std	Y+15, r11	; 0x0f
    1538:	40 e0       	ldi	r20, 0x00	; 0
    153a:	61 e0       	ldi	r22, 0x01	; 1
    153c:	83 e0       	ldi	r24, 0x03	; 3
    153e:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    1542:	8a 8b       	std	Y+18, r24	; 0x12
    1544:	9b 8b       	std	Y+19, r25	; 0x13
    1546:	4c 8a       	std	Y+20, r4	; 0x14
    1548:	5d 8a       	std	Y+21, r5	; 0x15
    154a:	6e 8a       	std	Y+22, r6	; 0x16
    154c:	7f 8a       	std	Y+23, r7	; 0x17
    154e:	8e 86       	std	Y+14, r8	; 0x0e
    1550:	9f 86       	std	Y+15, r9	; 0x0f
    1552:	0f 2e       	mov	r0, r31
    1554:	f3 e0       	ldi	r31, 0x03	; 3
    1556:	bf 2e       	mov	r11, r31
    1558:	f0 2d       	mov	r31, r0
    155a:	b8 8e       	std	Y+24, r11	; 0x18
    155c:	8a e0       	ldi	r24, 0x0A	; 10
    155e:	90 e2       	ldi	r25, 0x20	; 32
    1560:	88 83       	st	Y, r24
    1562:	99 83       	std	Y+1, r25	; 0x01
    1564:	ca 8e       	std	Y+26, r12	; 0x1a
    1566:	db 8e       	std	Y+27, r13	; 0x1b
    1568:	f8 01       	movw	r30, r16
    156a:	c4 83       	std	Z+4, r28	; 0x04
    156c:	d5 83       	std	Z+5, r29	; 0x05
    156e:	86 e0       	ldi	r24, 0x06	; 6
    1570:	90 e0       	ldi	r25, 0x00	; 0
    1572:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    1576:	fc 01       	movw	r30, r24
    1578:	10 82       	st	Z, r1
    157a:	11 82       	std	Z+1, r1	; 0x01
    157c:	12 82       	std	Z+2, r1	; 0x02
    157e:	13 82       	std	Z+3, r1	; 0x03
    1580:	14 82       	std	Z+4, r1	; 0x04
    1582:	15 82       	std	Z+5, r1	; 0x05
    1584:	d8 01       	movw	r26, r16
    1586:	16 96       	adiw	r26, 0x06	; 6
    1588:	8d 93       	st	X+, r24
    158a:	9c 93       	st	X, r25
    158c:	17 97       	sbiw	r26, 0x07	; 7
    158e:	8d e1       	ldi	r24, 0x1D	; 29
    1590:	18 96       	adiw	r26, 0x08	; 8
    1592:	8c 93       	st	X, r24
    1594:	84 e0       	ldi	r24, 0x04	; 4
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    159c:	fc 01       	movw	r30, r24
    159e:	8e e2       	ldi	r24, 0x2E	; 46
    15a0:	91 e2       	ldi	r25, 0x21	; 33
    15a2:	80 83       	st	Z, r24
    15a4:	91 83       	std	Z+1, r25	; 0x01
    15a6:	8a e2       	ldi	r24, 0x2A	; 42
    15a8:	82 83       	std	Z+2, r24	; 0x02
    15aa:	c1 e0       	ldi	r28, 0x01	; 1
    15ac:	c3 83       	std	Z+3, r28	; 0x03
    15ae:	d8 01       	movw	r26, r16
    15b0:	1b 96       	adiw	r26, 0x0b	; 11
    15b2:	ed 93       	st	X+, r30
    15b4:	fc 93       	st	X, r31
    15b6:	1c 97       	sbiw	r26, 0x0c	; 12
    15b8:	83 e0       	ldi	r24, 0x03	; 3
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    15c0:	24 e3       	ldi	r18, 0x34	; 52
    15c2:	31 e2       	ldi	r19, 0x21	; 33
    15c4:	fc 01       	movw	r30, r24
    15c6:	20 83       	st	Z, r18
    15c8:	31 83       	std	Z+1, r19	; 0x01
    15ca:	c2 83       	std	Z+2, r28	; 0x02
    15cc:	d8 01       	movw	r26, r16
    15ce:	1d 96       	adiw	r26, 0x0d	; 13
    15d0:	8d 93       	st	X+, r24
    15d2:	9c 93       	st	X, r25
    15d4:	1e 97       	sbiw	r26, 0x0e	; 14
    15d6:	83 e0       	ldi	r24, 0x03	; 3
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    15de:	2a e3       	ldi	r18, 0x3A	; 58
    15e0:	31 e2       	ldi	r19, 0x21	; 33
    15e2:	fc 01       	movw	r30, r24
    15e4:	20 83       	st	Z, r18
    15e6:	31 83       	std	Z+1, r19	; 0x01
    15e8:	b2 82       	std	Z+2, r11	; 0x02
    15ea:	d8 01       	movw	r26, r16
    15ec:	1f 96       	adiw	r26, 0x0f	; 15
    15ee:	8d 93       	st	X+, r24
    15f0:	9c 93       	st	X, r25
    15f2:	50 97       	sbiw	r26, 0x10	; 16
    15f4:	83 e0       	ldi	r24, 0x03	; 3
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    15fc:	20 e4       	ldi	r18, 0x40	; 64
    15fe:	31 e2       	ldi	r19, 0x21	; 33
    1600:	fc 01       	movw	r30, r24
    1602:	20 83       	st	Z, r18
    1604:	31 83       	std	Z+1, r19	; 0x01
    1606:	25 e0       	ldi	r18, 0x05	; 5
    1608:	22 83       	std	Z+2, r18	; 0x02
    160a:	d8 01       	movw	r26, r16
    160c:	51 96       	adiw	r26, 0x11	; 17
    160e:	8d 93       	st	X+, r24
    1610:	9c 93       	st	X, r25
    1612:	52 97       	sbiw	r26, 0x12	; 18
    1614:	14 96       	adiw	r26, 0x04	; 4
    1616:	ed 91       	ld	r30, X+
    1618:	fc 91       	ld	r31, X
    161a:	15 97       	sbiw	r26, 0x05	; 5
    161c:	e4 8e       	std	Z+28, r14	; 0x1c
    161e:	f5 8e       	std	Z+29, r15	; 0x1d
    1620:	18 96       	adiw	r26, 0x08	; 8
    1622:	6c 91       	ld	r22, X
    1624:	18 97       	sbiw	r26, 0x08	; 8
    1626:	14 96       	adiw	r26, 0x04	; 4
    1628:	8d 91       	ld	r24, X+
    162a:	9c 91       	ld	r25, X
    162c:	15 97       	sbiw	r26, 0x05	; 5
    162e:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <_ZN8I2CAgent12setSlaveAddrEh>
    1632:	df 91       	pop	r29
    1634:	cf 91       	pop	r28
    1636:	1f 91       	pop	r17
    1638:	0f 91       	pop	r16
    163a:	ff 90       	pop	r15
    163c:	ef 90       	pop	r14
    163e:	df 90       	pop	r13
    1640:	cf 90       	pop	r12
    1642:	bf 90       	pop	r11
    1644:	af 90       	pop	r10
    1646:	9f 90       	pop	r9
    1648:	8f 90       	pop	r8
    164a:	7f 90       	pop	r7
    164c:	6f 90       	pop	r6
    164e:	5f 90       	pop	r5
    1650:	4f 90       	pop	r4
    1652:	08 95       	ret

00001654 <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    1654:	1f 93       	push	r17
    1656:	cf 93       	push	r28
    1658:	df 93       	push	r29
    165a:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	9d 81       	ldd	r25, Y+5	; 0x05
    1660:	6b 85       	ldd	r22, Y+11	; 0x0b
    1662:	7c 85       	ldd	r23, Y+12	; 0x0c
    1664:	dc 01       	movw	r26, r24
    1666:	ed 91       	ld	r30, X+
    1668:	fc 91       	ld	r31, X
    166a:	01 90       	ld	r0, Z+
    166c:	f0 81       	ld	r31, Z
    166e:	e0 2d       	mov	r30, r0
    1670:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    1672:	8c 81       	ldd	r24, Y+4	; 0x04
    1674:	9d 81       	ldd	r25, Y+5	; 0x05
    1676:	6d 85       	ldd	r22, Y+13	; 0x0d
    1678:	7e 85       	ldd	r23, Y+14	; 0x0e
    167a:	dc 01       	movw	r26, r24
    167c:	ed 91       	ld	r30, X+
    167e:	fc 91       	ld	r31, X
    1680:	01 90       	ld	r0, Z+
    1682:	f0 81       	ld	r31, Z
    1684:	e0 2d       	mov	r30, r0
    1686:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    1688:	8c 81       	ldd	r24, Y+4	; 0x04
    168a:	9d 81       	ldd	r25, Y+5	; 0x05
    168c:	dc 01       	movw	r26, r24
    168e:	ed 91       	ld	r30, X+
    1690:	fc 91       	ld	r31, X
    1692:	02 80       	ldd	r0, Z+2	; 0x02
    1694:	f3 81       	ldd	r31, Z+3	; 0x03
    1696:	e0 2d       	mov	r30, r0
    1698:	19 95       	eicall
    169a:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    169c:	8b 85       	ldd	r24, Y+11	; 0x0b
    169e:	88 23       	and	r24, r24
    16a0:	b9 f0       	breq	.+46     	; 0x16d0 <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    16a2:	e8 81       	ld	r30, Y
    16a4:	f9 81       	ldd	r31, Y+1	; 0x01
    16a6:	00 84       	ldd	r0, Z+8	; 0x08
    16a8:	f1 85       	ldd	r31, Z+9	; 0x09
    16aa:	e0 2d       	mov	r30, r0
    16ac:	ce 01       	movw	r24, r28
    16ae:	19 95       	eicall
    16b0:	18 2f       	mov	r17, r24
    16b2:	e8 81       	ld	r30, Y
    16b4:	f9 81       	ldd	r31, Y+1	; 0x01
    16b6:	00 84       	ldd	r0, Z+8	; 0x08
    16b8:	f1 85       	ldd	r31, Z+9	; 0x09
    16ba:	e0 2d       	mov	r30, r0
    16bc:	ce 01       	movw	r24, r28
    16be:	19 95       	eicall
    16c0:	21 2f       	mov	r18, r17
    16c2:	30 e0       	ldi	r19, 0x00	; 0
    16c4:	32 2f       	mov	r19, r18
    16c6:	22 27       	eor	r18, r18
    16c8:	a9 01       	movw	r20, r18
    16ca:	48 2b       	or	r20, r24
    16cc:	ca 01       	movw	r24, r20
    16ce:	02 c0       	rjmp	.+4      	; 0x16d4 <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    16d0:	80 e0       	ldi	r24, 0x00	; 0
    16d2:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    16d4:	df 91       	pop	r29
    16d6:	cf 91       	pop	r28
    16d8:	1f 91       	pop	r17
    16da:	08 95       	ret

000016dc <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    16e4:	8c 81       	ldd	r24, Y+4	; 0x04
    16e6:	9d 81       	ldd	r25, Y+5	; 0x05
    16e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    16ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    16ec:	dc 01       	movw	r26, r24
    16ee:	ed 91       	ld	r30, X+
    16f0:	fc 91       	ld	r31, X
    16f2:	01 90       	ld	r0, Z+
    16f4:	f0 81       	ld	r31, Z
    16f6:	e0 2d       	mov	r30, r0
    16f8:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    16fa:	8c 81       	ldd	r24, Y+4	; 0x04
    16fc:	9d 81       	ldd	r25, Y+5	; 0x05
    16fe:	6f 85       	ldd	r22, Y+15	; 0x0f
    1700:	78 89       	ldd	r23, Y+16	; 0x10
    1702:	dc 01       	movw	r26, r24
    1704:	ed 91       	ld	r30, X+
    1706:	fc 91       	ld	r31, X
    1708:	01 90       	ld	r0, Z+
    170a:	f0 81       	ld	r31, Z
    170c:	e0 2d       	mov	r30, r0
    170e:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    1710:	8c 81       	ldd	r24, Y+4	; 0x04
    1712:	9d 81       	ldd	r25, Y+5	; 0x05
    1714:	dc 01       	movw	r26, r24
    1716:	ed 91       	ld	r30, X+
    1718:	fc 91       	ld	r31, X
    171a:	02 80       	ldd	r0, Z+2	; 0x02
    171c:	f3 81       	ldd	r31, Z+3	; 0x03
    171e:	e0 2d       	mov	r30, r0
    1720:	19 95       	eicall
    1722:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    1724:	8b 85       	ldd	r24, Y+11	; 0x0b
    1726:	88 23       	and	r24, r24
    1728:	b9 f0       	breq	.+46     	; 0x1758 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    172a:	e8 81       	ld	r30, Y
    172c:	f9 81       	ldd	r31, Y+1	; 0x01
    172e:	00 84       	ldd	r0, Z+8	; 0x08
    1730:	f1 85       	ldd	r31, Z+9	; 0x09
    1732:	e0 2d       	mov	r30, r0
    1734:	ce 01       	movw	r24, r28
    1736:	19 95       	eicall
    1738:	18 2f       	mov	r17, r24
    173a:	e8 81       	ld	r30, Y
    173c:	f9 81       	ldd	r31, Y+1	; 0x01
    173e:	00 84       	ldd	r0, Z+8	; 0x08
    1740:	f1 85       	ldd	r31, Z+9	; 0x09
    1742:	e0 2d       	mov	r30, r0
    1744:	ce 01       	movw	r24, r28
    1746:	19 95       	eicall
    1748:	21 2f       	mov	r18, r17
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	32 2f       	mov	r19, r18
    174e:	22 27       	eor	r18, r18
    1750:	a9 01       	movw	r20, r18
    1752:	48 2b       	or	r20, r24
    1754:	ca 01       	movw	r24, r20
    1756:	02 c0       	rjmp	.+4      	; 0x175c <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    1758:	80 e0       	ldi	r24, 0x00	; 0
    175a:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    175c:	df 91       	pop	r29
    175e:	cf 91       	pop	r28
    1760:	1f 91       	pop	r17
    1762:	08 95       	ret

00001764 <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    1764:	1f 93       	push	r17
    1766:	cf 93       	push	r28
    1768:	df 93       	push	r29
    176a:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    176c:	8c 81       	ldd	r24, Y+4	; 0x04
    176e:	9d 81       	ldd	r25, Y+5	; 0x05
    1770:	6b 85       	ldd	r22, Y+11	; 0x0b
    1772:	7c 85       	ldd	r23, Y+12	; 0x0c
    1774:	dc 01       	movw	r26, r24
    1776:	ed 91       	ld	r30, X+
    1778:	fc 91       	ld	r31, X
    177a:	01 90       	ld	r0, Z+
    177c:	f0 81       	ld	r31, Z
    177e:	e0 2d       	mov	r30, r0
    1780:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    1782:	8c 81       	ldd	r24, Y+4	; 0x04
    1784:	9d 81       	ldd	r25, Y+5	; 0x05
    1786:	69 89       	ldd	r22, Y+17	; 0x11
    1788:	7a 89       	ldd	r23, Y+18	; 0x12
    178a:	dc 01       	movw	r26, r24
    178c:	ed 91       	ld	r30, X+
    178e:	fc 91       	ld	r31, X
    1790:	01 90       	ld	r0, Z+
    1792:	f0 81       	ld	r31, Z
    1794:	e0 2d       	mov	r30, r0
    1796:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    1798:	8c 81       	ldd	r24, Y+4	; 0x04
    179a:	9d 81       	ldd	r25, Y+5	; 0x05
    179c:	dc 01       	movw	r26, r24
    179e:	ed 91       	ld	r30, X+
    17a0:	fc 91       	ld	r31, X
    17a2:	02 80       	ldd	r0, Z+2	; 0x02
    17a4:	f3 81       	ldd	r31, Z+3	; 0x03
    17a6:	e0 2d       	mov	r30, r0
    17a8:	19 95       	eicall
    17aa:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    17ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    17ae:	88 23       	and	r24, r24
    17b0:	b9 f0       	breq	.+46     	; 0x17e0 <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    17b2:	e8 81       	ld	r30, Y
    17b4:	f9 81       	ldd	r31, Y+1	; 0x01
    17b6:	00 84       	ldd	r0, Z+8	; 0x08
    17b8:	f1 85       	ldd	r31, Z+9	; 0x09
    17ba:	e0 2d       	mov	r30, r0
    17bc:	ce 01       	movw	r24, r28
    17be:	19 95       	eicall
    17c0:	18 2f       	mov	r17, r24
    17c2:	e8 81       	ld	r30, Y
    17c4:	f9 81       	ldd	r31, Y+1	; 0x01
    17c6:	00 84       	ldd	r0, Z+8	; 0x08
    17c8:	f1 85       	ldd	r31, Z+9	; 0x09
    17ca:	e0 2d       	mov	r30, r0
    17cc:	ce 01       	movw	r24, r28
    17ce:	19 95       	eicall
    17d0:	21 2f       	mov	r18, r17
    17d2:	30 e0       	ldi	r19, 0x00	; 0
    17d4:	32 2f       	mov	r19, r18
    17d6:	22 27       	eor	r18, r18
    17d8:	a9 01       	movw	r20, r18
    17da:	48 2b       	or	r20, r24
    17dc:	ca 01       	movw	r24, r20
    17de:	02 c0       	rjmp	.+4      	; 0x17e4 <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    17e4:	df 91       	pop	r29
    17e6:	cf 91       	pop	r28
    17e8:	1f 91       	pop	r17
    17ea:	08 95       	ret

000017ec <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    17ec:	cf 93       	push	r28
    17ee:	df 93       	push	r29
    17f0:	ec 01       	movw	r28, r24
  success_ = false;
    17f2:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    17f4:	e8 81       	ld	r30, Y
    17f6:	f9 81       	ldd	r31, Y+1	; 0x01
    17f8:	00 8c       	ldd	r0, Z+24	; 0x18
    17fa:	f1 8d       	ldd	r31, Z+25	; 0x19
    17fc:	e0 2d       	mov	r30, r0
    17fe:	ce 01       	movw	r24, r28
    1800:	19 95       	eicall
    1802:	88 23       	and	r24, r24
    1804:	41 f0       	breq	.+16     	; 0x1816 <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    1806:	e8 81       	ld	r30, Y
    1808:	f9 81       	ldd	r31, Y+1	; 0x01
    180a:	00 84       	ldd	r0, Z+8	; 0x08
    180c:	f1 85       	ldd	r31, Z+9	; 0x09
    180e:	e0 2d       	mov	r30, r0
    1810:	ce 01       	movw	r24, r28
    1812:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    1814:	ef cf       	rjmp	.-34     	; 0x17f4 <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    1816:	df 91       	pop	r29
    1818:	cf 91       	pop	r28
    181a:	08 95       	ret

0000181c <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    181c:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    181e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1820:	81 11       	cpse	r24, r1
    1822:	39 c0       	rjmp	.+114    	; 0x1896 <_ZN10task_sonar3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    1824:	8c 89       	ldd	r24, Y+20	; 0x14
    1826:	9d 89       	ldd	r25, Y+21	; 0x15
    1828:	0e 94 2a 0b 	call	0x1654	; 0x1654 <_ZN7MMA845111getXReadingEv>
    182c:	7c 01       	movw	r14, r24
    182e:	0e 81       	ldd	r16, Y+6	; 0x06
    1830:	1f 81       	ldd	r17, Y+7	; 0x07
    1832:	62 e4       	ldi	r22, 0x42	; 66
    1834:	71 e2       	ldi	r23, 0x21	; 33
    1836:	c8 01       	movw	r24, r16
    1838:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    183c:	b7 01       	movw	r22, r14
    183e:	c8 01       	movw	r24, r16
    1840:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    1844:	66 e0       	ldi	r22, 0x06	; 6
    1846:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    184a:	8c 89       	ldd	r24, Y+20	; 0x14
    184c:	9d 89       	ldd	r25, Y+21	; 0x15
    184e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <_ZN7MMA845111getYReadingEv>
    1852:	7c 01       	movw	r14, r24
    1854:	0e 81       	ldd	r16, Y+6	; 0x06
    1856:	1f 81       	ldd	r17, Y+7	; 0x07
    1858:	66 e4       	ldi	r22, 0x46	; 70
    185a:	71 e2       	ldi	r23, 0x21	; 33
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1862:	b7 01       	movw	r22, r14
    1864:	c8 01       	movw	r24, r16
    1866:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    186a:	66 e0       	ldi	r22, 0x06	; 6
    186c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    1870:	8c 89       	ldd	r24, Y+20	; 0x14
    1872:	9d 89       	ldd	r25, Y+21	; 0x15
    1874:	0e 94 b2 0b 	call	0x1764	; 0x1764 <_ZN7MMA845111getZReadingEv>
    1878:	7c 01       	movw	r14, r24
    187a:	0e 81       	ldd	r16, Y+6	; 0x06
    187c:	1f 81       	ldd	r17, Y+7	; 0x07
    187e:	6a e4       	ldi	r22, 0x4A	; 74
    1880:	71 e2       	ldi	r23, 0x21	; 33
    1882:	c8 01       	movw	r24, r16
    1884:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1888:	b7 01       	movw	r22, r14
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    1890:	66 e0       	ldi	r22, 0x06	; 6
    1892:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1896:	8e 85       	ldd	r24, Y+14	; 0x0e
    1898:	9f 85       	ldd	r25, Y+15	; 0x0f
    189a:	a8 89       	ldd	r26, Y+16	; 0x10
    189c:	b9 89       	ldd	r27, Y+17	; 0x11
    189e:	01 96       	adiw	r24, 0x01	; 1
    18a0:	a1 1d       	adc	r26, r1
    18a2:	b1 1d       	adc	r27, r1
    18a4:	8e 87       	std	Y+14, r24	; 0x0e
    18a6:	9f 87       	std	Y+15, r25	; 0x0f
    18a8:	a8 8b       	std	Y+16, r26	; 0x10
    18aa:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    18ac:	68 ee       	ldi	r22, 0xE8	; 232
    18ae:	73 e0       	ldi	r23, 0x03	; 3
    18b0:	80 e0       	ldi	r24, 0x00	; 0
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    18b8:	b2 cf       	rjmp	.-156    	; 0x181e <_ZN10task_sonar3runEv+0x2>

000018ba <_ZN10task_sonarC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    18ba:	cf 92       	push	r12
    18bc:	df 92       	push	r13
    18be:	ef 92       	push	r14
    18c0:	ff 92       	push	r15
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
    18cc:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    18ce:	0e 94 2e 1a 	call	0x345c	; 0x345c <_ZN8frt_taskC1EPKchjP8emstream>
    18d2:	82 e5       	ldi	r24, 0x52	; 82
    18d4:	91 e2       	ldi	r25, 0x21	; 33
    18d6:	88 83       	st	Y, r24
    18d8:	99 83       	std	Y+1, r25	; 0x01
    18da:	ec 8a       	std	Y+20, r14	; 0x14
    18dc:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    18de:	ce 8a       	std	Y+22, r12	; 0x16
    18e0:	df 8a       	std	Y+23, r13	; 0x17
}
    18e2:	df 91       	pop	r29
    18e4:	cf 91       	pop	r28
    18e6:	1f 91       	pop	r17
    18e8:	0f 91       	pop	r16
    18ea:	ff 90       	pop	r15
    18ec:	ef 90       	pop	r14
    18ee:	df 90       	pop	r13
    18f0:	cf 90       	pop	r12
    18f2:	08 95       	ret

000018f4 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    18f4:	0f 93       	push	r16
    18f6:	1f 93       	push	r17
    18f8:	cf 93       	push	r28
    18fa:	df 93       	push	r29
    18fc:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    18fe:	0e 94 2e 1a 	call	0x345c	; 0x345c <_ZN8frt_taskC1EPKchjP8emstream>
    1902:	8a e5       	ldi	r24, 0x5A	; 90
    1904:	91 e2       	ldi	r25, 0x21	; 33
    1906:	88 83       	st	Y, r24
    1908:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    190a:	df 91       	pop	r29
    190c:	cf 91       	pop	r28
    190e:	1f 91       	pop	r17
    1910:	0f 91       	pop	r16
    1912:	08 95       	ret

00001914 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1914:	0f 93       	push	r16
    1916:	1f 93       	push	r17
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    191e:	6a e0       	ldi	r22, 0x0A	; 10
    1920:	8e 81       	ldd	r24, Y+6	; 0x06
    1922:	9f 81       	ldd	r25, Y+7	; 0x07
    1924:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1928:	8c 01       	movw	r16, r24
    192a:	69 e0       	ldi	r22, 0x09	; 9
    192c:	75 e0       	ldi	r23, 0x05	; 5
    192e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1932:	6a e0       	ldi	r22, 0x0A	; 10
    1934:	c8 01       	movw	r24, r16
    1936:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    193a:	8c 01       	movw	r16, r24
    193c:	63 e0       	ldi	r22, 0x03	; 3
    193e:	75 e0       	ldi	r23, 0x05	; 5
    1940:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1944:	67 e0       	ldi	r22, 0x07	; 7
    1946:	c8 01       	movw	r24, r16
    1948:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    194c:	6a e0       	ldi	r22, 0x0A	; 10
    194e:	8e 81       	ldd	r24, Y+6	; 0x06
    1950:	9f 81       	ldd	r25, Y+7	; 0x07
    1952:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1956:	8c 01       	movw	r16, r24
    1958:	64 ee       	ldi	r22, 0xE4	; 228
    195a:	74 e0       	ldi	r23, 0x04	; 4
    195c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1960:	6a e0       	ldi	r22, 0x0A	; 10
    1962:	c8 01       	movw	r24, r16
    1964:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1968:	8c 01       	movw	r16, r24
    196a:	6e ed       	ldi	r22, 0xDE	; 222
    196c:	74 e0       	ldi	r23, 0x04	; 4
    196e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1972:	66 e0       	ldi	r22, 0x06	; 6
    1974:	c8 01       	movw	r24, r16
    1976:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    197a:	6a e0       	ldi	r22, 0x0A	; 10
    197c:	8e 81       	ldd	r24, Y+6	; 0x06
    197e:	9f 81       	ldd	r25, Y+7	; 0x07
    1980:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1984:	8c 01       	movw	r16, r24
    1986:	67 ec       	ldi	r22, 0xC7	; 199
    1988:	74 e0       	ldi	r23, 0x04	; 4
    198a:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    198e:	66 e0       	ldi	r22, 0x06	; 6
    1990:	c8 01       	movw	r24, r16
    1992:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1996:	6a e0       	ldi	r22, 0x0A	; 10
    1998:	8e 81       	ldd	r24, Y+6	; 0x06
    199a:	9f 81       	ldd	r25, Y+7	; 0x07
    199c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    19a0:	8c 01       	movw	r16, r24
    19a2:	6b ea       	ldi	r22, 0xAB	; 171
    19a4:	74 e0       	ldi	r23, 0x04	; 4
    19a6:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    19aa:	66 e0       	ldi	r22, 0x06	; 6
    19ac:	c8 01       	movw	r24, r16
    19ae:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    19b2:	6a e0       	ldi	r22, 0x0A	; 10
    19b4:	8e 81       	ldd	r24, Y+6	; 0x06
    19b6:	9f 81       	ldd	r25, Y+7	; 0x07
    19b8:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    19bc:	8c 01       	movw	r16, r24
    19be:	63 e9       	ldi	r22, 0x93	; 147
    19c0:	74 e0       	ldi	r23, 0x04	; 4
    19c2:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    19c6:	66 e0       	ldi	r22, 0x06	; 6
    19c8:	c8 01       	movw	r24, r16
    19ca:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    19ce:	6a e0       	ldi	r22, 0x0A	; 10
    19d0:	8e 81       	ldd	r24, Y+6	; 0x06
    19d2:	9f 81       	ldd	r25, Y+7	; 0x07
    19d4:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    19d8:	8c 01       	movw	r16, r24
    19da:	62 e7       	ldi	r22, 0x72	; 114
    19dc:	74 e0       	ldi	r23, 0x04	; 4
    19de:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    19e2:	66 e0       	ldi	r22, 0x06	; 6
    19e4:	c8 01       	movw	r24, r16
    19e6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    19ea:	6a e0       	ldi	r22, 0x0A	; 10
    19ec:	8e 81       	ldd	r24, Y+6	; 0x06
    19ee:	9f 81       	ldd	r25, Y+7	; 0x07
    19f0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    19f4:	8c 01       	movw	r16, r24
    19f6:	6b e4       	ldi	r22, 0x4B	; 75
    19f8:	74 e0       	ldi	r23, 0x04	; 4
    19fa:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    19fe:	66 e0       	ldi	r22, 0x06	; 6
    1a00:	c8 01       	movw	r24, r16
    1a02:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1a06:	6a e0       	ldi	r22, 0x0A	; 10
    1a08:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a0c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1a10:	8c 01       	movw	r16, r24
    1a12:	6d e2       	ldi	r22, 0x2D	; 45
    1a14:	74 e0       	ldi	r23, 0x04	; 4
    1a16:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1a1a:	66 e0       	ldi	r22, 0x06	; 6
    1a1c:	c8 01       	movw	r24, r16
    1a1e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1a22:	6a e0       	ldi	r22, 0x0A	; 10
    1a24:	8e 81       	ldd	r24, Y+6	; 0x06
    1a26:	9f 81       	ldd	r25, Y+7	; 0x07
    1a28:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1a2c:	8c 01       	movw	r16, r24
    1a2e:	62 e1       	ldi	r22, 0x12	; 18
    1a30:	74 e0       	ldi	r23, 0x04	; 4
    1a32:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1a36:	66 e0       	ldi	r22, 0x06	; 6
    1a38:	c8 01       	movw	r24, r16
    1a3a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1a3e:	6a e0       	ldi	r22, 0x0A	; 10
    1a40:	8e 81       	ldd	r24, Y+6	; 0x06
    1a42:	9f 81       	ldd	r25, Y+7	; 0x07
    1a44:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1a48:	ec 01       	movw	r28, r24
    1a4a:	63 e0       	ldi	r22, 0x03	; 3
    1a4c:	74 e0       	ldi	r23, 0x04	; 4
    1a4e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1a52:	66 e0       	ldi	r22, 0x06	; 6
    1a54:	ce 01       	movw	r24, r28
    1a56:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
}
    1a5a:	df 91       	pop	r29
    1a5c:	cf 91       	pop	r28
    1a5e:	1f 91       	pop	r17
    1a60:	0f 91       	pop	r16
    1a62:	08 95       	ret

00001a64 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1a64:	af 92       	push	r10
    1a66:	bf 92       	push	r11
    1a68:	cf 92       	push	r12
    1a6a:	df 92       	push	r13
    1a6c:	ef 92       	push	r14
    1a6e:	ff 92       	push	r15
    1a70:	0f 93       	push	r16
    1a72:	1f 93       	push	r17
    1a74:	cf 93       	push	r28
    1a76:	df 93       	push	r29
    1a78:	00 d0       	rcall	.+0      	; 0x1a7a <_ZN9task_user11show_statusEv+0x16>
    1a7a:	00 d0       	rcall	.+0      	; 0x1a7c <_ZN9task_user11show_statusEv+0x18>
    1a7c:	cd b7       	in	r28, 0x3d	; 61
    1a7e:	de b7       	in	r29, 0x3e	; 62
    1a80:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1a82:	19 82       	std	Y+1, r1	; 0x01
    1a84:	1a 82       	std	Y+2, r1	; 0x02
    1a86:	1b 82       	std	Y+3, r1	; 0x03
    1a88:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1a8a:	1d 82       	std	Y+5, r1	; 0x05
    1a8c:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1a8e:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <xPortGetFreeHeapSize>
    1a92:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a94:	ce 01       	movw	r24, r28
    1a96:	01 96       	adiw	r24, 0x01	; 1
    1a98:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_ZN10time_stamp10set_to_nowEv>
    1a9c:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1a9e:	66 e0       	ldi	r22, 0x06	; 6
    1aa0:	f8 01       	movw	r30, r16
    1aa2:	86 81       	ldd	r24, Z+6	; 0x06
    1aa4:	97 81       	ldd	r25, Z+7	; 0x07
    1aa6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1aaa:	6a e0       	ldi	r22, 0x0A	; 10
    1aac:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1ab0:	7c 01       	movw	r14, r24
    1ab2:	64 ee       	ldi	r22, 0xE4	; 228
    1ab4:	73 e0       	ldi	r23, 0x03	; 3
    1ab6:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1aba:	6a e0       	ldi	r22, 0x0A	; 10
    1abc:	c7 01       	movw	r24, r14
    1abe:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1ac2:	7c 01       	movw	r14, r24
    1ac4:	68 ed       	ldi	r22, 0xD8	; 216
    1ac6:	73 e0       	ldi	r23, 0x03	; 3
    1ac8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1acc:	66 e0       	ldi	r22, 0x06	; 6
    1ace:	c7 01       	movw	r24, r14
    1ad0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1ad4:	6a e0       	ldi	r22, 0x0A	; 10
    1ad6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1ada:	7c 01       	movw	r14, r24
    1adc:	61 ed       	ldi	r22, 0xD1	; 209
    1ade:	73 e0       	ldi	r23, 0x03	; 3
    1ae0:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1ae4:	b5 01       	movw	r22, r10
    1ae6:	c7 01       	movw	r24, r14
    1ae8:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1aec:	6a e0       	ldi	r22, 0x0A	; 10
    1aee:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1af2:	7c 01       	movw	r14, r24
    1af4:	63 ec       	ldi	r22, 0xC3	; 195
    1af6:	73 e0       	ldi	r23, 0x03	; 3
    1af8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1afc:	b6 01       	movw	r22, r12
    1afe:	c7 01       	movw	r24, r14
    1b00:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    1b04:	6a e0       	ldi	r22, 0x0A	; 10
    1b06:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1b0a:	7c 01       	movw	r14, r24
    1b0c:	61 ec       	ldi	r22, 0xC1	; 193
    1b0e:	73 e0       	ldi	r23, 0x03	; 3
    1b10:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1b14:	4f ef       	ldi	r20, 0xFF	; 255
    1b16:	5f e0       	ldi	r21, 0x0F	; 15
    1b18:	60 e0       	ldi	r22, 0x00	; 0
    1b1a:	70 e0       	ldi	r23, 0x00	; 0
    1b1c:	c7 01       	movw	r24, r14
    1b1e:	0e 94 4b 20 	call	0x4096	; 0x4096 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1b22:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1b26:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1b2a:	6a e0       	ldi	r22, 0x0A	; 10
    1b2c:	f8 01       	movw	r30, r16
    1b2e:	86 81       	ldd	r24, Z+6	; 0x06
    1b30:	97 81       	ldd	r25, Z+7	; 0x07
    1b32:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1b36:	7c 01       	movw	r14, r24
    1b38:	66 eb       	ldi	r22, 0xB6	; 182
    1b3a:	73 e0       	ldi	r23, 0x03	; 3
    1b3c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1b40:	b6 01       	movw	r22, r12
    1b42:	c7 01       	movw	r24, r14
    1b44:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    1b48:	66 e0       	ldi	r22, 0x06	; 6
    1b4a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1b4e:	66 e0       	ldi	r22, 0x06	; 6
    1b50:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1b54:	f8 01       	movw	r30, r16
    1b56:	86 81       	ldd	r24, Z+6	; 0x06
    1b58:	97 81       	ldd	r25, Z+7	; 0x07
    1b5a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <_Z15print_task_listP8emstream>
}
    1b5e:	26 96       	adiw	r28, 0x06	; 6
    1b60:	cd bf       	out	0x3d, r28	; 61
    1b62:	de bf       	out	0x3e, r29	; 62
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	ff 90       	pop	r15
    1b6e:	ef 90       	pop	r14
    1b70:	df 90       	pop	r13
    1b72:	cf 90       	pop	r12
    1b74:	bf 90       	pop	r11
    1b76:	af 90       	pop	r10
    1b78:	08 95       	ret

00001b7a <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
    1b7e:	00 d0       	rcall	.+0      	; 0x1b80 <_ZN9task_user3runEv+0x6>
    1b80:	00 d0       	rcall	.+0      	; 0x1b82 <_ZN9task_user3runEv+0x8>
    1b82:	cd b7       	in	r28, 0x3d	; 61
    1b84:	de b7       	in	r29, 0x3e	; 62
    1b86:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1b88:	19 82       	std	Y+1, r1	; 0x01
    1b8a:	1a 82       	std	Y+2, r1	; 0x02
    1b8c:	1b 82       	std	Y+3, r1	; 0x03
    1b8e:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1b90:	1d 82       	std	Y+5, r1	; 0x05
    1b92:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1b94:	6a e0       	ldi	r22, 0x0A	; 10
    1b96:	dc 01       	movw	r26, r24
    1b98:	16 96       	adiw	r26, 0x06	; 6
    1b9a:	8d 91       	ld	r24, X+
    1b9c:	9c 91       	ld	r25, X
    1b9e:	17 97       	sbiw	r26, 0x07	; 7
    1ba0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1ba4:	7c 01       	movw	r14, r24
    1ba6:	62 e5       	ldi	r22, 0x52	; 82
    1ba8:	75 e0       	ldi	r23, 0x05	; 5
    1baa:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1bae:	66 e0       	ldi	r22, 0x06	; 6
    1bb0:	c7 01       	movw	r24, r14
    1bb2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1bb6:	f8 01       	movw	r30, r16
    1bb8:	84 85       	ldd	r24, Z+12	; 0x0c
    1bba:	88 23       	and	r24, r24
    1bbc:	21 f0       	breq	.+8      	; 0x1bc6 <_ZN9task_user3runEv+0x4c>
    1bbe:	81 30       	cpi	r24, 0x01	; 1
    1bc0:	09 f4       	brne	.+2      	; 0x1bc4 <_ZN9task_user3runEv+0x4a>
    1bc2:	5d c0       	rjmp	.+186    	; 0x1c7e <_ZN9task_user3runEv+0x104>
    1bc4:	d8 c0       	rjmp	.+432    	; 0x1d76 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1bc6:	86 81       	ldd	r24, Z+6	; 0x06
    1bc8:	97 81       	ldd	r25, Z+7	; 0x07
    1bca:	dc 01       	movw	r26, r24
    1bcc:	ed 91       	ld	r30, X+
    1bce:	fc 91       	ld	r31, X
    1bd0:	04 80       	ldd	r0, Z+4	; 0x04
    1bd2:	f5 81       	ldd	r31, Z+5	; 0x05
    1bd4:	e0 2d       	mov	r30, r0
    1bd6:	19 95       	eicall
    1bd8:	88 23       	and	r24, r24
    1bda:	a9 f1       	breq	.+106    	; 0x1c46 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1bdc:	f8 01       	movw	r30, r16
    1bde:	86 81       	ldd	r24, Z+6	; 0x06
    1be0:	97 81       	ldd	r25, Z+7	; 0x07
    1be2:	dc 01       	movw	r26, r24
    1be4:	ed 91       	ld	r30, X+
    1be6:	fc 91       	ld	r31, X
    1be8:	06 80       	ldd	r0, Z+6	; 0x06
    1bea:	f7 81       	ldd	r31, Z+7	; 0x07
    1bec:	e0 2d       	mov	r30, r0
    1bee:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1bf0:	99 27       	eor	r25, r25
    1bf2:	81 30       	cpi	r24, 0x01	; 1
    1bf4:	91 05       	cpc	r25, r1
    1bf6:	f9 f0       	breq	.+62     	; 0x1c36 <_ZN9task_user3runEv+0xbc>
    1bf8:	03 97       	sbiw	r24, 0x03	; 3
    1bfa:	09 f0       	breq	.+2      	; 0x1bfe <_ZN9task_user3runEv+0x84>
    1bfc:	d8 c0       	rjmp	.+432    	; 0x1dae <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1bfe:	6a e0       	ldi	r22, 0x0A	; 10
    1c00:	f8 01       	movw	r30, r16
    1c02:	86 81       	ldd	r24, Z+6	; 0x06
    1c04:	97 81       	ldd	r25, Z+7	; 0x07
    1c06:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1c0a:	8c 01       	movw	r16, r24
    1c0c:	64 e4       	ldi	r22, 0x44	; 68
    1c0e:	75 e0       	ldi	r23, 0x05	; 5
    1c10:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1c14:	66 e0       	ldi	r22, 0x06	; 6
    1c16:	c8 01       	movw	r24, r16
    1c18:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1c1c:	93 e0       	ldi	r25, 0x03	; 3
    1c1e:	88 ed       	ldi	r24, 0xD8	; 216
    1c20:	08 b6       	in	r0, 0x38	; 56
    1c22:	18 be       	out	0x38, r1	; 56
    1c24:	84 bf       	out	0x34, r24	; 52
    1c26:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1c2a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1c2e:	81 fd       	sbrc	r24, 1
    1c30:	fc cf       	rjmp	.-8      	; 0x1c2a <_ZN9task_user3runEv+0xb0>
    1c32:	08 be       	out	0x38, r0	; 56
    1c34:	ff cf       	rjmp	.-2      	; 0x1c34 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1c36:	c8 01       	movw	r24, r16
    1c38:	0e 94 8a 0c 	call	0x1914	; 0x1914 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1c3c:	61 e0       	ldi	r22, 0x01	; 1
    1c3e:	c8 01       	movw	r24, r16
    1c40:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8frt_task13transition_toEh>
							break;
    1c44:	b4 c0       	rjmp	.+360    	; 0x1dae <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1c46:	8c ec       	ldi	r24, 0xCC	; 204
    1c48:	92 e3       	ldi	r25, 0x32	; 50
    1c4a:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <_ZN14frt_text_queue14check_for_charEv>
    1c4e:	88 23       	and	r24, r24
    1c50:	09 f4       	brne	.+2      	; 0x1c54 <_ZN9task_user3runEv+0xda>
    1c52:	ad c0       	rjmp	.+346    	; 0x1dae <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1c54:	d8 01       	movw	r26, r16
    1c56:	16 96       	adiw	r26, 0x06	; 6
    1c58:	ed 91       	ld	r30, X+
    1c5a:	fc 91       	ld	r31, X
    1c5c:	17 97       	sbiw	r26, 0x07	; 7
    1c5e:	01 90       	ld	r0, Z+
    1c60:	f0 81       	ld	r31, Z
    1c62:	e0 2d       	mov	r30, r0
    1c64:	e2 80       	ldd	r14, Z+2	; 0x02
    1c66:	f3 80       	ldd	r15, Z+3	; 0x03
    1c68:	8c ec       	ldi	r24, 0xCC	; 204
    1c6a:	92 e3       	ldi	r25, 0x32	; 50
    1c6c:	0e 94 cd 1c 	call	0x399a	; 0x399a <_ZN14frt_text_queue7getcharEv>
    1c70:	68 2f       	mov	r22, r24
    1c72:	f8 01       	movw	r30, r16
    1c74:	86 81       	ldd	r24, Z+6	; 0x06
    1c76:	97 81       	ldd	r25, Z+7	; 0x07
    1c78:	f7 01       	movw	r30, r14
    1c7a:	19 95       	eicall
    1c7c:	98 c0       	rjmp	.+304    	; 0x1dae <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1c7e:	86 81       	ldd	r24, Z+6	; 0x06
    1c80:	97 81       	ldd	r25, Z+7	; 0x07
    1c82:	dc 01       	movw	r26, r24
    1c84:	ed 91       	ld	r30, X+
    1c86:	fc 91       	ld	r31, X
    1c88:	04 80       	ldd	r0, Z+4	; 0x04
    1c8a:	f5 81       	ldd	r31, Z+5	; 0x05
    1c8c:	e0 2d       	mov	r30, r0
    1c8e:	19 95       	eicall
    1c90:	88 23       	and	r24, r24
    1c92:	09 f4       	brne	.+2      	; 0x1c96 <_ZN9task_user3runEv+0x11c>
    1c94:	8c c0       	rjmp	.+280    	; 0x1dae <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1c96:	f8 01       	movw	r30, r16
    1c98:	86 81       	ldd	r24, Z+6	; 0x06
    1c9a:	97 81       	ldd	r25, Z+7	; 0x07
    1c9c:	dc 01       	movw	r26, r24
    1c9e:	ed 91       	ld	r30, X+
    1ca0:	fc 91       	ld	r31, X
    1ca2:	06 80       	ldd	r0, Z+6	; 0x06
    1ca4:	f7 81       	ldd	r31, Z+7	; 0x07
    1ca6:	e0 2d       	mov	r30, r0
    1ca8:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1caa:	9c 01       	movw	r18, r24
    1cac:	33 27       	eor	r19, r19
    1cae:	28 36       	cpi	r18, 0x68	; 104
    1cb0:	31 05       	cpc	r19, r1
    1cb2:	59 f1       	breq	.+86     	; 0x1d0a <_ZN9task_user3runEv+0x190>
    1cb4:	3c f4       	brge	.+14     	; 0x1cc4 <_ZN9task_user3runEv+0x14a>
    1cb6:	2b 31       	cpi	r18, 0x1B	; 27
    1cb8:	31 05       	cpc	r19, r1
    1cba:	59 f1       	breq	.+86     	; 0x1d12 <_ZN9task_user3runEv+0x198>
    1cbc:	25 36       	cpi	r18, 0x65	; 101
    1cbe:	31 05       	cpc	r19, r1
    1cc0:	41 f1       	breq	.+80     	; 0x1d12 <_ZN9task_user3runEv+0x198>
    1cc2:	3b c0       	rjmp	.+118    	; 0x1d3a <_ZN9task_user3runEv+0x1c0>
    1cc4:	23 37       	cpi	r18, 0x73	; 115
    1cc6:	31 05       	cpc	r19, r1
    1cc8:	c1 f0       	breq	.+48     	; 0x1cfa <_ZN9task_user3runEv+0x180>
    1cca:	26 37       	cpi	r18, 0x76	; 118
    1ccc:	31 05       	cpc	r19, r1
    1cce:	89 f0       	breq	.+34     	; 0x1cf2 <_ZN9task_user3runEv+0x178>
    1cd0:	2e 36       	cpi	r18, 0x6E	; 110
    1cd2:	31 05       	cpc	r19, r1
    1cd4:	91 f5       	brne	.+100    	; 0x1d3a <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1cd6:	ce 01       	movw	r24, r28
    1cd8:	01 96       	adiw	r24, 0x01	; 1
    1cda:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_ZN10time_stamp10set_to_nowEv>
    1cde:	bc 01       	movw	r22, r24
    1ce0:	f8 01       	movw	r30, r16
    1ce2:	86 81       	ldd	r24, Z+6	; 0x06
    1ce4:	97 81       	ldd	r25, Z+7	; 0x07
    1ce6:	0e 94 83 1d 	call	0x3b06	; 0x3b06 <_ZlsR8emstreamR10time_stamp>
    1cea:	66 e0       	ldi	r22, 0x06	; 6
    1cec:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1cf0:	5e c0       	rjmp	.+188    	; 0x1dae <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1cf2:	c8 01       	movw	r24, r16
    1cf4:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <_ZN9task_user11show_statusEv>
							break;
    1cf8:	5a c0       	rjmp	.+180    	; 0x1dae <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1cfa:	d8 01       	movw	r26, r16
    1cfc:	16 96       	adiw	r26, 0x06	; 6
    1cfe:	8d 91       	ld	r24, X+
    1d00:	9c 91       	ld	r25, X
    1d02:	17 97       	sbiw	r26, 0x07	; 7
    1d04:	0e 94 43 1b 	call	0x3686	; 0x3686 <_Z17print_task_stacksP8emstream>
							break;
    1d08:	52 c0       	rjmp	.+164    	; 0x1dae <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1d0a:	c8 01       	movw	r24, r16
    1d0c:	0e 94 8a 0c 	call	0x1914	; 0x1914 <_ZN9task_user18print_help_messageEv>
							break;
    1d10:	4e c0       	rjmp	.+156    	; 0x1dae <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1d12:	6a e0       	ldi	r22, 0x0A	; 10
    1d14:	f8 01       	movw	r30, r16
    1d16:	86 81       	ldd	r24, Z+6	; 0x06
    1d18:	97 81       	ldd	r25, Z+7	; 0x07
    1d1a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1d1e:	7c 01       	movw	r14, r24
    1d20:	62 e3       	ldi	r22, 0x32	; 50
    1d22:	75 e0       	ldi	r23, 0x05	; 5
    1d24:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1d28:	66 e0       	ldi	r22, 0x06	; 6
    1d2a:	c7 01       	movw	r24, r14
    1d2c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1d30:	60 e0       	ldi	r22, 0x00	; 0
    1d32:	c8 01       	movw	r24, r16
    1d34:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8frt_task13transition_toEh>
							break;
    1d38:	3a c0       	rjmp	.+116    	; 0x1dae <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1d3a:	f8 01       	movw	r30, r16
    1d3c:	a6 81       	ldd	r26, Z+6	; 0x06
    1d3e:	b7 81       	ldd	r27, Z+7	; 0x07
    1d40:	ed 91       	ld	r30, X+
    1d42:	fc 91       	ld	r31, X
    1d44:	11 97       	sbiw	r26, 0x01	; 1
    1d46:	02 80       	ldd	r0, Z+2	; 0x02
    1d48:	f3 81       	ldd	r31, Z+3	; 0x03
    1d4a:	e0 2d       	mov	r30, r0
    1d4c:	68 2f       	mov	r22, r24
    1d4e:	cd 01       	movw	r24, r26
    1d50:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1d52:	6a e0       	ldi	r22, 0x0A	; 10
    1d54:	d8 01       	movw	r26, r16
    1d56:	16 96       	adiw	r26, 0x06	; 6
    1d58:	8d 91       	ld	r24, X+
    1d5a:	9c 91       	ld	r25, X
    1d5c:	17 97       	sbiw	r26, 0x07	; 7
    1d5e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1d62:	7c 01       	movw	r14, r24
    1d64:	6c e2       	ldi	r22, 0x2C	; 44
    1d66:	75 e0       	ldi	r23, 0x05	; 5
    1d68:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1d6c:	66 e0       	ldi	r22, 0x06	; 6
    1d6e:	c7 01       	movw	r24, r14
    1d70:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1d74:	1c c0       	rjmp	.+56     	; 0x1dae <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1d76:	6a e0       	ldi	r22, 0x0A	; 10
    1d78:	f8 01       	movw	r30, r16
    1d7a:	86 81       	ldd	r24, Z+6	; 0x06
    1d7c:	97 81       	ldd	r25, Z+7	; 0x07
    1d7e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    1d82:	8c 01       	movw	r16, r24
    1d84:	6f e0       	ldi	r22, 0x0F	; 15
    1d86:	75 e0       	ldi	r23, 0x05	; 5
    1d88:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    1d8c:	66 e0       	ldi	r22, 0x06	; 6
    1d8e:	c8 01       	movw	r24, r16
    1d90:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1d94:	93 e0       	ldi	r25, 0x03	; 3
    1d96:	88 ed       	ldi	r24, 0xD8	; 216
    1d98:	08 b6       	in	r0, 0x38	; 56
    1d9a:	18 be       	out	0x38, r1	; 56
    1d9c:	84 bf       	out	0x34, r24	; 52
    1d9e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1da2:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1da6:	81 fd       	sbrc	r24, 1
    1da8:	fc cf       	rjmp	.-8      	; 0x1da2 <_ZN9task_user3runEv+0x228>
    1daa:	08 be       	out	0x38, r0	; 56
    1dac:	ff cf       	rjmp	.-2      	; 0x1dac <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1dae:	f8 01       	movw	r30, r16
    1db0:	86 85       	ldd	r24, Z+14	; 0x0e
    1db2:	97 85       	ldd	r25, Z+15	; 0x0f
    1db4:	a0 89       	ldd	r26, Z+16	; 0x10
    1db6:	b1 89       	ldd	r27, Z+17	; 0x11
    1db8:	01 96       	adiw	r24, 0x01	; 1
    1dba:	a1 1d       	adc	r26, r1
    1dbc:	b1 1d       	adc	r27, r1
    1dbe:	86 87       	std	Z+14, r24	; 0x0e
    1dc0:	97 87       	std	Z+15, r25	; 0x0f
    1dc2:	a0 8b       	std	Z+16, r26	; 0x10
    1dc4:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1dc6:	68 ee       	ldi	r22, 0xE8	; 232
    1dc8:	73 e0       	ldi	r23, 0x03	; 3
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1dd2:	f1 ce       	rjmp	.-542    	; 0x1bb6 <_ZN9task_user3runEv+0x3c>

00001dd4 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29
    1ddc:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1dde:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1de2:	80 91 10 22 	lds	r24, 0x2210	; 0x802210 <__data_end>
    1de6:	81 11       	cpse	r24, r1
    1de8:	1d c0       	rjmp	.+58     	; 0x1e24 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1dea:	a5 e1       	ldi	r26, 0x15	; 21
    1dec:	b2 e2       	ldi	r27, 0x22	; 34
    1dee:	e9 e1       	ldi	r30, 0x19	; 25
    1df0:	f2 e2       	ldi	r31, 0x22	; 34
    1df2:	ed 93       	st	X+, r30
    1df4:	fc 93       	st	X, r31
    1df6:	11 97       	sbiw	r26, 0x01	; 1
    1df8:	12 96       	adiw	r26, 0x02	; 2
    1dfa:	1d 92       	st	X+, r1
    1dfc:	1c 92       	st	X, r1
    1dfe:	13 97       	sbiw	r26, 0x03	; 3
    1e00:	a1 e1       	ldi	r26, 0x11	; 17
    1e02:	b2 e2       	ldi	r27, 0x22	; 34
    1e04:	8f ef       	ldi	r24, 0xFF	; 255
    1e06:	9f e0       	ldi	r25, 0x0F	; 15
    1e08:	12 96       	adiw	r26, 0x02	; 2
    1e0a:	8d 93       	st	X+, r24
    1e0c:	9c 93       	st	X, r25
    1e0e:	13 97       	sbiw	r26, 0x03	; 3
    1e10:	1d 92       	st	X+, r1
    1e12:	1c 92       	st	X, r1
    1e14:	11 97       	sbiw	r26, 0x01	; 1
    1e16:	82 83       	std	Z+2, r24	; 0x02
    1e18:	93 83       	std	Z+3, r25	; 0x03
    1e1a:	a0 83       	st	Z, r26
    1e1c:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1e1e:	81 e0       	ldi	r24, 0x01	; 1
    1e20:	80 93 10 22 	sts	0x2210, r24	; 0x802210 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1e24:	20 97       	sbiw	r28, 0x00	; 0
    1e26:	09 f4       	brne	.+2      	; 0x1e2a <pvPortMalloc+0x56>
    1e28:	5f c0       	rjmp	.+190    	; 0x1ee8 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1e2a:	9e 01       	movw	r18, r28
    1e2c:	2b 5f       	subi	r18, 0xFB	; 251
    1e2e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1e30:	24 96       	adiw	r28, 0x04	; 4
    1e32:	ce 3f       	cpi	r28, 0xFE	; 254
    1e34:	df 40       	sbci	r29, 0x0F	; 15
    1e36:	08 f0       	brcs	.+2      	; 0x1e3a <pvPortMalloc+0x66>
    1e38:	5a c0       	rjmp	.+180    	; 0x1eee <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1e3a:	e0 91 15 22 	lds	r30, 0x2215	; 0x802215 <xStart>
    1e3e:	f0 91 16 22 	lds	r31, 0x2216	; 0x802216 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1e42:	a5 e1       	ldi	r26, 0x15	; 21
    1e44:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e46:	02 c0       	rjmp	.+4      	; 0x1e4c <pvPortMalloc+0x78>
    1e48:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1e4a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e4c:	82 81       	ldd	r24, Z+2	; 0x02
    1e4e:	93 81       	ldd	r25, Z+3	; 0x03
    1e50:	82 17       	cp	r24, r18
    1e52:	93 07       	cpc	r25, r19
    1e54:	20 f4       	brcc	.+8      	; 0x1e5e <pvPortMalloc+0x8a>
    1e56:	80 81       	ld	r24, Z
    1e58:	91 81       	ldd	r25, Z+1	; 0x01
    1e5a:	00 97       	sbiw	r24, 0x00	; 0
    1e5c:	a9 f7       	brne	.-22     	; 0x1e48 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1e5e:	c2 e2       	ldi	r28, 0x22	; 34
    1e60:	e1 31       	cpi	r30, 0x11	; 17
    1e62:	fc 07       	cpc	r31, r28
    1e64:	09 f4       	brne	.+2      	; 0x1e68 <pvPortMalloc+0x94>
    1e66:	46 c0       	rjmp	.+140    	; 0x1ef4 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1e68:	cd 91       	ld	r28, X+
    1e6a:	dc 91       	ld	r29, X
    1e6c:	11 97       	sbiw	r26, 0x01	; 1
    1e6e:	8e 01       	movw	r16, r28
    1e70:	0b 5f       	subi	r16, 0xFB	; 251
    1e72:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e74:	80 81       	ld	r24, Z
    1e76:	91 81       	ldd	r25, Z+1	; 0x01
    1e78:	8d 93       	st	X+, r24
    1e7a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e7c:	82 81       	ldd	r24, Z+2	; 0x02
    1e7e:	93 81       	ldd	r25, Z+3	; 0x03
    1e80:	82 1b       	sub	r24, r18
    1e82:	93 0b       	sbc	r25, r19
    1e84:	8b 30       	cpi	r24, 0x0B	; 11
    1e86:	91 05       	cpc	r25, r1
    1e88:	10 f1       	brcs	.+68     	; 0x1ece <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1e8a:	bf 01       	movw	r22, r30
    1e8c:	62 0f       	add	r22, r18
    1e8e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e90:	db 01       	movw	r26, r22
    1e92:	12 96       	adiw	r26, 0x02	; 2
    1e94:	8d 93       	st	X+, r24
    1e96:	9c 93       	st	X, r25
    1e98:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1e9a:	22 83       	std	Z+2, r18	; 0x02
    1e9c:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1e9e:	12 96       	adiw	r26, 0x02	; 2
    1ea0:	4d 91       	ld	r20, X+
    1ea2:	5c 91       	ld	r21, X
    1ea4:	13 97       	sbiw	r26, 0x03	; 3
    1ea6:	85 e1       	ldi	r24, 0x15	; 21
    1ea8:	92 e2       	ldi	r25, 0x22	; 34
    1eaa:	01 c0       	rjmp	.+2      	; 0x1eae <pvPortMalloc+0xda>
    1eac:	cd 01       	movw	r24, r26
    1eae:	ec 01       	movw	r28, r24
    1eb0:	a8 81       	ld	r26, Y
    1eb2:	b9 81       	ldd	r27, Y+1	; 0x01
    1eb4:	12 96       	adiw	r26, 0x02	; 2
    1eb6:	2d 91       	ld	r18, X+
    1eb8:	3c 91       	ld	r19, X
    1eba:	13 97       	sbiw	r26, 0x03	; 3
    1ebc:	24 17       	cp	r18, r20
    1ebe:	35 07       	cpc	r19, r21
    1ec0:	a8 f3       	brcs	.-22     	; 0x1eac <pvPortMalloc+0xd8>
    1ec2:	eb 01       	movw	r28, r22
    1ec4:	a8 83       	st	Y, r26
    1ec6:	b9 83       	std	Y+1, r27	; 0x01
    1ec8:	dc 01       	movw	r26, r24
    1eca:	6d 93       	st	X+, r22
    1ecc:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1ece:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1ed2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1ed6:	22 81       	ldd	r18, Z+2	; 0x02
    1ed8:	33 81       	ldd	r19, Z+3	; 0x03
    1eda:	82 1b       	sub	r24, r18
    1edc:	93 0b       	sbc	r25, r19
    1ede:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1ee2:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1ee6:	08 c0       	rjmp	.+16     	; 0x1ef8 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1ee8:	00 e0       	ldi	r16, 0x00	; 0
    1eea:	10 e0       	ldi	r17, 0x00	; 0
    1eec:	05 c0       	rjmp	.+10     	; 0x1ef8 <pvPortMalloc+0x124>
    1eee:	00 e0       	ldi	r16, 0x00	; 0
    1ef0:	10 e0       	ldi	r17, 0x00	; 0
    1ef2:	02 c0       	rjmp	.+4      	; 0x1ef8 <pvPortMalloc+0x124>
    1ef4:	00 e0       	ldi	r16, 0x00	; 0
    1ef6:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1ef8:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1efc:	c8 01       	movw	r24, r16
    1efe:	df 91       	pop	r29
    1f00:	cf 91       	pop	r28
    1f02:	1f 91       	pop	r17
    1f04:	0f 91       	pop	r16
    1f06:	08 95       	ret

00001f08 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1f08:	0f 93       	push	r16
    1f0a:	1f 93       	push	r17
    1f0c:	cf 93       	push	r28
    1f0e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1f10:	00 97       	sbiw	r24, 0x00	; 0
    1f12:	41 f1       	breq	.+80     	; 0x1f64 <vPortFree+0x5c>
    1f14:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1f16:	8c 01       	movw	r16, r24
    1f18:	05 50       	subi	r16, 0x05	; 5
    1f1a:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1f1c:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1f20:	f8 01       	movw	r30, r16
    1f22:	42 81       	ldd	r20, Z+2	; 0x02
    1f24:	53 81       	ldd	r21, Z+3	; 0x03
    1f26:	a5 e1       	ldi	r26, 0x15	; 21
    1f28:	b2 e2       	ldi	r27, 0x22	; 34
    1f2a:	01 c0       	rjmp	.+2      	; 0x1f2e <vPortFree+0x26>
    1f2c:	df 01       	movw	r26, r30
    1f2e:	ed 91       	ld	r30, X+
    1f30:	fc 91       	ld	r31, X
    1f32:	11 97       	sbiw	r26, 0x01	; 1
    1f34:	22 81       	ldd	r18, Z+2	; 0x02
    1f36:	33 81       	ldd	r19, Z+3	; 0x03
    1f38:	24 17       	cp	r18, r20
    1f3a:	35 07       	cpc	r19, r21
    1f3c:	b8 f3       	brcs	.-18     	; 0x1f2c <vPortFree+0x24>
    1f3e:	25 97       	sbiw	r28, 0x05	; 5
    1f40:	e8 83       	st	Y, r30
    1f42:	f9 83       	std	Y+1, r31	; 0x01
    1f44:	0d 93       	st	X+, r16
    1f46:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1f48:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1f4c:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1f50:	8a 81       	ldd	r24, Y+2	; 0x02
    1f52:	9b 81       	ldd	r25, Y+3	; 0x03
    1f54:	82 0f       	add	r24, r18
    1f56:	93 1f       	adc	r25, r19
    1f58:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f5c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1f60:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
	}
}
    1f64:	df 91       	pop	r29
    1f66:	cf 91       	pop	r28
    1f68:	1f 91       	pop	r17
    1f6a:	0f 91       	pop	r16
    1f6c:	08 95       	ret

00001f6e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1f6e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1f72:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1f76:	08 95       	ret

00001f78 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1f78:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1f7a:	03 96       	adiw	r24, 0x03	; 3
    1f7c:	81 83       	std	Z+1, r24	; 0x01
    1f7e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f80:	4f ef       	ldi	r20, 0xFF	; 255
    1f82:	5f ef       	ldi	r21, 0xFF	; 255
    1f84:	ba 01       	movw	r22, r20
    1f86:	43 83       	std	Z+3, r20	; 0x03
    1f88:	54 83       	std	Z+4, r21	; 0x04
    1f8a:	65 83       	std	Z+5, r22	; 0x05
    1f8c:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1f8e:	87 83       	std	Z+7, r24	; 0x07
    1f90:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1f92:	81 87       	std	Z+9, r24	; 0x09
    1f94:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1f96:	10 82       	st	Z, r1
    1f98:	08 95       	ret

00001f9a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	12 86       	std	Z+10, r1	; 0x0a
    1f9e:	13 86       	std	Z+11, r1	; 0x0b
    1fa0:	08 95       	ret

00001fa2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1fa2:	cf 93       	push	r28
    1fa4:	df 93       	push	r29
    1fa6:	fc 01       	movw	r30, r24
    1fa8:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1faa:	21 81       	ldd	r18, Z+1	; 0x01
    1fac:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1fae:	e9 01       	movw	r28, r18
    1fb0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fb2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fb4:	14 96       	adiw	r26, 0x04	; 4
    1fb6:	8d 93       	st	X+, r24
    1fb8:	9c 93       	st	X, r25
    1fba:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1fbc:	81 81       	ldd	r24, Z+1	; 0x01
    1fbe:	92 81       	ldd	r25, Z+2	; 0x02
    1fc0:	16 96       	adiw	r26, 0x06	; 6
    1fc2:	8d 93       	st	X+, r24
    1fc4:	9c 93       	st	X, r25
    1fc6:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1fc8:	8c 81       	ldd	r24, Y+4	; 0x04
    1fca:	9d 81       	ldd	r25, Y+5	; 0x05
    1fcc:	ec 01       	movw	r28, r24
    1fce:	6e 83       	std	Y+6, r22	; 0x06
    1fd0:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1fd2:	e9 01       	movw	r28, r18
    1fd4:	6c 83       	std	Y+4, r22	; 0x04
    1fd6:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1fd8:	61 83       	std	Z+1, r22	; 0x01
    1fda:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fdc:	1a 96       	adiw	r26, 0x0a	; 10
    1fde:	ed 93       	st	X+, r30
    1fe0:	fc 93       	st	X, r31
    1fe2:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1fe4:	80 81       	ld	r24, Z
    1fe6:	8f 5f       	subi	r24, 0xFF	; 255
    1fe8:	80 83       	st	Z, r24
}
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	08 95       	ret

00001ff0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1ff0:	0f 93       	push	r16
    1ff2:	1f 93       	push	r17
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
    1ff8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1ffa:	08 81       	ld	r16, Y
    1ffc:	19 81       	ldd	r17, Y+1	; 0x01
    1ffe:	2a 81       	ldd	r18, Y+2	; 0x02
    2000:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2002:	0f 3f       	cpi	r16, 0xFF	; 255
    2004:	4f ef       	ldi	r20, 0xFF	; 255
    2006:	14 07       	cpc	r17, r20
    2008:	24 07       	cpc	r18, r20
    200a:	34 07       	cpc	r19, r20
    200c:	31 f4       	brne	.+12     	; 0x201a <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    200e:	dc 01       	movw	r26, r24
    2010:	19 96       	adiw	r26, 0x09	; 9
    2012:	ed 91       	ld	r30, X+
    2014:	fc 91       	ld	r31, X
    2016:	1a 97       	sbiw	r26, 0x0a	; 10
    2018:	1f c0       	rjmp	.+62     	; 0x2058 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    201a:	fc 01       	movw	r30, r24
    201c:	33 96       	adiw	r30, 0x03	; 3
    201e:	dc 01       	movw	r26, r24
    2020:	17 96       	adiw	r26, 0x07	; 7
    2022:	4d 91       	ld	r20, X+
    2024:	5c 91       	ld	r21, X
    2026:	18 97       	sbiw	r26, 0x08	; 8
    2028:	da 01       	movw	r26, r20
    202a:	4d 91       	ld	r20, X+
    202c:	5d 91       	ld	r21, X+
    202e:	6d 91       	ld	r22, X+
    2030:	7c 91       	ld	r23, X
    2032:	04 17       	cp	r16, r20
    2034:	15 07       	cpc	r17, r21
    2036:	26 07       	cpc	r18, r22
    2038:	37 07       	cpc	r19, r23
    203a:	70 f0       	brcs	.+28     	; 0x2058 <vListInsert+0x68>
    203c:	04 80       	ldd	r0, Z+4	; 0x04
    203e:	f5 81       	ldd	r31, Z+5	; 0x05
    2040:	e0 2d       	mov	r30, r0
    2042:	a4 81       	ldd	r26, Z+4	; 0x04
    2044:	b5 81       	ldd	r27, Z+5	; 0x05
    2046:	4d 91       	ld	r20, X+
    2048:	5d 91       	ld	r21, X+
    204a:	6d 91       	ld	r22, X+
    204c:	7c 91       	ld	r23, X
    204e:	04 17       	cp	r16, r20
    2050:	15 07       	cpc	r17, r21
    2052:	26 07       	cpc	r18, r22
    2054:	37 07       	cpc	r19, r23
    2056:	90 f7       	brcc	.-28     	; 0x203c <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2058:	a4 81       	ldd	r26, Z+4	; 0x04
    205a:	b5 81       	ldd	r27, Z+5	; 0x05
    205c:	ac 83       	std	Y+4, r26	; 0x04
    205e:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2060:	16 96       	adiw	r26, 0x06	; 6
    2062:	cd 93       	st	X+, r28
    2064:	dc 93       	st	X, r29
    2066:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    2068:	ee 83       	std	Y+6, r30	; 0x06
    206a:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    206c:	c4 83       	std	Z+4, r28	; 0x04
    206e:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2070:	8a 87       	std	Y+10, r24	; 0x0a
    2072:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    2074:	fc 01       	movw	r30, r24
    2076:	20 81       	ld	r18, Z
    2078:	2f 5f       	subi	r18, 0xFF	; 255
    207a:	20 83       	st	Z, r18
}
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	1f 91       	pop	r17
    2082:	0f 91       	pop	r16
    2084:	08 95       	ret

00002086 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2086:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2088:	a4 81       	ldd	r26, Z+4	; 0x04
    208a:	b5 81       	ldd	r27, Z+5	; 0x05
    208c:	86 81       	ldd	r24, Z+6	; 0x06
    208e:	97 81       	ldd	r25, Z+7	; 0x07
    2090:	16 96       	adiw	r26, 0x06	; 6
    2092:	8d 93       	st	X+, r24
    2094:	9c 93       	st	X, r25
    2096:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2098:	a6 81       	ldd	r26, Z+6	; 0x06
    209a:	b7 81       	ldd	r27, Z+7	; 0x07
    209c:	84 81       	ldd	r24, Z+4	; 0x04
    209e:	95 81       	ldd	r25, Z+5	; 0x05
    20a0:	14 96       	adiw	r26, 0x04	; 4
    20a2:	8d 93       	st	X+, r24
    20a4:	9c 93       	st	X, r25
    20a6:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    20a8:	a2 85       	ldd	r26, Z+10	; 0x0a
    20aa:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    20ac:	11 96       	adiw	r26, 0x01	; 1
    20ae:	8d 91       	ld	r24, X+
    20b0:	9c 91       	ld	r25, X
    20b2:	12 97       	sbiw	r26, 0x02	; 2
    20b4:	e8 17       	cp	r30, r24
    20b6:	f9 07       	cpc	r31, r25
    20b8:	31 f4       	brne	.+12     	; 0x20c6 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    20ba:	86 81       	ldd	r24, Z+6	; 0x06
    20bc:	97 81       	ldd	r25, Z+7	; 0x07
    20be:	11 96       	adiw	r26, 0x01	; 1
    20c0:	8d 93       	st	X+, r24
    20c2:	9c 93       	st	X, r25
    20c4:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    20c6:	12 86       	std	Z+10, r1	; 0x0a
    20c8:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    20ca:	8c 91       	ld	r24, X
    20cc:	81 50       	subi	r24, 0x01	; 1
    20ce:	8c 93       	st	X, r24
    20d0:	08 95       	ret

000020d2 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    20d2:	80 93 dc 32 	sts	0x32DC, r24	; 0x8032dc <portStackTopForTask>
    20d6:	90 93 dd 32 	sts	0x32DD, r25	; 0x8032dd <portStackTopForTask+0x1>
    20da:	31 e1       	ldi	r19, 0x11	; 17
    20dc:	fc 01       	movw	r30, r24
    20de:	30 83       	st	Z, r19
    20e0:	31 97       	sbiw	r30, 0x01	; 1
    20e2:	22 e2       	ldi	r18, 0x22	; 34
    20e4:	20 83       	st	Z, r18
    20e6:	31 97       	sbiw	r30, 0x01	; 1
    20e8:	a3 e3       	ldi	r26, 0x33	; 51
    20ea:	a0 83       	st	Z, r26
    20ec:	31 97       	sbiw	r30, 0x01	; 1
    20ee:	60 83       	st	Z, r22
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	70 83       	st	Z, r23
    20f4:	31 97       	sbiw	r30, 0x01	; 1
    20f6:	10 82       	st	Z, r1
    20f8:	31 97       	sbiw	r30, 0x01	; 1
    20fa:	10 82       	st	Z, r1
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	60 e8       	ldi	r22, 0x80	; 128
    2100:	60 83       	st	Z, r22
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	10 82       	st	Z, r1
    2106:	31 97       	sbiw	r30, 0x01	; 1
    2108:	10 82       	st	Z, r1
    210a:	31 97       	sbiw	r30, 0x01	; 1
    210c:	10 82       	st	Z, r1
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	62 e0       	ldi	r22, 0x02	; 2
    2112:	60 83       	st	Z, r22
    2114:	31 97       	sbiw	r30, 0x01	; 1
    2116:	63 e0       	ldi	r22, 0x03	; 3
    2118:	60 83       	st	Z, r22
    211a:	31 97       	sbiw	r30, 0x01	; 1
    211c:	64 e0       	ldi	r22, 0x04	; 4
    211e:	60 83       	st	Z, r22
    2120:	31 97       	sbiw	r30, 0x01	; 1
    2122:	65 e0       	ldi	r22, 0x05	; 5
    2124:	60 83       	st	Z, r22
    2126:	31 97       	sbiw	r30, 0x01	; 1
    2128:	66 e0       	ldi	r22, 0x06	; 6
    212a:	60 83       	st	Z, r22
    212c:	31 97       	sbiw	r30, 0x01	; 1
    212e:	67 e0       	ldi	r22, 0x07	; 7
    2130:	60 83       	st	Z, r22
    2132:	31 97       	sbiw	r30, 0x01	; 1
    2134:	68 e0       	ldi	r22, 0x08	; 8
    2136:	60 83       	st	Z, r22
    2138:	31 97       	sbiw	r30, 0x01	; 1
    213a:	69 e0       	ldi	r22, 0x09	; 9
    213c:	60 83       	st	Z, r22
    213e:	31 97       	sbiw	r30, 0x01	; 1
    2140:	60 e1       	ldi	r22, 0x10	; 16
    2142:	60 83       	st	Z, r22
    2144:	31 97       	sbiw	r30, 0x01	; 1
    2146:	30 83       	st	Z, r19
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	32 e1       	ldi	r19, 0x12	; 18
    214c:	30 83       	st	Z, r19
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	33 e1       	ldi	r19, 0x13	; 19
    2152:	30 83       	st	Z, r19
    2154:	31 97       	sbiw	r30, 0x01	; 1
    2156:	34 e1       	ldi	r19, 0x14	; 20
    2158:	30 83       	st	Z, r19
    215a:	31 97       	sbiw	r30, 0x01	; 1
    215c:	35 e1       	ldi	r19, 0x15	; 21
    215e:	30 83       	st	Z, r19
    2160:	31 97       	sbiw	r30, 0x01	; 1
    2162:	36 e1       	ldi	r19, 0x16	; 22
    2164:	30 83       	st	Z, r19
    2166:	31 97       	sbiw	r30, 0x01	; 1
    2168:	37 e1       	ldi	r19, 0x17	; 23
    216a:	30 83       	st	Z, r19
    216c:	31 97       	sbiw	r30, 0x01	; 1
    216e:	38 e1       	ldi	r19, 0x18	; 24
    2170:	30 83       	st	Z, r19
    2172:	31 97       	sbiw	r30, 0x01	; 1
    2174:	39 e1       	ldi	r19, 0x19	; 25
    2176:	30 83       	st	Z, r19
    2178:	31 97       	sbiw	r30, 0x01	; 1
    217a:	30 e2       	ldi	r19, 0x20	; 32
    217c:	30 83       	st	Z, r19
    217e:	31 97       	sbiw	r30, 0x01	; 1
    2180:	31 e2       	ldi	r19, 0x21	; 33
    2182:	30 83       	st	Z, r19
    2184:	31 97       	sbiw	r30, 0x01	; 1
    2186:	20 83       	st	Z, r18
    2188:	31 97       	sbiw	r30, 0x01	; 1
    218a:	23 e2       	ldi	r18, 0x23	; 35
    218c:	20 83       	st	Z, r18
    218e:	31 97       	sbiw	r30, 0x01	; 1
    2190:	40 83       	st	Z, r20
    2192:	31 97       	sbiw	r30, 0x01	; 1
    2194:	50 83       	st	Z, r21
    2196:	31 97       	sbiw	r30, 0x01	; 1
    2198:	26 e2       	ldi	r18, 0x26	; 38
    219a:	20 83       	st	Z, r18
    219c:	31 97       	sbiw	r30, 0x01	; 1
    219e:	27 e2       	ldi	r18, 0x27	; 39
    21a0:	20 83       	st	Z, r18
    21a2:	31 97       	sbiw	r30, 0x01	; 1
    21a4:	28 e2       	ldi	r18, 0x28	; 40
    21a6:	20 83       	st	Z, r18
    21a8:	31 97       	sbiw	r30, 0x01	; 1
    21aa:	29 e2       	ldi	r18, 0x29	; 41
    21ac:	20 83       	st	Z, r18
    21ae:	31 97       	sbiw	r30, 0x01	; 1
    21b0:	20 e3       	ldi	r18, 0x30	; 48
    21b2:	20 83       	st	Z, r18
    21b4:	31 97       	sbiw	r30, 0x01	; 1
    21b6:	21 e3       	ldi	r18, 0x31	; 49
    21b8:	20 83       	st	Z, r18
    21ba:	89 97       	sbiw	r24, 0x29	; 41
    21bc:	08 95       	ret

000021be <xPortStartScheduler>:
    21be:	8c e7       	ldi	r24, 0x7C	; 124
    21c0:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    21c4:	8f ef       	ldi	r24, 0xFF	; 255
    21c6:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    21ca:	81 e0       	ldi	r24, 0x01	; 1
    21cc:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    21d0:	91 e1       	ldi	r25, 0x11	; 17
    21d2:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    21d6:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    21da:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    21de:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    21e2:	cd 91       	ld	r28, X+
    21e4:	cd bf       	out	0x3d, r28	; 61
    21e6:	dd 91       	ld	r29, X+
    21e8:	de bf       	out	0x3e, r29	; 62
    21ea:	ff 91       	pop	r31
    21ec:	ef 91       	pop	r30
    21ee:	df 91       	pop	r29
    21f0:	cf 91       	pop	r28
    21f2:	bf 91       	pop	r27
    21f4:	af 91       	pop	r26
    21f6:	9f 91       	pop	r25
    21f8:	8f 91       	pop	r24
    21fa:	7f 91       	pop	r23
    21fc:	6f 91       	pop	r22
    21fe:	5f 91       	pop	r21
    2200:	4f 91       	pop	r20
    2202:	3f 91       	pop	r19
    2204:	2f 91       	pop	r18
    2206:	1f 91       	pop	r17
    2208:	0f 91       	pop	r16
    220a:	ff 90       	pop	r15
    220c:	ef 90       	pop	r14
    220e:	df 90       	pop	r13
    2210:	cf 90       	pop	r12
    2212:	bf 90       	pop	r11
    2214:	af 90       	pop	r10
    2216:	9f 90       	pop	r9
    2218:	8f 90       	pop	r8
    221a:	7f 90       	pop	r7
    221c:	6f 90       	pop	r6
    221e:	5f 90       	pop	r5
    2220:	4f 90       	pop	r4
    2222:	3f 90       	pop	r3
    2224:	2f 90       	pop	r2
    2226:	1f 90       	pop	r1
    2228:	0f 90       	pop	r0
    222a:	0c be       	out	0x3c, r0	; 60
    222c:	0f 90       	pop	r0
    222e:	0b be       	out	0x3b, r0	; 59
    2230:	0f 90       	pop	r0
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	0f 90       	pop	r0
    2236:	08 95       	ret
    2238:	08 95       	ret

0000223a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    223a:	0f 92       	push	r0
    223c:	0f b6       	in	r0, 0x3f	; 63
    223e:	f8 94       	cli
    2240:	0f 92       	push	r0
    2242:	0b b6       	in	r0, 0x3b	; 59
    2244:	0f 92       	push	r0
    2246:	0c b6       	in	r0, 0x3c	; 60
    2248:	0f 92       	push	r0
    224a:	1f 92       	push	r1
    224c:	11 24       	eor	r1, r1
    224e:	2f 92       	push	r2
    2250:	3f 92       	push	r3
    2252:	4f 92       	push	r4
    2254:	5f 92       	push	r5
    2256:	6f 92       	push	r6
    2258:	7f 92       	push	r7
    225a:	8f 92       	push	r8
    225c:	9f 92       	push	r9
    225e:	af 92       	push	r10
    2260:	bf 92       	push	r11
    2262:	cf 92       	push	r12
    2264:	df 92       	push	r13
    2266:	ef 92       	push	r14
    2268:	ff 92       	push	r15
    226a:	0f 93       	push	r16
    226c:	1f 93       	push	r17
    226e:	2f 93       	push	r18
    2270:	3f 93       	push	r19
    2272:	4f 93       	push	r20
    2274:	5f 93       	push	r21
    2276:	6f 93       	push	r22
    2278:	7f 93       	push	r23
    227a:	8f 93       	push	r24
    227c:	9f 93       	push	r25
    227e:	af 93       	push	r26
    2280:	bf 93       	push	r27
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	ef 93       	push	r30
    2288:	ff 93       	push	r31
    228a:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    228e:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2292:	0d b6       	in	r0, 0x3d	; 61
    2294:	0d 92       	st	X+, r0
    2296:	0e b6       	in	r0, 0x3e	; 62
    2298:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    229a:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    229e:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    22a2:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    22a6:	cd 91       	ld	r28, X+
    22a8:	cd bf       	out	0x3d, r28	; 61
    22aa:	dd 91       	ld	r29, X+
    22ac:	de bf       	out	0x3e, r29	; 62
    22ae:	ff 91       	pop	r31
    22b0:	ef 91       	pop	r30
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	bf 91       	pop	r27
    22b8:	af 91       	pop	r26
    22ba:	9f 91       	pop	r25
    22bc:	8f 91       	pop	r24
    22be:	7f 91       	pop	r23
    22c0:	6f 91       	pop	r22
    22c2:	5f 91       	pop	r21
    22c4:	4f 91       	pop	r20
    22c6:	3f 91       	pop	r19
    22c8:	2f 91       	pop	r18
    22ca:	1f 91       	pop	r17
    22cc:	0f 91       	pop	r16
    22ce:	ff 90       	pop	r15
    22d0:	ef 90       	pop	r14
    22d2:	df 90       	pop	r13
    22d4:	cf 90       	pop	r12
    22d6:	bf 90       	pop	r11
    22d8:	af 90       	pop	r10
    22da:	9f 90       	pop	r9
    22dc:	8f 90       	pop	r8
    22de:	7f 90       	pop	r7
    22e0:	6f 90       	pop	r6
    22e2:	5f 90       	pop	r5
    22e4:	4f 90       	pop	r4
    22e6:	3f 90       	pop	r3
    22e8:	2f 90       	pop	r2
    22ea:	1f 90       	pop	r1
    22ec:	0f 90       	pop	r0
    22ee:	0c be       	out	0x3c, r0	; 60
    22f0:	0f 90       	pop	r0
    22f2:	0b be       	out	0x3b, r0	; 59
    22f4:	0f 90       	pop	r0
    22f6:	0f be       	out	0x3f, r0	; 63
    22f8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22fa:	08 95       	ret

000022fc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22fc:	0f 92       	push	r0
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
    2304:	0b b6       	in	r0, 0x3b	; 59
    2306:	0f 92       	push	r0
    2308:	0c b6       	in	r0, 0x3c	; 60
    230a:	0f 92       	push	r0
    230c:	1f 92       	push	r1
    230e:	11 24       	eor	r1, r1
    2310:	2f 92       	push	r2
    2312:	3f 92       	push	r3
    2314:	4f 92       	push	r4
    2316:	5f 92       	push	r5
    2318:	6f 92       	push	r6
    231a:	7f 92       	push	r7
    231c:	8f 92       	push	r8
    231e:	9f 92       	push	r9
    2320:	af 92       	push	r10
    2322:	bf 92       	push	r11
    2324:	cf 92       	push	r12
    2326:	df 92       	push	r13
    2328:	ef 92       	push	r14
    232a:	ff 92       	push	r15
    232c:	0f 93       	push	r16
    232e:	1f 93       	push	r17
    2330:	2f 93       	push	r18
    2332:	3f 93       	push	r19
    2334:	4f 93       	push	r20
    2336:	5f 93       	push	r21
    2338:	6f 93       	push	r22
    233a:	7f 93       	push	r23
    233c:	8f 93       	push	r24
    233e:	9f 93       	push	r25
    2340:	af 93       	push	r26
    2342:	bf 93       	push	r27
    2344:	cf 93       	push	r28
    2346:	df 93       	push	r29
    2348:	ef 93       	push	r30
    234a:	ff 93       	push	r31
    234c:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    2350:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2354:	0d b6       	in	r0, 0x3d	; 61
    2356:	0d 92       	st	X+, r0
    2358:	0e b6       	in	r0, 0x3e	; 62
    235a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    235c:	0e 94 7b 16 	call	0x2cf6	; 0x2cf6 <vTaskIncrementTick>
	vTaskSwitchContext();
    2360:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2364:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    2368:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    236c:	cd 91       	ld	r28, X+
    236e:	cd bf       	out	0x3d, r28	; 61
    2370:	dd 91       	ld	r29, X+
    2372:	de bf       	out	0x3e, r29	; 62
    2374:	ff 91       	pop	r31
    2376:	ef 91       	pop	r30
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	bf 91       	pop	r27
    237e:	af 91       	pop	r26
    2380:	9f 91       	pop	r25
    2382:	8f 91       	pop	r24
    2384:	7f 91       	pop	r23
    2386:	6f 91       	pop	r22
    2388:	5f 91       	pop	r21
    238a:	4f 91       	pop	r20
    238c:	3f 91       	pop	r19
    238e:	2f 91       	pop	r18
    2390:	1f 91       	pop	r17
    2392:	0f 91       	pop	r16
    2394:	ff 90       	pop	r15
    2396:	ef 90       	pop	r14
    2398:	df 90       	pop	r13
    239a:	cf 90       	pop	r12
    239c:	bf 90       	pop	r11
    239e:	af 90       	pop	r10
    23a0:	9f 90       	pop	r9
    23a2:	8f 90       	pop	r8
    23a4:	7f 90       	pop	r7
    23a6:	6f 90       	pop	r6
    23a8:	5f 90       	pop	r5
    23aa:	4f 90       	pop	r4
    23ac:	3f 90       	pop	r3
    23ae:	2f 90       	pop	r2
    23b0:	1f 90       	pop	r1
    23b2:	0f 90       	pop	r0
    23b4:	0c be       	out	0x3c, r0	; 60
    23b6:	0f 90       	pop	r0
    23b8:	0b be       	out	0x3b, r0	; 59
    23ba:	0f 90       	pop	r0
    23bc:	0f be       	out	0x3f, r0	; 63
    23be:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23c0:	08 95       	ret

000023c2 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    23c2:	0e 94 7e 11 	call	0x22fc	; 0x22fc <vPortYieldFromTick>
		asm volatile ( "reti" );
    23c6:	18 95       	reti

000023c8 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
    23cc:	ec 01       	movw	r28, r24
    23ce:	88 a1       	ldd	r24, Y+32	; 0x20
    23d0:	81 11       	cpse	r24, r1
    23d2:	0b c0       	rjmp	.+22     	; 0x23ea <prvCopyDataToQueue+0x22>
    23d4:	88 81       	ld	r24, Y
    23d6:	99 81       	ldd	r25, Y+1	; 0x01
    23d8:	89 2b       	or	r24, r25
    23da:	e1 f5       	brne	.+120    	; 0x2454 <prvCopyDataToQueue+0x8c>
    23dc:	8a 81       	ldd	r24, Y+2	; 0x02
    23de:	9b 81       	ldd	r25, Y+3	; 0x03
    23e0:	0e 94 e7 19 	call	0x33ce	; 0x33ce <vTaskPriorityDisinherit>
    23e4:	1a 82       	std	Y+2, r1	; 0x02
    23e6:	1b 82       	std	Y+3, r1	; 0x03
    23e8:	35 c0       	rjmp	.+106    	; 0x2454 <prvCopyDataToQueue+0x8c>
    23ea:	41 11       	cpse	r20, r1
    23ec:	17 c0       	rjmp	.+46     	; 0x241c <prvCopyDataToQueue+0x54>
    23ee:	48 2f       	mov	r20, r24
    23f0:	50 e0       	ldi	r21, 0x00	; 0
    23f2:	8c 81       	ldd	r24, Y+4	; 0x04
    23f4:	9d 81       	ldd	r25, Y+5	; 0x05
    23f6:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <memcpy>
    23fa:	28 a1       	ldd	r18, Y+32	; 0x20
    23fc:	8c 81       	ldd	r24, Y+4	; 0x04
    23fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2400:	82 0f       	add	r24, r18
    2402:	91 1d       	adc	r25, r1
    2404:	8c 83       	std	Y+4, r24	; 0x04
    2406:	9d 83       	std	Y+5, r25	; 0x05
    2408:	2a 81       	ldd	r18, Y+2	; 0x02
    240a:	3b 81       	ldd	r19, Y+3	; 0x03
    240c:	82 17       	cp	r24, r18
    240e:	93 07       	cpc	r25, r19
    2410:	08 f1       	brcs	.+66     	; 0x2454 <prvCopyDataToQueue+0x8c>
    2412:	88 81       	ld	r24, Y
    2414:	99 81       	ldd	r25, Y+1	; 0x01
    2416:	8c 83       	std	Y+4, r24	; 0x04
    2418:	9d 83       	std	Y+5, r25	; 0x05
    241a:	1c c0       	rjmp	.+56     	; 0x2454 <prvCopyDataToQueue+0x8c>
    241c:	48 2f       	mov	r20, r24
    241e:	50 e0       	ldi	r21, 0x00	; 0
    2420:	8e 81       	ldd	r24, Y+6	; 0x06
    2422:	9f 81       	ldd	r25, Y+7	; 0x07
    2424:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <memcpy>
    2428:	88 a1       	ldd	r24, Y+32	; 0x20
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	91 95       	neg	r25
    242e:	81 95       	neg	r24
    2430:	91 09       	sbc	r25, r1
    2432:	2e 81       	ldd	r18, Y+6	; 0x06
    2434:	3f 81       	ldd	r19, Y+7	; 0x07
    2436:	28 0f       	add	r18, r24
    2438:	39 1f       	adc	r19, r25
    243a:	2e 83       	std	Y+6, r18	; 0x06
    243c:	3f 83       	std	Y+7, r19	; 0x07
    243e:	48 81       	ld	r20, Y
    2440:	59 81       	ldd	r21, Y+1	; 0x01
    2442:	24 17       	cp	r18, r20
    2444:	35 07       	cpc	r19, r21
    2446:	30 f4       	brcc	.+12     	; 0x2454 <prvCopyDataToQueue+0x8c>
    2448:	2a 81       	ldd	r18, Y+2	; 0x02
    244a:	3b 81       	ldd	r19, Y+3	; 0x03
    244c:	82 0f       	add	r24, r18
    244e:	93 1f       	adc	r25, r19
    2450:	8e 83       	std	Y+6, r24	; 0x06
    2452:	9f 83       	std	Y+7, r25	; 0x07
    2454:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2456:	8f 5f       	subi	r24, 0xFF	; 255
    2458:	8e 8f       	std	Y+30, r24	; 0x1e
    245a:	df 91       	pop	r29
    245c:	cf 91       	pop	r28
    245e:	08 95       	ret

00002460 <prvCopyDataFromQueue>:
    2460:	fc 01       	movw	r30, r24
    2462:	80 81       	ld	r24, Z
    2464:	91 81       	ldd	r25, Z+1	; 0x01
    2466:	00 97       	sbiw	r24, 0x00	; 0
    2468:	a1 f0       	breq	.+40     	; 0x2492 <prvCopyDataFromQueue+0x32>
    246a:	40 a1       	ldd	r20, Z+32	; 0x20
    246c:	50 e0       	ldi	r21, 0x00	; 0
    246e:	26 81       	ldd	r18, Z+6	; 0x06
    2470:	37 81       	ldd	r19, Z+7	; 0x07
    2472:	24 0f       	add	r18, r20
    2474:	35 1f       	adc	r19, r21
    2476:	26 83       	std	Z+6, r18	; 0x06
    2478:	37 83       	std	Z+7, r19	; 0x07
    247a:	a2 81       	ldd	r26, Z+2	; 0x02
    247c:	b3 81       	ldd	r27, Z+3	; 0x03
    247e:	2a 17       	cp	r18, r26
    2480:	3b 07       	cpc	r19, r27
    2482:	10 f0       	brcs	.+4      	; 0x2488 <prvCopyDataFromQueue+0x28>
    2484:	86 83       	std	Z+6, r24	; 0x06
    2486:	97 83       	std	Z+7, r25	; 0x07
    2488:	cb 01       	movw	r24, r22
    248a:	66 81       	ldd	r22, Z+6	; 0x06
    248c:	77 81       	ldd	r23, Z+7	; 0x07
    248e:	0e 94 5a 27 	call	0x4eb4	; 0x4eb4 <memcpy>
    2492:	08 95       	ret

00002494 <prvUnlockQueue>:
    2494:	0f 93       	push	r16
    2496:	1f 93       	push	r17
    2498:	cf 93       	push	r28
    249a:	df 93       	push	r29
    249c:	ec 01       	movw	r28, r24
    249e:	0f b6       	in	r0, 0x3f	; 63
    24a0:	f8 94       	cli
    24a2:	0f 92       	push	r0
    24a4:	8a a1       	ldd	r24, Y+34	; 0x22
    24a6:	18 16       	cp	r1, r24
    24a8:	b4 f4       	brge	.+44     	; 0x24d6 <prvUnlockQueue+0x42>
    24aa:	8b 89       	ldd	r24, Y+19	; 0x13
    24ac:	81 11       	cpse	r24, r1
    24ae:	05 c0       	rjmp	.+10     	; 0x24ba <prvUnlockQueue+0x26>
    24b0:	12 c0       	rjmp	.+36     	; 0x24d6 <prvUnlockQueue+0x42>
    24b2:	8b 89       	ldd	r24, Y+19	; 0x13
    24b4:	81 11       	cpse	r24, r1
    24b6:	04 c0       	rjmp	.+8      	; 0x24c0 <prvUnlockQueue+0x2c>
    24b8:	0e c0       	rjmp	.+28     	; 0x24d6 <prvUnlockQueue+0x42>
    24ba:	8e 01       	movw	r16, r28
    24bc:	0d 5e       	subi	r16, 0xED	; 237
    24be:	1f 4f       	sbci	r17, 0xFF	; 255
    24c0:	c8 01       	movw	r24, r16
    24c2:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    24c6:	81 11       	cpse	r24, r1
    24c8:	0e 94 70 19 	call	0x32e0	; 0x32e0 <vTaskMissedYield>
    24cc:	8a a1       	ldd	r24, Y+34	; 0x22
    24ce:	81 50       	subi	r24, 0x01	; 1
    24d0:	8a a3       	std	Y+34, r24	; 0x22
    24d2:	18 16       	cp	r1, r24
    24d4:	74 f3       	brlt	.-36     	; 0x24b2 <prvUnlockQueue+0x1e>
    24d6:	8f ef       	ldi	r24, 0xFF	; 255
    24d8:	8a a3       	std	Y+34, r24	; 0x22
    24da:	0f 90       	pop	r0
    24dc:	0f be       	out	0x3f, r0	; 63
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	0f 92       	push	r0
    24e4:	89 a1       	ldd	r24, Y+33	; 0x21
    24e6:	18 16       	cp	r1, r24
    24e8:	b4 f4       	brge	.+44     	; 0x2516 <prvUnlockQueue+0x82>
    24ea:	88 85       	ldd	r24, Y+8	; 0x08
    24ec:	81 11       	cpse	r24, r1
    24ee:	05 c0       	rjmp	.+10     	; 0x24fa <prvUnlockQueue+0x66>
    24f0:	12 c0       	rjmp	.+36     	; 0x2516 <prvUnlockQueue+0x82>
    24f2:	88 85       	ldd	r24, Y+8	; 0x08
    24f4:	81 11       	cpse	r24, r1
    24f6:	04 c0       	rjmp	.+8      	; 0x2500 <prvUnlockQueue+0x6c>
    24f8:	0e c0       	rjmp	.+28     	; 0x2516 <prvUnlockQueue+0x82>
    24fa:	8e 01       	movw	r16, r28
    24fc:	08 5f       	subi	r16, 0xF8	; 248
    24fe:	1f 4f       	sbci	r17, 0xFF	; 255
    2500:	c8 01       	movw	r24, r16
    2502:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    2506:	81 11       	cpse	r24, r1
    2508:	0e 94 70 19 	call	0x32e0	; 0x32e0 <vTaskMissedYield>
    250c:	89 a1       	ldd	r24, Y+33	; 0x21
    250e:	81 50       	subi	r24, 0x01	; 1
    2510:	89 a3       	std	Y+33, r24	; 0x21
    2512:	18 16       	cp	r1, r24
    2514:	74 f3       	brlt	.-36     	; 0x24f2 <prvUnlockQueue+0x5e>
    2516:	8f ef       	ldi	r24, 0xFF	; 255
    2518:	89 a3       	std	Y+33, r24	; 0x21
    251a:	0f 90       	pop	r0
    251c:	0f be       	out	0x3f, r0	; 63
    251e:	df 91       	pop	r29
    2520:	cf 91       	pop	r28
    2522:	1f 91       	pop	r17
    2524:	0f 91       	pop	r16
    2526:	08 95       	ret

00002528 <xQueueGenericReset>:
    2528:	1f 93       	push	r17
    252a:	cf 93       	push	r28
    252c:	df 93       	push	r29
    252e:	61 30       	cpi	r22, 0x01	; 1
    2530:	59 f0       	breq	.+22     	; 0x2548 <xQueueGenericReset+0x20>
    2532:	fc 01       	movw	r30, r24
    2534:	23 89       	ldd	r18, Z+19	; 0x13
    2536:	30 85       	ldd	r19, Z+8	; 0x08
    2538:	31 11       	cpse	r19, r1
    253a:	2c c0       	rjmp	.+88     	; 0x2594 <xQueueGenericReset+0x6c>
    253c:	11 e0       	ldi	r17, 0x01	; 1
    253e:	21 11       	cpse	r18, r1
    2540:	10 e0       	ldi	r17, 0x00	; 0
    2542:	21 11       	cpse	r18, r1
    2544:	28 c0       	rjmp	.+80     	; 0x2596 <xQueueGenericReset+0x6e>
    2546:	01 c0       	rjmp	.+2      	; 0x254a <xQueueGenericReset+0x22>
    2548:	11 e0       	ldi	r17, 0x01	; 1
    254a:	ec 01       	movw	r28, r24
    254c:	48 81       	ld	r20, Y
    254e:	59 81       	ldd	r21, Y+1	; 0x01
    2550:	28 a1       	ldd	r18, Y+32	; 0x20
    2552:	30 e0       	ldi	r19, 0x00	; 0
    2554:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2556:	62 9f       	mul	r22, r18
    2558:	c0 01       	movw	r24, r0
    255a:	63 9f       	mul	r22, r19
    255c:	90 0d       	add	r25, r0
    255e:	11 24       	eor	r1, r1
    2560:	ba 01       	movw	r22, r20
    2562:	68 0f       	add	r22, r24
    2564:	79 1f       	adc	r23, r25
    2566:	6a 83       	std	Y+2, r22	; 0x02
    2568:	7b 83       	std	Y+3, r23	; 0x03
    256a:	1e 8e       	std	Y+30, r1	; 0x1e
    256c:	4c 83       	std	Y+4, r20	; 0x04
    256e:	5d 83       	std	Y+5, r21	; 0x05
    2570:	82 1b       	sub	r24, r18
    2572:	93 0b       	sbc	r25, r19
    2574:	84 0f       	add	r24, r20
    2576:	95 1f       	adc	r25, r21
    2578:	8e 83       	std	Y+6, r24	; 0x06
    257a:	9f 83       	std	Y+7, r25	; 0x07
    257c:	8f ef       	ldi	r24, 0xFF	; 255
    257e:	89 a3       	std	Y+33, r24	; 0x21
    2580:	8a a3       	std	Y+34, r24	; 0x22
    2582:	ce 01       	movw	r24, r28
    2584:	08 96       	adiw	r24, 0x08	; 8
    2586:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    258a:	ce 01       	movw	r24, r28
    258c:	43 96       	adiw	r24, 0x13	; 19
    258e:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2592:	01 c0       	rjmp	.+2      	; 0x2596 <xQueueGenericReset+0x6e>
    2594:	10 e0       	ldi	r17, 0x00	; 0
    2596:	81 2f       	mov	r24, r17
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	1f 91       	pop	r17
    259e:	08 95       	ret

000025a0 <xQueueGenericCreate>:
    25a0:	0f 93       	push	r16
    25a2:	1f 93       	push	r17
    25a4:	cf 93       	push	r28
    25a6:	df 93       	push	r29
    25a8:	88 23       	and	r24, r24
    25aa:	01 f1       	breq	.+64     	; 0x25ec <xQueueGenericCreate+0x4c>
    25ac:	06 2f       	mov	r16, r22
    25ae:	18 2f       	mov	r17, r24
    25b0:	83 e2       	ldi	r24, 0x23	; 35
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    25b8:	ec 01       	movw	r28, r24
    25ba:	89 2b       	or	r24, r25
    25bc:	c9 f0       	breq	.+50     	; 0x25f0 <xQueueGenericCreate+0x50>
    25be:	10 9f       	mul	r17, r16
    25c0:	c0 01       	movw	r24, r0
    25c2:	11 24       	eor	r1, r1
    25c4:	01 96       	adiw	r24, 0x01	; 1
    25c6:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    25ca:	88 83       	st	Y, r24
    25cc:	99 83       	std	Y+1, r25	; 0x01
    25ce:	89 2b       	or	r24, r25
    25d0:	39 f0       	breq	.+14     	; 0x25e0 <xQueueGenericCreate+0x40>
    25d2:	1f 8f       	std	Y+31, r17	; 0x1f
    25d4:	08 a3       	std	Y+32, r16	; 0x20
    25d6:	61 e0       	ldi	r22, 0x01	; 1
    25d8:	ce 01       	movw	r24, r28
    25da:	0e 94 94 12 	call	0x2528	; 0x2528 <xQueueGenericReset>
    25de:	08 c0       	rjmp	.+16     	; 0x25f0 <xQueueGenericCreate+0x50>
    25e0:	ce 01       	movw	r24, r28
    25e2:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <vPortFree>
    25e6:	c0 e0       	ldi	r28, 0x00	; 0
    25e8:	d0 e0       	ldi	r29, 0x00	; 0
    25ea:	02 c0       	rjmp	.+4      	; 0x25f0 <xQueueGenericCreate+0x50>
    25ec:	c0 e0       	ldi	r28, 0x00	; 0
    25ee:	d0 e0       	ldi	r29, 0x00	; 0
    25f0:	ce 01       	movw	r24, r28
    25f2:	df 91       	pop	r29
    25f4:	cf 91       	pop	r28
    25f6:	1f 91       	pop	r17
    25f8:	0f 91       	pop	r16
    25fa:	08 95       	ret

000025fc <xQueueGenericSend>:
    25fc:	af 92       	push	r10
    25fe:	bf 92       	push	r11
    2600:	cf 92       	push	r12
    2602:	df 92       	push	r13
    2604:	ef 92       	push	r14
    2606:	ff 92       	push	r15
    2608:	0f 93       	push	r16
    260a:	1f 93       	push	r17
    260c:	cf 93       	push	r28
    260e:	df 93       	push	r29
    2610:	cd b7       	in	r28, 0x3d	; 61
    2612:	de b7       	in	r29, 0x3e	; 62
    2614:	29 97       	sbiw	r28, 0x09	; 9
    2616:	cd bf       	out	0x3d, r28	; 61
    2618:	de bf       	out	0x3e, r29	; 62
    261a:	7c 01       	movw	r14, r24
    261c:	5b 01       	movw	r10, r22
    261e:	2e 83       	std	Y+6, r18	; 0x06
    2620:	3f 83       	std	Y+7, r19	; 0x07
    2622:	48 87       	std	Y+8, r20	; 0x08
    2624:	59 87       	std	Y+9, r21	; 0x09
    2626:	10 e0       	ldi	r17, 0x00	; 0
    2628:	6c 01       	movw	r12, r24
    262a:	88 e0       	ldi	r24, 0x08	; 8
    262c:	c8 0e       	add	r12, r24
    262e:	d1 1c       	adc	r13, r1
    2630:	0f b6       	in	r0, 0x3f	; 63
    2632:	f8 94       	cli
    2634:	0f 92       	push	r0
    2636:	f7 01       	movw	r30, r14
    2638:	96 8d       	ldd	r25, Z+30	; 0x1e
    263a:	87 8d       	ldd	r24, Z+31	; 0x1f
    263c:	98 17       	cp	r25, r24
    263e:	a8 f4       	brcc	.+42     	; 0x266a <xQueueGenericSend+0x6e>
    2640:	40 2f       	mov	r20, r16
    2642:	b5 01       	movw	r22, r10
    2644:	c7 01       	movw	r24, r14
    2646:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <prvCopyDataToQueue>
    264a:	f7 01       	movw	r30, r14
    264c:	83 89       	ldd	r24, Z+19	; 0x13
    264e:	88 23       	and	r24, r24
    2650:	41 f0       	breq	.+16     	; 0x2662 <xQueueGenericSend+0x66>
    2652:	c7 01       	movw	r24, r14
    2654:	43 96       	adiw	r24, 0x13	; 19
    2656:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    265a:	81 30       	cpi	r24, 0x01	; 1
    265c:	11 f4       	brne	.+4      	; 0x2662 <xQueueGenericSend+0x66>
    265e:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    2662:	0f 90       	pop	r0
    2664:	0f be       	out	0x3f, r0	; 63
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	56 c0       	rjmp	.+172    	; 0x2716 <xQueueGenericSend+0x11a>
    266a:	8e 81       	ldd	r24, Y+6	; 0x06
    266c:	9f 81       	ldd	r25, Y+7	; 0x07
    266e:	a8 85       	ldd	r26, Y+8	; 0x08
    2670:	b9 85       	ldd	r27, Y+9	; 0x09
    2672:	89 2b       	or	r24, r25
    2674:	8a 2b       	or	r24, r26
    2676:	8b 2b       	or	r24, r27
    2678:	21 f4       	brne	.+8      	; 0x2682 <xQueueGenericSend+0x86>
    267a:	0f 90       	pop	r0
    267c:	0f be       	out	0x3f, r0	; 63
    267e:	80 e0       	ldi	r24, 0x00	; 0
    2680:	4a c0       	rjmp	.+148    	; 0x2716 <xQueueGenericSend+0x11a>
    2682:	11 11       	cpse	r17, r1
    2684:	05 c0       	rjmp	.+10     	; 0x2690 <xQueueGenericSend+0x94>
    2686:	ce 01       	movw	r24, r28
    2688:	01 96       	adiw	r24, 0x01	; 1
    268a:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <vTaskSetTimeOutState>
    268e:	11 e0       	ldi	r17, 0x01	; 1
    2690:	0f 90       	pop	r0
    2692:	0f be       	out	0x3f, r0	; 63
    2694:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <vTaskSuspendAll>
    2698:	0f b6       	in	r0, 0x3f	; 63
    269a:	f8 94       	cli
    269c:	0f 92       	push	r0
    269e:	f7 01       	movw	r30, r14
    26a0:	81 a1       	ldd	r24, Z+33	; 0x21
    26a2:	8f 3f       	cpi	r24, 0xFF	; 255
    26a4:	09 f4       	brne	.+2      	; 0x26a8 <xQueueGenericSend+0xac>
    26a6:	11 a2       	std	Z+33, r1	; 0x21
    26a8:	f7 01       	movw	r30, r14
    26aa:	82 a1       	ldd	r24, Z+34	; 0x22
    26ac:	8f 3f       	cpi	r24, 0xFF	; 255
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <xQueueGenericSend+0xb6>
    26b0:	12 a2       	std	Z+34, r1	; 0x22
    26b2:	0f 90       	pop	r0
    26b4:	0f be       	out	0x3f, r0	; 63
    26b6:	be 01       	movw	r22, r28
    26b8:	6a 5f       	subi	r22, 0xFA	; 250
    26ba:	7f 4f       	sbci	r23, 0xFF	; 255
    26bc:	ce 01       	movw	r24, r28
    26be:	01 96       	adiw	r24, 0x01	; 1
    26c0:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCheckForTimeOut>
    26c4:	81 11       	cpse	r24, r1
    26c6:	21 c0       	rjmp	.+66     	; 0x270a <xQueueGenericSend+0x10e>
    26c8:	0f b6       	in	r0, 0x3f	; 63
    26ca:	f8 94       	cli
    26cc:	0f 92       	push	r0
    26ce:	f7 01       	movw	r30, r14
    26d0:	96 8d       	ldd	r25, Z+30	; 0x1e
    26d2:	0f 90       	pop	r0
    26d4:	0f be       	out	0x3f, r0	; 63
    26d6:	87 8d       	ldd	r24, Z+31	; 0x1f
    26d8:	98 13       	cpse	r25, r24
    26da:	11 c0       	rjmp	.+34     	; 0x26fe <xQueueGenericSend+0x102>
    26dc:	4e 81       	ldd	r20, Y+6	; 0x06
    26de:	5f 81       	ldd	r21, Y+7	; 0x07
    26e0:	68 85       	ldd	r22, Y+8	; 0x08
    26e2:	79 85       	ldd	r23, Y+9	; 0x09
    26e4:	c6 01       	movw	r24, r12
    26e6:	0e 94 89 18 	call	0x3112	; 0x3112 <vTaskPlaceOnEventList>
    26ea:	c7 01       	movw	r24, r14
    26ec:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
    26f0:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
    26f4:	81 11       	cpse	r24, r1
    26f6:	9c cf       	rjmp	.-200    	; 0x2630 <xQueueGenericSend+0x34>
    26f8:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    26fc:	99 cf       	rjmp	.-206    	; 0x2630 <xQueueGenericSend+0x34>
    26fe:	c7 01       	movw	r24, r14
    2700:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
    2704:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
    2708:	93 cf       	rjmp	.-218    	; 0x2630 <xQueueGenericSend+0x34>
    270a:	c7 01       	movw	r24, r14
    270c:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
    2710:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	29 96       	adiw	r28, 0x09	; 9
    2718:	cd bf       	out	0x3d, r28	; 61
    271a:	de bf       	out	0x3e, r29	; 62
    271c:	df 91       	pop	r29
    271e:	cf 91       	pop	r28
    2720:	1f 91       	pop	r17
    2722:	0f 91       	pop	r16
    2724:	ff 90       	pop	r15
    2726:	ef 90       	pop	r14
    2728:	df 90       	pop	r13
    272a:	cf 90       	pop	r12
    272c:	bf 90       	pop	r11
    272e:	af 90       	pop	r10
    2730:	08 95       	ret

00002732 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    2732:	0f 93       	push	r16
    2734:	1f 93       	push	r17
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    273c:	fc 01       	movw	r30, r24
    273e:	56 8d       	ldd	r21, Z+30	; 0x1e
    2740:	37 8d       	ldd	r19, Z+31	; 0x1f
    2742:	53 17       	cp	r21, r19
    2744:	c0 f4       	brcc	.+48     	; 0x2776 <xQueueGenericSendFromISR+0x44>
    2746:	42 2f       	mov	r20, r18
    2748:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    274a:	0e 94 e4 11 	call	0x23c8	; 0x23c8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    274e:	8a a1       	ldd	r24, Y+34	; 0x22
    2750:	8f 3f       	cpi	r24, 0xFF	; 255
    2752:	69 f4       	brne	.+26     	; 0x276e <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2754:	8b 89       	ldd	r24, Y+19	; 0x13
    2756:	88 23       	and	r24, r24
    2758:	81 f0       	breq	.+32     	; 0x277a <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    275a:	ce 01       	movw	r24, r28
    275c:	43 96       	adiw	r24, 0x13	; 19
    275e:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    2762:	88 23       	and	r24, r24
    2764:	61 f0       	breq	.+24     	; 0x277e <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	f8 01       	movw	r30, r16
    276a:	80 83       	st	Z, r24
    276c:	09 c0       	rjmp	.+18     	; 0x2780 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    276e:	8f 5f       	subi	r24, 0xFF	; 255
    2770:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    2772:	81 e0       	ldi	r24, 0x01	; 1
    2774:	05 c0       	rjmp	.+10     	; 0x2780 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2776:	80 e0       	ldi	r24, 0x00	; 0
    2778:	03 c0       	rjmp	.+6      	; 0x2780 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	01 c0       	rjmp	.+2      	; 0x2780 <xQueueGenericSendFromISR+0x4e>
    277e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2780:	df 91       	pop	r29
    2782:	cf 91       	pop	r28
    2784:	1f 91       	pop	r17
    2786:	0f 91       	pop	r16
    2788:	08 95       	ret

0000278a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    278a:	af 92       	push	r10
    278c:	bf 92       	push	r11
    278e:	cf 92       	push	r12
    2790:	df 92       	push	r13
    2792:	ef 92       	push	r14
    2794:	ff 92       	push	r15
    2796:	0f 93       	push	r16
    2798:	1f 93       	push	r17
    279a:	cf 93       	push	r28
    279c:	df 93       	push	r29
    279e:	cd b7       	in	r28, 0x3d	; 61
    27a0:	de b7       	in	r29, 0x3e	; 62
    27a2:	29 97       	sbiw	r28, 0x09	; 9
    27a4:	cd bf       	out	0x3d, r28	; 61
    27a6:	de bf       	out	0x3e, r29	; 62
    27a8:	7c 01       	movw	r14, r24
    27aa:	5b 01       	movw	r10, r22
    27ac:	2e 83       	std	Y+6, r18	; 0x06
    27ae:	3f 83       	std	Y+7, r19	; 0x07
    27b0:	48 87       	std	Y+8, r20	; 0x08
    27b2:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    27b4:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    27b6:	6c 01       	movw	r12, r24
    27b8:	83 e1       	ldi	r24, 0x13	; 19
    27ba:	c8 0e       	add	r12, r24
    27bc:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    27be:	0f b6       	in	r0, 0x3f	; 63
    27c0:	f8 94       	cli
    27c2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    27c4:	f7 01       	movw	r30, r14
    27c6:	86 8d       	ldd	r24, Z+30	; 0x1e
    27c8:	88 23       	and	r24, r24
    27ca:	99 f1       	breq	.+102    	; 0x2832 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    27cc:	c6 80       	ldd	r12, Z+6	; 0x06
    27ce:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    27d0:	b5 01       	movw	r22, r10
    27d2:	c7 01       	movw	r24, r14
    27d4:	0e 94 30 12 	call	0x2460	; 0x2460 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    27d8:	01 11       	cpse	r16, r1
    27da:	1a c0       	rjmp	.+52     	; 0x2810 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    27dc:	f7 01       	movw	r30, r14
    27de:	86 8d       	ldd	r24, Z+30	; 0x1e
    27e0:	81 50       	subi	r24, 0x01	; 1
    27e2:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    27e4:	80 81       	ld	r24, Z
    27e6:	91 81       	ldd	r25, Z+1	; 0x01
    27e8:	89 2b       	or	r24, r25
    27ea:	29 f4       	brne	.+10     	; 0x27f6 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    27ec:	0e 94 8d 19 	call	0x331a	; 0x331a <xTaskGetCurrentTaskHandle>
    27f0:	f7 01       	movw	r30, r14
    27f2:	82 83       	std	Z+2, r24	; 0x02
    27f4:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27f6:	f7 01       	movw	r30, r14
    27f8:	80 85       	ldd	r24, Z+8	; 0x08
    27fa:	88 23       	and	r24, r24
    27fc:	b1 f0       	breq	.+44     	; 0x282a <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    27fe:	c7 01       	movw	r24, r14
    2800:	08 96       	adiw	r24, 0x08	; 8
    2802:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    2806:	81 30       	cpi	r24, 0x01	; 1
    2808:	81 f4       	brne	.+32     	; 0x282a <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    280a:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    280e:	0d c0       	rjmp	.+26     	; 0x282a <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    2810:	f7 01       	movw	r30, r14
    2812:	c6 82       	std	Z+6, r12	; 0x06
    2814:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2816:	83 89       	ldd	r24, Z+19	; 0x13
    2818:	88 23       	and	r24, r24
    281a:	39 f0       	breq	.+14     	; 0x282a <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    281c:	c7 01       	movw	r24, r14
    281e:	43 96       	adiw	r24, 0x13	; 19
    2820:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    2824:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2826:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    282a:	0f 90       	pop	r0
    282c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    282e:	81 e0       	ldi	r24, 0x01	; 1
    2830:	62 c0       	rjmp	.+196    	; 0x28f6 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2832:	8e 81       	ldd	r24, Y+6	; 0x06
    2834:	9f 81       	ldd	r25, Y+7	; 0x07
    2836:	a8 85       	ldd	r26, Y+8	; 0x08
    2838:	b9 85       	ldd	r27, Y+9	; 0x09
    283a:	89 2b       	or	r24, r25
    283c:	8a 2b       	or	r24, r26
    283e:	8b 2b       	or	r24, r27
    2840:	21 f4       	brne	.+8      	; 0x284a <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2842:	0f 90       	pop	r0
    2844:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2846:	80 e0       	ldi	r24, 0x00	; 0
    2848:	56 c0       	rjmp	.+172    	; 0x28f6 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    284a:	11 11       	cpse	r17, r1
    284c:	05 c0       	rjmp	.+10     	; 0x2858 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    284e:	ce 01       	movw	r24, r28
    2850:	01 96       	adiw	r24, 0x01	; 1
    2852:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2856:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2858:	0f 90       	pop	r0
    285a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    285c:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2860:	0f b6       	in	r0, 0x3f	; 63
    2862:	f8 94       	cli
    2864:	0f 92       	push	r0
    2866:	f7 01       	movw	r30, r14
    2868:	81 a1       	ldd	r24, Z+33	; 0x21
    286a:	8f 3f       	cpi	r24, 0xFF	; 255
    286c:	09 f4       	brne	.+2      	; 0x2870 <xQueueGenericReceive+0xe6>
    286e:	11 a2       	std	Z+33, r1	; 0x21
    2870:	f7 01       	movw	r30, r14
    2872:	82 a1       	ldd	r24, Z+34	; 0x22
    2874:	8f 3f       	cpi	r24, 0xFF	; 255
    2876:	09 f4       	brne	.+2      	; 0x287a <xQueueGenericReceive+0xf0>
    2878:	12 a2       	std	Z+34, r1	; 0x22
    287a:	0f 90       	pop	r0
    287c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    287e:	be 01       	movw	r22, r28
    2880:	6a 5f       	subi	r22, 0xFA	; 250
    2882:	7f 4f       	sbci	r23, 0xFF	; 255
    2884:	ce 01       	movw	r24, r28
    2886:	01 96       	adiw	r24, 0x01	; 1
    2888:	0e 94 03 19 	call	0x3206	; 0x3206 <xTaskCheckForTimeOut>
    288c:	81 11       	cpse	r24, r1
    288e:	2d c0       	rjmp	.+90     	; 0x28ea <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	f8 94       	cli
    2894:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2896:	f7 01       	movw	r30, r14
    2898:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    289a:	0f 90       	pop	r0
    289c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    289e:	81 11       	cpse	r24, r1
    28a0:	1e c0       	rjmp	.+60     	; 0x28de <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28a2:	80 81       	ld	r24, Z
    28a4:	91 81       	ldd	r25, Z+1	; 0x01
    28a6:	89 2b       	or	r24, r25
    28a8:	49 f4       	brne	.+18     	; 0x28bc <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    28aa:	0f b6       	in	r0, 0x3f	; 63
    28ac:	f8 94       	cli
    28ae:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    28b0:	82 81       	ldd	r24, Z+2	; 0x02
    28b2:	93 81       	ldd	r25, Z+3	; 0x03
    28b4:	0e 94 92 19 	call	0x3324	; 0x3324 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    28b8:	0f 90       	pop	r0
    28ba:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28bc:	4e 81       	ldd	r20, Y+6	; 0x06
    28be:	5f 81       	ldd	r21, Y+7	; 0x07
    28c0:	68 85       	ldd	r22, Y+8	; 0x08
    28c2:	79 85       	ldd	r23, Y+9	; 0x09
    28c4:	c6 01       	movw	r24, r12
    28c6:	0e 94 89 18 	call	0x3112	; 0x3112 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    28ca:	c7 01       	movw	r24, r14
    28cc:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    28d0:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
    28d4:	81 11       	cpse	r24, r1
    28d6:	73 cf       	rjmp	.-282    	; 0x27be <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    28d8:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    28dc:	70 cf       	rjmp	.-288    	; 0x27be <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    28de:	c7 01       	movw	r24, r14
    28e0:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    28e4:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
    28e8:	6a cf       	rjmp	.-300    	; 0x27be <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    28ea:	c7 01       	movw	r24, r14
    28ec:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    28f0:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    28f4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    28f6:	29 96       	adiw	r28, 0x09	; 9
    28f8:	cd bf       	out	0x3d, r28	; 61
    28fa:	de bf       	out	0x3e, r29	; 62
    28fc:	df 91       	pop	r29
    28fe:	cf 91       	pop	r28
    2900:	1f 91       	pop	r17
    2902:	0f 91       	pop	r16
    2904:	ff 90       	pop	r15
    2906:	ef 90       	pop	r14
    2908:	df 90       	pop	r13
    290a:	cf 90       	pop	r12
    290c:	bf 90       	pop	r11
    290e:	af 90       	pop	r10
    2910:	08 95       	ret

00002912 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2912:	0f 93       	push	r16
    2914:	1f 93       	push	r17
    2916:	cf 93       	push	r28
    2918:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    291a:	fc 01       	movw	r30, r24
    291c:	26 8d       	ldd	r18, Z+30	; 0x1e
    291e:	22 23       	and	r18, r18
    2920:	d9 f0       	breq	.+54     	; 0x2958 <xQueueReceiveFromISR+0x46>
    2922:	8a 01       	movw	r16, r20
    2924:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2926:	0e 94 30 12 	call	0x2460	; 0x2460 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    292a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    292c:	81 50       	subi	r24, 0x01	; 1
    292e:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2930:	89 a1       	ldd	r24, Y+33	; 0x21
    2932:	8f 3f       	cpi	r24, 0xFF	; 255
    2934:	69 f4       	brne	.+26     	; 0x2950 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2936:	88 85       	ldd	r24, Y+8	; 0x08
    2938:	88 23       	and	r24, r24
    293a:	81 f0       	breq	.+32     	; 0x295c <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    293c:	ce 01       	movw	r24, r28
    293e:	08 96       	adiw	r24, 0x08	; 8
    2940:	0e 94 b3 18 	call	0x3166	; 0x3166 <xTaskRemoveFromEventList>
    2944:	88 23       	and	r24, r24
    2946:	61 f0       	breq	.+24     	; 0x2960 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2948:	81 e0       	ldi	r24, 0x01	; 1
    294a:	f8 01       	movw	r30, r16
    294c:	80 83       	st	Z, r24
    294e:	09 c0       	rjmp	.+18     	; 0x2962 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2950:	8f 5f       	subi	r24, 0xFF	; 255
    2952:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    2954:	81 e0       	ldi	r24, 0x01	; 1
    2956:	05 c0       	rjmp	.+10     	; 0x2962 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2958:	80 e0       	ldi	r24, 0x00	; 0
    295a:	03 c0       	rjmp	.+6      	; 0x2962 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    295c:	81 e0       	ldi	r24, 0x01	; 1
    295e:	01 c0       	rjmp	.+2      	; 0x2962 <xQueueReceiveFromISR+0x50>
    2960:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2962:	df 91       	pop	r29
    2964:	cf 91       	pop	r28
    2966:	1f 91       	pop	r17
    2968:	0f 91       	pop	r16
    296a:	08 95       	ret

0000296c <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	f8 94       	cli
    2970:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2972:	fc 01       	movw	r30, r24
    2974:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2976:	0f 90       	pop	r0
    2978:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    297a:	08 95       	ret

0000297c <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    297c:	fc 01       	movw	r30, r24
    297e:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    2980:	08 95       	ret

00002982 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2982:	cc e4       	ldi	r28, 0x4C	; 76
    2984:	d2 e3       	ldi	r29, 0x32	; 50
    2986:	88 81       	ld	r24, Y
    2988:	82 30       	cpi	r24, 0x02	; 2
    298a:	e8 f3       	brcs	.-6      	; 0x2986 <prvIdleTask+0x4>
    298c:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    2990:	fa cf       	rjmp	.-12     	; 0x2986 <prvIdleTask+0x4>

00002992 <prvAddCurrentTaskToDelayedList>:
    2992:	cf 92       	push	r12
    2994:	df 92       	push	r13
    2996:	ef 92       	push	r14
    2998:	ff 92       	push	r15
    299a:	6b 01       	movw	r12, r22
    299c:	7c 01       	movw	r14, r24
    299e:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    29a2:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    29a6:	62 83       	std	Z+2, r22	; 0x02
    29a8:	73 83       	std	Z+3, r23	; 0x03
    29aa:	84 83       	std	Z+4, r24	; 0x04
    29ac:	95 83       	std	Z+5, r25	; 0x05
    29ae:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    29b2:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    29b6:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    29ba:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    29be:	c8 16       	cp	r12, r24
    29c0:	d9 06       	cpc	r13, r25
    29c2:	ea 06       	cpc	r14, r26
    29c4:	fb 06       	cpc	r15, r27
    29c6:	68 f4       	brcc	.+26     	; 0x29e2 <prvAddCurrentTaskToDelayedList+0x50>
    29c8:	60 91 78 32 	lds	r22, 0x3278	; 0x803278 <pxCurrentTCB>
    29cc:	70 91 79 32 	lds	r23, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    29d0:	80 91 32 32 	lds	r24, 0x3232	; 0x803232 <pxOverflowDelayedTaskList>
    29d4:	90 91 33 32 	lds	r25, 0x3233	; 0x803233 <pxOverflowDelayedTaskList+0x1>
    29d8:	6e 5f       	subi	r22, 0xFE	; 254
    29da:	7f 4f       	sbci	r23, 0xFF	; 255
    29dc:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <vListInsert>
    29e0:	21 c0       	rjmp	.+66     	; 0x2a24 <prvAddCurrentTaskToDelayedList+0x92>
    29e2:	60 91 78 32 	lds	r22, 0x3278	; 0x803278 <pxCurrentTCB>
    29e6:	70 91 79 32 	lds	r23, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    29ea:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <pxDelayedTaskList>
    29ee:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    29f2:	6e 5f       	subi	r22, 0xFE	; 254
    29f4:	7f 4f       	sbci	r23, 0xFF	; 255
    29f6:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <vListInsert>
    29fa:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    29fe:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a02:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a06:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a0a:	c8 16       	cp	r12, r24
    2a0c:	d9 06       	cpc	r13, r25
    2a0e:	ea 06       	cpc	r14, r26
    2a10:	fb 06       	cpc	r15, r27
    2a12:	40 f4       	brcc	.+16     	; 0x2a24 <prvAddCurrentTaskToDelayedList+0x92>
    2a14:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2a18:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2a1c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2a20:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2a24:	ff 90       	pop	r15
    2a26:	ef 90       	pop	r14
    2a28:	df 90       	pop	r13
    2a2a:	cf 90       	pop	r12
    2a2c:	08 95       	ret

00002a2e <xTaskGenericCreate>:
    2a2e:	4f 92       	push	r4
    2a30:	5f 92       	push	r5
    2a32:	6f 92       	push	r6
    2a34:	7f 92       	push	r7
    2a36:	8f 92       	push	r8
    2a38:	9f 92       	push	r9
    2a3a:	af 92       	push	r10
    2a3c:	bf 92       	push	r11
    2a3e:	cf 92       	push	r12
    2a40:	df 92       	push	r13
    2a42:	ef 92       	push	r14
    2a44:	ff 92       	push	r15
    2a46:	0f 93       	push	r16
    2a48:	1f 93       	push	r17
    2a4a:	cf 93       	push	r28
    2a4c:	df 93       	push	r29
    2a4e:	5c 01       	movw	r10, r24
    2a50:	4b 01       	movw	r8, r22
    2a52:	3a 01       	movw	r6, r20
    2a54:	29 01       	movw	r4, r18
    2a56:	88 e2       	ldi	r24, 0x28	; 40
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    2a5e:	ec 01       	movw	r28, r24
    2a60:	89 2b       	or	r24, r25
    2a62:	09 f4       	brne	.+2      	; 0x2a66 <xTaskGenericCreate+0x38>
    2a64:	d4 c0       	rjmp	.+424    	; 0x2c0e <xTaskGenericCreate+0x1e0>
    2a66:	c1 14       	cp	r12, r1
    2a68:	d1 04       	cpc	r13, r1
    2a6a:	09 f0       	breq	.+2      	; 0x2a6e <xTaskGenericCreate+0x40>
    2a6c:	cc c0       	rjmp	.+408    	; 0x2c06 <xTaskGenericCreate+0x1d8>
    2a6e:	c3 01       	movw	r24, r6
    2a70:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    2a74:	8b 8f       	std	Y+27, r24	; 0x1b
    2a76:	9c 8f       	std	Y+28, r25	; 0x1c
    2a78:	00 97       	sbiw	r24, 0x00	; 0
    2a7a:	21 f4       	brne	.+8      	; 0x2a84 <xTaskGenericCreate+0x56>
    2a7c:	ce 01       	movw	r24, r28
    2a7e:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <vPortFree>
    2a82:	c5 c0       	rjmp	.+394    	; 0x2c0e <xTaskGenericCreate+0x1e0>
    2a84:	a3 01       	movw	r20, r6
    2a86:	61 e1       	ldi	r22, 0x11	; 17
    2a88:	70 e0       	ldi	r23, 0x00	; 0
    2a8a:	0e 94 63 27 	call	0x4ec6	; 0x4ec6 <memset>
    2a8e:	93 01       	movw	r18, r6
    2a90:	21 50       	subi	r18, 0x01	; 1
    2a92:	31 09       	sbc	r19, r1
    2a94:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a96:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a98:	3c 01       	movw	r6, r24
    2a9a:	62 0e       	add	r6, r18
    2a9c:	73 1e       	adc	r7, r19
    2a9e:	4a e0       	ldi	r20, 0x0A	; 10
    2aa0:	50 e0       	ldi	r21, 0x00	; 0
    2aa2:	b4 01       	movw	r22, r8
    2aa4:	ce 01       	movw	r24, r28
    2aa6:	4d 96       	adiw	r24, 0x1d	; 29
    2aa8:	0e 94 6a 27 	call	0x4ed4	; 0x4ed4 <strncpy>
    2aac:	1e a2       	std	Y+38, r1	; 0x26
    2aae:	10 2f       	mov	r17, r16
    2ab0:	04 30       	cpi	r16, 0x04	; 4
    2ab2:	08 f0       	brcs	.+2      	; 0x2ab6 <xTaskGenericCreate+0x88>
    2ab4:	13 e0       	ldi	r17, 0x03	; 3
    2ab6:	1a 8f       	std	Y+26, r17	; 0x1a
    2ab8:	1f a3       	std	Y+39, r17	; 0x27
    2aba:	6e 01       	movw	r12, r28
    2abc:	22 e0       	ldi	r18, 0x02	; 2
    2abe:	c2 0e       	add	r12, r18
    2ac0:	d1 1c       	adc	r13, r1
    2ac2:	c6 01       	movw	r24, r12
    2ac4:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <vListInitialiseItem>
    2ac8:	ce 01       	movw	r24, r28
    2aca:	0e 96       	adiw	r24, 0x0e	; 14
    2acc:	0e 94 cd 0f 	call	0x1f9a	; 0x1f9a <vListInitialiseItem>
    2ad0:	ca 87       	std	Y+10, r28	; 0x0a
    2ad2:	db 87       	std	Y+11, r29	; 0x0b
    2ad4:	84 e0       	ldi	r24, 0x04	; 4
    2ad6:	90 e0       	ldi	r25, 0x00	; 0
    2ad8:	a0 e0       	ldi	r26, 0x00	; 0
    2ada:	b0 e0       	ldi	r27, 0x00	; 0
    2adc:	81 1b       	sub	r24, r17
    2ade:	91 09       	sbc	r25, r1
    2ae0:	a1 09       	sbc	r26, r1
    2ae2:	b1 09       	sbc	r27, r1
    2ae4:	8e 87       	std	Y+14, r24	; 0x0e
    2ae6:	9f 87       	std	Y+15, r25	; 0x0f
    2ae8:	a8 8b       	std	Y+16, r26	; 0x10
    2aea:	b9 8b       	std	Y+17, r27	; 0x11
    2aec:	ce 8b       	std	Y+22, r28	; 0x16
    2aee:	df 8b       	std	Y+23, r29	; 0x17
    2af0:	a2 01       	movw	r20, r4
    2af2:	b5 01       	movw	r22, r10
    2af4:	c3 01       	movw	r24, r6
    2af6:	0e 94 69 10 	call	0x20d2	; 0x20d2 <pxPortInitialiseStack>
    2afa:	88 83       	st	Y, r24
    2afc:	99 83       	std	Y+1, r25	; 0x01
    2afe:	e1 14       	cp	r14, r1
    2b00:	f1 04       	cpc	r15, r1
    2b02:	19 f0       	breq	.+6      	; 0x2b0a <xTaskGenericCreate+0xdc>
    2b04:	f7 01       	movw	r30, r14
    2b06:	c0 83       	st	Z, r28
    2b08:	d1 83       	std	Z+1, r29	; 0x01
    2b0a:	0f b6       	in	r0, 0x3f	; 63
    2b0c:	f8 94       	cli
    2b0e:	0f 92       	push	r0
    2b10:	80 91 24 32 	lds	r24, 0x3224	; 0x803224 <uxCurrentNumberOfTasks>
    2b14:	8f 5f       	subi	r24, 0xFF	; 255
    2b16:	80 93 24 32 	sts	0x3224, r24	; 0x803224 <uxCurrentNumberOfTasks>
    2b1a:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    2b1e:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2b22:	89 2b       	or	r24, r25
    2b24:	89 f5       	brne	.+98     	; 0x2b88 <xTaskGenericCreate+0x15a>
    2b26:	c0 93 78 32 	sts	0x3278, r28	; 0x803278 <pxCurrentTCB>
    2b2a:	d0 93 79 32 	sts	0x3279, r29	; 0x803279 <pxCurrentTCB+0x1>
    2b2e:	80 91 24 32 	lds	r24, 0x3224	; 0x803224 <uxCurrentNumberOfTasks>
    2b32:	81 30       	cpi	r24, 0x01	; 1
    2b34:	c1 f5       	brne	.+112    	; 0x2ba6 <xTaskGenericCreate+0x178>
    2b36:	8c e4       	ldi	r24, 0x4C	; 76
    2b38:	92 e3       	ldi	r25, 0x32	; 50
    2b3a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b3e:	87 e5       	ldi	r24, 0x57	; 87
    2b40:	92 e3       	ldi	r25, 0x32	; 50
    2b42:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b46:	82 e6       	ldi	r24, 0x62	; 98
    2b48:	92 e3       	ldi	r25, 0x32	; 50
    2b4a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b4e:	8d e6       	ldi	r24, 0x6D	; 109
    2b50:	92 e3       	ldi	r25, 0x32	; 50
    2b52:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b56:	81 e4       	ldi	r24, 0x41	; 65
    2b58:	92 e3       	ldi	r25, 0x32	; 50
    2b5a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b5e:	86 e3       	ldi	r24, 0x36	; 54
    2b60:	92 e3       	ldi	r25, 0x32	; 50
    2b62:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b66:	87 e2       	ldi	r24, 0x27	; 39
    2b68:	92 e3       	ldi	r25, 0x32	; 50
    2b6a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vListInitialise>
    2b6e:	81 e4       	ldi	r24, 0x41	; 65
    2b70:	92 e3       	ldi	r25, 0x32	; 50
    2b72:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <pxDelayedTaskList>
    2b76:	90 93 35 32 	sts	0x3235, r25	; 0x803235 <pxDelayedTaskList+0x1>
    2b7a:	86 e3       	ldi	r24, 0x36	; 54
    2b7c:	92 e3       	ldi	r25, 0x32	; 50
    2b7e:	80 93 32 32 	sts	0x3232, r24	; 0x803232 <pxOverflowDelayedTaskList>
    2b82:	90 93 33 32 	sts	0x3233, r25	; 0x803233 <pxOverflowDelayedTaskList+0x1>
    2b86:	0f c0       	rjmp	.+30     	; 0x2ba6 <xTaskGenericCreate+0x178>
    2b88:	80 91 1d 32 	lds	r24, 0x321D	; 0x80321d <xSchedulerRunning>
    2b8c:	81 11       	cpse	r24, r1
    2b8e:	0b c0       	rjmp	.+22     	; 0x2ba6 <xTaskGenericCreate+0x178>
    2b90:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    2b94:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2b98:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b9a:	08 17       	cp	r16, r24
    2b9c:	20 f0       	brcs	.+8      	; 0x2ba6 <xTaskGenericCreate+0x178>
    2b9e:	c0 93 78 32 	sts	0x3278, r28	; 0x803278 <pxCurrentTCB>
    2ba2:	d0 93 79 32 	sts	0x3279, r29	; 0x803279 <pxCurrentTCB+0x1>
    2ba6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ba8:	90 91 1f 32 	lds	r25, 0x321F	; 0x80321f <uxTopUsedPriority>
    2bac:	98 17       	cp	r25, r24
    2bae:	10 f4       	brcc	.+4      	; 0x2bb4 <xTaskGenericCreate+0x186>
    2bb0:	80 93 1f 32 	sts	0x321F, r24	; 0x80321f <uxTopUsedPriority>
    2bb4:	90 91 18 32 	lds	r25, 0x3218	; 0x803218 <uxTaskNumber>
    2bb8:	9f 5f       	subi	r25, 0xFF	; 255
    2bba:	90 93 18 32 	sts	0x3218, r25	; 0x803218 <uxTaskNumber>
    2bbe:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    2bc2:	98 17       	cp	r25, r24
    2bc4:	10 f4       	brcc	.+4      	; 0x2bca <xTaskGenericCreate+0x19c>
    2bc6:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    2bca:	fb e0       	ldi	r31, 0x0B	; 11
    2bcc:	8f 9f       	mul	r24, r31
    2bce:	c0 01       	movw	r24, r0
    2bd0:	11 24       	eor	r1, r1
    2bd2:	b6 01       	movw	r22, r12
    2bd4:	84 5b       	subi	r24, 0xB4	; 180
    2bd6:	9d 4c       	sbci	r25, 0xCD	; 205
    2bd8:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
    2bdc:	0f 90       	pop	r0
    2bde:	0f be       	out	0x3f, r0	; 63
    2be0:	80 91 1d 32 	lds	r24, 0x321D	; 0x80321d <xSchedulerRunning>
    2be4:	88 23       	and	r24, r24
    2be6:	59 f0       	breq	.+22     	; 0x2bfe <xTaskGenericCreate+0x1d0>
    2be8:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    2bec:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2bf0:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bf2:	80 17       	cp	r24, r16
    2bf4:	30 f4       	brcc	.+12     	; 0x2c02 <xTaskGenericCreate+0x1d4>
    2bf6:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	09 c0       	rjmp	.+18     	; 0x2c10 <xTaskGenericCreate+0x1e2>
    2bfe:	81 e0       	ldi	r24, 0x01	; 1
    2c00:	07 c0       	rjmp	.+14     	; 0x2c10 <xTaskGenericCreate+0x1e2>
    2c02:	81 e0       	ldi	r24, 0x01	; 1
    2c04:	05 c0       	rjmp	.+10     	; 0x2c10 <xTaskGenericCreate+0x1e2>
    2c06:	cb 8e       	std	Y+27, r12	; 0x1b
    2c08:	dc 8e       	std	Y+28, r13	; 0x1c
    2c0a:	c6 01       	movw	r24, r12
    2c0c:	3b cf       	rjmp	.-394    	; 0x2a84 <xTaskGenericCreate+0x56>
    2c0e:	8f ef       	ldi	r24, 0xFF	; 255
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	1f 91       	pop	r17
    2c16:	0f 91       	pop	r16
    2c18:	ff 90       	pop	r15
    2c1a:	ef 90       	pop	r14
    2c1c:	df 90       	pop	r13
    2c1e:	cf 90       	pop	r12
    2c20:	bf 90       	pop	r11
    2c22:	af 90       	pop	r10
    2c24:	9f 90       	pop	r9
    2c26:	8f 90       	pop	r8
    2c28:	7f 90       	pop	r7
    2c2a:	6f 90       	pop	r6
    2c2c:	5f 90       	pop	r5
    2c2e:	4f 90       	pop	r4
    2c30:	08 95       	ret

00002c32 <uxTaskPriorityGet>:
    2c32:	0f b6       	in	r0, 0x3f	; 63
    2c34:	f8 94       	cli
    2c36:	0f 92       	push	r0
    2c38:	00 97       	sbiw	r24, 0x00	; 0
    2c3a:	21 f4       	brne	.+8      	; 0x2c44 <uxTaskPriorityGet+0x12>
    2c3c:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    2c40:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2c44:	0f 90       	pop	r0
    2c46:	0f be       	out	0x3f, r0	; 63
    2c48:	fc 01       	movw	r30, r24
    2c4a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c4c:	08 95       	ret

00002c4e <vTaskStartScheduler>:
    2c4e:	af 92       	push	r10
    2c50:	bf 92       	push	r11
    2c52:	cf 92       	push	r12
    2c54:	df 92       	push	r13
    2c56:	ef 92       	push	r14
    2c58:	ff 92       	push	r15
    2c5a:	0f 93       	push	r16
    2c5c:	a1 2c       	mov	r10, r1
    2c5e:	b1 2c       	mov	r11, r1
    2c60:	c1 2c       	mov	r12, r1
    2c62:	d1 2c       	mov	r13, r1
    2c64:	0f 2e       	mov	r0, r31
    2c66:	f5 e2       	ldi	r31, 0x25	; 37
    2c68:	ef 2e       	mov	r14, r31
    2c6a:	f2 e3       	ldi	r31, 0x32	; 50
    2c6c:	ff 2e       	mov	r15, r31
    2c6e:	f0 2d       	mov	r31, r0
    2c70:	00 e0       	ldi	r16, 0x00	; 0
    2c72:	20 e0       	ldi	r18, 0x00	; 0
    2c74:	30 e0       	ldi	r19, 0x00	; 0
    2c76:	44 e6       	ldi	r20, 0x64	; 100
    2c78:	50 e0       	ldi	r21, 0x00	; 0
    2c7a:	6e e5       	ldi	r22, 0x5E	; 94
    2c7c:	71 e2       	ldi	r23, 0x21	; 33
    2c7e:	81 ec       	ldi	r24, 0xC1	; 193
    2c80:	94 e1       	ldi	r25, 0x14	; 20
    2c82:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <xTaskGenericCreate>
    2c86:	81 30       	cpi	r24, 0x01	; 1
    2c88:	69 f4       	brne	.+26     	; 0x2ca4 <vTaskStartScheduler+0x56>
    2c8a:	f8 94       	cli
    2c8c:	80 93 1d 32 	sts	0x321D, r24	; 0x80321d <xSchedulerRunning>
    2c90:	10 92 20 32 	sts	0x3220, r1	; 0x803220 <xTickCount>
    2c94:	10 92 21 32 	sts	0x3221, r1	; 0x803221 <xTickCount+0x1>
    2c98:	10 92 22 32 	sts	0x3222, r1	; 0x803222 <xTickCount+0x2>
    2c9c:	10 92 23 32 	sts	0x3223, r1	; 0x803223 <xTickCount+0x3>
    2ca0:	0e 94 df 10 	call	0x21be	; 0x21be <xPortStartScheduler>
    2ca4:	0f 91       	pop	r16
    2ca6:	ff 90       	pop	r15
    2ca8:	ef 90       	pop	r14
    2caa:	df 90       	pop	r13
    2cac:	cf 90       	pop	r12
    2cae:	bf 90       	pop	r11
    2cb0:	af 90       	pop	r10
    2cb2:	08 95       	ret

00002cb4 <vTaskSuspendAll>:
    2cb4:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    2cb8:	8f 5f       	subi	r24, 0xFF	; 255
    2cba:	80 93 1c 32 	sts	0x321C, r24	; 0x80321c <uxSchedulerSuspended>
    2cbe:	08 95       	ret

00002cc0 <xTaskGetTickCount>:
    2cc0:	0f b6       	in	r0, 0x3f	; 63
    2cc2:	f8 94       	cli
    2cc4:	0f 92       	push	r0
    2cc6:	60 91 20 32 	lds	r22, 0x3220	; 0x803220 <xTickCount>
    2cca:	70 91 21 32 	lds	r23, 0x3221	; 0x803221 <xTickCount+0x1>
    2cce:	80 91 22 32 	lds	r24, 0x3222	; 0x803222 <xTickCount+0x2>
    2cd2:	90 91 23 32 	lds	r25, 0x3223	; 0x803223 <xTickCount+0x3>
    2cd6:	0f 90       	pop	r0
    2cd8:	0f be       	out	0x3f, r0	; 63
    2cda:	08 95       	ret

00002cdc <pcTaskGetTaskName>:
    2cdc:	00 97       	sbiw	r24, 0x00	; 0
    2cde:	21 f4       	brne	.+8      	; 0x2ce8 <pcTaskGetTaskName+0xc>
    2ce0:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    2ce4:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2ce8:	4d 96       	adiw	r24, 0x1d	; 29
    2cea:	08 95       	ret

00002cec <xTaskGetIdleTaskHandle>:
    2cec:	80 91 25 32 	lds	r24, 0x3225	; 0x803225 <xIdleTaskHandle>
    2cf0:	90 91 26 32 	lds	r25, 0x3226	; 0x803226 <xIdleTaskHandle+0x1>
    2cf4:	08 95       	ret

00002cf6 <vTaskIncrementTick>:
    2cf6:	ff 92       	push	r15
    2cf8:	0f 93       	push	r16
    2cfa:	1f 93       	push	r17
    2cfc:	cf 93       	push	r28
    2cfe:	df 93       	push	r29
    2d00:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    2d04:	81 11       	cpse	r24, r1
    2d06:	ed c0       	rjmp	.+474    	; 0x2ee2 <vTaskIncrementTick+0x1ec>
    2d08:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    2d0c:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    2d10:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    2d14:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    2d18:	01 96       	adiw	r24, 0x01	; 1
    2d1a:	a1 1d       	adc	r26, r1
    2d1c:	b1 1d       	adc	r27, r1
    2d1e:	80 93 20 32 	sts	0x3220, r24	; 0x803220 <xTickCount>
    2d22:	90 93 21 32 	sts	0x3221, r25	; 0x803221 <xTickCount+0x1>
    2d26:	a0 93 22 32 	sts	0x3222, r26	; 0x803222 <xTickCount+0x2>
    2d2a:	b0 93 23 32 	sts	0x3223, r27	; 0x803223 <xTickCount+0x3>
    2d2e:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    2d32:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    2d36:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    2d3a:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    2d3e:	89 2b       	or	r24, r25
    2d40:	8a 2b       	or	r24, r26
    2d42:	8b 2b       	or	r24, r27
    2d44:	f1 f5       	brne	.+124    	; 0x2dc2 <vTaskIncrementTick+0xcc>
    2d46:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <pxDelayedTaskList>
    2d4a:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2d4e:	20 91 32 32 	lds	r18, 0x3232	; 0x803232 <pxOverflowDelayedTaskList>
    2d52:	30 91 33 32 	lds	r19, 0x3233	; 0x803233 <pxOverflowDelayedTaskList+0x1>
    2d56:	20 93 34 32 	sts	0x3234, r18	; 0x803234 <pxDelayedTaskList>
    2d5a:	30 93 35 32 	sts	0x3235, r19	; 0x803235 <pxDelayedTaskList+0x1>
    2d5e:	80 93 32 32 	sts	0x3232, r24	; 0x803232 <pxOverflowDelayedTaskList>
    2d62:	90 93 33 32 	sts	0x3233, r25	; 0x803233 <pxOverflowDelayedTaskList+0x1>
    2d66:	80 91 19 32 	lds	r24, 0x3219	; 0x803219 <xNumOfOverflows>
    2d6a:	8f 5f       	subi	r24, 0xFF	; 255
    2d6c:	80 93 19 32 	sts	0x3219, r24	; 0x803219 <xNumOfOverflows>
    2d70:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2d74:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2d78:	80 81       	ld	r24, Z
    2d7a:	81 11       	cpse	r24, r1
    2d7c:	0c c0       	rjmp	.+24     	; 0x2d96 <vTaskIncrementTick+0xa0>
    2d7e:	8f ef       	ldi	r24, 0xFF	; 255
    2d80:	9f ef       	ldi	r25, 0xFF	; 255
    2d82:	dc 01       	movw	r26, r24
    2d84:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d88:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d8c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d90:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d94:	16 c0       	rjmp	.+44     	; 0x2dc2 <vTaskIncrementTick+0xcc>
    2d96:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2d9a:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2d9e:	07 80       	ldd	r0, Z+7	; 0x07
    2da0:	f0 85       	ldd	r31, Z+8	; 0x08
    2da2:	e0 2d       	mov	r30, r0
    2da4:	00 84       	ldd	r0, Z+8	; 0x08
    2da6:	f1 85       	ldd	r31, Z+9	; 0x09
    2da8:	e0 2d       	mov	r30, r0
    2daa:	82 81       	ldd	r24, Z+2	; 0x02
    2dac:	93 81       	ldd	r25, Z+3	; 0x03
    2dae:	a4 81       	ldd	r26, Z+4	; 0x04
    2db0:	b5 81       	ldd	r27, Z+5	; 0x05
    2db2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2db6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2dba:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2dbe:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2dc2:	40 91 20 32 	lds	r20, 0x3220	; 0x803220 <xTickCount>
    2dc6:	50 91 21 32 	lds	r21, 0x3221	; 0x803221 <xTickCount+0x1>
    2dca:	60 91 22 32 	lds	r22, 0x3222	; 0x803222 <xTickCount+0x2>
    2dce:	70 91 23 32 	lds	r23, 0x3223	; 0x803223 <xTickCount+0x3>
    2dd2:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2dd6:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2dda:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2dde:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2de2:	48 17       	cp	r20, r24
    2de4:	59 07       	cpc	r21, r25
    2de6:	6a 07       	cpc	r22, r26
    2de8:	7b 07       	cpc	r23, r27
    2dea:	08 f4       	brcc	.+2      	; 0x2dee <vTaskIncrementTick+0xf8>
    2dec:	7f c0       	rjmp	.+254    	; 0x2eec <vTaskIncrementTick+0x1f6>
    2dee:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2df2:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2df6:	80 81       	ld	r24, Z
    2df8:	88 23       	and	r24, r24
    2dfa:	f9 f0       	breq	.+62     	; 0x2e3a <vTaskIncrementTick+0x144>
    2dfc:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2e00:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2e04:	07 80       	ldd	r0, Z+7	; 0x07
    2e06:	f0 85       	ldd	r31, Z+8	; 0x08
    2e08:	e0 2d       	mov	r30, r0
    2e0a:	c0 85       	ldd	r28, Z+8	; 0x08
    2e0c:	d1 85       	ldd	r29, Z+9	; 0x09
    2e0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e10:	9b 81       	ldd	r25, Y+3	; 0x03
    2e12:	ac 81       	ldd	r26, Y+4	; 0x04
    2e14:	bd 81       	ldd	r27, Y+5	; 0x05
    2e16:	40 91 20 32 	lds	r20, 0x3220	; 0x803220 <xTickCount>
    2e1a:	50 91 21 32 	lds	r21, 0x3221	; 0x803221 <xTickCount+0x1>
    2e1e:	60 91 22 32 	lds	r22, 0x3222	; 0x803222 <xTickCount+0x2>
    2e22:	70 91 23 32 	lds	r23, 0x3223	; 0x803223 <xTickCount+0x3>
    2e26:	48 17       	cp	r20, r24
    2e28:	59 07       	cpc	r21, r25
    2e2a:	6a 07       	cpc	r22, r26
    2e2c:	7b 07       	cpc	r23, r27
    2e2e:	58 f1       	brcs	.+86     	; 0x2e86 <vTaskIncrementTick+0x190>
    2e30:	0f 2e       	mov	r0, r31
    2e32:	fb e0       	ldi	r31, 0x0B	; 11
    2e34:	ff 2e       	mov	r15, r31
    2e36:	f0 2d       	mov	r31, r0
    2e38:	2f c0       	rjmp	.+94     	; 0x2e98 <vTaskIncrementTick+0x1a2>
    2e3a:	8f ef       	ldi	r24, 0xFF	; 255
    2e3c:	9f ef       	ldi	r25, 0xFF	; 255
    2e3e:	dc 01       	movw	r26, r24
    2e40:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e44:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e48:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e4c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e50:	4d c0       	rjmp	.+154    	; 0x2eec <vTaskIncrementTick+0x1f6>
    2e52:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2e56:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2e5a:	07 80       	ldd	r0, Z+7	; 0x07
    2e5c:	f0 85       	ldd	r31, Z+8	; 0x08
    2e5e:	e0 2d       	mov	r30, r0
    2e60:	c0 85       	ldd	r28, Z+8	; 0x08
    2e62:	d1 85       	ldd	r29, Z+9	; 0x09
    2e64:	8a 81       	ldd	r24, Y+2	; 0x02
    2e66:	9b 81       	ldd	r25, Y+3	; 0x03
    2e68:	ac 81       	ldd	r26, Y+4	; 0x04
    2e6a:	bd 81       	ldd	r27, Y+5	; 0x05
    2e6c:	40 91 20 32 	lds	r20, 0x3220	; 0x803220 <xTickCount>
    2e70:	50 91 21 32 	lds	r21, 0x3221	; 0x803221 <xTickCount+0x1>
    2e74:	60 91 22 32 	lds	r22, 0x3222	; 0x803222 <xTickCount+0x2>
    2e78:	70 91 23 32 	lds	r23, 0x3223	; 0x803223 <xTickCount+0x3>
    2e7c:	48 17       	cp	r20, r24
    2e7e:	59 07       	cpc	r21, r25
    2e80:	6a 07       	cpc	r22, r26
    2e82:	7b 07       	cpc	r23, r27
    2e84:	48 f4       	brcc	.+18     	; 0x2e98 <vTaskIncrementTick+0x1a2>
    2e86:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e8a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e8e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e92:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e96:	2a c0       	rjmp	.+84     	; 0x2eec <vTaskIncrementTick+0x1f6>
    2e98:	8e 01       	movw	r16, r28
    2e9a:	0e 5f       	subi	r16, 0xFE	; 254
    2e9c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e9e:	c8 01       	movw	r24, r16
    2ea0:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
    2ea4:	88 8d       	ldd	r24, Y+24	; 0x18
    2ea6:	99 8d       	ldd	r25, Y+25	; 0x19
    2ea8:	89 2b       	or	r24, r25
    2eaa:	21 f0       	breq	.+8      	; 0x2eb4 <vTaskIncrementTick+0x1be>
    2eac:	ce 01       	movw	r24, r28
    2eae:	0e 96       	adiw	r24, 0x0e	; 14
    2eb0:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
    2eb4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2eb6:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    2eba:	98 17       	cp	r25, r24
    2ebc:	10 f4       	brcc	.+4      	; 0x2ec2 <vTaskIncrementTick+0x1cc>
    2ebe:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    2ec2:	f8 9e       	mul	r15, r24
    2ec4:	c0 01       	movw	r24, r0
    2ec6:	11 24       	eor	r1, r1
    2ec8:	b8 01       	movw	r22, r16
    2eca:	84 5b       	subi	r24, 0xB4	; 180
    2ecc:	9d 4c       	sbci	r25, 0xCD	; 205
    2ece:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
    2ed2:	e0 91 34 32 	lds	r30, 0x3234	; 0x803234 <pxDelayedTaskList>
    2ed6:	f0 91 35 32 	lds	r31, 0x3235	; 0x803235 <pxDelayedTaskList+0x1>
    2eda:	80 81       	ld	r24, Z
    2edc:	81 11       	cpse	r24, r1
    2ede:	b9 cf       	rjmp	.-142    	; 0x2e52 <vTaskIncrementTick+0x15c>
    2ee0:	ac cf       	rjmp	.-168    	; 0x2e3a <vTaskIncrementTick+0x144>
    2ee2:	80 91 1b 32 	lds	r24, 0x321B	; 0x80321b <uxMissedTicks>
    2ee6:	8f 5f       	subi	r24, 0xFF	; 255
    2ee8:	80 93 1b 32 	sts	0x321B, r24	; 0x80321b <uxMissedTicks>
    2eec:	df 91       	pop	r29
    2eee:	cf 91       	pop	r28
    2ef0:	1f 91       	pop	r17
    2ef2:	0f 91       	pop	r16
    2ef4:	ff 90       	pop	r15
    2ef6:	08 95       	ret

00002ef8 <xTaskResumeAll>:
    2ef8:	cf 92       	push	r12
    2efa:	df 92       	push	r13
    2efc:	ef 92       	push	r14
    2efe:	ff 92       	push	r15
    2f00:	0f 93       	push	r16
    2f02:	1f 93       	push	r17
    2f04:	cf 93       	push	r28
    2f06:	df 93       	push	r29
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	0f 92       	push	r0
    2f0e:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    2f12:	81 50       	subi	r24, 0x01	; 1
    2f14:	80 93 1c 32 	sts	0x321C, r24	; 0x80321c <uxSchedulerSuspended>
    2f18:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    2f1c:	81 11       	cpse	r24, r1
    2f1e:	60 c0       	rjmp	.+192    	; 0x2fe0 <xTaskResumeAll+0xe8>
    2f20:	80 91 24 32 	lds	r24, 0x3224	; 0x803224 <uxCurrentNumberOfTasks>
    2f24:	81 11       	cpse	r24, r1
    2f26:	2c c0       	rjmp	.+88     	; 0x2f80 <xTaskResumeAll+0x88>
    2f28:	5e c0       	rjmp	.+188    	; 0x2fe6 <xTaskResumeAll+0xee>
    2f2a:	d7 01       	movw	r26, r14
    2f2c:	17 96       	adiw	r26, 0x07	; 7
    2f2e:	ed 91       	ld	r30, X+
    2f30:	fc 91       	ld	r31, X
    2f32:	18 97       	sbiw	r26, 0x08	; 8
    2f34:	c0 85       	ldd	r28, Z+8	; 0x08
    2f36:	d1 85       	ldd	r29, Z+9	; 0x09
    2f38:	ce 01       	movw	r24, r28
    2f3a:	0e 96       	adiw	r24, 0x0e	; 14
    2f3c:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
    2f40:	8e 01       	movw	r16, r28
    2f42:	0e 5f       	subi	r16, 0xFE	; 254
    2f44:	1f 4f       	sbci	r17, 0xFF	; 255
    2f46:	c8 01       	movw	r24, r16
    2f48:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
    2f4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f4e:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    2f52:	98 17       	cp	r25, r24
    2f54:	10 f4       	brcc	.+4      	; 0x2f5a <xTaskResumeAll+0x62>
    2f56:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    2f5a:	d8 9e       	mul	r13, r24
    2f5c:	c0 01       	movw	r24, r0
    2f5e:	11 24       	eor	r1, r1
    2f60:	b8 01       	movw	r22, r16
    2f62:	84 5b       	subi	r24, 0xB4	; 180
    2f64:	9d 4c       	sbci	r25, 0xCD	; 205
    2f66:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
    2f6a:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    2f6e:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    2f72:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f74:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f76:	98 17       	cp	r25, r24
    2f78:	70 f0       	brcs	.+28     	; 0x2f96 <xTaskResumeAll+0x9e>
    2f7a:	cc 24       	eor	r12, r12
    2f7c:	c3 94       	inc	r12
    2f7e:	0b c0       	rjmp	.+22     	; 0x2f96 <xTaskResumeAll+0x9e>
    2f80:	c1 2c       	mov	r12, r1
    2f82:	0f 2e       	mov	r0, r31
    2f84:	f7 e2       	ldi	r31, 0x27	; 39
    2f86:	ef 2e       	mov	r14, r31
    2f88:	f2 e3       	ldi	r31, 0x32	; 50
    2f8a:	ff 2e       	mov	r15, r31
    2f8c:	f0 2d       	mov	r31, r0
    2f8e:	0f 2e       	mov	r0, r31
    2f90:	fb e0       	ldi	r31, 0x0B	; 11
    2f92:	df 2e       	mov	r13, r31
    2f94:	f0 2d       	mov	r31, r0
    2f96:	f7 01       	movw	r30, r14
    2f98:	80 81       	ld	r24, Z
    2f9a:	81 11       	cpse	r24, r1
    2f9c:	c6 cf       	rjmp	.-116    	; 0x2f2a <xTaskResumeAll+0x32>
    2f9e:	80 91 1b 32 	lds	r24, 0x321B	; 0x80321b <uxMissedTicks>
    2fa2:	88 23       	and	r24, r24
    2fa4:	81 f0       	breq	.+32     	; 0x2fc6 <xTaskResumeAll+0xce>
    2fa6:	80 91 1b 32 	lds	r24, 0x321B	; 0x80321b <uxMissedTicks>
    2faa:	88 23       	and	r24, r24
    2fac:	99 f0       	breq	.+38     	; 0x2fd4 <xTaskResumeAll+0xdc>
    2fae:	0e 94 7b 16 	call	0x2cf6	; 0x2cf6 <vTaskIncrementTick>
    2fb2:	80 91 1b 32 	lds	r24, 0x321B	; 0x80321b <uxMissedTicks>
    2fb6:	81 50       	subi	r24, 0x01	; 1
    2fb8:	80 93 1b 32 	sts	0x321B, r24	; 0x80321b <uxMissedTicks>
    2fbc:	80 91 1b 32 	lds	r24, 0x321B	; 0x80321b <uxMissedTicks>
    2fc0:	81 11       	cpse	r24, r1
    2fc2:	f5 cf       	rjmp	.-22     	; 0x2fae <xTaskResumeAll+0xb6>
    2fc4:	07 c0       	rjmp	.+14     	; 0x2fd4 <xTaskResumeAll+0xdc>
    2fc6:	f1 e0       	ldi	r31, 0x01	; 1
    2fc8:	cf 16       	cp	r12, r31
    2fca:	21 f0       	breq	.+8      	; 0x2fd4 <xTaskResumeAll+0xdc>
    2fcc:	80 91 1a 32 	lds	r24, 0x321A	; 0x80321a <xMissedYield>
    2fd0:	81 30       	cpi	r24, 0x01	; 1
    2fd2:	41 f4       	brne	.+16     	; 0x2fe4 <xTaskResumeAll+0xec>
    2fd4:	10 92 1a 32 	sts	0x321A, r1	; 0x80321a <xMissedYield>
    2fd8:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	03 c0       	rjmp	.+6      	; 0x2fe6 <xTaskResumeAll+0xee>
    2fe0:	80 e0       	ldi	r24, 0x00	; 0
    2fe2:	01 c0       	rjmp	.+2      	; 0x2fe6 <xTaskResumeAll+0xee>
    2fe4:	80 e0       	ldi	r24, 0x00	; 0
    2fe6:	0f 90       	pop	r0
    2fe8:	0f be       	out	0x3f, r0	; 63
    2fea:	df 91       	pop	r29
    2fec:	cf 91       	pop	r28
    2fee:	1f 91       	pop	r17
    2ff0:	0f 91       	pop	r16
    2ff2:	ff 90       	pop	r15
    2ff4:	ef 90       	pop	r14
    2ff6:	df 90       	pop	r13
    2ff8:	cf 90       	pop	r12
    2ffa:	08 95       	ret

00002ffc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2ffc:	cf 92       	push	r12
    2ffe:	df 92       	push	r13
    3000:	ef 92       	push	r14
    3002:	ff 92       	push	r15
    3004:	6b 01       	movw	r12, r22
    3006:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3008:	67 2b       	or	r22, r23
    300a:	68 2b       	or	r22, r24
    300c:	69 2b       	or	r22, r25
    300e:	e9 f0       	breq	.+58     	; 0x304a <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    3010:	0e 94 5a 16 	call	0x2cb4	; 0x2cb4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3014:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    3018:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    301c:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    3020:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    3024:	c8 0e       	add	r12, r24
    3026:	d9 1e       	adc	r13, r25
    3028:	ea 1e       	adc	r14, r26
    302a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    302c:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    3030:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    3034:	02 96       	adiw	r24, 0x02	; 2
    3036:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    303a:	c7 01       	movw	r24, r14
    303c:	b6 01       	movw	r22, r12
    303e:	0e 94 c9 14 	call	0x2992	; 0x2992 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3042:	0e 94 7c 17 	call	0x2ef8	; 0x2ef8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3046:	81 11       	cpse	r24, r1
    3048:	02 c0       	rjmp	.+4      	; 0x304e <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    304a:	0e 94 1d 11 	call	0x223a	; 0x223a <vPortYield>
		}
	}
    304e:	ff 90       	pop	r15
    3050:	ef 90       	pop	r14
    3052:	df 90       	pop	r13
    3054:	cf 90       	pop	r12
    3056:	08 95       	ret

00003058 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3058:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    305c:	81 11       	cpse	r24, r1
    305e:	0c c0       	rjmp	.+24     	; 0x3078 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3060:	e0 91 1e 32 	lds	r30, 0x321E	; 0x80321e <uxTopReadyPriority>
    3064:	4b e0       	ldi	r20, 0x0B	; 11
    3066:	e4 9f       	mul	r30, r20
    3068:	f0 01       	movw	r30, r0
    306a:	11 24       	eor	r1, r1
    306c:	e4 5b       	subi	r30, 0xB4	; 180
    306e:	fd 4c       	sbci	r31, 0xCD	; 205
    3070:	80 81       	ld	r24, Z
    3072:	88 23       	and	r24, r24
    3074:	29 f0       	breq	.+10     	; 0x3080 <vTaskSwitchContext+0x28>
    3076:	14 c0       	rjmp	.+40     	; 0x30a0 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3078:	81 e0       	ldi	r24, 0x01	; 1
    307a:	80 93 1a 32 	sts	0x321A, r24	; 0x80321a <xMissedYield>
    307e:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3080:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3082:	80 91 1e 32 	lds	r24, 0x321E	; 0x80321e <uxTopReadyPriority>
    3086:	81 50       	subi	r24, 0x01	; 1
    3088:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    308c:	e0 91 1e 32 	lds	r30, 0x321E	; 0x80321e <uxTopReadyPriority>
    3090:	9e 9f       	mul	r25, r30
    3092:	f0 01       	movw	r30, r0
    3094:	11 24       	eor	r1, r1
    3096:	e4 5b       	subi	r30, 0xB4	; 180
    3098:	fd 4c       	sbci	r31, 0xCD	; 205
    309a:	80 81       	ld	r24, Z
    309c:	88 23       	and	r24, r24
    309e:	89 f3       	breq	.-30     	; 0x3082 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    30a0:	80 91 1e 32 	lds	r24, 0x321E	; 0x80321e <uxTopReadyPriority>
    30a4:	28 2f       	mov	r18, r24
    30a6:	30 e0       	ldi	r19, 0x00	; 0
    30a8:	4b e0       	ldi	r20, 0x0B	; 11
    30aa:	84 9f       	mul	r24, r20
    30ac:	c0 01       	movw	r24, r0
    30ae:	11 24       	eor	r1, r1
    30b0:	dc 01       	movw	r26, r24
    30b2:	a4 5b       	subi	r26, 0xB4	; 180
    30b4:	bd 4c       	sbci	r27, 0xCD	; 205
    30b6:	11 96       	adiw	r26, 0x01	; 1
    30b8:	ed 91       	ld	r30, X+
    30ba:	fc 91       	ld	r31, X
    30bc:	12 97       	sbiw	r26, 0x02	; 2
    30be:	04 80       	ldd	r0, Z+4	; 0x04
    30c0:	f5 81       	ldd	r31, Z+5	; 0x05
    30c2:	e0 2d       	mov	r30, r0
    30c4:	11 96       	adiw	r26, 0x01	; 1
    30c6:	ed 93       	st	X+, r30
    30c8:	fc 93       	st	X, r31
    30ca:	12 97       	sbiw	r26, 0x02	; 2
    30cc:	81 5b       	subi	r24, 0xB1	; 177
    30ce:	9d 4c       	sbci	r25, 0xCD	; 205
    30d0:	e8 17       	cp	r30, r24
    30d2:	f9 07       	cpc	r31, r25
    30d4:	61 f4       	brne	.+24     	; 0x30ee <vTaskSwitchContext+0x96>
    30d6:	84 81       	ldd	r24, Z+4	; 0x04
    30d8:	95 81       	ldd	r25, Z+5	; 0x05
    30da:	4b e0       	ldi	r20, 0x0B	; 11
    30dc:	42 9f       	mul	r20, r18
    30de:	f0 01       	movw	r30, r0
    30e0:	43 9f       	mul	r20, r19
    30e2:	f0 0d       	add	r31, r0
    30e4:	11 24       	eor	r1, r1
    30e6:	e4 5b       	subi	r30, 0xB4	; 180
    30e8:	fd 4c       	sbci	r31, 0xCD	; 205
    30ea:	81 83       	std	Z+1, r24	; 0x01
    30ec:	92 83       	std	Z+2, r25	; 0x02
    30ee:	8b e0       	ldi	r24, 0x0B	; 11
    30f0:	82 9f       	mul	r24, r18
    30f2:	f0 01       	movw	r30, r0
    30f4:	83 9f       	mul	r24, r19
    30f6:	f0 0d       	add	r31, r0
    30f8:	11 24       	eor	r1, r1
    30fa:	e4 5b       	subi	r30, 0xB4	; 180
    30fc:	fd 4c       	sbci	r31, 0xCD	; 205
    30fe:	01 80       	ldd	r0, Z+1	; 0x01
    3100:	f2 81       	ldd	r31, Z+2	; 0x02
    3102:	e0 2d       	mov	r30, r0
    3104:	80 85       	ldd	r24, Z+8	; 0x08
    3106:	91 85       	ldd	r25, Z+9	; 0x09
    3108:	80 93 78 32 	sts	0x3278, r24	; 0x803278 <pxCurrentTCB>
    310c:	90 93 79 32 	sts	0x3279, r25	; 0x803279 <pxCurrentTCB+0x1>
    3110:	08 95       	ret

00003112 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3112:	cf 92       	push	r12
    3114:	df 92       	push	r13
    3116:	ef 92       	push	r14
    3118:	ff 92       	push	r15
    311a:	6a 01       	movw	r12, r20
    311c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    311e:	60 91 78 32 	lds	r22, 0x3278	; 0x803278 <pxCurrentTCB>
    3122:	70 91 79 32 	lds	r23, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    3126:	62 5f       	subi	r22, 0xF2	; 242
    3128:	7f 4f       	sbci	r23, 0xFF	; 255
    312a:	0e 94 f8 0f 	call	0x1ff0	; 0x1ff0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    312e:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    3132:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    3136:	02 96       	adiw	r24, 0x02	; 2
    3138:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    313c:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    3140:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    3144:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    3148:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    314c:	bc 01       	movw	r22, r24
    314e:	cd 01       	movw	r24, r26
    3150:	6c 0d       	add	r22, r12
    3152:	7d 1d       	adc	r23, r13
    3154:	8e 1d       	adc	r24, r14
    3156:	9f 1d       	adc	r25, r15
    3158:	0e 94 c9 14 	call	0x2992	; 0x2992 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    315c:	ff 90       	pop	r15
    315e:	ef 90       	pop	r14
    3160:	df 90       	pop	r13
    3162:	cf 90       	pop	r12
    3164:	08 95       	ret

00003166 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3166:	0f 93       	push	r16
    3168:	1f 93       	push	r17
    316a:	cf 93       	push	r28
    316c:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    316e:	dc 01       	movw	r26, r24
    3170:	17 96       	adiw	r26, 0x07	; 7
    3172:	ed 91       	ld	r30, X+
    3174:	fc 91       	ld	r31, X
    3176:	18 97       	sbiw	r26, 0x08	; 8
    3178:	c0 85       	ldd	r28, Z+8	; 0x08
    317a:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    317c:	8e 01       	movw	r16, r28
    317e:	02 5f       	subi	r16, 0xF2	; 242
    3180:	1f 4f       	sbci	r17, 0xFF	; 255
    3182:	c8 01       	movw	r24, r16
    3184:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3188:	80 91 1c 32 	lds	r24, 0x321C	; 0x80321c <uxSchedulerSuspended>
    318c:	81 11       	cpse	r24, r1
    318e:	16 c0       	rjmp	.+44     	; 0x31bc <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3190:	0c 50       	subi	r16, 0x0C	; 12
    3192:	11 09       	sbc	r17, r1
    3194:	c8 01       	movw	r24, r16
    3196:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    319a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    319c:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    31a0:	98 17       	cp	r25, r24
    31a2:	10 f4       	brcc	.+4      	; 0x31a8 <xTaskRemoveFromEventList+0x42>
    31a4:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    31a8:	bb e0       	ldi	r27, 0x0B	; 11
    31aa:	8b 9f       	mul	r24, r27
    31ac:	c0 01       	movw	r24, r0
    31ae:	11 24       	eor	r1, r1
    31b0:	b8 01       	movw	r22, r16
    31b2:	84 5b       	subi	r24, 0xB4	; 180
    31b4:	9d 4c       	sbci	r25, 0xCD	; 205
    31b6:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
    31ba:	05 c0       	rjmp	.+10     	; 0x31c6 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    31bc:	b8 01       	movw	r22, r16
    31be:	87 e2       	ldi	r24, 0x27	; 39
    31c0:	92 e3       	ldi	r25, 0x32	; 50
    31c2:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    31c6:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    31ca:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    31ce:	81 e0       	ldi	r24, 0x01	; 1
    31d0:	2a 8d       	ldd	r18, Y+26	; 0x1a
    31d2:	92 8d       	ldd	r25, Z+26	; 0x1a
    31d4:	29 17       	cp	r18, r25
    31d6:	08 f4       	brcc	.+2      	; 0x31da <xTaskRemoveFromEventList+0x74>
    31d8:	80 e0       	ldi	r24, 0x00	; 0
}
    31da:	df 91       	pop	r29
    31dc:	cf 91       	pop	r28
    31de:	1f 91       	pop	r17
    31e0:	0f 91       	pop	r16
    31e2:	08 95       	ret

000031e4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    31e4:	20 91 19 32 	lds	r18, 0x3219	; 0x803219 <xNumOfOverflows>
    31e8:	fc 01       	movw	r30, r24
    31ea:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    31ec:	40 91 20 32 	lds	r20, 0x3220	; 0x803220 <xTickCount>
    31f0:	50 91 21 32 	lds	r21, 0x3221	; 0x803221 <xTickCount+0x1>
    31f4:	60 91 22 32 	lds	r22, 0x3222	; 0x803222 <xTickCount+0x2>
    31f8:	70 91 23 32 	lds	r23, 0x3223	; 0x803223 <xTickCount+0x3>
    31fc:	41 83       	std	Z+1, r20	; 0x01
    31fe:	52 83       	std	Z+2, r21	; 0x02
    3200:	63 83       	std	Z+3, r22	; 0x03
    3202:	74 83       	std	Z+4, r23	; 0x04
    3204:	08 95       	ret

00003206 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3206:	8f 92       	push	r8
    3208:	9f 92       	push	r9
    320a:	af 92       	push	r10
    320c:	bf 92       	push	r11
    320e:	cf 92       	push	r12
    3210:	df 92       	push	r13
    3212:	ef 92       	push	r14
    3214:	ff 92       	push	r15
    3216:	0f 93       	push	r16
    3218:	1f 93       	push	r17
    321a:	cf 93       	push	r28
    321c:	df 93       	push	r29
    321e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3220:	0f b6       	in	r0, 0x3f	; 63
    3222:	f8 94       	cli
    3224:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3226:	80 91 19 32 	lds	r24, 0x3219	; 0x803219 <xNumOfOverflows>
    322a:	90 81       	ld	r25, Z
    322c:	98 17       	cp	r25, r24
    322e:	89 f0       	breq	.+34     	; 0x3252 <xTaskCheckForTimeOut+0x4c>
    3230:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    3234:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    3238:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    323c:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    3240:	01 81       	ldd	r16, Z+1	; 0x01
    3242:	12 81       	ldd	r17, Z+2	; 0x02
    3244:	23 81       	ldd	r18, Z+3	; 0x03
    3246:	34 81       	ldd	r19, Z+4	; 0x04
    3248:	80 17       	cp	r24, r16
    324a:	91 07       	cpc	r25, r17
    324c:	a2 07       	cpc	r26, r18
    324e:	b3 07       	cpc	r27, r19
    3250:	a8 f5       	brcc	.+106    	; 0x32bc <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3252:	80 91 20 32 	lds	r24, 0x3220	; 0x803220 <xTickCount>
    3256:	90 91 21 32 	lds	r25, 0x3221	; 0x803221 <xTickCount+0x1>
    325a:	a0 91 22 32 	lds	r26, 0x3222	; 0x803222 <xTickCount+0x2>
    325e:	b0 91 23 32 	lds	r27, 0x3223	; 0x803223 <xTickCount+0x3>
    3262:	c1 80       	ldd	r12, Z+1	; 0x01
    3264:	d2 80       	ldd	r13, Z+2	; 0x02
    3266:	e3 80       	ldd	r14, Z+3	; 0x03
    3268:	f4 80       	ldd	r15, Z+4	; 0x04
    326a:	eb 01       	movw	r28, r22
    326c:	08 81       	ld	r16, Y
    326e:	19 81       	ldd	r17, Y+1	; 0x01
    3270:	2a 81       	ldd	r18, Y+2	; 0x02
    3272:	3b 81       	ldd	r19, Y+3	; 0x03
    3274:	8c 19       	sub	r24, r12
    3276:	9d 09       	sbc	r25, r13
    3278:	ae 09       	sbc	r26, r14
    327a:	bf 09       	sbc	r27, r15
    327c:	80 17       	cp	r24, r16
    327e:	91 07       	cpc	r25, r17
    3280:	a2 07       	cpc	r26, r18
    3282:	b3 07       	cpc	r27, r19
    3284:	e8 f4       	brcc	.+58     	; 0x32c0 <xTaskCheckForTimeOut+0xba>
    3286:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3288:	80 90 20 32 	lds	r8, 0x3220	; 0x803220 <xTickCount>
    328c:	90 90 21 32 	lds	r9, 0x3221	; 0x803221 <xTickCount+0x1>
    3290:	a0 90 22 32 	lds	r10, 0x3222	; 0x803222 <xTickCount+0x2>
    3294:	b0 90 23 32 	lds	r11, 0x3223	; 0x803223 <xTickCount+0x3>
    3298:	b5 01       	movw	r22, r10
    329a:	a4 01       	movw	r20, r8
    329c:	4c 19       	sub	r20, r12
    329e:	5d 09       	sbc	r21, r13
    32a0:	6e 09       	sbc	r22, r14
    32a2:	7f 09       	sbc	r23, r15
    32a4:	04 1b       	sub	r16, r20
    32a6:	15 0b       	sbc	r17, r21
    32a8:	26 0b       	sbc	r18, r22
    32aa:	37 0b       	sbc	r19, r23
    32ac:	08 83       	st	Y, r16
    32ae:	19 83       	std	Y+1, r17	; 0x01
    32b0:	2a 83       	std	Y+2, r18	; 0x02
    32b2:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    32b4:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    32b8:	80 e0       	ldi	r24, 0x00	; 0
    32ba:	03 c0       	rjmp	.+6      	; 0x32c2 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	01 c0       	rjmp	.+2      	; 0x32c2 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    32c0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    32c2:	0f 90       	pop	r0
    32c4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    32c6:	df 91       	pop	r29
    32c8:	cf 91       	pop	r28
    32ca:	1f 91       	pop	r17
    32cc:	0f 91       	pop	r16
    32ce:	ff 90       	pop	r15
    32d0:	ef 90       	pop	r14
    32d2:	df 90       	pop	r13
    32d4:	cf 90       	pop	r12
    32d6:	bf 90       	pop	r11
    32d8:	af 90       	pop	r10
    32da:	9f 90       	pop	r9
    32dc:	8f 90       	pop	r8
    32de:	08 95       	ret

000032e0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	80 93 1a 32 	sts	0x321A, r24	; 0x80321a <xMissedYield>
    32e6:	08 95       	ret

000032e8 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    32e8:	00 97       	sbiw	r24, 0x00	; 0
    32ea:	21 f4       	brne	.+8      	; 0x32f4 <uxTaskGetStackHighWaterMark+0xc>
    32ec:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    32f0:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    32f4:	dc 01       	movw	r26, r24
    32f6:	5b 96       	adiw	r26, 0x1b	; 27
    32f8:	ed 91       	ld	r30, X+
    32fa:	fc 91       	ld	r31, X
    32fc:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32fe:	80 81       	ld	r24, Z
    3300:	81 31       	cpi	r24, 0x11	; 17
    3302:	41 f4       	brne	.+16     	; 0x3314 <uxTaskGetStackHighWaterMark+0x2c>
    3304:	31 96       	adiw	r30, 0x01	; 1
    3306:	80 e0       	ldi	r24, 0x00	; 0
    3308:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    330a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    330c:	21 91       	ld	r18, Z+
    330e:	21 31       	cpi	r18, 0x11	; 17
    3310:	e1 f3       	breq	.-8      	; 0x330a <uxTaskGetStackHighWaterMark+0x22>
    3312:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    3314:	80 e0       	ldi	r24, 0x00	; 0
    3316:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3318:	08 95       	ret

0000331a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    331a:	80 91 78 32 	lds	r24, 0x3278	; 0x803278 <pxCurrentTCB>
    331e:	90 91 79 32 	lds	r25, 0x3279	; 0x803279 <pxCurrentTCB+0x1>

		return xReturn;
	}
    3322:	08 95       	ret

00003324 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    3324:	0f 93       	push	r16
    3326:	1f 93       	push	r17
    3328:	cf 93       	push	r28
    332a:	df 93       	push	r29
    332c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    332e:	22 8d       	ldd	r18, Z+26	; 0x1a
    3330:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    3334:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    3338:	5a 96       	adiw	r26, 0x1a	; 26
    333a:	8c 91       	ld	r24, X
    333c:	28 17       	cp	r18, r24
    333e:	08 f0       	brcs	.+2      	; 0x3342 <vTaskPriorityInherit+0x1e>
    3340:	41 c0       	rjmp	.+130    	; 0x33c4 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    3342:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    3346:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    334a:	5a 96       	adiw	r26, 0x1a	; 26
    334c:	3c 91       	ld	r19, X
    334e:	84 e0       	ldi	r24, 0x04	; 4
    3350:	90 e0       	ldi	r25, 0x00	; 0
    3352:	a0 e0       	ldi	r26, 0x00	; 0
    3354:	b0 e0       	ldi	r27, 0x00	; 0
    3356:	83 1b       	sub	r24, r19
    3358:	91 09       	sbc	r25, r1
    335a:	a1 09       	sbc	r26, r1
    335c:	b1 09       	sbc	r27, r1
    335e:	86 87       	std	Z+14, r24	; 0x0e
    3360:	97 87       	std	Z+15, r25	; 0x0f
    3362:	a0 8b       	std	Z+16, r26	; 0x10
    3364:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3366:	8b e0       	ldi	r24, 0x0B	; 11
    3368:	28 9f       	mul	r18, r24
    336a:	90 01       	movw	r18, r0
    336c:	11 24       	eor	r1, r1
    336e:	24 5b       	subi	r18, 0xB4	; 180
    3370:	3d 4c       	sbci	r19, 0xCD	; 205
    3372:	84 85       	ldd	r24, Z+12	; 0x0c
    3374:	95 85       	ldd	r25, Z+13	; 0x0d
    3376:	82 17       	cp	r24, r18
    3378:	93 07       	cpc	r25, r19
    337a:	e9 f4       	brne	.+58     	; 0x33b6 <vTaskPriorityInherit+0x92>
    337c:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    337e:	ef 01       	movw	r28, r30
    3380:	22 96       	adiw	r28, 0x02	; 2
    3382:	ce 01       	movw	r24, r28
    3384:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3388:	e0 91 78 32 	lds	r30, 0x3278	; 0x803278 <pxCurrentTCB>
    338c:	f0 91 79 32 	lds	r31, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    3390:	82 8d       	ldd	r24, Z+26	; 0x1a
    3392:	f8 01       	movw	r30, r16
    3394:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    3396:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    339a:	98 17       	cp	r25, r24
    339c:	10 f4       	brcc	.+4      	; 0x33a2 <vTaskPriorityInherit+0x7e>
    339e:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    33a2:	fb e0       	ldi	r31, 0x0B	; 11
    33a4:	8f 9f       	mul	r24, r31
    33a6:	c0 01       	movw	r24, r0
    33a8:	11 24       	eor	r1, r1
    33aa:	be 01       	movw	r22, r28
    33ac:	84 5b       	subi	r24, 0xB4	; 180
    33ae:	9d 4c       	sbci	r25, 0xCD	; 205
    33b0:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
    33b4:	07 c0       	rjmp	.+14     	; 0x33c4 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    33b6:	a0 91 78 32 	lds	r26, 0x3278	; 0x803278 <pxCurrentTCB>
    33ba:	b0 91 79 32 	lds	r27, 0x3279	; 0x803279 <pxCurrentTCB+0x1>
    33be:	5a 96       	adiw	r26, 0x1a	; 26
    33c0:	8c 91       	ld	r24, X
    33c2:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    33c4:	df 91       	pop	r29
    33c6:	cf 91       	pop	r28
    33c8:	1f 91       	pop	r17
    33ca:	0f 91       	pop	r16
    33cc:	08 95       	ret

000033ce <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    33ce:	0f 93       	push	r16
    33d0:	1f 93       	push	r17
    33d2:	cf 93       	push	r28
    33d4:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    33d6:	00 97       	sbiw	r24, 0x00	; 0
    33d8:	49 f1       	breq	.+82     	; 0x342c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    33da:	fc 01       	movw	r30, r24
    33dc:	32 8d       	ldd	r19, Z+26	; 0x1a
    33de:	27 a1       	ldd	r18, Z+39	; 0x27
    33e0:	32 17       	cp	r19, r18
    33e2:	21 f1       	breq	.+72     	; 0x342c <vTaskPriorityDisinherit+0x5e>
    33e4:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    33e6:	8c 01       	movw	r16, r24
    33e8:	0e 5f       	subi	r16, 0xFE	; 254
    33ea:	1f 4f       	sbci	r17, 0xFF	; 255
    33ec:	c8 01       	movw	r24, r16
    33ee:	0e 94 43 10 	call	0x2086	; 0x2086 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    33f2:	8f a1       	ldd	r24, Y+39	; 0x27
    33f4:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    33f6:	44 e0       	ldi	r20, 0x04	; 4
    33f8:	50 e0       	ldi	r21, 0x00	; 0
    33fa:	60 e0       	ldi	r22, 0x00	; 0
    33fc:	70 e0       	ldi	r23, 0x00	; 0
    33fe:	48 1b       	sub	r20, r24
    3400:	51 09       	sbc	r21, r1
    3402:	61 09       	sbc	r22, r1
    3404:	71 09       	sbc	r23, r1
    3406:	4e 87       	std	Y+14, r20	; 0x0e
    3408:	5f 87       	std	Y+15, r21	; 0x0f
    340a:	68 8b       	std	Y+16, r22	; 0x10
    340c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    340e:	90 91 1e 32 	lds	r25, 0x321E	; 0x80321e <uxTopReadyPriority>
    3412:	98 17       	cp	r25, r24
    3414:	10 f4       	brcc	.+4      	; 0x341a <vTaskPriorityDisinherit+0x4c>
    3416:	80 93 1e 32 	sts	0x321E, r24	; 0x80321e <uxTopReadyPriority>
    341a:	fb e0       	ldi	r31, 0x0B	; 11
    341c:	8f 9f       	mul	r24, r31
    341e:	c0 01       	movw	r24, r0
    3420:	11 24       	eor	r1, r1
    3422:	b8 01       	movw	r22, r16
    3424:	84 5b       	subi	r24, 0xB4	; 180
    3426:	9d 4c       	sbci	r25, 0xCD	; 205
    3428:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <vListInsertEnd>
			}
		}
	}
    342c:	df 91       	pop	r29
    342e:	cf 91       	pop	r28
    3430:	1f 91       	pop	r17
    3432:	0f 91       	pop	r16
    3434:	08 95       	ret

00003436 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    3436:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    3438:	e8 81       	ld	r30, Y
    343a:	f9 81       	ldd	r31, Y+1	; 0x01
    343c:	01 90       	ld	r0, Z+
    343e:	f0 81       	ld	r31, Z
    3440:	e0 2d       	mov	r30, r0
    3442:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    3444:	1a 82       	std	Y+2, r1	; 0x02
    3446:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    3448:	6f ef       	ldi	r22, 0xFF	; 255
    344a:	7f ef       	ldi	r23, 0xFF	; 255
    344c:	cb 01       	movw	r24, r22
    344e:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <vTaskDelay>
    3452:	fa cf       	rjmp	.-12     	; 0x3448 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00003454 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    3454:	fc 01       	movw	r30, r24
    3456:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3458:	65 87       	std	Z+13, r22	; 0x0d
    345a:	08 95       	ret

0000345c <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    345c:	4f 92       	push	r4
    345e:	5f 92       	push	r5
    3460:	6f 92       	push	r6
    3462:	7f 92       	push	r7
    3464:	8f 92       	push	r8
    3466:	9f 92       	push	r9
    3468:	af 92       	push	r10
    346a:	bf 92       	push	r11
    346c:	cf 92       	push	r12
    346e:	df 92       	push	r13
    3470:	ef 92       	push	r14
    3472:	ff 92       	push	r15
    3474:	0f 93       	push	r16
    3476:	1f 93       	push	r17
    3478:	cf 93       	push	r28
    347a:	df 93       	push	r29
    347c:	cd b7       	in	r28, 0x3d	; 61
    347e:	de b7       	in	r29, 0x3e	; 62
    3480:	2a 97       	sbiw	r28, 0x0a	; 10
    3482:	cd bf       	out	0x3d, r28	; 61
    3484:	de bf       	out	0x3e, r29	; 62
    3486:	4c 01       	movw	r8, r24
    3488:	29 01       	movw	r4, r18
    348a:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    348c:	87 e6       	ldi	r24, 0x67	; 103
    348e:	91 e2       	ldi	r25, 0x21	; 33
    3490:	f4 01       	movw	r30, r8
    3492:	80 83       	st	Z, r24
    3494:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3496:	fb 01       	movw	r30, r22
    3498:	80 81       	ld	r24, Z
    349a:	88 23       	and	r24, r24
    349c:	69 f0       	breq	.+26     	; 0x34b8 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    349e:	de 01       	movw	r26, r28
    34a0:	11 96       	adiw	r26, 0x01	; 1
    34a2:	31 96       	adiw	r30, 0x01	; 1
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	02 c0       	rjmp	.+4      	; 0x34ac <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    34a8:	99 30       	cpi	r25, 0x09	; 9
    34aa:	39 f0       	breq	.+14     	; 0x34ba <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    34ac:	9f 5f       	subi	r25, 0xFF	; 255
    34ae:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    34b0:	81 91       	ld	r24, Z+
    34b2:	81 11       	cpse	r24, r1
    34b4:	f9 cf       	rjmp	.-14     	; 0x34a8 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    34b6:	01 c0       	rjmp	.+2      	; 0x34ba <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    34b8:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    34ba:	e1 e0       	ldi	r30, 0x01	; 1
    34bc:	f0 e0       	ldi	r31, 0x00	; 0
    34be:	ec 0f       	add	r30, r28
    34c0:	fd 1f       	adc	r31, r29
    34c2:	e9 0f       	add	r30, r25
    34c4:	f1 1d       	adc	r31, r1
    34c6:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    34c8:	74 01       	movw	r14, r8
    34ca:	f2 e0       	ldi	r31, 0x02	; 2
    34cc:	ef 0e       	add	r14, r31
    34ce:	f1 1c       	adc	r15, r1
    34d0:	a1 2c       	mov	r10, r1
    34d2:	b1 2c       	mov	r11, r1
    34d4:	c1 2c       	mov	r12, r1
    34d6:	d1 2c       	mov	r13, r1
    34d8:	04 2f       	mov	r16, r20
    34da:	94 01       	movw	r18, r8
    34dc:	a2 01       	movw	r20, r4
    34de:	be 01       	movw	r22, r28
    34e0:	6f 5f       	subi	r22, 0xFF	; 255
    34e2:	7f 4f       	sbci	r23, 0xFF	; 255
    34e4:	84 e3       	ldi	r24, 0x34	; 52
    34e6:	93 e0       	ldi	r25, 0x03	; 3
    34e8:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    34ec:	f4 01       	movw	r30, r8
    34ee:	66 82       	std	Z+6, r6	; 0x06
    34f0:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    34f2:	40 86       	std	Z+8, r4	; 0x08
    34f4:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    34f6:	20 91 7a 32 	lds	r18, 0x327A	; 0x80327a <last_created_task_pointer>
    34fa:	30 91 7b 32 	lds	r19, 0x327B	; 0x80327b <last_created_task_pointer+0x1>
    34fe:	24 83       	std	Z+4, r18	; 0x04
    3500:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3502:	80 92 7a 32 	sts	0x327A, r8	; 0x80327a <last_created_task_pointer>
    3506:	90 92 7b 32 	sts	0x327B, r9	; 0x80327b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    350a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    350c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    350e:	40 90 dc 32 	lds	r4, 0x32DC	; 0x8032dc <portStackTopForTask>
    3512:	50 90 dd 32 	lds	r5, 0x32DD	; 0x8032dd <portStackTopForTask+0x1>
    3516:	ff ef       	ldi	r31, 0xFF	; 255
    3518:	4f 1a       	sub	r4, r31
    351a:	5f 0a       	sbc	r5, r31
    351c:	40 92 dc 32 	sts	0x32DC, r4	; 0x8032dc <portStackTopForTask>
    3520:	50 92 dd 32 	sts	0x32DD, r5	; 0x8032dd <portStackTopForTask+0x1>
    3524:	f4 01       	movw	r30, r8
    3526:	42 86       	std	Z+10, r4	; 0x0a
    3528:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    352a:	16 86       	std	Z+14, r1	; 0x0e
    352c:	17 86       	std	Z+15, r1	; 0x0f
    352e:	10 8a       	std	Z+16, r1	; 0x10
    3530:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    3532:	61 14       	cp	r6, r1
    3534:	71 04       	cpc	r7, r1
    3536:	09 f4       	brne	.+2      	; 0x353a <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3538:	44 c0       	rjmp	.+136    	; 0x35c2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    353a:	81 30       	cpi	r24, 0x01	; 1
    353c:	79 f5       	brne	.+94     	; 0x359c <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    353e:	6a e0       	ldi	r22, 0x0A	; 10
    3540:	c3 01       	movw	r24, r6
    3542:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3546:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3548:	65 eb       	ldi	r22, 0xB5	; 181
    354a:	75 e0       	ldi	r23, 0x05	; 5
    354c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3550:	be 01       	movw	r22, r28
    3552:	6f 5f       	subi	r22, 0xFF	; 255
    3554:	7f 4f       	sbci	r23, 0xFF	; 255
    3556:	c7 01       	movw	r24, r14
    3558:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    355c:	6a e0       	ldi	r22, 0x0A	; 10
    355e:	c7 01       	movw	r24, r14
    3560:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3564:	7c 01       	movw	r14, r24
    3566:	6c ea       	ldi	r22, 0xAC	; 172
    3568:	75 e0       	ldi	r23, 0x05	; 5
    356a:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    356e:	6a e0       	ldi	r22, 0x0A	; 10
    3570:	c7 01       	movw	r24, r14
    3572:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3576:	7c 01       	movw	r14, r24
    3578:	6e e9       	ldi	r22, 0x9E	; 158
    357a:	75 e0       	ldi	r23, 0x05	; 5
    357c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3580:	63 e0       	ldi	r22, 0x03	; 3
    3582:	c7 01       	movw	r24, r14
    3584:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3588:	b2 01       	movw	r22, r4
    358a:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    358e:	62 e0       	ldi	r22, 0x02	; 2
    3590:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3594:	66 e0       	ldi	r22, 0x06	; 6
    3596:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    359a:	13 c0       	rjmp	.+38     	; 0x35c2 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    359c:	6a e0       	ldi	r22, 0x0A	; 10
    359e:	c3 01       	movw	r24, r6
    35a0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    35a4:	4c 01       	movw	r8, r24
    35a6:	69 e8       	ldi	r22, 0x89	; 137
    35a8:	75 e0       	ldi	r23, 0x05	; 5
    35aa:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    35ae:	be 01       	movw	r22, r28
    35b0:	6f 5f       	subi	r22, 0xFF	; 255
    35b2:	7f 4f       	sbci	r23, 0xFF	; 255
    35b4:	c4 01       	movw	r24, r8
    35b6:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    35ba:	66 e0       	ldi	r22, 0x06	; 6
    35bc:	c4 01       	movw	r24, r8
    35be:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    35c2:	2a 96       	adiw	r28, 0x0a	; 10
    35c4:	cd bf       	out	0x3d, r28	; 61
    35c6:	de bf       	out	0x3e, r29	; 62
    35c8:	df 91       	pop	r29
    35ca:	cf 91       	pop	r28
    35cc:	1f 91       	pop	r17
    35ce:	0f 91       	pop	r16
    35d0:	ff 90       	pop	r15
    35d2:	ef 90       	pop	r14
    35d4:	df 90       	pop	r13
    35d6:	cf 90       	pop	r12
    35d8:	bf 90       	pop	r11
    35da:	af 90       	pop	r10
    35dc:	9f 90       	pop	r9
    35de:	8f 90       	pop	r8
    35e0:	7f 90       	pop	r7
    35e2:	6f 90       	pop	r6
    35e4:	5f 90       	pop	r5
    35e6:	4f 90       	pop	r4
    35e8:	08 95       	ret

000035ea <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    35ea:	cf 92       	push	r12
    35ec:	df 92       	push	r13
    35ee:	ef 92       	push	r14
    35f0:	ff 92       	push	r15
    35f2:	0f 93       	push	r16
    35f4:	1f 93       	push	r17
    35f6:	cf 93       	push	r28
    35f8:	df 93       	push	r29
    35fa:	ec 01       	movw	r28, r24
    35fc:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    35fe:	8a 81       	ldd	r24, Y+2	; 0x02
    3600:	9b 81       	ldd	r25, Y+3	; 0x03
    3602:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <pcTaskGetTaskName>
    3606:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3608:	6a e0       	ldi	r22, 0x0A	; 10
    360a:	c7 01       	movw	r24, r14
    360c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3610:	8c 01       	movw	r16, r24
    3612:	68 ec       	ldi	r22, 0xC8	; 200
    3614:	75 e0       	ldi	r23, 0x05	; 5
    3616:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    361a:	6a e0       	ldi	r22, 0x0A	; 10
    361c:	c8 01       	movw	r24, r16
    361e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3622:	8c 01       	movw	r16, r24
    3624:	61 ec       	ldi	r22, 0xC1	; 193
    3626:	75 e0       	ldi	r23, 0x05	; 5
    3628:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    362c:	b6 01       	movw	r22, r12
    362e:	c8 01       	movw	r24, r16
    3630:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    3634:	6a e0       	ldi	r22, 0x0A	; 10
    3636:	c8 01       	movw	r24, r16
    3638:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    363c:	8c 01       	movw	r16, r24
    363e:	6b eb       	ldi	r22, 0xBB	; 187
    3640:	75 e0       	ldi	r23, 0x05	; 5
    3642:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3646:	66 e0       	ldi	r22, 0x06	; 6
    3648:	c8 01       	movw	r24, r16
    364a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    364e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3650:	9b 85       	ldd	r25, Y+11	; 0x0b
    3652:	e8 85       	ldd	r30, Y+8	; 0x08
    3654:	f9 85       	ldd	r31, Y+9	; 0x09
    3656:	01 e1       	ldi	r16, 0x11	; 17
    3658:	21 e0       	ldi	r18, 0x01	; 1
    365a:	a7 01       	movw	r20, r14
    365c:	bc 01       	movw	r22, r24
    365e:	8e 1b       	sub	r24, r30
    3660:	9f 0b       	sbc	r25, r31
    3662:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3666:	8c 81       	ldd	r24, Y+4	; 0x04
    3668:	9d 81       	ldd	r25, Y+5	; 0x05
    366a:	00 97       	sbiw	r24, 0x00	; 0
    366c:	19 f0       	breq	.+6      	; 0x3674 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    366e:	b7 01       	movw	r22, r14
    3670:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    3674:	df 91       	pop	r29
    3676:	cf 91       	pop	r28
    3678:	1f 91       	pop	r17
    367a:	0f 91       	pop	r16
    367c:	ff 90       	pop	r15
    367e:	ef 90       	pop	r14
    3680:	df 90       	pop	r13
    3682:	cf 90       	pop	r12
    3684:	08 95       	ret

00003686 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3686:	0f 93       	push	r16
    3688:	1f 93       	push	r17
    368a:	cf 93       	push	r28
    368c:	df 93       	push	r29
    368e:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    3690:	80 91 7a 32 	lds	r24, 0x327A	; 0x80327a <last_created_task_pointer>
    3694:	90 91 7b 32 	lds	r25, 0x327B	; 0x80327b <last_created_task_pointer+0x1>
    3698:	00 97       	sbiw	r24, 0x00	; 0
    369a:	19 f0       	breq	.+6      	; 0x36a2 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    369c:	be 01       	movw	r22, r28
    369e:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    36a2:	6a e0       	ldi	r22, 0x0A	; 10
    36a4:	ce 01       	movw	r24, r28
    36a6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    36aa:	8c 01       	movw	r16, r24
    36ac:	6e ed       	ldi	r22, 0xDE	; 222
    36ae:	75 e0       	ldi	r23, 0x05	; 5
    36b0:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    36b4:	6a e0       	ldi	r22, 0x0A	; 10
    36b6:	c8 01       	movw	r24, r16
    36b8:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    36bc:	8c 01       	movw	r16, r24
    36be:	63 ed       	ldi	r22, 0xD3	; 211
    36c0:	75 e0       	ldi	r23, 0x05	; 5
    36c2:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    36c6:	6a e0       	ldi	r22, 0x0A	; 10
    36c8:	c8 01       	movw	r24, r16
    36ca:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    36ce:	8c 01       	movw	r16, r24
    36d0:	6d ec       	ldi	r22, 0xCD	; 205
    36d2:	75 e0       	ldi	r23, 0x05	; 5
    36d4:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    36d8:	66 e0       	ldi	r22, 0x06	; 6
    36da:	c8 01       	movw	r24, r16
    36dc:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    36e0:	80 91 dc 32 	lds	r24, 0x32DC	; 0x8032dc <portStackTopForTask>
    36e4:	90 91 dd 32 	lds	r25, 0x32DD	; 0x8032dd <portStackTopForTask+0x1>
    36e8:	bc 01       	movw	r22, r24
    36ea:	6f 5f       	subi	r22, 0xFF	; 255
    36ec:	7f 4f       	sbci	r23, 0xFF	; 255
    36ee:	01 e1       	ldi	r16, 0x11	; 17
    36f0:	21 e0       	ldi	r18, 0x01	; 1
    36f2:	ae 01       	movw	r20, r28
    36f4:	83 56       	subi	r24, 0x63	; 99
    36f6:	91 09       	sbc	r25, r1
    36f8:	0e 94 f7 1d 	call	0x3bee	; 0x3bee <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    36fc:	df 91       	pop	r29
    36fe:	cf 91       	pop	r28
    3700:	1f 91       	pop	r17
    3702:	0f 91       	pop	r16
    3704:	08 95       	ret

00003706 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3706:	8f 92       	push	r8
    3708:	9f 92       	push	r9
    370a:	af 92       	push	r10
    370c:	bf 92       	push	r11
    370e:	cf 92       	push	r12
    3710:	df 92       	push	r13
    3712:	ef 92       	push	r14
    3714:	ff 92       	push	r15
    3716:	0f 93       	push	r16
    3718:	1f 93       	push	r17
    371a:	cf 93       	push	r28
    371c:	df 93       	push	r29
    371e:	ec 01       	movw	r28, r24
    3720:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3722:	8a 81       	ldd	r24, Y+2	; 0x02
    3724:	9b 81       	ldd	r25, Y+3	; 0x03
    3726:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <pcTaskGetTaskName>
    372a:	bc 01       	movw	r22, r24
    372c:	c8 01       	movw	r24, r16
    372e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    3732:	d8 01       	movw	r26, r16
    3734:	ed 91       	ld	r30, X+
    3736:	fc 91       	ld	r31, X
    3738:	02 80       	ldd	r0, Z+2	; 0x02
    373a:	f3 81       	ldd	r31, Z+3	; 0x03
    373c:	e0 2d       	mov	r30, r0
    373e:	69 e0       	ldi	r22, 0x09	; 9
    3740:	c8 01       	movw	r24, r16
    3742:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    3744:	8a 81       	ldd	r24, Y+2	; 0x02
    3746:	9b 81       	ldd	r25, Y+3	; 0x03
    3748:	0e 94 6e 16 	call	0x2cdc	; 0x2cdc <pcTaskGetTaskName>
    374c:	fc 01       	movw	r30, r24
    374e:	01 90       	ld	r0, Z+
    3750:	00 20       	and	r0, r0
    3752:	e9 f7       	brne	.-6      	; 0x374e <_ZN8frt_task12print_statusER8emstream+0x48>
    3754:	31 97       	sbiw	r30, 0x01	; 1
    3756:	e8 1b       	sub	r30, r24
    3758:	f9 0b       	sbc	r31, r25
    375a:	38 97       	sbiw	r30, 0x08	; 8
    375c:	48 f4       	brcc	.+18     	; 0x3770 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    375e:	d8 01       	movw	r26, r16
    3760:	ed 91       	ld	r30, X+
    3762:	fc 91       	ld	r31, X
    3764:	02 80       	ldd	r0, Z+2	; 0x02
    3766:	f3 81       	ldd	r31, Z+3	; 0x03
    3768:	e0 2d       	mov	r30, r0
    376a:	69 e0       	ldi	r22, 0x09	; 9
    376c:	c8 01       	movw	r24, r16
    376e:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    3770:	ce 84       	ldd	r12, Y+14	; 0x0e
    3772:	df 84       	ldd	r13, Y+15	; 0x0f
    3774:	e8 88       	ldd	r14, Y+16	; 0x10
    3776:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3778:	a8 84       	ldd	r10, Y+8	; 0x08
    377a:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    377c:	8a 81       	ldd	r24, Y+2	; 0x02
    377e:	9b 81       	ldd	r25, Y+3	; 0x03
    3780:	0e 94 74 19 	call	0x32e8	; 0x32e8 <uxTaskGetStackHighWaterMark>
    3784:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3786:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3788:	8a 81       	ldd	r24, Y+2	; 0x02
    378a:	9b 81       	ldd	r25, Y+3	; 0x03
    378c:	0e 94 19 16 	call	0x2c32	; 0x2c32 <uxTaskPriorityGet>
    3790:	68 2f       	mov	r22, r24
    3792:	c8 01       	movw	r24, r16
    3794:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    3798:	6a e0       	ldi	r22, 0x0A	; 10
    379a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    379e:	ec 01       	movw	r28, r24
    37a0:	63 e5       	ldi	r22, 0x53	; 83
    37a2:	76 e0       	ldi	r23, 0x06	; 6
    37a4:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
			<< get_state ()
    37a8:	68 2d       	mov	r22, r8
    37aa:	ce 01       	movw	r24, r28
    37ac:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    37b0:	6a e0       	ldi	r22, 0x0A	; 10
    37b2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    37b6:	ec 01       	movw	r28, r24
    37b8:	61 e5       	ldi	r22, 0x51	; 81
    37ba:	76 e0       	ldi	r23, 0x06	; 6
    37bc:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    37c0:	69 2d       	mov	r22, r9
    37c2:	ce 01       	movw	r24, r28
    37c4:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    37c8:	6a e0       	ldi	r22, 0x0A	; 10
    37ca:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    37ce:	ec 01       	movw	r28, r24
    37d0:	6f e4       	ldi	r22, 0x4F	; 79
    37d2:	76 e0       	ldi	r23, 0x06	; 6
    37d4:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    37d8:	b5 01       	movw	r22, r10
    37da:	ce 01       	movw	r24, r28
    37dc:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    37e0:	6a e0       	ldi	r22, 0x0A	; 10
    37e2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    37e6:	ec 01       	movw	r28, r24
    37e8:	6d e4       	ldi	r22, 0x4D	; 77
    37ea:	76 e0       	ldi	r23, 0x06	; 6
    37ec:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    37f0:	6a e0       	ldi	r22, 0x0A	; 10
    37f2:	ce 01       	movw	r24, r28
    37f4:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    37f8:	ec 01       	movw	r28, r24
    37fa:	6b e4       	ldi	r22, 0x4B	; 75
    37fc:	76 e0       	ldi	r23, 0x06	; 6
    37fe:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3802:	b7 01       	movw	r22, r14
    3804:	a6 01       	movw	r20, r12
    3806:	ce 01       	movw	r24, r28
    3808:	0e 94 4b 20 	call	0x4096	; 0x4096 <_ZN8emstreamlsEm>
}
    380c:	df 91       	pop	r29
    380e:	cf 91       	pop	r28
    3810:	1f 91       	pop	r17
    3812:	0f 91       	pop	r16
    3814:	ff 90       	pop	r15
    3816:	ef 90       	pop	r14
    3818:	df 90       	pop	r13
    381a:	cf 90       	pop	r12
    381c:	bf 90       	pop	r11
    381e:	af 90       	pop	r10
    3820:	9f 90       	pop	r9
    3822:	8f 90       	pop	r8
    3824:	08 95       	ret

00003826 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3826:	cf 93       	push	r28
    3828:	df 93       	push	r29
    382a:	ec 01       	movw	r28, r24
    382c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    382e:	db 01       	movw	r26, r22
    3830:	ed 91       	ld	r30, X+
    3832:	fc 91       	ld	r31, X
    3834:	02 80       	ldd	r0, Z+2	; 0x02
    3836:	f3 81       	ldd	r31, Z+3	; 0x03
    3838:	e0 2d       	mov	r30, r0
    383a:	be 01       	movw	r22, r28
    383c:	19 95       	eicall
	return (ser_dev);
}
    383e:	ce 01       	movw	r24, r28
    3840:	df 91       	pop	r29
    3842:	cf 91       	pop	r28
    3844:	08 95       	ret

00003846 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3846:	0f 93       	push	r16
    3848:	1f 93       	push	r17
    384a:	cf 93       	push	r28
    384c:	df 93       	push	r29
    384e:	ec 01       	movw	r28, r24
    3850:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    3852:	bc 01       	movw	r22, r24
    3854:	c8 01       	movw	r24, r16
    3856:	0e 94 13 1c 	call	0x3826	; 0x3826 <_ZlsR8emstreamR8frt_task>
    385a:	66 e0       	ldi	r22, 0x06	; 6
    385c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    3860:	8c 81       	ldd	r24, Y+4	; 0x04
    3862:	9d 81       	ldd	r25, Y+5	; 0x05
    3864:	00 97       	sbiw	r24, 0x00	; 0
    3866:	19 f0       	breq	.+6      	; 0x386e <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3868:	b8 01       	movw	r22, r16
    386a:	0e 94 23 1c 	call	0x3846	; 0x3846 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    386e:	df 91       	pop	r29
    3870:	cf 91       	pop	r28
    3872:	1f 91       	pop	r17
    3874:	0f 91       	pop	r16
    3876:	08 95       	ret

00003878 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3878:	0f 93       	push	r16
    387a:	1f 93       	push	r17
    387c:	cf 93       	push	r28
    387e:	df 93       	push	r29
    3880:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    3882:	6a e0       	ldi	r22, 0x0A	; 10
    3884:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3888:	8c 01       	movw	r16, r24
    388a:	60 e4       	ldi	r22, 0x40	; 64
    388c:	76 e0       	ldi	r23, 0x06	; 6
    388e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3892:	6a e0       	ldi	r22, 0x0A	; 10
    3894:	c8 01       	movw	r24, r16
    3896:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    389a:	8c 01       	movw	r16, r24
    389c:	69 e3       	ldi	r22, 0x39	; 57
    389e:	76 e0       	ldi	r23, 0x06	; 6
    38a0:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    38a4:	66 e0       	ldi	r22, 0x06	; 6
    38a6:	c8 01       	movw	r24, r16
    38a8:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    38ac:	6a e0       	ldi	r22, 0x0A	; 10
    38ae:	ce 01       	movw	r24, r28
    38b0:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    38b4:	8c 01       	movw	r16, r24
    38b6:	68 e2       	ldi	r22, 0x28	; 40
    38b8:	76 e0       	ldi	r23, 0x06	; 6
    38ba:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    38be:	6a e0       	ldi	r22, 0x0A	; 10
    38c0:	c8 01       	movw	r24, r16
    38c2:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    38c6:	8c 01       	movw	r16, r24
    38c8:	6c e1       	ldi	r22, 0x1C	; 28
    38ca:	76 e0       	ldi	r23, 0x06	; 6
    38cc:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    38d0:	6a e0       	ldi	r22, 0x0A	; 10
    38d2:	c8 01       	movw	r24, r16
    38d4:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    38d8:	8c 01       	movw	r16, r24
    38da:	66 e1       	ldi	r22, 0x16	; 22
    38dc:	76 e0       	ldi	r23, 0x06	; 6
    38de:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    38e2:	66 e0       	ldi	r22, 0x06	; 6
    38e4:	c8 01       	movw	r24, r16
    38e6:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    38ea:	6a e0       	ldi	r22, 0x0A	; 10
    38ec:	ce 01       	movw	r24, r28
    38ee:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    38f2:	8c 01       	movw	r16, r24
    38f4:	65 e0       	ldi	r22, 0x05	; 5
    38f6:	76 e0       	ldi	r23, 0x06	; 6
    38f8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    38fc:	6a e0       	ldi	r22, 0x0A	; 10
    38fe:	c8 01       	movw	r24, r16
    3900:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3904:	8c 01       	movw	r16, r24
    3906:	69 ef       	ldi	r22, 0xF9	; 249
    3908:	75 e0       	ldi	r23, 0x05	; 5
    390a:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    390e:	6a e0       	ldi	r22, 0x0A	; 10
    3910:	c8 01       	movw	r24, r16
    3912:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3916:	8c 01       	movw	r16, r24
    3918:	63 ef       	ldi	r22, 0xF3	; 243
    391a:	75 e0       	ldi	r23, 0x05	; 5
    391c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3920:	66 e0       	ldi	r22, 0x06	; 6
    3922:	c8 01       	movw	r24, r16
    3924:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3928:	80 91 7a 32 	lds	r24, 0x327A	; 0x80327a <last_created_task_pointer>
    392c:	90 91 7b 32 	lds	r25, 0x327B	; 0x80327b <last_created_task_pointer+0x1>
    3930:	00 97       	sbiw	r24, 0x00	; 0
    3932:	19 f0       	breq	.+6      	; 0x393a <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3934:	be 01       	movw	r22, r28
    3936:	0e 94 23 1c 	call	0x3846	; 0x3846 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    393a:	0e 94 76 16 	call	0x2cec	; 0x2cec <xTaskGetIdleTaskHandle>
    393e:	0e 94 74 19 	call	0x32e8	; 0x32e8 <uxTaskGetStackHighWaterMark>
    3942:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3944:	6a e0       	ldi	r22, 0x0A	; 10
    3946:	ce 01       	movw	r24, r28
    3948:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    394c:	ec 01       	movw	r28, r24
    394e:	68 ee       	ldi	r22, 0xE8	; 232
    3950:	75 e0       	ldi	r23, 0x05	; 5
    3952:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3956:	61 2f       	mov	r22, r17
    3958:	ce 01       	movw	r24, r28
    395a:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    395e:	6a e0       	ldi	r22, 0x0A	; 10
    3960:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3964:	ec 01       	movw	r28, r24
    3966:	66 ee       	ldi	r22, 0xE6	; 230
    3968:	75 e0       	ldi	r23, 0x05	; 5
    396a:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    396e:	64 e6       	ldi	r22, 0x64	; 100
    3970:	70 e0       	ldi	r23, 0x00	; 0
    3972:	ce 01       	movw	r24, r28
    3974:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    3978:	6a e0       	ldi	r22, 0x0A	; 10
    397a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    397e:	ec 01       	movw	r28, r24
    3980:	63 ee       	ldi	r22, 0xE3	; 227
    3982:	75 e0       	ldi	r23, 0x05	; 5
    3984:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3988:	66 e0       	ldi	r22, 0x06	; 6
    398a:	ce 01       	movw	r24, r28
    398c:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
}
    3990:	df 91       	pop	r29
    3992:	cf 91       	pop	r28
    3994:	1f 91       	pop	r17
    3996:	0f 91       	pop	r16
    3998:	08 95       	ret

0000399a <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    399a:	0f 93       	push	r16
    399c:	cf 93       	push	r28
    399e:	df 93       	push	r29
    39a0:	1f 92       	push	r1
    39a2:	cd b7       	in	r28, 0x3d	; 61
    39a4:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    39a6:	00 e0       	ldi	r16, 0x00	; 0
    39a8:	2f ef       	ldi	r18, 0xFF	; 255
    39aa:	3f ef       	ldi	r19, 0xFF	; 255
    39ac:	a9 01       	movw	r20, r18
    39ae:	be 01       	movw	r22, r28
    39b0:	6f 5f       	subi	r22, 0xFF	; 255
    39b2:	7f 4f       	sbci	r23, 0xFF	; 255
    39b4:	fc 01       	movw	r30, r24
    39b6:	80 85       	ldd	r24, Z+8	; 0x08
    39b8:	91 85       	ldd	r25, Z+9	; 0x09
    39ba:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
    39be:	81 30       	cpi	r24, 0x01	; 1
    39c0:	19 f4       	brne	.+6      	; 0x39c8 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    39c2:	89 81       	ldd	r24, Y+1	; 0x01
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	02 c0       	rjmp	.+4      	; 0x39cc <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    39c8:	8f ef       	ldi	r24, 0xFF	; 255
    39ca:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    39cc:	0f 90       	pop	r0
    39ce:	df 91       	pop	r29
    39d0:	cf 91       	pop	r28
    39d2:	0f 91       	pop	r16
    39d4:	08 95       	ret

000039d6 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    39d6:	fc 01       	movw	r30, r24
    39d8:	80 85       	ldd	r24, Z+8	; 0x08
    39da:	91 85       	ldd	r25, Z+9	; 0x09
    39dc:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    39e0:	91 e0       	ldi	r25, 0x01	; 1
    39e2:	81 11       	cpse	r24, r1
    39e4:	01 c0       	rjmp	.+2      	; 0x39e8 <_ZN14frt_text_queue14check_for_charEv+0x12>
    39e6:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    39e8:	89 2f       	mov	r24, r25
    39ea:	08 95       	ret

000039ec <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    39ec:	0f 93       	push	r16
    39ee:	cf 93       	push	r28
    39f0:	df 93       	push	r29
    39f2:	1f 92       	push	r1
    39f4:	cd b7       	in	r28, 0x3d	; 61
    39f6:	de b7       	in	r29, 0x3e	; 62
    39f8:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    39fa:	fc 01       	movw	r30, r24
    39fc:	22 85       	ldd	r18, Z+10	; 0x0a
    39fe:	33 85       	ldd	r19, Z+11	; 0x0b
    3a00:	44 85       	ldd	r20, Z+12	; 0x0c
    3a02:	55 85       	ldd	r21, Z+13	; 0x0d
    3a04:	00 e0       	ldi	r16, 0x00	; 0
    3a06:	be 01       	movw	r22, r28
    3a08:	6f 5f       	subi	r22, 0xFF	; 255
    3a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a0c:	80 85       	ldd	r24, Z+8	; 0x08
    3a0e:	91 85       	ldd	r25, Z+9	; 0x09
    3a10:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    3a14:	91 e0       	ldi	r25, 0x01	; 1
    3a16:	81 11       	cpse	r24, r1
    3a18:	01 c0       	rjmp	.+2      	; 0x3a1c <_ZN14frt_text_queue7putcharEc+0x30>
    3a1a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3a1c:	89 2f       	mov	r24, r25
    3a1e:	0f 90       	pop	r0
    3a20:	df 91       	pop	r29
    3a22:	cf 91       	pop	r28
    3a24:	0f 91       	pop	r16
    3a26:	08 95       	ret

00003a28 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3a28:	8f 92       	push	r8
    3a2a:	9f 92       	push	r9
    3a2c:	bf 92       	push	r11
    3a2e:	cf 92       	push	r12
    3a30:	df 92       	push	r13
    3a32:	ef 92       	push	r14
    3a34:	ff 92       	push	r15
    3a36:	0f 93       	push	r16
    3a38:	1f 93       	push	r17
    3a3a:	cf 93       	push	r28
    3a3c:	df 93       	push	r29
    3a3e:	ec 01       	movw	r28, r24
    3a40:	b6 2e       	mov	r11, r22
    3a42:	4a 01       	movw	r8, r20
    3a44:	68 01       	movw	r12, r16
    3a46:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3a48:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <_ZN8emstreamC1Ev>
    3a4c:	8f e6       	ldi	r24, 0x6F	; 111
    3a4e:	91 e2       	ldi	r25, 0x21	; 33
    3a50:	88 83       	st	Y, r24
    3a52:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3a54:	8e 86       	std	Y+14, r8	; 0x0e
    3a56:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3a58:	40 e0       	ldi	r20, 0x00	; 0
    3a5a:	61 e0       	ldi	r22, 0x01	; 1
    3a5c:	8b 2d       	mov	r24, r11
    3a5e:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    3a62:	88 87       	std	Y+8, r24	; 0x08
    3a64:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3a66:	ca 86       	std	Y+10, r12	; 0x0a
    3a68:	db 86       	std	Y+11, r13	; 0x0b
    3a6a:	ec 86       	std	Y+12, r14	; 0x0c
    3a6c:	fd 86       	std	Y+13, r15	; 0x0d
}
    3a6e:	df 91       	pop	r29
    3a70:	cf 91       	pop	r28
    3a72:	1f 91       	pop	r17
    3a74:	0f 91       	pop	r16
    3a76:	ff 90       	pop	r15
    3a78:	ef 90       	pop	r14
    3a7a:	df 90       	pop	r13
    3a7c:	cf 90       	pop	r12
    3a7e:	bf 90       	pop	r11
    3a80:	9f 90       	pop	r9
    3a82:	8f 90       	pop	r8
    3a84:	08 95       	ret

00003a86 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3a86:	cf 92       	push	r12
    3a88:	df 92       	push	r13
    3a8a:	ef 92       	push	r14
    3a8c:	ff 92       	push	r15
    3a8e:	cf 93       	push	r28
    3a90:	df 93       	push	r29
    3a92:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3a94:	68 81       	ld	r22, Y
    3a96:	79 81       	ldd	r23, Y+1	; 0x01
    3a98:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a9c:	0f 2e       	mov	r0, r31
    3a9e:	f8 ee       	ldi	r31, 0xE8	; 232
    3aa0:	cf 2e       	mov	r12, r31
    3aa2:	f3 e0       	ldi	r31, 0x03	; 3
    3aa4:	df 2e       	mov	r13, r31
    3aa6:	e1 2c       	mov	r14, r1
    3aa8:	f1 2c       	mov	r15, r1
    3aaa:	f0 2d       	mov	r31, r0
    3aac:	a7 01       	movw	r20, r14
    3aae:	96 01       	movw	r18, r12
    3ab0:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
    3ab4:	9b 01       	movw	r18, r22
    3ab6:	ac 01       	movw	r20, r24
    3ab8:	60 e4       	ldi	r22, 0x40	; 64
    3aba:	72 e4       	ldi	r23, 0x42	; 66
    3abc:	8f e0       	ldi	r24, 0x0F	; 15
    3abe:	90 e0       	ldi	r25, 0x00	; 0
    3ac0:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <__mulsi3>
    3ac4:	a7 01       	movw	r20, r14
    3ac6:	96 01       	movw	r18, r12
    3ac8:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
    3acc:	69 01       	movw	r12, r18
    3ace:	7a 01       	movw	r14, r20
    3ad0:	ac 81       	ldd	r26, Y+4	; 0x04
    3ad2:	bd 81       	ldd	r27, Y+5	; 0x05
    3ad4:	20 e4       	ldi	r18, 0x40	; 64
    3ad6:	32 e4       	ldi	r19, 0x42	; 66
    3ad8:	4f e0       	ldi	r20, 0x0F	; 15
    3ada:	50 e0       	ldi	r21, 0x00	; 0
    3adc:	0e 94 40 27 	call	0x4e80	; 0x4e80 <__muluhisi3>
    3ae0:	20 e0       	ldi	r18, 0x00	; 0
    3ae2:	38 e4       	ldi	r19, 0x48	; 72
    3ae4:	48 ee       	ldi	r20, 0xE8	; 232
    3ae6:	51 e0       	ldi	r21, 0x01	; 1
    3ae8:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
    3aec:	c7 01       	movw	r24, r14
    3aee:	b6 01       	movw	r22, r12
    3af0:	62 0f       	add	r22, r18
    3af2:	73 1f       	adc	r23, r19
    3af4:	84 1f       	adc	r24, r20
    3af6:	95 1f       	adc	r25, r21
}
    3af8:	df 91       	pop	r29
    3afa:	cf 91       	pop	r28
    3afc:	ff 90       	pop	r15
    3afe:	ef 90       	pop	r14
    3b00:	df 90       	pop	r13
    3b02:	cf 90       	pop	r12
    3b04:	08 95       	ret

00003b06 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3b06:	cf 92       	push	r12
    3b08:	df 92       	push	r13
    3b0a:	ef 92       	push	r14
    3b0c:	ff 92       	push	r15
    3b0e:	0f 93       	push	r16
    3b10:	1f 93       	push	r17
    3b12:	cf 93       	push	r28
    3b14:	df 93       	push	r29
    3b16:	cd b7       	in	r28, 0x3d	; 61
    3b18:	de b7       	in	r29, 0x3e	; 62
    3b1a:	2f 97       	sbiw	r28, 0x0f	; 15
    3b1c:	cd bf       	out	0x3d, r28	; 61
    3b1e:	de bf       	out	0x3e, r29	; 62
    3b20:	6c 01       	movw	r12, r24
    3b22:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3b24:	db 01       	movw	r26, r22
    3b26:	6d 91       	ld	r22, X+
    3b28:	7d 91       	ld	r23, X+
    3b2a:	8d 91       	ld	r24, X+
    3b2c:	9c 91       	ld	r25, X
    3b2e:	28 ee       	ldi	r18, 0xE8	; 232
    3b30:	33 e0       	ldi	r19, 0x03	; 3
    3b32:	40 e0       	ldi	r20, 0x00	; 0
    3b34:	50 e0       	ldi	r21, 0x00	; 0
    3b36:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
    3b3a:	ba 01       	movw	r22, r20
    3b3c:	a9 01       	movw	r20, r18
    3b3e:	c6 01       	movw	r24, r12
    3b40:	0e 94 4b 20 	call	0x4096	; 0x4096 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3b44:	d6 01       	movw	r26, r12
    3b46:	ed 91       	ld	r30, X+
    3b48:	fc 91       	ld	r31, X
    3b4a:	02 80       	ldd	r0, Z+2	; 0x02
    3b4c:	f3 81       	ldd	r31, Z+3	; 0x03
    3b4e:	e0 2d       	mov	r30, r0
    3b50:	6e e2       	ldi	r22, 0x2E	; 46
    3b52:	c6 01       	movw	r24, r12
    3b54:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3b56:	c8 01       	movw	r24, r16
    3b58:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <_ZN10time_stamp12get_microsecEv>
    3b5c:	8e 01       	movw	r16, r28
    3b5e:	09 5f       	subi	r16, 0xF9	; 249
    3b60:	1f 4f       	sbci	r17, 0xFF	; 255
    3b62:	fe 01       	movw	r30, r28
    3b64:	31 96       	adiw	r30, 0x01	; 1
    3b66:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3b68:	2a e0       	ldi	r18, 0x0A	; 10
    3b6a:	30 e0       	ldi	r19, 0x00	; 0
    3b6c:	40 e0       	ldi	r20, 0x00	; 0
    3b6e:	50 e0       	ldi	r21, 0x00	; 0
    3b70:	0e 94 18 27 	call	0x4e30	; 0x4e30 <__divmodsi4>
    3b74:	e6 2f       	mov	r30, r22
    3b76:	28 87       	std	Y+8, r18	; 0x08
    3b78:	39 87       	std	Y+9, r19	; 0x09
    3b7a:	4a 87       	std	Y+10, r20	; 0x0a
    3b7c:	5b 87       	std	Y+11, r21	; 0x0b
    3b7e:	68 85       	ldd	r22, Y+8	; 0x08
    3b80:	79 85       	ldd	r23, Y+9	; 0x09
    3b82:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b84:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3b86:	20 e3       	ldi	r18, 0x30	; 48
    3b88:	2e 0f       	add	r18, r30
    3b8a:	d8 01       	movw	r26, r16
    3b8c:	2e 93       	st	-X, r18
    3b8e:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3b90:	ae 15       	cp	r26, r14
    3b92:	bf 05       	cpc	r27, r15
    3b94:	49 f7       	brne	.-46     	; 0x3b68 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3b96:	1f 82       	std	Y+7, r1	; 0x07
    3b98:	be 01       	movw	r22, r28
    3b9a:	6f 5f       	subi	r22, 0xFF	; 255
    3b9c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9e:	c6 01       	movw	r24, r12
    3ba0:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3ba4:	c6 01       	movw	r24, r12
    3ba6:	2f 96       	adiw	r28, 0x0f	; 15
    3ba8:	cd bf       	out	0x3d, r28	; 61
    3baa:	de bf       	out	0x3e, r29	; 62
    3bac:	df 91       	pop	r29
    3bae:	cf 91       	pop	r28
    3bb0:	1f 91       	pop	r17
    3bb2:	0f 91       	pop	r16
    3bb4:	ff 90       	pop	r15
    3bb6:	ef 90       	pop	r14
    3bb8:	df 90       	pop	r13
    3bba:	cf 90       	pop	r12
    3bbc:	08 95       	ret

00003bbe <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3bbe:	cf 93       	push	r28
    3bc0:	df 93       	push	r29
    3bc2:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	f8 94       	cli
    3bc8:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3bca:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3bce:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3bd2:	8c 83       	std	Y+4, r24	; 0x04
    3bd4:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3bd6:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <xTaskGetTickCount>
    3bda:	68 83       	st	Y, r22
    3bdc:	79 83       	std	Y+1, r23	; 0x01
    3bde:	8a 83       	std	Y+2, r24	; 0x02
    3be0:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3be2:	0f 90       	pop	r0
    3be4:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3be6:	ce 01       	movw	r24, r28
    3be8:	df 91       	pop	r29
    3bea:	cf 91       	pop	r28
    3bec:	08 95       	ret

00003bee <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3bee:	5f 92       	push	r5
    3bf0:	6f 92       	push	r6
    3bf2:	7f 92       	push	r7
    3bf4:	8f 92       	push	r8
    3bf6:	9f 92       	push	r9
    3bf8:	af 92       	push	r10
    3bfa:	bf 92       	push	r11
    3bfc:	cf 92       	push	r12
    3bfe:	df 92       	push	r13
    3c00:	ef 92       	push	r14
    3c02:	ff 92       	push	r15
    3c04:	0f 93       	push	r16
    3c06:	1f 93       	push	r17
    3c08:	cf 93       	push	r28
    3c0a:	df 93       	push	r29
    3c0c:	5c 01       	movw	r10, r24
    3c0e:	4b 01       	movw	r8, r22
    3c10:	7a 01       	movw	r14, r20
    3c12:	12 2f       	mov	r17, r18
    3c14:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3c16:	63 e0       	ldi	r22, 0x03	; 3
    3c18:	ca 01       	movw	r24, r20
    3c1a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3c1e:	a8 14       	cp	r10, r8
    3c20:	b9 04       	cpc	r11, r9
    3c22:	08 f0       	brcs	.+2      	; 0x3c26 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3c24:	7d c0       	rjmp	.+250    	; 0x3d20 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3c26:	65 01       	movw	r12, r10
    3c28:	84 e1       	ldi	r24, 0x14	; 20
    3c2a:	c8 0e       	add	r12, r24
    3c2c:	d1 1c       	adc	r13, r1
    3c2e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3c30:	6a 2c       	mov	r6, r10
    3c32:	5b 2c       	mov	r5, r11
    3c34:	b5 01       	movw	r22, r10
    3c36:	c7 01       	movw	r24, r14
    3c38:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    3c3c:	6a e0       	ldi	r22, 0x0A	; 10
    3c3e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3c42:	65 e6       	ldi	r22, 0x65	; 101
    3c44:	76 e0       	ldi	r23, 0x06	; 6
    3c46:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3c4a:	11 23       	and	r17, r17
    3c4c:	09 f4       	brne	.+2      	; 0x3c50 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3c4e:	6d c0       	rjmp	.+218    	; 0x3d2a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3c50:	00 23       	and	r16, r16
    3c52:	09 f4       	brne	.+2      	; 0x3c56 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3c54:	6a c0       	rjmp	.+212    	; 0x3d2a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3c56:	6a e0       	ldi	r22, 0x0A	; 10
    3c58:	c7 01       	movw	r24, r14
    3c5a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3c5e:	60 e6       	ldi	r22, 0x60	; 96
    3c60:	76 e0       	ldi	r23, 0x06	; 6
    3c62:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    3c66:	61 c0       	rjmp	.+194    	; 0x3d2a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3c68:	11 23       	and	r17, r17
    3c6a:	71 f0       	breq	.+28     	; 0x3c88 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c6c:	01 11       	cpse	r16, r1
    3c6e:	0c c0       	rjmp	.+24     	; 0x3c88 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c70:	88 81       	ld	r24, Y
    3c72:	87 15       	cp	r24, r7
    3c74:	49 f0       	breq	.+18     	; 0x3c88 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3c76:	6a e0       	ldi	r22, 0x0A	; 10
    3c78:	c7 01       	movw	r24, r14
    3c7a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3c7e:	6b e5       	ldi	r22, 0x5B	; 91
    3c80:	76 e0       	ldi	r23, 0x06	; 6
    3c82:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c86:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3c88:	69 91       	ld	r22, Y+
    3c8a:	c7 01       	movw	r24, r14
    3c8c:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c90:	dc 01       	movw	r26, r24
    3c92:	ed 91       	ld	r30, X+
    3c94:	fc 91       	ld	r31, X
    3c96:	02 80       	ldd	r0, Z+2	; 0x02
    3c98:	f3 81       	ldd	r31, Z+3	; 0x03
    3c9a:	e0 2d       	mov	r30, r0
    3c9c:	60 e2       	ldi	r22, 0x20	; 32
    3c9e:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3ca0:	cc 16       	cp	r12, r28
    3ca2:	dd 06       	cpc	r13, r29
    3ca4:	09 f7       	brne	.-62     	; 0x3c68 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3ca6:	11 23       	and	r17, r17
    3ca8:	89 f0       	breq	.+34     	; 0x3ccc <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3caa:	6a e0       	ldi	r22, 0x0A	; 10
    3cac:	c7 01       	movw	r24, r14
    3cae:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3cb2:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3cb4:	65 e5       	ldi	r22, 0x55	; 85
    3cb6:	76 e0       	ldi	r23, 0x06	; 6
    3cb8:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3cbc:	e8 81       	ld	r30, Y
    3cbe:	f9 81       	ldd	r31, Y+1	; 0x01
    3cc0:	02 80       	ldd	r0, Z+2	; 0x02
    3cc2:	f3 81       	ldd	r31, Z+3	; 0x03
    3cc4:	e0 2d       	mov	r30, r0
    3cc6:	60 e2       	ldi	r22, 0x20	; 32
    3cc8:	ce 01       	movw	r24, r28
    3cca:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3ccc:	c6 2d       	mov	r28, r6
    3cce:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3cd0:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3cd2:	80 ee       	ldi	r24, 0xE0	; 224
    3cd4:	86 0f       	add	r24, r22
    3cd6:	8f 35       	cpi	r24, 0x5F	; 95
    3cd8:	48 f4       	brcc	.+18     	; 0x3cec <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3cda:	d7 01       	movw	r26, r14
    3cdc:	ed 91       	ld	r30, X+
    3cde:	fc 91       	ld	r31, X
    3ce0:	02 80       	ldd	r0, Z+2	; 0x02
    3ce2:	f3 81       	ldd	r31, Z+3	; 0x03
    3ce4:	e0 2d       	mov	r30, r0
    3ce6:	c7 01       	movw	r24, r14
    3ce8:	19 95       	eicall
    3cea:	09 c0       	rjmp	.+18     	; 0x3cfe <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3cec:	d7 01       	movw	r26, r14
    3cee:	ed 91       	ld	r30, X+
    3cf0:	fc 91       	ld	r31, X
    3cf2:	02 80       	ldd	r0, Z+2	; 0x02
    3cf4:	f3 81       	ldd	r31, Z+3	; 0x03
    3cf6:	e0 2d       	mov	r30, r0
    3cf8:	6e e2       	ldi	r22, 0x2E	; 46
    3cfa:	c7 01       	movw	r24, r14
    3cfc:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3cfe:	cc 16       	cp	r12, r28
    3d00:	dd 06       	cpc	r13, r29
    3d02:	31 f7       	brne	.-52     	; 0x3cd0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3d04:	b4 e1       	ldi	r27, 0x14	; 20
    3d06:	ab 0e       	add	r10, r27
    3d08:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3d0a:	66 e0       	ldi	r22, 0x06	; 6
    3d0c:	c7 01       	movw	r24, r14
    3d0e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    3d12:	84 e1       	ldi	r24, 0x14	; 20
    3d14:	c8 0e       	add	r12, r24
    3d16:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3d18:	a8 14       	cp	r10, r8
    3d1a:	b9 04       	cpc	r11, r9
    3d1c:	08 f4       	brcc	.+2      	; 0x3d20 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3d1e:	88 cf       	rjmp	.-240    	; 0x3c30 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3d20:	62 e0       	ldi	r22, 0x02	; 2
    3d22:	c7 01       	movw	r24, r14
    3d24:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
}
    3d28:	03 c0       	rjmp	.+6      	; 0x3d30 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3d2a:	c6 2d       	mov	r28, r6
    3d2c:	d5 2d       	mov	r29, r5
    3d2e:	9c cf       	rjmp	.-200    	; 0x3c68 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3d30:	df 91       	pop	r29
    3d32:	cf 91       	pop	r28
    3d34:	1f 91       	pop	r17
    3d36:	0f 91       	pop	r16
    3d38:	ff 90       	pop	r15
    3d3a:	ef 90       	pop	r14
    3d3c:	df 90       	pop	r13
    3d3e:	cf 90       	pop	r12
    3d40:	bf 90       	pop	r11
    3d42:	af 90       	pop	r10
    3d44:	9f 90       	pop	r9
    3d46:	8f 90       	pop	r8
    3d48:	7f 90       	pop	r7
    3d4a:	6f 90       	pop	r6
    3d4c:	5f 90       	pop	r5
    3d4e:	08 95       	ret

00003d50 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3d50:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    3d54:	08 95       	ret

00003d56 <_Znaj>:
    3d56:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <pvPortMalloc>
    3d5a:	08 95       	ret

00003d5c <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3d5c:	08 95       	ret

00003d5e <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3d5e:	cf 93       	push	r28
    3d60:	df 93       	push	r29
    3d62:	fc 01       	movw	r30, r24
    3d64:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3d66:	40 3a       	cpi	r20, 0xA0	; 160
    3d68:	68 e0       	ldi	r22, 0x08	; 8
    3d6a:	56 07       	cpc	r21, r22
    3d6c:	49 f4       	brne	.+18     	; 0x3d80 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3d6e:	80 e4       	ldi	r24, 0x40	; 64
    3d70:	96 e0       	ldi	r25, 0x06	; 6
    3d72:	82 83       	std	Z+2, r24	; 0x02
    3d74:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d76:	82 e0       	ldi	r24, 0x02	; 2
    3d78:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d7a:	83 e0       	ldi	r24, 0x03	; 3
    3d7c:	85 83       	std	Z+5, r24	; 0x05
    3d7e:	32 c0       	rjmp	.+100    	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3d80:	40 3b       	cpi	r20, 0xB0	; 176
    3d82:	78 e0       	ldi	r23, 0x08	; 8
    3d84:	57 07       	cpc	r21, r23
    3d86:	49 f4       	brne	.+18     	; 0x3d9a <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3d88:	80 e4       	ldi	r24, 0x40	; 64
    3d8a:	96 e0       	ldi	r25, 0x06	; 6
    3d8c:	82 83       	std	Z+2, r24	; 0x02
    3d8e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d90:	86 e0       	ldi	r24, 0x06	; 6
    3d92:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d94:	87 e0       	ldi	r24, 0x07	; 7
    3d96:	85 83       	std	Z+5, r24	; 0x05
    3d98:	25 c0       	rjmp	.+74     	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3d9a:	40 3a       	cpi	r20, 0xA0	; 160
    3d9c:	89 e0       	ldi	r24, 0x09	; 9
    3d9e:	58 07       	cpc	r21, r24
    3da0:	49 f4       	brne	.+18     	; 0x3db4 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3da2:	80 e6       	ldi	r24, 0x60	; 96
    3da4:	96 e0       	ldi	r25, 0x06	; 6
    3da6:	82 83       	std	Z+2, r24	; 0x02
    3da8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3daa:	82 e0       	ldi	r24, 0x02	; 2
    3dac:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3dae:	83 e0       	ldi	r24, 0x03	; 3
    3db0:	85 83       	std	Z+5, r24	; 0x05
    3db2:	18 c0       	rjmp	.+48     	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3db4:	40 3b       	cpi	r20, 0xB0	; 176
    3db6:	69 e0       	ldi	r22, 0x09	; 9
    3db8:	56 07       	cpc	r21, r22
    3dba:	49 f4       	brne	.+18     	; 0x3dce <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3dbc:	80 e6       	ldi	r24, 0x60	; 96
    3dbe:	96 e0       	ldi	r25, 0x06	; 6
    3dc0:	82 83       	std	Z+2, r24	; 0x02
    3dc2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3dc4:	86 e0       	ldi	r24, 0x06	; 6
    3dc6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3dc8:	87 e0       	ldi	r24, 0x07	; 7
    3dca:	85 83       	std	Z+5, r24	; 0x05
    3dcc:	0b c0       	rjmp	.+22     	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3dce:	40 3a       	cpi	r20, 0xA0	; 160
    3dd0:	5a 40       	sbci	r21, 0x0A	; 10
    3dd2:	41 f4       	brne	.+16     	; 0x3de4 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3dd4:	80 e8       	ldi	r24, 0x80	; 128
    3dd6:	96 e0       	ldi	r25, 0x06	; 6
    3dd8:	82 83       	std	Z+2, r24	; 0x02
    3dda:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3ddc:	82 e0       	ldi	r24, 0x02	; 2
    3dde:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3de0:	83 e0       	ldi	r24, 0x03	; 3
    3de2:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3de4:	a6 83       	std	Z+6, r26	; 0x06
    3de6:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3de8:	cd 01       	movw	r24, r26
    3dea:	01 96       	adiw	r24, 0x01	; 1
    3dec:	80 87       	std	Z+8, r24	; 0x08
    3dee:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3df0:	03 96       	adiw	r24, 0x03	; 3
    3df2:	82 87       	std	Z+10, r24	; 0x0a
    3df4:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3df6:	25 81       	ldd	r18, Z+5	; 0x05
    3df8:	c2 81       	ldd	r28, Z+2	; 0x02
    3dfa:	d3 81       	ldd	r29, Z+3	; 0x03
    3dfc:	4c 81       	ldd	r20, Y+4	; 0x04
    3dfe:	81 e0       	ldi	r24, 0x01	; 1
    3e00:	90 e0       	ldi	r25, 0x00	; 0
    3e02:	bc 01       	movw	r22, r24
    3e04:	02 c0       	rjmp	.+4      	; 0x3e0a <_ZN7base232C1EjP12USART_struct+0xac>
    3e06:	66 0f       	add	r22, r22
    3e08:	77 1f       	adc	r23, r23
    3e0a:	2a 95       	dec	r18
    3e0c:	e2 f7       	brpl	.-8      	; 0x3e06 <_ZN7base232C1EjP12USART_struct+0xa8>
    3e0e:	9b 01       	movw	r18, r22
    3e10:	24 2b       	or	r18, r20
    3e12:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3e14:	25 81       	ldd	r18, Z+5	; 0x05
    3e16:	c2 81       	ldd	r28, Z+2	; 0x02
    3e18:	d3 81       	ldd	r29, Z+3	; 0x03
    3e1a:	48 81       	ld	r20, Y
    3e1c:	bc 01       	movw	r22, r24
    3e1e:	02 c0       	rjmp	.+4      	; 0x3e24 <_ZN7base232C1EjP12USART_struct+0xc6>
    3e20:	66 0f       	add	r22, r22
    3e22:	77 1f       	adc	r23, r23
    3e24:	2a 95       	dec	r18
    3e26:	e2 f7       	brpl	.-8      	; 0x3e20 <_ZN7base232C1EjP12USART_struct+0xc2>
    3e28:	9b 01       	movw	r18, r22
    3e2a:	24 2b       	or	r18, r20
    3e2c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3e2e:	34 81       	ldd	r19, Z+4	; 0x04
    3e30:	c2 81       	ldd	r28, Z+2	; 0x02
    3e32:	d3 81       	ldd	r29, Z+3	; 0x03
    3e34:	28 81       	ld	r18, Y
    3e36:	02 c0       	rjmp	.+4      	; 0x3e3c <_ZN7base232C1EjP12USART_struct+0xde>
    3e38:	88 0f       	add	r24, r24
    3e3a:	99 1f       	adc	r25, r25
    3e3c:	3a 95       	dec	r19
    3e3e:	e2 f7       	brpl	.-8      	; 0x3e38 <_ZN7base232C1EjP12USART_struct+0xda>
    3e40:	80 95       	com	r24
    3e42:	90 95       	com	r25
    3e44:	82 23       	and	r24, r18
    3e46:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3e48:	80 e1       	ldi	r24, 0x10	; 16
    3e4a:	13 96       	adiw	r26, 0x03	; 3
    3e4c:	8c 93       	st	X, r24
    3e4e:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3e50:	83 e0       	ldi	r24, 0x03	; 3
    3e52:	15 96       	adiw	r26, 0x05	; 5
    3e54:	8c 93       	st	X, r24
    3e56:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3e58:	80 ef       	ldi	r24, 0xF0	; 240
    3e5a:	17 96       	adiw	r26, 0x07	; 7
    3e5c:	8c 93       	st	X, r24
    3e5e:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3e60:	81 e2       	ldi	r24, 0x21	; 33
    3e62:	16 96       	adiw	r26, 0x06	; 6
    3e64:	8c 93       	st	X, r24
    3e66:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3e68:	88 e1       	ldi	r24, 0x18	; 24
    3e6a:	14 96       	adiw	r26, 0x04	; 4
    3e6c:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3e6e:	80 e8       	ldi	r24, 0x80	; 128
    3e70:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3e72:	80 e4       	ldi	r24, 0x40	; 64
    3e74:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3e76:	80 e2       	ldi	r24, 0x20	; 32
    3e78:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3e7a:	06 80       	ldd	r0, Z+6	; 0x06
    3e7c:	f7 81       	ldd	r31, Z+7	; 0x07
    3e7e:	e0 2d       	mov	r30, r0
    3e80:	80 81       	ld	r24, Z
    3e82:	80 81       	ld	r24, Z
}
    3e84:	df 91       	pop	r29
    3e86:	cf 91       	pop	r28
    3e88:	08 95       	ret

00003e8a <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3e8a:	81 e0       	ldi	r24, 0x01	; 1
    3e8c:	08 95       	ret

00003e8e <_ZN8emstream7getcharEv>:
    3e8e:	80 e0       	ldi	r24, 0x00	; 0
    3e90:	90 e0       	ldi	r25, 0x00	; 0
    3e92:	08 95       	ret

00003e94 <_ZN8emstream14check_for_charEv>:
    3e94:	80 e0       	ldi	r24, 0x00	; 0
    3e96:	08 95       	ret

00003e98 <_ZN8emstream12transmit_nowEv>:
    3e98:	08 95       	ret

00003e9a <_ZN8emstream12clear_screenEv>:
    3e9a:	08 95       	ret

00003e9c <_ZN8emstreamC1Ev>:
    3e9c:	fc 01       	movw	r30, r24
    3e9e:	8f e7       	ldi	r24, 0x7F	; 127
    3ea0:	91 e2       	ldi	r25, 0x21	; 33
    3ea2:	80 83       	st	Z, r24
    3ea4:	91 83       	std	Z+1, r25	; 0x01
    3ea6:	8a e0       	ldi	r24, 0x0A	; 10
    3ea8:	82 83       	std	Z+2, r24	; 0x02
    3eaa:	13 82       	std	Z+3, r1	; 0x03
    3eac:	83 e0       	ldi	r24, 0x03	; 3
    3eae:	85 83       	std	Z+5, r24	; 0x05
    3eb0:	14 82       	std	Z+4, r1	; 0x04
    3eb2:	16 82       	std	Z+6, r1	; 0x06
    3eb4:	17 82       	std	Z+7, r1	; 0x07
    3eb6:	08 95       	ret

00003eb8 <_ZN8emstream4putsEPKc>:
    3eb8:	0f 93       	push	r16
    3eba:	1f 93       	push	r17
    3ebc:	cf 93       	push	r28
    3ebe:	df 93       	push	r29
    3ec0:	8c 01       	movw	r16, r24
    3ec2:	fb 01       	movw	r30, r22
    3ec4:	dc 01       	movw	r26, r24
    3ec6:	14 96       	adiw	r26, 0x04	; 4
    3ec8:	8c 91       	ld	r24, X
    3eca:	81 11       	cpse	r24, r1
    3ecc:	04 c0       	rjmp	.+8      	; 0x3ed6 <_ZN8emstream4putsEPKc+0x1e>
    3ece:	60 81       	ld	r22, Z
    3ed0:	61 11       	cpse	r22, r1
    3ed2:	17 c0       	rjmp	.+46     	; 0x3f02 <_ZN8emstream4putsEPKc+0x4a>
    3ed4:	23 c0       	rjmp	.+70     	; 0x3f1c <_ZN8emstream4putsEPKc+0x64>
    3ed6:	d8 01       	movw	r26, r16
    3ed8:	14 96       	adiw	r26, 0x04	; 4
    3eda:	1c 92       	st	X, r1
    3edc:	eb 01       	movw	r28, r22
    3ede:	21 96       	adiw	r28, 0x01	; 1
    3ee0:	64 91       	lpm	r22, Z
    3ee2:	66 23       	and	r22, r22
    3ee4:	d9 f0       	breq	.+54     	; 0x3f1c <_ZN8emstream4putsEPKc+0x64>
    3ee6:	d8 01       	movw	r26, r16
    3ee8:	ed 91       	ld	r30, X+
    3eea:	fc 91       	ld	r31, X
    3eec:	02 80       	ldd	r0, Z+2	; 0x02
    3eee:	f3 81       	ldd	r31, Z+3	; 0x03
    3ef0:	e0 2d       	mov	r30, r0
    3ef2:	c8 01       	movw	r24, r16
    3ef4:	19 95       	eicall
    3ef6:	fe 01       	movw	r30, r28
    3ef8:	64 91       	lpm	r22, Z
    3efa:	21 96       	adiw	r28, 0x01	; 1
    3efc:	61 11       	cpse	r22, r1
    3efe:	f3 cf       	rjmp	.-26     	; 0x3ee6 <_ZN8emstream4putsEPKc+0x2e>
    3f00:	0d c0       	rjmp	.+26     	; 0x3f1c <_ZN8emstream4putsEPKc+0x64>
    3f02:	ef 01       	movw	r28, r30
    3f04:	21 96       	adiw	r28, 0x01	; 1
    3f06:	d8 01       	movw	r26, r16
    3f08:	ed 91       	ld	r30, X+
    3f0a:	fc 91       	ld	r31, X
    3f0c:	02 80       	ldd	r0, Z+2	; 0x02
    3f0e:	f3 81       	ldd	r31, Z+3	; 0x03
    3f10:	e0 2d       	mov	r30, r0
    3f12:	c8 01       	movw	r24, r16
    3f14:	19 95       	eicall
    3f16:	69 91       	ld	r22, Y+
    3f18:	61 11       	cpse	r22, r1
    3f1a:	f5 cf       	rjmp	.-22     	; 0x3f06 <_ZN8emstream4putsEPKc+0x4e>
    3f1c:	df 91       	pop	r29
    3f1e:	cf 91       	pop	r28
    3f20:	1f 91       	pop	r17
    3f22:	0f 91       	pop	r16
    3f24:	08 95       	ret

00003f26 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3f26:	cf 93       	push	r28
    3f28:	df 93       	push	r29
    3f2a:	ec 01       	movw	r28, r24
	switch (new_manip)
    3f2c:	86 2f       	mov	r24, r22
    3f2e:	90 e0       	ldi	r25, 0x00	; 0
    3f30:	8b 30       	cpi	r24, 0x0B	; 11
    3f32:	91 05       	cpc	r25, r1
    3f34:	d8 f5       	brcc	.+118    	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
    3f36:	fc 01       	movw	r30, r24
    3f38:	88 27       	eor	r24, r24
    3f3a:	e2 50       	subi	r30, 0x02	; 2
    3f3c:	ff 4f       	sbci	r31, 0xFF	; 255
    3f3e:	8f 4f       	sbci	r24, 0xFF	; 255
    3f40:	0c 94 37 27 	jmp	0x4e6e	; 0x4e6e <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3f44:	82 e0       	ldi	r24, 0x02	; 2
    3f46:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f48:	31 c0       	rjmp	.+98     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3f4a:	88 e0       	ldi	r24, 0x08	; 8
    3f4c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f4e:	2e c0       	rjmp	.+92     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3f50:	8a e0       	ldi	r24, 0x0A	; 10
    3f52:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f54:	2b c0       	rjmp	.+86     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3f56:	80 e1       	ldi	r24, 0x10	; 16
    3f58:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f5a:	28 c0       	rjmp	.+80     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3f5c:	81 e0       	ldi	r24, 0x01	; 1
    3f5e:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3f60:	25 c0       	rjmp	.+74     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3f62:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3f64:	23 c0       	rjmp	.+70     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3f66:	e8 81       	ld	r30, Y
    3f68:	f9 81       	ldd	r31, Y+1	; 0x01
    3f6a:	02 80       	ldd	r0, Z+2	; 0x02
    3f6c:	f3 81       	ldd	r31, Z+3	; 0x03
    3f6e:	e0 2d       	mov	r30, r0
    3f70:	6d e0       	ldi	r22, 0x0D	; 13
    3f72:	ce 01       	movw	r24, r28
    3f74:	19 95       	eicall
    3f76:	e8 81       	ld	r30, Y
    3f78:	f9 81       	ldd	r31, Y+1	; 0x01
    3f7a:	02 80       	ldd	r0, Z+2	; 0x02
    3f7c:	f3 81       	ldd	r31, Z+3	; 0x03
    3f7e:	e0 2d       	mov	r30, r0
    3f80:	6a e0       	ldi	r22, 0x0A	; 10
    3f82:	ce 01       	movw	r24, r28
    3f84:	19 95       	eicall
			break;
    3f86:	12 c0       	rjmp	.+36     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3f88:	e8 81       	ld	r30, Y
    3f8a:	f9 81       	ldd	r31, Y+1	; 0x01
    3f8c:	02 84       	ldd	r0, Z+10	; 0x0a
    3f8e:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f90:	e0 2d       	mov	r30, r0
    3f92:	ce 01       	movw	r24, r28
    3f94:	19 95       	eicall
			break;
    3f96:	0a c0       	rjmp	.+20     	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3f98:	e8 81       	ld	r30, Y
    3f9a:	f9 81       	ldd	r31, Y+1	; 0x01
    3f9c:	00 84       	ldd	r0, Z+8	; 0x08
    3f9e:	f1 85       	ldd	r31, Z+9	; 0x09
    3fa0:	e0 2d       	mov	r30, r0
    3fa2:	ce 01       	movw	r24, r28
    3fa4:	19 95       	eicall
			break;
    3fa6:	02 c0       	rjmp	.+4      	; 0x3fac <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3fa8:	81 e0       	ldi	r24, 0x01	; 1
    3faa:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3fac:	ce 01       	movw	r24, r28
    3fae:	df 91       	pop	r29
    3fb0:	cf 91       	pop	r28
    3fb2:	08 95       	ret

00003fb4 <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    3fb4:	cf 93       	push	r28
    3fb6:	df 93       	push	r29
    3fb8:	ec 01       	movw	r28, r24
	if (value)
    3fba:	66 23       	and	r22, r22
    3fbc:	41 f0       	breq	.+16     	; 0x3fce <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    3fbe:	e8 81       	ld	r30, Y
    3fc0:	f9 81       	ldd	r31, Y+1	; 0x01
    3fc2:	02 80       	ldd	r0, Z+2	; 0x02
    3fc4:	f3 81       	ldd	r31, Z+3	; 0x03
    3fc6:	e0 2d       	mov	r30, r0
    3fc8:	64 e5       	ldi	r22, 0x54	; 84
    3fca:	19 95       	eicall
    3fcc:	07 c0       	rjmp	.+14     	; 0x3fdc <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    3fce:	e8 81       	ld	r30, Y
    3fd0:	f9 81       	ldd	r31, Y+1	; 0x01
    3fd2:	02 80       	ldd	r0, Z+2	; 0x02
    3fd4:	f3 81       	ldd	r31, Z+3	; 0x03
    3fd6:	e0 2d       	mov	r30, r0
    3fd8:	66 e4       	ldi	r22, 0x46	; 70
    3fda:	19 95       	eicall

	return (*this);
}
    3fdc:	ce 01       	movw	r24, r28
    3fde:	df 91       	pop	r29
    3fe0:	cf 91       	pop	r28
    3fe2:	08 95       	ret

00003fe4 <_ZN8emstreamlsEPv>:
 *          reference is used to string printable items together with "<<" operators
 *  @param ptr The pointer to be sent out
 */

emstream& emstream::operator<< (void* ptr)
{
    3fe4:	0f 93       	push	r16
    3fe6:	1f 93       	push	r17
    3fe8:	cf 93       	push	r28
    3fea:	df 93       	push	r29
    3fec:	ec 01       	movw	r28, r24
    3fee:	8b 01       	movw	r16, r22
	putchar ('[');
    3ff0:	e8 81       	ld	r30, Y
    3ff2:	f9 81       	ldd	r31, Y+1	; 0x01
    3ff4:	02 80       	ldd	r0, Z+2	; 0x02
    3ff6:	f3 81       	ldd	r31, Z+3	; 0x03
    3ff8:	e0 2d       	mov	r30, r0
    3ffa:	6b e5       	ldi	r22, 0x5B	; 91
    3ffc:	19 95       	eicall
	*this << hex << (size_t)ptr << dec;
    3ffe:	63 e0       	ldi	r22, 0x03	; 3
    4000:	ce 01       	movw	r24, r28
    4002:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    4006:	b8 01       	movw	r22, r16
    4008:	0e 94 17 20 	call	0x402e	; 0x402e <_ZN8emstreamlsEj>
    400c:	62 e0       	ldi	r22, 0x02	; 2
    400e:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	putchar (']');
    4012:	e8 81       	ld	r30, Y
    4014:	f9 81       	ldd	r31, Y+1	; 0x01
    4016:	02 80       	ldd	r0, Z+2	; 0x02
    4018:	f3 81       	ldd	r31, Z+3	; 0x03
    401a:	e0 2d       	mov	r30, r0
    401c:	6d e5       	ldi	r22, 0x5D	; 93
    401e:	ce 01       	movw	r24, r28
    4020:	19 95       	eicall

	return (*this);
}
    4022:	ce 01       	movw	r24, r28
    4024:	df 91       	pop	r29
    4026:	cf 91       	pop	r28
    4028:	1f 91       	pop	r17
    402a:	0f 91       	pop	r16
    402c:	08 95       	ret

0000402e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    402e:	ff 92       	push	r15
    4030:	0f 93       	push	r16
    4032:	1f 93       	push	r17
    4034:	cf 93       	push	r28
    4036:	df 93       	push	r29
    4038:	cd b7       	in	r28, 0x3d	; 61
    403a:	de b7       	in	r29, 0x3e	; 62
    403c:	61 97       	sbiw	r28, 0x11	; 17
    403e:	cd bf       	out	0x3d, r28	; 61
    4040:	de bf       	out	0x3e, r29	; 62
    4042:	8c 01       	movw	r16, r24
    4044:	f6 2e       	mov	r15, r22
    4046:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    4048:	f8 01       	movw	r30, r16
    404a:	42 81       	ldd	r20, Z+2	; 0x02
    404c:	40 31       	cpi	r20, 0x10	; 16
    404e:	21 f0       	breq	.+8      	; 0x4058 <_ZN8emstreamlsEj+0x2a>
    4050:	48 30       	cpi	r20, 0x08	; 8
    4052:	11 f0       	breq	.+4      	; 0x4058 <_ZN8emstreamlsEj+0x2a>
    4054:	42 30       	cpi	r20, 0x02	; 2
    4056:	41 f4       	brne	.+16     	; 0x4068 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    4058:	69 2f       	mov	r22, r25
    405a:	c8 01       	movw	r24, r16
    405c:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    4060:	6f 2d       	mov	r22, r15
    4062:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    4066:	0d c0       	rjmp	.+26     	; 0x4082 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4068:	50 e0       	ldi	r21, 0x00	; 0
    406a:	be 01       	movw	r22, r28
    406c:	6f 5f       	subi	r22, 0xFF	; 255
    406e:	7f 4f       	sbci	r23, 0xFF	; 255
    4070:	8f 2d       	mov	r24, r15
    4072:	0e 94 a6 27 	call	0x4f4c	; 0x4f4c <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    4076:	be 01       	movw	r22, r28
    4078:	6f 5f       	subi	r22, 0xFF	; 255
    407a:	7f 4f       	sbci	r23, 0xFF	; 255
    407c:	c8 01       	movw	r24, r16
    407e:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    4082:	c8 01       	movw	r24, r16
    4084:	61 96       	adiw	r28, 0x11	; 17
    4086:	cd bf       	out	0x3d, r28	; 61
    4088:	de bf       	out	0x3e, r29	; 62
    408a:	df 91       	pop	r29
    408c:	cf 91       	pop	r28
    408e:	1f 91       	pop	r17
    4090:	0f 91       	pop	r16
    4092:	ff 90       	pop	r15
    4094:	08 95       	ret

00004096 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    4096:	df 92       	push	r13
    4098:	ef 92       	push	r14
    409a:	ff 92       	push	r15
    409c:	0f 93       	push	r16
    409e:	1f 93       	push	r17
    40a0:	cf 93       	push	r28
    40a2:	df 93       	push	r29
    40a4:	cd b7       	in	r28, 0x3d	; 61
    40a6:	de b7       	in	r29, 0x3e	; 62
    40a8:	a1 97       	sbiw	r28, 0x21	; 33
    40aa:	cd bf       	out	0x3d, r28	; 61
    40ac:	de bf       	out	0x3e, r29	; 62
    40ae:	8c 01       	movw	r16, r24
    40b0:	d4 2e       	mov	r13, r20
    40b2:	e5 2e       	mov	r14, r21
    40b4:	f6 2e       	mov	r15, r22
    40b6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    40b8:	f8 01       	movw	r30, r16
    40ba:	22 81       	ldd	r18, Z+2	; 0x02
    40bc:	20 31       	cpi	r18, 0x10	; 16
    40be:	21 f0       	breq	.+8      	; 0x40c8 <_ZN8emstreamlsEm+0x32>
    40c0:	28 30       	cpi	r18, 0x08	; 8
    40c2:	11 f0       	breq	.+4      	; 0x40c8 <_ZN8emstreamlsEm+0x32>
    40c4:	22 30       	cpi	r18, 0x02	; 2
    40c6:	71 f4       	brne	.+28     	; 0x40e4 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    40c8:	69 2f       	mov	r22, r25
    40ca:	c8 01       	movw	r24, r16
    40cc:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    40d0:	6f 2d       	mov	r22, r15
    40d2:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    40d6:	6e 2d       	mov	r22, r14
    40d8:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    40dc:	6d 2d       	mov	r22, r13
    40de:	0e 94 8d 20 	call	0x411a	; 0x411a <_ZN8emstreamlsEh>
    40e2:	0f c0       	rjmp	.+30     	; 0x4102 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    40e4:	30 e0       	ldi	r19, 0x00	; 0
    40e6:	ae 01       	movw	r20, r28
    40e8:	4f 5f       	subi	r20, 0xFF	; 255
    40ea:	5f 4f       	sbci	r21, 0xFF	; 255
    40ec:	6d 2d       	mov	r22, r13
    40ee:	7e 2d       	mov	r23, r14
    40f0:	8f 2d       	mov	r24, r15
    40f2:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    40f6:	be 01       	movw	r22, r28
    40f8:	6f 5f       	subi	r22, 0xFF	; 255
    40fa:	7f 4f       	sbci	r23, 0xFF	; 255
    40fc:	c8 01       	movw	r24, r16
    40fe:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    4102:	c8 01       	movw	r24, r16
    4104:	a1 96       	adiw	r28, 0x21	; 33
    4106:	cd bf       	out	0x3d, r28	; 61
    4108:	de bf       	out	0x3e, r29	; 62
    410a:	df 91       	pop	r29
    410c:	cf 91       	pop	r28
    410e:	1f 91       	pop	r17
    4110:	0f 91       	pop	r16
    4112:	ff 90       	pop	r15
    4114:	ef 90       	pop	r14
    4116:	df 90       	pop	r13
    4118:	08 95       	ret

0000411a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    411a:	cf 92       	push	r12
    411c:	df 92       	push	r13
    411e:	ef 92       	push	r14
    4120:	ff 92       	push	r15
    4122:	0f 93       	push	r16
    4124:	1f 93       	push	r17
    4126:	cf 93       	push	r28
    4128:	df 93       	push	r29
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
    412e:	29 97       	sbiw	r28, 0x09	; 9
    4130:	cd bf       	out	0x3d, r28	; 61
    4132:	de bf       	out	0x3e, r29	; 62
    4134:	8c 01       	movw	r16, r24
    4136:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    4138:	dc 01       	movw	r26, r24
    413a:	13 96       	adiw	r26, 0x03	; 3
    413c:	8c 91       	ld	r24, X
    413e:	13 97       	sbiw	r26, 0x03	; 3
    4140:	88 23       	and	r24, r24
    4142:	41 f0       	breq	.+16     	; 0x4154 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    4144:	ed 91       	ld	r30, X+
    4146:	fc 91       	ld	r31, X
    4148:	02 80       	ldd	r0, Z+2	; 0x02
    414a:	f3 81       	ldd	r31, Z+3	; 0x03
    414c:	e0 2d       	mov	r30, r0
    414e:	c8 01       	movw	r24, r16
    4150:	19 95       	eicall
    4152:	56 c0       	rjmp	.+172    	; 0x4200 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    4154:	f8 01       	movw	r30, r16
    4156:	42 81       	ldd	r20, Z+2	; 0x02
    4158:	42 30       	cpi	r20, 0x02	; 2
    415a:	19 f5       	brne	.+70     	; 0x41a2 <_ZN8emstreamlsEh+0x88>
    415c:	68 94       	set
    415e:	cc 24       	eor	r12, r12
    4160:	c3 f8       	bld	r12, 3
    4162:	d1 2c       	mov	r13, r1
    4164:	68 94       	set
    4166:	ff 24       	eor	r15, r15
    4168:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    416a:	8e 2d       	mov	r24, r14
    416c:	8f 21       	and	r24, r15
    416e:	51 f0       	breq	.+20     	; 0x4184 <_ZN8emstreamlsEh+0x6a>
    4170:	d8 01       	movw	r26, r16
    4172:	ed 91       	ld	r30, X+
    4174:	fc 91       	ld	r31, X
    4176:	02 80       	ldd	r0, Z+2	; 0x02
    4178:	f3 81       	ldd	r31, Z+3	; 0x03
    417a:	e0 2d       	mov	r30, r0
    417c:	61 e3       	ldi	r22, 0x31	; 49
    417e:	c8 01       	movw	r24, r16
    4180:	19 95       	eicall
    4182:	09 c0       	rjmp	.+18     	; 0x4196 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    4184:	d8 01       	movw	r26, r16
    4186:	ed 91       	ld	r30, X+
    4188:	fc 91       	ld	r31, X
    418a:	02 80       	ldd	r0, Z+2	; 0x02
    418c:	f3 81       	ldd	r31, Z+3	; 0x03
    418e:	e0 2d       	mov	r30, r0
    4190:	60 e3       	ldi	r22, 0x30	; 48
    4192:	c8 01       	movw	r24, r16
    4194:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    4196:	f6 94       	lsr	r15
    4198:	b1 e0       	ldi	r27, 0x01	; 1
    419a:	cb 1a       	sub	r12, r27
    419c:	d1 08       	sbc	r13, r1
    419e:	29 f7       	brne	.-54     	; 0x416a <_ZN8emstreamlsEh+0x50>
    41a0:	2f c0       	rjmp	.+94     	; 0x4200 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    41a2:	40 31       	cpi	r20, 0x10	; 16
    41a4:	f9 f4       	brne	.+62     	; 0x41e4 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    41a6:	62 95       	swap	r22
    41a8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    41aa:	01 90       	ld	r0, Z+
    41ac:	f0 81       	ld	r31, Z
    41ae:	e0 2d       	mov	r30, r0
    41b0:	02 80       	ldd	r0, Z+2	; 0x02
    41b2:	f3 81       	ldd	r31, Z+3	; 0x03
    41b4:	e0 2d       	mov	r30, r0
    41b6:	6a 30       	cpi	r22, 0x0A	; 10
    41b8:	10 f0       	brcs	.+4      	; 0x41be <_ZN8emstreamlsEh+0xa4>
    41ba:	69 5c       	subi	r22, 0xC9	; 201
    41bc:	01 c0       	rjmp	.+2      	; 0x41c0 <_ZN8emstreamlsEh+0xa6>
    41be:	60 5d       	subi	r22, 0xD0	; 208
    41c0:	c8 01       	movw	r24, r16
    41c2:	19 95       	eicall
		temp_char = num & 0x0F;
    41c4:	6e 2d       	mov	r22, r14
    41c6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    41c8:	d8 01       	movw	r26, r16
    41ca:	ed 91       	ld	r30, X+
    41cc:	fc 91       	ld	r31, X
    41ce:	02 80       	ldd	r0, Z+2	; 0x02
    41d0:	f3 81       	ldd	r31, Z+3	; 0x03
    41d2:	e0 2d       	mov	r30, r0
    41d4:	6a 30       	cpi	r22, 0x0A	; 10
    41d6:	10 f0       	brcs	.+4      	; 0x41dc <_ZN8emstreamlsEh+0xc2>
    41d8:	69 5c       	subi	r22, 0xC9	; 201
    41da:	01 c0       	rjmp	.+2      	; 0x41de <_ZN8emstreamlsEh+0xc4>
    41dc:	60 5d       	subi	r22, 0xD0	; 208
    41de:	c8 01       	movw	r24, r16
    41e0:	19 95       	eicall
    41e2:	0e c0       	rjmp	.+28     	; 0x4200 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    41e4:	50 e0       	ldi	r21, 0x00	; 0
    41e6:	be 01       	movw	r22, r28
    41e8:	6f 5f       	subi	r22, 0xFF	; 255
    41ea:	7f 4f       	sbci	r23, 0xFF	; 255
    41ec:	8e 2d       	mov	r24, r14
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	0e 94 a6 27 	call	0x4f4c	; 0x4f4c <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    41f4:	be 01       	movw	r22, r28
    41f6:	6f 5f       	subi	r22, 0xFF	; 255
    41f8:	7f 4f       	sbci	r23, 0xFF	; 255
    41fa:	c8 01       	movw	r24, r16
    41fc:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    4200:	c8 01       	movw	r24, r16
    4202:	29 96       	adiw	r28, 0x09	; 9
    4204:	cd bf       	out	0x3d, r28	; 61
    4206:	de bf       	out	0x3e, r29	; 62
    4208:	df 91       	pop	r29
    420a:	cf 91       	pop	r28
    420c:	1f 91       	pop	r17
    420e:	0f 91       	pop	r16
    4210:	ff 90       	pop	r15
    4212:	ef 90       	pop	r14
    4214:	df 90       	pop	r13
    4216:	cf 90       	pop	r12
    4218:	08 95       	ret

0000421a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    421a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    421c:	50 96       	adiw	r26, 0x10	; 16
    421e:	ed 91       	ld	r30, X+
    4220:	fc 91       	ld	r31, X
    4222:	51 97       	sbiw	r26, 0x11	; 17
    4224:	80 81       	ld	r24, Z
    4226:	54 96       	adiw	r26, 0x14	; 20
    4228:	4c 91       	ld	r20, X
    422a:	54 97       	sbiw	r26, 0x14	; 20
    422c:	84 23       	and	r24, r20
    422e:	29 f0       	breq	.+10     	; 0x423a <_ZN5rs2327putcharEc+0x20>
    4230:	09 c0       	rjmp	.+18     	; 0x4244 <_ZN5rs2327putcharEc+0x2a>
    4232:	21 50       	subi	r18, 0x01	; 1
    4234:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4236:	19 f4       	brne	.+6      	; 0x423e <_ZN5rs2327putcharEc+0x24>
    4238:	12 c0       	rjmp	.+36     	; 0x425e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    423a:	21 e2       	ldi	r18, 0x21	; 33
    423c:	3e e4       	ldi	r19, 0x4E	; 78
    423e:	90 81       	ld	r25, Z
    4240:	94 23       	and	r25, r20
    4242:	b9 f3       	breq	.-18     	; 0x4232 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4244:	90 81       	ld	r25, Z
    4246:	56 96       	adiw	r26, 0x16	; 22
    4248:	8c 91       	ld	r24, X
    424a:	56 97       	sbiw	r26, 0x16	; 22
    424c:	89 2b       	or	r24, r25
    424e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    4250:	1e 96       	adiw	r26, 0x0e	; 14
    4252:	ed 91       	ld	r30, X+
    4254:	fc 91       	ld	r31, X
    4256:	1f 97       	sbiw	r26, 0x0f	; 15
    4258:	60 83       	st	Z, r22
	return (true);
    425a:	81 e0       	ldi	r24, 0x01	; 1
    425c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    425e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    4260:	08 95       	ret

00004262 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    4262:	cf 93       	push	r28
    4264:	df 93       	push	r29
    4266:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    4268:	c1 8d       	ldd	r28, Z+25	; 0x19
    426a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    426c:	28 81       	ld	r18, Y
    426e:	39 81       	ldd	r19, Y+1	; 0x01
    4270:	a3 8d       	ldd	r26, Z+27	; 0x1b
    4272:	b4 8d       	ldd	r27, Z+28	; 0x1c
    4274:	4d 91       	ld	r20, X+
    4276:	5c 91       	ld	r21, X
    4278:	24 17       	cp	r18, r20
    427a:	35 07       	cpc	r19, r21
    427c:	e9 f3       	breq	.-6      	; 0x4278 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    427e:	a7 89       	ldd	r26, Z+23	; 0x17
    4280:	b0 8d       	ldd	r27, Z+24	; 0x18
    4282:	0d 90       	ld	r0, X+
    4284:	bc 91       	ld	r27, X
    4286:	a0 2d       	mov	r26, r0
    4288:	a2 0f       	add	r26, r18
    428a:	b3 1f       	adc	r27, r19
    428c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    428e:	2f 5f       	subi	r18, 0xFF	; 255
    4290:	3f 4f       	sbci	r19, 0xFF	; 255
    4292:	28 83       	st	Y, r18
    4294:	39 83       	std	Y+1, r19	; 0x01
    4296:	24 36       	cpi	r18, 0x64	; 100
    4298:	31 05       	cpc	r19, r1
    429a:	28 f0       	brcs	.+10     	; 0x42a6 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    429c:	01 8c       	ldd	r0, Z+25	; 0x19
    429e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    42a0:	e0 2d       	mov	r30, r0
    42a2:	10 82       	st	Z, r1
    42a4:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    42a6:	90 e0       	ldi	r25, 0x00	; 0
    42a8:	df 91       	pop	r29
    42aa:	cf 91       	pop	r28
    42ac:	08 95       	ret

000042ae <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    42ae:	cf 93       	push	r28
    42b0:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    42b2:	ec 01       	movw	r28, r24
    42b4:	a9 8d       	ldd	r26, Y+25	; 0x19
    42b6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    42b8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    42ba:	fc 8d       	ldd	r31, Y+28	; 0x1c
    42bc:	81 e0       	ldi	r24, 0x01	; 1
    42be:	4d 91       	ld	r20, X+
    42c0:	5c 91       	ld	r21, X
    42c2:	20 81       	ld	r18, Z
    42c4:	31 81       	ldd	r19, Z+1	; 0x01
    42c6:	42 17       	cp	r20, r18
    42c8:	53 07       	cpc	r21, r19
    42ca:	09 f4       	brne	.+2      	; 0x42ce <_ZN5rs23214check_for_charEv+0x20>
    42cc:	80 e0       	ldi	r24, 0x00	; 0
}
    42ce:	df 91       	pop	r29
    42d0:	cf 91       	pop	r28
    42d2:	08 95       	ret

000042d4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    42d4:	dc 01       	movw	r26, r24
    42d6:	ed 91       	ld	r30, X+
    42d8:	fc 91       	ld	r31, X
    42da:	02 80       	ldd	r0, Z+2	; 0x02
    42dc:	f3 81       	ldd	r31, Z+3	; 0x03
    42de:	e0 2d       	mov	r30, r0
    42e0:	6c e0       	ldi	r22, 0x0C	; 12
    42e2:	19 95       	eicall
    42e4:	08 95       	ret

000042e6 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    42e6:	ef 92       	push	r14
    42e8:	ff 92       	push	r15
    42ea:	0f 93       	push	r16
    42ec:	1f 93       	push	r17
    42ee:	cf 93       	push	r28
    42f0:	df 93       	push	r29
    42f2:	ec 01       	movw	r28, r24
    42f4:	7b 01       	movw	r14, r22
    42f6:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    42f8:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <_ZN8emstreamC1Ev>
    42fc:	a8 01       	movw	r20, r16
    42fe:	b7 01       	movw	r22, r14
    4300:	ce 01       	movw	r24, r28
    4302:	08 96       	adiw	r24, 0x08	; 8
    4304:	0e 94 af 1e 	call	0x3d5e	; 0x3d5e <_ZN7base232C1EjP12USART_struct>
    4308:	8f e8       	ldi	r24, 0x8F	; 143
    430a:	91 e2       	ldi	r25, 0x21	; 33
    430c:	88 83       	st	Y, r24
    430e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    4310:	00 3a       	cpi	r16, 0xA0	; 160
    4312:	88 e0       	ldi	r24, 0x08	; 8
    4314:	18 07       	cpc	r17, r24
    4316:	69 f4       	brne	.+26     	; 0x4332 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4318:	88 e9       	ldi	r24, 0x98	; 152
    431a:	92 e3       	ldi	r25, 0x32	; 50
    431c:	8f 8b       	std	Y+23, r24	; 0x17
    431e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    4320:	8e e8       	ldi	r24, 0x8E	; 142
    4322:	92 e3       	ldi	r25, 0x32	; 50
    4324:	89 8f       	std	Y+25, r24	; 0x19
    4326:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4328:	84 e8       	ldi	r24, 0x84	; 132
    432a:	92 e3       	ldi	r25, 0x32	; 50
    432c:	8b 8f       	std	Y+27, r24	; 0x1b
    432e:	9c 8f       	std	Y+28, r25	; 0x1c
    4330:	42 c0       	rjmp	.+132    	; 0x43b6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4332:	00 3b       	cpi	r16, 0xB0	; 176
    4334:	e8 e0       	ldi	r30, 0x08	; 8
    4336:	1e 07       	cpc	r17, r30
    4338:	69 f4       	brne	.+26     	; 0x4354 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    433a:	86 e9       	ldi	r24, 0x96	; 150
    433c:	92 e3       	ldi	r25, 0x32	; 50
    433e:	8f 8b       	std	Y+23, r24	; 0x17
    4340:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4342:	8c e8       	ldi	r24, 0x8C	; 140
    4344:	92 e3       	ldi	r25, 0x32	; 50
    4346:	89 8f       	std	Y+25, r24	; 0x19
    4348:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    434a:	82 e8       	ldi	r24, 0x82	; 130
    434c:	92 e3       	ldi	r25, 0x32	; 50
    434e:	8b 8f       	std	Y+27, r24	; 0x1b
    4350:	9c 8f       	std	Y+28, r25	; 0x1c
    4352:	31 c0       	rjmp	.+98     	; 0x43b6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    4354:	00 3a       	cpi	r16, 0xA0	; 160
    4356:	f9 e0       	ldi	r31, 0x09	; 9
    4358:	1f 07       	cpc	r17, r31
    435a:	69 f4       	brne	.+26     	; 0x4376 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    435c:	84 e9       	ldi	r24, 0x94	; 148
    435e:	92 e3       	ldi	r25, 0x32	; 50
    4360:	8f 8b       	std	Y+23, r24	; 0x17
    4362:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    4364:	8a e8       	ldi	r24, 0x8A	; 138
    4366:	92 e3       	ldi	r25, 0x32	; 50
    4368:	89 8f       	std	Y+25, r24	; 0x19
    436a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    436c:	80 e8       	ldi	r24, 0x80	; 128
    436e:	92 e3       	ldi	r25, 0x32	; 50
    4370:	8b 8f       	std	Y+27, r24	; 0x1b
    4372:	9c 8f       	std	Y+28, r25	; 0x1c
    4374:	20 c0       	rjmp	.+64     	; 0x43b6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    4376:	00 3b       	cpi	r16, 0xB0	; 176
    4378:	89 e0       	ldi	r24, 0x09	; 9
    437a:	18 07       	cpc	r17, r24
    437c:	69 f4       	brne	.+26     	; 0x4398 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    437e:	82 e9       	ldi	r24, 0x92	; 146
    4380:	92 e3       	ldi	r25, 0x32	; 50
    4382:	8f 8b       	std	Y+23, r24	; 0x17
    4384:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    4386:	88 e8       	ldi	r24, 0x88	; 136
    4388:	92 e3       	ldi	r25, 0x32	; 50
    438a:	89 8f       	std	Y+25, r24	; 0x19
    438c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    438e:	8e e7       	ldi	r24, 0x7E	; 126
    4390:	92 e3       	ldi	r25, 0x32	; 50
    4392:	8b 8f       	std	Y+27, r24	; 0x1b
    4394:	9c 8f       	std	Y+28, r25	; 0x1c
    4396:	0f c0       	rjmp	.+30     	; 0x43b6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    4398:	00 3a       	cpi	r16, 0xA0	; 160
    439a:	1a 40       	sbci	r17, 0x0A	; 10
    439c:	61 f4       	brne	.+24     	; 0x43b6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    439e:	80 e9       	ldi	r24, 0x90	; 144
    43a0:	92 e3       	ldi	r25, 0x32	; 50
    43a2:	8f 8b       	std	Y+23, r24	; 0x17
    43a4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    43a6:	86 e8       	ldi	r24, 0x86	; 134
    43a8:	92 e3       	ldi	r25, 0x32	; 50
    43aa:	89 8f       	std	Y+25, r24	; 0x19
    43ac:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    43ae:	8c e7       	ldi	r24, 0x7C	; 124
    43b0:	92 e3       	ldi	r25, 0x32	; 50
    43b2:	8b 8f       	std	Y+27, r24	; 0x1b
    43b4:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    43b6:	0f 89       	ldd	r16, Y+23	; 0x17
    43b8:	18 8d       	ldd	r17, Y+24	; 0x18
    43ba:	84 e6       	ldi	r24, 0x64	; 100
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	0e 94 ab 1e 	call	0x3d56	; 0x3d56 <_Znaj>
    43c2:	f8 01       	movw	r30, r16
    43c4:	80 83       	st	Z, r24
    43c6:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    43c8:	e9 8d       	ldd	r30, Y+25	; 0x19
    43ca:	fa 8d       	ldd	r31, Y+26	; 0x1a
    43cc:	10 82       	st	Z, r1
    43ce:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    43d0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    43d2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    43d4:	10 82       	st	Z, r1
    43d6:	11 82       	std	Z+1, r1	; 0x01
}
    43d8:	df 91       	pop	r29
    43da:	cf 91       	pop	r28
    43dc:	1f 91       	pop	r17
    43de:	0f 91       	pop	r16
    43e0:	ff 90       	pop	r15
    43e2:	ef 90       	pop	r14
    43e4:	08 95       	ret

000043e6 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    43e6:	1f 92       	push	r1
    43e8:	0f 92       	push	r0
    43ea:	0f b6       	in	r0, 0x3f	; 63
    43ec:	0f 92       	push	r0
    43ee:	11 24       	eor	r1, r1
    43f0:	08 b6       	in	r0, 0x38	; 56
    43f2:	0f 92       	push	r0
    43f4:	18 be       	out	0x38, r1	; 56
    43f6:	0b b6       	in	r0, 0x3b	; 59
    43f8:	0f 92       	push	r0
    43fa:	1b be       	out	0x3b, r1	; 59
    43fc:	2f 93       	push	r18
    43fe:	3f 93       	push	r19
    4400:	8f 93       	push	r24
    4402:	9f 93       	push	r25
    4404:	ef 93       	push	r30
    4406:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    4408:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    440c:	e0 91 98 32 	lds	r30, 0x3298	; 0x803298 <rcvC0_buffer>
    4410:	f0 91 99 32 	lds	r31, 0x3299	; 0x803299 <rcvC0_buffer+0x1>
    4414:	80 91 84 32 	lds	r24, 0x3284	; 0x803284 <rcvC0_write_index>
    4418:	90 91 85 32 	lds	r25, 0x3285	; 0x803285 <rcvC0_write_index+0x1>
    441c:	e8 0f       	add	r30, r24
    441e:	f9 1f       	adc	r31, r25
    4420:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    4422:	80 91 84 32 	lds	r24, 0x3284	; 0x803284 <rcvC0_write_index>
    4426:	90 91 85 32 	lds	r25, 0x3285	; 0x803285 <rcvC0_write_index+0x1>
    442a:	01 96       	adiw	r24, 0x01	; 1
    442c:	84 36       	cpi	r24, 0x64	; 100
    442e:	91 05       	cpc	r25, r1
    4430:	60 f4       	brcc	.+24     	; 0x444a <__vector_25+0x64>
    4432:	80 93 84 32 	sts	0x3284, r24	; 0x803284 <rcvC0_write_index>
    4436:	90 93 85 32 	sts	0x3285, r25	; 0x803285 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    443a:	20 91 8e 32 	lds	r18, 0x328E	; 0x80328e <rcvC0_read_index>
    443e:	30 91 8f 32 	lds	r19, 0x328F	; 0x80328f <rcvC0_read_index+0x1>
    4442:	82 17       	cp	r24, r18
    4444:	93 07       	cpc	r25, r19
    4446:	f1 f4       	brne	.+60     	; 0x4484 <__vector_25+0x9e>
    4448:	0c c0       	rjmp	.+24     	; 0x4462 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    444a:	10 92 84 32 	sts	0x3284, r1	; 0x803284 <rcvC0_write_index>
    444e:	10 92 85 32 	sts	0x3285, r1	; 0x803285 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4452:	80 91 8e 32 	lds	r24, 0x328E	; 0x80328e <rcvC0_read_index>
    4456:	90 91 8f 32 	lds	r25, 0x328F	; 0x80328f <rcvC0_read_index+0x1>
    445a:	18 16       	cp	r1, r24
    445c:	19 06       	cpc	r1, r25
    445e:	91 f4       	brne	.+36     	; 0x4484 <__vector_25+0x9e>
    4460:	0e c0       	rjmp	.+28     	; 0x447e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4462:	01 96       	adiw	r24, 0x01	; 1
    4464:	84 36       	cpi	r24, 0x64	; 100
    4466:	91 05       	cpc	r25, r1
    4468:	28 f4       	brcc	.+10     	; 0x4474 <__vector_25+0x8e>
    446a:	80 93 8e 32 	sts	0x328E, r24	; 0x80328e <rcvC0_read_index>
    446e:	90 93 8f 32 	sts	0x328F, r25	; 0x80328f <rcvC0_read_index+0x1>
    4472:	08 c0       	rjmp	.+16     	; 0x4484 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    4474:	10 92 8e 32 	sts	0x328E, r1	; 0x80328e <rcvC0_read_index>
    4478:	10 92 8f 32 	sts	0x328F, r1	; 0x80328f <rcvC0_read_index+0x1>
}
    447c:	03 c0       	rjmp	.+6      	; 0x4484 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    447e:	81 e0       	ldi	r24, 0x01	; 1
    4480:	90 e0       	ldi	r25, 0x00	; 0
    4482:	f3 cf       	rjmp	.-26     	; 0x446a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    4484:	ff 91       	pop	r31
    4486:	ef 91       	pop	r30
    4488:	9f 91       	pop	r25
    448a:	8f 91       	pop	r24
    448c:	3f 91       	pop	r19
    448e:	2f 91       	pop	r18
    4490:	0f 90       	pop	r0
    4492:	0b be       	out	0x3b, r0	; 59
    4494:	0f 90       	pop	r0
    4496:	08 be       	out	0x38, r0	; 56
    4498:	0f 90       	pop	r0
    449a:	0f be       	out	0x3f, r0	; 63
    449c:	0f 90       	pop	r0
    449e:	1f 90       	pop	r1
    44a0:	18 95       	reti

000044a2 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    44a2:	1f 92       	push	r1
    44a4:	0f 92       	push	r0
    44a6:	0f b6       	in	r0, 0x3f	; 63
    44a8:	0f 92       	push	r0
    44aa:	11 24       	eor	r1, r1
    44ac:	08 b6       	in	r0, 0x38	; 56
    44ae:	0f 92       	push	r0
    44b0:	18 be       	out	0x38, r1	; 56
    44b2:	0b b6       	in	r0, 0x3b	; 59
    44b4:	0f 92       	push	r0
    44b6:	1b be       	out	0x3b, r1	; 59
    44b8:	2f 93       	push	r18
    44ba:	3f 93       	push	r19
    44bc:	8f 93       	push	r24
    44be:	9f 93       	push	r25
    44c0:	ef 93       	push	r30
    44c2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    44c4:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    44c8:	e0 91 96 32 	lds	r30, 0x3296	; 0x803296 <rcvC1_buffer>
    44cc:	f0 91 97 32 	lds	r31, 0x3297	; 0x803297 <rcvC1_buffer+0x1>
    44d0:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <rcvC1_write_index>
    44d4:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <rcvC1_write_index+0x1>
    44d8:	e8 0f       	add	r30, r24
    44da:	f9 1f       	adc	r31, r25
    44dc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    44de:	80 91 82 32 	lds	r24, 0x3282	; 0x803282 <rcvC1_write_index>
    44e2:	90 91 83 32 	lds	r25, 0x3283	; 0x803283 <rcvC1_write_index+0x1>
    44e6:	01 96       	adiw	r24, 0x01	; 1
    44e8:	84 36       	cpi	r24, 0x64	; 100
    44ea:	91 05       	cpc	r25, r1
    44ec:	60 f4       	brcc	.+24     	; 0x4506 <__vector_28+0x64>
    44ee:	80 93 82 32 	sts	0x3282, r24	; 0x803282 <rcvC1_write_index>
    44f2:	90 93 83 32 	sts	0x3283, r25	; 0x803283 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    44f6:	20 91 8c 32 	lds	r18, 0x328C	; 0x80328c <rcvC1_read_index>
    44fa:	30 91 8d 32 	lds	r19, 0x328D	; 0x80328d <rcvC1_read_index+0x1>
    44fe:	82 17       	cp	r24, r18
    4500:	93 07       	cpc	r25, r19
    4502:	f1 f4       	brne	.+60     	; 0x4540 <__vector_28+0x9e>
    4504:	0c c0       	rjmp	.+24     	; 0x451e <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4506:	10 92 82 32 	sts	0x3282, r1	; 0x803282 <rcvC1_write_index>
    450a:	10 92 83 32 	sts	0x3283, r1	; 0x803283 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    450e:	80 91 8c 32 	lds	r24, 0x328C	; 0x80328c <rcvC1_read_index>
    4512:	90 91 8d 32 	lds	r25, 0x328D	; 0x80328d <rcvC1_read_index+0x1>
    4516:	18 16       	cp	r1, r24
    4518:	19 06       	cpc	r1, r25
    451a:	91 f4       	brne	.+36     	; 0x4540 <__vector_28+0x9e>
    451c:	0e c0       	rjmp	.+28     	; 0x453a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    451e:	01 96       	adiw	r24, 0x01	; 1
    4520:	84 36       	cpi	r24, 0x64	; 100
    4522:	91 05       	cpc	r25, r1
    4524:	28 f4       	brcc	.+10     	; 0x4530 <__vector_28+0x8e>
    4526:	80 93 8c 32 	sts	0x328C, r24	; 0x80328c <rcvC1_read_index>
    452a:	90 93 8d 32 	sts	0x328D, r25	; 0x80328d <rcvC1_read_index+0x1>
    452e:	08 c0       	rjmp	.+16     	; 0x4540 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    4530:	10 92 8c 32 	sts	0x328C, r1	; 0x80328c <rcvC1_read_index>
    4534:	10 92 8d 32 	sts	0x328D, r1	; 0x80328d <rcvC1_read_index+0x1>
}
    4538:	03 c0       	rjmp	.+6      	; 0x4540 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    453a:	81 e0       	ldi	r24, 0x01	; 1
    453c:	90 e0       	ldi	r25, 0x00	; 0
    453e:	f3 cf       	rjmp	.-26     	; 0x4526 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    4540:	ff 91       	pop	r31
    4542:	ef 91       	pop	r30
    4544:	9f 91       	pop	r25
    4546:	8f 91       	pop	r24
    4548:	3f 91       	pop	r19
    454a:	2f 91       	pop	r18
    454c:	0f 90       	pop	r0
    454e:	0b be       	out	0x3b, r0	; 59
    4550:	0f 90       	pop	r0
    4552:	08 be       	out	0x38, r0	; 56
    4554:	0f 90       	pop	r0
    4556:	0f be       	out	0x3f, r0	; 63
    4558:	0f 90       	pop	r0
    455a:	1f 90       	pop	r1
    455c:	18 95       	reti

0000455e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    455e:	1f 92       	push	r1
    4560:	0f 92       	push	r0
    4562:	0f b6       	in	r0, 0x3f	; 63
    4564:	0f 92       	push	r0
    4566:	11 24       	eor	r1, r1
    4568:	08 b6       	in	r0, 0x38	; 56
    456a:	0f 92       	push	r0
    456c:	18 be       	out	0x38, r1	; 56
    456e:	0b b6       	in	r0, 0x3b	; 59
    4570:	0f 92       	push	r0
    4572:	1b be       	out	0x3b, r1	; 59
    4574:	2f 93       	push	r18
    4576:	3f 93       	push	r19
    4578:	8f 93       	push	r24
    457a:	9f 93       	push	r25
    457c:	ef 93       	push	r30
    457e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    4580:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    4584:	e0 91 94 32 	lds	r30, 0x3294	; 0x803294 <rcvD0_buffer>
    4588:	f0 91 95 32 	lds	r31, 0x3295	; 0x803295 <rcvD0_buffer+0x1>
    458c:	80 91 84 32 	lds	r24, 0x3284	; 0x803284 <rcvC0_write_index>
    4590:	90 91 85 32 	lds	r25, 0x3285	; 0x803285 <rcvC0_write_index+0x1>
    4594:	e8 0f       	add	r30, r24
    4596:	f9 1f       	adc	r31, r25
    4598:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    459a:	80 91 80 32 	lds	r24, 0x3280	; 0x803280 <rcvD0_write_index>
    459e:	90 91 81 32 	lds	r25, 0x3281	; 0x803281 <rcvD0_write_index+0x1>
    45a2:	01 96       	adiw	r24, 0x01	; 1
    45a4:	84 36       	cpi	r24, 0x64	; 100
    45a6:	91 05       	cpc	r25, r1
    45a8:	60 f4       	brcc	.+24     	; 0x45c2 <__vector_88+0x64>
    45aa:	80 93 80 32 	sts	0x3280, r24	; 0x803280 <rcvD0_write_index>
    45ae:	90 93 81 32 	sts	0x3281, r25	; 0x803281 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    45b2:	20 91 8a 32 	lds	r18, 0x328A	; 0x80328a <rcvD0_read_index>
    45b6:	30 91 8b 32 	lds	r19, 0x328B	; 0x80328b <rcvD0_read_index+0x1>
    45ba:	82 17       	cp	r24, r18
    45bc:	93 07       	cpc	r25, r19
    45be:	f1 f4       	brne	.+60     	; 0x45fc <__vector_88+0x9e>
    45c0:	0c c0       	rjmp	.+24     	; 0x45da <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    45c2:	10 92 80 32 	sts	0x3280, r1	; 0x803280 <rcvD0_write_index>
    45c6:	10 92 81 32 	sts	0x3281, r1	; 0x803281 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    45ca:	80 91 8a 32 	lds	r24, 0x328A	; 0x80328a <rcvD0_read_index>
    45ce:	90 91 8b 32 	lds	r25, 0x328B	; 0x80328b <rcvD0_read_index+0x1>
    45d2:	18 16       	cp	r1, r24
    45d4:	19 06       	cpc	r1, r25
    45d6:	91 f4       	brne	.+36     	; 0x45fc <__vector_88+0x9e>
    45d8:	0e c0       	rjmp	.+28     	; 0x45f6 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    45da:	01 96       	adiw	r24, 0x01	; 1
    45dc:	84 36       	cpi	r24, 0x64	; 100
    45de:	91 05       	cpc	r25, r1
    45e0:	28 f4       	brcc	.+10     	; 0x45ec <__vector_88+0x8e>
    45e2:	80 93 8a 32 	sts	0x328A, r24	; 0x80328a <rcvD0_read_index>
    45e6:	90 93 8b 32 	sts	0x328B, r25	; 0x80328b <rcvD0_read_index+0x1>
    45ea:	08 c0       	rjmp	.+16     	; 0x45fc <__vector_88+0x9e>
	rcvD0_read_index = 0;
    45ec:	10 92 8a 32 	sts	0x328A, r1	; 0x80328a <rcvD0_read_index>
    45f0:	10 92 8b 32 	sts	0x328B, r1	; 0x80328b <rcvD0_read_index+0x1>
}
    45f4:	03 c0       	rjmp	.+6      	; 0x45fc <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    45f6:	81 e0       	ldi	r24, 0x01	; 1
    45f8:	90 e0       	ldi	r25, 0x00	; 0
    45fa:	f3 cf       	rjmp	.-26     	; 0x45e2 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    45fc:	ff 91       	pop	r31
    45fe:	ef 91       	pop	r30
    4600:	9f 91       	pop	r25
    4602:	8f 91       	pop	r24
    4604:	3f 91       	pop	r19
    4606:	2f 91       	pop	r18
    4608:	0f 90       	pop	r0
    460a:	0b be       	out	0x3b, r0	; 59
    460c:	0f 90       	pop	r0
    460e:	08 be       	out	0x38, r0	; 56
    4610:	0f 90       	pop	r0
    4612:	0f be       	out	0x3f, r0	; 63
    4614:	0f 90       	pop	r0
    4616:	1f 90       	pop	r1
    4618:	18 95       	reti

0000461a <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    461a:	1f 92       	push	r1
    461c:	0f 92       	push	r0
    461e:	0f b6       	in	r0, 0x3f	; 63
    4620:	0f 92       	push	r0
    4622:	11 24       	eor	r1, r1
    4624:	08 b6       	in	r0, 0x38	; 56
    4626:	0f 92       	push	r0
    4628:	18 be       	out	0x38, r1	; 56
    462a:	0b b6       	in	r0, 0x3b	; 59
    462c:	0f 92       	push	r0
    462e:	1b be       	out	0x3b, r1	; 59
    4630:	2f 93       	push	r18
    4632:	3f 93       	push	r19
    4634:	8f 93       	push	r24
    4636:	9f 93       	push	r25
    4638:	ef 93       	push	r30
    463a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    463c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4640:	e0 91 92 32 	lds	r30, 0x3292	; 0x803292 <rcvD1_buffer>
    4644:	f0 91 93 32 	lds	r31, 0x3293	; 0x803293 <rcvD1_buffer+0x1>
    4648:	80 91 7e 32 	lds	r24, 0x327E	; 0x80327e <rcvD1_write_index>
    464c:	90 91 7f 32 	lds	r25, 0x327F	; 0x80327f <rcvD1_write_index+0x1>
    4650:	e8 0f       	add	r30, r24
    4652:	f9 1f       	adc	r31, r25
    4654:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4656:	80 91 7e 32 	lds	r24, 0x327E	; 0x80327e <rcvD1_write_index>
    465a:	90 91 7f 32 	lds	r25, 0x327F	; 0x80327f <rcvD1_write_index+0x1>
    465e:	01 96       	adiw	r24, 0x01	; 1
    4660:	84 36       	cpi	r24, 0x64	; 100
    4662:	91 05       	cpc	r25, r1
    4664:	60 f4       	brcc	.+24     	; 0x467e <__vector_91+0x64>
    4666:	80 93 7e 32 	sts	0x327E, r24	; 0x80327e <rcvD1_write_index>
    466a:	90 93 7f 32 	sts	0x327F, r25	; 0x80327f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    466e:	20 91 88 32 	lds	r18, 0x3288	; 0x803288 <rcvD1_read_index>
    4672:	30 91 89 32 	lds	r19, 0x3289	; 0x803289 <rcvD1_read_index+0x1>
    4676:	82 17       	cp	r24, r18
    4678:	93 07       	cpc	r25, r19
    467a:	f1 f4       	brne	.+60     	; 0x46b8 <__vector_91+0x9e>
    467c:	0c c0       	rjmp	.+24     	; 0x4696 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    467e:	10 92 7e 32 	sts	0x327E, r1	; 0x80327e <rcvD1_write_index>
    4682:	10 92 7f 32 	sts	0x327F, r1	; 0x80327f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4686:	80 91 88 32 	lds	r24, 0x3288	; 0x803288 <rcvD1_read_index>
    468a:	90 91 89 32 	lds	r25, 0x3289	; 0x803289 <rcvD1_read_index+0x1>
    468e:	18 16       	cp	r1, r24
    4690:	19 06       	cpc	r1, r25
    4692:	91 f4       	brne	.+36     	; 0x46b8 <__vector_91+0x9e>
    4694:	0e c0       	rjmp	.+28     	; 0x46b2 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4696:	01 96       	adiw	r24, 0x01	; 1
    4698:	84 36       	cpi	r24, 0x64	; 100
    469a:	91 05       	cpc	r25, r1
    469c:	28 f4       	brcc	.+10     	; 0x46a8 <__vector_91+0x8e>
    469e:	80 93 88 32 	sts	0x3288, r24	; 0x803288 <rcvD1_read_index>
    46a2:	90 93 89 32 	sts	0x3289, r25	; 0x803289 <rcvD1_read_index+0x1>
    46a6:	08 c0       	rjmp	.+16     	; 0x46b8 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    46a8:	10 92 88 32 	sts	0x3288, r1	; 0x803288 <rcvD1_read_index>
    46ac:	10 92 89 32 	sts	0x3289, r1	; 0x803289 <rcvD1_read_index+0x1>
}
    46b0:	03 c0       	rjmp	.+6      	; 0x46b8 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    46b2:	81 e0       	ldi	r24, 0x01	; 1
    46b4:	90 e0       	ldi	r25, 0x00	; 0
    46b6:	f3 cf       	rjmp	.-26     	; 0x469e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    46b8:	ff 91       	pop	r31
    46ba:	ef 91       	pop	r30
    46bc:	9f 91       	pop	r25
    46be:	8f 91       	pop	r24
    46c0:	3f 91       	pop	r19
    46c2:	2f 91       	pop	r18
    46c4:	0f 90       	pop	r0
    46c6:	0b be       	out	0x3b, r0	; 59
    46c8:	0f 90       	pop	r0
    46ca:	08 be       	out	0x38, r0	; 56
    46cc:	0f 90       	pop	r0
    46ce:	0f be       	out	0x3f, r0	; 63
    46d0:	0f 90       	pop	r0
    46d2:	1f 90       	pop	r1
    46d4:	18 95       	reti

000046d6 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    46d6:	1f 92       	push	r1
    46d8:	0f 92       	push	r0
    46da:	0f b6       	in	r0, 0x3f	; 63
    46dc:	0f 92       	push	r0
    46de:	11 24       	eor	r1, r1
    46e0:	08 b6       	in	r0, 0x38	; 56
    46e2:	0f 92       	push	r0
    46e4:	18 be       	out	0x38, r1	; 56
    46e6:	0b b6       	in	r0, 0x3b	; 59
    46e8:	0f 92       	push	r0
    46ea:	1b be       	out	0x3b, r1	; 59
    46ec:	2f 93       	push	r18
    46ee:	3f 93       	push	r19
    46f0:	8f 93       	push	r24
    46f2:	9f 93       	push	r25
    46f4:	ef 93       	push	r30
    46f6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    46f8:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    46fc:	e0 91 90 32 	lds	r30, 0x3290	; 0x803290 <rcvE0_buffer>
    4700:	f0 91 91 32 	lds	r31, 0x3291	; 0x803291 <rcvE0_buffer+0x1>
    4704:	80 91 7c 32 	lds	r24, 0x327C	; 0x80327c <rcvE0_write_index>
    4708:	90 91 7d 32 	lds	r25, 0x327D	; 0x80327d <rcvE0_write_index+0x1>
    470c:	e8 0f       	add	r30, r24
    470e:	f9 1f       	adc	r31, r25
    4710:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4712:	80 91 7c 32 	lds	r24, 0x327C	; 0x80327c <rcvE0_write_index>
    4716:	90 91 7d 32 	lds	r25, 0x327D	; 0x80327d <rcvE0_write_index+0x1>
    471a:	01 96       	adiw	r24, 0x01	; 1
    471c:	84 36       	cpi	r24, 0x64	; 100
    471e:	91 05       	cpc	r25, r1
    4720:	60 f4       	brcc	.+24     	; 0x473a <__vector_58+0x64>
    4722:	80 93 7c 32 	sts	0x327C, r24	; 0x80327c <rcvE0_write_index>
    4726:	90 93 7d 32 	sts	0x327D, r25	; 0x80327d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    472a:	20 91 86 32 	lds	r18, 0x3286	; 0x803286 <rcvE0_read_index>
    472e:	30 91 87 32 	lds	r19, 0x3287	; 0x803287 <rcvE0_read_index+0x1>
    4732:	82 17       	cp	r24, r18
    4734:	93 07       	cpc	r25, r19
    4736:	f1 f4       	brne	.+60     	; 0x4774 <__vector_58+0x9e>
    4738:	0c c0       	rjmp	.+24     	; 0x4752 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    473a:	10 92 7c 32 	sts	0x327C, r1	; 0x80327c <rcvE0_write_index>
    473e:	10 92 7d 32 	sts	0x327D, r1	; 0x80327d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4742:	80 91 86 32 	lds	r24, 0x3286	; 0x803286 <rcvE0_read_index>
    4746:	90 91 87 32 	lds	r25, 0x3287	; 0x803287 <rcvE0_read_index+0x1>
    474a:	18 16       	cp	r1, r24
    474c:	19 06       	cpc	r1, r25
    474e:	91 f4       	brne	.+36     	; 0x4774 <__vector_58+0x9e>
    4750:	0e c0       	rjmp	.+28     	; 0x476e <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4752:	01 96       	adiw	r24, 0x01	; 1
    4754:	84 36       	cpi	r24, 0x64	; 100
    4756:	91 05       	cpc	r25, r1
    4758:	28 f4       	brcc	.+10     	; 0x4764 <__vector_58+0x8e>
    475a:	80 93 86 32 	sts	0x3286, r24	; 0x803286 <rcvE0_read_index>
    475e:	90 93 87 32 	sts	0x3287, r25	; 0x803287 <rcvE0_read_index+0x1>
    4762:	08 c0       	rjmp	.+16     	; 0x4774 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    4764:	10 92 86 32 	sts	0x3286, r1	; 0x803286 <rcvE0_read_index>
    4768:	10 92 87 32 	sts	0x3287, r1	; 0x803287 <rcvE0_read_index+0x1>
}
    476c:	03 c0       	rjmp	.+6      	; 0x4774 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    476e:	81 e0       	ldi	r24, 0x01	; 1
    4770:	90 e0       	ldi	r25, 0x00	; 0
    4772:	f3 cf       	rjmp	.-26     	; 0x475a <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    4774:	ff 91       	pop	r31
    4776:	ef 91       	pop	r30
    4778:	9f 91       	pop	r25
    477a:	8f 91       	pop	r24
    477c:	3f 91       	pop	r19
    477e:	2f 91       	pop	r18
    4780:	0f 90       	pop	r0
    4782:	0b be       	out	0x3b, r0	; 59
    4784:	0f 90       	pop	r0
    4786:	08 be       	out	0x38, r0	; 56
    4788:	0f 90       	pop	r0
    478a:	0f be       	out	0x3f, r0	; 63
    478c:	0f 90       	pop	r0
    478e:	1f 90       	pop	r1
    4790:	18 95       	reti

00004792 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4792:	fc 01       	movw	r30, r24
    4794:	84 81       	ldd	r24, Z+4	; 0x04
    4796:	95 81       	ldd	r25, Z+5	; 0x05
    4798:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
		}
    479c:	90 e0       	ldi	r25, 0x00	; 0
    479e:	08 95       	ret

000047a0 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    47a0:	fc 01       	movw	r30, r24
    47a2:	84 81       	ldd	r24, Z+4	; 0x04
    47a4:	95 81       	ldd	r25, Z+5	; 0x05
    47a6:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    47aa:	91 e0       	ldi	r25, 0x01	; 1
    47ac:	81 11       	cpse	r24, r1
    47ae:	01 c0       	rjmp	.+2      	; 0x47b2 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    47b0:	90 e0       	ldi	r25, 0x00	; 0
		}
    47b2:	89 2f       	mov	r24, r25
    47b4:	08 95       	ret

000047b6 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    47b6:	fc 01       	movw	r30, r24
    47b8:	84 81       	ldd	r24, Z+4	; 0x04
    47ba:	95 81       	ldd	r25, Z+5	; 0x05
    47bc:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    47c0:	91 e0       	ldi	r25, 0x01	; 1
    47c2:	81 11       	cpse	r24, r1
    47c4:	90 e0       	ldi	r25, 0x00	; 0
		}
    47c6:	89 2f       	mov	r24, r25
    47c8:	08 95       	ret

000047ca <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    47ca:	fc 01       	movw	r30, r24
    47cc:	84 81       	ldd	r24, Z+4	; 0x04
    47ce:	95 81       	ldd	r25, Z+5	; 0x05
    47d0:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
		}
    47d4:	90 e0       	ldi	r25, 0x00	; 0
    47d6:	08 95       	ret

000047d8 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    47d8:	fc 01       	movw	r30, r24
    47da:	84 81       	ldd	r24, Z+4	; 0x04
    47dc:	95 81       	ldd	r25, Z+5	; 0x05
    47de:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    47e2:	91 e0       	ldi	r25, 0x01	; 1
    47e4:	81 11       	cpse	r24, r1
    47e6:	01 c0       	rjmp	.+2      	; 0x47ea <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    47e8:	90 e0       	ldi	r25, 0x00	; 0
		}
    47ea:	89 2f       	mov	r24, r25
    47ec:	08 95       	ret

000047ee <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    47ee:	fc 01       	movw	r30, r24
    47f0:	84 81       	ldd	r24, Z+4	; 0x04
    47f2:	95 81       	ldd	r25, Z+5	; 0x05
    47f4:	0e 94 be 14 	call	0x297c	; 0x297c <uxQueueMessagesWaitingFromISR>
    47f8:	91 e0       	ldi	r25, 0x01	; 1
    47fa:	81 11       	cpse	r24, r1
    47fc:	90 e0       	ldi	r25, 0x00	; 0
		}
    47fe:	89 2f       	mov	r24, r25
    4800:	08 95       	ret

00004802 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4802:	fc 01       	movw	r30, r24
    4804:	84 81       	ldd	r24, Z+4	; 0x04
    4806:	95 81       	ldd	r25, Z+5	; 0x05
    4808:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
		}
    480c:	90 e0       	ldi	r25, 0x00	; 0
    480e:	08 95       	ret

00004810 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4810:	fc 01       	movw	r30, r24
    4812:	84 81       	ldd	r24, Z+4	; 0x04
    4814:	95 81       	ldd	r25, Z+5	; 0x05
    4816:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    481a:	91 e0       	ldi	r25, 0x01	; 1
    481c:	81 11       	cpse	r24, r1
    481e:	01 c0       	rjmp	.+2      	; 0x4822 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4820:	90 e0       	ldi	r25, 0x00	; 0
		}
    4822:	89 2f       	mov	r24, r25
    4824:	08 95       	ret

00004826 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4826:	fc 01       	movw	r30, r24
    4828:	84 81       	ldd	r24, Z+4	; 0x04
    482a:	95 81       	ldd	r25, Z+5	; 0x05
    482c:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    4830:	91 e0       	ldi	r25, 0x01	; 1
    4832:	81 11       	cpse	r24, r1
    4834:	90 e0       	ldi	r25, 0x00	; 0
		}
    4836:	89 2f       	mov	r24, r25
    4838:	08 95       	ret

0000483a <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    483a:	fc 01       	movw	r30, r24
    483c:	84 81       	ldd	r24, Z+4	; 0x04
    483e:	95 81       	ldd	r25, Z+5	; 0x05
    4840:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
		}
    4844:	90 e0       	ldi	r25, 0x00	; 0
    4846:	08 95       	ret

00004848 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4848:	fc 01       	movw	r30, r24
    484a:	84 81       	ldd	r24, Z+4	; 0x04
    484c:	95 81       	ldd	r25, Z+5	; 0x05
    484e:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    4852:	91 e0       	ldi	r25, 0x01	; 1
    4854:	81 11       	cpse	r24, r1
    4856:	01 c0       	rjmp	.+2      	; 0x485a <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4858:	90 e0       	ldi	r25, 0x00	; 0
		}
    485a:	89 2f       	mov	r24, r25
    485c:	08 95       	ret

0000485e <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    485e:	fc 01       	movw	r30, r24
    4860:	84 81       	ldd	r24, Z+4	; 0x04
    4862:	95 81       	ldd	r25, Z+5	; 0x05
    4864:	0e 94 b6 14 	call	0x296c	; 0x296c <uxQueueMessagesWaiting>
    4868:	91 e0       	ldi	r25, 0x01	; 1
    486a:	81 11       	cpse	r24, r1
    486c:	90 e0       	ldi	r25, 0x00	; 0
		}
    486e:	89 2f       	mov	r24, r25
    4870:	08 95       	ret

00004872 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4872:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4874:	01 e0       	ldi	r16, 0x01	; 1
    4876:	2f ef       	ldi	r18, 0xFF	; 255
    4878:	3f ef       	ldi	r19, 0xFF	; 255
    487a:	a9 01       	movw	r20, r18
    487c:	fc 01       	movw	r30, r24
    487e:	84 81       	ldd	r24, Z+4	; 0x04
    4880:	95 81       	ldd	r25, Z+5	; 0x05
    4882:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    4886:	0f 91       	pop	r16
    4888:	08 95       	ret

0000488a <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    488a:	0f 93       	push	r16
    488c:	cf 93       	push	r28
    488e:	df 93       	push	r29
    4890:	1f 92       	push	r1
    4892:	1f 92       	push	r1
    4894:	cd b7       	in	r28, 0x3d	; 61
    4896:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4898:	01 e0       	ldi	r16, 0x01	; 1
    489a:	2f ef       	ldi	r18, 0xFF	; 255
    489c:	3f ef       	ldi	r19, 0xFF	; 255
    489e:	a9 01       	movw	r20, r18
    48a0:	be 01       	movw	r22, r28
    48a2:	6f 5f       	subi	r22, 0xFF	; 255
    48a4:	7f 4f       	sbci	r23, 0xFF	; 255
    48a6:	fc 01       	movw	r30, r24
    48a8:	84 81       	ldd	r24, Z+4	; 0x04
    48aa:	95 81       	ldd	r25, Z+5	; 0x05
    48ac:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    48b0:	89 81       	ldd	r24, Y+1	; 0x01
    48b2:	9a 81       	ldd	r25, Y+2	; 0x02
    48b4:	0f 90       	pop	r0
    48b6:	0f 90       	pop	r0
    48b8:	df 91       	pop	r29
    48ba:	cf 91       	pop	r28
    48bc:	0f 91       	pop	r16
    48be:	08 95       	ret

000048c0 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    48c0:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    48c2:	00 e0       	ldi	r16, 0x00	; 0
    48c4:	2f ef       	ldi	r18, 0xFF	; 255
    48c6:	3f ef       	ldi	r19, 0xFF	; 255
    48c8:	a9 01       	movw	r20, r18
    48ca:	fc 01       	movw	r30, r24
    48cc:	84 81       	ldd	r24, Z+4	; 0x04
    48ce:	95 81       	ldd	r25, Z+5	; 0x05
    48d0:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    48d4:	0f 91       	pop	r16
    48d6:	08 95       	ret

000048d8 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    48d8:	0f 93       	push	r16
    48da:	cf 93       	push	r28
    48dc:	df 93       	push	r29
    48de:	1f 92       	push	r1
    48e0:	1f 92       	push	r1
    48e2:	cd b7       	in	r28, 0x3d	; 61
    48e4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    48e6:	00 e0       	ldi	r16, 0x00	; 0
    48e8:	2f ef       	ldi	r18, 0xFF	; 255
    48ea:	3f ef       	ldi	r19, 0xFF	; 255
    48ec:	a9 01       	movw	r20, r18
    48ee:	be 01       	movw	r22, r28
    48f0:	6f 5f       	subi	r22, 0xFF	; 255
    48f2:	7f 4f       	sbci	r23, 0xFF	; 255
    48f4:	fc 01       	movw	r30, r24
    48f6:	84 81       	ldd	r24, Z+4	; 0x04
    48f8:	95 81       	ldd	r25, Z+5	; 0x05
    48fa:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    48fe:	89 81       	ldd	r24, Y+1	; 0x01
    4900:	9a 81       	ldd	r25, Y+2	; 0x02
    4902:	0f 90       	pop	r0
    4904:	0f 90       	pop	r0
    4906:	df 91       	pop	r29
    4908:	cf 91       	pop	r28
    490a:	0f 91       	pop	r16
    490c:	08 95       	ret

0000490e <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    490e:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4910:	01 e0       	ldi	r16, 0x01	; 1
    4912:	2f ef       	ldi	r18, 0xFF	; 255
    4914:	3f ef       	ldi	r19, 0xFF	; 255
    4916:	a9 01       	movw	r20, r18
    4918:	fc 01       	movw	r30, r24
    491a:	84 81       	ldd	r24, Z+4	; 0x04
    491c:	95 81       	ldd	r25, Z+5	; 0x05
    491e:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    4922:	0f 91       	pop	r16
    4924:	08 95       	ret

00004926 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4926:	0f 93       	push	r16
    4928:	cf 93       	push	r28
    492a:	df 93       	push	r29
    492c:	1f 92       	push	r1
    492e:	1f 92       	push	r1
    4930:	cd b7       	in	r28, 0x3d	; 61
    4932:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4934:	01 e0       	ldi	r16, 0x01	; 1
    4936:	2f ef       	ldi	r18, 0xFF	; 255
    4938:	3f ef       	ldi	r19, 0xFF	; 255
    493a:	a9 01       	movw	r20, r18
    493c:	be 01       	movw	r22, r28
    493e:	6f 5f       	subi	r22, 0xFF	; 255
    4940:	7f 4f       	sbci	r23, 0xFF	; 255
    4942:	fc 01       	movw	r30, r24
    4944:	84 81       	ldd	r24, Z+4	; 0x04
    4946:	95 81       	ldd	r25, Z+5	; 0x05
    4948:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    494c:	89 81       	ldd	r24, Y+1	; 0x01
    494e:	9a 81       	ldd	r25, Y+2	; 0x02
    4950:	0f 90       	pop	r0
    4952:	0f 90       	pop	r0
    4954:	df 91       	pop	r29
    4956:	cf 91       	pop	r28
    4958:	0f 91       	pop	r16
    495a:	08 95       	ret

0000495c <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    495c:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    495e:	00 e0       	ldi	r16, 0x00	; 0
    4960:	2f ef       	ldi	r18, 0xFF	; 255
    4962:	3f ef       	ldi	r19, 0xFF	; 255
    4964:	a9 01       	movw	r20, r18
    4966:	fc 01       	movw	r30, r24
    4968:	84 81       	ldd	r24, Z+4	; 0x04
    496a:	95 81       	ldd	r25, Z+5	; 0x05
    496c:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
}
    4970:	0f 91       	pop	r16
    4972:	08 95       	ret

00004974 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4974:	0f 93       	push	r16
    4976:	cf 93       	push	r28
    4978:	df 93       	push	r29
    497a:	1f 92       	push	r1
    497c:	1f 92       	push	r1
    497e:	cd b7       	in	r28, 0x3d	; 61
    4980:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4982:	00 e0       	ldi	r16, 0x00	; 0
    4984:	2f ef       	ldi	r18, 0xFF	; 255
    4986:	3f ef       	ldi	r19, 0xFF	; 255
    4988:	a9 01       	movw	r20, r18
    498a:	be 01       	movw	r22, r28
    498c:	6f 5f       	subi	r22, 0xFF	; 255
    498e:	7f 4f       	sbci	r23, 0xFF	; 255
    4990:	fc 01       	movw	r30, r24
    4992:	84 81       	ldd	r24, Z+4	; 0x04
    4994:	95 81       	ldd	r25, Z+5	; 0x05
    4996:	0e 94 c5 13 	call	0x278a	; 0x278a <xQueueGenericReceive>
	return (recv_item);
}
    499a:	89 81       	ldd	r24, Y+1	; 0x01
    499c:	9a 81       	ldd	r25, Y+2	; 0x02
    499e:	0f 90       	pop	r0
    49a0:	0f 90       	pop	r0
    49a2:	df 91       	pop	r29
    49a4:	cf 91       	pop	r28
    49a6:	0f 91       	pop	r16
    49a8:	08 95       	ret

000049aa <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    49aa:	cf 93       	push	r28
    49ac:	df 93       	push	r29
    49ae:	1f 92       	push	r1
    49b0:	cd b7       	in	r28, 0x3d	; 61
    49b2:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    49b4:	ae 01       	movw	r20, r28
    49b6:	4f 5f       	subi	r20, 0xFF	; 255
    49b8:	5f 4f       	sbci	r21, 0xFF	; 255
    49ba:	fc 01       	movw	r30, r24
    49bc:	84 81       	ldd	r24, Z+4	; 0x04
    49be:	95 81       	ldd	r25, Z+5	; 0x05
    49c0:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
}
    49c4:	0f 90       	pop	r0
    49c6:	df 91       	pop	r29
    49c8:	cf 91       	pop	r28
    49ca:	08 95       	ret

000049cc <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    49cc:	cf 93       	push	r28
    49ce:	df 93       	push	r29
    49d0:	00 d0       	rcall	.+0      	; 0x49d2 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    49d2:	cd b7       	in	r28, 0x3d	; 61
    49d4:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    49d6:	ae 01       	movw	r20, r28
    49d8:	4d 5f       	subi	r20, 0xFD	; 253
    49da:	5f 4f       	sbci	r21, 0xFF	; 255
    49dc:	be 01       	movw	r22, r28
    49de:	6f 5f       	subi	r22, 0xFF	; 255
    49e0:	7f 4f       	sbci	r23, 0xFF	; 255
    49e2:	fc 01       	movw	r30, r24
    49e4:	84 81       	ldd	r24, Z+4	; 0x04
    49e6:	95 81       	ldd	r25, Z+5	; 0x05
    49e8:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
	return (recv_item);
}
    49ec:	89 81       	ldd	r24, Y+1	; 0x01
    49ee:	9a 81       	ldd	r25, Y+2	; 0x02
    49f0:	23 96       	adiw	r28, 0x03	; 3
    49f2:	cd bf       	out	0x3d, r28	; 61
    49f4:	de bf       	out	0x3e, r29	; 62
    49f6:	df 91       	pop	r29
    49f8:	cf 91       	pop	r28
    49fa:	08 95       	ret

000049fc <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    49fc:	cf 93       	push	r28
    49fe:	df 93       	push	r29
    4a00:	1f 92       	push	r1
    4a02:	cd b7       	in	r28, 0x3d	; 61
    4a04:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4a06:	ae 01       	movw	r20, r28
    4a08:	4f 5f       	subi	r20, 0xFF	; 255
    4a0a:	5f 4f       	sbci	r21, 0xFF	; 255
    4a0c:	fc 01       	movw	r30, r24
    4a0e:	84 81       	ldd	r24, Z+4	; 0x04
    4a10:	95 81       	ldd	r25, Z+5	; 0x05
    4a12:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
}
    4a16:	0f 90       	pop	r0
    4a18:	df 91       	pop	r29
    4a1a:	cf 91       	pop	r28
    4a1c:	08 95       	ret

00004a1e <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4a1e:	cf 93       	push	r28
    4a20:	df 93       	push	r29
    4a22:	00 d0       	rcall	.+0      	; 0x4a24 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4a24:	cd b7       	in	r28, 0x3d	; 61
    4a26:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4a28:	ae 01       	movw	r20, r28
    4a2a:	4d 5f       	subi	r20, 0xFD	; 253
    4a2c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a2e:	be 01       	movw	r22, r28
    4a30:	6f 5f       	subi	r22, 0xFF	; 255
    4a32:	7f 4f       	sbci	r23, 0xFF	; 255
    4a34:	fc 01       	movw	r30, r24
    4a36:	84 81       	ldd	r24, Z+4	; 0x04
    4a38:	95 81       	ldd	r25, Z+5	; 0x05
    4a3a:	0e 94 89 14 	call	0x2912	; 0x2912 <xQueueReceiveFromISR>
	return (recv_item);
}
    4a3e:	89 81       	ldd	r24, Y+1	; 0x01
    4a40:	9a 81       	ldd	r25, Y+2	; 0x02
    4a42:	23 96       	adiw	r28, 0x03	; 3
    4a44:	cd bf       	out	0x3d, r28	; 61
    4a46:	de bf       	out	0x3e, r29	; 62
    4a48:	df 91       	pop	r29
    4a4a:	cf 91       	pop	r28
    4a4c:	08 95       	ret

00004a4e <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4a4e:	cf 93       	push	r28
    4a50:	df 93       	push	r29
    4a52:	1f 92       	push	r1
    4a54:	cd b7       	in	r28, 0x3d	; 61
    4a56:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a58:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4a5a:	21 e0       	ldi	r18, 0x01	; 1
    4a5c:	ae 01       	movw	r20, r28
    4a5e:	4f 5f       	subi	r20, 0xFF	; 255
    4a60:	5f 4f       	sbci	r21, 0xFF	; 255
    4a62:	fc 01       	movw	r30, r24
    4a64:	84 81       	ldd	r24, Z+4	; 0x04
    4a66:	95 81       	ldd	r25, Z+5	; 0x05
    4a68:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a6c:	91 e0       	ldi	r25, 0x01	; 1
    4a6e:	81 11       	cpse	r24, r1
    4a70:	01 c0       	rjmp	.+2      	; 0x4a74 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4a72:	90 e0       	ldi	r25, 0x00	; 0
}
    4a74:	89 2f       	mov	r24, r25
    4a76:	0f 90       	pop	r0
    4a78:	df 91       	pop	r29
    4a7a:	cf 91       	pop	r28
    4a7c:	08 95       	ret

00004a7e <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4a7e:	cf 93       	push	r28
    4a80:	df 93       	push	r29
    4a82:	1f 92       	push	r1
    4a84:	cd b7       	in	r28, 0x3d	; 61
    4a86:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a88:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4a8a:	20 e0       	ldi	r18, 0x00	; 0
    4a8c:	ae 01       	movw	r20, r28
    4a8e:	4f 5f       	subi	r20, 0xFF	; 255
    4a90:	5f 4f       	sbci	r21, 0xFF	; 255
    4a92:	fc 01       	movw	r30, r24
    4a94:	84 81       	ldd	r24, Z+4	; 0x04
    4a96:	95 81       	ldd	r25, Z+5	; 0x05
    4a98:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a9c:	91 e0       	ldi	r25, 0x01	; 1
    4a9e:	81 11       	cpse	r24, r1
    4aa0:	01 c0       	rjmp	.+2      	; 0x4aa4 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4aa2:	90 e0       	ldi	r25, 0x00	; 0
}
    4aa4:	89 2f       	mov	r24, r25
    4aa6:	0f 90       	pop	r0
    4aa8:	df 91       	pop	r29
    4aaa:	cf 91       	pop	r28
    4aac:	08 95       	ret

00004aae <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4aae:	cf 93       	push	r28
    4ab0:	df 93       	push	r29
    4ab2:	1f 92       	push	r1
    4ab4:	cd b7       	in	r28, 0x3d	; 61
    4ab6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4ab8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4aba:	21 e0       	ldi	r18, 0x01	; 1
    4abc:	ae 01       	movw	r20, r28
    4abe:	4f 5f       	subi	r20, 0xFF	; 255
    4ac0:	5f 4f       	sbci	r21, 0xFF	; 255
    4ac2:	fc 01       	movw	r30, r24
    4ac4:	84 81       	ldd	r24, Z+4	; 0x04
    4ac6:	95 81       	ldd	r25, Z+5	; 0x05
    4ac8:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4acc:	91 e0       	ldi	r25, 0x01	; 1
    4ace:	81 11       	cpse	r24, r1
    4ad0:	01 c0       	rjmp	.+2      	; 0x4ad4 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4ad2:	90 e0       	ldi	r25, 0x00	; 0
}
    4ad4:	89 2f       	mov	r24, r25
    4ad6:	0f 90       	pop	r0
    4ad8:	df 91       	pop	r29
    4ada:	cf 91       	pop	r28
    4adc:	08 95       	ret

00004ade <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4ade:	cf 93       	push	r28
    4ae0:	df 93       	push	r29
    4ae2:	1f 92       	push	r1
    4ae4:	cd b7       	in	r28, 0x3d	; 61
    4ae6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4ae8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4aea:	20 e0       	ldi	r18, 0x00	; 0
    4aec:	ae 01       	movw	r20, r28
    4aee:	4f 5f       	subi	r20, 0xFF	; 255
    4af0:	5f 4f       	sbci	r21, 0xFF	; 255
    4af2:	fc 01       	movw	r30, r24
    4af4:	84 81       	ldd	r24, Z+4	; 0x04
    4af6:	95 81       	ldd	r25, Z+5	; 0x05
    4af8:	0e 94 99 13 	call	0x2732	; 0x2732 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4afc:	91 e0       	ldi	r25, 0x01	; 1
    4afe:	81 11       	cpse	r24, r1
    4b00:	01 c0       	rjmp	.+2      	; 0x4b04 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4b02:	90 e0       	ldi	r25, 0x00	; 0
}
    4b04:	89 2f       	mov	r24, r25
    4b06:	0f 90       	pop	r0
    4b08:	df 91       	pop	r29
    4b0a:	cf 91       	pop	r28
    4b0c:	08 95       	ret

00004b0e <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4b0e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4b10:	fc 01       	movw	r30, r24
    4b12:	26 81       	ldd	r18, Z+6	; 0x06
    4b14:	37 81       	ldd	r19, Z+7	; 0x07
    4b16:	40 85       	ldd	r20, Z+8	; 0x08
    4b18:	51 85       	ldd	r21, Z+9	; 0x09
    4b1a:	01 e0       	ldi	r16, 0x01	; 1
    4b1c:	84 81       	ldd	r24, Z+4	; 0x04
    4b1e:	95 81       	ldd	r25, Z+5	; 0x05
    4b20:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    4b24:	91 e0       	ldi	r25, 0x01	; 1
    4b26:	81 11       	cpse	r24, r1
    4b28:	01 c0       	rjmp	.+2      	; 0x4b2c <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4b2a:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b2c:	89 2f       	mov	r24, r25
    4b2e:	0f 91       	pop	r16
    4b30:	08 95       	ret

00004b32 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4b32:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4b34:	fc 01       	movw	r30, r24
    4b36:	26 81       	ldd	r18, Z+6	; 0x06
    4b38:	37 81       	ldd	r19, Z+7	; 0x07
    4b3a:	40 85       	ldd	r20, Z+8	; 0x08
    4b3c:	51 85       	ldd	r21, Z+9	; 0x09
    4b3e:	00 e0       	ldi	r16, 0x00	; 0
    4b40:	84 81       	ldd	r24, Z+4	; 0x04
    4b42:	95 81       	ldd	r25, Z+5	; 0x05
    4b44:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    4b48:	91 e0       	ldi	r25, 0x01	; 1
    4b4a:	81 11       	cpse	r24, r1
    4b4c:	01 c0       	rjmp	.+2      	; 0x4b50 <_ZN9frt_queueIjE3putERKj+0x1e>
    4b4e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b50:	89 2f       	mov	r24, r25
    4b52:	0f 91       	pop	r16
    4b54:	08 95       	ret

00004b56 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4b56:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4b58:	fc 01       	movw	r30, r24
    4b5a:	26 81       	ldd	r18, Z+6	; 0x06
    4b5c:	37 81       	ldd	r19, Z+7	; 0x07
    4b5e:	40 85       	ldd	r20, Z+8	; 0x08
    4b60:	51 85       	ldd	r21, Z+9	; 0x09
    4b62:	01 e0       	ldi	r16, 0x01	; 1
    4b64:	84 81       	ldd	r24, Z+4	; 0x04
    4b66:	95 81       	ldd	r25, Z+5	; 0x05
    4b68:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    4b6c:	91 e0       	ldi	r25, 0x01	; 1
    4b6e:	81 11       	cpse	r24, r1
    4b70:	01 c0       	rjmp	.+2      	; 0x4b74 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4b72:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b74:	89 2f       	mov	r24, r25
    4b76:	0f 91       	pop	r16
    4b78:	08 95       	ret

00004b7a <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4b7a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4b7c:	fc 01       	movw	r30, r24
    4b7e:	26 81       	ldd	r18, Z+6	; 0x06
    4b80:	37 81       	ldd	r19, Z+7	; 0x07
    4b82:	40 85       	ldd	r20, Z+8	; 0x08
    4b84:	51 85       	ldd	r21, Z+9	; 0x09
    4b86:	00 e0       	ldi	r16, 0x00	; 0
    4b88:	84 81       	ldd	r24, Z+4	; 0x04
    4b8a:	95 81       	ldd	r25, Z+5	; 0x05
    4b8c:	0e 94 fe 12 	call	0x25fc	; 0x25fc <xQueueGenericSend>
    4b90:	91 e0       	ldi	r25, 0x01	; 1
    4b92:	81 11       	cpse	r24, r1
    4b94:	01 c0       	rjmp	.+2      	; 0x4b98 <_ZN9frt_queueIiE3putERKi+0x1e>
    4b96:	90 e0       	ldi	r25, 0x00	; 0
		}
    4b98:	89 2f       	mov	r24, r25
    4b9a:	0f 91       	pop	r16
    4b9c:	08 95       	ret

00004b9e <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4b9e:	0f 93       	push	r16
    4ba0:	cf 93       	push	r28
    4ba2:	df 93       	push	r29
    4ba4:	1f 92       	push	r1
    4ba6:	cd b7       	in	r28, 0x3d	; 61
    4ba8:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4baa:	2f b7       	in	r18, 0x3f	; 63
    4bac:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4bae:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4bb0:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4bb2:	fc 01       	movw	r30, r24
    4bb4:	08 ed       	ldi	r16, 0xD8	; 216
    4bb6:	04 bf       	out	0x34, r16	; 52
    4bb8:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4bba:	89 81       	ldd	r24, Y+1	; 0x01
    4bbc:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4bbe:	0f 90       	pop	r0
    4bc0:	df 91       	pop	r29
    4bc2:	cf 91       	pop	r28
    4bc4:	0f 91       	pop	r16
    4bc6:	08 95       	ret

00004bc8 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4bc8:	ef 92       	push	r14
    4bca:	ff 92       	push	r15
    4bcc:	0f 93       	push	r16
    4bce:	1f 93       	push	r17
    4bd0:	cf 93       	push	r28
    4bd2:	df 93       	push	r29
    4bd4:	cd b7       	in	r28, 0x3d	; 61
    4bd6:	de b7       	in	r29, 0x3e	; 62
    4bd8:	c9 54       	subi	r28, 0x49	; 73
    4bda:	d1 09       	sbc	r29, r1
    4bdc:	cd bf       	out	0x3d, r28	; 61
    4bde:	de bf       	out	0x3e, r29	; 62
	cli();
    4be0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4be2:	e0 e5       	ldi	r30, 0x50	; 80
    4be4:	f0 e0       	ldi	r31, 0x00	; 0
    4be6:	80 81       	ld	r24, Z
    4be8:	82 60       	ori	r24, 0x02	; 2
    4bea:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4bec:	81 81       	ldd	r24, Z+1	; 0x01
    4bee:	81 ff       	sbrs	r24, 1
    4bf0:	fd cf       	rjmp	.-6      	; 0x4bec <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4bf2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4bf6:	68 7f       	andi	r22, 0xF8	; 248
    4bf8:	61 60       	ori	r22, 0x01	; 1
    4bfa:	80 e4       	ldi	r24, 0x40	; 64
    4bfc:	90 e0       	ldi	r25, 0x00	; 0
    4bfe:	0e 94 cf 25 	call	0x4b9e	; 0x4b9e <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4c02:	e0 e5       	ldi	r30, 0x50	; 80
    4c04:	f0 e0       	ldi	r31, 0x00	; 0
    4c06:	80 81       	ld	r24, Z
    4c08:	8e 7f       	andi	r24, 0xFE	; 254
    4c0a:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4c0c:	9d ef       	ldi	r25, 0xFD	; 253
    4c0e:	88 ed       	ldi	r24, 0xD8	; 216
    4c10:	08 b6       	in	r0, 0x38	; 56
    4c12:	18 be       	out	0x38, r1	; 56
    4c14:	84 bf       	out	0x34, r24	; 52
    4c16:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4c1a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4c1c:	40 ea       	ldi	r20, 0xA0	; 160
    4c1e:	5a e0       	ldi	r21, 0x0A	; 10
    4c20:	60 e0       	ldi	r22, 0x00	; 0
    4c22:	70 e0       	ldi	r23, 0x00	; 0
    4c24:	ce 01       	movw	r24, r28
    4c26:	01 96       	adiw	r24, 0x01	; 1
    4c28:	0e 94 73 21 	call	0x42e6	; 0x42e6 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4c2c:	67 e0       	ldi	r22, 0x07	; 7
    4c2e:	ce 01       	movw	r24, r28
    4c30:	01 96       	adiw	r24, 0x01	; 1
    4c32:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    4c36:	8c 01       	movw	r16, r24
    4c38:	6b e9       	ldi	r22, 0x9B	; 155
    4c3a:	71 e2       	ldi	r23, 0x21	; 33
    4c3c:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN8emstream4putsEPKc>
    4c40:	66 e0       	ldi	r22, 0x06	; 6
    4c42:	c8 01       	movw	r24, r16
    4c44:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
    4c48:	66 e0       	ldi	r22, 0x06	; 6
    4c4a:	0e 94 93 1f 	call	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4c4e:	8e 01       	movw	r16, r28
    4c50:	0f 5f       	subi	r16, 0xFF	; 255
    4c52:	1f 4f       	sbci	r17, 0xFF	; 255
    4c54:	20 e3       	ldi	r18, 0x30	; 48
    4c56:	32 ef       	ldi	r19, 0xF2	; 242
    4c58:	40 e0       	ldi	r20, 0x00	; 0
    4c5a:	50 e0       	ldi	r21, 0x00	; 0
    4c5c:	60 ea       	ldi	r22, 0xA0	; 160
    4c5e:	74 e0       	ldi	r23, 0x04	; 4
    4c60:	ce 01       	movw	r24, r28
    4c62:	4e 96       	adiw	r24, 0x1e	; 30
    4c64:	0e 94 99 08 	call	0x1132	; 0x1132 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>

	// I2CAgent i2cAgent();
	
	MMA8451 mma8451(&i2c, &ser_dev);
    4c68:	a8 01       	movw	r20, r16
    4c6a:	be 01       	movw	r22, r28
    4c6c:	62 5e       	subi	r22, 0xE2	; 226
    4c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    4c70:	ce 01       	movw	r24, r28
    4c72:	c7 96       	adiw	r24, 0x37	; 55
    4c74:	0e 94 4e 0a 	call	0x149c	; 0x149c <_ZN7MMA8451C1EP9I2CMasterP8emstream>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4c78:	82 e1       	ldi	r24, 0x12	; 18
    4c7a:	90 e0       	ldi	r25, 0x00	; 0
    4c7c:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    4c80:	20 e8       	ldi	r18, 0x80	; 128
    4c82:	30 e0       	ldi	r19, 0x00	; 0
    4c84:	40 e0       	ldi	r20, 0x00	; 0
    4c86:	6a eb       	ldi	r22, 0xBA	; 186
    4c88:	71 e2       	ldi	r23, 0x21	; 33
    4c8a:	0e 94 7a 0c 	call	0x18f4	; 0x18f4 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mma8451);
    4c8e:	88 e1       	ldi	r24, 0x18	; 24
    4c90:	90 e0       	ldi	r25, 0x00	; 0
    4c92:	0e 94 a8 1e 	call	0x3d50	; 0x3d50 <_Znwj>
    4c96:	9e 01       	movw	r18, r28
    4c98:	29 5c       	subi	r18, 0xC9	; 201
    4c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c9c:	79 01       	movw	r14, r18
    4c9e:	20 e8       	ldi	r18, 0x80	; 128
    4ca0:	30 e0       	ldi	r19, 0x00	; 0
    4ca2:	42 e0       	ldi	r20, 0x02	; 2
    4ca4:	62 ec       	ldi	r22, 0xC2	; 194
    4ca6:	71 e2       	ldi	r23, 0x21	; 33
    4ca8:	0e 94 5d 0c 	call	0x18ba	; 0x18ba <_ZN10task_sonarC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4cac:	87 e0       	ldi	r24, 0x07	; 7
    4cae:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4cb2:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4cb4:	0e 94 27 16 	call	0x2c4e	; 0x2c4e <vTaskStartScheduler>
}
    4cb8:	80 e0       	ldi	r24, 0x00	; 0
    4cba:	90 e0       	ldi	r25, 0x00	; 0
    4cbc:	c7 5b       	subi	r28, 0xB7	; 183
    4cbe:	df 4f       	sbci	r29, 0xFF	; 255
    4cc0:	cd bf       	out	0x3d, r28	; 61
    4cc2:	de bf       	out	0x3e, r29	; 62
    4cc4:	df 91       	pop	r29
    4cc6:	cf 91       	pop	r28
    4cc8:	1f 91       	pop	r17
    4cca:	0f 91       	pop	r16
    4ccc:	ff 90       	pop	r15
    4cce:	ef 90       	pop	r14
    4cd0:	08 95       	ret

00004cd2 <_GLOBAL__sub_I_counter>:
    4cd2:	cf 92       	push	r12
    4cd4:	df 92       	push	r13
    4cd6:	ef 92       	push	r14
    4cd8:	ff 92       	push	r15
    4cda:	0f 93       	push	r16
    4cdc:	1f 93       	push	r17
    4cde:	cf 93       	push	r28
    4ce0:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4ce2:	0a e0       	ldi	r16, 0x0A	; 10
    4ce4:	10 e0       	ldi	r17, 0x00	; 0
    4ce6:	20 e0       	ldi	r18, 0x00	; 0
    4ce8:	30 e0       	ldi	r19, 0x00	; 0
    4cea:	40 e0       	ldi	r20, 0x00	; 0
    4cec:	50 e0       	ldi	r21, 0x00	; 0
    4cee:	60 e2       	ldi	r22, 0x20	; 32
    4cf0:	70 e0       	ldi	r23, 0x00	; 0
    4cf2:	8c ec       	ldi	r24, 0xCC	; 204
    4cf4:	92 e3       	ldi	r25, 0x32	; 50
    4cf6:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4cfa:	c2 ec       	ldi	r28, 0xC2	; 194
    4cfc:	d2 e3       	ldi	r29, 0x32	; 50
    4cfe:	1a 82       	std	Y+2, r1	; 0x02
    4d00:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d02:	8c ec       	ldi	r24, 0xCC	; 204
    4d04:	91 e2       	ldi	r25, 0x21	; 33
    4d06:	88 83       	st	Y, r24
    4d08:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d0a:	40 e0       	ldi	r20, 0x00	; 0
    4d0c:	62 e0       	ldi	r22, 0x02	; 2
    4d0e:	8f ef       	ldi	r24, 0xFF	; 255
    4d10:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    4d14:	8c 83       	std	Y+4, r24	; 0x04
    4d16:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d18:	0f 2e       	mov	r0, r31
    4d1a:	fa e0       	ldi	r31, 0x0A	; 10
    4d1c:	cf 2e       	mov	r12, r31
    4d1e:	d1 2c       	mov	r13, r1
    4d20:	e1 2c       	mov	r14, r1
    4d22:	f1 2c       	mov	r15, r1
    4d24:	f0 2d       	mov	r31, r0
    4d26:	ce 82       	std	Y+6, r12	; 0x06
    4d28:	df 82       	std	Y+7, r13	; 0x07
    4d2a:	e8 86       	std	Y+8, r14	; 0x08
    4d2c:	f9 86       	std	Y+9, r15	; 0x09
    4d2e:	c8 eb       	ldi	r28, 0xB8	; 184
    4d30:	d2 e3       	ldi	r29, 0x32	; 50
    4d32:	1a 82       	std	Y+2, r1	; 0x02
    4d34:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d36:	00 ef       	ldi	r16, 0xF0	; 240
    4d38:	11 e2       	ldi	r17, 0x21	; 33
    4d3a:	08 83       	st	Y, r16
    4d3c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d3e:	40 e0       	ldi	r20, 0x00	; 0
    4d40:	62 e0       	ldi	r22, 0x02	; 2
    4d42:	8f ef       	ldi	r24, 0xFF	; 255
    4d44:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    4d48:	8c 83       	std	Y+4, r24	; 0x04
    4d4a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d4c:	ce 82       	std	Y+6, r12	; 0x06
    4d4e:	df 82       	std	Y+7, r13	; 0x07
    4d50:	e8 86       	std	Y+8, r14	; 0x08
    4d52:	f9 86       	std	Y+9, r15	; 0x09
    4d54:	ce ea       	ldi	r28, 0xAE	; 174
    4d56:	d2 e3       	ldi	r29, 0x32	; 50
    4d58:	1a 82       	std	Y+2, r1	; 0x02
    4d5a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d5c:	08 83       	st	Y, r16
    4d5e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d60:	40 e0       	ldi	r20, 0x00	; 0
    4d62:	62 e0       	ldi	r22, 0x02	; 2
    4d64:	8f ef       	ldi	r24, 0xFF	; 255
    4d66:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    4d6a:	8c 83       	std	Y+4, r24	; 0x04
    4d6c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d6e:	ce 82       	std	Y+6, r12	; 0x06
    4d70:	df 82       	std	Y+7, r13	; 0x07
    4d72:	e8 86       	std	Y+8, r14	; 0x08
    4d74:	f9 86       	std	Y+9, r15	; 0x09
    4d76:	c4 ea       	ldi	r28, 0xA4	; 164
    4d78:	d2 e3       	ldi	r29, 0x32	; 50
    4d7a:	1a 82       	std	Y+2, r1	; 0x02
    4d7c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d7e:	08 83       	st	Y, r16
    4d80:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d82:	40 e0       	ldi	r20, 0x00	; 0
    4d84:	62 e0       	ldi	r22, 0x02	; 2
    4d86:	8f ef       	ldi	r24, 0xFF	; 255
    4d88:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    4d8c:	8c 83       	std	Y+4, r24	; 0x04
    4d8e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d90:	ce 82       	std	Y+6, r12	; 0x06
    4d92:	df 82       	std	Y+7, r13	; 0x07
    4d94:	e8 86       	std	Y+8, r14	; 0x08
    4d96:	f9 86       	std	Y+9, r15	; 0x09
    4d98:	ca e9       	ldi	r28, 0x9A	; 154
    4d9a:	d2 e3       	ldi	r29, 0x32	; 50
    4d9c:	1a 82       	std	Y+2, r1	; 0x02
    4d9e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4da0:	08 83       	st	Y, r16
    4da2:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4da4:	40 e0       	ldi	r20, 0x00	; 0
    4da6:	62 e0       	ldi	r22, 0x02	; 2
    4da8:	8f ef       	ldi	r24, 0xFF	; 255
    4daa:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericCreate>
    4dae:	8c 83       	std	Y+4, r24	; 0x04
    4db0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4db2:	ce 82       	std	Y+6, r12	; 0x06
    4db4:	df 82       	std	Y+7, r13	; 0x07
    4db6:	e8 86       	std	Y+8, r14	; 0x08
    4db8:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4dba:	df 91       	pop	r29
    4dbc:	cf 91       	pop	r28
    4dbe:	1f 91       	pop	r17
    4dc0:	0f 91       	pop	r16
    4dc2:	ff 90       	pop	r15
    4dc4:	ef 90       	pop	r14
    4dc6:	df 90       	pop	r13
    4dc8:	cf 90       	pop	r12
    4dca:	08 95       	ret

00004dcc <__mulsi3>:
    4dcc:	db 01       	movw	r26, r22
    4dce:	8f 93       	push	r24
    4dd0:	9f 93       	push	r25
    4dd2:	0e 94 40 27 	call	0x4e80	; 0x4e80 <__muluhisi3>
    4dd6:	bf 91       	pop	r27
    4dd8:	af 91       	pop	r26
    4dda:	a2 9f       	mul	r26, r18
    4ddc:	80 0d       	add	r24, r0
    4dde:	91 1d       	adc	r25, r1
    4de0:	a3 9f       	mul	r26, r19
    4de2:	90 0d       	add	r25, r0
    4de4:	b2 9f       	mul	r27, r18
    4de6:	90 0d       	add	r25, r0
    4de8:	11 24       	eor	r1, r1
    4dea:	08 95       	ret

00004dec <__udivmodsi4>:
    4dec:	a1 e2       	ldi	r26, 0x21	; 33
    4dee:	1a 2e       	mov	r1, r26
    4df0:	aa 1b       	sub	r26, r26
    4df2:	bb 1b       	sub	r27, r27
    4df4:	fd 01       	movw	r30, r26
    4df6:	0d c0       	rjmp	.+26     	; 0x4e12 <__udivmodsi4_ep>

00004df8 <__udivmodsi4_loop>:
    4df8:	aa 1f       	adc	r26, r26
    4dfa:	bb 1f       	adc	r27, r27
    4dfc:	ee 1f       	adc	r30, r30
    4dfe:	ff 1f       	adc	r31, r31
    4e00:	a2 17       	cp	r26, r18
    4e02:	b3 07       	cpc	r27, r19
    4e04:	e4 07       	cpc	r30, r20
    4e06:	f5 07       	cpc	r31, r21
    4e08:	20 f0       	brcs	.+8      	; 0x4e12 <__udivmodsi4_ep>
    4e0a:	a2 1b       	sub	r26, r18
    4e0c:	b3 0b       	sbc	r27, r19
    4e0e:	e4 0b       	sbc	r30, r20
    4e10:	f5 0b       	sbc	r31, r21

00004e12 <__udivmodsi4_ep>:
    4e12:	66 1f       	adc	r22, r22
    4e14:	77 1f       	adc	r23, r23
    4e16:	88 1f       	adc	r24, r24
    4e18:	99 1f       	adc	r25, r25
    4e1a:	1a 94       	dec	r1
    4e1c:	69 f7       	brne	.-38     	; 0x4df8 <__udivmodsi4_loop>
    4e1e:	60 95       	com	r22
    4e20:	70 95       	com	r23
    4e22:	80 95       	com	r24
    4e24:	90 95       	com	r25
    4e26:	9b 01       	movw	r18, r22
    4e28:	ac 01       	movw	r20, r24
    4e2a:	bd 01       	movw	r22, r26
    4e2c:	cf 01       	movw	r24, r30
    4e2e:	08 95       	ret

00004e30 <__divmodsi4>:
    4e30:	05 2e       	mov	r0, r21
    4e32:	97 fb       	bst	r25, 7
    4e34:	1e f4       	brtc	.+6      	; 0x4e3c <__divmodsi4+0xc>
    4e36:	00 94       	com	r0
    4e38:	0e 94 2f 27 	call	0x4e5e	; 0x4e5e <__negsi2>
    4e3c:	57 fd       	sbrc	r21, 7
    4e3e:	07 d0       	rcall	.+14     	; 0x4e4e <__divmodsi4_neg2>
    4e40:	0e 94 f6 26 	call	0x4dec	; 0x4dec <__udivmodsi4>
    4e44:	07 fc       	sbrc	r0, 7
    4e46:	03 d0       	rcall	.+6      	; 0x4e4e <__divmodsi4_neg2>
    4e48:	4e f4       	brtc	.+18     	; 0x4e5c <__divmodsi4_exit>
    4e4a:	0c 94 2f 27 	jmp	0x4e5e	; 0x4e5e <__negsi2>

00004e4e <__divmodsi4_neg2>:
    4e4e:	50 95       	com	r21
    4e50:	40 95       	com	r20
    4e52:	30 95       	com	r19
    4e54:	21 95       	neg	r18
    4e56:	3f 4f       	sbci	r19, 0xFF	; 255
    4e58:	4f 4f       	sbci	r20, 0xFF	; 255
    4e5a:	5f 4f       	sbci	r21, 0xFF	; 255

00004e5c <__divmodsi4_exit>:
    4e5c:	08 95       	ret

00004e5e <__negsi2>:
    4e5e:	90 95       	com	r25
    4e60:	80 95       	com	r24
    4e62:	70 95       	com	r23
    4e64:	61 95       	neg	r22
    4e66:	7f 4f       	sbci	r23, 0xFF	; 255
    4e68:	8f 4f       	sbci	r24, 0xFF	; 255
    4e6a:	9f 4f       	sbci	r25, 0xFF	; 255
    4e6c:	08 95       	ret

00004e6e <__tablejump2__>:
    4e6e:	ee 0f       	add	r30, r30
    4e70:	ff 1f       	adc	r31, r31
    4e72:	88 1f       	adc	r24, r24
    4e74:	8b bf       	out	0x3b, r24	; 59
    4e76:	07 90       	elpm	r0, Z+
    4e78:	f6 91       	elpm	r31, Z
    4e7a:	e0 2d       	mov	r30, r0
    4e7c:	1b be       	out	0x3b, r1	; 59
    4e7e:	19 94       	eijmp

00004e80 <__muluhisi3>:
    4e80:	0e 94 4b 27 	call	0x4e96	; 0x4e96 <__umulhisi3>
    4e84:	a5 9f       	mul	r26, r21
    4e86:	90 0d       	add	r25, r0
    4e88:	b4 9f       	mul	r27, r20
    4e8a:	90 0d       	add	r25, r0
    4e8c:	a4 9f       	mul	r26, r20
    4e8e:	80 0d       	add	r24, r0
    4e90:	91 1d       	adc	r25, r1
    4e92:	11 24       	eor	r1, r1
    4e94:	08 95       	ret

00004e96 <__umulhisi3>:
    4e96:	a2 9f       	mul	r26, r18
    4e98:	b0 01       	movw	r22, r0
    4e9a:	b3 9f       	mul	r27, r19
    4e9c:	c0 01       	movw	r24, r0
    4e9e:	a3 9f       	mul	r26, r19
    4ea0:	70 0d       	add	r23, r0
    4ea2:	81 1d       	adc	r24, r1
    4ea4:	11 24       	eor	r1, r1
    4ea6:	91 1d       	adc	r25, r1
    4ea8:	b2 9f       	mul	r27, r18
    4eaa:	70 0d       	add	r23, r0
    4eac:	81 1d       	adc	r24, r1
    4eae:	11 24       	eor	r1, r1
    4eb0:	91 1d       	adc	r25, r1
    4eb2:	08 95       	ret

00004eb4 <memcpy>:
    4eb4:	fb 01       	movw	r30, r22
    4eb6:	dc 01       	movw	r26, r24
    4eb8:	02 c0       	rjmp	.+4      	; 0x4ebe <memcpy+0xa>
    4eba:	01 90       	ld	r0, Z+
    4ebc:	0d 92       	st	X+, r0
    4ebe:	41 50       	subi	r20, 0x01	; 1
    4ec0:	50 40       	sbci	r21, 0x00	; 0
    4ec2:	d8 f7       	brcc	.-10     	; 0x4eba <memcpy+0x6>
    4ec4:	08 95       	ret

00004ec6 <memset>:
    4ec6:	dc 01       	movw	r26, r24
    4ec8:	01 c0       	rjmp	.+2      	; 0x4ecc <memset+0x6>
    4eca:	6d 93       	st	X+, r22
    4ecc:	41 50       	subi	r20, 0x01	; 1
    4ece:	50 40       	sbci	r21, 0x00	; 0
    4ed0:	e0 f7       	brcc	.-8      	; 0x4eca <memset+0x4>
    4ed2:	08 95       	ret

00004ed4 <strncpy>:
    4ed4:	fb 01       	movw	r30, r22
    4ed6:	dc 01       	movw	r26, r24
    4ed8:	41 50       	subi	r20, 0x01	; 1
    4eda:	50 40       	sbci	r21, 0x00	; 0
    4edc:	48 f0       	brcs	.+18     	; 0x4ef0 <strncpy+0x1c>
    4ede:	01 90       	ld	r0, Z+
    4ee0:	0d 92       	st	X+, r0
    4ee2:	00 20       	and	r0, r0
    4ee4:	c9 f7       	brne	.-14     	; 0x4ed8 <strncpy+0x4>
    4ee6:	01 c0       	rjmp	.+2      	; 0x4eea <strncpy+0x16>
    4ee8:	1d 92       	st	X+, r1
    4eea:	41 50       	subi	r20, 0x01	; 1
    4eec:	50 40       	sbci	r21, 0x00	; 0
    4eee:	e0 f7       	brcc	.-8      	; 0x4ee8 <strncpy+0x14>
    4ef0:	08 95       	ret

00004ef2 <ultoa>:
    4ef2:	25 32       	cpi	r18, 0x25	; 37
    4ef4:	31 05       	cpc	r19, r1
    4ef6:	20 f4       	brcc	.+8      	; 0x4f00 <ultoa+0xe>
    4ef8:	22 30       	cpi	r18, 0x02	; 2
    4efa:	10 f0       	brcs	.+4      	; 0x4f00 <ultoa+0xe>
    4efc:	0c 94 84 27 	jmp	0x4f08	; 0x4f08 <__ultoa_ncheck>
    4f00:	fa 01       	movw	r30, r20
    4f02:	10 82       	st	Z, r1
    4f04:	ca 01       	movw	r24, r20
    4f06:	08 95       	ret

00004f08 <__ultoa_ncheck>:
    4f08:	bb 27       	eor	r27, r27

00004f0a <__ultoa_common>:
    4f0a:	fa 01       	movw	r30, r20
    4f0c:	a6 2f       	mov	r26, r22
    4f0e:	62 17       	cp	r22, r18
    4f10:	71 05       	cpc	r23, r1
    4f12:	81 05       	cpc	r24, r1
    4f14:	91 05       	cpc	r25, r1
    4f16:	33 0b       	sbc	r19, r19
    4f18:	30 fb       	bst	r19, 0
    4f1a:	66 f0       	brts	.+24     	; 0x4f34 <__ultoa_common+0x2a>
    4f1c:	aa 27       	eor	r26, r26
    4f1e:	66 0f       	add	r22, r22
    4f20:	77 1f       	adc	r23, r23
    4f22:	88 1f       	adc	r24, r24
    4f24:	99 1f       	adc	r25, r25
    4f26:	aa 1f       	adc	r26, r26
    4f28:	a2 17       	cp	r26, r18
    4f2a:	10 f0       	brcs	.+4      	; 0x4f30 <__ultoa_common+0x26>
    4f2c:	a2 1b       	sub	r26, r18
    4f2e:	63 95       	inc	r22
    4f30:	38 50       	subi	r19, 0x08	; 8
    4f32:	a9 f7       	brne	.-22     	; 0x4f1e <__ultoa_common+0x14>
    4f34:	a0 5d       	subi	r26, 0xD0	; 208
    4f36:	aa 33       	cpi	r26, 0x3A	; 58
    4f38:	08 f0       	brcs	.+2      	; 0x4f3c <__ultoa_common+0x32>
    4f3a:	a9 5d       	subi	r26, 0xD9	; 217
    4f3c:	a1 93       	st	Z+, r26
    4f3e:	36 f7       	brtc	.-52     	; 0x4f0c <__ultoa_common+0x2>
    4f40:	b1 11       	cpse	r27, r1
    4f42:	b1 93       	st	Z+, r27
    4f44:	10 82       	st	Z, r1
    4f46:	ca 01       	movw	r24, r20
    4f48:	0c 94 cb 27 	jmp	0x4f96	; 0x4f96 <strrev>

00004f4c <utoa>:
    4f4c:	45 32       	cpi	r20, 0x25	; 37
    4f4e:	51 05       	cpc	r21, r1
    4f50:	20 f4       	brcc	.+8      	; 0x4f5a <utoa+0xe>
    4f52:	42 30       	cpi	r20, 0x02	; 2
    4f54:	10 f0       	brcs	.+4      	; 0x4f5a <utoa+0xe>
    4f56:	0c 94 b1 27 	jmp	0x4f62	; 0x4f62 <__utoa_ncheck>
    4f5a:	fb 01       	movw	r30, r22
    4f5c:	10 82       	st	Z, r1
    4f5e:	cb 01       	movw	r24, r22
    4f60:	08 95       	ret

00004f62 <__utoa_ncheck>:
    4f62:	bb 27       	eor	r27, r27

00004f64 <__utoa_common>:
    4f64:	fb 01       	movw	r30, r22
    4f66:	55 27       	eor	r21, r21
    4f68:	aa 27       	eor	r26, r26
    4f6a:	88 0f       	add	r24, r24
    4f6c:	99 1f       	adc	r25, r25
    4f6e:	aa 1f       	adc	r26, r26
    4f70:	a4 17       	cp	r26, r20
    4f72:	10 f0       	brcs	.+4      	; 0x4f78 <__utoa_common+0x14>
    4f74:	a4 1b       	sub	r26, r20
    4f76:	83 95       	inc	r24
    4f78:	50 51       	subi	r21, 0x10	; 16
    4f7a:	b9 f7       	brne	.-18     	; 0x4f6a <__utoa_common+0x6>
    4f7c:	a0 5d       	subi	r26, 0xD0	; 208
    4f7e:	aa 33       	cpi	r26, 0x3A	; 58
    4f80:	08 f0       	brcs	.+2      	; 0x4f84 <__utoa_common+0x20>
    4f82:	a9 5d       	subi	r26, 0xD9	; 217
    4f84:	a1 93       	st	Z+, r26
    4f86:	00 97       	sbiw	r24, 0x00	; 0
    4f88:	79 f7       	brne	.-34     	; 0x4f68 <__utoa_common+0x4>
    4f8a:	b1 11       	cpse	r27, r1
    4f8c:	b1 93       	st	Z+, r27
    4f8e:	11 92       	st	Z+, r1
    4f90:	cb 01       	movw	r24, r22
    4f92:	0c 94 cb 27 	jmp	0x4f96	; 0x4f96 <strrev>

00004f96 <strrev>:
    4f96:	dc 01       	movw	r26, r24
    4f98:	fc 01       	movw	r30, r24
    4f9a:	67 2f       	mov	r22, r23
    4f9c:	71 91       	ld	r23, Z+
    4f9e:	77 23       	and	r23, r23
    4fa0:	e1 f7       	brne	.-8      	; 0x4f9a <strrev+0x4>
    4fa2:	32 97       	sbiw	r30, 0x02	; 2
    4fa4:	04 c0       	rjmp	.+8      	; 0x4fae <strrev+0x18>
    4fa6:	7c 91       	ld	r23, X
    4fa8:	6d 93       	st	X+, r22
    4faa:	70 83       	st	Z, r23
    4fac:	62 91       	ld	r22, -Z
    4fae:	ae 17       	cp	r26, r30
    4fb0:	bf 07       	cpc	r27, r31
    4fb2:	c8 f3       	brcs	.-14     	; 0x4fa6 <strrev+0x10>
    4fb4:	08 95       	ret

00004fb6 <_exit>:
    4fb6:	f8 94       	cli

00004fb8 <__stop_program>:
    4fb8:	ff cf       	rjmp	.-2      	; 0x4fb8 <__stop_program>
