
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003f76  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000de  00802000  00003f76  0000400a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020de  008020de  000040e8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000040e8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004118  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d8  00000000  00000000  00004158  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012bdd  00000000  00000000  00004930  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005bcd  00000000  00000000  0001750d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000051ff  00000000  00000000  0001d0da  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000177c  00000000  00000000  000222dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000066f0  00000000  00000000  00023a58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000077f3  00000000  00000000  0002a148  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000738  00000000  00000000  0003193b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__ctors_end>
       4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      10:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      14:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      18:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      1c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      20:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      24:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      28:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      2c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      30:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      34:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      38:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      3c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      40:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      44:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      48:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      4c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      50:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      54:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      58:	0c 94 19 0a 	jmp	0x1432	; 0x1432 <__vector_22>
      5c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      60:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      64:	0c 94 ee 19 	jmp	0x33dc	; 0x33dc <__vector_25>
      68:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      6c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      70:	0c 94 4c 1a 	jmp	0x3498	; 0x3498 <__vector_28>
      74:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      78:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      7c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      80:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      84:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      88:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      8c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      90:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      94:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      98:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      9c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e8:	0c 94 66 1b 	jmp	0x36cc	; 0x36cc <__vector_58>
      ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      fc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     100:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     104:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     108:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     10c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     110:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     114:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     118:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     11c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     120:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     124:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     128:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     12c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     130:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     134:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     138:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     13c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     140:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     144:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     148:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     14c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     150:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     154:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     158:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     15c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     160:	0c 94 aa 1a 	jmp	0x3554	; 0x3554 <__vector_88>
     164:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     168:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     16c:	0c 94 08 1b 	jmp	0x3610	; 0x3610 <__vector_91>
     170:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     174:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     178:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     17c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     180:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     184:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     188:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     18c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     190:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     194:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     198:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     19c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1fc:	da 17       	cp	r29, r26
     1fe:	dd 17       	cp	r29, r29
     200:	e0 17       	cp	r30, r16
     202:	e3 17       	cp	r30, r19
     204:	e6 17       	cp	r30, r22
     206:	e9 17       	cp	r30, r25
     208:	eb 17       	cp	r30, r27
     20a:	fc 17       	cp	r31, r28
     20c:	04 18       	sub	r0, r4
     20e:	0e 18       	sub	r0, r14
     210:	0c 18       	sub	r0, r12

00000212 <__trampolines_start>:
     212:	0c 94 82 1d 	jmp	0x3b04	; 0x3b04 <_ZN9frt_queueIjE7butt_inERKj>
     216:	0c 94 8e 1c 	jmp	0x391c	; 0x391c <_ZN9frt_queueIiE10get_a_copyEv>
     21a:	0c 94 08 19 	jmp	0x3210	; 0x3210 <_ZN5rs2327putcharEc>
     21e:	0c 94 b8 1d 	jmp	0x3b70	; 0x3b70 <_ZN9frt_queueIiE3putERKi>
     222:	0c 94 e1 1c 	jmp	0x39c2	; 0x39c2 <_ZN9frt_queueIjE7ISR_getEv>
     226:	0c 94 2e 15 	jmp	0x2a5c	; 0x2a5c <_ZN14frt_text_queue7putcharEc>
     22a:	0c 94 82 17 	jmp	0x2f04	; 0x2f04 <_ZN8emstream14check_for_charEv>
     22e:	0c 94 a9 1c 	jmp	0x3952	; 0x3952 <_ZN9frt_queueIiE3getEPi>
     232:	0c 94 f5 05 	jmp	0xbea	; 0xbea <_ZN9task_user3runEv>
     236:	0c 94 0e 1c 	jmp	0x381c	; 0x381c <_ZN9frt_queueIjE8is_emptyEv>
     23a:	0c 94 94 1d 	jmp	0x3b28	; 0x3b28 <_ZN9frt_queueIjE3putERKj>
     23e:	0c 94 18 1c 	jmp	0x3830	; 0x3830 <_ZN9frt_queueIiE12num_items_inEv>
     242:	0c 94 84 17 	jmp	0x2f08	; 0x2f08 <_ZN8emstream12transmit_nowEv>
     246:	0c 94 e7 1b 	jmp	0x37ce	; 0x37ce <_ZN9frt_queueIiE13ISR_not_emptyEv>
     24a:	0c 94 1f 1c 	jmp	0x383e	; 0x383e <_ZN9frt_queueIiE9not_emptyEv>
     24e:	0c 94 6c 03 	jmp	0x6d8	; 0x6d8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     252:	0c 94 6a 1d 	jmp	0x3ad4	; 0x3ad4 <_ZN9frt_queueIiE7ISR_putERKi>
     256:	0c 94 47 1e 	jmp	0x3c8e	; 0x3c8e <_GLOBAL__sub_I_counter>
     25a:	0c 94 e0 17 	jmp	0x2fc0	; 0x2fc0 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     25e:	0c 94 fc 17 	jmp	0x2ff8	; 0x2ff8 <_ZN8emstreamlsE15ser_manipulator+0x62>
     262:	0c 94 dd 17 	jmp	0x2fba	; 0x2fba <_ZN8emstreamlsE15ser_manipulator+0x24>
     266:	0c 94 fc 1b 	jmp	0x37f8	; 0x37f8 <_ZN9frt_queueIjE12num_items_inEv>
     26a:	0c 94 a6 1d 	jmp	0x3b4c	; 0x3b4c <_ZN9frt_queueIiE7butt_inERKi>
     26e:	0c 94 03 1c 	jmp	0x3806	; 0x3806 <_ZN9frt_queueIjE9not_emptyEv>
     272:	0c 94 40 1c 	jmp	0x3880	; 0x3880 <_ZN9frt_queueIjE10get_a_copyEv>
     276:	0c 94 e0 1b 	jmp	0x37c0	; 0x37c0 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     27a:	0c 94 52 19 	jmp	0x32a4	; 0x32a4 <_ZN5rs23214check_for_charEv>
     27e:	0c 94 3b 03 	jmp	0x676	; 0x676 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     282:	0c 94 2a 1c 	jmp	0x3854	; 0x3854 <_ZN9frt_queueIiE8is_emptyEv>
     286:	0c 94 ac 03 	jmp	0x758	; 0x758 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>
     28a:	0c 94 e6 17 	jmp	0x2fcc	; 0x2fcc <_ZN8emstreamlsE15ser_manipulator+0x36>
     28e:	0c 94 22 1d 	jmp	0x3a44	; 0x3a44 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     292:	0c 94 bb 13 	jmp	0x2776	; 0x2776 <_ZN8frt_task12print_statusER8emstream>
     296:	0c 94 b5 1c 	jmp	0x396a	; 0x396a <_ZN9frt_queueIiE3getEv>
     29a:	0c 94 e8 02 	jmp	0x5d0	; 0x5d0 <_call_static_run_method>
     29e:	0c 94 f2 1b 	jmp	0x37e4	; 0x37e4 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     2a2:	0c 94 d0 1c 	jmp	0x39a0	; 0x39a0 <_ZN9frt_queueIjE7ISR_getEPj>
     2a6:	0c 94 82 1c 	jmp	0x3904	; 0x3904 <_ZN9frt_queueIiE10get_a_copyERi>
     2aa:	0c 94 3a 1d 	jmp	0x3a74	; 0x3a74 <_ZN9frt_queueIjE7ISR_putERKj>
     2ae:	0c 94 f9 0c 	jmp	0x19f2	; 0x19f2 <prvIdleTask>
     2b2:	0c 94 67 1c 	jmp	0x38ce	; 0x38ce <_ZN9frt_queueIjE3getEv>
     2b6:	0c 94 7d 17 	jmp	0x2efa	; 0x2efa <_ZN8emstream13ready_to_sendEv>
     2ba:	0c 94 0c 18 	jmp	0x3018	; 0x3018 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2be:	0c 94 c4 1b 	jmp	0x3788	; 0x3788 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2c2:	0c 94 7f 17 	jmp	0x2efe	; 0x2efe <_ZN8emstream7getcharEv>
     2c6:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <_ZN5rs23212clear_screenEv>
     2ca:	0c 94 f9 1c 	jmp	0x39f2	; 0x39f2 <_ZN9frt_queueIiE7ISR_getEPi>
     2ce:	0c 94 e6 16 	jmp	0x2dcc	; 0x2dcc <__cxa_pure_virtual>
     2d2:	0c 94 e9 17 	jmp	0x2fd2	; 0x2fd2 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2d6:	0c 94 85 17 	jmp	0x2f0a	; 0x2f0a <_ZN8emstream12clear_screenEv>
     2da:	0c 94 a8 03 	jmp	0x750	; 0x750 <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>
     2de:	0c 94 eb 17 	jmp	0x2fd6	; 0x2fd6 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2e2:	0c 94 0a 1d 	jmp	0x3a14	; 0x3a14 <_ZN9frt_queueIiE7ISR_getEv>
     2e6:	0c 94 0e 18 	jmp	0x301c	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
     2ea:	0c 94 23 03 	jmp	0x646	; 0x646 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>
     2ee:	0c 94 e3 17 	jmp	0x2fc6	; 0x2fc6 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2f2:	0c 94 cb 1b 	jmp	0x3796	; 0x3796 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2f6:	0c 94 93 03 	jmp	0x726	; 0x726 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     2fa:	0c 94 2c 19 	jmp	0x3258	; 0x3258 <_ZN5rs2327getcharEv>
     2fe:	0c 94 34 1c 	jmp	0x3868	; 0x3868 <_ZN9frt_queueIjE10get_a_copyERj>
     302:	0c 94 5b 1c 	jmp	0x38b6	; 0x38b6 <_ZN9frt_queueIjE3getEPj>
     306:	0c 94 05 15 	jmp	0x2a0a	; 0x2a0a <_ZN14frt_text_queue7getcharEv>
     30a:	0c 94 04 18 	jmp	0x3008	; 0x3008 <_ZN8emstreamlsE15ser_manipulator+0x72>
     30e:	0c 94 52 1d 	jmp	0x3aa4	; 0x3aa4 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     312:	0c 94 23 15 	jmp	0x2a46	; 0x2a46 <_ZN14frt_text_queue14check_for_charEv>
     316:	0c 94 d6 1b 	jmp	0x37ac	; 0x37ac <_ZN9frt_queueIjE12ISR_is_emptyEv>
     31a:	0c 94 da 17 	jmp	0x2fb4	; 0x2fb4 <_ZN8emstreamlsE15ser_manipulator+0x1e>

0000031e <__trampolines_end>:
     31e:	2c 20       	and	r2, r12
     320:	54 43       	sbci	r21, 0x34	; 52
     322:	43 30       	cpi	r20, 0x03	; 3
     324:	43 43       	sbci	r20, 0x33	; 51
     326:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000329 <_ZZN9task_user11show_statusEvE3__c_3>:
     329:	2f 00                                               /.

0000032b <_ZZN9task_user11show_statusEvE3__c_2>:
     32b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000339 <_ZZN9task_user11show_statusEvE3__c_1>:
     339:	54 69 6d 65 3a 20 00                                Time: .

00000340 <_ZZN9task_user11show_statusEvE3__c_0>:
     340:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

0000034c <_ZZN9task_user11show_statusEvE3__c>:
     34c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     35c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000036b <_ZZN9task_user18print_help_messageEvE3__c_10>:
     36b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000037a <_ZZN9task_user18print_help_messageEvE3__c_9>:
     37a:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     38a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000395 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     395:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3a5:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003b3 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3b3:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3c3:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3d3:	6d 61 74 69 6f 6e 00                                mation.

000003da <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3da:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3ea:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003fb <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3fb:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     40b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000413 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     413:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     423:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000042f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     42f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     43f:	68 65 20 41 56 52 00                                he AVR.

00000446 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     446:	20 68 65 6c 70 00                                    help.

0000044c <_ZZN9task_user18print_help_messageEvE3__c_1>:
     44c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     45c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000046b <_ZZN9task_user18print_help_messageEvE3__c_0>:
     46b:	1b 5b 33 30 6d 00                                   .[30m.

00000471 <_ZZN9task_user18print_help_messageEvE3__c>:
     471:	1b 5b 34 36 6d 00                                   .[46m.

00000477 <_ZZN9task_user3runEvE3__c_3>:
     477:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     487:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000494 <_ZZN9task_user3runEvE3__c_2>:
     494:	3a 57 54 46 3f 00                                   :WTF?.

0000049a <_ZZN9task_user3runEvE3__c_1>:
     49a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4aa:	65 00                                               e.

000004ac <_ZZN9task_user3runEvE3__c_0>:
     4ac:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004ba <_ZZN9task_user3runEvE3__c>:
     4ba:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4ca:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004d8 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4d8:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004e2 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4e2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004f1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4f1:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     501:	61 73 6b 20 00                                      ask .

00000506 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     506:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000514 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     514:	20 63 72 65 61 74 65 64 00                           created.

0000051d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     51d:	54 61 73 6b 20 00                                   Task .

00000523 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     523:	1b 5b 32 32 6d 00                                   .[22m.

00000529 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     529:	54 61 73 6b 3a 20 00                                Task: .

00000530 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     530:	1b 5b 31 6d 00                                      .[1m.

00000535 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     53b:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000546 <_ZZ17print_task_stacksP8emstreamE3__c>:
     546:	1b 5b 31 6d 00                                      .[1m.

0000054b <_ZZ15print_task_listP8emstreamE3__c_9>:
     54b:	09 09 00                                            ...

0000054e <_ZZ15print_task_listP8emstreamE3__c_8>:
     54e:	2f 00                                               /.

00000550 <_ZZ15print_task_listP8emstreamE3__c_7>:
     550:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000055b <_ZZ15print_task_listP8emstreamE3__c_6>:
     55b:	09 2d 2d 2d 2d 00                                   .----.

00000561 <_ZZ15print_task_listP8emstreamE3__c_5>:
     561:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000056d <_ZZ15print_task_listP8emstreamE3__c_4>:
     56d:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000057e <_ZZ15print_task_listP8emstreamE3__c_3>:
     57e:	09 52 75 6e 73 00                                   .Runs.

00000584 <_ZZ15print_task_listP8emstreamE3__c_2>:
     584:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000590 <_ZZ15print_task_listP8emstreamE3__c_1>:
     590:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005a1 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5a1:	09 53 74 61 63 6b 00                                .Stack.

000005a8 <_ZZ15print_task_listP8emstreamE3__c>:
     5a8:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005b3 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5b3:	09 00                                               ..

000005b5 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5b5:	09 00                                               ..

000005b7 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5b7:	2f 00                                               /.

000005b9 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5b9:	09 00                                               ..

000005bb <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5bb:	09 00                                               ..

000005bd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5bd:	1b 5b 32 32 6d 00                                   .[22m.

000005c3 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5c3:	1b 5b 31 6d 00                                      .[1m.

000005c8 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5cd:	20 20 00                                              .

000005d0 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5d0:	0e 94 53 12 	call	0x24a6	; 0x24a6 <_ZN8frt_task22_call_users_run_methodEPS_>

000005d4 <__ctors_start>:
     5d4:	47 1e       	adc	r4, r23

000005d6 <__ctors_end>:
     5d6:	11 24       	eor	r1, r1
     5d8:	1f be       	out	0x3f, r1	; 63
     5da:	cf ef       	ldi	r28, 0xFF	; 255
     5dc:	cd bf       	out	0x3d, r28	; 61
     5de:	df e3       	ldi	r29, 0x3F	; 63
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	00 e0       	ldi	r16, 0x00	; 0
     5e4:	0c bf       	out	0x3c, r16	; 60
     5e6:	18 be       	out	0x38, r1	; 56
     5e8:	19 be       	out	0x39, r1	; 57
     5ea:	1a be       	out	0x3a, r1	; 58
     5ec:	1b be       	out	0x3b, r1	; 59

000005ee <__do_copy_data>:
     5ee:	10 e2       	ldi	r17, 0x20	; 32
     5f0:	a0 e0       	ldi	r26, 0x00	; 0
     5f2:	b0 e2       	ldi	r27, 0x20	; 32
     5f4:	e6 e7       	ldi	r30, 0x76	; 118
     5f6:	ff e3       	ldi	r31, 0x3F	; 63
     5f8:	00 e0       	ldi	r16, 0x00	; 0
     5fa:	0b bf       	out	0x3b, r16	; 59
     5fc:	02 c0       	rjmp	.+4      	; 0x602 <__do_copy_data+0x14>
     5fe:	07 90       	elpm	r0, Z+
     600:	0d 92       	st	X+, r0
     602:	ae 3d       	cpi	r26, 0xDE	; 222
     604:	b1 07       	cpc	r27, r17
     606:	d9 f7       	brne	.-10     	; 0x5fe <__do_copy_data+0x10>
     608:	1b be       	out	0x3b, r1	; 59

0000060a <__do_clear_bss>:
     60a:	21 e3       	ldi	r18, 0x31	; 49
     60c:	ae ed       	ldi	r26, 0xDE	; 222
     60e:	b0 e2       	ldi	r27, 0x20	; 32
     610:	01 c0       	rjmp	.+2      	; 0x614 <.do_clear_bss_start>

00000612 <.do_clear_bss_loop>:
     612:	1d 92       	st	X+, r1

00000614 <.do_clear_bss_start>:
     614:	ac 3a       	cpi	r26, 0xAC	; 172
     616:	b2 07       	cpc	r27, r18
     618:	e1 f7       	brne	.-8      	; 0x612 <.do_clear_bss_loop>

0000061a <__do_global_ctors>:
     61a:	12 e0       	ldi	r17, 0x02	; 2
     61c:	cb ee       	ldi	r28, 0xEB	; 235
     61e:	d2 e0       	ldi	r29, 0x02	; 2
     620:	00 e0       	ldi	r16, 0x00	; 0
     622:	06 c0       	rjmp	.+12     	; 0x630 <__do_global_ctors+0x16>
     624:	21 97       	sbiw	r28, 0x01	; 1
     626:	01 09       	sbc	r16, r1
     628:	80 2f       	mov	r24, r16
     62a:	fe 01       	movw	r30, r28
     62c:	0e 94 15 1f 	call	0x3e2a	; 0x3e2a <__tablejump2__>
     630:	ca 3e       	cpi	r28, 0xEA	; 234
     632:	d1 07       	cpc	r29, r17
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	08 07       	cpc	r16, r24
     638:	a9 f7       	brne	.-22     	; 0x624 <__do_global_ctors+0xa>
     63a:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <main>
     63e:	0c 94 b9 1f 	jmp	0x3f72	; 0x3f72 <_exit>

00000642 <__bad_interrupt>:
     642:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000646 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>:
  {
    currentState_ = currentState_->execute(packet);
  }

  return packet;
}
     646:	0f 93       	push	r16
     648:	1f 93       	push	r17
     64a:	cf 93       	push	r28
     64c:	df 93       	push	r29
     64e:	ec 01       	movw	r28, r24
     650:	cb 01       	movw	r24, r22
     652:	0f 81       	ldd	r16, Y+7	; 0x07
     654:	18 85       	ldd	r17, Y+8	; 0x08
     656:	db 01       	movw	r26, r22
     658:	ed 91       	ld	r30, X+
     65a:	fc 91       	ld	r31, X
     65c:	00 84       	ldd	r0, Z+8	; 0x08
     65e:	f1 85       	ldd	r31, Z+9	; 0x09
     660:	e0 2d       	mov	r30, r0
     662:	19 95       	eicall
     664:	f8 01       	movw	r30, r16
     666:	86 83       	std	Z+6, r24	; 0x06
     668:	8a 81       	ldd	r24, Y+2	; 0x02
     66a:	9b 81       	ldd	r25, Y+3	; 0x03
     66c:	df 91       	pop	r29
     66e:	cf 91       	pop	r28
     670:	1f 91       	pop	r17
     672:	0f 91       	pop	r16
     674:	08 95       	ret

00000676 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	1f 92       	push	r1
     67c:	1f 92       	push	r1
     67e:	cd b7       	in	r28, 0x3d	; 61
     680:	de b7       	in	r29, 0x3e	; 62
     682:	dc 01       	movw	r26, r24
     684:	19 96       	adiw	r26, 0x09	; 9
     686:	8d 91       	ld	r24, X+
     688:	9c 91       	ld	r25, X
     68a:	1a 97       	sbiw	r26, 0x0a	; 10
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	9a 83       	std	Y+2, r25	; 0x02
     690:	29 81       	ldd	r18, Y+1	; 0x01
     692:	3a 81       	ldd	r19, Y+2	; 0x02
     694:	21 50       	subi	r18, 0x01	; 1
     696:	31 09       	sbc	r19, r1
     698:	29 83       	std	Y+1, r18	; 0x01
     69a:	3a 83       	std	Y+2, r19	; 0x02
     69c:	23 2b       	or	r18, r19
     69e:	91 f0       	breq	.+36     	; 0x6c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     6a0:	17 96       	adiw	r26, 0x07	; 7
     6a2:	ed 91       	ld	r30, X+
     6a4:	fc 91       	ld	r31, X
     6a6:	18 97       	sbiw	r26, 0x08	; 8
     6a8:	94 81       	ldd	r25, Z+4	; 0x04
     6aa:	90 75       	andi	r25, 0x50	; 80
     6ac:	89 f7       	brne	.-30     	; 0x690 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
     6ae:	0a c0       	rjmp	.+20     	; 0x6c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     6b0:	14 96       	adiw	r26, 0x04	; 4
     6b2:	8d 91       	ld	r24, X+
     6b4:	9c 91       	ld	r25, X
     6b6:	15 97       	sbiw	r26, 0x05	; 5
     6b8:	0a c0       	rjmp	.+20     	; 0x6ce <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     6ba:	12 96       	adiw	r26, 0x02	; 2
     6bc:	8d 91       	ld	r24, X+
     6be:	9c 91       	ld	r25, X
     6c0:	13 97       	sbiw	r26, 0x03	; 3
     6c2:	05 c0       	rjmp	.+10     	; 0x6ce <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     6c4:	29 81       	ldd	r18, Y+1	; 0x01
     6c6:	3a 81       	ldd	r19, Y+2	; 0x02
     6c8:	23 2b       	or	r18, r19
     6ca:	b9 f7       	brne	.-18     	; 0x6ba <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     6cc:	f1 cf       	rjmp	.-30     	; 0x6b0 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3a>
     6ce:	0f 90       	pop	r0
     6d0:	0f 90       	pop	r0
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	08 95       	ret

000006d8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     6d8:	ef 92       	push	r14
     6da:	ff 92       	push	r15
     6dc:	0f 93       	push	r16
     6de:	1f 93       	push	r17
     6e0:	cf 93       	push	r28
     6e2:	df 93       	push	r29
     6e4:	8c 01       	movw	r16, r24
     6e6:	eb 01       	movw	r28, r22
     6e8:	e8 81       	ld	r30, Y
     6ea:	f9 81       	ldd	r31, Y+1	; 0x01
     6ec:	00 8c       	ldd	r0, Z+24	; 0x18
     6ee:	f1 8d       	ldd	r31, Z+25	; 0x19
     6f0:	e0 2d       	mov	r30, r0
     6f2:	cb 01       	movw	r24, r22
     6f4:	19 95       	eicall
     6f6:	88 23       	and	r24, r24
     6f8:	61 f0       	breq	.+24     	; 0x712 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x3a>
     6fa:	f8 01       	movw	r30, r16
     6fc:	e7 80       	ldd	r14, Z+7	; 0x07
     6fe:	f0 84       	ldd	r15, Z+8	; 0x08
     700:	e8 81       	ld	r30, Y
     702:	f9 81       	ldd	r31, Y+1	; 0x01
     704:	00 84       	ldd	r0, Z+8	; 0x08
     706:	f1 85       	ldd	r31, Z+9	; 0x09
     708:	e0 2d       	mov	r30, r0
     70a:	ce 01       	movw	r24, r28
     70c:	19 95       	eicall
     70e:	f7 01       	movw	r30, r14
     710:	87 83       	std	Z+7, r24	; 0x07
     712:	f8 01       	movw	r30, r16
     714:	82 81       	ldd	r24, Z+2	; 0x02
     716:	93 81       	ldd	r25, Z+3	; 0x03
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	1f 91       	pop	r17
     71e:	0f 91       	pop	r16
     720:	ff 90       	pop	r15
     722:	ef 90       	pop	r14
     724:	08 95       	ret

00000726 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     726:	cf 93       	push	r28
     728:	df 93       	push	r29
     72a:	ec 01       	movw	r28, r24
     72c:	cb 01       	movw	r24, r22
     72e:	db 01       	movw	r26, r22
     730:	ed 91       	ld	r30, X+
     732:	fc 91       	ld	r31, X
     734:	04 88       	ldd	r0, Z+20	; 0x14
     736:	f5 89       	ldd	r31, Z+21	; 0x15
     738:	e0 2d       	mov	r30, r0
     73a:	19 95       	eicall
     73c:	88 23       	and	r24, r24
     73e:	19 f0       	breq	.+6      	; 0x746 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     740:	8a 81       	ldd	r24, Y+2	; 0x02
     742:	9b 81       	ldd	r25, Y+3	; 0x03
     744:	02 c0       	rjmp	.+4      	; 0x74a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     746:	8c 81       	ldd	r24, Y+4	; 0x04
     748:	9d 81       	ldd	r25, Y+5	; 0x05
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>:
     750:	fc 01       	movw	r30, r24
     752:	82 81       	ldd	r24, Z+2	; 0x02
     754:	93 81       	ldd	r25, Z+3	; 0x03
     756:	08 95       	ret

00000758 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>:
     758:	fc 01       	movw	r30, r24
     75a:	82 81       	ldd	r24, Z+2	; 0x02
     75c:	93 81       	ldd	r25, Z+3	; 0x03
     75e:	08 95       	ret

00000760 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     760:	0f 93       	push	r16
     762:	1f 93       	push	r17
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	ec 01       	movw	r28, r24
     76a:	8b 01       	movw	r16, r22
     76c:	89 e0       	ldi	r24, 0x09	; 9
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     774:	fc 01       	movw	r30, r24
     776:	16 82       	std	Z+6, r1	; 0x06
     778:	8a e0       	ldi	r24, 0x0A	; 10
     77a:	90 e2       	ldi	r25, 0x20	; 32
     77c:	80 83       	st	Z, r24
     77e:	91 83       	std	Z+1, r25	; 0x01
     780:	07 83       	std	Z+7, r16	; 0x07
     782:	10 87       	std	Z+8, r17	; 0x08
     784:	ea 83       	std	Y+2, r30	; 0x02
     786:	fb 83       	std	Y+3, r31	; 0x03
     788:	8b e0       	ldi	r24, 0x0B	; 11
     78a:	90 e0       	ldi	r25, 0x00	; 0
     78c:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     790:	fc 01       	movw	r30, r24
     792:	89 89       	ldd	r24, Y+17	; 0x11
     794:	9a 89       	ldd	r25, Y+18	; 0x12
     796:	16 82       	std	Z+6, r1	; 0x06
     798:	20 e1       	ldi	r18, 0x10	; 16
     79a:	30 e2       	ldi	r19, 0x20	; 32
     79c:	20 83       	st	Z, r18
     79e:	31 83       	std	Z+1, r19	; 0x01
     7a0:	07 83       	std	Z+7, r16	; 0x07
     7a2:	10 87       	std	Z+8, r17	; 0x08
     7a4:	81 87       	std	Z+9, r24	; 0x09
     7a6:	92 87       	std	Z+10, r25	; 0x0a
     7a8:	ec 83       	std	Y+4, r30	; 0x04
     7aa:	fd 83       	std	Y+5, r31	; 0x05
     7ac:	89 e0       	ldi	r24, 0x09	; 9
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     7b4:	fc 01       	movw	r30, r24
     7b6:	16 82       	std	Z+6, r1	; 0x06
     7b8:	86 e1       	ldi	r24, 0x16	; 22
     7ba:	90 e2       	ldi	r25, 0x20	; 32
     7bc:	80 83       	st	Z, r24
     7be:	91 83       	std	Z+1, r25	; 0x01
     7c0:	07 83       	std	Z+7, r16	; 0x07
     7c2:	10 87       	std	Z+8, r17	; 0x08
     7c4:	ee 83       	std	Y+6, r30	; 0x06
     7c6:	ff 83       	std	Y+7, r31	; 0x07
     7c8:	89 e0       	ldi	r24, 0x09	; 9
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     7d0:	fc 01       	movw	r30, r24
     7d2:	16 82       	std	Z+6, r1	; 0x06
     7d4:	8c e1       	ldi	r24, 0x1C	; 28
     7d6:	90 e2       	ldi	r25, 0x20	; 32
     7d8:	80 83       	st	Z, r24
     7da:	91 83       	std	Z+1, r25	; 0x01
     7dc:	07 83       	std	Z+7, r16	; 0x07
     7de:	10 87       	std	Z+8, r17	; 0x08
     7e0:	e8 87       	std	Y+8, r30	; 0x08
     7e2:	f9 87       	std	Y+9, r31	; 0x09
     7e4:	89 e0       	ldi	r24, 0x09	; 9
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     7ec:	fc 01       	movw	r30, r24
     7ee:	16 82       	std	Z+6, r1	; 0x06
     7f0:	88 e2       	ldi	r24, 0x28	; 40
     7f2:	90 e2       	ldi	r25, 0x20	; 32
     7f4:	80 83       	st	Z, r24
     7f6:	91 83       	std	Z+1, r25	; 0x01
     7f8:	07 83       	std	Z+7, r16	; 0x07
     7fa:	10 87       	std	Z+8, r17	; 0x08
     7fc:	ea 87       	std	Y+10, r30	; 0x0a
     7fe:	fb 87       	std	Y+11, r31	; 0x0b
     800:	89 e0       	ldi	r24, 0x09	; 9
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     808:	fc 01       	movw	r30, r24
     80a:	16 82       	std	Z+6, r1	; 0x06
     80c:	82 e2       	ldi	r24, 0x22	; 34
     80e:	90 e2       	ldi	r25, 0x20	; 32
     810:	80 83       	st	Z, r24
     812:	91 83       	std	Z+1, r25	; 0x01
     814:	07 83       	std	Z+7, r16	; 0x07
     816:	10 87       	std	Z+8, r17	; 0x08
     818:	ec 87       	std	Y+12, r30	; 0x0c
     81a:	fd 87       	std	Y+13, r31	; 0x0d
     81c:	80 e1       	ldi	r24, 0x10	; 16
     81e:	97 e2       	ldi	r25, 0x27	; 39
     820:	89 8b       	std	Y+17, r24	; 0x11
     822:	9a 8b       	std	Y+18, r25	; 0x12
     824:	8c 81       	ldd	r24, Y+4	; 0x04
     826:	9d 81       	ldd	r25, Y+5	; 0x05
     828:	ea 81       	ldd	r30, Y+2	; 0x02
     82a:	fb 81       	ldd	r31, Y+3	; 0x03
     82c:	82 83       	std	Z+2, r24	; 0x02
     82e:	93 83       	std	Z+3, r25	; 0x03
     830:	84 83       	std	Z+4, r24	; 0x04
     832:	95 83       	std	Z+5, r25	; 0x05
     834:	8a 85       	ldd	r24, Y+10	; 0x0a
     836:	9b 85       	ldd	r25, Y+11	; 0x0b
     838:	2e 81       	ldd	r18, Y+6	; 0x06
     83a:	3f 81       	ldd	r19, Y+7	; 0x07
     83c:	ec 81       	ldd	r30, Y+4	; 0x04
     83e:	fd 81       	ldd	r31, Y+5	; 0x05
     840:	22 83       	std	Z+2, r18	; 0x02
     842:	33 83       	std	Z+3, r19	; 0x03
     844:	84 83       	std	Z+4, r24	; 0x04
     846:	95 83       	std	Z+5, r25	; 0x05
     848:	88 85       	ldd	r24, Y+8	; 0x08
     84a:	99 85       	ldd	r25, Y+9	; 0x09
     84c:	ee 81       	ldd	r30, Y+6	; 0x06
     84e:	ff 81       	ldd	r31, Y+7	; 0x07
     850:	82 83       	std	Z+2, r24	; 0x02
     852:	93 83       	std	Z+3, r25	; 0x03
     854:	84 83       	std	Z+4, r24	; 0x04
     856:	95 83       	std	Z+5, r25	; 0x05
     858:	8c 81       	ldd	r24, Y+4	; 0x04
     85a:	9d 81       	ldd	r25, Y+5	; 0x05
     85c:	2c 85       	ldd	r18, Y+12	; 0x0c
     85e:	3d 85       	ldd	r19, Y+13	; 0x0d
     860:	e8 85       	ldd	r30, Y+8	; 0x08
     862:	f9 85       	ldd	r31, Y+9	; 0x09
     864:	22 83       	std	Z+2, r18	; 0x02
     866:	33 83       	std	Z+3, r19	; 0x03
     868:	84 83       	std	Z+4, r24	; 0x04
     86a:	95 83       	std	Z+5, r25	; 0x05
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     876:	cf 93       	push	r28
     878:	df 93       	push	r29
     87a:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     87c:	9a 01       	movw	r18, r20
     87e:	ab 01       	movw	r20, r22
     880:	22 0f       	add	r18, r18
     882:	33 1f       	adc	r19, r19
     884:	44 1f       	adc	r20, r20
     886:	55 1f       	adc	r21, r21
     888:	60 e0       	ldi	r22, 0x00	; 0
     88a:	78 e4       	ldi	r23, 0x48	; 72
     88c:	88 ee       	ldi	r24, 0xE8	; 232
     88e:	91 e0       	ldi	r25, 0x01	; 1
     890:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
     894:	25 50       	subi	r18, 0x05	; 5
     896:	28 87       	std	Y+8, r18	; 0x08
  interface->MASTER.BAUD = baudrate;
     898:	ec 81       	ldd	r30, Y+4	; 0x04
     89a:	fd 81       	ldd	r31, Y+5	; 0x05
     89c:	25 83       	std	Z+5, r18	; 0x05
}
     89e:	df 91       	pop	r29
     8a0:	cf 91       	pop	r28
     8a2:	08 95       	ret

000008a4 <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t* interface, uint32_t i2c_freq)
     8a4:	af 92       	push	r10
     8a6:	bf 92       	push	r11
     8a8:	cf 92       	push	r12
     8aa:	df 92       	push	r13
     8ac:	ef 92       	push	r14
     8ae:	ff 92       	push	r15
     8b0:	0f 93       	push	r16
     8b2:	1f 93       	push	r17
     8b4:	cf 93       	push	r28
     8b6:	df 93       	push	r29
     8b8:	8c 01       	movw	r16, r24
     8ba:	eb 01       	movw	r28, r22
     8bc:	69 01       	movw	r12, r18
     8be:	7a 01       	movw	r14, r20
  : interface(interface), 
    i2c_freq(i2c_freq),
    transmitter_( new Transmitter(interface) )
     8c0:	83 e1       	ldi	r24, 0x13	; 19
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
     8c8:	5c 01       	movw	r10, r24
     8ca:	be 01       	movw	r22, r28
     8cc:	0e 94 b0 03 	call	0x760	; 0x760 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     8d0:	d8 01       	movw	r26, r16
     8d2:	ad 92       	st	X+, r10
     8d4:	bc 92       	st	X, r11
     8d6:	11 97       	sbiw	r26, 0x01	; 1
     8d8:	14 96       	adiw	r26, 0x04	; 4
     8da:	cd 93       	st	X+, r28
     8dc:	dc 93       	st	X, r29
     8de:	15 97       	sbiw	r26, 0x05	; 5
     8e0:	f8 01       	movw	r30, r16
     8e2:	c1 86       	std	Z+9, r12	; 0x09
     8e4:	d2 86       	std	Z+10, r13	; 0x0a
     8e6:	e3 86       	std	Z+11, r14	; 0x0b
     8e8:	f4 86       	std	Z+12, r15	; 0x0c
{ 
  if (interface == &TWIC)
     8ea:	c0 38       	cpi	r28, 0x80	; 128
     8ec:	f4 e0       	ldi	r31, 0x04	; 4
     8ee:	df 07       	cpc	r29, r31
     8f0:	39 f4       	brne	.+14     	; 0x900 <_ZN9I2CMasterC1EP10TWI_structm+0x5c>
  {
    bus_port = &PORTC;
     8f2:	80 e4       	ldi	r24, 0x40	; 64
     8f4:	96 e0       	ldi	r25, 0x06	; 6
     8f6:	16 96       	adiw	r26, 0x06	; 6
     8f8:	8d 93       	st	X+, r24
     8fa:	9c 93       	st	X, r25
     8fc:	17 97       	sbiw	r26, 0x07	; 7
     8fe:	09 c0       	rjmp	.+18     	; 0x912 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  }
  if (interface == &TWIE)
     900:	c0 3a       	cpi	r28, 0xA0	; 160
     902:	b4 e0       	ldi	r27, 0x04	; 4
     904:	db 07       	cpc	r29, r27
     906:	29 f4       	brne	.+10     	; 0x912 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  {
    bus_port = &PORTE;
     908:	80 e8       	ldi	r24, 0x80	; 128
     90a:	96 e0       	ldi	r25, 0x06	; 6
     90c:	f8 01       	movw	r30, r16
     90e:	86 83       	std	Z+6, r24	; 0x06
     910:	97 83       	std	Z+7, r25	; 0x07
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     912:	d8 01       	movw	r26, r16
     914:	16 96       	adiw	r26, 0x06	; 6
     916:	ed 91       	ld	r30, X+
     918:	fc 91       	ld	r31, X
     91a:	17 97       	sbiw	r26, 0x07	; 7
     91c:	83 e0       	ldi	r24, 0x03	; 3
     91e:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     920:	16 96       	adiw	r26, 0x06	; 6
     922:	ed 91       	ld	r30, X+
     924:	fc 91       	ld	r31, X
     926:	17 97       	sbiw	r26, 0x07	; 7
     928:	88 e3       	ldi	r24, 0x38	; 56
     92a:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     92c:	16 96       	adiw	r26, 0x06	; 6
     92e:	ed 91       	ld	r30, X+
     930:	fc 91       	ld	r31, X
     932:	17 97       	sbiw	r26, 0x07	; 7
     934:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     936:	82 e0       	ldi	r24, 0x02	; 2
     938:	8a 83       	std	Y+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     93a:	b7 01       	movw	r22, r14
     93c:	a6 01       	movw	r20, r12
     93e:	c8 01       	movw	r24, r16
     940:	0e 94 3b 04 	call	0x876	; 0x876 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     944:	8c 81       	ldd	r24, Y+4	; 0x04
     946:	8d 6c       	ori	r24, 0xCD	; 205
     948:	8c 83       	std	Y+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     94a:	88 e0       	ldi	r24, 0x08	; 8
     94c:	89 83       	std	Y+1, r24	; 0x01
}
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	1f 91       	pop	r17
     954:	0f 91       	pop	r16
     956:	ff 90       	pop	r15
     958:	ef 90       	pop	r14
     95a:	df 90       	pop	r13
     95c:	cf 90       	pop	r12
     95e:	bf 90       	pop	r11
     960:	af 90       	pop	r10
     962:	08 95       	ret

00000964 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     964:	0f 93       	push	r16
     966:	1f 93       	push	r17
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     96e:	0e 94 66 12 	call	0x24cc	; 0x24cc <_ZN8frt_taskC1EPKchjP8emstream>
     972:	8e e2       	ldi	r24, 0x2E	; 46
     974:	90 e2       	ldi	r25, 0x20	; 32
     976:	88 83       	st	Y, r24
     978:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     97a:	df 91       	pop	r29
     97c:	cf 91       	pop	r28
     97e:	1f 91       	pop	r17
     980:	0f 91       	pop	r16
     982:	08 95       	ret

00000984 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     984:	0f 93       	push	r16
     986:	1f 93       	push	r17
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     98e:	6a e0       	ldi	r22, 0x0A	; 10
     990:	8e 81       	ldd	r24, Y+6	; 0x06
     992:	9f 81       	ldd	r25, Y+7	; 0x07
     994:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     998:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     99a:	61 e7       	ldi	r22, 0x71	; 113
     99c:	74 e0       	ldi	r23, 0x04	; 4
     99e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     9a2:	6a e0       	ldi	r22, 0x0A	; 10
     9a4:	c8 01       	movw	r24, r16
     9a6:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     9aa:	8c 01       	movw	r16, r24
     9ac:	6b e6       	ldi	r22, 0x6B	; 107
     9ae:	74 e0       	ldi	r23, 0x04	; 4
     9b0:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     9b4:	67 e0       	ldi	r22, 0x07	; 7
     9b6:	c8 01       	movw	r24, r16
     9b8:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     9bc:	6a e0       	ldi	r22, 0x0A	; 10
     9be:	8e 81       	ldd	r24, Y+6	; 0x06
     9c0:	9f 81       	ldd	r25, Y+7	; 0x07
     9c2:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     9c6:	8c 01       	movw	r16, r24
     9c8:	6c e4       	ldi	r22, 0x4C	; 76
     9ca:	74 e0       	ldi	r23, 0x04	; 4
     9cc:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     9d0:	6a e0       	ldi	r22, 0x0A	; 10
     9d2:	c8 01       	movw	r24, r16
     9d4:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     9d8:	8c 01       	movw	r16, r24
     9da:	66 e4       	ldi	r22, 0x46	; 70
     9dc:	74 e0       	ldi	r23, 0x04	; 4
     9de:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     9e2:	66 e0       	ldi	r22, 0x06	; 6
     9e4:	c8 01       	movw	r24, r16
     9e6:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     9ea:	6a e0       	ldi	r22, 0x0A	; 10
     9ec:	8e 81       	ldd	r24, Y+6	; 0x06
     9ee:	9f 81       	ldd	r25, Y+7	; 0x07
     9f0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     9f4:	8c 01       	movw	r16, r24
     9f6:	6f e2       	ldi	r22, 0x2F	; 47
     9f8:	74 e0       	ldi	r23, 0x04	; 4
     9fa:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     9fe:	66 e0       	ldi	r22, 0x06	; 6
     a00:	c8 01       	movw	r24, r16
     a02:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     a06:	6a e0       	ldi	r22, 0x0A	; 10
     a08:	8e 81       	ldd	r24, Y+6	; 0x06
     a0a:	9f 81       	ldd	r25, Y+7	; 0x07
     a0c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a10:	8c 01       	movw	r16, r24
     a12:	63 e1       	ldi	r22, 0x13	; 19
     a14:	74 e0       	ldi	r23, 0x04	; 4
     a16:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     a1a:	66 e0       	ldi	r22, 0x06	; 6
     a1c:	c8 01       	movw	r24, r16
     a1e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     a22:	6a e0       	ldi	r22, 0x0A	; 10
     a24:	8e 81       	ldd	r24, Y+6	; 0x06
     a26:	9f 81       	ldd	r25, Y+7	; 0x07
     a28:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a2c:	8c 01       	movw	r16, r24
     a2e:	6b ef       	ldi	r22, 0xFB	; 251
     a30:	73 e0       	ldi	r23, 0x03	; 3
     a32:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     a36:	66 e0       	ldi	r22, 0x06	; 6
     a38:	c8 01       	movw	r24, r16
     a3a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     a3e:	6a e0       	ldi	r22, 0x0A	; 10
     a40:	8e 81       	ldd	r24, Y+6	; 0x06
     a42:	9f 81       	ldd	r25, Y+7	; 0x07
     a44:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a48:	8c 01       	movw	r16, r24
     a4a:	6a ed       	ldi	r22, 0xDA	; 218
     a4c:	73 e0       	ldi	r23, 0x03	; 3
     a4e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     a52:	66 e0       	ldi	r22, 0x06	; 6
     a54:	c8 01       	movw	r24, r16
     a56:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     a5a:	6a e0       	ldi	r22, 0x0A	; 10
     a5c:	8e 81       	ldd	r24, Y+6	; 0x06
     a5e:	9f 81       	ldd	r25, Y+7	; 0x07
     a60:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a64:	8c 01       	movw	r16, r24
     a66:	63 eb       	ldi	r22, 0xB3	; 179
     a68:	73 e0       	ldi	r23, 0x03	; 3
     a6a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     a6e:	66 e0       	ldi	r22, 0x06	; 6
     a70:	c8 01       	movw	r24, r16
     a72:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     a76:	6a e0       	ldi	r22, 0x0A	; 10
     a78:	8e 81       	ldd	r24, Y+6	; 0x06
     a7a:	9f 81       	ldd	r25, Y+7	; 0x07
     a7c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a80:	8c 01       	movw	r16, r24
     a82:	65 e9       	ldi	r22, 0x95	; 149
     a84:	73 e0       	ldi	r23, 0x03	; 3
     a86:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     a8a:	66 e0       	ldi	r22, 0x06	; 6
     a8c:	c8 01       	movw	r24, r16
     a8e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     a92:	6a e0       	ldi	r22, 0x0A	; 10
     a94:	8e 81       	ldd	r24, Y+6	; 0x06
     a96:	9f 81       	ldd	r25, Y+7	; 0x07
     a98:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     a9c:	8c 01       	movw	r16, r24
     a9e:	6a e7       	ldi	r22, 0x7A	; 122
     aa0:	73 e0       	ldi	r23, 0x03	; 3
     aa2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     aa6:	66 e0       	ldi	r22, 0x06	; 6
     aa8:	c8 01       	movw	r24, r16
     aaa:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     aae:	6a e0       	ldi	r22, 0x0A	; 10
     ab0:	8e 81       	ldd	r24, Y+6	; 0x06
     ab2:	9f 81       	ldd	r25, Y+7	; 0x07
     ab4:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     ab8:	ec 01       	movw	r28, r24
     aba:	6b e6       	ldi	r22, 0x6B	; 107
     abc:	73 e0       	ldi	r23, 0x03	; 3
     abe:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     ac2:	66 e0       	ldi	r22, 0x06	; 6
     ac4:	ce 01       	movw	r24, r28
     ac6:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
}
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	1f 91       	pop	r17
     ad0:	0f 91       	pop	r16
     ad2:	08 95       	ret

00000ad4 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     ad4:	af 92       	push	r10
     ad6:	bf 92       	push	r11
     ad8:	cf 92       	push	r12
     ada:	df 92       	push	r13
     adc:	ef 92       	push	r14
     ade:	ff 92       	push	r15
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	00 d0       	rcall	.+0      	; 0xaea <_ZN9task_user11show_statusEv+0x16>
     aea:	00 d0       	rcall	.+0      	; 0xaec <_ZN9task_user11show_statusEv+0x18>
     aec:	cd b7       	in	r28, 0x3d	; 61
     aee:	de b7       	in	r29, 0x3e	; 62
     af0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     af2:	19 82       	std	Y+1, r1	; 0x01
     af4:	1a 82       	std	Y+2, r1	; 0x02
     af6:	1b 82       	std	Y+3, r1	; 0x03
     af8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     afa:	1d 82       	std	Y+5, r1	; 0x05
     afc:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     afe:	0e 94 ef 07 	call	0xfde	; 0xfde <xPortGetFreeHeapSize>
     b02:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     b04:	ce 01       	movw	r24, r28
     b06:	01 96       	adiw	r24, 0x01	; 1
     b08:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <_ZN10time_stamp10set_to_nowEv>
     b0c:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     b0e:	66 e0       	ldi	r22, 0x06	; 6
     b10:	f8 01       	movw	r30, r16
     b12:	86 81       	ldd	r24, Z+6	; 0x06
     b14:	97 81       	ldd	r25, Z+7	; 0x07
     b16:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b1a:	6a e0       	ldi	r22, 0x0A	; 10
     b1c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b20:	7c 01       	movw	r14, r24
     b22:	6c e4       	ldi	r22, 0x4C	; 76
     b24:	73 e0       	ldi	r23, 0x03	; 3
     b26:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     b2a:	6a e0       	ldi	r22, 0x0A	; 10
     b2c:	c7 01       	movw	r24, r14
     b2e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b32:	7c 01       	movw	r14, r24
     b34:	60 e4       	ldi	r22, 0x40	; 64
     b36:	73 e0       	ldi	r23, 0x03	; 3
     b38:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     b3c:	66 e0       	ldi	r22, 0x06	; 6
     b3e:	c7 01       	movw	r24, r14
     b40:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     b44:	6a e0       	ldi	r22, 0x0A	; 10
     b46:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b4a:	7c 01       	movw	r14, r24
     b4c:	69 e3       	ldi	r22, 0x39	; 57
     b4e:	73 e0       	ldi	r23, 0x03	; 3
     b50:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     b54:	b5 01       	movw	r22, r10
     b56:	c7 01       	movw	r24, r14
     b58:	0e 94 bb 15 	call	0x2b76	; 0x2b76 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     b5c:	6a e0       	ldi	r22, 0x0A	; 10
     b5e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b62:	7c 01       	movw	r14, r24
     b64:	6b e2       	ldi	r22, 0x2B	; 43
     b66:	73 e0       	ldi	r23, 0x03	; 3
     b68:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     b6c:	b6 01       	movw	r22, r12
     b6e:	c7 01       	movw	r24, r14
     b70:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
     b74:	6a e0       	ldi	r22, 0x0A	; 10
     b76:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     b7a:	7c 01       	movw	r14, r24
     b7c:	69 e2       	ldi	r22, 0x29	; 41
     b7e:	73 e0       	ldi	r23, 0x03	; 3
     b80:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     b84:	4f ef       	ldi	r20, 0xFF	; 255
     b86:	5f e0       	ldi	r21, 0x0F	; 15
     b88:	60 e0       	ldi	r22, 0x00	; 0
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	c7 01       	movw	r24, r14
     b8e:	0e 94 46 18 	call	0x308c	; 0x308c <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     b92:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     b96:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     b9a:	6a e0       	ldi	r22, 0x0A	; 10
     b9c:	f8 01       	movw	r30, r16
     b9e:	86 81       	ldd	r24, Z+6	; 0x06
     ba0:	97 81       	ldd	r25, Z+7	; 0x07
     ba2:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     ba6:	7c 01       	movw	r14, r24
     ba8:	6e e1       	ldi	r22, 0x1E	; 30
     baa:	73 e0       	ldi	r23, 0x03	; 3
     bac:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     bb0:	b6 01       	movw	r22, r12
     bb2:	c7 01       	movw	r24, r14
     bb4:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
     bb8:	66 e0       	ldi	r22, 0x06	; 6
     bba:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     bbe:	66 e0       	ldi	r22, 0x06	; 6
     bc0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     bc4:	f8 01       	movw	r30, r16
     bc6:	86 81       	ldd	r24, Z+6	; 0x06
     bc8:	97 81       	ldd	r25, Z+7	; 0x07
     bca:	0e 94 74 14 	call	0x28e8	; 0x28e8 <_Z15print_task_listP8emstream>
}
     bce:	26 96       	adiw	r28, 0x06	; 6
     bd0:	cd bf       	out	0x3d, r28	; 61
     bd2:	de bf       	out	0x3e, r29	; 62
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	ff 90       	pop	r15
     bde:	ef 90       	pop	r14
     be0:	df 90       	pop	r13
     be2:	cf 90       	pop	r12
     be4:	bf 90       	pop	r11
     be6:	af 90       	pop	r10
     be8:	08 95       	ret

00000bea <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
     bee:	00 d0       	rcall	.+0      	; 0xbf0 <_ZN9task_user3runEv+0x6>
     bf0:	00 d0       	rcall	.+0      	; 0xbf2 <_ZN9task_user3runEv+0x8>
     bf2:	cd b7       	in	r28, 0x3d	; 61
     bf4:	de b7       	in	r29, 0x3e	; 62
     bf6:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     bf8:	19 82       	std	Y+1, r1	; 0x01
     bfa:	1a 82       	std	Y+2, r1	; 0x02
     bfc:	1b 82       	std	Y+3, r1	; 0x03
     bfe:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     c00:	1d 82       	std	Y+5, r1	; 0x05
     c02:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     c04:	6a e0       	ldi	r22, 0x0A	; 10
     c06:	dc 01       	movw	r26, r24
     c08:	16 96       	adiw	r26, 0x06	; 6
     c0a:	8d 91       	ld	r24, X+
     c0c:	9c 91       	ld	r25, X
     c0e:	17 97       	sbiw	r26, 0x07	; 7
     c10:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     c14:	7c 01       	movw	r14, r24
     c16:	6a eb       	ldi	r22, 0xBA	; 186
     c18:	74 e0       	ldi	r23, 0x04	; 4
     c1a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     c1e:	66 e0       	ldi	r22, 0x06	; 6
     c20:	c7 01       	movw	r24, r14
     c22:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     c26:	f8 01       	movw	r30, r16
     c28:	84 85       	ldd	r24, Z+12	; 0x0c
     c2a:	88 23       	and	r24, r24
     c2c:	21 f0       	breq	.+8      	; 0xc36 <_ZN9task_user3runEv+0x4c>
     c2e:	81 30       	cpi	r24, 0x01	; 1
     c30:	09 f4       	brne	.+2      	; 0xc34 <_ZN9task_user3runEv+0x4a>
     c32:	5d c0       	rjmp	.+186    	; 0xcee <_ZN9task_user3runEv+0x104>
     c34:	d8 c0       	rjmp	.+432    	; 0xde6 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     c36:	86 81       	ldd	r24, Z+6	; 0x06
     c38:	97 81       	ldd	r25, Z+7	; 0x07
     c3a:	dc 01       	movw	r26, r24
     c3c:	ed 91       	ld	r30, X+
     c3e:	fc 91       	ld	r31, X
     c40:	04 80       	ldd	r0, Z+4	; 0x04
     c42:	f5 81       	ldd	r31, Z+5	; 0x05
     c44:	e0 2d       	mov	r30, r0
     c46:	19 95       	eicall
     c48:	88 23       	and	r24, r24
     c4a:	a9 f1       	breq	.+106    	; 0xcb6 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     c4c:	f8 01       	movw	r30, r16
     c4e:	86 81       	ldd	r24, Z+6	; 0x06
     c50:	97 81       	ldd	r25, Z+7	; 0x07
     c52:	dc 01       	movw	r26, r24
     c54:	ed 91       	ld	r30, X+
     c56:	fc 91       	ld	r31, X
     c58:	06 80       	ldd	r0, Z+6	; 0x06
     c5a:	f7 81       	ldd	r31, Z+7	; 0x07
     c5c:	e0 2d       	mov	r30, r0
     c5e:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     c60:	99 27       	eor	r25, r25
     c62:	81 30       	cpi	r24, 0x01	; 1
     c64:	91 05       	cpc	r25, r1
     c66:	f9 f0       	breq	.+62     	; 0xca6 <_ZN9task_user3runEv+0xbc>
     c68:	03 97       	sbiw	r24, 0x03	; 3
     c6a:	09 f0       	breq	.+2      	; 0xc6e <_ZN9task_user3runEv+0x84>
     c6c:	d8 c0       	rjmp	.+432    	; 0xe1e <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     c6e:	6a e0       	ldi	r22, 0x0A	; 10
     c70:	f8 01       	movw	r30, r16
     c72:	86 81       	ldd	r24, Z+6	; 0x06
     c74:	97 81       	ldd	r25, Z+7	; 0x07
     c76:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     c7a:	8c 01       	movw	r16, r24
     c7c:	6c ea       	ldi	r22, 0xAC	; 172
     c7e:	74 e0       	ldi	r23, 0x04	; 4
     c80:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     c84:	66 e0       	ldi	r22, 0x06	; 6
     c86:	c8 01       	movw	r24, r16
     c88:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     c8c:	93 e0       	ldi	r25, 0x03	; 3
     c8e:	88 ed       	ldi	r24, 0xD8	; 216
     c90:	08 b6       	in	r0, 0x38	; 56
     c92:	18 be       	out	0x38, r1	; 56
     c94:	84 bf       	out	0x34, r24	; 52
     c96:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     c9a:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     c9e:	81 fd       	sbrc	r24, 1
     ca0:	fc cf       	rjmp	.-8      	; 0xc9a <_ZN9task_user3runEv+0xb0>
     ca2:	08 be       	out	0x38, r0	; 56
     ca4:	ff cf       	rjmp	.-2      	; 0xca4 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     ca6:	c8 01       	movw	r24, r16
     ca8:	0e 94 c2 04 	call	0x984	; 0x984 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     cac:	61 e0       	ldi	r22, 0x01	; 1
     cae:	c8 01       	movw	r24, r16
     cb0:	0e 94 62 12 	call	0x24c4	; 0x24c4 <_ZN8frt_task13transition_toEh>
							break;
     cb4:	b4 c0       	rjmp	.+360    	; 0xe1e <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     cb6:	8a e9       	ldi	r24, 0x9A	; 154
     cb8:	91 e3       	ldi	r25, 0x31	; 49
     cba:	0e 94 23 15 	call	0x2a46	; 0x2a46 <_ZN14frt_text_queue14check_for_charEv>
     cbe:	88 23       	and	r24, r24
     cc0:	09 f4       	brne	.+2      	; 0xcc4 <_ZN9task_user3runEv+0xda>
     cc2:	ad c0       	rjmp	.+346    	; 0xe1e <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     cc4:	d8 01       	movw	r26, r16
     cc6:	16 96       	adiw	r26, 0x06	; 6
     cc8:	ed 91       	ld	r30, X+
     cca:	fc 91       	ld	r31, X
     ccc:	17 97       	sbiw	r26, 0x07	; 7
     cce:	01 90       	ld	r0, Z+
     cd0:	f0 81       	ld	r31, Z
     cd2:	e0 2d       	mov	r30, r0
     cd4:	e2 80       	ldd	r14, Z+2	; 0x02
     cd6:	f3 80       	ldd	r15, Z+3	; 0x03
     cd8:	8a e9       	ldi	r24, 0x9A	; 154
     cda:	91 e3       	ldi	r25, 0x31	; 49
     cdc:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <_ZN14frt_text_queue7getcharEv>
     ce0:	68 2f       	mov	r22, r24
     ce2:	f8 01       	movw	r30, r16
     ce4:	86 81       	ldd	r24, Z+6	; 0x06
     ce6:	97 81       	ldd	r25, Z+7	; 0x07
     ce8:	f7 01       	movw	r30, r14
     cea:	19 95       	eicall
     cec:	98 c0       	rjmp	.+304    	; 0xe1e <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     cee:	86 81       	ldd	r24, Z+6	; 0x06
     cf0:	97 81       	ldd	r25, Z+7	; 0x07
     cf2:	dc 01       	movw	r26, r24
     cf4:	ed 91       	ld	r30, X+
     cf6:	fc 91       	ld	r31, X
     cf8:	04 80       	ldd	r0, Z+4	; 0x04
     cfa:	f5 81       	ldd	r31, Z+5	; 0x05
     cfc:	e0 2d       	mov	r30, r0
     cfe:	19 95       	eicall
     d00:	88 23       	and	r24, r24
     d02:	09 f4       	brne	.+2      	; 0xd06 <_ZN9task_user3runEv+0x11c>
     d04:	8c c0       	rjmp	.+280    	; 0xe1e <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     d06:	f8 01       	movw	r30, r16
     d08:	86 81       	ldd	r24, Z+6	; 0x06
     d0a:	97 81       	ldd	r25, Z+7	; 0x07
     d0c:	dc 01       	movw	r26, r24
     d0e:	ed 91       	ld	r30, X+
     d10:	fc 91       	ld	r31, X
     d12:	06 80       	ldd	r0, Z+6	; 0x06
     d14:	f7 81       	ldd	r31, Z+7	; 0x07
     d16:	e0 2d       	mov	r30, r0
     d18:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     d1a:	9c 01       	movw	r18, r24
     d1c:	33 27       	eor	r19, r19
     d1e:	28 36       	cpi	r18, 0x68	; 104
     d20:	31 05       	cpc	r19, r1
     d22:	59 f1       	breq	.+86     	; 0xd7a <_ZN9task_user3runEv+0x190>
     d24:	3c f4       	brge	.+14     	; 0xd34 <_ZN9task_user3runEv+0x14a>
     d26:	2b 31       	cpi	r18, 0x1B	; 27
     d28:	31 05       	cpc	r19, r1
     d2a:	59 f1       	breq	.+86     	; 0xd82 <_ZN9task_user3runEv+0x198>
     d2c:	25 36       	cpi	r18, 0x65	; 101
     d2e:	31 05       	cpc	r19, r1
     d30:	41 f1       	breq	.+80     	; 0xd82 <_ZN9task_user3runEv+0x198>
     d32:	3b c0       	rjmp	.+118    	; 0xdaa <_ZN9task_user3runEv+0x1c0>
     d34:	23 37       	cpi	r18, 0x73	; 115
     d36:	31 05       	cpc	r19, r1
     d38:	c1 f0       	breq	.+48     	; 0xd6a <_ZN9task_user3runEv+0x180>
     d3a:	26 37       	cpi	r18, 0x76	; 118
     d3c:	31 05       	cpc	r19, r1
     d3e:	89 f0       	breq	.+34     	; 0xd62 <_ZN9task_user3runEv+0x178>
     d40:	2e 36       	cpi	r18, 0x6E	; 110
     d42:	31 05       	cpc	r19, r1
     d44:	91 f5       	brne	.+100    	; 0xdaa <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     d46:	ce 01       	movw	r24, r28
     d48:	01 96       	adiw	r24, 0x01	; 1
     d4a:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <_ZN10time_stamp10set_to_nowEv>
     d4e:	bc 01       	movw	r22, r24
     d50:	f8 01       	movw	r30, r16
     d52:	86 81       	ldd	r24, Z+6	; 0x06
     d54:	97 81       	ldd	r25, Z+7	; 0x07
     d56:	0e 94 bb 15 	call	0x2b76	; 0x2b76 <_ZlsR8emstreamR10time_stamp>
     d5a:	66 e0       	ldi	r22, 0x06	; 6
     d5c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
							break;
     d60:	5e c0       	rjmp	.+188    	; 0xe1e <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     d62:	c8 01       	movw	r24, r16
     d64:	0e 94 6a 05 	call	0xad4	; 0xad4 <_ZN9task_user11show_statusEv>
							break;
     d68:	5a c0       	rjmp	.+180    	; 0xe1e <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     d6a:	d8 01       	movw	r26, r16
     d6c:	16 96       	adiw	r26, 0x06	; 6
     d6e:	8d 91       	ld	r24, X+
     d70:	9c 91       	ld	r25, X
     d72:	17 97       	sbiw	r26, 0x07	; 7
     d74:	0e 94 7b 13 	call	0x26f6	; 0x26f6 <_Z17print_task_stacksP8emstream>
							break;
     d78:	52 c0       	rjmp	.+164    	; 0xe1e <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     d7a:	c8 01       	movw	r24, r16
     d7c:	0e 94 c2 04 	call	0x984	; 0x984 <_ZN9task_user18print_help_messageEv>
							break;
     d80:	4e c0       	rjmp	.+156    	; 0xe1e <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     d82:	6a e0       	ldi	r22, 0x0A	; 10
     d84:	f8 01       	movw	r30, r16
     d86:	86 81       	ldd	r24, Z+6	; 0x06
     d88:	97 81       	ldd	r25, Z+7	; 0x07
     d8a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     d8e:	7c 01       	movw	r14, r24
     d90:	6a e9       	ldi	r22, 0x9A	; 154
     d92:	74 e0       	ldi	r23, 0x04	; 4
     d94:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     d98:	66 e0       	ldi	r22, 0x06	; 6
     d9a:	c7 01       	movw	r24, r14
     d9c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     da0:	60 e0       	ldi	r22, 0x00	; 0
     da2:	c8 01       	movw	r24, r16
     da4:	0e 94 62 12 	call	0x24c4	; 0x24c4 <_ZN8frt_task13transition_toEh>
							break;
     da8:	3a c0       	rjmp	.+116    	; 0xe1e <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     daa:	f8 01       	movw	r30, r16
     dac:	a6 81       	ldd	r26, Z+6	; 0x06
     dae:	b7 81       	ldd	r27, Z+7	; 0x07
     db0:	ed 91       	ld	r30, X+
     db2:	fc 91       	ld	r31, X
     db4:	11 97       	sbiw	r26, 0x01	; 1
     db6:	02 80       	ldd	r0, Z+2	; 0x02
     db8:	f3 81       	ldd	r31, Z+3	; 0x03
     dba:	e0 2d       	mov	r30, r0
     dbc:	68 2f       	mov	r22, r24
     dbe:	cd 01       	movw	r24, r26
     dc0:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     dc2:	6a e0       	ldi	r22, 0x0A	; 10
     dc4:	d8 01       	movw	r26, r16
     dc6:	16 96       	adiw	r26, 0x06	; 6
     dc8:	8d 91       	ld	r24, X+
     dca:	9c 91       	ld	r25, X
     dcc:	17 97       	sbiw	r26, 0x07	; 7
     dce:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     dd2:	7c 01       	movw	r14, r24
     dd4:	64 e9       	ldi	r22, 0x94	; 148
     dd6:	74 e0       	ldi	r23, 0x04	; 4
     dd8:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     ddc:	66 e0       	ldi	r22, 0x06	; 6
     dde:	c7 01       	movw	r24, r14
     de0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
							break;
     de4:	1c c0       	rjmp	.+56     	; 0xe1e <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     de6:	6a e0       	ldi	r22, 0x0A	; 10
     de8:	f8 01       	movw	r30, r16
     dea:	86 81       	ldd	r24, Z+6	; 0x06
     dec:	97 81       	ldd	r25, Z+7	; 0x07
     dee:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
     df2:	8c 01       	movw	r16, r24
     df4:	67 e7       	ldi	r22, 0x77	; 119
     df6:	74 e0       	ldi	r23, 0x04	; 4
     df8:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
     dfc:	66 e0       	ldi	r22, 0x06	; 6
     dfe:	c8 01       	movw	r24, r16
     e00:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     e04:	93 e0       	ldi	r25, 0x03	; 3
     e06:	88 ed       	ldi	r24, 0xD8	; 216
     e08:	08 b6       	in	r0, 0x38	; 56
     e0a:	18 be       	out	0x38, r1	; 56
     e0c:	84 bf       	out	0x34, r24	; 52
     e0e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e12:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e16:	81 fd       	sbrc	r24, 1
     e18:	fc cf       	rjmp	.-8      	; 0xe12 <_ZN9task_user3runEv+0x228>
     e1a:	08 be       	out	0x38, r0	; 56
     e1c:	ff cf       	rjmp	.-2      	; 0xe1c <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     e1e:	f8 01       	movw	r30, r16
     e20:	86 85       	ldd	r24, Z+14	; 0x0e
     e22:	97 85       	ldd	r25, Z+15	; 0x0f
     e24:	a0 89       	ldd	r26, Z+16	; 0x10
     e26:	b1 89       	ldd	r27, Z+17	; 0x11
     e28:	01 96       	adiw	r24, 0x01	; 1
     e2a:	a1 1d       	adc	r26, r1
     e2c:	b1 1d       	adc	r27, r1
     e2e:	86 87       	std	Z+14, r24	; 0x0e
     e30:	97 87       	std	Z+15, r25	; 0x0f
     e32:	a0 8b       	std	Z+16, r26	; 0x10
     e34:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     e36:	61 e0       	ldi	r22, 0x01	; 1
     e38:	70 e0       	ldi	r23, 0x00	; 0
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	0e 94 36 10 	call	0x206c	; 0x206c <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     e42:	f1 ce       	rjmp	.-542    	; 0xc26 <_ZN9task_user3runEv+0x3c>

00000e44 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e44:	0f 93       	push	r16
     e46:	1f 93       	push	r17
     e48:	cf 93       	push	r28
     e4a:	df 93       	push	r29
     e4c:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     e4e:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     e52:	80 91 de 20 	lds	r24, 0x20DE	; 0x8020de <__data_end>
     e56:	81 11       	cpse	r24, r1
     e58:	1d c0       	rjmp	.+58     	; 0xe94 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     e5a:	a3 ee       	ldi	r26, 0xE3	; 227
     e5c:	b0 e2       	ldi	r27, 0x20	; 32
     e5e:	e7 ee       	ldi	r30, 0xE7	; 231
     e60:	f0 e2       	ldi	r31, 0x20	; 32
     e62:	ed 93       	st	X+, r30
     e64:	fc 93       	st	X, r31
     e66:	11 97       	sbiw	r26, 0x01	; 1
     e68:	12 96       	adiw	r26, 0x02	; 2
     e6a:	1d 92       	st	X+, r1
     e6c:	1c 92       	st	X, r1
     e6e:	13 97       	sbiw	r26, 0x03	; 3
     e70:	af ed       	ldi	r26, 0xDF	; 223
     e72:	b0 e2       	ldi	r27, 0x20	; 32
     e74:	8f ef       	ldi	r24, 0xFF	; 255
     e76:	9f e0       	ldi	r25, 0x0F	; 15
     e78:	12 96       	adiw	r26, 0x02	; 2
     e7a:	8d 93       	st	X+, r24
     e7c:	9c 93       	st	X, r25
     e7e:	13 97       	sbiw	r26, 0x03	; 3
     e80:	1d 92       	st	X+, r1
     e82:	1c 92       	st	X, r1
     e84:	11 97       	sbiw	r26, 0x01	; 1
     e86:	82 83       	std	Z+2, r24	; 0x02
     e88:	93 83       	std	Z+3, r25	; 0x03
     e8a:	a0 83       	st	Z, r26
     e8c:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	80 93 de 20 	sts	0x20DE, r24	; 0x8020de <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     e94:	20 97       	sbiw	r28, 0x00	; 0
     e96:	09 f4       	brne	.+2      	; 0xe9a <pvPortMalloc+0x56>
     e98:	5f c0       	rjmp	.+190    	; 0xf58 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e9a:	9e 01       	movw	r18, r28
     e9c:	2b 5f       	subi	r18, 0xFB	; 251
     e9e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     ea0:	24 96       	adiw	r28, 0x04	; 4
     ea2:	ce 3f       	cpi	r28, 0xFE	; 254
     ea4:	df 40       	sbci	r29, 0x0F	; 15
     ea6:	08 f0       	brcs	.+2      	; 0xeaa <pvPortMalloc+0x66>
     ea8:	5a c0       	rjmp	.+180    	; 0xf5e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     eaa:	e0 91 e3 20 	lds	r30, 0x20E3	; 0x8020e3 <xStart>
     eae:	f0 91 e4 20 	lds	r31, 0x20E4	; 0x8020e4 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     eb2:	a3 ee       	ldi	r26, 0xE3	; 227
     eb4:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     eb6:	02 c0       	rjmp	.+4      	; 0xebc <pvPortMalloc+0x78>
     eb8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     eba:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     ebc:	82 81       	ldd	r24, Z+2	; 0x02
     ebe:	93 81       	ldd	r25, Z+3	; 0x03
     ec0:	82 17       	cp	r24, r18
     ec2:	93 07       	cpc	r25, r19
     ec4:	20 f4       	brcc	.+8      	; 0xece <pvPortMalloc+0x8a>
     ec6:	80 81       	ld	r24, Z
     ec8:	91 81       	ldd	r25, Z+1	; 0x01
     eca:	00 97       	sbiw	r24, 0x00	; 0
     ecc:	a9 f7       	brne	.-22     	; 0xeb8 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     ece:	c0 e2       	ldi	r28, 0x20	; 32
     ed0:	ef 3d       	cpi	r30, 0xDF	; 223
     ed2:	fc 07       	cpc	r31, r28
     ed4:	09 f4       	brne	.+2      	; 0xed8 <pvPortMalloc+0x94>
     ed6:	46 c0       	rjmp	.+140    	; 0xf64 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     ed8:	cd 91       	ld	r28, X+
     eda:	dc 91       	ld	r29, X
     edc:	11 97       	sbiw	r26, 0x01	; 1
     ede:	8e 01       	movw	r16, r28
     ee0:	0b 5f       	subi	r16, 0xFB	; 251
     ee2:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     ee4:	80 81       	ld	r24, Z
     ee6:	91 81       	ldd	r25, Z+1	; 0x01
     ee8:	8d 93       	st	X+, r24
     eea:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     eec:	82 81       	ldd	r24, Z+2	; 0x02
     eee:	93 81       	ldd	r25, Z+3	; 0x03
     ef0:	82 1b       	sub	r24, r18
     ef2:	93 0b       	sbc	r25, r19
     ef4:	8b 30       	cpi	r24, 0x0B	; 11
     ef6:	91 05       	cpc	r25, r1
     ef8:	10 f1       	brcs	.+68     	; 0xf3e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     efa:	bf 01       	movw	r22, r30
     efc:	62 0f       	add	r22, r18
     efe:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     f00:	db 01       	movw	r26, r22
     f02:	12 96       	adiw	r26, 0x02	; 2
     f04:	8d 93       	st	X+, r24
     f06:	9c 93       	st	X, r25
     f08:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     f0a:	22 83       	std	Z+2, r18	; 0x02
     f0c:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f0e:	12 96       	adiw	r26, 0x02	; 2
     f10:	4d 91       	ld	r20, X+
     f12:	5c 91       	ld	r21, X
     f14:	13 97       	sbiw	r26, 0x03	; 3
     f16:	83 ee       	ldi	r24, 0xE3	; 227
     f18:	90 e2       	ldi	r25, 0x20	; 32
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <pvPortMalloc+0xda>
     f1c:	cd 01       	movw	r24, r26
     f1e:	ec 01       	movw	r28, r24
     f20:	a8 81       	ld	r26, Y
     f22:	b9 81       	ldd	r27, Y+1	; 0x01
     f24:	12 96       	adiw	r26, 0x02	; 2
     f26:	2d 91       	ld	r18, X+
     f28:	3c 91       	ld	r19, X
     f2a:	13 97       	sbiw	r26, 0x03	; 3
     f2c:	24 17       	cp	r18, r20
     f2e:	35 07       	cpc	r19, r21
     f30:	a8 f3       	brcs	.-22     	; 0xf1c <pvPortMalloc+0xd8>
     f32:	eb 01       	movw	r28, r22
     f34:	a8 83       	st	Y, r26
     f36:	b9 83       	std	Y+1, r27	; 0x01
     f38:	dc 01       	movw	r26, r24
     f3a:	6d 93       	st	X+, r22
     f3c:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     f3e:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     f42:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     f46:	22 81       	ldd	r18, Z+2	; 0x02
     f48:	33 81       	ldd	r19, Z+3	; 0x03
     f4a:	82 1b       	sub	r24, r18
     f4c:	93 0b       	sbc	r25, r19
     f4e:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     f52:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     f56:	08 c0       	rjmp	.+16     	; 0xf68 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     f58:	00 e0       	ldi	r16, 0x00	; 0
     f5a:	10 e0       	ldi	r17, 0x00	; 0
     f5c:	05 c0       	rjmp	.+10     	; 0xf68 <pvPortMalloc+0x124>
     f5e:	00 e0       	ldi	r16, 0x00	; 0
     f60:	10 e0       	ldi	r17, 0x00	; 0
     f62:	02 c0       	rjmp	.+4      	; 0xf68 <pvPortMalloc+0x124>
     f64:	00 e0       	ldi	r16, 0x00	; 0
     f66:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     f68:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     f6c:	c8 01       	movw	r24, r16
     f6e:	df 91       	pop	r29
     f70:	cf 91       	pop	r28
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	08 95       	ret

00000f78 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f78:	0f 93       	push	r16
     f7a:	1f 93       	push	r17
     f7c:	cf 93       	push	r28
     f7e:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     f80:	00 97       	sbiw	r24, 0x00	; 0
     f82:	41 f1       	breq	.+80     	; 0xfd4 <vPortFree+0x5c>
     f84:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     f86:	8c 01       	movw	r16, r24
     f88:	05 50       	subi	r16, 0x05	; 5
     f8a:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     f8c:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     f90:	f8 01       	movw	r30, r16
     f92:	42 81       	ldd	r20, Z+2	; 0x02
     f94:	53 81       	ldd	r21, Z+3	; 0x03
     f96:	a3 ee       	ldi	r26, 0xE3	; 227
     f98:	b0 e2       	ldi	r27, 0x20	; 32
     f9a:	01 c0       	rjmp	.+2      	; 0xf9e <vPortFree+0x26>
     f9c:	df 01       	movw	r26, r30
     f9e:	ed 91       	ld	r30, X+
     fa0:	fc 91       	ld	r31, X
     fa2:	11 97       	sbiw	r26, 0x01	; 1
     fa4:	22 81       	ldd	r18, Z+2	; 0x02
     fa6:	33 81       	ldd	r19, Z+3	; 0x03
     fa8:	24 17       	cp	r18, r20
     faa:	35 07       	cpc	r19, r21
     fac:	b8 f3       	brcs	.-18     	; 0xf9c <vPortFree+0x24>
     fae:	25 97       	sbiw	r28, 0x05	; 5
     fb0:	e8 83       	st	Y, r30
     fb2:	f9 83       	std	Y+1, r31	; 0x01
     fb4:	0d 93       	st	X+, r16
     fb6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     fb8:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     fbc:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     fc0:	8a 81       	ldd	r24, Y+2	; 0x02
     fc2:	9b 81       	ldd	r25, Y+3	; 0x03
     fc4:	82 0f       	add	r24, r18
     fc6:	93 1f       	adc	r25, r19
     fc8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     fcc:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     fd0:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
	}
}
     fd4:	df 91       	pop	r29
     fd6:	cf 91       	pop	r28
     fd8:	1f 91       	pop	r17
     fda:	0f 91       	pop	r16
     fdc:	08 95       	ret

00000fde <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     fde:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     fe2:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     fe6:	08 95       	ret

00000fe8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     fe8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     fea:	03 96       	adiw	r24, 0x03	; 3
     fec:	81 83       	std	Z+1, r24	; 0x01
     fee:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     ff0:	4f ef       	ldi	r20, 0xFF	; 255
     ff2:	5f ef       	ldi	r21, 0xFF	; 255
     ff4:	ba 01       	movw	r22, r20
     ff6:	43 83       	std	Z+3, r20	; 0x03
     ff8:	54 83       	std	Z+4, r21	; 0x04
     ffa:	65 83       	std	Z+5, r22	; 0x05
     ffc:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     ffe:	87 83       	std	Z+7, r24	; 0x07
    1000:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1002:	81 87       	std	Z+9, r24	; 0x09
    1004:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1006:	10 82       	st	Z, r1
    1008:	08 95       	ret

0000100a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    100a:	fc 01       	movw	r30, r24
    100c:	12 86       	std	Z+10, r1	; 0x0a
    100e:	13 86       	std	Z+11, r1	; 0x0b
    1010:	08 95       	ret

00001012 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
    1016:	fc 01       	movw	r30, r24
    1018:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    101a:	21 81       	ldd	r18, Z+1	; 0x01
    101c:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    101e:	e9 01       	movw	r28, r18
    1020:	8c 81       	ldd	r24, Y+4	; 0x04
    1022:	9d 81       	ldd	r25, Y+5	; 0x05
    1024:	14 96       	adiw	r26, 0x04	; 4
    1026:	8d 93       	st	X+, r24
    1028:	9c 93       	st	X, r25
    102a:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    102c:	81 81       	ldd	r24, Z+1	; 0x01
    102e:	92 81       	ldd	r25, Z+2	; 0x02
    1030:	16 96       	adiw	r26, 0x06	; 6
    1032:	8d 93       	st	X+, r24
    1034:	9c 93       	st	X, r25
    1036:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1038:	8c 81       	ldd	r24, Y+4	; 0x04
    103a:	9d 81       	ldd	r25, Y+5	; 0x05
    103c:	ec 01       	movw	r28, r24
    103e:	6e 83       	std	Y+6, r22	; 0x06
    1040:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1042:	e9 01       	movw	r28, r18
    1044:	6c 83       	std	Y+4, r22	; 0x04
    1046:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1048:	61 83       	std	Z+1, r22	; 0x01
    104a:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    104c:	1a 96       	adiw	r26, 0x0a	; 10
    104e:	ed 93       	st	X+, r30
    1050:	fc 93       	st	X, r31
    1052:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1054:	80 81       	ld	r24, Z
    1056:	8f 5f       	subi	r24, 0xFF	; 255
    1058:	80 83       	st	Z, r24
}
    105a:	df 91       	pop	r29
    105c:	cf 91       	pop	r28
    105e:	08 95       	ret

00001060 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1060:	0f 93       	push	r16
    1062:	1f 93       	push	r17
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    106a:	08 81       	ld	r16, Y
    106c:	19 81       	ldd	r17, Y+1	; 0x01
    106e:	2a 81       	ldd	r18, Y+2	; 0x02
    1070:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1072:	0f 3f       	cpi	r16, 0xFF	; 255
    1074:	4f ef       	ldi	r20, 0xFF	; 255
    1076:	14 07       	cpc	r17, r20
    1078:	24 07       	cpc	r18, r20
    107a:	34 07       	cpc	r19, r20
    107c:	31 f4       	brne	.+12     	; 0x108a <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    107e:	dc 01       	movw	r26, r24
    1080:	19 96       	adiw	r26, 0x09	; 9
    1082:	ed 91       	ld	r30, X+
    1084:	fc 91       	ld	r31, X
    1086:	1a 97       	sbiw	r26, 0x0a	; 10
    1088:	1f c0       	rjmp	.+62     	; 0x10c8 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    108a:	fc 01       	movw	r30, r24
    108c:	33 96       	adiw	r30, 0x03	; 3
    108e:	dc 01       	movw	r26, r24
    1090:	17 96       	adiw	r26, 0x07	; 7
    1092:	4d 91       	ld	r20, X+
    1094:	5c 91       	ld	r21, X
    1096:	18 97       	sbiw	r26, 0x08	; 8
    1098:	da 01       	movw	r26, r20
    109a:	4d 91       	ld	r20, X+
    109c:	5d 91       	ld	r21, X+
    109e:	6d 91       	ld	r22, X+
    10a0:	7c 91       	ld	r23, X
    10a2:	04 17       	cp	r16, r20
    10a4:	15 07       	cpc	r17, r21
    10a6:	26 07       	cpc	r18, r22
    10a8:	37 07       	cpc	r19, r23
    10aa:	70 f0       	brcs	.+28     	; 0x10c8 <vListInsert+0x68>
    10ac:	04 80       	ldd	r0, Z+4	; 0x04
    10ae:	f5 81       	ldd	r31, Z+5	; 0x05
    10b0:	e0 2d       	mov	r30, r0
    10b2:	a4 81       	ldd	r26, Z+4	; 0x04
    10b4:	b5 81       	ldd	r27, Z+5	; 0x05
    10b6:	4d 91       	ld	r20, X+
    10b8:	5d 91       	ld	r21, X+
    10ba:	6d 91       	ld	r22, X+
    10bc:	7c 91       	ld	r23, X
    10be:	04 17       	cp	r16, r20
    10c0:	15 07       	cpc	r17, r21
    10c2:	26 07       	cpc	r18, r22
    10c4:	37 07       	cpc	r19, r23
    10c6:	90 f7       	brcc	.-28     	; 0x10ac <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    10c8:	a4 81       	ldd	r26, Z+4	; 0x04
    10ca:	b5 81       	ldd	r27, Z+5	; 0x05
    10cc:	ac 83       	std	Y+4, r26	; 0x04
    10ce:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10d0:	16 96       	adiw	r26, 0x06	; 6
    10d2:	cd 93       	st	X+, r28
    10d4:	dc 93       	st	X, r29
    10d6:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    10d8:	ee 83       	std	Y+6, r30	; 0x06
    10da:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    10dc:	c4 83       	std	Z+4, r28	; 0x04
    10de:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10e0:	8a 87       	std	Y+10, r24	; 0x0a
    10e2:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    10e4:	fc 01       	movw	r30, r24
    10e6:	20 81       	ld	r18, Z
    10e8:	2f 5f       	subi	r18, 0xFF	; 255
    10ea:	20 83       	st	Z, r18
}
    10ec:	df 91       	pop	r29
    10ee:	cf 91       	pop	r28
    10f0:	1f 91       	pop	r17
    10f2:	0f 91       	pop	r16
    10f4:	08 95       	ret

000010f6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    10f6:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10f8:	a4 81       	ldd	r26, Z+4	; 0x04
    10fa:	b5 81       	ldd	r27, Z+5	; 0x05
    10fc:	86 81       	ldd	r24, Z+6	; 0x06
    10fe:	97 81       	ldd	r25, Z+7	; 0x07
    1100:	16 96       	adiw	r26, 0x06	; 6
    1102:	8d 93       	st	X+, r24
    1104:	9c 93       	st	X, r25
    1106:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1108:	a6 81       	ldd	r26, Z+6	; 0x06
    110a:	b7 81       	ldd	r27, Z+7	; 0x07
    110c:	84 81       	ldd	r24, Z+4	; 0x04
    110e:	95 81       	ldd	r25, Z+5	; 0x05
    1110:	14 96       	adiw	r26, 0x04	; 4
    1112:	8d 93       	st	X+, r24
    1114:	9c 93       	st	X, r25
    1116:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1118:	a2 85       	ldd	r26, Z+10	; 0x0a
    111a:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    111c:	11 96       	adiw	r26, 0x01	; 1
    111e:	8d 91       	ld	r24, X+
    1120:	9c 91       	ld	r25, X
    1122:	12 97       	sbiw	r26, 0x02	; 2
    1124:	e8 17       	cp	r30, r24
    1126:	f9 07       	cpc	r31, r25
    1128:	31 f4       	brne	.+12     	; 0x1136 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    112a:	86 81       	ldd	r24, Z+6	; 0x06
    112c:	97 81       	ldd	r25, Z+7	; 0x07
    112e:	11 96       	adiw	r26, 0x01	; 1
    1130:	8d 93       	st	X+, r24
    1132:	9c 93       	st	X, r25
    1134:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1136:	12 86       	std	Z+10, r1	; 0x0a
    1138:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    113a:	8c 91       	ld	r24, X
    113c:	81 50       	subi	r24, 0x01	; 1
    113e:	8c 93       	st	X, r24
    1140:	08 95       	ret

00001142 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1142:	80 93 aa 31 	sts	0x31AA, r24	; 0x8031aa <portStackTopForTask>
    1146:	90 93 ab 31 	sts	0x31AB, r25	; 0x8031ab <portStackTopForTask+0x1>
    114a:	31 e1       	ldi	r19, 0x11	; 17
    114c:	fc 01       	movw	r30, r24
    114e:	30 83       	st	Z, r19
    1150:	31 97       	sbiw	r30, 0x01	; 1
    1152:	22 e2       	ldi	r18, 0x22	; 34
    1154:	20 83       	st	Z, r18
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	a3 e3       	ldi	r26, 0x33	; 51
    115a:	a0 83       	st	Z, r26
    115c:	31 97       	sbiw	r30, 0x01	; 1
    115e:	60 83       	st	Z, r22
    1160:	31 97       	sbiw	r30, 0x01	; 1
    1162:	70 83       	st	Z, r23
    1164:	31 97       	sbiw	r30, 0x01	; 1
    1166:	10 82       	st	Z, r1
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	10 82       	st	Z, r1
    116c:	31 97       	sbiw	r30, 0x01	; 1
    116e:	60 e8       	ldi	r22, 0x80	; 128
    1170:	60 83       	st	Z, r22
    1172:	31 97       	sbiw	r30, 0x01	; 1
    1174:	10 82       	st	Z, r1
    1176:	31 97       	sbiw	r30, 0x01	; 1
    1178:	10 82       	st	Z, r1
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	10 82       	st	Z, r1
    117e:	31 97       	sbiw	r30, 0x01	; 1
    1180:	62 e0       	ldi	r22, 0x02	; 2
    1182:	60 83       	st	Z, r22
    1184:	31 97       	sbiw	r30, 0x01	; 1
    1186:	63 e0       	ldi	r22, 0x03	; 3
    1188:	60 83       	st	Z, r22
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	64 e0       	ldi	r22, 0x04	; 4
    118e:	60 83       	st	Z, r22
    1190:	31 97       	sbiw	r30, 0x01	; 1
    1192:	65 e0       	ldi	r22, 0x05	; 5
    1194:	60 83       	st	Z, r22
    1196:	31 97       	sbiw	r30, 0x01	; 1
    1198:	66 e0       	ldi	r22, 0x06	; 6
    119a:	60 83       	st	Z, r22
    119c:	31 97       	sbiw	r30, 0x01	; 1
    119e:	67 e0       	ldi	r22, 0x07	; 7
    11a0:	60 83       	st	Z, r22
    11a2:	31 97       	sbiw	r30, 0x01	; 1
    11a4:	68 e0       	ldi	r22, 0x08	; 8
    11a6:	60 83       	st	Z, r22
    11a8:	31 97       	sbiw	r30, 0x01	; 1
    11aa:	69 e0       	ldi	r22, 0x09	; 9
    11ac:	60 83       	st	Z, r22
    11ae:	31 97       	sbiw	r30, 0x01	; 1
    11b0:	60 e1       	ldi	r22, 0x10	; 16
    11b2:	60 83       	st	Z, r22
    11b4:	31 97       	sbiw	r30, 0x01	; 1
    11b6:	30 83       	st	Z, r19
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	32 e1       	ldi	r19, 0x12	; 18
    11bc:	30 83       	st	Z, r19
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	33 e1       	ldi	r19, 0x13	; 19
    11c2:	30 83       	st	Z, r19
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	34 e1       	ldi	r19, 0x14	; 20
    11c8:	30 83       	st	Z, r19
    11ca:	31 97       	sbiw	r30, 0x01	; 1
    11cc:	35 e1       	ldi	r19, 0x15	; 21
    11ce:	30 83       	st	Z, r19
    11d0:	31 97       	sbiw	r30, 0x01	; 1
    11d2:	36 e1       	ldi	r19, 0x16	; 22
    11d4:	30 83       	st	Z, r19
    11d6:	31 97       	sbiw	r30, 0x01	; 1
    11d8:	37 e1       	ldi	r19, 0x17	; 23
    11da:	30 83       	st	Z, r19
    11dc:	31 97       	sbiw	r30, 0x01	; 1
    11de:	38 e1       	ldi	r19, 0x18	; 24
    11e0:	30 83       	st	Z, r19
    11e2:	31 97       	sbiw	r30, 0x01	; 1
    11e4:	39 e1       	ldi	r19, 0x19	; 25
    11e6:	30 83       	st	Z, r19
    11e8:	31 97       	sbiw	r30, 0x01	; 1
    11ea:	30 e2       	ldi	r19, 0x20	; 32
    11ec:	30 83       	st	Z, r19
    11ee:	31 97       	sbiw	r30, 0x01	; 1
    11f0:	31 e2       	ldi	r19, 0x21	; 33
    11f2:	30 83       	st	Z, r19
    11f4:	31 97       	sbiw	r30, 0x01	; 1
    11f6:	20 83       	st	Z, r18
    11f8:	31 97       	sbiw	r30, 0x01	; 1
    11fa:	23 e2       	ldi	r18, 0x23	; 35
    11fc:	20 83       	st	Z, r18
    11fe:	31 97       	sbiw	r30, 0x01	; 1
    1200:	40 83       	st	Z, r20
    1202:	31 97       	sbiw	r30, 0x01	; 1
    1204:	50 83       	st	Z, r21
    1206:	31 97       	sbiw	r30, 0x01	; 1
    1208:	26 e2       	ldi	r18, 0x26	; 38
    120a:	20 83       	st	Z, r18
    120c:	31 97       	sbiw	r30, 0x01	; 1
    120e:	27 e2       	ldi	r18, 0x27	; 39
    1210:	20 83       	st	Z, r18
    1212:	31 97       	sbiw	r30, 0x01	; 1
    1214:	28 e2       	ldi	r18, 0x28	; 40
    1216:	20 83       	st	Z, r18
    1218:	31 97       	sbiw	r30, 0x01	; 1
    121a:	29 e2       	ldi	r18, 0x29	; 41
    121c:	20 83       	st	Z, r18
    121e:	31 97       	sbiw	r30, 0x01	; 1
    1220:	20 e3       	ldi	r18, 0x30	; 48
    1222:	20 83       	st	Z, r18
    1224:	31 97       	sbiw	r30, 0x01	; 1
    1226:	21 e3       	ldi	r18, 0x31	; 49
    1228:	20 83       	st	Z, r18
    122a:	89 97       	sbiw	r24, 0x29	; 41
    122c:	08 95       	ret

0000122e <xPortStartScheduler>:
    122e:	8c e7       	ldi	r24, 0x7C	; 124
    1230:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1234:	8f ef       	ldi	r24, 0xFF	; 255
    1236:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1240:	91 e1       	ldi	r25, 0x11	; 17
    1242:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1246:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    124a:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    124e:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1252:	cd 91       	ld	r28, X+
    1254:	cd bf       	out	0x3d, r28	; 61
    1256:	dd 91       	ld	r29, X+
    1258:	de bf       	out	0x3e, r29	; 62
    125a:	ff 91       	pop	r31
    125c:	ef 91       	pop	r30
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	bf 91       	pop	r27
    1264:	af 91       	pop	r26
    1266:	9f 91       	pop	r25
    1268:	8f 91       	pop	r24
    126a:	7f 91       	pop	r23
    126c:	6f 91       	pop	r22
    126e:	5f 91       	pop	r21
    1270:	4f 91       	pop	r20
    1272:	3f 91       	pop	r19
    1274:	2f 91       	pop	r18
    1276:	1f 91       	pop	r17
    1278:	0f 91       	pop	r16
    127a:	ff 90       	pop	r15
    127c:	ef 90       	pop	r14
    127e:	df 90       	pop	r13
    1280:	cf 90       	pop	r12
    1282:	bf 90       	pop	r11
    1284:	af 90       	pop	r10
    1286:	9f 90       	pop	r9
    1288:	8f 90       	pop	r8
    128a:	7f 90       	pop	r7
    128c:	6f 90       	pop	r6
    128e:	5f 90       	pop	r5
    1290:	4f 90       	pop	r4
    1292:	3f 90       	pop	r3
    1294:	2f 90       	pop	r2
    1296:	1f 90       	pop	r1
    1298:	0f 90       	pop	r0
    129a:	0c be       	out	0x3c, r0	; 60
    129c:	0f 90       	pop	r0
    129e:	0b be       	out	0x3b, r0	; 59
    12a0:	0f 90       	pop	r0
    12a2:	0f be       	out	0x3f, r0	; 63
    12a4:	0f 90       	pop	r0
    12a6:	08 95       	ret
    12a8:	08 95       	ret

000012aa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12aa:	0f 92       	push	r0
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	f8 94       	cli
    12b0:	0f 92       	push	r0
    12b2:	0b b6       	in	r0, 0x3b	; 59
    12b4:	0f 92       	push	r0
    12b6:	0c b6       	in	r0, 0x3c	; 60
    12b8:	0f 92       	push	r0
    12ba:	1f 92       	push	r1
    12bc:	11 24       	eor	r1, r1
    12be:	2f 92       	push	r2
    12c0:	3f 92       	push	r3
    12c2:	4f 92       	push	r4
    12c4:	5f 92       	push	r5
    12c6:	6f 92       	push	r6
    12c8:	7f 92       	push	r7
    12ca:	8f 92       	push	r8
    12cc:	9f 92       	push	r9
    12ce:	af 92       	push	r10
    12d0:	bf 92       	push	r11
    12d2:	cf 92       	push	r12
    12d4:	df 92       	push	r13
    12d6:	ef 92       	push	r14
    12d8:	ff 92       	push	r15
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	2f 93       	push	r18
    12e0:	3f 93       	push	r19
    12e2:	4f 93       	push	r20
    12e4:	5f 93       	push	r21
    12e6:	6f 93       	push	r22
    12e8:	7f 93       	push	r23
    12ea:	8f 93       	push	r24
    12ec:	9f 93       	push	r25
    12ee:	af 93       	push	r26
    12f0:	bf 93       	push	r27
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	ef 93       	push	r30
    12f8:	ff 93       	push	r31
    12fa:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    12fe:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1302:	0d b6       	in	r0, 0x3d	; 61
    1304:	0d 92       	st	X+, r0
    1306:	0e b6       	in	r0, 0x3e	; 62
    1308:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    130a:	0e 94 64 10 	call	0x20c8	; 0x20c8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    130e:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    1312:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1316:	cd 91       	ld	r28, X+
    1318:	cd bf       	out	0x3d, r28	; 61
    131a:	dd 91       	ld	r29, X+
    131c:	de bf       	out	0x3e, r29	; 62
    131e:	ff 91       	pop	r31
    1320:	ef 91       	pop	r30
    1322:	df 91       	pop	r29
    1324:	cf 91       	pop	r28
    1326:	bf 91       	pop	r27
    1328:	af 91       	pop	r26
    132a:	9f 91       	pop	r25
    132c:	8f 91       	pop	r24
    132e:	7f 91       	pop	r23
    1330:	6f 91       	pop	r22
    1332:	5f 91       	pop	r21
    1334:	4f 91       	pop	r20
    1336:	3f 91       	pop	r19
    1338:	2f 91       	pop	r18
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	ff 90       	pop	r15
    1340:	ef 90       	pop	r14
    1342:	df 90       	pop	r13
    1344:	cf 90       	pop	r12
    1346:	bf 90       	pop	r11
    1348:	af 90       	pop	r10
    134a:	9f 90       	pop	r9
    134c:	8f 90       	pop	r8
    134e:	7f 90       	pop	r7
    1350:	6f 90       	pop	r6
    1352:	5f 90       	pop	r5
    1354:	4f 90       	pop	r4
    1356:	3f 90       	pop	r3
    1358:	2f 90       	pop	r2
    135a:	1f 90       	pop	r1
    135c:	0f 90       	pop	r0
    135e:	0c be       	out	0x3c, r0	; 60
    1360:	0f 90       	pop	r0
    1362:	0b be       	out	0x3b, r0	; 59
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63
    1368:	0f 90       	pop	r0

	asm volatile ( "ret" );
    136a:	08 95       	ret

0000136c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    136c:	0f 92       	push	r0
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	0f 92       	push	r0
    1374:	0b b6       	in	r0, 0x3b	; 59
    1376:	0f 92       	push	r0
    1378:	0c b6       	in	r0, 0x3c	; 60
    137a:	0f 92       	push	r0
    137c:	1f 92       	push	r1
    137e:	11 24       	eor	r1, r1
    1380:	2f 92       	push	r2
    1382:	3f 92       	push	r3
    1384:	4f 92       	push	r4
    1386:	5f 92       	push	r5
    1388:	6f 92       	push	r6
    138a:	7f 92       	push	r7
    138c:	8f 92       	push	r8
    138e:	9f 92       	push	r9
    1390:	af 92       	push	r10
    1392:	bf 92       	push	r11
    1394:	cf 92       	push	r12
    1396:	df 92       	push	r13
    1398:	ef 92       	push	r14
    139a:	ff 92       	push	r15
    139c:	0f 93       	push	r16
    139e:	1f 93       	push	r17
    13a0:	2f 93       	push	r18
    13a2:	3f 93       	push	r19
    13a4:	4f 93       	push	r20
    13a6:	5f 93       	push	r21
    13a8:	6f 93       	push	r22
    13aa:	7f 93       	push	r23
    13ac:	8f 93       	push	r24
    13ae:	9f 93       	push	r25
    13b0:	af 93       	push	r26
    13b2:	bf 93       	push	r27
    13b4:	cf 93       	push	r28
    13b6:	df 93       	push	r29
    13b8:	ef 93       	push	r30
    13ba:	ff 93       	push	r31
    13bc:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    13c0:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    13c4:	0d b6       	in	r0, 0x3d	; 61
    13c6:	0d 92       	st	X+, r0
    13c8:	0e b6       	in	r0, 0x3e	; 62
    13ca:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    13cc:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vTaskIncrementTick>
	vTaskSwitchContext();
    13d0:	0e 94 64 10 	call	0x20c8	; 0x20c8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13d4:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    13d8:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    13dc:	cd 91       	ld	r28, X+
    13de:	cd bf       	out	0x3d, r28	; 61
    13e0:	dd 91       	ld	r29, X+
    13e2:	de bf       	out	0x3e, r29	; 62
    13e4:	ff 91       	pop	r31
    13e6:	ef 91       	pop	r30
    13e8:	df 91       	pop	r29
    13ea:	cf 91       	pop	r28
    13ec:	bf 91       	pop	r27
    13ee:	af 91       	pop	r26
    13f0:	9f 91       	pop	r25
    13f2:	8f 91       	pop	r24
    13f4:	7f 91       	pop	r23
    13f6:	6f 91       	pop	r22
    13f8:	5f 91       	pop	r21
    13fa:	4f 91       	pop	r20
    13fc:	3f 91       	pop	r19
    13fe:	2f 91       	pop	r18
    1400:	1f 91       	pop	r17
    1402:	0f 91       	pop	r16
    1404:	ff 90       	pop	r15
    1406:	ef 90       	pop	r14
    1408:	df 90       	pop	r13
    140a:	cf 90       	pop	r12
    140c:	bf 90       	pop	r11
    140e:	af 90       	pop	r10
    1410:	9f 90       	pop	r9
    1412:	8f 90       	pop	r8
    1414:	7f 90       	pop	r7
    1416:	6f 90       	pop	r6
    1418:	5f 90       	pop	r5
    141a:	4f 90       	pop	r4
    141c:	3f 90       	pop	r3
    141e:	2f 90       	pop	r2
    1420:	1f 90       	pop	r1
    1422:	0f 90       	pop	r0
    1424:	0c be       	out	0x3c, r0	; 60
    1426:	0f 90       	pop	r0
    1428:	0b be       	out	0x3b, r0	; 59
    142a:	0f 90       	pop	r0
    142c:	0f be       	out	0x3f, r0	; 63
    142e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1430:	08 95       	ret

00001432 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1432:	0e 94 b6 09 	call	0x136c	; 0x136c <vPortYieldFromTick>
		asm volatile ( "reti" );
    1436:	18 95       	reti

00001438 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	ec 01       	movw	r28, r24
    143e:	88 a1       	ldd	r24, Y+32	; 0x20
    1440:	81 11       	cpse	r24, r1
    1442:	0b c0       	rjmp	.+22     	; 0x145a <prvCopyDataToQueue+0x22>
    1444:	88 81       	ld	r24, Y
    1446:	99 81       	ldd	r25, Y+1	; 0x01
    1448:	89 2b       	or	r24, r25
    144a:	e1 f5       	brne	.+120    	; 0x14c4 <prvCopyDataToQueue+0x8c>
    144c:	8a 81       	ldd	r24, Y+2	; 0x02
    144e:	9b 81       	ldd	r25, Y+3	; 0x03
    1450:	0e 94 1f 12 	call	0x243e	; 0x243e <vTaskPriorityDisinherit>
    1454:	1a 82       	std	Y+2, r1	; 0x02
    1456:	1b 82       	std	Y+3, r1	; 0x03
    1458:	35 c0       	rjmp	.+106    	; 0x14c4 <prvCopyDataToQueue+0x8c>
    145a:	41 11       	cpse	r20, r1
    145c:	17 c0       	rjmp	.+46     	; 0x148c <prvCopyDataToQueue+0x54>
    145e:	48 2f       	mov	r20, r24
    1460:	50 e0       	ldi	r21, 0x00	; 0
    1462:	8c 81       	ldd	r24, Y+4	; 0x04
    1464:	9d 81       	ldd	r25, Y+5	; 0x05
    1466:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <memcpy>
    146a:	28 a1       	ldd	r18, Y+32	; 0x20
    146c:	8c 81       	ldd	r24, Y+4	; 0x04
    146e:	9d 81       	ldd	r25, Y+5	; 0x05
    1470:	82 0f       	add	r24, r18
    1472:	91 1d       	adc	r25, r1
    1474:	8c 83       	std	Y+4, r24	; 0x04
    1476:	9d 83       	std	Y+5, r25	; 0x05
    1478:	2a 81       	ldd	r18, Y+2	; 0x02
    147a:	3b 81       	ldd	r19, Y+3	; 0x03
    147c:	82 17       	cp	r24, r18
    147e:	93 07       	cpc	r25, r19
    1480:	08 f1       	brcs	.+66     	; 0x14c4 <prvCopyDataToQueue+0x8c>
    1482:	88 81       	ld	r24, Y
    1484:	99 81       	ldd	r25, Y+1	; 0x01
    1486:	8c 83       	std	Y+4, r24	; 0x04
    1488:	9d 83       	std	Y+5, r25	; 0x05
    148a:	1c c0       	rjmp	.+56     	; 0x14c4 <prvCopyDataToQueue+0x8c>
    148c:	48 2f       	mov	r20, r24
    148e:	50 e0       	ldi	r21, 0x00	; 0
    1490:	8e 81       	ldd	r24, Y+6	; 0x06
    1492:	9f 81       	ldd	r25, Y+7	; 0x07
    1494:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <memcpy>
    1498:	88 a1       	ldd	r24, Y+32	; 0x20
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	91 95       	neg	r25
    149e:	81 95       	neg	r24
    14a0:	91 09       	sbc	r25, r1
    14a2:	2e 81       	ldd	r18, Y+6	; 0x06
    14a4:	3f 81       	ldd	r19, Y+7	; 0x07
    14a6:	28 0f       	add	r18, r24
    14a8:	39 1f       	adc	r19, r25
    14aa:	2e 83       	std	Y+6, r18	; 0x06
    14ac:	3f 83       	std	Y+7, r19	; 0x07
    14ae:	48 81       	ld	r20, Y
    14b0:	59 81       	ldd	r21, Y+1	; 0x01
    14b2:	24 17       	cp	r18, r20
    14b4:	35 07       	cpc	r19, r21
    14b6:	30 f4       	brcc	.+12     	; 0x14c4 <prvCopyDataToQueue+0x8c>
    14b8:	2a 81       	ldd	r18, Y+2	; 0x02
    14ba:	3b 81       	ldd	r19, Y+3	; 0x03
    14bc:	82 0f       	add	r24, r18
    14be:	93 1f       	adc	r25, r19
    14c0:	8e 83       	std	Y+6, r24	; 0x06
    14c2:	9f 83       	std	Y+7, r25	; 0x07
    14c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14c6:	8f 5f       	subi	r24, 0xFF	; 255
    14c8:	8e 8f       	std	Y+30, r24	; 0x1e
    14ca:	df 91       	pop	r29
    14cc:	cf 91       	pop	r28
    14ce:	08 95       	ret

000014d0 <prvCopyDataFromQueue>:
    14d0:	fc 01       	movw	r30, r24
    14d2:	80 81       	ld	r24, Z
    14d4:	91 81       	ldd	r25, Z+1	; 0x01
    14d6:	00 97       	sbiw	r24, 0x00	; 0
    14d8:	a1 f0       	breq	.+40     	; 0x1502 <prvCopyDataFromQueue+0x32>
    14da:	40 a1       	ldd	r20, Z+32	; 0x20
    14dc:	50 e0       	ldi	r21, 0x00	; 0
    14de:	26 81       	ldd	r18, Z+6	; 0x06
    14e0:	37 81       	ldd	r19, Z+7	; 0x07
    14e2:	24 0f       	add	r18, r20
    14e4:	35 1f       	adc	r19, r21
    14e6:	26 83       	std	Z+6, r18	; 0x06
    14e8:	37 83       	std	Z+7, r19	; 0x07
    14ea:	a2 81       	ldd	r26, Z+2	; 0x02
    14ec:	b3 81       	ldd	r27, Z+3	; 0x03
    14ee:	2a 17       	cp	r18, r26
    14f0:	3b 07       	cpc	r19, r27
    14f2:	10 f0       	brcs	.+4      	; 0x14f8 <prvCopyDataFromQueue+0x28>
    14f4:	86 83       	std	Z+6, r24	; 0x06
    14f6:	97 83       	std	Z+7, r25	; 0x07
    14f8:	cb 01       	movw	r24, r22
    14fa:	66 81       	ldd	r22, Z+6	; 0x06
    14fc:	77 81       	ldd	r23, Z+7	; 0x07
    14fe:	0e 94 38 1f 	call	0x3e70	; 0x3e70 <memcpy>
    1502:	08 95       	ret

00001504 <prvUnlockQueue>:
    1504:	0f 93       	push	r16
    1506:	1f 93       	push	r17
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ec 01       	movw	r28, r24
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	0f 92       	push	r0
    1514:	8a a1       	ldd	r24, Y+34	; 0x22
    1516:	18 16       	cp	r1, r24
    1518:	b4 f4       	brge	.+44     	; 0x1546 <prvUnlockQueue+0x42>
    151a:	8b 89       	ldd	r24, Y+19	; 0x13
    151c:	81 11       	cpse	r24, r1
    151e:	05 c0       	rjmp	.+10     	; 0x152a <prvUnlockQueue+0x26>
    1520:	12 c0       	rjmp	.+36     	; 0x1546 <prvUnlockQueue+0x42>
    1522:	8b 89       	ldd	r24, Y+19	; 0x13
    1524:	81 11       	cpse	r24, r1
    1526:	04 c0       	rjmp	.+8      	; 0x1530 <prvUnlockQueue+0x2c>
    1528:	0e c0       	rjmp	.+28     	; 0x1546 <prvUnlockQueue+0x42>
    152a:	8e 01       	movw	r16, r28
    152c:	0d 5e       	subi	r16, 0xED	; 237
    152e:	1f 4f       	sbci	r17, 0xFF	; 255
    1530:	c8 01       	movw	r24, r16
    1532:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    1536:	81 11       	cpse	r24, r1
    1538:	0e 94 a8 11 	call	0x2350	; 0x2350 <vTaskMissedYield>
    153c:	8a a1       	ldd	r24, Y+34	; 0x22
    153e:	81 50       	subi	r24, 0x01	; 1
    1540:	8a a3       	std	Y+34, r24	; 0x22
    1542:	18 16       	cp	r1, r24
    1544:	74 f3       	brlt	.-36     	; 0x1522 <prvUnlockQueue+0x1e>
    1546:	8f ef       	ldi	r24, 0xFF	; 255
    1548:	8a a3       	std	Y+34, r24	; 0x22
    154a:	0f 90       	pop	r0
    154c:	0f be       	out	0x3f, r0	; 63
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	0f 92       	push	r0
    1554:	89 a1       	ldd	r24, Y+33	; 0x21
    1556:	18 16       	cp	r1, r24
    1558:	b4 f4       	brge	.+44     	; 0x1586 <prvUnlockQueue+0x82>
    155a:	88 85       	ldd	r24, Y+8	; 0x08
    155c:	81 11       	cpse	r24, r1
    155e:	05 c0       	rjmp	.+10     	; 0x156a <prvUnlockQueue+0x66>
    1560:	12 c0       	rjmp	.+36     	; 0x1586 <prvUnlockQueue+0x82>
    1562:	88 85       	ldd	r24, Y+8	; 0x08
    1564:	81 11       	cpse	r24, r1
    1566:	04 c0       	rjmp	.+8      	; 0x1570 <prvUnlockQueue+0x6c>
    1568:	0e c0       	rjmp	.+28     	; 0x1586 <prvUnlockQueue+0x82>
    156a:	8e 01       	movw	r16, r28
    156c:	08 5f       	subi	r16, 0xF8	; 248
    156e:	1f 4f       	sbci	r17, 0xFF	; 255
    1570:	c8 01       	movw	r24, r16
    1572:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    1576:	81 11       	cpse	r24, r1
    1578:	0e 94 a8 11 	call	0x2350	; 0x2350 <vTaskMissedYield>
    157c:	89 a1       	ldd	r24, Y+33	; 0x21
    157e:	81 50       	subi	r24, 0x01	; 1
    1580:	89 a3       	std	Y+33, r24	; 0x21
    1582:	18 16       	cp	r1, r24
    1584:	74 f3       	brlt	.-36     	; 0x1562 <prvUnlockQueue+0x5e>
    1586:	8f ef       	ldi	r24, 0xFF	; 255
    1588:	89 a3       	std	Y+33, r24	; 0x21
    158a:	0f 90       	pop	r0
    158c:	0f be       	out	0x3f, r0	; 63
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	08 95       	ret

00001598 <xQueueGenericReset>:
    1598:	1f 93       	push	r17
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	61 30       	cpi	r22, 0x01	; 1
    15a0:	59 f0       	breq	.+22     	; 0x15b8 <xQueueGenericReset+0x20>
    15a2:	fc 01       	movw	r30, r24
    15a4:	23 89       	ldd	r18, Z+19	; 0x13
    15a6:	30 85       	ldd	r19, Z+8	; 0x08
    15a8:	31 11       	cpse	r19, r1
    15aa:	2c c0       	rjmp	.+88     	; 0x1604 <xQueueGenericReset+0x6c>
    15ac:	11 e0       	ldi	r17, 0x01	; 1
    15ae:	21 11       	cpse	r18, r1
    15b0:	10 e0       	ldi	r17, 0x00	; 0
    15b2:	21 11       	cpse	r18, r1
    15b4:	28 c0       	rjmp	.+80     	; 0x1606 <xQueueGenericReset+0x6e>
    15b6:	01 c0       	rjmp	.+2      	; 0x15ba <xQueueGenericReset+0x22>
    15b8:	11 e0       	ldi	r17, 0x01	; 1
    15ba:	ec 01       	movw	r28, r24
    15bc:	48 81       	ld	r20, Y
    15be:	59 81       	ldd	r21, Y+1	; 0x01
    15c0:	28 a1       	ldd	r18, Y+32	; 0x20
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    15c6:	62 9f       	mul	r22, r18
    15c8:	c0 01       	movw	r24, r0
    15ca:	63 9f       	mul	r22, r19
    15cc:	90 0d       	add	r25, r0
    15ce:	11 24       	eor	r1, r1
    15d0:	ba 01       	movw	r22, r20
    15d2:	68 0f       	add	r22, r24
    15d4:	79 1f       	adc	r23, r25
    15d6:	6a 83       	std	Y+2, r22	; 0x02
    15d8:	7b 83       	std	Y+3, r23	; 0x03
    15da:	1e 8e       	std	Y+30, r1	; 0x1e
    15dc:	4c 83       	std	Y+4, r20	; 0x04
    15de:	5d 83       	std	Y+5, r21	; 0x05
    15e0:	82 1b       	sub	r24, r18
    15e2:	93 0b       	sbc	r25, r19
    15e4:	84 0f       	add	r24, r20
    15e6:	95 1f       	adc	r25, r21
    15e8:	8e 83       	std	Y+6, r24	; 0x06
    15ea:	9f 83       	std	Y+7, r25	; 0x07
    15ec:	8f ef       	ldi	r24, 0xFF	; 255
    15ee:	89 a3       	std	Y+33, r24	; 0x21
    15f0:	8a a3       	std	Y+34, r24	; 0x22
    15f2:	ce 01       	movw	r24, r28
    15f4:	08 96       	adiw	r24, 0x08	; 8
    15f6:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    15fa:	ce 01       	movw	r24, r28
    15fc:	43 96       	adiw	r24, 0x13	; 19
    15fe:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1602:	01 c0       	rjmp	.+2      	; 0x1606 <xQueueGenericReset+0x6e>
    1604:	10 e0       	ldi	r17, 0x00	; 0
    1606:	81 2f       	mov	r24, r17
    1608:	df 91       	pop	r29
    160a:	cf 91       	pop	r28
    160c:	1f 91       	pop	r17
    160e:	08 95       	ret

00001610 <xQueueGenericCreate>:
    1610:	0f 93       	push	r16
    1612:	1f 93       	push	r17
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
    1618:	88 23       	and	r24, r24
    161a:	01 f1       	breq	.+64     	; 0x165c <xQueueGenericCreate+0x4c>
    161c:	06 2f       	mov	r16, r22
    161e:	18 2f       	mov	r17, r24
    1620:	83 e2       	ldi	r24, 0x23	; 35
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    1628:	ec 01       	movw	r28, r24
    162a:	89 2b       	or	r24, r25
    162c:	c9 f0       	breq	.+50     	; 0x1660 <xQueueGenericCreate+0x50>
    162e:	10 9f       	mul	r17, r16
    1630:	c0 01       	movw	r24, r0
    1632:	11 24       	eor	r1, r1
    1634:	01 96       	adiw	r24, 0x01	; 1
    1636:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    163a:	88 83       	st	Y, r24
    163c:	99 83       	std	Y+1, r25	; 0x01
    163e:	89 2b       	or	r24, r25
    1640:	39 f0       	breq	.+14     	; 0x1650 <xQueueGenericCreate+0x40>
    1642:	1f 8f       	std	Y+31, r17	; 0x1f
    1644:	08 a3       	std	Y+32, r16	; 0x20
    1646:	61 e0       	ldi	r22, 0x01	; 1
    1648:	ce 01       	movw	r24, r28
    164a:	0e 94 cc 0a 	call	0x1598	; 0x1598 <xQueueGenericReset>
    164e:	08 c0       	rjmp	.+16     	; 0x1660 <xQueueGenericCreate+0x50>
    1650:	ce 01       	movw	r24, r28
    1652:	0e 94 bc 07 	call	0xf78	; 0xf78 <vPortFree>
    1656:	c0 e0       	ldi	r28, 0x00	; 0
    1658:	d0 e0       	ldi	r29, 0x00	; 0
    165a:	02 c0       	rjmp	.+4      	; 0x1660 <xQueueGenericCreate+0x50>
    165c:	c0 e0       	ldi	r28, 0x00	; 0
    165e:	d0 e0       	ldi	r29, 0x00	; 0
    1660:	ce 01       	movw	r24, r28
    1662:	df 91       	pop	r29
    1664:	cf 91       	pop	r28
    1666:	1f 91       	pop	r17
    1668:	0f 91       	pop	r16
    166a:	08 95       	ret

0000166c <xQueueGenericSend>:
    166c:	af 92       	push	r10
    166e:	bf 92       	push	r11
    1670:	cf 92       	push	r12
    1672:	df 92       	push	r13
    1674:	ef 92       	push	r14
    1676:	ff 92       	push	r15
    1678:	0f 93       	push	r16
    167a:	1f 93       	push	r17
    167c:	cf 93       	push	r28
    167e:	df 93       	push	r29
    1680:	cd b7       	in	r28, 0x3d	; 61
    1682:	de b7       	in	r29, 0x3e	; 62
    1684:	29 97       	sbiw	r28, 0x09	; 9
    1686:	cd bf       	out	0x3d, r28	; 61
    1688:	de bf       	out	0x3e, r29	; 62
    168a:	7c 01       	movw	r14, r24
    168c:	5b 01       	movw	r10, r22
    168e:	2e 83       	std	Y+6, r18	; 0x06
    1690:	3f 83       	std	Y+7, r19	; 0x07
    1692:	48 87       	std	Y+8, r20	; 0x08
    1694:	59 87       	std	Y+9, r21	; 0x09
    1696:	10 e0       	ldi	r17, 0x00	; 0
    1698:	6c 01       	movw	r12, r24
    169a:	88 e0       	ldi	r24, 0x08	; 8
    169c:	c8 0e       	add	r12, r24
    169e:	d1 1c       	adc	r13, r1
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	0f 92       	push	r0
    16a6:	f7 01       	movw	r30, r14
    16a8:	96 8d       	ldd	r25, Z+30	; 0x1e
    16aa:	87 8d       	ldd	r24, Z+31	; 0x1f
    16ac:	98 17       	cp	r25, r24
    16ae:	a8 f4       	brcc	.+42     	; 0x16da <xQueueGenericSend+0x6e>
    16b0:	40 2f       	mov	r20, r16
    16b2:	b5 01       	movw	r22, r10
    16b4:	c7 01       	movw	r24, r14
    16b6:	0e 94 1c 0a 	call	0x1438	; 0x1438 <prvCopyDataToQueue>
    16ba:	f7 01       	movw	r30, r14
    16bc:	83 89       	ldd	r24, Z+19	; 0x13
    16be:	88 23       	and	r24, r24
    16c0:	41 f0       	breq	.+16     	; 0x16d2 <xQueueGenericSend+0x66>
    16c2:	c7 01       	movw	r24, r14
    16c4:	43 96       	adiw	r24, 0x13	; 19
    16c6:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    16ca:	81 30       	cpi	r24, 0x01	; 1
    16cc:	11 f4       	brne	.+4      	; 0x16d2 <xQueueGenericSend+0x66>
    16ce:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    16d2:	0f 90       	pop	r0
    16d4:	0f be       	out	0x3f, r0	; 63
    16d6:	81 e0       	ldi	r24, 0x01	; 1
    16d8:	56 c0       	rjmp	.+172    	; 0x1786 <xQueueGenericSend+0x11a>
    16da:	8e 81       	ldd	r24, Y+6	; 0x06
    16dc:	9f 81       	ldd	r25, Y+7	; 0x07
    16de:	a8 85       	ldd	r26, Y+8	; 0x08
    16e0:	b9 85       	ldd	r27, Y+9	; 0x09
    16e2:	89 2b       	or	r24, r25
    16e4:	8a 2b       	or	r24, r26
    16e6:	8b 2b       	or	r24, r27
    16e8:	21 f4       	brne	.+8      	; 0x16f2 <xQueueGenericSend+0x86>
    16ea:	0f 90       	pop	r0
    16ec:	0f be       	out	0x3f, r0	; 63
    16ee:	80 e0       	ldi	r24, 0x00	; 0
    16f0:	4a c0       	rjmp	.+148    	; 0x1786 <xQueueGenericSend+0x11a>
    16f2:	11 11       	cpse	r17, r1
    16f4:	05 c0       	rjmp	.+10     	; 0x1700 <xQueueGenericSend+0x94>
    16f6:	ce 01       	movw	r24, r28
    16f8:	01 96       	adiw	r24, 0x01	; 1
    16fa:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskSetTimeOutState>
    16fe:	11 e0       	ldi	r17, 0x01	; 1
    1700:	0f 90       	pop	r0
    1702:	0f be       	out	0x3f, r0	; 63
    1704:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskSuspendAll>
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
    170e:	f7 01       	movw	r30, r14
    1710:	81 a1       	ldd	r24, Z+33	; 0x21
    1712:	8f 3f       	cpi	r24, 0xFF	; 255
    1714:	09 f4       	brne	.+2      	; 0x1718 <xQueueGenericSend+0xac>
    1716:	11 a2       	std	Z+33, r1	; 0x21
    1718:	f7 01       	movw	r30, r14
    171a:	82 a1       	ldd	r24, Z+34	; 0x22
    171c:	8f 3f       	cpi	r24, 0xFF	; 255
    171e:	09 f4       	brne	.+2      	; 0x1722 <xQueueGenericSend+0xb6>
    1720:	12 a2       	std	Z+34, r1	; 0x22
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	be 01       	movw	r22, r28
    1728:	6a 5f       	subi	r22, 0xFA	; 250
    172a:	7f 4f       	sbci	r23, 0xFF	; 255
    172c:	ce 01       	movw	r24, r28
    172e:	01 96       	adiw	r24, 0x01	; 1
    1730:	0e 94 3b 11 	call	0x2276	; 0x2276 <xTaskCheckForTimeOut>
    1734:	81 11       	cpse	r24, r1
    1736:	21 c0       	rjmp	.+66     	; 0x177a <xQueueGenericSend+0x10e>
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	f8 94       	cli
    173c:	0f 92       	push	r0
    173e:	f7 01       	movw	r30, r14
    1740:	96 8d       	ldd	r25, Z+30	; 0x1e
    1742:	0f 90       	pop	r0
    1744:	0f be       	out	0x3f, r0	; 63
    1746:	87 8d       	ldd	r24, Z+31	; 0x1f
    1748:	98 13       	cpse	r25, r24
    174a:	11 c0       	rjmp	.+34     	; 0x176e <xQueueGenericSend+0x102>
    174c:	4e 81       	ldd	r20, Y+6	; 0x06
    174e:	5f 81       	ldd	r21, Y+7	; 0x07
    1750:	68 85       	ldd	r22, Y+8	; 0x08
    1752:	79 85       	ldd	r23, Y+9	; 0x09
    1754:	c6 01       	movw	r24, r12
    1756:	0e 94 c1 10 	call	0x2182	; 0x2182 <vTaskPlaceOnEventList>
    175a:	c7 01       	movw	r24, r14
    175c:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
    1760:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
    1764:	81 11       	cpse	r24, r1
    1766:	9c cf       	rjmp	.-200    	; 0x16a0 <xQueueGenericSend+0x34>
    1768:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    176c:	99 cf       	rjmp	.-206    	; 0x16a0 <xQueueGenericSend+0x34>
    176e:	c7 01       	movw	r24, r14
    1770:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
    1774:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
    1778:	93 cf       	rjmp	.-218    	; 0x16a0 <xQueueGenericSend+0x34>
    177a:	c7 01       	movw	r24, r14
    177c:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
    1780:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
    1784:	80 e0       	ldi	r24, 0x00	; 0
    1786:	29 96       	adiw	r28, 0x09	; 9
    1788:	cd bf       	out	0x3d, r28	; 61
    178a:	de bf       	out	0x3e, r29	; 62
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	0f 91       	pop	r16
    1794:	ff 90       	pop	r15
    1796:	ef 90       	pop	r14
    1798:	df 90       	pop	r13
    179a:	cf 90       	pop	r12
    179c:	bf 90       	pop	r11
    179e:	af 90       	pop	r10
    17a0:	08 95       	ret

000017a2 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    17a2:	0f 93       	push	r16
    17a4:	1f 93       	push	r17
    17a6:	cf 93       	push	r28
    17a8:	df 93       	push	r29
    17aa:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17ac:	fc 01       	movw	r30, r24
    17ae:	56 8d       	ldd	r21, Z+30	; 0x1e
    17b0:	37 8d       	ldd	r19, Z+31	; 0x1f
    17b2:	53 17       	cp	r21, r19
    17b4:	c0 f4       	brcc	.+48     	; 0x17e6 <xQueueGenericSendFromISR+0x44>
    17b6:	42 2f       	mov	r20, r18
    17b8:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17ba:	0e 94 1c 0a 	call	0x1438	; 0x1438 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    17be:	8a a1       	ldd	r24, Y+34	; 0x22
    17c0:	8f 3f       	cpi	r24, 0xFF	; 255
    17c2:	69 f4       	brne	.+26     	; 0x17de <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17c4:	8b 89       	ldd	r24, Y+19	; 0x13
    17c6:	88 23       	and	r24, r24
    17c8:	81 f0       	breq	.+32     	; 0x17ea <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ca:	ce 01       	movw	r24, r28
    17cc:	43 96       	adiw	r24, 0x13	; 19
    17ce:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    17d2:	88 23       	and	r24, r24
    17d4:	61 f0       	breq	.+24     	; 0x17ee <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	f8 01       	movw	r30, r16
    17da:	80 83       	st	Z, r24
    17dc:	09 c0       	rjmp	.+18     	; 0x17f0 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17de:	8f 5f       	subi	r24, 0xFF	; 255
    17e0:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    17e2:	81 e0       	ldi	r24, 0x01	; 1
    17e4:	05 c0       	rjmp	.+10     	; 0x17f0 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17e6:	80 e0       	ldi	r24, 0x00	; 0
    17e8:	03 c0       	rjmp	.+6      	; 0x17f0 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	01 c0       	rjmp	.+2      	; 0x17f0 <xQueueGenericSendFromISR+0x4e>
    17ee:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17f0:	df 91       	pop	r29
    17f2:	cf 91       	pop	r28
    17f4:	1f 91       	pop	r17
    17f6:	0f 91       	pop	r16
    17f8:	08 95       	ret

000017fa <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    17fa:	af 92       	push	r10
    17fc:	bf 92       	push	r11
    17fe:	cf 92       	push	r12
    1800:	df 92       	push	r13
    1802:	ef 92       	push	r14
    1804:	ff 92       	push	r15
    1806:	0f 93       	push	r16
    1808:	1f 93       	push	r17
    180a:	cf 93       	push	r28
    180c:	df 93       	push	r29
    180e:	cd b7       	in	r28, 0x3d	; 61
    1810:	de b7       	in	r29, 0x3e	; 62
    1812:	29 97       	sbiw	r28, 0x09	; 9
    1814:	cd bf       	out	0x3d, r28	; 61
    1816:	de bf       	out	0x3e, r29	; 62
    1818:	7c 01       	movw	r14, r24
    181a:	5b 01       	movw	r10, r22
    181c:	2e 83       	std	Y+6, r18	; 0x06
    181e:	3f 83       	std	Y+7, r19	; 0x07
    1820:	48 87       	std	Y+8, r20	; 0x08
    1822:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1824:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1826:	6c 01       	movw	r12, r24
    1828:	83 e1       	ldi	r24, 0x13	; 19
    182a:	c8 0e       	add	r12, r24
    182c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    182e:	0f b6       	in	r0, 0x3f	; 63
    1830:	f8 94       	cli
    1832:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1834:	f7 01       	movw	r30, r14
    1836:	86 8d       	ldd	r24, Z+30	; 0x1e
    1838:	88 23       	and	r24, r24
    183a:	99 f1       	breq	.+102    	; 0x18a2 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    183c:	c6 80       	ldd	r12, Z+6	; 0x06
    183e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1840:	b5 01       	movw	r22, r10
    1842:	c7 01       	movw	r24, r14
    1844:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1848:	01 11       	cpse	r16, r1
    184a:	1a c0       	rjmp	.+52     	; 0x1880 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    184c:	f7 01       	movw	r30, r14
    184e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1850:	81 50       	subi	r24, 0x01	; 1
    1852:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1854:	80 81       	ld	r24, Z
    1856:	91 81       	ldd	r25, Z+1	; 0x01
    1858:	89 2b       	or	r24, r25
    185a:	29 f4       	brne	.+10     	; 0x1866 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    185c:	0e 94 c5 11 	call	0x238a	; 0x238a <xTaskGetCurrentTaskHandle>
    1860:	f7 01       	movw	r30, r14
    1862:	82 83       	std	Z+2, r24	; 0x02
    1864:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1866:	f7 01       	movw	r30, r14
    1868:	80 85       	ldd	r24, Z+8	; 0x08
    186a:	88 23       	and	r24, r24
    186c:	b1 f0       	breq	.+44     	; 0x189a <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    186e:	c7 01       	movw	r24, r14
    1870:	08 96       	adiw	r24, 0x08	; 8
    1872:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    1876:	81 30       	cpi	r24, 0x01	; 1
    1878:	81 f4       	brne	.+32     	; 0x189a <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    187a:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    187e:	0d c0       	rjmp	.+26     	; 0x189a <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1880:	f7 01       	movw	r30, r14
    1882:	c6 82       	std	Z+6, r12	; 0x06
    1884:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1886:	83 89       	ldd	r24, Z+19	; 0x13
    1888:	88 23       	and	r24, r24
    188a:	39 f0       	breq	.+14     	; 0x189a <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    188c:	c7 01       	movw	r24, r14
    188e:	43 96       	adiw	r24, 0x13	; 19
    1890:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    1894:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1896:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    189a:	0f 90       	pop	r0
    189c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	62 c0       	rjmp	.+196    	; 0x1966 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    18a2:	8e 81       	ldd	r24, Y+6	; 0x06
    18a4:	9f 81       	ldd	r25, Y+7	; 0x07
    18a6:	a8 85       	ldd	r26, Y+8	; 0x08
    18a8:	b9 85       	ldd	r27, Y+9	; 0x09
    18aa:	89 2b       	or	r24, r25
    18ac:	8a 2b       	or	r24, r26
    18ae:	8b 2b       	or	r24, r27
    18b0:	21 f4       	brne	.+8      	; 0x18ba <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	56 c0       	rjmp	.+172    	; 0x1966 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    18ba:	11 11       	cpse	r17, r1
    18bc:	05 c0       	rjmp	.+10     	; 0x18c8 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18be:	ce 01       	movw	r24, r28
    18c0:	01 96       	adiw	r24, 0x01	; 1
    18c2:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18c6:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    18c8:	0f 90       	pop	r0
    18ca:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18cc:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18d0:	0f b6       	in	r0, 0x3f	; 63
    18d2:	f8 94       	cli
    18d4:	0f 92       	push	r0
    18d6:	f7 01       	movw	r30, r14
    18d8:	81 a1       	ldd	r24, Z+33	; 0x21
    18da:	8f 3f       	cpi	r24, 0xFF	; 255
    18dc:	09 f4       	brne	.+2      	; 0x18e0 <xQueueGenericReceive+0xe6>
    18de:	11 a2       	std	Z+33, r1	; 0x21
    18e0:	f7 01       	movw	r30, r14
    18e2:	82 a1       	ldd	r24, Z+34	; 0x22
    18e4:	8f 3f       	cpi	r24, 0xFF	; 255
    18e6:	09 f4       	brne	.+2      	; 0x18ea <xQueueGenericReceive+0xf0>
    18e8:	12 a2       	std	Z+34, r1	; 0x22
    18ea:	0f 90       	pop	r0
    18ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18ee:	be 01       	movw	r22, r28
    18f0:	6a 5f       	subi	r22, 0xFA	; 250
    18f2:	7f 4f       	sbci	r23, 0xFF	; 255
    18f4:	ce 01       	movw	r24, r28
    18f6:	01 96       	adiw	r24, 0x01	; 1
    18f8:	0e 94 3b 11 	call	0x2276	; 0x2276 <xTaskCheckForTimeOut>
    18fc:	81 11       	cpse	r24, r1
    18fe:	2d c0       	rjmp	.+90     	; 0x195a <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1900:	0f b6       	in	r0, 0x3f	; 63
    1902:	f8 94       	cli
    1904:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1906:	f7 01       	movw	r30, r14
    1908:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    190a:	0f 90       	pop	r0
    190c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    190e:	81 11       	cpse	r24, r1
    1910:	1e c0       	rjmp	.+60     	; 0x194e <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1912:	80 81       	ld	r24, Z
    1914:	91 81       	ldd	r25, Z+1	; 0x01
    1916:	89 2b       	or	r24, r25
    1918:	49 f4       	brne	.+18     	; 0x192c <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    191a:	0f b6       	in	r0, 0x3f	; 63
    191c:	f8 94       	cli
    191e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1920:	82 81       	ldd	r24, Z+2	; 0x02
    1922:	93 81       	ldd	r25, Z+3	; 0x03
    1924:	0e 94 ca 11 	call	0x2394	; 0x2394 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1928:	0f 90       	pop	r0
    192a:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    192c:	4e 81       	ldd	r20, Y+6	; 0x06
    192e:	5f 81       	ldd	r21, Y+7	; 0x07
    1930:	68 85       	ldd	r22, Y+8	; 0x08
    1932:	79 85       	ldd	r23, Y+9	; 0x09
    1934:	c6 01       	movw	r24, r12
    1936:	0e 94 c1 10 	call	0x2182	; 0x2182 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    193a:	c7 01       	movw	r24, r14
    193c:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1940:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
    1944:	81 11       	cpse	r24, r1
    1946:	73 cf       	rjmp	.-282    	; 0x182e <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1948:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    194c:	70 cf       	rjmp	.-288    	; 0x182e <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    194e:	c7 01       	movw	r24, r14
    1950:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1954:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
    1958:	6a cf       	rjmp	.-300    	; 0x182e <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    195a:	c7 01       	movw	r24, r14
    195c:	0e 94 82 0a 	call	0x1504	; 0x1504 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1960:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1964:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1966:	29 96       	adiw	r28, 0x09	; 9
    1968:	cd bf       	out	0x3d, r28	; 61
    196a:	de bf       	out	0x3e, r29	; 62
    196c:	df 91       	pop	r29
    196e:	cf 91       	pop	r28
    1970:	1f 91       	pop	r17
    1972:	0f 91       	pop	r16
    1974:	ff 90       	pop	r15
    1976:	ef 90       	pop	r14
    1978:	df 90       	pop	r13
    197a:	cf 90       	pop	r12
    197c:	bf 90       	pop	r11
    197e:	af 90       	pop	r10
    1980:	08 95       	ret

00001982 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1982:	0f 93       	push	r16
    1984:	1f 93       	push	r17
    1986:	cf 93       	push	r28
    1988:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    198a:	fc 01       	movw	r30, r24
    198c:	26 8d       	ldd	r18, Z+30	; 0x1e
    198e:	22 23       	and	r18, r18
    1990:	d9 f0       	breq	.+54     	; 0x19c8 <xQueueReceiveFromISR+0x46>
    1992:	8a 01       	movw	r16, r20
    1994:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1996:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    199a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    199c:	81 50       	subi	r24, 0x01	; 1
    199e:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    19a0:	89 a1       	ldd	r24, Y+33	; 0x21
    19a2:	8f 3f       	cpi	r24, 0xFF	; 255
    19a4:	69 f4       	brne	.+26     	; 0x19c0 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19a6:	88 85       	ldd	r24, Y+8	; 0x08
    19a8:	88 23       	and	r24, r24
    19aa:	81 f0       	breq	.+32     	; 0x19cc <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19ac:	ce 01       	movw	r24, r28
    19ae:	08 96       	adiw	r24, 0x08	; 8
    19b0:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xTaskRemoveFromEventList>
    19b4:	88 23       	and	r24, r24
    19b6:	61 f0       	breq	.+24     	; 0x19d0 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	f8 01       	movw	r30, r16
    19bc:	80 83       	st	Z, r24
    19be:	09 c0       	rjmp	.+18     	; 0x19d2 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    19c0:	8f 5f       	subi	r24, 0xFF	; 255
    19c2:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    19c4:	81 e0       	ldi	r24, 0x01	; 1
    19c6:	05 c0       	rjmp	.+10     	; 0x19d2 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    19c8:	80 e0       	ldi	r24, 0x00	; 0
    19ca:	03 c0       	rjmp	.+6      	; 0x19d2 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <xQueueReceiveFromISR+0x50>
    19d0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	1f 91       	pop	r17
    19d8:	0f 91       	pop	r16
    19da:	08 95       	ret

000019dc <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    19e2:	fc 01       	movw	r30, r24
    19e4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    19e6:	0f 90       	pop	r0
    19e8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    19ea:	08 95       	ret

000019ec <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    19ec:	fc 01       	movw	r30, r24
    19ee:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    19f0:	08 95       	ret

000019f2 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    19f2:	ca e1       	ldi	r28, 0x1A	; 26
    19f4:	d1 e3       	ldi	r29, 0x31	; 49
    19f6:	88 81       	ld	r24, Y
    19f8:	82 30       	cpi	r24, 0x02	; 2
    19fa:	e8 f3       	brcs	.-6      	; 0x19f6 <prvIdleTask+0x4>
    19fc:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    1a00:	fa cf       	rjmp	.-12     	; 0x19f6 <prvIdleTask+0x4>

00001a02 <prvAddCurrentTaskToDelayedList>:
    1a02:	cf 92       	push	r12
    1a04:	df 92       	push	r13
    1a06:	ef 92       	push	r14
    1a08:	ff 92       	push	r15
    1a0a:	6b 01       	movw	r12, r22
    1a0c:	7c 01       	movw	r14, r24
    1a0e:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1a12:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a16:	62 83       	std	Z+2, r22	; 0x02
    1a18:	73 83       	std	Z+3, r23	; 0x03
    1a1a:	84 83       	std	Z+4, r24	; 0x04
    1a1c:	95 83       	std	Z+5, r25	; 0x05
    1a1e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1a22:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1a26:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1a2a:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1a2e:	c8 16       	cp	r12, r24
    1a30:	d9 06       	cpc	r13, r25
    1a32:	ea 06       	cpc	r14, r26
    1a34:	fb 06       	cpc	r15, r27
    1a36:	68 f4       	brcc	.+26     	; 0x1a52 <prvAddCurrentTaskToDelayedList+0x50>
    1a38:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    1a3c:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a40:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <pxOverflowDelayedTaskList>
    1a44:	90 91 01 31 	lds	r25, 0x3101	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1a48:	6e 5f       	subi	r22, 0xFE	; 254
    1a4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a4c:	0e 94 30 08 	call	0x1060	; 0x1060 <vListInsert>
    1a50:	21 c0       	rjmp	.+66     	; 0x1a94 <prvAddCurrentTaskToDelayedList+0x92>
    1a52:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    1a56:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a5a:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxDelayedTaskList>
    1a5e:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1a62:	6e 5f       	subi	r22, 0xFE	; 254
    1a64:	7f 4f       	sbci	r23, 0xFF	; 255
    1a66:	0e 94 30 08 	call	0x1060	; 0x1060 <vListInsert>
    1a6a:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1a6e:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a72:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a76:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a7a:	c8 16       	cp	r12, r24
    1a7c:	d9 06       	cpc	r13, r25
    1a7e:	ea 06       	cpc	r14, r26
    1a80:	fb 06       	cpc	r15, r27
    1a82:	40 f4       	brcc	.+16     	; 0x1a94 <prvAddCurrentTaskToDelayedList+0x92>
    1a84:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1a88:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a8c:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a90:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a94:	ff 90       	pop	r15
    1a96:	ef 90       	pop	r14
    1a98:	df 90       	pop	r13
    1a9a:	cf 90       	pop	r12
    1a9c:	08 95       	ret

00001a9e <xTaskGenericCreate>:
    1a9e:	4f 92       	push	r4
    1aa0:	5f 92       	push	r5
    1aa2:	6f 92       	push	r6
    1aa4:	7f 92       	push	r7
    1aa6:	8f 92       	push	r8
    1aa8:	9f 92       	push	r9
    1aaa:	af 92       	push	r10
    1aac:	bf 92       	push	r11
    1aae:	cf 92       	push	r12
    1ab0:	df 92       	push	r13
    1ab2:	ef 92       	push	r14
    1ab4:	ff 92       	push	r15
    1ab6:	0f 93       	push	r16
    1ab8:	1f 93       	push	r17
    1aba:	cf 93       	push	r28
    1abc:	df 93       	push	r29
    1abe:	5c 01       	movw	r10, r24
    1ac0:	4b 01       	movw	r8, r22
    1ac2:	3a 01       	movw	r6, r20
    1ac4:	29 01       	movw	r4, r18
    1ac6:	88 e2       	ldi	r24, 0x28	; 40
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    1ace:	ec 01       	movw	r28, r24
    1ad0:	89 2b       	or	r24, r25
    1ad2:	09 f4       	brne	.+2      	; 0x1ad6 <xTaskGenericCreate+0x38>
    1ad4:	d4 c0       	rjmp	.+424    	; 0x1c7e <xTaskGenericCreate+0x1e0>
    1ad6:	c1 14       	cp	r12, r1
    1ad8:	d1 04       	cpc	r13, r1
    1ada:	09 f0       	breq	.+2      	; 0x1ade <xTaskGenericCreate+0x40>
    1adc:	cc c0       	rjmp	.+408    	; 0x1c76 <xTaskGenericCreate+0x1d8>
    1ade:	c3 01       	movw	r24, r6
    1ae0:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    1ae4:	8b 8f       	std	Y+27, r24	; 0x1b
    1ae6:	9c 8f       	std	Y+28, r25	; 0x1c
    1ae8:	00 97       	sbiw	r24, 0x00	; 0
    1aea:	21 f4       	brne	.+8      	; 0x1af4 <xTaskGenericCreate+0x56>
    1aec:	ce 01       	movw	r24, r28
    1aee:	0e 94 bc 07 	call	0xf78	; 0xf78 <vPortFree>
    1af2:	c5 c0       	rjmp	.+394    	; 0x1c7e <xTaskGenericCreate+0x1e0>
    1af4:	a3 01       	movw	r20, r6
    1af6:	61 e1       	ldi	r22, 0x11	; 17
    1af8:	70 e0       	ldi	r23, 0x00	; 0
    1afa:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <memset>
    1afe:	93 01       	movw	r18, r6
    1b00:	21 50       	subi	r18, 0x01	; 1
    1b02:	31 09       	sbc	r19, r1
    1b04:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b06:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b08:	3c 01       	movw	r6, r24
    1b0a:	62 0e       	add	r6, r18
    1b0c:	73 1e       	adc	r7, r19
    1b0e:	4a e0       	ldi	r20, 0x0A	; 10
    1b10:	50 e0       	ldi	r21, 0x00	; 0
    1b12:	b4 01       	movw	r22, r8
    1b14:	ce 01       	movw	r24, r28
    1b16:	4d 96       	adiw	r24, 0x1d	; 29
    1b18:	0e 94 48 1f 	call	0x3e90	; 0x3e90 <strncpy>
    1b1c:	1e a2       	std	Y+38, r1	; 0x26
    1b1e:	10 2f       	mov	r17, r16
    1b20:	04 30       	cpi	r16, 0x04	; 4
    1b22:	08 f0       	brcs	.+2      	; 0x1b26 <xTaskGenericCreate+0x88>
    1b24:	13 e0       	ldi	r17, 0x03	; 3
    1b26:	1a 8f       	std	Y+26, r17	; 0x1a
    1b28:	1f a3       	std	Y+39, r17	; 0x27
    1b2a:	6e 01       	movw	r12, r28
    1b2c:	22 e0       	ldi	r18, 0x02	; 2
    1b2e:	c2 0e       	add	r12, r18
    1b30:	d1 1c       	adc	r13, r1
    1b32:	c6 01       	movw	r24, r12
    1b34:	0e 94 05 08 	call	0x100a	; 0x100a <vListInitialiseItem>
    1b38:	ce 01       	movw	r24, r28
    1b3a:	0e 96       	adiw	r24, 0x0e	; 14
    1b3c:	0e 94 05 08 	call	0x100a	; 0x100a <vListInitialiseItem>
    1b40:	ca 87       	std	Y+10, r28	; 0x0a
    1b42:	db 87       	std	Y+11, r29	; 0x0b
    1b44:	84 e0       	ldi	r24, 0x04	; 4
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	a0 e0       	ldi	r26, 0x00	; 0
    1b4a:	b0 e0       	ldi	r27, 0x00	; 0
    1b4c:	81 1b       	sub	r24, r17
    1b4e:	91 09       	sbc	r25, r1
    1b50:	a1 09       	sbc	r26, r1
    1b52:	b1 09       	sbc	r27, r1
    1b54:	8e 87       	std	Y+14, r24	; 0x0e
    1b56:	9f 87       	std	Y+15, r25	; 0x0f
    1b58:	a8 8b       	std	Y+16, r26	; 0x10
    1b5a:	b9 8b       	std	Y+17, r27	; 0x11
    1b5c:	ce 8b       	std	Y+22, r28	; 0x16
    1b5e:	df 8b       	std	Y+23, r29	; 0x17
    1b60:	a2 01       	movw	r20, r4
    1b62:	b5 01       	movw	r22, r10
    1b64:	c3 01       	movw	r24, r6
    1b66:	0e 94 a1 08 	call	0x1142	; 0x1142 <pxPortInitialiseStack>
    1b6a:	88 83       	st	Y, r24
    1b6c:	99 83       	std	Y+1, r25	; 0x01
    1b6e:	e1 14       	cp	r14, r1
    1b70:	f1 04       	cpc	r15, r1
    1b72:	19 f0       	breq	.+6      	; 0x1b7a <xTaskGenericCreate+0xdc>
    1b74:	f7 01       	movw	r30, r14
    1b76:	c0 83       	st	Z, r28
    1b78:	d1 83       	std	Z+1, r29	; 0x01
    1b7a:	0f b6       	in	r0, 0x3f	; 63
    1b7c:	f8 94       	cli
    1b7e:	0f 92       	push	r0
    1b80:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1b84:	8f 5f       	subi	r24, 0xFF	; 255
    1b86:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <uxCurrentNumberOfTasks>
    1b8a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1b8e:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1b92:	89 2b       	or	r24, r25
    1b94:	89 f5       	brne	.+98     	; 0x1bf8 <xTaskGenericCreate+0x15a>
    1b96:	c0 93 46 31 	sts	0x3146, r28	; 0x803146 <pxCurrentTCB>
    1b9a:	d0 93 47 31 	sts	0x3147, r29	; 0x803147 <pxCurrentTCB+0x1>
    1b9e:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1ba2:	81 30       	cpi	r24, 0x01	; 1
    1ba4:	c1 f5       	brne	.+112    	; 0x1c16 <xTaskGenericCreate+0x178>
    1ba6:	8a e1       	ldi	r24, 0x1A	; 26
    1ba8:	91 e3       	ldi	r25, 0x31	; 49
    1baa:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bae:	85 e2       	ldi	r24, 0x25	; 37
    1bb0:	91 e3       	ldi	r25, 0x31	; 49
    1bb2:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bb6:	80 e3       	ldi	r24, 0x30	; 48
    1bb8:	91 e3       	ldi	r25, 0x31	; 49
    1bba:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bbe:	8b e3       	ldi	r24, 0x3B	; 59
    1bc0:	91 e3       	ldi	r25, 0x31	; 49
    1bc2:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bc6:	8f e0       	ldi	r24, 0x0F	; 15
    1bc8:	91 e3       	ldi	r25, 0x31	; 49
    1bca:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bce:	84 e0       	ldi	r24, 0x04	; 4
    1bd0:	91 e3       	ldi	r25, 0x31	; 49
    1bd2:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bd6:	85 ef       	ldi	r24, 0xF5	; 245
    1bd8:	90 e3       	ldi	r25, 0x30	; 48
    1bda:	0e 94 f4 07 	call	0xfe8	; 0xfe8 <vListInitialise>
    1bde:	8f e0       	ldi	r24, 0x0F	; 15
    1be0:	91 e3       	ldi	r25, 0x31	; 49
    1be2:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxDelayedTaskList>
    1be6:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxDelayedTaskList+0x1>
    1bea:	84 e0       	ldi	r24, 0x04	; 4
    1bec:	91 e3       	ldi	r25, 0x31	; 49
    1bee:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <pxOverflowDelayedTaskList>
    1bf2:	90 93 01 31 	sts	0x3101, r25	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1bf6:	0f c0       	rjmp	.+30     	; 0x1c16 <xTaskGenericCreate+0x178>
    1bf8:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xSchedulerRunning>
    1bfc:	81 11       	cpse	r24, r1
    1bfe:	0b c0       	rjmp	.+22     	; 0x1c16 <xTaskGenericCreate+0x178>
    1c00:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1c04:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1c08:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c0a:	08 17       	cp	r16, r24
    1c0c:	20 f0       	brcs	.+8      	; 0x1c16 <xTaskGenericCreate+0x178>
    1c0e:	c0 93 46 31 	sts	0x3146, r28	; 0x803146 <pxCurrentTCB>
    1c12:	d0 93 47 31 	sts	0x3147, r29	; 0x803147 <pxCurrentTCB+0x1>
    1c16:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c18:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <uxTopUsedPriority>
    1c1c:	98 17       	cp	r25, r24
    1c1e:	10 f4       	brcc	.+4      	; 0x1c24 <xTaskGenericCreate+0x186>
    1c20:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxTopUsedPriority>
    1c24:	90 91 e6 30 	lds	r25, 0x30E6	; 0x8030e6 <uxTaskNumber>
    1c28:	9f 5f       	subi	r25, 0xFF	; 255
    1c2a:	90 93 e6 30 	sts	0x30E6, r25	; 0x8030e6 <uxTaskNumber>
    1c2e:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1c32:	98 17       	cp	r25, r24
    1c34:	10 f4       	brcc	.+4      	; 0x1c3a <xTaskGenericCreate+0x19c>
    1c36:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1c3a:	fb e0       	ldi	r31, 0x0B	; 11
    1c3c:	8f 9f       	mul	r24, r31
    1c3e:	c0 01       	movw	r24, r0
    1c40:	11 24       	eor	r1, r1
    1c42:	b6 01       	movw	r22, r12
    1c44:	86 5e       	subi	r24, 0xE6	; 230
    1c46:	9e 4c       	sbci	r25, 0xCE	; 206
    1c48:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
    1c4c:	0f 90       	pop	r0
    1c4e:	0f be       	out	0x3f, r0	; 63
    1c50:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xSchedulerRunning>
    1c54:	88 23       	and	r24, r24
    1c56:	59 f0       	breq	.+22     	; 0x1c6e <xTaskGenericCreate+0x1d0>
    1c58:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1c5c:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1c60:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c62:	80 17       	cp	r24, r16
    1c64:	30 f4       	brcc	.+12     	; 0x1c72 <xTaskGenericCreate+0x1d4>
    1c66:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	09 c0       	rjmp	.+18     	; 0x1c80 <xTaskGenericCreate+0x1e2>
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	07 c0       	rjmp	.+14     	; 0x1c80 <xTaskGenericCreate+0x1e2>
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	05 c0       	rjmp	.+10     	; 0x1c80 <xTaskGenericCreate+0x1e2>
    1c76:	cb 8e       	std	Y+27, r12	; 0x1b
    1c78:	dc 8e       	std	Y+28, r13	; 0x1c
    1c7a:	c6 01       	movw	r24, r12
    1c7c:	3b cf       	rjmp	.-394    	; 0x1af4 <xTaskGenericCreate+0x56>
    1c7e:	8f ef       	ldi	r24, 0xFF	; 255
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	1f 91       	pop	r17
    1c86:	0f 91       	pop	r16
    1c88:	ff 90       	pop	r15
    1c8a:	ef 90       	pop	r14
    1c8c:	df 90       	pop	r13
    1c8e:	cf 90       	pop	r12
    1c90:	bf 90       	pop	r11
    1c92:	af 90       	pop	r10
    1c94:	9f 90       	pop	r9
    1c96:	8f 90       	pop	r8
    1c98:	7f 90       	pop	r7
    1c9a:	6f 90       	pop	r6
    1c9c:	5f 90       	pop	r5
    1c9e:	4f 90       	pop	r4
    1ca0:	08 95       	ret

00001ca2 <uxTaskPriorityGet>:
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	0f 92       	push	r0
    1ca8:	00 97       	sbiw	r24, 0x00	; 0
    1caa:	21 f4       	brne	.+8      	; 0x1cb4 <uxTaskPriorityGet+0x12>
    1cac:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1cb0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1cb4:	0f 90       	pop	r0
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	fc 01       	movw	r30, r24
    1cba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cbc:	08 95       	ret

00001cbe <vTaskStartScheduler>:
    1cbe:	af 92       	push	r10
    1cc0:	bf 92       	push	r11
    1cc2:	cf 92       	push	r12
    1cc4:	df 92       	push	r13
    1cc6:	ef 92       	push	r14
    1cc8:	ff 92       	push	r15
    1cca:	0f 93       	push	r16
    1ccc:	a1 2c       	mov	r10, r1
    1cce:	b1 2c       	mov	r11, r1
    1cd0:	c1 2c       	mov	r12, r1
    1cd2:	d1 2c       	mov	r13, r1
    1cd4:	0f 2e       	mov	r0, r31
    1cd6:	f3 ef       	ldi	r31, 0xF3	; 243
    1cd8:	ef 2e       	mov	r14, r31
    1cda:	f0 e3       	ldi	r31, 0x30	; 48
    1cdc:	ff 2e       	mov	r15, r31
    1cde:	f0 2d       	mov	r31, r0
    1ce0:	00 e0       	ldi	r16, 0x00	; 0
    1ce2:	20 e0       	ldi	r18, 0x00	; 0
    1ce4:	30 e0       	ldi	r19, 0x00	; 0
    1ce6:	44 e6       	ldi	r20, 0x64	; 100
    1ce8:	50 e0       	ldi	r21, 0x00	; 0
    1cea:	62 e3       	ldi	r22, 0x32	; 50
    1cec:	70 e2       	ldi	r23, 0x20	; 32
    1cee:	89 ef       	ldi	r24, 0xF9	; 249
    1cf0:	9c e0       	ldi	r25, 0x0C	; 12
    1cf2:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <xTaskGenericCreate>
    1cf6:	81 30       	cpi	r24, 0x01	; 1
    1cf8:	69 f4       	brne	.+26     	; 0x1d14 <vTaskStartScheduler+0x56>
    1cfa:	f8 94       	cli
    1cfc:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <xSchedulerRunning>
    1d00:	10 92 ee 30 	sts	0x30EE, r1	; 0x8030ee <xTickCount>
    1d04:	10 92 ef 30 	sts	0x30EF, r1	; 0x8030ef <xTickCount+0x1>
    1d08:	10 92 f0 30 	sts	0x30F0, r1	; 0x8030f0 <xTickCount+0x2>
    1d0c:	10 92 f1 30 	sts	0x30F1, r1	; 0x8030f1 <xTickCount+0x3>
    1d10:	0e 94 17 09 	call	0x122e	; 0x122e <xPortStartScheduler>
    1d14:	0f 91       	pop	r16
    1d16:	ff 90       	pop	r15
    1d18:	ef 90       	pop	r14
    1d1a:	df 90       	pop	r13
    1d1c:	cf 90       	pop	r12
    1d1e:	bf 90       	pop	r11
    1d20:	af 90       	pop	r10
    1d22:	08 95       	ret

00001d24 <vTaskSuspendAll>:
    1d24:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1d28:	8f 5f       	subi	r24, 0xFF	; 255
    1d2a:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <uxSchedulerSuspended>
    1d2e:	08 95       	ret

00001d30 <xTaskGetTickCount>:
    1d30:	0f b6       	in	r0, 0x3f	; 63
    1d32:	f8 94       	cli
    1d34:	0f 92       	push	r0
    1d36:	60 91 ee 30 	lds	r22, 0x30EE	; 0x8030ee <xTickCount>
    1d3a:	70 91 ef 30 	lds	r23, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1d3e:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1d42:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1d46:	0f 90       	pop	r0
    1d48:	0f be       	out	0x3f, r0	; 63
    1d4a:	08 95       	ret

00001d4c <pcTaskGetTaskName>:
    1d4c:	00 97       	sbiw	r24, 0x00	; 0
    1d4e:	21 f4       	brne	.+8      	; 0x1d58 <pcTaskGetTaskName+0xc>
    1d50:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1d54:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1d58:	4d 96       	adiw	r24, 0x1d	; 29
    1d5a:	08 95       	ret

00001d5c <xTaskGetIdleTaskHandle>:
    1d5c:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <xIdleTaskHandle>
    1d60:	90 91 f4 30 	lds	r25, 0x30F4	; 0x8030f4 <xIdleTaskHandle+0x1>
    1d64:	08 95       	ret

00001d66 <vTaskIncrementTick>:
    1d66:	ff 92       	push	r15
    1d68:	0f 93       	push	r16
    1d6a:	1f 93       	push	r17
    1d6c:	cf 93       	push	r28
    1d6e:	df 93       	push	r29
    1d70:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1d74:	81 11       	cpse	r24, r1
    1d76:	ed c0       	rjmp	.+474    	; 0x1f52 <vTaskIncrementTick+0x1ec>
    1d78:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1d7c:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1d80:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1d84:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1d88:	01 96       	adiw	r24, 0x01	; 1
    1d8a:	a1 1d       	adc	r26, r1
    1d8c:	b1 1d       	adc	r27, r1
    1d8e:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <xTickCount>
    1d92:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <xTickCount+0x1>
    1d96:	a0 93 f0 30 	sts	0x30F0, r26	; 0x8030f0 <xTickCount+0x2>
    1d9a:	b0 93 f1 30 	sts	0x30F1, r27	; 0x8030f1 <xTickCount+0x3>
    1d9e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1da2:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1da6:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1daa:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1dae:	89 2b       	or	r24, r25
    1db0:	8a 2b       	or	r24, r26
    1db2:	8b 2b       	or	r24, r27
    1db4:	f1 f5       	brne	.+124    	; 0x1e32 <vTaskIncrementTick+0xcc>
    1db6:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxDelayedTaskList>
    1dba:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1dbe:	20 91 00 31 	lds	r18, 0x3100	; 0x803100 <pxOverflowDelayedTaskList>
    1dc2:	30 91 01 31 	lds	r19, 0x3101	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1dc6:	20 93 02 31 	sts	0x3102, r18	; 0x803102 <pxDelayedTaskList>
    1dca:	30 93 03 31 	sts	0x3103, r19	; 0x803103 <pxDelayedTaskList+0x1>
    1dce:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <pxOverflowDelayedTaskList>
    1dd2:	90 93 01 31 	sts	0x3101, r25	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1dd6:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    1dda:	8f 5f       	subi	r24, 0xFF	; 255
    1ddc:	80 93 e7 30 	sts	0x30E7, r24	; 0x8030e7 <xNumOfOverflows>
    1de0:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1de4:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1de8:	80 81       	ld	r24, Z
    1dea:	81 11       	cpse	r24, r1
    1dec:	0c c0       	rjmp	.+24     	; 0x1e06 <vTaskIncrementTick+0xa0>
    1dee:	8f ef       	ldi	r24, 0xFF	; 255
    1df0:	9f ef       	ldi	r25, 0xFF	; 255
    1df2:	dc 01       	movw	r26, r24
    1df4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1df8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dfc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e00:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e04:	16 c0       	rjmp	.+44     	; 0x1e32 <vTaskIncrementTick+0xcc>
    1e06:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1e0a:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e0e:	07 80       	ldd	r0, Z+7	; 0x07
    1e10:	f0 85       	ldd	r31, Z+8	; 0x08
    1e12:	e0 2d       	mov	r30, r0
    1e14:	00 84       	ldd	r0, Z+8	; 0x08
    1e16:	f1 85       	ldd	r31, Z+9	; 0x09
    1e18:	e0 2d       	mov	r30, r0
    1e1a:	82 81       	ldd	r24, Z+2	; 0x02
    1e1c:	93 81       	ldd	r25, Z+3	; 0x03
    1e1e:	a4 81       	ldd	r26, Z+4	; 0x04
    1e20:	b5 81       	ldd	r27, Z+5	; 0x05
    1e22:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e26:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e2a:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e2e:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e32:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1e36:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1e3a:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1e3e:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1e42:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e46:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e4a:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e4e:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e52:	48 17       	cp	r20, r24
    1e54:	59 07       	cpc	r21, r25
    1e56:	6a 07       	cpc	r22, r26
    1e58:	7b 07       	cpc	r23, r27
    1e5a:	08 f4       	brcc	.+2      	; 0x1e5e <vTaskIncrementTick+0xf8>
    1e5c:	7f c0       	rjmp	.+254    	; 0x1f5c <vTaskIncrementTick+0x1f6>
    1e5e:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1e62:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e66:	80 81       	ld	r24, Z
    1e68:	88 23       	and	r24, r24
    1e6a:	f9 f0       	breq	.+62     	; 0x1eaa <vTaskIncrementTick+0x144>
    1e6c:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1e70:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e74:	07 80       	ldd	r0, Z+7	; 0x07
    1e76:	f0 85       	ldd	r31, Z+8	; 0x08
    1e78:	e0 2d       	mov	r30, r0
    1e7a:	c0 85       	ldd	r28, Z+8	; 0x08
    1e7c:	d1 85       	ldd	r29, Z+9	; 0x09
    1e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e80:	9b 81       	ldd	r25, Y+3	; 0x03
    1e82:	ac 81       	ldd	r26, Y+4	; 0x04
    1e84:	bd 81       	ldd	r27, Y+5	; 0x05
    1e86:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1e8a:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1e8e:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1e92:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1e96:	48 17       	cp	r20, r24
    1e98:	59 07       	cpc	r21, r25
    1e9a:	6a 07       	cpc	r22, r26
    1e9c:	7b 07       	cpc	r23, r27
    1e9e:	58 f1       	brcs	.+86     	; 0x1ef6 <vTaskIncrementTick+0x190>
    1ea0:	0f 2e       	mov	r0, r31
    1ea2:	fb e0       	ldi	r31, 0x0B	; 11
    1ea4:	ff 2e       	mov	r15, r31
    1ea6:	f0 2d       	mov	r31, r0
    1ea8:	2f c0       	rjmp	.+94     	; 0x1f08 <vTaskIncrementTick+0x1a2>
    1eaa:	8f ef       	ldi	r24, 0xFF	; 255
    1eac:	9f ef       	ldi	r25, 0xFF	; 255
    1eae:	dc 01       	movw	r26, r24
    1eb0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1eb4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1eb8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ebc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ec0:	4d c0       	rjmp	.+154    	; 0x1f5c <vTaskIncrementTick+0x1f6>
    1ec2:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1ec6:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1eca:	07 80       	ldd	r0, Z+7	; 0x07
    1ecc:	f0 85       	ldd	r31, Z+8	; 0x08
    1ece:	e0 2d       	mov	r30, r0
    1ed0:	c0 85       	ldd	r28, Z+8	; 0x08
    1ed2:	d1 85       	ldd	r29, Z+9	; 0x09
    1ed4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ed8:	ac 81       	ldd	r26, Y+4	; 0x04
    1eda:	bd 81       	ldd	r27, Y+5	; 0x05
    1edc:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1ee0:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1ee4:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1ee8:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1eec:	48 17       	cp	r20, r24
    1eee:	59 07       	cpc	r21, r25
    1ef0:	6a 07       	cpc	r22, r26
    1ef2:	7b 07       	cpc	r23, r27
    1ef4:	48 f4       	brcc	.+18     	; 0x1f08 <vTaskIncrementTick+0x1a2>
    1ef6:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1efa:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1efe:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f02:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f06:	2a c0       	rjmp	.+84     	; 0x1f5c <vTaskIncrementTick+0x1f6>
    1f08:	8e 01       	movw	r16, r28
    1f0a:	0e 5f       	subi	r16, 0xFE	; 254
    1f0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f0e:	c8 01       	movw	r24, r16
    1f10:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
    1f14:	88 8d       	ldd	r24, Y+24	; 0x18
    1f16:	99 8d       	ldd	r25, Y+25	; 0x19
    1f18:	89 2b       	or	r24, r25
    1f1a:	21 f0       	breq	.+8      	; 0x1f24 <vTaskIncrementTick+0x1be>
    1f1c:	ce 01       	movw	r24, r28
    1f1e:	0e 96       	adiw	r24, 0x0e	; 14
    1f20:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
    1f24:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f26:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1f2a:	98 17       	cp	r25, r24
    1f2c:	10 f4       	brcc	.+4      	; 0x1f32 <vTaskIncrementTick+0x1cc>
    1f2e:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1f32:	f8 9e       	mul	r15, r24
    1f34:	c0 01       	movw	r24, r0
    1f36:	11 24       	eor	r1, r1
    1f38:	b8 01       	movw	r22, r16
    1f3a:	86 5e       	subi	r24, 0xE6	; 230
    1f3c:	9e 4c       	sbci	r25, 0xCE	; 206
    1f3e:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
    1f42:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1f46:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1f4a:	80 81       	ld	r24, Z
    1f4c:	81 11       	cpse	r24, r1
    1f4e:	b9 cf       	rjmp	.-142    	; 0x1ec2 <vTaskIncrementTick+0x15c>
    1f50:	ac cf       	rjmp	.-168    	; 0x1eaa <vTaskIncrementTick+0x144>
    1f52:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    1f56:	8f 5f       	subi	r24, 0xFF	; 255
    1f58:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxMissedTicks>
    1f5c:	df 91       	pop	r29
    1f5e:	cf 91       	pop	r28
    1f60:	1f 91       	pop	r17
    1f62:	0f 91       	pop	r16
    1f64:	ff 90       	pop	r15
    1f66:	08 95       	ret

00001f68 <xTaskResumeAll>:
    1f68:	cf 92       	push	r12
    1f6a:	df 92       	push	r13
    1f6c:	ef 92       	push	r14
    1f6e:	ff 92       	push	r15
    1f70:	0f 93       	push	r16
    1f72:	1f 93       	push	r17
    1f74:	cf 93       	push	r28
    1f76:	df 93       	push	r29
    1f78:	0f b6       	in	r0, 0x3f	; 63
    1f7a:	f8 94       	cli
    1f7c:	0f 92       	push	r0
    1f7e:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1f82:	81 50       	subi	r24, 0x01	; 1
    1f84:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <uxSchedulerSuspended>
    1f88:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	60 c0       	rjmp	.+192    	; 0x2050 <xTaskResumeAll+0xe8>
    1f90:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1f94:	81 11       	cpse	r24, r1
    1f96:	2c c0       	rjmp	.+88     	; 0x1ff0 <xTaskResumeAll+0x88>
    1f98:	5e c0       	rjmp	.+188    	; 0x2056 <xTaskResumeAll+0xee>
    1f9a:	d7 01       	movw	r26, r14
    1f9c:	17 96       	adiw	r26, 0x07	; 7
    1f9e:	ed 91       	ld	r30, X+
    1fa0:	fc 91       	ld	r31, X
    1fa2:	18 97       	sbiw	r26, 0x08	; 8
    1fa4:	c0 85       	ldd	r28, Z+8	; 0x08
    1fa6:	d1 85       	ldd	r29, Z+9	; 0x09
    1fa8:	ce 01       	movw	r24, r28
    1faa:	0e 96       	adiw	r24, 0x0e	; 14
    1fac:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
    1fb0:	8e 01       	movw	r16, r28
    1fb2:	0e 5f       	subi	r16, 0xFE	; 254
    1fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb6:	c8 01       	movw	r24, r16
    1fb8:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
    1fbc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fbe:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1fc2:	98 17       	cp	r25, r24
    1fc4:	10 f4       	brcc	.+4      	; 0x1fca <xTaskResumeAll+0x62>
    1fc6:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1fca:	d8 9e       	mul	r13, r24
    1fcc:	c0 01       	movw	r24, r0
    1fce:	11 24       	eor	r1, r1
    1fd0:	b8 01       	movw	r22, r16
    1fd2:	86 5e       	subi	r24, 0xE6	; 230
    1fd4:	9e 4c       	sbci	r25, 0xCE	; 206
    1fd6:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
    1fda:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1fde:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1fe2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fe6:	98 17       	cp	r25, r24
    1fe8:	70 f0       	brcs	.+28     	; 0x2006 <xTaskResumeAll+0x9e>
    1fea:	cc 24       	eor	r12, r12
    1fec:	c3 94       	inc	r12
    1fee:	0b c0       	rjmp	.+22     	; 0x2006 <xTaskResumeAll+0x9e>
    1ff0:	c1 2c       	mov	r12, r1
    1ff2:	0f 2e       	mov	r0, r31
    1ff4:	f5 ef       	ldi	r31, 0xF5	; 245
    1ff6:	ef 2e       	mov	r14, r31
    1ff8:	f0 e3       	ldi	r31, 0x30	; 48
    1ffa:	ff 2e       	mov	r15, r31
    1ffc:	f0 2d       	mov	r31, r0
    1ffe:	0f 2e       	mov	r0, r31
    2000:	fb e0       	ldi	r31, 0x0B	; 11
    2002:	df 2e       	mov	r13, r31
    2004:	f0 2d       	mov	r31, r0
    2006:	f7 01       	movw	r30, r14
    2008:	80 81       	ld	r24, Z
    200a:	81 11       	cpse	r24, r1
    200c:	c6 cf       	rjmp	.-116    	; 0x1f9a <xTaskResumeAll+0x32>
    200e:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    2012:	88 23       	and	r24, r24
    2014:	81 f0       	breq	.+32     	; 0x2036 <xTaskResumeAll+0xce>
    2016:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    201a:	88 23       	and	r24, r24
    201c:	99 f0       	breq	.+38     	; 0x2044 <xTaskResumeAll+0xdc>
    201e:	0e 94 b3 0e 	call	0x1d66	; 0x1d66 <vTaskIncrementTick>
    2022:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    2026:	81 50       	subi	r24, 0x01	; 1
    2028:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxMissedTicks>
    202c:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    2030:	81 11       	cpse	r24, r1
    2032:	f5 cf       	rjmp	.-22     	; 0x201e <xTaskResumeAll+0xb6>
    2034:	07 c0       	rjmp	.+14     	; 0x2044 <xTaskResumeAll+0xdc>
    2036:	f1 e0       	ldi	r31, 0x01	; 1
    2038:	cf 16       	cp	r12, r31
    203a:	21 f0       	breq	.+8      	; 0x2044 <xTaskResumeAll+0xdc>
    203c:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <xMissedYield>
    2040:	81 30       	cpi	r24, 0x01	; 1
    2042:	41 f4       	brne	.+16     	; 0x2054 <xTaskResumeAll+0xec>
    2044:	10 92 e8 30 	sts	0x30E8, r1	; 0x8030e8 <xMissedYield>
    2048:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	03 c0       	rjmp	.+6      	; 0x2056 <xTaskResumeAll+0xee>
    2050:	80 e0       	ldi	r24, 0x00	; 0
    2052:	01 c0       	rjmp	.+2      	; 0x2056 <xTaskResumeAll+0xee>
    2054:	80 e0       	ldi	r24, 0x00	; 0
    2056:	0f 90       	pop	r0
    2058:	0f be       	out	0x3f, r0	; 63
    205a:	df 91       	pop	r29
    205c:	cf 91       	pop	r28
    205e:	1f 91       	pop	r17
    2060:	0f 91       	pop	r16
    2062:	ff 90       	pop	r15
    2064:	ef 90       	pop	r14
    2066:	df 90       	pop	r13
    2068:	cf 90       	pop	r12
    206a:	08 95       	ret

0000206c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    206c:	cf 92       	push	r12
    206e:	df 92       	push	r13
    2070:	ef 92       	push	r14
    2072:	ff 92       	push	r15
    2074:	6b 01       	movw	r12, r22
    2076:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2078:	67 2b       	or	r22, r23
    207a:	68 2b       	or	r22, r24
    207c:	69 2b       	or	r22, r25
    207e:	e9 f0       	breq	.+58     	; 0x20ba <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2080:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2084:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    2088:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    208c:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    2090:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    2094:	c8 0e       	add	r12, r24
    2096:	d9 1e       	adc	r13, r25
    2098:	ea 1e       	adc	r14, r26
    209a:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    209c:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    20a0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    20a4:	02 96       	adiw	r24, 0x02	; 2
    20a6:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20aa:	c7 01       	movw	r24, r14
    20ac:	b6 01       	movw	r22, r12
    20ae:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    20b2:	0e 94 b4 0f 	call	0x1f68	; 0x1f68 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20b6:	81 11       	cpse	r24, r1
    20b8:	02 c0       	rjmp	.+4      	; 0x20be <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    20ba:	0e 94 55 09 	call	0x12aa	; 0x12aa <vPortYield>
		}
	}
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12
    20c6:	08 95       	ret

000020c8 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20c8:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    20cc:	81 11       	cpse	r24, r1
    20ce:	0c c0       	rjmp	.+24     	; 0x20e8 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20d0:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    20d4:	4b e0       	ldi	r20, 0x0B	; 11
    20d6:	e4 9f       	mul	r30, r20
    20d8:	f0 01       	movw	r30, r0
    20da:	11 24       	eor	r1, r1
    20dc:	e6 5e       	subi	r30, 0xE6	; 230
    20de:	fe 4c       	sbci	r31, 0xCE	; 206
    20e0:	80 81       	ld	r24, Z
    20e2:	88 23       	and	r24, r24
    20e4:	29 f0       	breq	.+10     	; 0x20f0 <vTaskSwitchContext+0x28>
    20e6:	14 c0       	rjmp	.+40     	; 0x2110 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <xMissedYield>
    20ee:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20f0:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20f2:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    20f6:	81 50       	subi	r24, 0x01	; 1
    20f8:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20fc:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2100:	9e 9f       	mul	r25, r30
    2102:	f0 01       	movw	r30, r0
    2104:	11 24       	eor	r1, r1
    2106:	e6 5e       	subi	r30, 0xE6	; 230
    2108:	fe 4c       	sbci	r31, 0xCE	; 206
    210a:	80 81       	ld	r24, Z
    210c:	88 23       	and	r24, r24
    210e:	89 f3       	breq	.-30     	; 0x20f2 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2110:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2114:	28 2f       	mov	r18, r24
    2116:	30 e0       	ldi	r19, 0x00	; 0
    2118:	4b e0       	ldi	r20, 0x0B	; 11
    211a:	84 9f       	mul	r24, r20
    211c:	c0 01       	movw	r24, r0
    211e:	11 24       	eor	r1, r1
    2120:	dc 01       	movw	r26, r24
    2122:	a6 5e       	subi	r26, 0xE6	; 230
    2124:	be 4c       	sbci	r27, 0xCE	; 206
    2126:	11 96       	adiw	r26, 0x01	; 1
    2128:	ed 91       	ld	r30, X+
    212a:	fc 91       	ld	r31, X
    212c:	12 97       	sbiw	r26, 0x02	; 2
    212e:	04 80       	ldd	r0, Z+4	; 0x04
    2130:	f5 81       	ldd	r31, Z+5	; 0x05
    2132:	e0 2d       	mov	r30, r0
    2134:	11 96       	adiw	r26, 0x01	; 1
    2136:	ed 93       	st	X+, r30
    2138:	fc 93       	st	X, r31
    213a:	12 97       	sbiw	r26, 0x02	; 2
    213c:	83 5e       	subi	r24, 0xE3	; 227
    213e:	9e 4c       	sbci	r25, 0xCE	; 206
    2140:	e8 17       	cp	r30, r24
    2142:	f9 07       	cpc	r31, r25
    2144:	61 f4       	brne	.+24     	; 0x215e <vTaskSwitchContext+0x96>
    2146:	84 81       	ldd	r24, Z+4	; 0x04
    2148:	95 81       	ldd	r25, Z+5	; 0x05
    214a:	4b e0       	ldi	r20, 0x0B	; 11
    214c:	42 9f       	mul	r20, r18
    214e:	f0 01       	movw	r30, r0
    2150:	43 9f       	mul	r20, r19
    2152:	f0 0d       	add	r31, r0
    2154:	11 24       	eor	r1, r1
    2156:	e6 5e       	subi	r30, 0xE6	; 230
    2158:	fe 4c       	sbci	r31, 0xCE	; 206
    215a:	81 83       	std	Z+1, r24	; 0x01
    215c:	92 83       	std	Z+2, r25	; 0x02
    215e:	8b e0       	ldi	r24, 0x0B	; 11
    2160:	82 9f       	mul	r24, r18
    2162:	f0 01       	movw	r30, r0
    2164:	83 9f       	mul	r24, r19
    2166:	f0 0d       	add	r31, r0
    2168:	11 24       	eor	r1, r1
    216a:	e6 5e       	subi	r30, 0xE6	; 230
    216c:	fe 4c       	sbci	r31, 0xCE	; 206
    216e:	01 80       	ldd	r0, Z+1	; 0x01
    2170:	f2 81       	ldd	r31, Z+2	; 0x02
    2172:	e0 2d       	mov	r30, r0
    2174:	80 85       	ldd	r24, Z+8	; 0x08
    2176:	91 85       	ldd	r25, Z+9	; 0x09
    2178:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <pxCurrentTCB>
    217c:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <pxCurrentTCB+0x1>
    2180:	08 95       	ret

00002182 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2182:	cf 92       	push	r12
    2184:	df 92       	push	r13
    2186:	ef 92       	push	r14
    2188:	ff 92       	push	r15
    218a:	6a 01       	movw	r12, r20
    218c:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    218e:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    2192:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    2196:	62 5f       	subi	r22, 0xF2	; 242
    2198:	7f 4f       	sbci	r23, 0xFF	; 255
    219a:	0e 94 30 08 	call	0x1060	; 0x1060 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    219e:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    21a2:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    21a6:	02 96       	adiw	r24, 0x02	; 2
    21a8:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21ac:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    21b0:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    21b4:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    21b8:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21bc:	bc 01       	movw	r22, r24
    21be:	cd 01       	movw	r24, r26
    21c0:	6c 0d       	add	r22, r12
    21c2:	7d 1d       	adc	r23, r13
    21c4:	8e 1d       	adc	r24, r14
    21c6:	9f 1d       	adc	r25, r15
    21c8:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21cc:	ff 90       	pop	r15
    21ce:	ef 90       	pop	r14
    21d0:	df 90       	pop	r13
    21d2:	cf 90       	pop	r12
    21d4:	08 95       	ret

000021d6 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    21d6:	0f 93       	push	r16
    21d8:	1f 93       	push	r17
    21da:	cf 93       	push	r28
    21dc:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    21de:	dc 01       	movw	r26, r24
    21e0:	17 96       	adiw	r26, 0x07	; 7
    21e2:	ed 91       	ld	r30, X+
    21e4:	fc 91       	ld	r31, X
    21e6:	18 97       	sbiw	r26, 0x08	; 8
    21e8:	c0 85       	ldd	r28, Z+8	; 0x08
    21ea:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    21ec:	8e 01       	movw	r16, r28
    21ee:	02 5f       	subi	r16, 0xF2	; 242
    21f0:	1f 4f       	sbci	r17, 0xFF	; 255
    21f2:	c8 01       	movw	r24, r16
    21f4:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21f8:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    21fc:	81 11       	cpse	r24, r1
    21fe:	16 c0       	rjmp	.+44     	; 0x222c <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2200:	0c 50       	subi	r16, 0x0C	; 12
    2202:	11 09       	sbc	r17, r1
    2204:	c8 01       	movw	r24, r16
    2206:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    220a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    220c:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2210:	98 17       	cp	r25, r24
    2212:	10 f4       	brcc	.+4      	; 0x2218 <xTaskRemoveFromEventList+0x42>
    2214:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    2218:	bb e0       	ldi	r27, 0x0B	; 11
    221a:	8b 9f       	mul	r24, r27
    221c:	c0 01       	movw	r24, r0
    221e:	11 24       	eor	r1, r1
    2220:	b8 01       	movw	r22, r16
    2222:	86 5e       	subi	r24, 0xE6	; 230
    2224:	9e 4c       	sbci	r25, 0xCE	; 206
    2226:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
    222a:	05 c0       	rjmp	.+10     	; 0x2236 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    222c:	b8 01       	movw	r22, r16
    222e:	85 ef       	ldi	r24, 0xF5	; 245
    2230:	90 e3       	ldi	r25, 0x30	; 48
    2232:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2236:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    223a:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    223e:	81 e0       	ldi	r24, 0x01	; 1
    2240:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2242:	92 8d       	ldd	r25, Z+26	; 0x1a
    2244:	29 17       	cp	r18, r25
    2246:	08 f4       	brcc	.+2      	; 0x224a <xTaskRemoveFromEventList+0x74>
    2248:	80 e0       	ldi	r24, 0x00	; 0
}
    224a:	df 91       	pop	r29
    224c:	cf 91       	pop	r28
    224e:	1f 91       	pop	r17
    2250:	0f 91       	pop	r16
    2252:	08 95       	ret

00002254 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2254:	20 91 e7 30 	lds	r18, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    2258:	fc 01       	movw	r30, r24
    225a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    225c:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    2260:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    2264:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    2268:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    226c:	41 83       	std	Z+1, r20	; 0x01
    226e:	52 83       	std	Z+2, r21	; 0x02
    2270:	63 83       	std	Z+3, r22	; 0x03
    2272:	74 83       	std	Z+4, r23	; 0x04
    2274:	08 95       	ret

00002276 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2276:	8f 92       	push	r8
    2278:	9f 92       	push	r9
    227a:	af 92       	push	r10
    227c:	bf 92       	push	r11
    227e:	cf 92       	push	r12
    2280:	df 92       	push	r13
    2282:	ef 92       	push	r14
    2284:	ff 92       	push	r15
    2286:	0f 93       	push	r16
    2288:	1f 93       	push	r17
    228a:	cf 93       	push	r28
    228c:	df 93       	push	r29
    228e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2296:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    229a:	90 81       	ld	r25, Z
    229c:	98 17       	cp	r25, r24
    229e:	89 f0       	breq	.+34     	; 0x22c2 <xTaskCheckForTimeOut+0x4c>
    22a0:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    22a4:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    22a8:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    22ac:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    22b0:	01 81       	ldd	r16, Z+1	; 0x01
    22b2:	12 81       	ldd	r17, Z+2	; 0x02
    22b4:	23 81       	ldd	r18, Z+3	; 0x03
    22b6:	34 81       	ldd	r19, Z+4	; 0x04
    22b8:	80 17       	cp	r24, r16
    22ba:	91 07       	cpc	r25, r17
    22bc:	a2 07       	cpc	r26, r18
    22be:	b3 07       	cpc	r27, r19
    22c0:	a8 f5       	brcc	.+106    	; 0x232c <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    22c2:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    22c6:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    22ca:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    22ce:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    22d2:	c1 80       	ldd	r12, Z+1	; 0x01
    22d4:	d2 80       	ldd	r13, Z+2	; 0x02
    22d6:	e3 80       	ldd	r14, Z+3	; 0x03
    22d8:	f4 80       	ldd	r15, Z+4	; 0x04
    22da:	eb 01       	movw	r28, r22
    22dc:	08 81       	ld	r16, Y
    22de:	19 81       	ldd	r17, Y+1	; 0x01
    22e0:	2a 81       	ldd	r18, Y+2	; 0x02
    22e2:	3b 81       	ldd	r19, Y+3	; 0x03
    22e4:	8c 19       	sub	r24, r12
    22e6:	9d 09       	sbc	r25, r13
    22e8:	ae 09       	sbc	r26, r14
    22ea:	bf 09       	sbc	r27, r15
    22ec:	80 17       	cp	r24, r16
    22ee:	91 07       	cpc	r25, r17
    22f0:	a2 07       	cpc	r26, r18
    22f2:	b3 07       	cpc	r27, r19
    22f4:	e8 f4       	brcc	.+58     	; 0x2330 <xTaskCheckForTimeOut+0xba>
    22f6:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    22f8:	80 90 ee 30 	lds	r8, 0x30EE	; 0x8030ee <xTickCount>
    22fc:	90 90 ef 30 	lds	r9, 0x30EF	; 0x8030ef <xTickCount+0x1>
    2300:	a0 90 f0 30 	lds	r10, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    2304:	b0 90 f1 30 	lds	r11, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    2308:	b5 01       	movw	r22, r10
    230a:	a4 01       	movw	r20, r8
    230c:	4c 19       	sub	r20, r12
    230e:	5d 09       	sbc	r21, r13
    2310:	6e 09       	sbc	r22, r14
    2312:	7f 09       	sbc	r23, r15
    2314:	04 1b       	sub	r16, r20
    2316:	15 0b       	sbc	r17, r21
    2318:	26 0b       	sbc	r18, r22
    231a:	37 0b       	sbc	r19, r23
    231c:	08 83       	st	Y, r16
    231e:	19 83       	std	Y+1, r17	; 0x01
    2320:	2a 83       	std	Y+2, r18	; 0x02
    2322:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2324:	0e 94 2a 11 	call	0x2254	; 0x2254 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	03 c0       	rjmp	.+6      	; 0x2332 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    232c:	81 e0       	ldi	r24, 0x01	; 1
    232e:	01 c0       	rjmp	.+2      	; 0x2332 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2330:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2332:	0f 90       	pop	r0
    2334:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2336:	df 91       	pop	r29
    2338:	cf 91       	pop	r28
    233a:	1f 91       	pop	r17
    233c:	0f 91       	pop	r16
    233e:	ff 90       	pop	r15
    2340:	ef 90       	pop	r14
    2342:	df 90       	pop	r13
    2344:	cf 90       	pop	r12
    2346:	bf 90       	pop	r11
    2348:	af 90       	pop	r10
    234a:	9f 90       	pop	r9
    234c:	8f 90       	pop	r8
    234e:	08 95       	ret

00002350 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2350:	81 e0       	ldi	r24, 0x01	; 1
    2352:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <xMissedYield>
    2356:	08 95       	ret

00002358 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2358:	00 97       	sbiw	r24, 0x00	; 0
    235a:	21 f4       	brne	.+8      	; 0x2364 <uxTaskGetStackHighWaterMark+0xc>
    235c:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    2360:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2364:	dc 01       	movw	r26, r24
    2366:	5b 96       	adiw	r26, 0x1b	; 27
    2368:	ed 91       	ld	r30, X+
    236a:	fc 91       	ld	r31, X
    236c:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    236e:	80 81       	ld	r24, Z
    2370:	81 31       	cpi	r24, 0x11	; 17
    2372:	41 f4       	brne	.+16     	; 0x2384 <uxTaskGetStackHighWaterMark+0x2c>
    2374:	31 96       	adiw	r30, 0x01	; 1
    2376:	80 e0       	ldi	r24, 0x00	; 0
    2378:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    237a:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    237c:	21 91       	ld	r18, Z+
    237e:	21 31       	cpi	r18, 0x11	; 17
    2380:	e1 f3       	breq	.-8      	; 0x237a <uxTaskGetStackHighWaterMark+0x22>
    2382:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2384:	80 e0       	ldi	r24, 0x00	; 0
    2386:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2388:	08 95       	ret

0000238a <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    238a:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    238e:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2392:	08 95       	ret

00002394 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2394:	0f 93       	push	r16
    2396:	1f 93       	push	r17
    2398:	cf 93       	push	r28
    239a:	df 93       	push	r29
    239c:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    239e:	22 8d       	ldd	r18, Z+26	; 0x1a
    23a0:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    23a4:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    23a8:	5a 96       	adiw	r26, 0x1a	; 26
    23aa:	8c 91       	ld	r24, X
    23ac:	28 17       	cp	r18, r24
    23ae:	08 f0       	brcs	.+2      	; 0x23b2 <vTaskPriorityInherit+0x1e>
    23b0:	41 c0       	rjmp	.+130    	; 0x2434 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    23b2:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    23b6:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    23ba:	5a 96       	adiw	r26, 0x1a	; 26
    23bc:	3c 91       	ld	r19, X
    23be:	84 e0       	ldi	r24, 0x04	; 4
    23c0:	90 e0       	ldi	r25, 0x00	; 0
    23c2:	a0 e0       	ldi	r26, 0x00	; 0
    23c4:	b0 e0       	ldi	r27, 0x00	; 0
    23c6:	83 1b       	sub	r24, r19
    23c8:	91 09       	sbc	r25, r1
    23ca:	a1 09       	sbc	r26, r1
    23cc:	b1 09       	sbc	r27, r1
    23ce:	86 87       	std	Z+14, r24	; 0x0e
    23d0:	97 87       	std	Z+15, r25	; 0x0f
    23d2:	a0 8b       	std	Z+16, r26	; 0x10
    23d4:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    23d6:	8b e0       	ldi	r24, 0x0B	; 11
    23d8:	28 9f       	mul	r18, r24
    23da:	90 01       	movw	r18, r0
    23dc:	11 24       	eor	r1, r1
    23de:	26 5e       	subi	r18, 0xE6	; 230
    23e0:	3e 4c       	sbci	r19, 0xCE	; 206
    23e2:	84 85       	ldd	r24, Z+12	; 0x0c
    23e4:	95 85       	ldd	r25, Z+13	; 0x0d
    23e6:	82 17       	cp	r24, r18
    23e8:	93 07       	cpc	r25, r19
    23ea:	e9 f4       	brne	.+58     	; 0x2426 <vTaskPriorityInherit+0x92>
    23ec:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    23ee:	ef 01       	movw	r28, r30
    23f0:	22 96       	adiw	r28, 0x02	; 2
    23f2:	ce 01       	movw	r24, r28
    23f4:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    23f8:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    23fc:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    2400:	82 8d       	ldd	r24, Z+26	; 0x1a
    2402:	f8 01       	movw	r30, r16
    2404:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2406:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    240a:	98 17       	cp	r25, r24
    240c:	10 f4       	brcc	.+4      	; 0x2412 <vTaskPriorityInherit+0x7e>
    240e:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    2412:	fb e0       	ldi	r31, 0x0B	; 11
    2414:	8f 9f       	mul	r24, r31
    2416:	c0 01       	movw	r24, r0
    2418:	11 24       	eor	r1, r1
    241a:	be 01       	movw	r22, r28
    241c:	86 5e       	subi	r24, 0xE6	; 230
    241e:	9e 4c       	sbci	r25, 0xCE	; 206
    2420:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
    2424:	07 c0       	rjmp	.+14     	; 0x2434 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2426:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    242a:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    242e:	5a 96       	adiw	r26, 0x1a	; 26
    2430:	8c 91       	ld	r24, X
    2432:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2434:	df 91       	pop	r29
    2436:	cf 91       	pop	r28
    2438:	1f 91       	pop	r17
    243a:	0f 91       	pop	r16
    243c:	08 95       	ret

0000243e <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2446:	00 97       	sbiw	r24, 0x00	; 0
    2448:	49 f1       	breq	.+82     	; 0x249c <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    244a:	fc 01       	movw	r30, r24
    244c:	32 8d       	ldd	r19, Z+26	; 0x1a
    244e:	27 a1       	ldd	r18, Z+39	; 0x27
    2450:	32 17       	cp	r19, r18
    2452:	21 f1       	breq	.+72     	; 0x249c <vTaskPriorityDisinherit+0x5e>
    2454:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2456:	8c 01       	movw	r16, r24
    2458:	0e 5f       	subi	r16, 0xFE	; 254
    245a:	1f 4f       	sbci	r17, 0xFF	; 255
    245c:	c8 01       	movw	r24, r16
    245e:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2462:	8f a1       	ldd	r24, Y+39	; 0x27
    2464:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2466:	44 e0       	ldi	r20, 0x04	; 4
    2468:	50 e0       	ldi	r21, 0x00	; 0
    246a:	60 e0       	ldi	r22, 0x00	; 0
    246c:	70 e0       	ldi	r23, 0x00	; 0
    246e:	48 1b       	sub	r20, r24
    2470:	51 09       	sbc	r21, r1
    2472:	61 09       	sbc	r22, r1
    2474:	71 09       	sbc	r23, r1
    2476:	4e 87       	std	Y+14, r20	; 0x0e
    2478:	5f 87       	std	Y+15, r21	; 0x0f
    247a:	68 8b       	std	Y+16, r22	; 0x10
    247c:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    247e:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2482:	98 17       	cp	r25, r24
    2484:	10 f4       	brcc	.+4      	; 0x248a <vTaskPriorityDisinherit+0x4c>
    2486:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    248a:	fb e0       	ldi	r31, 0x0B	; 11
    248c:	8f 9f       	mul	r24, r31
    248e:	c0 01       	movw	r24, r0
    2490:	11 24       	eor	r1, r1
    2492:	b8 01       	movw	r22, r16
    2494:	86 5e       	subi	r24, 0xE6	; 230
    2496:	9e 4c       	sbci	r25, 0xCE	; 206
    2498:	0e 94 09 08 	call	0x1012	; 0x1012 <vListInsertEnd>
			}
		}
	}
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	08 95       	ret

000024a6 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    24a6:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    24a8:	e8 81       	ld	r30, Y
    24aa:	f9 81       	ldd	r31, Y+1	; 0x01
    24ac:	01 90       	ld	r0, Z+
    24ae:	f0 81       	ld	r31, Z
    24b0:	e0 2d       	mov	r30, r0
    24b2:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    24b4:	1a 82       	std	Y+2, r1	; 0x02
    24b6:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    24b8:	6f ef       	ldi	r22, 0xFF	; 255
    24ba:	7f ef       	ldi	r23, 0xFF	; 255
    24bc:	cb 01       	movw	r24, r22
    24be:	0e 94 36 10 	call	0x206c	; 0x206c <vTaskDelay>
    24c2:	fa cf       	rjmp	.-12     	; 0x24b8 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000024c4 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    24c4:	fc 01       	movw	r30, r24
    24c6:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    24c8:	65 87       	std	Z+13, r22	; 0x0d
    24ca:	08 95       	ret

000024cc <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    24cc:	4f 92       	push	r4
    24ce:	5f 92       	push	r5
    24d0:	6f 92       	push	r6
    24d2:	7f 92       	push	r7
    24d4:	8f 92       	push	r8
    24d6:	9f 92       	push	r9
    24d8:	af 92       	push	r10
    24da:	bf 92       	push	r11
    24dc:	cf 92       	push	r12
    24de:	df 92       	push	r13
    24e0:	ef 92       	push	r14
    24e2:	ff 92       	push	r15
    24e4:	0f 93       	push	r16
    24e6:	1f 93       	push	r17
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
    24ec:	cd b7       	in	r28, 0x3d	; 61
    24ee:	de b7       	in	r29, 0x3e	; 62
    24f0:	2a 97       	sbiw	r28, 0x0a	; 10
    24f2:	cd bf       	out	0x3d, r28	; 61
    24f4:	de bf       	out	0x3e, r29	; 62
    24f6:	4c 01       	movw	r8, r24
    24f8:	29 01       	movw	r4, r18
    24fa:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    24fc:	8b e3       	ldi	r24, 0x3B	; 59
    24fe:	90 e2       	ldi	r25, 0x20	; 32
    2500:	f4 01       	movw	r30, r8
    2502:	80 83       	st	Z, r24
    2504:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2506:	fb 01       	movw	r30, r22
    2508:	80 81       	ld	r24, Z
    250a:	88 23       	and	r24, r24
    250c:	69 f0       	breq	.+26     	; 0x2528 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    250e:	de 01       	movw	r26, r28
    2510:	11 96       	adiw	r26, 0x01	; 1
    2512:	31 96       	adiw	r30, 0x01	; 1
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	02 c0       	rjmp	.+4      	; 0x251c <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2518:	99 30       	cpi	r25, 0x09	; 9
    251a:	39 f0       	breq	.+14     	; 0x252a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    251c:	9f 5f       	subi	r25, 0xFF	; 255
    251e:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2520:	81 91       	ld	r24, Z+
    2522:	81 11       	cpse	r24, r1
    2524:	f9 cf       	rjmp	.-14     	; 0x2518 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2526:	01 c0       	rjmp	.+2      	; 0x252a <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2528:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    252a:	e1 e0       	ldi	r30, 0x01	; 1
    252c:	f0 e0       	ldi	r31, 0x00	; 0
    252e:	ec 0f       	add	r30, r28
    2530:	fd 1f       	adc	r31, r29
    2532:	e9 0f       	add	r30, r25
    2534:	f1 1d       	adc	r31, r1
    2536:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2538:	74 01       	movw	r14, r8
    253a:	f2 e0       	ldi	r31, 0x02	; 2
    253c:	ef 0e       	add	r14, r31
    253e:	f1 1c       	adc	r15, r1
    2540:	a1 2c       	mov	r10, r1
    2542:	b1 2c       	mov	r11, r1
    2544:	c1 2c       	mov	r12, r1
    2546:	d1 2c       	mov	r13, r1
    2548:	04 2f       	mov	r16, r20
    254a:	94 01       	movw	r18, r8
    254c:	a2 01       	movw	r20, r4
    254e:	be 01       	movw	r22, r28
    2550:	6f 5f       	subi	r22, 0xFF	; 255
    2552:	7f 4f       	sbci	r23, 0xFF	; 255
    2554:	88 ee       	ldi	r24, 0xE8	; 232
    2556:	92 e0       	ldi	r25, 0x02	; 2
    2558:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    255c:	f4 01       	movw	r30, r8
    255e:	66 82       	std	Z+6, r6	; 0x06
    2560:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2562:	40 86       	std	Z+8, r4	; 0x08
    2564:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2566:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <last_created_task_pointer>
    256a:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    256e:	24 83       	std	Z+4, r18	; 0x04
    2570:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2572:	80 92 48 31 	sts	0x3148, r8	; 0x803148 <last_created_task_pointer>
    2576:	90 92 49 31 	sts	0x3149, r9	; 0x803149 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    257a:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    257c:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    257e:	40 90 aa 31 	lds	r4, 0x31AA	; 0x8031aa <portStackTopForTask>
    2582:	50 90 ab 31 	lds	r5, 0x31AB	; 0x8031ab <portStackTopForTask+0x1>
    2586:	ff ef       	ldi	r31, 0xFF	; 255
    2588:	4f 1a       	sub	r4, r31
    258a:	5f 0a       	sbc	r5, r31
    258c:	40 92 aa 31 	sts	0x31AA, r4	; 0x8031aa <portStackTopForTask>
    2590:	50 92 ab 31 	sts	0x31AB, r5	; 0x8031ab <portStackTopForTask+0x1>
    2594:	f4 01       	movw	r30, r8
    2596:	42 86       	std	Z+10, r4	; 0x0a
    2598:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    259a:	16 86       	std	Z+14, r1	; 0x0e
    259c:	17 86       	std	Z+15, r1	; 0x0f
    259e:	10 8a       	std	Z+16, r1	; 0x10
    25a0:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    25a2:	61 14       	cp	r6, r1
    25a4:	71 04       	cpc	r7, r1
    25a6:	09 f4       	brne	.+2      	; 0x25aa <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    25a8:	44 c0       	rjmp	.+136    	; 0x2632 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    25aa:	81 30       	cpi	r24, 0x01	; 1
    25ac:	79 f5       	brne	.+94     	; 0x260c <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    25ae:	6a e0       	ldi	r22, 0x0A	; 10
    25b0:	c3 01       	movw	r24, r6
    25b2:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    25b6:	7c 01       	movw	r14, r24
    25b8:	6d e1       	ldi	r22, 0x1D	; 29
    25ba:	75 e0       	ldi	r23, 0x05	; 5
    25bc:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    25c0:	be 01       	movw	r22, r28
    25c2:	6f 5f       	subi	r22, 0xFF	; 255
    25c4:	7f 4f       	sbci	r23, 0xFF	; 255
    25c6:	c7 01       	movw	r24, r14
    25c8:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    25cc:	6a e0       	ldi	r22, 0x0A	; 10
    25ce:	c7 01       	movw	r24, r14
    25d0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    25d4:	7c 01       	movw	r14, r24
    25d6:	64 e1       	ldi	r22, 0x14	; 20
    25d8:	75 e0       	ldi	r23, 0x05	; 5
    25da:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    25de:	6a e0       	ldi	r22, 0x0A	; 10
    25e0:	c7 01       	movw	r24, r14
    25e2:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    25e6:	7c 01       	movw	r14, r24
    25e8:	66 e0       	ldi	r22, 0x06	; 6
    25ea:	75 e0       	ldi	r23, 0x05	; 5
    25ec:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    25f0:	63 e0       	ldi	r22, 0x03	; 3
    25f2:	c7 01       	movw	r24, r14
    25f4:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    25f8:	b2 01       	movw	r22, r4
    25fa:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
    25fe:	62 e0       	ldi	r22, 0x02	; 2
    2600:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2604:	66 e0       	ldi	r22, 0x06	; 6
    2606:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    260a:	13 c0       	rjmp	.+38     	; 0x2632 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    260c:	6a e0       	ldi	r22, 0x0A	; 10
    260e:	c3 01       	movw	r24, r6
    2610:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2614:	4c 01       	movw	r8, r24
    2616:	61 ef       	ldi	r22, 0xF1	; 241
    2618:	74 e0       	ldi	r23, 0x04	; 4
    261a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    261e:	be 01       	movw	r22, r28
    2620:	6f 5f       	subi	r22, 0xFF	; 255
    2622:	7f 4f       	sbci	r23, 0xFF	; 255
    2624:	c4 01       	movw	r24, r8
    2626:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    262a:	66 e0       	ldi	r22, 0x06	; 6
    262c:	c4 01       	movw	r24, r8
    262e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2632:	2a 96       	adiw	r28, 0x0a	; 10
    2634:	cd bf       	out	0x3d, r28	; 61
    2636:	de bf       	out	0x3e, r29	; 62
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	1f 91       	pop	r17
    263e:	0f 91       	pop	r16
    2640:	ff 90       	pop	r15
    2642:	ef 90       	pop	r14
    2644:	df 90       	pop	r13
    2646:	cf 90       	pop	r12
    2648:	bf 90       	pop	r11
    264a:	af 90       	pop	r10
    264c:	9f 90       	pop	r9
    264e:	8f 90       	pop	r8
    2650:	7f 90       	pop	r7
    2652:	6f 90       	pop	r6
    2654:	5f 90       	pop	r5
    2656:	4f 90       	pop	r4
    2658:	08 95       	ret

0000265a <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    265a:	cf 92       	push	r12
    265c:	df 92       	push	r13
    265e:	ef 92       	push	r14
    2660:	ff 92       	push	r15
    2662:	0f 93       	push	r16
    2664:	1f 93       	push	r17
    2666:	cf 93       	push	r28
    2668:	df 93       	push	r29
    266a:	ec 01       	movw	r28, r24
    266c:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    266e:	8a 81       	ldd	r24, Y+2	; 0x02
    2670:	9b 81       	ldd	r25, Y+3	; 0x03
    2672:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <pcTaskGetTaskName>
    2676:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2678:	6a e0       	ldi	r22, 0x0A	; 10
    267a:	c7 01       	movw	r24, r14
    267c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2680:	8c 01       	movw	r16, r24
    2682:	60 e3       	ldi	r22, 0x30	; 48
    2684:	75 e0       	ldi	r23, 0x05	; 5
    2686:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    268a:	6a e0       	ldi	r22, 0x0A	; 10
    268c:	c8 01       	movw	r24, r16
    268e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2692:	8c 01       	movw	r16, r24
    2694:	69 e2       	ldi	r22, 0x29	; 41
    2696:	75 e0       	ldi	r23, 0x05	; 5
    2698:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    269c:	b6 01       	movw	r22, r12
    269e:	c8 01       	movw	r24, r16
    26a0:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    26a4:	6a e0       	ldi	r22, 0x0A	; 10
    26a6:	c8 01       	movw	r24, r16
    26a8:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    26ac:	8c 01       	movw	r16, r24
    26ae:	63 e2       	ldi	r22, 0x23	; 35
    26b0:	75 e0       	ldi	r23, 0x05	; 5
    26b2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    26b6:	66 e0       	ldi	r22, 0x06	; 6
    26b8:	c8 01       	movw	r24, r16
    26ba:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    26be:	8a 85       	ldd	r24, Y+10	; 0x0a
    26c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    26c2:	e8 85       	ldd	r30, Y+8	; 0x08
    26c4:	f9 85       	ldd	r31, Y+9	; 0x09
    26c6:	01 e1       	ldi	r16, 0x11	; 17
    26c8:	21 e0       	ldi	r18, 0x01	; 1
    26ca:	a7 01       	movw	r20, r14
    26cc:	bc 01       	movw	r22, r24
    26ce:	8e 1b       	sub	r24, r30
    26d0:	9f 0b       	sbc	r25, r31
    26d2:	0e 94 2f 16 	call	0x2c5e	; 0x2c5e <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    26d6:	8c 81       	ldd	r24, Y+4	; 0x04
    26d8:	9d 81       	ldd	r25, Y+5	; 0x05
    26da:	00 97       	sbiw	r24, 0x00	; 0
    26dc:	19 f0       	breq	.+6      	; 0x26e4 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    26de:	b7 01       	movw	r22, r14
    26e0:	0e 94 2d 13 	call	0x265a	; 0x265a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    26e4:	df 91       	pop	r29
    26e6:	cf 91       	pop	r28
    26e8:	1f 91       	pop	r17
    26ea:	0f 91       	pop	r16
    26ec:	ff 90       	pop	r15
    26ee:	ef 90       	pop	r14
    26f0:	df 90       	pop	r13
    26f2:	cf 90       	pop	r12
    26f4:	08 95       	ret

000026f6 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    26f6:	0f 93       	push	r16
    26f8:	1f 93       	push	r17
    26fa:	cf 93       	push	r28
    26fc:	df 93       	push	r29
    26fe:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2700:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <last_created_task_pointer>
    2704:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    2708:	00 97       	sbiw	r24, 0x00	; 0
    270a:	19 f0       	breq	.+6      	; 0x2712 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    270c:	be 01       	movw	r22, r28
    270e:	0e 94 2d 13 	call	0x265a	; 0x265a <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2712:	6a e0       	ldi	r22, 0x0A	; 10
    2714:	ce 01       	movw	r24, r28
    2716:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    271a:	8c 01       	movw	r16, r24
    271c:	66 e4       	ldi	r22, 0x46	; 70
    271e:	75 e0       	ldi	r23, 0x05	; 5
    2720:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2724:	6a e0       	ldi	r22, 0x0A	; 10
    2726:	c8 01       	movw	r24, r16
    2728:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    272c:	8c 01       	movw	r16, r24
    272e:	6b e3       	ldi	r22, 0x3B	; 59
    2730:	75 e0       	ldi	r23, 0x05	; 5
    2732:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2736:	6a e0       	ldi	r22, 0x0A	; 10
    2738:	c8 01       	movw	r24, r16
    273a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    273e:	8c 01       	movw	r16, r24
    2740:	65 e3       	ldi	r22, 0x35	; 53
    2742:	75 e0       	ldi	r23, 0x05	; 5
    2744:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2748:	66 e0       	ldi	r22, 0x06	; 6
    274a:	c8 01       	movw	r24, r16
    274c:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2750:	80 91 aa 31 	lds	r24, 0x31AA	; 0x8031aa <portStackTopForTask>
    2754:	90 91 ab 31 	lds	r25, 0x31AB	; 0x8031ab <portStackTopForTask+0x1>
    2758:	bc 01       	movw	r22, r24
    275a:	6f 5f       	subi	r22, 0xFF	; 255
    275c:	7f 4f       	sbci	r23, 0xFF	; 255
    275e:	01 e1       	ldi	r16, 0x11	; 17
    2760:	21 e0       	ldi	r18, 0x01	; 1
    2762:	ae 01       	movw	r20, r28
    2764:	83 56       	subi	r24, 0x63	; 99
    2766:	91 09       	sbc	r25, r1
    2768:	0e 94 2f 16 	call	0x2c5e	; 0x2c5e <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    276c:	df 91       	pop	r29
    276e:	cf 91       	pop	r28
    2770:	1f 91       	pop	r17
    2772:	0f 91       	pop	r16
    2774:	08 95       	ret

00002776 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2776:	8f 92       	push	r8
    2778:	9f 92       	push	r9
    277a:	af 92       	push	r10
    277c:	bf 92       	push	r11
    277e:	cf 92       	push	r12
    2780:	df 92       	push	r13
    2782:	ef 92       	push	r14
    2784:	ff 92       	push	r15
    2786:	0f 93       	push	r16
    2788:	1f 93       	push	r17
    278a:	cf 93       	push	r28
    278c:	df 93       	push	r29
    278e:	ec 01       	movw	r28, r24
    2790:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2792:	8a 81       	ldd	r24, Y+2	; 0x02
    2794:	9b 81       	ldd	r25, Y+3	; 0x03
    2796:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <pcTaskGetTaskName>
    279a:	bc 01       	movw	r22, r24
    279c:	c8 01       	movw	r24, r16
    279e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    27a2:	d8 01       	movw	r26, r16
    27a4:	ed 91       	ld	r30, X+
    27a6:	fc 91       	ld	r31, X
    27a8:	02 80       	ldd	r0, Z+2	; 0x02
    27aa:	f3 81       	ldd	r31, Z+3	; 0x03
    27ac:	e0 2d       	mov	r30, r0
    27ae:	69 e0       	ldi	r22, 0x09	; 9
    27b0:	c8 01       	movw	r24, r16
    27b2:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    27b4:	8a 81       	ldd	r24, Y+2	; 0x02
    27b6:	9b 81       	ldd	r25, Y+3	; 0x03
    27b8:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <pcTaskGetTaskName>
    27bc:	fc 01       	movw	r30, r24
    27be:	01 90       	ld	r0, Z+
    27c0:	00 20       	and	r0, r0
    27c2:	e9 f7       	brne	.-6      	; 0x27be <_ZN8frt_task12print_statusER8emstream+0x48>
    27c4:	31 97       	sbiw	r30, 0x01	; 1
    27c6:	e8 1b       	sub	r30, r24
    27c8:	f9 0b       	sbc	r31, r25
    27ca:	38 97       	sbiw	r30, 0x08	; 8
    27cc:	48 f4       	brcc	.+18     	; 0x27e0 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    27ce:	d8 01       	movw	r26, r16
    27d0:	ed 91       	ld	r30, X+
    27d2:	fc 91       	ld	r31, X
    27d4:	02 80       	ldd	r0, Z+2	; 0x02
    27d6:	f3 81       	ldd	r31, Z+3	; 0x03
    27d8:	e0 2d       	mov	r30, r0
    27da:	69 e0       	ldi	r22, 0x09	; 9
    27dc:	c8 01       	movw	r24, r16
    27de:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    27e0:	ce 84       	ldd	r12, Y+14	; 0x0e
    27e2:	df 84       	ldd	r13, Y+15	; 0x0f
    27e4:	e8 88       	ldd	r14, Y+16	; 0x10
    27e6:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    27e8:	a8 84       	ldd	r10, Y+8	; 0x08
    27ea:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    27ec:	8a 81       	ldd	r24, Y+2	; 0x02
    27ee:	9b 81       	ldd	r25, Y+3	; 0x03
    27f0:	0e 94 ac 11 	call	0x2358	; 0x2358 <uxTaskGetStackHighWaterMark>
    27f4:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    27f6:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    27f8:	8a 81       	ldd	r24, Y+2	; 0x02
    27fa:	9b 81       	ldd	r25, Y+3	; 0x03
    27fc:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxTaskPriorityGet>
    2800:	68 2f       	mov	r22, r24
    2802:	c8 01       	movw	r24, r16
    2804:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    2808:	6a e0       	ldi	r22, 0x0A	; 10
    280a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    280e:	ec 01       	movw	r28, r24
    2810:	6b eb       	ldi	r22, 0xBB	; 187
    2812:	75 e0       	ldi	r23, 0x05	; 5
    2814:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2818:	68 2d       	mov	r22, r8
    281a:	ce 01       	movw	r24, r28
    281c:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2820:	6a e0       	ldi	r22, 0x0A	; 10
    2822:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2826:	ec 01       	movw	r28, r24
    2828:	69 eb       	ldi	r22, 0xB9	; 185
    282a:	75 e0       	ldi	r23, 0x05	; 5
    282c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2830:	69 2d       	mov	r22, r9
    2832:	ce 01       	movw	r24, r28
    2834:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    2838:	6a e0       	ldi	r22, 0x0A	; 10
    283a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    283e:	ec 01       	movw	r28, r24
    2840:	67 eb       	ldi	r22, 0xB7	; 183
    2842:	75 e0       	ldi	r23, 0x05	; 5
    2844:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2848:	b5 01       	movw	r22, r10
    284a:	ce 01       	movw	r24, r28
    284c:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
    2850:	6a e0       	ldi	r22, 0x0A	; 10
    2852:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2856:	ec 01       	movw	r28, r24
    2858:	65 eb       	ldi	r22, 0xB5	; 181
    285a:	75 e0       	ldi	r23, 0x05	; 5
    285c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2860:	6a e0       	ldi	r22, 0x0A	; 10
    2862:	ce 01       	movw	r24, r28
    2864:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2868:	ec 01       	movw	r28, r24
    286a:	63 eb       	ldi	r22, 0xB3	; 179
    286c:	75 e0       	ldi	r23, 0x05	; 5
    286e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2872:	b7 01       	movw	r22, r14
    2874:	a6 01       	movw	r20, r12
    2876:	ce 01       	movw	r24, r28
    2878:	0e 94 46 18 	call	0x308c	; 0x308c <_ZN8emstreamlsEm>
}
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	1f 91       	pop	r17
    2882:	0f 91       	pop	r16
    2884:	ff 90       	pop	r15
    2886:	ef 90       	pop	r14
    2888:	df 90       	pop	r13
    288a:	cf 90       	pop	r12
    288c:	bf 90       	pop	r11
    288e:	af 90       	pop	r10
    2890:	9f 90       	pop	r9
    2892:	8f 90       	pop	r8
    2894:	08 95       	ret

00002896 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2896:	cf 93       	push	r28
    2898:	df 93       	push	r29
    289a:	ec 01       	movw	r28, r24
    289c:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    289e:	db 01       	movw	r26, r22
    28a0:	ed 91       	ld	r30, X+
    28a2:	fc 91       	ld	r31, X
    28a4:	02 80       	ldd	r0, Z+2	; 0x02
    28a6:	f3 81       	ldd	r31, Z+3	; 0x03
    28a8:	e0 2d       	mov	r30, r0
    28aa:	be 01       	movw	r22, r28
    28ac:	19 95       	eicall
	return (ser_dev);
}
    28ae:	ce 01       	movw	r24, r28
    28b0:	df 91       	pop	r29
    28b2:	cf 91       	pop	r28
    28b4:	08 95       	ret

000028b6 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    28b6:	0f 93       	push	r16
    28b8:	1f 93       	push	r17
    28ba:	cf 93       	push	r28
    28bc:	df 93       	push	r29
    28be:	ec 01       	movw	r28, r24
    28c0:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    28c2:	bc 01       	movw	r22, r24
    28c4:	c8 01       	movw	r24, r16
    28c6:	0e 94 4b 14 	call	0x2896	; 0x2896 <_ZlsR8emstreamR8frt_task>
    28ca:	66 e0       	ldi	r22, 0x06	; 6
    28cc:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    28d0:	8c 81       	ldd	r24, Y+4	; 0x04
    28d2:	9d 81       	ldd	r25, Y+5	; 0x05
    28d4:	00 97       	sbiw	r24, 0x00	; 0
    28d6:	19 f0       	breq	.+6      	; 0x28de <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    28d8:	b8 01       	movw	r22, r16
    28da:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    28de:	df 91       	pop	r29
    28e0:	cf 91       	pop	r28
    28e2:	1f 91       	pop	r17
    28e4:	0f 91       	pop	r16
    28e6:	08 95       	ret

000028e8 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    28e8:	0f 93       	push	r16
    28ea:	1f 93       	push	r17
    28ec:	cf 93       	push	r28
    28ee:	df 93       	push	r29
    28f0:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    28f2:	6a e0       	ldi	r22, 0x0A	; 10
    28f4:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    28f8:	8c 01       	movw	r16, r24
    28fa:	68 ea       	ldi	r22, 0xA8	; 168
    28fc:	75 e0       	ldi	r23, 0x05	; 5
    28fe:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2902:	6a e0       	ldi	r22, 0x0A	; 10
    2904:	c8 01       	movw	r24, r16
    2906:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    290a:	8c 01       	movw	r16, r24
    290c:	61 ea       	ldi	r22, 0xA1	; 161
    290e:	75 e0       	ldi	r23, 0x05	; 5
    2910:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2914:	66 e0       	ldi	r22, 0x06	; 6
    2916:	c8 01       	movw	r24, r16
    2918:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    291c:	6a e0       	ldi	r22, 0x0A	; 10
    291e:	ce 01       	movw	r24, r28
    2920:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2924:	8c 01       	movw	r16, r24
    2926:	60 e9       	ldi	r22, 0x90	; 144
    2928:	75 e0       	ldi	r23, 0x05	; 5
    292a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    292e:	6a e0       	ldi	r22, 0x0A	; 10
    2930:	c8 01       	movw	r24, r16
    2932:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2936:	8c 01       	movw	r16, r24
    2938:	64 e8       	ldi	r22, 0x84	; 132
    293a:	75 e0       	ldi	r23, 0x05	; 5
    293c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2940:	6a e0       	ldi	r22, 0x0A	; 10
    2942:	c8 01       	movw	r24, r16
    2944:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2948:	8c 01       	movw	r16, r24
    294a:	6e e7       	ldi	r22, 0x7E	; 126
    294c:	75 e0       	ldi	r23, 0x05	; 5
    294e:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2952:	66 e0       	ldi	r22, 0x06	; 6
    2954:	c8 01       	movw	r24, r16
    2956:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    295a:	6a e0       	ldi	r22, 0x0A	; 10
    295c:	ce 01       	movw	r24, r28
    295e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2962:	8c 01       	movw	r16, r24
    2964:	6d e6       	ldi	r22, 0x6D	; 109
    2966:	75 e0       	ldi	r23, 0x05	; 5
    2968:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    296c:	6a e0       	ldi	r22, 0x0A	; 10
    296e:	c8 01       	movw	r24, r16
    2970:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2974:	8c 01       	movw	r16, r24
    2976:	61 e6       	ldi	r22, 0x61	; 97
    2978:	75 e0       	ldi	r23, 0x05	; 5
    297a:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    297e:	6a e0       	ldi	r22, 0x0A	; 10
    2980:	c8 01       	movw	r24, r16
    2982:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2986:	8c 01       	movw	r16, r24
    2988:	6b e5       	ldi	r22, 0x5B	; 91
    298a:	75 e0       	ldi	r23, 0x05	; 5
    298c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2990:	66 e0       	ldi	r22, 0x06	; 6
    2992:	c8 01       	movw	r24, r16
    2994:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2998:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <last_created_task_pointer>
    299c:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    29a0:	00 97       	sbiw	r24, 0x00	; 0
    29a2:	19 f0       	breq	.+6      	; 0x29aa <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    29a4:	be 01       	movw	r22, r28
    29a6:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29aa:	0e 94 ae 0e 	call	0x1d5c	; 0x1d5c <xTaskGetIdleTaskHandle>
    29ae:	0e 94 ac 11 	call	0x2358	; 0x2358 <uxTaskGetStackHighWaterMark>
    29b2:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    29b4:	6a e0       	ldi	r22, 0x0A	; 10
    29b6:	ce 01       	movw	r24, r28
    29b8:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    29bc:	ec 01       	movw	r28, r24
    29be:	60 e5       	ldi	r22, 0x50	; 80
    29c0:	75 e0       	ldi	r23, 0x05	; 5
    29c2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29c6:	61 2f       	mov	r22, r17
    29c8:	ce 01       	movw	r24, r28
    29ca:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    29ce:	6a e0       	ldi	r22, 0x0A	; 10
    29d0:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    29d4:	ec 01       	movw	r28, r24
    29d6:	6e e4       	ldi	r22, 0x4E	; 78
    29d8:	75 e0       	ldi	r23, 0x05	; 5
    29da:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    29de:	64 e6       	ldi	r22, 0x64	; 100
    29e0:	70 e0       	ldi	r23, 0x00	; 0
    29e2:	ce 01       	movw	r24, r28
    29e4:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
    29e8:	6a e0       	ldi	r22, 0x0A	; 10
    29ea:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    29ee:	ec 01       	movw	r28, r24
    29f0:	6b e4       	ldi	r22, 0x4B	; 75
    29f2:	75 e0       	ldi	r23, 0x05	; 5
    29f4:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    29f8:	66 e0       	ldi	r22, 0x06	; 6
    29fa:	ce 01       	movw	r24, r28
    29fc:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
}
    2a00:	df 91       	pop	r29
    2a02:	cf 91       	pop	r28
    2a04:	1f 91       	pop	r17
    2a06:	0f 91       	pop	r16
    2a08:	08 95       	ret

00002a0a <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2a0a:	0f 93       	push	r16
    2a0c:	cf 93       	push	r28
    2a0e:	df 93       	push	r29
    2a10:	1f 92       	push	r1
    2a12:	cd b7       	in	r28, 0x3d	; 61
    2a14:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2a16:	00 e0       	ldi	r16, 0x00	; 0
    2a18:	2f ef       	ldi	r18, 0xFF	; 255
    2a1a:	3f ef       	ldi	r19, 0xFF	; 255
    2a1c:	a9 01       	movw	r20, r18
    2a1e:	be 01       	movw	r22, r28
    2a20:	6f 5f       	subi	r22, 0xFF	; 255
    2a22:	7f 4f       	sbci	r23, 0xFF	; 255
    2a24:	fc 01       	movw	r30, r24
    2a26:	80 85       	ldd	r24, Z+8	; 0x08
    2a28:	91 85       	ldd	r25, Z+9	; 0x09
    2a2a:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
    2a2e:	81 30       	cpi	r24, 0x01	; 1
    2a30:	19 f4       	brne	.+6      	; 0x2a38 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	02 c0       	rjmp	.+4      	; 0x2a3c <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2a38:	8f ef       	ldi	r24, 0xFF	; 255
    2a3a:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2a3c:	0f 90       	pop	r0
    2a3e:	df 91       	pop	r29
    2a40:	cf 91       	pop	r28
    2a42:	0f 91       	pop	r16
    2a44:	08 95       	ret

00002a46 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2a46:	fc 01       	movw	r30, r24
    2a48:	80 85       	ldd	r24, Z+8	; 0x08
    2a4a:	91 85       	ldd	r25, Z+9	; 0x09
    2a4c:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
    2a50:	91 e0       	ldi	r25, 0x01	; 1
    2a52:	81 11       	cpse	r24, r1
    2a54:	01 c0       	rjmp	.+2      	; 0x2a58 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2a56:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2a58:	89 2f       	mov	r24, r25
    2a5a:	08 95       	ret

00002a5c <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2a5c:	0f 93       	push	r16
    2a5e:	cf 93       	push	r28
    2a60:	df 93       	push	r29
    2a62:	1f 92       	push	r1
    2a64:	cd b7       	in	r28, 0x3d	; 61
    2a66:	de b7       	in	r29, 0x3e	; 62
    2a68:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	22 85       	ldd	r18, Z+10	; 0x0a
    2a6e:	33 85       	ldd	r19, Z+11	; 0x0b
    2a70:	44 85       	ldd	r20, Z+12	; 0x0c
    2a72:	55 85       	ldd	r21, Z+13	; 0x0d
    2a74:	00 e0       	ldi	r16, 0x00	; 0
    2a76:	be 01       	movw	r22, r28
    2a78:	6f 5f       	subi	r22, 0xFF	; 255
    2a7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a7c:	80 85       	ldd	r24, Z+8	; 0x08
    2a7e:	91 85       	ldd	r25, Z+9	; 0x09
    2a80:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    2a84:	91 e0       	ldi	r25, 0x01	; 1
    2a86:	81 11       	cpse	r24, r1
    2a88:	01 c0       	rjmp	.+2      	; 0x2a8c <_ZN14frt_text_queue7putcharEc+0x30>
    2a8a:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2a8c:	89 2f       	mov	r24, r25
    2a8e:	0f 90       	pop	r0
    2a90:	df 91       	pop	r29
    2a92:	cf 91       	pop	r28
    2a94:	0f 91       	pop	r16
    2a96:	08 95       	ret

00002a98 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2a98:	8f 92       	push	r8
    2a9a:	9f 92       	push	r9
    2a9c:	bf 92       	push	r11
    2a9e:	cf 92       	push	r12
    2aa0:	df 92       	push	r13
    2aa2:	ef 92       	push	r14
    2aa4:	ff 92       	push	r15
    2aa6:	0f 93       	push	r16
    2aa8:	1f 93       	push	r17
    2aaa:	cf 93       	push	r28
    2aac:	df 93       	push	r29
    2aae:	ec 01       	movw	r28, r24
    2ab0:	b6 2e       	mov	r11, r22
    2ab2:	4a 01       	movw	r8, r20
    2ab4:	68 01       	movw	r12, r16
    2ab6:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2ab8:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <_ZN8emstreamC1Ev>
    2abc:	83 e4       	ldi	r24, 0x43	; 67
    2abe:	90 e2       	ldi	r25, 0x20	; 32
    2ac0:	88 83       	st	Y, r24
    2ac2:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ac4:	8e 86       	std	Y+14, r8	; 0x0e
    2ac6:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2ac8:	40 e0       	ldi	r20, 0x00	; 0
    2aca:	61 e0       	ldi	r22, 0x01	; 1
    2acc:	8b 2d       	mov	r24, r11
    2ace:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    2ad2:	88 87       	std	Y+8, r24	; 0x08
    2ad4:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2ad6:	ca 86       	std	Y+10, r12	; 0x0a
    2ad8:	db 86       	std	Y+11, r13	; 0x0b
    2ada:	ec 86       	std	Y+12, r14	; 0x0c
    2adc:	fd 86       	std	Y+13, r15	; 0x0d
}
    2ade:	df 91       	pop	r29
    2ae0:	cf 91       	pop	r28
    2ae2:	1f 91       	pop	r17
    2ae4:	0f 91       	pop	r16
    2ae6:	ff 90       	pop	r15
    2ae8:	ef 90       	pop	r14
    2aea:	df 90       	pop	r13
    2aec:	cf 90       	pop	r12
    2aee:	bf 90       	pop	r11
    2af0:	9f 90       	pop	r9
    2af2:	8f 90       	pop	r8
    2af4:	08 95       	ret

00002af6 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2af6:	cf 92       	push	r12
    2af8:	df 92       	push	r13
    2afa:	ef 92       	push	r14
    2afc:	ff 92       	push	r15
    2afe:	cf 93       	push	r28
    2b00:	df 93       	push	r29
    2b02:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2b04:	68 81       	ld	r22, Y
    2b06:	79 81       	ldd	r23, Y+1	; 0x01
    2b08:	8a 81       	ldd	r24, Y+2	; 0x02
    2b0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2b0c:	0f 2e       	mov	r0, r31
    2b0e:	f8 ee       	ldi	r31, 0xE8	; 232
    2b10:	cf 2e       	mov	r12, r31
    2b12:	f3 e0       	ldi	r31, 0x03	; 3
    2b14:	df 2e       	mov	r13, r31
    2b16:	e1 2c       	mov	r14, r1
    2b18:	f1 2c       	mov	r15, r1
    2b1a:	f0 2d       	mov	r31, r0
    2b1c:	a7 01       	movw	r20, r14
    2b1e:	96 01       	movw	r18, r12
    2b20:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
    2b24:	9b 01       	movw	r18, r22
    2b26:	ac 01       	movw	r20, r24
    2b28:	60 e4       	ldi	r22, 0x40	; 64
    2b2a:	72 e4       	ldi	r23, 0x42	; 66
    2b2c:	8f e0       	ldi	r24, 0x0F	; 15
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <__mulsi3>
    2b34:	a7 01       	movw	r20, r14
    2b36:	96 01       	movw	r18, r12
    2b38:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
    2b3c:	69 01       	movw	r12, r18
    2b3e:	7a 01       	movw	r14, r20
    2b40:	ac 81       	ldd	r26, Y+4	; 0x04
    2b42:	bd 81       	ldd	r27, Y+5	; 0x05
    2b44:	20 e4       	ldi	r18, 0x40	; 64
    2b46:	32 e4       	ldi	r19, 0x42	; 66
    2b48:	4f e0       	ldi	r20, 0x0F	; 15
    2b4a:	50 e0       	ldi	r21, 0x00	; 0
    2b4c:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__muluhisi3>
    2b50:	20 e0       	ldi	r18, 0x00	; 0
    2b52:	38 e4       	ldi	r19, 0x48	; 72
    2b54:	48 ee       	ldi	r20, 0xE8	; 232
    2b56:	51 e0       	ldi	r21, 0x01	; 1
    2b58:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
    2b5c:	c7 01       	movw	r24, r14
    2b5e:	b6 01       	movw	r22, r12
    2b60:	62 0f       	add	r22, r18
    2b62:	73 1f       	adc	r23, r19
    2b64:	84 1f       	adc	r24, r20
    2b66:	95 1f       	adc	r25, r21
}
    2b68:	df 91       	pop	r29
    2b6a:	cf 91       	pop	r28
    2b6c:	ff 90       	pop	r15
    2b6e:	ef 90       	pop	r14
    2b70:	df 90       	pop	r13
    2b72:	cf 90       	pop	r12
    2b74:	08 95       	ret

00002b76 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2b76:	cf 92       	push	r12
    2b78:	df 92       	push	r13
    2b7a:	ef 92       	push	r14
    2b7c:	ff 92       	push	r15
    2b7e:	0f 93       	push	r16
    2b80:	1f 93       	push	r17
    2b82:	cf 93       	push	r28
    2b84:	df 93       	push	r29
    2b86:	cd b7       	in	r28, 0x3d	; 61
    2b88:	de b7       	in	r29, 0x3e	; 62
    2b8a:	2f 97       	sbiw	r28, 0x0f	; 15
    2b8c:	cd bf       	out	0x3d, r28	; 61
    2b8e:	de bf       	out	0x3e, r29	; 62
    2b90:	6c 01       	movw	r12, r24
    2b92:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2b94:	db 01       	movw	r26, r22
    2b96:	6d 91       	ld	r22, X+
    2b98:	7d 91       	ld	r23, X+
    2b9a:	8d 91       	ld	r24, X+
    2b9c:	9c 91       	ld	r25, X
    2b9e:	28 ee       	ldi	r18, 0xE8	; 232
    2ba0:	33 e0       	ldi	r19, 0x03	; 3
    2ba2:	40 e0       	ldi	r20, 0x00	; 0
    2ba4:	50 e0       	ldi	r21, 0x00	; 0
    2ba6:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
    2baa:	ba 01       	movw	r22, r20
    2bac:	a9 01       	movw	r20, r18
    2bae:	c6 01       	movw	r24, r12
    2bb0:	0e 94 46 18 	call	0x308c	; 0x308c <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2bb4:	d6 01       	movw	r26, r12
    2bb6:	ed 91       	ld	r30, X+
    2bb8:	fc 91       	ld	r31, X
    2bba:	02 80       	ldd	r0, Z+2	; 0x02
    2bbc:	f3 81       	ldd	r31, Z+3	; 0x03
    2bbe:	e0 2d       	mov	r30, r0
    2bc0:	6e e2       	ldi	r22, 0x2E	; 46
    2bc2:	c6 01       	movw	r24, r12
    2bc4:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2bc6:	c8 01       	movw	r24, r16
    2bc8:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <_ZN10time_stamp12get_microsecEv>
    2bcc:	8e 01       	movw	r16, r28
    2bce:	09 5f       	subi	r16, 0xF9	; 249
    2bd0:	1f 4f       	sbci	r17, 0xFF	; 255
    2bd2:	fe 01       	movw	r30, r28
    2bd4:	31 96       	adiw	r30, 0x01	; 1
    2bd6:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2bd8:	2a e0       	ldi	r18, 0x0A	; 10
    2bda:	30 e0       	ldi	r19, 0x00	; 0
    2bdc:	40 e0       	ldi	r20, 0x00	; 0
    2bde:	50 e0       	ldi	r21, 0x00	; 0
    2be0:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <__divmodsi4>
    2be4:	e6 2f       	mov	r30, r22
    2be6:	28 87       	std	Y+8, r18	; 0x08
    2be8:	39 87       	std	Y+9, r19	; 0x09
    2bea:	4a 87       	std	Y+10, r20	; 0x0a
    2bec:	5b 87       	std	Y+11, r21	; 0x0b
    2bee:	68 85       	ldd	r22, Y+8	; 0x08
    2bf0:	79 85       	ldd	r23, Y+9	; 0x09
    2bf2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bf4:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2bf6:	20 e3       	ldi	r18, 0x30	; 48
    2bf8:	2e 0f       	add	r18, r30
    2bfa:	d8 01       	movw	r26, r16
    2bfc:	2e 93       	st	-X, r18
    2bfe:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2c00:	ae 15       	cp	r26, r14
    2c02:	bf 05       	cpc	r27, r15
    2c04:	49 f7       	brne	.-46     	; 0x2bd8 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2c06:	1f 82       	std	Y+7, r1	; 0x07
    2c08:	be 01       	movw	r22, r28
    2c0a:	6f 5f       	subi	r22, 0xFF	; 255
    2c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c0e:	c6 01       	movw	r24, r12
    2c10:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2c14:	c6 01       	movw	r24, r12
    2c16:	2f 96       	adiw	r28, 0x0f	; 15
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	de bf       	out	0x3e, r29	; 62
    2c1c:	df 91       	pop	r29
    2c1e:	cf 91       	pop	r28
    2c20:	1f 91       	pop	r17
    2c22:	0f 91       	pop	r16
    2c24:	ff 90       	pop	r15
    2c26:	ef 90       	pop	r14
    2c28:	df 90       	pop	r13
    2c2a:	cf 90       	pop	r12
    2c2c:	08 95       	ret

00002c2e <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2c2e:	cf 93       	push	r28
    2c30:	df 93       	push	r29
    2c32:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	f8 94       	cli
    2c38:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2c3a:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c3e:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c42:	8c 83       	std	Y+4, r24	; 0x04
    2c44:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2c46:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <xTaskGetTickCount>
    2c4a:	68 83       	st	Y, r22
    2c4c:	79 83       	std	Y+1, r23	; 0x01
    2c4e:	8a 83       	std	Y+2, r24	; 0x02
    2c50:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2c52:	0f 90       	pop	r0
    2c54:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2c56:	ce 01       	movw	r24, r28
    2c58:	df 91       	pop	r29
    2c5a:	cf 91       	pop	r28
    2c5c:	08 95       	ret

00002c5e <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2c5e:	5f 92       	push	r5
    2c60:	6f 92       	push	r6
    2c62:	7f 92       	push	r7
    2c64:	8f 92       	push	r8
    2c66:	9f 92       	push	r9
    2c68:	af 92       	push	r10
    2c6a:	bf 92       	push	r11
    2c6c:	cf 92       	push	r12
    2c6e:	df 92       	push	r13
    2c70:	ef 92       	push	r14
    2c72:	ff 92       	push	r15
    2c74:	0f 93       	push	r16
    2c76:	1f 93       	push	r17
    2c78:	cf 93       	push	r28
    2c7a:	df 93       	push	r29
    2c7c:	5c 01       	movw	r10, r24
    2c7e:	4b 01       	movw	r8, r22
    2c80:	7a 01       	movw	r14, r20
    2c82:	12 2f       	mov	r17, r18
    2c84:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2c86:	63 e0       	ldi	r22, 0x03	; 3
    2c88:	ca 01       	movw	r24, r20
    2c8a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2c8e:	a8 14       	cp	r10, r8
    2c90:	b9 04       	cpc	r11, r9
    2c92:	08 f0       	brcs	.+2      	; 0x2c96 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2c94:	7d c0       	rjmp	.+250    	; 0x2d90 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2c96:	65 01       	movw	r12, r10
    2c98:	84 e1       	ldi	r24, 0x14	; 20
    2c9a:	c8 0e       	add	r12, r24
    2c9c:	d1 1c       	adc	r13, r1
    2c9e:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2ca0:	6a 2c       	mov	r6, r10
    2ca2:	5b 2c       	mov	r5, r11
    2ca4:	b5 01       	movw	r22, r10
    2ca6:	c7 01       	movw	r24, r14
    2ca8:	0e 94 12 18 	call	0x3024	; 0x3024 <_ZN8emstreamlsEj>
    2cac:	6a e0       	ldi	r22, 0x0A	; 10
    2cae:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2cb2:	6d ec       	ldi	r22, 0xCD	; 205
    2cb4:	75 e0       	ldi	r23, 0x05	; 5
    2cb6:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2cba:	11 23       	and	r17, r17
    2cbc:	09 f4       	brne	.+2      	; 0x2cc0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2cbe:	6d c0       	rjmp	.+218    	; 0x2d9a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2cc0:	00 23       	and	r16, r16
    2cc2:	09 f4       	brne	.+2      	; 0x2cc6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2cc4:	6a c0       	rjmp	.+212    	; 0x2d9a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2cc6:	6a e0       	ldi	r22, 0x0A	; 10
    2cc8:	c7 01       	movw	r24, r14
    2cca:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2cce:	68 ec       	ldi	r22, 0xC8	; 200
    2cd0:	75 e0       	ldi	r23, 0x05	; 5
    2cd2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    2cd6:	61 c0       	rjmp	.+194    	; 0x2d9a <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2cd8:	11 23       	and	r17, r17
    2cda:	71 f0       	breq	.+28     	; 0x2cf8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2cdc:	01 11       	cpse	r16, r1
    2cde:	0c c0       	rjmp	.+24     	; 0x2cf8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2ce0:	88 81       	ld	r24, Y
    2ce2:	87 15       	cp	r24, r7
    2ce4:	49 f0       	breq	.+18     	; 0x2cf8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2ce6:	6a e0       	ldi	r22, 0x0A	; 10
    2ce8:	c7 01       	movw	r24, r14
    2cea:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2cee:	63 ec       	ldi	r22, 0xC3	; 195
    2cf0:	75 e0       	ldi	r23, 0x05	; 5
    2cf2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2cf6:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2cf8:	69 91       	ld	r22, Y+
    2cfa:	c7 01       	movw	r24, r14
    2cfc:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d00:	dc 01       	movw	r26, r24
    2d02:	ed 91       	ld	r30, X+
    2d04:	fc 91       	ld	r31, X
    2d06:	02 80       	ldd	r0, Z+2	; 0x02
    2d08:	f3 81       	ldd	r31, Z+3	; 0x03
    2d0a:	e0 2d       	mov	r30, r0
    2d0c:	60 e2       	ldi	r22, 0x20	; 32
    2d0e:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2d10:	cc 16       	cp	r12, r28
    2d12:	dd 06       	cpc	r13, r29
    2d14:	09 f7       	brne	.-62     	; 0x2cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2d16:	11 23       	and	r17, r17
    2d18:	89 f0       	breq	.+34     	; 0x2d3c <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2d1a:	6a e0       	ldi	r22, 0x0A	; 10
    2d1c:	c7 01       	movw	r24, r14
    2d1e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2d22:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2d24:	6d eb       	ldi	r22, 0xBD	; 189
    2d26:	75 e0       	ldi	r23, 0x05	; 5
    2d28:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d2c:	e8 81       	ld	r30, Y
    2d2e:	f9 81       	ldd	r31, Y+1	; 0x01
    2d30:	02 80       	ldd	r0, Z+2	; 0x02
    2d32:	f3 81       	ldd	r31, Z+3	; 0x03
    2d34:	e0 2d       	mov	r30, r0
    2d36:	60 e2       	ldi	r22, 0x20	; 32
    2d38:	ce 01       	movw	r24, r28
    2d3a:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d3c:	c6 2d       	mov	r28, r6
    2d3e:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2d40:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2d42:	80 ee       	ldi	r24, 0xE0	; 224
    2d44:	86 0f       	add	r24, r22
    2d46:	8f 35       	cpi	r24, 0x5F	; 95
    2d48:	48 f4       	brcc	.+18     	; 0x2d5c <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2d4a:	d7 01       	movw	r26, r14
    2d4c:	ed 91       	ld	r30, X+
    2d4e:	fc 91       	ld	r31, X
    2d50:	02 80       	ldd	r0, Z+2	; 0x02
    2d52:	f3 81       	ldd	r31, Z+3	; 0x03
    2d54:	e0 2d       	mov	r30, r0
    2d56:	c7 01       	movw	r24, r14
    2d58:	19 95       	eicall
    2d5a:	09 c0       	rjmp	.+18     	; 0x2d6e <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2d5c:	d7 01       	movw	r26, r14
    2d5e:	ed 91       	ld	r30, X+
    2d60:	fc 91       	ld	r31, X
    2d62:	02 80       	ldd	r0, Z+2	; 0x02
    2d64:	f3 81       	ldd	r31, Z+3	; 0x03
    2d66:	e0 2d       	mov	r30, r0
    2d68:	6e e2       	ldi	r22, 0x2E	; 46
    2d6a:	c7 01       	movw	r24, r14
    2d6c:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2d6e:	cc 16       	cp	r12, r28
    2d70:	dd 06       	cpc	r13, r29
    2d72:	31 f7       	brne	.-52     	; 0x2d40 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2d74:	b4 e1       	ldi	r27, 0x14	; 20
    2d76:	ab 0e       	add	r10, r27
    2d78:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2d7a:	66 e0       	ldi	r22, 0x06	; 6
    2d7c:	c7 01       	movw	r24, r14
    2d7e:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    2d82:	84 e1       	ldi	r24, 0x14	; 20
    2d84:	c8 0e       	add	r12, r24
    2d86:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d88:	a8 14       	cp	r10, r8
    2d8a:	b9 04       	cpc	r11, r9
    2d8c:	08 f4       	brcc	.+2      	; 0x2d90 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2d8e:	88 cf       	rjmp	.-240    	; 0x2ca0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2d90:	62 e0       	ldi	r22, 0x02	; 2
    2d92:	c7 01       	movw	r24, r14
    2d94:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
}
    2d98:	03 c0       	rjmp	.+6      	; 0x2da0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d9a:	c6 2d       	mov	r28, r6
    2d9c:	d5 2d       	mov	r29, r5
    2d9e:	9c cf       	rjmp	.-200    	; 0x2cd8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2da0:	df 91       	pop	r29
    2da2:	cf 91       	pop	r28
    2da4:	1f 91       	pop	r17
    2da6:	0f 91       	pop	r16
    2da8:	ff 90       	pop	r15
    2daa:	ef 90       	pop	r14
    2dac:	df 90       	pop	r13
    2dae:	cf 90       	pop	r12
    2db0:	bf 90       	pop	r11
    2db2:	af 90       	pop	r10
    2db4:	9f 90       	pop	r9
    2db6:	8f 90       	pop	r8
    2db8:	7f 90       	pop	r7
    2dba:	6f 90       	pop	r6
    2dbc:	5f 90       	pop	r5
    2dbe:	08 95       	ret

00002dc0 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2dc0:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    2dc4:	08 95       	ret

00002dc6 <_Znaj>:
    2dc6:	0e 94 22 07 	call	0xe44	; 0xe44 <pvPortMalloc>
    2dca:	08 95       	ret

00002dcc <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2dcc:	08 95       	ret

00002dce <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2dce:	cf 93       	push	r28
    2dd0:	df 93       	push	r29
    2dd2:	fc 01       	movw	r30, r24
    2dd4:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2dd6:	40 3a       	cpi	r20, 0xA0	; 160
    2dd8:	68 e0       	ldi	r22, 0x08	; 8
    2dda:	56 07       	cpc	r21, r22
    2ddc:	49 f4       	brne	.+18     	; 0x2df0 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2dde:	80 e4       	ldi	r24, 0x40	; 64
    2de0:	96 e0       	ldi	r25, 0x06	; 6
    2de2:	82 83       	std	Z+2, r24	; 0x02
    2de4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2de6:	82 e0       	ldi	r24, 0x02	; 2
    2de8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2dea:	83 e0       	ldi	r24, 0x03	; 3
    2dec:	85 83       	std	Z+5, r24	; 0x05
    2dee:	32 c0       	rjmp	.+100    	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2df0:	40 3b       	cpi	r20, 0xB0	; 176
    2df2:	78 e0       	ldi	r23, 0x08	; 8
    2df4:	57 07       	cpc	r21, r23
    2df6:	49 f4       	brne	.+18     	; 0x2e0a <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2df8:	80 e4       	ldi	r24, 0x40	; 64
    2dfa:	96 e0       	ldi	r25, 0x06	; 6
    2dfc:	82 83       	std	Z+2, r24	; 0x02
    2dfe:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e00:	86 e0       	ldi	r24, 0x06	; 6
    2e02:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e04:	87 e0       	ldi	r24, 0x07	; 7
    2e06:	85 83       	std	Z+5, r24	; 0x05
    2e08:	25 c0       	rjmp	.+74     	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2e0a:	40 3a       	cpi	r20, 0xA0	; 160
    2e0c:	89 e0       	ldi	r24, 0x09	; 9
    2e0e:	58 07       	cpc	r21, r24
    2e10:	49 f4       	brne	.+18     	; 0x2e24 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2e12:	80 e6       	ldi	r24, 0x60	; 96
    2e14:	96 e0       	ldi	r25, 0x06	; 6
    2e16:	82 83       	std	Z+2, r24	; 0x02
    2e18:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e1a:	82 e0       	ldi	r24, 0x02	; 2
    2e1c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e1e:	83 e0       	ldi	r24, 0x03	; 3
    2e20:	85 83       	std	Z+5, r24	; 0x05
    2e22:	18 c0       	rjmp	.+48     	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2e24:	40 3b       	cpi	r20, 0xB0	; 176
    2e26:	69 e0       	ldi	r22, 0x09	; 9
    2e28:	56 07       	cpc	r21, r22
    2e2a:	49 f4       	brne	.+18     	; 0x2e3e <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2e2c:	80 e6       	ldi	r24, 0x60	; 96
    2e2e:	96 e0       	ldi	r25, 0x06	; 6
    2e30:	82 83       	std	Z+2, r24	; 0x02
    2e32:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e34:	86 e0       	ldi	r24, 0x06	; 6
    2e36:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e38:	87 e0       	ldi	r24, 0x07	; 7
    2e3a:	85 83       	std	Z+5, r24	; 0x05
    2e3c:	0b c0       	rjmp	.+22     	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2e3e:	40 3a       	cpi	r20, 0xA0	; 160
    2e40:	5a 40       	sbci	r21, 0x0A	; 10
    2e42:	41 f4       	brne	.+16     	; 0x2e54 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    2e44:	80 e8       	ldi	r24, 0x80	; 128
    2e46:	96 e0       	ldi	r25, 0x06	; 6
    2e48:	82 83       	std	Z+2, r24	; 0x02
    2e4a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e4c:	82 e0       	ldi	r24, 0x02	; 2
    2e4e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e50:	83 e0       	ldi	r24, 0x03	; 3
    2e52:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2e54:	a6 83       	std	Z+6, r26	; 0x06
    2e56:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2e58:	cd 01       	movw	r24, r26
    2e5a:	01 96       	adiw	r24, 0x01	; 1
    2e5c:	80 87       	std	Z+8, r24	; 0x08
    2e5e:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2e60:	03 96       	adiw	r24, 0x03	; 3
    2e62:	82 87       	std	Z+10, r24	; 0x0a
    2e64:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2e66:	25 81       	ldd	r18, Z+5	; 0x05
    2e68:	c2 81       	ldd	r28, Z+2	; 0x02
    2e6a:	d3 81       	ldd	r29, Z+3	; 0x03
    2e6c:	4c 81       	ldd	r20, Y+4	; 0x04
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	bc 01       	movw	r22, r24
    2e74:	02 c0       	rjmp	.+4      	; 0x2e7a <_ZN7base232C1EjP12USART_struct+0xac>
    2e76:	66 0f       	add	r22, r22
    2e78:	77 1f       	adc	r23, r23
    2e7a:	2a 95       	dec	r18
    2e7c:	e2 f7       	brpl	.-8      	; 0x2e76 <_ZN7base232C1EjP12USART_struct+0xa8>
    2e7e:	9b 01       	movw	r18, r22
    2e80:	24 2b       	or	r18, r20
    2e82:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2e84:	25 81       	ldd	r18, Z+5	; 0x05
    2e86:	c2 81       	ldd	r28, Z+2	; 0x02
    2e88:	d3 81       	ldd	r29, Z+3	; 0x03
    2e8a:	48 81       	ld	r20, Y
    2e8c:	bc 01       	movw	r22, r24
    2e8e:	02 c0       	rjmp	.+4      	; 0x2e94 <_ZN7base232C1EjP12USART_struct+0xc6>
    2e90:	66 0f       	add	r22, r22
    2e92:	77 1f       	adc	r23, r23
    2e94:	2a 95       	dec	r18
    2e96:	e2 f7       	brpl	.-8      	; 0x2e90 <_ZN7base232C1EjP12USART_struct+0xc2>
    2e98:	9b 01       	movw	r18, r22
    2e9a:	24 2b       	or	r18, r20
    2e9c:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2e9e:	34 81       	ldd	r19, Z+4	; 0x04
    2ea0:	c2 81       	ldd	r28, Z+2	; 0x02
    2ea2:	d3 81       	ldd	r29, Z+3	; 0x03
    2ea4:	28 81       	ld	r18, Y
    2ea6:	02 c0       	rjmp	.+4      	; 0x2eac <_ZN7base232C1EjP12USART_struct+0xde>
    2ea8:	88 0f       	add	r24, r24
    2eaa:	99 1f       	adc	r25, r25
    2eac:	3a 95       	dec	r19
    2eae:	e2 f7       	brpl	.-8      	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0xda>
    2eb0:	80 95       	com	r24
    2eb2:	90 95       	com	r25
    2eb4:	82 23       	and	r24, r18
    2eb6:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2eb8:	80 e1       	ldi	r24, 0x10	; 16
    2eba:	13 96       	adiw	r26, 0x03	; 3
    2ebc:	8c 93       	st	X, r24
    2ebe:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2ec0:	83 e0       	ldi	r24, 0x03	; 3
    2ec2:	15 96       	adiw	r26, 0x05	; 5
    2ec4:	8c 93       	st	X, r24
    2ec6:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2ec8:	80 ef       	ldi	r24, 0xF0	; 240
    2eca:	17 96       	adiw	r26, 0x07	; 7
    2ecc:	8c 93       	st	X, r24
    2ece:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2ed0:	81 e2       	ldi	r24, 0x21	; 33
    2ed2:	16 96       	adiw	r26, 0x06	; 6
    2ed4:	8c 93       	st	X, r24
    2ed6:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2ed8:	88 e1       	ldi	r24, 0x18	; 24
    2eda:	14 96       	adiw	r26, 0x04	; 4
    2edc:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2ede:	80 e8       	ldi	r24, 0x80	; 128
    2ee0:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2ee2:	80 e4       	ldi	r24, 0x40	; 64
    2ee4:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2ee6:	80 e2       	ldi	r24, 0x20	; 32
    2ee8:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2eea:	06 80       	ldd	r0, Z+6	; 0x06
    2eec:	f7 81       	ldd	r31, Z+7	; 0x07
    2eee:	e0 2d       	mov	r30, r0
    2ef0:	80 81       	ld	r24, Z
    2ef2:	80 81       	ld	r24, Z
}
    2ef4:	df 91       	pop	r29
    2ef6:	cf 91       	pop	r28
    2ef8:	08 95       	ret

00002efa <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	08 95       	ret

00002efe <_ZN8emstream7getcharEv>:
    2efe:	80 e0       	ldi	r24, 0x00	; 0
    2f00:	90 e0       	ldi	r25, 0x00	; 0
    2f02:	08 95       	ret

00002f04 <_ZN8emstream14check_for_charEv>:
    2f04:	80 e0       	ldi	r24, 0x00	; 0
    2f06:	08 95       	ret

00002f08 <_ZN8emstream12transmit_nowEv>:
    2f08:	08 95       	ret

00002f0a <_ZN8emstream12clear_screenEv>:
    2f0a:	08 95       	ret

00002f0c <_ZN8emstreamC1Ev>:
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	83 e5       	ldi	r24, 0x53	; 83
    2f10:	90 e2       	ldi	r25, 0x20	; 32
    2f12:	80 83       	st	Z, r24
    2f14:	91 83       	std	Z+1, r25	; 0x01
    2f16:	8a e0       	ldi	r24, 0x0A	; 10
    2f18:	82 83       	std	Z+2, r24	; 0x02
    2f1a:	13 82       	std	Z+3, r1	; 0x03
    2f1c:	83 e0       	ldi	r24, 0x03	; 3
    2f1e:	85 83       	std	Z+5, r24	; 0x05
    2f20:	14 82       	std	Z+4, r1	; 0x04
    2f22:	16 82       	std	Z+6, r1	; 0x06
    2f24:	17 82       	std	Z+7, r1	; 0x07
    2f26:	08 95       	ret

00002f28 <_ZN8emstream4putsEPKc>:
    2f28:	0f 93       	push	r16
    2f2a:	1f 93       	push	r17
    2f2c:	cf 93       	push	r28
    2f2e:	df 93       	push	r29
    2f30:	8c 01       	movw	r16, r24
    2f32:	fb 01       	movw	r30, r22
    2f34:	dc 01       	movw	r26, r24
    2f36:	14 96       	adiw	r26, 0x04	; 4
    2f38:	8c 91       	ld	r24, X
    2f3a:	81 11       	cpse	r24, r1
    2f3c:	04 c0       	rjmp	.+8      	; 0x2f46 <_ZN8emstream4putsEPKc+0x1e>
    2f3e:	60 81       	ld	r22, Z
    2f40:	61 11       	cpse	r22, r1
    2f42:	17 c0       	rjmp	.+46     	; 0x2f72 <_ZN8emstream4putsEPKc+0x4a>
    2f44:	23 c0       	rjmp	.+70     	; 0x2f8c <_ZN8emstream4putsEPKc+0x64>
    2f46:	d8 01       	movw	r26, r16
    2f48:	14 96       	adiw	r26, 0x04	; 4
    2f4a:	1c 92       	st	X, r1
    2f4c:	eb 01       	movw	r28, r22
    2f4e:	21 96       	adiw	r28, 0x01	; 1
    2f50:	64 91       	lpm	r22, Z
    2f52:	66 23       	and	r22, r22
    2f54:	d9 f0       	breq	.+54     	; 0x2f8c <_ZN8emstream4putsEPKc+0x64>
    2f56:	d8 01       	movw	r26, r16
    2f58:	ed 91       	ld	r30, X+
    2f5a:	fc 91       	ld	r31, X
    2f5c:	02 80       	ldd	r0, Z+2	; 0x02
    2f5e:	f3 81       	ldd	r31, Z+3	; 0x03
    2f60:	e0 2d       	mov	r30, r0
    2f62:	c8 01       	movw	r24, r16
    2f64:	19 95       	eicall
    2f66:	fe 01       	movw	r30, r28
    2f68:	64 91       	lpm	r22, Z
    2f6a:	21 96       	adiw	r28, 0x01	; 1
    2f6c:	61 11       	cpse	r22, r1
    2f6e:	f3 cf       	rjmp	.-26     	; 0x2f56 <_ZN8emstream4putsEPKc+0x2e>
    2f70:	0d c0       	rjmp	.+26     	; 0x2f8c <_ZN8emstream4putsEPKc+0x64>
    2f72:	ef 01       	movw	r28, r30
    2f74:	21 96       	adiw	r28, 0x01	; 1
    2f76:	d8 01       	movw	r26, r16
    2f78:	ed 91       	ld	r30, X+
    2f7a:	fc 91       	ld	r31, X
    2f7c:	02 80       	ldd	r0, Z+2	; 0x02
    2f7e:	f3 81       	ldd	r31, Z+3	; 0x03
    2f80:	e0 2d       	mov	r30, r0
    2f82:	c8 01       	movw	r24, r16
    2f84:	19 95       	eicall
    2f86:	69 91       	ld	r22, Y+
    2f88:	61 11       	cpse	r22, r1
    2f8a:	f5 cf       	rjmp	.-22     	; 0x2f76 <_ZN8emstream4putsEPKc+0x4e>
    2f8c:	df 91       	pop	r29
    2f8e:	cf 91       	pop	r28
    2f90:	1f 91       	pop	r17
    2f92:	0f 91       	pop	r16
    2f94:	08 95       	ret

00002f96 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2f96:	cf 93       	push	r28
    2f98:	df 93       	push	r29
    2f9a:	ec 01       	movw	r28, r24
	switch (new_manip)
    2f9c:	86 2f       	mov	r24, r22
    2f9e:	90 e0       	ldi	r25, 0x00	; 0
    2fa0:	8b 30       	cpi	r24, 0x0B	; 11
    2fa2:	91 05       	cpc	r25, r1
    2fa4:	d8 f5       	brcc	.+118    	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
    2fa6:	fc 01       	movw	r30, r24
    2fa8:	88 27       	eor	r24, r24
    2faa:	e2 50       	subi	r30, 0x02	; 2
    2fac:	ff 4f       	sbci	r31, 0xFF	; 255
    2fae:	8f 4f       	sbci	r24, 0xFF	; 255
    2fb0:	0c 94 15 1f 	jmp	0x3e2a	; 0x3e2a <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2fb4:	82 e0       	ldi	r24, 0x02	; 2
    2fb6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fb8:	31 c0       	rjmp	.+98     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2fba:	88 e0       	ldi	r24, 0x08	; 8
    2fbc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fbe:	2e c0       	rjmp	.+92     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2fc0:	8a e0       	ldi	r24, 0x0A	; 10
    2fc2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fc4:	2b c0       	rjmp	.+86     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2fc6:	80 e1       	ldi	r24, 0x10	; 16
    2fc8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fca:	28 c0       	rjmp	.+80     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2fd0:	25 c0       	rjmp	.+74     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2fd2:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2fd4:	23 c0       	rjmp	.+70     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2fd6:	e8 81       	ld	r30, Y
    2fd8:	f9 81       	ldd	r31, Y+1	; 0x01
    2fda:	02 80       	ldd	r0, Z+2	; 0x02
    2fdc:	f3 81       	ldd	r31, Z+3	; 0x03
    2fde:	e0 2d       	mov	r30, r0
    2fe0:	6d e0       	ldi	r22, 0x0D	; 13
    2fe2:	ce 01       	movw	r24, r28
    2fe4:	19 95       	eicall
    2fe6:	e8 81       	ld	r30, Y
    2fe8:	f9 81       	ldd	r31, Y+1	; 0x01
    2fea:	02 80       	ldd	r0, Z+2	; 0x02
    2fec:	f3 81       	ldd	r31, Z+3	; 0x03
    2fee:	e0 2d       	mov	r30, r0
    2ff0:	6a e0       	ldi	r22, 0x0A	; 10
    2ff2:	ce 01       	movw	r24, r28
    2ff4:	19 95       	eicall
			break;
    2ff6:	12 c0       	rjmp	.+36     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2ff8:	e8 81       	ld	r30, Y
    2ffa:	f9 81       	ldd	r31, Y+1	; 0x01
    2ffc:	02 84       	ldd	r0, Z+10	; 0x0a
    2ffe:	f3 85       	ldd	r31, Z+11	; 0x0b
    3000:	e0 2d       	mov	r30, r0
    3002:	ce 01       	movw	r24, r28
    3004:	19 95       	eicall
			break;
    3006:	0a c0       	rjmp	.+20     	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3008:	e8 81       	ld	r30, Y
    300a:	f9 81       	ldd	r31, Y+1	; 0x01
    300c:	00 84       	ldd	r0, Z+8	; 0x08
    300e:	f1 85       	ldd	r31, Z+9	; 0x09
    3010:	e0 2d       	mov	r30, r0
    3012:	ce 01       	movw	r24, r28
    3014:	19 95       	eicall
			break;
    3016:	02 c0       	rjmp	.+4      	; 0x301c <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3018:	81 e0       	ldi	r24, 0x01	; 1
    301a:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    301c:	ce 01       	movw	r24, r28
    301e:	df 91       	pop	r29
    3020:	cf 91       	pop	r28
    3022:	08 95       	ret

00003024 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3024:	ff 92       	push	r15
    3026:	0f 93       	push	r16
    3028:	1f 93       	push	r17
    302a:	cf 93       	push	r28
    302c:	df 93       	push	r29
    302e:	cd b7       	in	r28, 0x3d	; 61
    3030:	de b7       	in	r29, 0x3e	; 62
    3032:	61 97       	sbiw	r28, 0x11	; 17
    3034:	cd bf       	out	0x3d, r28	; 61
    3036:	de bf       	out	0x3e, r29	; 62
    3038:	8c 01       	movw	r16, r24
    303a:	f6 2e       	mov	r15, r22
    303c:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    303e:	f8 01       	movw	r30, r16
    3040:	42 81       	ldd	r20, Z+2	; 0x02
    3042:	40 31       	cpi	r20, 0x10	; 16
    3044:	21 f0       	breq	.+8      	; 0x304e <_ZN8emstreamlsEj+0x2a>
    3046:	48 30       	cpi	r20, 0x08	; 8
    3048:	11 f0       	breq	.+4      	; 0x304e <_ZN8emstreamlsEj+0x2a>
    304a:	42 30       	cpi	r20, 0x02	; 2
    304c:	41 f4       	brne	.+16     	; 0x305e <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    304e:	69 2f       	mov	r22, r25
    3050:	c8 01       	movw	r24, r16
    3052:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    3056:	6f 2d       	mov	r22, r15
    3058:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    305c:	0d c0       	rjmp	.+26     	; 0x3078 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	be 01       	movw	r22, r28
    3062:	6f 5f       	subi	r22, 0xFF	; 255
    3064:	7f 4f       	sbci	r23, 0xFF	; 255
    3066:	8f 2d       	mov	r24, r15
    3068:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    306c:	be 01       	movw	r22, r28
    306e:	6f 5f       	subi	r22, 0xFF	; 255
    3070:	7f 4f       	sbci	r23, 0xFF	; 255
    3072:	c8 01       	movw	r24, r16
    3074:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3078:	c8 01       	movw	r24, r16
    307a:	61 96       	adiw	r28, 0x11	; 17
    307c:	cd bf       	out	0x3d, r28	; 61
    307e:	de bf       	out	0x3e, r29	; 62
    3080:	df 91       	pop	r29
    3082:	cf 91       	pop	r28
    3084:	1f 91       	pop	r17
    3086:	0f 91       	pop	r16
    3088:	ff 90       	pop	r15
    308a:	08 95       	ret

0000308c <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    308c:	df 92       	push	r13
    308e:	ef 92       	push	r14
    3090:	ff 92       	push	r15
    3092:	0f 93       	push	r16
    3094:	1f 93       	push	r17
    3096:	cf 93       	push	r28
    3098:	df 93       	push	r29
    309a:	cd b7       	in	r28, 0x3d	; 61
    309c:	de b7       	in	r29, 0x3e	; 62
    309e:	a1 97       	sbiw	r28, 0x21	; 33
    30a0:	cd bf       	out	0x3d, r28	; 61
    30a2:	de bf       	out	0x3e, r29	; 62
    30a4:	8c 01       	movw	r16, r24
    30a6:	d4 2e       	mov	r13, r20
    30a8:	e5 2e       	mov	r14, r21
    30aa:	f6 2e       	mov	r15, r22
    30ac:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    30ae:	f8 01       	movw	r30, r16
    30b0:	22 81       	ldd	r18, Z+2	; 0x02
    30b2:	20 31       	cpi	r18, 0x10	; 16
    30b4:	21 f0       	breq	.+8      	; 0x30be <_ZN8emstreamlsEm+0x32>
    30b6:	28 30       	cpi	r18, 0x08	; 8
    30b8:	11 f0       	breq	.+4      	; 0x30be <_ZN8emstreamlsEm+0x32>
    30ba:	22 30       	cpi	r18, 0x02	; 2
    30bc:	71 f4       	brne	.+28     	; 0x30da <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    30be:	69 2f       	mov	r22, r25
    30c0:	c8 01       	movw	r24, r16
    30c2:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    30c6:	6f 2d       	mov	r22, r15
    30c8:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    30cc:	6e 2d       	mov	r22, r14
    30ce:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    30d2:	6d 2d       	mov	r22, r13
    30d4:	0e 94 88 18 	call	0x3110	; 0x3110 <_ZN8emstreamlsEh>
    30d8:	0f c0       	rjmp	.+30     	; 0x30f8 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    30da:	30 e0       	ldi	r19, 0x00	; 0
    30dc:	ae 01       	movw	r20, r28
    30de:	4f 5f       	subi	r20, 0xFF	; 255
    30e0:	5f 4f       	sbci	r21, 0xFF	; 255
    30e2:	6d 2d       	mov	r22, r13
    30e4:	7e 2d       	mov	r23, r14
    30e6:	8f 2d       	mov	r24, r15
    30e8:	0e 94 57 1f 	call	0x3eae	; 0x3eae <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    30ec:	be 01       	movw	r22, r28
    30ee:	6f 5f       	subi	r22, 0xFF	; 255
    30f0:	7f 4f       	sbci	r23, 0xFF	; 255
    30f2:	c8 01       	movw	r24, r16
    30f4:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30f8:	c8 01       	movw	r24, r16
    30fa:	a1 96       	adiw	r28, 0x21	; 33
    30fc:	cd bf       	out	0x3d, r28	; 61
    30fe:	de bf       	out	0x3e, r29	; 62
    3100:	df 91       	pop	r29
    3102:	cf 91       	pop	r28
    3104:	1f 91       	pop	r17
    3106:	0f 91       	pop	r16
    3108:	ff 90       	pop	r15
    310a:	ef 90       	pop	r14
    310c:	df 90       	pop	r13
    310e:	08 95       	ret

00003110 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3110:	cf 92       	push	r12
    3112:	df 92       	push	r13
    3114:	ef 92       	push	r14
    3116:	ff 92       	push	r15
    3118:	0f 93       	push	r16
    311a:	1f 93       	push	r17
    311c:	cf 93       	push	r28
    311e:	df 93       	push	r29
    3120:	cd b7       	in	r28, 0x3d	; 61
    3122:	de b7       	in	r29, 0x3e	; 62
    3124:	29 97       	sbiw	r28, 0x09	; 9
    3126:	cd bf       	out	0x3d, r28	; 61
    3128:	de bf       	out	0x3e, r29	; 62
    312a:	8c 01       	movw	r16, r24
    312c:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    312e:	dc 01       	movw	r26, r24
    3130:	13 96       	adiw	r26, 0x03	; 3
    3132:	8c 91       	ld	r24, X
    3134:	13 97       	sbiw	r26, 0x03	; 3
    3136:	88 23       	and	r24, r24
    3138:	41 f0       	breq	.+16     	; 0x314a <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    313a:	ed 91       	ld	r30, X+
    313c:	fc 91       	ld	r31, X
    313e:	02 80       	ldd	r0, Z+2	; 0x02
    3140:	f3 81       	ldd	r31, Z+3	; 0x03
    3142:	e0 2d       	mov	r30, r0
    3144:	c8 01       	movw	r24, r16
    3146:	19 95       	eicall
    3148:	56 c0       	rjmp	.+172    	; 0x31f6 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    314a:	f8 01       	movw	r30, r16
    314c:	42 81       	ldd	r20, Z+2	; 0x02
    314e:	42 30       	cpi	r20, 0x02	; 2
    3150:	19 f5       	brne	.+70     	; 0x3198 <_ZN8emstreamlsEh+0x88>
    3152:	68 94       	set
    3154:	cc 24       	eor	r12, r12
    3156:	c3 f8       	bld	r12, 3
    3158:	d1 2c       	mov	r13, r1
    315a:	68 94       	set
    315c:	ff 24       	eor	r15, r15
    315e:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3160:	8e 2d       	mov	r24, r14
    3162:	8f 21       	and	r24, r15
    3164:	51 f0       	breq	.+20     	; 0x317a <_ZN8emstreamlsEh+0x6a>
    3166:	d8 01       	movw	r26, r16
    3168:	ed 91       	ld	r30, X+
    316a:	fc 91       	ld	r31, X
    316c:	02 80       	ldd	r0, Z+2	; 0x02
    316e:	f3 81       	ldd	r31, Z+3	; 0x03
    3170:	e0 2d       	mov	r30, r0
    3172:	61 e3       	ldi	r22, 0x31	; 49
    3174:	c8 01       	movw	r24, r16
    3176:	19 95       	eicall
    3178:	09 c0       	rjmp	.+18     	; 0x318c <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    317a:	d8 01       	movw	r26, r16
    317c:	ed 91       	ld	r30, X+
    317e:	fc 91       	ld	r31, X
    3180:	02 80       	ldd	r0, Z+2	; 0x02
    3182:	f3 81       	ldd	r31, Z+3	; 0x03
    3184:	e0 2d       	mov	r30, r0
    3186:	60 e3       	ldi	r22, 0x30	; 48
    3188:	c8 01       	movw	r24, r16
    318a:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    318c:	f6 94       	lsr	r15
    318e:	b1 e0       	ldi	r27, 0x01	; 1
    3190:	cb 1a       	sub	r12, r27
    3192:	d1 08       	sbc	r13, r1
    3194:	29 f7       	brne	.-54     	; 0x3160 <_ZN8emstreamlsEh+0x50>
    3196:	2f c0       	rjmp	.+94     	; 0x31f6 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3198:	40 31       	cpi	r20, 0x10	; 16
    319a:	f9 f4       	brne	.+62     	; 0x31da <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    319c:	62 95       	swap	r22
    319e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    31a0:	01 90       	ld	r0, Z+
    31a2:	f0 81       	ld	r31, Z
    31a4:	e0 2d       	mov	r30, r0
    31a6:	02 80       	ldd	r0, Z+2	; 0x02
    31a8:	f3 81       	ldd	r31, Z+3	; 0x03
    31aa:	e0 2d       	mov	r30, r0
    31ac:	6a 30       	cpi	r22, 0x0A	; 10
    31ae:	10 f0       	brcs	.+4      	; 0x31b4 <_ZN8emstreamlsEh+0xa4>
    31b0:	69 5c       	subi	r22, 0xC9	; 201
    31b2:	01 c0       	rjmp	.+2      	; 0x31b6 <_ZN8emstreamlsEh+0xa6>
    31b4:	60 5d       	subi	r22, 0xD0	; 208
    31b6:	c8 01       	movw	r24, r16
    31b8:	19 95       	eicall
		temp_char = num & 0x0F;
    31ba:	6e 2d       	mov	r22, r14
    31bc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    31be:	d8 01       	movw	r26, r16
    31c0:	ed 91       	ld	r30, X+
    31c2:	fc 91       	ld	r31, X
    31c4:	02 80       	ldd	r0, Z+2	; 0x02
    31c6:	f3 81       	ldd	r31, Z+3	; 0x03
    31c8:	e0 2d       	mov	r30, r0
    31ca:	6a 30       	cpi	r22, 0x0A	; 10
    31cc:	10 f0       	brcs	.+4      	; 0x31d2 <_ZN8emstreamlsEh+0xc2>
    31ce:	69 5c       	subi	r22, 0xC9	; 201
    31d0:	01 c0       	rjmp	.+2      	; 0x31d4 <_ZN8emstreamlsEh+0xc4>
    31d2:	60 5d       	subi	r22, 0xD0	; 208
    31d4:	c8 01       	movw	r24, r16
    31d6:	19 95       	eicall
    31d8:	0e c0       	rjmp	.+28     	; 0x31f6 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    31da:	50 e0       	ldi	r21, 0x00	; 0
    31dc:	be 01       	movw	r22, r28
    31de:	6f 5f       	subi	r22, 0xFF	; 255
    31e0:	7f 4f       	sbci	r23, 0xFF	; 255
    31e2:	8e 2d       	mov	r24, r14
    31e4:	90 e0       	ldi	r25, 0x00	; 0
    31e6:	0e 94 84 1f 	call	0x3f08	; 0x3f08 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    31ea:	be 01       	movw	r22, r28
    31ec:	6f 5f       	subi	r22, 0xFF	; 255
    31ee:	7f 4f       	sbci	r23, 0xFF	; 255
    31f0:	c8 01       	movw	r24, r16
    31f2:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    31f6:	c8 01       	movw	r24, r16
    31f8:	29 96       	adiw	r28, 0x09	; 9
    31fa:	cd bf       	out	0x3d, r28	; 61
    31fc:	de bf       	out	0x3e, r29	; 62
    31fe:	df 91       	pop	r29
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
    3206:	ff 90       	pop	r15
    3208:	ef 90       	pop	r14
    320a:	df 90       	pop	r13
    320c:	cf 90       	pop	r12
    320e:	08 95       	ret

00003210 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3210:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3212:	50 96       	adiw	r26, 0x10	; 16
    3214:	ed 91       	ld	r30, X+
    3216:	fc 91       	ld	r31, X
    3218:	51 97       	sbiw	r26, 0x11	; 17
    321a:	80 81       	ld	r24, Z
    321c:	54 96       	adiw	r26, 0x14	; 20
    321e:	4c 91       	ld	r20, X
    3220:	54 97       	sbiw	r26, 0x14	; 20
    3222:	84 23       	and	r24, r20
    3224:	29 f0       	breq	.+10     	; 0x3230 <_ZN5rs2327putcharEc+0x20>
    3226:	09 c0       	rjmp	.+18     	; 0x323a <_ZN5rs2327putcharEc+0x2a>
    3228:	21 50       	subi	r18, 0x01	; 1
    322a:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    322c:	19 f4       	brne	.+6      	; 0x3234 <_ZN5rs2327putcharEc+0x24>
    322e:	12 c0       	rjmp	.+36     	; 0x3254 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3230:	21 e2       	ldi	r18, 0x21	; 33
    3232:	3e e4       	ldi	r19, 0x4E	; 78
    3234:	90 81       	ld	r25, Z
    3236:	94 23       	and	r25, r20
    3238:	b9 f3       	breq	.-18     	; 0x3228 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    323a:	90 81       	ld	r25, Z
    323c:	56 96       	adiw	r26, 0x16	; 22
    323e:	8c 91       	ld	r24, X
    3240:	56 97       	sbiw	r26, 0x16	; 22
    3242:	89 2b       	or	r24, r25
    3244:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3246:	1e 96       	adiw	r26, 0x0e	; 14
    3248:	ed 91       	ld	r30, X+
    324a:	fc 91       	ld	r31, X
    324c:	1f 97       	sbiw	r26, 0x0f	; 15
    324e:	60 83       	st	Z, r22
	return (true);
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3254:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3256:	08 95       	ret

00003258 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
    325c:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    325e:	c1 8d       	ldd	r28, Z+25	; 0x19
    3260:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3262:	28 81       	ld	r18, Y
    3264:	39 81       	ldd	r19, Y+1	; 0x01
    3266:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3268:	b4 8d       	ldd	r27, Z+28	; 0x1c
    326a:	4d 91       	ld	r20, X+
    326c:	5c 91       	ld	r21, X
    326e:	24 17       	cp	r18, r20
    3270:	35 07       	cpc	r19, r21
    3272:	e9 f3       	breq	.-6      	; 0x326e <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3274:	a7 89       	ldd	r26, Z+23	; 0x17
    3276:	b0 8d       	ldd	r27, Z+24	; 0x18
    3278:	0d 90       	ld	r0, X+
    327a:	bc 91       	ld	r27, X
    327c:	a0 2d       	mov	r26, r0
    327e:	a2 0f       	add	r26, r18
    3280:	b3 1f       	adc	r27, r19
    3282:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3284:	2f 5f       	subi	r18, 0xFF	; 255
    3286:	3f 4f       	sbci	r19, 0xFF	; 255
    3288:	28 83       	st	Y, r18
    328a:	39 83       	std	Y+1, r19	; 0x01
    328c:	24 36       	cpi	r18, 0x64	; 100
    328e:	31 05       	cpc	r19, r1
    3290:	28 f0       	brcs	.+10     	; 0x329c <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3292:	01 8c       	ldd	r0, Z+25	; 0x19
    3294:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3296:	e0 2d       	mov	r30, r0
    3298:	10 82       	st	Z, r1
    329a:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    329c:	90 e0       	ldi	r25, 0x00	; 0
    329e:	df 91       	pop	r29
    32a0:	cf 91       	pop	r28
    32a2:	08 95       	ret

000032a4 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    32a4:	cf 93       	push	r28
    32a6:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    32a8:	ec 01       	movw	r28, r24
    32aa:	a9 8d       	ldd	r26, Y+25	; 0x19
    32ac:	ba 8d       	ldd	r27, Y+26	; 0x1a
    32ae:	eb 8d       	ldd	r30, Y+27	; 0x1b
    32b0:	fc 8d       	ldd	r31, Y+28	; 0x1c
    32b2:	81 e0       	ldi	r24, 0x01	; 1
    32b4:	4d 91       	ld	r20, X+
    32b6:	5c 91       	ld	r21, X
    32b8:	20 81       	ld	r18, Z
    32ba:	31 81       	ldd	r19, Z+1	; 0x01
    32bc:	42 17       	cp	r20, r18
    32be:	53 07       	cpc	r21, r19
    32c0:	09 f4       	brne	.+2      	; 0x32c4 <_ZN5rs23214check_for_charEv+0x20>
    32c2:	80 e0       	ldi	r24, 0x00	; 0
}
    32c4:	df 91       	pop	r29
    32c6:	cf 91       	pop	r28
    32c8:	08 95       	ret

000032ca <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    32ca:	dc 01       	movw	r26, r24
    32cc:	ed 91       	ld	r30, X+
    32ce:	fc 91       	ld	r31, X
    32d0:	02 80       	ldd	r0, Z+2	; 0x02
    32d2:	f3 81       	ldd	r31, Z+3	; 0x03
    32d4:	e0 2d       	mov	r30, r0
    32d6:	6c e0       	ldi	r22, 0x0C	; 12
    32d8:	19 95       	eicall
    32da:	08 95       	ret

000032dc <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    32dc:	ef 92       	push	r14
    32de:	ff 92       	push	r15
    32e0:	0f 93       	push	r16
    32e2:	1f 93       	push	r17
    32e4:	cf 93       	push	r28
    32e6:	df 93       	push	r29
    32e8:	ec 01       	movw	r28, r24
    32ea:	7b 01       	movw	r14, r22
    32ec:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    32ee:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <_ZN8emstreamC1Ev>
    32f2:	a8 01       	movw	r20, r16
    32f4:	b7 01       	movw	r22, r14
    32f6:	ce 01       	movw	r24, r28
    32f8:	08 96       	adiw	r24, 0x08	; 8
    32fa:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_ZN7base232C1EjP12USART_struct>
    32fe:	83 e6       	ldi	r24, 0x63	; 99
    3300:	90 e2       	ldi	r25, 0x20	; 32
    3302:	88 83       	st	Y, r24
    3304:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3306:	00 3a       	cpi	r16, 0xA0	; 160
    3308:	88 e0       	ldi	r24, 0x08	; 8
    330a:	18 07       	cpc	r17, r24
    330c:	69 f4       	brne	.+26     	; 0x3328 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    330e:	86 e6       	ldi	r24, 0x66	; 102
    3310:	91 e3       	ldi	r25, 0x31	; 49
    3312:	8f 8b       	std	Y+23, r24	; 0x17
    3314:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3316:	8c e5       	ldi	r24, 0x5C	; 92
    3318:	91 e3       	ldi	r25, 0x31	; 49
    331a:	89 8f       	std	Y+25, r24	; 0x19
    331c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    331e:	82 e5       	ldi	r24, 0x52	; 82
    3320:	91 e3       	ldi	r25, 0x31	; 49
    3322:	8b 8f       	std	Y+27, r24	; 0x1b
    3324:	9c 8f       	std	Y+28, r25	; 0x1c
    3326:	42 c0       	rjmp	.+132    	; 0x33ac <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3328:	00 3b       	cpi	r16, 0xB0	; 176
    332a:	e8 e0       	ldi	r30, 0x08	; 8
    332c:	1e 07       	cpc	r17, r30
    332e:	69 f4       	brne	.+26     	; 0x334a <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3330:	84 e6       	ldi	r24, 0x64	; 100
    3332:	91 e3       	ldi	r25, 0x31	; 49
    3334:	8f 8b       	std	Y+23, r24	; 0x17
    3336:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3338:	8a e5       	ldi	r24, 0x5A	; 90
    333a:	91 e3       	ldi	r25, 0x31	; 49
    333c:	89 8f       	std	Y+25, r24	; 0x19
    333e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3340:	80 e5       	ldi	r24, 0x50	; 80
    3342:	91 e3       	ldi	r25, 0x31	; 49
    3344:	8b 8f       	std	Y+27, r24	; 0x1b
    3346:	9c 8f       	std	Y+28, r25	; 0x1c
    3348:	31 c0       	rjmp	.+98     	; 0x33ac <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    334a:	00 3a       	cpi	r16, 0xA0	; 160
    334c:	f9 e0       	ldi	r31, 0x09	; 9
    334e:	1f 07       	cpc	r17, r31
    3350:	69 f4       	brne	.+26     	; 0x336c <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3352:	82 e6       	ldi	r24, 0x62	; 98
    3354:	91 e3       	ldi	r25, 0x31	; 49
    3356:	8f 8b       	std	Y+23, r24	; 0x17
    3358:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    335a:	88 e5       	ldi	r24, 0x58	; 88
    335c:	91 e3       	ldi	r25, 0x31	; 49
    335e:	89 8f       	std	Y+25, r24	; 0x19
    3360:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3362:	8e e4       	ldi	r24, 0x4E	; 78
    3364:	91 e3       	ldi	r25, 0x31	; 49
    3366:	8b 8f       	std	Y+27, r24	; 0x1b
    3368:	9c 8f       	std	Y+28, r25	; 0x1c
    336a:	20 c0       	rjmp	.+64     	; 0x33ac <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    336c:	00 3b       	cpi	r16, 0xB0	; 176
    336e:	89 e0       	ldi	r24, 0x09	; 9
    3370:	18 07       	cpc	r17, r24
    3372:	69 f4       	brne	.+26     	; 0x338e <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3374:	80 e6       	ldi	r24, 0x60	; 96
    3376:	91 e3       	ldi	r25, 0x31	; 49
    3378:	8f 8b       	std	Y+23, r24	; 0x17
    337a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    337c:	86 e5       	ldi	r24, 0x56	; 86
    337e:	91 e3       	ldi	r25, 0x31	; 49
    3380:	89 8f       	std	Y+25, r24	; 0x19
    3382:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3384:	8c e4       	ldi	r24, 0x4C	; 76
    3386:	91 e3       	ldi	r25, 0x31	; 49
    3388:	8b 8f       	std	Y+27, r24	; 0x1b
    338a:	9c 8f       	std	Y+28, r25	; 0x1c
    338c:	0f c0       	rjmp	.+30     	; 0x33ac <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    338e:	00 3a       	cpi	r16, 0xA0	; 160
    3390:	1a 40       	sbci	r17, 0x0A	; 10
    3392:	61 f4       	brne	.+24     	; 0x33ac <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3394:	8e e5       	ldi	r24, 0x5E	; 94
    3396:	91 e3       	ldi	r25, 0x31	; 49
    3398:	8f 8b       	std	Y+23, r24	; 0x17
    339a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    339c:	84 e5       	ldi	r24, 0x54	; 84
    339e:	91 e3       	ldi	r25, 0x31	; 49
    33a0:	89 8f       	std	Y+25, r24	; 0x19
    33a2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    33a4:	8a e4       	ldi	r24, 0x4A	; 74
    33a6:	91 e3       	ldi	r25, 0x31	; 49
    33a8:	8b 8f       	std	Y+27, r24	; 0x1b
    33aa:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    33ac:	0f 89       	ldd	r16, Y+23	; 0x17
    33ae:	18 8d       	ldd	r17, Y+24	; 0x18
    33b0:	84 e6       	ldi	r24, 0x64	; 100
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <_Znaj>
    33b8:	f8 01       	movw	r30, r16
    33ba:	80 83       	st	Z, r24
    33bc:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    33be:	e9 8d       	ldd	r30, Y+25	; 0x19
    33c0:	fa 8d       	ldd	r31, Y+26	; 0x1a
    33c2:	10 82       	st	Z, r1
    33c4:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    33c6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    33c8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    33ca:	10 82       	st	Z, r1
    33cc:	11 82       	std	Z+1, r1	; 0x01
}
    33ce:	df 91       	pop	r29
    33d0:	cf 91       	pop	r28
    33d2:	1f 91       	pop	r17
    33d4:	0f 91       	pop	r16
    33d6:	ff 90       	pop	r15
    33d8:	ef 90       	pop	r14
    33da:	08 95       	ret

000033dc <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    33dc:	1f 92       	push	r1
    33de:	0f 92       	push	r0
    33e0:	0f b6       	in	r0, 0x3f	; 63
    33e2:	0f 92       	push	r0
    33e4:	11 24       	eor	r1, r1
    33e6:	08 b6       	in	r0, 0x38	; 56
    33e8:	0f 92       	push	r0
    33ea:	18 be       	out	0x38, r1	; 56
    33ec:	0b b6       	in	r0, 0x3b	; 59
    33ee:	0f 92       	push	r0
    33f0:	1b be       	out	0x3b, r1	; 59
    33f2:	2f 93       	push	r18
    33f4:	3f 93       	push	r19
    33f6:	8f 93       	push	r24
    33f8:	9f 93       	push	r25
    33fa:	ef 93       	push	r30
    33fc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    33fe:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3402:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvC0_buffer>
    3406:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvC0_buffer+0x1>
    340a:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    340e:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3412:	e8 0f       	add	r30, r24
    3414:	f9 1f       	adc	r31, r25
    3416:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3418:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    341c:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3420:	01 96       	adiw	r24, 0x01	; 1
    3422:	84 36       	cpi	r24, 0x64	; 100
    3424:	91 05       	cpc	r25, r1
    3426:	60 f4       	brcc	.+24     	; 0x3440 <__vector_25+0x64>
    3428:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvC0_write_index>
    342c:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3430:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvC0_read_index>
    3434:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvC0_read_index+0x1>
    3438:	82 17       	cp	r24, r18
    343a:	93 07       	cpc	r25, r19
    343c:	f1 f4       	brne	.+60     	; 0x347a <__vector_25+0x9e>
    343e:	0c c0       	rjmp	.+24     	; 0x3458 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3440:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvC0_write_index>
    3444:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3448:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC0_read_index>
    344c:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC0_read_index+0x1>
    3450:	18 16       	cp	r1, r24
    3452:	19 06       	cpc	r1, r25
    3454:	91 f4       	brne	.+36     	; 0x347a <__vector_25+0x9e>
    3456:	0e c0       	rjmp	.+28     	; 0x3474 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3458:	01 96       	adiw	r24, 0x01	; 1
    345a:	84 36       	cpi	r24, 0x64	; 100
    345c:	91 05       	cpc	r25, r1
    345e:	28 f4       	brcc	.+10     	; 0x346a <__vector_25+0x8e>
    3460:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC0_read_index>
    3464:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC0_read_index+0x1>
    3468:	08 c0       	rjmp	.+16     	; 0x347a <__vector_25+0x9e>
			rcvC0_read_index = 0;
    346a:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC0_read_index>
    346e:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC0_read_index+0x1>
}
    3472:	03 c0       	rjmp	.+6      	; 0x347a <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3474:	81 e0       	ldi	r24, 0x01	; 1
    3476:	90 e0       	ldi	r25, 0x00	; 0
    3478:	f3 cf       	rjmp	.-26     	; 0x3460 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    347a:	ff 91       	pop	r31
    347c:	ef 91       	pop	r30
    347e:	9f 91       	pop	r25
    3480:	8f 91       	pop	r24
    3482:	3f 91       	pop	r19
    3484:	2f 91       	pop	r18
    3486:	0f 90       	pop	r0
    3488:	0b be       	out	0x3b, r0	; 59
    348a:	0f 90       	pop	r0
    348c:	08 be       	out	0x38, r0	; 56
    348e:	0f 90       	pop	r0
    3490:	0f be       	out	0x3f, r0	; 63
    3492:	0f 90       	pop	r0
    3494:	1f 90       	pop	r1
    3496:	18 95       	reti

00003498 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3498:	1f 92       	push	r1
    349a:	0f 92       	push	r0
    349c:	0f b6       	in	r0, 0x3f	; 63
    349e:	0f 92       	push	r0
    34a0:	11 24       	eor	r1, r1
    34a2:	08 b6       	in	r0, 0x38	; 56
    34a4:	0f 92       	push	r0
    34a6:	18 be       	out	0x38, r1	; 56
    34a8:	0b b6       	in	r0, 0x3b	; 59
    34aa:	0f 92       	push	r0
    34ac:	1b be       	out	0x3b, r1	; 59
    34ae:	2f 93       	push	r18
    34b0:	3f 93       	push	r19
    34b2:	8f 93       	push	r24
    34b4:	9f 93       	push	r25
    34b6:	ef 93       	push	r30
    34b8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    34ba:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    34be:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvC1_buffer>
    34c2:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvC1_buffer+0x1>
    34c6:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    34ca:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    34ce:	e8 0f       	add	r30, r24
    34d0:	f9 1f       	adc	r31, r25
    34d2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    34d4:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    34d8:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    34dc:	01 96       	adiw	r24, 0x01	; 1
    34de:	84 36       	cpi	r24, 0x64	; 100
    34e0:	91 05       	cpc	r25, r1
    34e2:	60 f4       	brcc	.+24     	; 0x34fc <__vector_28+0x64>
    34e4:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC1_write_index>
    34e8:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34ec:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvC1_read_index>
    34f0:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvC1_read_index+0x1>
    34f4:	82 17       	cp	r24, r18
    34f6:	93 07       	cpc	r25, r19
    34f8:	f1 f4       	brne	.+60     	; 0x3536 <__vector_28+0x9e>
    34fa:	0c c0       	rjmp	.+24     	; 0x3514 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    34fc:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC1_write_index>
    3500:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3504:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvC1_read_index>
    3508:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvC1_read_index+0x1>
    350c:	18 16       	cp	r1, r24
    350e:	19 06       	cpc	r1, r25
    3510:	91 f4       	brne	.+36     	; 0x3536 <__vector_28+0x9e>
    3512:	0e c0       	rjmp	.+28     	; 0x3530 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3514:	01 96       	adiw	r24, 0x01	; 1
    3516:	84 36       	cpi	r24, 0x64	; 100
    3518:	91 05       	cpc	r25, r1
    351a:	28 f4       	brcc	.+10     	; 0x3526 <__vector_28+0x8e>
    351c:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvC1_read_index>
    3520:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvC1_read_index+0x1>
    3524:	08 c0       	rjmp	.+16     	; 0x3536 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3526:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvC1_read_index>
    352a:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvC1_read_index+0x1>
}
    352e:	03 c0       	rjmp	.+6      	; 0x3536 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3530:	81 e0       	ldi	r24, 0x01	; 1
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	f3 cf       	rjmp	.-26     	; 0x351c <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3536:	ff 91       	pop	r31
    3538:	ef 91       	pop	r30
    353a:	9f 91       	pop	r25
    353c:	8f 91       	pop	r24
    353e:	3f 91       	pop	r19
    3540:	2f 91       	pop	r18
    3542:	0f 90       	pop	r0
    3544:	0b be       	out	0x3b, r0	; 59
    3546:	0f 90       	pop	r0
    3548:	08 be       	out	0x38, r0	; 56
    354a:	0f 90       	pop	r0
    354c:	0f be       	out	0x3f, r0	; 63
    354e:	0f 90       	pop	r0
    3550:	1f 90       	pop	r1
    3552:	18 95       	reti

00003554 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3554:	1f 92       	push	r1
    3556:	0f 92       	push	r0
    3558:	0f b6       	in	r0, 0x3f	; 63
    355a:	0f 92       	push	r0
    355c:	11 24       	eor	r1, r1
    355e:	08 b6       	in	r0, 0x38	; 56
    3560:	0f 92       	push	r0
    3562:	18 be       	out	0x38, r1	; 56
    3564:	0b b6       	in	r0, 0x3b	; 59
    3566:	0f 92       	push	r0
    3568:	1b be       	out	0x3b, r1	; 59
    356a:	2f 93       	push	r18
    356c:	3f 93       	push	r19
    356e:	8f 93       	push	r24
    3570:	9f 93       	push	r25
    3572:	ef 93       	push	r30
    3574:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3576:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    357a:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvD0_buffer>
    357e:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvD0_buffer+0x1>
    3582:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    3586:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    358a:	e8 0f       	add	r30, r24
    358c:	f9 1f       	adc	r31, r25
    358e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3590:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD0_write_index>
    3594:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD0_write_index+0x1>
    3598:	01 96       	adiw	r24, 0x01	; 1
    359a:	84 36       	cpi	r24, 0x64	; 100
    359c:	91 05       	cpc	r25, r1
    359e:	60 f4       	brcc	.+24     	; 0x35b8 <__vector_88+0x64>
    35a0:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvD0_write_index>
    35a4:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35a8:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvD0_read_index>
    35ac:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvD0_read_index+0x1>
    35b0:	82 17       	cp	r24, r18
    35b2:	93 07       	cpc	r25, r19
    35b4:	f1 f4       	brne	.+60     	; 0x35f2 <__vector_88+0x9e>
    35b6:	0c c0       	rjmp	.+24     	; 0x35d0 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    35b8:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvD0_write_index>
    35bc:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35c0:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD0_read_index>
    35c4:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD0_read_index+0x1>
    35c8:	18 16       	cp	r1, r24
    35ca:	19 06       	cpc	r1, r25
    35cc:	91 f4       	brne	.+36     	; 0x35f2 <__vector_88+0x9e>
    35ce:	0e c0       	rjmp	.+28     	; 0x35ec <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35d0:	01 96       	adiw	r24, 0x01	; 1
    35d2:	84 36       	cpi	r24, 0x64	; 100
    35d4:	91 05       	cpc	r25, r1
    35d6:	28 f4       	brcc	.+10     	; 0x35e2 <__vector_88+0x8e>
    35d8:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD0_read_index>
    35dc:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD0_read_index+0x1>
    35e0:	08 c0       	rjmp	.+16     	; 0x35f2 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    35e2:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD0_read_index>
    35e6:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD0_read_index+0x1>
}
    35ea:	03 c0       	rjmp	.+6      	; 0x35f2 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35ec:	81 e0       	ldi	r24, 0x01	; 1
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	f3 cf       	rjmp	.-26     	; 0x35d8 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    35f2:	ff 91       	pop	r31
    35f4:	ef 91       	pop	r30
    35f6:	9f 91       	pop	r25
    35f8:	8f 91       	pop	r24
    35fa:	3f 91       	pop	r19
    35fc:	2f 91       	pop	r18
    35fe:	0f 90       	pop	r0
    3600:	0b be       	out	0x3b, r0	; 59
    3602:	0f 90       	pop	r0
    3604:	08 be       	out	0x38, r0	; 56
    3606:	0f 90       	pop	r0
    3608:	0f be       	out	0x3f, r0	; 63
    360a:	0f 90       	pop	r0
    360c:	1f 90       	pop	r1
    360e:	18 95       	reti

00003610 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3610:	1f 92       	push	r1
    3612:	0f 92       	push	r0
    3614:	0f b6       	in	r0, 0x3f	; 63
    3616:	0f 92       	push	r0
    3618:	11 24       	eor	r1, r1
    361a:	08 b6       	in	r0, 0x38	; 56
    361c:	0f 92       	push	r0
    361e:	18 be       	out	0x38, r1	; 56
    3620:	0b b6       	in	r0, 0x3b	; 59
    3622:	0f 92       	push	r0
    3624:	1b be       	out	0x3b, r1	; 59
    3626:	2f 93       	push	r18
    3628:	3f 93       	push	r19
    362a:	8f 93       	push	r24
    362c:	9f 93       	push	r25
    362e:	ef 93       	push	r30
    3630:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3632:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3636:	e0 91 60 31 	lds	r30, 0x3160	; 0x803160 <rcvD1_buffer>
    363a:	f0 91 61 31 	lds	r31, 0x3161	; 0x803161 <rcvD1_buffer+0x1>
    363e:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3642:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    3646:	e8 0f       	add	r30, r24
    3648:	f9 1f       	adc	r31, r25
    364a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    364c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3650:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    3654:	01 96       	adiw	r24, 0x01	; 1
    3656:	84 36       	cpi	r24, 0x64	; 100
    3658:	91 05       	cpc	r25, r1
    365a:	60 f4       	brcc	.+24     	; 0x3674 <__vector_91+0x64>
    365c:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD1_write_index>
    3660:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3664:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvD1_read_index>
    3668:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvD1_read_index+0x1>
    366c:	82 17       	cp	r24, r18
    366e:	93 07       	cpc	r25, r19
    3670:	f1 f4       	brne	.+60     	; 0x36ae <__vector_91+0x9e>
    3672:	0c c0       	rjmp	.+24     	; 0x368c <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3674:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD1_write_index>
    3678:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    367c:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvD1_read_index>
    3680:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvD1_read_index+0x1>
    3684:	18 16       	cp	r1, r24
    3686:	19 06       	cpc	r1, r25
    3688:	91 f4       	brne	.+36     	; 0x36ae <__vector_91+0x9e>
    368a:	0e c0       	rjmp	.+28     	; 0x36a8 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    368c:	01 96       	adiw	r24, 0x01	; 1
    368e:	84 36       	cpi	r24, 0x64	; 100
    3690:	91 05       	cpc	r25, r1
    3692:	28 f4       	brcc	.+10     	; 0x369e <__vector_91+0x8e>
    3694:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvD1_read_index>
    3698:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvD1_read_index+0x1>
    369c:	08 c0       	rjmp	.+16     	; 0x36ae <__vector_91+0x9e>
	rcvD1_read_index = 0;
    369e:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvD1_read_index>
    36a2:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvD1_read_index+0x1>
}
    36a6:	03 c0       	rjmp	.+6      	; 0x36ae <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    36a8:	81 e0       	ldi	r24, 0x01	; 1
    36aa:	90 e0       	ldi	r25, 0x00	; 0
    36ac:	f3 cf       	rjmp	.-26     	; 0x3694 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    36ae:	ff 91       	pop	r31
    36b0:	ef 91       	pop	r30
    36b2:	9f 91       	pop	r25
    36b4:	8f 91       	pop	r24
    36b6:	3f 91       	pop	r19
    36b8:	2f 91       	pop	r18
    36ba:	0f 90       	pop	r0
    36bc:	0b be       	out	0x3b, r0	; 59
    36be:	0f 90       	pop	r0
    36c0:	08 be       	out	0x38, r0	; 56
    36c2:	0f 90       	pop	r0
    36c4:	0f be       	out	0x3f, r0	; 63
    36c6:	0f 90       	pop	r0
    36c8:	1f 90       	pop	r1
    36ca:	18 95       	reti

000036cc <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    36cc:	1f 92       	push	r1
    36ce:	0f 92       	push	r0
    36d0:	0f b6       	in	r0, 0x3f	; 63
    36d2:	0f 92       	push	r0
    36d4:	11 24       	eor	r1, r1
    36d6:	08 b6       	in	r0, 0x38	; 56
    36d8:	0f 92       	push	r0
    36da:	18 be       	out	0x38, r1	; 56
    36dc:	0b b6       	in	r0, 0x3b	; 59
    36de:	0f 92       	push	r0
    36e0:	1b be       	out	0x3b, r1	; 59
    36e2:	2f 93       	push	r18
    36e4:	3f 93       	push	r19
    36e6:	8f 93       	push	r24
    36e8:	9f 93       	push	r25
    36ea:	ef 93       	push	r30
    36ec:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    36ee:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    36f2:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvE0_buffer>
    36f6:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvE0_buffer+0x1>
    36fa:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    36fe:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    3702:	e8 0f       	add	r30, r24
    3704:	f9 1f       	adc	r31, r25
    3706:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3708:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    370c:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    3710:	01 96       	adiw	r24, 0x01	; 1
    3712:	84 36       	cpi	r24, 0x64	; 100
    3714:	91 05       	cpc	r25, r1
    3716:	60 f4       	brcc	.+24     	; 0x3730 <__vector_58+0x64>
    3718:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvE0_write_index>
    371c:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3720:	20 91 54 31 	lds	r18, 0x3154	; 0x803154 <rcvE0_read_index>
    3724:	30 91 55 31 	lds	r19, 0x3155	; 0x803155 <rcvE0_read_index+0x1>
    3728:	82 17       	cp	r24, r18
    372a:	93 07       	cpc	r25, r19
    372c:	f1 f4       	brne	.+60     	; 0x376a <__vector_58+0x9e>
    372e:	0c c0       	rjmp	.+24     	; 0x3748 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3730:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvE0_write_index>
    3734:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3738:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvE0_read_index>
    373c:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvE0_read_index+0x1>
    3740:	18 16       	cp	r1, r24
    3742:	19 06       	cpc	r1, r25
    3744:	91 f4       	brne	.+36     	; 0x376a <__vector_58+0x9e>
    3746:	0e c0       	rjmp	.+28     	; 0x3764 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3748:	01 96       	adiw	r24, 0x01	; 1
    374a:	84 36       	cpi	r24, 0x64	; 100
    374c:	91 05       	cpc	r25, r1
    374e:	28 f4       	brcc	.+10     	; 0x375a <__vector_58+0x8e>
    3750:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvE0_read_index>
    3754:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvE0_read_index+0x1>
    3758:	08 c0       	rjmp	.+16     	; 0x376a <__vector_58+0x9e>
	rcvE0_read_index = 0;
    375a:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvE0_read_index>
    375e:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvE0_read_index+0x1>
}
    3762:	03 c0       	rjmp	.+6      	; 0x376a <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3764:	81 e0       	ldi	r24, 0x01	; 1
    3766:	90 e0       	ldi	r25, 0x00	; 0
    3768:	f3 cf       	rjmp	.-26     	; 0x3750 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    376a:	ff 91       	pop	r31
    376c:	ef 91       	pop	r30
    376e:	9f 91       	pop	r25
    3770:	8f 91       	pop	r24
    3772:	3f 91       	pop	r19
    3774:	2f 91       	pop	r18
    3776:	0f 90       	pop	r0
    3778:	0b be       	out	0x3b, r0	; 59
    377a:	0f 90       	pop	r0
    377c:	08 be       	out	0x38, r0	; 56
    377e:	0f 90       	pop	r0
    3780:	0f be       	out	0x3f, r0	; 63
    3782:	0f 90       	pop	r0
    3784:	1f 90       	pop	r1
    3786:	18 95       	reti

00003788 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3788:	fc 01       	movw	r30, r24
    378a:	84 81       	ldd	r24, Z+4	; 0x04
    378c:	95 81       	ldd	r25, Z+5	; 0x05
    378e:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
		}
    3792:	90 e0       	ldi	r25, 0x00	; 0
    3794:	08 95       	ret

00003796 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3796:	fc 01       	movw	r30, r24
    3798:	84 81       	ldd	r24, Z+4	; 0x04
    379a:	95 81       	ldd	r25, Z+5	; 0x05
    379c:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
    37a0:	91 e0       	ldi	r25, 0x01	; 1
    37a2:	81 11       	cpse	r24, r1
    37a4:	01 c0       	rjmp	.+2      	; 0x37a8 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    37a6:	90 e0       	ldi	r25, 0x00	; 0
		}
    37a8:	89 2f       	mov	r24, r25
    37aa:	08 95       	ret

000037ac <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    37ac:	fc 01       	movw	r30, r24
    37ae:	84 81       	ldd	r24, Z+4	; 0x04
    37b0:	95 81       	ldd	r25, Z+5	; 0x05
    37b2:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
    37b6:	91 e0       	ldi	r25, 0x01	; 1
    37b8:	81 11       	cpse	r24, r1
    37ba:	90 e0       	ldi	r25, 0x00	; 0
		}
    37bc:	89 2f       	mov	r24, r25
    37be:	08 95       	ret

000037c0 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    37c0:	fc 01       	movw	r30, r24
    37c2:	84 81       	ldd	r24, Z+4	; 0x04
    37c4:	95 81       	ldd	r25, Z+5	; 0x05
    37c6:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
		}
    37ca:	90 e0       	ldi	r25, 0x00	; 0
    37cc:	08 95       	ret

000037ce <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    37ce:	fc 01       	movw	r30, r24
    37d0:	84 81       	ldd	r24, Z+4	; 0x04
    37d2:	95 81       	ldd	r25, Z+5	; 0x05
    37d4:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
    37d8:	91 e0       	ldi	r25, 0x01	; 1
    37da:	81 11       	cpse	r24, r1
    37dc:	01 c0       	rjmp	.+2      	; 0x37e0 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    37de:	90 e0       	ldi	r25, 0x00	; 0
		}
    37e0:	89 2f       	mov	r24, r25
    37e2:	08 95       	ret

000037e4 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    37e4:	fc 01       	movw	r30, r24
    37e6:	84 81       	ldd	r24, Z+4	; 0x04
    37e8:	95 81       	ldd	r25, Z+5	; 0x05
    37ea:	0e 94 f6 0c 	call	0x19ec	; 0x19ec <uxQueueMessagesWaitingFromISR>
    37ee:	91 e0       	ldi	r25, 0x01	; 1
    37f0:	81 11       	cpse	r24, r1
    37f2:	90 e0       	ldi	r25, 0x00	; 0
		}
    37f4:	89 2f       	mov	r24, r25
    37f6:	08 95       	ret

000037f8 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    37f8:	fc 01       	movw	r30, r24
    37fa:	84 81       	ldd	r24, Z+4	; 0x04
    37fc:	95 81       	ldd	r25, Z+5	; 0x05
    37fe:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
		}
    3802:	90 e0       	ldi	r25, 0x00	; 0
    3804:	08 95       	ret

00003806 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3806:	fc 01       	movw	r30, r24
    3808:	84 81       	ldd	r24, Z+4	; 0x04
    380a:	95 81       	ldd	r25, Z+5	; 0x05
    380c:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
    3810:	91 e0       	ldi	r25, 0x01	; 1
    3812:	81 11       	cpse	r24, r1
    3814:	01 c0       	rjmp	.+2      	; 0x3818 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    3816:	90 e0       	ldi	r25, 0x00	; 0
		}
    3818:	89 2f       	mov	r24, r25
    381a:	08 95       	ret

0000381c <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    381c:	fc 01       	movw	r30, r24
    381e:	84 81       	ldd	r24, Z+4	; 0x04
    3820:	95 81       	ldd	r25, Z+5	; 0x05
    3822:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
    3826:	91 e0       	ldi	r25, 0x01	; 1
    3828:	81 11       	cpse	r24, r1
    382a:	90 e0       	ldi	r25, 0x00	; 0
		}
    382c:	89 2f       	mov	r24, r25
    382e:	08 95       	ret

00003830 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3830:	fc 01       	movw	r30, r24
    3832:	84 81       	ldd	r24, Z+4	; 0x04
    3834:	95 81       	ldd	r25, Z+5	; 0x05
    3836:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
		}
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	08 95       	ret

0000383e <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    383e:	fc 01       	movw	r30, r24
    3840:	84 81       	ldd	r24, Z+4	; 0x04
    3842:	95 81       	ldd	r25, Z+5	; 0x05
    3844:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
    3848:	91 e0       	ldi	r25, 0x01	; 1
    384a:	81 11       	cpse	r24, r1
    384c:	01 c0       	rjmp	.+2      	; 0x3850 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    384e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3850:	89 2f       	mov	r24, r25
    3852:	08 95       	ret

00003854 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3854:	fc 01       	movw	r30, r24
    3856:	84 81       	ldd	r24, Z+4	; 0x04
    3858:	95 81       	ldd	r25, Z+5	; 0x05
    385a:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <uxQueueMessagesWaiting>
    385e:	91 e0       	ldi	r25, 0x01	; 1
    3860:	81 11       	cpse	r24, r1
    3862:	90 e0       	ldi	r25, 0x00	; 0
		}
    3864:	89 2f       	mov	r24, r25
    3866:	08 95       	ret

00003868 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3868:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    386a:	01 e0       	ldi	r16, 0x01	; 1
    386c:	2f ef       	ldi	r18, 0xFF	; 255
    386e:	3f ef       	ldi	r19, 0xFF	; 255
    3870:	a9 01       	movw	r20, r18
    3872:	fc 01       	movw	r30, r24
    3874:	84 81       	ldd	r24, Z+4	; 0x04
    3876:	95 81       	ldd	r25, Z+5	; 0x05
    3878:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
}
    387c:	0f 91       	pop	r16
    387e:	08 95       	ret

00003880 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3880:	0f 93       	push	r16
    3882:	cf 93       	push	r28
    3884:	df 93       	push	r29
    3886:	1f 92       	push	r1
    3888:	1f 92       	push	r1
    388a:	cd b7       	in	r28, 0x3d	; 61
    388c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    388e:	01 e0       	ldi	r16, 0x01	; 1
    3890:	2f ef       	ldi	r18, 0xFF	; 255
    3892:	3f ef       	ldi	r19, 0xFF	; 255
    3894:	a9 01       	movw	r20, r18
    3896:	be 01       	movw	r22, r28
    3898:	6f 5f       	subi	r22, 0xFF	; 255
    389a:	7f 4f       	sbci	r23, 0xFF	; 255
    389c:	fc 01       	movw	r30, r24
    389e:	84 81       	ldd	r24, Z+4	; 0x04
    38a0:	95 81       	ldd	r25, Z+5	; 0x05
    38a2:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
	return (recv_item);
}
    38a6:	89 81       	ldd	r24, Y+1	; 0x01
    38a8:	9a 81       	ldd	r25, Y+2	; 0x02
    38aa:	0f 90       	pop	r0
    38ac:	0f 90       	pop	r0
    38ae:	df 91       	pop	r29
    38b0:	cf 91       	pop	r28
    38b2:	0f 91       	pop	r16
    38b4:	08 95       	ret

000038b6 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    38b6:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    38b8:	00 e0       	ldi	r16, 0x00	; 0
    38ba:	2f ef       	ldi	r18, 0xFF	; 255
    38bc:	3f ef       	ldi	r19, 0xFF	; 255
    38be:	a9 01       	movw	r20, r18
    38c0:	fc 01       	movw	r30, r24
    38c2:	84 81       	ldd	r24, Z+4	; 0x04
    38c4:	95 81       	ldd	r25, Z+5	; 0x05
    38c6:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
}
    38ca:	0f 91       	pop	r16
    38cc:	08 95       	ret

000038ce <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    38ce:	0f 93       	push	r16
    38d0:	cf 93       	push	r28
    38d2:	df 93       	push	r29
    38d4:	1f 92       	push	r1
    38d6:	1f 92       	push	r1
    38d8:	cd b7       	in	r28, 0x3d	; 61
    38da:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    38dc:	00 e0       	ldi	r16, 0x00	; 0
    38de:	2f ef       	ldi	r18, 0xFF	; 255
    38e0:	3f ef       	ldi	r19, 0xFF	; 255
    38e2:	a9 01       	movw	r20, r18
    38e4:	be 01       	movw	r22, r28
    38e6:	6f 5f       	subi	r22, 0xFF	; 255
    38e8:	7f 4f       	sbci	r23, 0xFF	; 255
    38ea:	fc 01       	movw	r30, r24
    38ec:	84 81       	ldd	r24, Z+4	; 0x04
    38ee:	95 81       	ldd	r25, Z+5	; 0x05
    38f0:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
	return (recv_item);
}
    38f4:	89 81       	ldd	r24, Y+1	; 0x01
    38f6:	9a 81       	ldd	r25, Y+2	; 0x02
    38f8:	0f 90       	pop	r0
    38fa:	0f 90       	pop	r0
    38fc:	df 91       	pop	r29
    38fe:	cf 91       	pop	r28
    3900:	0f 91       	pop	r16
    3902:	08 95       	ret

00003904 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3904:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3906:	01 e0       	ldi	r16, 0x01	; 1
    3908:	2f ef       	ldi	r18, 0xFF	; 255
    390a:	3f ef       	ldi	r19, 0xFF	; 255
    390c:	a9 01       	movw	r20, r18
    390e:	fc 01       	movw	r30, r24
    3910:	84 81       	ldd	r24, Z+4	; 0x04
    3912:	95 81       	ldd	r25, Z+5	; 0x05
    3914:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
}
    3918:	0f 91       	pop	r16
    391a:	08 95       	ret

0000391c <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    391c:	0f 93       	push	r16
    391e:	cf 93       	push	r28
    3920:	df 93       	push	r29
    3922:	1f 92       	push	r1
    3924:	1f 92       	push	r1
    3926:	cd b7       	in	r28, 0x3d	; 61
    3928:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    392a:	01 e0       	ldi	r16, 0x01	; 1
    392c:	2f ef       	ldi	r18, 0xFF	; 255
    392e:	3f ef       	ldi	r19, 0xFF	; 255
    3930:	a9 01       	movw	r20, r18
    3932:	be 01       	movw	r22, r28
    3934:	6f 5f       	subi	r22, 0xFF	; 255
    3936:	7f 4f       	sbci	r23, 0xFF	; 255
    3938:	fc 01       	movw	r30, r24
    393a:	84 81       	ldd	r24, Z+4	; 0x04
    393c:	95 81       	ldd	r25, Z+5	; 0x05
    393e:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
	return (recv_item);
}
    3942:	89 81       	ldd	r24, Y+1	; 0x01
    3944:	9a 81       	ldd	r25, Y+2	; 0x02
    3946:	0f 90       	pop	r0
    3948:	0f 90       	pop	r0
    394a:	df 91       	pop	r29
    394c:	cf 91       	pop	r28
    394e:	0f 91       	pop	r16
    3950:	08 95       	ret

00003952 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3952:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3954:	00 e0       	ldi	r16, 0x00	; 0
    3956:	2f ef       	ldi	r18, 0xFF	; 255
    3958:	3f ef       	ldi	r19, 0xFF	; 255
    395a:	a9 01       	movw	r20, r18
    395c:	fc 01       	movw	r30, r24
    395e:	84 81       	ldd	r24, Z+4	; 0x04
    3960:	95 81       	ldd	r25, Z+5	; 0x05
    3962:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
}
    3966:	0f 91       	pop	r16
    3968:	08 95       	ret

0000396a <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    396a:	0f 93       	push	r16
    396c:	cf 93       	push	r28
    396e:	df 93       	push	r29
    3970:	1f 92       	push	r1
    3972:	1f 92       	push	r1
    3974:	cd b7       	in	r28, 0x3d	; 61
    3976:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3978:	00 e0       	ldi	r16, 0x00	; 0
    397a:	2f ef       	ldi	r18, 0xFF	; 255
    397c:	3f ef       	ldi	r19, 0xFF	; 255
    397e:	a9 01       	movw	r20, r18
    3980:	be 01       	movw	r22, r28
    3982:	6f 5f       	subi	r22, 0xFF	; 255
    3984:	7f 4f       	sbci	r23, 0xFF	; 255
    3986:	fc 01       	movw	r30, r24
    3988:	84 81       	ldd	r24, Z+4	; 0x04
    398a:	95 81       	ldd	r25, Z+5	; 0x05
    398c:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <xQueueGenericReceive>
	return (recv_item);
}
    3990:	89 81       	ldd	r24, Y+1	; 0x01
    3992:	9a 81       	ldd	r25, Y+2	; 0x02
    3994:	0f 90       	pop	r0
    3996:	0f 90       	pop	r0
    3998:	df 91       	pop	r29
    399a:	cf 91       	pop	r28
    399c:	0f 91       	pop	r16
    399e:	08 95       	ret

000039a0 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    39a0:	cf 93       	push	r28
    39a2:	df 93       	push	r29
    39a4:	1f 92       	push	r1
    39a6:	cd b7       	in	r28, 0x3d	; 61
    39a8:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    39aa:	ae 01       	movw	r20, r28
    39ac:	4f 5f       	subi	r20, 0xFF	; 255
    39ae:	5f 4f       	sbci	r21, 0xFF	; 255
    39b0:	fc 01       	movw	r30, r24
    39b2:	84 81       	ldd	r24, Z+4	; 0x04
    39b4:	95 81       	ldd	r25, Z+5	; 0x05
    39b6:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueReceiveFromISR>
}
    39ba:	0f 90       	pop	r0
    39bc:	df 91       	pop	r29
    39be:	cf 91       	pop	r28
    39c0:	08 95       	ret

000039c2 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	00 d0       	rcall	.+0      	; 0x39c8 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    39c8:	cd b7       	in	r28, 0x3d	; 61
    39ca:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    39cc:	ae 01       	movw	r20, r28
    39ce:	4d 5f       	subi	r20, 0xFD	; 253
    39d0:	5f 4f       	sbci	r21, 0xFF	; 255
    39d2:	be 01       	movw	r22, r28
    39d4:	6f 5f       	subi	r22, 0xFF	; 255
    39d6:	7f 4f       	sbci	r23, 0xFF	; 255
    39d8:	fc 01       	movw	r30, r24
    39da:	84 81       	ldd	r24, Z+4	; 0x04
    39dc:	95 81       	ldd	r25, Z+5	; 0x05
    39de:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueReceiveFromISR>
	return (recv_item);
}
    39e2:	89 81       	ldd	r24, Y+1	; 0x01
    39e4:	9a 81       	ldd	r25, Y+2	; 0x02
    39e6:	23 96       	adiw	r28, 0x03	; 3
    39e8:	cd bf       	out	0x3d, r28	; 61
    39ea:	de bf       	out	0x3e, r29	; 62
    39ec:	df 91       	pop	r29
    39ee:	cf 91       	pop	r28
    39f0:	08 95       	ret

000039f2 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    39f2:	cf 93       	push	r28
    39f4:	df 93       	push	r29
    39f6:	1f 92       	push	r1
    39f8:	cd b7       	in	r28, 0x3d	; 61
    39fa:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    39fc:	ae 01       	movw	r20, r28
    39fe:	4f 5f       	subi	r20, 0xFF	; 255
    3a00:	5f 4f       	sbci	r21, 0xFF	; 255
    3a02:	fc 01       	movw	r30, r24
    3a04:	84 81       	ldd	r24, Z+4	; 0x04
    3a06:	95 81       	ldd	r25, Z+5	; 0x05
    3a08:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueReceiveFromISR>
}
    3a0c:	0f 90       	pop	r0
    3a0e:	df 91       	pop	r29
    3a10:	cf 91       	pop	r28
    3a12:	08 95       	ret

00003a14 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3a14:	cf 93       	push	r28
    3a16:	df 93       	push	r29
    3a18:	00 d0       	rcall	.+0      	; 0x3a1a <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3a1a:	cd b7       	in	r28, 0x3d	; 61
    3a1c:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3a1e:	ae 01       	movw	r20, r28
    3a20:	4d 5f       	subi	r20, 0xFD	; 253
    3a22:	5f 4f       	sbci	r21, 0xFF	; 255
    3a24:	be 01       	movw	r22, r28
    3a26:	6f 5f       	subi	r22, 0xFF	; 255
    3a28:	7f 4f       	sbci	r23, 0xFF	; 255
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	84 81       	ldd	r24, Z+4	; 0x04
    3a2e:	95 81       	ldd	r25, Z+5	; 0x05
    3a30:	0e 94 c1 0c 	call	0x1982	; 0x1982 <xQueueReceiveFromISR>
	return (recv_item);
}
    3a34:	89 81       	ldd	r24, Y+1	; 0x01
    3a36:	9a 81       	ldd	r25, Y+2	; 0x02
    3a38:	23 96       	adiw	r28, 0x03	; 3
    3a3a:	cd bf       	out	0x3d, r28	; 61
    3a3c:	de bf       	out	0x3e, r29	; 62
    3a3e:	df 91       	pop	r29
    3a40:	cf 91       	pop	r28
    3a42:	08 95       	ret

00003a44 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3a44:	cf 93       	push	r28
    3a46:	df 93       	push	r29
    3a48:	1f 92       	push	r1
    3a4a:	cd b7       	in	r28, 0x3d	; 61
    3a4c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3a4e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3a50:	21 e0       	ldi	r18, 0x01	; 1
    3a52:	ae 01       	movw	r20, r28
    3a54:	4f 5f       	subi	r20, 0xFF	; 255
    3a56:	5f 4f       	sbci	r21, 0xFF	; 255
    3a58:	fc 01       	movw	r30, r24
    3a5a:	84 81       	ldd	r24, Z+4	; 0x04
    3a5c:	95 81       	ldd	r25, Z+5	; 0x05
    3a5e:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3a62:	91 e0       	ldi	r25, 0x01	; 1
    3a64:	81 11       	cpse	r24, r1
    3a66:	01 c0       	rjmp	.+2      	; 0x3a6a <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3a68:	90 e0       	ldi	r25, 0x00	; 0
}
    3a6a:	89 2f       	mov	r24, r25
    3a6c:	0f 90       	pop	r0
    3a6e:	df 91       	pop	r29
    3a70:	cf 91       	pop	r28
    3a72:	08 95       	ret

00003a74 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3a74:	cf 93       	push	r28
    3a76:	df 93       	push	r29
    3a78:	1f 92       	push	r1
    3a7a:	cd b7       	in	r28, 0x3d	; 61
    3a7c:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3a7e:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3a80:	20 e0       	ldi	r18, 0x00	; 0
    3a82:	ae 01       	movw	r20, r28
    3a84:	4f 5f       	subi	r20, 0xFF	; 255
    3a86:	5f 4f       	sbci	r21, 0xFF	; 255
    3a88:	fc 01       	movw	r30, r24
    3a8a:	84 81       	ldd	r24, Z+4	; 0x04
    3a8c:	95 81       	ldd	r25, Z+5	; 0x05
    3a8e:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3a92:	91 e0       	ldi	r25, 0x01	; 1
    3a94:	81 11       	cpse	r24, r1
    3a96:	01 c0       	rjmp	.+2      	; 0x3a9a <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3a98:	90 e0       	ldi	r25, 0x00	; 0
}
    3a9a:	89 2f       	mov	r24, r25
    3a9c:	0f 90       	pop	r0
    3a9e:	df 91       	pop	r29
    3aa0:	cf 91       	pop	r28
    3aa2:	08 95       	ret

00003aa4 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3aa4:	cf 93       	push	r28
    3aa6:	df 93       	push	r29
    3aa8:	1f 92       	push	r1
    3aaa:	cd b7       	in	r28, 0x3d	; 61
    3aac:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3aae:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3ab0:	21 e0       	ldi	r18, 0x01	; 1
    3ab2:	ae 01       	movw	r20, r28
    3ab4:	4f 5f       	subi	r20, 0xFF	; 255
    3ab6:	5f 4f       	sbci	r21, 0xFF	; 255
    3ab8:	fc 01       	movw	r30, r24
    3aba:	84 81       	ldd	r24, Z+4	; 0x04
    3abc:	95 81       	ldd	r25, Z+5	; 0x05
    3abe:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ac2:	91 e0       	ldi	r25, 0x01	; 1
    3ac4:	81 11       	cpse	r24, r1
    3ac6:	01 c0       	rjmp	.+2      	; 0x3aca <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3ac8:	90 e0       	ldi	r25, 0x00	; 0
}
    3aca:	89 2f       	mov	r24, r25
    3acc:	0f 90       	pop	r0
    3ace:	df 91       	pop	r29
    3ad0:	cf 91       	pop	r28
    3ad2:	08 95       	ret

00003ad4 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3ad4:	cf 93       	push	r28
    3ad6:	df 93       	push	r29
    3ad8:	1f 92       	push	r1
    3ada:	cd b7       	in	r28, 0x3d	; 61
    3adc:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3ade:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3ae0:	20 e0       	ldi	r18, 0x00	; 0
    3ae2:	ae 01       	movw	r20, r28
    3ae4:	4f 5f       	subi	r20, 0xFF	; 255
    3ae6:	5f 4f       	sbci	r21, 0xFF	; 255
    3ae8:	fc 01       	movw	r30, r24
    3aea:	84 81       	ldd	r24, Z+4	; 0x04
    3aec:	95 81       	ldd	r25, Z+5	; 0x05
    3aee:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3af2:	91 e0       	ldi	r25, 0x01	; 1
    3af4:	81 11       	cpse	r24, r1
    3af6:	01 c0       	rjmp	.+2      	; 0x3afa <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3af8:	90 e0       	ldi	r25, 0x00	; 0
}
    3afa:	89 2f       	mov	r24, r25
    3afc:	0f 90       	pop	r0
    3afe:	df 91       	pop	r29
    3b00:	cf 91       	pop	r28
    3b02:	08 95       	ret

00003b04 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3b04:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3b06:	fc 01       	movw	r30, r24
    3b08:	26 81       	ldd	r18, Z+6	; 0x06
    3b0a:	37 81       	ldd	r19, Z+7	; 0x07
    3b0c:	40 85       	ldd	r20, Z+8	; 0x08
    3b0e:	51 85       	ldd	r21, Z+9	; 0x09
    3b10:	01 e0       	ldi	r16, 0x01	; 1
    3b12:	84 81       	ldd	r24, Z+4	; 0x04
    3b14:	95 81       	ldd	r25, Z+5	; 0x05
    3b16:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    3b1a:	91 e0       	ldi	r25, 0x01	; 1
    3b1c:	81 11       	cpse	r24, r1
    3b1e:	01 c0       	rjmp	.+2      	; 0x3b22 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3b20:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b22:	89 2f       	mov	r24, r25
    3b24:	0f 91       	pop	r16
    3b26:	08 95       	ret

00003b28 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3b28:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3b2a:	fc 01       	movw	r30, r24
    3b2c:	26 81       	ldd	r18, Z+6	; 0x06
    3b2e:	37 81       	ldd	r19, Z+7	; 0x07
    3b30:	40 85       	ldd	r20, Z+8	; 0x08
    3b32:	51 85       	ldd	r21, Z+9	; 0x09
    3b34:	00 e0       	ldi	r16, 0x00	; 0
    3b36:	84 81       	ldd	r24, Z+4	; 0x04
    3b38:	95 81       	ldd	r25, Z+5	; 0x05
    3b3a:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    3b3e:	91 e0       	ldi	r25, 0x01	; 1
    3b40:	81 11       	cpse	r24, r1
    3b42:	01 c0       	rjmp	.+2      	; 0x3b46 <_ZN9frt_queueIjE3putERKj+0x1e>
    3b44:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b46:	89 2f       	mov	r24, r25
    3b48:	0f 91       	pop	r16
    3b4a:	08 95       	ret

00003b4c <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3b4c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3b4e:	fc 01       	movw	r30, r24
    3b50:	26 81       	ldd	r18, Z+6	; 0x06
    3b52:	37 81       	ldd	r19, Z+7	; 0x07
    3b54:	40 85       	ldd	r20, Z+8	; 0x08
    3b56:	51 85       	ldd	r21, Z+9	; 0x09
    3b58:	01 e0       	ldi	r16, 0x01	; 1
    3b5a:	84 81       	ldd	r24, Z+4	; 0x04
    3b5c:	95 81       	ldd	r25, Z+5	; 0x05
    3b5e:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    3b62:	91 e0       	ldi	r25, 0x01	; 1
    3b64:	81 11       	cpse	r24, r1
    3b66:	01 c0       	rjmp	.+2      	; 0x3b6a <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3b68:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b6a:	89 2f       	mov	r24, r25
    3b6c:	0f 91       	pop	r16
    3b6e:	08 95       	ret

00003b70 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3b70:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3b72:	fc 01       	movw	r30, r24
    3b74:	26 81       	ldd	r18, Z+6	; 0x06
    3b76:	37 81       	ldd	r19, Z+7	; 0x07
    3b78:	40 85       	ldd	r20, Z+8	; 0x08
    3b7a:	51 85       	ldd	r21, Z+9	; 0x09
    3b7c:	00 e0       	ldi	r16, 0x00	; 0
    3b7e:	84 81       	ldd	r24, Z+4	; 0x04
    3b80:	95 81       	ldd	r25, Z+5	; 0x05
    3b82:	0e 94 36 0b 	call	0x166c	; 0x166c <xQueueGenericSend>
    3b86:	91 e0       	ldi	r25, 0x01	; 1
    3b88:	81 11       	cpse	r24, r1
    3b8a:	01 c0       	rjmp	.+2      	; 0x3b8e <_ZN9frt_queueIiE3putERKi+0x1e>
    3b8c:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b8e:	89 2f       	mov	r24, r25
    3b90:	0f 91       	pop	r16
    3b92:	08 95       	ret

00003b94 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3b94:	0f 93       	push	r16
    3b96:	cf 93       	push	r28
    3b98:	df 93       	push	r29
    3b9a:	1f 92       	push	r1
    3b9c:	cd b7       	in	r28, 0x3d	; 61
    3b9e:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3ba0:	2f b7       	in	r18, 0x3f	; 63
    3ba2:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3ba4:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3ba6:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3ba8:	fc 01       	movw	r30, r24
    3baa:	08 ed       	ldi	r16, 0xD8	; 216
    3bac:	04 bf       	out	0x34, r16	; 52
    3bae:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3bb0:	89 81       	ldd	r24, Y+1	; 0x01
    3bb2:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3bb4:	0f 90       	pop	r0
    3bb6:	df 91       	pop	r29
    3bb8:	cf 91       	pop	r28
    3bba:	0f 91       	pop	r16
    3bbc:	08 95       	ret

00003bbe <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3bbe:	0f 93       	push	r16
    3bc0:	1f 93       	push	r17
    3bc2:	cf 93       	push	r28
    3bc4:	df 93       	push	r29
    3bc6:	cd b7       	in	r28, 0x3d	; 61
    3bc8:	de b7       	in	r29, 0x3e	; 62
    3bca:	e4 97       	sbiw	r28, 0x34	; 52
    3bcc:	cd bf       	out	0x3d, r28	; 61
    3bce:	de bf       	out	0x3e, r29	; 62
	cli();
    3bd0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3bd2:	e0 e5       	ldi	r30, 0x50	; 80
    3bd4:	f0 e0       	ldi	r31, 0x00	; 0
    3bd6:	80 81       	ld	r24, Z
    3bd8:	82 60       	ori	r24, 0x02	; 2
    3bda:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3bdc:	81 81       	ldd	r24, Z+1	; 0x01
    3bde:	81 ff       	sbrs	r24, 1
    3be0:	fd cf       	rjmp	.-6      	; 0x3bdc <main+0x1e>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3be2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3be6:	68 7f       	andi	r22, 0xF8	; 248
    3be8:	61 60       	ori	r22, 0x01	; 1
    3bea:	80 e4       	ldi	r24, 0x40	; 64
    3bec:	90 e0       	ldi	r25, 0x00	; 0
    3bee:	0e 94 ca 1d 	call	0x3b94	; 0x3b94 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3bf2:	e0 e5       	ldi	r30, 0x50	; 80
    3bf4:	f0 e0       	ldi	r31, 0x00	; 0
    3bf6:	80 81       	ld	r24, Z
    3bf8:	8e 7f       	andi	r24, 0xFE	; 254
    3bfa:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3bfc:	9d ef       	ldi	r25, 0xFD	; 253
    3bfe:	88 ed       	ldi	r24, 0xD8	; 216
    3c00:	08 b6       	in	r0, 0x38	; 56
    3c02:	18 be       	out	0x38, r1	; 56
    3c04:	84 bf       	out	0x34, r24	; 52
    3c06:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3c0a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3c0c:	40 ea       	ldi	r20, 0xA0	; 160
    3c0e:	5a e0       	ldi	r21, 0x0A	; 10
    3c10:	60 e0       	ldi	r22, 0x00	; 0
    3c12:	70 e0       	ldi	r23, 0x00	; 0
    3c14:	ce 01       	movw	r24, r28
    3c16:	01 96       	adiw	r24, 0x01	; 1
    3c18:	0e 94 6e 19 	call	0x32dc	; 0x32dc <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3c1c:	67 e0       	ldi	r22, 0x07	; 7
    3c1e:	ce 01       	movw	r24, r28
    3c20:	01 96       	adiw	r24, 0x01	; 1
    3c22:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    3c26:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c28:	6f e6       	ldi	r22, 0x6F	; 111
    3c2a:	70 e2       	ldi	r23, 0x20	; 32
    3c2c:	0e 94 94 17 	call	0x2f28	; 0x2f28 <_ZN8emstream4putsEPKc>
    3c30:	66 e0       	ldi	r22, 0x06	; 6
    3c32:	c8 01       	movw	r24, r16
    3c34:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
    3c38:	66 e0       	ldi	r22, 0x06	; 6
    3c3a:	0e 94 cb 17 	call	0x2f96	; 0x2f96 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    3c3e:	20 e3       	ldi	r18, 0x30	; 48
    3c40:	32 ef       	ldi	r19, 0xF2	; 242
    3c42:	40 e0       	ldi	r20, 0x00	; 0
    3c44:	50 e0       	ldi	r21, 0x00	; 0
    3c46:	60 ea       	ldi	r22, 0xA0	; 160
    3c48:	74 e0       	ldi	r23, 0x04	; 4
    3c4a:	ce 01       	movw	r24, r28
    3c4c:	4e 96       	adiw	r24, 0x1e	; 30
    3c4e:	0e 94 52 04 	call	0x8a4	; 0x8a4 <_ZN9I2CMasterC1EP10TWI_structm>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3c52:	82 e1       	ldi	r24, 0x12	; 18
    3c54:	90 e0       	ldi	r25, 0x00	; 0
    3c56:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <_Znwj>
    3c5a:	8e 01       	movw	r16, r28
    3c5c:	0f 5f       	subi	r16, 0xFF	; 255
    3c5e:	1f 4f       	sbci	r17, 0xFF	; 255
    3c60:	20 e8       	ldi	r18, 0x80	; 128
    3c62:	30 e0       	ldi	r19, 0x00	; 0
    3c64:	40 e0       	ldi	r20, 0x00	; 0
    3c66:	6e e8       	ldi	r22, 0x8E	; 142
    3c68:	70 e2       	ldi	r23, 0x20	; 32
    3c6a:	0e 94 b2 04 	call	0x964	; 0x964 <_ZN9task_userC1EPKchjP8emstream>
	
	// new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3c6e:	87 e0       	ldi	r24, 0x07	; 7
    3c70:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3c74:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3c76:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <vTaskStartScheduler>
}
    3c7a:	80 e0       	ldi	r24, 0x00	; 0
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	e4 96       	adiw	r28, 0x34	; 52
    3c80:	cd bf       	out	0x3d, r28	; 61
    3c82:	de bf       	out	0x3e, r29	; 62
    3c84:	df 91       	pop	r29
    3c86:	cf 91       	pop	r28
    3c88:	1f 91       	pop	r17
    3c8a:	0f 91       	pop	r16
    3c8c:	08 95       	ret

00003c8e <_GLOBAL__sub_I_counter>:
    3c8e:	cf 92       	push	r12
    3c90:	df 92       	push	r13
    3c92:	ef 92       	push	r14
    3c94:	ff 92       	push	r15
    3c96:	0f 93       	push	r16
    3c98:	1f 93       	push	r17
    3c9a:	cf 93       	push	r28
    3c9c:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3c9e:	0a e0       	ldi	r16, 0x0A	; 10
    3ca0:	10 e0       	ldi	r17, 0x00	; 0
    3ca2:	20 e0       	ldi	r18, 0x00	; 0
    3ca4:	30 e0       	ldi	r19, 0x00	; 0
    3ca6:	40 e0       	ldi	r20, 0x00	; 0
    3ca8:	50 e0       	ldi	r21, 0x00	; 0
    3caa:	60 e2       	ldi	r22, 0x20	; 32
    3cac:	70 e0       	ldi	r23, 0x00	; 0
    3cae:	8a e9       	ldi	r24, 0x9A	; 154
    3cb0:	91 e3       	ldi	r25, 0x31	; 49
    3cb2:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3cb6:	c0 e9       	ldi	r28, 0x90	; 144
    3cb8:	d1 e3       	ldi	r29, 0x31	; 49
    3cba:	1a 82       	std	Y+2, r1	; 0x02
    3cbc:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3cbe:	8a e9       	ldi	r24, 0x9A	; 154
    3cc0:	90 e2       	ldi	r25, 0x20	; 32
    3cc2:	88 83       	st	Y, r24
    3cc4:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3cc6:	40 e0       	ldi	r20, 0x00	; 0
    3cc8:	62 e0       	ldi	r22, 0x02	; 2
    3cca:	8f ef       	ldi	r24, 0xFF	; 255
    3ccc:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    3cd0:	8c 83       	std	Y+4, r24	; 0x04
    3cd2:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3cd4:	0f 2e       	mov	r0, r31
    3cd6:	fa e0       	ldi	r31, 0x0A	; 10
    3cd8:	cf 2e       	mov	r12, r31
    3cda:	d1 2c       	mov	r13, r1
    3cdc:	e1 2c       	mov	r14, r1
    3cde:	f1 2c       	mov	r15, r1
    3ce0:	f0 2d       	mov	r31, r0
    3ce2:	ce 82       	std	Y+6, r12	; 0x06
    3ce4:	df 82       	std	Y+7, r13	; 0x07
    3ce6:	e8 86       	std	Y+8, r14	; 0x08
    3ce8:	f9 86       	std	Y+9, r15	; 0x09
    3cea:	c6 e8       	ldi	r28, 0x86	; 134
    3cec:	d1 e3       	ldi	r29, 0x31	; 49
    3cee:	1a 82       	std	Y+2, r1	; 0x02
    3cf0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3cf2:	0e eb       	ldi	r16, 0xBE	; 190
    3cf4:	10 e2       	ldi	r17, 0x20	; 32
    3cf6:	08 83       	st	Y, r16
    3cf8:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3cfa:	40 e0       	ldi	r20, 0x00	; 0
    3cfc:	62 e0       	ldi	r22, 0x02	; 2
    3cfe:	8f ef       	ldi	r24, 0xFF	; 255
    3d00:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    3d04:	8c 83       	std	Y+4, r24	; 0x04
    3d06:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d08:	ce 82       	std	Y+6, r12	; 0x06
    3d0a:	df 82       	std	Y+7, r13	; 0x07
    3d0c:	e8 86       	std	Y+8, r14	; 0x08
    3d0e:	f9 86       	std	Y+9, r15	; 0x09
    3d10:	cc e7       	ldi	r28, 0x7C	; 124
    3d12:	d1 e3       	ldi	r29, 0x31	; 49
    3d14:	1a 82       	std	Y+2, r1	; 0x02
    3d16:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d18:	08 83       	st	Y, r16
    3d1a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d1c:	40 e0       	ldi	r20, 0x00	; 0
    3d1e:	62 e0       	ldi	r22, 0x02	; 2
    3d20:	8f ef       	ldi	r24, 0xFF	; 255
    3d22:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    3d26:	8c 83       	std	Y+4, r24	; 0x04
    3d28:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d2a:	ce 82       	std	Y+6, r12	; 0x06
    3d2c:	df 82       	std	Y+7, r13	; 0x07
    3d2e:	e8 86       	std	Y+8, r14	; 0x08
    3d30:	f9 86       	std	Y+9, r15	; 0x09
    3d32:	c2 e7       	ldi	r28, 0x72	; 114
    3d34:	d1 e3       	ldi	r29, 0x31	; 49
    3d36:	1a 82       	std	Y+2, r1	; 0x02
    3d38:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d3a:	08 83       	st	Y, r16
    3d3c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d3e:	40 e0       	ldi	r20, 0x00	; 0
    3d40:	62 e0       	ldi	r22, 0x02	; 2
    3d42:	8f ef       	ldi	r24, 0xFF	; 255
    3d44:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    3d48:	8c 83       	std	Y+4, r24	; 0x04
    3d4a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d4c:	ce 82       	std	Y+6, r12	; 0x06
    3d4e:	df 82       	std	Y+7, r13	; 0x07
    3d50:	e8 86       	std	Y+8, r14	; 0x08
    3d52:	f9 86       	std	Y+9, r15	; 0x09
    3d54:	c8 e6       	ldi	r28, 0x68	; 104
    3d56:	d1 e3       	ldi	r29, 0x31	; 49
    3d58:	1a 82       	std	Y+2, r1	; 0x02
    3d5a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d5c:	08 83       	st	Y, r16
    3d5e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d60:	40 e0       	ldi	r20, 0x00	; 0
    3d62:	62 e0       	ldi	r22, 0x02	; 2
    3d64:	8f ef       	ldi	r24, 0xFF	; 255
    3d66:	0e 94 08 0b 	call	0x1610	; 0x1610 <xQueueGenericCreate>
    3d6a:	8c 83       	std	Y+4, r24	; 0x04
    3d6c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d6e:	ce 82       	std	Y+6, r12	; 0x06
    3d70:	df 82       	std	Y+7, r13	; 0x07
    3d72:	e8 86       	std	Y+8, r14	; 0x08
    3d74:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3d76:	df 91       	pop	r29
    3d78:	cf 91       	pop	r28
    3d7a:	1f 91       	pop	r17
    3d7c:	0f 91       	pop	r16
    3d7e:	ff 90       	pop	r15
    3d80:	ef 90       	pop	r14
    3d82:	df 90       	pop	r13
    3d84:	cf 90       	pop	r12
    3d86:	08 95       	ret

00003d88 <__mulsi3>:
    3d88:	db 01       	movw	r26, r22
    3d8a:	8f 93       	push	r24
    3d8c:	9f 93       	push	r25
    3d8e:	0e 94 1e 1f 	call	0x3e3c	; 0x3e3c <__muluhisi3>
    3d92:	bf 91       	pop	r27
    3d94:	af 91       	pop	r26
    3d96:	a2 9f       	mul	r26, r18
    3d98:	80 0d       	add	r24, r0
    3d9a:	91 1d       	adc	r25, r1
    3d9c:	a3 9f       	mul	r26, r19
    3d9e:	90 0d       	add	r25, r0
    3da0:	b2 9f       	mul	r27, r18
    3da2:	90 0d       	add	r25, r0
    3da4:	11 24       	eor	r1, r1
    3da6:	08 95       	ret

00003da8 <__udivmodsi4>:
    3da8:	a1 e2       	ldi	r26, 0x21	; 33
    3daa:	1a 2e       	mov	r1, r26
    3dac:	aa 1b       	sub	r26, r26
    3dae:	bb 1b       	sub	r27, r27
    3db0:	fd 01       	movw	r30, r26
    3db2:	0d c0       	rjmp	.+26     	; 0x3dce <__udivmodsi4_ep>

00003db4 <__udivmodsi4_loop>:
    3db4:	aa 1f       	adc	r26, r26
    3db6:	bb 1f       	adc	r27, r27
    3db8:	ee 1f       	adc	r30, r30
    3dba:	ff 1f       	adc	r31, r31
    3dbc:	a2 17       	cp	r26, r18
    3dbe:	b3 07       	cpc	r27, r19
    3dc0:	e4 07       	cpc	r30, r20
    3dc2:	f5 07       	cpc	r31, r21
    3dc4:	20 f0       	brcs	.+8      	; 0x3dce <__udivmodsi4_ep>
    3dc6:	a2 1b       	sub	r26, r18
    3dc8:	b3 0b       	sbc	r27, r19
    3dca:	e4 0b       	sbc	r30, r20
    3dcc:	f5 0b       	sbc	r31, r21

00003dce <__udivmodsi4_ep>:
    3dce:	66 1f       	adc	r22, r22
    3dd0:	77 1f       	adc	r23, r23
    3dd2:	88 1f       	adc	r24, r24
    3dd4:	99 1f       	adc	r25, r25
    3dd6:	1a 94       	dec	r1
    3dd8:	69 f7       	brne	.-38     	; 0x3db4 <__udivmodsi4_loop>
    3dda:	60 95       	com	r22
    3ddc:	70 95       	com	r23
    3dde:	80 95       	com	r24
    3de0:	90 95       	com	r25
    3de2:	9b 01       	movw	r18, r22
    3de4:	ac 01       	movw	r20, r24
    3de6:	bd 01       	movw	r22, r26
    3de8:	cf 01       	movw	r24, r30
    3dea:	08 95       	ret

00003dec <__divmodsi4>:
    3dec:	05 2e       	mov	r0, r21
    3dee:	97 fb       	bst	r25, 7
    3df0:	1e f4       	brtc	.+6      	; 0x3df8 <__divmodsi4+0xc>
    3df2:	00 94       	com	r0
    3df4:	0e 94 0d 1f 	call	0x3e1a	; 0x3e1a <__negsi2>
    3df8:	57 fd       	sbrc	r21, 7
    3dfa:	07 d0       	rcall	.+14     	; 0x3e0a <__divmodsi4_neg2>
    3dfc:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <__udivmodsi4>
    3e00:	07 fc       	sbrc	r0, 7
    3e02:	03 d0       	rcall	.+6      	; 0x3e0a <__divmodsi4_neg2>
    3e04:	4e f4       	brtc	.+18     	; 0x3e18 <__divmodsi4_exit>
    3e06:	0c 94 0d 1f 	jmp	0x3e1a	; 0x3e1a <__negsi2>

00003e0a <__divmodsi4_neg2>:
    3e0a:	50 95       	com	r21
    3e0c:	40 95       	com	r20
    3e0e:	30 95       	com	r19
    3e10:	21 95       	neg	r18
    3e12:	3f 4f       	sbci	r19, 0xFF	; 255
    3e14:	4f 4f       	sbci	r20, 0xFF	; 255
    3e16:	5f 4f       	sbci	r21, 0xFF	; 255

00003e18 <__divmodsi4_exit>:
    3e18:	08 95       	ret

00003e1a <__negsi2>:
    3e1a:	90 95       	com	r25
    3e1c:	80 95       	com	r24
    3e1e:	70 95       	com	r23
    3e20:	61 95       	neg	r22
    3e22:	7f 4f       	sbci	r23, 0xFF	; 255
    3e24:	8f 4f       	sbci	r24, 0xFF	; 255
    3e26:	9f 4f       	sbci	r25, 0xFF	; 255
    3e28:	08 95       	ret

00003e2a <__tablejump2__>:
    3e2a:	ee 0f       	add	r30, r30
    3e2c:	ff 1f       	adc	r31, r31
    3e2e:	88 1f       	adc	r24, r24
    3e30:	8b bf       	out	0x3b, r24	; 59
    3e32:	07 90       	elpm	r0, Z+
    3e34:	f6 91       	elpm	r31, Z
    3e36:	e0 2d       	mov	r30, r0
    3e38:	1b be       	out	0x3b, r1	; 59
    3e3a:	19 94       	eijmp

00003e3c <__muluhisi3>:
    3e3c:	0e 94 29 1f 	call	0x3e52	; 0x3e52 <__umulhisi3>
    3e40:	a5 9f       	mul	r26, r21
    3e42:	90 0d       	add	r25, r0
    3e44:	b4 9f       	mul	r27, r20
    3e46:	90 0d       	add	r25, r0
    3e48:	a4 9f       	mul	r26, r20
    3e4a:	80 0d       	add	r24, r0
    3e4c:	91 1d       	adc	r25, r1
    3e4e:	11 24       	eor	r1, r1
    3e50:	08 95       	ret

00003e52 <__umulhisi3>:
    3e52:	a2 9f       	mul	r26, r18
    3e54:	b0 01       	movw	r22, r0
    3e56:	b3 9f       	mul	r27, r19
    3e58:	c0 01       	movw	r24, r0
    3e5a:	a3 9f       	mul	r26, r19
    3e5c:	70 0d       	add	r23, r0
    3e5e:	81 1d       	adc	r24, r1
    3e60:	11 24       	eor	r1, r1
    3e62:	91 1d       	adc	r25, r1
    3e64:	b2 9f       	mul	r27, r18
    3e66:	70 0d       	add	r23, r0
    3e68:	81 1d       	adc	r24, r1
    3e6a:	11 24       	eor	r1, r1
    3e6c:	91 1d       	adc	r25, r1
    3e6e:	08 95       	ret

00003e70 <memcpy>:
    3e70:	fb 01       	movw	r30, r22
    3e72:	dc 01       	movw	r26, r24
    3e74:	02 c0       	rjmp	.+4      	; 0x3e7a <memcpy+0xa>
    3e76:	01 90       	ld	r0, Z+
    3e78:	0d 92       	st	X+, r0
    3e7a:	41 50       	subi	r20, 0x01	; 1
    3e7c:	50 40       	sbci	r21, 0x00	; 0
    3e7e:	d8 f7       	brcc	.-10     	; 0x3e76 <memcpy+0x6>
    3e80:	08 95       	ret

00003e82 <memset>:
    3e82:	dc 01       	movw	r26, r24
    3e84:	01 c0       	rjmp	.+2      	; 0x3e88 <memset+0x6>
    3e86:	6d 93       	st	X+, r22
    3e88:	41 50       	subi	r20, 0x01	; 1
    3e8a:	50 40       	sbci	r21, 0x00	; 0
    3e8c:	e0 f7       	brcc	.-8      	; 0x3e86 <memset+0x4>
    3e8e:	08 95       	ret

00003e90 <strncpy>:
    3e90:	fb 01       	movw	r30, r22
    3e92:	dc 01       	movw	r26, r24
    3e94:	41 50       	subi	r20, 0x01	; 1
    3e96:	50 40       	sbci	r21, 0x00	; 0
    3e98:	48 f0       	brcs	.+18     	; 0x3eac <strncpy+0x1c>
    3e9a:	01 90       	ld	r0, Z+
    3e9c:	0d 92       	st	X+, r0
    3e9e:	00 20       	and	r0, r0
    3ea0:	c9 f7       	brne	.-14     	; 0x3e94 <strncpy+0x4>
    3ea2:	01 c0       	rjmp	.+2      	; 0x3ea6 <strncpy+0x16>
    3ea4:	1d 92       	st	X+, r1
    3ea6:	41 50       	subi	r20, 0x01	; 1
    3ea8:	50 40       	sbci	r21, 0x00	; 0
    3eaa:	e0 f7       	brcc	.-8      	; 0x3ea4 <strncpy+0x14>
    3eac:	08 95       	ret

00003eae <ultoa>:
    3eae:	25 32       	cpi	r18, 0x25	; 37
    3eb0:	31 05       	cpc	r19, r1
    3eb2:	20 f4       	brcc	.+8      	; 0x3ebc <ultoa+0xe>
    3eb4:	22 30       	cpi	r18, 0x02	; 2
    3eb6:	10 f0       	brcs	.+4      	; 0x3ebc <ultoa+0xe>
    3eb8:	0c 94 62 1f 	jmp	0x3ec4	; 0x3ec4 <__ultoa_ncheck>
    3ebc:	fa 01       	movw	r30, r20
    3ebe:	10 82       	st	Z, r1
    3ec0:	ca 01       	movw	r24, r20
    3ec2:	08 95       	ret

00003ec4 <__ultoa_ncheck>:
    3ec4:	bb 27       	eor	r27, r27

00003ec6 <__ultoa_common>:
    3ec6:	fa 01       	movw	r30, r20
    3ec8:	a6 2f       	mov	r26, r22
    3eca:	62 17       	cp	r22, r18
    3ecc:	71 05       	cpc	r23, r1
    3ece:	81 05       	cpc	r24, r1
    3ed0:	91 05       	cpc	r25, r1
    3ed2:	33 0b       	sbc	r19, r19
    3ed4:	30 fb       	bst	r19, 0
    3ed6:	66 f0       	brts	.+24     	; 0x3ef0 <__ultoa_common+0x2a>
    3ed8:	aa 27       	eor	r26, r26
    3eda:	66 0f       	add	r22, r22
    3edc:	77 1f       	adc	r23, r23
    3ede:	88 1f       	adc	r24, r24
    3ee0:	99 1f       	adc	r25, r25
    3ee2:	aa 1f       	adc	r26, r26
    3ee4:	a2 17       	cp	r26, r18
    3ee6:	10 f0       	brcs	.+4      	; 0x3eec <__ultoa_common+0x26>
    3ee8:	a2 1b       	sub	r26, r18
    3eea:	63 95       	inc	r22
    3eec:	38 50       	subi	r19, 0x08	; 8
    3eee:	a9 f7       	brne	.-22     	; 0x3eda <__ultoa_common+0x14>
    3ef0:	a0 5d       	subi	r26, 0xD0	; 208
    3ef2:	aa 33       	cpi	r26, 0x3A	; 58
    3ef4:	08 f0       	brcs	.+2      	; 0x3ef8 <__ultoa_common+0x32>
    3ef6:	a9 5d       	subi	r26, 0xD9	; 217
    3ef8:	a1 93       	st	Z+, r26
    3efa:	36 f7       	brtc	.-52     	; 0x3ec8 <__ultoa_common+0x2>
    3efc:	b1 11       	cpse	r27, r1
    3efe:	b1 93       	st	Z+, r27
    3f00:	10 82       	st	Z, r1
    3f02:	ca 01       	movw	r24, r20
    3f04:	0c 94 a9 1f 	jmp	0x3f52	; 0x3f52 <strrev>

00003f08 <utoa>:
    3f08:	45 32       	cpi	r20, 0x25	; 37
    3f0a:	51 05       	cpc	r21, r1
    3f0c:	20 f4       	brcc	.+8      	; 0x3f16 <utoa+0xe>
    3f0e:	42 30       	cpi	r20, 0x02	; 2
    3f10:	10 f0       	brcs	.+4      	; 0x3f16 <utoa+0xe>
    3f12:	0c 94 8f 1f 	jmp	0x3f1e	; 0x3f1e <__utoa_ncheck>
    3f16:	fb 01       	movw	r30, r22
    3f18:	10 82       	st	Z, r1
    3f1a:	cb 01       	movw	r24, r22
    3f1c:	08 95       	ret

00003f1e <__utoa_ncheck>:
    3f1e:	bb 27       	eor	r27, r27

00003f20 <__utoa_common>:
    3f20:	fb 01       	movw	r30, r22
    3f22:	55 27       	eor	r21, r21
    3f24:	aa 27       	eor	r26, r26
    3f26:	88 0f       	add	r24, r24
    3f28:	99 1f       	adc	r25, r25
    3f2a:	aa 1f       	adc	r26, r26
    3f2c:	a4 17       	cp	r26, r20
    3f2e:	10 f0       	brcs	.+4      	; 0x3f34 <__utoa_common+0x14>
    3f30:	a4 1b       	sub	r26, r20
    3f32:	83 95       	inc	r24
    3f34:	50 51       	subi	r21, 0x10	; 16
    3f36:	b9 f7       	brne	.-18     	; 0x3f26 <__utoa_common+0x6>
    3f38:	a0 5d       	subi	r26, 0xD0	; 208
    3f3a:	aa 33       	cpi	r26, 0x3A	; 58
    3f3c:	08 f0       	brcs	.+2      	; 0x3f40 <__utoa_common+0x20>
    3f3e:	a9 5d       	subi	r26, 0xD9	; 217
    3f40:	a1 93       	st	Z+, r26
    3f42:	00 97       	sbiw	r24, 0x00	; 0
    3f44:	79 f7       	brne	.-34     	; 0x3f24 <__utoa_common+0x4>
    3f46:	b1 11       	cpse	r27, r1
    3f48:	b1 93       	st	Z+, r27
    3f4a:	11 92       	st	Z+, r1
    3f4c:	cb 01       	movw	r24, r22
    3f4e:	0c 94 a9 1f 	jmp	0x3f52	; 0x3f52 <strrev>

00003f52 <strrev>:
    3f52:	dc 01       	movw	r26, r24
    3f54:	fc 01       	movw	r30, r24
    3f56:	67 2f       	mov	r22, r23
    3f58:	71 91       	ld	r23, Z+
    3f5a:	77 23       	and	r23, r23
    3f5c:	e1 f7       	brne	.-8      	; 0x3f56 <strrev+0x4>
    3f5e:	32 97       	sbiw	r30, 0x02	; 2
    3f60:	04 c0       	rjmp	.+8      	; 0x3f6a <strrev+0x18>
    3f62:	7c 91       	ld	r23, X
    3f64:	6d 93       	st	X+, r22
    3f66:	70 83       	st	Z, r23
    3f68:	62 91       	ld	r22, -Z
    3f6a:	ae 17       	cp	r26, r30
    3f6c:	bf 07       	cpc	r27, r31
    3f6e:	c8 f3       	brcs	.-14     	; 0x3f62 <strrev+0x10>
    3f70:	08 95       	ret

00003f72 <_exit>:
    3f72:	f8 94       	cli

00003f74 <__stop_program>:
    3f74:	ff cf       	rjmp	.-2      	; 0x3f74 <__stop_program>
