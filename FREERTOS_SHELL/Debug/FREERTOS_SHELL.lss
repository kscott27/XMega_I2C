
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000050a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002da  00802000  000050a4  00005138  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008022da  008022da  00005412  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005412  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005444  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ac8  00000000  00000000  00005484  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001d91f  00000000  00000000  00005f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000075eb  00000000  00000000  0002386b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006d66  00000000  00000000  0002ae56  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000213c  00000000  00000000  00031bbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000726f  00000000  00000000  00033cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000acaf  00000000  00000000  0003af67  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a18  00000000  00000000  00045c16  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3b 03 	jmp	0x676	; 0x676 <__ctors_end>
       4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
       8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
       c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      10:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      14:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      18:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      1c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      20:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      24:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      28:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      2c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      30:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      34:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      38:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      3c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      40:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      44:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      48:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      4c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      50:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      54:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      58:	0c 94 56 12 	jmp	0x24ac	; 0x24ac <__vector_22>
      5c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      60:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      64:	0c 94 68 22 	jmp	0x44d0	; 0x44d0 <__vector_25>
      68:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      6c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      70:	0c 94 c6 22 	jmp	0x458c	; 0x458c <__vector_28>
      74:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      78:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      7c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      80:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      84:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      88:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      8c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      90:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      94:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      98:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      9c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      a0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      a4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      a8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      ac:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      b0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      b4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      b8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      bc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      c0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      c4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      c8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      cc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      d0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      d4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      d8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      dc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      e0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      e4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      e8:	0c 94 e0 23 	jmp	0x47c0	; 0x47c0 <__vector_58>
      ec:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      f0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      f4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      f8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
      fc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     100:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     104:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     108:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     10c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     110:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     114:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     118:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     11c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     120:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     124:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     128:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     12c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     130:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     134:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     138:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     13c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     140:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     144:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     148:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     14c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     150:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     154:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     158:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     15c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     160:	0c 94 24 23 	jmp	0x4648	; 0x4648 <__vector_88>
     164:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     168:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     16c:	0c 94 82 23 	jmp	0x4704	; 0x4704 <__vector_91>
     170:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     174:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     178:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     17c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     180:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     184:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     188:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     18c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     190:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     194:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     198:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     19c:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1a0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1a4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1a8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1ac:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1b0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1b4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1b8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1bc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1c0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1c4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1c8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1cc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1d0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1d4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1d8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1dc:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1e0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1e4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1e8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1ec:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1f0:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1f4:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1f8:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <__bad_interrupt>
     1fc:	17 20       	and	r1, r7
     1fe:	1a 20       	and	r1, r10
     200:	1d 20       	and	r1, r13
     202:	20 20       	and	r2, r0
     204:	23 20       	and	r2, r3
     206:	26 20       	and	r2, r6
     208:	28 20       	and	r2, r8
     20a:	39 20       	and	r3, r9
     20c:	41 20       	and	r4, r1
     20e:	4b 20       	and	r4, r11
     210:	49 20       	and	r4, r9

00000212 <__trampolines_start>:
     212:	0c 94 32 26 	jmp	0x4c64	; 0x4c64 <_ZN9frt_queueIiE3putERKi>
     216:	0c 94 fc 24 	jmp	0x49f8	; 0x49f8 <_ZN9frt_queueIiE10get_a_copyERi>
     21a:	0c 94 6b 1d 	jmp	0x3ad6	; 0x3ad6 <_ZN14frt_text_queue7putcharEc>
     21e:	0c 94 90 0c 	jmp	0x1920	; 0x1920 <_ZN10task_sonar3runEv>
     222:	0c 94 e4 25 	jmp	0x4bc8	; 0x4bc8 <_ZN9frt_queueIiE7ISR_putERKi>
     226:	0c 94 6c 24 	jmp	0x48d8	; 0x48d8 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     22a:	0c 94 7a 0a 	jmp	0x14f4	; 0x14f4 <_ZN9frt_queueIhE3getEPh>
     22e:	0c 94 36 15 	jmp	0x2a6c	; 0x2a6c <prvIdleTask>
     232:	0c 94 34 0b 	jmp	0x1668	; 0x1668 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     236:	0c 94 39 20 	jmp	0x4072	; 0x4072 <_ZN8emstreamlsE15ser_manipulator+0x62>
     23a:	0c 94 68 05 	jmp	0xad0	; 0xad0 <_ZN9I2CMaster10StartState11serialDebugEv>
     23e:	0c 94 4b 20 	jmp	0x4096	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
     242:	0c 94 20 26 	jmp	0x4c40	; 0x4c40 <_ZN9frt_queueIiE7butt_inERKi>
     246:	0c 94 bf 04 	jmp	0x97e	; 0x97e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     24a:	0c 94 5b 25 	jmp	0x4ab6	; 0x4ab6 <_ZN9frt_queueIjE7ISR_getEv>
     24e:	0c 94 fc 25 	jmp	0x4bf8	; 0x4bf8 <_ZN9frt_queueIjE7butt_inERKj>
     252:	0c 94 fc 05 	jmp	0xbf8	; 0xbf8 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     256:	0c 94 3b 06 	jmp	0xc76	; 0xc76 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     25a:	0c 94 3a 0a 	jmp	0x1474	; 0x1474 <_ZN9frt_queueIhE12num_items_inEv>
     25e:	0c 94 08 0b 	jmp	0x1610	; 0x1610 <_ZN9frt_queueIhE3putERKh>
     262:	0c 94 25 0a 	jmp	0x144a	; 0x144a <_ZN9frt_queueIhE13ISR_not_emptyEv>
     266:	0c 94 7d 05 	jmp	0xafa	; 0xafa <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     26a:	0c 94 50 24 	jmp	0x48a0	; 0x48a0 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     26e:	0c 94 3e 24 	jmp	0x487c	; 0x487c <_ZN9frt_queueIjE16ISR_num_items_inEv>
     272:	0c 94 9b 05 	jmp	0xb36	; 0xb36 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     276:	0c 94 ba 1f 	jmp	0x3f74	; 0x3f74 <_ZN8emstream13ready_to_sendEv>
     27a:	0c 94 f6 0a 	jmp	0x15ec	; 0x15ec <_ZN9frt_queueIhE7butt_inERKh>
     27e:	0c 94 19 04 	jmp	0x832	; 0x832 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     282:	0c 94 73 25 	jmp	0x4ae6	; 0x4ae6 <_ZN9frt_queueIiE7ISR_getEPi>
     286:	0c 94 08 25 	jmp	0x4a10	; 0x4a10 <_ZN9frt_queueIiE10get_a_copyEv>
     28a:	0c 94 49 20 	jmp	0x4092	; 0x4092 <_ZN8emstreamlsE15ser_manipulator+0x82>
     28e:	0c 94 a6 21 	jmp	0x434c	; 0x434c <_ZN5rs2327getcharEv>
     292:	0c 94 d6 03 	jmp	0x7ac	; 0x7ac <_ZN8I2CAgent11writePacketER7Command>
     296:	0c 94 af 0a 	jmp	0x155e	; 0x155e <_ZN9frt_queueIhE7ISR_getEv>
     29a:	0c 94 7e 03 	jmp	0x6fc	; 0x6fc <_ZN8I2CAgent8transmitER7Command>
     29e:	0c 94 38 03 	jmp	0x670	; 0x670 <_call_static_run_method>
     2a2:	0c 94 5a 24 	jmp	0x48b4	; 0x48b4 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2a6:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2aa:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <_ZN9frt_queueIhE16ISR_num_items_inEv>
     2ae:	0c 94 0e 26 	jmp	0x4c1c	; 0x4c1c <_ZN9frt_queueIjE3putERKj>
     2b2:	0c 94 b4 25 	jmp	0x4b68	; 0x4b68 <_ZN9frt_queueIjE7ISR_putERKj>
     2b6:	0c 94 41 20 	jmp	0x4082	; 0x4082 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ba:	0c 94 4a 25 	jmp	0x4a94	; 0x4a94 <_ZN9frt_queueIjE7ISR_getEPj>
     2be:	0c 94 1a 20 	jmp	0x4034	; 0x4034 <_ZN8emstreamlsE15ser_manipulator+0x24>
     2c2:	0c 94 15 04 	jmp	0x82a	; 0x82a <_ZN9I2CMaster9DoneState7executeER6Packet>
     2c6:	0c 94 c1 1f 	jmp	0x3f82	; 0x3f82 <_ZN8emstream12transmit_nowEv>
     2ca:	0c 94 14 05 	jmp	0xa28	; 0xa28 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     2ce:	0c 94 d5 24 	jmp	0x49aa	; 0x49aa <_ZN9frt_queueIjE3getEPj>
     2d2:	0c 94 23 1f 	jmp	0x3e46	; 0x3e46 <__cxa_pure_virtual>
     2d6:	0c 94 ba 24 	jmp	0x4974	; 0x4974 <_ZN9frt_queueIjE10get_a_copyEv>
     2da:	0c 94 1d 20 	jmp	0x403a	; 0x403a <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2de:	0c 94 1d 04 	jmp	0x83a	; 0x83a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2e2:	0c 94 f8 1b 	jmp	0x37f0	; 0x37f0 <_ZN8frt_task12print_statusER8emstream>
     2e6:	0c 94 ae 24 	jmp	0x495c	; 0x495c <_ZN9frt_queueIjE10get_a_copyERj>
     2ea:	0c 94 e1 24 	jmp	0x49c2	; 0x49c2 <_ZN9frt_queueIjE3getEv>
     2ee:	0c 94 26 20 	jmp	0x404c	; 0x404c <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2f2:	0c 94 c2 1f 	jmp	0x3f84	; 0x3f84 <_ZN8emstream12clear_screenEv>
     2f6:	0c 94 62 0a 	jmp	0x14c4	; 0x14c4 <_ZN9frt_queueIhE10get_a_copyEv>
     2fa:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <_ZN14frt_text_queue14check_for_charEv>
     2fe:	0c 94 ab 03 	jmp	0x756	; 0x756 <_ZN8I2CAgent7receiveEv>
     302:	0c 94 df 21 	jmp	0x43be	; 0x43be <_ZN5rs23212clear_screenEv>
     306:	0c 94 de 26 	jmp	0x4dbc	; 0x4dbc <_GLOBAL__sub_I_counter>
     30a:	0c 94 88 24 	jmp	0x4910	; 0x4910 <_ZN9frt_queueIjE8is_emptyEv>
     30e:	0c 94 3e 05 	jmp	0xa7c	; 0xa7c <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     312:	0c 94 17 20 	jmp	0x402e	; 0x402e <_ZN8emstreamlsE15ser_manipulator+0x1e>
     316:	0c 94 bf 1f 	jmp	0x3f7e	; 0x3f7e <_ZN8emstream14check_for_charEv>
     31a:	0c 94 7d 24 	jmp	0x48fa	; 0x48fa <_ZN9frt_queueIjE9not_emptyEv>
     31e:	0c 94 42 1d 	jmp	0x3a84	; 0x3a84 <_ZN14frt_text_queue7getcharEv>
     322:	0c 94 84 25 	jmp	0x4b08	; 0x4b08 <_ZN9frt_queueIiE7ISR_getEv>
     326:	0c 94 28 20 	jmp	0x4050	; 0x4050 <_ZN8emstreamlsE15ser_manipulator+0x40>
     32a:	0c 94 20 20 	jmp	0x4040	; 0x4040 <_ZN8emstreamlsE15ser_manipulator+0x30>
     32e:	0c 94 bc 1f 	jmp	0x3f78	; 0x3f78 <_ZN8emstream7getcharEv>
     332:	0c 94 76 24 	jmp	0x48ec	; 0x48ec <_ZN9frt_queueIjE12num_items_inEv>
     336:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     33a:	0c 94 9c 25 	jmp	0x4b38	; 0x4b38 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     33e:	0c 94 27 0b 	jmp	0x164e	; 0x164e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     342:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <_ZN9frt_queueIhE8is_emptyEv>
     346:	0c 94 cc 25 	jmp	0x4b98	; 0x4b98 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     34a:	0c 94 92 24 	jmp	0x4924	; 0x4924 <_ZN9frt_queueIiE12num_items_inEv>
     34e:	0c 94 99 24 	jmp	0x4932	; 0x4932 <_ZN9frt_queueIiE9not_emptyEv>
     352:	0c 94 45 24 	jmp	0x488a	; 0x488a <_ZN9frt_queueIjE13ISR_not_emptyEv>
     356:	0c 94 b9 05 	jmp	0xb72	; 0xb72 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     35a:	0c 94 08 04 	jmp	0x810	; 0x810 <_ZN8I2CAgent11resetPacketER6Packet>
     35e:	0c 94 73 03 	jmp	0x6e6	; 0x6e6 <_ZN8I2CAgent10readPacketEv>
     362:	0c 94 23 25 	jmp	0x4a46	; 0x4a46 <_ZN9frt_queueIiE3getEPi>
     366:	0c 94 29 05 	jmp	0xa52	; 0xa52 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     36a:	0c 94 32 0e 	jmp	0x1c64	; 0x1c64 <_ZN9task_user3runEv>
     36e:	0c 94 41 0b 	jmp	0x1682	; 0x1682 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     372:	0c 94 61 24 	jmp	0x48c2	; 0x48c2 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     376:	0c 94 ea 04 	jmp	0x9d4	; 0x9d4 <_ZN9I2CMaster10ErrorState11serialDebugEv>
     37a:	0c 94 82 21 	jmp	0x4304	; 0x4304 <_ZN5rs2327putcharEc>
     37e:	0c 94 9e 0a 	jmp	0x153c	; 0x153c <_ZN9frt_queueIhE7ISR_getEPh>
     382:	0c 94 56 0a 	jmp	0x14ac	; 0x14ac <_ZN9frt_queueIhE10get_a_copyERh>
     386:	0c 94 ff 04 	jmp	0x9fe	; 0x9fe <_ZN9I2CMaster9DoneState11serialDebugEv>
     38a:	0c 94 53 05 	jmp	0xaa6	; 0xaa6 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     38e:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <_ZN9frt_queueIhE11ISR_butt_inERKh>
     392:	0c 94 cc 21 	jmp	0x4398	; 0x4398 <_ZN5rs23214check_for_charEv>
     396:	0c 94 1a 0b 	jmp	0x1634	; 0x1634 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     39a:	0c 94 41 0a 	jmp	0x1482	; 0x1482 <_ZN9frt_queueIhE9not_emptyEv>
     39e:	0c 94 2f 25 	jmp	0x4a5e	; 0x4a5e <_ZN9frt_queueIiE3getEv>
     3a2:	0c 94 86 0a 	jmp	0x150c	; 0x150c <_ZN9frt_queueIhE3getEv>
     3a6:	0c 94 de 0a 	jmp	0x15bc	; 0x15bc <_ZN9frt_queueIhE7ISR_putERKh>
     3aa:	0c 94 23 20 	jmp	0x4046	; 0x4046 <_ZN8emstreamlsE15ser_manipulator+0x36>
     3ae:	0c 94 a4 24 	jmp	0x4948	; 0x4948 <_ZN9frt_queueIiE8is_emptyEv>
     3b2:	0c 94 c2 08 	jmp	0x1184	; 0x1184 <_ZN9I2CMaster10StartState7executeER6Packet>

000003b6 <__trampolines_end>:
     3b6:	53 6f       	ori	r21, 0xF3	; 243
     3b8:	6e 61       	ori	r22, 0x1E	; 30
     3ba:	72 3a       	cpi	r23, 0xA2	; 162
     3bc:	20 00       	.word	0x0020	; ????

000003be <_ZZN9task_user11show_statusEvE3__c_4>:
     3be:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

000003c9 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c9:	2f 00                                               /.

000003cb <_ZZN9task_user11show_statusEvE3__c_2>:
     3cb:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d9 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d9:	54 69 6d 65 3a 20 00                                Time: .

000003e0 <_ZZN9task_user11show_statusEvE3__c_0>:
     3e0:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003ec <_ZZN9task_user11show_statusEvE3__c>:
     3ec:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3fc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000040b <_ZZN9task_user18print_help_messageEvE3__c_10>:
     40b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000041a <_ZZN9task_user18print_help_messageEvE3__c_9>:
     41a:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     42a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000435 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     435:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     445:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000453 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     453:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     463:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     473:	6d 61 74 69 6f 6e 00                                mation.

0000047a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     47a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     48a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000049b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     49b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4ab:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004b3 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4b3:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4c3:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004cf <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4cf:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4df:	68 65 20 41 56 52 00                                he AVR.

000004e6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4e6:	20 68 65 6c 70 00                                    help.

000004ec <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4ec:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4fc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000050b <_ZZN9task_user18print_help_messageEvE3__c_0>:
     50b:	1b 5b 33 30 6d 00                                   .[30m.

00000511 <_ZZN9task_user18print_help_messageEvE3__c>:
     511:	1b 5b 34 36 6d 00                                   .[46m.

00000517 <_ZZN9task_user3runEvE3__c_3>:
     517:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     527:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000534 <_ZZN9task_user3runEvE3__c_2>:
     534:	3a 57 54 46 3f 00                                   :WTF?.

0000053a <_ZZN9task_user3runEvE3__c_1>:
     53a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     54a:	65 00                                               e.

0000054c <_ZZN9task_user3runEvE3__c_0>:
     54c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000055a <_ZZN9task_user3runEvE3__c>:
     55a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     56a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000578 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     578:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000582 <_ZZN8frt_task15emergency_resetEvE3__c>:
     582:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000591 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     591:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     5a1:	61 73 6b 20 00                                      ask .

000005a6 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     5a6:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005b4 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5b4:	20 63 72 65 61 74 65 64 00                           created.

000005bd <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5bd:	54 61 73 6b 20 00                                   Task .

000005c3 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5c3:	1b 5b 32 32 6d 00                                   .[22m.

000005c9 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c9:	54 61 73 6b 3a 20 00                                Task: .

000005d0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5d0:	1b 5b 31 6d 00                                      .[1m.

000005d5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5d5:	1b 5b 32 32 6d 00                                   .[22m.

000005db <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5db:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005e6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5e6:	1b 5b 31 6d 00                                      .[1m.

000005eb <_ZZ15print_task_listP8emstreamE3__c_9>:
     5eb:	09 09 00                                            ...

000005ee <_ZZ15print_task_listP8emstreamE3__c_8>:
     5ee:	2f 00                                               /.

000005f0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5f0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005fb <_ZZ15print_task_listP8emstreamE3__c_6>:
     5fb:	09 2d 2d 2d 2d 00                                   .----.

00000601 <_ZZ15print_task_listP8emstreamE3__c_5>:
     601:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000060d <_ZZ15print_task_listP8emstreamE3__c_4>:
     60d:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000061e <_ZZ15print_task_listP8emstreamE3__c_3>:
     61e:	09 52 75 6e 73 00                                   .Runs.

00000624 <_ZZ15print_task_listP8emstreamE3__c_2>:
     624:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000630 <_ZZ15print_task_listP8emstreamE3__c_1>:
     630:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000641 <_ZZ15print_task_listP8emstreamE3__c_0>:
     641:	09 53 74 61 63 6b 00                                .Stack.

00000648 <_ZZ15print_task_listP8emstreamE3__c>:
     648:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     653:	09 00                                               ..

00000655 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     655:	09 00                                               ..

00000657 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     657:	2f 00                                               /.

00000659 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     659:	09 00                                               ..

0000065b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     65b:	09 00                                               ..

0000065d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     65d:	1b 5b 32 32 6d 00                                   .[22m.

00000663 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     663:	1b 5b 31 6d 00                                      .[1m.

00000668 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     668:	1b 5b 31 6d 00                                      .[1m.

0000066d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     66d:	20 20 00                                              .

00000670 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     670:	0e 94 90 1a 	call	0x3520	; 0x3520 <_ZN8frt_task22_call_users_run_methodEPS_>

00000674 <__ctors_start>:
     674:	de 26       	eor	r13, r30

00000676 <__ctors_end>:
     676:	11 24       	eor	r1, r1
     678:	1f be       	out	0x3f, r1	; 63
     67a:	cf ef       	ldi	r28, 0xFF	; 255
     67c:	cd bf       	out	0x3d, r28	; 61
     67e:	df e3       	ldi	r29, 0x3F	; 63
     680:	de bf       	out	0x3e, r29	; 62
     682:	00 e0       	ldi	r16, 0x00	; 0
     684:	0c bf       	out	0x3c, r16	; 60
     686:	18 be       	out	0x38, r1	; 56
     688:	19 be       	out	0x39, r1	; 57
     68a:	1a be       	out	0x3a, r1	; 58
     68c:	1b be       	out	0x3b, r1	; 59

0000068e <__do_copy_data>:
     68e:	12 e2       	ldi	r17, 0x22	; 34
     690:	a0 e0       	ldi	r26, 0x00	; 0
     692:	b0 e2       	ldi	r27, 0x20	; 32
     694:	e4 ea       	ldi	r30, 0xA4	; 164
     696:	f0 e5       	ldi	r31, 0x50	; 80
     698:	00 e0       	ldi	r16, 0x00	; 0
     69a:	0b bf       	out	0x3b, r16	; 59
     69c:	02 c0       	rjmp	.+4      	; 0x6a2 <__do_copy_data+0x14>
     69e:	07 90       	elpm	r0, Z+
     6a0:	0d 92       	st	X+, r0
     6a2:	aa 3d       	cpi	r26, 0xDA	; 218
     6a4:	b1 07       	cpc	r27, r17
     6a6:	d9 f7       	brne	.-10     	; 0x69e <__do_copy_data+0x10>
     6a8:	1b be       	out	0x3b, r1	; 59

000006aa <__do_clear_bss>:
     6aa:	23 e3       	ldi	r18, 0x33	; 51
     6ac:	aa ed       	ldi	r26, 0xDA	; 218
     6ae:	b2 e2       	ldi	r27, 0x22	; 34
     6b0:	01 c0       	rjmp	.+2      	; 0x6b4 <.do_clear_bss_start>

000006b2 <.do_clear_bss_loop>:
     6b2:	1d 92       	st	X+, r1

000006b4 <.do_clear_bss_start>:
     6b4:	a8 3a       	cpi	r26, 0xA8	; 168
     6b6:	b2 07       	cpc	r27, r18
     6b8:	e1 f7       	brne	.-8      	; 0x6b2 <.do_clear_bss_loop>

000006ba <__do_global_ctors>:
     6ba:	13 e0       	ldi	r17, 0x03	; 3
     6bc:	cb e3       	ldi	r28, 0x3B	; 59
     6be:	d3 e0       	ldi	r29, 0x03	; 3
     6c0:	00 e0       	ldi	r16, 0x00	; 0
     6c2:	06 c0       	rjmp	.+12     	; 0x6d0 <__do_global_ctors+0x16>
     6c4:	21 97       	sbiw	r28, 0x01	; 1
     6c6:	01 09       	sbc	r16, r1
     6c8:	80 2f       	mov	r24, r16
     6ca:	fe 01       	movw	r30, r28
     6cc:	0e 94 ac 27 	call	0x4f58	; 0x4f58 <__tablejump2__>
     6d0:	ca 33       	cpi	r28, 0x3A	; 58
     6d2:	d1 07       	cpc	r29, r17
     6d4:	80 e0       	ldi	r24, 0x00	; 0
     6d6:	08 07       	cpc	r16, r24
     6d8:	a9 f7       	brne	.-22     	; 0x6c4 <__do_global_ctors+0xa>
     6da:	0e 94 59 26 	call	0x4cb2	; 0x4cb2 <main>
     6de:	0c 94 50 28 	jmp	0x50a0	; 0x50a0 <_exit>

000006e2 <__bad_interrupt>:
     6e2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006e6 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6e6:	bc 01       	movw	r22, r24
     6e8:	6e 5f       	subi	r22, 0xFE	; 254
     6ea:	7f 4f       	sbci	r23, 0xFF	; 255
     6ec:	dc 01       	movw	r26, r24
     6ee:	ed 91       	ld	r30, X+
     6f0:	fc 91       	ld	r31, X
     6f2:	00 84       	ldd	r0, Z+8	; 0x08
     6f4:	f1 85       	ldd	r31, Z+9	; 0x09
     6f6:	e0 2d       	mov	r30, r0
     6f8:	19 95       	eicall
     6fa:	08 95       	ret

000006fc <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6fc:	ef 92       	push	r14
     6fe:	ff 92       	push	r15
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	ec 01       	movw	r28, r24
     70a:	7b 01       	movw	r14, r22
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream *    getSerial()       { return p_serial; }
     70c:	ea 8d       	ldd	r30, Y+26	; 0x1a
     70e:	fb 8d       	ldd	r31, Y+27	; 0x1b
     710:	06 81       	ldd	r16, Z+6	; 0x06
     712:	17 81       	ldd	r17, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     714:	66 e0       	ldi	r22, 0x06	; 6
     716:	70 e2       	ldi	r23, 0x20	; 32
     718:	c8 01       	movw	r24, r16
     71a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
  *(driver_->getSerial()) << "trans" << endl;
     71e:	66 e0       	ldi	r22, 0x06	; 6
     720:	c8 01       	movw	r24, r16
     722:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
  writePacket(cmd);
     726:	e8 81       	ld	r30, Y
     728:	f9 81       	ldd	r31, Y+1	; 0x01
     72a:	04 80       	ldd	r0, Z+4	; 0x04
     72c:	f5 81       	ldd	r31, Z+5	; 0x05
     72e:	e0 2d       	mov	r30, r0
     730:	b7 01       	movw	r22, r14
     732:	ce 01       	movw	r24, r28
     734:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     736:	be 01       	movw	r22, r28
     738:	63 5f       	subi	r22, 0xF3	; 243
     73a:	7f 4f       	sbci	r23, 0xFF	; 255
  };

  // I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     73c:	ea 8d       	ldd	r30, Y+26	; 0x1a
     73e:	fb 8d       	ldd	r31, Y+27	; 0x1b
     740:	80 81       	ld	r24, Z
     742:	91 81       	ldd	r25, Z+1	; 0x01
     744:	0e 94 11 08 	call	0x1022	; 0x1022 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     748:	df 91       	pop	r29
     74a:	cf 91       	pop	r28
     74c:	1f 91       	pop	r17
     74e:	0f 91       	pop	r16
     750:	ff 90       	pop	r15
     752:	ef 90       	pop	r14
     754:	08 95       	ret

00000756 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     756:	ef 92       	push	r14
     758:	ff 92       	push	r15
     75a:	0f 93       	push	r16
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     762:	7c 01       	movw	r14, r24
     764:	82 e0       	ldi	r24, 0x02	; 2
     766:	e8 0e       	add	r14, r24
     768:	f1 1c       	adc	r15, r1
     76a:	e8 81       	ld	r30, Y
     76c:	f9 81       	ldd	r31, Y+1	; 0x01
     76e:	00 84       	ldd	r0, Z+8	; 0x08
     770:	f1 85       	ldd	r31, Z+9	; 0x09
     772:	e0 2d       	mov	r30, r0
     774:	b7 01       	movw	r22, r14
     776:	ce 01       	movw	r24, r28
     778:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     77a:	28 85       	ldd	r18, Y+8	; 0x08
     77c:	39 85       	ldd	r19, Y+9	; 0x09
     77e:	4a 85       	ldd	r20, Y+10	; 0x0a
     780:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     782:	be 01       	movw	r22, r28
     784:	62 5e       	subi	r22, 0xE2	; 226
     786:	7f 4f       	sbci	r23, 0xFF	; 255
     788:	00 e0       	ldi	r16, 0x00	; 0
     78a:	8e 81       	ldd	r24, Y+6	; 0x06
     78c:	9f 81       	ldd	r25, Y+7	; 0x07
     78e:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     792:	ea 8d       	ldd	r30, Y+26	; 0x1a
     794:	fb 8d       	ldd	r31, Y+27	; 0x1b
  return driver_->getReceiver()->run(inPacket_);
     796:	b7 01       	movw	r22, r14
     798:	82 81       	ldd	r24, Z+2	; 0x02
     79a:	93 81       	ldd	r25, Z+3	; 0x03
     79c:	0e 94 53 08 	call	0x10a6	; 0x10a6 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     7a0:	df 91       	pop	r29
     7a2:	cf 91       	pop	r28
     7a4:	0f 91       	pop	r16
     7a6:	ff 90       	pop	r15
     7a8:	ef 90       	pop	r14
     7aa:	08 95       	ret

000007ac <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     7ac:	cf 92       	push	r12
     7ae:	df 92       	push	r13
     7b0:	ef 92       	push	r14
     7b2:	ff 92       	push	r15
     7b4:	0f 93       	push	r16
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
     7ba:	ec 01       	movw	r28, r24
     7bc:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     7be:	6c 01       	movw	r12, r24
     7c0:	8d e0       	ldi	r24, 0x0D	; 13
     7c2:	c8 0e       	add	r12, r24
     7c4:	d1 1c       	adc	r13, r1
     7c6:	e8 81       	ld	r30, Y
     7c8:	f9 81       	ldd	r31, Y+1	; 0x01
     7ca:	00 84       	ldd	r0, Z+8	; 0x08
     7cc:	f1 85       	ldd	r31, Z+9	; 0x09
     7ce:	e0 2d       	mov	r30, r0
     7d0:	b6 01       	movw	r22, r12
     7d2:	ce 01       	movw	r24, r28
     7d4:	19 95       	eicall
     7d6:	2b 89       	ldd	r18, Y+19	; 0x13
     7d8:	3c 89       	ldd	r19, Y+20	; 0x14
     7da:	4d 89       	ldd	r20, Y+21	; 0x15
     7dc:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7de:	be 01       	movw	r22, r28
     7e0:	63 5e       	subi	r22, 0xE3	; 227
     7e2:	7f 4f       	sbci	r23, 0xFF	; 255
     7e4:	00 e0       	ldi	r16, 0x00	; 0
     7e6:	89 89       	ldd	r24, Y+17	; 0x11
     7e8:	9a 89       	ldd	r25, Y+18	; 0x12
     7ea:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7ee:	d7 01       	movw	r26, r14
     7f0:	ed 91       	ld	r30, X+
     7f2:	fc 91       	ld	r31, X
     7f4:	01 90       	ld	r0, Z+
     7f6:	f0 81       	ld	r31, Z
     7f8:	e0 2d       	mov	r30, r0
     7fa:	b6 01       	movw	r22, r12
     7fc:	c7 01       	movw	r24, r14
     7fe:	19 95       	eicall
}
     800:	df 91       	pop	r29
     802:	cf 91       	pop	r28
     804:	0f 91       	pop	r16
     806:	ff 90       	pop	r15
     808:	ef 90       	pop	r14
     80a:	df 90       	pop	r13
     80c:	cf 90       	pop	r12
     80e:	08 95       	ret

00000810 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     810:	cb 01       	movw	r24, r22
  packet.resetContent();
     812:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <_ZN6Packet12resetContentEv>
     816:	08 95       	ret

00000818 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     818:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     81a:	64 8f       	std	Z+28, r22	; 0x1c
  writeCommand_ = addr << 1;
     81c:	86 2f       	mov	r24, r22
     81e:	88 0f       	add	r24, r24
     820:	85 8f       	std	Z+29, r24	; 0x1d
  readCommand_ = addr << 1 | 1 << 0;
     822:	68 2f       	mov	r22, r24
     824:	61 60       	ori	r22, 0x01	; 1
     826:	66 8f       	std	Z+30, r22	; 0x1e
     828:	08 95       	ret

0000082a <_ZN9I2CMaster9DoneState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     82a:	fc 01       	movw	r30, r24
     82c:	82 81       	ldd	r24, Z+2	; 0x02
     82e:	93 81       	ldd	r25, Z+3	; 0x03
     830:	08 95       	ret

00000832 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     832:	fc 01       	movw	r30, r24
     834:	82 81       	ldd	r24, Z+2	; 0x02
     836:	93 81       	ldd	r25, Z+3	; 0x03
     838:	08 95       	ret

0000083a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     83a:	ef 92       	push	r14
     83c:	ff 92       	push	r15
     83e:	0f 93       	push	r16
     840:	1f 93       	push	r17
     842:	cf 93       	push	r28
     844:	df 93       	push	r29
     846:	1f 92       	push	r1
     848:	1f 92       	push	r1
     84a:	cd b7       	in	r28, 0x3d	; 61
     84c:	de b7       	in	r29, 0x3e	; 62
     84e:	8c 01       	movw	r16, r24
     850:	dc 01       	movw	r26, r24
     852:	17 96       	adiw	r26, 0x07	; 7
     854:	ed 91       	ld	r30, X+
     856:	fc 91       	ld	r31, X
     858:	18 97       	sbiw	r26, 0x08	; 8
     85a:	e6 80       	ldd	r14, Z+6	; 0x06
     85c:	f7 80       	ldd	r15, Z+7	; 0x07
     85e:	6a e1       	ldi	r22, 0x1A	; 26
     860:	70 e2       	ldi	r23, 0x20	; 32
     862:	c7 01       	movw	r24, r14
     864:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     868:	66 e0       	ldi	r22, 0x06	; 6
     86a:	c7 01       	movw	r24, r14
     86c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     870:	f8 01       	movw	r30, r16
     872:	81 85       	ldd	r24, Z+9	; 0x09
     874:	92 85       	ldd	r25, Z+10	; 0x0a
     876:	89 83       	std	Y+1, r24	; 0x01
     878:	9a 83       	std	Y+2, r25	; 0x02
     87a:	89 81       	ldd	r24, Y+1	; 0x01
     87c:	9a 81       	ldd	r25, Y+2	; 0x02
     87e:	01 97       	sbiw	r24, 0x01	; 1
     880:	89 83       	std	Y+1, r24	; 0x01
     882:	9a 83       	std	Y+2, r25	; 0x02
     884:	89 2b       	or	r24, r25
     886:	59 f0       	breq	.+22     	; 0x89e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x64>
     888:	d8 01       	movw	r26, r16
     88a:	17 96       	adiw	r26, 0x07	; 7
     88c:	ed 91       	ld	r30, X+
     88e:	fc 91       	ld	r31, X
     890:	18 97       	sbiw	r26, 0x08	; 8
     892:	04 80       	ldd	r0, Z+4	; 0x04
     894:	f5 81       	ldd	r31, Z+5	; 0x05
     896:	e0 2d       	mov	r30, r0
     898:	84 81       	ldd	r24, Z+4	; 0x04
     89a:	86 ff       	sbrs	r24, 6
     89c:	ee cf       	rjmp	.-36     	; 0x87a <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x40>
     89e:	d8 01       	movw	r26, r16
     8a0:	17 96       	adiw	r26, 0x07	; 7
     8a2:	ed 91       	ld	r30, X+
     8a4:	fc 91       	ld	r31, X
     8a6:	18 97       	sbiw	r26, 0x08	; 8
     8a8:	04 80       	ldd	r0, Z+4	; 0x04
     8aa:	f5 81       	ldd	r31, Z+5	; 0x05
     8ac:	e0 2d       	mov	r30, r0
     8ae:	84 81       	ldd	r24, Z+4	; 0x04
     8b0:	84 fd       	sbrc	r24, 4
     8b2:	08 c0       	rjmp	.+16     	; 0x8c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x8a>
     8b4:	84 81       	ldd	r24, Z+4	; 0x04
     8b6:	86 ff       	sbrs	r24, 6
     8b8:	05 c0       	rjmp	.+10     	; 0x8c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x8a>
     8ba:	12 96       	adiw	r26, 0x02	; 2
     8bc:	8d 91       	ld	r24, X+
     8be:	9c 91       	ld	r25, X
     8c0:	13 97       	sbiw	r26, 0x03	; 3
     8c2:	03 c0       	rjmp	.+6      	; 0x8ca <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x90>
     8c4:	f8 01       	movw	r30, r16
     8c6:	84 81       	ldd	r24, Z+4	; 0x04
     8c8:	95 81       	ldd	r25, Z+5	; 0x05
     8ca:	0f 90       	pop	r0
     8cc:	0f 90       	pop	r0
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	1f 91       	pop	r17
     8d4:	0f 91       	pop	r16
     8d6:	ff 90       	pop	r15
     8d8:	ef 90       	pop	r14
     8da:	08 95       	ret

000008dc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     8dc:	ef 92       	push	r14
     8de:	ff 92       	push	r15
     8e0:	0f 93       	push	r16
     8e2:	1f 93       	push	r17
     8e4:	cf 93       	push	r28
     8e6:	df 93       	push	r29
     8e8:	1f 92       	push	r1
     8ea:	1f 92       	push	r1
     8ec:	cd b7       	in	r28, 0x3d	; 61
     8ee:	de b7       	in	r29, 0x3e	; 62
     8f0:	8c 01       	movw	r16, r24
     8f2:	dc 01       	movw	r26, r24
     8f4:	17 96       	adiw	r26, 0x07	; 7
     8f6:	ed 91       	ld	r30, X+
     8f8:	fc 91       	ld	r31, X
     8fa:	18 97       	sbiw	r26, 0x08	; 8
     8fc:	e6 80       	ldd	r14, Z+6	; 0x06
     8fe:	f7 80       	ldd	r15, Z+7	; 0x07
     900:	63 e2       	ldi	r22, 0x23	; 35
     902:	70 e2       	ldi	r23, 0x20	; 32
     904:	c7 01       	movw	r24, r14
     906:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     90a:	66 e0       	ldi	r22, 0x06	; 6
     90c:	c7 01       	movw	r24, r14
     90e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     912:	f8 01       	movw	r30, r16
     914:	81 85       	ldd	r24, Z+9	; 0x09
     916:	92 85       	ldd	r25, Z+10	; 0x0a
     918:	89 83       	std	Y+1, r24	; 0x01
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	89 81       	ldd	r24, Y+1	; 0x01
     91e:	9a 81       	ldd	r25, Y+2	; 0x02
     920:	01 97       	sbiw	r24, 0x01	; 1
     922:	89 83       	std	Y+1, r24	; 0x01
     924:	9a 83       	std	Y+2, r25	; 0x02
     926:	89 2b       	or	r24, r25
     928:	59 f0       	breq	.+22     	; 0x940 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x64>
     92a:	d8 01       	movw	r26, r16
     92c:	17 96       	adiw	r26, 0x07	; 7
     92e:	ed 91       	ld	r30, X+
     930:	fc 91       	ld	r31, X
     932:	18 97       	sbiw	r26, 0x08	; 8
     934:	04 80       	ldd	r0, Z+4	; 0x04
     936:	f5 81       	ldd	r31, Z+5	; 0x05
     938:	e0 2d       	mov	r30, r0
     93a:	84 81       	ldd	r24, Z+4	; 0x04
     93c:	88 23       	and	r24, r24
     93e:	74 f7       	brge	.-36     	; 0x91c <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x40>
     940:	d8 01       	movw	r26, r16
     942:	17 96       	adiw	r26, 0x07	; 7
     944:	ed 91       	ld	r30, X+
     946:	fc 91       	ld	r31, X
     948:	18 97       	sbiw	r26, 0x08	; 8
     94a:	04 80       	ldd	r0, Z+4	; 0x04
     94c:	f5 81       	ldd	r31, Z+5	; 0x05
     94e:	e0 2d       	mov	r30, r0
     950:	84 81       	ldd	r24, Z+4	; 0x04
     952:	84 fd       	sbrc	r24, 4
     954:	08 c0       	rjmp	.+16     	; 0x966 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x8a>
     956:	84 81       	ldd	r24, Z+4	; 0x04
     958:	88 23       	and	r24, r24
     95a:	2c f4       	brge	.+10     	; 0x966 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x8a>
     95c:	12 96       	adiw	r26, 0x02	; 2
     95e:	8d 91       	ld	r24, X+
     960:	9c 91       	ld	r25, X
     962:	13 97       	sbiw	r26, 0x03	; 3
     964:	03 c0       	rjmp	.+6      	; 0x96c <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x90>
     966:	f8 01       	movw	r30, r16
     968:	84 81       	ldd	r24, Z+4	; 0x04
     96a:	95 81       	ldd	r25, Z+5	; 0x05
     96c:	0f 90       	pop	r0
     96e:	0f 90       	pop	r0
     970:	df 91       	pop	r29
     972:	cf 91       	pop	r28
     974:	1f 91       	pop	r17
     976:	0f 91       	pop	r16
     978:	ff 90       	pop	r15
     97a:	ef 90       	pop	r14
     97c:	08 95       	ret

0000097e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     97e:	ef 92       	push	r14
     980:	ff 92       	push	r15
     982:	0f 93       	push	r16
     984:	1f 93       	push	r17
     986:	cf 93       	push	r28
     988:	df 93       	push	r29
     98a:	ec 01       	movw	r28, r24
     98c:	8b 01       	movw	r16, r22
     98e:	ef 81       	ldd	r30, Y+7	; 0x07
     990:	f8 85       	ldd	r31, Y+8	; 0x08
     992:	e6 80       	ldd	r14, Z+6	; 0x06
     994:	f7 80       	ldd	r15, Z+7	; 0x07
     996:	6c e2       	ldi	r22, 0x2C	; 44
     998:	70 e2       	ldi	r23, 0x20	; 32
     99a:	c7 01       	movw	r24, r14
     99c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     9a0:	66 e0       	ldi	r22, 0x06	; 6
     9a2:	c7 01       	movw	r24, r14
     9a4:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     9a8:	d8 01       	movw	r26, r16
     9aa:	ed 91       	ld	r30, X+
     9ac:	fc 91       	ld	r31, X
     9ae:	04 88       	ldd	r0, Z+20	; 0x14
     9b0:	f5 89       	ldd	r31, Z+21	; 0x15
     9b2:	e0 2d       	mov	r30, r0
     9b4:	c8 01       	movw	r24, r16
     9b6:	19 95       	eicall
     9b8:	88 23       	and	r24, r24
     9ba:	19 f0       	breq	.+6      	; 0x9c2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x44>
     9bc:	8a 81       	ldd	r24, Y+2	; 0x02
     9be:	9b 81       	ldd	r25, Y+3	; 0x03
     9c0:	02 c0       	rjmp	.+4      	; 0x9c6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x48>
     9c2:	8c 81       	ldd	r24, Y+4	; 0x04
     9c4:	9d 81       	ldd	r25, Y+5	; 0x05
     9c6:	df 91       	pop	r29
     9c8:	cf 91       	pop	r28
     9ca:	1f 91       	pop	r17
     9cc:	0f 91       	pop	r16
     9ce:	ff 90       	pop	r15
     9d0:	ef 90       	pop	r14
     9d2:	08 95       	ret

000009d4 <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     9d4:	cf 93       	push	r28
     9d6:	df 93       	push	r29
     9d8:	dc 01       	movw	r26, r24
     9da:	17 96       	adiw	r26, 0x07	; 7
     9dc:	ed 91       	ld	r30, X+
     9de:	fc 91       	ld	r31, X
     9e0:	18 97       	sbiw	r26, 0x08	; 8
     9e2:	c6 81       	ldd	r28, Z+6	; 0x06
     9e4:	d7 81       	ldd	r29, Z+7	; 0x07
     9e6:	66 e3       	ldi	r22, 0x36	; 54
     9e8:	70 e2       	ldi	r23, 0x20	; 32
     9ea:	ce 01       	movw	r24, r28
     9ec:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     9f0:	66 e0       	ldi	r22, 0x06	; 6
     9f2:	ce 01       	movw	r24, r28
     9f4:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <_ZN9I2CMaster9DoneState11serialDebugEv>:
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	dc 01       	movw	r26, r24
     a04:	17 96       	adiw	r26, 0x07	; 7
     a06:	ed 91       	ld	r30, X+
     a08:	fc 91       	ld	r31, X
     a0a:	18 97       	sbiw	r26, 0x08	; 8
     a0c:	c6 81       	ldd	r28, Z+6	; 0x06
     a0e:	d7 81       	ldd	r29, Z+7	; 0x07
     a10:	6c e3       	ldi	r22, 0x3C	; 60
     a12:	70 e2       	ldi	r23, 0x20	; 32
     a14:	ce 01       	movw	r24, r28
     a16:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     a1a:	66 e0       	ldi	r22, 0x06	; 6
     a1c:	ce 01       	movw	r24, r28
     a1e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	08 95       	ret

00000a28 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	dc 01       	movw	r26, r24
     a2e:	17 96       	adiw	r26, 0x07	; 7
     a30:	ed 91       	ld	r30, X+
     a32:	fc 91       	ld	r31, X
     a34:	18 97       	sbiw	r26, 0x08	; 8
     a36:	c6 81       	ldd	r28, Z+6	; 0x06
     a38:	d7 81       	ldd	r29, Z+7	; 0x07
     a3a:	61 e4       	ldi	r22, 0x41	; 65
     a3c:	70 e2       	ldi	r23, 0x20	; 32
     a3e:	ce 01       	movw	r24, r28
     a40:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     a44:	66 e0       	ldi	r22, 0x06	; 6
     a46:	ce 01       	movw	r24, r28
     a48:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a52:	cf 93       	push	r28
     a54:	df 93       	push	r29
     a56:	dc 01       	movw	r26, r24
     a58:	17 96       	adiw	r26, 0x07	; 7
     a5a:	ed 91       	ld	r30, X+
     a5c:	fc 91       	ld	r31, X
     a5e:	18 97       	sbiw	r26, 0x08	; 8
     a60:	c6 81       	ldd	r28, Z+6	; 0x06
     a62:	d7 81       	ldd	r29, Z+7	; 0x07
     a64:	6a e4       	ldi	r22, 0x4A	; 74
     a66:	70 e2       	ldi	r23, 0x20	; 32
     a68:	ce 01       	movw	r24, r28
     a6a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     a6e:	66 e0       	ldi	r22, 0x06	; 6
     a70:	ce 01       	movw	r24, r28
     a72:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     a76:	df 91       	pop	r29
     a78:	cf 91       	pop	r28
     a7a:	08 95       	ret

00000a7c <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
     a80:	dc 01       	movw	r26, r24
     a82:	17 96       	adiw	r26, 0x07	; 7
     a84:	ed 91       	ld	r30, X+
     a86:	fc 91       	ld	r31, X
     a88:	18 97       	sbiw	r26, 0x08	; 8
     a8a:	c6 81       	ldd	r28, Z+6	; 0x06
     a8c:	d7 81       	ldd	r29, Z+7	; 0x07
     a8e:	63 e5       	ldi	r22, 0x53	; 83
     a90:	70 e2       	ldi	r23, 0x20	; 32
     a92:	ce 01       	movw	r24, r28
     a94:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     a98:	66 e0       	ldi	r22, 0x06	; 6
     a9a:	ce 01       	movw	r24, r28
     a9c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	08 95       	ret

00000aa6 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	dc 01       	movw	r26, r24
     aac:	17 96       	adiw	r26, 0x07	; 7
     aae:	ed 91       	ld	r30, X+
     ab0:	fc 91       	ld	r31, X
     ab2:	18 97       	sbiw	r26, 0x08	; 8
     ab4:	c6 81       	ldd	r28, Z+6	; 0x06
     ab6:	d7 81       	ldd	r29, Z+7	; 0x07
     ab8:	6e e5       	ldi	r22, 0x5E	; 94
     aba:	70 e2       	ldi	r23, 0x20	; 32
     abc:	ce 01       	movw	r24, r28
     abe:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     ac2:	66 e0       	ldi	r22, 0x06	; 6
     ac4:	ce 01       	movw	r24, r28
     ac6:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     aca:	df 91       	pop	r29
     acc:	cf 91       	pop	r28
     ace:	08 95       	ret

00000ad0 <_ZN9I2CMaster10StartState11serialDebugEv>:
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
     ad4:	dc 01       	movw	r26, r24
     ad6:	17 96       	adiw	r26, 0x07	; 7
     ad8:	ed 91       	ld	r30, X+
     ada:	fc 91       	ld	r31, X
     adc:	18 97       	sbiw	r26, 0x08	; 8
     ade:	c6 81       	ldd	r28, Z+6	; 0x06
     ae0:	d7 81       	ldd	r29, Z+7	; 0x07
     ae2:	69 e6       	ldi	r22, 0x69	; 105
     ae4:	70 e2       	ldi	r23, 0x20	; 32
     ae6:	ce 01       	movw	r24, r28
     ae8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     aec:	66 e0       	ldi	r22, 0x06	; 6
     aee:	ce 01       	movw	r24, r28
     af0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	08 95       	ret

00000afa <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
     afa:	1f 93       	push	r17
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
     b00:	dc 01       	movw	r26, r24
     b02:	17 96       	adiw	r26, 0x07	; 7
     b04:	ed 91       	ld	r30, X+
     b06:	fc 91       	ld	r31, X
     b08:	18 97       	sbiw	r26, 0x08	; 8
     b0a:	a4 81       	ldd	r26, Z+4	; 0x04
     b0c:	b5 81       	ldd	r27, Z+5	; 0x05
     b0e:	14 96       	adiw	r26, 0x04	; 4
     b10:	1c 91       	ld	r17, X
     b12:	c6 81       	ldd	r28, Z+6	; 0x06
     b14:	d7 81       	ldd	r29, Z+7	; 0x07
     b16:	6f e6       	ldi	r22, 0x6F	; 111
     b18:	70 e2       	ldi	r23, 0x20	; 32
     b1a:	ce 01       	movw	r24, r28
     b1c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     b20:	61 2f       	mov	r22, r17
     b22:	ce 01       	movw	r24, r28
     b24:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
     b28:	66 e0       	ldi	r22, 0x06	; 6
     b2a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     b2e:	df 91       	pop	r29
     b30:	cf 91       	pop	r28
     b32:	1f 91       	pop	r17
     b34:	08 95       	ret

00000b36 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	dc 01       	movw	r26, r24
     b3e:	17 96       	adiw	r26, 0x07	; 7
     b40:	ed 91       	ld	r30, X+
     b42:	fc 91       	ld	r31, X
     b44:	18 97       	sbiw	r26, 0x08	; 8
     b46:	a4 81       	ldd	r26, Z+4	; 0x04
     b48:	b5 81       	ldd	r27, Z+5	; 0x05
     b4a:	14 96       	adiw	r26, 0x04	; 4
     b4c:	1c 91       	ld	r17, X
     b4e:	c6 81       	ldd	r28, Z+6	; 0x06
     b50:	d7 81       	ldd	r29, Z+7	; 0x07
     b52:	6a e7       	ldi	r22, 0x7A	; 122
     b54:	70 e2       	ldi	r23, 0x20	; 32
     b56:	ce 01       	movw	r24, r28
     b58:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     b5c:	61 2f       	mov	r22, r17
     b5e:	ce 01       	movw	r24, r28
     b60:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
     b64:	66 e0       	ldi	r22, 0x06	; 6
     b66:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     b6a:	df 91       	pop	r29
     b6c:	cf 91       	pop	r28
     b6e:	1f 91       	pop	r17
     b70:	08 95       	ret

00000b72 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     b72:	ef 92       	push	r14
     b74:	ff 92       	push	r15
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	8c 01       	movw	r16, r24
     b80:	eb 01       	movw	r28, r22
     b82:	e8 81       	ld	r30, Y
     b84:	f9 81       	ldd	r31, Y+1	; 0x01
     b86:	00 8c       	ldd	r0, Z+24	; 0x18
     b88:	f1 8d       	ldd	r31, Z+25	; 0x19
     b8a:	e0 2d       	mov	r30, r0
     b8c:	cb 01       	movw	r24, r22
     b8e:	19 95       	eicall
     b90:	88 23       	and	r24, r24
     b92:	41 f1       	breq	.+80     	; 0xbe4 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x72>
     b94:	e8 81       	ld	r30, Y
     b96:	f9 81       	ldd	r31, Y+1	; 0x01
     b98:	02 84       	ldd	r0, Z+10	; 0x0a
     b9a:	f3 85       	ldd	r31, Z+11	; 0x0b
     b9c:	e0 2d       	mov	r30, r0
     b9e:	e1 2c       	mov	r14, r1
     ba0:	f1 2c       	mov	r15, r1
     ba2:	b7 01       	movw	r22, r14
     ba4:	ce 01       	movw	r24, r28
     ba6:	19 95       	eicall
     ba8:	d7 01       	movw	r26, r14
     baa:	cc 91       	ld	r28, X
     bac:	d8 01       	movw	r26, r16
     bae:	17 96       	adiw	r26, 0x07	; 7
     bb0:	ed 91       	ld	r30, X+
     bb2:	fc 91       	ld	r31, X
     bb4:	18 97       	sbiw	r26, 0x08	; 8
     bb6:	e6 80       	ldd	r14, Z+6	; 0x06
     bb8:	f7 80       	ldd	r15, Z+7	; 0x07
     bba:	65 e8       	ldi	r22, 0x85	; 133
     bbc:	70 e2       	ldi	r23, 0x20	; 32
     bbe:	c7 01       	movw	r24, r14
     bc0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     bc4:	6c 2f       	mov	r22, r28
     bc6:	c7 01       	movw	r24, r14
     bc8:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
     bcc:	66 e0       	ldi	r22, 0x06	; 6
     bce:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     bd2:	d8 01       	movw	r26, r16
     bd4:	17 96       	adiw	r26, 0x07	; 7
     bd6:	ed 91       	ld	r30, X+
     bd8:	fc 91       	ld	r31, X
     bda:	18 97       	sbiw	r26, 0x08	; 8
     bdc:	04 80       	ldd	r0, Z+4	; 0x04
     bde:	f5 81       	ldd	r31, Z+5	; 0x05
     be0:	e0 2d       	mov	r30, r0
     be2:	c7 83       	std	Z+7, r28	; 0x07
     be4:	f8 01       	movw	r30, r16
     be6:	82 81       	ldd	r24, Z+2	; 0x02
     be8:	93 81       	ldd	r25, Z+3	; 0x03
     bea:	df 91       	pop	r29
     bec:	cf 91       	pop	r28
     bee:	1f 91       	pop	r17
     bf0:	0f 91       	pop	r16
     bf2:	ff 90       	pop	r15
     bf4:	ef 90       	pop	r14
     bf6:	08 95       	ret

00000bf8 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     bf8:	bf 92       	push	r11
     bfa:	cf 92       	push	r12
     bfc:	df 92       	push	r13
     bfe:	ef 92       	push	r14
     c00:	ff 92       	push	r15
     c02:	0f 93       	push	r16
     c04:	1f 93       	push	r17
     c06:	cf 93       	push	r28
     c08:	df 93       	push	r29
     c0a:	1f 92       	push	r1
     c0c:	cd b7       	in	r28, 0x3d	; 61
     c0e:	de b7       	in	r29, 0x3e	; 62
     c10:	8c 01       	movw	r16, r24
     c12:	7b 01       	movw	r14, r22
     c14:	dc 01       	movw	r26, r24
     c16:	17 96       	adiw	r26, 0x07	; 7
     c18:	ed 91       	ld	r30, X+
     c1a:	fc 91       	ld	r31, X
     c1c:	18 97       	sbiw	r26, 0x08	; 8
     c1e:	a4 81       	ldd	r26, Z+4	; 0x04
     c20:	b5 81       	ldd	r27, Z+5	; 0x05
     c22:	17 96       	adiw	r26, 0x07	; 7
     c24:	bc 90       	ld	r11, X
     c26:	b9 82       	std	Y+1, r11	; 0x01
     c28:	c6 80       	ldd	r12, Z+6	; 0x06
     c2a:	d7 80       	ldd	r13, Z+7	; 0x07
     c2c:	67 e9       	ldi	r22, 0x97	; 151
     c2e:	70 e2       	ldi	r23, 0x20	; 32
     c30:	c6 01       	movw	r24, r12
     c32:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     c36:	6b 2d       	mov	r22, r11
     c38:	c6 01       	movw	r24, r12
     c3a:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
     c3e:	66 e0       	ldi	r22, 0x06	; 6
     c40:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     c44:	d7 01       	movw	r26, r14
     c46:	ed 91       	ld	r30, X+
     c48:	fc 91       	ld	r31, X
     c4a:	01 90       	ld	r0, Z+
     c4c:	f0 81       	ld	r31, Z
     c4e:	e0 2d       	mov	r30, r0
     c50:	be 01       	movw	r22, r28
     c52:	6f 5f       	subi	r22, 0xFF	; 255
     c54:	7f 4f       	sbci	r23, 0xFF	; 255
     c56:	c7 01       	movw	r24, r14
     c58:	19 95       	eicall
     c5a:	f8 01       	movw	r30, r16
     c5c:	82 81       	ldd	r24, Z+2	; 0x02
     c5e:	93 81       	ldd	r25, Z+3	; 0x03
     c60:	0f 90       	pop	r0
     c62:	df 91       	pop	r29
     c64:	cf 91       	pop	r28
     c66:	1f 91       	pop	r17
     c68:	0f 91       	pop	r16
     c6a:	ff 90       	pop	r15
     c6c:	ef 90       	pop	r14
     c6e:	df 90       	pop	r13
     c70:	cf 90       	pop	r12
     c72:	bf 90       	pop	r11
     c74:	08 95       	ret

00000c76 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	8b 01       	movw	r16, r22
     c86:	ef 81       	ldd	r30, Y+7	; 0x07
     c88:	f8 85       	ldd	r31, Y+8	; 0x08
     c8a:	e6 80       	ldd	r14, Z+6	; 0x06
     c8c:	f7 80       	ldd	r15, Z+7	; 0x07
     c8e:	67 ea       	ldi	r22, 0xA7	; 167
     c90:	70 e2       	ldi	r23, 0x20	; 32
     c92:	c7 01       	movw	r24, r14
     c94:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     c98:	66 e0       	ldi	r22, 0x06	; 6
     c9a:	c7 01       	movw	r24, r14
     c9c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     ca0:	d8 01       	movw	r26, r16
     ca2:	ed 91       	ld	r30, X+
     ca4:	fc 91       	ld	r31, X
     ca6:	04 8c       	ldd	r0, Z+28	; 0x1c
     ca8:	f5 8d       	ldd	r31, Z+29	; 0x1d
     caa:	e0 2d       	mov	r30, r0
     cac:	c8 01       	movw	r24, r16
     cae:	19 95       	eicall
     cb0:	f8 01       	movw	r30, r16
     cb2:	22 85       	ldd	r18, Z+10	; 0x0a
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	82 17       	cp	r24, r18
     cb8:	93 07       	cpc	r25, r19
     cba:	b9 f4       	brne	.+46     	; 0xcea <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x74>
     cbc:	ef 81       	ldd	r30, Y+7	; 0x07
     cbe:	f8 85       	ldd	r31, Y+8	; 0x08
     cc0:	04 80       	ldd	r0, Z+4	; 0x04
     cc2:	f5 81       	ldd	r31, Z+5	; 0x05
     cc4:	e0 2d       	mov	r30, r0
     cc6:	87 e0       	ldi	r24, 0x07	; 7
     cc8:	83 83       	std	Z+3, r24	; 0x03
     cca:	ef 81       	ldd	r30, Y+7	; 0x07
     ccc:	f8 85       	ldd	r31, Y+8	; 0x08
     cce:	06 81       	ldd	r16, Z+6	; 0x06
     cd0:	17 81       	ldd	r17, Z+7	; 0x07
     cd2:	61 eb       	ldi	r22, 0xB1	; 177
     cd4:	70 e2       	ldi	r23, 0x20	; 32
     cd6:	c8 01       	movw	r24, r16
     cd8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     cdc:	66 e0       	ldi	r22, 0x06	; 6
     cde:	c8 01       	movw	r24, r16
     ce0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     ce4:	8a 81       	ldd	r24, Y+2	; 0x02
     ce6:	9b 81       	ldd	r25, Y+3	; 0x03
     ce8:	16 c0       	rjmp	.+44     	; 0xd16 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0xa0>
     cea:	ef 81       	ldd	r30, Y+7	; 0x07
     cec:	f8 85       	ldd	r31, Y+8	; 0x08
     cee:	04 80       	ldd	r0, Z+4	; 0x04
     cf0:	f5 81       	ldd	r31, Z+5	; 0x05
     cf2:	e0 2d       	mov	r30, r0
     cf4:	82 e0       	ldi	r24, 0x02	; 2
     cf6:	83 83       	std	Z+3, r24	; 0x03
     cf8:	ef 81       	ldd	r30, Y+7	; 0x07
     cfa:	f8 85       	ldd	r31, Y+8	; 0x08
     cfc:	06 81       	ldd	r16, Z+6	; 0x06
     cfe:	17 81       	ldd	r17, Z+7	; 0x07
     d00:	66 eb       	ldi	r22, 0xB6	; 182
     d02:	70 e2       	ldi	r23, 0x20	; 32
     d04:	c8 01       	movw	r24, r16
     d06:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     d0a:	66 e0       	ldi	r22, 0x06	; 6
     d0c:	c8 01       	movw	r24, r16
     d0e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     d12:	8c 81       	ldd	r24, Y+4	; 0x04
     d14:	9d 81       	ldd	r25, Y+5	; 0x05
     d16:	df 91       	pop	r29
     d18:	cf 91       	pop	r28
     d1a:	1f 91       	pop	r17
     d1c:	0f 91       	pop	r16
     d1e:	ff 90       	pop	r15
     d20:	ef 90       	pop	r14
     d22:	08 95       	ret

00000d24 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>:
     d24:	af 92       	push	r10
     d26:	bf 92       	push	r11
     d28:	cf 92       	push	r12
     d2a:	df 92       	push	r13
     d2c:	ef 92       	push	r14
     d2e:	ff 92       	push	r15
     d30:	0f 93       	push	r16
     d32:	1f 93       	push	r17
     d34:	cf 93       	push	r28
     d36:	df 93       	push	r29
     d38:	ec 01       	movw	r28, r24
     d3a:	8b 01       	movw	r16, r22
     d3c:	7a 01       	movw	r14, r20
     d3e:	68 83       	st	Y, r22
     d40:	79 83       	std	Y+1, r23	; 0x01
     d42:	4a 83       	std	Y+2, r20	; 0x02
     d44:	5b 83       	std	Y+3, r21	; 0x03
     d46:	8b e0       	ldi	r24, 0x0B	; 11
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     d4e:	6c 01       	movw	r12, r24
     d50:	fc 01       	movw	r30, r24
     d52:	16 82       	std	Z+6, r1	; 0x06
     d54:	85 e6       	ldi	r24, 0x65	; 101
     d56:	91 e2       	ldi	r25, 0x21	; 33
     d58:	80 83       	st	Z, r24
     d5a:	91 83       	std	Z+1, r25	; 0x01
     d5c:	07 83       	std	Z+7, r16	; 0x07
     d5e:	10 87       	std	Z+8, r17	; 0x08
     d60:	e1 86       	std	Z+9, r14	; 0x09
     d62:	f2 86       	std	Z+10, r15	; 0x0a
     d64:	f8 01       	movw	r30, r16
     d66:	a6 80       	ldd	r10, Z+6	; 0x06
     d68:	b7 80       	ldd	r11, Z+7	; 0x07
     d6a:	6f eb       	ldi	r22, 0xBF	; 191
     d6c:	70 e2       	ldi	r23, 0x20	; 32
     d6e:	c5 01       	movw	r24, r10
     d70:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     d74:	b5 01       	movw	r22, r10
     d76:	c5 01       	movw	r24, r10
     d78:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
     d7c:	66 e0       	ldi	r22, 0x06	; 6
     d7e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     d82:	ce 82       	std	Y+6, r12	; 0x06
     d84:	df 82       	std	Y+7, r13	; 0x07
     d86:	8b e0       	ldi	r24, 0x0B	; 11
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     d8e:	fc 01       	movw	r30, r24
     d90:	8d 89       	ldd	r24, Y+21	; 0x15
     d92:	9e 89       	ldd	r25, Y+22	; 0x16
     d94:	16 82       	std	Z+6, r1	; 0x06
     d96:	2d e6       	ldi	r18, 0x6D	; 109
     d98:	31 e2       	ldi	r19, 0x21	; 33
     d9a:	20 83       	st	Z, r18
     d9c:	31 83       	std	Z+1, r19	; 0x01
     d9e:	07 83       	std	Z+7, r16	; 0x07
     da0:	10 87       	std	Z+8, r17	; 0x08
     da2:	81 87       	std	Z+9, r24	; 0x09
     da4:	92 87       	std	Z+10, r25	; 0x0a
     da6:	e8 87       	std	Y+8, r30	; 0x08
     da8:	f9 87       	std	Y+9, r31	; 0x09
     daa:	89 e0       	ldi	r24, 0x09	; 9
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     db2:	fc 01       	movw	r30, r24
     db4:	16 82       	std	Z+6, r1	; 0x06
     db6:	8d e7       	ldi	r24, 0x7D	; 125
     db8:	91 e2       	ldi	r25, 0x21	; 33
     dba:	80 83       	st	Z, r24
     dbc:	91 83       	std	Z+1, r25	; 0x01
     dbe:	07 83       	std	Z+7, r16	; 0x07
     dc0:	10 87       	std	Z+8, r17	; 0x08
     dc2:	ea 87       	std	Y+10, r30	; 0x0a
     dc4:	fb 87       	std	Y+11, r31	; 0x0b
     dc6:	89 e0       	ldi	r24, 0x09	; 9
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     dce:	fc 01       	movw	r30, r24
     dd0:	16 82       	std	Z+6, r1	; 0x06
     dd2:	8d e8       	ldi	r24, 0x8D	; 141
     dd4:	91 e2       	ldi	r25, 0x21	; 33
     dd6:	80 83       	st	Z, r24
     dd8:	91 83       	std	Z+1, r25	; 0x01
     dda:	07 83       	std	Z+7, r16	; 0x07
     ddc:	10 87       	std	Z+8, r17	; 0x08
     dde:	ec 87       	std	Y+12, r30	; 0x0c
     de0:	fd 87       	std	Y+13, r31	; 0x0d
     de2:	89 e0       	ldi	r24, 0x09	; 9
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     dea:	fc 01       	movw	r30, r24
     dec:	16 82       	std	Z+6, r1	; 0x06
     dee:	85 ea       	ldi	r24, 0xA5	; 165
     df0:	91 e2       	ldi	r25, 0x21	; 33
     df2:	80 83       	st	Z, r24
     df4:	91 83       	std	Z+1, r25	; 0x01
     df6:	07 83       	std	Z+7, r16	; 0x07
     df8:	10 87       	std	Z+8, r17	; 0x08
     dfa:	ee 87       	std	Y+14, r30	; 0x0e
     dfc:	ff 87       	std	Y+15, r31	; 0x0f
     dfe:	89 e0       	ldi	r24, 0x09	; 9
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     e06:	fc 01       	movw	r30, r24
     e08:	16 82       	std	Z+6, r1	; 0x06
     e0a:	8d e9       	ldi	r24, 0x9D	; 157
     e0c:	91 e2       	ldi	r25, 0x21	; 33
     e0e:	80 83       	st	Z, r24
     e10:	91 83       	std	Z+1, r25	; 0x01
     e12:	07 83       	std	Z+7, r16	; 0x07
     e14:	10 87       	std	Z+8, r17	; 0x08
     e16:	e8 8b       	std	Y+16, r30	; 0x10
     e18:	f9 8b       	std	Y+17, r31	; 0x11
     e1a:	80 e1       	ldi	r24, 0x10	; 16
     e1c:	97 e2       	ldi	r25, 0x27	; 39
     e1e:	8d 8b       	std	Y+21, r24	; 0x15
     e20:	9e 8b       	std	Y+22, r25	; 0x16
     e22:	68 ed       	ldi	r22, 0xD8	; 216
     e24:	70 e2       	ldi	r23, 0x20	; 32
     e26:	c7 01       	movw	r24, r14
     e28:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     e2c:	b8 01       	movw	r22, r16
     e2e:	c7 01       	movw	r24, r14
     e30:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
     e34:	66 e0       	ldi	r22, 0x06	; 6
     e36:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     e3a:	f8 01       	movw	r30, r16
     e3c:	06 81       	ldd	r16, Z+6	; 0x06
     e3e:	17 81       	ldd	r17, Z+7	; 0x07
     e40:	64 ef       	ldi	r22, 0xF4	; 244
     e42:	70 e2       	ldi	r23, 0x20	; 32
     e44:	c7 01       	movw	r24, r14
     e46:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     e4a:	b8 01       	movw	r22, r16
     e4c:	c7 01       	movw	r24, r14
     e4e:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
     e52:	66 e0       	ldi	r22, 0x06	; 6
     e54:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     e58:	6a e0       	ldi	r22, 0x0A	; 10
     e5a:	71 e2       	ldi	r23, 0x21	; 33
     e5c:	c7 01       	movw	r24, r14
     e5e:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     e62:	b7 01       	movw	r22, r14
     e64:	c7 01       	movw	r24, r14
     e66:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
     e6a:	66 e0       	ldi	r22, 0x06	; 6
     e6c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     e70:	88 85       	ldd	r24, Y+8	; 0x08
     e72:	99 85       	ldd	r25, Y+9	; 0x09
     e74:	ee 81       	ldd	r30, Y+6	; 0x06
     e76:	ff 81       	ldd	r31, Y+7	; 0x07
     e78:	82 83       	std	Z+2, r24	; 0x02
     e7a:	93 83       	std	Z+3, r25	; 0x03
     e7c:	84 83       	std	Z+4, r24	; 0x04
     e7e:	95 83       	std	Z+5, r25	; 0x05
     e80:	8e 85       	ldd	r24, Y+14	; 0x0e
     e82:	9f 85       	ldd	r25, Y+15	; 0x0f
     e84:	2a 85       	ldd	r18, Y+10	; 0x0a
     e86:	3b 85       	ldd	r19, Y+11	; 0x0b
     e88:	e8 85       	ldd	r30, Y+8	; 0x08
     e8a:	f9 85       	ldd	r31, Y+9	; 0x09
     e8c:	22 83       	std	Z+2, r18	; 0x02
     e8e:	33 83       	std	Z+3, r19	; 0x03
     e90:	84 83       	std	Z+4, r24	; 0x04
     e92:	95 83       	std	Z+5, r25	; 0x05
     e94:	8c 85       	ldd	r24, Y+12	; 0x0c
     e96:	9d 85       	ldd	r25, Y+13	; 0x0d
     e98:	ea 85       	ldd	r30, Y+10	; 0x0a
     e9a:	fb 85       	ldd	r31, Y+11	; 0x0b
     e9c:	82 83       	std	Z+2, r24	; 0x02
     e9e:	93 83       	std	Z+3, r25	; 0x03
     ea0:	84 83       	std	Z+4, r24	; 0x04
     ea2:	95 83       	std	Z+5, r25	; 0x05
     ea4:	88 85       	ldd	r24, Y+8	; 0x08
     ea6:	99 85       	ldd	r25, Y+9	; 0x09
     ea8:	28 89       	ldd	r18, Y+16	; 0x10
     eaa:	39 89       	ldd	r19, Y+17	; 0x11
     eac:	ec 85       	ldd	r30, Y+12	; 0x0c
     eae:	fd 85       	ldd	r31, Y+13	; 0x0d
     eb0:	22 83       	std	Z+2, r18	; 0x02
     eb2:	33 83       	std	Z+3, r19	; 0x03
     eb4:	84 83       	std	Z+4, r24	; 0x04
     eb6:	95 83       	std	Z+5, r25	; 0x05
     eb8:	df 91       	pop	r29
     eba:	cf 91       	pop	r28
     ebc:	1f 91       	pop	r17
     ebe:	0f 91       	pop	r16
     ec0:	ff 90       	pop	r15
     ec2:	ef 90       	pop	r14
     ec4:	df 90       	pop	r13
     ec6:	cf 90       	pop	r12
     ec8:	bf 90       	pop	r11
     eca:	af 90       	pop	r10
     ecc:	08 95       	ret

00000ece <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>:
     ece:	cf 92       	push	r12
     ed0:	df 92       	push	r13
     ed2:	ef 92       	push	r14
     ed4:	ff 92       	push	r15
     ed6:	0f 93       	push	r16
     ed8:	1f 93       	push	r17
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
     ede:	ec 01       	movw	r28, r24
     ee0:	8b 01       	movw	r16, r22
     ee2:	6a 01       	movw	r12, r20
     ee4:	68 83       	st	Y, r22
     ee6:	79 83       	std	Y+1, r23	; 0x01
     ee8:	4a 83       	std	Y+2, r20	; 0x02
     eea:	5b 83       	std	Y+3, r21	; 0x03
     eec:	8b e0       	ldi	r24, 0x0B	; 11
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     ef4:	7c 01       	movw	r14, r24
     ef6:	fc 01       	movw	r30, r24
     ef8:	16 82       	std	Z+6, r1	; 0x06
     efa:	85 e6       	ldi	r24, 0x65	; 101
     efc:	91 e2       	ldi	r25, 0x21	; 33
     efe:	80 83       	st	Z, r24
     f00:	91 83       	std	Z+1, r25	; 0x01
     f02:	07 83       	std	Z+7, r16	; 0x07
     f04:	10 87       	std	Z+8, r17	; 0x08
     f06:	c1 86       	std	Z+9, r12	; 0x09
     f08:	d2 86       	std	Z+10, r13	; 0x0a
     f0a:	f8 01       	movw	r30, r16
     f0c:	c6 80       	ldd	r12, Z+6	; 0x06
     f0e:	d7 80       	ldd	r13, Z+7	; 0x07
     f10:	6f eb       	ldi	r22, 0xBF	; 191
     f12:	70 e2       	ldi	r23, 0x20	; 32
     f14:	c6 01       	movw	r24, r12
     f16:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
     f1a:	b6 01       	movw	r22, r12
     f1c:	c6 01       	movw	r24, r12
     f1e:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
     f22:	66 e0       	ldi	r22, 0x06	; 6
     f24:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
     f28:	ee 82       	std	Y+6, r14	; 0x06
     f2a:	ff 82       	std	Y+7, r15	; 0x07
     f2c:	8b e0       	ldi	r24, 0x0B	; 11
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     f34:	fc 01       	movw	r30, r24
     f36:	8d 89       	ldd	r24, Y+21	; 0x15
     f38:	9e 89       	ldd	r25, Y+22	; 0x16
     f3a:	16 82       	std	Z+6, r1	; 0x06
     f3c:	25 e7       	ldi	r18, 0x75	; 117
     f3e:	31 e2       	ldi	r19, 0x21	; 33
     f40:	20 83       	st	Z, r18
     f42:	31 83       	std	Z+1, r19	; 0x01
     f44:	07 83       	std	Z+7, r16	; 0x07
     f46:	10 87       	std	Z+8, r17	; 0x08
     f48:	81 87       	std	Z+9, r24	; 0x09
     f4a:	92 87       	std	Z+10, r25	; 0x0a
     f4c:	e8 87       	std	Y+8, r30	; 0x08
     f4e:	f9 87       	std	Y+9, r31	; 0x09
     f50:	89 e0       	ldi	r24, 0x09	; 9
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     f58:	fc 01       	movw	r30, r24
     f5a:	16 82       	std	Z+6, r1	; 0x06
     f5c:	85 e8       	ldi	r24, 0x85	; 133
     f5e:	91 e2       	ldi	r25, 0x21	; 33
     f60:	80 83       	st	Z, r24
     f62:	91 83       	std	Z+1, r25	; 0x01
     f64:	07 83       	std	Z+7, r16	; 0x07
     f66:	10 87       	std	Z+8, r17	; 0x08
     f68:	ea 87       	std	Y+10, r30	; 0x0a
     f6a:	fb 87       	std	Y+11, r31	; 0x0b
     f6c:	89 e0       	ldi	r24, 0x09	; 9
     f6e:	90 e0       	ldi	r25, 0x00	; 0
     f70:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     f74:	fc 01       	movw	r30, r24
     f76:	16 82       	std	Z+6, r1	; 0x06
     f78:	85 e9       	ldi	r24, 0x95	; 149
     f7a:	91 e2       	ldi	r25, 0x21	; 33
     f7c:	80 83       	st	Z, r24
     f7e:	91 83       	std	Z+1, r25	; 0x01
     f80:	07 83       	std	Z+7, r16	; 0x07
     f82:	10 87       	std	Z+8, r17	; 0x08
     f84:	ec 87       	std	Y+12, r30	; 0x0c
     f86:	fd 87       	std	Y+13, r31	; 0x0d
     f88:	89 e0       	ldi	r24, 0x09	; 9
     f8a:	90 e0       	ldi	r25, 0x00	; 0
     f8c:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     f90:	fc 01       	movw	r30, r24
     f92:	16 82       	std	Z+6, r1	; 0x06
     f94:	85 ea       	ldi	r24, 0xA5	; 165
     f96:	91 e2       	ldi	r25, 0x21	; 33
     f98:	80 83       	st	Z, r24
     f9a:	91 83       	std	Z+1, r25	; 0x01
     f9c:	07 83       	std	Z+7, r16	; 0x07
     f9e:	10 87       	std	Z+8, r17	; 0x08
     fa0:	ee 87       	std	Y+14, r30	; 0x0e
     fa2:	ff 87       	std	Y+15, r31	; 0x0f
     fa4:	89 e0       	ldi	r24, 0x09	; 9
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
     fac:	fc 01       	movw	r30, r24
     fae:	16 82       	std	Z+6, r1	; 0x06
     fb0:	8d e9       	ldi	r24, 0x9D	; 157
     fb2:	91 e2       	ldi	r25, 0x21	; 33
     fb4:	80 83       	st	Z, r24
     fb6:	91 83       	std	Z+1, r25	; 0x01
     fb8:	07 83       	std	Z+7, r16	; 0x07
     fba:	10 87       	std	Z+8, r17	; 0x08
     fbc:	e8 8b       	std	Y+16, r30	; 0x10
     fbe:	f9 8b       	std	Y+17, r31	; 0x11
     fc0:	80 e1       	ldi	r24, 0x10	; 16
     fc2:	97 e2       	ldi	r25, 0x27	; 39
     fc4:	8d 8b       	std	Y+21, r24	; 0x15
     fc6:	9e 8b       	std	Y+22, r25	; 0x16
     fc8:	88 85       	ldd	r24, Y+8	; 0x08
     fca:	99 85       	ldd	r25, Y+9	; 0x09
     fcc:	ee 81       	ldd	r30, Y+6	; 0x06
     fce:	ff 81       	ldd	r31, Y+7	; 0x07
     fd0:	82 83       	std	Z+2, r24	; 0x02
     fd2:	93 83       	std	Z+3, r25	; 0x03
     fd4:	84 83       	std	Z+4, r24	; 0x04
     fd6:	95 83       	std	Z+5, r25	; 0x05
     fd8:	8e 85       	ldd	r24, Y+14	; 0x0e
     fda:	9f 85       	ldd	r25, Y+15	; 0x0f
     fdc:	2a 85       	ldd	r18, Y+10	; 0x0a
     fde:	3b 85       	ldd	r19, Y+11	; 0x0b
     fe0:	e8 85       	ldd	r30, Y+8	; 0x08
     fe2:	f9 85       	ldd	r31, Y+9	; 0x09
     fe4:	22 83       	std	Z+2, r18	; 0x02
     fe6:	33 83       	std	Z+3, r19	; 0x03
     fe8:	84 83       	std	Z+4, r24	; 0x04
     fea:	95 83       	std	Z+5, r25	; 0x05
     fec:	8c 85       	ldd	r24, Y+12	; 0x0c
     fee:	9d 85       	ldd	r25, Y+13	; 0x0d
     ff0:	ea 85       	ldd	r30, Y+10	; 0x0a
     ff2:	fb 85       	ldd	r31, Y+11	; 0x0b
     ff4:	82 83       	std	Z+2, r24	; 0x02
     ff6:	93 83       	std	Z+3, r25	; 0x03
     ff8:	84 83       	std	Z+4, r24	; 0x04
     ffa:	95 83       	std	Z+5, r25	; 0x05
     ffc:	88 85       	ldd	r24, Y+8	; 0x08
     ffe:	99 85       	ldd	r25, Y+9	; 0x09
    1000:	28 89       	ldd	r18, Y+16	; 0x10
    1002:	39 89       	ldd	r19, Y+17	; 0x11
    1004:	ec 85       	ldd	r30, Y+12	; 0x0c
    1006:	fd 85       	ldd	r31, Y+13	; 0x0d
    1008:	22 83       	std	Z+2, r18	; 0x02
    100a:	33 83       	std	Z+3, r19	; 0x03
    100c:	84 83       	std	Z+4, r24	; 0x04
    100e:	95 83       	std	Z+5, r25	; 0x05
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	1f 91       	pop	r17
    1016:	0f 91       	pop	r16
    1018:	ff 90       	pop	r15
    101a:	ef 90       	pop	r14
    101c:	df 90       	pop	r13
    101e:	cf 90       	pop	r12
    1020:	08 95       	ret

00001022 <_ZN9I2CMaster11Transmitter3runER6Packet>:
    1022:	0f 93       	push	r16
    1024:	1f 93       	push	r17
    1026:	cf 93       	push	r28
    1028:	df 93       	push	r29
    102a:	ec 01       	movw	r28, r24
    102c:	8b 01       	movw	r16, r22
    102e:	8e 81       	ldd	r24, Y+6	; 0x06
    1030:	9f 81       	ldd	r25, Y+7	; 0x07
    1032:	8c 83       	std	Y+4, r24	; 0x04
    1034:	9d 83       	std	Y+5, r25	; 0x05
    1036:	28 89       	ldd	r18, Y+16	; 0x10
    1038:	39 89       	ldd	r19, Y+17	; 0x11
    103a:	82 17       	cp	r24, r18
    103c:	93 07       	cpc	r25, r19
    103e:	d9 f0       	breq	.+54     	; 0x1076 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
    1040:	2e 85       	ldd	r18, Y+14	; 0x0e
    1042:	3f 85       	ldd	r19, Y+15	; 0x0f
    1044:	82 17       	cp	r24, r18
    1046:	93 07       	cpc	r25, r19
    1048:	31 f4       	brne	.+12     	; 0x1056 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
    104a:	17 c0       	rjmp	.+46     	; 0x107a <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
    104c:	2e 85       	ldd	r18, Y+14	; 0x0e
    104e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1050:	28 17       	cp	r18, r24
    1052:	39 07       	cpc	r19, r25
    1054:	99 f0       	breq	.+38     	; 0x107c <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
    1056:	dc 01       	movw	r26, r24
    1058:	ed 91       	ld	r30, X+
    105a:	fc 91       	ld	r31, X
    105c:	01 90       	ld	r0, Z+
    105e:	f0 81       	ld	r31, Z
    1060:	e0 2d       	mov	r30, r0
    1062:	b8 01       	movw	r22, r16
    1064:	19 95       	eicall
    1066:	8c 83       	std	Y+4, r24	; 0x04
    1068:	9d 83       	std	Y+5, r25	; 0x05
    106a:	28 89       	ldd	r18, Y+16	; 0x10
    106c:	39 89       	ldd	r19, Y+17	; 0x11
    106e:	28 17       	cp	r18, r24
    1070:	39 07       	cpc	r19, r25
    1072:	61 f7       	brne	.-40     	; 0x104c <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
    1074:	03 c0       	rjmp	.+6      	; 0x107c <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
    1076:	c9 01       	movw	r24, r18
    1078:	01 c0       	rjmp	.+2      	; 0x107c <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
    107a:	c9 01       	movw	r24, r18
    107c:	dc 01       	movw	r26, r24
    107e:	ed 91       	ld	r30, X+
    1080:	fc 91       	ld	r31, X
    1082:	02 80       	ldd	r0, Z+2	; 0x02
    1084:	f3 81       	ldd	r31, Z+3	; 0x03
    1086:	e0 2d       	mov	r30, r0
    1088:	19 95       	eicall
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	4c 81       	ldd	r20, Y+4	; 0x04
    108e:	5d 81       	ldd	r21, Y+5	; 0x05
    1090:	28 89       	ldd	r18, Y+16	; 0x10
    1092:	39 89       	ldd	r19, Y+17	; 0x11
    1094:	42 17       	cp	r20, r18
    1096:	53 07       	cpc	r21, r19
    1098:	09 f0       	breq	.+2      	; 0x109c <_ZN9I2CMaster11Transmitter3runER6Packet+0x7a>
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	df 91       	pop	r29
    109e:	cf 91       	pop	r28
    10a0:	1f 91       	pop	r17
    10a2:	0f 91       	pop	r16
    10a4:	08 95       	ret

000010a6 <_ZN9I2CMaster8Receiver3runER6Packet>:
    10a6:	ef 92       	push	r14
    10a8:	ff 92       	push	r15
    10aa:	0f 93       	push	r16
    10ac:	1f 93       	push	r17
    10ae:	cf 93       	push	r28
    10b0:	df 93       	push	r29
    10b2:	ec 01       	movw	r28, r24
    10b4:	7b 01       	movw	r14, r22
    10b6:	8e 81       	ldd	r24, Y+6	; 0x06
    10b8:	9f 81       	ldd	r25, Y+7	; 0x07
    10ba:	8c 83       	std	Y+4, r24	; 0x04
    10bc:	9d 83       	std	Y+5, r25	; 0x05
    10be:	a8 89       	ldd	r26, Y+16	; 0x10
    10c0:	b9 89       	ldd	r27, Y+17	; 0x11
    10c2:	8a 17       	cp	r24, r26
    10c4:	9b 07       	cpc	r25, r27
    10c6:	71 f1       	breq	.+92     	; 0x1124 <_ZN9I2CMaster8Receiver3runER6Packet+0x7e>
    10c8:	ae 85       	ldd	r26, Y+14	; 0x0e
    10ca:	bf 85       	ldd	r27, Y+15	; 0x0f
    10cc:	8a 17       	cp	r24, r26
    10ce:	9b 07       	cpc	r25, r27
    10d0:	39 f4       	brne	.+14     	; 0x10e0 <_ZN9I2CMaster8Receiver3runER6Packet+0x3a>
    10d2:	28 c0       	rjmp	.+80     	; 0x1124 <_ZN9I2CMaster8Receiver3runER6Packet+0x7e>
    10d4:	ae 85       	ldd	r26, Y+14	; 0x0e
    10d6:	bf 85       	ldd	r27, Y+15	; 0x0f
    10d8:	c8 01       	movw	r24, r16
    10da:	a0 17       	cp	r26, r16
    10dc:	b1 07       	cpc	r27, r17
    10de:	11 f1       	breq	.+68     	; 0x1124 <_ZN9I2CMaster8Receiver3runER6Packet+0x7e>
    10e0:	dc 01       	movw	r26, r24
    10e2:	ed 91       	ld	r30, X+
    10e4:	fc 91       	ld	r31, X
    10e6:	01 90       	ld	r0, Z+
    10e8:	f0 81       	ld	r31, Z
    10ea:	e0 2d       	mov	r30, r0
    10ec:	b7 01       	movw	r22, r14
    10ee:	19 95       	eicall
    10f0:	8c 01       	movw	r16, r24
    10f2:	8c 81       	ldd	r24, Y+4	; 0x04
    10f4:	9d 81       	ldd	r25, Y+5	; 0x05
    10f6:	dc 01       	movw	r26, r24
    10f8:	ed 91       	ld	r30, X+
    10fa:	fc 91       	ld	r31, X
    10fc:	02 80       	ldd	r0, Z+2	; 0x02
    10fe:	f3 81       	ldd	r31, Z+3	; 0x03
    1100:	e0 2d       	mov	r30, r0
    1102:	19 95       	eicall
    1104:	88 85       	ldd	r24, Y+8	; 0x08
    1106:	99 85       	ldd	r25, Y+9	; 0x09
    1108:	dc 01       	movw	r26, r24
    110a:	ed 91       	ld	r30, X+
    110c:	fc 91       	ld	r31, X
    110e:	02 80       	ldd	r0, Z+2	; 0x02
    1110:	f3 81       	ldd	r31, Z+3	; 0x03
    1112:	e0 2d       	mov	r30, r0
    1114:	19 95       	eicall
    1116:	0c 83       	std	Y+4, r16	; 0x04
    1118:	1d 83       	std	Y+5, r17	; 0x05
    111a:	a8 89       	ldd	r26, Y+16	; 0x10
    111c:	b9 89       	ldd	r27, Y+17	; 0x11
    111e:	a0 17       	cp	r26, r16
    1120:	b1 07       	cpc	r27, r17
    1122:	c1 f6       	brne	.-80     	; 0x10d4 <_ZN9I2CMaster8Receiver3runER6Packet+0x2e>
    1124:	ed 91       	ld	r30, X+
    1126:	fc 91       	ld	r31, X
    1128:	11 97       	sbiw	r26, 0x01	; 1
    112a:	02 80       	ldd	r0, Z+2	; 0x02
    112c:	f3 81       	ldd	r31, Z+3	; 0x03
    112e:	e0 2d       	mov	r30, r0
    1130:	cd 01       	movw	r24, r26
    1132:	19 95       	eicall
    1134:	c7 01       	movw	r24, r14
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	1f 91       	pop	r17
    113c:	0f 91       	pop	r16
    113e:	ff 90       	pop	r15
    1140:	ef 90       	pop	r14
    1142:	08 95       	ret

00001144 <_ZN9I2CMaster12set_baudrateEm>:
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
    1148:	ec 01       	movw	r28, r24
    114a:	9a 01       	movw	r18, r20
    114c:	ab 01       	movw	r20, r22
    114e:	22 0f       	add	r18, r18
    1150:	33 1f       	adc	r19, r19
    1152:	44 1f       	adc	r20, r20
    1154:	55 1f       	adc	r21, r21
    1156:	60 e0       	ldi	r22, 0x00	; 0
    1158:	78 e4       	ldi	r23, 0x48	; 72
    115a:	88 ee       	ldi	r24, 0xE8	; 232
    115c:	91 e0       	ldi	r25, 0x01	; 1
    115e:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    1162:	25 50       	subi	r18, 0x05	; 5
    1164:	2a 87       	std	Y+10, r18	; 0x0a
    1166:	ec 81       	ldd	r30, Y+4	; 0x04
    1168:	fd 81       	ldd	r31, Y+5	; 0x05
    116a:	25 83       	std	Z+5, r18	; 0x05
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	08 95       	ret

00001172 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1172:	dc 01       	movw	r26, r24
    1174:	14 96       	adiw	r26, 0x04	; 4
    1176:	ed 91       	ld	r30, X+
    1178:	fc 91       	ld	r31, X
    117a:	15 97       	sbiw	r26, 0x05	; 5
    117c:	83 81       	ldd	r24, Z+3	; 0x03
    117e:	81 60       	ori	r24, 0x01	; 1
    1180:	83 83       	std	Z+3, r24	; 0x03
    1182:	08 95       	ret

00001184 <_ZN9I2CMaster10StartState7executeER6Packet>:
  // statusState_->serialDebug();
  // return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1184:	0f 93       	push	r16
    1186:	1f 93       	push	r17
    1188:	cf 93       	push	r28
    118a:	df 93       	push	r29
    118c:	ec 01       	movw	r28, r24
    118e:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    1190:	db 01       	movw	r26, r22
    1192:	ed 91       	ld	r30, X+
    1194:	fc 91       	ld	r31, X
    1196:	02 84       	ldd	r0, Z+10	; 0x0a
    1198:	f3 85       	ldd	r31, Z+11	; 0x0b
    119a:	e0 2d       	mov	r30, r0
    119c:	00 e0       	ldi	r16, 0x00	; 0
    119e:	10 e0       	ldi	r17, 0x00	; 0
    11a0:	b8 01       	movw	r22, r16
    11a2:	19 95       	eicall
  driver_->send_start();
    11a4:	8f 81       	ldd	r24, Y+7	; 0x07
    11a6:	98 85       	ldd	r25, Y+8	; 0x08
    11a8:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    11ac:	ef 81       	ldd	r30, Y+7	; 0x07
    11ae:	f8 85       	ldd	r31, Y+8	; 0x08
    11b0:	04 80       	ldd	r0, Z+4	; 0x04
    11b2:	f5 81       	ldd	r31, Z+5	; 0x05
    11b4:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    11b6:	d8 01       	movw	r26, r16
    11b8:	8c 91       	ld	r24, X
    11ba:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    11bc:	8a 81       	ldd	r24, Y+2	; 0x02
    11be:	9b 81       	ldd	r25, Y+3	; 0x03
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	1f 91       	pop	r17
    11c6:	0f 91       	pop	r16
    11c8:	08 95       	ret

000011ca <_ZN9I2CMaster8is_readyEh>:
  
  return addr_list;
}

bool I2CMaster::is_ready (uint8_t addr)
{
    11ca:	ff 92       	push	r15
    11cc:	0f 93       	push	r16
    11ce:	1f 93       	push	r17
    11d0:	cf 93       	push	r28
    11d2:	df 93       	push	r29
    11d4:	1f 92       	push	r1
    11d6:	1f 92       	push	r1
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
    11dc:	8c 01       	movw	r16, r24
    11de:	f6 2e       	mov	r15, r22
  volatile uint16_t counter = 500;
    11e0:	84 ef       	ldi	r24, 0xF4	; 244
    11e2:	91 e0       	ldi	r25, 0x01	; 1
    11e4:	89 83       	std	Y+1, r24	; 0x01
    11e6:	9a 83       	std	Y+2, r25	; 0x02
  send_start();
    11e8:	c8 01       	movw	r24, r16
    11ea:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN9I2CMaster10send_startEv>
  interface_->MASTER.ADDR = addr << 1;
    11ee:	d8 01       	movw	r26, r16
    11f0:	14 96       	adiw	r26, 0x04	; 4
    11f2:	ed 91       	ld	r30, X+
    11f4:	fc 91       	ld	r31, X
    11f6:	15 97       	sbiw	r26, 0x05	; 5
    11f8:	ff 0c       	add	r15, r15
    11fa:	f6 82       	std	Z+6, r15	; 0x06
  
  while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    11fc:	89 81       	ldd	r24, Y+1	; 0x01
    11fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1200:	01 97       	sbiw	r24, 0x01	; 1
    1202:	89 83       	std	Y+1, r24	; 0x01
    1204:	9a 83       	std	Y+2, r25	; 0x02
    1206:	89 2b       	or	r24, r25
    1208:	41 f0       	breq	.+16     	; 0x121a <_ZN9I2CMaster8is_readyEh+0x50>
    120a:	d8 01       	movw	r26, r16
    120c:	14 96       	adiw	r26, 0x04	; 4
    120e:	ed 91       	ld	r30, X+
    1210:	fc 91       	ld	r31, X
    1212:	15 97       	sbiw	r26, 0x05	; 5
    1214:	84 81       	ldd	r24, Z+4	; 0x04
    1216:	84 fd       	sbrc	r24, 4
    1218:	f1 cf       	rjmp	.-30     	; 0x11fc <_ZN9I2CMaster8is_readyEh+0x32>
  if(counter != 0)
    121a:	29 81       	ldd	r18, Y+1	; 0x01
    121c:	3a 81       	ldd	r19, Y+2	; 0x02
    121e:	81 e0       	ldi	r24, 0x01	; 1
    1220:	23 2b       	or	r18, r19
    1222:	09 f4       	brne	.+2      	; 0x1226 <_ZN9I2CMaster8is_readyEh+0x5c>
    1224:	80 e0       	ldi	r24, 0x00	; 0
  else
  {
    return false;
  }
  send_nack_stop();
}
    1226:	0f 90       	pop	r0
    1228:	0f 90       	pop	r0
    122a:	df 91       	pop	r29
    122c:	cf 91       	pop	r28
    122e:	1f 91       	pop	r17
    1230:	0f 91       	pop	r16
    1232:	ff 90       	pop	r15
    1234:	08 95       	ret

00001236 <_ZN9I2CMaster4scanEv>:
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
  interface_->MASTER.BAUD = baudrate;
}

uint8_t* I2CMaster::scan (void)
{
    1236:	8f 92       	push	r8
    1238:	9f 92       	push	r9
    123a:	af 92       	push	r10
    123c:	bf 92       	push	r11
    123e:	cf 92       	push	r12
    1240:	df 92       	push	r13
    1242:	ef 92       	push	r14
    1244:	ff 92       	push	r15
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	1f 92       	push	r1
    1250:	1f 92       	push	r1
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	8c 01       	movw	r16, r24
    1258:	dd 24       	eor	r13, r13
    125a:	d3 94       	inc	r13
    125c:	b1 2c       	mov	r11, r1
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    125e:	0f 2e       	mov	r0, r31
    1260:	f4 e6       	ldi	r31, 0x64	; 100
    1262:	ef 2e       	mov	r14, r31
    1264:	f1 2c       	mov	r15, r1
    1266:	f0 2d       	mov	r31, r0
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    1268:	0f 2e       	mov	r0, r31
    126a:	f7 e0       	ldi	r31, 0x07	; 7
    126c:	cf 2e       	mov	r12, r31
    126e:	f0 2d       	mov	r31, r0
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
  {
    counter = 100;
    1270:	e9 82       	std	Y+1, r14	; 0x01
    1272:	fa 82       	std	Y+2, r15	; 0x02
    send_start();
    1274:	c8 01       	movw	r24, r16
    1276:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN9I2CMaster10send_startEv>
    interface_->MASTER.ADDR = addr << 1;
    127a:	d8 01       	movw	r26, r16
    127c:	14 96       	adiw	r26, 0x04	; 4
    127e:	ed 91       	ld	r30, X+
    1280:	fc 91       	ld	r31, X
    1282:	15 97       	sbiw	r26, 0x05	; 5
    1284:	8d 2d       	mov	r24, r13
    1286:	88 0f       	add	r24, r24
    1288:	86 83       	std	Z+6, r24	; 0x06
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    128a:	89 81       	ldd	r24, Y+1	; 0x01
    128c:	9a 81       	ldd	r25, Y+2	; 0x02
    128e:	01 97       	sbiw	r24, 0x01	; 1
    1290:	89 83       	std	Y+1, r24	; 0x01
    1292:	9a 83       	std	Y+2, r25	; 0x02
    1294:	89 2b       	or	r24, r25
    1296:	89 f1       	breq	.+98     	; 0x12fa <_ZN9I2CMaster4scanEv+0xc4>
    1298:	d8 01       	movw	r26, r16
    129a:	14 96       	adiw	r26, 0x04	; 4
    129c:	ed 91       	ld	r30, X+
    129e:	fc 91       	ld	r31, X
    12a0:	15 97       	sbiw	r26, 0x05	; 5
    12a2:	84 81       	ldd	r24, Z+4	; 0x04
    12a4:	84 fd       	sbrc	r24, 4
    12a6:	f1 cf       	rjmp	.-30     	; 0x128a <_ZN9I2CMaster4scanEv+0x54>
    12a8:	28 c0       	rjmp	.+80     	; 0x12fa <_ZN9I2CMaster4scanEv+0xc4>
    if(counter != 0)
    {
      uint8_t addr_reg = interface_->MASTER.ADDR;
    12aa:	d8 01       	movw	r26, r16
    12ac:	14 96       	adiw	r26, 0x04	; 4
    12ae:	ed 91       	ld	r30, X+
    12b0:	fc 91       	ld	r31, X
    12b2:	15 97       	sbiw	r26, 0x05	; 5
    12b4:	a6 80       	ldd	r10, Z+6	; 0x06
      *p_serial << "Detected i2c addr: " << addr_reg << endl;
    12b6:	16 96       	adiw	r26, 0x06	; 6
    12b8:	8d 90       	ld	r8, X+
    12ba:	9c 90       	ld	r9, X
    12bc:	17 97       	sbiw	r26, 0x07	; 7
    12be:	63 e1       	ldi	r22, 0x13	; 19
    12c0:	71 e2       	ldi	r23, 0x21	; 33
    12c2:	c4 01       	movw	r24, r8
    12c4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    12c8:	6a 2d       	mov	r22, r10
    12ca:	c4 01       	movw	r24, r8
    12cc:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    12d0:	66 e0       	ldi	r22, 0x06	; 6
    12d2:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
      addr_list[addr_list_index] = addr;
    12d6:	f8 01       	movw	r30, r16
    12d8:	eb 0d       	add	r30, r11
    12da:	f1 1d       	adc	r31, r1
    12dc:	d7 86       	std	Z+15, r13	; 0x0f
      addr_list_index++;
    12de:	b3 94       	inc	r11
  interface_->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
    12e0:	d8 01       	movw	r26, r16
    12e2:	14 96       	adiw	r26, 0x04	; 4
    12e4:	ed 91       	ld	r30, X+
    12e6:	fc 91       	ld	r31, X
    12e8:	15 97       	sbiw	r26, 0x05	; 5
    12ea:	c3 82       	std	Z+3, r12	; 0x03
  volatile uint16_t counter;
  
  uint8_t addr_list_index;
  addr_list_index = 0;
  
  for (uint8_t addr = 1; addr < 128; addr++)
    12ec:	d3 94       	inc	r13
    12ee:	b0 e8       	ldi	r27, 0x80	; 128
    12f0:	db 12       	cpse	r13, r27
    12f2:	be cf       	rjmp	.-132    	; 0x1270 <_ZN9I2CMaster4scanEv+0x3a>

    send_nack_stop();
      
  }
  
  return addr_list;
    12f4:	c8 01       	movw	r24, r16
    12f6:	0f 96       	adiw	r24, 0x0f	; 15
    12f8:	05 c0       	rjmp	.+10     	; 0x1304 <_ZN9I2CMaster4scanEv+0xce>
    counter = 100;
    send_start();
    interface_->MASTER.ADDR = addr << 1;
    
    while ((--counter != 0) && (interface_->MASTER.STATUS & TWI_MASTER_RXACK_bm)){ }
    if(counter != 0)
    12fa:	89 81       	ldd	r24, Y+1	; 0x01
    12fc:	9a 81       	ldd	r25, Y+2	; 0x02
    12fe:	89 2b       	or	r24, r25
    1300:	79 f3       	breq	.-34     	; 0x12e0 <_ZN9I2CMaster4scanEv+0xaa>
    1302:	d3 cf       	rjmp	.-90     	; 0x12aa <_ZN9I2CMaster4scanEv+0x74>
    send_nack_stop();
      
  }
  
  return addr_list;
}
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	df 91       	pop	r29
    130a:	cf 91       	pop	r28
    130c:	1f 91       	pop	r17
    130e:	0f 91       	pop	r16
    1310:	ff 90       	pop	r15
    1312:	ef 90       	pop	r14
    1314:	df 90       	pop	r13
    1316:	cf 90       	pop	r12
    1318:	bf 90       	pop	r11
    131a:	af 90       	pop	r10
    131c:	9f 90       	pop	r9
    131e:	8f 90       	pop	r8
    1320:	08 95       	ret

00001322 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
//   interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

//   interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
// }

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s)
    1322:	ef 92       	push	r14
    1324:	ff 92       	push	r15
    1326:	0f 93       	push	r16
    1328:	1f 93       	push	r17
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
    132e:	ec 01       	movw	r28, r24
    1330:	7b 01       	movw	r14, r22
    1332:	ba 01       	movw	r22, r20
    1334:	a9 01       	movw	r20, r18
  : interface_(interface), 
    i2c_freq(i2c_freq),
    p_serial(s)
    1336:	ec 82       	std	Y+4, r14	; 0x04
    1338:	fd 82       	std	Y+5, r15	; 0x05
    133a:	0e 83       	std	Y+6, r16	; 0x06
    133c:	1f 83       	std	Y+7, r17	; 0x07
    133e:	4b 87       	std	Y+11, r20	; 0x0b
    1340:	5c 87       	std	Y+12, r21	; 0x0c
    1342:	6d 87       	std	Y+13, r22	; 0x0d
    1344:	7e 87       	std	Y+14, r23	; 0x0e
    // transmitter_(new Transmitter(this, s)),
    // receiver_(new Receiver(this, s))
{ 
  if (interface == &TWIC)
    1346:	80 e8       	ldi	r24, 0x80	; 128
    1348:	e8 16       	cp	r14, r24
    134a:	84 e0       	ldi	r24, 0x04	; 4
    134c:	f8 06       	cpc	r15, r24
    134e:	29 f4       	brne	.+10     	; 0x135a <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
  {
    bus_port = &PORTC;
    1350:	80 e4       	ldi	r24, 0x40	; 64
    1352:	96 e0       	ldi	r25, 0x06	; 6
    1354:	88 87       	std	Y+8, r24	; 0x08
    1356:	99 87       	std	Y+9, r25	; 0x09
    1358:	09 c0       	rjmp	.+18     	; 0x136c <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  }
  if (interface == &TWIE)
    135a:	e0 ea       	ldi	r30, 0xA0	; 160
    135c:	ee 16       	cp	r14, r30
    135e:	e4 e0       	ldi	r30, 0x04	; 4
    1360:	fe 06       	cpc	r15, r30
    1362:	21 f4       	brne	.+8      	; 0x136c <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
  {
    bus_port = &PORTE;
    1364:	80 e8       	ldi	r24, 0x80	; 128
    1366:	96 e0       	ldi	r25, 0x06	; 6
    1368:	88 87       	std	Y+8, r24	; 0x08
    136a:	99 87       	std	Y+9, r25	; 0x09
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
    136c:	e8 85       	ldd	r30, Y+8	; 0x08
    136e:	f9 85       	ldd	r31, Y+9	; 0x09
    1370:	83 e0       	ldi	r24, 0x03	; 3
    1372:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
    1374:	e8 85       	ldd	r30, Y+8	; 0x08
    1376:	f9 85       	ldd	r31, Y+9	; 0x09
    1378:	88 e3       	ldi	r24, 0x38	; 56
    137a:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
    137c:	e8 85       	ldd	r30, Y+8	; 0x08
    137e:	f9 85       	ldd	r31, Y+9	; 0x09
    1380:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
    1382:	82 e0       	ldi	r24, 0x02	; 2
    1384:	f7 01       	movw	r30, r14
    1386:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
    1388:	ce 01       	movw	r24, r28
    138a:	0e 94 a2 08 	call	0x1144	; 0x1144 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
    138e:	f7 01       	movw	r30, r14
    1390:	84 81       	ldd	r24, Z+4	; 0x04
    1392:	8d 6c       	ori	r24, 0xCD	; 205
    1394:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
    1396:	88 e0       	ldi	r24, 0x08	; 8
    1398:	81 83       	std	Z+1, r24	; 0x01
    139a:	67 e2       	ldi	r22, 0x27	; 39
    139c:	71 e2       	ldi	r23, 0x21	; 33
    139e:	c8 01       	movw	r24, r16
    13a0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>


  *s << "i2c constructor this: " << this << endl;
    13a4:	be 01       	movw	r22, r28
    13a6:	c8 01       	movw	r24, r16
    13a8:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
    13ac:	66 e0       	ldi	r22, 0x06	; 6
    13ae:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
  emstream *    getSerial()       { return p_serial; }
    13b2:	ee 80       	ldd	r14, Y+6	; 0x06
    13b4:	ff 80       	ldd	r15, Y+7	; 0x07
    13b6:	6e e3       	ldi	r22, 0x3E	; 62
    13b8:	71 e2       	ldi	r23, 0x21	; 33
    13ba:	c8 01       	movw	r24, r16
    13bc:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
  *s << "i2c serial ptr: " << getSerial() << endl;
    13c0:	b7 01       	movw	r22, r14
    13c2:	c8 01       	movw	r24, r16
    13c4:	0e 94 67 20 	call	0x40ce	; 0x40ce <_ZN8emstreamlsEPv>
    13c8:	66 e0       	ldi	r22, 0x06	; 6
    13ca:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

  transmitter_ = new Transmitter(this, s);
    13ce:	87 e1       	ldi	r24, 0x17	; 23
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    13d6:	7c 01       	movw	r14, r24
    13d8:	a8 01       	movw	r20, r16
    13da:	be 01       	movw	r22, r28
    13dc:	0e 94 92 06 	call	0xd24	; 0xd24 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>
    13e0:	e8 82       	st	Y, r14
    13e2:	f9 82       	std	Y+1, r15	; 0x01
  receiver_ = new Receiver(this, s);
    13e4:	88 e1       	ldi	r24, 0x18	; 24
    13e6:	90 e0       	ldi	r25, 0x00	; 0
    13e8:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    13ec:	7c 01       	movw	r14, r24
    13ee:	a8 01       	movw	r20, r16
    13f0:	be 01       	movw	r22, r28
    13f2:	0e 94 67 07 	call	0xece	; 0xece <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>
    13f6:	ea 82       	std	Y+2, r14	; 0x02
    13f8:	fb 82       	std	Y+3, r15	; 0x03

  scan();
    13fa:	ce 01       	movw	r24, r28
    13fc:	0e 94 1b 09 	call	0x1236	; 0x1236 <_ZN9I2CMaster4scanEv>
  *s << is_ready(29) << endl;
    1400:	6d e1       	ldi	r22, 0x1D	; 29
    1402:	ce 01       	movw	r24, r28
    1404:	0e 94 e5 08 	call	0x11ca	; 0x11ca <_ZN9I2CMaster8is_readyEh>
    1408:	68 2f       	mov	r22, r24
    140a:	c8 01       	movw	r24, r16
    140c:	0e 94 4f 20 	call	0x409e	; 0x409e <_ZN8emstreamlsEb>
    1410:	66 e0       	ldi	r22, 0x06	; 6
    1412:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1416:	0e 80       	ldd	r0, Y+6	; 0x06
    1418:	df 81       	ldd	r29, Y+7	; 0x07
    141a:	c0 2d       	mov	r28, r0
    141c:	6f e4       	ldi	r22, 0x4F	; 79
    141e:	71 e2       	ldi	r23, 0x21	; 33
    1420:	ce 01       	movw	r24, r28
    1422:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>

  *(getSerial()) << "I2CMaster created" << endl;
    1426:	66 e0       	ldi	r22, 0x06	; 6
    1428:	ce 01       	movw	r24, r28
    142a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
}
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	1f 91       	pop	r17
    1434:	0f 91       	pop	r16
    1436:	ff 90       	pop	r15
    1438:	ef 90       	pop	r14
    143a:	08 95       	ret

0000143c <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    143c:	fc 01       	movw	r30, r24
    143e:	84 81       	ldd	r24, Z+4	; 0x04
    1440:	95 81       	ldd	r25, Z+5	; 0x05
    1442:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
		}
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	08 95       	ret

0000144a <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    144a:	fc 01       	movw	r30, r24
    144c:	84 81       	ldd	r24, Z+4	; 0x04
    144e:	95 81       	ldd	r25, Z+5	; 0x05
    1450:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    1454:	91 e0       	ldi	r25, 0x01	; 1
    1456:	81 11       	cpse	r24, r1
    1458:	01 c0       	rjmp	.+2      	; 0x145c <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    145a:	90 e0       	ldi	r25, 0x00	; 0
		}
    145c:	89 2f       	mov	r24, r25
    145e:	08 95       	ret

00001460 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    1460:	fc 01       	movw	r30, r24
    1462:	84 81       	ldd	r24, Z+4	; 0x04
    1464:	95 81       	ldd	r25, Z+5	; 0x05
    1466:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    146a:	91 e0       	ldi	r25, 0x01	; 1
    146c:	81 11       	cpse	r24, r1
    146e:	90 e0       	ldi	r25, 0x00	; 0
		}
    1470:	89 2f       	mov	r24, r25
    1472:	08 95       	ret

00001474 <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    1474:	fc 01       	movw	r30, r24
    1476:	84 81       	ldd	r24, Z+4	; 0x04
    1478:	95 81       	ldd	r25, Z+5	; 0x05
    147a:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
		}
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	08 95       	ret

00001482 <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    1482:	fc 01       	movw	r30, r24
    1484:	84 81       	ldd	r24, Z+4	; 0x04
    1486:	95 81       	ldd	r25, Z+5	; 0x05
    1488:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    148c:	91 e0       	ldi	r25, 0x01	; 1
    148e:	81 11       	cpse	r24, r1
    1490:	01 c0       	rjmp	.+2      	; 0x1494 <_ZN9frt_queueIhE9not_emptyEv+0x12>
    1492:	90 e0       	ldi	r25, 0x00	; 0
		}
    1494:	89 2f       	mov	r24, r25
    1496:	08 95       	ret

00001498 <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    1498:	fc 01       	movw	r30, r24
    149a:	84 81       	ldd	r24, Z+4	; 0x04
    149c:	95 81       	ldd	r25, Z+5	; 0x05
    149e:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    14a2:	91 e0       	ldi	r25, 0x01	; 1
    14a4:	81 11       	cpse	r24, r1
    14a6:	90 e0       	ldi	r25, 0x00	; 0
		}
    14a8:	89 2f       	mov	r24, r25
    14aa:	08 95       	ret

000014ac <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    14ac:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    14ae:	01 e0       	ldi	r16, 0x01	; 1
    14b0:	2f ef       	ldi	r18, 0xFF	; 255
    14b2:	3f ef       	ldi	r19, 0xFF	; 255
    14b4:	a9 01       	movw	r20, r18
    14b6:	fc 01       	movw	r30, r24
    14b8:	84 81       	ldd	r24, Z+4	; 0x04
    14ba:	95 81       	ldd	r25, Z+5	; 0x05
    14bc:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    14c0:	0f 91       	pop	r16
    14c2:	08 95       	ret

000014c4 <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    14c4:	0f 93       	push	r16
    14c6:	cf 93       	push	r28
    14c8:	df 93       	push	r29
    14ca:	1f 92       	push	r1
    14cc:	cd b7       	in	r28, 0x3d	; 61
    14ce:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    14d0:	01 e0       	ldi	r16, 0x01	; 1
    14d2:	2f ef       	ldi	r18, 0xFF	; 255
    14d4:	3f ef       	ldi	r19, 0xFF	; 255
    14d6:	a9 01       	movw	r20, r18
    14d8:	be 01       	movw	r22, r28
    14da:	6f 5f       	subi	r22, 0xFF	; 255
    14dc:	7f 4f       	sbci	r23, 0xFF	; 255
    14de:	fc 01       	movw	r30, r24
    14e0:	84 81       	ldd	r24, Z+4	; 0x04
    14e2:	95 81       	ldd	r25, Z+5	; 0x05
    14e4:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	0f 90       	pop	r0
    14ec:	df 91       	pop	r29
    14ee:	cf 91       	pop	r28
    14f0:	0f 91       	pop	r16
    14f2:	08 95       	ret

000014f4 <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    14f4:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    14f6:	00 e0       	ldi	r16, 0x00	; 0
    14f8:	2f ef       	ldi	r18, 0xFF	; 255
    14fa:	3f ef       	ldi	r19, 0xFF	; 255
    14fc:	a9 01       	movw	r20, r18
    14fe:	fc 01       	movw	r30, r24
    1500:	84 81       	ldd	r24, Z+4	; 0x04
    1502:	95 81       	ldd	r25, Z+5	; 0x05
    1504:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    1508:	0f 91       	pop	r16
    150a:	08 95       	ret

0000150c <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    150c:	0f 93       	push	r16
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	1f 92       	push	r1
    1514:	cd b7       	in	r28, 0x3d	; 61
    1516:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    1518:	00 e0       	ldi	r16, 0x00	; 0
    151a:	2f ef       	ldi	r18, 0xFF	; 255
    151c:	3f ef       	ldi	r19, 0xFF	; 255
    151e:	a9 01       	movw	r20, r18
    1520:	be 01       	movw	r22, r28
    1522:	6f 5f       	subi	r22, 0xFF	; 255
    1524:	7f 4f       	sbci	r23, 0xFF	; 255
    1526:	fc 01       	movw	r30, r24
    1528:	84 81       	ldd	r24, Z+4	; 0x04
    152a:	95 81       	ldd	r25, Z+5	; 0x05
    152c:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    1530:	89 81       	ldd	r24, Y+1	; 0x01
    1532:	0f 90       	pop	r0
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	0f 91       	pop	r16
    153a:	08 95       	ret

0000153c <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    153c:	cf 93       	push	r28
    153e:	df 93       	push	r29
    1540:	1f 92       	push	r1
    1542:	cd b7       	in	r28, 0x3d	; 61
    1544:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    1546:	ae 01       	movw	r20, r28
    1548:	4f 5f       	subi	r20, 0xFF	; 255
    154a:	5f 4f       	sbci	r21, 0xFF	; 255
    154c:	fc 01       	movw	r30, r24
    154e:	84 81       	ldd	r24, Z+4	; 0x04
    1550:	95 81       	ldd	r25, Z+5	; 0x05
    1552:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
}
    1556:	0f 90       	pop	r0
    1558:	df 91       	pop	r29
    155a:	cf 91       	pop	r28
    155c:	08 95       	ret

0000155e <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    155e:	cf 93       	push	r28
    1560:	df 93       	push	r29
    1562:	1f 92       	push	r1
    1564:	1f 92       	push	r1
    1566:	cd b7       	in	r28, 0x3d	; 61
    1568:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    156a:	ae 01       	movw	r20, r28
    156c:	4e 5f       	subi	r20, 0xFE	; 254
    156e:	5f 4f       	sbci	r21, 0xFF	; 255
    1570:	be 01       	movw	r22, r28
    1572:	6f 5f       	subi	r22, 0xFF	; 255
    1574:	7f 4f       	sbci	r23, 0xFF	; 255
    1576:	fc 01       	movw	r30, r24
    1578:	84 81       	ldd	r24, Z+4	; 0x04
    157a:	95 81       	ldd	r25, Z+5	; 0x05
    157c:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
	return (recv_item);
}
    1580:	89 81       	ldd	r24, Y+1	; 0x01
    1582:	0f 90       	pop	r0
    1584:	0f 90       	pop	r0
    1586:	df 91       	pop	r29
    1588:	cf 91       	pop	r28
    158a:	08 95       	ret

0000158c <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
    1590:	1f 92       	push	r1
    1592:	cd b7       	in	r28, 0x3d	; 61
    1594:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    1596:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    1598:	21 e0       	ldi	r18, 0x01	; 1
    159a:	ae 01       	movw	r20, r28
    159c:	4f 5f       	subi	r20, 0xFF	; 255
    159e:	5f 4f       	sbci	r21, 0xFF	; 255
    15a0:	fc 01       	movw	r30, r24
    15a2:	84 81       	ldd	r24, Z+4	; 0x04
    15a4:	95 81       	ldd	r25, Z+5	; 0x05
    15a6:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    15aa:	91 e0       	ldi	r25, 0x01	; 1
    15ac:	81 11       	cpse	r24, r1
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    15b0:	90 e0       	ldi	r25, 0x00	; 0
}
    15b2:	89 2f       	mov	r24, r25
    15b4:	0f 90       	pop	r0
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    15bc:	cf 93       	push	r28
    15be:	df 93       	push	r29
    15c0:	1f 92       	push	r1
    15c2:	cd b7       	in	r28, 0x3d	; 61
    15c4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    15c6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    15c8:	20 e0       	ldi	r18, 0x00	; 0
    15ca:	ae 01       	movw	r20, r28
    15cc:	4f 5f       	subi	r20, 0xFF	; 255
    15ce:	5f 4f       	sbci	r21, 0xFF	; 255
    15d0:	fc 01       	movw	r30, r24
    15d2:	84 81       	ldd	r24, Z+4	; 0x04
    15d4:	95 81       	ldd	r25, Z+5	; 0x05
    15d6:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    15da:	91 e0       	ldi	r25, 0x01	; 1
    15dc:	81 11       	cpse	r24, r1
    15de:	01 c0       	rjmp	.+2      	; 0x15e2 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    15e0:	90 e0       	ldi	r25, 0x00	; 0
}
    15e2:	89 2f       	mov	r24, r25
    15e4:	0f 90       	pop	r0
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	08 95       	ret

000015ec <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    15ec:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    15ee:	fc 01       	movw	r30, r24
    15f0:	26 81       	ldd	r18, Z+6	; 0x06
    15f2:	37 81       	ldd	r19, Z+7	; 0x07
    15f4:	40 85       	ldd	r20, Z+8	; 0x08
    15f6:	51 85       	ldd	r21, Z+9	; 0x09
    15f8:	01 e0       	ldi	r16, 0x01	; 1
    15fa:	84 81       	ldd	r24, Z+4	; 0x04
    15fc:	95 81       	ldd	r25, Z+5	; 0x05
    15fe:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    1602:	91 e0       	ldi	r25, 0x01	; 1
    1604:	81 11       	cpse	r24, r1
    1606:	01 c0       	rjmp	.+2      	; 0x160a <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    1608:	90 e0       	ldi	r25, 0x00	; 0
		}
    160a:	89 2f       	mov	r24, r25
    160c:	0f 91       	pop	r16
    160e:	08 95       	ret

00001610 <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    1610:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    1612:	fc 01       	movw	r30, r24
    1614:	26 81       	ldd	r18, Z+6	; 0x06
    1616:	37 81       	ldd	r19, Z+7	; 0x07
    1618:	40 85       	ldd	r20, Z+8	; 0x08
    161a:	51 85       	ldd	r21, Z+9	; 0x09
    161c:	00 e0       	ldi	r16, 0x00	; 0
    161e:	84 81       	ldd	r24, Z+4	; 0x04
    1620:	95 81       	ldd	r25, Z+5	; 0x05
    1622:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    1626:	91 e0       	ldi	r25, 0x01	; 1
    1628:	81 11       	cpse	r24, r1
    162a:	01 c0       	rjmp	.+2      	; 0x162e <_ZN9frt_queueIhE3putERKh+0x1e>
    162c:	90 e0       	ldi	r25, 0x00	; 0
		}
    162e:	89 2f       	mov	r24, r25
    1630:	0f 91       	pop	r16
    1632:	08 95       	ret

00001634 <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::takeReading()
{
  return i2cAgent_->transmit(*queryX_);
}
    1634:	db 01       	movw	r26, r22
    1636:	bc 01       	movw	r22, r24
    1638:	6e 5f       	subi	r22, 0xFE	; 254
    163a:	7f 4f       	sbci	r23, 0xFF	; 255
    163c:	ed 91       	ld	r30, X+
    163e:	fc 91       	ld	r31, X
    1640:	11 97       	sbiw	r26, 0x01	; 1
    1642:	01 90       	ld	r0, Z+
    1644:	f0 81       	ld	r31, Z
    1646:	e0 2d       	mov	r30, r0
    1648:	cd 01       	movw	r24, r26
    164a:	19 95       	eicall
    164c:	08 95       	ret

0000164e <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    164e:	db 01       	movw	r26, r22
    1650:	bc 01       	movw	r22, r24
    1652:	6e 5f       	subi	r22, 0xFE	; 254
    1654:	7f 4f       	sbci	r23, 0xFF	; 255
    1656:	ed 91       	ld	r30, X+
    1658:	fc 91       	ld	r31, X
    165a:	11 97       	sbiw	r26, 0x01	; 1
    165c:	01 90       	ld	r0, Z+
    165e:	f0 81       	ld	r31, Z
    1660:	e0 2d       	mov	r30, r0
    1662:	cd 01       	movw	r24, r26
    1664:	19 95       	eicall
    1666:	08 95       	ret

00001668 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    1668:	db 01       	movw	r26, r22
    166a:	bc 01       	movw	r22, r24
    166c:	6e 5f       	subi	r22, 0xFE	; 254
    166e:	7f 4f       	sbci	r23, 0xFF	; 255
    1670:	ed 91       	ld	r30, X+
    1672:	fc 91       	ld	r31, X
    1674:	11 97       	sbiw	r26, 0x01	; 1
    1676:	01 90       	ld	r0, Z+
    1678:	f0 81       	ld	r31, Z
    167a:	e0 2d       	mov	r30, r0
    167c:	cd 01       	movw	r24, r26
    167e:	19 95       	eicall
    1680:	08 95       	ret

00001682 <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    1682:	db 01       	movw	r26, r22
    1684:	bc 01       	movw	r22, r24
    1686:	6e 5f       	subi	r22, 0xFE	; 254
    1688:	7f 4f       	sbci	r23, 0xFF	; 255
    168a:	ed 91       	ld	r30, X+
    168c:	fc 91       	ld	r31, X
    168e:	11 97       	sbiw	r26, 0x01	; 1
    1690:	01 90       	ld	r0, Z+
    1692:	f0 81       	ld	r31, Z
    1694:	e0 2d       	mov	r30, r0
    1696:	cd 01       	movw	r24, r26
    1698:	19 95       	eicall
    169a:	08 95       	ret

0000169c <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    169c:	3f 92       	push	r3
    169e:	4f 92       	push	r4
    16a0:	5f 92       	push	r5
    16a2:	6f 92       	push	r6
    16a4:	7f 92       	push	r7
    16a6:	8f 92       	push	r8
    16a8:	9f 92       	push	r9
    16aa:	af 92       	push	r10
    16ac:	bf 92       	push	r11
    16ae:	cf 92       	push	r12
    16b0:	df 92       	push	r13
    16b2:	ef 92       	push	r14
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	8c 01       	movw	r16, r24
    16c0:	7b 01       	movw	r14, r22
    16c2:	6a 01       	movw	r12, r20
    16c4:	dc 01       	movw	r26, r24
    16c6:	6d 93       	st	X+, r22
    16c8:	7c 93       	st	X, r23
    16ca:	11 97       	sbiw	r26, 0x01	; 1
    16cc:	12 96       	adiw	r26, 0x02	; 2
    16ce:	4d 93       	st	X+, r20
    16d0:	5c 93       	st	X, r21
    16d2:	13 97       	sbiw	r26, 0x03	; 3
    16d4:	8f e1       	ldi	r24, 0x1F	; 31
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    16dc:	ec 01       	movw	r28, r24
    16de:	85 ef       	ldi	r24, 0xF5	; 245
    16e0:	91 e2       	ldi	r25, 0x21	; 33
    16e2:	88 83       	st	Y, r24
    16e4:	99 83       	std	Y+1, r25	; 0x01
    16e6:	1c 82       	std	Y+4, r1	; 0x04
    16e8:	1d 82       	std	Y+5, r1	; 0x05
    16ea:	0f 2e       	mov	r0, r31
    16ec:	fd ea       	ldi	r31, 0xAD	; 173
    16ee:	af 2e       	mov	r10, r31
    16f0:	f1 e2       	ldi	r31, 0x21	; 33
    16f2:	bf 2e       	mov	r11, r31
    16f4:	f0 2d       	mov	r31, r0
    16f6:	aa 82       	std	Y+2, r10	; 0x02
    16f8:	bb 82       	std	Y+3, r11	; 0x03
    16fa:	40 e0       	ldi	r20, 0x00	; 0
    16fc:	61 e0       	ldi	r22, 0x01	; 1
    16fe:	82 e0       	ldi	r24, 0x02	; 2
    1700:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    1704:	8e 83       	std	Y+6, r24	; 0x06
    1706:	9f 83       	std	Y+7, r25	; 0x07
    1708:	0f 2e       	mov	r0, r31
    170a:	fa e0       	ldi	r31, 0x0A	; 10
    170c:	4f 2e       	mov	r4, r31
    170e:	51 2c       	mov	r5, r1
    1710:	61 2c       	mov	r6, r1
    1712:	71 2c       	mov	r7, r1
    1714:	f0 2d       	mov	r31, r0
    1716:	48 86       	std	Y+8, r4	; 0x08
    1718:	59 86       	std	Y+9, r5	; 0x09
    171a:	6a 86       	std	Y+10, r6	; 0x0a
    171c:	7b 86       	std	Y+11, r7	; 0x0b
    171e:	0f 2e       	mov	r0, r31
    1720:	f1 ed       	ldi	r31, 0xD1	; 209
    1722:	8f 2e       	mov	r8, r31
    1724:	f1 e2       	ldi	r31, 0x21	; 33
    1726:	9f 2e       	mov	r9, r31
    1728:	f0 2d       	mov	r31, r0
    172a:	8a 82       	std	Y+2, r8	; 0x02
    172c:	9b 82       	std	Y+3, r9	; 0x03
    172e:	68 94       	set
    1730:	33 24       	eor	r3, r3
    1732:	31 f8       	bld	r3, 1
    1734:	3c 86       	std	Y+12, r3	; 0x0c
    1736:	1f 86       	std	Y+15, r1	; 0x0f
    1738:	18 8a       	std	Y+16, r1	; 0x10
    173a:	ad 86       	std	Y+13, r10	; 0x0d
    173c:	be 86       	std	Y+14, r11	; 0x0e
    173e:	40 e0       	ldi	r20, 0x00	; 0
    1740:	61 e0       	ldi	r22, 0x01	; 1
    1742:	82 e0       	ldi	r24, 0x02	; 2
    1744:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    1748:	89 8b       	std	Y+17, r24	; 0x11
    174a:	9a 8b       	std	Y+18, r25	; 0x12
    174c:	4b 8a       	std	Y+19, r4	; 0x13
    174e:	5c 8a       	std	Y+20, r5	; 0x14
    1750:	6d 8a       	std	Y+21, r6	; 0x15
    1752:	7e 8a       	std	Y+22, r7	; 0x16
    1754:	8d 86       	std	Y+13, r8	; 0x0d
    1756:	9e 86       	std	Y+14, r9	; 0x0e
    1758:	3f 8a       	std	Y+23, r3	; 0x17
    175a:	80 e1       	ldi	r24, 0x10	; 16
    175c:	90 e2       	ldi	r25, 0x20	; 32
    175e:	88 83       	st	Y, r24
    1760:	99 83       	std	Y+1, r25	; 0x01
    1762:	c8 8e       	std	Y+24, r12	; 0x18
    1764:	d9 8e       	std	Y+25, r13	; 0x19
    1766:	f8 01       	movw	r30, r16
    1768:	c4 83       	std	Z+4, r28	; 0x04
    176a:	d5 83       	std	Z+5, r29	; 0x05
    176c:	8d e1       	ldi	r24, 0x1D	; 29
    176e:	86 83       	std	Z+6, r24	; 0x06
    1770:	84 e0       	ldi	r24, 0x04	; 4
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    1778:	fc 01       	movw	r30, r24
    177a:	83 e0       	ldi	r24, 0x03	; 3
    177c:	92 e2       	ldi	r25, 0x22	; 34
    177e:	80 83       	st	Z, r24
    1780:	91 83       	std	Z+1, r25	; 0x01
    1782:	8a e2       	ldi	r24, 0x2A	; 42
    1784:	82 83       	std	Z+2, r24	; 0x02
    1786:	c1 e0       	ldi	r28, 0x01	; 1
    1788:	c3 83       	std	Z+3, r28	; 0x03
    178a:	d8 01       	movw	r26, r16
    178c:	19 96       	adiw	r26, 0x09	; 9
    178e:	ed 93       	st	X+, r30
    1790:	fc 93       	st	X, r31
    1792:	1a 97       	sbiw	r26, 0x0a	; 10
    1794:	83 e0       	ldi	r24, 0x03	; 3
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    179c:	29 e0       	ldi	r18, 0x09	; 9
    179e:	32 e2       	ldi	r19, 0x22	; 34
    17a0:	fc 01       	movw	r30, r24
    17a2:	20 83       	st	Z, r18
    17a4:	31 83       	std	Z+1, r19	; 0x01
    17a6:	c2 83       	std	Z+2, r28	; 0x02
    17a8:	d8 01       	movw	r26, r16
    17aa:	1b 96       	adiw	r26, 0x0b	; 11
    17ac:	8d 93       	st	X+, r24
    17ae:	9c 93       	st	X, r25
    17b0:	1c 97       	sbiw	r26, 0x0c	; 12
    17b2:	83 e0       	ldi	r24, 0x03	; 3
    17b4:	90 e0       	ldi	r25, 0x00	; 0
    17b6:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    17ba:	2f e0       	ldi	r18, 0x0F	; 15
    17bc:	32 e2       	ldi	r19, 0x22	; 34
    17be:	fc 01       	movw	r30, r24
    17c0:	20 83       	st	Z, r18
    17c2:	31 83       	std	Z+1, r19	; 0x01
    17c4:	23 e0       	ldi	r18, 0x03	; 3
    17c6:	22 83       	std	Z+2, r18	; 0x02
    17c8:	d8 01       	movw	r26, r16
    17ca:	1d 96       	adiw	r26, 0x0d	; 13
    17cc:	8d 93       	st	X+, r24
    17ce:	9c 93       	st	X, r25
    17d0:	1e 97       	sbiw	r26, 0x0e	; 14
    17d2:	83 e0       	ldi	r24, 0x03	; 3
    17d4:	90 e0       	ldi	r25, 0x00	; 0
    17d6:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    17da:	25 e1       	ldi	r18, 0x15	; 21
    17dc:	32 e2       	ldi	r19, 0x22	; 34
    17de:	fc 01       	movw	r30, r24
    17e0:	20 83       	st	Z, r18
    17e2:	31 83       	std	Z+1, r19	; 0x01
    17e4:	25 e0       	ldi	r18, 0x05	; 5
    17e6:	22 83       	std	Z+2, r18	; 0x02
    17e8:	d8 01       	movw	r26, r16
    17ea:	1f 96       	adiw	r26, 0x0f	; 15
    17ec:	8d 93       	st	X+, r24
    17ee:	9c 93       	st	X, r25
    17f0:	50 97       	sbiw	r26, 0x10	; 16
    17f2:	14 96       	adiw	r26, 0x04	; 4
    17f4:	ed 91       	ld	r30, X+
    17f6:	fc 91       	ld	r31, X
    17f8:	15 97       	sbiw	r26, 0x05	; 5
    17fa:	e2 8e       	std	Z+26, r14	; 0x1a
    17fc:	f3 8e       	std	Z+27, r15	; 0x1b
    17fe:	16 96       	adiw	r26, 0x06	; 6
    1800:	6c 91       	ld	r22, X
    1802:	16 97       	sbiw	r26, 0x06	; 6
    1804:	14 96       	adiw	r26, 0x04	; 4
    1806:	8d 91       	ld	r24, X+
    1808:	9c 91       	ld	r25, X
    180a:	15 97       	sbiw	r26, 0x05	; 5
    180c:	0e 94 0c 04 	call	0x818	; 0x818 <_ZN8I2CAgent12setSlaveAddrEh>
    1810:	df 91       	pop	r29
    1812:	cf 91       	pop	r28
    1814:	1f 91       	pop	r17
    1816:	0f 91       	pop	r16
    1818:	ff 90       	pop	r15
    181a:	ef 90       	pop	r14
    181c:	df 90       	pop	r13
    181e:	cf 90       	pop	r12
    1820:	bf 90       	pop	r11
    1822:	af 90       	pop	r10
    1824:	9f 90       	pop	r9
    1826:	8f 90       	pop	r8
    1828:	7f 90       	pop	r7
    182a:	6f 90       	pop	r6
    182c:	5f 90       	pop	r5
    182e:	4f 90       	pop	r4
    1830:	3f 90       	pop	r3
    1832:	08 95       	ret

00001834 <_ZN7MMA845110getReadingEv>:

uint16_t MMA8451::getReading()
{
    1834:	0f 93       	push	r16
    1836:	1f 93       	push	r17
    1838:	cf 93       	push	r28
    183a:	df 93       	push	r29
    183c:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*queryX_);
    183e:	8c 81       	ldd	r24, Y+4	; 0x04
    1840:	9d 81       	ldd	r25, Y+5	; 0x05
    1842:	6b 85       	ldd	r22, Y+11	; 0x0b
    1844:	7c 85       	ldd	r23, Y+12	; 0x0c
    1846:	dc 01       	movw	r26, r24
    1848:	ed 91       	ld	r30, X+
    184a:	fc 91       	ld	r31, X
    184c:	01 90       	ld	r0, Z+
    184e:	f0 81       	ld	r31, Z
    1850:	e0 2d       	mov	r30, r0
    1852:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    1854:	8c 81       	ldd	r24, Y+4	; 0x04
    1856:	9d 81       	ldd	r25, Y+5	; 0x05
    1858:	dc 01       	movw	r26, r24
    185a:	ed 91       	ld	r30, X+
    185c:	fc 91       	ld	r31, X
    185e:	02 80       	ldd	r0, Z+2	; 0x02
    1860:	f3 81       	ldd	r31, Z+3	; 0x03
    1862:	e0 2d       	mov	r30, r0
    1864:	19 95       	eicall
    1866:	8c 01       	movw	r16, r24
  i2cAgent_->transmit(*queryY_);
    1868:	8c 81       	ldd	r24, Y+4	; 0x04
    186a:	9d 81       	ldd	r25, Y+5	; 0x05
    186c:	6d 85       	ldd	r22, Y+13	; 0x0d
    186e:	7e 85       	ldd	r23, Y+14	; 0x0e
    1870:	dc 01       	movw	r26, r24
    1872:	ed 91       	ld	r30, X+
    1874:	fc 91       	ld	r31, X
    1876:	01 90       	ld	r0, Z+
    1878:	f0 81       	ld	r31, Z
    187a:	e0 2d       	mov	r30, r0
    187c:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    187e:	8c 81       	ldd	r24, Y+4	; 0x04
    1880:	9d 81       	ldd	r25, Y+5	; 0x05
    1882:	dc 01       	movw	r26, r24
    1884:	ed 91       	ld	r30, X+
    1886:	fc 91       	ld	r31, X
    1888:	02 80       	ldd	r0, Z+2	; 0x02
    188a:	f3 81       	ldd	r31, Z+3	; 0x03
    188c:	e0 2d       	mov	r30, r0
    188e:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    1890:	8c 81       	ldd	r24, Y+4	; 0x04
    1892:	9d 81       	ldd	r25, Y+5	; 0x05
    1894:	6f 85       	ldd	r22, Y+15	; 0x0f
    1896:	78 89       	ldd	r23, Y+16	; 0x10
    1898:	dc 01       	movw	r26, r24
    189a:	ed 91       	ld	r30, X+
    189c:	fc 91       	ld	r31, X
    189e:	01 90       	ld	r0, Z+
    18a0:	f0 81       	ld	r31, Z
    18a2:	e0 2d       	mov	r30, r0
    18a4:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    18a6:	8c 81       	ldd	r24, Y+4	; 0x04
    18a8:	9d 81       	ldd	r25, Y+5	; 0x05
    18aa:	dc 01       	movw	r26, r24
    18ac:	ed 91       	ld	r30, X+
    18ae:	fc 91       	ld	r31, X
    18b0:	02 80       	ldd	r0, Z+2	; 0x02
    18b2:	f3 81       	ldd	r31, Z+3	; 0x03
    18b4:	e0 2d       	mov	r30, r0
    18b6:	19 95       	eicall
  uint16_t xReading = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    18b8:	d8 01       	movw	r26, r16
    18ba:	ed 91       	ld	r30, X+
    18bc:	fc 91       	ld	r31, X
    18be:	00 84       	ldd	r0, Z+8	; 0x08
    18c0:	f1 85       	ldd	r31, Z+9	; 0x09
    18c2:	e0 2d       	mov	r30, r0
    18c4:	c8 01       	movw	r24, r16
    18c6:	19 95       	eicall
    18c8:	c8 2f       	mov	r28, r24
    18ca:	d8 01       	movw	r26, r16
    18cc:	ed 91       	ld	r30, X+
    18ce:	fc 91       	ld	r31, X
    18d0:	00 84       	ldd	r0, Z+8	; 0x08
    18d2:	f1 85       	ldd	r31, Z+9	; 0x09
    18d4:	e0 2d       	mov	r30, r0
    18d6:	c8 01       	movw	r24, r16
    18d8:	19 95       	eicall
  return xReading;
    18da:	2c 2f       	mov	r18, r28
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	32 2f       	mov	r19, r18
    18e0:	22 27       	eor	r18, r18
}
    18e2:	a9 01       	movw	r20, r18
    18e4:	48 2b       	or	r20, r24
    18e6:	ca 01       	movw	r24, r20
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	1f 91       	pop	r17
    18ee:	0f 91       	pop	r16
    18f0:	08 95       	ret

000018f2 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    18f2:	cf 93       	push	r28
    18f4:	df 93       	push	r29
    18f6:	ec 01       	movw	r28, r24
  while( not_empty() )
    18f8:	e8 81       	ld	r30, Y
    18fa:	f9 81       	ldd	r31, Y+1	; 0x01
    18fc:	00 8c       	ldd	r0, Z+24	; 0x18
    18fe:	f1 8d       	ldd	r31, Z+25	; 0x19
    1900:	e0 2d       	mov	r30, r0
    1902:	ce 01       	movw	r24, r28
    1904:	19 95       	eicall
    1906:	88 23       	and	r24, r24
    1908:	41 f0       	breq	.+16     	; 0x191a <_ZN6Packet12resetContentEv+0x28>
  {
    get();
    190a:	e8 81       	ld	r30, Y
    190c:	f9 81       	ldd	r31, Y+1	; 0x01
    190e:	00 84       	ldd	r0, Z+8	; 0x08
    1910:	f1 85       	ldd	r31, Z+9	; 0x09
    1912:	e0 2d       	mov	r30, r0
    1914:	ce 01       	movw	r24, r28
    1916:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  while( not_empty() )
    1918:	ef cf       	rjmp	.-34     	; 0x18f8 <_ZN6Packet12resetContentEv+0x6>
  {
    get();
  }
    191a:	df 91       	pop	r29
    191c:	cf 91       	pop	r28
    191e:	08 95       	ret

00001920 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    1920:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1922:	8c 85       	ldd	r24, Y+12	; 0x0c
    1924:	88 23       	and	r24, r24
    1926:	19 f0       	breq	.+6      	; 0x192e <_ZN10task_sonar3runEv+0xe>
    1928:	81 30       	cpi	r24, 0x01	; 1
    192a:	71 f0       	breq	.+28     	; 0x1948 <_ZN10task_sonar3runEv+0x28>
    192c:	29 c0       	rjmp	.+82     	; 0x1980 <_ZN10task_sonar3runEv+0x60>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
			  *p_serial << mma8451_->getReading() << endl;
    192e:	8c 89       	ldd	r24, Y+20	; 0x14
    1930:	9d 89       	ldd	r25, Y+21	; 0x15
    1932:	0e 94 1a 0c 	call	0x1834	; 0x1834 <_ZN7MMA845110getReadingEv>
    1936:	bc 01       	movw	r22, r24
    1938:	8e 81       	ldd	r24, Y+6	; 0x06
    193a:	9f 81       	ldd	r25, Y+7	; 0x07
    193c:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    1940:	66 e0       	ldi	r22, 0x06	; 6
    1942:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
				// *p_serial << "Range cmd" << endl;
				// mma8451_->takeReading();	
				
				// transition_to(1);			
			
			  break;
    1946:	1c c0       	rjmp	.+56     	; 0x1980 <_ZN10task_sonar3runEv+0x60>
				
			case (1):
			
				rangeReading_ = mma8451_->getReading();
    1948:	8c 89       	ldd	r24, Y+20	; 0x14
    194a:	9d 89       	ldd	r25, Y+21	; 0x15
    194c:	0e 94 1a 0c 	call	0x1834	; 0x1834 <_ZN7MMA845110getReadingEv>
    1950:	7c 01       	movw	r14, r24
    1952:	8a 8b       	std	Y+18, r24	; 0x12
    1954:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << rangeReading_ << endl;
    1956:	6a e0       	ldi	r22, 0x0A	; 10
    1958:	8e 81       	ldd	r24, Y+6	; 0x06
    195a:	9f 81       	ldd	r25, Y+7	; 0x07
    195c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1960:	8c 01       	movw	r16, r24
    1962:	66 eb       	ldi	r22, 0xB6	; 182
    1964:	73 e0       	ldi	r23, 0x03	; 3
    1966:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    196a:	b7 01       	movw	r22, r14
    196c:	c8 01       	movw	r24, r16
    196e:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    1972:	66 e0       	ldi	r22, 0x06	; 6
    1974:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    1978:	60 e0       	ldi	r22, 0x00	; 0
    197a:	ce 01       	movw	r24, r28
    197c:	0e 94 9f 1a 	call	0x353e	; 0x353e <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1980:	8e 85       	ldd	r24, Y+14	; 0x0e
    1982:	9f 85       	ldd	r25, Y+15	; 0x0f
    1984:	a8 89       	ldd	r26, Y+16	; 0x10
    1986:	b9 89       	ldd	r27, Y+17	; 0x11
    1988:	01 96       	adiw	r24, 0x01	; 1
    198a:	a1 1d       	adc	r26, r1
    198c:	b1 1d       	adc	r27, r1
    198e:	8e 87       	std	Y+14, r24	; 0x0e
    1990:	9f 87       	std	Y+15, r25	; 0x0f
    1992:	a8 8b       	std	Y+16, r26	; 0x10
    1994:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (5000));
    1996:	68 e8       	ldi	r22, 0x88	; 136
    1998:	73 e1       	ldi	r23, 0x13	; 19
    199a:	80 e0       	ldi	r24, 0x00	; 0
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	0e 94 73 18 	call	0x30e6	; 0x30e6 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    19a2:	bf cf       	rjmp	.-130    	; 0x1922 <_ZN10task_sonar3runEv+0x2>

000019a4 <_ZN10task_sonarC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    19a4:	cf 92       	push	r12
    19a6:	df 92       	push	r13
    19a8:	ef 92       	push	r14
    19aa:	ff 92       	push	r15
    19ac:	0f 93       	push	r16
    19ae:	1f 93       	push	r17
    19b0:	cf 93       	push	r28
    19b2:	df 93       	push	r29
    19b4:	ec 01       	movw	r28, r24
    19b6:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    19b8:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN8frt_taskC1EPKchjP8emstream>
    19bc:	8b e1       	ldi	r24, 0x1B	; 27
    19be:	92 e2       	ldi	r25, 0x22	; 34
    19c0:	88 83       	st	Y, r24
    19c2:	99 83       	std	Y+1, r25	; 0x01
    19c4:	ec 8a       	std	Y+20, r14	; 0x14
    19c6:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    19c8:	ce 8a       	std	Y+22, r12	; 0x16
    19ca:	df 8a       	std	Y+23, r13	; 0x17
}
    19cc:	df 91       	pop	r29
    19ce:	cf 91       	pop	r28
    19d0:	1f 91       	pop	r17
    19d2:	0f 91       	pop	r16
    19d4:	ff 90       	pop	r15
    19d6:	ef 90       	pop	r14
    19d8:	df 90       	pop	r13
    19da:	cf 90       	pop	r12
    19dc:	08 95       	ret

000019de <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    19de:	0f 93       	push	r16
    19e0:	1f 93       	push	r17
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
    19e6:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    19e8:	0e 94 a3 1a 	call	0x3546	; 0x3546 <_ZN8frt_taskC1EPKchjP8emstream>
    19ec:	83 e2       	ldi	r24, 0x23	; 35
    19ee:	92 e2       	ldi	r25, 0x22	; 34
    19f0:	88 83       	st	Y, r24
    19f2:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	1f 91       	pop	r17
    19fa:	0f 91       	pop	r16
    19fc:	08 95       	ret

000019fe <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
    1a02:	cf 93       	push	r28
    1a04:	df 93       	push	r29
    1a06:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1a08:	6a e0       	ldi	r22, 0x0A	; 10
    1a0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a0e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a12:	8c 01       	movw	r16, r24
    1a14:	61 e1       	ldi	r22, 0x11	; 17
    1a16:	75 e0       	ldi	r23, 0x05	; 5
    1a18:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a1c:	6a e0       	ldi	r22, 0x0A	; 10
    1a1e:	c8 01       	movw	r24, r16
    1a20:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a24:	8c 01       	movw	r16, r24
    1a26:	6b e0       	ldi	r22, 0x0B	; 11
    1a28:	75 e0       	ldi	r23, 0x05	; 5
    1a2a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a2e:	67 e0       	ldi	r22, 0x07	; 7
    1a30:	c8 01       	movw	r24, r16
    1a32:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1a36:	6a e0       	ldi	r22, 0x0A	; 10
    1a38:	8e 81       	ldd	r24, Y+6	; 0x06
    1a3a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a3c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a40:	8c 01       	movw	r16, r24
    1a42:	6c ee       	ldi	r22, 0xEC	; 236
    1a44:	74 e0       	ldi	r23, 0x04	; 4
    1a46:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a4a:	6a e0       	ldi	r22, 0x0A	; 10
    1a4c:	c8 01       	movw	r24, r16
    1a4e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a52:	8c 01       	movw	r16, r24
    1a54:	66 ee       	ldi	r22, 0xE6	; 230
    1a56:	74 e0       	ldi	r23, 0x04	; 4
    1a58:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a5c:	66 e0       	ldi	r22, 0x06	; 6
    1a5e:	c8 01       	movw	r24, r16
    1a60:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1a64:	6a e0       	ldi	r22, 0x0A	; 10
    1a66:	8e 81       	ldd	r24, Y+6	; 0x06
    1a68:	9f 81       	ldd	r25, Y+7	; 0x07
    1a6a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a6e:	8c 01       	movw	r16, r24
    1a70:	6f ec       	ldi	r22, 0xCF	; 207
    1a72:	74 e0       	ldi	r23, 0x04	; 4
    1a74:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a78:	66 e0       	ldi	r22, 0x06	; 6
    1a7a:	c8 01       	movw	r24, r16
    1a7c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1a80:	6a e0       	ldi	r22, 0x0A	; 10
    1a82:	8e 81       	ldd	r24, Y+6	; 0x06
    1a84:	9f 81       	ldd	r25, Y+7	; 0x07
    1a86:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1a8a:	8c 01       	movw	r16, r24
    1a8c:	63 eb       	ldi	r22, 0xB3	; 179
    1a8e:	74 e0       	ldi	r23, 0x04	; 4
    1a90:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1a94:	66 e0       	ldi	r22, 0x06	; 6
    1a96:	c8 01       	movw	r24, r16
    1a98:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1a9c:	6a e0       	ldi	r22, 0x0A	; 10
    1a9e:	8e 81       	ldd	r24, Y+6	; 0x06
    1aa0:	9f 81       	ldd	r25, Y+7	; 0x07
    1aa2:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1aa6:	8c 01       	movw	r16, r24
    1aa8:	6b e9       	ldi	r22, 0x9B	; 155
    1aaa:	74 e0       	ldi	r23, 0x04	; 4
    1aac:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1ab0:	66 e0       	ldi	r22, 0x06	; 6
    1ab2:	c8 01       	movw	r24, r16
    1ab4:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1ab8:	6a e0       	ldi	r22, 0x0A	; 10
    1aba:	8e 81       	ldd	r24, Y+6	; 0x06
    1abc:	9f 81       	ldd	r25, Y+7	; 0x07
    1abe:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1ac2:	8c 01       	movw	r16, r24
    1ac4:	6a e7       	ldi	r22, 0x7A	; 122
    1ac6:	74 e0       	ldi	r23, 0x04	; 4
    1ac8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1acc:	66 e0       	ldi	r22, 0x06	; 6
    1ace:	c8 01       	movw	r24, r16
    1ad0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1ad4:	6a e0       	ldi	r22, 0x0A	; 10
    1ad6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ad8:	9f 81       	ldd	r25, Y+7	; 0x07
    1ada:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1ade:	8c 01       	movw	r16, r24
    1ae0:	63 e5       	ldi	r22, 0x53	; 83
    1ae2:	74 e0       	ldi	r23, 0x04	; 4
    1ae4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1ae8:	66 e0       	ldi	r22, 0x06	; 6
    1aea:	c8 01       	movw	r24, r16
    1aec:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1af0:	6a e0       	ldi	r22, 0x0A	; 10
    1af2:	8e 81       	ldd	r24, Y+6	; 0x06
    1af4:	9f 81       	ldd	r25, Y+7	; 0x07
    1af6:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1afa:	8c 01       	movw	r16, r24
    1afc:	65 e3       	ldi	r22, 0x35	; 53
    1afe:	74 e0       	ldi	r23, 0x04	; 4
    1b00:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1b04:	66 e0       	ldi	r22, 0x06	; 6
    1b06:	c8 01       	movw	r24, r16
    1b08:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1b0c:	6a e0       	ldi	r22, 0x0A	; 10
    1b0e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b10:	9f 81       	ldd	r25, Y+7	; 0x07
    1b12:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1b16:	8c 01       	movw	r16, r24
    1b18:	6a e1       	ldi	r22, 0x1A	; 26
    1b1a:	74 e0       	ldi	r23, 0x04	; 4
    1b1c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1b20:	66 e0       	ldi	r22, 0x06	; 6
    1b22:	c8 01       	movw	r24, r16
    1b24:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1b28:	6a e0       	ldi	r22, 0x0A	; 10
    1b2a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b2c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b2e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1b32:	ec 01       	movw	r28, r24
    1b34:	6b e0       	ldi	r22, 0x0B	; 11
    1b36:	74 e0       	ldi	r23, 0x04	; 4
    1b38:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1b3c:	66 e0       	ldi	r22, 0x06	; 6
    1b3e:	ce 01       	movw	r24, r28
    1b40:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
}
    1b44:	df 91       	pop	r29
    1b46:	cf 91       	pop	r28
    1b48:	1f 91       	pop	r17
    1b4a:	0f 91       	pop	r16
    1b4c:	08 95       	ret

00001b4e <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1b4e:	af 92       	push	r10
    1b50:	bf 92       	push	r11
    1b52:	cf 92       	push	r12
    1b54:	df 92       	push	r13
    1b56:	ef 92       	push	r14
    1b58:	ff 92       	push	r15
    1b5a:	0f 93       	push	r16
    1b5c:	1f 93       	push	r17
    1b5e:	cf 93       	push	r28
    1b60:	df 93       	push	r29
    1b62:	00 d0       	rcall	.+0      	; 0x1b64 <_ZN9task_user11show_statusEv+0x16>
    1b64:	00 d0       	rcall	.+0      	; 0x1b66 <_ZN9task_user11show_statusEv+0x18>
    1b66:	cd b7       	in	r28, 0x3d	; 61
    1b68:	de b7       	in	r29, 0x3e	; 62
    1b6a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1b6c:	19 82       	std	Y+1, r1	; 0x01
    1b6e:	1a 82       	std	Y+2, r1	; 0x02
    1b70:	1b 82       	std	Y+3, r1	; 0x03
    1b72:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1b74:	1d 82       	std	Y+5, r1	; 0x05
    1b76:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1b78:	0e 94 2c 10 	call	0x2058	; 0x2058 <xPortGetFreeHeapSize>
    1b7c:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1b7e:	ce 01       	movw	r24, r28
    1b80:	01 96       	adiw	r24, 0x01	; 1
    1b82:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <_ZN10time_stamp10set_to_nowEv>
    1b86:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1b88:	66 e0       	ldi	r22, 0x06	; 6
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	86 81       	ldd	r24, Z+6	; 0x06
    1b8e:	97 81       	ldd	r25, Z+7	; 0x07
    1b90:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1b94:	6a e0       	ldi	r22, 0x0A	; 10
    1b96:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1b9a:	7c 01       	movw	r14, r24
    1b9c:	6c ee       	ldi	r22, 0xEC	; 236
    1b9e:	73 e0       	ldi	r23, 0x03	; 3
    1ba0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1ba4:	6a e0       	ldi	r22, 0x0A	; 10
    1ba6:	c7 01       	movw	r24, r14
    1ba8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1bac:	7c 01       	movw	r14, r24
    1bae:	60 ee       	ldi	r22, 0xE0	; 224
    1bb0:	73 e0       	ldi	r23, 0x03	; 3
    1bb2:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1bb6:	66 e0       	ldi	r22, 0x06	; 6
    1bb8:	c7 01       	movw	r24, r14
    1bba:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1bbe:	6a e0       	ldi	r22, 0x0A	; 10
    1bc0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1bc4:	7c 01       	movw	r14, r24
    1bc6:	69 ed       	ldi	r22, 0xD9	; 217
    1bc8:	73 e0       	ldi	r23, 0x03	; 3
    1bca:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1bce:	b5 01       	movw	r22, r10
    1bd0:	c7 01       	movw	r24, r14
    1bd2:	0e 94 f8 1d 	call	0x3bf0	; 0x3bf0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1bd6:	6a e0       	ldi	r22, 0x0A	; 10
    1bd8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1bdc:	7c 01       	movw	r14, r24
    1bde:	6b ec       	ldi	r22, 0xCB	; 203
    1be0:	73 e0       	ldi	r23, 0x03	; 3
    1be2:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1be6:	b6 01       	movw	r22, r12
    1be8:	c7 01       	movw	r24, r14
    1bea:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    1bee:	6a e0       	ldi	r22, 0x0A	; 10
    1bf0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1bf4:	7c 01       	movw	r14, r24
    1bf6:	69 ec       	ldi	r22, 0xC9	; 201
    1bf8:	73 e0       	ldi	r23, 0x03	; 3
    1bfa:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1bfe:	4f ef       	ldi	r20, 0xFF	; 255
    1c00:	5f e0       	ldi	r21, 0x0F	; 15
    1c02:	60 e0       	ldi	r22, 0x00	; 0
    1c04:	70 e0       	ldi	r23, 0x00	; 0
    1c06:	c7 01       	movw	r24, r14
    1c08:	0e 94 c0 20 	call	0x4180	; 0x4180 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1c0c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1c10:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1c14:	6a e0       	ldi	r22, 0x0A	; 10
    1c16:	f8 01       	movw	r30, r16
    1c18:	86 81       	ldd	r24, Z+6	; 0x06
    1c1a:	97 81       	ldd	r25, Z+7	; 0x07
    1c1c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1c20:	7c 01       	movw	r14, r24
    1c22:	6e eb       	ldi	r22, 0xBE	; 190
    1c24:	73 e0       	ldi	r23, 0x03	; 3
    1c26:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1c2a:	b6 01       	movw	r22, r12
    1c2c:	c7 01       	movw	r24, r14
    1c2e:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    1c32:	66 e0       	ldi	r22, 0x06	; 6
    1c34:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1c38:	66 e0       	ldi	r22, 0x06	; 6
    1c3a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1c3e:	f8 01       	movw	r30, r16
    1c40:	86 81       	ldd	r24, Z+6	; 0x06
    1c42:	97 81       	ldd	r25, Z+7	; 0x07
    1c44:	0e 94 b1 1c 	call	0x3962	; 0x3962 <_Z15print_task_listP8emstream>
}
    1c48:	26 96       	adiw	r28, 0x06	; 6
    1c4a:	cd bf       	out	0x3d, r28	; 61
    1c4c:	de bf       	out	0x3e, r29	; 62
    1c4e:	df 91       	pop	r29
    1c50:	cf 91       	pop	r28
    1c52:	1f 91       	pop	r17
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	cf 90       	pop	r12
    1c5e:	bf 90       	pop	r11
    1c60:	af 90       	pop	r10
    1c62:	08 95       	ret

00001c64 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1c64:	cf 93       	push	r28
    1c66:	df 93       	push	r29
    1c68:	00 d0       	rcall	.+0      	; 0x1c6a <_ZN9task_user3runEv+0x6>
    1c6a:	00 d0       	rcall	.+0      	; 0x1c6c <_ZN9task_user3runEv+0x8>
    1c6c:	cd b7       	in	r28, 0x3d	; 61
    1c6e:	de b7       	in	r29, 0x3e	; 62
    1c70:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1c72:	19 82       	std	Y+1, r1	; 0x01
    1c74:	1a 82       	std	Y+2, r1	; 0x02
    1c76:	1b 82       	std	Y+3, r1	; 0x03
    1c78:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1c7a:	1d 82       	std	Y+5, r1	; 0x05
    1c7c:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1c7e:	6a e0       	ldi	r22, 0x0A	; 10
    1c80:	dc 01       	movw	r26, r24
    1c82:	16 96       	adiw	r26, 0x06	; 6
    1c84:	8d 91       	ld	r24, X+
    1c86:	9c 91       	ld	r25, X
    1c88:	17 97       	sbiw	r26, 0x07	; 7
    1c8a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1c8e:	7c 01       	movw	r14, r24
    1c90:	6a e5       	ldi	r22, 0x5A	; 90
    1c92:	75 e0       	ldi	r23, 0x05	; 5
    1c94:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1c98:	66 e0       	ldi	r22, 0x06	; 6
    1c9a:	c7 01       	movw	r24, r14
    1c9c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1ca0:	f8 01       	movw	r30, r16
    1ca2:	84 85       	ldd	r24, Z+12	; 0x0c
    1ca4:	88 23       	and	r24, r24
    1ca6:	21 f0       	breq	.+8      	; 0x1cb0 <_ZN9task_user3runEv+0x4c>
    1ca8:	81 30       	cpi	r24, 0x01	; 1
    1caa:	09 f4       	brne	.+2      	; 0x1cae <_ZN9task_user3runEv+0x4a>
    1cac:	5d c0       	rjmp	.+186    	; 0x1d68 <_ZN9task_user3runEv+0x104>
    1cae:	d8 c0       	rjmp	.+432    	; 0x1e60 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1cb0:	86 81       	ldd	r24, Z+6	; 0x06
    1cb2:	97 81       	ldd	r25, Z+7	; 0x07
    1cb4:	dc 01       	movw	r26, r24
    1cb6:	ed 91       	ld	r30, X+
    1cb8:	fc 91       	ld	r31, X
    1cba:	04 80       	ldd	r0, Z+4	; 0x04
    1cbc:	f5 81       	ldd	r31, Z+5	; 0x05
    1cbe:	e0 2d       	mov	r30, r0
    1cc0:	19 95       	eicall
    1cc2:	88 23       	and	r24, r24
    1cc4:	a9 f1       	breq	.+106    	; 0x1d30 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1cc6:	f8 01       	movw	r30, r16
    1cc8:	86 81       	ldd	r24, Z+6	; 0x06
    1cca:	97 81       	ldd	r25, Z+7	; 0x07
    1ccc:	dc 01       	movw	r26, r24
    1cce:	ed 91       	ld	r30, X+
    1cd0:	fc 91       	ld	r31, X
    1cd2:	06 80       	ldd	r0, Z+6	; 0x06
    1cd4:	f7 81       	ldd	r31, Z+7	; 0x07
    1cd6:	e0 2d       	mov	r30, r0
    1cd8:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1cda:	99 27       	eor	r25, r25
    1cdc:	81 30       	cpi	r24, 0x01	; 1
    1cde:	91 05       	cpc	r25, r1
    1ce0:	f9 f0       	breq	.+62     	; 0x1d20 <_ZN9task_user3runEv+0xbc>
    1ce2:	03 97       	sbiw	r24, 0x03	; 3
    1ce4:	09 f0       	breq	.+2      	; 0x1ce8 <_ZN9task_user3runEv+0x84>
    1ce6:	d8 c0       	rjmp	.+432    	; 0x1e98 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1ce8:	6a e0       	ldi	r22, 0x0A	; 10
    1cea:	f8 01       	movw	r30, r16
    1cec:	86 81       	ldd	r24, Z+6	; 0x06
    1cee:	97 81       	ldd	r25, Z+7	; 0x07
    1cf0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1cf4:	8c 01       	movw	r16, r24
    1cf6:	6c e4       	ldi	r22, 0x4C	; 76
    1cf8:	75 e0       	ldi	r23, 0x05	; 5
    1cfa:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1cfe:	66 e0       	ldi	r22, 0x06	; 6
    1d00:	c8 01       	movw	r24, r16
    1d02:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1d06:	93 e0       	ldi	r25, 0x03	; 3
    1d08:	88 ed       	ldi	r24, 0xD8	; 216
    1d0a:	08 b6       	in	r0, 0x38	; 56
    1d0c:	18 be       	out	0x38, r1	; 56
    1d0e:	84 bf       	out	0x34, r24	; 52
    1d10:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1d14:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1d18:	81 fd       	sbrc	r24, 1
    1d1a:	fc cf       	rjmp	.-8      	; 0x1d14 <_ZN9task_user3runEv+0xb0>
    1d1c:	08 be       	out	0x38, r0	; 56
    1d1e:	ff cf       	rjmp	.-2      	; 0x1d1e <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1d20:	c8 01       	movw	r24, r16
    1d22:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1d26:	61 e0       	ldi	r22, 0x01	; 1
    1d28:	c8 01       	movw	r24, r16
    1d2a:	0e 94 9f 1a 	call	0x353e	; 0x353e <_ZN8frt_task13transition_toEh>
							break;
    1d2e:	b4 c0       	rjmp	.+360    	; 0x1e98 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1d30:	86 e9       	ldi	r24, 0x96	; 150
    1d32:	93 e3       	ldi	r25, 0x33	; 51
    1d34:	0e 94 60 1d 	call	0x3ac0	; 0x3ac0 <_ZN14frt_text_queue14check_for_charEv>
    1d38:	88 23       	and	r24, r24
    1d3a:	09 f4       	brne	.+2      	; 0x1d3e <_ZN9task_user3runEv+0xda>
    1d3c:	ad c0       	rjmp	.+346    	; 0x1e98 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1d3e:	d8 01       	movw	r26, r16
    1d40:	16 96       	adiw	r26, 0x06	; 6
    1d42:	ed 91       	ld	r30, X+
    1d44:	fc 91       	ld	r31, X
    1d46:	17 97       	sbiw	r26, 0x07	; 7
    1d48:	01 90       	ld	r0, Z+
    1d4a:	f0 81       	ld	r31, Z
    1d4c:	e0 2d       	mov	r30, r0
    1d4e:	e2 80       	ldd	r14, Z+2	; 0x02
    1d50:	f3 80       	ldd	r15, Z+3	; 0x03
    1d52:	86 e9       	ldi	r24, 0x96	; 150
    1d54:	93 e3       	ldi	r25, 0x33	; 51
    1d56:	0e 94 42 1d 	call	0x3a84	; 0x3a84 <_ZN14frt_text_queue7getcharEv>
    1d5a:	68 2f       	mov	r22, r24
    1d5c:	f8 01       	movw	r30, r16
    1d5e:	86 81       	ldd	r24, Z+6	; 0x06
    1d60:	97 81       	ldd	r25, Z+7	; 0x07
    1d62:	f7 01       	movw	r30, r14
    1d64:	19 95       	eicall
    1d66:	98 c0       	rjmp	.+304    	; 0x1e98 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1d68:	86 81       	ldd	r24, Z+6	; 0x06
    1d6a:	97 81       	ldd	r25, Z+7	; 0x07
    1d6c:	dc 01       	movw	r26, r24
    1d6e:	ed 91       	ld	r30, X+
    1d70:	fc 91       	ld	r31, X
    1d72:	04 80       	ldd	r0, Z+4	; 0x04
    1d74:	f5 81       	ldd	r31, Z+5	; 0x05
    1d76:	e0 2d       	mov	r30, r0
    1d78:	19 95       	eicall
    1d7a:	88 23       	and	r24, r24
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <_ZN9task_user3runEv+0x11c>
    1d7e:	8c c0       	rjmp	.+280    	; 0x1e98 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1d80:	f8 01       	movw	r30, r16
    1d82:	86 81       	ldd	r24, Z+6	; 0x06
    1d84:	97 81       	ldd	r25, Z+7	; 0x07
    1d86:	dc 01       	movw	r26, r24
    1d88:	ed 91       	ld	r30, X+
    1d8a:	fc 91       	ld	r31, X
    1d8c:	06 80       	ldd	r0, Z+6	; 0x06
    1d8e:	f7 81       	ldd	r31, Z+7	; 0x07
    1d90:	e0 2d       	mov	r30, r0
    1d92:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1d94:	9c 01       	movw	r18, r24
    1d96:	33 27       	eor	r19, r19
    1d98:	28 36       	cpi	r18, 0x68	; 104
    1d9a:	31 05       	cpc	r19, r1
    1d9c:	59 f1       	breq	.+86     	; 0x1df4 <_ZN9task_user3runEv+0x190>
    1d9e:	3c f4       	brge	.+14     	; 0x1dae <_ZN9task_user3runEv+0x14a>
    1da0:	2b 31       	cpi	r18, 0x1B	; 27
    1da2:	31 05       	cpc	r19, r1
    1da4:	59 f1       	breq	.+86     	; 0x1dfc <_ZN9task_user3runEv+0x198>
    1da6:	25 36       	cpi	r18, 0x65	; 101
    1da8:	31 05       	cpc	r19, r1
    1daa:	41 f1       	breq	.+80     	; 0x1dfc <_ZN9task_user3runEv+0x198>
    1dac:	3b c0       	rjmp	.+118    	; 0x1e24 <_ZN9task_user3runEv+0x1c0>
    1dae:	23 37       	cpi	r18, 0x73	; 115
    1db0:	31 05       	cpc	r19, r1
    1db2:	c1 f0       	breq	.+48     	; 0x1de4 <_ZN9task_user3runEv+0x180>
    1db4:	26 37       	cpi	r18, 0x76	; 118
    1db6:	31 05       	cpc	r19, r1
    1db8:	89 f0       	breq	.+34     	; 0x1ddc <_ZN9task_user3runEv+0x178>
    1dba:	2e 36       	cpi	r18, 0x6E	; 110
    1dbc:	31 05       	cpc	r19, r1
    1dbe:	91 f5       	brne	.+100    	; 0x1e24 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1dc0:	ce 01       	movw	r24, r28
    1dc2:	01 96       	adiw	r24, 0x01	; 1
    1dc4:	0e 94 54 1e 	call	0x3ca8	; 0x3ca8 <_ZN10time_stamp10set_to_nowEv>
    1dc8:	bc 01       	movw	r22, r24
    1dca:	f8 01       	movw	r30, r16
    1dcc:	86 81       	ldd	r24, Z+6	; 0x06
    1dce:	97 81       	ldd	r25, Z+7	; 0x07
    1dd0:	0e 94 f8 1d 	call	0x3bf0	; 0x3bf0 <_ZlsR8emstreamR10time_stamp>
    1dd4:	66 e0       	ldi	r22, 0x06	; 6
    1dd6:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1dda:	5e c0       	rjmp	.+188    	; 0x1e98 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1ddc:	c8 01       	movw	r24, r16
    1dde:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <_ZN9task_user11show_statusEv>
							break;
    1de2:	5a c0       	rjmp	.+180    	; 0x1e98 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1de4:	d8 01       	movw	r26, r16
    1de6:	16 96       	adiw	r26, 0x06	; 6
    1de8:	8d 91       	ld	r24, X+
    1dea:	9c 91       	ld	r25, X
    1dec:	17 97       	sbiw	r26, 0x07	; 7
    1dee:	0e 94 b8 1b 	call	0x3770	; 0x3770 <_Z17print_task_stacksP8emstream>
							break;
    1df2:	52 c0       	rjmp	.+164    	; 0x1e98 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1df4:	c8 01       	movw	r24, r16
    1df6:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <_ZN9task_user18print_help_messageEv>
							break;
    1dfa:	4e c0       	rjmp	.+156    	; 0x1e98 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1dfc:	6a e0       	ldi	r22, 0x0A	; 10
    1dfe:	f8 01       	movw	r30, r16
    1e00:	86 81       	ldd	r24, Z+6	; 0x06
    1e02:	97 81       	ldd	r25, Z+7	; 0x07
    1e04:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1e08:	7c 01       	movw	r14, r24
    1e0a:	6a e3       	ldi	r22, 0x3A	; 58
    1e0c:	75 e0       	ldi	r23, 0x05	; 5
    1e0e:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1e12:	66 e0       	ldi	r22, 0x06	; 6
    1e14:	c7 01       	movw	r24, r14
    1e16:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1e1a:	60 e0       	ldi	r22, 0x00	; 0
    1e1c:	c8 01       	movw	r24, r16
    1e1e:	0e 94 9f 1a 	call	0x353e	; 0x353e <_ZN8frt_task13transition_toEh>
							break;
    1e22:	3a c0       	rjmp	.+116    	; 0x1e98 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1e24:	f8 01       	movw	r30, r16
    1e26:	a6 81       	ldd	r26, Z+6	; 0x06
    1e28:	b7 81       	ldd	r27, Z+7	; 0x07
    1e2a:	ed 91       	ld	r30, X+
    1e2c:	fc 91       	ld	r31, X
    1e2e:	11 97       	sbiw	r26, 0x01	; 1
    1e30:	02 80       	ldd	r0, Z+2	; 0x02
    1e32:	f3 81       	ldd	r31, Z+3	; 0x03
    1e34:	e0 2d       	mov	r30, r0
    1e36:	68 2f       	mov	r22, r24
    1e38:	cd 01       	movw	r24, r26
    1e3a:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1e3c:	6a e0       	ldi	r22, 0x0A	; 10
    1e3e:	d8 01       	movw	r26, r16
    1e40:	16 96       	adiw	r26, 0x06	; 6
    1e42:	8d 91       	ld	r24, X+
    1e44:	9c 91       	ld	r25, X
    1e46:	17 97       	sbiw	r26, 0x07	; 7
    1e48:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1e4c:	7c 01       	movw	r14, r24
    1e4e:	64 e3       	ldi	r22, 0x34	; 52
    1e50:	75 e0       	ldi	r23, 0x05	; 5
    1e52:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1e56:	66 e0       	ldi	r22, 0x06	; 6
    1e58:	c7 01       	movw	r24, r14
    1e5a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1e5e:	1c c0       	rjmp	.+56     	; 0x1e98 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1e60:	6a e0       	ldi	r22, 0x0A	; 10
    1e62:	f8 01       	movw	r30, r16
    1e64:	86 81       	ldd	r24, Z+6	; 0x06
    1e66:	97 81       	ldd	r25, Z+7	; 0x07
    1e68:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    1e6c:	8c 01       	movw	r16, r24
    1e6e:	67 e1       	ldi	r22, 0x17	; 23
    1e70:	75 e0       	ldi	r23, 0x05	; 5
    1e72:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    1e76:	66 e0       	ldi	r22, 0x06	; 6
    1e78:	c8 01       	movw	r24, r16
    1e7a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1e7e:	93 e0       	ldi	r25, 0x03	; 3
    1e80:	88 ed       	ldi	r24, 0xD8	; 216
    1e82:	08 b6       	in	r0, 0x38	; 56
    1e84:	18 be       	out	0x38, r1	; 56
    1e86:	84 bf       	out	0x34, r24	; 52
    1e88:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1e8c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1e90:	81 fd       	sbrc	r24, 1
    1e92:	fc cf       	rjmp	.-8      	; 0x1e8c <_ZN9task_user3runEv+0x228>
    1e94:	08 be       	out	0x38, r0	; 56
    1e96:	ff cf       	rjmp	.-2      	; 0x1e96 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1e98:	f8 01       	movw	r30, r16
    1e9a:	86 85       	ldd	r24, Z+14	; 0x0e
    1e9c:	97 85       	ldd	r25, Z+15	; 0x0f
    1e9e:	a0 89       	ldd	r26, Z+16	; 0x10
    1ea0:	b1 89       	ldd	r27, Z+17	; 0x11
    1ea2:	01 96       	adiw	r24, 0x01	; 1
    1ea4:	a1 1d       	adc	r26, r1
    1ea6:	b1 1d       	adc	r27, r1
    1ea8:	86 87       	std	Z+14, r24	; 0x0e
    1eaa:	97 87       	std	Z+15, r25	; 0x0f
    1eac:	a0 8b       	std	Z+16, r26	; 0x10
    1eae:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1eb0:	68 ee       	ldi	r22, 0xE8	; 232
    1eb2:	73 e0       	ldi	r23, 0x03	; 3
    1eb4:	80 e0       	ldi	r24, 0x00	; 0
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	0e 94 73 18 	call	0x30e6	; 0x30e6 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1ebc:	f1 ce       	rjmp	.-542    	; 0x1ca0 <_ZN9task_user3runEv+0x3c>

00001ebe <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1ebe:	0f 93       	push	r16
    1ec0:	1f 93       	push	r17
    1ec2:	cf 93       	push	r28
    1ec4:	df 93       	push	r29
    1ec6:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1ec8:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1ecc:	80 91 da 22 	lds	r24, 0x22DA	; 0x8022da <__data_end>
    1ed0:	81 11       	cpse	r24, r1
    1ed2:	1d c0       	rjmp	.+58     	; 0x1f0e <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1ed4:	af ed       	ldi	r26, 0xDF	; 223
    1ed6:	b2 e2       	ldi	r27, 0x22	; 34
    1ed8:	e3 ee       	ldi	r30, 0xE3	; 227
    1eda:	f2 e2       	ldi	r31, 0x22	; 34
    1edc:	ed 93       	st	X+, r30
    1ede:	fc 93       	st	X, r31
    1ee0:	11 97       	sbiw	r26, 0x01	; 1
    1ee2:	12 96       	adiw	r26, 0x02	; 2
    1ee4:	1d 92       	st	X+, r1
    1ee6:	1c 92       	st	X, r1
    1ee8:	13 97       	sbiw	r26, 0x03	; 3
    1eea:	ab ed       	ldi	r26, 0xDB	; 219
    1eec:	b2 e2       	ldi	r27, 0x22	; 34
    1eee:	8f ef       	ldi	r24, 0xFF	; 255
    1ef0:	9f e0       	ldi	r25, 0x0F	; 15
    1ef2:	12 96       	adiw	r26, 0x02	; 2
    1ef4:	8d 93       	st	X+, r24
    1ef6:	9c 93       	st	X, r25
    1ef8:	13 97       	sbiw	r26, 0x03	; 3
    1efa:	1d 92       	st	X+, r1
    1efc:	1c 92       	st	X, r1
    1efe:	11 97       	sbiw	r26, 0x01	; 1
    1f00:	82 83       	std	Z+2, r24	; 0x02
    1f02:	93 83       	std	Z+3, r25	; 0x03
    1f04:	a0 83       	st	Z, r26
    1f06:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1f08:	81 e0       	ldi	r24, 0x01	; 1
    1f0a:	80 93 da 22 	sts	0x22DA, r24	; 0x8022da <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1f0e:	20 97       	sbiw	r28, 0x00	; 0
    1f10:	09 f4       	brne	.+2      	; 0x1f14 <pvPortMalloc+0x56>
    1f12:	5f c0       	rjmp	.+190    	; 0x1fd2 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1f14:	9e 01       	movw	r18, r28
    1f16:	2b 5f       	subi	r18, 0xFB	; 251
    1f18:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1f1a:	24 96       	adiw	r28, 0x04	; 4
    1f1c:	ce 3f       	cpi	r28, 0xFE	; 254
    1f1e:	df 40       	sbci	r29, 0x0F	; 15
    1f20:	08 f0       	brcs	.+2      	; 0x1f24 <pvPortMalloc+0x66>
    1f22:	5a c0       	rjmp	.+180    	; 0x1fd8 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1f24:	e0 91 df 22 	lds	r30, 0x22DF	; 0x8022df <xStart>
    1f28:	f0 91 e0 22 	lds	r31, 0x22E0	; 0x8022e0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1f2c:	af ed       	ldi	r26, 0xDF	; 223
    1f2e:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1f30:	02 c0       	rjmp	.+4      	; 0x1f36 <pvPortMalloc+0x78>
    1f32:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1f34:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1f36:	82 81       	ldd	r24, Z+2	; 0x02
    1f38:	93 81       	ldd	r25, Z+3	; 0x03
    1f3a:	82 17       	cp	r24, r18
    1f3c:	93 07       	cpc	r25, r19
    1f3e:	20 f4       	brcc	.+8      	; 0x1f48 <pvPortMalloc+0x8a>
    1f40:	80 81       	ld	r24, Z
    1f42:	91 81       	ldd	r25, Z+1	; 0x01
    1f44:	00 97       	sbiw	r24, 0x00	; 0
    1f46:	a9 f7       	brne	.-22     	; 0x1f32 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1f48:	c2 e2       	ldi	r28, 0x22	; 34
    1f4a:	eb 3d       	cpi	r30, 0xDB	; 219
    1f4c:	fc 07       	cpc	r31, r28
    1f4e:	09 f4       	brne	.+2      	; 0x1f52 <pvPortMalloc+0x94>
    1f50:	46 c0       	rjmp	.+140    	; 0x1fde <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1f52:	cd 91       	ld	r28, X+
    1f54:	dc 91       	ld	r29, X
    1f56:	11 97       	sbiw	r26, 0x01	; 1
    1f58:	8e 01       	movw	r16, r28
    1f5a:	0b 5f       	subi	r16, 0xFB	; 251
    1f5c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1f5e:	80 81       	ld	r24, Z
    1f60:	91 81       	ldd	r25, Z+1	; 0x01
    1f62:	8d 93       	st	X+, r24
    1f64:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1f66:	82 81       	ldd	r24, Z+2	; 0x02
    1f68:	93 81       	ldd	r25, Z+3	; 0x03
    1f6a:	82 1b       	sub	r24, r18
    1f6c:	93 0b       	sbc	r25, r19
    1f6e:	8b 30       	cpi	r24, 0x0B	; 11
    1f70:	91 05       	cpc	r25, r1
    1f72:	10 f1       	brcs	.+68     	; 0x1fb8 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1f74:	bf 01       	movw	r22, r30
    1f76:	62 0f       	add	r22, r18
    1f78:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1f7a:	db 01       	movw	r26, r22
    1f7c:	12 96       	adiw	r26, 0x02	; 2
    1f7e:	8d 93       	st	X+, r24
    1f80:	9c 93       	st	X, r25
    1f82:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1f84:	22 83       	std	Z+2, r18	; 0x02
    1f86:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1f88:	12 96       	adiw	r26, 0x02	; 2
    1f8a:	4d 91       	ld	r20, X+
    1f8c:	5c 91       	ld	r21, X
    1f8e:	13 97       	sbiw	r26, 0x03	; 3
    1f90:	8f ed       	ldi	r24, 0xDF	; 223
    1f92:	92 e2       	ldi	r25, 0x22	; 34
    1f94:	01 c0       	rjmp	.+2      	; 0x1f98 <pvPortMalloc+0xda>
    1f96:	cd 01       	movw	r24, r26
    1f98:	ec 01       	movw	r28, r24
    1f9a:	a8 81       	ld	r26, Y
    1f9c:	b9 81       	ldd	r27, Y+1	; 0x01
    1f9e:	12 96       	adiw	r26, 0x02	; 2
    1fa0:	2d 91       	ld	r18, X+
    1fa2:	3c 91       	ld	r19, X
    1fa4:	13 97       	sbiw	r26, 0x03	; 3
    1fa6:	24 17       	cp	r18, r20
    1fa8:	35 07       	cpc	r19, r21
    1faa:	a8 f3       	brcs	.-22     	; 0x1f96 <pvPortMalloc+0xd8>
    1fac:	eb 01       	movw	r28, r22
    1fae:	a8 83       	st	Y, r26
    1fb0:	b9 83       	std	Y+1, r27	; 0x01
    1fb2:	dc 01       	movw	r26, r24
    1fb4:	6d 93       	st	X+, r22
    1fb6:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1fb8:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1fbc:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1fc0:	22 81       	ldd	r18, Z+2	; 0x02
    1fc2:	33 81       	ldd	r19, Z+3	; 0x03
    1fc4:	82 1b       	sub	r24, r18
    1fc6:	93 0b       	sbc	r25, r19
    1fc8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1fcc:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1fd0:	08 c0       	rjmp	.+16     	; 0x1fe2 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1fd2:	00 e0       	ldi	r16, 0x00	; 0
    1fd4:	10 e0       	ldi	r17, 0x00	; 0
    1fd6:	05 c0       	rjmp	.+10     	; 0x1fe2 <pvPortMalloc+0x124>
    1fd8:	00 e0       	ldi	r16, 0x00	; 0
    1fda:	10 e0       	ldi	r17, 0x00	; 0
    1fdc:	02 c0       	rjmp	.+4      	; 0x1fe2 <pvPortMalloc+0x124>
    1fde:	00 e0       	ldi	r16, 0x00	; 0
    1fe0:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1fe2:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1fe6:	c8 01       	movw	r24, r16
    1fe8:	df 91       	pop	r29
    1fea:	cf 91       	pop	r28
    1fec:	1f 91       	pop	r17
    1fee:	0f 91       	pop	r16
    1ff0:	08 95       	ret

00001ff2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ff2:	0f 93       	push	r16
    1ff4:	1f 93       	push	r17
    1ff6:	cf 93       	push	r28
    1ff8:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1ffa:	00 97       	sbiw	r24, 0x00	; 0
    1ffc:	41 f1       	breq	.+80     	; 0x204e <vPortFree+0x5c>
    1ffe:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    2000:	8c 01       	movw	r16, r24
    2002:	05 50       	subi	r16, 0x05	; 5
    2004:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    2006:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    200a:	f8 01       	movw	r30, r16
    200c:	42 81       	ldd	r20, Z+2	; 0x02
    200e:	53 81       	ldd	r21, Z+3	; 0x03
    2010:	af ed       	ldi	r26, 0xDF	; 223
    2012:	b2 e2       	ldi	r27, 0x22	; 34
    2014:	01 c0       	rjmp	.+2      	; 0x2018 <vPortFree+0x26>
    2016:	df 01       	movw	r26, r30
    2018:	ed 91       	ld	r30, X+
    201a:	fc 91       	ld	r31, X
    201c:	11 97       	sbiw	r26, 0x01	; 1
    201e:	22 81       	ldd	r18, Z+2	; 0x02
    2020:	33 81       	ldd	r19, Z+3	; 0x03
    2022:	24 17       	cp	r18, r20
    2024:	35 07       	cpc	r19, r21
    2026:	b8 f3       	brcs	.-18     	; 0x2016 <vPortFree+0x24>
    2028:	25 97       	sbiw	r28, 0x05	; 5
    202a:	e8 83       	st	Y, r30
    202c:	f9 83       	std	Y+1, r31	; 0x01
    202e:	0d 93       	st	X+, r16
    2030:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    2032:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    2036:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    203a:	8a 81       	ldd	r24, Y+2	; 0x02
    203c:	9b 81       	ldd	r25, Y+3	; 0x03
    203e:	82 0f       	add	r24, r18
    2040:	93 1f       	adc	r25, r19
    2042:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    2046:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    204a:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
	}
}
    204e:	df 91       	pop	r29
    2050:	cf 91       	pop	r28
    2052:	1f 91       	pop	r17
    2054:	0f 91       	pop	r16
    2056:	08 95       	ret

00002058 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    2058:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    205c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    2060:	08 95       	ret

00002062 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2062:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2064:	03 96       	adiw	r24, 0x03	; 3
    2066:	81 83       	std	Z+1, r24	; 0x01
    2068:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    206a:	4f ef       	ldi	r20, 0xFF	; 255
    206c:	5f ef       	ldi	r21, 0xFF	; 255
    206e:	ba 01       	movw	r22, r20
    2070:	43 83       	std	Z+3, r20	; 0x03
    2072:	54 83       	std	Z+4, r21	; 0x04
    2074:	65 83       	std	Z+5, r22	; 0x05
    2076:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2078:	87 83       	std	Z+7, r24	; 0x07
    207a:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    207c:	81 87       	std	Z+9, r24	; 0x09
    207e:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2080:	10 82       	st	Z, r1
    2082:	08 95       	ret

00002084 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2084:	fc 01       	movw	r30, r24
    2086:	12 86       	std	Z+10, r1	; 0x0a
    2088:	13 86       	std	Z+11, r1	; 0x0b
    208a:	08 95       	ret

0000208c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    208c:	cf 93       	push	r28
    208e:	df 93       	push	r29
    2090:	fc 01       	movw	r30, r24
    2092:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2094:	21 81       	ldd	r18, Z+1	; 0x01
    2096:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    2098:	e9 01       	movw	r28, r18
    209a:	8c 81       	ldd	r24, Y+4	; 0x04
    209c:	9d 81       	ldd	r25, Y+5	; 0x05
    209e:	14 96       	adiw	r26, 0x04	; 4
    20a0:	8d 93       	st	X+, r24
    20a2:	9c 93       	st	X, r25
    20a4:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    20a6:	81 81       	ldd	r24, Z+1	; 0x01
    20a8:	92 81       	ldd	r25, Z+2	; 0x02
    20aa:	16 96       	adiw	r26, 0x06	; 6
    20ac:	8d 93       	st	X+, r24
    20ae:	9c 93       	st	X, r25
    20b0:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    20b2:	8c 81       	ldd	r24, Y+4	; 0x04
    20b4:	9d 81       	ldd	r25, Y+5	; 0x05
    20b6:	ec 01       	movw	r28, r24
    20b8:	6e 83       	std	Y+6, r22	; 0x06
    20ba:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    20bc:	e9 01       	movw	r28, r18
    20be:	6c 83       	std	Y+4, r22	; 0x04
    20c0:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    20c2:	61 83       	std	Z+1, r22	; 0x01
    20c4:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    20c6:	1a 96       	adiw	r26, 0x0a	; 10
    20c8:	ed 93       	st	X+, r30
    20ca:	fc 93       	st	X, r31
    20cc:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    20ce:	80 81       	ld	r24, Z
    20d0:	8f 5f       	subi	r24, 0xFF	; 255
    20d2:	80 83       	st	Z, r24
}
    20d4:	df 91       	pop	r29
    20d6:	cf 91       	pop	r28
    20d8:	08 95       	ret

000020da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    20da:	0f 93       	push	r16
    20dc:	1f 93       	push	r17
    20de:	cf 93       	push	r28
    20e0:	df 93       	push	r29
    20e2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    20e4:	08 81       	ld	r16, Y
    20e6:	19 81       	ldd	r17, Y+1	; 0x01
    20e8:	2a 81       	ldd	r18, Y+2	; 0x02
    20ea:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    20ec:	0f 3f       	cpi	r16, 0xFF	; 255
    20ee:	4f ef       	ldi	r20, 0xFF	; 255
    20f0:	14 07       	cpc	r17, r20
    20f2:	24 07       	cpc	r18, r20
    20f4:	34 07       	cpc	r19, r20
    20f6:	31 f4       	brne	.+12     	; 0x2104 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    20f8:	dc 01       	movw	r26, r24
    20fa:	19 96       	adiw	r26, 0x09	; 9
    20fc:	ed 91       	ld	r30, X+
    20fe:	fc 91       	ld	r31, X
    2100:	1a 97       	sbiw	r26, 0x0a	; 10
    2102:	1f c0       	rjmp	.+62     	; 0x2142 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2104:	fc 01       	movw	r30, r24
    2106:	33 96       	adiw	r30, 0x03	; 3
    2108:	dc 01       	movw	r26, r24
    210a:	17 96       	adiw	r26, 0x07	; 7
    210c:	4d 91       	ld	r20, X+
    210e:	5c 91       	ld	r21, X
    2110:	18 97       	sbiw	r26, 0x08	; 8
    2112:	da 01       	movw	r26, r20
    2114:	4d 91       	ld	r20, X+
    2116:	5d 91       	ld	r21, X+
    2118:	6d 91       	ld	r22, X+
    211a:	7c 91       	ld	r23, X
    211c:	04 17       	cp	r16, r20
    211e:	15 07       	cpc	r17, r21
    2120:	26 07       	cpc	r18, r22
    2122:	37 07       	cpc	r19, r23
    2124:	70 f0       	brcs	.+28     	; 0x2142 <vListInsert+0x68>
    2126:	04 80       	ldd	r0, Z+4	; 0x04
    2128:	f5 81       	ldd	r31, Z+5	; 0x05
    212a:	e0 2d       	mov	r30, r0
    212c:	a4 81       	ldd	r26, Z+4	; 0x04
    212e:	b5 81       	ldd	r27, Z+5	; 0x05
    2130:	4d 91       	ld	r20, X+
    2132:	5d 91       	ld	r21, X+
    2134:	6d 91       	ld	r22, X+
    2136:	7c 91       	ld	r23, X
    2138:	04 17       	cp	r16, r20
    213a:	15 07       	cpc	r17, r21
    213c:	26 07       	cpc	r18, r22
    213e:	37 07       	cpc	r19, r23
    2140:	90 f7       	brcc	.-28     	; 0x2126 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2142:	a4 81       	ldd	r26, Z+4	; 0x04
    2144:	b5 81       	ldd	r27, Z+5	; 0x05
    2146:	ac 83       	std	Y+4, r26	; 0x04
    2148:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    214a:	16 96       	adiw	r26, 0x06	; 6
    214c:	cd 93       	st	X+, r28
    214e:	dc 93       	st	X, r29
    2150:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    2152:	ee 83       	std	Y+6, r30	; 0x06
    2154:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2156:	c4 83       	std	Z+4, r28	; 0x04
    2158:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    215a:	8a 87       	std	Y+10, r24	; 0x0a
    215c:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    215e:	fc 01       	movw	r30, r24
    2160:	20 81       	ld	r18, Z
    2162:	2f 5f       	subi	r18, 0xFF	; 255
    2164:	20 83       	st	Z, r18
}
    2166:	df 91       	pop	r29
    2168:	cf 91       	pop	r28
    216a:	1f 91       	pop	r17
    216c:	0f 91       	pop	r16
    216e:	08 95       	ret

00002170 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2170:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2172:	a4 81       	ldd	r26, Z+4	; 0x04
    2174:	b5 81       	ldd	r27, Z+5	; 0x05
    2176:	86 81       	ldd	r24, Z+6	; 0x06
    2178:	97 81       	ldd	r25, Z+7	; 0x07
    217a:	16 96       	adiw	r26, 0x06	; 6
    217c:	8d 93       	st	X+, r24
    217e:	9c 93       	st	X, r25
    2180:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2182:	a6 81       	ldd	r26, Z+6	; 0x06
    2184:	b7 81       	ldd	r27, Z+7	; 0x07
    2186:	84 81       	ldd	r24, Z+4	; 0x04
    2188:	95 81       	ldd	r25, Z+5	; 0x05
    218a:	14 96       	adiw	r26, 0x04	; 4
    218c:	8d 93       	st	X+, r24
    218e:	9c 93       	st	X, r25
    2190:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2192:	a2 85       	ldd	r26, Z+10	; 0x0a
    2194:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2196:	11 96       	adiw	r26, 0x01	; 1
    2198:	8d 91       	ld	r24, X+
    219a:	9c 91       	ld	r25, X
    219c:	12 97       	sbiw	r26, 0x02	; 2
    219e:	e8 17       	cp	r30, r24
    21a0:	f9 07       	cpc	r31, r25
    21a2:	31 f4       	brne	.+12     	; 0x21b0 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    21a4:	86 81       	ldd	r24, Z+6	; 0x06
    21a6:	97 81       	ldd	r25, Z+7	; 0x07
    21a8:	11 96       	adiw	r26, 0x01	; 1
    21aa:	8d 93       	st	X+, r24
    21ac:	9c 93       	st	X, r25
    21ae:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    21b0:	12 86       	std	Z+10, r1	; 0x0a
    21b2:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    21b4:	8c 91       	ld	r24, X
    21b6:	81 50       	subi	r24, 0x01	; 1
    21b8:	8c 93       	st	X, r24
    21ba:	08 95       	ret

000021bc <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    21bc:	80 93 a6 33 	sts	0x33A6, r24	; 0x8033a6 <portStackTopForTask>
    21c0:	90 93 a7 33 	sts	0x33A7, r25	; 0x8033a7 <portStackTopForTask+0x1>
    21c4:	31 e1       	ldi	r19, 0x11	; 17
    21c6:	fc 01       	movw	r30, r24
    21c8:	30 83       	st	Z, r19
    21ca:	31 97       	sbiw	r30, 0x01	; 1
    21cc:	22 e2       	ldi	r18, 0x22	; 34
    21ce:	20 83       	st	Z, r18
    21d0:	31 97       	sbiw	r30, 0x01	; 1
    21d2:	a3 e3       	ldi	r26, 0x33	; 51
    21d4:	a0 83       	st	Z, r26
    21d6:	31 97       	sbiw	r30, 0x01	; 1
    21d8:	60 83       	st	Z, r22
    21da:	31 97       	sbiw	r30, 0x01	; 1
    21dc:	70 83       	st	Z, r23
    21de:	31 97       	sbiw	r30, 0x01	; 1
    21e0:	10 82       	st	Z, r1
    21e2:	31 97       	sbiw	r30, 0x01	; 1
    21e4:	10 82       	st	Z, r1
    21e6:	31 97       	sbiw	r30, 0x01	; 1
    21e8:	60 e8       	ldi	r22, 0x80	; 128
    21ea:	60 83       	st	Z, r22
    21ec:	31 97       	sbiw	r30, 0x01	; 1
    21ee:	10 82       	st	Z, r1
    21f0:	31 97       	sbiw	r30, 0x01	; 1
    21f2:	10 82       	st	Z, r1
    21f4:	31 97       	sbiw	r30, 0x01	; 1
    21f6:	10 82       	st	Z, r1
    21f8:	31 97       	sbiw	r30, 0x01	; 1
    21fa:	62 e0       	ldi	r22, 0x02	; 2
    21fc:	60 83       	st	Z, r22
    21fe:	31 97       	sbiw	r30, 0x01	; 1
    2200:	63 e0       	ldi	r22, 0x03	; 3
    2202:	60 83       	st	Z, r22
    2204:	31 97       	sbiw	r30, 0x01	; 1
    2206:	64 e0       	ldi	r22, 0x04	; 4
    2208:	60 83       	st	Z, r22
    220a:	31 97       	sbiw	r30, 0x01	; 1
    220c:	65 e0       	ldi	r22, 0x05	; 5
    220e:	60 83       	st	Z, r22
    2210:	31 97       	sbiw	r30, 0x01	; 1
    2212:	66 e0       	ldi	r22, 0x06	; 6
    2214:	60 83       	st	Z, r22
    2216:	31 97       	sbiw	r30, 0x01	; 1
    2218:	67 e0       	ldi	r22, 0x07	; 7
    221a:	60 83       	st	Z, r22
    221c:	31 97       	sbiw	r30, 0x01	; 1
    221e:	68 e0       	ldi	r22, 0x08	; 8
    2220:	60 83       	st	Z, r22
    2222:	31 97       	sbiw	r30, 0x01	; 1
    2224:	69 e0       	ldi	r22, 0x09	; 9
    2226:	60 83       	st	Z, r22
    2228:	31 97       	sbiw	r30, 0x01	; 1
    222a:	60 e1       	ldi	r22, 0x10	; 16
    222c:	60 83       	st	Z, r22
    222e:	31 97       	sbiw	r30, 0x01	; 1
    2230:	30 83       	st	Z, r19
    2232:	31 97       	sbiw	r30, 0x01	; 1
    2234:	32 e1       	ldi	r19, 0x12	; 18
    2236:	30 83       	st	Z, r19
    2238:	31 97       	sbiw	r30, 0x01	; 1
    223a:	33 e1       	ldi	r19, 0x13	; 19
    223c:	30 83       	st	Z, r19
    223e:	31 97       	sbiw	r30, 0x01	; 1
    2240:	34 e1       	ldi	r19, 0x14	; 20
    2242:	30 83       	st	Z, r19
    2244:	31 97       	sbiw	r30, 0x01	; 1
    2246:	35 e1       	ldi	r19, 0x15	; 21
    2248:	30 83       	st	Z, r19
    224a:	31 97       	sbiw	r30, 0x01	; 1
    224c:	36 e1       	ldi	r19, 0x16	; 22
    224e:	30 83       	st	Z, r19
    2250:	31 97       	sbiw	r30, 0x01	; 1
    2252:	37 e1       	ldi	r19, 0x17	; 23
    2254:	30 83       	st	Z, r19
    2256:	31 97       	sbiw	r30, 0x01	; 1
    2258:	38 e1       	ldi	r19, 0x18	; 24
    225a:	30 83       	st	Z, r19
    225c:	31 97       	sbiw	r30, 0x01	; 1
    225e:	39 e1       	ldi	r19, 0x19	; 25
    2260:	30 83       	st	Z, r19
    2262:	31 97       	sbiw	r30, 0x01	; 1
    2264:	30 e2       	ldi	r19, 0x20	; 32
    2266:	30 83       	st	Z, r19
    2268:	31 97       	sbiw	r30, 0x01	; 1
    226a:	31 e2       	ldi	r19, 0x21	; 33
    226c:	30 83       	st	Z, r19
    226e:	31 97       	sbiw	r30, 0x01	; 1
    2270:	20 83       	st	Z, r18
    2272:	31 97       	sbiw	r30, 0x01	; 1
    2274:	23 e2       	ldi	r18, 0x23	; 35
    2276:	20 83       	st	Z, r18
    2278:	31 97       	sbiw	r30, 0x01	; 1
    227a:	40 83       	st	Z, r20
    227c:	31 97       	sbiw	r30, 0x01	; 1
    227e:	50 83       	st	Z, r21
    2280:	31 97       	sbiw	r30, 0x01	; 1
    2282:	26 e2       	ldi	r18, 0x26	; 38
    2284:	20 83       	st	Z, r18
    2286:	31 97       	sbiw	r30, 0x01	; 1
    2288:	27 e2       	ldi	r18, 0x27	; 39
    228a:	20 83       	st	Z, r18
    228c:	31 97       	sbiw	r30, 0x01	; 1
    228e:	28 e2       	ldi	r18, 0x28	; 40
    2290:	20 83       	st	Z, r18
    2292:	31 97       	sbiw	r30, 0x01	; 1
    2294:	29 e2       	ldi	r18, 0x29	; 41
    2296:	20 83       	st	Z, r18
    2298:	31 97       	sbiw	r30, 0x01	; 1
    229a:	20 e3       	ldi	r18, 0x30	; 48
    229c:	20 83       	st	Z, r18
    229e:	31 97       	sbiw	r30, 0x01	; 1
    22a0:	21 e3       	ldi	r18, 0x31	; 49
    22a2:	20 83       	st	Z, r18
    22a4:	89 97       	sbiw	r24, 0x29	; 41
    22a6:	08 95       	ret

000022a8 <xPortStartScheduler>:
    22a8:	8c e7       	ldi	r24, 0x7C	; 124
    22aa:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    22ae:	8f ef       	ldi	r24, 0xFF	; 255
    22b0:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    22ba:	91 e1       	ldi	r25, 0x11	; 17
    22bc:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    22c0:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    22c4:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    22c8:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    22cc:	cd 91       	ld	r28, X+
    22ce:	cd bf       	out	0x3d, r28	; 61
    22d0:	dd 91       	ld	r29, X+
    22d2:	de bf       	out	0x3e, r29	; 62
    22d4:	ff 91       	pop	r31
    22d6:	ef 91       	pop	r30
    22d8:	df 91       	pop	r29
    22da:	cf 91       	pop	r28
    22dc:	bf 91       	pop	r27
    22de:	af 91       	pop	r26
    22e0:	9f 91       	pop	r25
    22e2:	8f 91       	pop	r24
    22e4:	7f 91       	pop	r23
    22e6:	6f 91       	pop	r22
    22e8:	5f 91       	pop	r21
    22ea:	4f 91       	pop	r20
    22ec:	3f 91       	pop	r19
    22ee:	2f 91       	pop	r18
    22f0:	1f 91       	pop	r17
    22f2:	0f 91       	pop	r16
    22f4:	ff 90       	pop	r15
    22f6:	ef 90       	pop	r14
    22f8:	df 90       	pop	r13
    22fa:	cf 90       	pop	r12
    22fc:	bf 90       	pop	r11
    22fe:	af 90       	pop	r10
    2300:	9f 90       	pop	r9
    2302:	8f 90       	pop	r8
    2304:	7f 90       	pop	r7
    2306:	6f 90       	pop	r6
    2308:	5f 90       	pop	r5
    230a:	4f 90       	pop	r4
    230c:	3f 90       	pop	r3
    230e:	2f 90       	pop	r2
    2310:	1f 90       	pop	r1
    2312:	0f 90       	pop	r0
    2314:	0c be       	out	0x3c, r0	; 60
    2316:	0f 90       	pop	r0
    2318:	0b be       	out	0x3b, r0	; 59
    231a:	0f 90       	pop	r0
    231c:	0f be       	out	0x3f, r0	; 63
    231e:	0f 90       	pop	r0
    2320:	08 95       	ret
    2322:	08 95       	ret

00002324 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2324:	0f 92       	push	r0
    2326:	0f b6       	in	r0, 0x3f	; 63
    2328:	f8 94       	cli
    232a:	0f 92       	push	r0
    232c:	0b b6       	in	r0, 0x3b	; 59
    232e:	0f 92       	push	r0
    2330:	0c b6       	in	r0, 0x3c	; 60
    2332:	0f 92       	push	r0
    2334:	1f 92       	push	r1
    2336:	11 24       	eor	r1, r1
    2338:	2f 92       	push	r2
    233a:	3f 92       	push	r3
    233c:	4f 92       	push	r4
    233e:	5f 92       	push	r5
    2340:	6f 92       	push	r6
    2342:	7f 92       	push	r7
    2344:	8f 92       	push	r8
    2346:	9f 92       	push	r9
    2348:	af 92       	push	r10
    234a:	bf 92       	push	r11
    234c:	cf 92       	push	r12
    234e:	df 92       	push	r13
    2350:	ef 92       	push	r14
    2352:	ff 92       	push	r15
    2354:	0f 93       	push	r16
    2356:	1f 93       	push	r17
    2358:	2f 93       	push	r18
    235a:	3f 93       	push	r19
    235c:	4f 93       	push	r20
    235e:	5f 93       	push	r21
    2360:	6f 93       	push	r22
    2362:	7f 93       	push	r23
    2364:	8f 93       	push	r24
    2366:	9f 93       	push	r25
    2368:	af 93       	push	r26
    236a:	bf 93       	push	r27
    236c:	cf 93       	push	r28
    236e:	df 93       	push	r29
    2370:	ef 93       	push	r30
    2372:	ff 93       	push	r31
    2374:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    2378:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    237c:	0d b6       	in	r0, 0x3d	; 61
    237e:	0d 92       	st	X+, r0
    2380:	0e b6       	in	r0, 0x3e	; 62
    2382:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2384:	0e 94 a1 18 	call	0x3142	; 0x3142 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2388:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    238c:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2390:	cd 91       	ld	r28, X+
    2392:	cd bf       	out	0x3d, r28	; 61
    2394:	dd 91       	ld	r29, X+
    2396:	de bf       	out	0x3e, r29	; 62
    2398:	ff 91       	pop	r31
    239a:	ef 91       	pop	r30
    239c:	df 91       	pop	r29
    239e:	cf 91       	pop	r28
    23a0:	bf 91       	pop	r27
    23a2:	af 91       	pop	r26
    23a4:	9f 91       	pop	r25
    23a6:	8f 91       	pop	r24
    23a8:	7f 91       	pop	r23
    23aa:	6f 91       	pop	r22
    23ac:	5f 91       	pop	r21
    23ae:	4f 91       	pop	r20
    23b0:	3f 91       	pop	r19
    23b2:	2f 91       	pop	r18
    23b4:	1f 91       	pop	r17
    23b6:	0f 91       	pop	r16
    23b8:	ff 90       	pop	r15
    23ba:	ef 90       	pop	r14
    23bc:	df 90       	pop	r13
    23be:	cf 90       	pop	r12
    23c0:	bf 90       	pop	r11
    23c2:	af 90       	pop	r10
    23c4:	9f 90       	pop	r9
    23c6:	8f 90       	pop	r8
    23c8:	7f 90       	pop	r7
    23ca:	6f 90       	pop	r6
    23cc:	5f 90       	pop	r5
    23ce:	4f 90       	pop	r4
    23d0:	3f 90       	pop	r3
    23d2:	2f 90       	pop	r2
    23d4:	1f 90       	pop	r1
    23d6:	0f 90       	pop	r0
    23d8:	0c be       	out	0x3c, r0	; 60
    23da:	0f 90       	pop	r0
    23dc:	0b be       	out	0x3b, r0	; 59
    23de:	0f 90       	pop	r0
    23e0:	0f be       	out	0x3f, r0	; 63
    23e2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23e4:	08 95       	ret

000023e6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    23e6:	0f 92       	push	r0
    23e8:	0f b6       	in	r0, 0x3f	; 63
    23ea:	f8 94       	cli
    23ec:	0f 92       	push	r0
    23ee:	0b b6       	in	r0, 0x3b	; 59
    23f0:	0f 92       	push	r0
    23f2:	0c b6       	in	r0, 0x3c	; 60
    23f4:	0f 92       	push	r0
    23f6:	1f 92       	push	r1
    23f8:	11 24       	eor	r1, r1
    23fa:	2f 92       	push	r2
    23fc:	3f 92       	push	r3
    23fe:	4f 92       	push	r4
    2400:	5f 92       	push	r5
    2402:	6f 92       	push	r6
    2404:	7f 92       	push	r7
    2406:	8f 92       	push	r8
    2408:	9f 92       	push	r9
    240a:	af 92       	push	r10
    240c:	bf 92       	push	r11
    240e:	cf 92       	push	r12
    2410:	df 92       	push	r13
    2412:	ef 92       	push	r14
    2414:	ff 92       	push	r15
    2416:	0f 93       	push	r16
    2418:	1f 93       	push	r17
    241a:	2f 93       	push	r18
    241c:	3f 93       	push	r19
    241e:	4f 93       	push	r20
    2420:	5f 93       	push	r21
    2422:	6f 93       	push	r22
    2424:	7f 93       	push	r23
    2426:	8f 93       	push	r24
    2428:	9f 93       	push	r25
    242a:	af 93       	push	r26
    242c:	bf 93       	push	r27
    242e:	cf 93       	push	r28
    2430:	df 93       	push	r29
    2432:	ef 93       	push	r30
    2434:	ff 93       	push	r31
    2436:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    243a:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    243e:	0d b6       	in	r0, 0x3d	; 61
    2440:	0d 92       	st	X+, r0
    2442:	0e b6       	in	r0, 0x3e	; 62
    2444:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2446:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <vTaskIncrementTick>
	vTaskSwitchContext();
    244a:	0e 94 a1 18 	call	0x3142	; 0x3142 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    244e:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    2452:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2456:	cd 91       	ld	r28, X+
    2458:	cd bf       	out	0x3d, r28	; 61
    245a:	dd 91       	ld	r29, X+
    245c:	de bf       	out	0x3e, r29	; 62
    245e:	ff 91       	pop	r31
    2460:	ef 91       	pop	r30
    2462:	df 91       	pop	r29
    2464:	cf 91       	pop	r28
    2466:	bf 91       	pop	r27
    2468:	af 91       	pop	r26
    246a:	9f 91       	pop	r25
    246c:	8f 91       	pop	r24
    246e:	7f 91       	pop	r23
    2470:	6f 91       	pop	r22
    2472:	5f 91       	pop	r21
    2474:	4f 91       	pop	r20
    2476:	3f 91       	pop	r19
    2478:	2f 91       	pop	r18
    247a:	1f 91       	pop	r17
    247c:	0f 91       	pop	r16
    247e:	ff 90       	pop	r15
    2480:	ef 90       	pop	r14
    2482:	df 90       	pop	r13
    2484:	cf 90       	pop	r12
    2486:	bf 90       	pop	r11
    2488:	af 90       	pop	r10
    248a:	9f 90       	pop	r9
    248c:	8f 90       	pop	r8
    248e:	7f 90       	pop	r7
    2490:	6f 90       	pop	r6
    2492:	5f 90       	pop	r5
    2494:	4f 90       	pop	r4
    2496:	3f 90       	pop	r3
    2498:	2f 90       	pop	r2
    249a:	1f 90       	pop	r1
    249c:	0f 90       	pop	r0
    249e:	0c be       	out	0x3c, r0	; 60
    24a0:	0f 90       	pop	r0
    24a2:	0b be       	out	0x3b, r0	; 59
    24a4:	0f 90       	pop	r0
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	0f 90       	pop	r0

	asm volatile ( "ret" );
    24aa:	08 95       	ret

000024ac <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    24ac:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    24b0:	18 95       	reti

000024b2 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    24b2:	cf 93       	push	r28
    24b4:	df 93       	push	r29
    24b6:	ec 01       	movw	r28, r24
    24b8:	88 a1       	ldd	r24, Y+32	; 0x20
    24ba:	81 11       	cpse	r24, r1
    24bc:	0b c0       	rjmp	.+22     	; 0x24d4 <prvCopyDataToQueue+0x22>
    24be:	88 81       	ld	r24, Y
    24c0:	99 81       	ldd	r25, Y+1	; 0x01
    24c2:	89 2b       	or	r24, r25
    24c4:	e1 f5       	brne	.+120    	; 0x253e <prvCopyDataToQueue+0x8c>
    24c6:	8a 81       	ldd	r24, Y+2	; 0x02
    24c8:	9b 81       	ldd	r25, Y+3	; 0x03
    24ca:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <vTaskPriorityDisinherit>
    24ce:	1a 82       	std	Y+2, r1	; 0x02
    24d0:	1b 82       	std	Y+3, r1	; 0x03
    24d2:	35 c0       	rjmp	.+106    	; 0x253e <prvCopyDataToQueue+0x8c>
    24d4:	41 11       	cpse	r20, r1
    24d6:	17 c0       	rjmp	.+46     	; 0x2506 <prvCopyDataToQueue+0x54>
    24d8:	48 2f       	mov	r20, r24
    24da:	50 e0       	ldi	r21, 0x00	; 0
    24dc:	8c 81       	ldd	r24, Y+4	; 0x04
    24de:	9d 81       	ldd	r25, Y+5	; 0x05
    24e0:	0e 94 cf 27 	call	0x4f9e	; 0x4f9e <memcpy>
    24e4:	28 a1       	ldd	r18, Y+32	; 0x20
    24e6:	8c 81       	ldd	r24, Y+4	; 0x04
    24e8:	9d 81       	ldd	r25, Y+5	; 0x05
    24ea:	82 0f       	add	r24, r18
    24ec:	91 1d       	adc	r25, r1
    24ee:	8c 83       	std	Y+4, r24	; 0x04
    24f0:	9d 83       	std	Y+5, r25	; 0x05
    24f2:	2a 81       	ldd	r18, Y+2	; 0x02
    24f4:	3b 81       	ldd	r19, Y+3	; 0x03
    24f6:	82 17       	cp	r24, r18
    24f8:	93 07       	cpc	r25, r19
    24fa:	08 f1       	brcs	.+66     	; 0x253e <prvCopyDataToQueue+0x8c>
    24fc:	88 81       	ld	r24, Y
    24fe:	99 81       	ldd	r25, Y+1	; 0x01
    2500:	8c 83       	std	Y+4, r24	; 0x04
    2502:	9d 83       	std	Y+5, r25	; 0x05
    2504:	1c c0       	rjmp	.+56     	; 0x253e <prvCopyDataToQueue+0x8c>
    2506:	48 2f       	mov	r20, r24
    2508:	50 e0       	ldi	r21, 0x00	; 0
    250a:	8e 81       	ldd	r24, Y+6	; 0x06
    250c:	9f 81       	ldd	r25, Y+7	; 0x07
    250e:	0e 94 cf 27 	call	0x4f9e	; 0x4f9e <memcpy>
    2512:	88 a1       	ldd	r24, Y+32	; 0x20
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	91 95       	neg	r25
    2518:	81 95       	neg	r24
    251a:	91 09       	sbc	r25, r1
    251c:	2e 81       	ldd	r18, Y+6	; 0x06
    251e:	3f 81       	ldd	r19, Y+7	; 0x07
    2520:	28 0f       	add	r18, r24
    2522:	39 1f       	adc	r19, r25
    2524:	2e 83       	std	Y+6, r18	; 0x06
    2526:	3f 83       	std	Y+7, r19	; 0x07
    2528:	48 81       	ld	r20, Y
    252a:	59 81       	ldd	r21, Y+1	; 0x01
    252c:	24 17       	cp	r18, r20
    252e:	35 07       	cpc	r19, r21
    2530:	30 f4       	brcc	.+12     	; 0x253e <prvCopyDataToQueue+0x8c>
    2532:	2a 81       	ldd	r18, Y+2	; 0x02
    2534:	3b 81       	ldd	r19, Y+3	; 0x03
    2536:	82 0f       	add	r24, r18
    2538:	93 1f       	adc	r25, r19
    253a:	8e 83       	std	Y+6, r24	; 0x06
    253c:	9f 83       	std	Y+7, r25	; 0x07
    253e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2540:	8f 5f       	subi	r24, 0xFF	; 255
    2542:	8e 8f       	std	Y+30, r24	; 0x1e
    2544:	df 91       	pop	r29
    2546:	cf 91       	pop	r28
    2548:	08 95       	ret

0000254a <prvCopyDataFromQueue>:
    254a:	fc 01       	movw	r30, r24
    254c:	80 81       	ld	r24, Z
    254e:	91 81       	ldd	r25, Z+1	; 0x01
    2550:	00 97       	sbiw	r24, 0x00	; 0
    2552:	a1 f0       	breq	.+40     	; 0x257c <prvCopyDataFromQueue+0x32>
    2554:	40 a1       	ldd	r20, Z+32	; 0x20
    2556:	50 e0       	ldi	r21, 0x00	; 0
    2558:	26 81       	ldd	r18, Z+6	; 0x06
    255a:	37 81       	ldd	r19, Z+7	; 0x07
    255c:	24 0f       	add	r18, r20
    255e:	35 1f       	adc	r19, r21
    2560:	26 83       	std	Z+6, r18	; 0x06
    2562:	37 83       	std	Z+7, r19	; 0x07
    2564:	a2 81       	ldd	r26, Z+2	; 0x02
    2566:	b3 81       	ldd	r27, Z+3	; 0x03
    2568:	2a 17       	cp	r18, r26
    256a:	3b 07       	cpc	r19, r27
    256c:	10 f0       	brcs	.+4      	; 0x2572 <prvCopyDataFromQueue+0x28>
    256e:	86 83       	std	Z+6, r24	; 0x06
    2570:	97 83       	std	Z+7, r25	; 0x07
    2572:	cb 01       	movw	r24, r22
    2574:	66 81       	ldd	r22, Z+6	; 0x06
    2576:	77 81       	ldd	r23, Z+7	; 0x07
    2578:	0e 94 cf 27 	call	0x4f9e	; 0x4f9e <memcpy>
    257c:	08 95       	ret

0000257e <prvUnlockQueue>:
    257e:	0f 93       	push	r16
    2580:	1f 93       	push	r17
    2582:	cf 93       	push	r28
    2584:	df 93       	push	r29
    2586:	ec 01       	movw	r28, r24
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
    258e:	8a a1       	ldd	r24, Y+34	; 0x22
    2590:	18 16       	cp	r1, r24
    2592:	b4 f4       	brge	.+44     	; 0x25c0 <prvUnlockQueue+0x42>
    2594:	8b 89       	ldd	r24, Y+19	; 0x13
    2596:	81 11       	cpse	r24, r1
    2598:	05 c0       	rjmp	.+10     	; 0x25a4 <prvUnlockQueue+0x26>
    259a:	12 c0       	rjmp	.+36     	; 0x25c0 <prvUnlockQueue+0x42>
    259c:	8b 89       	ldd	r24, Y+19	; 0x13
    259e:	81 11       	cpse	r24, r1
    25a0:	04 c0       	rjmp	.+8      	; 0x25aa <prvUnlockQueue+0x2c>
    25a2:	0e c0       	rjmp	.+28     	; 0x25c0 <prvUnlockQueue+0x42>
    25a4:	8e 01       	movw	r16, r28
    25a6:	0d 5e       	subi	r16, 0xED	; 237
    25a8:	1f 4f       	sbci	r17, 0xFF	; 255
    25aa:	c8 01       	movw	r24, r16
    25ac:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    25b0:	81 11       	cpse	r24, r1
    25b2:	0e 94 e5 19 	call	0x33ca	; 0x33ca <vTaskMissedYield>
    25b6:	8a a1       	ldd	r24, Y+34	; 0x22
    25b8:	81 50       	subi	r24, 0x01	; 1
    25ba:	8a a3       	std	Y+34, r24	; 0x22
    25bc:	18 16       	cp	r1, r24
    25be:	74 f3       	brlt	.-36     	; 0x259c <prvUnlockQueue+0x1e>
    25c0:	8f ef       	ldi	r24, 0xFF	; 255
    25c2:	8a a3       	std	Y+34, r24	; 0x22
    25c4:	0f 90       	pop	r0
    25c6:	0f be       	out	0x3f, r0	; 63
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	f8 94       	cli
    25cc:	0f 92       	push	r0
    25ce:	89 a1       	ldd	r24, Y+33	; 0x21
    25d0:	18 16       	cp	r1, r24
    25d2:	b4 f4       	brge	.+44     	; 0x2600 <prvUnlockQueue+0x82>
    25d4:	88 85       	ldd	r24, Y+8	; 0x08
    25d6:	81 11       	cpse	r24, r1
    25d8:	05 c0       	rjmp	.+10     	; 0x25e4 <prvUnlockQueue+0x66>
    25da:	12 c0       	rjmp	.+36     	; 0x2600 <prvUnlockQueue+0x82>
    25dc:	88 85       	ldd	r24, Y+8	; 0x08
    25de:	81 11       	cpse	r24, r1
    25e0:	04 c0       	rjmp	.+8      	; 0x25ea <prvUnlockQueue+0x6c>
    25e2:	0e c0       	rjmp	.+28     	; 0x2600 <prvUnlockQueue+0x82>
    25e4:	8e 01       	movw	r16, r28
    25e6:	08 5f       	subi	r16, 0xF8	; 248
    25e8:	1f 4f       	sbci	r17, 0xFF	; 255
    25ea:	c8 01       	movw	r24, r16
    25ec:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    25f0:	81 11       	cpse	r24, r1
    25f2:	0e 94 e5 19 	call	0x33ca	; 0x33ca <vTaskMissedYield>
    25f6:	89 a1       	ldd	r24, Y+33	; 0x21
    25f8:	81 50       	subi	r24, 0x01	; 1
    25fa:	89 a3       	std	Y+33, r24	; 0x21
    25fc:	18 16       	cp	r1, r24
    25fe:	74 f3       	brlt	.-36     	; 0x25dc <prvUnlockQueue+0x5e>
    2600:	8f ef       	ldi	r24, 0xFF	; 255
    2602:	89 a3       	std	Y+33, r24	; 0x21
    2604:	0f 90       	pop	r0
    2606:	0f be       	out	0x3f, r0	; 63
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	1f 91       	pop	r17
    260e:	0f 91       	pop	r16
    2610:	08 95       	ret

00002612 <xQueueGenericReset>:
    2612:	1f 93       	push	r17
    2614:	cf 93       	push	r28
    2616:	df 93       	push	r29
    2618:	61 30       	cpi	r22, 0x01	; 1
    261a:	59 f0       	breq	.+22     	; 0x2632 <xQueueGenericReset+0x20>
    261c:	fc 01       	movw	r30, r24
    261e:	23 89       	ldd	r18, Z+19	; 0x13
    2620:	30 85       	ldd	r19, Z+8	; 0x08
    2622:	31 11       	cpse	r19, r1
    2624:	2c c0       	rjmp	.+88     	; 0x267e <xQueueGenericReset+0x6c>
    2626:	11 e0       	ldi	r17, 0x01	; 1
    2628:	21 11       	cpse	r18, r1
    262a:	10 e0       	ldi	r17, 0x00	; 0
    262c:	21 11       	cpse	r18, r1
    262e:	28 c0       	rjmp	.+80     	; 0x2680 <xQueueGenericReset+0x6e>
    2630:	01 c0       	rjmp	.+2      	; 0x2634 <xQueueGenericReset+0x22>
    2632:	11 e0       	ldi	r17, 0x01	; 1
    2634:	ec 01       	movw	r28, r24
    2636:	48 81       	ld	r20, Y
    2638:	59 81       	ldd	r21, Y+1	; 0x01
    263a:	28 a1       	ldd	r18, Y+32	; 0x20
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2640:	62 9f       	mul	r22, r18
    2642:	c0 01       	movw	r24, r0
    2644:	63 9f       	mul	r22, r19
    2646:	90 0d       	add	r25, r0
    2648:	11 24       	eor	r1, r1
    264a:	ba 01       	movw	r22, r20
    264c:	68 0f       	add	r22, r24
    264e:	79 1f       	adc	r23, r25
    2650:	6a 83       	std	Y+2, r22	; 0x02
    2652:	7b 83       	std	Y+3, r23	; 0x03
    2654:	1e 8e       	std	Y+30, r1	; 0x1e
    2656:	4c 83       	std	Y+4, r20	; 0x04
    2658:	5d 83       	std	Y+5, r21	; 0x05
    265a:	82 1b       	sub	r24, r18
    265c:	93 0b       	sbc	r25, r19
    265e:	84 0f       	add	r24, r20
    2660:	95 1f       	adc	r25, r21
    2662:	8e 83       	std	Y+6, r24	; 0x06
    2664:	9f 83       	std	Y+7, r25	; 0x07
    2666:	8f ef       	ldi	r24, 0xFF	; 255
    2668:	89 a3       	std	Y+33, r24	; 0x21
    266a:	8a a3       	std	Y+34, r24	; 0x22
    266c:	ce 01       	movw	r24, r28
    266e:	08 96       	adiw	r24, 0x08	; 8
    2670:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2674:	ce 01       	movw	r24, r28
    2676:	43 96       	adiw	r24, 0x13	; 19
    2678:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    267c:	01 c0       	rjmp	.+2      	; 0x2680 <xQueueGenericReset+0x6e>
    267e:	10 e0       	ldi	r17, 0x00	; 0
    2680:	81 2f       	mov	r24, r17
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	1f 91       	pop	r17
    2688:	08 95       	ret

0000268a <xQueueGenericCreate>:
    268a:	0f 93       	push	r16
    268c:	1f 93       	push	r17
    268e:	cf 93       	push	r28
    2690:	df 93       	push	r29
    2692:	88 23       	and	r24, r24
    2694:	01 f1       	breq	.+64     	; 0x26d6 <xQueueGenericCreate+0x4c>
    2696:	06 2f       	mov	r16, r22
    2698:	18 2f       	mov	r17, r24
    269a:	83 e2       	ldi	r24, 0x23	; 35
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    26a2:	ec 01       	movw	r28, r24
    26a4:	89 2b       	or	r24, r25
    26a6:	c9 f0       	breq	.+50     	; 0x26da <xQueueGenericCreate+0x50>
    26a8:	10 9f       	mul	r17, r16
    26aa:	c0 01       	movw	r24, r0
    26ac:	11 24       	eor	r1, r1
    26ae:	01 96       	adiw	r24, 0x01	; 1
    26b0:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    26b4:	88 83       	st	Y, r24
    26b6:	99 83       	std	Y+1, r25	; 0x01
    26b8:	89 2b       	or	r24, r25
    26ba:	39 f0       	breq	.+14     	; 0x26ca <xQueueGenericCreate+0x40>
    26bc:	1f 8f       	std	Y+31, r17	; 0x1f
    26be:	08 a3       	std	Y+32, r16	; 0x20
    26c0:	61 e0       	ldi	r22, 0x01	; 1
    26c2:	ce 01       	movw	r24, r28
    26c4:	0e 94 09 13 	call	0x2612	; 0x2612 <xQueueGenericReset>
    26c8:	08 c0       	rjmp	.+16     	; 0x26da <xQueueGenericCreate+0x50>
    26ca:	ce 01       	movw	r24, r28
    26cc:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <vPortFree>
    26d0:	c0 e0       	ldi	r28, 0x00	; 0
    26d2:	d0 e0       	ldi	r29, 0x00	; 0
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <xQueueGenericCreate+0x50>
    26d6:	c0 e0       	ldi	r28, 0x00	; 0
    26d8:	d0 e0       	ldi	r29, 0x00	; 0
    26da:	ce 01       	movw	r24, r28
    26dc:	df 91       	pop	r29
    26de:	cf 91       	pop	r28
    26e0:	1f 91       	pop	r17
    26e2:	0f 91       	pop	r16
    26e4:	08 95       	ret

000026e6 <xQueueGenericSend>:
    26e6:	af 92       	push	r10
    26e8:	bf 92       	push	r11
    26ea:	cf 92       	push	r12
    26ec:	df 92       	push	r13
    26ee:	ef 92       	push	r14
    26f0:	ff 92       	push	r15
    26f2:	0f 93       	push	r16
    26f4:	1f 93       	push	r17
    26f6:	cf 93       	push	r28
    26f8:	df 93       	push	r29
    26fa:	cd b7       	in	r28, 0x3d	; 61
    26fc:	de b7       	in	r29, 0x3e	; 62
    26fe:	29 97       	sbiw	r28, 0x09	; 9
    2700:	cd bf       	out	0x3d, r28	; 61
    2702:	de bf       	out	0x3e, r29	; 62
    2704:	7c 01       	movw	r14, r24
    2706:	5b 01       	movw	r10, r22
    2708:	2e 83       	std	Y+6, r18	; 0x06
    270a:	3f 83       	std	Y+7, r19	; 0x07
    270c:	48 87       	std	Y+8, r20	; 0x08
    270e:	59 87       	std	Y+9, r21	; 0x09
    2710:	10 e0       	ldi	r17, 0x00	; 0
    2712:	6c 01       	movw	r12, r24
    2714:	88 e0       	ldi	r24, 0x08	; 8
    2716:	c8 0e       	add	r12, r24
    2718:	d1 1c       	adc	r13, r1
    271a:	0f b6       	in	r0, 0x3f	; 63
    271c:	f8 94       	cli
    271e:	0f 92       	push	r0
    2720:	f7 01       	movw	r30, r14
    2722:	96 8d       	ldd	r25, Z+30	; 0x1e
    2724:	87 8d       	ldd	r24, Z+31	; 0x1f
    2726:	98 17       	cp	r25, r24
    2728:	a8 f4       	brcc	.+42     	; 0x2754 <xQueueGenericSend+0x6e>
    272a:	40 2f       	mov	r20, r16
    272c:	b5 01       	movw	r22, r10
    272e:	c7 01       	movw	r24, r14
    2730:	0e 94 59 12 	call	0x24b2	; 0x24b2 <prvCopyDataToQueue>
    2734:	f7 01       	movw	r30, r14
    2736:	83 89       	ldd	r24, Z+19	; 0x13
    2738:	88 23       	and	r24, r24
    273a:	41 f0       	breq	.+16     	; 0x274c <xQueueGenericSend+0x66>
    273c:	c7 01       	movw	r24, r14
    273e:	43 96       	adiw	r24, 0x13	; 19
    2740:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    2744:	81 30       	cpi	r24, 0x01	; 1
    2746:	11 f4       	brne	.+4      	; 0x274c <xQueueGenericSend+0x66>
    2748:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    274c:	0f 90       	pop	r0
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	56 c0       	rjmp	.+172    	; 0x2800 <xQueueGenericSend+0x11a>
    2754:	8e 81       	ldd	r24, Y+6	; 0x06
    2756:	9f 81       	ldd	r25, Y+7	; 0x07
    2758:	a8 85       	ldd	r26, Y+8	; 0x08
    275a:	b9 85       	ldd	r27, Y+9	; 0x09
    275c:	89 2b       	or	r24, r25
    275e:	8a 2b       	or	r24, r26
    2760:	8b 2b       	or	r24, r27
    2762:	21 f4       	brne	.+8      	; 0x276c <xQueueGenericSend+0x86>
    2764:	0f 90       	pop	r0
    2766:	0f be       	out	0x3f, r0	; 63
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	4a c0       	rjmp	.+148    	; 0x2800 <xQueueGenericSend+0x11a>
    276c:	11 11       	cpse	r17, r1
    276e:	05 c0       	rjmp	.+10     	; 0x277a <xQueueGenericSend+0x94>
    2770:	ce 01       	movw	r24, r28
    2772:	01 96       	adiw	r24, 0x01	; 1
    2774:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
    2778:	11 e0       	ldi	r17, 0x01	; 1
    277a:	0f 90       	pop	r0
    277c:	0f be       	out	0x3f, r0	; 63
    277e:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <vTaskSuspendAll>
    2782:	0f b6       	in	r0, 0x3f	; 63
    2784:	f8 94       	cli
    2786:	0f 92       	push	r0
    2788:	f7 01       	movw	r30, r14
    278a:	81 a1       	ldd	r24, Z+33	; 0x21
    278c:	8f 3f       	cpi	r24, 0xFF	; 255
    278e:	09 f4       	brne	.+2      	; 0x2792 <xQueueGenericSend+0xac>
    2790:	11 a2       	std	Z+33, r1	; 0x21
    2792:	f7 01       	movw	r30, r14
    2794:	82 a1       	ldd	r24, Z+34	; 0x22
    2796:	8f 3f       	cpi	r24, 0xFF	; 255
    2798:	09 f4       	brne	.+2      	; 0x279c <xQueueGenericSend+0xb6>
    279a:	12 a2       	std	Z+34, r1	; 0x22
    279c:	0f 90       	pop	r0
    279e:	0f be       	out	0x3f, r0	; 63
    27a0:	be 01       	movw	r22, r28
    27a2:	6a 5f       	subi	r22, 0xFA	; 250
    27a4:	7f 4f       	sbci	r23, 0xFF	; 255
    27a6:	ce 01       	movw	r24, r28
    27a8:	01 96       	adiw	r24, 0x01	; 1
    27aa:	0e 94 78 19 	call	0x32f0	; 0x32f0 <xTaskCheckForTimeOut>
    27ae:	81 11       	cpse	r24, r1
    27b0:	21 c0       	rjmp	.+66     	; 0x27f4 <xQueueGenericSend+0x10e>
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	0f 92       	push	r0
    27b8:	f7 01       	movw	r30, r14
    27ba:	96 8d       	ldd	r25, Z+30	; 0x1e
    27bc:	0f 90       	pop	r0
    27be:	0f be       	out	0x3f, r0	; 63
    27c0:	87 8d       	ldd	r24, Z+31	; 0x1f
    27c2:	98 13       	cpse	r25, r24
    27c4:	11 c0       	rjmp	.+34     	; 0x27e8 <xQueueGenericSend+0x102>
    27c6:	4e 81       	ldd	r20, Y+6	; 0x06
    27c8:	5f 81       	ldd	r21, Y+7	; 0x07
    27ca:	68 85       	ldd	r22, Y+8	; 0x08
    27cc:	79 85       	ldd	r23, Y+9	; 0x09
    27ce:	c6 01       	movw	r24, r12
    27d0:	0e 94 fe 18 	call	0x31fc	; 0x31fc <vTaskPlaceOnEventList>
    27d4:	c7 01       	movw	r24, r14
    27d6:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
    27da:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
    27de:	81 11       	cpse	r24, r1
    27e0:	9c cf       	rjmp	.-200    	; 0x271a <xQueueGenericSend+0x34>
    27e2:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    27e6:	99 cf       	rjmp	.-206    	; 0x271a <xQueueGenericSend+0x34>
    27e8:	c7 01       	movw	r24, r14
    27ea:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
    27ee:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
    27f2:	93 cf       	rjmp	.-218    	; 0x271a <xQueueGenericSend+0x34>
    27f4:	c7 01       	movw	r24, r14
    27f6:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
    27fa:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
    27fe:	80 e0       	ldi	r24, 0x00	; 0
    2800:	29 96       	adiw	r28, 0x09	; 9
    2802:	cd bf       	out	0x3d, r28	; 61
    2804:	de bf       	out	0x3e, r29	; 62
    2806:	df 91       	pop	r29
    2808:	cf 91       	pop	r28
    280a:	1f 91       	pop	r17
    280c:	0f 91       	pop	r16
    280e:	ff 90       	pop	r15
    2810:	ef 90       	pop	r14
    2812:	df 90       	pop	r13
    2814:	cf 90       	pop	r12
    2816:	bf 90       	pop	r11
    2818:	af 90       	pop	r10
    281a:	08 95       	ret

0000281c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    281c:	0f 93       	push	r16
    281e:	1f 93       	push	r17
    2820:	cf 93       	push	r28
    2822:	df 93       	push	r29
    2824:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2826:	fc 01       	movw	r30, r24
    2828:	56 8d       	ldd	r21, Z+30	; 0x1e
    282a:	37 8d       	ldd	r19, Z+31	; 0x1f
    282c:	53 17       	cp	r21, r19
    282e:	c0 f4       	brcc	.+48     	; 0x2860 <xQueueGenericSendFromISR+0x44>
    2830:	42 2f       	mov	r20, r18
    2832:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2834:	0e 94 59 12 	call	0x24b2	; 0x24b2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2838:	8a a1       	ldd	r24, Y+34	; 0x22
    283a:	8f 3f       	cpi	r24, 0xFF	; 255
    283c:	69 f4       	brne	.+26     	; 0x2858 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    283e:	8b 89       	ldd	r24, Y+19	; 0x13
    2840:	88 23       	and	r24, r24
    2842:	81 f0       	breq	.+32     	; 0x2864 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2844:	ce 01       	movw	r24, r28
    2846:	43 96       	adiw	r24, 0x13	; 19
    2848:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    284c:	88 23       	and	r24, r24
    284e:	61 f0       	breq	.+24     	; 0x2868 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2850:	81 e0       	ldi	r24, 0x01	; 1
    2852:	f8 01       	movw	r30, r16
    2854:	80 83       	st	Z, r24
    2856:	09 c0       	rjmp	.+18     	; 0x286a <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2858:	8f 5f       	subi	r24, 0xFF	; 255
    285a:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    285c:	81 e0       	ldi	r24, 0x01	; 1
    285e:	05 c0       	rjmp	.+10     	; 0x286a <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2860:	80 e0       	ldi	r24, 0x00	; 0
    2862:	03 c0       	rjmp	.+6      	; 0x286a <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	01 c0       	rjmp	.+2      	; 0x286a <xQueueGenericSendFromISR+0x4e>
    2868:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    286a:	df 91       	pop	r29
    286c:	cf 91       	pop	r28
    286e:	1f 91       	pop	r17
    2870:	0f 91       	pop	r16
    2872:	08 95       	ret

00002874 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2874:	af 92       	push	r10
    2876:	bf 92       	push	r11
    2878:	cf 92       	push	r12
    287a:	df 92       	push	r13
    287c:	ef 92       	push	r14
    287e:	ff 92       	push	r15
    2880:	0f 93       	push	r16
    2882:	1f 93       	push	r17
    2884:	cf 93       	push	r28
    2886:	df 93       	push	r29
    2888:	cd b7       	in	r28, 0x3d	; 61
    288a:	de b7       	in	r29, 0x3e	; 62
    288c:	29 97       	sbiw	r28, 0x09	; 9
    288e:	cd bf       	out	0x3d, r28	; 61
    2890:	de bf       	out	0x3e, r29	; 62
    2892:	7c 01       	movw	r14, r24
    2894:	5b 01       	movw	r10, r22
    2896:	2e 83       	std	Y+6, r18	; 0x06
    2898:	3f 83       	std	Y+7, r19	; 0x07
    289a:	48 87       	std	Y+8, r20	; 0x08
    289c:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    289e:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28a0:	6c 01       	movw	r12, r24
    28a2:	83 e1       	ldi	r24, 0x13	; 19
    28a4:	c8 0e       	add	r12, r24
    28a6:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    28a8:	0f b6       	in	r0, 0x3f	; 63
    28aa:	f8 94       	cli
    28ac:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    28ae:	f7 01       	movw	r30, r14
    28b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    28b2:	88 23       	and	r24, r24
    28b4:	99 f1       	breq	.+102    	; 0x291c <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    28b6:	c6 80       	ldd	r12, Z+6	; 0x06
    28b8:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    28ba:	b5 01       	movw	r22, r10
    28bc:	c7 01       	movw	r24, r14
    28be:	0e 94 a5 12 	call	0x254a	; 0x254a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    28c2:	01 11       	cpse	r16, r1
    28c4:	1a c0       	rjmp	.+52     	; 0x28fa <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    28c6:	f7 01       	movw	r30, r14
    28c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    28ca:	81 50       	subi	r24, 0x01	; 1
    28cc:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28ce:	80 81       	ld	r24, Z
    28d0:	91 81       	ldd	r25, Z+1	; 0x01
    28d2:	89 2b       	or	r24, r25
    28d4:	29 f4       	brne	.+10     	; 0x28e0 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    28d6:	0e 94 02 1a 	call	0x3404	; 0x3404 <xTaskGetCurrentTaskHandle>
    28da:	f7 01       	movw	r30, r14
    28dc:	82 83       	std	Z+2, r24	; 0x02
    28de:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28e0:	f7 01       	movw	r30, r14
    28e2:	80 85       	ldd	r24, Z+8	; 0x08
    28e4:	88 23       	and	r24, r24
    28e6:	b1 f0       	breq	.+44     	; 0x2914 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    28e8:	c7 01       	movw	r24, r14
    28ea:	08 96       	adiw	r24, 0x08	; 8
    28ec:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    28f0:	81 30       	cpi	r24, 0x01	; 1
    28f2:	81 f4       	brne	.+32     	; 0x2914 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    28f4:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    28f8:	0d c0       	rjmp	.+26     	; 0x2914 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    28fa:	f7 01       	movw	r30, r14
    28fc:	c6 82       	std	Z+6, r12	; 0x06
    28fe:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2900:	83 89       	ldd	r24, Z+19	; 0x13
    2902:	88 23       	and	r24, r24
    2904:	39 f0       	breq	.+14     	; 0x2914 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2906:	c7 01       	movw	r24, r14
    2908:	43 96       	adiw	r24, 0x13	; 19
    290a:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    290e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2910:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2914:	0f 90       	pop	r0
    2916:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2918:	81 e0       	ldi	r24, 0x01	; 1
    291a:	62 c0       	rjmp	.+196    	; 0x29e0 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    291c:	8e 81       	ldd	r24, Y+6	; 0x06
    291e:	9f 81       	ldd	r25, Y+7	; 0x07
    2920:	a8 85       	ldd	r26, Y+8	; 0x08
    2922:	b9 85       	ldd	r27, Y+9	; 0x09
    2924:	89 2b       	or	r24, r25
    2926:	8a 2b       	or	r24, r26
    2928:	8b 2b       	or	r24, r27
    292a:	21 f4       	brne	.+8      	; 0x2934 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    292c:	0f 90       	pop	r0
    292e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2930:	80 e0       	ldi	r24, 0x00	; 0
    2932:	56 c0       	rjmp	.+172    	; 0x29e0 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2934:	11 11       	cpse	r17, r1
    2936:	05 c0       	rjmp	.+10     	; 0x2942 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2938:	ce 01       	movw	r24, r28
    293a:	01 96       	adiw	r24, 0x01	; 1
    293c:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2940:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2942:	0f 90       	pop	r0
    2944:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2946:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    294a:	0f b6       	in	r0, 0x3f	; 63
    294c:	f8 94       	cli
    294e:	0f 92       	push	r0
    2950:	f7 01       	movw	r30, r14
    2952:	81 a1       	ldd	r24, Z+33	; 0x21
    2954:	8f 3f       	cpi	r24, 0xFF	; 255
    2956:	09 f4       	brne	.+2      	; 0x295a <xQueueGenericReceive+0xe6>
    2958:	11 a2       	std	Z+33, r1	; 0x21
    295a:	f7 01       	movw	r30, r14
    295c:	82 a1       	ldd	r24, Z+34	; 0x22
    295e:	8f 3f       	cpi	r24, 0xFF	; 255
    2960:	09 f4       	brne	.+2      	; 0x2964 <xQueueGenericReceive+0xf0>
    2962:	12 a2       	std	Z+34, r1	; 0x22
    2964:	0f 90       	pop	r0
    2966:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2968:	be 01       	movw	r22, r28
    296a:	6a 5f       	subi	r22, 0xFA	; 250
    296c:	7f 4f       	sbci	r23, 0xFF	; 255
    296e:	ce 01       	movw	r24, r28
    2970:	01 96       	adiw	r24, 0x01	; 1
    2972:	0e 94 78 19 	call	0x32f0	; 0x32f0 <xTaskCheckForTimeOut>
    2976:	81 11       	cpse	r24, r1
    2978:	2d c0       	rjmp	.+90     	; 0x29d4 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    297a:	0f b6       	in	r0, 0x3f	; 63
    297c:	f8 94       	cli
    297e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2980:	f7 01       	movw	r30, r14
    2982:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2984:	0f 90       	pop	r0
    2986:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2988:	81 11       	cpse	r24, r1
    298a:	1e c0       	rjmp	.+60     	; 0x29c8 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    298c:	80 81       	ld	r24, Z
    298e:	91 81       	ldd	r25, Z+1	; 0x01
    2990:	89 2b       	or	r24, r25
    2992:	49 f4       	brne	.+18     	; 0x29a6 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2994:	0f b6       	in	r0, 0x3f	; 63
    2996:	f8 94       	cli
    2998:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    299a:	82 81       	ldd	r24, Z+2	; 0x02
    299c:	93 81       	ldd	r25, Z+3	; 0x03
    299e:	0e 94 07 1a 	call	0x340e	; 0x340e <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    29a2:	0f 90       	pop	r0
    29a4:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    29a6:	4e 81       	ldd	r20, Y+6	; 0x06
    29a8:	5f 81       	ldd	r21, Y+7	; 0x07
    29aa:	68 85       	ldd	r22, Y+8	; 0x08
    29ac:	79 85       	ldd	r23, Y+9	; 0x09
    29ae:	c6 01       	movw	r24, r12
    29b0:	0e 94 fe 18 	call	0x31fc	; 0x31fc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    29b4:	c7 01       	movw	r24, r14
    29b6:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    29ba:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
    29be:	81 11       	cpse	r24, r1
    29c0:	73 cf       	rjmp	.-282    	; 0x28a8 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    29c2:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    29c6:	70 cf       	rjmp	.-288    	; 0x28a8 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    29c8:	c7 01       	movw	r24, r14
    29ca:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29ce:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
    29d2:	6a cf       	rjmp	.-300    	; 0x28a8 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    29d4:	c7 01       	movw	r24, r14
    29d6:	0e 94 bf 12 	call	0x257e	; 0x257e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    29da:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    29de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    29e0:	29 96       	adiw	r28, 0x09	; 9
    29e2:	cd bf       	out	0x3d, r28	; 61
    29e4:	de bf       	out	0x3e, r29	; 62
    29e6:	df 91       	pop	r29
    29e8:	cf 91       	pop	r28
    29ea:	1f 91       	pop	r17
    29ec:	0f 91       	pop	r16
    29ee:	ff 90       	pop	r15
    29f0:	ef 90       	pop	r14
    29f2:	df 90       	pop	r13
    29f4:	cf 90       	pop	r12
    29f6:	bf 90       	pop	r11
    29f8:	af 90       	pop	r10
    29fa:	08 95       	ret

000029fc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    29fc:	0f 93       	push	r16
    29fe:	1f 93       	push	r17
    2a00:	cf 93       	push	r28
    2a02:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2a04:	fc 01       	movw	r30, r24
    2a06:	26 8d       	ldd	r18, Z+30	; 0x1e
    2a08:	22 23       	and	r18, r18
    2a0a:	d9 f0       	breq	.+54     	; 0x2a42 <xQueueReceiveFromISR+0x46>
    2a0c:	8a 01       	movw	r16, r20
    2a0e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2a10:	0e 94 a5 12 	call	0x254a	; 0x254a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2a14:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2a16:	81 50       	subi	r24, 0x01	; 1
    2a18:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2a1a:	89 a1       	ldd	r24, Y+33	; 0x21
    2a1c:	8f 3f       	cpi	r24, 0xFF	; 255
    2a1e:	69 f4       	brne	.+26     	; 0x2a3a <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a20:	88 85       	ldd	r24, Y+8	; 0x08
    2a22:	88 23       	and	r24, r24
    2a24:	81 f0       	breq	.+32     	; 0x2a46 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a26:	ce 01       	movw	r24, r28
    2a28:	08 96       	adiw	r24, 0x08	; 8
    2a2a:	0e 94 28 19 	call	0x3250	; 0x3250 <xTaskRemoveFromEventList>
    2a2e:	88 23       	and	r24, r24
    2a30:	61 f0       	breq	.+24     	; 0x2a4a <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2a32:	81 e0       	ldi	r24, 0x01	; 1
    2a34:	f8 01       	movw	r30, r16
    2a36:	80 83       	st	Z, r24
    2a38:	09 c0       	rjmp	.+18     	; 0x2a4c <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2a3a:	8f 5f       	subi	r24, 0xFF	; 255
    2a3c:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	05 c0       	rjmp	.+10     	; 0x2a4c <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2a42:	80 e0       	ldi	r24, 0x00	; 0
    2a44:	03 c0       	rjmp	.+6      	; 0x2a4c <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2a46:	81 e0       	ldi	r24, 0x01	; 1
    2a48:	01 c0       	rjmp	.+2      	; 0x2a4c <xQueueReceiveFromISR+0x50>
    2a4a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2a4c:	df 91       	pop	r29
    2a4e:	cf 91       	pop	r28
    2a50:	1f 91       	pop	r17
    2a52:	0f 91       	pop	r16
    2a54:	08 95       	ret

00002a56 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2a56:	0f b6       	in	r0, 0x3f	; 63
    2a58:	f8 94       	cli
    2a5a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2a5c:	fc 01       	movw	r30, r24
    2a5e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2a60:	0f 90       	pop	r0
    2a62:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2a64:	08 95       	ret

00002a66 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2a66:	fc 01       	movw	r30, r24
    2a68:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    2a6a:	08 95       	ret

00002a6c <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2a6c:	c6 e1       	ldi	r28, 0x16	; 22
    2a6e:	d3 e3       	ldi	r29, 0x33	; 51
    2a70:	88 81       	ld	r24, Y
    2a72:	82 30       	cpi	r24, 0x02	; 2
    2a74:	e8 f3       	brcs	.-6      	; 0x2a70 <prvIdleTask+0x4>
    2a76:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    2a7a:	fa cf       	rjmp	.-12     	; 0x2a70 <prvIdleTask+0x4>

00002a7c <prvAddCurrentTaskToDelayedList>:
    2a7c:	cf 92       	push	r12
    2a7e:	df 92       	push	r13
    2a80:	ef 92       	push	r14
    2a82:	ff 92       	push	r15
    2a84:	6b 01       	movw	r12, r22
    2a86:	7c 01       	movw	r14, r24
    2a88:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    2a8c:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2a90:	62 83       	std	Z+2, r22	; 0x02
    2a92:	73 83       	std	Z+3, r23	; 0x03
    2a94:	84 83       	std	Z+4, r24	; 0x04
    2a96:	95 83       	std	Z+5, r25	; 0x05
    2a98:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    2a9c:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2aa0:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2aa4:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2aa8:	c8 16       	cp	r12, r24
    2aaa:	d9 06       	cpc	r13, r25
    2aac:	ea 06       	cpc	r14, r26
    2aae:	fb 06       	cpc	r15, r27
    2ab0:	68 f4       	brcc	.+26     	; 0x2acc <prvAddCurrentTaskToDelayedList+0x50>
    2ab2:	60 91 42 33 	lds	r22, 0x3342	; 0x803342 <pxCurrentTCB>
    2ab6:	70 91 43 33 	lds	r23, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2aba:	80 91 fc 32 	lds	r24, 0x32FC	; 0x8032fc <pxOverflowDelayedTaskList>
    2abe:	90 91 fd 32 	lds	r25, 0x32FD	; 0x8032fd <pxOverflowDelayedTaskList+0x1>
    2ac2:	6e 5f       	subi	r22, 0xFE	; 254
    2ac4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac6:	0e 94 6d 10 	call	0x20da	; 0x20da <vListInsert>
    2aca:	21 c0       	rjmp	.+66     	; 0x2b0e <prvAddCurrentTaskToDelayedList+0x92>
    2acc:	60 91 42 33 	lds	r22, 0x3342	; 0x803342 <pxCurrentTCB>
    2ad0:	70 91 43 33 	lds	r23, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2ad4:	80 91 fe 32 	lds	r24, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2ad8:	90 91 ff 32 	lds	r25, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2adc:	6e 5f       	subi	r22, 0xFE	; 254
    2ade:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae0:	0e 94 6d 10 	call	0x20da	; 0x20da <vListInsert>
    2ae4:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2ae8:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2aec:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2af0:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2af4:	c8 16       	cp	r12, r24
    2af6:	d9 06       	cpc	r13, r25
    2af8:	ea 06       	cpc	r14, r26
    2afa:	fb 06       	cpc	r15, r27
    2afc:	40 f4       	brcc	.+16     	; 0x2b0e <prvAddCurrentTaskToDelayedList+0x92>
    2afe:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2b02:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2b06:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    2b0a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2b0e:	ff 90       	pop	r15
    2b10:	ef 90       	pop	r14
    2b12:	df 90       	pop	r13
    2b14:	cf 90       	pop	r12
    2b16:	08 95       	ret

00002b18 <xTaskGenericCreate>:
    2b18:	4f 92       	push	r4
    2b1a:	5f 92       	push	r5
    2b1c:	6f 92       	push	r6
    2b1e:	7f 92       	push	r7
    2b20:	8f 92       	push	r8
    2b22:	9f 92       	push	r9
    2b24:	af 92       	push	r10
    2b26:	bf 92       	push	r11
    2b28:	cf 92       	push	r12
    2b2a:	df 92       	push	r13
    2b2c:	ef 92       	push	r14
    2b2e:	ff 92       	push	r15
    2b30:	0f 93       	push	r16
    2b32:	1f 93       	push	r17
    2b34:	cf 93       	push	r28
    2b36:	df 93       	push	r29
    2b38:	5c 01       	movw	r10, r24
    2b3a:	4b 01       	movw	r8, r22
    2b3c:	3a 01       	movw	r6, r20
    2b3e:	29 01       	movw	r4, r18
    2b40:	88 e2       	ldi	r24, 0x28	; 40
    2b42:	90 e0       	ldi	r25, 0x00	; 0
    2b44:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    2b48:	ec 01       	movw	r28, r24
    2b4a:	89 2b       	or	r24, r25
    2b4c:	09 f4       	brne	.+2      	; 0x2b50 <xTaskGenericCreate+0x38>
    2b4e:	d4 c0       	rjmp	.+424    	; 0x2cf8 <xTaskGenericCreate+0x1e0>
    2b50:	c1 14       	cp	r12, r1
    2b52:	d1 04       	cpc	r13, r1
    2b54:	09 f0       	breq	.+2      	; 0x2b58 <xTaskGenericCreate+0x40>
    2b56:	cc c0       	rjmp	.+408    	; 0x2cf0 <xTaskGenericCreate+0x1d8>
    2b58:	c3 01       	movw	r24, r6
    2b5a:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    2b5e:	8b 8f       	std	Y+27, r24	; 0x1b
    2b60:	9c 8f       	std	Y+28, r25	; 0x1c
    2b62:	00 97       	sbiw	r24, 0x00	; 0
    2b64:	21 f4       	brne	.+8      	; 0x2b6e <xTaskGenericCreate+0x56>
    2b66:	ce 01       	movw	r24, r28
    2b68:	0e 94 f9 0f 	call	0x1ff2	; 0x1ff2 <vPortFree>
    2b6c:	c5 c0       	rjmp	.+394    	; 0x2cf8 <xTaskGenericCreate+0x1e0>
    2b6e:	a3 01       	movw	r20, r6
    2b70:	61 e1       	ldi	r22, 0x11	; 17
    2b72:	70 e0       	ldi	r23, 0x00	; 0
    2b74:	0e 94 d8 27 	call	0x4fb0	; 0x4fb0 <memset>
    2b78:	93 01       	movw	r18, r6
    2b7a:	21 50       	subi	r18, 0x01	; 1
    2b7c:	31 09       	sbc	r19, r1
    2b7e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2b80:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2b82:	3c 01       	movw	r6, r24
    2b84:	62 0e       	add	r6, r18
    2b86:	73 1e       	adc	r7, r19
    2b88:	4a e0       	ldi	r20, 0x0A	; 10
    2b8a:	50 e0       	ldi	r21, 0x00	; 0
    2b8c:	b4 01       	movw	r22, r8
    2b8e:	ce 01       	movw	r24, r28
    2b90:	4d 96       	adiw	r24, 0x1d	; 29
    2b92:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <strncpy>
    2b96:	1e a2       	std	Y+38, r1	; 0x26
    2b98:	10 2f       	mov	r17, r16
    2b9a:	04 30       	cpi	r16, 0x04	; 4
    2b9c:	08 f0       	brcs	.+2      	; 0x2ba0 <xTaskGenericCreate+0x88>
    2b9e:	13 e0       	ldi	r17, 0x03	; 3
    2ba0:	1a 8f       	std	Y+26, r17	; 0x1a
    2ba2:	1f a3       	std	Y+39, r17	; 0x27
    2ba4:	6e 01       	movw	r12, r28
    2ba6:	22 e0       	ldi	r18, 0x02	; 2
    2ba8:	c2 0e       	add	r12, r18
    2baa:	d1 1c       	adc	r13, r1
    2bac:	c6 01       	movw	r24, r12
    2bae:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialiseItem>
    2bb2:	ce 01       	movw	r24, r28
    2bb4:	0e 96       	adiw	r24, 0x0e	; 14
    2bb6:	0e 94 42 10 	call	0x2084	; 0x2084 <vListInitialiseItem>
    2bba:	ca 87       	std	Y+10, r28	; 0x0a
    2bbc:	db 87       	std	Y+11, r29	; 0x0b
    2bbe:	84 e0       	ldi	r24, 0x04	; 4
    2bc0:	90 e0       	ldi	r25, 0x00	; 0
    2bc2:	a0 e0       	ldi	r26, 0x00	; 0
    2bc4:	b0 e0       	ldi	r27, 0x00	; 0
    2bc6:	81 1b       	sub	r24, r17
    2bc8:	91 09       	sbc	r25, r1
    2bca:	a1 09       	sbc	r26, r1
    2bcc:	b1 09       	sbc	r27, r1
    2bce:	8e 87       	std	Y+14, r24	; 0x0e
    2bd0:	9f 87       	std	Y+15, r25	; 0x0f
    2bd2:	a8 8b       	std	Y+16, r26	; 0x10
    2bd4:	b9 8b       	std	Y+17, r27	; 0x11
    2bd6:	ce 8b       	std	Y+22, r28	; 0x16
    2bd8:	df 8b       	std	Y+23, r29	; 0x17
    2bda:	a2 01       	movw	r20, r4
    2bdc:	b5 01       	movw	r22, r10
    2bde:	c3 01       	movw	r24, r6
    2be0:	0e 94 de 10 	call	0x21bc	; 0x21bc <pxPortInitialiseStack>
    2be4:	88 83       	st	Y, r24
    2be6:	99 83       	std	Y+1, r25	; 0x01
    2be8:	e1 14       	cp	r14, r1
    2bea:	f1 04       	cpc	r15, r1
    2bec:	19 f0       	breq	.+6      	; 0x2bf4 <xTaskGenericCreate+0xdc>
    2bee:	f7 01       	movw	r30, r14
    2bf0:	c0 83       	st	Z, r28
    2bf2:	d1 83       	std	Z+1, r29	; 0x01
    2bf4:	0f b6       	in	r0, 0x3f	; 63
    2bf6:	f8 94       	cli
    2bf8:	0f 92       	push	r0
    2bfa:	80 91 ee 32 	lds	r24, 0x32EE	; 0x8032ee <uxCurrentNumberOfTasks>
    2bfe:	8f 5f       	subi	r24, 0xFF	; 255
    2c00:	80 93 ee 32 	sts	0x32EE, r24	; 0x8032ee <uxCurrentNumberOfTasks>
    2c04:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    2c08:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2c0c:	89 2b       	or	r24, r25
    2c0e:	89 f5       	brne	.+98     	; 0x2c72 <xTaskGenericCreate+0x15a>
    2c10:	c0 93 42 33 	sts	0x3342, r28	; 0x803342 <pxCurrentTCB>
    2c14:	d0 93 43 33 	sts	0x3343, r29	; 0x803343 <pxCurrentTCB+0x1>
    2c18:	80 91 ee 32 	lds	r24, 0x32EE	; 0x8032ee <uxCurrentNumberOfTasks>
    2c1c:	81 30       	cpi	r24, 0x01	; 1
    2c1e:	c1 f5       	brne	.+112    	; 0x2c90 <xTaskGenericCreate+0x178>
    2c20:	86 e1       	ldi	r24, 0x16	; 22
    2c22:	93 e3       	ldi	r25, 0x33	; 51
    2c24:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c28:	81 e2       	ldi	r24, 0x21	; 33
    2c2a:	93 e3       	ldi	r25, 0x33	; 51
    2c2c:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c30:	8c e2       	ldi	r24, 0x2C	; 44
    2c32:	93 e3       	ldi	r25, 0x33	; 51
    2c34:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c38:	87 e3       	ldi	r24, 0x37	; 55
    2c3a:	93 e3       	ldi	r25, 0x33	; 51
    2c3c:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c40:	8b e0       	ldi	r24, 0x0B	; 11
    2c42:	93 e3       	ldi	r25, 0x33	; 51
    2c44:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c48:	80 e0       	ldi	r24, 0x00	; 0
    2c4a:	93 e3       	ldi	r25, 0x33	; 51
    2c4c:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c50:	81 ef       	ldi	r24, 0xF1	; 241
    2c52:	92 e3       	ldi	r25, 0x32	; 50
    2c54:	0e 94 31 10 	call	0x2062	; 0x2062 <vListInitialise>
    2c58:	8b e0       	ldi	r24, 0x0B	; 11
    2c5a:	93 e3       	ldi	r25, 0x33	; 51
    2c5c:	80 93 fe 32 	sts	0x32FE, r24	; 0x8032fe <pxDelayedTaskList>
    2c60:	90 93 ff 32 	sts	0x32FF, r25	; 0x8032ff <pxDelayedTaskList+0x1>
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	93 e3       	ldi	r25, 0x33	; 51
    2c68:	80 93 fc 32 	sts	0x32FC, r24	; 0x8032fc <pxOverflowDelayedTaskList>
    2c6c:	90 93 fd 32 	sts	0x32FD, r25	; 0x8032fd <pxOverflowDelayedTaskList+0x1>
    2c70:	0f c0       	rjmp	.+30     	; 0x2c90 <xTaskGenericCreate+0x178>
    2c72:	80 91 e7 32 	lds	r24, 0x32E7	; 0x8032e7 <xSchedulerRunning>
    2c76:	81 11       	cpse	r24, r1
    2c78:	0b c0       	rjmp	.+22     	; 0x2c90 <xTaskGenericCreate+0x178>
    2c7a:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    2c7e:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2c82:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c84:	08 17       	cp	r16, r24
    2c86:	20 f0       	brcs	.+8      	; 0x2c90 <xTaskGenericCreate+0x178>
    2c88:	c0 93 42 33 	sts	0x3342, r28	; 0x803342 <pxCurrentTCB>
    2c8c:	d0 93 43 33 	sts	0x3343, r29	; 0x803343 <pxCurrentTCB+0x1>
    2c90:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2c92:	90 91 e9 32 	lds	r25, 0x32E9	; 0x8032e9 <uxTopUsedPriority>
    2c96:	98 17       	cp	r25, r24
    2c98:	10 f4       	brcc	.+4      	; 0x2c9e <xTaskGenericCreate+0x186>
    2c9a:	80 93 e9 32 	sts	0x32E9, r24	; 0x8032e9 <uxTopUsedPriority>
    2c9e:	90 91 e2 32 	lds	r25, 0x32E2	; 0x8032e2 <uxTaskNumber>
    2ca2:	9f 5f       	subi	r25, 0xFF	; 255
    2ca4:	90 93 e2 32 	sts	0x32E2, r25	; 0x8032e2 <uxTaskNumber>
    2ca8:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    2cac:	98 17       	cp	r25, r24
    2cae:	10 f4       	brcc	.+4      	; 0x2cb4 <xTaskGenericCreate+0x19c>
    2cb0:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    2cb4:	fb e0       	ldi	r31, 0x0B	; 11
    2cb6:	8f 9f       	mul	r24, r31
    2cb8:	c0 01       	movw	r24, r0
    2cba:	11 24       	eor	r1, r1
    2cbc:	b6 01       	movw	r22, r12
    2cbe:	8a 5e       	subi	r24, 0xEA	; 234
    2cc0:	9c 4c       	sbci	r25, 0xCC	; 204
    2cc2:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
    2cc6:	0f 90       	pop	r0
    2cc8:	0f be       	out	0x3f, r0	; 63
    2cca:	80 91 e7 32 	lds	r24, 0x32E7	; 0x8032e7 <xSchedulerRunning>
    2cce:	88 23       	and	r24, r24
    2cd0:	59 f0       	breq	.+22     	; 0x2ce8 <xTaskGenericCreate+0x1d0>
    2cd2:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    2cd6:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2cda:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cdc:	80 17       	cp	r24, r16
    2cde:	30 f4       	brcc	.+12     	; 0x2cec <xTaskGenericCreate+0x1d4>
    2ce0:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    2ce4:	81 e0       	ldi	r24, 0x01	; 1
    2ce6:	09 c0       	rjmp	.+18     	; 0x2cfa <xTaskGenericCreate+0x1e2>
    2ce8:	81 e0       	ldi	r24, 0x01	; 1
    2cea:	07 c0       	rjmp	.+14     	; 0x2cfa <xTaskGenericCreate+0x1e2>
    2cec:	81 e0       	ldi	r24, 0x01	; 1
    2cee:	05 c0       	rjmp	.+10     	; 0x2cfa <xTaskGenericCreate+0x1e2>
    2cf0:	cb 8e       	std	Y+27, r12	; 0x1b
    2cf2:	dc 8e       	std	Y+28, r13	; 0x1c
    2cf4:	c6 01       	movw	r24, r12
    2cf6:	3b cf       	rjmp	.-394    	; 0x2b6e <xTaskGenericCreate+0x56>
    2cf8:	8f ef       	ldi	r24, 0xFF	; 255
    2cfa:	df 91       	pop	r29
    2cfc:	cf 91       	pop	r28
    2cfe:	1f 91       	pop	r17
    2d00:	0f 91       	pop	r16
    2d02:	ff 90       	pop	r15
    2d04:	ef 90       	pop	r14
    2d06:	df 90       	pop	r13
    2d08:	cf 90       	pop	r12
    2d0a:	bf 90       	pop	r11
    2d0c:	af 90       	pop	r10
    2d0e:	9f 90       	pop	r9
    2d10:	8f 90       	pop	r8
    2d12:	7f 90       	pop	r7
    2d14:	6f 90       	pop	r6
    2d16:	5f 90       	pop	r5
    2d18:	4f 90       	pop	r4
    2d1a:	08 95       	ret

00002d1c <uxTaskPriorityGet>:
    2d1c:	0f b6       	in	r0, 0x3f	; 63
    2d1e:	f8 94       	cli
    2d20:	0f 92       	push	r0
    2d22:	00 97       	sbiw	r24, 0x00	; 0
    2d24:	21 f4       	brne	.+8      	; 0x2d2e <uxTaskPriorityGet+0x12>
    2d26:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    2d2a:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2d2e:	0f 90       	pop	r0
    2d30:	0f be       	out	0x3f, r0	; 63
    2d32:	fc 01       	movw	r30, r24
    2d34:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d36:	08 95       	ret

00002d38 <vTaskStartScheduler>:
    2d38:	af 92       	push	r10
    2d3a:	bf 92       	push	r11
    2d3c:	cf 92       	push	r12
    2d3e:	df 92       	push	r13
    2d40:	ef 92       	push	r14
    2d42:	ff 92       	push	r15
    2d44:	0f 93       	push	r16
    2d46:	a1 2c       	mov	r10, r1
    2d48:	b1 2c       	mov	r11, r1
    2d4a:	c1 2c       	mov	r12, r1
    2d4c:	d1 2c       	mov	r13, r1
    2d4e:	0f 2e       	mov	r0, r31
    2d50:	ff ee       	ldi	r31, 0xEF	; 239
    2d52:	ef 2e       	mov	r14, r31
    2d54:	f2 e3       	ldi	r31, 0x32	; 50
    2d56:	ff 2e       	mov	r15, r31
    2d58:	f0 2d       	mov	r31, r0
    2d5a:	00 e0       	ldi	r16, 0x00	; 0
    2d5c:	20 e0       	ldi	r18, 0x00	; 0
    2d5e:	30 e0       	ldi	r19, 0x00	; 0
    2d60:	44 e6       	ldi	r20, 0x64	; 100
    2d62:	50 e0       	ldi	r21, 0x00	; 0
    2d64:	67 e2       	ldi	r22, 0x27	; 39
    2d66:	72 e2       	ldi	r23, 0x22	; 34
    2d68:	86 e3       	ldi	r24, 0x36	; 54
    2d6a:	95 e1       	ldi	r25, 0x15	; 21
    2d6c:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xTaskGenericCreate>
    2d70:	81 30       	cpi	r24, 0x01	; 1
    2d72:	69 f4       	brne	.+26     	; 0x2d8e <vTaskStartScheduler+0x56>
    2d74:	f8 94       	cli
    2d76:	80 93 e7 32 	sts	0x32E7, r24	; 0x8032e7 <xSchedulerRunning>
    2d7a:	10 92 ea 32 	sts	0x32EA, r1	; 0x8032ea <xTickCount>
    2d7e:	10 92 eb 32 	sts	0x32EB, r1	; 0x8032eb <xTickCount+0x1>
    2d82:	10 92 ec 32 	sts	0x32EC, r1	; 0x8032ec <xTickCount+0x2>
    2d86:	10 92 ed 32 	sts	0x32ED, r1	; 0x8032ed <xTickCount+0x3>
    2d8a:	0e 94 54 11 	call	0x22a8	; 0x22a8 <xPortStartScheduler>
    2d8e:	0f 91       	pop	r16
    2d90:	ff 90       	pop	r15
    2d92:	ef 90       	pop	r14
    2d94:	df 90       	pop	r13
    2d96:	cf 90       	pop	r12
    2d98:	bf 90       	pop	r11
    2d9a:	af 90       	pop	r10
    2d9c:	08 95       	ret

00002d9e <vTaskSuspendAll>:
    2d9e:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    2da2:	8f 5f       	subi	r24, 0xFF	; 255
    2da4:	80 93 e6 32 	sts	0x32E6, r24	; 0x8032e6 <uxSchedulerSuspended>
    2da8:	08 95       	ret

00002daa <xTaskGetTickCount>:
    2daa:	0f b6       	in	r0, 0x3f	; 63
    2dac:	f8 94       	cli
    2dae:	0f 92       	push	r0
    2db0:	60 91 ea 32 	lds	r22, 0x32EA	; 0x8032ea <xTickCount>
    2db4:	70 91 eb 32 	lds	r23, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2db8:	80 91 ec 32 	lds	r24, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2dbc:	90 91 ed 32 	lds	r25, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2dc0:	0f 90       	pop	r0
    2dc2:	0f be       	out	0x3f, r0	; 63
    2dc4:	08 95       	ret

00002dc6 <pcTaskGetTaskName>:
    2dc6:	00 97       	sbiw	r24, 0x00	; 0
    2dc8:	21 f4       	brne	.+8      	; 0x2dd2 <pcTaskGetTaskName+0xc>
    2dca:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    2dce:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    2dd2:	4d 96       	adiw	r24, 0x1d	; 29
    2dd4:	08 95       	ret

00002dd6 <xTaskGetIdleTaskHandle>:
    2dd6:	80 91 ef 32 	lds	r24, 0x32EF	; 0x8032ef <xIdleTaskHandle>
    2dda:	90 91 f0 32 	lds	r25, 0x32F0	; 0x8032f0 <xIdleTaskHandle+0x1>
    2dde:	08 95       	ret

00002de0 <vTaskIncrementTick>:
    2de0:	ff 92       	push	r15
    2de2:	0f 93       	push	r16
    2de4:	1f 93       	push	r17
    2de6:	cf 93       	push	r28
    2de8:	df 93       	push	r29
    2dea:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    2dee:	81 11       	cpse	r24, r1
    2df0:	ed c0       	rjmp	.+474    	; 0x2fcc <vTaskIncrementTick+0x1ec>
    2df2:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    2df6:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2dfa:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2dfe:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2e02:	01 96       	adiw	r24, 0x01	; 1
    2e04:	a1 1d       	adc	r26, r1
    2e06:	b1 1d       	adc	r27, r1
    2e08:	80 93 ea 32 	sts	0x32EA, r24	; 0x8032ea <xTickCount>
    2e0c:	90 93 eb 32 	sts	0x32EB, r25	; 0x8032eb <xTickCount+0x1>
    2e10:	a0 93 ec 32 	sts	0x32EC, r26	; 0x8032ec <xTickCount+0x2>
    2e14:	b0 93 ed 32 	sts	0x32ED, r27	; 0x8032ed <xTickCount+0x3>
    2e18:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    2e1c:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2e20:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2e24:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2e28:	89 2b       	or	r24, r25
    2e2a:	8a 2b       	or	r24, r26
    2e2c:	8b 2b       	or	r24, r27
    2e2e:	f1 f5       	brne	.+124    	; 0x2eac <vTaskIncrementTick+0xcc>
    2e30:	80 91 fe 32 	lds	r24, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2e34:	90 91 ff 32 	lds	r25, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2e38:	20 91 fc 32 	lds	r18, 0x32FC	; 0x8032fc <pxOverflowDelayedTaskList>
    2e3c:	30 91 fd 32 	lds	r19, 0x32FD	; 0x8032fd <pxOverflowDelayedTaskList+0x1>
    2e40:	20 93 fe 32 	sts	0x32FE, r18	; 0x8032fe <pxDelayedTaskList>
    2e44:	30 93 ff 32 	sts	0x32FF, r19	; 0x8032ff <pxDelayedTaskList+0x1>
    2e48:	80 93 fc 32 	sts	0x32FC, r24	; 0x8032fc <pxOverflowDelayedTaskList>
    2e4c:	90 93 fd 32 	sts	0x32FD, r25	; 0x8032fd <pxOverflowDelayedTaskList+0x1>
    2e50:	80 91 e3 32 	lds	r24, 0x32E3	; 0x8032e3 <xNumOfOverflows>
    2e54:	8f 5f       	subi	r24, 0xFF	; 255
    2e56:	80 93 e3 32 	sts	0x32E3, r24	; 0x8032e3 <xNumOfOverflows>
    2e5a:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2e5e:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2e62:	80 81       	ld	r24, Z
    2e64:	81 11       	cpse	r24, r1
    2e66:	0c c0       	rjmp	.+24     	; 0x2e80 <vTaskIncrementTick+0xa0>
    2e68:	8f ef       	ldi	r24, 0xFF	; 255
    2e6a:	9f ef       	ldi	r25, 0xFF	; 255
    2e6c:	dc 01       	movw	r26, r24
    2e6e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e72:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e76:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e7a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e7e:	16 c0       	rjmp	.+44     	; 0x2eac <vTaskIncrementTick+0xcc>
    2e80:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2e84:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2e88:	07 80       	ldd	r0, Z+7	; 0x07
    2e8a:	f0 85       	ldd	r31, Z+8	; 0x08
    2e8c:	e0 2d       	mov	r30, r0
    2e8e:	00 84       	ldd	r0, Z+8	; 0x08
    2e90:	f1 85       	ldd	r31, Z+9	; 0x09
    2e92:	e0 2d       	mov	r30, r0
    2e94:	82 81       	ldd	r24, Z+2	; 0x02
    2e96:	93 81       	ldd	r25, Z+3	; 0x03
    2e98:	a4 81       	ldd	r26, Z+4	; 0x04
    2e9a:	b5 81       	ldd	r27, Z+5	; 0x05
    2e9c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2ea0:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2ea4:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2ea8:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2eac:	40 91 ea 32 	lds	r20, 0x32EA	; 0x8032ea <xTickCount>
    2eb0:	50 91 eb 32 	lds	r21, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2eb4:	60 91 ec 32 	lds	r22, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2eb8:	70 91 ed 32 	lds	r23, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2ebc:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2ec0:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2ec4:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2ec8:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2ecc:	48 17       	cp	r20, r24
    2ece:	59 07       	cpc	r21, r25
    2ed0:	6a 07       	cpc	r22, r26
    2ed2:	7b 07       	cpc	r23, r27
    2ed4:	08 f4       	brcc	.+2      	; 0x2ed8 <vTaskIncrementTick+0xf8>
    2ed6:	7f c0       	rjmp	.+254    	; 0x2fd6 <vTaskIncrementTick+0x1f6>
    2ed8:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2edc:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2ee0:	80 81       	ld	r24, Z
    2ee2:	88 23       	and	r24, r24
    2ee4:	f9 f0       	breq	.+62     	; 0x2f24 <vTaskIncrementTick+0x144>
    2ee6:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2eea:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2eee:	07 80       	ldd	r0, Z+7	; 0x07
    2ef0:	f0 85       	ldd	r31, Z+8	; 0x08
    2ef2:	e0 2d       	mov	r30, r0
    2ef4:	c0 85       	ldd	r28, Z+8	; 0x08
    2ef6:	d1 85       	ldd	r29, Z+9	; 0x09
    2ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    2efa:	9b 81       	ldd	r25, Y+3	; 0x03
    2efc:	ac 81       	ldd	r26, Y+4	; 0x04
    2efe:	bd 81       	ldd	r27, Y+5	; 0x05
    2f00:	40 91 ea 32 	lds	r20, 0x32EA	; 0x8032ea <xTickCount>
    2f04:	50 91 eb 32 	lds	r21, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2f08:	60 91 ec 32 	lds	r22, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2f0c:	70 91 ed 32 	lds	r23, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2f10:	48 17       	cp	r20, r24
    2f12:	59 07       	cpc	r21, r25
    2f14:	6a 07       	cpc	r22, r26
    2f16:	7b 07       	cpc	r23, r27
    2f18:	58 f1       	brcs	.+86     	; 0x2f70 <vTaskIncrementTick+0x190>
    2f1a:	0f 2e       	mov	r0, r31
    2f1c:	fb e0       	ldi	r31, 0x0B	; 11
    2f1e:	ff 2e       	mov	r15, r31
    2f20:	f0 2d       	mov	r31, r0
    2f22:	2f c0       	rjmp	.+94     	; 0x2f82 <vTaskIncrementTick+0x1a2>
    2f24:	8f ef       	ldi	r24, 0xFF	; 255
    2f26:	9f ef       	ldi	r25, 0xFF	; 255
    2f28:	dc 01       	movw	r26, r24
    2f2a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2f2e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2f32:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2f36:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2f3a:	4d c0       	rjmp	.+154    	; 0x2fd6 <vTaskIncrementTick+0x1f6>
    2f3c:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2f40:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2f44:	07 80       	ldd	r0, Z+7	; 0x07
    2f46:	f0 85       	ldd	r31, Z+8	; 0x08
    2f48:	e0 2d       	mov	r30, r0
    2f4a:	c0 85       	ldd	r28, Z+8	; 0x08
    2f4c:	d1 85       	ldd	r29, Z+9	; 0x09
    2f4e:	8a 81       	ldd	r24, Y+2	; 0x02
    2f50:	9b 81       	ldd	r25, Y+3	; 0x03
    2f52:	ac 81       	ldd	r26, Y+4	; 0x04
    2f54:	bd 81       	ldd	r27, Y+5	; 0x05
    2f56:	40 91 ea 32 	lds	r20, 0x32EA	; 0x8032ea <xTickCount>
    2f5a:	50 91 eb 32 	lds	r21, 0x32EB	; 0x8032eb <xTickCount+0x1>
    2f5e:	60 91 ec 32 	lds	r22, 0x32EC	; 0x8032ec <xTickCount+0x2>
    2f62:	70 91 ed 32 	lds	r23, 0x32ED	; 0x8032ed <xTickCount+0x3>
    2f66:	48 17       	cp	r20, r24
    2f68:	59 07       	cpc	r21, r25
    2f6a:	6a 07       	cpc	r22, r26
    2f6c:	7b 07       	cpc	r23, r27
    2f6e:	48 f4       	brcc	.+18     	; 0x2f82 <vTaskIncrementTick+0x1a2>
    2f70:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2f74:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2f78:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2f7c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2f80:	2a c0       	rjmp	.+84     	; 0x2fd6 <vTaskIncrementTick+0x1f6>
    2f82:	8e 01       	movw	r16, r28
    2f84:	0e 5f       	subi	r16, 0xFE	; 254
    2f86:	1f 4f       	sbci	r17, 0xFF	; 255
    2f88:	c8 01       	movw	r24, r16
    2f8a:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
    2f8e:	88 8d       	ldd	r24, Y+24	; 0x18
    2f90:	99 8d       	ldd	r25, Y+25	; 0x19
    2f92:	89 2b       	or	r24, r25
    2f94:	21 f0       	breq	.+8      	; 0x2f9e <vTaskIncrementTick+0x1be>
    2f96:	ce 01       	movw	r24, r28
    2f98:	0e 96       	adiw	r24, 0x0e	; 14
    2f9a:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
    2f9e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2fa0:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    2fa4:	98 17       	cp	r25, r24
    2fa6:	10 f4       	brcc	.+4      	; 0x2fac <vTaskIncrementTick+0x1cc>
    2fa8:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    2fac:	f8 9e       	mul	r15, r24
    2fae:	c0 01       	movw	r24, r0
    2fb0:	11 24       	eor	r1, r1
    2fb2:	b8 01       	movw	r22, r16
    2fb4:	8a 5e       	subi	r24, 0xEA	; 234
    2fb6:	9c 4c       	sbci	r25, 0xCC	; 204
    2fb8:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
    2fbc:	e0 91 fe 32 	lds	r30, 0x32FE	; 0x8032fe <pxDelayedTaskList>
    2fc0:	f0 91 ff 32 	lds	r31, 0x32FF	; 0x8032ff <pxDelayedTaskList+0x1>
    2fc4:	80 81       	ld	r24, Z
    2fc6:	81 11       	cpse	r24, r1
    2fc8:	b9 cf       	rjmp	.-142    	; 0x2f3c <vTaskIncrementTick+0x15c>
    2fca:	ac cf       	rjmp	.-168    	; 0x2f24 <vTaskIncrementTick+0x144>
    2fcc:	80 91 e5 32 	lds	r24, 0x32E5	; 0x8032e5 <uxMissedTicks>
    2fd0:	8f 5f       	subi	r24, 0xFF	; 255
    2fd2:	80 93 e5 32 	sts	0x32E5, r24	; 0x8032e5 <uxMissedTicks>
    2fd6:	df 91       	pop	r29
    2fd8:	cf 91       	pop	r28
    2fda:	1f 91       	pop	r17
    2fdc:	0f 91       	pop	r16
    2fde:	ff 90       	pop	r15
    2fe0:	08 95       	ret

00002fe2 <xTaskResumeAll>:
    2fe2:	cf 92       	push	r12
    2fe4:	df 92       	push	r13
    2fe6:	ef 92       	push	r14
    2fe8:	ff 92       	push	r15
    2fea:	0f 93       	push	r16
    2fec:	1f 93       	push	r17
    2fee:	cf 93       	push	r28
    2ff0:	df 93       	push	r29
    2ff2:	0f b6       	in	r0, 0x3f	; 63
    2ff4:	f8 94       	cli
    2ff6:	0f 92       	push	r0
    2ff8:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    2ffc:	81 50       	subi	r24, 0x01	; 1
    2ffe:	80 93 e6 32 	sts	0x32E6, r24	; 0x8032e6 <uxSchedulerSuspended>
    3002:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    3006:	81 11       	cpse	r24, r1
    3008:	60 c0       	rjmp	.+192    	; 0x30ca <xTaskResumeAll+0xe8>
    300a:	80 91 ee 32 	lds	r24, 0x32EE	; 0x8032ee <uxCurrentNumberOfTasks>
    300e:	81 11       	cpse	r24, r1
    3010:	2c c0       	rjmp	.+88     	; 0x306a <xTaskResumeAll+0x88>
    3012:	5e c0       	rjmp	.+188    	; 0x30d0 <xTaskResumeAll+0xee>
    3014:	d7 01       	movw	r26, r14
    3016:	17 96       	adiw	r26, 0x07	; 7
    3018:	ed 91       	ld	r30, X+
    301a:	fc 91       	ld	r31, X
    301c:	18 97       	sbiw	r26, 0x08	; 8
    301e:	c0 85       	ldd	r28, Z+8	; 0x08
    3020:	d1 85       	ldd	r29, Z+9	; 0x09
    3022:	ce 01       	movw	r24, r28
    3024:	0e 96       	adiw	r24, 0x0e	; 14
    3026:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
    302a:	8e 01       	movw	r16, r28
    302c:	0e 5f       	subi	r16, 0xFE	; 254
    302e:	1f 4f       	sbci	r17, 0xFF	; 255
    3030:	c8 01       	movw	r24, r16
    3032:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
    3036:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3038:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    303c:	98 17       	cp	r25, r24
    303e:	10 f4       	brcc	.+4      	; 0x3044 <xTaskResumeAll+0x62>
    3040:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    3044:	d8 9e       	mul	r13, r24
    3046:	c0 01       	movw	r24, r0
    3048:	11 24       	eor	r1, r1
    304a:	b8 01       	movw	r22, r16
    304c:	8a 5e       	subi	r24, 0xEA	; 234
    304e:	9c 4c       	sbci	r25, 0xCC	; 204
    3050:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
    3054:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    3058:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    305c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    305e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3060:	98 17       	cp	r25, r24
    3062:	70 f0       	brcs	.+28     	; 0x3080 <xTaskResumeAll+0x9e>
    3064:	cc 24       	eor	r12, r12
    3066:	c3 94       	inc	r12
    3068:	0b c0       	rjmp	.+22     	; 0x3080 <xTaskResumeAll+0x9e>
    306a:	c1 2c       	mov	r12, r1
    306c:	0f 2e       	mov	r0, r31
    306e:	f1 ef       	ldi	r31, 0xF1	; 241
    3070:	ef 2e       	mov	r14, r31
    3072:	f2 e3       	ldi	r31, 0x32	; 50
    3074:	ff 2e       	mov	r15, r31
    3076:	f0 2d       	mov	r31, r0
    3078:	0f 2e       	mov	r0, r31
    307a:	fb e0       	ldi	r31, 0x0B	; 11
    307c:	df 2e       	mov	r13, r31
    307e:	f0 2d       	mov	r31, r0
    3080:	f7 01       	movw	r30, r14
    3082:	80 81       	ld	r24, Z
    3084:	81 11       	cpse	r24, r1
    3086:	c6 cf       	rjmp	.-116    	; 0x3014 <xTaskResumeAll+0x32>
    3088:	80 91 e5 32 	lds	r24, 0x32E5	; 0x8032e5 <uxMissedTicks>
    308c:	88 23       	and	r24, r24
    308e:	81 f0       	breq	.+32     	; 0x30b0 <xTaskResumeAll+0xce>
    3090:	80 91 e5 32 	lds	r24, 0x32E5	; 0x8032e5 <uxMissedTicks>
    3094:	88 23       	and	r24, r24
    3096:	99 f0       	breq	.+38     	; 0x30be <xTaskResumeAll+0xdc>
    3098:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <vTaskIncrementTick>
    309c:	80 91 e5 32 	lds	r24, 0x32E5	; 0x8032e5 <uxMissedTicks>
    30a0:	81 50       	subi	r24, 0x01	; 1
    30a2:	80 93 e5 32 	sts	0x32E5, r24	; 0x8032e5 <uxMissedTicks>
    30a6:	80 91 e5 32 	lds	r24, 0x32E5	; 0x8032e5 <uxMissedTicks>
    30aa:	81 11       	cpse	r24, r1
    30ac:	f5 cf       	rjmp	.-22     	; 0x3098 <xTaskResumeAll+0xb6>
    30ae:	07 c0       	rjmp	.+14     	; 0x30be <xTaskResumeAll+0xdc>
    30b0:	f1 e0       	ldi	r31, 0x01	; 1
    30b2:	cf 16       	cp	r12, r31
    30b4:	21 f0       	breq	.+8      	; 0x30be <xTaskResumeAll+0xdc>
    30b6:	80 91 e4 32 	lds	r24, 0x32E4	; 0x8032e4 <xMissedYield>
    30ba:	81 30       	cpi	r24, 0x01	; 1
    30bc:	41 f4       	brne	.+16     	; 0x30ce <xTaskResumeAll+0xec>
    30be:	10 92 e4 32 	sts	0x32E4, r1	; 0x8032e4 <xMissedYield>
    30c2:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
    30c6:	81 e0       	ldi	r24, 0x01	; 1
    30c8:	03 c0       	rjmp	.+6      	; 0x30d0 <xTaskResumeAll+0xee>
    30ca:	80 e0       	ldi	r24, 0x00	; 0
    30cc:	01 c0       	rjmp	.+2      	; 0x30d0 <xTaskResumeAll+0xee>
    30ce:	80 e0       	ldi	r24, 0x00	; 0
    30d0:	0f 90       	pop	r0
    30d2:	0f be       	out	0x3f, r0	; 63
    30d4:	df 91       	pop	r29
    30d6:	cf 91       	pop	r28
    30d8:	1f 91       	pop	r17
    30da:	0f 91       	pop	r16
    30dc:	ff 90       	pop	r15
    30de:	ef 90       	pop	r14
    30e0:	df 90       	pop	r13
    30e2:	cf 90       	pop	r12
    30e4:	08 95       	ret

000030e6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    30e6:	cf 92       	push	r12
    30e8:	df 92       	push	r13
    30ea:	ef 92       	push	r14
    30ec:	ff 92       	push	r15
    30ee:	6b 01       	movw	r12, r22
    30f0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    30f2:	67 2b       	or	r22, r23
    30f4:	68 2b       	or	r22, r24
    30f6:	69 2b       	or	r22, r25
    30f8:	e9 f0       	breq	.+58     	; 0x3134 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    30fa:	0e 94 cf 16 	call	0x2d9e	; 0x2d9e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    30fe:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    3102:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    3106:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    310a:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    310e:	c8 0e       	add	r12, r24
    3110:	d9 1e       	adc	r13, r25
    3112:	ea 1e       	adc	r14, r26
    3114:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3116:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    311a:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    311e:	02 96       	adiw	r24, 0x02	; 2
    3120:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3124:	c7 01       	movw	r24, r14
    3126:	b6 01       	movw	r22, r12
    3128:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    312c:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3130:	81 11       	cpse	r24, r1
    3132:	02 c0       	rjmp	.+4      	; 0x3138 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    3134:	0e 94 92 11 	call	0x2324	; 0x2324 <vPortYield>
		}
	}
    3138:	ff 90       	pop	r15
    313a:	ef 90       	pop	r14
    313c:	df 90       	pop	r13
    313e:	cf 90       	pop	r12
    3140:	08 95       	ret

00003142 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3142:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    3146:	81 11       	cpse	r24, r1
    3148:	0c c0       	rjmp	.+24     	; 0x3162 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    314a:	e0 91 e8 32 	lds	r30, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    314e:	4b e0       	ldi	r20, 0x0B	; 11
    3150:	e4 9f       	mul	r30, r20
    3152:	f0 01       	movw	r30, r0
    3154:	11 24       	eor	r1, r1
    3156:	ea 5e       	subi	r30, 0xEA	; 234
    3158:	fc 4c       	sbci	r31, 0xCC	; 204
    315a:	80 81       	ld	r24, Z
    315c:	88 23       	and	r24, r24
    315e:	29 f0       	breq	.+10     	; 0x316a <vTaskSwitchContext+0x28>
    3160:	14 c0       	rjmp	.+40     	; 0x318a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3162:	81 e0       	ldi	r24, 0x01	; 1
    3164:	80 93 e4 32 	sts	0x32E4, r24	; 0x8032e4 <xMissedYield>
    3168:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    316a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    316c:	80 91 e8 32 	lds	r24, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    3170:	81 50       	subi	r24, 0x01	; 1
    3172:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3176:	e0 91 e8 32 	lds	r30, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    317a:	9e 9f       	mul	r25, r30
    317c:	f0 01       	movw	r30, r0
    317e:	11 24       	eor	r1, r1
    3180:	ea 5e       	subi	r30, 0xEA	; 234
    3182:	fc 4c       	sbci	r31, 0xCC	; 204
    3184:	80 81       	ld	r24, Z
    3186:	88 23       	and	r24, r24
    3188:	89 f3       	breq	.-30     	; 0x316c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    318a:	80 91 e8 32 	lds	r24, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    318e:	28 2f       	mov	r18, r24
    3190:	30 e0       	ldi	r19, 0x00	; 0
    3192:	4b e0       	ldi	r20, 0x0B	; 11
    3194:	84 9f       	mul	r24, r20
    3196:	c0 01       	movw	r24, r0
    3198:	11 24       	eor	r1, r1
    319a:	dc 01       	movw	r26, r24
    319c:	aa 5e       	subi	r26, 0xEA	; 234
    319e:	bc 4c       	sbci	r27, 0xCC	; 204
    31a0:	11 96       	adiw	r26, 0x01	; 1
    31a2:	ed 91       	ld	r30, X+
    31a4:	fc 91       	ld	r31, X
    31a6:	12 97       	sbiw	r26, 0x02	; 2
    31a8:	04 80       	ldd	r0, Z+4	; 0x04
    31aa:	f5 81       	ldd	r31, Z+5	; 0x05
    31ac:	e0 2d       	mov	r30, r0
    31ae:	11 96       	adiw	r26, 0x01	; 1
    31b0:	ed 93       	st	X+, r30
    31b2:	fc 93       	st	X, r31
    31b4:	12 97       	sbiw	r26, 0x02	; 2
    31b6:	87 5e       	subi	r24, 0xE7	; 231
    31b8:	9c 4c       	sbci	r25, 0xCC	; 204
    31ba:	e8 17       	cp	r30, r24
    31bc:	f9 07       	cpc	r31, r25
    31be:	61 f4       	brne	.+24     	; 0x31d8 <vTaskSwitchContext+0x96>
    31c0:	84 81       	ldd	r24, Z+4	; 0x04
    31c2:	95 81       	ldd	r25, Z+5	; 0x05
    31c4:	4b e0       	ldi	r20, 0x0B	; 11
    31c6:	42 9f       	mul	r20, r18
    31c8:	f0 01       	movw	r30, r0
    31ca:	43 9f       	mul	r20, r19
    31cc:	f0 0d       	add	r31, r0
    31ce:	11 24       	eor	r1, r1
    31d0:	ea 5e       	subi	r30, 0xEA	; 234
    31d2:	fc 4c       	sbci	r31, 0xCC	; 204
    31d4:	81 83       	std	Z+1, r24	; 0x01
    31d6:	92 83       	std	Z+2, r25	; 0x02
    31d8:	8b e0       	ldi	r24, 0x0B	; 11
    31da:	82 9f       	mul	r24, r18
    31dc:	f0 01       	movw	r30, r0
    31de:	83 9f       	mul	r24, r19
    31e0:	f0 0d       	add	r31, r0
    31e2:	11 24       	eor	r1, r1
    31e4:	ea 5e       	subi	r30, 0xEA	; 234
    31e6:	fc 4c       	sbci	r31, 0xCC	; 204
    31e8:	01 80       	ldd	r0, Z+1	; 0x01
    31ea:	f2 81       	ldd	r31, Z+2	; 0x02
    31ec:	e0 2d       	mov	r30, r0
    31ee:	80 85       	ldd	r24, Z+8	; 0x08
    31f0:	91 85       	ldd	r25, Z+9	; 0x09
    31f2:	80 93 42 33 	sts	0x3342, r24	; 0x803342 <pxCurrentTCB>
    31f6:	90 93 43 33 	sts	0x3343, r25	; 0x803343 <pxCurrentTCB+0x1>
    31fa:	08 95       	ret

000031fc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    31fc:	cf 92       	push	r12
    31fe:	df 92       	push	r13
    3200:	ef 92       	push	r14
    3202:	ff 92       	push	r15
    3204:	6a 01       	movw	r12, r20
    3206:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3208:	60 91 42 33 	lds	r22, 0x3342	; 0x803342 <pxCurrentTCB>
    320c:	70 91 43 33 	lds	r23, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    3210:	62 5f       	subi	r22, 0xF2	; 242
    3212:	7f 4f       	sbci	r23, 0xFF	; 255
    3214:	0e 94 6d 10 	call	0x20da	; 0x20da <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3218:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    321c:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    3220:	02 96       	adiw	r24, 0x02	; 2
    3222:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3226:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    322a:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    322e:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    3232:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3236:	bc 01       	movw	r22, r24
    3238:	cd 01       	movw	r24, r26
    323a:	6c 0d       	add	r22, r12
    323c:	7d 1d       	adc	r23, r13
    323e:	8e 1d       	adc	r24, r14
    3240:	9f 1d       	adc	r25, r15
    3242:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3246:	ff 90       	pop	r15
    3248:	ef 90       	pop	r14
    324a:	df 90       	pop	r13
    324c:	cf 90       	pop	r12
    324e:	08 95       	ret

00003250 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3250:	0f 93       	push	r16
    3252:	1f 93       	push	r17
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3258:	dc 01       	movw	r26, r24
    325a:	17 96       	adiw	r26, 0x07	; 7
    325c:	ed 91       	ld	r30, X+
    325e:	fc 91       	ld	r31, X
    3260:	18 97       	sbiw	r26, 0x08	; 8
    3262:	c0 85       	ldd	r28, Z+8	; 0x08
    3264:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3266:	8e 01       	movw	r16, r28
    3268:	02 5f       	subi	r16, 0xF2	; 242
    326a:	1f 4f       	sbci	r17, 0xFF	; 255
    326c:	c8 01       	movw	r24, r16
    326e:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3272:	80 91 e6 32 	lds	r24, 0x32E6	; 0x8032e6 <uxSchedulerSuspended>
    3276:	81 11       	cpse	r24, r1
    3278:	16 c0       	rjmp	.+44     	; 0x32a6 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    327a:	0c 50       	subi	r16, 0x0C	; 12
    327c:	11 09       	sbc	r17, r1
    327e:	c8 01       	movw	r24, r16
    3280:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3284:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3286:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    328a:	98 17       	cp	r25, r24
    328c:	10 f4       	brcc	.+4      	; 0x3292 <xTaskRemoveFromEventList+0x42>
    328e:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    3292:	bb e0       	ldi	r27, 0x0B	; 11
    3294:	8b 9f       	mul	r24, r27
    3296:	c0 01       	movw	r24, r0
    3298:	11 24       	eor	r1, r1
    329a:	b8 01       	movw	r22, r16
    329c:	8a 5e       	subi	r24, 0xEA	; 234
    329e:	9c 4c       	sbci	r25, 0xCC	; 204
    32a0:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
    32a4:	05 c0       	rjmp	.+10     	; 0x32b0 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    32a6:	b8 01       	movw	r22, r16
    32a8:	81 ef       	ldi	r24, 0xF1	; 241
    32aa:	92 e3       	ldi	r25, 0x32	; 50
    32ac:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    32b0:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    32b4:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    32b8:	81 e0       	ldi	r24, 0x01	; 1
    32ba:	2a 8d       	ldd	r18, Y+26	; 0x1a
    32bc:	92 8d       	ldd	r25, Z+26	; 0x1a
    32be:	29 17       	cp	r18, r25
    32c0:	08 f4       	brcc	.+2      	; 0x32c4 <xTaskRemoveFromEventList+0x74>
    32c2:	80 e0       	ldi	r24, 0x00	; 0
}
    32c4:	df 91       	pop	r29
    32c6:	cf 91       	pop	r28
    32c8:	1f 91       	pop	r17
    32ca:	0f 91       	pop	r16
    32cc:	08 95       	ret

000032ce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    32ce:	20 91 e3 32 	lds	r18, 0x32E3	; 0x8032e3 <xNumOfOverflows>
    32d2:	fc 01       	movw	r30, r24
    32d4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    32d6:	40 91 ea 32 	lds	r20, 0x32EA	; 0x8032ea <xTickCount>
    32da:	50 91 eb 32 	lds	r21, 0x32EB	; 0x8032eb <xTickCount+0x1>
    32de:	60 91 ec 32 	lds	r22, 0x32EC	; 0x8032ec <xTickCount+0x2>
    32e2:	70 91 ed 32 	lds	r23, 0x32ED	; 0x8032ed <xTickCount+0x3>
    32e6:	41 83       	std	Z+1, r20	; 0x01
    32e8:	52 83       	std	Z+2, r21	; 0x02
    32ea:	63 83       	std	Z+3, r22	; 0x03
    32ec:	74 83       	std	Z+4, r23	; 0x04
    32ee:	08 95       	ret

000032f0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    32f0:	8f 92       	push	r8
    32f2:	9f 92       	push	r9
    32f4:	af 92       	push	r10
    32f6:	bf 92       	push	r11
    32f8:	cf 92       	push	r12
    32fa:	df 92       	push	r13
    32fc:	ef 92       	push	r14
    32fe:	ff 92       	push	r15
    3300:	0f 93       	push	r16
    3302:	1f 93       	push	r17
    3304:	cf 93       	push	r28
    3306:	df 93       	push	r29
    3308:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    330a:	0f b6       	in	r0, 0x3f	; 63
    330c:	f8 94       	cli
    330e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3310:	80 91 e3 32 	lds	r24, 0x32E3	; 0x8032e3 <xNumOfOverflows>
    3314:	90 81       	ld	r25, Z
    3316:	98 17       	cp	r25, r24
    3318:	89 f0       	breq	.+34     	; 0x333c <xTaskCheckForTimeOut+0x4c>
    331a:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    331e:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    3322:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    3326:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    332a:	01 81       	ldd	r16, Z+1	; 0x01
    332c:	12 81       	ldd	r17, Z+2	; 0x02
    332e:	23 81       	ldd	r18, Z+3	; 0x03
    3330:	34 81       	ldd	r19, Z+4	; 0x04
    3332:	80 17       	cp	r24, r16
    3334:	91 07       	cpc	r25, r17
    3336:	a2 07       	cpc	r26, r18
    3338:	b3 07       	cpc	r27, r19
    333a:	a8 f5       	brcc	.+106    	; 0x33a6 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    333c:	80 91 ea 32 	lds	r24, 0x32EA	; 0x8032ea <xTickCount>
    3340:	90 91 eb 32 	lds	r25, 0x32EB	; 0x8032eb <xTickCount+0x1>
    3344:	a0 91 ec 32 	lds	r26, 0x32EC	; 0x8032ec <xTickCount+0x2>
    3348:	b0 91 ed 32 	lds	r27, 0x32ED	; 0x8032ed <xTickCount+0x3>
    334c:	c1 80       	ldd	r12, Z+1	; 0x01
    334e:	d2 80       	ldd	r13, Z+2	; 0x02
    3350:	e3 80       	ldd	r14, Z+3	; 0x03
    3352:	f4 80       	ldd	r15, Z+4	; 0x04
    3354:	eb 01       	movw	r28, r22
    3356:	08 81       	ld	r16, Y
    3358:	19 81       	ldd	r17, Y+1	; 0x01
    335a:	2a 81       	ldd	r18, Y+2	; 0x02
    335c:	3b 81       	ldd	r19, Y+3	; 0x03
    335e:	8c 19       	sub	r24, r12
    3360:	9d 09       	sbc	r25, r13
    3362:	ae 09       	sbc	r26, r14
    3364:	bf 09       	sbc	r27, r15
    3366:	80 17       	cp	r24, r16
    3368:	91 07       	cpc	r25, r17
    336a:	a2 07       	cpc	r26, r18
    336c:	b3 07       	cpc	r27, r19
    336e:	e8 f4       	brcc	.+58     	; 0x33aa <xTaskCheckForTimeOut+0xba>
    3370:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3372:	80 90 ea 32 	lds	r8, 0x32EA	; 0x8032ea <xTickCount>
    3376:	90 90 eb 32 	lds	r9, 0x32EB	; 0x8032eb <xTickCount+0x1>
    337a:	a0 90 ec 32 	lds	r10, 0x32EC	; 0x8032ec <xTickCount+0x2>
    337e:	b0 90 ed 32 	lds	r11, 0x32ED	; 0x8032ed <xTickCount+0x3>
    3382:	b5 01       	movw	r22, r10
    3384:	a4 01       	movw	r20, r8
    3386:	4c 19       	sub	r20, r12
    3388:	5d 09       	sbc	r21, r13
    338a:	6e 09       	sbc	r22, r14
    338c:	7f 09       	sbc	r23, r15
    338e:	04 1b       	sub	r16, r20
    3390:	15 0b       	sbc	r17, r21
    3392:	26 0b       	sbc	r18, r22
    3394:	37 0b       	sbc	r19, r23
    3396:	08 83       	st	Y, r16
    3398:	19 83       	std	Y+1, r17	; 0x01
    339a:	2a 83       	std	Y+2, r18	; 0x02
    339c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    339e:	0e 94 67 19 	call	0x32ce	; 0x32ce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    33a2:	80 e0       	ldi	r24, 0x00	; 0
    33a4:	03 c0       	rjmp	.+6      	; 0x33ac <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    33a6:	81 e0       	ldi	r24, 0x01	; 1
    33a8:	01 c0       	rjmp	.+2      	; 0x33ac <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    33aa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    33ac:	0f 90       	pop	r0
    33ae:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    33b0:	df 91       	pop	r29
    33b2:	cf 91       	pop	r28
    33b4:	1f 91       	pop	r17
    33b6:	0f 91       	pop	r16
    33b8:	ff 90       	pop	r15
    33ba:	ef 90       	pop	r14
    33bc:	df 90       	pop	r13
    33be:	cf 90       	pop	r12
    33c0:	bf 90       	pop	r11
    33c2:	af 90       	pop	r10
    33c4:	9f 90       	pop	r9
    33c6:	8f 90       	pop	r8
    33c8:	08 95       	ret

000033ca <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    33ca:	81 e0       	ldi	r24, 0x01	; 1
    33cc:	80 93 e4 32 	sts	0x32E4, r24	; 0x8032e4 <xMissedYield>
    33d0:	08 95       	ret

000033d2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    33d2:	00 97       	sbiw	r24, 0x00	; 0
    33d4:	21 f4       	brne	.+8      	; 0x33de <uxTaskGetStackHighWaterMark+0xc>
    33d6:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    33da:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    33de:	dc 01       	movw	r26, r24
    33e0:	5b 96       	adiw	r26, 0x1b	; 27
    33e2:	ed 91       	ld	r30, X+
    33e4:	fc 91       	ld	r31, X
    33e6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    33e8:	80 81       	ld	r24, Z
    33ea:	81 31       	cpi	r24, 0x11	; 17
    33ec:	41 f4       	brne	.+16     	; 0x33fe <uxTaskGetStackHighWaterMark+0x2c>
    33ee:	31 96       	adiw	r30, 0x01	; 1
    33f0:	80 e0       	ldi	r24, 0x00	; 0
    33f2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    33f4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    33f6:	21 91       	ld	r18, Z+
    33f8:	21 31       	cpi	r18, 0x11	; 17
    33fa:	e1 f3       	breq	.-8      	; 0x33f4 <uxTaskGetStackHighWaterMark+0x22>
    33fc:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    33fe:	80 e0       	ldi	r24, 0x00	; 0
    3400:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3402:	08 95       	ret

00003404 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3404:	80 91 42 33 	lds	r24, 0x3342	; 0x803342 <pxCurrentTCB>
    3408:	90 91 43 33 	lds	r25, 0x3343	; 0x803343 <pxCurrentTCB+0x1>

		return xReturn;
	}
    340c:	08 95       	ret

0000340e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    340e:	0f 93       	push	r16
    3410:	1f 93       	push	r17
    3412:	cf 93       	push	r28
    3414:	df 93       	push	r29
    3416:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    3418:	22 8d       	ldd	r18, Z+26	; 0x1a
    341a:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    341e:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    3422:	5a 96       	adiw	r26, 0x1a	; 26
    3424:	8c 91       	ld	r24, X
    3426:	28 17       	cp	r18, r24
    3428:	08 f0       	brcs	.+2      	; 0x342c <vTaskPriorityInherit+0x1e>
    342a:	41 c0       	rjmp	.+130    	; 0x34ae <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    342c:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    3430:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    3434:	5a 96       	adiw	r26, 0x1a	; 26
    3436:	3c 91       	ld	r19, X
    3438:	84 e0       	ldi	r24, 0x04	; 4
    343a:	90 e0       	ldi	r25, 0x00	; 0
    343c:	a0 e0       	ldi	r26, 0x00	; 0
    343e:	b0 e0       	ldi	r27, 0x00	; 0
    3440:	83 1b       	sub	r24, r19
    3442:	91 09       	sbc	r25, r1
    3444:	a1 09       	sbc	r26, r1
    3446:	b1 09       	sbc	r27, r1
    3448:	86 87       	std	Z+14, r24	; 0x0e
    344a:	97 87       	std	Z+15, r25	; 0x0f
    344c:	a0 8b       	std	Z+16, r26	; 0x10
    344e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3450:	8b e0       	ldi	r24, 0x0B	; 11
    3452:	28 9f       	mul	r18, r24
    3454:	90 01       	movw	r18, r0
    3456:	11 24       	eor	r1, r1
    3458:	2a 5e       	subi	r18, 0xEA	; 234
    345a:	3c 4c       	sbci	r19, 0xCC	; 204
    345c:	84 85       	ldd	r24, Z+12	; 0x0c
    345e:	95 85       	ldd	r25, Z+13	; 0x0d
    3460:	82 17       	cp	r24, r18
    3462:	93 07       	cpc	r25, r19
    3464:	e9 f4       	brne	.+58     	; 0x34a0 <vTaskPriorityInherit+0x92>
    3466:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    3468:	ef 01       	movw	r28, r30
    346a:	22 96       	adiw	r28, 0x02	; 2
    346c:	ce 01       	movw	r24, r28
    346e:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3472:	e0 91 42 33 	lds	r30, 0x3342	; 0x803342 <pxCurrentTCB>
    3476:	f0 91 43 33 	lds	r31, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    347a:	82 8d       	ldd	r24, Z+26	; 0x1a
    347c:	f8 01       	movw	r30, r16
    347e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    3480:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    3484:	98 17       	cp	r25, r24
    3486:	10 f4       	brcc	.+4      	; 0x348c <vTaskPriorityInherit+0x7e>
    3488:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    348c:	fb e0       	ldi	r31, 0x0B	; 11
    348e:	8f 9f       	mul	r24, r31
    3490:	c0 01       	movw	r24, r0
    3492:	11 24       	eor	r1, r1
    3494:	be 01       	movw	r22, r28
    3496:	8a 5e       	subi	r24, 0xEA	; 234
    3498:	9c 4c       	sbci	r25, 0xCC	; 204
    349a:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
    349e:	07 c0       	rjmp	.+14     	; 0x34ae <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    34a0:	a0 91 42 33 	lds	r26, 0x3342	; 0x803342 <pxCurrentTCB>
    34a4:	b0 91 43 33 	lds	r27, 0x3343	; 0x803343 <pxCurrentTCB+0x1>
    34a8:	5a 96       	adiw	r26, 0x1a	; 26
    34aa:	8c 91       	ld	r24, X
    34ac:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    34ae:	df 91       	pop	r29
    34b0:	cf 91       	pop	r28
    34b2:	1f 91       	pop	r17
    34b4:	0f 91       	pop	r16
    34b6:	08 95       	ret

000034b8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    34b8:	0f 93       	push	r16
    34ba:	1f 93       	push	r17
    34bc:	cf 93       	push	r28
    34be:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    34c0:	00 97       	sbiw	r24, 0x00	; 0
    34c2:	49 f1       	breq	.+82     	; 0x3516 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    34c4:	fc 01       	movw	r30, r24
    34c6:	32 8d       	ldd	r19, Z+26	; 0x1a
    34c8:	27 a1       	ldd	r18, Z+39	; 0x27
    34ca:	32 17       	cp	r19, r18
    34cc:	21 f1       	breq	.+72     	; 0x3516 <vTaskPriorityDisinherit+0x5e>
    34ce:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    34d0:	8c 01       	movw	r16, r24
    34d2:	0e 5f       	subi	r16, 0xFE	; 254
    34d4:	1f 4f       	sbci	r17, 0xFF	; 255
    34d6:	c8 01       	movw	r24, r16
    34d8:	0e 94 b8 10 	call	0x2170	; 0x2170 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    34dc:	8f a1       	ldd	r24, Y+39	; 0x27
    34de:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    34e0:	44 e0       	ldi	r20, 0x04	; 4
    34e2:	50 e0       	ldi	r21, 0x00	; 0
    34e4:	60 e0       	ldi	r22, 0x00	; 0
    34e6:	70 e0       	ldi	r23, 0x00	; 0
    34e8:	48 1b       	sub	r20, r24
    34ea:	51 09       	sbc	r21, r1
    34ec:	61 09       	sbc	r22, r1
    34ee:	71 09       	sbc	r23, r1
    34f0:	4e 87       	std	Y+14, r20	; 0x0e
    34f2:	5f 87       	std	Y+15, r21	; 0x0f
    34f4:	68 8b       	std	Y+16, r22	; 0x10
    34f6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    34f8:	90 91 e8 32 	lds	r25, 0x32E8	; 0x8032e8 <uxTopReadyPriority>
    34fc:	98 17       	cp	r25, r24
    34fe:	10 f4       	brcc	.+4      	; 0x3504 <vTaskPriorityDisinherit+0x4c>
    3500:	80 93 e8 32 	sts	0x32E8, r24	; 0x8032e8 <uxTopReadyPriority>
    3504:	fb e0       	ldi	r31, 0x0B	; 11
    3506:	8f 9f       	mul	r24, r31
    3508:	c0 01       	movw	r24, r0
    350a:	11 24       	eor	r1, r1
    350c:	b8 01       	movw	r22, r16
    350e:	8a 5e       	subi	r24, 0xEA	; 234
    3510:	9c 4c       	sbci	r25, 0xCC	; 204
    3512:	0e 94 46 10 	call	0x208c	; 0x208c <vListInsertEnd>
			}
		}
	}
    3516:	df 91       	pop	r29
    3518:	cf 91       	pop	r28
    351a:	1f 91       	pop	r17
    351c:	0f 91       	pop	r16
    351e:	08 95       	ret

00003520 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    3520:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    3522:	e8 81       	ld	r30, Y
    3524:	f9 81       	ldd	r31, Y+1	; 0x01
    3526:	01 90       	ld	r0, Z+
    3528:	f0 81       	ld	r31, Z
    352a:	e0 2d       	mov	r30, r0
    352c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    352e:	1a 82       	std	Y+2, r1	; 0x02
    3530:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    3532:	6f ef       	ldi	r22, 0xFF	; 255
    3534:	7f ef       	ldi	r23, 0xFF	; 255
    3536:	cb 01       	movw	r24, r22
    3538:	0e 94 73 18 	call	0x30e6	; 0x30e6 <vTaskDelay>
    353c:	fa cf       	rjmp	.-12     	; 0x3532 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000353e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    353e:	fc 01       	movw	r30, r24
    3540:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3542:	65 87       	std	Z+13, r22	; 0x0d
    3544:	08 95       	ret

00003546 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    3546:	4f 92       	push	r4
    3548:	5f 92       	push	r5
    354a:	6f 92       	push	r6
    354c:	7f 92       	push	r7
    354e:	8f 92       	push	r8
    3550:	9f 92       	push	r9
    3552:	af 92       	push	r10
    3554:	bf 92       	push	r11
    3556:	cf 92       	push	r12
    3558:	df 92       	push	r13
    355a:	ef 92       	push	r14
    355c:	ff 92       	push	r15
    355e:	0f 93       	push	r16
    3560:	1f 93       	push	r17
    3562:	cf 93       	push	r28
    3564:	df 93       	push	r29
    3566:	cd b7       	in	r28, 0x3d	; 61
    3568:	de b7       	in	r29, 0x3e	; 62
    356a:	2a 97       	sbiw	r28, 0x0a	; 10
    356c:	cd bf       	out	0x3d, r28	; 61
    356e:	de bf       	out	0x3e, r29	; 62
    3570:	4c 01       	movw	r8, r24
    3572:	29 01       	movw	r4, r18
    3574:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    3576:	80 e3       	ldi	r24, 0x30	; 48
    3578:	92 e2       	ldi	r25, 0x22	; 34
    357a:	f4 01       	movw	r30, r8
    357c:	80 83       	st	Z, r24
    357e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3580:	fb 01       	movw	r30, r22
    3582:	80 81       	ld	r24, Z
    3584:	88 23       	and	r24, r24
    3586:	69 f0       	breq	.+26     	; 0x35a2 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    3588:	de 01       	movw	r26, r28
    358a:	11 96       	adiw	r26, 0x01	; 1
    358c:	31 96       	adiw	r30, 0x01	; 1
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	02 c0       	rjmp	.+4      	; 0x3596 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3592:	99 30       	cpi	r25, 0x09	; 9
    3594:	39 f0       	breq	.+14     	; 0x35a4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    3596:	9f 5f       	subi	r25, 0xFF	; 255
    3598:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    359a:	81 91       	ld	r24, Z+
    359c:	81 11       	cpse	r24, r1
    359e:	f9 cf       	rjmp	.-14     	; 0x3592 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    35a0:	01 c0       	rjmp	.+2      	; 0x35a4 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    35a2:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    35a4:	e1 e0       	ldi	r30, 0x01	; 1
    35a6:	f0 e0       	ldi	r31, 0x00	; 0
    35a8:	ec 0f       	add	r30, r28
    35aa:	fd 1f       	adc	r31, r29
    35ac:	e9 0f       	add	r30, r25
    35ae:	f1 1d       	adc	r31, r1
    35b0:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    35b2:	74 01       	movw	r14, r8
    35b4:	f2 e0       	ldi	r31, 0x02	; 2
    35b6:	ef 0e       	add	r14, r31
    35b8:	f1 1c       	adc	r15, r1
    35ba:	a1 2c       	mov	r10, r1
    35bc:	b1 2c       	mov	r11, r1
    35be:	c1 2c       	mov	r12, r1
    35c0:	d1 2c       	mov	r13, r1
    35c2:	04 2f       	mov	r16, r20
    35c4:	94 01       	movw	r18, r8
    35c6:	a2 01       	movw	r20, r4
    35c8:	be 01       	movw	r22, r28
    35ca:	6f 5f       	subi	r22, 0xFF	; 255
    35cc:	7f 4f       	sbci	r23, 0xFF	; 255
    35ce:	88 e3       	ldi	r24, 0x38	; 56
    35d0:	93 e0       	ldi	r25, 0x03	; 3
    35d2:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    35d6:	f4 01       	movw	r30, r8
    35d8:	66 82       	std	Z+6, r6	; 0x06
    35da:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    35dc:	40 86       	std	Z+8, r4	; 0x08
    35de:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    35e0:	20 91 44 33 	lds	r18, 0x3344	; 0x803344 <last_created_task_pointer>
    35e4:	30 91 45 33 	lds	r19, 0x3345	; 0x803345 <last_created_task_pointer+0x1>
    35e8:	24 83       	std	Z+4, r18	; 0x04
    35ea:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    35ec:	80 92 44 33 	sts	0x3344, r8	; 0x803344 <last_created_task_pointer>
    35f0:	90 92 45 33 	sts	0x3345, r9	; 0x803345 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    35f4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    35f6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    35f8:	40 90 a6 33 	lds	r4, 0x33A6	; 0x8033a6 <portStackTopForTask>
    35fc:	50 90 a7 33 	lds	r5, 0x33A7	; 0x8033a7 <portStackTopForTask+0x1>
    3600:	ff ef       	ldi	r31, 0xFF	; 255
    3602:	4f 1a       	sub	r4, r31
    3604:	5f 0a       	sbc	r5, r31
    3606:	40 92 a6 33 	sts	0x33A6, r4	; 0x8033a6 <portStackTopForTask>
    360a:	50 92 a7 33 	sts	0x33A7, r5	; 0x8033a7 <portStackTopForTask+0x1>
    360e:	f4 01       	movw	r30, r8
    3610:	42 86       	std	Z+10, r4	; 0x0a
    3612:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3614:	16 86       	std	Z+14, r1	; 0x0e
    3616:	17 86       	std	Z+15, r1	; 0x0f
    3618:	10 8a       	std	Z+16, r1	; 0x10
    361a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    361c:	61 14       	cp	r6, r1
    361e:	71 04       	cpc	r7, r1
    3620:	09 f4       	brne	.+2      	; 0x3624 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3622:	44 c0       	rjmp	.+136    	; 0x36ac <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3624:	81 30       	cpi	r24, 0x01	; 1
    3626:	79 f5       	brne	.+94     	; 0x3686 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    3628:	6a e0       	ldi	r22, 0x0A	; 10
    362a:	c3 01       	movw	r24, r6
    362c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3630:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3632:	6d eb       	ldi	r22, 0xBD	; 189
    3634:	75 e0       	ldi	r23, 0x05	; 5
    3636:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    363a:	be 01       	movw	r22, r28
    363c:	6f 5f       	subi	r22, 0xFF	; 255
    363e:	7f 4f       	sbci	r23, 0xFF	; 255
    3640:	c7 01       	movw	r24, r14
    3642:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3646:	6a e0       	ldi	r22, 0x0A	; 10
    3648:	c7 01       	movw	r24, r14
    364a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    364e:	7c 01       	movw	r14, r24
    3650:	64 eb       	ldi	r22, 0xB4	; 180
    3652:	75 e0       	ldi	r23, 0x05	; 5
    3654:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3658:	6a e0       	ldi	r22, 0x0A	; 10
    365a:	c7 01       	movw	r24, r14
    365c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3660:	7c 01       	movw	r14, r24
    3662:	66 ea       	ldi	r22, 0xA6	; 166
    3664:	75 e0       	ldi	r23, 0x05	; 5
    3666:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    366a:	63 e0       	ldi	r22, 0x03	; 3
    366c:	c7 01       	movw	r24, r14
    366e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3672:	b2 01       	movw	r22, r4
    3674:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    3678:	62 e0       	ldi	r22, 0x02	; 2
    367a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    367e:	66 e0       	ldi	r22, 0x06	; 6
    3680:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3684:	13 c0       	rjmp	.+38     	; 0x36ac <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    3686:	6a e0       	ldi	r22, 0x0A	; 10
    3688:	c3 01       	movw	r24, r6
    368a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    368e:	4c 01       	movw	r8, r24
    3690:	61 e9       	ldi	r22, 0x91	; 145
    3692:	75 e0       	ldi	r23, 0x05	; 5
    3694:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3698:	be 01       	movw	r22, r28
    369a:	6f 5f       	subi	r22, 0xFF	; 255
    369c:	7f 4f       	sbci	r23, 0xFF	; 255
    369e:	c4 01       	movw	r24, r8
    36a0:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    36a4:	66 e0       	ldi	r22, 0x06	; 6
    36a6:	c4 01       	movw	r24, r8
    36a8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    36ac:	2a 96       	adiw	r28, 0x0a	; 10
    36ae:	cd bf       	out	0x3d, r28	; 61
    36b0:	de bf       	out	0x3e, r29	; 62
    36b2:	df 91       	pop	r29
    36b4:	cf 91       	pop	r28
    36b6:	1f 91       	pop	r17
    36b8:	0f 91       	pop	r16
    36ba:	ff 90       	pop	r15
    36bc:	ef 90       	pop	r14
    36be:	df 90       	pop	r13
    36c0:	cf 90       	pop	r12
    36c2:	bf 90       	pop	r11
    36c4:	af 90       	pop	r10
    36c6:	9f 90       	pop	r9
    36c8:	8f 90       	pop	r8
    36ca:	7f 90       	pop	r7
    36cc:	6f 90       	pop	r6
    36ce:	5f 90       	pop	r5
    36d0:	4f 90       	pop	r4
    36d2:	08 95       	ret

000036d4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    36d4:	cf 92       	push	r12
    36d6:	df 92       	push	r13
    36d8:	ef 92       	push	r14
    36da:	ff 92       	push	r15
    36dc:	0f 93       	push	r16
    36de:	1f 93       	push	r17
    36e0:	cf 93       	push	r28
    36e2:	df 93       	push	r29
    36e4:	ec 01       	movw	r28, r24
    36e6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    36e8:	8a 81       	ldd	r24, Y+2	; 0x02
    36ea:	9b 81       	ldd	r25, Y+3	; 0x03
    36ec:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <pcTaskGetTaskName>
    36f0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    36f2:	6a e0       	ldi	r22, 0x0A	; 10
    36f4:	c7 01       	movw	r24, r14
    36f6:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    36fa:	8c 01       	movw	r16, r24
    36fc:	60 ed       	ldi	r22, 0xD0	; 208
    36fe:	75 e0       	ldi	r23, 0x05	; 5
    3700:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3704:	6a e0       	ldi	r22, 0x0A	; 10
    3706:	c8 01       	movw	r24, r16
    3708:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    370c:	8c 01       	movw	r16, r24
    370e:	69 ec       	ldi	r22, 0xC9	; 201
    3710:	75 e0       	ldi	r23, 0x05	; 5
    3712:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3716:	b6 01       	movw	r22, r12
    3718:	c8 01       	movw	r24, r16
    371a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    371e:	6a e0       	ldi	r22, 0x0A	; 10
    3720:	c8 01       	movw	r24, r16
    3722:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3726:	8c 01       	movw	r16, r24
    3728:	63 ec       	ldi	r22, 0xC3	; 195
    372a:	75 e0       	ldi	r23, 0x05	; 5
    372c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3730:	66 e0       	ldi	r22, 0x06	; 6
    3732:	c8 01       	movw	r24, r16
    3734:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    3738:	8a 85       	ldd	r24, Y+10	; 0x0a
    373a:	9b 85       	ldd	r25, Y+11	; 0x0b
    373c:	e8 85       	ldd	r30, Y+8	; 0x08
    373e:	f9 85       	ldd	r31, Y+9	; 0x09
    3740:	01 e1       	ldi	r16, 0x11	; 17
    3742:	21 e0       	ldi	r18, 0x01	; 1
    3744:	a7 01       	movw	r20, r14
    3746:	bc 01       	movw	r22, r24
    3748:	8e 1b       	sub	r24, r30
    374a:	9f 0b       	sbc	r25, r31
    374c:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3750:	8c 81       	ldd	r24, Y+4	; 0x04
    3752:	9d 81       	ldd	r25, Y+5	; 0x05
    3754:	00 97       	sbiw	r24, 0x00	; 0
    3756:	19 f0       	breq	.+6      	; 0x375e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3758:	b7 01       	movw	r22, r14
    375a:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    375e:	df 91       	pop	r29
    3760:	cf 91       	pop	r28
    3762:	1f 91       	pop	r17
    3764:	0f 91       	pop	r16
    3766:	ff 90       	pop	r15
    3768:	ef 90       	pop	r14
    376a:	df 90       	pop	r13
    376c:	cf 90       	pop	r12
    376e:	08 95       	ret

00003770 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3770:	0f 93       	push	r16
    3772:	1f 93       	push	r17
    3774:	cf 93       	push	r28
    3776:	df 93       	push	r29
    3778:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    377a:	80 91 44 33 	lds	r24, 0x3344	; 0x803344 <last_created_task_pointer>
    377e:	90 91 45 33 	lds	r25, 0x3345	; 0x803345 <last_created_task_pointer+0x1>
    3782:	00 97       	sbiw	r24, 0x00	; 0
    3784:	19 f0       	breq	.+6      	; 0x378c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3786:	be 01       	movw	r22, r28
    3788:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    378c:	6a e0       	ldi	r22, 0x0A	; 10
    378e:	ce 01       	movw	r24, r28
    3790:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3794:	8c 01       	movw	r16, r24
    3796:	66 ee       	ldi	r22, 0xE6	; 230
    3798:	75 e0       	ldi	r23, 0x05	; 5
    379a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    379e:	6a e0       	ldi	r22, 0x0A	; 10
    37a0:	c8 01       	movw	r24, r16
    37a2:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    37a6:	8c 01       	movw	r16, r24
    37a8:	6b ed       	ldi	r22, 0xDB	; 219
    37aa:	75 e0       	ldi	r23, 0x05	; 5
    37ac:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    37b0:	6a e0       	ldi	r22, 0x0A	; 10
    37b2:	c8 01       	movw	r24, r16
    37b4:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    37b8:	8c 01       	movw	r16, r24
    37ba:	65 ed       	ldi	r22, 0xD5	; 213
    37bc:	75 e0       	ldi	r23, 0x05	; 5
    37be:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    37c2:	66 e0       	ldi	r22, 0x06	; 6
    37c4:	c8 01       	movw	r24, r16
    37c6:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    37ca:	80 91 a6 33 	lds	r24, 0x33A6	; 0x8033a6 <portStackTopForTask>
    37ce:	90 91 a7 33 	lds	r25, 0x33A7	; 0x8033a7 <portStackTopForTask+0x1>
    37d2:	bc 01       	movw	r22, r24
    37d4:	6f 5f       	subi	r22, 0xFF	; 255
    37d6:	7f 4f       	sbci	r23, 0xFF	; 255
    37d8:	01 e1       	ldi	r16, 0x11	; 17
    37da:	21 e0       	ldi	r18, 0x01	; 1
    37dc:	ae 01       	movw	r20, r28
    37de:	83 56       	subi	r24, 0x63	; 99
    37e0:	91 09       	sbc	r25, r1
    37e2:	0e 94 6c 1e 	call	0x3cd8	; 0x3cd8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    37e6:	df 91       	pop	r29
    37e8:	cf 91       	pop	r28
    37ea:	1f 91       	pop	r17
    37ec:	0f 91       	pop	r16
    37ee:	08 95       	ret

000037f0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    37f0:	8f 92       	push	r8
    37f2:	9f 92       	push	r9
    37f4:	af 92       	push	r10
    37f6:	bf 92       	push	r11
    37f8:	cf 92       	push	r12
    37fa:	df 92       	push	r13
    37fc:	ef 92       	push	r14
    37fe:	ff 92       	push	r15
    3800:	0f 93       	push	r16
    3802:	1f 93       	push	r17
    3804:	cf 93       	push	r28
    3806:	df 93       	push	r29
    3808:	ec 01       	movw	r28, r24
    380a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    380c:	8a 81       	ldd	r24, Y+2	; 0x02
    380e:	9b 81       	ldd	r25, Y+3	; 0x03
    3810:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <pcTaskGetTaskName>
    3814:	bc 01       	movw	r22, r24
    3816:	c8 01       	movw	r24, r16
    3818:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    381c:	d8 01       	movw	r26, r16
    381e:	ed 91       	ld	r30, X+
    3820:	fc 91       	ld	r31, X
    3822:	02 80       	ldd	r0, Z+2	; 0x02
    3824:	f3 81       	ldd	r31, Z+3	; 0x03
    3826:	e0 2d       	mov	r30, r0
    3828:	69 e0       	ldi	r22, 0x09	; 9
    382a:	c8 01       	movw	r24, r16
    382c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    382e:	8a 81       	ldd	r24, Y+2	; 0x02
    3830:	9b 81       	ldd	r25, Y+3	; 0x03
    3832:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <pcTaskGetTaskName>
    3836:	fc 01       	movw	r30, r24
    3838:	01 90       	ld	r0, Z+
    383a:	00 20       	and	r0, r0
    383c:	e9 f7       	brne	.-6      	; 0x3838 <_ZN8frt_task12print_statusER8emstream+0x48>
    383e:	31 97       	sbiw	r30, 0x01	; 1
    3840:	e8 1b       	sub	r30, r24
    3842:	f9 0b       	sbc	r31, r25
    3844:	38 97       	sbiw	r30, 0x08	; 8
    3846:	48 f4       	brcc	.+18     	; 0x385a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3848:	d8 01       	movw	r26, r16
    384a:	ed 91       	ld	r30, X+
    384c:	fc 91       	ld	r31, X
    384e:	02 80       	ldd	r0, Z+2	; 0x02
    3850:	f3 81       	ldd	r31, Z+3	; 0x03
    3852:	e0 2d       	mov	r30, r0
    3854:	69 e0       	ldi	r22, 0x09	; 9
    3856:	c8 01       	movw	r24, r16
    3858:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    385a:	ce 84       	ldd	r12, Y+14	; 0x0e
    385c:	df 84       	ldd	r13, Y+15	; 0x0f
    385e:	e8 88       	ldd	r14, Y+16	; 0x10
    3860:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3862:	a8 84       	ldd	r10, Y+8	; 0x08
    3864:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3866:	8a 81       	ldd	r24, Y+2	; 0x02
    3868:	9b 81       	ldd	r25, Y+3	; 0x03
    386a:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <uxTaskGetStackHighWaterMark>
    386e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3870:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3872:	8a 81       	ldd	r24, Y+2	; 0x02
    3874:	9b 81       	ldd	r25, Y+3	; 0x03
    3876:	0e 94 8e 16 	call	0x2d1c	; 0x2d1c <uxTaskPriorityGet>
    387a:	68 2f       	mov	r22, r24
    387c:	c8 01       	movw	r24, r16
    387e:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    3882:	6a e0       	ldi	r22, 0x0A	; 10
    3884:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3888:	ec 01       	movw	r28, r24
    388a:	6b e5       	ldi	r22, 0x5B	; 91
    388c:	76 e0       	ldi	r23, 0x06	; 6
    388e:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3892:	68 2d       	mov	r22, r8
    3894:	ce 01       	movw	r24, r28
    3896:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    389a:	6a e0       	ldi	r22, 0x0A	; 10
    389c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    38a0:	ec 01       	movw	r28, r24
    38a2:	69 e5       	ldi	r22, 0x59	; 89
    38a4:	76 e0       	ldi	r23, 0x06	; 6
    38a6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    38aa:	69 2d       	mov	r22, r9
    38ac:	ce 01       	movw	r24, r28
    38ae:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    38b2:	6a e0       	ldi	r22, 0x0A	; 10
    38b4:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    38b8:	ec 01       	movw	r28, r24
    38ba:	67 e5       	ldi	r22, 0x57	; 87
    38bc:	76 e0       	ldi	r23, 0x06	; 6
    38be:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    38c2:	b5 01       	movw	r22, r10
    38c4:	ce 01       	movw	r24, r28
    38c6:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    38ca:	6a e0       	ldi	r22, 0x0A	; 10
    38cc:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    38d0:	ec 01       	movw	r28, r24
    38d2:	65 e5       	ldi	r22, 0x55	; 85
    38d4:	76 e0       	ldi	r23, 0x06	; 6
    38d6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    38da:	6a e0       	ldi	r22, 0x0A	; 10
    38dc:	ce 01       	movw	r24, r28
    38de:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    38e2:	ec 01       	movw	r28, r24
    38e4:	63 e5       	ldi	r22, 0x53	; 83
    38e6:	76 e0       	ldi	r23, 0x06	; 6
    38e8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    38ec:	b7 01       	movw	r22, r14
    38ee:	a6 01       	movw	r20, r12
    38f0:	ce 01       	movw	r24, r28
    38f2:	0e 94 c0 20 	call	0x4180	; 0x4180 <_ZN8emstreamlsEm>
}
    38f6:	df 91       	pop	r29
    38f8:	cf 91       	pop	r28
    38fa:	1f 91       	pop	r17
    38fc:	0f 91       	pop	r16
    38fe:	ff 90       	pop	r15
    3900:	ef 90       	pop	r14
    3902:	df 90       	pop	r13
    3904:	cf 90       	pop	r12
    3906:	bf 90       	pop	r11
    3908:	af 90       	pop	r10
    390a:	9f 90       	pop	r9
    390c:	8f 90       	pop	r8
    390e:	08 95       	ret

00003910 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3910:	cf 93       	push	r28
    3912:	df 93       	push	r29
    3914:	ec 01       	movw	r28, r24
    3916:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    3918:	db 01       	movw	r26, r22
    391a:	ed 91       	ld	r30, X+
    391c:	fc 91       	ld	r31, X
    391e:	02 80       	ldd	r0, Z+2	; 0x02
    3920:	f3 81       	ldd	r31, Z+3	; 0x03
    3922:	e0 2d       	mov	r30, r0
    3924:	be 01       	movw	r22, r28
    3926:	19 95       	eicall
	return (ser_dev);
}
    3928:	ce 01       	movw	r24, r28
    392a:	df 91       	pop	r29
    392c:	cf 91       	pop	r28
    392e:	08 95       	ret

00003930 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3930:	0f 93       	push	r16
    3932:	1f 93       	push	r17
    3934:	cf 93       	push	r28
    3936:	df 93       	push	r29
    3938:	ec 01       	movw	r28, r24
    393a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    393c:	bc 01       	movw	r22, r24
    393e:	c8 01       	movw	r24, r16
    3940:	0e 94 88 1c 	call	0x3910	; 0x3910 <_ZlsR8emstreamR8frt_task>
    3944:	66 e0       	ldi	r22, 0x06	; 6
    3946:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    394a:	8c 81       	ldd	r24, Y+4	; 0x04
    394c:	9d 81       	ldd	r25, Y+5	; 0x05
    394e:	00 97       	sbiw	r24, 0x00	; 0
    3950:	19 f0       	breq	.+6      	; 0x3958 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3952:	b8 01       	movw	r22, r16
    3954:	0e 94 98 1c 	call	0x3930	; 0x3930 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3958:	df 91       	pop	r29
    395a:	cf 91       	pop	r28
    395c:	1f 91       	pop	r17
    395e:	0f 91       	pop	r16
    3960:	08 95       	ret

00003962 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3962:	0f 93       	push	r16
    3964:	1f 93       	push	r17
    3966:	cf 93       	push	r28
    3968:	df 93       	push	r29
    396a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    396c:	6a e0       	ldi	r22, 0x0A	; 10
    396e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3972:	8c 01       	movw	r16, r24
    3974:	68 e4       	ldi	r22, 0x48	; 72
    3976:	76 e0       	ldi	r23, 0x06	; 6
    3978:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    397c:	6a e0       	ldi	r22, 0x0A	; 10
    397e:	c8 01       	movw	r24, r16
    3980:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3984:	8c 01       	movw	r16, r24
    3986:	61 e4       	ldi	r22, 0x41	; 65
    3988:	76 e0       	ldi	r23, 0x06	; 6
    398a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    398e:	66 e0       	ldi	r22, 0x06	; 6
    3990:	c8 01       	movw	r24, r16
    3992:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3996:	6a e0       	ldi	r22, 0x0A	; 10
    3998:	ce 01       	movw	r24, r28
    399a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    399e:	8c 01       	movw	r16, r24
    39a0:	60 e3       	ldi	r22, 0x30	; 48
    39a2:	76 e0       	ldi	r23, 0x06	; 6
    39a4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    39a8:	6a e0       	ldi	r22, 0x0A	; 10
    39aa:	c8 01       	movw	r24, r16
    39ac:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    39b0:	8c 01       	movw	r16, r24
    39b2:	64 e2       	ldi	r22, 0x24	; 36
    39b4:	76 e0       	ldi	r23, 0x06	; 6
    39b6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    39ba:	6a e0       	ldi	r22, 0x0A	; 10
    39bc:	c8 01       	movw	r24, r16
    39be:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    39c2:	8c 01       	movw	r16, r24
    39c4:	6e e1       	ldi	r22, 0x1E	; 30
    39c6:	76 e0       	ldi	r23, 0x06	; 6
    39c8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    39cc:	66 e0       	ldi	r22, 0x06	; 6
    39ce:	c8 01       	movw	r24, r16
    39d0:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    39d4:	6a e0       	ldi	r22, 0x0A	; 10
    39d6:	ce 01       	movw	r24, r28
    39d8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    39dc:	8c 01       	movw	r16, r24
    39de:	6d e0       	ldi	r22, 0x0D	; 13
    39e0:	76 e0       	ldi	r23, 0x06	; 6
    39e2:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    39e6:	6a e0       	ldi	r22, 0x0A	; 10
    39e8:	c8 01       	movw	r24, r16
    39ea:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    39ee:	8c 01       	movw	r16, r24
    39f0:	61 e0       	ldi	r22, 0x01	; 1
    39f2:	76 e0       	ldi	r23, 0x06	; 6
    39f4:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    39f8:	6a e0       	ldi	r22, 0x0A	; 10
    39fa:	c8 01       	movw	r24, r16
    39fc:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3a00:	8c 01       	movw	r16, r24
    3a02:	6b ef       	ldi	r22, 0xFB	; 251
    3a04:	75 e0       	ldi	r23, 0x05	; 5
    3a06:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3a0a:	66 e0       	ldi	r22, 0x06	; 6
    3a0c:	c8 01       	movw	r24, r16
    3a0e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3a12:	80 91 44 33 	lds	r24, 0x3344	; 0x803344 <last_created_task_pointer>
    3a16:	90 91 45 33 	lds	r25, 0x3345	; 0x803345 <last_created_task_pointer+0x1>
    3a1a:	00 97       	sbiw	r24, 0x00	; 0
    3a1c:	19 f0       	breq	.+6      	; 0x3a24 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    3a1e:	be 01       	movw	r22, r28
    3a20:	0e 94 98 1c 	call	0x3930	; 0x3930 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3a24:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <xTaskGetIdleTaskHandle>
    3a28:	0e 94 e9 19 	call	0x33d2	; 0x33d2 <uxTaskGetStackHighWaterMark>
    3a2c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    3a2e:	6a e0       	ldi	r22, 0x0A	; 10
    3a30:	ce 01       	movw	r24, r28
    3a32:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3a36:	ec 01       	movw	r28, r24
    3a38:	60 ef       	ldi	r22, 0xF0	; 240
    3a3a:	75 e0       	ldi	r23, 0x05	; 5
    3a3c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3a40:	61 2f       	mov	r22, r17
    3a42:	ce 01       	movw	r24, r28
    3a44:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3a48:	6a e0       	ldi	r22, 0x0A	; 10
    3a4a:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3a4e:	ec 01       	movw	r28, r24
    3a50:	6e ee       	ldi	r22, 0xEE	; 238
    3a52:	75 e0       	ldi	r23, 0x05	; 5
    3a54:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3a58:	64 e6       	ldi	r22, 0x64	; 100
    3a5a:	70 e0       	ldi	r23, 0x00	; 0
    3a5c:	ce 01       	movw	r24, r28
    3a5e:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    3a62:	6a e0       	ldi	r22, 0x0A	; 10
    3a64:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3a68:	ec 01       	movw	r28, r24
    3a6a:	6b ee       	ldi	r22, 0xEB	; 235
    3a6c:	75 e0       	ldi	r23, 0x05	; 5
    3a6e:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3a72:	66 e0       	ldi	r22, 0x06	; 6
    3a74:	ce 01       	movw	r24, r28
    3a76:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
}
    3a7a:	df 91       	pop	r29
    3a7c:	cf 91       	pop	r28
    3a7e:	1f 91       	pop	r17
    3a80:	0f 91       	pop	r16
    3a82:	08 95       	ret

00003a84 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3a84:	0f 93       	push	r16
    3a86:	cf 93       	push	r28
    3a88:	df 93       	push	r29
    3a8a:	1f 92       	push	r1
    3a8c:	cd b7       	in	r28, 0x3d	; 61
    3a8e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3a90:	00 e0       	ldi	r16, 0x00	; 0
    3a92:	2f ef       	ldi	r18, 0xFF	; 255
    3a94:	3f ef       	ldi	r19, 0xFF	; 255
    3a96:	a9 01       	movw	r20, r18
    3a98:	be 01       	movw	r22, r28
    3a9a:	6f 5f       	subi	r22, 0xFF	; 255
    3a9c:	7f 4f       	sbci	r23, 0xFF	; 255
    3a9e:	fc 01       	movw	r30, r24
    3aa0:	80 85       	ldd	r24, Z+8	; 0x08
    3aa2:	91 85       	ldd	r25, Z+9	; 0x09
    3aa4:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
    3aa8:	81 30       	cpi	r24, 0x01	; 1
    3aaa:	19 f4       	brne	.+6      	; 0x3ab2 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3aac:	89 81       	ldd	r24, Y+1	; 0x01
    3aae:	90 e0       	ldi	r25, 0x00	; 0
    3ab0:	02 c0       	rjmp	.+4      	; 0x3ab6 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3ab2:	8f ef       	ldi	r24, 0xFF	; 255
    3ab4:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3ab6:	0f 90       	pop	r0
    3ab8:	df 91       	pop	r29
    3aba:	cf 91       	pop	r28
    3abc:	0f 91       	pop	r16
    3abe:	08 95       	ret

00003ac0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3ac0:	fc 01       	movw	r30, r24
    3ac2:	80 85       	ldd	r24, Z+8	; 0x08
    3ac4:	91 85       	ldd	r25, Z+9	; 0x09
    3ac6:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    3aca:	91 e0       	ldi	r25, 0x01	; 1
    3acc:	81 11       	cpse	r24, r1
    3ace:	01 c0       	rjmp	.+2      	; 0x3ad2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3ad0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3ad2:	89 2f       	mov	r24, r25
    3ad4:	08 95       	ret

00003ad6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3ad6:	0f 93       	push	r16
    3ad8:	cf 93       	push	r28
    3ada:	df 93       	push	r29
    3adc:	1f 92       	push	r1
    3ade:	cd b7       	in	r28, 0x3d	; 61
    3ae0:	de b7       	in	r29, 0x3e	; 62
    3ae2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3ae4:	fc 01       	movw	r30, r24
    3ae6:	22 85       	ldd	r18, Z+10	; 0x0a
    3ae8:	33 85       	ldd	r19, Z+11	; 0x0b
    3aea:	44 85       	ldd	r20, Z+12	; 0x0c
    3aec:	55 85       	ldd	r21, Z+13	; 0x0d
    3aee:	00 e0       	ldi	r16, 0x00	; 0
    3af0:	be 01       	movw	r22, r28
    3af2:	6f 5f       	subi	r22, 0xFF	; 255
    3af4:	7f 4f       	sbci	r23, 0xFF	; 255
    3af6:	80 85       	ldd	r24, Z+8	; 0x08
    3af8:	91 85       	ldd	r25, Z+9	; 0x09
    3afa:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    3afe:	91 e0       	ldi	r25, 0x01	; 1
    3b00:	81 11       	cpse	r24, r1
    3b02:	01 c0       	rjmp	.+2      	; 0x3b06 <_ZN14frt_text_queue7putcharEc+0x30>
    3b04:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3b06:	89 2f       	mov	r24, r25
    3b08:	0f 90       	pop	r0
    3b0a:	df 91       	pop	r29
    3b0c:	cf 91       	pop	r28
    3b0e:	0f 91       	pop	r16
    3b10:	08 95       	ret

00003b12 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3b12:	8f 92       	push	r8
    3b14:	9f 92       	push	r9
    3b16:	bf 92       	push	r11
    3b18:	cf 92       	push	r12
    3b1a:	df 92       	push	r13
    3b1c:	ef 92       	push	r14
    3b1e:	ff 92       	push	r15
    3b20:	0f 93       	push	r16
    3b22:	1f 93       	push	r17
    3b24:	cf 93       	push	r28
    3b26:	df 93       	push	r29
    3b28:	ec 01       	movw	r28, r24
    3b2a:	b6 2e       	mov	r11, r22
    3b2c:	4a 01       	movw	r8, r20
    3b2e:	68 01       	movw	r12, r16
    3b30:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3b32:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <_ZN8emstreamC1Ev>
    3b36:	88 e3       	ldi	r24, 0x38	; 56
    3b38:	92 e2       	ldi	r25, 0x22	; 34
    3b3a:	88 83       	st	Y, r24
    3b3c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3b3e:	8e 86       	std	Y+14, r8	; 0x0e
    3b40:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3b42:	40 e0       	ldi	r20, 0x00	; 0
    3b44:	61 e0       	ldi	r22, 0x01	; 1
    3b46:	8b 2d       	mov	r24, r11
    3b48:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    3b4c:	88 87       	std	Y+8, r24	; 0x08
    3b4e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3b50:	ca 86       	std	Y+10, r12	; 0x0a
    3b52:	db 86       	std	Y+11, r13	; 0x0b
    3b54:	ec 86       	std	Y+12, r14	; 0x0c
    3b56:	fd 86       	std	Y+13, r15	; 0x0d
}
    3b58:	df 91       	pop	r29
    3b5a:	cf 91       	pop	r28
    3b5c:	1f 91       	pop	r17
    3b5e:	0f 91       	pop	r16
    3b60:	ff 90       	pop	r15
    3b62:	ef 90       	pop	r14
    3b64:	df 90       	pop	r13
    3b66:	cf 90       	pop	r12
    3b68:	bf 90       	pop	r11
    3b6a:	9f 90       	pop	r9
    3b6c:	8f 90       	pop	r8
    3b6e:	08 95       	ret

00003b70 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3b70:	cf 92       	push	r12
    3b72:	df 92       	push	r13
    3b74:	ef 92       	push	r14
    3b76:	ff 92       	push	r15
    3b78:	cf 93       	push	r28
    3b7a:	df 93       	push	r29
    3b7c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3b7e:	68 81       	ld	r22, Y
    3b80:	79 81       	ldd	r23, Y+1	; 0x01
    3b82:	8a 81       	ldd	r24, Y+2	; 0x02
    3b84:	9b 81       	ldd	r25, Y+3	; 0x03
    3b86:	0f 2e       	mov	r0, r31
    3b88:	f8 ee       	ldi	r31, 0xE8	; 232
    3b8a:	cf 2e       	mov	r12, r31
    3b8c:	f3 e0       	ldi	r31, 0x03	; 3
    3b8e:	df 2e       	mov	r13, r31
    3b90:	e1 2c       	mov	r14, r1
    3b92:	f1 2c       	mov	r15, r1
    3b94:	f0 2d       	mov	r31, r0
    3b96:	a7 01       	movw	r20, r14
    3b98:	96 01       	movw	r18, r12
    3b9a:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    3b9e:	9b 01       	movw	r18, r22
    3ba0:	ac 01       	movw	r20, r24
    3ba2:	60 e4       	ldi	r22, 0x40	; 64
    3ba4:	72 e4       	ldi	r23, 0x42	; 66
    3ba6:	8f e0       	ldi	r24, 0x0F	; 15
    3ba8:	90 e0       	ldi	r25, 0x00	; 0
    3baa:	0e 94 5b 27 	call	0x4eb6	; 0x4eb6 <__mulsi3>
    3bae:	a7 01       	movw	r20, r14
    3bb0:	96 01       	movw	r18, r12
    3bb2:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    3bb6:	69 01       	movw	r12, r18
    3bb8:	7a 01       	movw	r14, r20
    3bba:	ac 81       	ldd	r26, Y+4	; 0x04
    3bbc:	bd 81       	ldd	r27, Y+5	; 0x05
    3bbe:	20 e4       	ldi	r18, 0x40	; 64
    3bc0:	32 e4       	ldi	r19, 0x42	; 66
    3bc2:	4f e0       	ldi	r20, 0x0F	; 15
    3bc4:	50 e0       	ldi	r21, 0x00	; 0
    3bc6:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__muluhisi3>
    3bca:	20 e0       	ldi	r18, 0x00	; 0
    3bcc:	38 e4       	ldi	r19, 0x48	; 72
    3bce:	48 ee       	ldi	r20, 0xE8	; 232
    3bd0:	51 e0       	ldi	r21, 0x01	; 1
    3bd2:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    3bd6:	c7 01       	movw	r24, r14
    3bd8:	b6 01       	movw	r22, r12
    3bda:	62 0f       	add	r22, r18
    3bdc:	73 1f       	adc	r23, r19
    3bde:	84 1f       	adc	r24, r20
    3be0:	95 1f       	adc	r25, r21
}
    3be2:	df 91       	pop	r29
    3be4:	cf 91       	pop	r28
    3be6:	ff 90       	pop	r15
    3be8:	ef 90       	pop	r14
    3bea:	df 90       	pop	r13
    3bec:	cf 90       	pop	r12
    3bee:	08 95       	ret

00003bf0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3bf0:	cf 92       	push	r12
    3bf2:	df 92       	push	r13
    3bf4:	ef 92       	push	r14
    3bf6:	ff 92       	push	r15
    3bf8:	0f 93       	push	r16
    3bfa:	1f 93       	push	r17
    3bfc:	cf 93       	push	r28
    3bfe:	df 93       	push	r29
    3c00:	cd b7       	in	r28, 0x3d	; 61
    3c02:	de b7       	in	r29, 0x3e	; 62
    3c04:	2f 97       	sbiw	r28, 0x0f	; 15
    3c06:	cd bf       	out	0x3d, r28	; 61
    3c08:	de bf       	out	0x3e, r29	; 62
    3c0a:	6c 01       	movw	r12, r24
    3c0c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3c0e:	db 01       	movw	r26, r22
    3c10:	6d 91       	ld	r22, X+
    3c12:	7d 91       	ld	r23, X+
    3c14:	8d 91       	ld	r24, X+
    3c16:	9c 91       	ld	r25, X
    3c18:	28 ee       	ldi	r18, 0xE8	; 232
    3c1a:	33 e0       	ldi	r19, 0x03	; 3
    3c1c:	40 e0       	ldi	r20, 0x00	; 0
    3c1e:	50 e0       	ldi	r21, 0x00	; 0
    3c20:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    3c24:	ba 01       	movw	r22, r20
    3c26:	a9 01       	movw	r20, r18
    3c28:	c6 01       	movw	r24, r12
    3c2a:	0e 94 c0 20 	call	0x4180	; 0x4180 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3c2e:	d6 01       	movw	r26, r12
    3c30:	ed 91       	ld	r30, X+
    3c32:	fc 91       	ld	r31, X
    3c34:	02 80       	ldd	r0, Z+2	; 0x02
    3c36:	f3 81       	ldd	r31, Z+3	; 0x03
    3c38:	e0 2d       	mov	r30, r0
    3c3a:	6e e2       	ldi	r22, 0x2E	; 46
    3c3c:	c6 01       	movw	r24, r12
    3c3e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3c40:	c8 01       	movw	r24, r16
    3c42:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <_ZN10time_stamp12get_microsecEv>
    3c46:	8e 01       	movw	r16, r28
    3c48:	09 5f       	subi	r16, 0xF9	; 249
    3c4a:	1f 4f       	sbci	r17, 0xFF	; 255
    3c4c:	fe 01       	movw	r30, r28
    3c4e:	31 96       	adiw	r30, 0x01	; 1
    3c50:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3c52:	2a e0       	ldi	r18, 0x0A	; 10
    3c54:	30 e0       	ldi	r19, 0x00	; 0
    3c56:	40 e0       	ldi	r20, 0x00	; 0
    3c58:	50 e0       	ldi	r21, 0x00	; 0
    3c5a:	0e 94 8d 27 	call	0x4f1a	; 0x4f1a <__divmodsi4>
    3c5e:	e6 2f       	mov	r30, r22
    3c60:	28 87       	std	Y+8, r18	; 0x08
    3c62:	39 87       	std	Y+9, r19	; 0x09
    3c64:	4a 87       	std	Y+10, r20	; 0x0a
    3c66:	5b 87       	std	Y+11, r21	; 0x0b
    3c68:	68 85       	ldd	r22, Y+8	; 0x08
    3c6a:	79 85       	ldd	r23, Y+9	; 0x09
    3c6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3c6e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3c70:	20 e3       	ldi	r18, 0x30	; 48
    3c72:	2e 0f       	add	r18, r30
    3c74:	d8 01       	movw	r26, r16
    3c76:	2e 93       	st	-X, r18
    3c78:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3c7a:	ae 15       	cp	r26, r14
    3c7c:	bf 05       	cpc	r27, r15
    3c7e:	49 f7       	brne	.-46     	; 0x3c52 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3c80:	1f 82       	std	Y+7, r1	; 0x07
    3c82:	be 01       	movw	r22, r28
    3c84:	6f 5f       	subi	r22, 0xFF	; 255
    3c86:	7f 4f       	sbci	r23, 0xFF	; 255
    3c88:	c6 01       	movw	r24, r12
    3c8a:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3c8e:	c6 01       	movw	r24, r12
    3c90:	2f 96       	adiw	r28, 0x0f	; 15
    3c92:	cd bf       	out	0x3d, r28	; 61
    3c94:	de bf       	out	0x3e, r29	; 62
    3c96:	df 91       	pop	r29
    3c98:	cf 91       	pop	r28
    3c9a:	1f 91       	pop	r17
    3c9c:	0f 91       	pop	r16
    3c9e:	ff 90       	pop	r15
    3ca0:	ef 90       	pop	r14
    3ca2:	df 90       	pop	r13
    3ca4:	cf 90       	pop	r12
    3ca6:	08 95       	ret

00003ca8 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3ca8:	cf 93       	push	r28
    3caa:	df 93       	push	r29
    3cac:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3cae:	0f b6       	in	r0, 0x3f	; 63
    3cb0:	f8 94       	cli
    3cb2:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3cb4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3cb8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3cbc:	8c 83       	std	Y+4, r24	; 0x04
    3cbe:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3cc0:	0e 94 d5 16 	call	0x2daa	; 0x2daa <xTaskGetTickCount>
    3cc4:	68 83       	st	Y, r22
    3cc6:	79 83       	std	Y+1, r23	; 0x01
    3cc8:	8a 83       	std	Y+2, r24	; 0x02
    3cca:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3ccc:	0f 90       	pop	r0
    3cce:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3cd0:	ce 01       	movw	r24, r28
    3cd2:	df 91       	pop	r29
    3cd4:	cf 91       	pop	r28
    3cd6:	08 95       	ret

00003cd8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3cd8:	5f 92       	push	r5
    3cda:	6f 92       	push	r6
    3cdc:	7f 92       	push	r7
    3cde:	8f 92       	push	r8
    3ce0:	9f 92       	push	r9
    3ce2:	af 92       	push	r10
    3ce4:	bf 92       	push	r11
    3ce6:	cf 92       	push	r12
    3ce8:	df 92       	push	r13
    3cea:	ef 92       	push	r14
    3cec:	ff 92       	push	r15
    3cee:	0f 93       	push	r16
    3cf0:	1f 93       	push	r17
    3cf2:	cf 93       	push	r28
    3cf4:	df 93       	push	r29
    3cf6:	5c 01       	movw	r10, r24
    3cf8:	4b 01       	movw	r8, r22
    3cfa:	7a 01       	movw	r14, r20
    3cfc:	12 2f       	mov	r17, r18
    3cfe:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3d00:	63 e0       	ldi	r22, 0x03	; 3
    3d02:	ca 01       	movw	r24, r20
    3d04:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3d08:	a8 14       	cp	r10, r8
    3d0a:	b9 04       	cpc	r11, r9
    3d0c:	08 f0       	brcs	.+2      	; 0x3d10 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3d0e:	7d c0       	rjmp	.+250    	; 0x3e0a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3d10:	65 01       	movw	r12, r10
    3d12:	84 e1       	ldi	r24, 0x14	; 20
    3d14:	c8 0e       	add	r12, r24
    3d16:	d1 1c       	adc	r13, r1
    3d18:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3d1a:	6a 2c       	mov	r6, r10
    3d1c:	5b 2c       	mov	r5, r11
    3d1e:	b5 01       	movw	r22, r10
    3d20:	c7 01       	movw	r24, r14
    3d22:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    3d26:	6a e0       	ldi	r22, 0x0A	; 10
    3d28:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3d2c:	6d e6       	ldi	r22, 0x6D	; 109
    3d2e:	76 e0       	ldi	r23, 0x06	; 6
    3d30:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3d34:	11 23       	and	r17, r17
    3d36:	09 f4       	brne	.+2      	; 0x3d3a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3d38:	6d c0       	rjmp	.+218    	; 0x3e14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3d3a:	00 23       	and	r16, r16
    3d3c:	09 f4       	brne	.+2      	; 0x3d40 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3d3e:	6a c0       	rjmp	.+212    	; 0x3e14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3d40:	6a e0       	ldi	r22, 0x0A	; 10
    3d42:	c7 01       	movw	r24, r14
    3d44:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3d48:	68 e6       	ldi	r22, 0x68	; 104
    3d4a:	76 e0       	ldi	r23, 0x06	; 6
    3d4c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    3d50:	61 c0       	rjmp	.+194    	; 0x3e14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3d52:	11 23       	and	r17, r17
    3d54:	71 f0       	breq	.+28     	; 0x3d72 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3d56:	01 11       	cpse	r16, r1
    3d58:	0c c0       	rjmp	.+24     	; 0x3d72 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3d5a:	88 81       	ld	r24, Y
    3d5c:	87 15       	cp	r24, r7
    3d5e:	49 f0       	breq	.+18     	; 0x3d72 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3d60:	6a e0       	ldi	r22, 0x0A	; 10
    3d62:	c7 01       	movw	r24, r14
    3d64:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3d68:	63 e6       	ldi	r22, 0x63	; 99
    3d6a:	76 e0       	ldi	r23, 0x06	; 6
    3d6c:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3d70:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3d72:	69 91       	ld	r22, Y+
    3d74:	c7 01       	movw	r24, r14
    3d76:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3d7a:	dc 01       	movw	r26, r24
    3d7c:	ed 91       	ld	r30, X+
    3d7e:	fc 91       	ld	r31, X
    3d80:	02 80       	ldd	r0, Z+2	; 0x02
    3d82:	f3 81       	ldd	r31, Z+3	; 0x03
    3d84:	e0 2d       	mov	r30, r0
    3d86:	60 e2       	ldi	r22, 0x20	; 32
    3d88:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3d8a:	cc 16       	cp	r12, r28
    3d8c:	dd 06       	cpc	r13, r29
    3d8e:	09 f7       	brne	.-62     	; 0x3d52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3d90:	11 23       	and	r17, r17
    3d92:	89 f0       	breq	.+34     	; 0x3db6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3d94:	6a e0       	ldi	r22, 0x0A	; 10
    3d96:	c7 01       	movw	r24, r14
    3d98:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3d9c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3d9e:	6d e5       	ldi	r22, 0x5D	; 93
    3da0:	76 e0       	ldi	r23, 0x06	; 6
    3da2:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3da6:	e8 81       	ld	r30, Y
    3da8:	f9 81       	ldd	r31, Y+1	; 0x01
    3daa:	02 80       	ldd	r0, Z+2	; 0x02
    3dac:	f3 81       	ldd	r31, Z+3	; 0x03
    3dae:	e0 2d       	mov	r30, r0
    3db0:	60 e2       	ldi	r22, 0x20	; 32
    3db2:	ce 01       	movw	r24, r28
    3db4:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3db6:	c6 2d       	mov	r28, r6
    3db8:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3dba:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3dbc:	80 ee       	ldi	r24, 0xE0	; 224
    3dbe:	86 0f       	add	r24, r22
    3dc0:	8f 35       	cpi	r24, 0x5F	; 95
    3dc2:	48 f4       	brcc	.+18     	; 0x3dd6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3dc4:	d7 01       	movw	r26, r14
    3dc6:	ed 91       	ld	r30, X+
    3dc8:	fc 91       	ld	r31, X
    3dca:	02 80       	ldd	r0, Z+2	; 0x02
    3dcc:	f3 81       	ldd	r31, Z+3	; 0x03
    3dce:	e0 2d       	mov	r30, r0
    3dd0:	c7 01       	movw	r24, r14
    3dd2:	19 95       	eicall
    3dd4:	09 c0       	rjmp	.+18     	; 0x3de8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3dd6:	d7 01       	movw	r26, r14
    3dd8:	ed 91       	ld	r30, X+
    3dda:	fc 91       	ld	r31, X
    3ddc:	02 80       	ldd	r0, Z+2	; 0x02
    3dde:	f3 81       	ldd	r31, Z+3	; 0x03
    3de0:	e0 2d       	mov	r30, r0
    3de2:	6e e2       	ldi	r22, 0x2E	; 46
    3de4:	c7 01       	movw	r24, r14
    3de6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3de8:	cc 16       	cp	r12, r28
    3dea:	dd 06       	cpc	r13, r29
    3dec:	31 f7       	brne	.-52     	; 0x3dba <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3dee:	b4 e1       	ldi	r27, 0x14	; 20
    3df0:	ab 0e       	add	r10, r27
    3df2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3df4:	66 e0       	ldi	r22, 0x06	; 6
    3df6:	c7 01       	movw	r24, r14
    3df8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    3dfc:	84 e1       	ldi	r24, 0x14	; 20
    3dfe:	c8 0e       	add	r12, r24
    3e00:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3e02:	a8 14       	cp	r10, r8
    3e04:	b9 04       	cpc	r11, r9
    3e06:	08 f4       	brcc	.+2      	; 0x3e0a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3e08:	88 cf       	rjmp	.-240    	; 0x3d1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3e0a:	62 e0       	ldi	r22, 0x02	; 2
    3e0c:	c7 01       	movw	r24, r14
    3e0e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
}
    3e12:	03 c0       	rjmp	.+6      	; 0x3e1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3e14:	c6 2d       	mov	r28, r6
    3e16:	d5 2d       	mov	r29, r5
    3e18:	9c cf       	rjmp	.-200    	; 0x3d52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3e1a:	df 91       	pop	r29
    3e1c:	cf 91       	pop	r28
    3e1e:	1f 91       	pop	r17
    3e20:	0f 91       	pop	r16
    3e22:	ff 90       	pop	r15
    3e24:	ef 90       	pop	r14
    3e26:	df 90       	pop	r13
    3e28:	cf 90       	pop	r12
    3e2a:	bf 90       	pop	r11
    3e2c:	af 90       	pop	r10
    3e2e:	9f 90       	pop	r9
    3e30:	8f 90       	pop	r8
    3e32:	7f 90       	pop	r7
    3e34:	6f 90       	pop	r6
    3e36:	5f 90       	pop	r5
    3e38:	08 95       	ret

00003e3a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3e3a:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    3e3e:	08 95       	ret

00003e40 <_Znaj>:
    3e40:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <pvPortMalloc>
    3e44:	08 95       	ret

00003e46 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3e46:	08 95       	ret

00003e48 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3e48:	cf 93       	push	r28
    3e4a:	df 93       	push	r29
    3e4c:	fc 01       	movw	r30, r24
    3e4e:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3e50:	40 3a       	cpi	r20, 0xA0	; 160
    3e52:	68 e0       	ldi	r22, 0x08	; 8
    3e54:	56 07       	cpc	r21, r22
    3e56:	49 f4       	brne	.+18     	; 0x3e6a <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3e58:	80 e4       	ldi	r24, 0x40	; 64
    3e5a:	96 e0       	ldi	r25, 0x06	; 6
    3e5c:	82 83       	std	Z+2, r24	; 0x02
    3e5e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3e60:	82 e0       	ldi	r24, 0x02	; 2
    3e62:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3e64:	83 e0       	ldi	r24, 0x03	; 3
    3e66:	85 83       	std	Z+5, r24	; 0x05
    3e68:	32 c0       	rjmp	.+100    	; 0x3ece <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3e6a:	40 3b       	cpi	r20, 0xB0	; 176
    3e6c:	78 e0       	ldi	r23, 0x08	; 8
    3e6e:	57 07       	cpc	r21, r23
    3e70:	49 f4       	brne	.+18     	; 0x3e84 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3e72:	80 e4       	ldi	r24, 0x40	; 64
    3e74:	96 e0       	ldi	r25, 0x06	; 6
    3e76:	82 83       	std	Z+2, r24	; 0x02
    3e78:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3e7a:	86 e0       	ldi	r24, 0x06	; 6
    3e7c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3e7e:	87 e0       	ldi	r24, 0x07	; 7
    3e80:	85 83       	std	Z+5, r24	; 0x05
    3e82:	25 c0       	rjmp	.+74     	; 0x3ece <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3e84:	40 3a       	cpi	r20, 0xA0	; 160
    3e86:	89 e0       	ldi	r24, 0x09	; 9
    3e88:	58 07       	cpc	r21, r24
    3e8a:	49 f4       	brne	.+18     	; 0x3e9e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3e8c:	80 e6       	ldi	r24, 0x60	; 96
    3e8e:	96 e0       	ldi	r25, 0x06	; 6
    3e90:	82 83       	std	Z+2, r24	; 0x02
    3e92:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3e94:	82 e0       	ldi	r24, 0x02	; 2
    3e96:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3e98:	83 e0       	ldi	r24, 0x03	; 3
    3e9a:	85 83       	std	Z+5, r24	; 0x05
    3e9c:	18 c0       	rjmp	.+48     	; 0x3ece <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3e9e:	40 3b       	cpi	r20, 0xB0	; 176
    3ea0:	69 e0       	ldi	r22, 0x09	; 9
    3ea2:	56 07       	cpc	r21, r22
    3ea4:	49 f4       	brne	.+18     	; 0x3eb8 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3ea6:	80 e6       	ldi	r24, 0x60	; 96
    3ea8:	96 e0       	ldi	r25, 0x06	; 6
    3eaa:	82 83       	std	Z+2, r24	; 0x02
    3eac:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3eae:	86 e0       	ldi	r24, 0x06	; 6
    3eb0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3eb2:	87 e0       	ldi	r24, 0x07	; 7
    3eb4:	85 83       	std	Z+5, r24	; 0x05
    3eb6:	0b c0       	rjmp	.+22     	; 0x3ece <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3eb8:	40 3a       	cpi	r20, 0xA0	; 160
    3eba:	5a 40       	sbci	r21, 0x0A	; 10
    3ebc:	41 f4       	brne	.+16     	; 0x3ece <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3ebe:	80 e8       	ldi	r24, 0x80	; 128
    3ec0:	96 e0       	ldi	r25, 0x06	; 6
    3ec2:	82 83       	std	Z+2, r24	; 0x02
    3ec4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3ec6:	82 e0       	ldi	r24, 0x02	; 2
    3ec8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3eca:	83 e0       	ldi	r24, 0x03	; 3
    3ecc:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3ece:	a6 83       	std	Z+6, r26	; 0x06
    3ed0:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3ed2:	cd 01       	movw	r24, r26
    3ed4:	01 96       	adiw	r24, 0x01	; 1
    3ed6:	80 87       	std	Z+8, r24	; 0x08
    3ed8:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3eda:	03 96       	adiw	r24, 0x03	; 3
    3edc:	82 87       	std	Z+10, r24	; 0x0a
    3ede:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3ee0:	25 81       	ldd	r18, Z+5	; 0x05
    3ee2:	c2 81       	ldd	r28, Z+2	; 0x02
    3ee4:	d3 81       	ldd	r29, Z+3	; 0x03
    3ee6:	4c 81       	ldd	r20, Y+4	; 0x04
    3ee8:	81 e0       	ldi	r24, 0x01	; 1
    3eea:	90 e0       	ldi	r25, 0x00	; 0
    3eec:	bc 01       	movw	r22, r24
    3eee:	02 c0       	rjmp	.+4      	; 0x3ef4 <_ZN7base232C1EjP12USART_struct+0xac>
    3ef0:	66 0f       	add	r22, r22
    3ef2:	77 1f       	adc	r23, r23
    3ef4:	2a 95       	dec	r18
    3ef6:	e2 f7       	brpl	.-8      	; 0x3ef0 <_ZN7base232C1EjP12USART_struct+0xa8>
    3ef8:	9b 01       	movw	r18, r22
    3efa:	24 2b       	or	r18, r20
    3efc:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3efe:	25 81       	ldd	r18, Z+5	; 0x05
    3f00:	c2 81       	ldd	r28, Z+2	; 0x02
    3f02:	d3 81       	ldd	r29, Z+3	; 0x03
    3f04:	48 81       	ld	r20, Y
    3f06:	bc 01       	movw	r22, r24
    3f08:	02 c0       	rjmp	.+4      	; 0x3f0e <_ZN7base232C1EjP12USART_struct+0xc6>
    3f0a:	66 0f       	add	r22, r22
    3f0c:	77 1f       	adc	r23, r23
    3f0e:	2a 95       	dec	r18
    3f10:	e2 f7       	brpl	.-8      	; 0x3f0a <_ZN7base232C1EjP12USART_struct+0xc2>
    3f12:	9b 01       	movw	r18, r22
    3f14:	24 2b       	or	r18, r20
    3f16:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3f18:	34 81       	ldd	r19, Z+4	; 0x04
    3f1a:	c2 81       	ldd	r28, Z+2	; 0x02
    3f1c:	d3 81       	ldd	r29, Z+3	; 0x03
    3f1e:	28 81       	ld	r18, Y
    3f20:	02 c0       	rjmp	.+4      	; 0x3f26 <_ZN7base232C1EjP12USART_struct+0xde>
    3f22:	88 0f       	add	r24, r24
    3f24:	99 1f       	adc	r25, r25
    3f26:	3a 95       	dec	r19
    3f28:	e2 f7       	brpl	.-8      	; 0x3f22 <_ZN7base232C1EjP12USART_struct+0xda>
    3f2a:	80 95       	com	r24
    3f2c:	90 95       	com	r25
    3f2e:	82 23       	and	r24, r18
    3f30:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3f32:	80 e1       	ldi	r24, 0x10	; 16
    3f34:	13 96       	adiw	r26, 0x03	; 3
    3f36:	8c 93       	st	X, r24
    3f38:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3f3a:	83 e0       	ldi	r24, 0x03	; 3
    3f3c:	15 96       	adiw	r26, 0x05	; 5
    3f3e:	8c 93       	st	X, r24
    3f40:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3f42:	80 ef       	ldi	r24, 0xF0	; 240
    3f44:	17 96       	adiw	r26, 0x07	; 7
    3f46:	8c 93       	st	X, r24
    3f48:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3f4a:	81 e2       	ldi	r24, 0x21	; 33
    3f4c:	16 96       	adiw	r26, 0x06	; 6
    3f4e:	8c 93       	st	X, r24
    3f50:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3f52:	88 e1       	ldi	r24, 0x18	; 24
    3f54:	14 96       	adiw	r26, 0x04	; 4
    3f56:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3f58:	80 e8       	ldi	r24, 0x80	; 128
    3f5a:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3f5c:	80 e4       	ldi	r24, 0x40	; 64
    3f5e:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3f60:	80 e2       	ldi	r24, 0x20	; 32
    3f62:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3f64:	06 80       	ldd	r0, Z+6	; 0x06
    3f66:	f7 81       	ldd	r31, Z+7	; 0x07
    3f68:	e0 2d       	mov	r30, r0
    3f6a:	80 81       	ld	r24, Z
    3f6c:	80 81       	ld	r24, Z
}
    3f6e:	df 91       	pop	r29
    3f70:	cf 91       	pop	r28
    3f72:	08 95       	ret

00003f74 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3f74:	81 e0       	ldi	r24, 0x01	; 1
    3f76:	08 95       	ret

00003f78 <_ZN8emstream7getcharEv>:
    3f78:	80 e0       	ldi	r24, 0x00	; 0
    3f7a:	90 e0       	ldi	r25, 0x00	; 0
    3f7c:	08 95       	ret

00003f7e <_ZN8emstream14check_for_charEv>:
    3f7e:	80 e0       	ldi	r24, 0x00	; 0
    3f80:	08 95       	ret

00003f82 <_ZN8emstream12transmit_nowEv>:
    3f82:	08 95       	ret

00003f84 <_ZN8emstream12clear_screenEv>:
    3f84:	08 95       	ret

00003f86 <_ZN8emstreamC1Ev>:
    3f86:	fc 01       	movw	r30, r24
    3f88:	88 e4       	ldi	r24, 0x48	; 72
    3f8a:	92 e2       	ldi	r25, 0x22	; 34
    3f8c:	80 83       	st	Z, r24
    3f8e:	91 83       	std	Z+1, r25	; 0x01
    3f90:	8a e0       	ldi	r24, 0x0A	; 10
    3f92:	82 83       	std	Z+2, r24	; 0x02
    3f94:	13 82       	std	Z+3, r1	; 0x03
    3f96:	83 e0       	ldi	r24, 0x03	; 3
    3f98:	85 83       	std	Z+5, r24	; 0x05
    3f9a:	14 82       	std	Z+4, r1	; 0x04
    3f9c:	16 82       	std	Z+6, r1	; 0x06
    3f9e:	17 82       	std	Z+7, r1	; 0x07
    3fa0:	08 95       	ret

00003fa2 <_ZN8emstream4putsEPKc>:
    3fa2:	0f 93       	push	r16
    3fa4:	1f 93       	push	r17
    3fa6:	cf 93       	push	r28
    3fa8:	df 93       	push	r29
    3faa:	8c 01       	movw	r16, r24
    3fac:	fb 01       	movw	r30, r22
    3fae:	dc 01       	movw	r26, r24
    3fb0:	14 96       	adiw	r26, 0x04	; 4
    3fb2:	8c 91       	ld	r24, X
    3fb4:	81 11       	cpse	r24, r1
    3fb6:	04 c0       	rjmp	.+8      	; 0x3fc0 <_ZN8emstream4putsEPKc+0x1e>
    3fb8:	60 81       	ld	r22, Z
    3fba:	61 11       	cpse	r22, r1
    3fbc:	17 c0       	rjmp	.+46     	; 0x3fec <_ZN8emstream4putsEPKc+0x4a>
    3fbe:	23 c0       	rjmp	.+70     	; 0x4006 <__stack+0x7>
    3fc0:	d8 01       	movw	r26, r16
    3fc2:	14 96       	adiw	r26, 0x04	; 4
    3fc4:	1c 92       	st	X, r1
    3fc6:	eb 01       	movw	r28, r22
    3fc8:	21 96       	adiw	r28, 0x01	; 1
    3fca:	64 91       	lpm	r22, Z
    3fcc:	66 23       	and	r22, r22
    3fce:	d9 f0       	breq	.+54     	; 0x4006 <__stack+0x7>
    3fd0:	d8 01       	movw	r26, r16
    3fd2:	ed 91       	ld	r30, X+
    3fd4:	fc 91       	ld	r31, X
    3fd6:	02 80       	ldd	r0, Z+2	; 0x02
    3fd8:	f3 81       	ldd	r31, Z+3	; 0x03
    3fda:	e0 2d       	mov	r30, r0
    3fdc:	c8 01       	movw	r24, r16
    3fde:	19 95       	eicall
    3fe0:	fe 01       	movw	r30, r28
    3fe2:	64 91       	lpm	r22, Z
    3fe4:	21 96       	adiw	r28, 0x01	; 1
    3fe6:	61 11       	cpse	r22, r1
    3fe8:	f3 cf       	rjmp	.-26     	; 0x3fd0 <_ZN8emstream4putsEPKc+0x2e>
    3fea:	0d c0       	rjmp	.+26     	; 0x4006 <__stack+0x7>
    3fec:	ef 01       	movw	r28, r30
    3fee:	21 96       	adiw	r28, 0x01	; 1
    3ff0:	d8 01       	movw	r26, r16
    3ff2:	ed 91       	ld	r30, X+
    3ff4:	fc 91       	ld	r31, X
    3ff6:	02 80       	ldd	r0, Z+2	; 0x02
    3ff8:	f3 81       	ldd	r31, Z+3	; 0x03
    3ffa:	e0 2d       	mov	r30, r0
    3ffc:	c8 01       	movw	r24, r16
    3ffe:	19 95       	eicall
    4000:	69 91       	ld	r22, Y+
    4002:	61 11       	cpse	r22, r1
    4004:	f5 cf       	rjmp	.-22     	; 0x3ff0 <_ZN8emstream4putsEPKc+0x4e>
    4006:	df 91       	pop	r29
    4008:	cf 91       	pop	r28
    400a:	1f 91       	pop	r17
    400c:	0f 91       	pop	r16
    400e:	08 95       	ret

00004010 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    4010:	cf 93       	push	r28
    4012:	df 93       	push	r29
    4014:	ec 01       	movw	r28, r24
	switch (new_manip)
    4016:	86 2f       	mov	r24, r22
    4018:	90 e0       	ldi	r25, 0x00	; 0
    401a:	8b 30       	cpi	r24, 0x0B	; 11
    401c:	91 05       	cpc	r25, r1
    401e:	d8 f5       	brcc	.+118    	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
    4020:	fc 01       	movw	r30, r24
    4022:	88 27       	eor	r24, r24
    4024:	e2 50       	subi	r30, 0x02	; 2
    4026:	ff 4f       	sbci	r31, 0xFF	; 255
    4028:	8f 4f       	sbci	r24, 0xFF	; 255
    402a:	0c 94 ac 27 	jmp	0x4f58	; 0x4f58 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    402e:	82 e0       	ldi	r24, 0x02	; 2
    4030:	8a 83       	std	Y+2, r24	; 0x02
			break;
    4032:	31 c0       	rjmp	.+98     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    4034:	88 e0       	ldi	r24, 0x08	; 8
    4036:	8a 83       	std	Y+2, r24	; 0x02
			break;
    4038:	2e c0       	rjmp	.+92     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    403a:	8a e0       	ldi	r24, 0x0A	; 10
    403c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    403e:	2b c0       	rjmp	.+86     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    4040:	80 e1       	ldi	r24, 0x10	; 16
    4042:	8a 83       	std	Y+2, r24	; 0x02
			break;
    4044:	28 c0       	rjmp	.+80     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    4046:	81 e0       	ldi	r24, 0x01	; 1
    4048:	8b 83       	std	Y+3, r24	; 0x03
			break;
    404a:	25 c0       	rjmp	.+74     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    404c:	1b 82       	std	Y+3, r1	; 0x03
			break;
    404e:	23 c0       	rjmp	.+70     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    4050:	e8 81       	ld	r30, Y
    4052:	f9 81       	ldd	r31, Y+1	; 0x01
    4054:	02 80       	ldd	r0, Z+2	; 0x02
    4056:	f3 81       	ldd	r31, Z+3	; 0x03
    4058:	e0 2d       	mov	r30, r0
    405a:	6d e0       	ldi	r22, 0x0D	; 13
    405c:	ce 01       	movw	r24, r28
    405e:	19 95       	eicall
    4060:	e8 81       	ld	r30, Y
    4062:	f9 81       	ldd	r31, Y+1	; 0x01
    4064:	02 80       	ldd	r0, Z+2	; 0x02
    4066:	f3 81       	ldd	r31, Z+3	; 0x03
    4068:	e0 2d       	mov	r30, r0
    406a:	6a e0       	ldi	r22, 0x0A	; 10
    406c:	ce 01       	movw	r24, r28
    406e:	19 95       	eicall
			break;
    4070:	12 c0       	rjmp	.+36     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    4072:	e8 81       	ld	r30, Y
    4074:	f9 81       	ldd	r31, Y+1	; 0x01
    4076:	02 84       	ldd	r0, Z+10	; 0x0a
    4078:	f3 85       	ldd	r31, Z+11	; 0x0b
    407a:	e0 2d       	mov	r30, r0
    407c:	ce 01       	movw	r24, r28
    407e:	19 95       	eicall
			break;
    4080:	0a c0       	rjmp	.+20     	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    4082:	e8 81       	ld	r30, Y
    4084:	f9 81       	ldd	r31, Y+1	; 0x01
    4086:	00 84       	ldd	r0, Z+8	; 0x08
    4088:	f1 85       	ldd	r31, Z+9	; 0x09
    408a:	e0 2d       	mov	r30, r0
    408c:	ce 01       	movw	r24, r28
    408e:	19 95       	eicall
			break;
    4090:	02 c0       	rjmp	.+4      	; 0x4096 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    4092:	81 e0       	ldi	r24, 0x01	; 1
    4094:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    4096:	ce 01       	movw	r24, r28
    4098:	df 91       	pop	r29
    409a:	cf 91       	pop	r28
    409c:	08 95       	ret

0000409e <_ZN8emstreamlsEb>:
 *          reference is used to string printable items together with "<<" operators
 *  @param value The boolean value to be written
 */

emstream& emstream::operator<< (bool value)
{
    409e:	cf 93       	push	r28
    40a0:	df 93       	push	r29
    40a2:	ec 01       	movw	r28, r24
	if (value)
    40a4:	66 23       	and	r22, r22
    40a6:	41 f0       	breq	.+16     	; 0x40b8 <_ZN8emstreamlsEb+0x1a>
		putchar ('T');
    40a8:	e8 81       	ld	r30, Y
    40aa:	f9 81       	ldd	r31, Y+1	; 0x01
    40ac:	02 80       	ldd	r0, Z+2	; 0x02
    40ae:	f3 81       	ldd	r31, Z+3	; 0x03
    40b0:	e0 2d       	mov	r30, r0
    40b2:	64 e5       	ldi	r22, 0x54	; 84
    40b4:	19 95       	eicall
    40b6:	07 c0       	rjmp	.+14     	; 0x40c6 <_ZN8emstreamlsEb+0x28>
	else
		putchar ('F');
    40b8:	e8 81       	ld	r30, Y
    40ba:	f9 81       	ldd	r31, Y+1	; 0x01
    40bc:	02 80       	ldd	r0, Z+2	; 0x02
    40be:	f3 81       	ldd	r31, Z+3	; 0x03
    40c0:	e0 2d       	mov	r30, r0
    40c2:	66 e4       	ldi	r22, 0x46	; 70
    40c4:	19 95       	eicall

	return (*this);
}
    40c6:	ce 01       	movw	r24, r28
    40c8:	df 91       	pop	r29
    40ca:	cf 91       	pop	r28
    40cc:	08 95       	ret

000040ce <_ZN8emstreamlsEPv>:
 *          reference is used to string printable items together with "<<" operators
 *  @param ptr The pointer to be sent out
 */

emstream& emstream::operator<< (void* ptr)
{
    40ce:	0f 93       	push	r16
    40d0:	1f 93       	push	r17
    40d2:	cf 93       	push	r28
    40d4:	df 93       	push	r29
    40d6:	ec 01       	movw	r28, r24
    40d8:	8b 01       	movw	r16, r22
	putchar ('[');
    40da:	e8 81       	ld	r30, Y
    40dc:	f9 81       	ldd	r31, Y+1	; 0x01
    40de:	02 80       	ldd	r0, Z+2	; 0x02
    40e0:	f3 81       	ldd	r31, Z+3	; 0x03
    40e2:	e0 2d       	mov	r30, r0
    40e4:	6b e5       	ldi	r22, 0x5B	; 91
    40e6:	19 95       	eicall
	*this << hex << (size_t)ptr << dec;
    40e8:	63 e0       	ldi	r22, 0x03	; 3
    40ea:	ce 01       	movw	r24, r28
    40ec:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    40f0:	b8 01       	movw	r22, r16
    40f2:	0e 94 8c 20 	call	0x4118	; 0x4118 <_ZN8emstreamlsEj>
    40f6:	62 e0       	ldi	r22, 0x02	; 2
    40f8:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	putchar (']');
    40fc:	e8 81       	ld	r30, Y
    40fe:	f9 81       	ldd	r31, Y+1	; 0x01
    4100:	02 80       	ldd	r0, Z+2	; 0x02
    4102:	f3 81       	ldd	r31, Z+3	; 0x03
    4104:	e0 2d       	mov	r30, r0
    4106:	6d e5       	ldi	r22, 0x5D	; 93
    4108:	ce 01       	movw	r24, r28
    410a:	19 95       	eicall

	return (*this);
}
    410c:	ce 01       	movw	r24, r28
    410e:	df 91       	pop	r29
    4110:	cf 91       	pop	r28
    4112:	1f 91       	pop	r17
    4114:	0f 91       	pop	r16
    4116:	08 95       	ret

00004118 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    4118:	ff 92       	push	r15
    411a:	0f 93       	push	r16
    411c:	1f 93       	push	r17
    411e:	cf 93       	push	r28
    4120:	df 93       	push	r29
    4122:	cd b7       	in	r28, 0x3d	; 61
    4124:	de b7       	in	r29, 0x3e	; 62
    4126:	61 97       	sbiw	r28, 0x11	; 17
    4128:	cd bf       	out	0x3d, r28	; 61
    412a:	de bf       	out	0x3e, r29	; 62
    412c:	8c 01       	movw	r16, r24
    412e:	f6 2e       	mov	r15, r22
    4130:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    4132:	f8 01       	movw	r30, r16
    4134:	42 81       	ldd	r20, Z+2	; 0x02
    4136:	40 31       	cpi	r20, 0x10	; 16
    4138:	21 f0       	breq	.+8      	; 0x4142 <_ZN8emstreamlsEj+0x2a>
    413a:	48 30       	cpi	r20, 0x08	; 8
    413c:	11 f0       	breq	.+4      	; 0x4142 <_ZN8emstreamlsEj+0x2a>
    413e:	42 30       	cpi	r20, 0x02	; 2
    4140:	41 f4       	brne	.+16     	; 0x4152 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    4142:	69 2f       	mov	r22, r25
    4144:	c8 01       	movw	r24, r16
    4146:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    414a:	6f 2d       	mov	r22, r15
    414c:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    4150:	0d c0       	rjmp	.+26     	; 0x416c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4152:	50 e0       	ldi	r21, 0x00	; 0
    4154:	be 01       	movw	r22, r28
    4156:	6f 5f       	subi	r22, 0xFF	; 255
    4158:	7f 4f       	sbci	r23, 0xFF	; 255
    415a:	8f 2d       	mov	r24, r15
    415c:	0e 94 1b 28 	call	0x5036	; 0x5036 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    4160:	be 01       	movw	r22, r28
    4162:	6f 5f       	subi	r22, 0xFF	; 255
    4164:	7f 4f       	sbci	r23, 0xFF	; 255
    4166:	c8 01       	movw	r24, r16
    4168:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    416c:	c8 01       	movw	r24, r16
    416e:	61 96       	adiw	r28, 0x11	; 17
    4170:	cd bf       	out	0x3d, r28	; 61
    4172:	de bf       	out	0x3e, r29	; 62
    4174:	df 91       	pop	r29
    4176:	cf 91       	pop	r28
    4178:	1f 91       	pop	r17
    417a:	0f 91       	pop	r16
    417c:	ff 90       	pop	r15
    417e:	08 95       	ret

00004180 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    4180:	df 92       	push	r13
    4182:	ef 92       	push	r14
    4184:	ff 92       	push	r15
    4186:	0f 93       	push	r16
    4188:	1f 93       	push	r17
    418a:	cf 93       	push	r28
    418c:	df 93       	push	r29
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	a1 97       	sbiw	r28, 0x21	; 33
    4194:	cd bf       	out	0x3d, r28	; 61
    4196:	de bf       	out	0x3e, r29	; 62
    4198:	8c 01       	movw	r16, r24
    419a:	d4 2e       	mov	r13, r20
    419c:	e5 2e       	mov	r14, r21
    419e:	f6 2e       	mov	r15, r22
    41a0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    41a2:	f8 01       	movw	r30, r16
    41a4:	22 81       	ldd	r18, Z+2	; 0x02
    41a6:	20 31       	cpi	r18, 0x10	; 16
    41a8:	21 f0       	breq	.+8      	; 0x41b2 <_ZN8emstreamlsEm+0x32>
    41aa:	28 30       	cpi	r18, 0x08	; 8
    41ac:	11 f0       	breq	.+4      	; 0x41b2 <_ZN8emstreamlsEm+0x32>
    41ae:	22 30       	cpi	r18, 0x02	; 2
    41b0:	71 f4       	brne	.+28     	; 0x41ce <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    41b2:	69 2f       	mov	r22, r25
    41b4:	c8 01       	movw	r24, r16
    41b6:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    41ba:	6f 2d       	mov	r22, r15
    41bc:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    41c0:	6e 2d       	mov	r22, r14
    41c2:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    41c6:	6d 2d       	mov	r22, r13
    41c8:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN8emstreamlsEh>
    41cc:	0f c0       	rjmp	.+30     	; 0x41ec <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    41ce:	30 e0       	ldi	r19, 0x00	; 0
    41d0:	ae 01       	movw	r20, r28
    41d2:	4f 5f       	subi	r20, 0xFF	; 255
    41d4:	5f 4f       	sbci	r21, 0xFF	; 255
    41d6:	6d 2d       	mov	r22, r13
    41d8:	7e 2d       	mov	r23, r14
    41da:	8f 2d       	mov	r24, r15
    41dc:	0e 94 ee 27 	call	0x4fdc	; 0x4fdc <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    41e0:	be 01       	movw	r22, r28
    41e2:	6f 5f       	subi	r22, 0xFF	; 255
    41e4:	7f 4f       	sbci	r23, 0xFF	; 255
    41e6:	c8 01       	movw	r24, r16
    41e8:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    41ec:	c8 01       	movw	r24, r16
    41ee:	a1 96       	adiw	r28, 0x21	; 33
    41f0:	cd bf       	out	0x3d, r28	; 61
    41f2:	de bf       	out	0x3e, r29	; 62
    41f4:	df 91       	pop	r29
    41f6:	cf 91       	pop	r28
    41f8:	1f 91       	pop	r17
    41fa:	0f 91       	pop	r16
    41fc:	ff 90       	pop	r15
    41fe:	ef 90       	pop	r14
    4200:	df 90       	pop	r13
    4202:	08 95       	ret

00004204 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    4204:	cf 92       	push	r12
    4206:	df 92       	push	r13
    4208:	ef 92       	push	r14
    420a:	ff 92       	push	r15
    420c:	0f 93       	push	r16
    420e:	1f 93       	push	r17
    4210:	cf 93       	push	r28
    4212:	df 93       	push	r29
    4214:	cd b7       	in	r28, 0x3d	; 61
    4216:	de b7       	in	r29, 0x3e	; 62
    4218:	29 97       	sbiw	r28, 0x09	; 9
    421a:	cd bf       	out	0x3d, r28	; 61
    421c:	de bf       	out	0x3e, r29	; 62
    421e:	8c 01       	movw	r16, r24
    4220:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    4222:	dc 01       	movw	r26, r24
    4224:	13 96       	adiw	r26, 0x03	; 3
    4226:	8c 91       	ld	r24, X
    4228:	13 97       	sbiw	r26, 0x03	; 3
    422a:	88 23       	and	r24, r24
    422c:	41 f0       	breq	.+16     	; 0x423e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    422e:	ed 91       	ld	r30, X+
    4230:	fc 91       	ld	r31, X
    4232:	02 80       	ldd	r0, Z+2	; 0x02
    4234:	f3 81       	ldd	r31, Z+3	; 0x03
    4236:	e0 2d       	mov	r30, r0
    4238:	c8 01       	movw	r24, r16
    423a:	19 95       	eicall
    423c:	56 c0       	rjmp	.+172    	; 0x42ea <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    423e:	f8 01       	movw	r30, r16
    4240:	42 81       	ldd	r20, Z+2	; 0x02
    4242:	42 30       	cpi	r20, 0x02	; 2
    4244:	19 f5       	brne	.+70     	; 0x428c <_ZN8emstreamlsEh+0x88>
    4246:	68 94       	set
    4248:	cc 24       	eor	r12, r12
    424a:	c3 f8       	bld	r12, 3
    424c:	d1 2c       	mov	r13, r1
    424e:	68 94       	set
    4250:	ff 24       	eor	r15, r15
    4252:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    4254:	8e 2d       	mov	r24, r14
    4256:	8f 21       	and	r24, r15
    4258:	51 f0       	breq	.+20     	; 0x426e <_ZN8emstreamlsEh+0x6a>
    425a:	d8 01       	movw	r26, r16
    425c:	ed 91       	ld	r30, X+
    425e:	fc 91       	ld	r31, X
    4260:	02 80       	ldd	r0, Z+2	; 0x02
    4262:	f3 81       	ldd	r31, Z+3	; 0x03
    4264:	e0 2d       	mov	r30, r0
    4266:	61 e3       	ldi	r22, 0x31	; 49
    4268:	c8 01       	movw	r24, r16
    426a:	19 95       	eicall
    426c:	09 c0       	rjmp	.+18     	; 0x4280 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    426e:	d8 01       	movw	r26, r16
    4270:	ed 91       	ld	r30, X+
    4272:	fc 91       	ld	r31, X
    4274:	02 80       	ldd	r0, Z+2	; 0x02
    4276:	f3 81       	ldd	r31, Z+3	; 0x03
    4278:	e0 2d       	mov	r30, r0
    427a:	60 e3       	ldi	r22, 0x30	; 48
    427c:	c8 01       	movw	r24, r16
    427e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    4280:	f6 94       	lsr	r15
    4282:	b1 e0       	ldi	r27, 0x01	; 1
    4284:	cb 1a       	sub	r12, r27
    4286:	d1 08       	sbc	r13, r1
    4288:	29 f7       	brne	.-54     	; 0x4254 <_ZN8emstreamlsEh+0x50>
    428a:	2f c0       	rjmp	.+94     	; 0x42ea <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    428c:	40 31       	cpi	r20, 0x10	; 16
    428e:	f9 f4       	brne	.+62     	; 0x42ce <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    4290:	62 95       	swap	r22
    4292:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    4294:	01 90       	ld	r0, Z+
    4296:	f0 81       	ld	r31, Z
    4298:	e0 2d       	mov	r30, r0
    429a:	02 80       	ldd	r0, Z+2	; 0x02
    429c:	f3 81       	ldd	r31, Z+3	; 0x03
    429e:	e0 2d       	mov	r30, r0
    42a0:	6a 30       	cpi	r22, 0x0A	; 10
    42a2:	10 f0       	brcs	.+4      	; 0x42a8 <_ZN8emstreamlsEh+0xa4>
    42a4:	69 5c       	subi	r22, 0xC9	; 201
    42a6:	01 c0       	rjmp	.+2      	; 0x42aa <_ZN8emstreamlsEh+0xa6>
    42a8:	60 5d       	subi	r22, 0xD0	; 208
    42aa:	c8 01       	movw	r24, r16
    42ac:	19 95       	eicall
		temp_char = num & 0x0F;
    42ae:	6e 2d       	mov	r22, r14
    42b0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    42b2:	d8 01       	movw	r26, r16
    42b4:	ed 91       	ld	r30, X+
    42b6:	fc 91       	ld	r31, X
    42b8:	02 80       	ldd	r0, Z+2	; 0x02
    42ba:	f3 81       	ldd	r31, Z+3	; 0x03
    42bc:	e0 2d       	mov	r30, r0
    42be:	6a 30       	cpi	r22, 0x0A	; 10
    42c0:	10 f0       	brcs	.+4      	; 0x42c6 <_ZN8emstreamlsEh+0xc2>
    42c2:	69 5c       	subi	r22, 0xC9	; 201
    42c4:	01 c0       	rjmp	.+2      	; 0x42c8 <_ZN8emstreamlsEh+0xc4>
    42c6:	60 5d       	subi	r22, 0xD0	; 208
    42c8:	c8 01       	movw	r24, r16
    42ca:	19 95       	eicall
    42cc:	0e c0       	rjmp	.+28     	; 0x42ea <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    42ce:	50 e0       	ldi	r21, 0x00	; 0
    42d0:	be 01       	movw	r22, r28
    42d2:	6f 5f       	subi	r22, 0xFF	; 255
    42d4:	7f 4f       	sbci	r23, 0xFF	; 255
    42d6:	8e 2d       	mov	r24, r14
    42d8:	90 e0       	ldi	r25, 0x00	; 0
    42da:	0e 94 1b 28 	call	0x5036	; 0x5036 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    42de:	be 01       	movw	r22, r28
    42e0:	6f 5f       	subi	r22, 0xFF	; 255
    42e2:	7f 4f       	sbci	r23, 0xFF	; 255
    42e4:	c8 01       	movw	r24, r16
    42e6:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    42ea:	c8 01       	movw	r24, r16
    42ec:	29 96       	adiw	r28, 0x09	; 9
    42ee:	cd bf       	out	0x3d, r28	; 61
    42f0:	de bf       	out	0x3e, r29	; 62
    42f2:	df 91       	pop	r29
    42f4:	cf 91       	pop	r28
    42f6:	1f 91       	pop	r17
    42f8:	0f 91       	pop	r16
    42fa:	ff 90       	pop	r15
    42fc:	ef 90       	pop	r14
    42fe:	df 90       	pop	r13
    4300:	cf 90       	pop	r12
    4302:	08 95       	ret

00004304 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    4304:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4306:	50 96       	adiw	r26, 0x10	; 16
    4308:	ed 91       	ld	r30, X+
    430a:	fc 91       	ld	r31, X
    430c:	51 97       	sbiw	r26, 0x11	; 17
    430e:	80 81       	ld	r24, Z
    4310:	54 96       	adiw	r26, 0x14	; 20
    4312:	4c 91       	ld	r20, X
    4314:	54 97       	sbiw	r26, 0x14	; 20
    4316:	84 23       	and	r24, r20
    4318:	29 f0       	breq	.+10     	; 0x4324 <_ZN5rs2327putcharEc+0x20>
    431a:	09 c0       	rjmp	.+18     	; 0x432e <_ZN5rs2327putcharEc+0x2a>
    431c:	21 50       	subi	r18, 0x01	; 1
    431e:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4320:	19 f4       	brne	.+6      	; 0x4328 <_ZN5rs2327putcharEc+0x24>
    4322:	12 c0       	rjmp	.+36     	; 0x4348 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4324:	21 e2       	ldi	r18, 0x21	; 33
    4326:	3e e4       	ldi	r19, 0x4E	; 78
    4328:	90 81       	ld	r25, Z
    432a:	94 23       	and	r25, r20
    432c:	b9 f3       	breq	.-18     	; 0x431c <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    432e:	90 81       	ld	r25, Z
    4330:	56 96       	adiw	r26, 0x16	; 22
    4332:	8c 91       	ld	r24, X
    4334:	56 97       	sbiw	r26, 0x16	; 22
    4336:	89 2b       	or	r24, r25
    4338:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    433a:	1e 96       	adiw	r26, 0x0e	; 14
    433c:	ed 91       	ld	r30, X+
    433e:	fc 91       	ld	r31, X
    4340:	1f 97       	sbiw	r26, 0x0f	; 15
    4342:	60 83       	st	Z, r22
	return (true);
    4344:	81 e0       	ldi	r24, 0x01	; 1
    4346:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    4348:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    434a:	08 95       	ret

0000434c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    434c:	cf 93       	push	r28
    434e:	df 93       	push	r29
    4350:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    4352:	c1 8d       	ldd	r28, Z+25	; 0x19
    4354:	d2 8d       	ldd	r29, Z+26	; 0x1a
    4356:	28 81       	ld	r18, Y
    4358:	39 81       	ldd	r19, Y+1	; 0x01
    435a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    435c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    435e:	4d 91       	ld	r20, X+
    4360:	5c 91       	ld	r21, X
    4362:	24 17       	cp	r18, r20
    4364:	35 07       	cpc	r19, r21
    4366:	e9 f3       	breq	.-6      	; 0x4362 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    4368:	a7 89       	ldd	r26, Z+23	; 0x17
    436a:	b0 8d       	ldd	r27, Z+24	; 0x18
    436c:	0d 90       	ld	r0, X+
    436e:	bc 91       	ld	r27, X
    4370:	a0 2d       	mov	r26, r0
    4372:	a2 0f       	add	r26, r18
    4374:	b3 1f       	adc	r27, r19
    4376:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    4378:	2f 5f       	subi	r18, 0xFF	; 255
    437a:	3f 4f       	sbci	r19, 0xFF	; 255
    437c:	28 83       	st	Y, r18
    437e:	39 83       	std	Y+1, r19	; 0x01
    4380:	24 36       	cpi	r18, 0x64	; 100
    4382:	31 05       	cpc	r19, r1
    4384:	28 f0       	brcs	.+10     	; 0x4390 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    4386:	01 8c       	ldd	r0, Z+25	; 0x19
    4388:	f2 8d       	ldd	r31, Z+26	; 0x1a
    438a:	e0 2d       	mov	r30, r0
    438c:	10 82       	st	Z, r1
    438e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    4390:	90 e0       	ldi	r25, 0x00	; 0
    4392:	df 91       	pop	r29
    4394:	cf 91       	pop	r28
    4396:	08 95       	ret

00004398 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    4398:	cf 93       	push	r28
    439a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    439c:	ec 01       	movw	r28, r24
    439e:	a9 8d       	ldd	r26, Y+25	; 0x19
    43a0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    43a2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    43a4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    43a6:	81 e0       	ldi	r24, 0x01	; 1
    43a8:	4d 91       	ld	r20, X+
    43aa:	5c 91       	ld	r21, X
    43ac:	20 81       	ld	r18, Z
    43ae:	31 81       	ldd	r19, Z+1	; 0x01
    43b0:	42 17       	cp	r20, r18
    43b2:	53 07       	cpc	r21, r19
    43b4:	09 f4       	brne	.+2      	; 0x43b8 <_ZN5rs23214check_for_charEv+0x20>
    43b6:	80 e0       	ldi	r24, 0x00	; 0
}
    43b8:	df 91       	pop	r29
    43ba:	cf 91       	pop	r28
    43bc:	08 95       	ret

000043be <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    43be:	dc 01       	movw	r26, r24
    43c0:	ed 91       	ld	r30, X+
    43c2:	fc 91       	ld	r31, X
    43c4:	02 80       	ldd	r0, Z+2	; 0x02
    43c6:	f3 81       	ldd	r31, Z+3	; 0x03
    43c8:	e0 2d       	mov	r30, r0
    43ca:	6c e0       	ldi	r22, 0x0C	; 12
    43cc:	19 95       	eicall
    43ce:	08 95       	ret

000043d0 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    43d0:	ef 92       	push	r14
    43d2:	ff 92       	push	r15
    43d4:	0f 93       	push	r16
    43d6:	1f 93       	push	r17
    43d8:	cf 93       	push	r28
    43da:	df 93       	push	r29
    43dc:	ec 01       	movw	r28, r24
    43de:	7b 01       	movw	r14, r22
    43e0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    43e2:	0e 94 c3 1f 	call	0x3f86	; 0x3f86 <_ZN8emstreamC1Ev>
    43e6:	a8 01       	movw	r20, r16
    43e8:	b7 01       	movw	r22, r14
    43ea:	ce 01       	movw	r24, r28
    43ec:	08 96       	adiw	r24, 0x08	; 8
    43ee:	0e 94 24 1f 	call	0x3e48	; 0x3e48 <_ZN7base232C1EjP12USART_struct>
    43f2:	88 e5       	ldi	r24, 0x58	; 88
    43f4:	92 e2       	ldi	r25, 0x22	; 34
    43f6:	88 83       	st	Y, r24
    43f8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    43fa:	00 3a       	cpi	r16, 0xA0	; 160
    43fc:	88 e0       	ldi	r24, 0x08	; 8
    43fe:	18 07       	cpc	r17, r24
    4400:	69 f4       	brne	.+26     	; 0x441c <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4402:	82 e6       	ldi	r24, 0x62	; 98
    4404:	93 e3       	ldi	r25, 0x33	; 51
    4406:	8f 8b       	std	Y+23, r24	; 0x17
    4408:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    440a:	88 e5       	ldi	r24, 0x58	; 88
    440c:	93 e3       	ldi	r25, 0x33	; 51
    440e:	89 8f       	std	Y+25, r24	; 0x19
    4410:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4412:	8e e4       	ldi	r24, 0x4E	; 78
    4414:	93 e3       	ldi	r25, 0x33	; 51
    4416:	8b 8f       	std	Y+27, r24	; 0x1b
    4418:	9c 8f       	std	Y+28, r25	; 0x1c
    441a:	42 c0       	rjmp	.+132    	; 0x44a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    441c:	00 3b       	cpi	r16, 0xB0	; 176
    441e:	e8 e0       	ldi	r30, 0x08	; 8
    4420:	1e 07       	cpc	r17, r30
    4422:	69 f4       	brne	.+26     	; 0x443e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    4424:	80 e6       	ldi	r24, 0x60	; 96
    4426:	93 e3       	ldi	r25, 0x33	; 51
    4428:	8f 8b       	std	Y+23, r24	; 0x17
    442a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    442c:	86 e5       	ldi	r24, 0x56	; 86
    442e:	93 e3       	ldi	r25, 0x33	; 51
    4430:	89 8f       	std	Y+25, r24	; 0x19
    4432:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    4434:	8c e4       	ldi	r24, 0x4C	; 76
    4436:	93 e3       	ldi	r25, 0x33	; 51
    4438:	8b 8f       	std	Y+27, r24	; 0x1b
    443a:	9c 8f       	std	Y+28, r25	; 0x1c
    443c:	31 c0       	rjmp	.+98     	; 0x44a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    443e:	00 3a       	cpi	r16, 0xA0	; 160
    4440:	f9 e0       	ldi	r31, 0x09	; 9
    4442:	1f 07       	cpc	r17, r31
    4444:	69 f4       	brne	.+26     	; 0x4460 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    4446:	8e e5       	ldi	r24, 0x5E	; 94
    4448:	93 e3       	ldi	r25, 0x33	; 51
    444a:	8f 8b       	std	Y+23, r24	; 0x17
    444c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    444e:	84 e5       	ldi	r24, 0x54	; 84
    4450:	93 e3       	ldi	r25, 0x33	; 51
    4452:	89 8f       	std	Y+25, r24	; 0x19
    4454:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    4456:	8a e4       	ldi	r24, 0x4A	; 74
    4458:	93 e3       	ldi	r25, 0x33	; 51
    445a:	8b 8f       	std	Y+27, r24	; 0x1b
    445c:	9c 8f       	std	Y+28, r25	; 0x1c
    445e:	20 c0       	rjmp	.+64     	; 0x44a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    4460:	00 3b       	cpi	r16, 0xB0	; 176
    4462:	89 e0       	ldi	r24, 0x09	; 9
    4464:	18 07       	cpc	r17, r24
    4466:	69 f4       	brne	.+26     	; 0x4482 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    4468:	8c e5       	ldi	r24, 0x5C	; 92
    446a:	93 e3       	ldi	r25, 0x33	; 51
    446c:	8f 8b       	std	Y+23, r24	; 0x17
    446e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    4470:	82 e5       	ldi	r24, 0x52	; 82
    4472:	93 e3       	ldi	r25, 0x33	; 51
    4474:	89 8f       	std	Y+25, r24	; 0x19
    4476:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    4478:	88 e4       	ldi	r24, 0x48	; 72
    447a:	93 e3       	ldi	r25, 0x33	; 51
    447c:	8b 8f       	std	Y+27, r24	; 0x1b
    447e:	9c 8f       	std	Y+28, r25	; 0x1c
    4480:	0f c0       	rjmp	.+30     	; 0x44a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    4482:	00 3a       	cpi	r16, 0xA0	; 160
    4484:	1a 40       	sbci	r17, 0x0A	; 10
    4486:	61 f4       	brne	.+24     	; 0x44a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    4488:	8a e5       	ldi	r24, 0x5A	; 90
    448a:	93 e3       	ldi	r25, 0x33	; 51
    448c:	8f 8b       	std	Y+23, r24	; 0x17
    448e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    4490:	80 e5       	ldi	r24, 0x50	; 80
    4492:	93 e3       	ldi	r25, 0x33	; 51
    4494:	89 8f       	std	Y+25, r24	; 0x19
    4496:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    4498:	86 e4       	ldi	r24, 0x46	; 70
    449a:	93 e3       	ldi	r25, 0x33	; 51
    449c:	8b 8f       	std	Y+27, r24	; 0x1b
    449e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    44a0:	0f 89       	ldd	r16, Y+23	; 0x17
    44a2:	18 8d       	ldd	r17, Y+24	; 0x18
    44a4:	84 e6       	ldi	r24, 0x64	; 100
    44a6:	90 e0       	ldi	r25, 0x00	; 0
    44a8:	0e 94 20 1f 	call	0x3e40	; 0x3e40 <_Znaj>
    44ac:	f8 01       	movw	r30, r16
    44ae:	80 83       	st	Z, r24
    44b0:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    44b2:	e9 8d       	ldd	r30, Y+25	; 0x19
    44b4:	fa 8d       	ldd	r31, Y+26	; 0x1a
    44b6:	10 82       	st	Z, r1
    44b8:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    44ba:	eb 8d       	ldd	r30, Y+27	; 0x1b
    44bc:	fc 8d       	ldd	r31, Y+28	; 0x1c
    44be:	10 82       	st	Z, r1
    44c0:	11 82       	std	Z+1, r1	; 0x01
}
    44c2:	df 91       	pop	r29
    44c4:	cf 91       	pop	r28
    44c6:	1f 91       	pop	r17
    44c8:	0f 91       	pop	r16
    44ca:	ff 90       	pop	r15
    44cc:	ef 90       	pop	r14
    44ce:	08 95       	ret

000044d0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    44d0:	1f 92       	push	r1
    44d2:	0f 92       	push	r0
    44d4:	0f b6       	in	r0, 0x3f	; 63
    44d6:	0f 92       	push	r0
    44d8:	11 24       	eor	r1, r1
    44da:	08 b6       	in	r0, 0x38	; 56
    44dc:	0f 92       	push	r0
    44de:	18 be       	out	0x38, r1	; 56
    44e0:	0b b6       	in	r0, 0x3b	; 59
    44e2:	0f 92       	push	r0
    44e4:	1b be       	out	0x3b, r1	; 59
    44e6:	2f 93       	push	r18
    44e8:	3f 93       	push	r19
    44ea:	8f 93       	push	r24
    44ec:	9f 93       	push	r25
    44ee:	ef 93       	push	r30
    44f0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    44f2:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    44f6:	e0 91 62 33 	lds	r30, 0x3362	; 0x803362 <rcvC0_buffer>
    44fa:	f0 91 63 33 	lds	r31, 0x3363	; 0x803363 <rcvC0_buffer+0x1>
    44fe:	80 91 4e 33 	lds	r24, 0x334E	; 0x80334e <rcvC0_write_index>
    4502:	90 91 4f 33 	lds	r25, 0x334F	; 0x80334f <rcvC0_write_index+0x1>
    4506:	e8 0f       	add	r30, r24
    4508:	f9 1f       	adc	r31, r25
    450a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    450c:	80 91 4e 33 	lds	r24, 0x334E	; 0x80334e <rcvC0_write_index>
    4510:	90 91 4f 33 	lds	r25, 0x334F	; 0x80334f <rcvC0_write_index+0x1>
    4514:	01 96       	adiw	r24, 0x01	; 1
    4516:	84 36       	cpi	r24, 0x64	; 100
    4518:	91 05       	cpc	r25, r1
    451a:	60 f4       	brcc	.+24     	; 0x4534 <__vector_25+0x64>
    451c:	80 93 4e 33 	sts	0x334E, r24	; 0x80334e <rcvC0_write_index>
    4520:	90 93 4f 33 	sts	0x334F, r25	; 0x80334f <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4524:	20 91 58 33 	lds	r18, 0x3358	; 0x803358 <rcvC0_read_index>
    4528:	30 91 59 33 	lds	r19, 0x3359	; 0x803359 <rcvC0_read_index+0x1>
    452c:	82 17       	cp	r24, r18
    452e:	93 07       	cpc	r25, r19
    4530:	f1 f4       	brne	.+60     	; 0x456e <__vector_25+0x9e>
    4532:	0c c0       	rjmp	.+24     	; 0x454c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    4534:	10 92 4e 33 	sts	0x334E, r1	; 0x80334e <rcvC0_write_index>
    4538:	10 92 4f 33 	sts	0x334F, r1	; 0x80334f <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    453c:	80 91 58 33 	lds	r24, 0x3358	; 0x803358 <rcvC0_read_index>
    4540:	90 91 59 33 	lds	r25, 0x3359	; 0x803359 <rcvC0_read_index+0x1>
    4544:	18 16       	cp	r1, r24
    4546:	19 06       	cpc	r1, r25
    4548:	91 f4       	brne	.+36     	; 0x456e <__vector_25+0x9e>
    454a:	0e c0       	rjmp	.+28     	; 0x4568 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    454c:	01 96       	adiw	r24, 0x01	; 1
    454e:	84 36       	cpi	r24, 0x64	; 100
    4550:	91 05       	cpc	r25, r1
    4552:	28 f4       	brcc	.+10     	; 0x455e <__vector_25+0x8e>
    4554:	80 93 58 33 	sts	0x3358, r24	; 0x803358 <rcvC0_read_index>
    4558:	90 93 59 33 	sts	0x3359, r25	; 0x803359 <rcvC0_read_index+0x1>
    455c:	08 c0       	rjmp	.+16     	; 0x456e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    455e:	10 92 58 33 	sts	0x3358, r1	; 0x803358 <rcvC0_read_index>
    4562:	10 92 59 33 	sts	0x3359, r1	; 0x803359 <rcvC0_read_index+0x1>
}
    4566:	03 c0       	rjmp	.+6      	; 0x456e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    4568:	81 e0       	ldi	r24, 0x01	; 1
    456a:	90 e0       	ldi	r25, 0x00	; 0
    456c:	f3 cf       	rjmp	.-26     	; 0x4554 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    456e:	ff 91       	pop	r31
    4570:	ef 91       	pop	r30
    4572:	9f 91       	pop	r25
    4574:	8f 91       	pop	r24
    4576:	3f 91       	pop	r19
    4578:	2f 91       	pop	r18
    457a:	0f 90       	pop	r0
    457c:	0b be       	out	0x3b, r0	; 59
    457e:	0f 90       	pop	r0
    4580:	08 be       	out	0x38, r0	; 56
    4582:	0f 90       	pop	r0
    4584:	0f be       	out	0x3f, r0	; 63
    4586:	0f 90       	pop	r0
    4588:	1f 90       	pop	r1
    458a:	18 95       	reti

0000458c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    458c:	1f 92       	push	r1
    458e:	0f 92       	push	r0
    4590:	0f b6       	in	r0, 0x3f	; 63
    4592:	0f 92       	push	r0
    4594:	11 24       	eor	r1, r1
    4596:	08 b6       	in	r0, 0x38	; 56
    4598:	0f 92       	push	r0
    459a:	18 be       	out	0x38, r1	; 56
    459c:	0b b6       	in	r0, 0x3b	; 59
    459e:	0f 92       	push	r0
    45a0:	1b be       	out	0x3b, r1	; 59
    45a2:	2f 93       	push	r18
    45a4:	3f 93       	push	r19
    45a6:	8f 93       	push	r24
    45a8:	9f 93       	push	r25
    45aa:	ef 93       	push	r30
    45ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    45ae:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    45b2:	e0 91 60 33 	lds	r30, 0x3360	; 0x803360 <rcvC1_buffer>
    45b6:	f0 91 61 33 	lds	r31, 0x3361	; 0x803361 <rcvC1_buffer+0x1>
    45ba:	80 91 4c 33 	lds	r24, 0x334C	; 0x80334c <rcvC1_write_index>
    45be:	90 91 4d 33 	lds	r25, 0x334D	; 0x80334d <rcvC1_write_index+0x1>
    45c2:	e8 0f       	add	r30, r24
    45c4:	f9 1f       	adc	r31, r25
    45c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    45c8:	80 91 4c 33 	lds	r24, 0x334C	; 0x80334c <rcvC1_write_index>
    45cc:	90 91 4d 33 	lds	r25, 0x334D	; 0x80334d <rcvC1_write_index+0x1>
    45d0:	01 96       	adiw	r24, 0x01	; 1
    45d2:	84 36       	cpi	r24, 0x64	; 100
    45d4:	91 05       	cpc	r25, r1
    45d6:	60 f4       	brcc	.+24     	; 0x45f0 <__vector_28+0x64>
    45d8:	80 93 4c 33 	sts	0x334C, r24	; 0x80334c <rcvC1_write_index>
    45dc:	90 93 4d 33 	sts	0x334D, r25	; 0x80334d <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    45e0:	20 91 56 33 	lds	r18, 0x3356	; 0x803356 <rcvC1_read_index>
    45e4:	30 91 57 33 	lds	r19, 0x3357	; 0x803357 <rcvC1_read_index+0x1>
    45e8:	82 17       	cp	r24, r18
    45ea:	93 07       	cpc	r25, r19
    45ec:	f1 f4       	brne	.+60     	; 0x462a <__vector_28+0x9e>
    45ee:	0c c0       	rjmp	.+24     	; 0x4608 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    45f0:	10 92 4c 33 	sts	0x334C, r1	; 0x80334c <rcvC1_write_index>
    45f4:	10 92 4d 33 	sts	0x334D, r1	; 0x80334d <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    45f8:	80 91 56 33 	lds	r24, 0x3356	; 0x803356 <rcvC1_read_index>
    45fc:	90 91 57 33 	lds	r25, 0x3357	; 0x803357 <rcvC1_read_index+0x1>
    4600:	18 16       	cp	r1, r24
    4602:	19 06       	cpc	r1, r25
    4604:	91 f4       	brne	.+36     	; 0x462a <__vector_28+0x9e>
    4606:	0e c0       	rjmp	.+28     	; 0x4624 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4608:	01 96       	adiw	r24, 0x01	; 1
    460a:	84 36       	cpi	r24, 0x64	; 100
    460c:	91 05       	cpc	r25, r1
    460e:	28 f4       	brcc	.+10     	; 0x461a <__vector_28+0x8e>
    4610:	80 93 56 33 	sts	0x3356, r24	; 0x803356 <rcvC1_read_index>
    4614:	90 93 57 33 	sts	0x3357, r25	; 0x803357 <rcvC1_read_index+0x1>
    4618:	08 c0       	rjmp	.+16     	; 0x462a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    461a:	10 92 56 33 	sts	0x3356, r1	; 0x803356 <rcvC1_read_index>
    461e:	10 92 57 33 	sts	0x3357, r1	; 0x803357 <rcvC1_read_index+0x1>
}
    4622:	03 c0       	rjmp	.+6      	; 0x462a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4624:	81 e0       	ldi	r24, 0x01	; 1
    4626:	90 e0       	ldi	r25, 0x00	; 0
    4628:	f3 cf       	rjmp	.-26     	; 0x4610 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    462a:	ff 91       	pop	r31
    462c:	ef 91       	pop	r30
    462e:	9f 91       	pop	r25
    4630:	8f 91       	pop	r24
    4632:	3f 91       	pop	r19
    4634:	2f 91       	pop	r18
    4636:	0f 90       	pop	r0
    4638:	0b be       	out	0x3b, r0	; 59
    463a:	0f 90       	pop	r0
    463c:	08 be       	out	0x38, r0	; 56
    463e:	0f 90       	pop	r0
    4640:	0f be       	out	0x3f, r0	; 63
    4642:	0f 90       	pop	r0
    4644:	1f 90       	pop	r1
    4646:	18 95       	reti

00004648 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    4648:	1f 92       	push	r1
    464a:	0f 92       	push	r0
    464c:	0f b6       	in	r0, 0x3f	; 63
    464e:	0f 92       	push	r0
    4650:	11 24       	eor	r1, r1
    4652:	08 b6       	in	r0, 0x38	; 56
    4654:	0f 92       	push	r0
    4656:	18 be       	out	0x38, r1	; 56
    4658:	0b b6       	in	r0, 0x3b	; 59
    465a:	0f 92       	push	r0
    465c:	1b be       	out	0x3b, r1	; 59
    465e:	2f 93       	push	r18
    4660:	3f 93       	push	r19
    4662:	8f 93       	push	r24
    4664:	9f 93       	push	r25
    4666:	ef 93       	push	r30
    4668:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    466a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    466e:	e0 91 5e 33 	lds	r30, 0x335E	; 0x80335e <rcvD0_buffer>
    4672:	f0 91 5f 33 	lds	r31, 0x335F	; 0x80335f <rcvD0_buffer+0x1>
    4676:	80 91 4e 33 	lds	r24, 0x334E	; 0x80334e <rcvC0_write_index>
    467a:	90 91 4f 33 	lds	r25, 0x334F	; 0x80334f <rcvC0_write_index+0x1>
    467e:	e8 0f       	add	r30, r24
    4680:	f9 1f       	adc	r31, r25
    4682:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    4684:	80 91 4a 33 	lds	r24, 0x334A	; 0x80334a <rcvD0_write_index>
    4688:	90 91 4b 33 	lds	r25, 0x334B	; 0x80334b <rcvD0_write_index+0x1>
    468c:	01 96       	adiw	r24, 0x01	; 1
    468e:	84 36       	cpi	r24, 0x64	; 100
    4690:	91 05       	cpc	r25, r1
    4692:	60 f4       	brcc	.+24     	; 0x46ac <__vector_88+0x64>
    4694:	80 93 4a 33 	sts	0x334A, r24	; 0x80334a <rcvD0_write_index>
    4698:	90 93 4b 33 	sts	0x334B, r25	; 0x80334b <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    469c:	20 91 54 33 	lds	r18, 0x3354	; 0x803354 <rcvD0_read_index>
    46a0:	30 91 55 33 	lds	r19, 0x3355	; 0x803355 <rcvD0_read_index+0x1>
    46a4:	82 17       	cp	r24, r18
    46a6:	93 07       	cpc	r25, r19
    46a8:	f1 f4       	brne	.+60     	; 0x46e6 <__vector_88+0x9e>
    46aa:	0c c0       	rjmp	.+24     	; 0x46c4 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    46ac:	10 92 4a 33 	sts	0x334A, r1	; 0x80334a <rcvD0_write_index>
    46b0:	10 92 4b 33 	sts	0x334B, r1	; 0x80334b <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    46b4:	80 91 54 33 	lds	r24, 0x3354	; 0x803354 <rcvD0_read_index>
    46b8:	90 91 55 33 	lds	r25, 0x3355	; 0x803355 <rcvD0_read_index+0x1>
    46bc:	18 16       	cp	r1, r24
    46be:	19 06       	cpc	r1, r25
    46c0:	91 f4       	brne	.+36     	; 0x46e6 <__vector_88+0x9e>
    46c2:	0e c0       	rjmp	.+28     	; 0x46e0 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    46c4:	01 96       	adiw	r24, 0x01	; 1
    46c6:	84 36       	cpi	r24, 0x64	; 100
    46c8:	91 05       	cpc	r25, r1
    46ca:	28 f4       	brcc	.+10     	; 0x46d6 <__vector_88+0x8e>
    46cc:	80 93 54 33 	sts	0x3354, r24	; 0x803354 <rcvD0_read_index>
    46d0:	90 93 55 33 	sts	0x3355, r25	; 0x803355 <rcvD0_read_index+0x1>
    46d4:	08 c0       	rjmp	.+16     	; 0x46e6 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    46d6:	10 92 54 33 	sts	0x3354, r1	; 0x803354 <rcvD0_read_index>
    46da:	10 92 55 33 	sts	0x3355, r1	; 0x803355 <rcvD0_read_index+0x1>
}
    46de:	03 c0       	rjmp	.+6      	; 0x46e6 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    46e0:	81 e0       	ldi	r24, 0x01	; 1
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	f3 cf       	rjmp	.-26     	; 0x46cc <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    46e6:	ff 91       	pop	r31
    46e8:	ef 91       	pop	r30
    46ea:	9f 91       	pop	r25
    46ec:	8f 91       	pop	r24
    46ee:	3f 91       	pop	r19
    46f0:	2f 91       	pop	r18
    46f2:	0f 90       	pop	r0
    46f4:	0b be       	out	0x3b, r0	; 59
    46f6:	0f 90       	pop	r0
    46f8:	08 be       	out	0x38, r0	; 56
    46fa:	0f 90       	pop	r0
    46fc:	0f be       	out	0x3f, r0	; 63
    46fe:	0f 90       	pop	r0
    4700:	1f 90       	pop	r1
    4702:	18 95       	reti

00004704 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4704:	1f 92       	push	r1
    4706:	0f 92       	push	r0
    4708:	0f b6       	in	r0, 0x3f	; 63
    470a:	0f 92       	push	r0
    470c:	11 24       	eor	r1, r1
    470e:	08 b6       	in	r0, 0x38	; 56
    4710:	0f 92       	push	r0
    4712:	18 be       	out	0x38, r1	; 56
    4714:	0b b6       	in	r0, 0x3b	; 59
    4716:	0f 92       	push	r0
    4718:	1b be       	out	0x3b, r1	; 59
    471a:	2f 93       	push	r18
    471c:	3f 93       	push	r19
    471e:	8f 93       	push	r24
    4720:	9f 93       	push	r25
    4722:	ef 93       	push	r30
    4724:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    4726:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    472a:	e0 91 5c 33 	lds	r30, 0x335C	; 0x80335c <rcvD1_buffer>
    472e:	f0 91 5d 33 	lds	r31, 0x335D	; 0x80335d <rcvD1_buffer+0x1>
    4732:	80 91 48 33 	lds	r24, 0x3348	; 0x803348 <rcvD1_write_index>
    4736:	90 91 49 33 	lds	r25, 0x3349	; 0x803349 <rcvD1_write_index+0x1>
    473a:	e8 0f       	add	r30, r24
    473c:	f9 1f       	adc	r31, r25
    473e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4740:	80 91 48 33 	lds	r24, 0x3348	; 0x803348 <rcvD1_write_index>
    4744:	90 91 49 33 	lds	r25, 0x3349	; 0x803349 <rcvD1_write_index+0x1>
    4748:	01 96       	adiw	r24, 0x01	; 1
    474a:	84 36       	cpi	r24, 0x64	; 100
    474c:	91 05       	cpc	r25, r1
    474e:	60 f4       	brcc	.+24     	; 0x4768 <__vector_91+0x64>
    4750:	80 93 48 33 	sts	0x3348, r24	; 0x803348 <rcvD1_write_index>
    4754:	90 93 49 33 	sts	0x3349, r25	; 0x803349 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4758:	20 91 52 33 	lds	r18, 0x3352	; 0x803352 <rcvD1_read_index>
    475c:	30 91 53 33 	lds	r19, 0x3353	; 0x803353 <rcvD1_read_index+0x1>
    4760:	82 17       	cp	r24, r18
    4762:	93 07       	cpc	r25, r19
    4764:	f1 f4       	brne	.+60     	; 0x47a2 <__vector_91+0x9e>
    4766:	0c c0       	rjmp	.+24     	; 0x4780 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    4768:	10 92 48 33 	sts	0x3348, r1	; 0x803348 <rcvD1_write_index>
    476c:	10 92 49 33 	sts	0x3349, r1	; 0x803349 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    4770:	80 91 52 33 	lds	r24, 0x3352	; 0x803352 <rcvD1_read_index>
    4774:	90 91 53 33 	lds	r25, 0x3353	; 0x803353 <rcvD1_read_index+0x1>
    4778:	18 16       	cp	r1, r24
    477a:	19 06       	cpc	r1, r25
    477c:	91 f4       	brne	.+36     	; 0x47a2 <__vector_91+0x9e>
    477e:	0e c0       	rjmp	.+28     	; 0x479c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4780:	01 96       	adiw	r24, 0x01	; 1
    4782:	84 36       	cpi	r24, 0x64	; 100
    4784:	91 05       	cpc	r25, r1
    4786:	28 f4       	brcc	.+10     	; 0x4792 <__vector_91+0x8e>
    4788:	80 93 52 33 	sts	0x3352, r24	; 0x803352 <rcvD1_read_index>
    478c:	90 93 53 33 	sts	0x3353, r25	; 0x803353 <rcvD1_read_index+0x1>
    4790:	08 c0       	rjmp	.+16     	; 0x47a2 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    4792:	10 92 52 33 	sts	0x3352, r1	; 0x803352 <rcvD1_read_index>
    4796:	10 92 53 33 	sts	0x3353, r1	; 0x803353 <rcvD1_read_index+0x1>
}
    479a:	03 c0       	rjmp	.+6      	; 0x47a2 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    479c:	81 e0       	ldi	r24, 0x01	; 1
    479e:	90 e0       	ldi	r25, 0x00	; 0
    47a0:	f3 cf       	rjmp	.-26     	; 0x4788 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    47a2:	ff 91       	pop	r31
    47a4:	ef 91       	pop	r30
    47a6:	9f 91       	pop	r25
    47a8:	8f 91       	pop	r24
    47aa:	3f 91       	pop	r19
    47ac:	2f 91       	pop	r18
    47ae:	0f 90       	pop	r0
    47b0:	0b be       	out	0x3b, r0	; 59
    47b2:	0f 90       	pop	r0
    47b4:	08 be       	out	0x38, r0	; 56
    47b6:	0f 90       	pop	r0
    47b8:	0f be       	out	0x3f, r0	; 63
    47ba:	0f 90       	pop	r0
    47bc:	1f 90       	pop	r1
    47be:	18 95       	reti

000047c0 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    47c0:	1f 92       	push	r1
    47c2:	0f 92       	push	r0
    47c4:	0f b6       	in	r0, 0x3f	; 63
    47c6:	0f 92       	push	r0
    47c8:	11 24       	eor	r1, r1
    47ca:	08 b6       	in	r0, 0x38	; 56
    47cc:	0f 92       	push	r0
    47ce:	18 be       	out	0x38, r1	; 56
    47d0:	0b b6       	in	r0, 0x3b	; 59
    47d2:	0f 92       	push	r0
    47d4:	1b be       	out	0x3b, r1	; 59
    47d6:	2f 93       	push	r18
    47d8:	3f 93       	push	r19
    47da:	8f 93       	push	r24
    47dc:	9f 93       	push	r25
    47de:	ef 93       	push	r30
    47e0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    47e2:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    47e6:	e0 91 5a 33 	lds	r30, 0x335A	; 0x80335a <rcvE0_buffer>
    47ea:	f0 91 5b 33 	lds	r31, 0x335B	; 0x80335b <rcvE0_buffer+0x1>
    47ee:	80 91 46 33 	lds	r24, 0x3346	; 0x803346 <rcvE0_write_index>
    47f2:	90 91 47 33 	lds	r25, 0x3347	; 0x803347 <rcvE0_write_index+0x1>
    47f6:	e8 0f       	add	r30, r24
    47f8:	f9 1f       	adc	r31, r25
    47fa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    47fc:	80 91 46 33 	lds	r24, 0x3346	; 0x803346 <rcvE0_write_index>
    4800:	90 91 47 33 	lds	r25, 0x3347	; 0x803347 <rcvE0_write_index+0x1>
    4804:	01 96       	adiw	r24, 0x01	; 1
    4806:	84 36       	cpi	r24, 0x64	; 100
    4808:	91 05       	cpc	r25, r1
    480a:	60 f4       	brcc	.+24     	; 0x4824 <__vector_58+0x64>
    480c:	80 93 46 33 	sts	0x3346, r24	; 0x803346 <rcvE0_write_index>
    4810:	90 93 47 33 	sts	0x3347, r25	; 0x803347 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4814:	20 91 50 33 	lds	r18, 0x3350	; 0x803350 <rcvE0_read_index>
    4818:	30 91 51 33 	lds	r19, 0x3351	; 0x803351 <rcvE0_read_index+0x1>
    481c:	82 17       	cp	r24, r18
    481e:	93 07       	cpc	r25, r19
    4820:	f1 f4       	brne	.+60     	; 0x485e <__vector_58+0x9e>
    4822:	0c c0       	rjmp	.+24     	; 0x483c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4824:	10 92 46 33 	sts	0x3346, r1	; 0x803346 <rcvE0_write_index>
    4828:	10 92 47 33 	sts	0x3347, r1	; 0x803347 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    482c:	80 91 50 33 	lds	r24, 0x3350	; 0x803350 <rcvE0_read_index>
    4830:	90 91 51 33 	lds	r25, 0x3351	; 0x803351 <rcvE0_read_index+0x1>
    4834:	18 16       	cp	r1, r24
    4836:	19 06       	cpc	r1, r25
    4838:	91 f4       	brne	.+36     	; 0x485e <__vector_58+0x9e>
    483a:	0e c0       	rjmp	.+28     	; 0x4858 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    483c:	01 96       	adiw	r24, 0x01	; 1
    483e:	84 36       	cpi	r24, 0x64	; 100
    4840:	91 05       	cpc	r25, r1
    4842:	28 f4       	brcc	.+10     	; 0x484e <__vector_58+0x8e>
    4844:	80 93 50 33 	sts	0x3350, r24	; 0x803350 <rcvE0_read_index>
    4848:	90 93 51 33 	sts	0x3351, r25	; 0x803351 <rcvE0_read_index+0x1>
    484c:	08 c0       	rjmp	.+16     	; 0x485e <__vector_58+0x9e>
	rcvE0_read_index = 0;
    484e:	10 92 50 33 	sts	0x3350, r1	; 0x803350 <rcvE0_read_index>
    4852:	10 92 51 33 	sts	0x3351, r1	; 0x803351 <rcvE0_read_index+0x1>
}
    4856:	03 c0       	rjmp	.+6      	; 0x485e <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4858:	81 e0       	ldi	r24, 0x01	; 1
    485a:	90 e0       	ldi	r25, 0x00	; 0
    485c:	f3 cf       	rjmp	.-26     	; 0x4844 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    485e:	ff 91       	pop	r31
    4860:	ef 91       	pop	r30
    4862:	9f 91       	pop	r25
    4864:	8f 91       	pop	r24
    4866:	3f 91       	pop	r19
    4868:	2f 91       	pop	r18
    486a:	0f 90       	pop	r0
    486c:	0b be       	out	0x3b, r0	; 59
    486e:	0f 90       	pop	r0
    4870:	08 be       	out	0x38, r0	; 56
    4872:	0f 90       	pop	r0
    4874:	0f be       	out	0x3f, r0	; 63
    4876:	0f 90       	pop	r0
    4878:	1f 90       	pop	r1
    487a:	18 95       	reti

0000487c <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    487c:	fc 01       	movw	r30, r24
    487e:	84 81       	ldd	r24, Z+4	; 0x04
    4880:	95 81       	ldd	r25, Z+5	; 0x05
    4882:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
		}
    4886:	90 e0       	ldi	r25, 0x00	; 0
    4888:	08 95       	ret

0000488a <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    488a:	fc 01       	movw	r30, r24
    488c:	84 81       	ldd	r24, Z+4	; 0x04
    488e:	95 81       	ldd	r25, Z+5	; 0x05
    4890:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    4894:	91 e0       	ldi	r25, 0x01	; 1
    4896:	81 11       	cpse	r24, r1
    4898:	01 c0       	rjmp	.+2      	; 0x489c <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    489a:	90 e0       	ldi	r25, 0x00	; 0
		}
    489c:	89 2f       	mov	r24, r25
    489e:	08 95       	ret

000048a0 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    48a0:	fc 01       	movw	r30, r24
    48a2:	84 81       	ldd	r24, Z+4	; 0x04
    48a4:	95 81       	ldd	r25, Z+5	; 0x05
    48a6:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    48aa:	91 e0       	ldi	r25, 0x01	; 1
    48ac:	81 11       	cpse	r24, r1
    48ae:	90 e0       	ldi	r25, 0x00	; 0
		}
    48b0:	89 2f       	mov	r24, r25
    48b2:	08 95       	ret

000048b4 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    48b4:	fc 01       	movw	r30, r24
    48b6:	84 81       	ldd	r24, Z+4	; 0x04
    48b8:	95 81       	ldd	r25, Z+5	; 0x05
    48ba:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
		}
    48be:	90 e0       	ldi	r25, 0x00	; 0
    48c0:	08 95       	ret

000048c2 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    48c2:	fc 01       	movw	r30, r24
    48c4:	84 81       	ldd	r24, Z+4	; 0x04
    48c6:	95 81       	ldd	r25, Z+5	; 0x05
    48c8:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    48cc:	91 e0       	ldi	r25, 0x01	; 1
    48ce:	81 11       	cpse	r24, r1
    48d0:	01 c0       	rjmp	.+2      	; 0x48d4 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    48d2:	90 e0       	ldi	r25, 0x00	; 0
		}
    48d4:	89 2f       	mov	r24, r25
    48d6:	08 95       	ret

000048d8 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    48d8:	fc 01       	movw	r30, r24
    48da:	84 81       	ldd	r24, Z+4	; 0x04
    48dc:	95 81       	ldd	r25, Z+5	; 0x05
    48de:	0e 94 33 15 	call	0x2a66	; 0x2a66 <uxQueueMessagesWaitingFromISR>
    48e2:	91 e0       	ldi	r25, 0x01	; 1
    48e4:	81 11       	cpse	r24, r1
    48e6:	90 e0       	ldi	r25, 0x00	; 0
		}
    48e8:	89 2f       	mov	r24, r25
    48ea:	08 95       	ret

000048ec <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    48ec:	fc 01       	movw	r30, r24
    48ee:	84 81       	ldd	r24, Z+4	; 0x04
    48f0:	95 81       	ldd	r25, Z+5	; 0x05
    48f2:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
		}
    48f6:	90 e0       	ldi	r25, 0x00	; 0
    48f8:	08 95       	ret

000048fa <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    48fa:	fc 01       	movw	r30, r24
    48fc:	84 81       	ldd	r24, Z+4	; 0x04
    48fe:	95 81       	ldd	r25, Z+5	; 0x05
    4900:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    4904:	91 e0       	ldi	r25, 0x01	; 1
    4906:	81 11       	cpse	r24, r1
    4908:	01 c0       	rjmp	.+2      	; 0x490c <_ZN9frt_queueIjE9not_emptyEv+0x12>
    490a:	90 e0       	ldi	r25, 0x00	; 0
		}
    490c:	89 2f       	mov	r24, r25
    490e:	08 95       	ret

00004910 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4910:	fc 01       	movw	r30, r24
    4912:	84 81       	ldd	r24, Z+4	; 0x04
    4914:	95 81       	ldd	r25, Z+5	; 0x05
    4916:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    491a:	91 e0       	ldi	r25, 0x01	; 1
    491c:	81 11       	cpse	r24, r1
    491e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4920:	89 2f       	mov	r24, r25
    4922:	08 95       	ret

00004924 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4924:	fc 01       	movw	r30, r24
    4926:	84 81       	ldd	r24, Z+4	; 0x04
    4928:	95 81       	ldd	r25, Z+5	; 0x05
    492a:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
		}
    492e:	90 e0       	ldi	r25, 0x00	; 0
    4930:	08 95       	ret

00004932 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4932:	fc 01       	movw	r30, r24
    4934:	84 81       	ldd	r24, Z+4	; 0x04
    4936:	95 81       	ldd	r25, Z+5	; 0x05
    4938:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    493c:	91 e0       	ldi	r25, 0x01	; 1
    493e:	81 11       	cpse	r24, r1
    4940:	01 c0       	rjmp	.+2      	; 0x4944 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4942:	90 e0       	ldi	r25, 0x00	; 0
		}
    4944:	89 2f       	mov	r24, r25
    4946:	08 95       	ret

00004948 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4948:	fc 01       	movw	r30, r24
    494a:	84 81       	ldd	r24, Z+4	; 0x04
    494c:	95 81       	ldd	r25, Z+5	; 0x05
    494e:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <uxQueueMessagesWaiting>
    4952:	91 e0       	ldi	r25, 0x01	; 1
    4954:	81 11       	cpse	r24, r1
    4956:	90 e0       	ldi	r25, 0x00	; 0
		}
    4958:	89 2f       	mov	r24, r25
    495a:	08 95       	ret

0000495c <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    495c:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    495e:	01 e0       	ldi	r16, 0x01	; 1
    4960:	2f ef       	ldi	r18, 0xFF	; 255
    4962:	3f ef       	ldi	r19, 0xFF	; 255
    4964:	a9 01       	movw	r20, r18
    4966:	fc 01       	movw	r30, r24
    4968:	84 81       	ldd	r24, Z+4	; 0x04
    496a:	95 81       	ldd	r25, Z+5	; 0x05
    496c:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    4970:	0f 91       	pop	r16
    4972:	08 95       	ret

00004974 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4974:	0f 93       	push	r16
    4976:	cf 93       	push	r28
    4978:	df 93       	push	r29
    497a:	1f 92       	push	r1
    497c:	1f 92       	push	r1
    497e:	cd b7       	in	r28, 0x3d	; 61
    4980:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4982:	01 e0       	ldi	r16, 0x01	; 1
    4984:	2f ef       	ldi	r18, 0xFF	; 255
    4986:	3f ef       	ldi	r19, 0xFF	; 255
    4988:	a9 01       	movw	r20, r18
    498a:	be 01       	movw	r22, r28
    498c:	6f 5f       	subi	r22, 0xFF	; 255
    498e:	7f 4f       	sbci	r23, 0xFF	; 255
    4990:	fc 01       	movw	r30, r24
    4992:	84 81       	ldd	r24, Z+4	; 0x04
    4994:	95 81       	ldd	r25, Z+5	; 0x05
    4996:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    499a:	89 81       	ldd	r24, Y+1	; 0x01
    499c:	9a 81       	ldd	r25, Y+2	; 0x02
    499e:	0f 90       	pop	r0
    49a0:	0f 90       	pop	r0
    49a2:	df 91       	pop	r29
    49a4:	cf 91       	pop	r28
    49a6:	0f 91       	pop	r16
    49a8:	08 95       	ret

000049aa <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    49aa:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    49ac:	00 e0       	ldi	r16, 0x00	; 0
    49ae:	2f ef       	ldi	r18, 0xFF	; 255
    49b0:	3f ef       	ldi	r19, 0xFF	; 255
    49b2:	a9 01       	movw	r20, r18
    49b4:	fc 01       	movw	r30, r24
    49b6:	84 81       	ldd	r24, Z+4	; 0x04
    49b8:	95 81       	ldd	r25, Z+5	; 0x05
    49ba:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    49be:	0f 91       	pop	r16
    49c0:	08 95       	ret

000049c2 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    49c2:	0f 93       	push	r16
    49c4:	cf 93       	push	r28
    49c6:	df 93       	push	r29
    49c8:	1f 92       	push	r1
    49ca:	1f 92       	push	r1
    49cc:	cd b7       	in	r28, 0x3d	; 61
    49ce:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    49d0:	00 e0       	ldi	r16, 0x00	; 0
    49d2:	2f ef       	ldi	r18, 0xFF	; 255
    49d4:	3f ef       	ldi	r19, 0xFF	; 255
    49d6:	a9 01       	movw	r20, r18
    49d8:	be 01       	movw	r22, r28
    49da:	6f 5f       	subi	r22, 0xFF	; 255
    49dc:	7f 4f       	sbci	r23, 0xFF	; 255
    49de:	fc 01       	movw	r30, r24
    49e0:	84 81       	ldd	r24, Z+4	; 0x04
    49e2:	95 81       	ldd	r25, Z+5	; 0x05
    49e4:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    49e8:	89 81       	ldd	r24, Y+1	; 0x01
    49ea:	9a 81       	ldd	r25, Y+2	; 0x02
    49ec:	0f 90       	pop	r0
    49ee:	0f 90       	pop	r0
    49f0:	df 91       	pop	r29
    49f2:	cf 91       	pop	r28
    49f4:	0f 91       	pop	r16
    49f6:	08 95       	ret

000049f8 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    49f8:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    49fa:	01 e0       	ldi	r16, 0x01	; 1
    49fc:	2f ef       	ldi	r18, 0xFF	; 255
    49fe:	3f ef       	ldi	r19, 0xFF	; 255
    4a00:	a9 01       	movw	r20, r18
    4a02:	fc 01       	movw	r30, r24
    4a04:	84 81       	ldd	r24, Z+4	; 0x04
    4a06:	95 81       	ldd	r25, Z+5	; 0x05
    4a08:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    4a0c:	0f 91       	pop	r16
    4a0e:	08 95       	ret

00004a10 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4a10:	0f 93       	push	r16
    4a12:	cf 93       	push	r28
    4a14:	df 93       	push	r29
    4a16:	1f 92       	push	r1
    4a18:	1f 92       	push	r1
    4a1a:	cd b7       	in	r28, 0x3d	; 61
    4a1c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4a1e:	01 e0       	ldi	r16, 0x01	; 1
    4a20:	2f ef       	ldi	r18, 0xFF	; 255
    4a22:	3f ef       	ldi	r19, 0xFF	; 255
    4a24:	a9 01       	movw	r20, r18
    4a26:	be 01       	movw	r22, r28
    4a28:	6f 5f       	subi	r22, 0xFF	; 255
    4a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    4a2c:	fc 01       	movw	r30, r24
    4a2e:	84 81       	ldd	r24, Z+4	; 0x04
    4a30:	95 81       	ldd	r25, Z+5	; 0x05
    4a32:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    4a36:	89 81       	ldd	r24, Y+1	; 0x01
    4a38:	9a 81       	ldd	r25, Y+2	; 0x02
    4a3a:	0f 90       	pop	r0
    4a3c:	0f 90       	pop	r0
    4a3e:	df 91       	pop	r29
    4a40:	cf 91       	pop	r28
    4a42:	0f 91       	pop	r16
    4a44:	08 95       	ret

00004a46 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4a46:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4a48:	00 e0       	ldi	r16, 0x00	; 0
    4a4a:	2f ef       	ldi	r18, 0xFF	; 255
    4a4c:	3f ef       	ldi	r19, 0xFF	; 255
    4a4e:	a9 01       	movw	r20, r18
    4a50:	fc 01       	movw	r30, r24
    4a52:	84 81       	ldd	r24, Z+4	; 0x04
    4a54:	95 81       	ldd	r25, Z+5	; 0x05
    4a56:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
}
    4a5a:	0f 91       	pop	r16
    4a5c:	08 95       	ret

00004a5e <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4a5e:	0f 93       	push	r16
    4a60:	cf 93       	push	r28
    4a62:	df 93       	push	r29
    4a64:	1f 92       	push	r1
    4a66:	1f 92       	push	r1
    4a68:	cd b7       	in	r28, 0x3d	; 61
    4a6a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4a6c:	00 e0       	ldi	r16, 0x00	; 0
    4a6e:	2f ef       	ldi	r18, 0xFF	; 255
    4a70:	3f ef       	ldi	r19, 0xFF	; 255
    4a72:	a9 01       	movw	r20, r18
    4a74:	be 01       	movw	r22, r28
    4a76:	6f 5f       	subi	r22, 0xFF	; 255
    4a78:	7f 4f       	sbci	r23, 0xFF	; 255
    4a7a:	fc 01       	movw	r30, r24
    4a7c:	84 81       	ldd	r24, Z+4	; 0x04
    4a7e:	95 81       	ldd	r25, Z+5	; 0x05
    4a80:	0e 94 3a 14 	call	0x2874	; 0x2874 <xQueueGenericReceive>
	return (recv_item);
}
    4a84:	89 81       	ldd	r24, Y+1	; 0x01
    4a86:	9a 81       	ldd	r25, Y+2	; 0x02
    4a88:	0f 90       	pop	r0
    4a8a:	0f 90       	pop	r0
    4a8c:	df 91       	pop	r29
    4a8e:	cf 91       	pop	r28
    4a90:	0f 91       	pop	r16
    4a92:	08 95       	ret

00004a94 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4a94:	cf 93       	push	r28
    4a96:	df 93       	push	r29
    4a98:	1f 92       	push	r1
    4a9a:	cd b7       	in	r28, 0x3d	; 61
    4a9c:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4a9e:	ae 01       	movw	r20, r28
    4aa0:	4f 5f       	subi	r20, 0xFF	; 255
    4aa2:	5f 4f       	sbci	r21, 0xFF	; 255
    4aa4:	fc 01       	movw	r30, r24
    4aa6:	84 81       	ldd	r24, Z+4	; 0x04
    4aa8:	95 81       	ldd	r25, Z+5	; 0x05
    4aaa:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
}
    4aae:	0f 90       	pop	r0
    4ab0:	df 91       	pop	r29
    4ab2:	cf 91       	pop	r28
    4ab4:	08 95       	ret

00004ab6 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4ab6:	cf 93       	push	r28
    4ab8:	df 93       	push	r29
    4aba:	00 d0       	rcall	.+0      	; 0x4abc <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4abc:	cd b7       	in	r28, 0x3d	; 61
    4abe:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4ac0:	ae 01       	movw	r20, r28
    4ac2:	4d 5f       	subi	r20, 0xFD	; 253
    4ac4:	5f 4f       	sbci	r21, 0xFF	; 255
    4ac6:	be 01       	movw	r22, r28
    4ac8:	6f 5f       	subi	r22, 0xFF	; 255
    4aca:	7f 4f       	sbci	r23, 0xFF	; 255
    4acc:	fc 01       	movw	r30, r24
    4ace:	84 81       	ldd	r24, Z+4	; 0x04
    4ad0:	95 81       	ldd	r25, Z+5	; 0x05
    4ad2:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
	return (recv_item);
}
    4ad6:	89 81       	ldd	r24, Y+1	; 0x01
    4ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    4ada:	23 96       	adiw	r28, 0x03	; 3
    4adc:	cd bf       	out	0x3d, r28	; 61
    4ade:	de bf       	out	0x3e, r29	; 62
    4ae0:	df 91       	pop	r29
    4ae2:	cf 91       	pop	r28
    4ae4:	08 95       	ret

00004ae6 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    4ae6:	cf 93       	push	r28
    4ae8:	df 93       	push	r29
    4aea:	1f 92       	push	r1
    4aec:	cd b7       	in	r28, 0x3d	; 61
    4aee:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4af0:	ae 01       	movw	r20, r28
    4af2:	4f 5f       	subi	r20, 0xFF	; 255
    4af4:	5f 4f       	sbci	r21, 0xFF	; 255
    4af6:	fc 01       	movw	r30, r24
    4af8:	84 81       	ldd	r24, Z+4	; 0x04
    4afa:	95 81       	ldd	r25, Z+5	; 0x05
    4afc:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
}
    4b00:	0f 90       	pop	r0
    4b02:	df 91       	pop	r29
    4b04:	cf 91       	pop	r28
    4b06:	08 95       	ret

00004b08 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    4b08:	cf 93       	push	r28
    4b0a:	df 93       	push	r29
    4b0c:	00 d0       	rcall	.+0      	; 0x4b0e <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4b0e:	cd b7       	in	r28, 0x3d	; 61
    4b10:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4b12:	ae 01       	movw	r20, r28
    4b14:	4d 5f       	subi	r20, 0xFD	; 253
    4b16:	5f 4f       	sbci	r21, 0xFF	; 255
    4b18:	be 01       	movw	r22, r28
    4b1a:	6f 5f       	subi	r22, 0xFF	; 255
    4b1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b1e:	fc 01       	movw	r30, r24
    4b20:	84 81       	ldd	r24, Z+4	; 0x04
    4b22:	95 81       	ldd	r25, Z+5	; 0x05
    4b24:	0e 94 fe 14 	call	0x29fc	; 0x29fc <xQueueReceiveFromISR>
	return (recv_item);
}
    4b28:	89 81       	ldd	r24, Y+1	; 0x01
    4b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4b2c:	23 96       	adiw	r28, 0x03	; 3
    4b2e:	cd bf       	out	0x3d, r28	; 61
    4b30:	de bf       	out	0x3e, r29	; 62
    4b32:	df 91       	pop	r29
    4b34:	cf 91       	pop	r28
    4b36:	08 95       	ret

00004b38 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4b38:	cf 93       	push	r28
    4b3a:	df 93       	push	r29
    4b3c:	1f 92       	push	r1
    4b3e:	cd b7       	in	r28, 0x3d	; 61
    4b40:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4b42:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4b44:	21 e0       	ldi	r18, 0x01	; 1
    4b46:	ae 01       	movw	r20, r28
    4b48:	4f 5f       	subi	r20, 0xFF	; 255
    4b4a:	5f 4f       	sbci	r21, 0xFF	; 255
    4b4c:	fc 01       	movw	r30, r24
    4b4e:	84 81       	ldd	r24, Z+4	; 0x04
    4b50:	95 81       	ldd	r25, Z+5	; 0x05
    4b52:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4b56:	91 e0       	ldi	r25, 0x01	; 1
    4b58:	81 11       	cpse	r24, r1
    4b5a:	01 c0       	rjmp	.+2      	; 0x4b5e <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4b5c:	90 e0       	ldi	r25, 0x00	; 0
}
    4b5e:	89 2f       	mov	r24, r25
    4b60:	0f 90       	pop	r0
    4b62:	df 91       	pop	r29
    4b64:	cf 91       	pop	r28
    4b66:	08 95       	ret

00004b68 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4b68:	cf 93       	push	r28
    4b6a:	df 93       	push	r29
    4b6c:	1f 92       	push	r1
    4b6e:	cd b7       	in	r28, 0x3d	; 61
    4b70:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4b72:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4b74:	20 e0       	ldi	r18, 0x00	; 0
    4b76:	ae 01       	movw	r20, r28
    4b78:	4f 5f       	subi	r20, 0xFF	; 255
    4b7a:	5f 4f       	sbci	r21, 0xFF	; 255
    4b7c:	fc 01       	movw	r30, r24
    4b7e:	84 81       	ldd	r24, Z+4	; 0x04
    4b80:	95 81       	ldd	r25, Z+5	; 0x05
    4b82:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4b86:	91 e0       	ldi	r25, 0x01	; 1
    4b88:	81 11       	cpse	r24, r1
    4b8a:	01 c0       	rjmp	.+2      	; 0x4b8e <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4b8c:	90 e0       	ldi	r25, 0x00	; 0
}
    4b8e:	89 2f       	mov	r24, r25
    4b90:	0f 90       	pop	r0
    4b92:	df 91       	pop	r29
    4b94:	cf 91       	pop	r28
    4b96:	08 95       	ret

00004b98 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    4b98:	cf 93       	push	r28
    4b9a:	df 93       	push	r29
    4b9c:	1f 92       	push	r1
    4b9e:	cd b7       	in	r28, 0x3d	; 61
    4ba0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4ba2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4ba4:	21 e0       	ldi	r18, 0x01	; 1
    4ba6:	ae 01       	movw	r20, r28
    4ba8:	4f 5f       	subi	r20, 0xFF	; 255
    4baa:	5f 4f       	sbci	r21, 0xFF	; 255
    4bac:	fc 01       	movw	r30, r24
    4bae:	84 81       	ldd	r24, Z+4	; 0x04
    4bb0:	95 81       	ldd	r25, Z+5	; 0x05
    4bb2:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4bb6:	91 e0       	ldi	r25, 0x01	; 1
    4bb8:	81 11       	cpse	r24, r1
    4bba:	01 c0       	rjmp	.+2      	; 0x4bbe <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4bbc:	90 e0       	ldi	r25, 0x00	; 0
}
    4bbe:	89 2f       	mov	r24, r25
    4bc0:	0f 90       	pop	r0
    4bc2:	df 91       	pop	r29
    4bc4:	cf 91       	pop	r28
    4bc6:	08 95       	ret

00004bc8 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4bc8:	cf 93       	push	r28
    4bca:	df 93       	push	r29
    4bcc:	1f 92       	push	r1
    4bce:	cd b7       	in	r28, 0x3d	; 61
    4bd0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4bd2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4bd4:	20 e0       	ldi	r18, 0x00	; 0
    4bd6:	ae 01       	movw	r20, r28
    4bd8:	4f 5f       	subi	r20, 0xFF	; 255
    4bda:	5f 4f       	sbci	r21, 0xFF	; 255
    4bdc:	fc 01       	movw	r30, r24
    4bde:	84 81       	ldd	r24, Z+4	; 0x04
    4be0:	95 81       	ldd	r25, Z+5	; 0x05
    4be2:	0e 94 0e 14 	call	0x281c	; 0x281c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4be6:	91 e0       	ldi	r25, 0x01	; 1
    4be8:	81 11       	cpse	r24, r1
    4bea:	01 c0       	rjmp	.+2      	; 0x4bee <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4bec:	90 e0       	ldi	r25, 0x00	; 0
}
    4bee:	89 2f       	mov	r24, r25
    4bf0:	0f 90       	pop	r0
    4bf2:	df 91       	pop	r29
    4bf4:	cf 91       	pop	r28
    4bf6:	08 95       	ret

00004bf8 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4bf8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4bfa:	fc 01       	movw	r30, r24
    4bfc:	26 81       	ldd	r18, Z+6	; 0x06
    4bfe:	37 81       	ldd	r19, Z+7	; 0x07
    4c00:	40 85       	ldd	r20, Z+8	; 0x08
    4c02:	51 85       	ldd	r21, Z+9	; 0x09
    4c04:	01 e0       	ldi	r16, 0x01	; 1
    4c06:	84 81       	ldd	r24, Z+4	; 0x04
    4c08:	95 81       	ldd	r25, Z+5	; 0x05
    4c0a:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    4c0e:	91 e0       	ldi	r25, 0x01	; 1
    4c10:	81 11       	cpse	r24, r1
    4c12:	01 c0       	rjmp	.+2      	; 0x4c16 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4c14:	90 e0       	ldi	r25, 0x00	; 0
		}
    4c16:	89 2f       	mov	r24, r25
    4c18:	0f 91       	pop	r16
    4c1a:	08 95       	ret

00004c1c <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4c1c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4c1e:	fc 01       	movw	r30, r24
    4c20:	26 81       	ldd	r18, Z+6	; 0x06
    4c22:	37 81       	ldd	r19, Z+7	; 0x07
    4c24:	40 85       	ldd	r20, Z+8	; 0x08
    4c26:	51 85       	ldd	r21, Z+9	; 0x09
    4c28:	00 e0       	ldi	r16, 0x00	; 0
    4c2a:	84 81       	ldd	r24, Z+4	; 0x04
    4c2c:	95 81       	ldd	r25, Z+5	; 0x05
    4c2e:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    4c32:	91 e0       	ldi	r25, 0x01	; 1
    4c34:	81 11       	cpse	r24, r1
    4c36:	01 c0       	rjmp	.+2      	; 0x4c3a <_ZN9frt_queueIjE3putERKj+0x1e>
    4c38:	90 e0       	ldi	r25, 0x00	; 0
		}
    4c3a:	89 2f       	mov	r24, r25
    4c3c:	0f 91       	pop	r16
    4c3e:	08 95       	ret

00004c40 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4c40:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4c42:	fc 01       	movw	r30, r24
    4c44:	26 81       	ldd	r18, Z+6	; 0x06
    4c46:	37 81       	ldd	r19, Z+7	; 0x07
    4c48:	40 85       	ldd	r20, Z+8	; 0x08
    4c4a:	51 85       	ldd	r21, Z+9	; 0x09
    4c4c:	01 e0       	ldi	r16, 0x01	; 1
    4c4e:	84 81       	ldd	r24, Z+4	; 0x04
    4c50:	95 81       	ldd	r25, Z+5	; 0x05
    4c52:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    4c56:	91 e0       	ldi	r25, 0x01	; 1
    4c58:	81 11       	cpse	r24, r1
    4c5a:	01 c0       	rjmp	.+2      	; 0x4c5e <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4c5c:	90 e0       	ldi	r25, 0x00	; 0
		}
    4c5e:	89 2f       	mov	r24, r25
    4c60:	0f 91       	pop	r16
    4c62:	08 95       	ret

00004c64 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4c64:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4c66:	fc 01       	movw	r30, r24
    4c68:	26 81       	ldd	r18, Z+6	; 0x06
    4c6a:	37 81       	ldd	r19, Z+7	; 0x07
    4c6c:	40 85       	ldd	r20, Z+8	; 0x08
    4c6e:	51 85       	ldd	r21, Z+9	; 0x09
    4c70:	00 e0       	ldi	r16, 0x00	; 0
    4c72:	84 81       	ldd	r24, Z+4	; 0x04
    4c74:	95 81       	ldd	r25, Z+5	; 0x05
    4c76:	0e 94 73 13 	call	0x26e6	; 0x26e6 <xQueueGenericSend>
    4c7a:	91 e0       	ldi	r25, 0x01	; 1
    4c7c:	81 11       	cpse	r24, r1
    4c7e:	01 c0       	rjmp	.+2      	; 0x4c82 <_ZN9frt_queueIiE3putERKi+0x1e>
    4c80:	90 e0       	ldi	r25, 0x00	; 0
		}
    4c82:	89 2f       	mov	r24, r25
    4c84:	0f 91       	pop	r16
    4c86:	08 95       	ret

00004c88 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4c88:	0f 93       	push	r16
    4c8a:	cf 93       	push	r28
    4c8c:	df 93       	push	r29
    4c8e:	1f 92       	push	r1
    4c90:	cd b7       	in	r28, 0x3d	; 61
    4c92:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4c94:	2f b7       	in	r18, 0x3f	; 63
    4c96:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4c98:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4c9a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4c9c:	fc 01       	movw	r30, r24
    4c9e:	08 ed       	ldi	r16, 0xD8	; 216
    4ca0:	04 bf       	out	0x34, r16	; 52
    4ca2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4ca4:	89 81       	ldd	r24, Y+1	; 0x01
    4ca6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4ca8:	0f 90       	pop	r0
    4caa:	df 91       	pop	r29
    4cac:	cf 91       	pop	r28
    4cae:	0f 91       	pop	r16
    4cb0:	08 95       	ret

00004cb2 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4cb2:	ef 92       	push	r14
    4cb4:	ff 92       	push	r15
    4cb6:	0f 93       	push	r16
    4cb8:	1f 93       	push	r17
    4cba:	cf 93       	push	r28
    4cbc:	df 93       	push	r29
    4cbe:	cd b7       	in	r28, 0x3d	; 61
    4cc0:	de b7       	in	r29, 0x3e	; 62
    4cc2:	c7 54       	subi	r28, 0x47	; 71
    4cc4:	d1 09       	sbc	r29, r1
    4cc6:	cd bf       	out	0x3d, r28	; 61
    4cc8:	de bf       	out	0x3e, r29	; 62
	cli();
    4cca:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4ccc:	e0 e5       	ldi	r30, 0x50	; 80
    4cce:	f0 e0       	ldi	r31, 0x00	; 0
    4cd0:	80 81       	ld	r24, Z
    4cd2:	82 60       	ori	r24, 0x02	; 2
    4cd4:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4cd6:	81 81       	ldd	r24, Z+1	; 0x01
    4cd8:	81 ff       	sbrs	r24, 1
    4cda:	fd cf       	rjmp	.-6      	; 0x4cd6 <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4cdc:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4ce0:	68 7f       	andi	r22, 0xF8	; 248
    4ce2:	61 60       	ori	r22, 0x01	; 1
    4ce4:	80 e4       	ldi	r24, 0x40	; 64
    4ce6:	90 e0       	ldi	r25, 0x00	; 0
    4ce8:	0e 94 44 26 	call	0x4c88	; 0x4c88 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4cec:	e0 e5       	ldi	r30, 0x50	; 80
    4cee:	f0 e0       	ldi	r31, 0x00	; 0
    4cf0:	80 81       	ld	r24, Z
    4cf2:	8e 7f       	andi	r24, 0xFE	; 254
    4cf4:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4cf6:	9d ef       	ldi	r25, 0xFD	; 253
    4cf8:	88 ed       	ldi	r24, 0xD8	; 216
    4cfa:	08 b6       	in	r0, 0x38	; 56
    4cfc:	18 be       	out	0x38, r1	; 56
    4cfe:	84 bf       	out	0x34, r24	; 52
    4d00:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4d04:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4d06:	40 ea       	ldi	r20, 0xA0	; 160
    4d08:	5a e0       	ldi	r21, 0x0A	; 10
    4d0a:	60 e0       	ldi	r22, 0x00	; 0
    4d0c:	70 e0       	ldi	r23, 0x00	; 0
    4d0e:	ce 01       	movw	r24, r28
    4d10:	01 96       	adiw	r24, 0x01	; 1
    4d12:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4d16:	67 e0       	ldi	r22, 0x07	; 7
    4d18:	ce 01       	movw	r24, r28
    4d1a:	01 96       	adiw	r24, 0x01	; 1
    4d1c:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    4d20:	8c 01       	movw	r16, r24
    4d22:	64 e6       	ldi	r22, 0x64	; 100
    4d24:	72 e2       	ldi	r23, 0x22	; 34
    4d26:	0e 94 d1 1f 	call	0x3fa2	; 0x3fa2 <_ZN8emstream4putsEPKc>
    4d2a:	66 e0       	ldi	r22, 0x06	; 6
    4d2c:	c8 01       	movw	r24, r16
    4d2e:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
    4d32:	66 e0       	ldi	r22, 0x06	; 6
    4d34:	0e 94 08 20 	call	0x4010	; 0x4010 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4d38:	8e 01       	movw	r16, r28
    4d3a:	0f 5f       	subi	r16, 0xFF	; 255
    4d3c:	1f 4f       	sbci	r17, 0xFF	; 255
    4d3e:	20 e3       	ldi	r18, 0x30	; 48
    4d40:	32 ef       	ldi	r19, 0xF2	; 242
    4d42:	40 e0       	ldi	r20, 0x00	; 0
    4d44:	50 e0       	ldi	r21, 0x00	; 0
    4d46:	60 ea       	ldi	r22, 0xA0	; 160
    4d48:	74 e0       	ldi	r23, 0x04	; 4
    4d4a:	ce 01       	movw	r24, r28
    4d4c:	4e 96       	adiw	r24, 0x1e	; 30
    4d4e:	0e 94 91 09 	call	0x1322	; 0x1322 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>

	// I2CAgent i2cAgent();
	
	MMA8451 mma8451(&i2c, &ser_dev);
    4d52:	a8 01       	movw	r20, r16
    4d54:	be 01       	movw	r22, r28
    4d56:	62 5e       	subi	r22, 0xE2	; 226
    4d58:	7f 4f       	sbci	r23, 0xFF	; 255
    4d5a:	ce 01       	movw	r24, r28
    4d5c:	c7 96       	adiw	r24, 0x37	; 55
    4d5e:	0e 94 4e 0b 	call	0x169c	; 0x169c <_ZN7MMA8451C1EP9I2CMasterP8emstream>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4d62:	82 e1       	ldi	r24, 0x12	; 18
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    4d6a:	20 e8       	ldi	r18, 0x80	; 128
    4d6c:	30 e0       	ldi	r19, 0x00	; 0
    4d6e:	40 e0       	ldi	r20, 0x00	; 0
    4d70:	63 e8       	ldi	r22, 0x83	; 131
    4d72:	72 e2       	ldi	r23, 0x22	; 34
    4d74:	0e 94 ef 0c 	call	0x19de	; 0x19de <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mma8451);
    4d78:	88 e1       	ldi	r24, 0x18	; 24
    4d7a:	90 e0       	ldi	r25, 0x00	; 0
    4d7c:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <_Znwj>
    4d80:	9e 01       	movw	r18, r28
    4d82:	29 5c       	subi	r18, 0xC9	; 201
    4d84:	3f 4f       	sbci	r19, 0xFF	; 255
    4d86:	79 01       	movw	r14, r18
    4d88:	20 e8       	ldi	r18, 0x80	; 128
    4d8a:	30 e0       	ldi	r19, 0x00	; 0
    4d8c:	42 e0       	ldi	r20, 0x02	; 2
    4d8e:	6b e8       	ldi	r22, 0x8B	; 139
    4d90:	72 e2       	ldi	r23, 0x22	; 34
    4d92:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <_ZN10task_sonarC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4d96:	87 e0       	ldi	r24, 0x07	; 7
    4d98:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4d9c:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4d9e:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <vTaskStartScheduler>
}
    4da2:	80 e0       	ldi	r24, 0x00	; 0
    4da4:	90 e0       	ldi	r25, 0x00	; 0
    4da6:	c9 5b       	subi	r28, 0xB9	; 185
    4da8:	df 4f       	sbci	r29, 0xFF	; 255
    4daa:	cd bf       	out	0x3d, r28	; 61
    4dac:	de bf       	out	0x3e, r29	; 62
    4dae:	df 91       	pop	r29
    4db0:	cf 91       	pop	r28
    4db2:	1f 91       	pop	r17
    4db4:	0f 91       	pop	r16
    4db6:	ff 90       	pop	r15
    4db8:	ef 90       	pop	r14
    4dba:	08 95       	ret

00004dbc <_GLOBAL__sub_I_counter>:
    4dbc:	cf 92       	push	r12
    4dbe:	df 92       	push	r13
    4dc0:	ef 92       	push	r14
    4dc2:	ff 92       	push	r15
    4dc4:	0f 93       	push	r16
    4dc6:	1f 93       	push	r17
    4dc8:	cf 93       	push	r28
    4dca:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4dcc:	0a e0       	ldi	r16, 0x0A	; 10
    4dce:	10 e0       	ldi	r17, 0x00	; 0
    4dd0:	20 e0       	ldi	r18, 0x00	; 0
    4dd2:	30 e0       	ldi	r19, 0x00	; 0
    4dd4:	40 e0       	ldi	r20, 0x00	; 0
    4dd6:	50 e0       	ldi	r21, 0x00	; 0
    4dd8:	60 e2       	ldi	r22, 0x20	; 32
    4dda:	70 e0       	ldi	r23, 0x00	; 0
    4ddc:	86 e9       	ldi	r24, 0x96	; 150
    4dde:	93 e3       	ldi	r25, 0x33	; 51
    4de0:	0e 94 89 1d 	call	0x3b12	; 0x3b12 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4de4:	cc e8       	ldi	r28, 0x8C	; 140
    4de6:	d3 e3       	ldi	r29, 0x33	; 51
    4de8:	1a 82       	std	Y+2, r1	; 0x02
    4dea:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4dec:	85 e9       	ldi	r24, 0x95	; 149
    4dee:	92 e2       	ldi	r25, 0x22	; 34
    4df0:	88 83       	st	Y, r24
    4df2:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4df4:	40 e0       	ldi	r20, 0x00	; 0
    4df6:	62 e0       	ldi	r22, 0x02	; 2
    4df8:	8f ef       	ldi	r24, 0xFF	; 255
    4dfa:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    4dfe:	8c 83       	std	Y+4, r24	; 0x04
    4e00:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4e02:	0f 2e       	mov	r0, r31
    4e04:	fa e0       	ldi	r31, 0x0A	; 10
    4e06:	cf 2e       	mov	r12, r31
    4e08:	d1 2c       	mov	r13, r1
    4e0a:	e1 2c       	mov	r14, r1
    4e0c:	f1 2c       	mov	r15, r1
    4e0e:	f0 2d       	mov	r31, r0
    4e10:	ce 82       	std	Y+6, r12	; 0x06
    4e12:	df 82       	std	Y+7, r13	; 0x07
    4e14:	e8 86       	std	Y+8, r14	; 0x08
    4e16:	f9 86       	std	Y+9, r15	; 0x09
    4e18:	c2 e8       	ldi	r28, 0x82	; 130
    4e1a:	d3 e3       	ldi	r29, 0x33	; 51
    4e1c:	1a 82       	std	Y+2, r1	; 0x02
    4e1e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4e20:	09 eb       	ldi	r16, 0xB9	; 185
    4e22:	12 e2       	ldi	r17, 0x22	; 34
    4e24:	08 83       	st	Y, r16
    4e26:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4e28:	40 e0       	ldi	r20, 0x00	; 0
    4e2a:	62 e0       	ldi	r22, 0x02	; 2
    4e2c:	8f ef       	ldi	r24, 0xFF	; 255
    4e2e:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    4e32:	8c 83       	std	Y+4, r24	; 0x04
    4e34:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4e36:	ce 82       	std	Y+6, r12	; 0x06
    4e38:	df 82       	std	Y+7, r13	; 0x07
    4e3a:	e8 86       	std	Y+8, r14	; 0x08
    4e3c:	f9 86       	std	Y+9, r15	; 0x09
    4e3e:	c8 e7       	ldi	r28, 0x78	; 120
    4e40:	d3 e3       	ldi	r29, 0x33	; 51
    4e42:	1a 82       	std	Y+2, r1	; 0x02
    4e44:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4e46:	08 83       	st	Y, r16
    4e48:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4e4a:	40 e0       	ldi	r20, 0x00	; 0
    4e4c:	62 e0       	ldi	r22, 0x02	; 2
    4e4e:	8f ef       	ldi	r24, 0xFF	; 255
    4e50:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    4e54:	8c 83       	std	Y+4, r24	; 0x04
    4e56:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4e58:	ce 82       	std	Y+6, r12	; 0x06
    4e5a:	df 82       	std	Y+7, r13	; 0x07
    4e5c:	e8 86       	std	Y+8, r14	; 0x08
    4e5e:	f9 86       	std	Y+9, r15	; 0x09
    4e60:	ce e6       	ldi	r28, 0x6E	; 110
    4e62:	d3 e3       	ldi	r29, 0x33	; 51
    4e64:	1a 82       	std	Y+2, r1	; 0x02
    4e66:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4e68:	08 83       	st	Y, r16
    4e6a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4e6c:	40 e0       	ldi	r20, 0x00	; 0
    4e6e:	62 e0       	ldi	r22, 0x02	; 2
    4e70:	8f ef       	ldi	r24, 0xFF	; 255
    4e72:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    4e76:	8c 83       	std	Y+4, r24	; 0x04
    4e78:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4e7a:	ce 82       	std	Y+6, r12	; 0x06
    4e7c:	df 82       	std	Y+7, r13	; 0x07
    4e7e:	e8 86       	std	Y+8, r14	; 0x08
    4e80:	f9 86       	std	Y+9, r15	; 0x09
    4e82:	c4 e6       	ldi	r28, 0x64	; 100
    4e84:	d3 e3       	ldi	r29, 0x33	; 51
    4e86:	1a 82       	std	Y+2, r1	; 0x02
    4e88:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4e8a:	08 83       	st	Y, r16
    4e8c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4e8e:	40 e0       	ldi	r20, 0x00	; 0
    4e90:	62 e0       	ldi	r22, 0x02	; 2
    4e92:	8f ef       	ldi	r24, 0xFF	; 255
    4e94:	0e 94 45 13 	call	0x268a	; 0x268a <xQueueGenericCreate>
    4e98:	8c 83       	std	Y+4, r24	; 0x04
    4e9a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4e9c:	ce 82       	std	Y+6, r12	; 0x06
    4e9e:	df 82       	std	Y+7, r13	; 0x07
    4ea0:	e8 86       	std	Y+8, r14	; 0x08
    4ea2:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4ea4:	df 91       	pop	r29
    4ea6:	cf 91       	pop	r28
    4ea8:	1f 91       	pop	r17
    4eaa:	0f 91       	pop	r16
    4eac:	ff 90       	pop	r15
    4eae:	ef 90       	pop	r14
    4eb0:	df 90       	pop	r13
    4eb2:	cf 90       	pop	r12
    4eb4:	08 95       	ret

00004eb6 <__mulsi3>:
    4eb6:	db 01       	movw	r26, r22
    4eb8:	8f 93       	push	r24
    4eba:	9f 93       	push	r25
    4ebc:	0e 94 b5 27 	call	0x4f6a	; 0x4f6a <__muluhisi3>
    4ec0:	bf 91       	pop	r27
    4ec2:	af 91       	pop	r26
    4ec4:	a2 9f       	mul	r26, r18
    4ec6:	80 0d       	add	r24, r0
    4ec8:	91 1d       	adc	r25, r1
    4eca:	a3 9f       	mul	r26, r19
    4ecc:	90 0d       	add	r25, r0
    4ece:	b2 9f       	mul	r27, r18
    4ed0:	90 0d       	add	r25, r0
    4ed2:	11 24       	eor	r1, r1
    4ed4:	08 95       	ret

00004ed6 <__udivmodsi4>:
    4ed6:	a1 e2       	ldi	r26, 0x21	; 33
    4ed8:	1a 2e       	mov	r1, r26
    4eda:	aa 1b       	sub	r26, r26
    4edc:	bb 1b       	sub	r27, r27
    4ede:	fd 01       	movw	r30, r26
    4ee0:	0d c0       	rjmp	.+26     	; 0x4efc <__udivmodsi4_ep>

00004ee2 <__udivmodsi4_loop>:
    4ee2:	aa 1f       	adc	r26, r26
    4ee4:	bb 1f       	adc	r27, r27
    4ee6:	ee 1f       	adc	r30, r30
    4ee8:	ff 1f       	adc	r31, r31
    4eea:	a2 17       	cp	r26, r18
    4eec:	b3 07       	cpc	r27, r19
    4eee:	e4 07       	cpc	r30, r20
    4ef0:	f5 07       	cpc	r31, r21
    4ef2:	20 f0       	brcs	.+8      	; 0x4efc <__udivmodsi4_ep>
    4ef4:	a2 1b       	sub	r26, r18
    4ef6:	b3 0b       	sbc	r27, r19
    4ef8:	e4 0b       	sbc	r30, r20
    4efa:	f5 0b       	sbc	r31, r21

00004efc <__udivmodsi4_ep>:
    4efc:	66 1f       	adc	r22, r22
    4efe:	77 1f       	adc	r23, r23
    4f00:	88 1f       	adc	r24, r24
    4f02:	99 1f       	adc	r25, r25
    4f04:	1a 94       	dec	r1
    4f06:	69 f7       	brne	.-38     	; 0x4ee2 <__udivmodsi4_loop>
    4f08:	60 95       	com	r22
    4f0a:	70 95       	com	r23
    4f0c:	80 95       	com	r24
    4f0e:	90 95       	com	r25
    4f10:	9b 01       	movw	r18, r22
    4f12:	ac 01       	movw	r20, r24
    4f14:	bd 01       	movw	r22, r26
    4f16:	cf 01       	movw	r24, r30
    4f18:	08 95       	ret

00004f1a <__divmodsi4>:
    4f1a:	05 2e       	mov	r0, r21
    4f1c:	97 fb       	bst	r25, 7
    4f1e:	1e f4       	brtc	.+6      	; 0x4f26 <__divmodsi4+0xc>
    4f20:	00 94       	com	r0
    4f22:	0e 94 a4 27 	call	0x4f48	; 0x4f48 <__negsi2>
    4f26:	57 fd       	sbrc	r21, 7
    4f28:	07 d0       	rcall	.+14     	; 0x4f38 <__divmodsi4_neg2>
    4f2a:	0e 94 6b 27 	call	0x4ed6	; 0x4ed6 <__udivmodsi4>
    4f2e:	07 fc       	sbrc	r0, 7
    4f30:	03 d0       	rcall	.+6      	; 0x4f38 <__divmodsi4_neg2>
    4f32:	4e f4       	brtc	.+18     	; 0x4f46 <__divmodsi4_exit>
    4f34:	0c 94 a4 27 	jmp	0x4f48	; 0x4f48 <__negsi2>

00004f38 <__divmodsi4_neg2>:
    4f38:	50 95       	com	r21
    4f3a:	40 95       	com	r20
    4f3c:	30 95       	com	r19
    4f3e:	21 95       	neg	r18
    4f40:	3f 4f       	sbci	r19, 0xFF	; 255
    4f42:	4f 4f       	sbci	r20, 0xFF	; 255
    4f44:	5f 4f       	sbci	r21, 0xFF	; 255

00004f46 <__divmodsi4_exit>:
    4f46:	08 95       	ret

00004f48 <__negsi2>:
    4f48:	90 95       	com	r25
    4f4a:	80 95       	com	r24
    4f4c:	70 95       	com	r23
    4f4e:	61 95       	neg	r22
    4f50:	7f 4f       	sbci	r23, 0xFF	; 255
    4f52:	8f 4f       	sbci	r24, 0xFF	; 255
    4f54:	9f 4f       	sbci	r25, 0xFF	; 255
    4f56:	08 95       	ret

00004f58 <__tablejump2__>:
    4f58:	ee 0f       	add	r30, r30
    4f5a:	ff 1f       	adc	r31, r31
    4f5c:	88 1f       	adc	r24, r24
    4f5e:	8b bf       	out	0x3b, r24	; 59
    4f60:	07 90       	elpm	r0, Z+
    4f62:	f6 91       	elpm	r31, Z
    4f64:	e0 2d       	mov	r30, r0
    4f66:	1b be       	out	0x3b, r1	; 59
    4f68:	19 94       	eijmp

00004f6a <__muluhisi3>:
    4f6a:	0e 94 c0 27 	call	0x4f80	; 0x4f80 <__umulhisi3>
    4f6e:	a5 9f       	mul	r26, r21
    4f70:	90 0d       	add	r25, r0
    4f72:	b4 9f       	mul	r27, r20
    4f74:	90 0d       	add	r25, r0
    4f76:	a4 9f       	mul	r26, r20
    4f78:	80 0d       	add	r24, r0
    4f7a:	91 1d       	adc	r25, r1
    4f7c:	11 24       	eor	r1, r1
    4f7e:	08 95       	ret

00004f80 <__umulhisi3>:
    4f80:	a2 9f       	mul	r26, r18
    4f82:	b0 01       	movw	r22, r0
    4f84:	b3 9f       	mul	r27, r19
    4f86:	c0 01       	movw	r24, r0
    4f88:	a3 9f       	mul	r26, r19
    4f8a:	70 0d       	add	r23, r0
    4f8c:	81 1d       	adc	r24, r1
    4f8e:	11 24       	eor	r1, r1
    4f90:	91 1d       	adc	r25, r1
    4f92:	b2 9f       	mul	r27, r18
    4f94:	70 0d       	add	r23, r0
    4f96:	81 1d       	adc	r24, r1
    4f98:	11 24       	eor	r1, r1
    4f9a:	91 1d       	adc	r25, r1
    4f9c:	08 95       	ret

00004f9e <memcpy>:
    4f9e:	fb 01       	movw	r30, r22
    4fa0:	dc 01       	movw	r26, r24
    4fa2:	02 c0       	rjmp	.+4      	; 0x4fa8 <memcpy+0xa>
    4fa4:	01 90       	ld	r0, Z+
    4fa6:	0d 92       	st	X+, r0
    4fa8:	41 50       	subi	r20, 0x01	; 1
    4faa:	50 40       	sbci	r21, 0x00	; 0
    4fac:	d8 f7       	brcc	.-10     	; 0x4fa4 <memcpy+0x6>
    4fae:	08 95       	ret

00004fb0 <memset>:
    4fb0:	dc 01       	movw	r26, r24
    4fb2:	01 c0       	rjmp	.+2      	; 0x4fb6 <memset+0x6>
    4fb4:	6d 93       	st	X+, r22
    4fb6:	41 50       	subi	r20, 0x01	; 1
    4fb8:	50 40       	sbci	r21, 0x00	; 0
    4fba:	e0 f7       	brcc	.-8      	; 0x4fb4 <memset+0x4>
    4fbc:	08 95       	ret

00004fbe <strncpy>:
    4fbe:	fb 01       	movw	r30, r22
    4fc0:	dc 01       	movw	r26, r24
    4fc2:	41 50       	subi	r20, 0x01	; 1
    4fc4:	50 40       	sbci	r21, 0x00	; 0
    4fc6:	48 f0       	brcs	.+18     	; 0x4fda <strncpy+0x1c>
    4fc8:	01 90       	ld	r0, Z+
    4fca:	0d 92       	st	X+, r0
    4fcc:	00 20       	and	r0, r0
    4fce:	c9 f7       	brne	.-14     	; 0x4fc2 <strncpy+0x4>
    4fd0:	01 c0       	rjmp	.+2      	; 0x4fd4 <strncpy+0x16>
    4fd2:	1d 92       	st	X+, r1
    4fd4:	41 50       	subi	r20, 0x01	; 1
    4fd6:	50 40       	sbci	r21, 0x00	; 0
    4fd8:	e0 f7       	brcc	.-8      	; 0x4fd2 <strncpy+0x14>
    4fda:	08 95       	ret

00004fdc <ultoa>:
    4fdc:	25 32       	cpi	r18, 0x25	; 37
    4fde:	31 05       	cpc	r19, r1
    4fe0:	20 f4       	brcc	.+8      	; 0x4fea <ultoa+0xe>
    4fe2:	22 30       	cpi	r18, 0x02	; 2
    4fe4:	10 f0       	brcs	.+4      	; 0x4fea <ultoa+0xe>
    4fe6:	0c 94 f9 27 	jmp	0x4ff2	; 0x4ff2 <__ultoa_ncheck>
    4fea:	fa 01       	movw	r30, r20
    4fec:	10 82       	st	Z, r1
    4fee:	ca 01       	movw	r24, r20
    4ff0:	08 95       	ret

00004ff2 <__ultoa_ncheck>:
    4ff2:	bb 27       	eor	r27, r27

00004ff4 <__ultoa_common>:
    4ff4:	fa 01       	movw	r30, r20
    4ff6:	a6 2f       	mov	r26, r22
    4ff8:	62 17       	cp	r22, r18
    4ffa:	71 05       	cpc	r23, r1
    4ffc:	81 05       	cpc	r24, r1
    4ffe:	91 05       	cpc	r25, r1
    5000:	33 0b       	sbc	r19, r19
    5002:	30 fb       	bst	r19, 0
    5004:	66 f0       	brts	.+24     	; 0x501e <__ultoa_common+0x2a>
    5006:	aa 27       	eor	r26, r26
    5008:	66 0f       	add	r22, r22
    500a:	77 1f       	adc	r23, r23
    500c:	88 1f       	adc	r24, r24
    500e:	99 1f       	adc	r25, r25
    5010:	aa 1f       	adc	r26, r26
    5012:	a2 17       	cp	r26, r18
    5014:	10 f0       	brcs	.+4      	; 0x501a <__ultoa_common+0x26>
    5016:	a2 1b       	sub	r26, r18
    5018:	63 95       	inc	r22
    501a:	38 50       	subi	r19, 0x08	; 8
    501c:	a9 f7       	brne	.-22     	; 0x5008 <__ultoa_common+0x14>
    501e:	a0 5d       	subi	r26, 0xD0	; 208
    5020:	aa 33       	cpi	r26, 0x3A	; 58
    5022:	08 f0       	brcs	.+2      	; 0x5026 <__ultoa_common+0x32>
    5024:	a9 5d       	subi	r26, 0xD9	; 217
    5026:	a1 93       	st	Z+, r26
    5028:	36 f7       	brtc	.-52     	; 0x4ff6 <__ultoa_common+0x2>
    502a:	b1 11       	cpse	r27, r1
    502c:	b1 93       	st	Z+, r27
    502e:	10 82       	st	Z, r1
    5030:	ca 01       	movw	r24, r20
    5032:	0c 94 40 28 	jmp	0x5080	; 0x5080 <strrev>

00005036 <utoa>:
    5036:	45 32       	cpi	r20, 0x25	; 37
    5038:	51 05       	cpc	r21, r1
    503a:	20 f4       	brcc	.+8      	; 0x5044 <utoa+0xe>
    503c:	42 30       	cpi	r20, 0x02	; 2
    503e:	10 f0       	brcs	.+4      	; 0x5044 <utoa+0xe>
    5040:	0c 94 26 28 	jmp	0x504c	; 0x504c <__utoa_ncheck>
    5044:	fb 01       	movw	r30, r22
    5046:	10 82       	st	Z, r1
    5048:	cb 01       	movw	r24, r22
    504a:	08 95       	ret

0000504c <__utoa_ncheck>:
    504c:	bb 27       	eor	r27, r27

0000504e <__utoa_common>:
    504e:	fb 01       	movw	r30, r22
    5050:	55 27       	eor	r21, r21
    5052:	aa 27       	eor	r26, r26
    5054:	88 0f       	add	r24, r24
    5056:	99 1f       	adc	r25, r25
    5058:	aa 1f       	adc	r26, r26
    505a:	a4 17       	cp	r26, r20
    505c:	10 f0       	brcs	.+4      	; 0x5062 <__utoa_common+0x14>
    505e:	a4 1b       	sub	r26, r20
    5060:	83 95       	inc	r24
    5062:	50 51       	subi	r21, 0x10	; 16
    5064:	b9 f7       	brne	.-18     	; 0x5054 <__utoa_common+0x6>
    5066:	a0 5d       	subi	r26, 0xD0	; 208
    5068:	aa 33       	cpi	r26, 0x3A	; 58
    506a:	08 f0       	brcs	.+2      	; 0x506e <__utoa_common+0x20>
    506c:	a9 5d       	subi	r26, 0xD9	; 217
    506e:	a1 93       	st	Z+, r26
    5070:	00 97       	sbiw	r24, 0x00	; 0
    5072:	79 f7       	brne	.-34     	; 0x5052 <__utoa_common+0x4>
    5074:	b1 11       	cpse	r27, r1
    5076:	b1 93       	st	Z+, r27
    5078:	11 92       	st	Z+, r1
    507a:	cb 01       	movw	r24, r22
    507c:	0c 94 40 28 	jmp	0x5080	; 0x5080 <strrev>

00005080 <strrev>:
    5080:	dc 01       	movw	r26, r24
    5082:	fc 01       	movw	r30, r24
    5084:	67 2f       	mov	r22, r23
    5086:	71 91       	ld	r23, Z+
    5088:	77 23       	and	r23, r23
    508a:	e1 f7       	brne	.-8      	; 0x5084 <strrev+0x4>
    508c:	32 97       	sbiw	r30, 0x02	; 2
    508e:	04 c0       	rjmp	.+8      	; 0x5098 <strrev+0x18>
    5090:	7c 91       	ld	r23, X
    5092:	6d 93       	st	X+, r22
    5094:	70 83       	st	Z, r23
    5096:	62 91       	ld	r22, -Z
    5098:	ae 17       	cp	r26, r30
    509a:	bf 07       	cpc	r27, r31
    509c:	c8 f3       	brcs	.-14     	; 0x5090 <strrev+0x10>
    509e:	08 95       	ret

000050a0 <_exit>:
    50a0:	f8 94       	cli

000050a2 <__stop_program>:
    50a2:	ff cf       	rjmp	.-2      	; 0x50a2 <__stop_program>
