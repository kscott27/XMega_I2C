
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000048a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000168  00802000  000048a8  0000493c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802168  00802168  00004aa4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004aa4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004ad4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000918  00000000  00000000  00004b14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000184e9  00000000  00000000  0000542c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006a4f  00000000  00000000  0001d915  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005de9  00000000  00000000  00024364  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b20  00000000  00000000  0002a150  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006b2e  00000000  00000000  0002bc70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008a13  00000000  00000000  0003279e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000878  00000000  00000000  0003b1b1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 23 03 	jmp	0x646	; 0x646 <__ctors_end>
       4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
       8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
       c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      10:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      14:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      18:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      1c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      20:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      24:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      28:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      2c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      30:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      34:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      38:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      3c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      40:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      44:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      48:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      4c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      50:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      54:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      58:	0c 94 96 0e 	jmp	0x1d2c	; 0x1d2c <__vector_22>
      5c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      60:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      64:	0c 94 6b 1e 	jmp	0x3cd6	; 0x3cd6 <__vector_25>
      68:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      6c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      70:	0c 94 c9 1e 	jmp	0x3d92	; 0x3d92 <__vector_28>
      74:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      78:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      7c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      80:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      84:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      88:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      8c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      90:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      94:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      98:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      9c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      ac:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      bc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      cc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      dc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e8:	0c 94 e3 1f 	jmp	0x3fc6	; 0x3fc6 <__vector_58>
      ec:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      fc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     100:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     104:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     108:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     10c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     110:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     114:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     118:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     11c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     120:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     124:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     128:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     12c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     130:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     134:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     138:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     13c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     140:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     144:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     148:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     14c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     150:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     154:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     158:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     15c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     160:	0c 94 27 1f 	jmp	0x3e4e	; 0x3e4e <__vector_88>
     164:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     168:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     16c:	0c 94 85 1f 	jmp	0x3f0a	; 0x3f0a <__vector_91>
     170:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     174:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     178:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     17c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     180:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     184:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     188:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     18c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     190:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     194:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     198:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     19c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1ac:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1bc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1cc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1dc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1ec:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1fc:	57 1c       	adc	r5, r7
     1fe:	5a 1c       	adc	r5, r10
     200:	5d 1c       	adc	r5, r13
     202:	60 1c       	adc	r6, r0
     204:	63 1c       	adc	r6, r3
     206:	66 1c       	adc	r6, r6
     208:	68 1c       	adc	r6, r8
     20a:	79 1c       	adc	r7, r9
     20c:	81 1c       	adc	r8, r1
     20e:	8b 1c       	adc	r8, r11
     210:	89 1c       	adc	r8, r9

00000212 <__trampolines_start>:
     212:	0c 94 72 0a 	jmp	0x14e4	; 0x14e4 <_ZN9task_user3runEv>
     216:	0c 94 35 22 	jmp	0x446a	; 0x446a <_ZN9frt_queueIiE3putERKi>
     21a:	0c 94 4d 21 	jmp	0x429a	; 0x429a <_ZN9frt_queueIjE7ISR_getEPj>
     21e:	0c 94 a0 19 	jmp	0x3340	; 0x3340 <_ZN14frt_text_queue14check_for_charEv>
     222:	0c 94 e2 1d 	jmp	0x3bc4	; 0x3bc4 <_ZN5rs23212clear_screenEv>
     226:	0c 94 63 1c 	jmp	0x38c6	; 0x38c6 <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 d9 07 	jmp	0xfb2	; 0xfb2 <_ZN9frt_queueIhE7butt_inERKh>
     22e:	0c 94 66 1c 	jmp	0x38cc	; 0x38cc <_ZN8emstreamlsE15ser_manipulator+0x3c>
     232:	0c 94 9f 21 	jmp	0x433e	; 0x433e <_ZN9frt_queueIjE11ISR_butt_inERKj>
     236:	0c 94 60 1c 	jmp	0x38c0	; 0x38c0 <_ZN8emstreamlsE15ser_manipulator+0x30>
     23a:	0c 94 24 07 	jmp	0xe48	; 0xe48 <_ZN9frt_queueIhE9not_emptyEv>
     23e:	0c 94 e0 22 	jmp	0x45c0	; 0x45c0 <_GLOBAL__sub_I_counter>
     242:	0c 94 2f 07 	jmp	0xe5e	; 0xe5e <_ZN9frt_queueIhE8is_emptyEv>
     246:	0c 94 e4 04 	jmp	0x9c8	; 0x9c8 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     24a:	0c 94 82 19 	jmp	0x3304	; 0x3304 <_ZN14frt_text_queue7getcharEv>
     24e:	0c 94 8b 1c 	jmp	0x3916	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
     252:	0c 94 5e 21 	jmp	0x42bc	; 0x42bc <_ZN9frt_queueIjE7ISR_getEv>
     256:	0c 94 a9 1d 	jmp	0x3b52	; 0x3b52 <_ZN5rs2327getcharEv>
     25a:	0c 94 81 07 	jmp	0xf02	; 0xf02 <_ZN9frt_queueIhE7ISR_getEPh>
     25e:	0c 94 c1 07 	jmp	0xf82	; 0xf82 <_ZN9frt_queueIhE7ISR_putERKh>
     262:	0c 94 41 20 	jmp	0x4082	; 0x4082 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     266:	0c 94 a7 20 	jmp	0x414e	; 0x414e <_ZN9frt_queueIiE8is_emptyEv>
     26a:	0c 94 ab 19 	jmp	0x3356	; 0x3356 <_ZN14frt_text_queue7putcharEc>
     26e:	0c 94 43 04 	jmp	0x886	; 0x886 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     272:	0c 94 cf 1d 	jmp	0x3b9e	; 0x3b9e <_ZN5rs23214check_for_charEv>
     276:	0c 94 b1 20 	jmp	0x4162	; 0x4162 <_ZN9frt_queueIjE10get_a_copyERj>
     27a:	0c 94 80 20 	jmp	0x4100	; 0x4100 <_ZN9frt_queueIjE9not_emptyEv>
     27e:	0c 94 bd 20 	jmp	0x417a	; 0x417a <_ZN9frt_queueIjE10get_a_copyEv>
     282:	0c 94 c7 04 	jmp	0x98e	; 0x98e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     286:	0c 94 a9 07 	jmp	0xf52	; 0xf52 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     28a:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <_ZN8emstreamlsE15ser_manipulator+0x24>
     28e:	0c 94 23 22 	jmp	0x4446	; 0x4446 <_ZN9frt_queueIiE7butt_inERKi>
     292:	0c 94 95 20 	jmp	0x412a	; 0x412a <_ZN9frt_queueIiE12num_items_inEv>
     296:	0c 94 9c 20 	jmp	0x4138	; 0x4138 <_ZN9frt_queueIiE9not_emptyEv>
     29a:	0c 94 ff 20 	jmp	0x41fe	; 0x41fe <_ZN9frt_queueIiE10get_a_copyERi>
     29e:	0c 94 bd 03 	jmp	0x77a	; 0x77a <_ZN8I2CAgent11writePacketER7Command>
     2a2:	0c 94 79 20 	jmp	0x40f2	; 0x40f2 <_ZN9frt_queueIjE12num_items_inEv>
     2a6:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <_ZN8I2CAgent8transmitER7Command>
     2aa:	0c 94 dc 04 	jmp	0x9b8	; 0x9b8 <_ZN9I2CMaster9DoneState7executeER6Packet>
     2ae:	0c 94 74 04 	jmp	0x8e8	; 0x8e8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2b2:	0c 94 d8 20 	jmp	0x41b0	; 0x41b0 <_ZN9frt_queueIjE3getEPj>
     2b6:	0c 94 13 07 	jmp	0xe26	; 0xe26 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2ba:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2be:	0c 94 81 1c 	jmp	0x3902	; 0x3902 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2c2:	0c 94 79 1c 	jmp	0x38f2	; 0x38f2 <_ZN8emstreamlsE15ser_manipulator+0x62>
     2c6:	0c 94 f8 03 	jmp	0x7f0	; 0x7f0 <_ZN9I2CMaster10StartState7executeER6Packet>
     2ca:	0c 94 38 18 	jmp	0x3070	; 0x3070 <_ZN8frt_task12print_statusER8emstream>
     2ce:	0c 94 e7 21 	jmp	0x43ce	; 0x43ce <_ZN9frt_queueIiE7ISR_putERKi>
     2d2:	0c 94 20 03 	jmp	0x640	; 0x640 <_call_static_run_method>
     2d6:	0c 94 48 20 	jmp	0x4090	; 0x4090 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2da:	0c 94 76 21 	jmp	0x42ec	; 0x42ec <_ZN9frt_queueIiE7ISR_getEPi>
     2de:	0c 94 45 07 	jmp	0xe8a	; 0xe8a <_ZN9frt_queueIhE10get_a_copyEv>
     2e2:	0c 94 76 11 	jmp	0x22ec	; 0x22ec <prvIdleTask>
     2e6:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     2ea:	0c 94 8b 20 	jmp	0x4116	; 0x4116 <_ZN9frt_queueIjE8is_emptyEv>
     2ee:	0c 94 87 21 	jmp	0x430e	; 0x430e <_ZN9frt_queueIiE7ISR_getEv>
     2f2:	0c 94 85 1d 	jmp	0x3b0a	; 0x3b0a <_ZN5rs2327putcharEc>
     2f6:	0c 94 92 03 	jmp	0x724	; 0x724 <_ZN8I2CAgent7receiveEv>
     2fa:	0c 94 32 21 	jmp	0x4264	; 0x4264 <_ZN9frt_queueIiE3getEv>
     2fe:	0c 94 ff 21 	jmp	0x43fe	; 0x43fe <_ZN9frt_queueIjE7butt_inERKj>
     302:	0c 94 26 21 	jmp	0x424c	; 0x424c <_ZN9frt_queueIiE3getEPi>
     306:	0c 94 fa 1b 	jmp	0x37f4	; 0x37f4 <_ZN8emstream13ready_to_sendEv>
     30a:	0c 94 01 1c 	jmp	0x3802	; 0x3802 <_ZN8emstream12transmit_nowEv>
     30e:	0c 94 69 07 	jmp	0xed2	; 0xed2 <_ZN9frt_queueIhE3getEv>
     312:	0c 94 fc 1b 	jmp	0x37f8	; 0x37f8 <_ZN8emstream7getcharEv>
     316:	0c 94 5d 20 	jmp	0x40ba	; 0x40ba <_ZN9frt_queueIiE16ISR_num_items_inEv>
     31a:	0c 94 ff 1b 	jmp	0x37fe	; 0x37fe <_ZN8emstream14check_for_charEv>
     31e:	0c 94 02 1c 	jmp	0x3804	; 0x3804 <_ZN8emstream12clear_screenEv>
     322:	0c 94 b7 21 	jmp	0x436e	; 0x436e <_ZN9frt_queueIjE7ISR_putERKj>
     326:	0c 94 89 1c 	jmp	0x3912	; 0x3912 <_ZN8emstreamlsE15ser_manipulator+0x82>
     32a:	0c 94 01 07 	jmp	0xe02	; 0xe02 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     32e:	0c 94 5d 1c 	jmp	0x38ba	; 0x38ba <_ZN8emstreamlsE15ser_manipulator+0x2a>
     332:	0c 94 08 07 	jmp	0xe10	; 0xe10 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     336:	0c 94 cf 21 	jmp	0x439e	; 0x439e <_ZN9frt_queueIiE11ISR_butt_inERKi>
     33a:	0c 94 1d 07 	jmp	0xe3a	; 0xe3a <_ZN9frt_queueIhE12num_items_inEv>
     33e:	0c 94 39 07 	jmp	0xe72	; 0xe72 <_ZN9frt_queueIhE10get_a_copyERh>
     342:	0c 94 d4 08 	jmp	0x11a8	; 0x11a8 <_ZN10task_sonar3runEv>
     346:	0c 94 92 07 	jmp	0xf24	; 0xf24 <_ZN9frt_queueIhE7ISR_getEv>
     34a:	0c 94 12 04 	jmp	0x824	; 0x824 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     34e:	0c 94 a1 04 	jmp	0x942	; 0x942 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     352:	0c 94 64 20 	jmp	0x40c8	; 0x40c8 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     356:	0c 94 5b 03 	jmp	0x6b6	; 0x6b6 <_ZN8I2CAgent10readPacketEv>
     35a:	0c 94 eb 07 	jmp	0xfd6	; 0xfd6 <_ZN9frt_queueIhE3putERKh>
     35e:	0c 94 e0 04 	jmp	0x9c0	; 0x9c0 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     362:	0c 94 e4 20 	jmp	0x41c8	; 0x41c8 <_ZN9frt_queueIjE3getEv>
     366:	0c 94 5d 07 	jmp	0xeba	; 0xeba <_ZN9frt_queueIhE3getEPh>
     36a:	0c 94 63 1b 	jmp	0x36c6	; 0x36c6 <__cxa_pure_virtual>
     36e:	0c 94 0b 21 	jmp	0x4216	; 0x4216 <_ZN9frt_queueIiE10get_a_copyEv>
     372:	0c 94 11 22 	jmp	0x4422	; 0x4422 <_ZN9frt_queueIjE3putERKj>
     376:	0c 94 6f 20 	jmp	0x40de	; 0x40de <_ZN9frt_queueIiE12ISR_is_emptyEv>
     37a:	0c 94 66 03 	jmp	0x6cc	; 0x6cc <_ZN8I2CAgent11resetPacketER6Packet>
     37e:	0c 94 68 1c 	jmp	0x38d0	; 0x38d0 <_ZN8emstreamlsE15ser_manipulator+0x40>
     382:	0c 94 53 20 	jmp	0x40a6	; 0x40a6 <_ZN9frt_queueIjE12ISR_is_emptyEv>

00000386 <__trampolines_end>:
     386:	53 6f       	ori	r21, 0xF3	; 243
     388:	6e 61       	ori	r22, 0x1E	; 30
     38a:	72 3a       	cpi	r23, 0xA2	; 162
     38c:	20 00       	.word	0x0020	; ????

0000038e <_ZZN9task_user11show_statusEvE3__c_4>:
     38e:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

00000399 <_ZZN9task_user11show_statusEvE3__c_3>:
     399:	2f 00                                               /.

0000039b <_ZZN9task_user11show_statusEvE3__c_2>:
     39b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003a9 <_ZZN9task_user11show_statusEvE3__c_1>:
     3a9:	54 69 6d 65 3a 20 00                                Time: .

000003b0 <_ZZN9task_user11show_statusEvE3__c_0>:
     3b0:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

000003bc <_ZZN9task_user11show_statusEvE3__c>:
     3bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003db <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3db:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000003ea <_ZZN9task_user18print_help_messageEvE3__c_9>:
     3ea:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     3fa:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000405 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     405:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     415:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000423 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     423:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     433:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     443:	6d 61 74 69 6f 6e 00                                mation.

0000044a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     44a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     45a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000046b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     46b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     47b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000483 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     483:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     493:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000049f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     49f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4af:	68 65 20 41 56 52 00                                he AVR.

000004b6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4b6:	20 68 65 6c 70 00                                    help.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004db <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4db:	1b 5b 33 30 6d 00                                   .[30m.

000004e1 <_ZZN9task_user18print_help_messageEvE3__c>:
     4e1:	1b 5b 34 36 6d 00                                   .[46m.

000004e7 <_ZZN9task_user3runEvE3__c_3>:
     4e7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     4f7:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000504 <_ZZN9task_user3runEvE3__c_2>:
     504:	3a 57 54 46 3f 00                                   :WTF?.

0000050a <_ZZN9task_user3runEvE3__c_1>:
     50a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     51a:	65 00                                               e.

0000051c <_ZZN9task_user3runEvE3__c_0>:
     51c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000052a <_ZZN9task_user3runEvE3__c>:
     52a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     53a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000548 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     548:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000552 <_ZZN8frt_task15emergency_resetEvE3__c>:
     552:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000561 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     561:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     571:	61 73 6b 20 00                                      ask .

00000576 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     576:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000584 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     584:	20 63 72 65 61 74 65 64 00                           created.

0000058d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     58d:	54 61 73 6b 20 00                                   Task .

00000593 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     593:	1b 5b 32 32 6d 00                                   .[22m.

00000599 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     599:	54 61 73 6b 3a 20 00                                Task: .

000005a0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5a0:	1b 5b 31 6d 00                                      .[1m.

000005a5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5a5:	1b 5b 32 32 6d 00                                   .[22m.

000005ab <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5ab:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005b6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5b6:	1b 5b 31 6d 00                                      .[1m.

000005bb <_ZZ15print_task_listP8emstreamE3__c_9>:
     5bb:	09 09 00                                            ...

000005be <_ZZ15print_task_listP8emstreamE3__c_8>:
     5be:	2f 00                                               /.

000005c0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5c0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005cb <_ZZ15print_task_listP8emstreamE3__c_6>:
     5cb:	09 2d 2d 2d 2d 00                                   .----.

000005d1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5d1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000005dd <_ZZ15print_task_listP8emstreamE3__c_4>:
     5dd:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000005ee <_ZZ15print_task_listP8emstreamE3__c_3>:
     5ee:	09 52 75 6e 73 00                                   .Runs.

000005f4 <_ZZ15print_task_listP8emstreamE3__c_2>:
     5f4:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000600 <_ZZ15print_task_listP8emstreamE3__c_1>:
     600:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000611 <_ZZ15print_task_listP8emstreamE3__c_0>:
     611:	09 53 74 61 63 6b 00                                .Stack.

00000618 <_ZZ15print_task_listP8emstreamE3__c>:
     618:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000623 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     623:	09 00                                               ..

00000625 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     625:	09 00                                               ..

00000627 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     627:	2f 00                                               /.

00000629 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     629:	09 00                                               ..

0000062b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     62b:	09 00                                               ..

0000062d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     62d:	1b 5b 32 32 6d 00                                   .[22m.

00000633 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     633:	1b 5b 31 6d 00                                      .[1m.

00000638 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     638:	1b 5b 31 6d 00                                      .[1m.

0000063d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     63d:	20 20 00                                              .

00000640 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     640:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <_ZN8frt_task22_call_users_run_methodEPS_>

00000644 <__ctors_start>:
     644:	e0 22       	and	r14, r16

00000646 <__ctors_end>:
     646:	11 24       	eor	r1, r1
     648:	1f be       	out	0x3f, r1	; 63
     64a:	cf ef       	ldi	r28, 0xFF	; 255
     64c:	cd bf       	out	0x3d, r28	; 61
     64e:	df e3       	ldi	r29, 0x3F	; 63
     650:	de bf       	out	0x3e, r29	; 62
     652:	00 e0       	ldi	r16, 0x00	; 0
     654:	0c bf       	out	0x3c, r16	; 60
     656:	18 be       	out	0x38, r1	; 56
     658:	19 be       	out	0x39, r1	; 57
     65a:	1a be       	out	0x3a, r1	; 58
     65c:	1b be       	out	0x3b, r1	; 59

0000065e <__do_copy_data>:
     65e:	11 e2       	ldi	r17, 0x21	; 33
     660:	a0 e0       	ldi	r26, 0x00	; 0
     662:	b0 e2       	ldi	r27, 0x20	; 32
     664:	e8 ea       	ldi	r30, 0xA8	; 168
     666:	f8 e4       	ldi	r31, 0x48	; 72
     668:	00 e0       	ldi	r16, 0x00	; 0
     66a:	0b bf       	out	0x3b, r16	; 59
     66c:	02 c0       	rjmp	.+4      	; 0x672 <__do_copy_data+0x14>
     66e:	07 90       	elpm	r0, Z+
     670:	0d 92       	st	X+, r0
     672:	a8 36       	cpi	r26, 0x68	; 104
     674:	b1 07       	cpc	r27, r17
     676:	d9 f7       	brne	.-10     	; 0x66e <__do_copy_data+0x10>
     678:	1b be       	out	0x3b, r1	; 59

0000067a <__do_clear_bss>:
     67a:	22 e3       	ldi	r18, 0x32	; 50
     67c:	a8 e6       	ldi	r26, 0x68	; 104
     67e:	b1 e2       	ldi	r27, 0x21	; 33
     680:	01 c0       	rjmp	.+2      	; 0x684 <.do_clear_bss_start>

00000682 <.do_clear_bss_loop>:
     682:	1d 92       	st	X+, r1

00000684 <.do_clear_bss_start>:
     684:	a6 33       	cpi	r26, 0x36	; 54
     686:	b2 07       	cpc	r27, r18
     688:	e1 f7       	brne	.-8      	; 0x682 <.do_clear_bss_loop>

0000068a <__do_global_ctors>:
     68a:	13 e0       	ldi	r17, 0x03	; 3
     68c:	c3 e2       	ldi	r28, 0x23	; 35
     68e:	d3 e0       	ldi	r29, 0x03	; 3
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	06 c0       	rjmp	.+12     	; 0x6a0 <__do_global_ctors+0x16>
     694:	21 97       	sbiw	r28, 0x01	; 1
     696:	01 09       	sbc	r16, r1
     698:	80 2f       	mov	r24, r16
     69a:	fe 01       	movw	r30, r28
     69c:	0e 94 ae 23 	call	0x475c	; 0x475c <__tablejump2__>
     6a0:	c2 32       	cpi	r28, 0x22	; 34
     6a2:	d1 07       	cpc	r29, r17
     6a4:	80 e0       	ldi	r24, 0x00	; 0
     6a6:	08 07       	cpc	r16, r24
     6a8:	a9 f7       	brne	.-22     	; 0x694 <__do_global_ctors+0xa>
     6aa:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <main>
     6ae:	0c 94 52 24 	jmp	0x48a4	; 0x48a4 <_exit>

000006b2 <__bad_interrupt>:
     6b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006b6 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6b6:	bc 01       	movw	r22, r24
     6b8:	6e 5f       	subi	r22, 0xFE	; 254
     6ba:	7f 4f       	sbci	r23, 0xFF	; 255
     6bc:	dc 01       	movw	r26, r24
     6be:	ed 91       	ld	r30, X+
     6c0:	fc 91       	ld	r31, X
     6c2:	00 84       	ldd	r0, Z+8	; 0x08
     6c4:	f1 85       	ldd	r31, Z+9	; 0x09
     6c6:	e0 2d       	mov	r30, r0
     6c8:	19 95       	eicall
     6ca:	08 95       	ret

000006cc <_ZN8I2CAgent11resetPacketER6Packet>:
}

void I2CAgent::resetPacket( Packet & packet )
{
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	eb 01       	movw	r28, r22
  while( packet.not_empty() )
     6d2:	e8 81       	ld	r30, Y
     6d4:	f9 81       	ldd	r31, Y+1	; 0x01
     6d6:	00 8c       	ldd	r0, Z+24	; 0x18
     6d8:	f1 8d       	ldd	r31, Z+25	; 0x19
     6da:	e0 2d       	mov	r30, r0
     6dc:	ce 01       	movw	r24, r28
     6de:	19 95       	eicall
     6e0:	88 23       	and	r24, r24
     6e2:	41 f0       	breq	.+16     	; 0x6f4 <_ZN8I2CAgent11resetPacketER6Packet+0x28>
  {
    packet.get();
     6e4:	e8 81       	ld	r30, Y
     6e6:	f9 81       	ldd	r31, Y+1	; 0x01
     6e8:	00 84       	ldd	r0, Z+8	; 0x08
     6ea:	f1 85       	ldd	r31, Z+9	; 0x09
     6ec:	e0 2d       	mov	r30, r0
     6ee:	ce 01       	movw	r24, r28
     6f0:	19 95       	eicall
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
  while( packet.not_empty() )
     6f2:	ef cf       	rjmp	.-34     	; 0x6d2 <_ZN8I2CAgent11resetPacketER6Packet+0x6>
  {
    packet.get();
  }
}
     6f4:	df 91       	pop	r29
     6f6:	cf 91       	pop	r28
     6f8:	08 95       	ret

000006fa <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
     6fe:	ec 01       	movw	r28, r24
  writePacket(cmd);
     700:	e8 81       	ld	r30, Y
     702:	f9 81       	ldd	r31, Y+1	; 0x01
     704:	04 80       	ldd	r0, Z+4	; 0x04
     706:	f5 81       	ldd	r31, Z+5	; 0x05
     708:	e0 2d       	mov	r30, r0
     70a:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     70c:	be 01       	movw	r22, r28
     70e:	63 5f       	subi	r22, 0xF3	; 243
     710:	7f 4f       	sbci	r23, 0xFF	; 255

  };
  
  I2CMaster(TWI_t * interface, uint32_t i2c_freq);

  Transmitter * getTransmitter()  { return transmitter_; }
     712:	e8 8d       	ldd	r30, Y+24	; 0x18
     714:	f9 8d       	ldd	r31, Y+25	; 0x19
     716:	80 81       	ld	r24, Z
     718:	91 81       	ldd	r25, Z+1	; 0x01
     71a:	0e 94 32 06 	call	0xc64	; 0xc64 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	08 95       	ret

00000724 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     724:	ef 92       	push	r14
     726:	ff 92       	push	r15
     728:	0f 93       	push	r16
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     730:	7c 01       	movw	r14, r24
     732:	82 e0       	ldi	r24, 0x02	; 2
     734:	e8 0e       	add	r14, r24
     736:	f1 1c       	adc	r15, r1
     738:	e8 81       	ld	r30, Y
     73a:	f9 81       	ldd	r31, Y+1	; 0x01
     73c:	00 84       	ldd	r0, Z+8	; 0x08
     73e:	f1 85       	ldd	r31, Z+9	; 0x09
     740:	e0 2d       	mov	r30, r0
     742:	b7 01       	movw	r22, r14
     744:	ce 01       	movw	r24, r28
     746:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     748:	28 85       	ldd	r18, Y+8	; 0x08
     74a:	39 85       	ldd	r19, Y+9	; 0x09
     74c:	4a 85       	ldd	r20, Y+10	; 0x0a
     74e:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     750:	be 01       	movw	r22, r28
     752:	64 5e       	subi	r22, 0xE4	; 228
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	00 e0       	ldi	r16, 0x00	; 0
     758:	8e 81       	ldd	r24, Y+6	; 0x06
     75a:	9f 81       	ldd	r25, Y+7	; 0x07
     75c:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     760:	e8 8d       	ldd	r30, Y+24	; 0x18
     762:	f9 8d       	ldd	r31, Y+25	; 0x19
  return driver_->getReceiver()->run(inPacket_);
     764:	b7 01       	movw	r22, r14
     766:	82 81       	ldd	r24, Z+2	; 0x02
     768:	93 81       	ldd	r25, Z+3	; 0x03
     76a:	0e 94 59 06 	call	0xcb2	; 0xcb2 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	0f 91       	pop	r16
     774:	ff 90       	pop	r15
     776:	ef 90       	pop	r14
     778:	08 95       	ret

0000077a <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     77a:	cf 92       	push	r12
     77c:	df 92       	push	r13
     77e:	ef 92       	push	r14
     780:	ff 92       	push	r15
     782:	0f 93       	push	r16
     784:	cf 93       	push	r28
     786:	df 93       	push	r29
     788:	ec 01       	movw	r28, r24
     78a:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     78c:	6c 01       	movw	r12, r24
     78e:	8d e0       	ldi	r24, 0x0D	; 13
     790:	c8 0e       	add	r12, r24
     792:	d1 1c       	adc	r13, r1
     794:	e8 81       	ld	r30, Y
     796:	f9 81       	ldd	r31, Y+1	; 0x01
     798:	00 84       	ldd	r0, Z+8	; 0x08
     79a:	f1 85       	ldd	r31, Z+9	; 0x09
     79c:	e0 2d       	mov	r30, r0
     79e:	b6 01       	movw	r22, r12
     7a0:	ce 01       	movw	r24, r28
     7a2:	19 95       	eicall
     7a4:	2b 89       	ldd	r18, Y+19	; 0x13
     7a6:	3c 89       	ldd	r19, Y+20	; 0x14
     7a8:	4d 89       	ldd	r20, Y+21	; 0x15
     7aa:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7ac:	be 01       	movw	r22, r28
     7ae:	65 5e       	subi	r22, 0xE5	; 229
     7b0:	7f 4f       	sbci	r23, 0xFF	; 255
     7b2:	00 e0       	ldi	r16, 0x00	; 0
     7b4:	89 89       	ldd	r24, Y+17	; 0x11
     7b6:	9a 89       	ldd	r25, Y+18	; 0x12
     7b8:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7bc:	d7 01       	movw	r26, r14
     7be:	ed 91       	ld	r30, X+
     7c0:	fc 91       	ld	r31, X
     7c2:	01 90       	ld	r0, Z+
     7c4:	f0 81       	ld	r31, Z
     7c6:	e0 2d       	mov	r30, r0
     7c8:	b6 01       	movw	r22, r12
     7ca:	c7 01       	movw	r24, r14
     7cc:	19 95       	eicall
}
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	0f 91       	pop	r16
     7d4:	ff 90       	pop	r15
     7d6:	ef 90       	pop	r14
     7d8:	df 90       	pop	r13
     7da:	cf 90       	pop	r12
     7dc:	08 95       	ret

000007de <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7de:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e0:	62 8f       	std	Z+26, r22	; 0x1a
  writeCommand_ = addr << 1;
     7e2:	86 2f       	mov	r24, r22
     7e4:	88 0f       	add	r24, r24
     7e6:	83 8f       	std	Z+27, r24	; 0x1b
  readCommand_ = addr << 1 | 1 << 0;
     7e8:	68 2f       	mov	r22, r24
     7ea:	61 60       	ori	r22, 0x01	; 1
     7ec:	64 8f       	std	Z+28, r22	; 0x1c
     7ee:	08 95       	ret

000007f0 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	ec 01       	movw	r28, r24
     7fa:	cb 01       	movw	r24, r22
  TWI_t *       getInterfacePtr() { return interface_; }
     7fc:	ef 81       	ldd	r30, Y+7	; 0x07
     7fe:	f8 85       	ldd	r31, Y+8	; 0x08
     800:	04 81       	ldd	r16, Z+4	; 0x04
     802:	15 81       	ldd	r17, Z+5	; 0x05
  driver_->getInterfacePtr()->MASTER.ADDR = packet.get();
     804:	db 01       	movw	r26, r22
     806:	ed 91       	ld	r30, X+
     808:	fc 91       	ld	r31, X
     80a:	00 84       	ldd	r0, Z+8	; 0x08
     80c:	f1 85       	ldd	r31, Z+9	; 0x09
     80e:	e0 2d       	mov	r30, r0
     810:	19 95       	eicall
     812:	f8 01       	movw	r30, r16
     814:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
     816:	8a 81       	ldd	r24, Y+2	; 0x02
     818:	9b 81       	ldd	r25, Y+3	; 0x03
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	1f 91       	pop	r17
     820:	0f 91       	pop	r16
     822:	08 95       	ret

00000824 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::StatusState::execute( Packet & packet )
{
     824:	cf 93       	push	r28
     826:	df 93       	push	r29
     828:	1f 92       	push	r1
     82a:	1f 92       	push	r1
     82c:	cd b7       	in	r28, 0x3d	; 61
     82e:	de b7       	in	r29, 0x3e	; 62
     830:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     832:	19 96       	adiw	r26, 0x09	; 9
     834:	8d 91       	ld	r24, X+
     836:	9c 91       	ld	r25, X
     838:	1a 97       	sbiw	r26, 0x0a	; 10
     83a:	89 83       	std	Y+1, r24	; 0x01
     83c:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_WIF_bm)) ){ }
     83e:	29 81       	ldd	r18, Y+1	; 0x01
     840:	3a 81       	ldd	r19, Y+2	; 0x02
     842:	21 50       	subi	r18, 0x01	; 1
     844:	31 09       	sbc	r19, r1
     846:	29 83       	std	Y+1, r18	; 0x01
     848:	3a 83       	std	Y+2, r19	; 0x02
     84a:	23 2b       	or	r18, r19
     84c:	51 f0       	breq	.+20     	; 0x862 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3e>
     84e:	17 96       	adiw	r26, 0x07	; 7
     850:	ed 91       	ld	r30, X+
     852:	fc 91       	ld	r31, X
     854:	18 97       	sbiw	r26, 0x08	; 8
     856:	04 80       	ldd	r0, Z+4	; 0x04
     858:	f5 81       	ldd	r31, Z+5	; 0x05
     85a:	e0 2d       	mov	r30, r0
     85c:	94 81       	ldd	r25, Z+4	; 0x04
     85e:	90 75       	andi	r25, 0x50	; 80
     860:	71 f7       	brne	.-36     	; 0x83e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
  if( counter == 0 )
     862:	89 81       	ldd	r24, Y+1	; 0x01
     864:	9a 81       	ldd	r25, Y+2	; 0x02
     866:	89 2b       	or	r24, r25
     868:	29 f4       	brne	.+10     	; 0x874 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x50>
  {
    return returnState_;
     86a:	14 96       	adiw	r26, 0x04	; 4
     86c:	8d 91       	ld	r24, X+
     86e:	9c 91       	ld	r25, X
     870:	15 97       	sbiw	r26, 0x05	; 5
     872:	04 c0       	rjmp	.+8      	; 0x87c <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
  }
  else
  {
    return nextState_;
     874:	12 96       	adiw	r26, 0x02	; 2
     876:	8d 91       	ld	r24, X+
     878:	9c 91       	ld	r25, X
     87a:	13 97       	sbiw	r26, 0x03	; 3
  }
}
     87c:	0f 90       	pop	r0
     87e:	0f 90       	pop	r0
     880:	df 91       	pop	r29
     882:	cf 91       	pop	r28
     884:	08 95       	ret

00000886 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::StatusState::execute( Packet & packet )
{
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	1f 92       	push	r1
     88c:	1f 92       	push	r1
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     894:	19 96       	adiw	r26, 0x09	; 9
     896:	8d 91       	ld	r24, X+
     898:	9c 91       	ld	r25, X
     89a:	1a 97       	sbiw	r26, 0x0a	; 10
     89c:	89 83       	std	Y+1, r24	; 0x01
     89e:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_RIF_bm)) ){ }
     8a0:	29 81       	ldd	r18, Y+1	; 0x01
     8a2:	3a 81       	ldd	r19, Y+2	; 0x02
     8a4:	21 50       	subi	r18, 0x01	; 1
     8a6:	31 09       	sbc	r19, r1
     8a8:	29 83       	std	Y+1, r18	; 0x01
     8aa:	3a 83       	std	Y+2, r19	; 0x02
     8ac:	23 2b       	or	r18, r19
     8ae:	51 f0       	breq	.+20     	; 0x8c4 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x3e>
     8b0:	17 96       	adiw	r26, 0x07	; 7
     8b2:	ed 91       	ld	r30, X+
     8b4:	fc 91       	ld	r31, X
     8b6:	18 97       	sbiw	r26, 0x08	; 8
     8b8:	04 80       	ldd	r0, Z+4	; 0x04
     8ba:	f5 81       	ldd	r31, Z+5	; 0x05
     8bc:	e0 2d       	mov	r30, r0
     8be:	94 81       	ldd	r25, Z+4	; 0x04
     8c0:	90 79       	andi	r25, 0x90	; 144
     8c2:	71 f7       	brne	.-36     	; 0x8a0 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x1a>
  if( counter == 0 ) {
     8c4:	89 81       	ldd	r24, Y+1	; 0x01
     8c6:	9a 81       	ldd	r25, Y+2	; 0x02
     8c8:	89 2b       	or	r24, r25
     8ca:	29 f4       	brne	.+10     	; 0x8d6 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x50>
    return returnState_; }
     8cc:	14 96       	adiw	r26, 0x04	; 4
     8ce:	8d 91       	ld	r24, X+
     8d0:	9c 91       	ld	r25, X
     8d2:	15 97       	sbiw	r26, 0x05	; 5
     8d4:	04 c0       	rjmp	.+8      	; 0x8de <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x58>
  else {
    return nextState_; }
     8d6:	12 96       	adiw	r26, 0x02	; 2
     8d8:	8d 91       	ld	r24, X+
     8da:	9c 91       	ld	r25, X
     8dc:	13 97       	sbiw	r26, 0x03	; 3
}
     8de:	0f 90       	pop	r0
     8e0:	0f 90       	pop	r0
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	08 95       	ret

000008e8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::ExchangeState::execute( Packet & packet )
{
     8e8:	ef 92       	push	r14
     8ea:	ff 92       	push	r15
     8ec:	0f 93       	push	r16
     8ee:	1f 93       	push	r17
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	8c 01       	movw	r16, r24
     8f6:	eb 01       	movw	r28, r22
  if( packet.not_empty() )
     8f8:	e8 81       	ld	r30, Y
     8fa:	f9 81       	ldd	r31, Y+1	; 0x01
     8fc:	00 8c       	ldd	r0, Z+24	; 0x18
     8fe:	f1 8d       	ldd	r31, Z+25	; 0x19
     900:	e0 2d       	mov	r30, r0
     902:	cb 01       	movw	r24, r22
     904:	19 95       	eicall
     906:	88 23       	and	r24, r24
     908:	81 f0       	breq	.+32     	; 0x92a <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x42>
     90a:	d8 01       	movw	r26, r16
     90c:	17 96       	adiw	r26, 0x07	; 7
     90e:	ed 91       	ld	r30, X+
     910:	fc 91       	ld	r31, X
     912:	18 97       	sbiw	r26, 0x08	; 8
     914:	e4 80       	ldd	r14, Z+4	; 0x04
     916:	f5 80       	ldd	r15, Z+5	; 0x05
  {
    driver_->getInterfacePtr()->MASTER.DATA = packet.get();
     918:	e8 81       	ld	r30, Y
     91a:	f9 81       	ldd	r31, Y+1	; 0x01
     91c:	00 84       	ldd	r0, Z+8	; 0x08
     91e:	f1 85       	ldd	r31, Z+9	; 0x09
     920:	e0 2d       	mov	r30, r0
     922:	ce 01       	movw	r24, r28
     924:	19 95       	eicall
     926:	f7 01       	movw	r30, r14
     928:	87 83       	std	Z+7, r24	; 0x07
  }
  return nextState_;
}
     92a:	d8 01       	movw	r26, r16
     92c:	12 96       	adiw	r26, 0x02	; 2
     92e:	8d 91       	ld	r24, X+
     930:	9c 91       	ld	r25, X
     932:	13 97       	sbiw	r26, 0x03	; 3
     934:	df 91       	pop	r29
     936:	cf 91       	pop	r28
     938:	1f 91       	pop	r17
     93a:	0f 91       	pop	r16
     93c:	ff 90       	pop	r15
     93e:	ef 90       	pop	r14
     940:	08 95       	ret

00000942 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::ExchangeState::execute( Packet & packet )
{
     942:	0f 93       	push	r16
     944:	1f 93       	push	r17
     946:	cf 93       	push	r28
     948:	df 93       	push	r29
     94a:	1f 92       	push	r1
     94c:	cd b7       	in	r28, 0x3d	; 61
     94e:	de b7       	in	r29, 0x3e	; 62
     950:	8c 01       	movw	r16, r24
     952:	cb 01       	movw	r24, r22
     954:	d8 01       	movw	r26, r16
     956:	17 96       	adiw	r26, 0x07	; 7
     958:	ed 91       	ld	r30, X+
     95a:	fc 91       	ld	r31, X
     95c:	18 97       	sbiw	r26, 0x08	; 8
     95e:	04 80       	ldd	r0, Z+4	; 0x04
     960:	f5 81       	ldd	r31, Z+5	; 0x05
     962:	e0 2d       	mov	r30, r0
  uint8_t data = driver_->getInterfacePtr()->MASTER.DATA;
     964:	27 81       	ldd	r18, Z+7	; 0x07
     966:	29 83       	std	Y+1, r18	; 0x01
  packet.put(data);
     968:	db 01       	movw	r26, r22
     96a:	ed 91       	ld	r30, X+
     96c:	fc 91       	ld	r31, X
     96e:	01 90       	ld	r0, Z+
     970:	f0 81       	ld	r31, Z
     972:	e0 2d       	mov	r30, r0
     974:	be 01       	movw	r22, r28
     976:	6f 5f       	subi	r22, 0xFF	; 255
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	19 95       	eicall
  return nextState_;
}
     97c:	f8 01       	movw	r30, r16
     97e:	82 81       	ldd	r24, Z+2	; 0x02
     980:	93 81       	ldd	r25, Z+3	; 0x03
     982:	0f 90       	pop	r0
     984:	df 91       	pop	r29
     986:	cf 91       	pop	r28
     988:	1f 91       	pop	r17
     98a:	0f 91       	pop	r16
     98c:	08 95       	ret

0000098e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::PacketStatusState::execute( Packet & packet )
{
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	ec 01       	movw	r28, r24
     994:	cb 01       	movw	r24, r22
  if( packet.is_empty() )
     996:	db 01       	movw	r26, r22
     998:	ed 91       	ld	r30, X+
     99a:	fc 91       	ld	r31, X
     99c:	04 88       	ldd	r0, Z+20	; 0x14
     99e:	f5 89       	ldd	r31, Z+21	; 0x15
     9a0:	e0 2d       	mov	r30, r0
     9a2:	19 95       	eicall
     9a4:	88 23       	and	r24, r24
     9a6:	19 f0       	breq	.+6      	; 0x9ae <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
  {
    return nextState_;
     9a8:	8a 81       	ldd	r24, Y+2	; 0x02
     9aa:	9b 81       	ldd	r25, Y+3	; 0x03
     9ac:	02 c0       	rjmp	.+4      	; 0x9b2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
  }
  else
  {
    return returnState_;
     9ae:	8c 81       	ldd	r24, Y+4	; 0x04
     9b0:	9d 81       	ldd	r25, Y+5	; 0x05
  }
}
     9b2:	df 91       	pop	r29
     9b4:	cf 91       	pop	r28
     9b6:	08 95       	ret

000009b8 <_ZN9I2CMaster9DoneState7executeER6Packet>:
}

I2CMaster::State * I2CMaster::DoneState::execute( Packet & packet )
{
  return nextState_;
}
     9b8:	fc 01       	movw	r30, r24
     9ba:	82 81       	ldd	r24, Z+2	; 0x02
     9bc:	93 81       	ldd	r25, Z+3	; 0x03
     9be:	08 95       	ret

000009c0 <_ZN9I2CMaster10ErrorState7executeER6Packet>:

I2CMaster::State * I2CMaster::ErrorState::execute( Packet & packet )
{
  return nextState_;
}
     9c0:	fc 01       	movw	r30, r24
     9c2:	82 81       	ldd	r24, Z+2	; 0x02
     9c4:	93 81       	ldd	r25, Z+3	; 0x03
     9c6:	08 95       	ret

000009c8 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
    return returnState_;
  }
}

I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
     9c8:	0f 93       	push	r16
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	8c 01       	movw	r16, r24
     9d2:	eb 01       	movw	r28, r22
  if( packet.num_items_in() == packet.getSize() ) {
     9d4:	e8 81       	ld	r30, Y
     9d6:	f9 81       	ldd	r31, Y+1	; 0x01
     9d8:	04 8c       	ldd	r0, Z+28	; 0x1c
     9da:	f5 8d       	ldd	r31, Z+29	; 0x1d
     9dc:	e0 2d       	mov	r30, r0
     9de:	cb 01       	movw	r24, r22
     9e0:	19 95       	eicall
     9e2:	2a 85       	ldd	r18, Y+10	; 0x0a
     9e4:	30 e0       	ldi	r19, 0x00	; 0
     9e6:	82 17       	cp	r24, r18
     9e8:	93 07       	cpc	r25, r19
     9ea:	79 f4       	brne	.+30     	; 0xa0a <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
}

void I2CMaster::send_ack_stop(void)
{
  interface_->MASTER.CTRLC = (1<<TWI_MASTER_CMD1_bp) | (1<<TWI_MASTER_CMD0_bp);
     9ec:	d8 01       	movw	r26, r16
     9ee:	17 96       	adiw	r26, 0x07	; 7
     9f0:	ed 91       	ld	r30, X+
     9f2:	fc 91       	ld	r31, X
     9f4:	18 97       	sbiw	r26, 0x08	; 8
     9f6:	04 80       	ldd	r0, Z+4	; 0x04
     9f8:	f5 81       	ldd	r31, Z+5	; 0x05
     9fa:	e0 2d       	mov	r30, r0
     9fc:	83 e0       	ldi	r24, 0x03	; 3
     9fe:	83 83       	std	Z+3, r24	; 0x03
I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
  if( packet.num_items_in() == packet.getSize() ) {
    // interface_->MASTER.CTRLC = (1<<TWI_MASTER_CMD1_bp) | (1<<TWI_MASTER_CMD0_bp);
    driver_->send_ack_stop();
    return nextState_; }
     a00:	12 96       	adiw	r26, 0x02	; 2
     a02:	8d 91       	ld	r24, X+
     a04:	9c 91       	ld	r25, X
     a06:	13 97       	sbiw	r26, 0x03	; 3
     a08:	0e c0       	rjmp	.+28     	; 0xa26 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     a0a:	d8 01       	movw	r26, r16
     a0c:	17 96       	adiw	r26, 0x07	; 7
     a0e:	ed 91       	ld	r30, X+
     a10:	fc 91       	ld	r31, X
     a12:	18 97       	sbiw	r26, 0x08	; 8
     a14:	04 80       	ldd	r0, Z+4	; 0x04
     a16:	f5 81       	ldd	r31, Z+5	; 0x05
     a18:	e0 2d       	mov	r30, r0
     a1a:	82 e0       	ldi	r24, 0x02	; 2
     a1c:	83 83       	std	Z+3, r24	; 0x03
    driver_->send_ack_stop();
    return nextState_; }
  else {
    // interface_->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
    driver_->byte_recv();
    return returnState_; }
     a1e:	14 96       	adiw	r26, 0x04	; 4
     a20:	8d 91       	ld	r24, X+
     a22:	9c 91       	ld	r25, X
     a24:	15 97       	sbiw	r26, 0x05	; 5
}
     a26:	df 91       	pop	r29
     a28:	cf 91       	pop	r28
     a2a:	1f 91       	pop	r17
     a2c:	0f 91       	pop	r16
     a2e:	08 95       	ret

00000a30 <_ZN9I2CMaster11TransmitterC1EPS_>:
  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
}

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
     a30:	0f 93       	push	r16
     a32:	1f 93       	push	r17
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	ec 01       	movw	r28, r24
     a3a:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     a3c:	68 83       	st	Y, r22
     a3e:	79 83       	std	Y+1, r23	; 0x01
     a40:	89 e0       	ldi	r24, 0x09	; 9
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     a48:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a4a:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     a4c:	88 e1       	ldi	r24, 0x18	; 24
     a4e:	90 e2       	ldi	r25, 0x20	; 32
     a50:	80 83       	st	Z, r24
     a52:	91 83       	std	Z+1, r25	; 0x01
     a54:	07 83       	std	Z+7, r16	; 0x07
     a56:	10 87       	std	Z+8, r17	; 0x08
     a58:	ec 83       	std	Y+4, r30	; 0x04
     a5a:	fd 83       	std	Y+5, r31	; 0x05
     a5c:	8b e0       	ldi	r24, 0x0B	; 11
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     a64:	fc 01       	movw	r30, r24

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     a66:	8b 89       	ldd	r24, Y+19	; 0x13
     a68:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a6a:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     a6c:	2e e1       	ldi	r18, 0x1E	; 30
     a6e:	30 e2       	ldi	r19, 0x20	; 32
     a70:	20 83       	st	Z, r18
     a72:	31 83       	std	Z+1, r19	; 0x01
     a74:	07 83       	std	Z+7, r16	; 0x07
     a76:	10 87       	std	Z+8, r17	; 0x08
     a78:	81 87       	std	Z+9, r24	; 0x09
     a7a:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     a7c:	ee 83       	std	Y+6, r30	; 0x06
     a7e:	ff 83       	std	Y+7, r31	; 0x07
     a80:	89 e0       	ldi	r24, 0x09	; 9
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     a88:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a8a:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     a8c:	8a e2       	ldi	r24, 0x2A	; 42
     a8e:	90 e2       	ldi	r25, 0x20	; 32
     a90:	80 83       	st	Z, r24
     a92:	91 83       	std	Z+1, r25	; 0x01
     a94:	07 83       	std	Z+7, r16	; 0x07
     a96:	10 87       	std	Z+8, r17	; 0x08
     a98:	e8 87       	std	Y+8, r30	; 0x08
     a9a:	f9 87       	std	Y+9, r31	; 0x09
     a9c:	89 e0       	ldi	r24, 0x09	; 9
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     aa4:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     aa6:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     aa8:	86 e3       	ldi	r24, 0x36	; 54
     aaa:	90 e2       	ldi	r25, 0x20	; 32
     aac:	80 83       	st	Z, r24
     aae:	91 83       	std	Z+1, r25	; 0x01
     ab0:	07 83       	std	Z+7, r16	; 0x07
     ab2:	10 87       	std	Z+8, r17	; 0x08
     ab4:	ea 87       	std	Y+10, r30	; 0x0a
     ab6:	fb 87       	std	Y+11, r31	; 0x0b
     ab8:	89 e0       	ldi	r24, 0x09	; 9
     aba:	90 e0       	ldi	r25, 0x00	; 0
     abc:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     ac0:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     ac2:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     ac4:	88 e4       	ldi	r24, 0x48	; 72
     ac6:	90 e2       	ldi	r25, 0x20	; 32
     ac8:	80 83       	st	Z, r24
     aca:	91 83       	std	Z+1, r25	; 0x01
     acc:	07 83       	std	Z+7, r16	; 0x07
     ace:	10 87       	std	Z+8, r17	; 0x08
     ad0:	ec 87       	std	Y+12, r30	; 0x0c
     ad2:	fd 87       	std	Y+13, r31	; 0x0d
     ad4:	89 e0       	ldi	r24, 0x09	; 9
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     adc:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     ade:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     ae0:	82 e4       	ldi	r24, 0x42	; 66
     ae2:	90 e2       	ldi	r25, 0x20	; 32
     ae4:	80 83       	st	Z, r24
     ae6:	91 83       	std	Z+1, r25	; 0x01
     ae8:	07 83       	std	Z+7, r16	; 0x07
     aea:	10 87       	std	Z+8, r17	; 0x08
     aec:	ee 87       	std	Y+14, r30	; 0x0e
     aee:	ff 87       	std	Y+15, r31	; 0x0f
     af0:	80 e1       	ldi	r24, 0x10	; 16
     af2:	97 e2       	ldi	r25, 0x27	; 39
     af4:	8b 8b       	std	Y+19, r24	; 0x13
     af6:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     af8:	8e 81       	ldd	r24, Y+6	; 0x06
     afa:	9f 81       	ldd	r25, Y+7	; 0x07
     afc:	ec 81       	ldd	r30, Y+4	; 0x04
     afe:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b00:	82 83       	std	Z+2, r24	; 0x02
     b02:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     b04:	84 83       	std	Z+4, r24	; 0x04
     b06:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     b08:	8c 85       	ldd	r24, Y+12	; 0x0c
     b0a:	9d 85       	ldd	r25, Y+13	; 0x0d
     b0c:	28 85       	ldd	r18, Y+8	; 0x08
     b0e:	39 85       	ldd	r19, Y+9	; 0x09
     b10:	ee 81       	ldd	r30, Y+6	; 0x06
     b12:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b14:	22 83       	std	Z+2, r18	; 0x02
     b16:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     b18:	84 83       	std	Z+4, r24	; 0x04
     b1a:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     b1c:	8a 85       	ldd	r24, Y+10	; 0x0a
     b1e:	9b 85       	ldd	r25, Y+11	; 0x0b
     b20:	e8 85       	ldd	r30, Y+8	; 0x08
     b22:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b24:	82 83       	std	Z+2, r24	; 0x02
     b26:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     b28:	84 83       	std	Z+4, r24	; 0x04
     b2a:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     b2c:	8e 81       	ldd	r24, Y+6	; 0x06
     b2e:	9f 81       	ldd	r25, Y+7	; 0x07
     b30:	2e 85       	ldd	r18, Y+14	; 0x0e
     b32:	3f 85       	ldd	r19, Y+15	; 0x0f
     b34:	ea 85       	ldd	r30, Y+10	; 0x0a
     b36:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b38:	22 83       	std	Z+2, r18	; 0x02
     b3a:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     b3c:	84 83       	std	Z+4, r24	; 0x04
     b3e:	95 83       	std	Z+5, r25	; 0x05
}
     b40:	df 91       	pop	r29
     b42:	cf 91       	pop	r28
     b44:	1f 91       	pop	r17
     b46:	0f 91       	pop	r16
     b48:	08 95       	ret

00000b4a <_ZN9I2CMaster8ReceiverC1EPS_>:

I2CMaster::Receiver::Receiver( I2CMaster * d )
     b4a:	0f 93       	push	r16
     b4c:	1f 93       	push	r17
     b4e:	cf 93       	push	r28
     b50:	df 93       	push	r29
     b52:	ec 01       	movw	r28, r24
     b54:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     b56:	68 83       	st	Y, r22
     b58:	79 83       	std	Y+1, r23	; 0x01
     b5a:	89 e0       	ldi	r24, 0x09	; 9
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     b62:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     b64:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     b66:	88 e1       	ldi	r24, 0x18	; 24
     b68:	90 e2       	ldi	r25, 0x20	; 32
     b6a:	80 83       	st	Z, r24
     b6c:	91 83       	std	Z+1, r25	; 0x01
     b6e:	07 83       	std	Z+7, r16	; 0x07
     b70:	10 87       	std	Z+8, r17	; 0x08
     b72:	ec 83       	std	Y+4, r30	; 0x04
     b74:	fd 83       	std	Y+5, r31	; 0x05
     b76:	8b e0       	ldi	r24, 0x0B	; 11
     b78:	90 e0       	ldi	r25, 0x00	; 0
     b7a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     b7e:	fc 01       	movw	r30, r24

I2CMaster::Receiver::Receiver( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     b80:	8b 89       	ldd	r24, Y+19	; 0x13
     b82:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     b84:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     b86:	24 e2       	ldi	r18, 0x24	; 36
     b88:	30 e2       	ldi	r19, 0x20	; 32
     b8a:	20 83       	st	Z, r18
     b8c:	31 83       	std	Z+1, r19	; 0x01
     b8e:	07 83       	std	Z+7, r16	; 0x07
     b90:	10 87       	std	Z+8, r17	; 0x08
     b92:	81 87       	std	Z+9, r24	; 0x09
     b94:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     b96:	ee 83       	std	Y+6, r30	; 0x06
     b98:	ff 83       	std	Y+7, r31	; 0x07
     b9a:	89 e0       	ldi	r24, 0x09	; 9
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     ba2:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     ba4:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     ba6:	80 e3       	ldi	r24, 0x30	; 48
     ba8:	90 e2       	ldi	r25, 0x20	; 32
     baa:	80 83       	st	Z, r24
     bac:	91 83       	std	Z+1, r25	; 0x01
     bae:	07 83       	std	Z+7, r16	; 0x07
     bb0:	10 87       	std	Z+8, r17	; 0x08
     bb2:	e8 87       	std	Y+8, r30	; 0x08
     bb4:	f9 87       	std	Y+9, r31	; 0x09
     bb6:	89 e0       	ldi	r24, 0x09	; 9
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     bbe:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bc0:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     bc2:	8c e3       	ldi	r24, 0x3C	; 60
     bc4:	90 e2       	ldi	r25, 0x20	; 32
     bc6:	80 83       	st	Z, r24
     bc8:	91 83       	std	Z+1, r25	; 0x01
     bca:	07 83       	std	Z+7, r16	; 0x07
     bcc:	10 87       	std	Z+8, r17	; 0x08
     bce:	ea 87       	std	Y+10, r30	; 0x0a
     bd0:	fb 87       	std	Y+11, r31	; 0x0b
     bd2:	89 e0       	ldi	r24, 0x09	; 9
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     bda:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bdc:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     bde:	88 e4       	ldi	r24, 0x48	; 72
     be0:	90 e2       	ldi	r25, 0x20	; 32
     be2:	80 83       	st	Z, r24
     be4:	91 83       	std	Z+1, r25	; 0x01
     be6:	07 83       	std	Z+7, r16	; 0x07
     be8:	10 87       	std	Z+8, r17	; 0x08
     bea:	ec 87       	std	Y+12, r30	; 0x0c
     bec:	fd 87       	std	Y+13, r31	; 0x0d
     bee:	89 e0       	ldi	r24, 0x09	; 9
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     bf6:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bf8:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     bfa:	82 e4       	ldi	r24, 0x42	; 66
     bfc:	90 e2       	ldi	r25, 0x20	; 32
     bfe:	80 83       	st	Z, r24
     c00:	91 83       	std	Z+1, r25	; 0x01
     c02:	07 83       	std	Z+7, r16	; 0x07
     c04:	10 87       	std	Z+8, r17	; 0x08
     c06:	ee 87       	std	Y+14, r30	; 0x0e
     c08:	ff 87       	std	Y+15, r31	; 0x0f
     c0a:	80 e1       	ldi	r24, 0x10	; 16
     c0c:	97 e2       	ldi	r25, 0x27	; 39
     c0e:	8b 8b       	std	Y+19, r24	; 0x13
     c10:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     c12:	8e 81       	ldd	r24, Y+6	; 0x06
     c14:	9f 81       	ldd	r25, Y+7	; 0x07
     c16:	ec 81       	ldd	r30, Y+4	; 0x04
     c18:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c1a:	82 83       	std	Z+2, r24	; 0x02
     c1c:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     c1e:	84 83       	std	Z+4, r24	; 0x04
     c20:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     c22:	8c 85       	ldd	r24, Y+12	; 0x0c
     c24:	9d 85       	ldd	r25, Y+13	; 0x0d
     c26:	28 85       	ldd	r18, Y+8	; 0x08
     c28:	39 85       	ldd	r19, Y+9	; 0x09
     c2a:	ee 81       	ldd	r30, Y+6	; 0x06
     c2c:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c2e:	22 83       	std	Z+2, r18	; 0x02
     c30:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     c32:	84 83       	std	Z+4, r24	; 0x04
     c34:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     c36:	8a 85       	ldd	r24, Y+10	; 0x0a
     c38:	9b 85       	ldd	r25, Y+11	; 0x0b
     c3a:	e8 85       	ldd	r30, Y+8	; 0x08
     c3c:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c3e:	82 83       	std	Z+2, r24	; 0x02
     c40:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     c42:	84 83       	std	Z+4, r24	; 0x04
     c44:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     c46:	8e 81       	ldd	r24, Y+6	; 0x06
     c48:	9f 81       	ldd	r25, Y+7	; 0x07
     c4a:	2e 85       	ldd	r18, Y+14	; 0x0e
     c4c:	3f 85       	ldd	r19, Y+15	; 0x0f
     c4e:	ea 85       	ldd	r30, Y+10	; 0x0a
     c50:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c52:	22 83       	std	Z+2, r18	; 0x02
     c54:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     c56:	84 83       	std	Z+4, r24	; 0x04
     c58:	95 83       	std	Z+5, r25	; 0x05
}
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	08 95       	ret

00000c64 <_ZN9I2CMaster11Transmitter3runER6Packet>:

bool I2CMaster::Transmitter::run( Packet & packet )
{
     c64:	0f 93       	push	r16
     c66:	1f 93       	push	r17
     c68:	cf 93       	push	r28
     c6a:	df 93       	push	r29
     c6c:	ec 01       	movw	r28, r24
     c6e:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     c70:	8c 81       	ldd	r24, Y+4	; 0x04
     c72:	9d 81       	ldd	r25, Y+5	; 0x05
     c74:	8a 83       	std	Y+2, r24	; 0x02
     c76:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     c78:	8a 81       	ldd	r24, Y+2	; 0x02
     c7a:	9b 81       	ldd	r25, Y+3	; 0x03
     c7c:	2e 85       	ldd	r18, Y+14	; 0x0e
     c7e:	3f 85       	ldd	r19, Y+15	; 0x0f
     c80:	82 17       	cp	r24, r18
     c82:	93 07       	cpc	r25, r19
     c84:	29 f4       	brne	.+10     	; 0xc90 <_ZN9I2CMaster11Transmitter3runER6Packet+0x2c>
     c86:	2c 85       	ldd	r18, Y+12	; 0x0c
     c88:	3d 85       	ldd	r19, Y+13	; 0x0d
     c8a:	82 17       	cp	r24, r18
     c8c:	93 07       	cpc	r25, r19
     c8e:	59 f0       	breq	.+22     	; 0xca6 <_ZN9I2CMaster11Transmitter3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     c90:	dc 01       	movw	r26, r24
     c92:	ed 91       	ld	r30, X+
     c94:	fc 91       	ld	r31, X
     c96:	01 90       	ld	r0, Z+
     c98:	f0 81       	ld	r31, Z
     c9a:	e0 2d       	mov	r30, r0
     c9c:	b8 01       	movw	r22, r16
     c9e:	19 95       	eicall
     ca0:	8a 83       	std	Y+2, r24	; 0x02
     ca2:	9b 83       	std	Y+3, r25	; 0x03

bool I2CMaster::Transmitter::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     ca4:	e9 cf       	rjmp	.-46     	; 0xc78 <_ZN9I2CMaster11Transmitter3runER6Packet+0x14>
  }
  else
  {
    return false;
  }
}
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	08 95       	ret

00000cb2 <_ZN9I2CMaster8Receiver3runER6Packet>:

Packet & I2CMaster::Receiver::run( Packet & packet )
{
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	cf 93       	push	r28
     cb8:	df 93       	push	r29
     cba:	ec 01       	movw	r28, r24
     cbc:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     cbe:	8c 81       	ldd	r24, Y+4	; 0x04
     cc0:	9d 81       	ldd	r25, Y+5	; 0x05
     cc2:	8a 83       	std	Y+2, r24	; 0x02
     cc4:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     cc6:	8a 81       	ldd	r24, Y+2	; 0x02
     cc8:	9b 81       	ldd	r25, Y+3	; 0x03
     cca:	2e 85       	ldd	r18, Y+14	; 0x0e
     ccc:	3f 85       	ldd	r19, Y+15	; 0x0f
     cce:	82 17       	cp	r24, r18
     cd0:	93 07       	cpc	r25, r19
     cd2:	29 f4       	brne	.+10     	; 0xcde <_ZN9I2CMaster8Receiver3runER6Packet+0x2c>
     cd4:	2c 85       	ldd	r18, Y+12	; 0x0c
     cd6:	3d 85       	ldd	r19, Y+13	; 0x0d
     cd8:	82 17       	cp	r24, r18
     cda:	93 07       	cpc	r25, r19
     cdc:	59 f0       	breq	.+22     	; 0xcf4 <_ZN9I2CMaster8Receiver3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     cde:	dc 01       	movw	r26, r24
     ce0:	ed 91       	ld	r30, X+
     ce2:	fc 91       	ld	r31, X
     ce4:	01 90       	ld	r0, Z+
     ce6:	f0 81       	ld	r31, Z
     ce8:	e0 2d       	mov	r30, r0
     cea:	b8 01       	movw	r22, r16
     cec:	19 95       	eicall
     cee:	8a 83       	std	Y+2, r24	; 0x02
     cf0:	9b 83       	std	Y+3, r25	; 0x03

Packet & I2CMaster::Receiver::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     cf2:	e9 cf       	rjmp	.-46     	; 0xcc6 <_ZN9I2CMaster8Receiver3runER6Packet+0x14>
  {
    currentState_ = currentState_->execute(packet);
  }

  return packet;
}
     cf4:	c8 01       	movw	r24, r16
     cf6:	df 91       	pop	r29
     cf8:	cf 91       	pop	r28
     cfa:	1f 91       	pop	r17
     cfc:	0f 91       	pop	r16
     cfe:	08 95       	ret

00000d00 <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     d00:	cf 93       	push	r28
     d02:	df 93       	push	r29
     d04:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     d06:	9a 01       	movw	r18, r20
     d08:	ab 01       	movw	r20, r22
     d0a:	22 0f       	add	r18, r18
     d0c:	33 1f       	adc	r19, r19
     d0e:	44 1f       	adc	r20, r20
     d10:	55 1f       	adc	r21, r21
     d12:	60 e0       	ldi	r22, 0x00	; 0
     d14:	78 e4       	ldi	r23, 0x48	; 72
     d16:	88 ee       	ldi	r24, 0xE8	; 232
     d18:	91 e0       	ldi	r25, 0x01	; 1
     d1a:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
     d1e:	25 50       	subi	r18, 0x05	; 5
     d20:	28 87       	std	Y+8, r18	; 0x08
  interface_->MASTER.BAUD = baudrate;
     d22:	ec 81       	ldd	r30, Y+4	; 0x04
     d24:	fd 81       	ldd	r31, Y+5	; 0x05
     d26:	25 83       	std	Z+5, r18	; 0x05
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	08 95       	ret

00000d2e <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
     d2e:	af 92       	push	r10
     d30:	bf 92       	push	r11
     d32:	cf 92       	push	r12
     d34:	df 92       	push	r13
     d36:	ef 92       	push	r14
     d38:	ff 92       	push	r15
     d3a:	0f 93       	push	r16
     d3c:	1f 93       	push	r17
     d3e:	cf 93       	push	r28
     d40:	df 93       	push	r29
     d42:	ec 01       	movw	r28, r24
     d44:	8b 01       	movw	r16, r22
     d46:	69 01       	movw	r12, r18
     d48:	7a 01       	movw	r14, r20
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
    receiver_(new Receiver(this))
     d4a:	85 e1       	ldi	r24, 0x15	; 21
     d4c:	90 e0       	ldi	r25, 0x00	; 0
     d4e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     d52:	5c 01       	movw	r10, r24
#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
     d54:	be 01       	movw	r22, r28
     d56:	0e 94 18 05 	call	0xa30	; 0xa30 <_ZN9I2CMaster11TransmitterC1EPS_>
    receiver_(new Receiver(this))
     d5a:	a8 82       	st	Y, r10
     d5c:	b9 82       	std	Y+1, r11	; 0x01
     d5e:	86 e1       	ldi	r24, 0x16	; 22
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
     d66:	5c 01       	movw	r10, r24
     d68:	be 01       	movw	r22, r28
     d6a:	0e 94 a5 05 	call	0xb4a	; 0xb4a <_ZN9I2CMaster8ReceiverC1EPS_>
     d6e:	aa 82       	std	Y+2, r10	; 0x02
     d70:	bb 82       	std	Y+3, r11	; 0x03
     d72:	0c 83       	std	Y+4, r16	; 0x04
     d74:	1d 83       	std	Y+5, r17	; 0x05
     d76:	c9 86       	std	Y+9, r12	; 0x09
     d78:	da 86       	std	Y+10, r13	; 0x0a
     d7a:	eb 86       	std	Y+11, r14	; 0x0b
     d7c:	fc 86       	std	Y+12, r15	; 0x0c
{ 
  if (interface == &TWIC)
     d7e:	00 38       	cpi	r16, 0x80	; 128
     d80:	84 e0       	ldi	r24, 0x04	; 4
     d82:	18 07       	cpc	r17, r24
     d84:	29 f4       	brne	.+10     	; 0xd90 <_ZN9I2CMasterC1EP10TWI_structm+0x62>
  {
    bus_port = &PORTC;
     d86:	80 e4       	ldi	r24, 0x40	; 64
     d88:	96 e0       	ldi	r25, 0x06	; 6
     d8a:	8e 83       	std	Y+6, r24	; 0x06
     d8c:	9f 83       	std	Y+7, r25	; 0x07
     d8e:	08 c0       	rjmp	.+16     	; 0xda0 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  }
  if (interface == &TWIE)
     d90:	00 3a       	cpi	r16, 0xA0	; 160
     d92:	e4 e0       	ldi	r30, 0x04	; 4
     d94:	1e 07       	cpc	r17, r30
     d96:	21 f4       	brne	.+8      	; 0xda0 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  {
    bus_port = &PORTE;
     d98:	80 e8       	ldi	r24, 0x80	; 128
     d9a:	96 e0       	ldi	r25, 0x06	; 6
     d9c:	8e 83       	std	Y+6, r24	; 0x06
     d9e:	9f 83       	std	Y+7, r25	; 0x07
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     da0:	ee 81       	ldd	r30, Y+6	; 0x06
     da2:	ff 81       	ldd	r31, Y+7	; 0x07
     da4:	83 e0       	ldi	r24, 0x03	; 3
     da6:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     da8:	ee 81       	ldd	r30, Y+6	; 0x06
     daa:	ff 81       	ldd	r31, Y+7	; 0x07
     dac:	88 e3       	ldi	r24, 0x38	; 56
     dae:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     db0:	ee 81       	ldd	r30, Y+6	; 0x06
     db2:	ff 81       	ldd	r31, Y+7	; 0x07
     db4:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     db6:	82 e0       	ldi	r24, 0x02	; 2
     db8:	f8 01       	movw	r30, r16
     dba:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     dbc:	b7 01       	movw	r22, r14
     dbe:	a6 01       	movw	r20, r12
     dc0:	ce 01       	movw	r24, r28
     dc2:	0e 94 80 06 	call	0xd00	; 0xd00 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     dc6:	f8 01       	movw	r30, r16
     dc8:	84 81       	ldd	r24, Z+4	; 0x04
     dca:	8d 6c       	ori	r24, 0xCD	; 205
     dcc:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     dce:	88 e0       	ldi	r24, 0x08	; 8
     dd0:	81 83       	std	Z+1, r24	; 0x01
}
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	1f 91       	pop	r17
     dd8:	0f 91       	pop	r16
     dda:	ff 90       	pop	r15
     ddc:	ef 90       	pop	r14
     dde:	df 90       	pop	r13
     de0:	cf 90       	pop	r12
     de2:	bf 90       	pop	r11
     de4:	af 90       	pop	r10
     de6:	08 95       	ret

00000de8 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return driver_->is_ready(slaveAddr_);
}
     de8:	db 01       	movw	r26, r22
     dea:	bc 01       	movw	r22, r24
     dec:	6e 5f       	subi	r22, 0xFE	; 254
     dee:	7f 4f       	sbci	r23, 0xFF	; 255
     df0:	ed 91       	ld	r30, X+
     df2:	fc 91       	ld	r31, X
     df4:	11 97       	sbiw	r26, 0x01	; 1
     df6:	01 90       	ld	r0, Z+
     df8:	f0 81       	ld	r31, Z
     dfa:	e0 2d       	mov	r30, r0
     dfc:	cd 01       	movw	r24, r26
     dfe:	19 95       	eicall
     e00:	08 95       	ret

00000e02 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
     e02:	fc 01       	movw	r30, r24
     e04:	84 81       	ldd	r24, Z+4	; 0x04
     e06:	95 81       	ldd	r25, Z+5	; 0x05
     e08:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	08 95       	ret

00000e10 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
     e10:	fc 01       	movw	r30, r24
     e12:	84 81       	ldd	r24, Z+4	; 0x04
     e14:	95 81       	ldd	r25, Z+5	; 0x05
     e16:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
     e1a:	91 e0       	ldi	r25, 0x01	; 1
     e1c:	81 11       	cpse	r24, r1
     e1e:	01 c0       	rjmp	.+2      	; 0xe22 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	89 2f       	mov	r24, r25
     e24:	08 95       	ret

00000e26 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
     e26:	fc 01       	movw	r30, r24
     e28:	84 81       	ldd	r24, Z+4	; 0x04
     e2a:	95 81       	ldd	r25, Z+5	; 0x05
     e2c:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
     e30:	91 e0       	ldi	r25, 0x01	; 1
     e32:	81 11       	cpse	r24, r1
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	89 2f       	mov	r24, r25
     e38:	08 95       	ret

00000e3a <_ZN9frt_queueIhE12num_items_inEv>:
     e3a:	fc 01       	movw	r30, r24
     e3c:	84 81       	ldd	r24, Z+4	; 0x04
     e3e:	95 81       	ldd	r25, Z+5	; 0x05
     e40:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	08 95       	ret

00000e48 <_ZN9frt_queueIhE9not_emptyEv>:
     e48:	fc 01       	movw	r30, r24
     e4a:	84 81       	ldd	r24, Z+4	; 0x04
     e4c:	95 81       	ldd	r25, Z+5	; 0x05
     e4e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
     e52:	91 e0       	ldi	r25, 0x01	; 1
     e54:	81 11       	cpse	r24, r1
     e56:	01 c0       	rjmp	.+2      	; 0xe5a <_ZN9frt_queueIhE9not_emptyEv+0x12>
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	89 2f       	mov	r24, r25
     e5c:	08 95       	ret

00000e5e <_ZN9frt_queueIhE8is_emptyEv>:
     e5e:	fc 01       	movw	r30, r24
     e60:	84 81       	ldd	r24, Z+4	; 0x04
     e62:	95 81       	ldd	r25, Z+5	; 0x05
     e64:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
     e68:	91 e0       	ldi	r25, 0x01	; 1
     e6a:	81 11       	cpse	r24, r1
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	89 2f       	mov	r24, r25
     e70:	08 95       	ret

00000e72 <_ZN9frt_queueIhE10get_a_copyERh>:
     e72:	0f 93       	push	r16
     e74:	01 e0       	ldi	r16, 0x01	; 1
     e76:	2f ef       	ldi	r18, 0xFF	; 255
     e78:	3f ef       	ldi	r19, 0xFF	; 255
     e7a:	a9 01       	movw	r20, r18
     e7c:	fc 01       	movw	r30, r24
     e7e:	84 81       	ldd	r24, Z+4	; 0x04
     e80:	95 81       	ldd	r25, Z+5	; 0x05
     e82:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
     e86:	0f 91       	pop	r16
     e88:	08 95       	ret

00000e8a <_ZN9frt_queueIhE10get_a_copyEv>:
     e8a:	0f 93       	push	r16
     e8c:	cf 93       	push	r28
     e8e:	df 93       	push	r29
     e90:	1f 92       	push	r1
     e92:	cd b7       	in	r28, 0x3d	; 61
     e94:	de b7       	in	r29, 0x3e	; 62
     e96:	01 e0       	ldi	r16, 0x01	; 1
     e98:	2f ef       	ldi	r18, 0xFF	; 255
     e9a:	3f ef       	ldi	r19, 0xFF	; 255
     e9c:	a9 01       	movw	r20, r18
     e9e:	be 01       	movw	r22, r28
     ea0:	6f 5f       	subi	r22, 0xFF	; 255
     ea2:	7f 4f       	sbci	r23, 0xFF	; 255
     ea4:	fc 01       	movw	r30, r24
     ea6:	84 81       	ldd	r24, Z+4	; 0x04
     ea8:	95 81       	ldd	r25, Z+5	; 0x05
     eaa:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	0f 90       	pop	r0
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	0f 91       	pop	r16
     eb8:	08 95       	ret

00000eba <_ZN9frt_queueIhE3getEPh>:
     eba:	0f 93       	push	r16
     ebc:	00 e0       	ldi	r16, 0x00	; 0
     ebe:	2f ef       	ldi	r18, 0xFF	; 255
     ec0:	3f ef       	ldi	r19, 0xFF	; 255
     ec2:	a9 01       	movw	r20, r18
     ec4:	fc 01       	movw	r30, r24
     ec6:	84 81       	ldd	r24, Z+4	; 0x04
     ec8:	95 81       	ldd	r25, Z+5	; 0x05
     eca:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
     ece:	0f 91       	pop	r16
     ed0:	08 95       	ret

00000ed2 <_ZN9frt_queueIhE3getEv>:
     ed2:	0f 93       	push	r16
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	1f 92       	push	r1
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
     ede:	00 e0       	ldi	r16, 0x00	; 0
     ee0:	2f ef       	ldi	r18, 0xFF	; 255
     ee2:	3f ef       	ldi	r19, 0xFF	; 255
     ee4:	a9 01       	movw	r20, r18
     ee6:	be 01       	movw	r22, r28
     ee8:	6f 5f       	subi	r22, 0xFF	; 255
     eea:	7f 4f       	sbci	r23, 0xFF	; 255
     eec:	fc 01       	movw	r30, r24
     eee:	84 81       	ldd	r24, Z+4	; 0x04
     ef0:	95 81       	ldd	r25, Z+5	; 0x05
     ef2:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
     ef6:	89 81       	ldd	r24, Y+1	; 0x01
     ef8:	0f 90       	pop	r0
     efa:	df 91       	pop	r29
     efc:	cf 91       	pop	r28
     efe:	0f 91       	pop	r16
     f00:	08 95       	ret

00000f02 <_ZN9frt_queueIhE7ISR_getEPh>:
     f02:	cf 93       	push	r28
     f04:	df 93       	push	r29
     f06:	1f 92       	push	r1
     f08:	cd b7       	in	r28, 0x3d	; 61
     f0a:	de b7       	in	r29, 0x3e	; 62
     f0c:	ae 01       	movw	r20, r28
     f0e:	4f 5f       	subi	r20, 0xFF	; 255
     f10:	5f 4f       	sbci	r21, 0xFF	; 255
     f12:	fc 01       	movw	r30, r24
     f14:	84 81       	ldd	r24, Z+4	; 0x04
     f16:	95 81       	ldd	r25, Z+5	; 0x05
     f18:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
     f1c:	0f 90       	pop	r0
     f1e:	df 91       	pop	r29
     f20:	cf 91       	pop	r28
     f22:	08 95       	ret

00000f24 <_ZN9frt_queueIhE7ISR_getEv>:
     f24:	cf 93       	push	r28
     f26:	df 93       	push	r29
     f28:	1f 92       	push	r1
     f2a:	1f 92       	push	r1
     f2c:	cd b7       	in	r28, 0x3d	; 61
     f2e:	de b7       	in	r29, 0x3e	; 62
     f30:	ae 01       	movw	r20, r28
     f32:	4e 5f       	subi	r20, 0xFE	; 254
     f34:	5f 4f       	sbci	r21, 0xFF	; 255
     f36:	be 01       	movw	r22, r28
     f38:	6f 5f       	subi	r22, 0xFF	; 255
     f3a:	7f 4f       	sbci	r23, 0xFF	; 255
     f3c:	fc 01       	movw	r30, r24
     f3e:	84 81       	ldd	r24, Z+4	; 0x04
     f40:	95 81       	ldd	r25, Z+5	; 0x05
     f42:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
     f46:	89 81       	ldd	r24, Y+1	; 0x01
     f48:	0f 90       	pop	r0
     f4a:	0f 90       	pop	r0
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	08 95       	ret

00000f52 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
     f52:	cf 93       	push	r28
     f54:	df 93       	push	r29
     f56:	1f 92       	push	r1
     f58:	cd b7       	in	r28, 0x3d	; 61
     f5a:	de b7       	in	r29, 0x3e	; 62
     f5c:	19 82       	std	Y+1, r1	; 0x01
     f5e:	21 e0       	ldi	r18, 0x01	; 1
     f60:	ae 01       	movw	r20, r28
     f62:	4f 5f       	subi	r20, 0xFF	; 255
     f64:	5f 4f       	sbci	r21, 0xFF	; 255
     f66:	fc 01       	movw	r30, r24
     f68:	84 81       	ldd	r24, Z+4	; 0x04
     f6a:	95 81       	ldd	r25, Z+5	; 0x05
     f6c:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
     f70:	91 e0       	ldi	r25, 0x01	; 1
     f72:	81 11       	cpse	r24, r1
     f74:	01 c0       	rjmp	.+2      	; 0xf78 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	89 2f       	mov	r24, r25
     f7a:	0f 90       	pop	r0
     f7c:	df 91       	pop	r29
     f7e:	cf 91       	pop	r28
     f80:	08 95       	ret

00000f82 <_ZN9frt_queueIhE7ISR_putERKh>:
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	1f 92       	push	r1
     f88:	cd b7       	in	r28, 0x3d	; 61
     f8a:	de b7       	in	r29, 0x3e	; 62
     f8c:	19 82       	std	Y+1, r1	; 0x01
     f8e:	20 e0       	ldi	r18, 0x00	; 0
     f90:	ae 01       	movw	r20, r28
     f92:	4f 5f       	subi	r20, 0xFF	; 255
     f94:	5f 4f       	sbci	r21, 0xFF	; 255
     f96:	fc 01       	movw	r30, r24
     f98:	84 81       	ldd	r24, Z+4	; 0x04
     f9a:	95 81       	ldd	r25, Z+5	; 0x05
     f9c:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
     fa0:	91 e0       	ldi	r25, 0x01	; 1
     fa2:	81 11       	cpse	r24, r1
     fa4:	01 c0       	rjmp	.+2      	; 0xfa8 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	89 2f       	mov	r24, r25
     faa:	0f 90       	pop	r0
     fac:	df 91       	pop	r29
     fae:	cf 91       	pop	r28
     fb0:	08 95       	ret

00000fb2 <_ZN9frt_queueIhE7butt_inERKh>:
     fb2:	0f 93       	push	r16
     fb4:	fc 01       	movw	r30, r24
     fb6:	26 81       	ldd	r18, Z+6	; 0x06
     fb8:	37 81       	ldd	r19, Z+7	; 0x07
     fba:	40 85       	ldd	r20, Z+8	; 0x08
     fbc:	51 85       	ldd	r21, Z+9	; 0x09
     fbe:	01 e0       	ldi	r16, 0x01	; 1
     fc0:	84 81       	ldd	r24, Z+4	; 0x04
     fc2:	95 81       	ldd	r25, Z+5	; 0x05
     fc4:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
     fc8:	91 e0       	ldi	r25, 0x01	; 1
     fca:	81 11       	cpse	r24, r1
     fcc:	01 c0       	rjmp	.+2      	; 0xfd0 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
     fce:	90 e0       	ldi	r25, 0x00	; 0
     fd0:	89 2f       	mov	r24, r25
     fd2:	0f 91       	pop	r16
     fd4:	08 95       	ret

00000fd6 <_ZN9frt_queueIhE3putERKh>:
     fd6:	0f 93       	push	r16
     fd8:	fc 01       	movw	r30, r24
     fda:	26 81       	ldd	r18, Z+6	; 0x06
     fdc:	37 81       	ldd	r19, Z+7	; 0x07
     fde:	40 85       	ldd	r20, Z+8	; 0x08
     fe0:	51 85       	ldd	r21, Z+9	; 0x09
     fe2:	00 e0       	ldi	r16, 0x00	; 0
     fe4:	84 81       	ldd	r24, Z+4	; 0x04
     fe6:	95 81       	ldd	r25, Z+5	; 0x05
     fe8:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
     fec:	91 e0       	ldi	r25, 0x01	; 1
     fee:	81 11       	cpse	r24, r1
     ff0:	01 c0       	rjmp	.+2      	; 0xff4 <_ZN9frt_queueIhE3putERKh+0x1e>
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	89 2f       	mov	r24, r25
     ff6:	0f 91       	pop	r16
     ff8:	08 95       	ret

00000ffa <_ZN6MB1202C1EP9I2CMaster>:
     ffa:	4f 92       	push	r4
     ffc:	5f 92       	push	r5
     ffe:	6f 92       	push	r6
    1000:	7f 92       	push	r7
    1002:	8f 92       	push	r8
    1004:	9f 92       	push	r9
    1006:	af 92       	push	r10
    1008:	bf 92       	push	r11
    100a:	df 92       	push	r13
    100c:	ef 92       	push	r14
    100e:	ff 92       	push	r15
    1010:	0f 93       	push	r16
    1012:	1f 93       	push	r17
    1014:	cf 93       	push	r28
    1016:	df 93       	push	r29
    1018:	8c 01       	movw	r16, r24
    101a:	7b 01       	movw	r14, r22
    101c:	dc 01       	movw	r26, r24
    101e:	6d 93       	st	X+, r22
    1020:	7c 93       	st	X, r23
    1022:	8d e1       	ldi	r24, 0x1D	; 29
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
    102a:	ec 01       	movw	r28, r24
    102c:	86 e9       	ldi	r24, 0x96	; 150
    102e:	90 e2       	ldi	r25, 0x20	; 32
    1030:	88 83       	st	Y, r24
    1032:	99 83       	std	Y+1, r25	; 0x01
    1034:	1c 82       	std	Y+4, r1	; 0x04
    1036:	1d 82       	std	Y+5, r1	; 0x05
    1038:	0f 2e       	mov	r0, r31
    103a:	fe e4       	ldi	r31, 0x4E	; 78
    103c:	8f 2e       	mov	r8, r31
    103e:	f0 e2       	ldi	r31, 0x20	; 32
    1040:	9f 2e       	mov	r9, r31
    1042:	f0 2d       	mov	r31, r0
    1044:	8a 82       	std	Y+2, r8	; 0x02
    1046:	9b 82       	std	Y+3, r9	; 0x03
    1048:	40 e0       	ldi	r20, 0x00	; 0
    104a:	61 e0       	ldi	r22, 0x01	; 1
    104c:	82 e0       	ldi	r24, 0x02	; 2
    104e:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    1052:	8e 83       	std	Y+6, r24	; 0x06
    1054:	9f 83       	std	Y+7, r25	; 0x07
    1056:	0f 2e       	mov	r0, r31
    1058:	fa e0       	ldi	r31, 0x0A	; 10
    105a:	4f 2e       	mov	r4, r31
    105c:	51 2c       	mov	r5, r1
    105e:	61 2c       	mov	r6, r1
    1060:	71 2c       	mov	r7, r1
    1062:	f0 2d       	mov	r31, r0
    1064:	48 86       	std	Y+8, r4	; 0x08
    1066:	59 86       	std	Y+9, r5	; 0x09
    1068:	6a 86       	std	Y+10, r6	; 0x0a
    106a:	7b 86       	std	Y+11, r7	; 0x0b
    106c:	0f 2e       	mov	r0, r31
    106e:	f2 e7       	ldi	r31, 0x72	; 114
    1070:	af 2e       	mov	r10, r31
    1072:	f0 e2       	ldi	r31, 0x20	; 32
    1074:	bf 2e       	mov	r11, r31
    1076:	f0 2d       	mov	r31, r0
    1078:	aa 82       	std	Y+2, r10	; 0x02
    107a:	bb 82       	std	Y+3, r11	; 0x03
    107c:	68 94       	set
    107e:	dd 24       	eor	r13, r13
    1080:	d1 f8       	bld	r13, 1
    1082:	dc 86       	std	Y+12, r13	; 0x0c
    1084:	1f 86       	std	Y+15, r1	; 0x0f
    1086:	18 8a       	std	Y+16, r1	; 0x10
    1088:	8d 86       	std	Y+13, r8	; 0x0d
    108a:	9e 86       	std	Y+14, r9	; 0x0e
    108c:	40 e0       	ldi	r20, 0x00	; 0
    108e:	61 e0       	ldi	r22, 0x01	; 1
    1090:	82 e0       	ldi	r24, 0x02	; 2
    1092:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    1096:	89 8b       	std	Y+17, r24	; 0x11
    1098:	9a 8b       	std	Y+18, r25	; 0x12
    109a:	4b 8a       	std	Y+19, r4	; 0x13
    109c:	5c 8a       	std	Y+20, r5	; 0x14
    109e:	6d 8a       	std	Y+21, r6	; 0x15
    10a0:	7e 8a       	std	Y+22, r7	; 0x16
    10a2:	ad 86       	std	Y+13, r10	; 0x0d
    10a4:	be 86       	std	Y+14, r11	; 0x0e
    10a6:	df 8a       	std	Y+23, r13	; 0x17
    10a8:	8a e0       	ldi	r24, 0x0A	; 10
    10aa:	90 e2       	ldi	r25, 0x20	; 32
    10ac:	88 83       	st	Y, r24
    10ae:	99 83       	std	Y+1, r25	; 0x01
    10b0:	f8 01       	movw	r30, r16
    10b2:	c2 83       	std	Z+2, r28	; 0x02
    10b4:	d3 83       	std	Z+3, r29	; 0x03
    10b6:	80 e7       	ldi	r24, 0x70	; 112
    10b8:	84 83       	std	Z+4, r24	; 0x04
    10ba:	16 82       	std	Z+6, r1	; 0x06
    10bc:	17 82       	std	Z+7, r1	; 0x07
    10be:	10 86       	std	Z+8, r1	; 0x08
    10c0:	11 86       	std	Z+9, r1	; 0x09
    10c2:	12 86       	std	Z+10, r1	; 0x0a
    10c4:	83 e0       	ldi	r24, 0x03	; 3
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
    10cc:	24 ea       	ldi	r18, 0xA4	; 164
    10ce:	30 e2       	ldi	r19, 0x20	; 32
    10d0:	fc 01       	movw	r30, r24
    10d2:	20 83       	st	Z, r18
    10d4:	31 83       	std	Z+1, r19	; 0x01
    10d6:	c1 e5       	ldi	r28, 0x51	; 81
    10d8:	c2 83       	std	Z+2, r28	; 0x02
    10da:	d8 01       	movw	r26, r16
    10dc:	1d 96       	adiw	r26, 0x0d	; 13
    10de:	8d 93       	st	X+, r24
    10e0:	9c 93       	st	X, r25
    10e2:	1e 97       	sbiw	r26, 0x0e	; 14
    10e4:	12 96       	adiw	r26, 0x02	; 2
    10e6:	ed 91       	ld	r30, X+
    10e8:	fc 91       	ld	r31, X
    10ea:	13 97       	sbiw	r26, 0x03	; 3
    10ec:	e0 8e       	std	Z+24, r14	; 0x18
    10ee:	f1 8e       	std	Z+25, r15	; 0x19
    10f0:	14 96       	adiw	r26, 0x04	; 4
    10f2:	6c 91       	ld	r22, X
    10f4:	14 97       	sbiw	r26, 0x04	; 4
    10f6:	12 96       	adiw	r26, 0x02	; 2
    10f8:	8d 91       	ld	r24, X+
    10fa:	9c 91       	ld	r25, X
    10fc:	13 97       	sbiw	r26, 0x03	; 3
    10fe:	0e 94 ef 03 	call	0x7de	; 0x7de <_ZN8I2CAgent12setSlaveAddrEh>
    1102:	f8 01       	movw	r30, r16
    1104:	c5 83       	std	Z+5, r28	; 0x05
    1106:	8a ea       	ldi	r24, 0xAA	; 170
    1108:	86 83       	std	Z+6, r24	; 0x06
    110a:	85 ea       	ldi	r24, 0xA5	; 165
    110c:	87 83       	std	Z+7, r24	; 0x07
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	df 90       	pop	r13
    111c:	bf 90       	pop	r11
    111e:	af 90       	pop	r10
    1120:	9f 90       	pop	r9
    1122:	8f 90       	pop	r8
    1124:	7f 90       	pop	r7
    1126:	6f 90       	pop	r6
    1128:	5f 90       	pop	r5
    112a:	4f 90       	pop	r4
    112c:	08 95       	ret

0000112e <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
	return i2cAgent_->transmit(*rangeCommand_);
    112e:	fc 01       	movw	r30, r24
    1130:	a2 81       	ldd	r26, Z+2	; 0x02
    1132:	b3 81       	ldd	r27, Z+3	; 0x03
    1134:	65 85       	ldd	r22, Z+13	; 0x0d
    1136:	76 85       	ldd	r23, Z+14	; 0x0e
    1138:	ed 91       	ld	r30, X+
    113a:	fc 91       	ld	r31, X
    113c:	11 97       	sbiw	r26, 0x01	; 1
    113e:	01 90       	ld	r0, Z+
    1140:	f0 81       	ld	r31, Z
    1142:	e0 2d       	mov	r30, r0
    1144:	cd 01       	movw	r24, r26
    1146:	19 95       	eicall
}
    1148:	08 95       	ret

0000114a <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
    114a:	ff 92       	push	r15
    114c:	0f 93       	push	r16
    114e:	1f 93       	push	r17
    1150:	cf 93       	push	r28
    1152:	df 93       	push	r29
    1154:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
    1156:	8a 81       	ldd	r24, Y+2	; 0x02
    1158:	9b 81       	ldd	r25, Y+3	; 0x03
    115a:	dc 01       	movw	r26, r24
    115c:	ed 91       	ld	r30, X+
    115e:	fc 91       	ld	r31, X
    1160:	02 80       	ldd	r0, Z+2	; 0x02
    1162:	f3 81       	ldd	r31, Z+3	; 0x03
    1164:	e0 2d       	mov	r30, r0
    1166:	19 95       	eicall
    1168:	8c 01       	movw	r16, r24
	range_reading = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
    116a:	dc 01       	movw	r26, r24
    116c:	ed 91       	ld	r30, X+
    116e:	fc 91       	ld	r31, X
    1170:	00 84       	ldd	r0, Z+8	; 0x08
    1172:	f1 85       	ldd	r31, Z+9	; 0x09
    1174:	e0 2d       	mov	r30, r0
    1176:	19 95       	eicall
    1178:	f8 2e       	mov	r15, r24
    117a:	d8 01       	movw	r26, r16
    117c:	ed 91       	ld	r30, X+
    117e:	fc 91       	ld	r31, X
    1180:	00 84       	ldd	r0, Z+8	; 0x08
    1182:	f1 85       	ldd	r31, Z+9	; 0x09
    1184:	e0 2d       	mov	r30, r0
    1186:	c8 01       	movw	r24, r16
    1188:	19 95       	eicall
    118a:	2f 2d       	mov	r18, r15
    118c:	30 e0       	ldi	r19, 0x00	; 0
    118e:	32 2f       	mov	r19, r18
    1190:	22 27       	eor	r18, r18
    1192:	a9 01       	movw	r20, r18
    1194:	48 2b       	or	r20, r24
    1196:	ca 01       	movw	r24, r20
    1198:	8b 87       	std	Y+11, r24	; 0x0b
    119a:	9c 87       	std	Y+12, r25	; 0x0c
	return range_reading;
}
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	1f 91       	pop	r17
    11a2:	0f 91       	pop	r16
    11a4:	ff 90       	pop	r15
    11a6:	08 95       	ret

000011a8 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    11a8:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    11aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    11ac:	88 23       	and	r24, r24
    11ae:	19 f0       	breq	.+6      	; 0x11b6 <_ZN10task_sonar3runEv+0xe>
    11b0:	81 30       	cpi	r24, 0x01	; 1
    11b2:	51 f0       	breq	.+20     	; 0x11c8 <_ZN10task_sonar3runEv+0x20>
    11b4:	25 c0       	rjmp	.+74     	; 0x1200 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
    11b6:	8c 89       	ldd	r24, Y+20	; 0x14
    11b8:	9d 89       	ldd	r25, Y+21	; 0x15
    11ba:	0e 94 97 08 	call	0x112e	; 0x112e <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
    11be:	61 e0       	ldi	r22, 0x01	; 1
    11c0:	ce 01       	movw	r24, r28
    11c2:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <_ZN8frt_task13transition_toEh>
			
			    break;
    11c6:	1c c0       	rjmp	.+56     	; 0x1200 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
    11c8:	8c 89       	ldd	r24, Y+20	; 0x14
    11ca:	9d 89       	ldd	r25, Y+21	; 0x15
    11cc:	0e 94 a5 08 	call	0x114a	; 0x114a <_ZN6MB120211get_readingEv>
    11d0:	7c 01       	movw	r14, r24
    11d2:	8a 8b       	std	Y+18, r24	; 0x12
    11d4:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
    11d6:	6a e0       	ldi	r22, 0x0A	; 10
    11d8:	8e 81       	ldd	r24, Y+6	; 0x06
    11da:	9f 81       	ldd	r25, Y+7	; 0x07
    11dc:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    11e0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    11e2:	66 e8       	ldi	r22, 0x86	; 134
    11e4:	73 e0       	ldi	r23, 0x03	; 3
    11e6:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    11ea:	b7 01       	movw	r22, r14
    11ec:	c8 01       	movw	r24, r16
    11ee:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    11f2:	66 e0       	ldi	r22, 0x06	; 6
    11f4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    11f8:	60 e0       	ldi	r22, 0x00	; 0
    11fa:	ce 01       	movw	r24, r28
    11fc:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1200:	8e 85       	ldd	r24, Y+14	; 0x0e
    1202:	9f 85       	ldd	r25, Y+15	; 0x0f
    1204:	a8 89       	ldd	r26, Y+16	; 0x10
    1206:	b9 89       	ldd	r27, Y+17	; 0x11
    1208:	01 96       	adiw	r24, 0x01	; 1
    120a:	a1 1d       	adc	r26, r1
    120c:	b1 1d       	adc	r27, r1
    120e:	8e 87       	std	Y+14, r24	; 0x0e
    1210:	9f 87       	std	Y+15, r25	; 0x0f
    1212:	a8 8b       	std	Y+16, r26	; 0x10
    1214:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
    1216:	64 ef       	ldi	r22, 0xF4	; 244
    1218:	71 e0       	ldi	r23, 0x01	; 1
    121a:	80 e0       	ldi	r24, 0x00	; 0
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 b3 14 	call	0x2966	; 0x2966 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1222:	c3 cf       	rjmp	.-122    	; 0x11aa <_ZN10task_sonar3runEv+0x2>

00001224 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    1224:	cf 92       	push	r12
    1226:	df 92       	push	r13
    1228:	ef 92       	push	r14
    122a:	ff 92       	push	r15
    122c:	0f 93       	push	r16
    122e:	1f 93       	push	r17
    1230:	cf 93       	push	r28
    1232:	df 93       	push	r29
    1234:	ec 01       	movw	r28, r24
    1236:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
    1238:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <_ZN8frt_taskC1EPKchjP8emstream>
    123c:	8a ea       	ldi	r24, 0xAA	; 170
    123e:	90 e2       	ldi	r25, 0x20	; 32
    1240:	88 83       	st	Y, r24
    1242:	99 83       	std	Y+1, r25	; 0x01
    1244:	ec 8a       	std	Y+20, r14	; 0x14
    1246:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    1248:	ce 8a       	std	Y+22, r12	; 0x16
    124a:	df 8a       	std	Y+23, r13	; 0x17
}
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	1f 91       	pop	r17
    1252:	0f 91       	pop	r16
    1254:	ff 90       	pop	r15
    1256:	ef 90       	pop	r14
    1258:	df 90       	pop	r13
    125a:	cf 90       	pop	r12
    125c:	08 95       	ret

0000125e <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    125e:	0f 93       	push	r16
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1268:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <_ZN8frt_taskC1EPKchjP8emstream>
    126c:	82 eb       	ldi	r24, 0xB2	; 178
    126e:	90 e2       	ldi	r25, 0x20	; 32
    1270:	88 83       	st	Y, r24
    1272:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	1f 91       	pop	r17
    127a:	0f 91       	pop	r16
    127c:	08 95       	ret

0000127e <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    127e:	0f 93       	push	r16
    1280:	1f 93       	push	r17
    1282:	cf 93       	push	r28
    1284:	df 93       	push	r29
    1286:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1288:	6a e0       	ldi	r22, 0x0A	; 10
    128a:	8e 81       	ldd	r24, Y+6	; 0x06
    128c:	9f 81       	ldd	r25, Y+7	; 0x07
    128e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1292:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    1294:	61 ee       	ldi	r22, 0xE1	; 225
    1296:	74 e0       	ldi	r23, 0x04	; 4
    1298:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    129c:	6a e0       	ldi	r22, 0x0A	; 10
    129e:	c8 01       	movw	r24, r16
    12a0:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    12a4:	8c 01       	movw	r16, r24
    12a6:	6b ed       	ldi	r22, 0xDB	; 219
    12a8:	74 e0       	ldi	r23, 0x04	; 4
    12aa:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    12ae:	67 e0       	ldi	r22, 0x07	; 7
    12b0:	c8 01       	movw	r24, r16
    12b2:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    12b6:	6a e0       	ldi	r22, 0x0A	; 10
    12b8:	8e 81       	ldd	r24, Y+6	; 0x06
    12ba:	9f 81       	ldd	r25, Y+7	; 0x07
    12bc:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    12c0:	8c 01       	movw	r16, r24
    12c2:	6c eb       	ldi	r22, 0xBC	; 188
    12c4:	74 e0       	ldi	r23, 0x04	; 4
    12c6:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    12ca:	6a e0       	ldi	r22, 0x0A	; 10
    12cc:	c8 01       	movw	r24, r16
    12ce:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    12d2:	8c 01       	movw	r16, r24
    12d4:	66 eb       	ldi	r22, 0xB6	; 182
    12d6:	74 e0       	ldi	r23, 0x04	; 4
    12d8:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    12dc:	66 e0       	ldi	r22, 0x06	; 6
    12de:	c8 01       	movw	r24, r16
    12e0:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    12e4:	6a e0       	ldi	r22, 0x0A	; 10
    12e6:	8e 81       	ldd	r24, Y+6	; 0x06
    12e8:	9f 81       	ldd	r25, Y+7	; 0x07
    12ea:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    12ee:	8c 01       	movw	r16, r24
    12f0:	6f e9       	ldi	r22, 0x9F	; 159
    12f2:	74 e0       	ldi	r23, 0x04	; 4
    12f4:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    12f8:	66 e0       	ldi	r22, 0x06	; 6
    12fa:	c8 01       	movw	r24, r16
    12fc:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1300:	6a e0       	ldi	r22, 0x0A	; 10
    1302:	8e 81       	ldd	r24, Y+6	; 0x06
    1304:	9f 81       	ldd	r25, Y+7	; 0x07
    1306:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    130a:	8c 01       	movw	r16, r24
    130c:	63 e8       	ldi	r22, 0x83	; 131
    130e:	74 e0       	ldi	r23, 0x04	; 4
    1310:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1314:	66 e0       	ldi	r22, 0x06	; 6
    1316:	c8 01       	movw	r24, r16
    1318:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    131c:	6a e0       	ldi	r22, 0x0A	; 10
    131e:	8e 81       	ldd	r24, Y+6	; 0x06
    1320:	9f 81       	ldd	r25, Y+7	; 0x07
    1322:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1326:	8c 01       	movw	r16, r24
    1328:	6b e6       	ldi	r22, 0x6B	; 107
    132a:	74 e0       	ldi	r23, 0x04	; 4
    132c:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1330:	66 e0       	ldi	r22, 0x06	; 6
    1332:	c8 01       	movw	r24, r16
    1334:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1338:	6a e0       	ldi	r22, 0x0A	; 10
    133a:	8e 81       	ldd	r24, Y+6	; 0x06
    133c:	9f 81       	ldd	r25, Y+7	; 0x07
    133e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1342:	8c 01       	movw	r16, r24
    1344:	6a e4       	ldi	r22, 0x4A	; 74
    1346:	74 e0       	ldi	r23, 0x04	; 4
    1348:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    134c:	66 e0       	ldi	r22, 0x06	; 6
    134e:	c8 01       	movw	r24, r16
    1350:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1354:	6a e0       	ldi	r22, 0x0A	; 10
    1356:	8e 81       	ldd	r24, Y+6	; 0x06
    1358:	9f 81       	ldd	r25, Y+7	; 0x07
    135a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    135e:	8c 01       	movw	r16, r24
    1360:	63 e2       	ldi	r22, 0x23	; 35
    1362:	74 e0       	ldi	r23, 0x04	; 4
    1364:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1368:	66 e0       	ldi	r22, 0x06	; 6
    136a:	c8 01       	movw	r24, r16
    136c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1370:	6a e0       	ldi	r22, 0x0A	; 10
    1372:	8e 81       	ldd	r24, Y+6	; 0x06
    1374:	9f 81       	ldd	r25, Y+7	; 0x07
    1376:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    137a:	8c 01       	movw	r16, r24
    137c:	65 e0       	ldi	r22, 0x05	; 5
    137e:	74 e0       	ldi	r23, 0x04	; 4
    1380:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1384:	66 e0       	ldi	r22, 0x06	; 6
    1386:	c8 01       	movw	r24, r16
    1388:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    138c:	6a e0       	ldi	r22, 0x0A	; 10
    138e:	8e 81       	ldd	r24, Y+6	; 0x06
    1390:	9f 81       	ldd	r25, Y+7	; 0x07
    1392:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1396:	8c 01       	movw	r16, r24
    1398:	6a ee       	ldi	r22, 0xEA	; 234
    139a:	73 e0       	ldi	r23, 0x03	; 3
    139c:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    13a0:	66 e0       	ldi	r22, 0x06	; 6
    13a2:	c8 01       	movw	r24, r16
    13a4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    13a8:	6a e0       	ldi	r22, 0x0A	; 10
    13aa:	8e 81       	ldd	r24, Y+6	; 0x06
    13ac:	9f 81       	ldd	r25, Y+7	; 0x07
    13ae:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    13b2:	ec 01       	movw	r28, r24
    13b4:	6b ed       	ldi	r22, 0xDB	; 219
    13b6:	73 e0       	ldi	r23, 0x03	; 3
    13b8:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    13bc:	66 e0       	ldi	r22, 0x06	; 6
    13be:	ce 01       	movw	r24, r28
    13c0:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
}
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	1f 91       	pop	r17
    13ca:	0f 91       	pop	r16
    13cc:	08 95       	ret

000013ce <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    13ce:	af 92       	push	r10
    13d0:	bf 92       	push	r11
    13d2:	cf 92       	push	r12
    13d4:	df 92       	push	r13
    13d6:	ef 92       	push	r14
    13d8:	ff 92       	push	r15
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	00 d0       	rcall	.+0      	; 0x13e4 <_ZN9task_user11show_statusEv+0x16>
    13e4:	00 d0       	rcall	.+0      	; 0x13e6 <_ZN9task_user11show_statusEv+0x18>
    13e6:	cd b7       	in	r28, 0x3d	; 61
    13e8:	de b7       	in	r29, 0x3e	; 62
    13ea:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    13ec:	19 82       	std	Y+1, r1	; 0x01
    13ee:	1a 82       	std	Y+2, r1	; 0x02
    13f0:	1b 82       	std	Y+3, r1	; 0x03
    13f2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    13f4:	1d 82       	std	Y+5, r1	; 0x05
    13f6:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    13f8:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <xPortGetFreeHeapSize>
    13fc:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    13fe:	ce 01       	movw	r24, r28
    1400:	01 96       	adiw	r24, 0x01	; 1
    1402:	0e 94 94 1a 	call	0x3528	; 0x3528 <_ZN10time_stamp10set_to_nowEv>
    1406:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1408:	66 e0       	ldi	r22, 0x06	; 6
    140a:	f8 01       	movw	r30, r16
    140c:	86 81       	ldd	r24, Z+6	; 0x06
    140e:	97 81       	ldd	r25, Z+7	; 0x07
    1410:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1414:	6a e0       	ldi	r22, 0x0A	; 10
    1416:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    141a:	7c 01       	movw	r14, r24
    141c:	6c eb       	ldi	r22, 0xBC	; 188
    141e:	73 e0       	ldi	r23, 0x03	; 3
    1420:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1424:	6a e0       	ldi	r22, 0x0A	; 10
    1426:	c7 01       	movw	r24, r14
    1428:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    142c:	7c 01       	movw	r14, r24
    142e:	60 eb       	ldi	r22, 0xB0	; 176
    1430:	73 e0       	ldi	r23, 0x03	; 3
    1432:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1436:	66 e0       	ldi	r22, 0x06	; 6
    1438:	c7 01       	movw	r24, r14
    143a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    143e:	6a e0       	ldi	r22, 0x0A	; 10
    1440:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1444:	7c 01       	movw	r14, r24
    1446:	69 ea       	ldi	r22, 0xA9	; 169
    1448:	73 e0       	ldi	r23, 0x03	; 3
    144a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    144e:	b5 01       	movw	r22, r10
    1450:	c7 01       	movw	r24, r14
    1452:	0e 94 38 1a 	call	0x3470	; 0x3470 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1456:	6a e0       	ldi	r22, 0x0A	; 10
    1458:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    145c:	7c 01       	movw	r14, r24
    145e:	6b e9       	ldi	r22, 0x9B	; 155
    1460:	73 e0       	ldi	r23, 0x03	; 3
    1462:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1466:	b6 01       	movw	r22, r12
    1468:	c7 01       	movw	r24, r14
    146a:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    146e:	6a e0       	ldi	r22, 0x0A	; 10
    1470:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1474:	7c 01       	movw	r14, r24
    1476:	69 e9       	ldi	r22, 0x99	; 153
    1478:	73 e0       	ldi	r23, 0x03	; 3
    147a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    147e:	4f ef       	ldi	r20, 0xFF	; 255
    1480:	5f e0       	ldi	r21, 0x0F	; 15
    1482:	60 e0       	ldi	r22, 0x00	; 0
    1484:	70 e0       	ldi	r23, 0x00	; 0
    1486:	c7 01       	movw	r24, r14
    1488:	0e 94 c3 1c 	call	0x3986	; 0x3986 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    148c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1490:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1494:	6a e0       	ldi	r22, 0x0A	; 10
    1496:	f8 01       	movw	r30, r16
    1498:	86 81       	ldd	r24, Z+6	; 0x06
    149a:	97 81       	ldd	r25, Z+7	; 0x07
    149c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    14a0:	7c 01       	movw	r14, r24
    14a2:	6e e8       	ldi	r22, 0x8E	; 142
    14a4:	73 e0       	ldi	r23, 0x03	; 3
    14a6:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    14aa:	b6 01       	movw	r22, r12
    14ac:	c7 01       	movw	r24, r14
    14ae:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    14b2:	66 e0       	ldi	r22, 0x06	; 6
    14b4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    14b8:	66 e0       	ldi	r22, 0x06	; 6
    14ba:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    14be:	f8 01       	movw	r30, r16
    14c0:	86 81       	ldd	r24, Z+6	; 0x06
    14c2:	97 81       	ldd	r25, Z+7	; 0x07
    14c4:	0e 94 f1 18 	call	0x31e2	; 0x31e2 <_Z15print_task_listP8emstream>
}
    14c8:	26 96       	adiw	r28, 0x06	; 6
    14ca:	cd bf       	out	0x3d, r28	; 61
    14cc:	de bf       	out	0x3e, r29	; 62
    14ce:	df 91       	pop	r29
    14d0:	cf 91       	pop	r28
    14d2:	1f 91       	pop	r17
    14d4:	0f 91       	pop	r16
    14d6:	ff 90       	pop	r15
    14d8:	ef 90       	pop	r14
    14da:	df 90       	pop	r13
    14dc:	cf 90       	pop	r12
    14de:	bf 90       	pop	r11
    14e0:	af 90       	pop	r10
    14e2:	08 95       	ret

000014e4 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    14e4:	cf 93       	push	r28
    14e6:	df 93       	push	r29
    14e8:	00 d0       	rcall	.+0      	; 0x14ea <_ZN9task_user3runEv+0x6>
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <_ZN9task_user3runEv+0x8>
    14ec:	cd b7       	in	r28, 0x3d	; 61
    14ee:	de b7       	in	r29, 0x3e	; 62
    14f0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    14f2:	19 82       	std	Y+1, r1	; 0x01
    14f4:	1a 82       	std	Y+2, r1	; 0x02
    14f6:	1b 82       	std	Y+3, r1	; 0x03
    14f8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    14fa:	1d 82       	std	Y+5, r1	; 0x05
    14fc:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    14fe:	6a e0       	ldi	r22, 0x0A	; 10
    1500:	dc 01       	movw	r26, r24
    1502:	16 96       	adiw	r26, 0x06	; 6
    1504:	8d 91       	ld	r24, X+
    1506:	9c 91       	ld	r25, X
    1508:	17 97       	sbiw	r26, 0x07	; 7
    150a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    150e:	7c 01       	movw	r14, r24
    1510:	6a e2       	ldi	r22, 0x2A	; 42
    1512:	75 e0       	ldi	r23, 0x05	; 5
    1514:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1518:	66 e0       	ldi	r22, 0x06	; 6
    151a:	c7 01       	movw	r24, r14
    151c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1520:	f8 01       	movw	r30, r16
    1522:	84 85       	ldd	r24, Z+12	; 0x0c
    1524:	88 23       	and	r24, r24
    1526:	21 f0       	breq	.+8      	; 0x1530 <_ZN9task_user3runEv+0x4c>
    1528:	81 30       	cpi	r24, 0x01	; 1
    152a:	09 f4       	brne	.+2      	; 0x152e <_ZN9task_user3runEv+0x4a>
    152c:	5d c0       	rjmp	.+186    	; 0x15e8 <_ZN9task_user3runEv+0x104>
    152e:	d8 c0       	rjmp	.+432    	; 0x16e0 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1530:	86 81       	ldd	r24, Z+6	; 0x06
    1532:	97 81       	ldd	r25, Z+7	; 0x07
    1534:	dc 01       	movw	r26, r24
    1536:	ed 91       	ld	r30, X+
    1538:	fc 91       	ld	r31, X
    153a:	04 80       	ldd	r0, Z+4	; 0x04
    153c:	f5 81       	ldd	r31, Z+5	; 0x05
    153e:	e0 2d       	mov	r30, r0
    1540:	19 95       	eicall
    1542:	88 23       	and	r24, r24
    1544:	a9 f1       	breq	.+106    	; 0x15b0 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1546:	f8 01       	movw	r30, r16
    1548:	86 81       	ldd	r24, Z+6	; 0x06
    154a:	97 81       	ldd	r25, Z+7	; 0x07
    154c:	dc 01       	movw	r26, r24
    154e:	ed 91       	ld	r30, X+
    1550:	fc 91       	ld	r31, X
    1552:	06 80       	ldd	r0, Z+6	; 0x06
    1554:	f7 81       	ldd	r31, Z+7	; 0x07
    1556:	e0 2d       	mov	r30, r0
    1558:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    155a:	99 27       	eor	r25, r25
    155c:	81 30       	cpi	r24, 0x01	; 1
    155e:	91 05       	cpc	r25, r1
    1560:	f9 f0       	breq	.+62     	; 0x15a0 <_ZN9task_user3runEv+0xbc>
    1562:	03 97       	sbiw	r24, 0x03	; 3
    1564:	09 f0       	breq	.+2      	; 0x1568 <_ZN9task_user3runEv+0x84>
    1566:	d8 c0       	rjmp	.+432    	; 0x1718 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1568:	6a e0       	ldi	r22, 0x0A	; 10
    156a:	f8 01       	movw	r30, r16
    156c:	86 81       	ldd	r24, Z+6	; 0x06
    156e:	97 81       	ldd	r25, Z+7	; 0x07
    1570:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1574:	8c 01       	movw	r16, r24
    1576:	6c e1       	ldi	r22, 0x1C	; 28
    1578:	75 e0       	ldi	r23, 0x05	; 5
    157a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    157e:	66 e0       	ldi	r22, 0x06	; 6
    1580:	c8 01       	movw	r24, r16
    1582:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1586:	93 e0       	ldi	r25, 0x03	; 3
    1588:	88 ed       	ldi	r24, 0xD8	; 216
    158a:	08 b6       	in	r0, 0x38	; 56
    158c:	18 be       	out	0x38, r1	; 56
    158e:	84 bf       	out	0x34, r24	; 52
    1590:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1594:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1598:	81 fd       	sbrc	r24, 1
    159a:	fc cf       	rjmp	.-8      	; 0x1594 <_ZN9task_user3runEv+0xb0>
    159c:	08 be       	out	0x38, r0	; 56
    159e:	ff cf       	rjmp	.-2      	; 0x159e <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    15a0:	c8 01       	movw	r24, r16
    15a2:	0e 94 3f 09 	call	0x127e	; 0x127e <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    15a6:	61 e0       	ldi	r22, 0x01	; 1
    15a8:	c8 01       	movw	r24, r16
    15aa:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <_ZN8frt_task13transition_toEh>
							break;
    15ae:	b4 c0       	rjmp	.+360    	; 0x1718 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    15b0:	84 e2       	ldi	r24, 0x24	; 36
    15b2:	92 e3       	ldi	r25, 0x32	; 50
    15b4:	0e 94 a0 19 	call	0x3340	; 0x3340 <_ZN14frt_text_queue14check_for_charEv>
    15b8:	88 23       	and	r24, r24
    15ba:	09 f4       	brne	.+2      	; 0x15be <_ZN9task_user3runEv+0xda>
    15bc:	ad c0       	rjmp	.+346    	; 0x1718 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    15be:	d8 01       	movw	r26, r16
    15c0:	16 96       	adiw	r26, 0x06	; 6
    15c2:	ed 91       	ld	r30, X+
    15c4:	fc 91       	ld	r31, X
    15c6:	17 97       	sbiw	r26, 0x07	; 7
    15c8:	01 90       	ld	r0, Z+
    15ca:	f0 81       	ld	r31, Z
    15cc:	e0 2d       	mov	r30, r0
    15ce:	e2 80       	ldd	r14, Z+2	; 0x02
    15d0:	f3 80       	ldd	r15, Z+3	; 0x03
    15d2:	84 e2       	ldi	r24, 0x24	; 36
    15d4:	92 e3       	ldi	r25, 0x32	; 50
    15d6:	0e 94 82 19 	call	0x3304	; 0x3304 <_ZN14frt_text_queue7getcharEv>
    15da:	68 2f       	mov	r22, r24
    15dc:	f8 01       	movw	r30, r16
    15de:	86 81       	ldd	r24, Z+6	; 0x06
    15e0:	97 81       	ldd	r25, Z+7	; 0x07
    15e2:	f7 01       	movw	r30, r14
    15e4:	19 95       	eicall
    15e6:	98 c0       	rjmp	.+304    	; 0x1718 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    15e8:	86 81       	ldd	r24, Z+6	; 0x06
    15ea:	97 81       	ldd	r25, Z+7	; 0x07
    15ec:	dc 01       	movw	r26, r24
    15ee:	ed 91       	ld	r30, X+
    15f0:	fc 91       	ld	r31, X
    15f2:	04 80       	ldd	r0, Z+4	; 0x04
    15f4:	f5 81       	ldd	r31, Z+5	; 0x05
    15f6:	e0 2d       	mov	r30, r0
    15f8:	19 95       	eicall
    15fa:	88 23       	and	r24, r24
    15fc:	09 f4       	brne	.+2      	; 0x1600 <_ZN9task_user3runEv+0x11c>
    15fe:	8c c0       	rjmp	.+280    	; 0x1718 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1600:	f8 01       	movw	r30, r16
    1602:	86 81       	ldd	r24, Z+6	; 0x06
    1604:	97 81       	ldd	r25, Z+7	; 0x07
    1606:	dc 01       	movw	r26, r24
    1608:	ed 91       	ld	r30, X+
    160a:	fc 91       	ld	r31, X
    160c:	06 80       	ldd	r0, Z+6	; 0x06
    160e:	f7 81       	ldd	r31, Z+7	; 0x07
    1610:	e0 2d       	mov	r30, r0
    1612:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1614:	9c 01       	movw	r18, r24
    1616:	33 27       	eor	r19, r19
    1618:	28 36       	cpi	r18, 0x68	; 104
    161a:	31 05       	cpc	r19, r1
    161c:	59 f1       	breq	.+86     	; 0x1674 <_ZN9task_user3runEv+0x190>
    161e:	3c f4       	brge	.+14     	; 0x162e <_ZN9task_user3runEv+0x14a>
    1620:	2b 31       	cpi	r18, 0x1B	; 27
    1622:	31 05       	cpc	r19, r1
    1624:	59 f1       	breq	.+86     	; 0x167c <_ZN9task_user3runEv+0x198>
    1626:	25 36       	cpi	r18, 0x65	; 101
    1628:	31 05       	cpc	r19, r1
    162a:	41 f1       	breq	.+80     	; 0x167c <_ZN9task_user3runEv+0x198>
    162c:	3b c0       	rjmp	.+118    	; 0x16a4 <_ZN9task_user3runEv+0x1c0>
    162e:	23 37       	cpi	r18, 0x73	; 115
    1630:	31 05       	cpc	r19, r1
    1632:	c1 f0       	breq	.+48     	; 0x1664 <_ZN9task_user3runEv+0x180>
    1634:	26 37       	cpi	r18, 0x76	; 118
    1636:	31 05       	cpc	r19, r1
    1638:	89 f0       	breq	.+34     	; 0x165c <_ZN9task_user3runEv+0x178>
    163a:	2e 36       	cpi	r18, 0x6E	; 110
    163c:	31 05       	cpc	r19, r1
    163e:	91 f5       	brne	.+100    	; 0x16a4 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1640:	ce 01       	movw	r24, r28
    1642:	01 96       	adiw	r24, 0x01	; 1
    1644:	0e 94 94 1a 	call	0x3528	; 0x3528 <_ZN10time_stamp10set_to_nowEv>
    1648:	bc 01       	movw	r22, r24
    164a:	f8 01       	movw	r30, r16
    164c:	86 81       	ldd	r24, Z+6	; 0x06
    164e:	97 81       	ldd	r25, Z+7	; 0x07
    1650:	0e 94 38 1a 	call	0x3470	; 0x3470 <_ZlsR8emstreamR10time_stamp>
    1654:	66 e0       	ldi	r22, 0x06	; 6
    1656:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
							break;
    165a:	5e c0       	rjmp	.+188    	; 0x1718 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    165c:	c8 01       	movw	r24, r16
    165e:	0e 94 e7 09 	call	0x13ce	; 0x13ce <_ZN9task_user11show_statusEv>
							break;
    1662:	5a c0       	rjmp	.+180    	; 0x1718 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1664:	d8 01       	movw	r26, r16
    1666:	16 96       	adiw	r26, 0x06	; 6
    1668:	8d 91       	ld	r24, X+
    166a:	9c 91       	ld	r25, X
    166c:	17 97       	sbiw	r26, 0x07	; 7
    166e:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <_Z17print_task_stacksP8emstream>
							break;
    1672:	52 c0       	rjmp	.+164    	; 0x1718 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1674:	c8 01       	movw	r24, r16
    1676:	0e 94 3f 09 	call	0x127e	; 0x127e <_ZN9task_user18print_help_messageEv>
							break;
    167a:	4e c0       	rjmp	.+156    	; 0x1718 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    167c:	6a e0       	ldi	r22, 0x0A	; 10
    167e:	f8 01       	movw	r30, r16
    1680:	86 81       	ldd	r24, Z+6	; 0x06
    1682:	97 81       	ldd	r25, Z+7	; 0x07
    1684:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    1688:	7c 01       	movw	r14, r24
    168a:	6a e0       	ldi	r22, 0x0A	; 10
    168c:	75 e0       	ldi	r23, 0x05	; 5
    168e:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    1692:	66 e0       	ldi	r22, 0x06	; 6
    1694:	c7 01       	movw	r24, r14
    1696:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    169a:	60 e0       	ldi	r22, 0x00	; 0
    169c:	c8 01       	movw	r24, r16
    169e:	0e 94 df 16 	call	0x2dbe	; 0x2dbe <_ZN8frt_task13transition_toEh>
							break;
    16a2:	3a c0       	rjmp	.+116    	; 0x1718 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    16a4:	f8 01       	movw	r30, r16
    16a6:	a6 81       	ldd	r26, Z+6	; 0x06
    16a8:	b7 81       	ldd	r27, Z+7	; 0x07
    16aa:	ed 91       	ld	r30, X+
    16ac:	fc 91       	ld	r31, X
    16ae:	11 97       	sbiw	r26, 0x01	; 1
    16b0:	02 80       	ldd	r0, Z+2	; 0x02
    16b2:	f3 81       	ldd	r31, Z+3	; 0x03
    16b4:	e0 2d       	mov	r30, r0
    16b6:	68 2f       	mov	r22, r24
    16b8:	cd 01       	movw	r24, r26
    16ba:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    16bc:	6a e0       	ldi	r22, 0x0A	; 10
    16be:	d8 01       	movw	r26, r16
    16c0:	16 96       	adiw	r26, 0x06	; 6
    16c2:	8d 91       	ld	r24, X+
    16c4:	9c 91       	ld	r25, X
    16c6:	17 97       	sbiw	r26, 0x07	; 7
    16c8:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    16cc:	7c 01       	movw	r14, r24
    16ce:	64 e0       	ldi	r22, 0x04	; 4
    16d0:	75 e0       	ldi	r23, 0x05	; 5
    16d2:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    16d6:	66 e0       	ldi	r22, 0x06	; 6
    16d8:	c7 01       	movw	r24, r14
    16da:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16de:	1c c0       	rjmp	.+56     	; 0x1718 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    16e0:	6a e0       	ldi	r22, 0x0A	; 10
    16e2:	f8 01       	movw	r30, r16
    16e4:	86 81       	ldd	r24, Z+6	; 0x06
    16e6:	97 81       	ldd	r25, Z+7	; 0x07
    16e8:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    16ec:	8c 01       	movw	r16, r24
    16ee:	67 ee       	ldi	r22, 0xE7	; 231
    16f0:	74 e0       	ldi	r23, 0x04	; 4
    16f2:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    16f6:	66 e0       	ldi	r22, 0x06	; 6
    16f8:	c8 01       	movw	r24, r16
    16fa:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    16fe:	93 e0       	ldi	r25, 0x03	; 3
    1700:	88 ed       	ldi	r24, 0xD8	; 216
    1702:	08 b6       	in	r0, 0x38	; 56
    1704:	18 be       	out	0x38, r1	; 56
    1706:	84 bf       	out	0x34, r24	; 52
    1708:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    170c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1710:	81 fd       	sbrc	r24, 1
    1712:	fc cf       	rjmp	.-8      	; 0x170c <_ZN9task_user3runEv+0x228>
    1714:	08 be       	out	0x38, r0	; 56
    1716:	ff cf       	rjmp	.-2      	; 0x1716 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1718:	f8 01       	movw	r30, r16
    171a:	86 85       	ldd	r24, Z+14	; 0x0e
    171c:	97 85       	ldd	r25, Z+15	; 0x0f
    171e:	a0 89       	ldd	r26, Z+16	; 0x10
    1720:	b1 89       	ldd	r27, Z+17	; 0x11
    1722:	01 96       	adiw	r24, 0x01	; 1
    1724:	a1 1d       	adc	r26, r1
    1726:	b1 1d       	adc	r27, r1
    1728:	86 87       	std	Z+14, r24	; 0x0e
    172a:	97 87       	std	Z+15, r25	; 0x0f
    172c:	a0 8b       	std	Z+16, r26	; 0x10
    172e:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1730:	61 e0       	ldi	r22, 0x01	; 1
    1732:	70 e0       	ldi	r23, 0x00	; 0
    1734:	80 e0       	ldi	r24, 0x00	; 0
    1736:	90 e0       	ldi	r25, 0x00	; 0
    1738:	0e 94 b3 14 	call	0x2966	; 0x2966 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    173c:	f1 ce       	rjmp	.-542    	; 0x1520 <_ZN9task_user3runEv+0x3c>

0000173e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    173e:	0f 93       	push	r16
    1740:	1f 93       	push	r17
    1742:	cf 93       	push	r28
    1744:	df 93       	push	r29
    1746:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1748:	0e 94 0f 13 	call	0x261e	; 0x261e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    174c:	80 91 68 21 	lds	r24, 0x2168	; 0x802168 <__data_end>
    1750:	81 11       	cpse	r24, r1
    1752:	1d c0       	rjmp	.+58     	; 0x178e <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1754:	ad e6       	ldi	r26, 0x6D	; 109
    1756:	b1 e2       	ldi	r27, 0x21	; 33
    1758:	e1 e7       	ldi	r30, 0x71	; 113
    175a:	f1 e2       	ldi	r31, 0x21	; 33
    175c:	ed 93       	st	X+, r30
    175e:	fc 93       	st	X, r31
    1760:	11 97       	sbiw	r26, 0x01	; 1
    1762:	12 96       	adiw	r26, 0x02	; 2
    1764:	1d 92       	st	X+, r1
    1766:	1c 92       	st	X, r1
    1768:	13 97       	sbiw	r26, 0x03	; 3
    176a:	a9 e6       	ldi	r26, 0x69	; 105
    176c:	b1 e2       	ldi	r27, 0x21	; 33
    176e:	8f ef       	ldi	r24, 0xFF	; 255
    1770:	9f e0       	ldi	r25, 0x0F	; 15
    1772:	12 96       	adiw	r26, 0x02	; 2
    1774:	8d 93       	st	X+, r24
    1776:	9c 93       	st	X, r25
    1778:	13 97       	sbiw	r26, 0x03	; 3
    177a:	1d 92       	st	X+, r1
    177c:	1c 92       	st	X, r1
    177e:	11 97       	sbiw	r26, 0x01	; 1
    1780:	82 83       	std	Z+2, r24	; 0x02
    1782:	93 83       	std	Z+3, r25	; 0x03
    1784:	a0 83       	st	Z, r26
    1786:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	80 93 68 21 	sts	0x2168, r24	; 0x802168 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    178e:	20 97       	sbiw	r28, 0x00	; 0
    1790:	09 f4       	brne	.+2      	; 0x1794 <pvPortMalloc+0x56>
    1792:	5f c0       	rjmp	.+190    	; 0x1852 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1794:	9e 01       	movw	r18, r28
    1796:	2b 5f       	subi	r18, 0xFB	; 251
    1798:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    179a:	24 96       	adiw	r28, 0x04	; 4
    179c:	ce 3f       	cpi	r28, 0xFE	; 254
    179e:	df 40       	sbci	r29, 0x0F	; 15
    17a0:	08 f0       	brcs	.+2      	; 0x17a4 <pvPortMalloc+0x66>
    17a2:	5a c0       	rjmp	.+180    	; 0x1858 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    17a4:	e0 91 6d 21 	lds	r30, 0x216D	; 0x80216d <xStart>
    17a8:	f0 91 6e 21 	lds	r31, 0x216E	; 0x80216e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    17ac:	ad e6       	ldi	r26, 0x6D	; 109
    17ae:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17b0:	02 c0       	rjmp	.+4      	; 0x17b6 <pvPortMalloc+0x78>
    17b2:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    17b4:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17b6:	82 81       	ldd	r24, Z+2	; 0x02
    17b8:	93 81       	ldd	r25, Z+3	; 0x03
    17ba:	82 17       	cp	r24, r18
    17bc:	93 07       	cpc	r25, r19
    17be:	20 f4       	brcc	.+8      	; 0x17c8 <pvPortMalloc+0x8a>
    17c0:	80 81       	ld	r24, Z
    17c2:	91 81       	ldd	r25, Z+1	; 0x01
    17c4:	00 97       	sbiw	r24, 0x00	; 0
    17c6:	a9 f7       	brne	.-22     	; 0x17b2 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    17c8:	c1 e2       	ldi	r28, 0x21	; 33
    17ca:	e9 36       	cpi	r30, 0x69	; 105
    17cc:	fc 07       	cpc	r31, r28
    17ce:	09 f4       	brne	.+2      	; 0x17d2 <pvPortMalloc+0x94>
    17d0:	46 c0       	rjmp	.+140    	; 0x185e <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    17d2:	cd 91       	ld	r28, X+
    17d4:	dc 91       	ld	r29, X
    17d6:	11 97       	sbiw	r26, 0x01	; 1
    17d8:	8e 01       	movw	r16, r28
    17da:	0b 5f       	subi	r16, 0xFB	; 251
    17dc:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    17de:	80 81       	ld	r24, Z
    17e0:	91 81       	ldd	r25, Z+1	; 0x01
    17e2:	8d 93       	st	X+, r24
    17e4:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    17e6:	82 81       	ldd	r24, Z+2	; 0x02
    17e8:	93 81       	ldd	r25, Z+3	; 0x03
    17ea:	82 1b       	sub	r24, r18
    17ec:	93 0b       	sbc	r25, r19
    17ee:	8b 30       	cpi	r24, 0x0B	; 11
    17f0:	91 05       	cpc	r25, r1
    17f2:	10 f1       	brcs	.+68     	; 0x1838 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    17f4:	bf 01       	movw	r22, r30
    17f6:	62 0f       	add	r22, r18
    17f8:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    17fa:	db 01       	movw	r26, r22
    17fc:	12 96       	adiw	r26, 0x02	; 2
    17fe:	8d 93       	st	X+, r24
    1800:	9c 93       	st	X, r25
    1802:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1804:	22 83       	std	Z+2, r18	; 0x02
    1806:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1808:	12 96       	adiw	r26, 0x02	; 2
    180a:	4d 91       	ld	r20, X+
    180c:	5c 91       	ld	r21, X
    180e:	13 97       	sbiw	r26, 0x03	; 3
    1810:	8d e6       	ldi	r24, 0x6D	; 109
    1812:	91 e2       	ldi	r25, 0x21	; 33
    1814:	01 c0       	rjmp	.+2      	; 0x1818 <pvPortMalloc+0xda>
    1816:	cd 01       	movw	r24, r26
    1818:	ec 01       	movw	r28, r24
    181a:	a8 81       	ld	r26, Y
    181c:	b9 81       	ldd	r27, Y+1	; 0x01
    181e:	12 96       	adiw	r26, 0x02	; 2
    1820:	2d 91       	ld	r18, X+
    1822:	3c 91       	ld	r19, X
    1824:	13 97       	sbiw	r26, 0x03	; 3
    1826:	24 17       	cp	r18, r20
    1828:	35 07       	cpc	r19, r21
    182a:	a8 f3       	brcs	.-22     	; 0x1816 <pvPortMalloc+0xd8>
    182c:	eb 01       	movw	r28, r22
    182e:	a8 83       	st	Y, r26
    1830:	b9 83       	std	Y+1, r27	; 0x01
    1832:	dc 01       	movw	r26, r24
    1834:	6d 93       	st	X+, r22
    1836:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1838:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    183c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1840:	22 81       	ldd	r18, Z+2	; 0x02
    1842:	33 81       	ldd	r19, Z+3	; 0x03
    1844:	82 1b       	sub	r24, r18
    1846:	93 0b       	sbc	r25, r19
    1848:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    184c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1850:	08 c0       	rjmp	.+16     	; 0x1862 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1852:	00 e0       	ldi	r16, 0x00	; 0
    1854:	10 e0       	ldi	r17, 0x00	; 0
    1856:	05 c0       	rjmp	.+10     	; 0x1862 <pvPortMalloc+0x124>
    1858:	00 e0       	ldi	r16, 0x00	; 0
    185a:	10 e0       	ldi	r17, 0x00	; 0
    185c:	02 c0       	rjmp	.+4      	; 0x1862 <pvPortMalloc+0x124>
    185e:	00 e0       	ldi	r16, 0x00	; 0
    1860:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1862:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1866:	c8 01       	movw	r24, r16
    1868:	df 91       	pop	r29
    186a:	cf 91       	pop	r28
    186c:	1f 91       	pop	r17
    186e:	0f 91       	pop	r16
    1870:	08 95       	ret

00001872 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1872:	0f 93       	push	r16
    1874:	1f 93       	push	r17
    1876:	cf 93       	push	r28
    1878:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    187a:	00 97       	sbiw	r24, 0x00	; 0
    187c:	41 f1       	breq	.+80     	; 0x18ce <vPortFree+0x5c>
    187e:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1880:	8c 01       	movw	r16, r24
    1882:	05 50       	subi	r16, 0x05	; 5
    1884:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1886:	0e 94 0f 13 	call	0x261e	; 0x261e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    188a:	f8 01       	movw	r30, r16
    188c:	42 81       	ldd	r20, Z+2	; 0x02
    188e:	53 81       	ldd	r21, Z+3	; 0x03
    1890:	ad e6       	ldi	r26, 0x6D	; 109
    1892:	b1 e2       	ldi	r27, 0x21	; 33
    1894:	01 c0       	rjmp	.+2      	; 0x1898 <vPortFree+0x26>
    1896:	df 01       	movw	r26, r30
    1898:	ed 91       	ld	r30, X+
    189a:	fc 91       	ld	r31, X
    189c:	11 97       	sbiw	r26, 0x01	; 1
    189e:	22 81       	ldd	r18, Z+2	; 0x02
    18a0:	33 81       	ldd	r19, Z+3	; 0x03
    18a2:	24 17       	cp	r18, r20
    18a4:	35 07       	cpc	r19, r21
    18a6:	b8 f3       	brcs	.-18     	; 0x1896 <vPortFree+0x24>
    18a8:	25 97       	sbiw	r28, 0x05	; 5
    18aa:	e8 83       	st	Y, r30
    18ac:	f9 83       	std	Y+1, r31	; 0x01
    18ae:	0d 93       	st	X+, r16
    18b0:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    18b2:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    18b6:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    18ba:	8a 81       	ldd	r24, Y+2	; 0x02
    18bc:	9b 81       	ldd	r25, Y+3	; 0x03
    18be:	82 0f       	add	r24, r18
    18c0:	93 1f       	adc	r25, r19
    18c2:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    18c6:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    18ca:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
	}
}
    18ce:	df 91       	pop	r29
    18d0:	cf 91       	pop	r28
    18d2:	1f 91       	pop	r17
    18d4:	0f 91       	pop	r16
    18d6:	08 95       	ret

000018d8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    18d8:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    18dc:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    18e0:	08 95       	ret

000018e2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    18e2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    18e4:	03 96       	adiw	r24, 0x03	; 3
    18e6:	81 83       	std	Z+1, r24	; 0x01
    18e8:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    18ea:	4f ef       	ldi	r20, 0xFF	; 255
    18ec:	5f ef       	ldi	r21, 0xFF	; 255
    18ee:	ba 01       	movw	r22, r20
    18f0:	43 83       	std	Z+3, r20	; 0x03
    18f2:	54 83       	std	Z+4, r21	; 0x04
    18f4:	65 83       	std	Z+5, r22	; 0x05
    18f6:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    18f8:	87 83       	std	Z+7, r24	; 0x07
    18fa:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    18fc:	81 87       	std	Z+9, r24	; 0x09
    18fe:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1900:	10 82       	st	Z, r1
    1902:	08 95       	ret

00001904 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1904:	fc 01       	movw	r30, r24
    1906:	12 86       	std	Z+10, r1	; 0x0a
    1908:	13 86       	std	Z+11, r1	; 0x0b
    190a:	08 95       	ret

0000190c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    190c:	cf 93       	push	r28
    190e:	df 93       	push	r29
    1910:	fc 01       	movw	r30, r24
    1912:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1914:	21 81       	ldd	r18, Z+1	; 0x01
    1916:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1918:	e9 01       	movw	r28, r18
    191a:	8c 81       	ldd	r24, Y+4	; 0x04
    191c:	9d 81       	ldd	r25, Y+5	; 0x05
    191e:	14 96       	adiw	r26, 0x04	; 4
    1920:	8d 93       	st	X+, r24
    1922:	9c 93       	st	X, r25
    1924:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1926:	81 81       	ldd	r24, Z+1	; 0x01
    1928:	92 81       	ldd	r25, Z+2	; 0x02
    192a:	16 96       	adiw	r26, 0x06	; 6
    192c:	8d 93       	st	X+, r24
    192e:	9c 93       	st	X, r25
    1930:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1932:	8c 81       	ldd	r24, Y+4	; 0x04
    1934:	9d 81       	ldd	r25, Y+5	; 0x05
    1936:	ec 01       	movw	r28, r24
    1938:	6e 83       	std	Y+6, r22	; 0x06
    193a:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    193c:	e9 01       	movw	r28, r18
    193e:	6c 83       	std	Y+4, r22	; 0x04
    1940:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1942:	61 83       	std	Z+1, r22	; 0x01
    1944:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1946:	1a 96       	adiw	r26, 0x0a	; 10
    1948:	ed 93       	st	X+, r30
    194a:	fc 93       	st	X, r31
    194c:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    194e:	80 81       	ld	r24, Z
    1950:	8f 5f       	subi	r24, 0xFF	; 255
    1952:	80 83       	st	Z, r24
}
    1954:	df 91       	pop	r29
    1956:	cf 91       	pop	r28
    1958:	08 95       	ret

0000195a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    195a:	0f 93       	push	r16
    195c:	1f 93       	push	r17
    195e:	cf 93       	push	r28
    1960:	df 93       	push	r29
    1962:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1964:	08 81       	ld	r16, Y
    1966:	19 81       	ldd	r17, Y+1	; 0x01
    1968:	2a 81       	ldd	r18, Y+2	; 0x02
    196a:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    196c:	0f 3f       	cpi	r16, 0xFF	; 255
    196e:	4f ef       	ldi	r20, 0xFF	; 255
    1970:	14 07       	cpc	r17, r20
    1972:	24 07       	cpc	r18, r20
    1974:	34 07       	cpc	r19, r20
    1976:	31 f4       	brne	.+12     	; 0x1984 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1978:	dc 01       	movw	r26, r24
    197a:	19 96       	adiw	r26, 0x09	; 9
    197c:	ed 91       	ld	r30, X+
    197e:	fc 91       	ld	r31, X
    1980:	1a 97       	sbiw	r26, 0x0a	; 10
    1982:	1f c0       	rjmp	.+62     	; 0x19c2 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1984:	fc 01       	movw	r30, r24
    1986:	33 96       	adiw	r30, 0x03	; 3
    1988:	dc 01       	movw	r26, r24
    198a:	17 96       	adiw	r26, 0x07	; 7
    198c:	4d 91       	ld	r20, X+
    198e:	5c 91       	ld	r21, X
    1990:	18 97       	sbiw	r26, 0x08	; 8
    1992:	da 01       	movw	r26, r20
    1994:	4d 91       	ld	r20, X+
    1996:	5d 91       	ld	r21, X+
    1998:	6d 91       	ld	r22, X+
    199a:	7c 91       	ld	r23, X
    199c:	04 17       	cp	r16, r20
    199e:	15 07       	cpc	r17, r21
    19a0:	26 07       	cpc	r18, r22
    19a2:	37 07       	cpc	r19, r23
    19a4:	70 f0       	brcs	.+28     	; 0x19c2 <vListInsert+0x68>
    19a6:	04 80       	ldd	r0, Z+4	; 0x04
    19a8:	f5 81       	ldd	r31, Z+5	; 0x05
    19aa:	e0 2d       	mov	r30, r0
    19ac:	a4 81       	ldd	r26, Z+4	; 0x04
    19ae:	b5 81       	ldd	r27, Z+5	; 0x05
    19b0:	4d 91       	ld	r20, X+
    19b2:	5d 91       	ld	r21, X+
    19b4:	6d 91       	ld	r22, X+
    19b6:	7c 91       	ld	r23, X
    19b8:	04 17       	cp	r16, r20
    19ba:	15 07       	cpc	r17, r21
    19bc:	26 07       	cpc	r18, r22
    19be:	37 07       	cpc	r19, r23
    19c0:	90 f7       	brcc	.-28     	; 0x19a6 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19c2:	a4 81       	ldd	r26, Z+4	; 0x04
    19c4:	b5 81       	ldd	r27, Z+5	; 0x05
    19c6:	ac 83       	std	Y+4, r26	; 0x04
    19c8:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19ca:	16 96       	adiw	r26, 0x06	; 6
    19cc:	cd 93       	st	X+, r28
    19ce:	dc 93       	st	X, r29
    19d0:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    19d2:	ee 83       	std	Y+6, r30	; 0x06
    19d4:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19d6:	c4 83       	std	Z+4, r28	; 0x04
    19d8:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19da:	8a 87       	std	Y+10, r24	; 0x0a
    19dc:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    19de:	fc 01       	movw	r30, r24
    19e0:	20 81       	ld	r18, Z
    19e2:	2f 5f       	subi	r18, 0xFF	; 255
    19e4:	20 83       	st	Z, r18
}
    19e6:	df 91       	pop	r29
    19e8:	cf 91       	pop	r28
    19ea:	1f 91       	pop	r17
    19ec:	0f 91       	pop	r16
    19ee:	08 95       	ret

000019f0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    19f0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19f2:	a4 81       	ldd	r26, Z+4	; 0x04
    19f4:	b5 81       	ldd	r27, Z+5	; 0x05
    19f6:	86 81       	ldd	r24, Z+6	; 0x06
    19f8:	97 81       	ldd	r25, Z+7	; 0x07
    19fa:	16 96       	adiw	r26, 0x06	; 6
    19fc:	8d 93       	st	X+, r24
    19fe:	9c 93       	st	X, r25
    1a00:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a02:	a6 81       	ldd	r26, Z+6	; 0x06
    1a04:	b7 81       	ldd	r27, Z+7	; 0x07
    1a06:	84 81       	ldd	r24, Z+4	; 0x04
    1a08:	95 81       	ldd	r25, Z+5	; 0x05
    1a0a:	14 96       	adiw	r26, 0x04	; 4
    1a0c:	8d 93       	st	X+, r24
    1a0e:	9c 93       	st	X, r25
    1a10:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a12:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a14:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a16:	11 96       	adiw	r26, 0x01	; 1
    1a18:	8d 91       	ld	r24, X+
    1a1a:	9c 91       	ld	r25, X
    1a1c:	12 97       	sbiw	r26, 0x02	; 2
    1a1e:	e8 17       	cp	r30, r24
    1a20:	f9 07       	cpc	r31, r25
    1a22:	31 f4       	brne	.+12     	; 0x1a30 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a24:	86 81       	ldd	r24, Z+6	; 0x06
    1a26:	97 81       	ldd	r25, Z+7	; 0x07
    1a28:	11 96       	adiw	r26, 0x01	; 1
    1a2a:	8d 93       	st	X+, r24
    1a2c:	9c 93       	st	X, r25
    1a2e:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1a30:	12 86       	std	Z+10, r1	; 0x0a
    1a32:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1a34:	8c 91       	ld	r24, X
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	8c 93       	st	X, r24
    1a3a:	08 95       	ret

00001a3c <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a3c:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <portStackTopForTask>
    1a40:	90 93 35 32 	sts	0x3235, r25	; 0x803235 <portStackTopForTask+0x1>
    1a44:	31 e1       	ldi	r19, 0x11	; 17
    1a46:	fc 01       	movw	r30, r24
    1a48:	30 83       	st	Z, r19
    1a4a:	31 97       	sbiw	r30, 0x01	; 1
    1a4c:	22 e2       	ldi	r18, 0x22	; 34
    1a4e:	20 83       	st	Z, r18
    1a50:	31 97       	sbiw	r30, 0x01	; 1
    1a52:	a3 e3       	ldi	r26, 0x33	; 51
    1a54:	a0 83       	st	Z, r26
    1a56:	31 97       	sbiw	r30, 0x01	; 1
    1a58:	60 83       	st	Z, r22
    1a5a:	31 97       	sbiw	r30, 0x01	; 1
    1a5c:	70 83       	st	Z, r23
    1a5e:	31 97       	sbiw	r30, 0x01	; 1
    1a60:	10 82       	st	Z, r1
    1a62:	31 97       	sbiw	r30, 0x01	; 1
    1a64:	10 82       	st	Z, r1
    1a66:	31 97       	sbiw	r30, 0x01	; 1
    1a68:	60 e8       	ldi	r22, 0x80	; 128
    1a6a:	60 83       	st	Z, r22
    1a6c:	31 97       	sbiw	r30, 0x01	; 1
    1a6e:	10 82       	st	Z, r1
    1a70:	31 97       	sbiw	r30, 0x01	; 1
    1a72:	10 82       	st	Z, r1
    1a74:	31 97       	sbiw	r30, 0x01	; 1
    1a76:	10 82       	st	Z, r1
    1a78:	31 97       	sbiw	r30, 0x01	; 1
    1a7a:	62 e0       	ldi	r22, 0x02	; 2
    1a7c:	60 83       	st	Z, r22
    1a7e:	31 97       	sbiw	r30, 0x01	; 1
    1a80:	63 e0       	ldi	r22, 0x03	; 3
    1a82:	60 83       	st	Z, r22
    1a84:	31 97       	sbiw	r30, 0x01	; 1
    1a86:	64 e0       	ldi	r22, 0x04	; 4
    1a88:	60 83       	st	Z, r22
    1a8a:	31 97       	sbiw	r30, 0x01	; 1
    1a8c:	65 e0       	ldi	r22, 0x05	; 5
    1a8e:	60 83       	st	Z, r22
    1a90:	31 97       	sbiw	r30, 0x01	; 1
    1a92:	66 e0       	ldi	r22, 0x06	; 6
    1a94:	60 83       	st	Z, r22
    1a96:	31 97       	sbiw	r30, 0x01	; 1
    1a98:	67 e0       	ldi	r22, 0x07	; 7
    1a9a:	60 83       	st	Z, r22
    1a9c:	31 97       	sbiw	r30, 0x01	; 1
    1a9e:	68 e0       	ldi	r22, 0x08	; 8
    1aa0:	60 83       	st	Z, r22
    1aa2:	31 97       	sbiw	r30, 0x01	; 1
    1aa4:	69 e0       	ldi	r22, 0x09	; 9
    1aa6:	60 83       	st	Z, r22
    1aa8:	31 97       	sbiw	r30, 0x01	; 1
    1aaa:	60 e1       	ldi	r22, 0x10	; 16
    1aac:	60 83       	st	Z, r22
    1aae:	31 97       	sbiw	r30, 0x01	; 1
    1ab0:	30 83       	st	Z, r19
    1ab2:	31 97       	sbiw	r30, 0x01	; 1
    1ab4:	32 e1       	ldi	r19, 0x12	; 18
    1ab6:	30 83       	st	Z, r19
    1ab8:	31 97       	sbiw	r30, 0x01	; 1
    1aba:	33 e1       	ldi	r19, 0x13	; 19
    1abc:	30 83       	st	Z, r19
    1abe:	31 97       	sbiw	r30, 0x01	; 1
    1ac0:	34 e1       	ldi	r19, 0x14	; 20
    1ac2:	30 83       	st	Z, r19
    1ac4:	31 97       	sbiw	r30, 0x01	; 1
    1ac6:	35 e1       	ldi	r19, 0x15	; 21
    1ac8:	30 83       	st	Z, r19
    1aca:	31 97       	sbiw	r30, 0x01	; 1
    1acc:	36 e1       	ldi	r19, 0x16	; 22
    1ace:	30 83       	st	Z, r19
    1ad0:	31 97       	sbiw	r30, 0x01	; 1
    1ad2:	37 e1       	ldi	r19, 0x17	; 23
    1ad4:	30 83       	st	Z, r19
    1ad6:	31 97       	sbiw	r30, 0x01	; 1
    1ad8:	38 e1       	ldi	r19, 0x18	; 24
    1ada:	30 83       	st	Z, r19
    1adc:	31 97       	sbiw	r30, 0x01	; 1
    1ade:	39 e1       	ldi	r19, 0x19	; 25
    1ae0:	30 83       	st	Z, r19
    1ae2:	31 97       	sbiw	r30, 0x01	; 1
    1ae4:	30 e2       	ldi	r19, 0x20	; 32
    1ae6:	30 83       	st	Z, r19
    1ae8:	31 97       	sbiw	r30, 0x01	; 1
    1aea:	31 e2       	ldi	r19, 0x21	; 33
    1aec:	30 83       	st	Z, r19
    1aee:	31 97       	sbiw	r30, 0x01	; 1
    1af0:	20 83       	st	Z, r18
    1af2:	31 97       	sbiw	r30, 0x01	; 1
    1af4:	23 e2       	ldi	r18, 0x23	; 35
    1af6:	20 83       	st	Z, r18
    1af8:	31 97       	sbiw	r30, 0x01	; 1
    1afa:	40 83       	st	Z, r20
    1afc:	31 97       	sbiw	r30, 0x01	; 1
    1afe:	50 83       	st	Z, r21
    1b00:	31 97       	sbiw	r30, 0x01	; 1
    1b02:	26 e2       	ldi	r18, 0x26	; 38
    1b04:	20 83       	st	Z, r18
    1b06:	31 97       	sbiw	r30, 0x01	; 1
    1b08:	27 e2       	ldi	r18, 0x27	; 39
    1b0a:	20 83       	st	Z, r18
    1b0c:	31 97       	sbiw	r30, 0x01	; 1
    1b0e:	28 e2       	ldi	r18, 0x28	; 40
    1b10:	20 83       	st	Z, r18
    1b12:	31 97       	sbiw	r30, 0x01	; 1
    1b14:	29 e2       	ldi	r18, 0x29	; 41
    1b16:	20 83       	st	Z, r18
    1b18:	31 97       	sbiw	r30, 0x01	; 1
    1b1a:	20 e3       	ldi	r18, 0x30	; 48
    1b1c:	20 83       	st	Z, r18
    1b1e:	31 97       	sbiw	r30, 0x01	; 1
    1b20:	21 e3       	ldi	r18, 0x31	; 49
    1b22:	20 83       	st	Z, r18
    1b24:	89 97       	sbiw	r24, 0x29	; 41
    1b26:	08 95       	ret

00001b28 <xPortStartScheduler>:
    1b28:	8c e7       	ldi	r24, 0x7C	; 124
    1b2a:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1b2e:	8f ef       	ldi	r24, 0xFF	; 255
    1b30:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1b3a:	91 e1       	ldi	r25, 0x11	; 17
    1b3c:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1b40:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    1b44:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1b48:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1b4c:	cd 91       	ld	r28, X+
    1b4e:	cd bf       	out	0x3d, r28	; 61
    1b50:	dd 91       	ld	r29, X+
    1b52:	de bf       	out	0x3e, r29	; 62
    1b54:	ff 91       	pop	r31
    1b56:	ef 91       	pop	r30
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	bf 91       	pop	r27
    1b5e:	af 91       	pop	r26
    1b60:	9f 91       	pop	r25
    1b62:	8f 91       	pop	r24
    1b64:	7f 91       	pop	r23
    1b66:	6f 91       	pop	r22
    1b68:	5f 91       	pop	r21
    1b6a:	4f 91       	pop	r20
    1b6c:	3f 91       	pop	r19
    1b6e:	2f 91       	pop	r18
    1b70:	1f 91       	pop	r17
    1b72:	0f 91       	pop	r16
    1b74:	ff 90       	pop	r15
    1b76:	ef 90       	pop	r14
    1b78:	df 90       	pop	r13
    1b7a:	cf 90       	pop	r12
    1b7c:	bf 90       	pop	r11
    1b7e:	af 90       	pop	r10
    1b80:	9f 90       	pop	r9
    1b82:	8f 90       	pop	r8
    1b84:	7f 90       	pop	r7
    1b86:	6f 90       	pop	r6
    1b88:	5f 90       	pop	r5
    1b8a:	4f 90       	pop	r4
    1b8c:	3f 90       	pop	r3
    1b8e:	2f 90       	pop	r2
    1b90:	1f 90       	pop	r1
    1b92:	0f 90       	pop	r0
    1b94:	0c be       	out	0x3c, r0	; 60
    1b96:	0f 90       	pop	r0
    1b98:	0b be       	out	0x3b, r0	; 59
    1b9a:	0f 90       	pop	r0
    1b9c:	0f be       	out	0x3f, r0	; 63
    1b9e:	0f 90       	pop	r0
    1ba0:	08 95       	ret
    1ba2:	08 95       	ret

00001ba4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1ba4:	0f 92       	push	r0
    1ba6:	0f b6       	in	r0, 0x3f	; 63
    1ba8:	f8 94       	cli
    1baa:	0f 92       	push	r0
    1bac:	0b b6       	in	r0, 0x3b	; 59
    1bae:	0f 92       	push	r0
    1bb0:	0c b6       	in	r0, 0x3c	; 60
    1bb2:	0f 92       	push	r0
    1bb4:	1f 92       	push	r1
    1bb6:	11 24       	eor	r1, r1
    1bb8:	2f 92       	push	r2
    1bba:	3f 92       	push	r3
    1bbc:	4f 92       	push	r4
    1bbe:	5f 92       	push	r5
    1bc0:	6f 92       	push	r6
    1bc2:	7f 92       	push	r7
    1bc4:	8f 92       	push	r8
    1bc6:	9f 92       	push	r9
    1bc8:	af 92       	push	r10
    1bca:	bf 92       	push	r11
    1bcc:	cf 92       	push	r12
    1bce:	df 92       	push	r13
    1bd0:	ef 92       	push	r14
    1bd2:	ff 92       	push	r15
    1bd4:	0f 93       	push	r16
    1bd6:	1f 93       	push	r17
    1bd8:	2f 93       	push	r18
    1bda:	3f 93       	push	r19
    1bdc:	4f 93       	push	r20
    1bde:	5f 93       	push	r21
    1be0:	6f 93       	push	r22
    1be2:	7f 93       	push	r23
    1be4:	8f 93       	push	r24
    1be6:	9f 93       	push	r25
    1be8:	af 93       	push	r26
    1bea:	bf 93       	push	r27
    1bec:	cf 93       	push	r28
    1bee:	df 93       	push	r29
    1bf0:	ef 93       	push	r30
    1bf2:	ff 93       	push	r31
    1bf4:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1bf8:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1bfc:	0d b6       	in	r0, 0x3d	; 61
    1bfe:	0d 92       	st	X+, r0
    1c00:	0e b6       	in	r0, 0x3e	; 62
    1c02:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c04:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c08:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1c0c:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1c10:	cd 91       	ld	r28, X+
    1c12:	cd bf       	out	0x3d, r28	; 61
    1c14:	dd 91       	ld	r29, X+
    1c16:	de bf       	out	0x3e, r29	; 62
    1c18:	ff 91       	pop	r31
    1c1a:	ef 91       	pop	r30
    1c1c:	df 91       	pop	r29
    1c1e:	cf 91       	pop	r28
    1c20:	bf 91       	pop	r27
    1c22:	af 91       	pop	r26
    1c24:	9f 91       	pop	r25
    1c26:	8f 91       	pop	r24
    1c28:	7f 91       	pop	r23
    1c2a:	6f 91       	pop	r22
    1c2c:	5f 91       	pop	r21
    1c2e:	4f 91       	pop	r20
    1c30:	3f 91       	pop	r19
    1c32:	2f 91       	pop	r18
    1c34:	1f 91       	pop	r17
    1c36:	0f 91       	pop	r16
    1c38:	ff 90       	pop	r15
    1c3a:	ef 90       	pop	r14
    1c3c:	df 90       	pop	r13
    1c3e:	cf 90       	pop	r12
    1c40:	bf 90       	pop	r11
    1c42:	af 90       	pop	r10
    1c44:	9f 90       	pop	r9
    1c46:	8f 90       	pop	r8
    1c48:	7f 90       	pop	r7
    1c4a:	6f 90       	pop	r6
    1c4c:	5f 90       	pop	r5
    1c4e:	4f 90       	pop	r4
    1c50:	3f 90       	pop	r3
    1c52:	2f 90       	pop	r2
    1c54:	1f 90       	pop	r1
    1c56:	0f 90       	pop	r0
    1c58:	0c be       	out	0x3c, r0	; 60
    1c5a:	0f 90       	pop	r0
    1c5c:	0b be       	out	0x3b, r0	; 59
    1c5e:	0f 90       	pop	r0
    1c60:	0f be       	out	0x3f, r0	; 63
    1c62:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c64:	08 95       	ret

00001c66 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c66:	0f 92       	push	r0
    1c68:	0f b6       	in	r0, 0x3f	; 63
    1c6a:	f8 94       	cli
    1c6c:	0f 92       	push	r0
    1c6e:	0b b6       	in	r0, 0x3b	; 59
    1c70:	0f 92       	push	r0
    1c72:	0c b6       	in	r0, 0x3c	; 60
    1c74:	0f 92       	push	r0
    1c76:	1f 92       	push	r1
    1c78:	11 24       	eor	r1, r1
    1c7a:	2f 92       	push	r2
    1c7c:	3f 92       	push	r3
    1c7e:	4f 92       	push	r4
    1c80:	5f 92       	push	r5
    1c82:	6f 92       	push	r6
    1c84:	7f 92       	push	r7
    1c86:	8f 92       	push	r8
    1c88:	9f 92       	push	r9
    1c8a:	af 92       	push	r10
    1c8c:	bf 92       	push	r11
    1c8e:	cf 92       	push	r12
    1c90:	df 92       	push	r13
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	2f 93       	push	r18
    1c9c:	3f 93       	push	r19
    1c9e:	4f 93       	push	r20
    1ca0:	5f 93       	push	r21
    1ca2:	6f 93       	push	r22
    1ca4:	7f 93       	push	r23
    1ca6:	8f 93       	push	r24
    1ca8:	9f 93       	push	r25
    1caa:	af 93       	push	r26
    1cac:	bf 93       	push	r27
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	ef 93       	push	r30
    1cb4:	ff 93       	push	r31
    1cb6:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1cba:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1cbe:	0d b6       	in	r0, 0x3d	; 61
    1cc0:	0d 92       	st	X+, r0
    1cc2:	0e b6       	in	r0, 0x3e	; 62
    1cc4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cc6:	0e 94 30 13 	call	0x2660	; 0x2660 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cca:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cce:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1cd2:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1cd6:	cd 91       	ld	r28, X+
    1cd8:	cd bf       	out	0x3d, r28	; 61
    1cda:	dd 91       	ld	r29, X+
    1cdc:	de bf       	out	0x3e, r29	; 62
    1cde:	ff 91       	pop	r31
    1ce0:	ef 91       	pop	r30
    1ce2:	df 91       	pop	r29
    1ce4:	cf 91       	pop	r28
    1ce6:	bf 91       	pop	r27
    1ce8:	af 91       	pop	r26
    1cea:	9f 91       	pop	r25
    1cec:	8f 91       	pop	r24
    1cee:	7f 91       	pop	r23
    1cf0:	6f 91       	pop	r22
    1cf2:	5f 91       	pop	r21
    1cf4:	4f 91       	pop	r20
    1cf6:	3f 91       	pop	r19
    1cf8:	2f 91       	pop	r18
    1cfa:	1f 91       	pop	r17
    1cfc:	0f 91       	pop	r16
    1cfe:	ff 90       	pop	r15
    1d00:	ef 90       	pop	r14
    1d02:	df 90       	pop	r13
    1d04:	cf 90       	pop	r12
    1d06:	bf 90       	pop	r11
    1d08:	af 90       	pop	r10
    1d0a:	9f 90       	pop	r9
    1d0c:	8f 90       	pop	r8
    1d0e:	7f 90       	pop	r7
    1d10:	6f 90       	pop	r6
    1d12:	5f 90       	pop	r5
    1d14:	4f 90       	pop	r4
    1d16:	3f 90       	pop	r3
    1d18:	2f 90       	pop	r2
    1d1a:	1f 90       	pop	r1
    1d1c:	0f 90       	pop	r0
    1d1e:	0c be       	out	0x3c, r0	; 60
    1d20:	0f 90       	pop	r0
    1d22:	0b be       	out	0x3b, r0	; 59
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63
    1d28:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d2a:	08 95       	ret

00001d2c <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1d2c:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d30:	18 95       	reti

00001d32 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1d32:	cf 93       	push	r28
    1d34:	df 93       	push	r29
    1d36:	ec 01       	movw	r28, r24
    1d38:	88 a1       	ldd	r24, Y+32	; 0x20
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	0b c0       	rjmp	.+22     	; 0x1d54 <prvCopyDataToQueue+0x22>
    1d3e:	88 81       	ld	r24, Y
    1d40:	99 81       	ldd	r25, Y+1	; 0x01
    1d42:	89 2b       	or	r24, r25
    1d44:	e1 f5       	brne	.+120    	; 0x1dbe <prvCopyDataToQueue+0x8c>
    1d46:	8a 81       	ldd	r24, Y+2	; 0x02
    1d48:	9b 81       	ldd	r25, Y+3	; 0x03
    1d4a:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <vTaskPriorityDisinherit>
    1d4e:	1a 82       	std	Y+2, r1	; 0x02
    1d50:	1b 82       	std	Y+3, r1	; 0x03
    1d52:	35 c0       	rjmp	.+106    	; 0x1dbe <prvCopyDataToQueue+0x8c>
    1d54:	41 11       	cpse	r20, r1
    1d56:	17 c0       	rjmp	.+46     	; 0x1d86 <prvCopyDataToQueue+0x54>
    1d58:	48 2f       	mov	r20, r24
    1d5a:	50 e0       	ldi	r21, 0x00	; 0
    1d5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d5e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d60:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <memcpy>
    1d64:	28 a1       	ldd	r18, Y+32	; 0x20
    1d66:	8c 81       	ldd	r24, Y+4	; 0x04
    1d68:	9d 81       	ldd	r25, Y+5	; 0x05
    1d6a:	82 0f       	add	r24, r18
    1d6c:	91 1d       	adc	r25, r1
    1d6e:	8c 83       	std	Y+4, r24	; 0x04
    1d70:	9d 83       	std	Y+5, r25	; 0x05
    1d72:	2a 81       	ldd	r18, Y+2	; 0x02
    1d74:	3b 81       	ldd	r19, Y+3	; 0x03
    1d76:	82 17       	cp	r24, r18
    1d78:	93 07       	cpc	r25, r19
    1d7a:	08 f1       	brcs	.+66     	; 0x1dbe <prvCopyDataToQueue+0x8c>
    1d7c:	88 81       	ld	r24, Y
    1d7e:	99 81       	ldd	r25, Y+1	; 0x01
    1d80:	8c 83       	std	Y+4, r24	; 0x04
    1d82:	9d 83       	std	Y+5, r25	; 0x05
    1d84:	1c c0       	rjmp	.+56     	; 0x1dbe <prvCopyDataToQueue+0x8c>
    1d86:	48 2f       	mov	r20, r24
    1d88:	50 e0       	ldi	r21, 0x00	; 0
    1d8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d8c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d8e:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <memcpy>
    1d92:	88 a1       	ldd	r24, Y+32	; 0x20
    1d94:	90 e0       	ldi	r25, 0x00	; 0
    1d96:	91 95       	neg	r25
    1d98:	81 95       	neg	r24
    1d9a:	91 09       	sbc	r25, r1
    1d9c:	2e 81       	ldd	r18, Y+6	; 0x06
    1d9e:	3f 81       	ldd	r19, Y+7	; 0x07
    1da0:	28 0f       	add	r18, r24
    1da2:	39 1f       	adc	r19, r25
    1da4:	2e 83       	std	Y+6, r18	; 0x06
    1da6:	3f 83       	std	Y+7, r19	; 0x07
    1da8:	48 81       	ld	r20, Y
    1daa:	59 81       	ldd	r21, Y+1	; 0x01
    1dac:	24 17       	cp	r18, r20
    1dae:	35 07       	cpc	r19, r21
    1db0:	30 f4       	brcc	.+12     	; 0x1dbe <prvCopyDataToQueue+0x8c>
    1db2:	2a 81       	ldd	r18, Y+2	; 0x02
    1db4:	3b 81       	ldd	r19, Y+3	; 0x03
    1db6:	82 0f       	add	r24, r18
    1db8:	93 1f       	adc	r25, r19
    1dba:	8e 83       	std	Y+6, r24	; 0x06
    1dbc:	9f 83       	std	Y+7, r25	; 0x07
    1dbe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1dc0:	8f 5f       	subi	r24, 0xFF	; 255
    1dc2:	8e 8f       	std	Y+30, r24	; 0x1e
    1dc4:	df 91       	pop	r29
    1dc6:	cf 91       	pop	r28
    1dc8:	08 95       	ret

00001dca <prvCopyDataFromQueue>:
    1dca:	fc 01       	movw	r30, r24
    1dcc:	80 81       	ld	r24, Z
    1dce:	91 81       	ldd	r25, Z+1	; 0x01
    1dd0:	00 97       	sbiw	r24, 0x00	; 0
    1dd2:	a1 f0       	breq	.+40     	; 0x1dfc <prvCopyDataFromQueue+0x32>
    1dd4:	40 a1       	ldd	r20, Z+32	; 0x20
    1dd6:	50 e0       	ldi	r21, 0x00	; 0
    1dd8:	26 81       	ldd	r18, Z+6	; 0x06
    1dda:	37 81       	ldd	r19, Z+7	; 0x07
    1ddc:	24 0f       	add	r18, r20
    1dde:	35 1f       	adc	r19, r21
    1de0:	26 83       	std	Z+6, r18	; 0x06
    1de2:	37 83       	std	Z+7, r19	; 0x07
    1de4:	a2 81       	ldd	r26, Z+2	; 0x02
    1de6:	b3 81       	ldd	r27, Z+3	; 0x03
    1de8:	2a 17       	cp	r18, r26
    1dea:	3b 07       	cpc	r19, r27
    1dec:	10 f0       	brcs	.+4      	; 0x1df2 <prvCopyDataFromQueue+0x28>
    1dee:	86 83       	std	Z+6, r24	; 0x06
    1df0:	97 83       	std	Z+7, r25	; 0x07
    1df2:	cb 01       	movw	r24, r22
    1df4:	66 81       	ldd	r22, Z+6	; 0x06
    1df6:	77 81       	ldd	r23, Z+7	; 0x07
    1df8:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <memcpy>
    1dfc:	08 95       	ret

00001dfe <prvUnlockQueue>:
    1dfe:	0f 93       	push	r16
    1e00:	1f 93       	push	r17
    1e02:	cf 93       	push	r28
    1e04:	df 93       	push	r29
    1e06:	ec 01       	movw	r28, r24
    1e08:	0f b6       	in	r0, 0x3f	; 63
    1e0a:	f8 94       	cli
    1e0c:	0f 92       	push	r0
    1e0e:	8a a1       	ldd	r24, Y+34	; 0x22
    1e10:	18 16       	cp	r1, r24
    1e12:	b4 f4       	brge	.+44     	; 0x1e40 <prvUnlockQueue+0x42>
    1e14:	8b 89       	ldd	r24, Y+19	; 0x13
    1e16:	81 11       	cpse	r24, r1
    1e18:	05 c0       	rjmp	.+10     	; 0x1e24 <prvUnlockQueue+0x26>
    1e1a:	12 c0       	rjmp	.+36     	; 0x1e40 <prvUnlockQueue+0x42>
    1e1c:	8b 89       	ldd	r24, Y+19	; 0x13
    1e1e:	81 11       	cpse	r24, r1
    1e20:	04 c0       	rjmp	.+8      	; 0x1e2a <prvUnlockQueue+0x2c>
    1e22:	0e c0       	rjmp	.+28     	; 0x1e40 <prvUnlockQueue+0x42>
    1e24:	8e 01       	movw	r16, r28
    1e26:	0d 5e       	subi	r16, 0xED	; 237
    1e28:	1f 4f       	sbci	r17, 0xFF	; 255
    1e2a:	c8 01       	movw	r24, r16
    1e2c:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    1e30:	81 11       	cpse	r24, r1
    1e32:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <vTaskMissedYield>
    1e36:	8a a1       	ldd	r24, Y+34	; 0x22
    1e38:	81 50       	subi	r24, 0x01	; 1
    1e3a:	8a a3       	std	Y+34, r24	; 0x22
    1e3c:	18 16       	cp	r1, r24
    1e3e:	74 f3       	brlt	.-36     	; 0x1e1c <prvUnlockQueue+0x1e>
    1e40:	8f ef       	ldi	r24, 0xFF	; 255
    1e42:	8a a3       	std	Y+34, r24	; 0x22
    1e44:	0f 90       	pop	r0
    1e46:	0f be       	out	0x3f, r0	; 63
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	f8 94       	cli
    1e4c:	0f 92       	push	r0
    1e4e:	89 a1       	ldd	r24, Y+33	; 0x21
    1e50:	18 16       	cp	r1, r24
    1e52:	b4 f4       	brge	.+44     	; 0x1e80 <prvUnlockQueue+0x82>
    1e54:	88 85       	ldd	r24, Y+8	; 0x08
    1e56:	81 11       	cpse	r24, r1
    1e58:	05 c0       	rjmp	.+10     	; 0x1e64 <prvUnlockQueue+0x66>
    1e5a:	12 c0       	rjmp	.+36     	; 0x1e80 <prvUnlockQueue+0x82>
    1e5c:	88 85       	ldd	r24, Y+8	; 0x08
    1e5e:	81 11       	cpse	r24, r1
    1e60:	04 c0       	rjmp	.+8      	; 0x1e6a <prvUnlockQueue+0x6c>
    1e62:	0e c0       	rjmp	.+28     	; 0x1e80 <prvUnlockQueue+0x82>
    1e64:	8e 01       	movw	r16, r28
    1e66:	08 5f       	subi	r16, 0xF8	; 248
    1e68:	1f 4f       	sbci	r17, 0xFF	; 255
    1e6a:	c8 01       	movw	r24, r16
    1e6c:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    1e70:	81 11       	cpse	r24, r1
    1e72:	0e 94 25 16 	call	0x2c4a	; 0x2c4a <vTaskMissedYield>
    1e76:	89 a1       	ldd	r24, Y+33	; 0x21
    1e78:	81 50       	subi	r24, 0x01	; 1
    1e7a:	89 a3       	std	Y+33, r24	; 0x21
    1e7c:	18 16       	cp	r1, r24
    1e7e:	74 f3       	brlt	.-36     	; 0x1e5c <prvUnlockQueue+0x5e>
    1e80:	8f ef       	ldi	r24, 0xFF	; 255
    1e82:	89 a3       	std	Y+33, r24	; 0x21
    1e84:	0f 90       	pop	r0
    1e86:	0f be       	out	0x3f, r0	; 63
    1e88:	df 91       	pop	r29
    1e8a:	cf 91       	pop	r28
    1e8c:	1f 91       	pop	r17
    1e8e:	0f 91       	pop	r16
    1e90:	08 95       	ret

00001e92 <xQueueGenericReset>:
    1e92:	1f 93       	push	r17
    1e94:	cf 93       	push	r28
    1e96:	df 93       	push	r29
    1e98:	61 30       	cpi	r22, 0x01	; 1
    1e9a:	59 f0       	breq	.+22     	; 0x1eb2 <xQueueGenericReset+0x20>
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	23 89       	ldd	r18, Z+19	; 0x13
    1ea0:	30 85       	ldd	r19, Z+8	; 0x08
    1ea2:	31 11       	cpse	r19, r1
    1ea4:	2c c0       	rjmp	.+88     	; 0x1efe <xQueueGenericReset+0x6c>
    1ea6:	11 e0       	ldi	r17, 0x01	; 1
    1ea8:	21 11       	cpse	r18, r1
    1eaa:	10 e0       	ldi	r17, 0x00	; 0
    1eac:	21 11       	cpse	r18, r1
    1eae:	28 c0       	rjmp	.+80     	; 0x1f00 <xQueueGenericReset+0x6e>
    1eb0:	01 c0       	rjmp	.+2      	; 0x1eb4 <xQueueGenericReset+0x22>
    1eb2:	11 e0       	ldi	r17, 0x01	; 1
    1eb4:	ec 01       	movw	r28, r24
    1eb6:	48 81       	ld	r20, Y
    1eb8:	59 81       	ldd	r21, Y+1	; 0x01
    1eba:	28 a1       	ldd	r18, Y+32	; 0x20
    1ebc:	30 e0       	ldi	r19, 0x00	; 0
    1ebe:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1ec0:	62 9f       	mul	r22, r18
    1ec2:	c0 01       	movw	r24, r0
    1ec4:	63 9f       	mul	r22, r19
    1ec6:	90 0d       	add	r25, r0
    1ec8:	11 24       	eor	r1, r1
    1eca:	ba 01       	movw	r22, r20
    1ecc:	68 0f       	add	r22, r24
    1ece:	79 1f       	adc	r23, r25
    1ed0:	6a 83       	std	Y+2, r22	; 0x02
    1ed2:	7b 83       	std	Y+3, r23	; 0x03
    1ed4:	1e 8e       	std	Y+30, r1	; 0x1e
    1ed6:	4c 83       	std	Y+4, r20	; 0x04
    1ed8:	5d 83       	std	Y+5, r21	; 0x05
    1eda:	82 1b       	sub	r24, r18
    1edc:	93 0b       	sbc	r25, r19
    1ede:	84 0f       	add	r24, r20
    1ee0:	95 1f       	adc	r25, r21
    1ee2:	8e 83       	std	Y+6, r24	; 0x06
    1ee4:	9f 83       	std	Y+7, r25	; 0x07
    1ee6:	8f ef       	ldi	r24, 0xFF	; 255
    1ee8:	89 a3       	std	Y+33, r24	; 0x21
    1eea:	8a a3       	std	Y+34, r24	; 0x22
    1eec:	ce 01       	movw	r24, r28
    1eee:	08 96       	adiw	r24, 0x08	; 8
    1ef0:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    1ef4:	ce 01       	movw	r24, r28
    1ef6:	43 96       	adiw	r24, 0x13	; 19
    1ef8:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    1efc:	01 c0       	rjmp	.+2      	; 0x1f00 <xQueueGenericReset+0x6e>
    1efe:	10 e0       	ldi	r17, 0x00	; 0
    1f00:	81 2f       	mov	r24, r17
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	1f 91       	pop	r17
    1f08:	08 95       	ret

00001f0a <xQueueGenericCreate>:
    1f0a:	0f 93       	push	r16
    1f0c:	1f 93       	push	r17
    1f0e:	cf 93       	push	r28
    1f10:	df 93       	push	r29
    1f12:	88 23       	and	r24, r24
    1f14:	01 f1       	breq	.+64     	; 0x1f56 <xQueueGenericCreate+0x4c>
    1f16:	06 2f       	mov	r16, r22
    1f18:	18 2f       	mov	r17, r24
    1f1a:	83 e2       	ldi	r24, 0x23	; 35
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    1f22:	ec 01       	movw	r28, r24
    1f24:	89 2b       	or	r24, r25
    1f26:	c9 f0       	breq	.+50     	; 0x1f5a <xQueueGenericCreate+0x50>
    1f28:	10 9f       	mul	r17, r16
    1f2a:	c0 01       	movw	r24, r0
    1f2c:	11 24       	eor	r1, r1
    1f2e:	01 96       	adiw	r24, 0x01	; 1
    1f30:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    1f34:	88 83       	st	Y, r24
    1f36:	99 83       	std	Y+1, r25	; 0x01
    1f38:	89 2b       	or	r24, r25
    1f3a:	39 f0       	breq	.+14     	; 0x1f4a <xQueueGenericCreate+0x40>
    1f3c:	1f 8f       	std	Y+31, r17	; 0x1f
    1f3e:	08 a3       	std	Y+32, r16	; 0x20
    1f40:	61 e0       	ldi	r22, 0x01	; 1
    1f42:	ce 01       	movw	r24, r28
    1f44:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <xQueueGenericReset>
    1f48:	08 c0       	rjmp	.+16     	; 0x1f5a <xQueueGenericCreate+0x50>
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	0e 94 39 0c 	call	0x1872	; 0x1872 <vPortFree>
    1f50:	c0 e0       	ldi	r28, 0x00	; 0
    1f52:	d0 e0       	ldi	r29, 0x00	; 0
    1f54:	02 c0       	rjmp	.+4      	; 0x1f5a <xQueueGenericCreate+0x50>
    1f56:	c0 e0       	ldi	r28, 0x00	; 0
    1f58:	d0 e0       	ldi	r29, 0x00	; 0
    1f5a:	ce 01       	movw	r24, r28
    1f5c:	df 91       	pop	r29
    1f5e:	cf 91       	pop	r28
    1f60:	1f 91       	pop	r17
    1f62:	0f 91       	pop	r16
    1f64:	08 95       	ret

00001f66 <xQueueGenericSend>:
    1f66:	af 92       	push	r10
    1f68:	bf 92       	push	r11
    1f6a:	cf 92       	push	r12
    1f6c:	df 92       	push	r13
    1f6e:	ef 92       	push	r14
    1f70:	ff 92       	push	r15
    1f72:	0f 93       	push	r16
    1f74:	1f 93       	push	r17
    1f76:	cf 93       	push	r28
    1f78:	df 93       	push	r29
    1f7a:	cd b7       	in	r28, 0x3d	; 61
    1f7c:	de b7       	in	r29, 0x3e	; 62
    1f7e:	29 97       	sbiw	r28, 0x09	; 9
    1f80:	cd bf       	out	0x3d, r28	; 61
    1f82:	de bf       	out	0x3e, r29	; 62
    1f84:	7c 01       	movw	r14, r24
    1f86:	5b 01       	movw	r10, r22
    1f88:	2e 83       	std	Y+6, r18	; 0x06
    1f8a:	3f 83       	std	Y+7, r19	; 0x07
    1f8c:	48 87       	std	Y+8, r20	; 0x08
    1f8e:	59 87       	std	Y+9, r21	; 0x09
    1f90:	10 e0       	ldi	r17, 0x00	; 0
    1f92:	6c 01       	movw	r12, r24
    1f94:	88 e0       	ldi	r24, 0x08	; 8
    1f96:	c8 0e       	add	r12, r24
    1f98:	d1 1c       	adc	r13, r1
    1f9a:	0f b6       	in	r0, 0x3f	; 63
    1f9c:	f8 94       	cli
    1f9e:	0f 92       	push	r0
    1fa0:	f7 01       	movw	r30, r14
    1fa2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1fa4:	87 8d       	ldd	r24, Z+31	; 0x1f
    1fa6:	98 17       	cp	r25, r24
    1fa8:	a8 f4       	brcc	.+42     	; 0x1fd4 <xQueueGenericSend+0x6e>
    1faa:	40 2f       	mov	r20, r16
    1fac:	b5 01       	movw	r22, r10
    1fae:	c7 01       	movw	r24, r14
    1fb0:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <prvCopyDataToQueue>
    1fb4:	f7 01       	movw	r30, r14
    1fb6:	83 89       	ldd	r24, Z+19	; 0x13
    1fb8:	88 23       	and	r24, r24
    1fba:	41 f0       	breq	.+16     	; 0x1fcc <xQueueGenericSend+0x66>
    1fbc:	c7 01       	movw	r24, r14
    1fbe:	43 96       	adiw	r24, 0x13	; 19
    1fc0:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    1fc4:	81 30       	cpi	r24, 0x01	; 1
    1fc6:	11 f4       	brne	.+4      	; 0x1fcc <xQueueGenericSend+0x66>
    1fc8:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	56 c0       	rjmp	.+172    	; 0x2080 <xQueueGenericSend+0x11a>
    1fd4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fd6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fd8:	a8 85       	ldd	r26, Y+8	; 0x08
    1fda:	b9 85       	ldd	r27, Y+9	; 0x09
    1fdc:	89 2b       	or	r24, r25
    1fde:	8a 2b       	or	r24, r26
    1fe0:	8b 2b       	or	r24, r27
    1fe2:	21 f4       	brne	.+8      	; 0x1fec <xQueueGenericSend+0x86>
    1fe4:	0f 90       	pop	r0
    1fe6:	0f be       	out	0x3f, r0	; 63
    1fe8:	80 e0       	ldi	r24, 0x00	; 0
    1fea:	4a c0       	rjmp	.+148    	; 0x2080 <xQueueGenericSend+0x11a>
    1fec:	11 11       	cpse	r17, r1
    1fee:	05 c0       	rjmp	.+10     	; 0x1ffa <xQueueGenericSend+0x94>
    1ff0:	ce 01       	movw	r24, r28
    1ff2:	01 96       	adiw	r24, 0x01	; 1
    1ff4:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <vTaskSetTimeOutState>
    1ff8:	11 e0       	ldi	r17, 0x01	; 1
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	0e 94 0f 13 	call	0x261e	; 0x261e <vTaskSuspendAll>
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
    2008:	f7 01       	movw	r30, r14
    200a:	81 a1       	ldd	r24, Z+33	; 0x21
    200c:	8f 3f       	cpi	r24, 0xFF	; 255
    200e:	09 f4       	brne	.+2      	; 0x2012 <xQueueGenericSend+0xac>
    2010:	11 a2       	std	Z+33, r1	; 0x21
    2012:	f7 01       	movw	r30, r14
    2014:	82 a1       	ldd	r24, Z+34	; 0x22
    2016:	8f 3f       	cpi	r24, 0xFF	; 255
    2018:	09 f4       	brne	.+2      	; 0x201c <xQueueGenericSend+0xb6>
    201a:	12 a2       	std	Z+34, r1	; 0x22
    201c:	0f 90       	pop	r0
    201e:	0f be       	out	0x3f, r0	; 63
    2020:	be 01       	movw	r22, r28
    2022:	6a 5f       	subi	r22, 0xFA	; 250
    2024:	7f 4f       	sbci	r23, 0xFF	; 255
    2026:	ce 01       	movw	r24, r28
    2028:	01 96       	adiw	r24, 0x01	; 1
    202a:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <xTaskCheckForTimeOut>
    202e:	81 11       	cpse	r24, r1
    2030:	21 c0       	rjmp	.+66     	; 0x2074 <xQueueGenericSend+0x10e>
    2032:	0f b6       	in	r0, 0x3f	; 63
    2034:	f8 94       	cli
    2036:	0f 92       	push	r0
    2038:	f7 01       	movw	r30, r14
    203a:	96 8d       	ldd	r25, Z+30	; 0x1e
    203c:	0f 90       	pop	r0
    203e:	0f be       	out	0x3f, r0	; 63
    2040:	87 8d       	ldd	r24, Z+31	; 0x1f
    2042:	98 13       	cpse	r25, r24
    2044:	11 c0       	rjmp	.+34     	; 0x2068 <xQueueGenericSend+0x102>
    2046:	4e 81       	ldd	r20, Y+6	; 0x06
    2048:	5f 81       	ldd	r21, Y+7	; 0x07
    204a:	68 85       	ldd	r22, Y+8	; 0x08
    204c:	79 85       	ldd	r23, Y+9	; 0x09
    204e:	c6 01       	movw	r24, r12
    2050:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <vTaskPlaceOnEventList>
    2054:	c7 01       	movw	r24, r14
    2056:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
    205a:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
    205e:	81 11       	cpse	r24, r1
    2060:	9c cf       	rjmp	.-200    	; 0x1f9a <xQueueGenericSend+0x34>
    2062:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    2066:	99 cf       	rjmp	.-206    	; 0x1f9a <xQueueGenericSend+0x34>
    2068:	c7 01       	movw	r24, r14
    206a:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
    206e:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
    2072:	93 cf       	rjmp	.-218    	; 0x1f9a <xQueueGenericSend+0x34>
    2074:	c7 01       	movw	r24, r14
    2076:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
    207a:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
    207e:	80 e0       	ldi	r24, 0x00	; 0
    2080:	29 96       	adiw	r28, 0x09	; 9
    2082:	cd bf       	out	0x3d, r28	; 61
    2084:	de bf       	out	0x3e, r29	; 62
    2086:	df 91       	pop	r29
    2088:	cf 91       	pop	r28
    208a:	1f 91       	pop	r17
    208c:	0f 91       	pop	r16
    208e:	ff 90       	pop	r15
    2090:	ef 90       	pop	r14
    2092:	df 90       	pop	r13
    2094:	cf 90       	pop	r12
    2096:	bf 90       	pop	r11
    2098:	af 90       	pop	r10
    209a:	08 95       	ret

0000209c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    209c:	0f 93       	push	r16
    209e:	1f 93       	push	r17
    20a0:	cf 93       	push	r28
    20a2:	df 93       	push	r29
    20a4:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20a6:	fc 01       	movw	r30, r24
    20a8:	56 8d       	ldd	r21, Z+30	; 0x1e
    20aa:	37 8d       	ldd	r19, Z+31	; 0x1f
    20ac:	53 17       	cp	r21, r19
    20ae:	c0 f4       	brcc	.+48     	; 0x20e0 <xQueueGenericSendFromISR+0x44>
    20b0:	42 2f       	mov	r20, r18
    20b2:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20b4:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    20b8:	8a a1       	ldd	r24, Y+34	; 0x22
    20ba:	8f 3f       	cpi	r24, 0xFF	; 255
    20bc:	69 f4       	brne	.+26     	; 0x20d8 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20be:	8b 89       	ldd	r24, Y+19	; 0x13
    20c0:	88 23       	and	r24, r24
    20c2:	81 f0       	breq	.+32     	; 0x20e4 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20c4:	ce 01       	movw	r24, r28
    20c6:	43 96       	adiw	r24, 0x13	; 19
    20c8:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    20cc:	88 23       	and	r24, r24
    20ce:	61 f0       	breq	.+24     	; 0x20e8 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    20d0:	81 e0       	ldi	r24, 0x01	; 1
    20d2:	f8 01       	movw	r30, r16
    20d4:	80 83       	st	Z, r24
    20d6:	09 c0       	rjmp	.+18     	; 0x20ea <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    20d8:	8f 5f       	subi	r24, 0xFF	; 255
    20da:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	05 c0       	rjmp	.+10     	; 0x20ea <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20e0:	80 e0       	ldi	r24, 0x00	; 0
    20e2:	03 c0       	rjmp	.+6      	; 0x20ea <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	01 c0       	rjmp	.+2      	; 0x20ea <xQueueGenericSendFromISR+0x4e>
    20e8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	1f 91       	pop	r17
    20f0:	0f 91       	pop	r16
    20f2:	08 95       	ret

000020f4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    20f4:	af 92       	push	r10
    20f6:	bf 92       	push	r11
    20f8:	cf 92       	push	r12
    20fa:	df 92       	push	r13
    20fc:	ef 92       	push	r14
    20fe:	ff 92       	push	r15
    2100:	0f 93       	push	r16
    2102:	1f 93       	push	r17
    2104:	cf 93       	push	r28
    2106:	df 93       	push	r29
    2108:	cd b7       	in	r28, 0x3d	; 61
    210a:	de b7       	in	r29, 0x3e	; 62
    210c:	29 97       	sbiw	r28, 0x09	; 9
    210e:	cd bf       	out	0x3d, r28	; 61
    2110:	de bf       	out	0x3e, r29	; 62
    2112:	7c 01       	movw	r14, r24
    2114:	5b 01       	movw	r10, r22
    2116:	2e 83       	std	Y+6, r18	; 0x06
    2118:	3f 83       	std	Y+7, r19	; 0x07
    211a:	48 87       	std	Y+8, r20	; 0x08
    211c:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    211e:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2120:	6c 01       	movw	r12, r24
    2122:	83 e1       	ldi	r24, 0x13	; 19
    2124:	c8 0e       	add	r12, r24
    2126:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    212e:	f7 01       	movw	r30, r14
    2130:	86 8d       	ldd	r24, Z+30	; 0x1e
    2132:	88 23       	and	r24, r24
    2134:	99 f1       	breq	.+102    	; 0x219c <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2136:	c6 80       	ldd	r12, Z+6	; 0x06
    2138:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    213a:	b5 01       	movw	r22, r10
    213c:	c7 01       	movw	r24, r14
    213e:	0e 94 e5 0e 	call	0x1dca	; 0x1dca <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2142:	01 11       	cpse	r16, r1
    2144:	1a c0       	rjmp	.+52     	; 0x217a <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2146:	f7 01       	movw	r30, r14
    2148:	86 8d       	ldd	r24, Z+30	; 0x1e
    214a:	81 50       	subi	r24, 0x01	; 1
    214c:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    214e:	80 81       	ld	r24, Z
    2150:	91 81       	ldd	r25, Z+1	; 0x01
    2152:	89 2b       	or	r24, r25
    2154:	29 f4       	brne	.+10     	; 0x2160 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2156:	0e 94 42 16 	call	0x2c84	; 0x2c84 <xTaskGetCurrentTaskHandle>
    215a:	f7 01       	movw	r30, r14
    215c:	82 83       	std	Z+2, r24	; 0x02
    215e:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2160:	f7 01       	movw	r30, r14
    2162:	80 85       	ldd	r24, Z+8	; 0x08
    2164:	88 23       	and	r24, r24
    2166:	b1 f0       	breq	.+44     	; 0x2194 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2168:	c7 01       	movw	r24, r14
    216a:	08 96       	adiw	r24, 0x08	; 8
    216c:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    2170:	81 30       	cpi	r24, 0x01	; 1
    2172:	81 f4       	brne	.+32     	; 0x2194 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    2174:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    2178:	0d c0       	rjmp	.+26     	; 0x2194 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    217a:	f7 01       	movw	r30, r14
    217c:	c6 82       	std	Z+6, r12	; 0x06
    217e:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2180:	83 89       	ldd	r24, Z+19	; 0x13
    2182:	88 23       	and	r24, r24
    2184:	39 f0       	breq	.+14     	; 0x2194 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2186:	c7 01       	movw	r24, r14
    2188:	43 96       	adiw	r24, 0x13	; 19
    218a:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    218e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2190:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2194:	0f 90       	pop	r0
    2196:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2198:	81 e0       	ldi	r24, 0x01	; 1
    219a:	62 c0       	rjmp	.+196    	; 0x2260 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    219c:	8e 81       	ldd	r24, Y+6	; 0x06
    219e:	9f 81       	ldd	r25, Y+7	; 0x07
    21a0:	a8 85       	ldd	r26, Y+8	; 0x08
    21a2:	b9 85       	ldd	r27, Y+9	; 0x09
    21a4:	89 2b       	or	r24, r25
    21a6:	8a 2b       	or	r24, r26
    21a8:	8b 2b       	or	r24, r27
    21aa:	21 f4       	brne	.+8      	; 0x21b4 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21ac:	0f 90       	pop	r0
    21ae:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    21b0:	80 e0       	ldi	r24, 0x00	; 0
    21b2:	56 c0       	rjmp	.+172    	; 0x2260 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    21b4:	11 11       	cpse	r17, r1
    21b6:	05 c0       	rjmp	.+10     	; 0x21c2 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    21b8:	ce 01       	movw	r24, r28
    21ba:	01 96       	adiw	r24, 0x01	; 1
    21bc:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    21c0:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    21c2:	0f 90       	pop	r0
    21c4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    21c6:	0e 94 0f 13 	call	0x261e	; 0x261e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	0f 92       	push	r0
    21d0:	f7 01       	movw	r30, r14
    21d2:	81 a1       	ldd	r24, Z+33	; 0x21
    21d4:	8f 3f       	cpi	r24, 0xFF	; 255
    21d6:	09 f4       	brne	.+2      	; 0x21da <xQueueGenericReceive+0xe6>
    21d8:	11 a2       	std	Z+33, r1	; 0x21
    21da:	f7 01       	movw	r30, r14
    21dc:	82 a1       	ldd	r24, Z+34	; 0x22
    21de:	8f 3f       	cpi	r24, 0xFF	; 255
    21e0:	09 f4       	brne	.+2      	; 0x21e4 <xQueueGenericReceive+0xf0>
    21e2:	12 a2       	std	Z+34, r1	; 0x22
    21e4:	0f 90       	pop	r0
    21e6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21e8:	be 01       	movw	r22, r28
    21ea:	6a 5f       	subi	r22, 0xFA	; 250
    21ec:	7f 4f       	sbci	r23, 0xFF	; 255
    21ee:	ce 01       	movw	r24, r28
    21f0:	01 96       	adiw	r24, 0x01	; 1
    21f2:	0e 94 b8 15 	call	0x2b70	; 0x2b70 <xTaskCheckForTimeOut>
    21f6:	81 11       	cpse	r24, r1
    21f8:	2d c0       	rjmp	.+90     	; 0x2254 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2200:	f7 01       	movw	r30, r14
    2202:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2208:	81 11       	cpse	r24, r1
    220a:	1e c0       	rjmp	.+60     	; 0x2248 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    220c:	80 81       	ld	r24, Z
    220e:	91 81       	ldd	r25, Z+1	; 0x01
    2210:	89 2b       	or	r24, r25
    2212:	49 f4       	brne	.+18     	; 0x2226 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2214:	0f b6       	in	r0, 0x3f	; 63
    2216:	f8 94       	cli
    2218:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    221a:	82 81       	ldd	r24, Z+2	; 0x02
    221c:	93 81       	ldd	r25, Z+3	; 0x03
    221e:	0e 94 47 16 	call	0x2c8e	; 0x2c8e <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2222:	0f 90       	pop	r0
    2224:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2226:	4e 81       	ldd	r20, Y+6	; 0x06
    2228:	5f 81       	ldd	r21, Y+7	; 0x07
    222a:	68 85       	ldd	r22, Y+8	; 0x08
    222c:	79 85       	ldd	r23, Y+9	; 0x09
    222e:	c6 01       	movw	r24, r12
    2230:	0e 94 3e 15 	call	0x2a7c	; 0x2a7c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2234:	c7 01       	movw	r24, r14
    2236:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    223a:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
    223e:	81 11       	cpse	r24, r1
    2240:	73 cf       	rjmp	.-282    	; 0x2128 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2242:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    2246:	70 cf       	rjmp	.-288    	; 0x2128 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2248:	c7 01       	movw	r24, r14
    224a:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
				( void ) xTaskResumeAll();
    224e:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
    2252:	6a cf       	rjmp	.-300    	; 0x2128 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2254:	c7 01       	movw	r24, r14
    2256:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvUnlockQueue>
			( void ) xTaskResumeAll();
    225a:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    225e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2260:	29 96       	adiw	r28, 0x09	; 9
    2262:	cd bf       	out	0x3d, r28	; 61
    2264:	de bf       	out	0x3e, r29	; 62
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	ff 90       	pop	r15
    2270:	ef 90       	pop	r14
    2272:	df 90       	pop	r13
    2274:	cf 90       	pop	r12
    2276:	bf 90       	pop	r11
    2278:	af 90       	pop	r10
    227a:	08 95       	ret

0000227c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    227c:	0f 93       	push	r16
    227e:	1f 93       	push	r17
    2280:	cf 93       	push	r28
    2282:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2284:	fc 01       	movw	r30, r24
    2286:	26 8d       	ldd	r18, Z+30	; 0x1e
    2288:	22 23       	and	r18, r18
    228a:	d9 f0       	breq	.+54     	; 0x22c2 <xQueueReceiveFromISR+0x46>
    228c:	8a 01       	movw	r16, r20
    228e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2290:	0e 94 e5 0e 	call	0x1dca	; 0x1dca <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2294:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2296:	81 50       	subi	r24, 0x01	; 1
    2298:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    229a:	89 a1       	ldd	r24, Y+33	; 0x21
    229c:	8f 3f       	cpi	r24, 0xFF	; 255
    229e:	69 f4       	brne	.+26     	; 0x22ba <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22a0:	88 85       	ldd	r24, Y+8	; 0x08
    22a2:	88 23       	and	r24, r24
    22a4:	81 f0       	breq	.+32     	; 0x22c6 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22a6:	ce 01       	movw	r24, r28
    22a8:	08 96       	adiw	r24, 0x08	; 8
    22aa:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskRemoveFromEventList>
    22ae:	88 23       	and	r24, r24
    22b0:	61 f0       	breq	.+24     	; 0x22ca <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    22b2:	81 e0       	ldi	r24, 0x01	; 1
    22b4:	f8 01       	movw	r30, r16
    22b6:	80 83       	st	Z, r24
    22b8:	09 c0       	rjmp	.+18     	; 0x22cc <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    22ba:	8f 5f       	subi	r24, 0xFF	; 255
    22bc:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    22be:	81 e0       	ldi	r24, 0x01	; 1
    22c0:	05 c0       	rjmp	.+10     	; 0x22cc <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	03 c0       	rjmp	.+6      	; 0x22cc <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    22c6:	81 e0       	ldi	r24, 0x01	; 1
    22c8:	01 c0       	rjmp	.+2      	; 0x22cc <xQueueReceiveFromISR+0x50>
    22ca:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    22cc:	df 91       	pop	r29
    22ce:	cf 91       	pop	r28
    22d0:	1f 91       	pop	r17
    22d2:	0f 91       	pop	r16
    22d4:	08 95       	ret

000022d6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    22d6:	0f b6       	in	r0, 0x3f	; 63
    22d8:	f8 94       	cli
    22da:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    22dc:	fc 01       	movw	r30, r24
    22de:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    22e0:	0f 90       	pop	r0
    22e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    22e4:	08 95       	ret

000022e6 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    22e6:	fc 01       	movw	r30, r24
    22e8:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    22ea:	08 95       	ret

000022ec <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    22ec:	c4 ea       	ldi	r28, 0xA4	; 164
    22ee:	d1 e3       	ldi	r29, 0x31	; 49
    22f0:	88 81       	ld	r24, Y
    22f2:	82 30       	cpi	r24, 0x02	; 2
    22f4:	e8 f3       	brcs	.-6      	; 0x22f0 <prvIdleTask+0x4>
    22f6:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    22fa:	fa cf       	rjmp	.-12     	; 0x22f0 <prvIdleTask+0x4>

000022fc <prvAddCurrentTaskToDelayedList>:
    22fc:	cf 92       	push	r12
    22fe:	df 92       	push	r13
    2300:	ef 92       	push	r14
    2302:	ff 92       	push	r15
    2304:	6b 01       	movw	r12, r22
    2306:	7c 01       	movw	r14, r24
    2308:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    230c:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2310:	62 83       	std	Z+2, r22	; 0x02
    2312:	73 83       	std	Z+3, r23	; 0x03
    2314:	84 83       	std	Z+4, r24	; 0x04
    2316:	95 83       	std	Z+5, r25	; 0x05
    2318:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    231c:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2320:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2324:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2328:	c8 16       	cp	r12, r24
    232a:	d9 06       	cpc	r13, r25
    232c:	ea 06       	cpc	r14, r26
    232e:	fb 06       	cpc	r15, r27
    2330:	68 f4       	brcc	.+26     	; 0x234c <prvAddCurrentTaskToDelayedList+0x50>
    2332:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2336:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    233a:	80 91 8a 31 	lds	r24, 0x318A	; 0x80318a <pxOverflowDelayedTaskList>
    233e:	90 91 8b 31 	lds	r25, 0x318B	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    2342:	6e 5f       	subi	r22, 0xFE	; 254
    2344:	7f 4f       	sbci	r23, 0xFF	; 255
    2346:	0e 94 ad 0c 	call	0x195a	; 0x195a <vListInsert>
    234a:	21 c0       	rjmp	.+66     	; 0x238e <prvAddCurrentTaskToDelayedList+0x92>
    234c:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2350:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2354:	80 91 8c 31 	lds	r24, 0x318C	; 0x80318c <pxDelayedTaskList>
    2358:	90 91 8d 31 	lds	r25, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    235c:	6e 5f       	subi	r22, 0xFE	; 254
    235e:	7f 4f       	sbci	r23, 0xFF	; 255
    2360:	0e 94 ad 0c 	call	0x195a	; 0x195a <vListInsert>
    2364:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2368:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    236c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2370:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2374:	c8 16       	cp	r12, r24
    2376:	d9 06       	cpc	r13, r25
    2378:	ea 06       	cpc	r14, r26
    237a:	fb 06       	cpc	r15, r27
    237c:	40 f4       	brcc	.+16     	; 0x238e <prvAddCurrentTaskToDelayedList+0x92>
    237e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2382:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2386:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    238a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    238e:	ff 90       	pop	r15
    2390:	ef 90       	pop	r14
    2392:	df 90       	pop	r13
    2394:	cf 90       	pop	r12
    2396:	08 95       	ret

00002398 <xTaskGenericCreate>:
    2398:	4f 92       	push	r4
    239a:	5f 92       	push	r5
    239c:	6f 92       	push	r6
    239e:	7f 92       	push	r7
    23a0:	8f 92       	push	r8
    23a2:	9f 92       	push	r9
    23a4:	af 92       	push	r10
    23a6:	bf 92       	push	r11
    23a8:	cf 92       	push	r12
    23aa:	df 92       	push	r13
    23ac:	ef 92       	push	r14
    23ae:	ff 92       	push	r15
    23b0:	0f 93       	push	r16
    23b2:	1f 93       	push	r17
    23b4:	cf 93       	push	r28
    23b6:	df 93       	push	r29
    23b8:	5c 01       	movw	r10, r24
    23ba:	4b 01       	movw	r8, r22
    23bc:	3a 01       	movw	r6, r20
    23be:	29 01       	movw	r4, r18
    23c0:	88 e2       	ldi	r24, 0x28	; 40
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    23c8:	ec 01       	movw	r28, r24
    23ca:	89 2b       	or	r24, r25
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <xTaskGenericCreate+0x38>
    23ce:	d4 c0       	rjmp	.+424    	; 0x2578 <xTaskGenericCreate+0x1e0>
    23d0:	c1 14       	cp	r12, r1
    23d2:	d1 04       	cpc	r13, r1
    23d4:	09 f0       	breq	.+2      	; 0x23d8 <xTaskGenericCreate+0x40>
    23d6:	cc c0       	rjmp	.+408    	; 0x2570 <xTaskGenericCreate+0x1d8>
    23d8:	c3 01       	movw	r24, r6
    23da:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    23de:	8b 8f       	std	Y+27, r24	; 0x1b
    23e0:	9c 8f       	std	Y+28, r25	; 0x1c
    23e2:	00 97       	sbiw	r24, 0x00	; 0
    23e4:	21 f4       	brne	.+8      	; 0x23ee <xTaskGenericCreate+0x56>
    23e6:	ce 01       	movw	r24, r28
    23e8:	0e 94 39 0c 	call	0x1872	; 0x1872 <vPortFree>
    23ec:	c5 c0       	rjmp	.+394    	; 0x2578 <xTaskGenericCreate+0x1e0>
    23ee:	a3 01       	movw	r20, r6
    23f0:	61 e1       	ldi	r22, 0x11	; 17
    23f2:	70 e0       	ldi	r23, 0x00	; 0
    23f4:	0e 94 da 23 	call	0x47b4	; 0x47b4 <memset>
    23f8:	93 01       	movw	r18, r6
    23fa:	21 50       	subi	r18, 0x01	; 1
    23fc:	31 09       	sbc	r19, r1
    23fe:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2400:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2402:	3c 01       	movw	r6, r24
    2404:	62 0e       	add	r6, r18
    2406:	73 1e       	adc	r7, r19
    2408:	4a e0       	ldi	r20, 0x0A	; 10
    240a:	50 e0       	ldi	r21, 0x00	; 0
    240c:	b4 01       	movw	r22, r8
    240e:	ce 01       	movw	r24, r28
    2410:	4d 96       	adiw	r24, 0x1d	; 29
    2412:	0e 94 e1 23 	call	0x47c2	; 0x47c2 <strncpy>
    2416:	1e a2       	std	Y+38, r1	; 0x26
    2418:	10 2f       	mov	r17, r16
    241a:	04 30       	cpi	r16, 0x04	; 4
    241c:	08 f0       	brcs	.+2      	; 0x2420 <xTaskGenericCreate+0x88>
    241e:	13 e0       	ldi	r17, 0x03	; 3
    2420:	1a 8f       	std	Y+26, r17	; 0x1a
    2422:	1f a3       	std	Y+39, r17	; 0x27
    2424:	6e 01       	movw	r12, r28
    2426:	22 e0       	ldi	r18, 0x02	; 2
    2428:	c2 0e       	add	r12, r18
    242a:	d1 1c       	adc	r13, r1
    242c:	c6 01       	movw	r24, r12
    242e:	0e 94 82 0c 	call	0x1904	; 0x1904 <vListInitialiseItem>
    2432:	ce 01       	movw	r24, r28
    2434:	0e 96       	adiw	r24, 0x0e	; 14
    2436:	0e 94 82 0c 	call	0x1904	; 0x1904 <vListInitialiseItem>
    243a:	ca 87       	std	Y+10, r28	; 0x0a
    243c:	db 87       	std	Y+11, r29	; 0x0b
    243e:	84 e0       	ldi	r24, 0x04	; 4
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	a0 e0       	ldi	r26, 0x00	; 0
    2444:	b0 e0       	ldi	r27, 0x00	; 0
    2446:	81 1b       	sub	r24, r17
    2448:	91 09       	sbc	r25, r1
    244a:	a1 09       	sbc	r26, r1
    244c:	b1 09       	sbc	r27, r1
    244e:	8e 87       	std	Y+14, r24	; 0x0e
    2450:	9f 87       	std	Y+15, r25	; 0x0f
    2452:	a8 8b       	std	Y+16, r26	; 0x10
    2454:	b9 8b       	std	Y+17, r27	; 0x11
    2456:	ce 8b       	std	Y+22, r28	; 0x16
    2458:	df 8b       	std	Y+23, r29	; 0x17
    245a:	a2 01       	movw	r20, r4
    245c:	b5 01       	movw	r22, r10
    245e:	c3 01       	movw	r24, r6
    2460:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <pxPortInitialiseStack>
    2464:	88 83       	st	Y, r24
    2466:	99 83       	std	Y+1, r25	; 0x01
    2468:	e1 14       	cp	r14, r1
    246a:	f1 04       	cpc	r15, r1
    246c:	19 f0       	breq	.+6      	; 0x2474 <xTaskGenericCreate+0xdc>
    246e:	f7 01       	movw	r30, r14
    2470:	c0 83       	st	Z, r28
    2472:	d1 83       	std	Z+1, r29	; 0x01
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	f8 94       	cli
    2478:	0f 92       	push	r0
    247a:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    247e:	8f 5f       	subi	r24, 0xFF	; 255
    2480:	80 93 7c 31 	sts	0x317C, r24	; 0x80317c <uxCurrentNumberOfTasks>
    2484:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2488:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    248c:	89 2b       	or	r24, r25
    248e:	89 f5       	brne	.+98     	; 0x24f2 <xTaskGenericCreate+0x15a>
    2490:	c0 93 d0 31 	sts	0x31D0, r28	; 0x8031d0 <pxCurrentTCB>
    2494:	d0 93 d1 31 	sts	0x31D1, r29	; 0x8031d1 <pxCurrentTCB+0x1>
    2498:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    249c:	81 30       	cpi	r24, 0x01	; 1
    249e:	c1 f5       	brne	.+112    	; 0x2510 <xTaskGenericCreate+0x178>
    24a0:	84 ea       	ldi	r24, 0xA4	; 164
    24a2:	91 e3       	ldi	r25, 0x31	; 49
    24a4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24a8:	8f ea       	ldi	r24, 0xAF	; 175
    24aa:	91 e3       	ldi	r25, 0x31	; 49
    24ac:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24b0:	8a eb       	ldi	r24, 0xBA	; 186
    24b2:	91 e3       	ldi	r25, 0x31	; 49
    24b4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24b8:	85 ec       	ldi	r24, 0xC5	; 197
    24ba:	91 e3       	ldi	r25, 0x31	; 49
    24bc:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24c0:	89 e9       	ldi	r24, 0x99	; 153
    24c2:	91 e3       	ldi	r25, 0x31	; 49
    24c4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24c8:	8e e8       	ldi	r24, 0x8E	; 142
    24ca:	91 e3       	ldi	r25, 0x31	; 49
    24cc:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24d0:	8f e7       	ldi	r24, 0x7F	; 127
    24d2:	91 e3       	ldi	r25, 0x31	; 49
    24d4:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <vListInitialise>
    24d8:	89 e9       	ldi	r24, 0x99	; 153
    24da:	91 e3       	ldi	r25, 0x31	; 49
    24dc:	80 93 8c 31 	sts	0x318C, r24	; 0x80318c <pxDelayedTaskList>
    24e0:	90 93 8d 31 	sts	0x318D, r25	; 0x80318d <pxDelayedTaskList+0x1>
    24e4:	8e e8       	ldi	r24, 0x8E	; 142
    24e6:	91 e3       	ldi	r25, 0x31	; 49
    24e8:	80 93 8a 31 	sts	0x318A, r24	; 0x80318a <pxOverflowDelayedTaskList>
    24ec:	90 93 8b 31 	sts	0x318B, r25	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    24f0:	0f c0       	rjmp	.+30     	; 0x2510 <xTaskGenericCreate+0x178>
    24f2:	80 91 75 31 	lds	r24, 0x3175	; 0x803175 <xSchedulerRunning>
    24f6:	81 11       	cpse	r24, r1
    24f8:	0b c0       	rjmp	.+22     	; 0x2510 <xTaskGenericCreate+0x178>
    24fa:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    24fe:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2502:	82 8d       	ldd	r24, Z+26	; 0x1a
    2504:	08 17       	cp	r16, r24
    2506:	20 f0       	brcs	.+8      	; 0x2510 <xTaskGenericCreate+0x178>
    2508:	c0 93 d0 31 	sts	0x31D0, r28	; 0x8031d0 <pxCurrentTCB>
    250c:	d0 93 d1 31 	sts	0x31D1, r29	; 0x8031d1 <pxCurrentTCB+0x1>
    2510:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2512:	90 91 77 31 	lds	r25, 0x3177	; 0x803177 <uxTopUsedPriority>
    2516:	98 17       	cp	r25, r24
    2518:	10 f4       	brcc	.+4      	; 0x251e <xTaskGenericCreate+0x186>
    251a:	80 93 77 31 	sts	0x3177, r24	; 0x803177 <uxTopUsedPriority>
    251e:	90 91 70 31 	lds	r25, 0x3170	; 0x803170 <uxTaskNumber>
    2522:	9f 5f       	subi	r25, 0xFF	; 255
    2524:	90 93 70 31 	sts	0x3170, r25	; 0x803170 <uxTaskNumber>
    2528:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    252c:	98 17       	cp	r25, r24
    252e:	10 f4       	brcc	.+4      	; 0x2534 <xTaskGenericCreate+0x19c>
    2530:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2534:	fb e0       	ldi	r31, 0x0B	; 11
    2536:	8f 9f       	mul	r24, r31
    2538:	c0 01       	movw	r24, r0
    253a:	11 24       	eor	r1, r1
    253c:	b6 01       	movw	r22, r12
    253e:	8c 55       	subi	r24, 0x5C	; 92
    2540:	9e 4c       	sbci	r25, 0xCE	; 206
    2542:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
    2546:	0f 90       	pop	r0
    2548:	0f be       	out	0x3f, r0	; 63
    254a:	80 91 75 31 	lds	r24, 0x3175	; 0x803175 <xSchedulerRunning>
    254e:	88 23       	and	r24, r24
    2550:	59 f0       	breq	.+22     	; 0x2568 <xTaskGenericCreate+0x1d0>
    2552:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2556:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    255a:	82 8d       	ldd	r24, Z+26	; 0x1a
    255c:	80 17       	cp	r24, r16
    255e:	30 f4       	brcc	.+12     	; 0x256c <xTaskGenericCreate+0x1d4>
    2560:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    2564:	81 e0       	ldi	r24, 0x01	; 1
    2566:	09 c0       	rjmp	.+18     	; 0x257a <xTaskGenericCreate+0x1e2>
    2568:	81 e0       	ldi	r24, 0x01	; 1
    256a:	07 c0       	rjmp	.+14     	; 0x257a <xTaskGenericCreate+0x1e2>
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	05 c0       	rjmp	.+10     	; 0x257a <xTaskGenericCreate+0x1e2>
    2570:	cb 8e       	std	Y+27, r12	; 0x1b
    2572:	dc 8e       	std	Y+28, r13	; 0x1c
    2574:	c6 01       	movw	r24, r12
    2576:	3b cf       	rjmp	.-394    	; 0x23ee <xTaskGenericCreate+0x56>
    2578:	8f ef       	ldi	r24, 0xFF	; 255
    257a:	df 91       	pop	r29
    257c:	cf 91       	pop	r28
    257e:	1f 91       	pop	r17
    2580:	0f 91       	pop	r16
    2582:	ff 90       	pop	r15
    2584:	ef 90       	pop	r14
    2586:	df 90       	pop	r13
    2588:	cf 90       	pop	r12
    258a:	bf 90       	pop	r11
    258c:	af 90       	pop	r10
    258e:	9f 90       	pop	r9
    2590:	8f 90       	pop	r8
    2592:	7f 90       	pop	r7
    2594:	6f 90       	pop	r6
    2596:	5f 90       	pop	r5
    2598:	4f 90       	pop	r4
    259a:	08 95       	ret

0000259c <uxTaskPriorityGet>:
    259c:	0f b6       	in	r0, 0x3f	; 63
    259e:	f8 94       	cli
    25a0:	0f 92       	push	r0
    25a2:	00 97       	sbiw	r24, 0x00	; 0
    25a4:	21 f4       	brne	.+8      	; 0x25ae <uxTaskPriorityGet+0x12>
    25a6:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    25aa:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    25ae:	0f 90       	pop	r0
    25b0:	0f be       	out	0x3f, r0	; 63
    25b2:	fc 01       	movw	r30, r24
    25b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    25b6:	08 95       	ret

000025b8 <vTaskStartScheduler>:
    25b8:	af 92       	push	r10
    25ba:	bf 92       	push	r11
    25bc:	cf 92       	push	r12
    25be:	df 92       	push	r13
    25c0:	ef 92       	push	r14
    25c2:	ff 92       	push	r15
    25c4:	0f 93       	push	r16
    25c6:	a1 2c       	mov	r10, r1
    25c8:	b1 2c       	mov	r11, r1
    25ca:	c1 2c       	mov	r12, r1
    25cc:	d1 2c       	mov	r13, r1
    25ce:	0f 2e       	mov	r0, r31
    25d0:	fd e7       	ldi	r31, 0x7D	; 125
    25d2:	ef 2e       	mov	r14, r31
    25d4:	f1 e3       	ldi	r31, 0x31	; 49
    25d6:	ff 2e       	mov	r15, r31
    25d8:	f0 2d       	mov	r31, r0
    25da:	00 e0       	ldi	r16, 0x00	; 0
    25dc:	20 e0       	ldi	r18, 0x00	; 0
    25de:	30 e0       	ldi	r19, 0x00	; 0
    25e0:	44 e6       	ldi	r20, 0x64	; 100
    25e2:	50 e0       	ldi	r21, 0x00	; 0
    25e4:	66 eb       	ldi	r22, 0xB6	; 182
    25e6:	70 e2       	ldi	r23, 0x20	; 32
    25e8:	86 e7       	ldi	r24, 0x76	; 118
    25ea:	91 e1       	ldi	r25, 0x11	; 17
    25ec:	0e 94 cc 11 	call	0x2398	; 0x2398 <xTaskGenericCreate>
    25f0:	81 30       	cpi	r24, 0x01	; 1
    25f2:	69 f4       	brne	.+26     	; 0x260e <vTaskStartScheduler+0x56>
    25f4:	f8 94       	cli
    25f6:	80 93 75 31 	sts	0x3175, r24	; 0x803175 <xSchedulerRunning>
    25fa:	10 92 78 31 	sts	0x3178, r1	; 0x803178 <xTickCount>
    25fe:	10 92 79 31 	sts	0x3179, r1	; 0x803179 <xTickCount+0x1>
    2602:	10 92 7a 31 	sts	0x317A, r1	; 0x80317a <xTickCount+0x2>
    2606:	10 92 7b 31 	sts	0x317B, r1	; 0x80317b <xTickCount+0x3>
    260a:	0e 94 94 0d 	call	0x1b28	; 0x1b28 <xPortStartScheduler>
    260e:	0f 91       	pop	r16
    2610:	ff 90       	pop	r15
    2612:	ef 90       	pop	r14
    2614:	df 90       	pop	r13
    2616:	cf 90       	pop	r12
    2618:	bf 90       	pop	r11
    261a:	af 90       	pop	r10
    261c:	08 95       	ret

0000261e <vTaskSuspendAll>:
    261e:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2622:	8f 5f       	subi	r24, 0xFF	; 255
    2624:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <uxSchedulerSuspended>
    2628:	08 95       	ret

0000262a <xTaskGetTickCount>:
    262a:	0f b6       	in	r0, 0x3f	; 63
    262c:	f8 94       	cli
    262e:	0f 92       	push	r0
    2630:	60 91 78 31 	lds	r22, 0x3178	; 0x803178 <xTickCount>
    2634:	70 91 79 31 	lds	r23, 0x3179	; 0x803179 <xTickCount+0x1>
    2638:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <xTickCount+0x2>
    263c:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <xTickCount+0x3>
    2640:	0f 90       	pop	r0
    2642:	0f be       	out	0x3f, r0	; 63
    2644:	08 95       	ret

00002646 <pcTaskGetTaskName>:
    2646:	00 97       	sbiw	r24, 0x00	; 0
    2648:	21 f4       	brne	.+8      	; 0x2652 <pcTaskGetTaskName+0xc>
    264a:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    264e:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2652:	4d 96       	adiw	r24, 0x1d	; 29
    2654:	08 95       	ret

00002656 <xTaskGetIdleTaskHandle>:
    2656:	80 91 7d 31 	lds	r24, 0x317D	; 0x80317d <xIdleTaskHandle>
    265a:	90 91 7e 31 	lds	r25, 0x317E	; 0x80317e <xIdleTaskHandle+0x1>
    265e:	08 95       	ret

00002660 <vTaskIncrementTick>:
    2660:	ff 92       	push	r15
    2662:	0f 93       	push	r16
    2664:	1f 93       	push	r17
    2666:	cf 93       	push	r28
    2668:	df 93       	push	r29
    266a:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    266e:	81 11       	cpse	r24, r1
    2670:	ed c0       	rjmp	.+474    	; 0x284c <vTaskIncrementTick+0x1ec>
    2672:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2676:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    267a:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    267e:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2682:	01 96       	adiw	r24, 0x01	; 1
    2684:	a1 1d       	adc	r26, r1
    2686:	b1 1d       	adc	r27, r1
    2688:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <xTickCount>
    268c:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <xTickCount+0x1>
    2690:	a0 93 7a 31 	sts	0x317A, r26	; 0x80317a <xTickCount+0x2>
    2694:	b0 93 7b 31 	sts	0x317B, r27	; 0x80317b <xTickCount+0x3>
    2698:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    269c:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    26a0:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    26a4:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    26a8:	89 2b       	or	r24, r25
    26aa:	8a 2b       	or	r24, r26
    26ac:	8b 2b       	or	r24, r27
    26ae:	f1 f5       	brne	.+124    	; 0x272c <vTaskIncrementTick+0xcc>
    26b0:	80 91 8c 31 	lds	r24, 0x318C	; 0x80318c <pxDelayedTaskList>
    26b4:	90 91 8d 31 	lds	r25, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    26b8:	20 91 8a 31 	lds	r18, 0x318A	; 0x80318a <pxOverflowDelayedTaskList>
    26bc:	30 91 8b 31 	lds	r19, 0x318B	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    26c0:	20 93 8c 31 	sts	0x318C, r18	; 0x80318c <pxDelayedTaskList>
    26c4:	30 93 8d 31 	sts	0x318D, r19	; 0x80318d <pxDelayedTaskList+0x1>
    26c8:	80 93 8a 31 	sts	0x318A, r24	; 0x80318a <pxOverflowDelayedTaskList>
    26cc:	90 93 8b 31 	sts	0x318B, r25	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    26d0:	80 91 71 31 	lds	r24, 0x3171	; 0x803171 <xNumOfOverflows>
    26d4:	8f 5f       	subi	r24, 0xFF	; 255
    26d6:	80 93 71 31 	sts	0x3171, r24	; 0x803171 <xNumOfOverflows>
    26da:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    26de:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    26e2:	80 81       	ld	r24, Z
    26e4:	81 11       	cpse	r24, r1
    26e6:	0c c0       	rjmp	.+24     	; 0x2700 <vTaskIncrementTick+0xa0>
    26e8:	8f ef       	ldi	r24, 0xFF	; 255
    26ea:	9f ef       	ldi	r25, 0xFF	; 255
    26ec:	dc 01       	movw	r26, r24
    26ee:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    26f2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    26f6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    26fa:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    26fe:	16 c0       	rjmp	.+44     	; 0x272c <vTaskIncrementTick+0xcc>
    2700:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    2704:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2708:	07 80       	ldd	r0, Z+7	; 0x07
    270a:	f0 85       	ldd	r31, Z+8	; 0x08
    270c:	e0 2d       	mov	r30, r0
    270e:	00 84       	ldd	r0, Z+8	; 0x08
    2710:	f1 85       	ldd	r31, Z+9	; 0x09
    2712:	e0 2d       	mov	r30, r0
    2714:	82 81       	ldd	r24, Z+2	; 0x02
    2716:	93 81       	ldd	r25, Z+3	; 0x03
    2718:	a4 81       	ldd	r26, Z+4	; 0x04
    271a:	b5 81       	ldd	r27, Z+5	; 0x05
    271c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2720:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2724:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2728:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    272c:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2730:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2734:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    2738:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    273c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2740:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2744:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2748:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    274c:	48 17       	cp	r20, r24
    274e:	59 07       	cpc	r21, r25
    2750:	6a 07       	cpc	r22, r26
    2752:	7b 07       	cpc	r23, r27
    2754:	08 f4       	brcc	.+2      	; 0x2758 <vTaskIncrementTick+0xf8>
    2756:	7f c0       	rjmp	.+254    	; 0x2856 <vTaskIncrementTick+0x1f6>
    2758:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    275c:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2760:	80 81       	ld	r24, Z
    2762:	88 23       	and	r24, r24
    2764:	f9 f0       	breq	.+62     	; 0x27a4 <vTaskIncrementTick+0x144>
    2766:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    276a:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    276e:	07 80       	ldd	r0, Z+7	; 0x07
    2770:	f0 85       	ldd	r31, Z+8	; 0x08
    2772:	e0 2d       	mov	r30, r0
    2774:	c0 85       	ldd	r28, Z+8	; 0x08
    2776:	d1 85       	ldd	r29, Z+9	; 0x09
    2778:	8a 81       	ldd	r24, Y+2	; 0x02
    277a:	9b 81       	ldd	r25, Y+3	; 0x03
    277c:	ac 81       	ldd	r26, Y+4	; 0x04
    277e:	bd 81       	ldd	r27, Y+5	; 0x05
    2780:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2784:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2788:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    278c:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    2790:	48 17       	cp	r20, r24
    2792:	59 07       	cpc	r21, r25
    2794:	6a 07       	cpc	r22, r26
    2796:	7b 07       	cpc	r23, r27
    2798:	58 f1       	brcs	.+86     	; 0x27f0 <vTaskIncrementTick+0x190>
    279a:	0f 2e       	mov	r0, r31
    279c:	fb e0       	ldi	r31, 0x0B	; 11
    279e:	ff 2e       	mov	r15, r31
    27a0:	f0 2d       	mov	r31, r0
    27a2:	2f c0       	rjmp	.+94     	; 0x2802 <vTaskIncrementTick+0x1a2>
    27a4:	8f ef       	ldi	r24, 0xFF	; 255
    27a6:	9f ef       	ldi	r25, 0xFF	; 255
    27a8:	dc 01       	movw	r26, r24
    27aa:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27ae:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27b2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27b6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27ba:	4d c0       	rjmp	.+154    	; 0x2856 <vTaskIncrementTick+0x1f6>
    27bc:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    27c0:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    27c4:	07 80       	ldd	r0, Z+7	; 0x07
    27c6:	f0 85       	ldd	r31, Z+8	; 0x08
    27c8:	e0 2d       	mov	r30, r0
    27ca:	c0 85       	ldd	r28, Z+8	; 0x08
    27cc:	d1 85       	ldd	r29, Z+9	; 0x09
    27ce:	8a 81       	ldd	r24, Y+2	; 0x02
    27d0:	9b 81       	ldd	r25, Y+3	; 0x03
    27d2:	ac 81       	ldd	r26, Y+4	; 0x04
    27d4:	bd 81       	ldd	r27, Y+5	; 0x05
    27d6:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    27da:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    27de:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    27e2:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    27e6:	48 17       	cp	r20, r24
    27e8:	59 07       	cpc	r21, r25
    27ea:	6a 07       	cpc	r22, r26
    27ec:	7b 07       	cpc	r23, r27
    27ee:	48 f4       	brcc	.+18     	; 0x2802 <vTaskIncrementTick+0x1a2>
    27f0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27f4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27f8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27fc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2800:	2a c0       	rjmp	.+84     	; 0x2856 <vTaskIncrementTick+0x1f6>
    2802:	8e 01       	movw	r16, r28
    2804:	0e 5f       	subi	r16, 0xFE	; 254
    2806:	1f 4f       	sbci	r17, 0xFF	; 255
    2808:	c8 01       	movw	r24, r16
    280a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
    280e:	88 8d       	ldd	r24, Y+24	; 0x18
    2810:	99 8d       	ldd	r25, Y+25	; 0x19
    2812:	89 2b       	or	r24, r25
    2814:	21 f0       	breq	.+8      	; 0x281e <vTaskIncrementTick+0x1be>
    2816:	ce 01       	movw	r24, r28
    2818:	0e 96       	adiw	r24, 0x0e	; 14
    281a:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
    281e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2820:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2824:	98 17       	cp	r25, r24
    2826:	10 f4       	brcc	.+4      	; 0x282c <vTaskIncrementTick+0x1cc>
    2828:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    282c:	f8 9e       	mul	r15, r24
    282e:	c0 01       	movw	r24, r0
    2830:	11 24       	eor	r1, r1
    2832:	b8 01       	movw	r22, r16
    2834:	8c 55       	subi	r24, 0x5C	; 92
    2836:	9e 4c       	sbci	r25, 0xCE	; 206
    2838:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
    283c:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    2840:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2844:	80 81       	ld	r24, Z
    2846:	81 11       	cpse	r24, r1
    2848:	b9 cf       	rjmp	.-142    	; 0x27bc <vTaskIncrementTick+0x15c>
    284a:	ac cf       	rjmp	.-168    	; 0x27a4 <vTaskIncrementTick+0x144>
    284c:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2850:	8f 5f       	subi	r24, 0xFF	; 255
    2852:	80 93 73 31 	sts	0x3173, r24	; 0x803173 <uxMissedTicks>
    2856:	df 91       	pop	r29
    2858:	cf 91       	pop	r28
    285a:	1f 91       	pop	r17
    285c:	0f 91       	pop	r16
    285e:	ff 90       	pop	r15
    2860:	08 95       	ret

00002862 <xTaskResumeAll>:
    2862:	cf 92       	push	r12
    2864:	df 92       	push	r13
    2866:	ef 92       	push	r14
    2868:	ff 92       	push	r15
    286a:	0f 93       	push	r16
    286c:	1f 93       	push	r17
    286e:	cf 93       	push	r28
    2870:	df 93       	push	r29
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	0f 92       	push	r0
    2878:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    287c:	81 50       	subi	r24, 0x01	; 1
    287e:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <uxSchedulerSuspended>
    2882:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2886:	81 11       	cpse	r24, r1
    2888:	60 c0       	rjmp	.+192    	; 0x294a <xTaskResumeAll+0xe8>
    288a:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    288e:	81 11       	cpse	r24, r1
    2890:	2c c0       	rjmp	.+88     	; 0x28ea <xTaskResumeAll+0x88>
    2892:	5e c0       	rjmp	.+188    	; 0x2950 <xTaskResumeAll+0xee>
    2894:	d7 01       	movw	r26, r14
    2896:	17 96       	adiw	r26, 0x07	; 7
    2898:	ed 91       	ld	r30, X+
    289a:	fc 91       	ld	r31, X
    289c:	18 97       	sbiw	r26, 0x08	; 8
    289e:	c0 85       	ldd	r28, Z+8	; 0x08
    28a0:	d1 85       	ldd	r29, Z+9	; 0x09
    28a2:	ce 01       	movw	r24, r28
    28a4:	0e 96       	adiw	r24, 0x0e	; 14
    28a6:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
    28aa:	8e 01       	movw	r16, r28
    28ac:	0e 5f       	subi	r16, 0xFE	; 254
    28ae:	1f 4f       	sbci	r17, 0xFF	; 255
    28b0:	c8 01       	movw	r24, r16
    28b2:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
    28b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28b8:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    28bc:	98 17       	cp	r25, r24
    28be:	10 f4       	brcc	.+4      	; 0x28c4 <xTaskResumeAll+0x62>
    28c0:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    28c4:	d8 9e       	mul	r13, r24
    28c6:	c0 01       	movw	r24, r0
    28c8:	11 24       	eor	r1, r1
    28ca:	b8 01       	movw	r22, r16
    28cc:	8c 55       	subi	r24, 0x5C	; 92
    28ce:	9e 4c       	sbci	r25, 0xCE	; 206
    28d0:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
    28d4:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    28d8:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    28dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28de:	82 8d       	ldd	r24, Z+26	; 0x1a
    28e0:	98 17       	cp	r25, r24
    28e2:	70 f0       	brcs	.+28     	; 0x2900 <xTaskResumeAll+0x9e>
    28e4:	cc 24       	eor	r12, r12
    28e6:	c3 94       	inc	r12
    28e8:	0b c0       	rjmp	.+22     	; 0x2900 <xTaskResumeAll+0x9e>
    28ea:	c1 2c       	mov	r12, r1
    28ec:	0f 2e       	mov	r0, r31
    28ee:	ff e7       	ldi	r31, 0x7F	; 127
    28f0:	ef 2e       	mov	r14, r31
    28f2:	f1 e3       	ldi	r31, 0x31	; 49
    28f4:	ff 2e       	mov	r15, r31
    28f6:	f0 2d       	mov	r31, r0
    28f8:	0f 2e       	mov	r0, r31
    28fa:	fb e0       	ldi	r31, 0x0B	; 11
    28fc:	df 2e       	mov	r13, r31
    28fe:	f0 2d       	mov	r31, r0
    2900:	f7 01       	movw	r30, r14
    2902:	80 81       	ld	r24, Z
    2904:	81 11       	cpse	r24, r1
    2906:	c6 cf       	rjmp	.-116    	; 0x2894 <xTaskResumeAll+0x32>
    2908:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    290c:	88 23       	and	r24, r24
    290e:	81 f0       	breq	.+32     	; 0x2930 <xTaskResumeAll+0xce>
    2910:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2914:	88 23       	and	r24, r24
    2916:	99 f0       	breq	.+38     	; 0x293e <xTaskResumeAll+0xdc>
    2918:	0e 94 30 13 	call	0x2660	; 0x2660 <vTaskIncrementTick>
    291c:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2920:	81 50       	subi	r24, 0x01	; 1
    2922:	80 93 73 31 	sts	0x3173, r24	; 0x803173 <uxMissedTicks>
    2926:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    292a:	81 11       	cpse	r24, r1
    292c:	f5 cf       	rjmp	.-22     	; 0x2918 <xTaskResumeAll+0xb6>
    292e:	07 c0       	rjmp	.+14     	; 0x293e <xTaskResumeAll+0xdc>
    2930:	f1 e0       	ldi	r31, 0x01	; 1
    2932:	cf 16       	cp	r12, r31
    2934:	21 f0       	breq	.+8      	; 0x293e <xTaskResumeAll+0xdc>
    2936:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <xMissedYield>
    293a:	81 30       	cpi	r24, 0x01	; 1
    293c:	41 f4       	brne	.+16     	; 0x294e <xTaskResumeAll+0xec>
    293e:	10 92 72 31 	sts	0x3172, r1	; 0x803172 <xMissedYield>
    2942:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	03 c0       	rjmp	.+6      	; 0x2950 <xTaskResumeAll+0xee>
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	01 c0       	rjmp	.+2      	; 0x2950 <xTaskResumeAll+0xee>
    294e:	80 e0       	ldi	r24, 0x00	; 0
    2950:	0f 90       	pop	r0
    2952:	0f be       	out	0x3f, r0	; 63
    2954:	df 91       	pop	r29
    2956:	cf 91       	pop	r28
    2958:	1f 91       	pop	r17
    295a:	0f 91       	pop	r16
    295c:	ff 90       	pop	r15
    295e:	ef 90       	pop	r14
    2960:	df 90       	pop	r13
    2962:	cf 90       	pop	r12
    2964:	08 95       	ret

00002966 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2966:	cf 92       	push	r12
    2968:	df 92       	push	r13
    296a:	ef 92       	push	r14
    296c:	ff 92       	push	r15
    296e:	6b 01       	movw	r12, r22
    2970:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2972:	67 2b       	or	r22, r23
    2974:	68 2b       	or	r22, r24
    2976:	69 2b       	or	r22, r25
    2978:	e9 f0       	breq	.+58     	; 0x29b4 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    297a:	0e 94 0f 13 	call	0x261e	; 0x261e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    297e:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2982:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2986:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    298a:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    298e:	c8 0e       	add	r12, r24
    2990:	d9 1e       	adc	r13, r25
    2992:	ea 1e       	adc	r14, r26
    2994:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2996:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    299a:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    299e:	02 96       	adiw	r24, 0x02	; 2
    29a0:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    29a4:	c7 01       	movw	r24, r14
    29a6:	b6 01       	movw	r22, r12
    29a8:	0e 94 7e 11 	call	0x22fc	; 0x22fc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    29ac:	0e 94 31 14 	call	0x2862	; 0x2862 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29b0:	81 11       	cpse	r24, r1
    29b2:	02 c0       	rjmp	.+4      	; 0x29b8 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    29b4:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <vPortYield>
		}
	}
    29b8:	ff 90       	pop	r15
    29ba:	ef 90       	pop	r14
    29bc:	df 90       	pop	r13
    29be:	cf 90       	pop	r12
    29c0:	08 95       	ret

000029c2 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    29c2:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    29c6:	81 11       	cpse	r24, r1
    29c8:	0c c0       	rjmp	.+24     	; 0x29e2 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29ca:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <uxTopReadyPriority>
    29ce:	4b e0       	ldi	r20, 0x0B	; 11
    29d0:	e4 9f       	mul	r30, r20
    29d2:	f0 01       	movw	r30, r0
    29d4:	11 24       	eor	r1, r1
    29d6:	ec 55       	subi	r30, 0x5C	; 92
    29d8:	fe 4c       	sbci	r31, 0xCE	; 206
    29da:	80 81       	ld	r24, Z
    29dc:	88 23       	and	r24, r24
    29de:	29 f0       	breq	.+10     	; 0x29ea <vTaskSwitchContext+0x28>
    29e0:	14 c0       	rjmp	.+40     	; 0x2a0a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    29e2:	81 e0       	ldi	r24, 0x01	; 1
    29e4:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <xMissedYield>
    29e8:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29ea:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    29ec:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <uxTopReadyPriority>
    29f0:	81 50       	subi	r24, 0x01	; 1
    29f2:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29f6:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <uxTopReadyPriority>
    29fa:	9e 9f       	mul	r25, r30
    29fc:	f0 01       	movw	r30, r0
    29fe:	11 24       	eor	r1, r1
    2a00:	ec 55       	subi	r30, 0x5C	; 92
    2a02:	fe 4c       	sbci	r31, 0xCE	; 206
    2a04:	80 81       	ld	r24, Z
    2a06:	88 23       	and	r24, r24
    2a08:	89 f3       	breq	.-30     	; 0x29ec <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2a0a:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <uxTopReadyPriority>
    2a0e:	28 2f       	mov	r18, r24
    2a10:	30 e0       	ldi	r19, 0x00	; 0
    2a12:	4b e0       	ldi	r20, 0x0B	; 11
    2a14:	84 9f       	mul	r24, r20
    2a16:	c0 01       	movw	r24, r0
    2a18:	11 24       	eor	r1, r1
    2a1a:	dc 01       	movw	r26, r24
    2a1c:	ac 55       	subi	r26, 0x5C	; 92
    2a1e:	be 4c       	sbci	r27, 0xCE	; 206
    2a20:	11 96       	adiw	r26, 0x01	; 1
    2a22:	ed 91       	ld	r30, X+
    2a24:	fc 91       	ld	r31, X
    2a26:	12 97       	sbiw	r26, 0x02	; 2
    2a28:	04 80       	ldd	r0, Z+4	; 0x04
    2a2a:	f5 81       	ldd	r31, Z+5	; 0x05
    2a2c:	e0 2d       	mov	r30, r0
    2a2e:	11 96       	adiw	r26, 0x01	; 1
    2a30:	ed 93       	st	X+, r30
    2a32:	fc 93       	st	X, r31
    2a34:	12 97       	sbiw	r26, 0x02	; 2
    2a36:	89 55       	subi	r24, 0x59	; 89
    2a38:	9e 4c       	sbci	r25, 0xCE	; 206
    2a3a:	e8 17       	cp	r30, r24
    2a3c:	f9 07       	cpc	r31, r25
    2a3e:	61 f4       	brne	.+24     	; 0x2a58 <vTaskSwitchContext+0x96>
    2a40:	84 81       	ldd	r24, Z+4	; 0x04
    2a42:	95 81       	ldd	r25, Z+5	; 0x05
    2a44:	4b e0       	ldi	r20, 0x0B	; 11
    2a46:	42 9f       	mul	r20, r18
    2a48:	f0 01       	movw	r30, r0
    2a4a:	43 9f       	mul	r20, r19
    2a4c:	f0 0d       	add	r31, r0
    2a4e:	11 24       	eor	r1, r1
    2a50:	ec 55       	subi	r30, 0x5C	; 92
    2a52:	fe 4c       	sbci	r31, 0xCE	; 206
    2a54:	81 83       	std	Z+1, r24	; 0x01
    2a56:	92 83       	std	Z+2, r25	; 0x02
    2a58:	8b e0       	ldi	r24, 0x0B	; 11
    2a5a:	82 9f       	mul	r24, r18
    2a5c:	f0 01       	movw	r30, r0
    2a5e:	83 9f       	mul	r24, r19
    2a60:	f0 0d       	add	r31, r0
    2a62:	11 24       	eor	r1, r1
    2a64:	ec 55       	subi	r30, 0x5C	; 92
    2a66:	fe 4c       	sbci	r31, 0xCE	; 206
    2a68:	01 80       	ldd	r0, Z+1	; 0x01
    2a6a:	f2 81       	ldd	r31, Z+2	; 0x02
    2a6c:	e0 2d       	mov	r30, r0
    2a6e:	80 85       	ldd	r24, Z+8	; 0x08
    2a70:	91 85       	ldd	r25, Z+9	; 0x09
    2a72:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <pxCurrentTCB>
    2a76:	90 93 d1 31 	sts	0x31D1, r25	; 0x8031d1 <pxCurrentTCB+0x1>
    2a7a:	08 95       	ret

00002a7c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2a7c:	cf 92       	push	r12
    2a7e:	df 92       	push	r13
    2a80:	ef 92       	push	r14
    2a82:	ff 92       	push	r15
    2a84:	6a 01       	movw	r12, r20
    2a86:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2a88:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2a8c:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2a90:	62 5f       	subi	r22, 0xF2	; 242
    2a92:	7f 4f       	sbci	r23, 0xFF	; 255
    2a94:	0e 94 ad 0c 	call	0x195a	; 0x195a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a98:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2a9c:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2aa0:	02 96       	adiw	r24, 0x02	; 2
    2aa2:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2aa6:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2aaa:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2aae:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2ab2:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ab6:	bc 01       	movw	r22, r24
    2ab8:	cd 01       	movw	r24, r26
    2aba:	6c 0d       	add	r22, r12
    2abc:	7d 1d       	adc	r23, r13
    2abe:	8e 1d       	adc	r24, r14
    2ac0:	9f 1d       	adc	r25, r15
    2ac2:	0e 94 7e 11 	call	0x22fc	; 0x22fc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2ac6:	ff 90       	pop	r15
    2ac8:	ef 90       	pop	r14
    2aca:	df 90       	pop	r13
    2acc:	cf 90       	pop	r12
    2ace:	08 95       	ret

00002ad0 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2ad0:	0f 93       	push	r16
    2ad2:	1f 93       	push	r17
    2ad4:	cf 93       	push	r28
    2ad6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2ad8:	dc 01       	movw	r26, r24
    2ada:	17 96       	adiw	r26, 0x07	; 7
    2adc:	ed 91       	ld	r30, X+
    2ade:	fc 91       	ld	r31, X
    2ae0:	18 97       	sbiw	r26, 0x08	; 8
    2ae2:	c0 85       	ldd	r28, Z+8	; 0x08
    2ae4:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2ae6:	8e 01       	movw	r16, r28
    2ae8:	02 5f       	subi	r16, 0xF2	; 242
    2aea:	1f 4f       	sbci	r17, 0xFF	; 255
    2aec:	c8 01       	movw	r24, r16
    2aee:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2af2:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2af6:	81 11       	cpse	r24, r1
    2af8:	16 c0       	rjmp	.+44     	; 0x2b26 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2afa:	0c 50       	subi	r16, 0x0C	; 12
    2afc:	11 09       	sbc	r17, r1
    2afe:	c8 01       	movw	r24, r16
    2b00:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2b04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b06:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2b0a:	98 17       	cp	r25, r24
    2b0c:	10 f4       	brcc	.+4      	; 0x2b12 <xTaskRemoveFromEventList+0x42>
    2b0e:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2b12:	bb e0       	ldi	r27, 0x0B	; 11
    2b14:	8b 9f       	mul	r24, r27
    2b16:	c0 01       	movw	r24, r0
    2b18:	11 24       	eor	r1, r1
    2b1a:	b8 01       	movw	r22, r16
    2b1c:	8c 55       	subi	r24, 0x5C	; 92
    2b1e:	9e 4c       	sbci	r25, 0xCE	; 206
    2b20:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
    2b24:	05 c0       	rjmp	.+10     	; 0x2b30 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b26:	b8 01       	movw	r22, r16
    2b28:	8f e7       	ldi	r24, 0x7F	; 127
    2b2a:	91 e3       	ldi	r25, 0x31	; 49
    2b2c:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b30:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2b34:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2b38:	81 e0       	ldi	r24, 0x01	; 1
    2b3a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b3c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b3e:	29 17       	cp	r18, r25
    2b40:	08 f4       	brcc	.+2      	; 0x2b44 <xTaskRemoveFromEventList+0x74>
    2b42:	80 e0       	ldi	r24, 0x00	; 0
}
    2b44:	df 91       	pop	r29
    2b46:	cf 91       	pop	r28
    2b48:	1f 91       	pop	r17
    2b4a:	0f 91       	pop	r16
    2b4c:	08 95       	ret

00002b4e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b4e:	20 91 71 31 	lds	r18, 0x3171	; 0x803171 <xNumOfOverflows>
    2b52:	fc 01       	movw	r30, r24
    2b54:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2b56:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2b5a:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2b5e:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    2b62:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    2b66:	41 83       	std	Z+1, r20	; 0x01
    2b68:	52 83       	std	Z+2, r21	; 0x02
    2b6a:	63 83       	std	Z+3, r22	; 0x03
    2b6c:	74 83       	std	Z+4, r23	; 0x04
    2b6e:	08 95       	ret

00002b70 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2b70:	8f 92       	push	r8
    2b72:	9f 92       	push	r9
    2b74:	af 92       	push	r10
    2b76:	bf 92       	push	r11
    2b78:	cf 92       	push	r12
    2b7a:	df 92       	push	r13
    2b7c:	ef 92       	push	r14
    2b7e:	ff 92       	push	r15
    2b80:	0f 93       	push	r16
    2b82:	1f 93       	push	r17
    2b84:	cf 93       	push	r28
    2b86:	df 93       	push	r29
    2b88:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2b90:	80 91 71 31 	lds	r24, 0x3171	; 0x803171 <xNumOfOverflows>
    2b94:	90 81       	ld	r25, Z
    2b96:	98 17       	cp	r25, r24
    2b98:	89 f0       	breq	.+34     	; 0x2bbc <xTaskCheckForTimeOut+0x4c>
    2b9a:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2b9e:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2ba2:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2ba6:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2baa:	01 81       	ldd	r16, Z+1	; 0x01
    2bac:	12 81       	ldd	r17, Z+2	; 0x02
    2bae:	23 81       	ldd	r18, Z+3	; 0x03
    2bb0:	34 81       	ldd	r19, Z+4	; 0x04
    2bb2:	80 17       	cp	r24, r16
    2bb4:	91 07       	cpc	r25, r17
    2bb6:	a2 07       	cpc	r26, r18
    2bb8:	b3 07       	cpc	r27, r19
    2bba:	a8 f5       	brcc	.+106    	; 0x2c26 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2bbc:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2bc0:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2bc4:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2bc8:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2bcc:	c1 80       	ldd	r12, Z+1	; 0x01
    2bce:	d2 80       	ldd	r13, Z+2	; 0x02
    2bd0:	e3 80       	ldd	r14, Z+3	; 0x03
    2bd2:	f4 80       	ldd	r15, Z+4	; 0x04
    2bd4:	eb 01       	movw	r28, r22
    2bd6:	08 81       	ld	r16, Y
    2bd8:	19 81       	ldd	r17, Y+1	; 0x01
    2bda:	2a 81       	ldd	r18, Y+2	; 0x02
    2bdc:	3b 81       	ldd	r19, Y+3	; 0x03
    2bde:	8c 19       	sub	r24, r12
    2be0:	9d 09       	sbc	r25, r13
    2be2:	ae 09       	sbc	r26, r14
    2be4:	bf 09       	sbc	r27, r15
    2be6:	80 17       	cp	r24, r16
    2be8:	91 07       	cpc	r25, r17
    2bea:	a2 07       	cpc	r26, r18
    2bec:	b3 07       	cpc	r27, r19
    2bee:	e8 f4       	brcc	.+58     	; 0x2c2a <xTaskCheckForTimeOut+0xba>
    2bf0:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2bf2:	80 90 78 31 	lds	r8, 0x3178	; 0x803178 <xTickCount>
    2bf6:	90 90 79 31 	lds	r9, 0x3179	; 0x803179 <xTickCount+0x1>
    2bfa:	a0 90 7a 31 	lds	r10, 0x317A	; 0x80317a <xTickCount+0x2>
    2bfe:	b0 90 7b 31 	lds	r11, 0x317B	; 0x80317b <xTickCount+0x3>
    2c02:	b5 01       	movw	r22, r10
    2c04:	a4 01       	movw	r20, r8
    2c06:	4c 19       	sub	r20, r12
    2c08:	5d 09       	sbc	r21, r13
    2c0a:	6e 09       	sbc	r22, r14
    2c0c:	7f 09       	sbc	r23, r15
    2c0e:	04 1b       	sub	r16, r20
    2c10:	15 0b       	sbc	r17, r21
    2c12:	26 0b       	sbc	r18, r22
    2c14:	37 0b       	sbc	r19, r23
    2c16:	08 83       	st	Y, r16
    2c18:	19 83       	std	Y+1, r17	; 0x01
    2c1a:	2a 83       	std	Y+2, r18	; 0x02
    2c1c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2c1e:	0e 94 a7 15 	call	0x2b4e	; 0x2b4e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c22:	80 e0       	ldi	r24, 0x00	; 0
    2c24:	03 c0       	rjmp	.+6      	; 0x2c2c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c26:	81 e0       	ldi	r24, 0x01	; 1
    2c28:	01 c0       	rjmp	.+2      	; 0x2c2c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2c2a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2c2c:	0f 90       	pop	r0
    2c2e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2c30:	df 91       	pop	r29
    2c32:	cf 91       	pop	r28
    2c34:	1f 91       	pop	r17
    2c36:	0f 91       	pop	r16
    2c38:	ff 90       	pop	r15
    2c3a:	ef 90       	pop	r14
    2c3c:	df 90       	pop	r13
    2c3e:	cf 90       	pop	r12
    2c40:	bf 90       	pop	r11
    2c42:	af 90       	pop	r10
    2c44:	9f 90       	pop	r9
    2c46:	8f 90       	pop	r8
    2c48:	08 95       	ret

00002c4a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2c4a:	81 e0       	ldi	r24, 0x01	; 1
    2c4c:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <xMissedYield>
    2c50:	08 95       	ret

00002c52 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2c52:	00 97       	sbiw	r24, 0x00	; 0
    2c54:	21 f4       	brne	.+8      	; 0x2c5e <uxTaskGetStackHighWaterMark+0xc>
    2c56:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2c5a:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2c5e:	dc 01       	movw	r26, r24
    2c60:	5b 96       	adiw	r26, 0x1b	; 27
    2c62:	ed 91       	ld	r30, X+
    2c64:	fc 91       	ld	r31, X
    2c66:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2c68:	80 81       	ld	r24, Z
    2c6a:	81 31       	cpi	r24, 0x11	; 17
    2c6c:	41 f4       	brne	.+16     	; 0x2c7e <uxTaskGetStackHighWaterMark+0x2c>
    2c6e:	31 96       	adiw	r30, 0x01	; 1
    2c70:	80 e0       	ldi	r24, 0x00	; 0
    2c72:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2c74:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2c76:	21 91       	ld	r18, Z+
    2c78:	21 31       	cpi	r18, 0x11	; 17
    2c7a:	e1 f3       	breq	.-8      	; 0x2c74 <uxTaskGetStackHighWaterMark+0x22>
    2c7c:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2c7e:	80 e0       	ldi	r24, 0x00	; 0
    2c80:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2c82:	08 95       	ret

00002c84 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2c84:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2c88:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2c8c:	08 95       	ret

00002c8e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2c8e:	0f 93       	push	r16
    2c90:	1f 93       	push	r17
    2c92:	cf 93       	push	r28
    2c94:	df 93       	push	r29
    2c96:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2c98:	22 8d       	ldd	r18, Z+26	; 0x1a
    2c9a:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2c9e:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2ca2:	5a 96       	adiw	r26, 0x1a	; 26
    2ca4:	8c 91       	ld	r24, X
    2ca6:	28 17       	cp	r18, r24
    2ca8:	08 f0       	brcs	.+2      	; 0x2cac <vTaskPriorityInherit+0x1e>
    2caa:	41 c0       	rjmp	.+130    	; 0x2d2e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2cac:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2cb0:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2cb4:	5a 96       	adiw	r26, 0x1a	; 26
    2cb6:	3c 91       	ld	r19, X
    2cb8:	84 e0       	ldi	r24, 0x04	; 4
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	a0 e0       	ldi	r26, 0x00	; 0
    2cbe:	b0 e0       	ldi	r27, 0x00	; 0
    2cc0:	83 1b       	sub	r24, r19
    2cc2:	91 09       	sbc	r25, r1
    2cc4:	a1 09       	sbc	r26, r1
    2cc6:	b1 09       	sbc	r27, r1
    2cc8:	86 87       	std	Z+14, r24	; 0x0e
    2cca:	97 87       	std	Z+15, r25	; 0x0f
    2ccc:	a0 8b       	std	Z+16, r26	; 0x10
    2cce:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2cd0:	8b e0       	ldi	r24, 0x0B	; 11
    2cd2:	28 9f       	mul	r18, r24
    2cd4:	90 01       	movw	r18, r0
    2cd6:	11 24       	eor	r1, r1
    2cd8:	2c 55       	subi	r18, 0x5C	; 92
    2cda:	3e 4c       	sbci	r19, 0xCE	; 206
    2cdc:	84 85       	ldd	r24, Z+12	; 0x0c
    2cde:	95 85       	ldd	r25, Z+13	; 0x0d
    2ce0:	82 17       	cp	r24, r18
    2ce2:	93 07       	cpc	r25, r19
    2ce4:	e9 f4       	brne	.+58     	; 0x2d20 <vTaskPriorityInherit+0x92>
    2ce6:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2ce8:	ef 01       	movw	r28, r30
    2cea:	22 96       	adiw	r28, 0x02	; 2
    2cec:	ce 01       	movw	r24, r28
    2cee:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2cf2:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2cf6:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2cfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cfc:	f8 01       	movw	r30, r16
    2cfe:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2d00:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2d04:	98 17       	cp	r25, r24
    2d06:	10 f4       	brcc	.+4      	; 0x2d0c <vTaskPriorityInherit+0x7e>
    2d08:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2d0c:	fb e0       	ldi	r31, 0x0B	; 11
    2d0e:	8f 9f       	mul	r24, r31
    2d10:	c0 01       	movw	r24, r0
    2d12:	11 24       	eor	r1, r1
    2d14:	be 01       	movw	r22, r28
    2d16:	8c 55       	subi	r24, 0x5C	; 92
    2d18:	9e 4c       	sbci	r25, 0xCE	; 206
    2d1a:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
    2d1e:	07 c0       	rjmp	.+14     	; 0x2d2e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d20:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2d24:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2d28:	5a 96       	adiw	r26, 0x1a	; 26
    2d2a:	8c 91       	ld	r24, X
    2d2c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2d2e:	df 91       	pop	r29
    2d30:	cf 91       	pop	r28
    2d32:	1f 91       	pop	r17
    2d34:	0f 91       	pop	r16
    2d36:	08 95       	ret

00002d38 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2d38:	0f 93       	push	r16
    2d3a:	1f 93       	push	r17
    2d3c:	cf 93       	push	r28
    2d3e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2d40:	00 97       	sbiw	r24, 0x00	; 0
    2d42:	49 f1       	breq	.+82     	; 0x2d96 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2d44:	fc 01       	movw	r30, r24
    2d46:	32 8d       	ldd	r19, Z+26	; 0x1a
    2d48:	27 a1       	ldd	r18, Z+39	; 0x27
    2d4a:	32 17       	cp	r19, r18
    2d4c:	21 f1       	breq	.+72     	; 0x2d96 <vTaskPriorityDisinherit+0x5e>
    2d4e:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d50:	8c 01       	movw	r16, r24
    2d52:	0e 5f       	subi	r16, 0xFE	; 254
    2d54:	1f 4f       	sbci	r17, 0xFF	; 255
    2d56:	c8 01       	movw	r24, r16
    2d58:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2d5c:	8f a1       	ldd	r24, Y+39	; 0x27
    2d5e:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2d60:	44 e0       	ldi	r20, 0x04	; 4
    2d62:	50 e0       	ldi	r21, 0x00	; 0
    2d64:	60 e0       	ldi	r22, 0x00	; 0
    2d66:	70 e0       	ldi	r23, 0x00	; 0
    2d68:	48 1b       	sub	r20, r24
    2d6a:	51 09       	sbc	r21, r1
    2d6c:	61 09       	sbc	r22, r1
    2d6e:	71 09       	sbc	r23, r1
    2d70:	4e 87       	std	Y+14, r20	; 0x0e
    2d72:	5f 87       	std	Y+15, r21	; 0x0f
    2d74:	68 8b       	std	Y+16, r22	; 0x10
    2d76:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2d78:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2d7c:	98 17       	cp	r25, r24
    2d7e:	10 f4       	brcc	.+4      	; 0x2d84 <vTaskPriorityDisinherit+0x4c>
    2d80:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2d84:	fb e0       	ldi	r31, 0x0B	; 11
    2d86:	8f 9f       	mul	r24, r31
    2d88:	c0 01       	movw	r24, r0
    2d8a:	11 24       	eor	r1, r1
    2d8c:	b8 01       	movw	r22, r16
    2d8e:	8c 55       	subi	r24, 0x5C	; 92
    2d90:	9e 4c       	sbci	r25, 0xCE	; 206
    2d92:	0e 94 86 0c 	call	0x190c	; 0x190c <vListInsertEnd>
			}
		}
	}
    2d96:	df 91       	pop	r29
    2d98:	cf 91       	pop	r28
    2d9a:	1f 91       	pop	r17
    2d9c:	0f 91       	pop	r16
    2d9e:	08 95       	ret

00002da0 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2da0:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2da2:	e8 81       	ld	r30, Y
    2da4:	f9 81       	ldd	r31, Y+1	; 0x01
    2da6:	01 90       	ld	r0, Z+
    2da8:	f0 81       	ld	r31, Z
    2daa:	e0 2d       	mov	r30, r0
    2dac:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2dae:	1a 82       	std	Y+2, r1	; 0x02
    2db0:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2db2:	6f ef       	ldi	r22, 0xFF	; 255
    2db4:	7f ef       	ldi	r23, 0xFF	; 255
    2db6:	cb 01       	movw	r24, r22
    2db8:	0e 94 b3 14 	call	0x2966	; 0x2966 <vTaskDelay>
    2dbc:	fa cf       	rjmp	.-12     	; 0x2db2 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002dbe <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2dbe:	fc 01       	movw	r30, r24
    2dc0:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2dc2:	65 87       	std	Z+13, r22	; 0x0d
    2dc4:	08 95       	ret

00002dc6 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2dc6:	4f 92       	push	r4
    2dc8:	5f 92       	push	r5
    2dca:	6f 92       	push	r6
    2dcc:	7f 92       	push	r7
    2dce:	8f 92       	push	r8
    2dd0:	9f 92       	push	r9
    2dd2:	af 92       	push	r10
    2dd4:	bf 92       	push	r11
    2dd6:	cf 92       	push	r12
    2dd8:	df 92       	push	r13
    2dda:	ef 92       	push	r14
    2ddc:	ff 92       	push	r15
    2dde:	0f 93       	push	r16
    2de0:	1f 93       	push	r17
    2de2:	cf 93       	push	r28
    2de4:	df 93       	push	r29
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
    2dea:	2a 97       	sbiw	r28, 0x0a	; 10
    2dec:	cd bf       	out	0x3d, r28	; 61
    2dee:	de bf       	out	0x3e, r29	; 62
    2df0:	4c 01       	movw	r8, r24
    2df2:	29 01       	movw	r4, r18
    2df4:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2df6:	8f eb       	ldi	r24, 0xBF	; 191
    2df8:	90 e2       	ldi	r25, 0x20	; 32
    2dfa:	f4 01       	movw	r30, r8
    2dfc:	80 83       	st	Z, r24
    2dfe:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e00:	fb 01       	movw	r30, r22
    2e02:	80 81       	ld	r24, Z
    2e04:	88 23       	and	r24, r24
    2e06:	69 f0       	breq	.+26     	; 0x2e22 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2e08:	de 01       	movw	r26, r28
    2e0a:	11 96       	adiw	r26, 0x01	; 1
    2e0c:	31 96       	adiw	r30, 0x01	; 1
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	02 c0       	rjmp	.+4      	; 0x2e16 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2e12:	99 30       	cpi	r25, 0x09	; 9
    2e14:	39 f0       	breq	.+14     	; 0x2e24 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2e16:	9f 5f       	subi	r25, 0xFF	; 255
    2e18:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e1a:	81 91       	ld	r24, Z+
    2e1c:	81 11       	cpse	r24, r1
    2e1e:	f9 cf       	rjmp	.-14     	; 0x2e12 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2e20:	01 c0       	rjmp	.+2      	; 0x2e24 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2e22:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2e24:	e1 e0       	ldi	r30, 0x01	; 1
    2e26:	f0 e0       	ldi	r31, 0x00	; 0
    2e28:	ec 0f       	add	r30, r28
    2e2a:	fd 1f       	adc	r31, r29
    2e2c:	e9 0f       	add	r30, r25
    2e2e:	f1 1d       	adc	r31, r1
    2e30:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2e32:	74 01       	movw	r14, r8
    2e34:	f2 e0       	ldi	r31, 0x02	; 2
    2e36:	ef 0e       	add	r14, r31
    2e38:	f1 1c       	adc	r15, r1
    2e3a:	a1 2c       	mov	r10, r1
    2e3c:	b1 2c       	mov	r11, r1
    2e3e:	c1 2c       	mov	r12, r1
    2e40:	d1 2c       	mov	r13, r1
    2e42:	04 2f       	mov	r16, r20
    2e44:	94 01       	movw	r18, r8
    2e46:	a2 01       	movw	r20, r4
    2e48:	be 01       	movw	r22, r28
    2e4a:	6f 5f       	subi	r22, 0xFF	; 255
    2e4c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e4e:	80 e2       	ldi	r24, 0x20	; 32
    2e50:	93 e0       	ldi	r25, 0x03	; 3
    2e52:	0e 94 cc 11 	call	0x2398	; 0x2398 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2e56:	f4 01       	movw	r30, r8
    2e58:	66 82       	std	Z+6, r6	; 0x06
    2e5a:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2e5c:	40 86       	std	Z+8, r4	; 0x08
    2e5e:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2e60:	20 91 d2 31 	lds	r18, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    2e64:	30 91 d3 31 	lds	r19, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    2e68:	24 83       	std	Z+4, r18	; 0x04
    2e6a:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2e6c:	80 92 d2 31 	sts	0x31D2, r8	; 0x8031d2 <last_created_task_pointer>
    2e70:	90 92 d3 31 	sts	0x31D3, r9	; 0x8031d3 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2e74:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2e76:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2e78:	40 90 34 32 	lds	r4, 0x3234	; 0x803234 <portStackTopForTask>
    2e7c:	50 90 35 32 	lds	r5, 0x3235	; 0x803235 <portStackTopForTask+0x1>
    2e80:	ff ef       	ldi	r31, 0xFF	; 255
    2e82:	4f 1a       	sub	r4, r31
    2e84:	5f 0a       	sbc	r5, r31
    2e86:	40 92 34 32 	sts	0x3234, r4	; 0x803234 <portStackTopForTask>
    2e8a:	50 92 35 32 	sts	0x3235, r5	; 0x803235 <portStackTopForTask+0x1>
    2e8e:	f4 01       	movw	r30, r8
    2e90:	42 86       	std	Z+10, r4	; 0x0a
    2e92:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2e94:	16 86       	std	Z+14, r1	; 0x0e
    2e96:	17 86       	std	Z+15, r1	; 0x0f
    2e98:	10 8a       	std	Z+16, r1	; 0x10
    2e9a:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2e9c:	61 14       	cp	r6, r1
    2e9e:	71 04       	cpc	r7, r1
    2ea0:	09 f4       	brne	.+2      	; 0x2ea4 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2ea2:	44 c0       	rjmp	.+136    	; 0x2f2c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2ea4:	81 30       	cpi	r24, 0x01	; 1
    2ea6:	79 f5       	brne	.+94     	; 0x2f06 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2ea8:	6a e0       	ldi	r22, 0x0A	; 10
    2eaa:	c3 01       	movw	r24, r6
    2eac:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2eb0:	7c 01       	movw	r14, r24
    2eb2:	6d e8       	ldi	r22, 0x8D	; 141
    2eb4:	75 e0       	ldi	r23, 0x05	; 5
    2eb6:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2eba:	be 01       	movw	r22, r28
    2ebc:	6f 5f       	subi	r22, 0xFF	; 255
    2ebe:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec0:	c7 01       	movw	r24, r14
    2ec2:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2ec6:	6a e0       	ldi	r22, 0x0A	; 10
    2ec8:	c7 01       	movw	r24, r14
    2eca:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2ece:	7c 01       	movw	r14, r24
    2ed0:	64 e8       	ldi	r22, 0x84	; 132
    2ed2:	75 e0       	ldi	r23, 0x05	; 5
    2ed4:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2ed8:	6a e0       	ldi	r22, 0x0A	; 10
    2eda:	c7 01       	movw	r24, r14
    2edc:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2ee0:	7c 01       	movw	r14, r24
    2ee2:	66 e7       	ldi	r22, 0x76	; 118
    2ee4:	75 e0       	ldi	r23, 0x05	; 5
    2ee6:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2eea:	63 e0       	ldi	r22, 0x03	; 3
    2eec:	c7 01       	movw	r24, r14
    2eee:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2ef2:	b2 01       	movw	r22, r4
    2ef4:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    2ef8:	62 e0       	ldi	r22, 0x02	; 2
    2efa:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2efe:	66 e0       	ldi	r22, 0x06	; 6
    2f00:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2f04:	13 c0       	rjmp	.+38     	; 0x2f2c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2f06:	6a e0       	ldi	r22, 0x0A	; 10
    2f08:	c3 01       	movw	r24, r6
    2f0a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2f0e:	4c 01       	movw	r8, r24
    2f10:	61 e6       	ldi	r22, 0x61	; 97
    2f12:	75 e0       	ldi	r23, 0x05	; 5
    2f14:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2f18:	be 01       	movw	r22, r28
    2f1a:	6f 5f       	subi	r22, 0xFF	; 255
    2f1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f1e:	c4 01       	movw	r24, r8
    2f20:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2f24:	66 e0       	ldi	r22, 0x06	; 6
    2f26:	c4 01       	movw	r24, r8
    2f28:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2f2c:	2a 96       	adiw	r28, 0x0a	; 10
    2f2e:	cd bf       	out	0x3d, r28	; 61
    2f30:	de bf       	out	0x3e, r29	; 62
    2f32:	df 91       	pop	r29
    2f34:	cf 91       	pop	r28
    2f36:	1f 91       	pop	r17
    2f38:	0f 91       	pop	r16
    2f3a:	ff 90       	pop	r15
    2f3c:	ef 90       	pop	r14
    2f3e:	df 90       	pop	r13
    2f40:	cf 90       	pop	r12
    2f42:	bf 90       	pop	r11
    2f44:	af 90       	pop	r10
    2f46:	9f 90       	pop	r9
    2f48:	8f 90       	pop	r8
    2f4a:	7f 90       	pop	r7
    2f4c:	6f 90       	pop	r6
    2f4e:	5f 90       	pop	r5
    2f50:	4f 90       	pop	r4
    2f52:	08 95       	ret

00002f54 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2f54:	cf 92       	push	r12
    2f56:	df 92       	push	r13
    2f58:	ef 92       	push	r14
    2f5a:	ff 92       	push	r15
    2f5c:	0f 93       	push	r16
    2f5e:	1f 93       	push	r17
    2f60:	cf 93       	push	r28
    2f62:	df 93       	push	r29
    2f64:	ec 01       	movw	r28, r24
    2f66:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2f68:	8a 81       	ldd	r24, Y+2	; 0x02
    2f6a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f6c:	0e 94 23 13 	call	0x2646	; 0x2646 <pcTaskGetTaskName>
    2f70:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2f72:	6a e0       	ldi	r22, 0x0A	; 10
    2f74:	c7 01       	movw	r24, r14
    2f76:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2f7a:	8c 01       	movw	r16, r24
    2f7c:	60 ea       	ldi	r22, 0xA0	; 160
    2f7e:	75 e0       	ldi	r23, 0x05	; 5
    2f80:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2f84:	6a e0       	ldi	r22, 0x0A	; 10
    2f86:	c8 01       	movw	r24, r16
    2f88:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2f8c:	8c 01       	movw	r16, r24
    2f8e:	69 e9       	ldi	r22, 0x99	; 153
    2f90:	75 e0       	ldi	r23, 0x05	; 5
    2f92:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2f96:	b6 01       	movw	r22, r12
    2f98:	c8 01       	movw	r24, r16
    2f9a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2f9e:	6a e0       	ldi	r22, 0x0A	; 10
    2fa0:	c8 01       	movw	r24, r16
    2fa2:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    2fa6:	8c 01       	movw	r16, r24
    2fa8:	63 e9       	ldi	r22, 0x93	; 147
    2faa:	75 e0       	ldi	r23, 0x05	; 5
    2fac:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    2fb0:	66 e0       	ldi	r22, 0x06	; 6
    2fb2:	c8 01       	movw	r24, r16
    2fb4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2fb8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fba:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fbc:	e8 85       	ldd	r30, Y+8	; 0x08
    2fbe:	f9 85       	ldd	r31, Y+9	; 0x09
    2fc0:	01 e1       	ldi	r16, 0x11	; 17
    2fc2:	21 e0       	ldi	r18, 0x01	; 1
    2fc4:	a7 01       	movw	r20, r14
    2fc6:	bc 01       	movw	r22, r24
    2fc8:	8e 1b       	sub	r24, r30
    2fca:	9f 0b       	sbc	r25, r31
    2fcc:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    2fd4:	00 97       	sbiw	r24, 0x00	; 0
    2fd6:	19 f0       	breq	.+6      	; 0x2fde <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2fd8:	b7 01       	movw	r22, r14
    2fda:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2fde:	df 91       	pop	r29
    2fe0:	cf 91       	pop	r28
    2fe2:	1f 91       	pop	r17
    2fe4:	0f 91       	pop	r16
    2fe6:	ff 90       	pop	r15
    2fe8:	ef 90       	pop	r14
    2fea:	df 90       	pop	r13
    2fec:	cf 90       	pop	r12
    2fee:	08 95       	ret

00002ff0 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2ff0:	0f 93       	push	r16
    2ff2:	1f 93       	push	r17
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
    2ff8:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2ffa:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    2ffe:	90 91 d3 31 	lds	r25, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    3002:	00 97       	sbiw	r24, 0x00	; 0
    3004:	19 f0       	breq	.+6      	; 0x300c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3006:	be 01       	movw	r22, r28
    3008:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    300c:	6a e0       	ldi	r22, 0x0A	; 10
    300e:	ce 01       	movw	r24, r28
    3010:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3014:	8c 01       	movw	r16, r24
    3016:	66 eb       	ldi	r22, 0xB6	; 182
    3018:	75 e0       	ldi	r23, 0x05	; 5
    301a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    301e:	6a e0       	ldi	r22, 0x0A	; 10
    3020:	c8 01       	movw	r24, r16
    3022:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3026:	8c 01       	movw	r16, r24
    3028:	6b ea       	ldi	r22, 0xAB	; 171
    302a:	75 e0       	ldi	r23, 0x05	; 5
    302c:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    3030:	6a e0       	ldi	r22, 0x0A	; 10
    3032:	c8 01       	movw	r24, r16
    3034:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3038:	8c 01       	movw	r16, r24
    303a:	65 ea       	ldi	r22, 0xA5	; 165
    303c:	75 e0       	ldi	r23, 0x05	; 5
    303e:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    3042:	66 e0       	ldi	r22, 0x06	; 6
    3044:	c8 01       	movw	r24, r16
    3046:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    304a:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <portStackTopForTask>
    304e:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <portStackTopForTask+0x1>
    3052:	bc 01       	movw	r22, r24
    3054:	6f 5f       	subi	r22, 0xFF	; 255
    3056:	7f 4f       	sbci	r23, 0xFF	; 255
    3058:	01 e1       	ldi	r16, 0x11	; 17
    305a:	21 e0       	ldi	r18, 0x01	; 1
    305c:	ae 01       	movw	r20, r28
    305e:	83 56       	subi	r24, 0x63	; 99
    3060:	91 09       	sbc	r25, r1
    3062:	0e 94 ac 1a 	call	0x3558	; 0x3558 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3066:	df 91       	pop	r29
    3068:	cf 91       	pop	r28
    306a:	1f 91       	pop	r17
    306c:	0f 91       	pop	r16
    306e:	08 95       	ret

00003070 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3070:	8f 92       	push	r8
    3072:	9f 92       	push	r9
    3074:	af 92       	push	r10
    3076:	bf 92       	push	r11
    3078:	cf 92       	push	r12
    307a:	df 92       	push	r13
    307c:	ef 92       	push	r14
    307e:	ff 92       	push	r15
    3080:	0f 93       	push	r16
    3082:	1f 93       	push	r17
    3084:	cf 93       	push	r28
    3086:	df 93       	push	r29
    3088:	ec 01       	movw	r28, r24
    308a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    308c:	8a 81       	ldd	r24, Y+2	; 0x02
    308e:	9b 81       	ldd	r25, Y+3	; 0x03
    3090:	0e 94 23 13 	call	0x2646	; 0x2646 <pcTaskGetTaskName>
    3094:	bc 01       	movw	r22, r24
    3096:	c8 01       	movw	r24, r16
    3098:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    309c:	d8 01       	movw	r26, r16
    309e:	ed 91       	ld	r30, X+
    30a0:	fc 91       	ld	r31, X
    30a2:	02 80       	ldd	r0, Z+2	; 0x02
    30a4:	f3 81       	ldd	r31, Z+3	; 0x03
    30a6:	e0 2d       	mov	r30, r0
    30a8:	69 e0       	ldi	r22, 0x09	; 9
    30aa:	c8 01       	movw	r24, r16
    30ac:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    30ae:	8a 81       	ldd	r24, Y+2	; 0x02
    30b0:	9b 81       	ldd	r25, Y+3	; 0x03
    30b2:	0e 94 23 13 	call	0x2646	; 0x2646 <pcTaskGetTaskName>
    30b6:	fc 01       	movw	r30, r24
    30b8:	01 90       	ld	r0, Z+
    30ba:	00 20       	and	r0, r0
    30bc:	e9 f7       	brne	.-6      	; 0x30b8 <_ZN8frt_task12print_statusER8emstream+0x48>
    30be:	31 97       	sbiw	r30, 0x01	; 1
    30c0:	e8 1b       	sub	r30, r24
    30c2:	f9 0b       	sbc	r31, r25
    30c4:	38 97       	sbiw	r30, 0x08	; 8
    30c6:	48 f4       	brcc	.+18     	; 0x30da <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    30c8:	d8 01       	movw	r26, r16
    30ca:	ed 91       	ld	r30, X+
    30cc:	fc 91       	ld	r31, X
    30ce:	02 80       	ldd	r0, Z+2	; 0x02
    30d0:	f3 81       	ldd	r31, Z+3	; 0x03
    30d2:	e0 2d       	mov	r30, r0
    30d4:	69 e0       	ldi	r22, 0x09	; 9
    30d6:	c8 01       	movw	r24, r16
    30d8:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    30da:	ce 84       	ldd	r12, Y+14	; 0x0e
    30dc:	df 84       	ldd	r13, Y+15	; 0x0f
    30de:	e8 88       	ldd	r14, Y+16	; 0x10
    30e0:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    30e2:	a8 84       	ldd	r10, Y+8	; 0x08
    30e4:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    30e6:	8a 81       	ldd	r24, Y+2	; 0x02
    30e8:	9b 81       	ldd	r25, Y+3	; 0x03
    30ea:	0e 94 29 16 	call	0x2c52	; 0x2c52 <uxTaskGetStackHighWaterMark>
    30ee:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    30f0:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    30f2:	8a 81       	ldd	r24, Y+2	; 0x02
    30f4:	9b 81       	ldd	r25, Y+3	; 0x03
    30f6:	0e 94 ce 12 	call	0x259c	; 0x259c <uxTaskPriorityGet>
    30fa:	68 2f       	mov	r22, r24
    30fc:	c8 01       	movw	r24, r16
    30fe:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    3102:	6a e0       	ldi	r22, 0x0A	; 10
    3104:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3108:	ec 01       	movw	r28, r24
    310a:	6b e2       	ldi	r22, 0x2B	; 43
    310c:	76 e0       	ldi	r23, 0x06	; 6
    310e:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3112:	68 2d       	mov	r22, r8
    3114:	ce 01       	movw	r24, r28
    3116:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    311a:	6a e0       	ldi	r22, 0x0A	; 10
    311c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3120:	ec 01       	movw	r28, r24
    3122:	69 e2       	ldi	r22, 0x29	; 41
    3124:	76 e0       	ldi	r23, 0x06	; 6
    3126:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    312a:	69 2d       	mov	r22, r9
    312c:	ce 01       	movw	r24, r28
    312e:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    3132:	6a e0       	ldi	r22, 0x0A	; 10
    3134:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3138:	ec 01       	movw	r28, r24
    313a:	67 e2       	ldi	r22, 0x27	; 39
    313c:	76 e0       	ldi	r23, 0x06	; 6
    313e:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3142:	b5 01       	movw	r22, r10
    3144:	ce 01       	movw	r24, r28
    3146:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    314a:	6a e0       	ldi	r22, 0x0A	; 10
    314c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3150:	ec 01       	movw	r28, r24
    3152:	65 e2       	ldi	r22, 0x25	; 37
    3154:	76 e0       	ldi	r23, 0x06	; 6
    3156:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    315a:	6a e0       	ldi	r22, 0x0A	; 10
    315c:	ce 01       	movw	r24, r28
    315e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3162:	ec 01       	movw	r28, r24
    3164:	63 e2       	ldi	r22, 0x23	; 35
    3166:	76 e0       	ldi	r23, 0x06	; 6
    3168:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    316c:	b7 01       	movw	r22, r14
    316e:	a6 01       	movw	r20, r12
    3170:	ce 01       	movw	r24, r28
    3172:	0e 94 c3 1c 	call	0x3986	; 0x3986 <_ZN8emstreamlsEm>
}
    3176:	df 91       	pop	r29
    3178:	cf 91       	pop	r28
    317a:	1f 91       	pop	r17
    317c:	0f 91       	pop	r16
    317e:	ff 90       	pop	r15
    3180:	ef 90       	pop	r14
    3182:	df 90       	pop	r13
    3184:	cf 90       	pop	r12
    3186:	bf 90       	pop	r11
    3188:	af 90       	pop	r10
    318a:	9f 90       	pop	r9
    318c:	8f 90       	pop	r8
    318e:	08 95       	ret

00003190 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3190:	cf 93       	push	r28
    3192:	df 93       	push	r29
    3194:	ec 01       	movw	r28, r24
    3196:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    3198:	db 01       	movw	r26, r22
    319a:	ed 91       	ld	r30, X+
    319c:	fc 91       	ld	r31, X
    319e:	02 80       	ldd	r0, Z+2	; 0x02
    31a0:	f3 81       	ldd	r31, Z+3	; 0x03
    31a2:	e0 2d       	mov	r30, r0
    31a4:	be 01       	movw	r22, r28
    31a6:	19 95       	eicall
	return (ser_dev);
}
    31a8:	ce 01       	movw	r24, r28
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	08 95       	ret

000031b0 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    31b0:	0f 93       	push	r16
    31b2:	1f 93       	push	r17
    31b4:	cf 93       	push	r28
    31b6:	df 93       	push	r29
    31b8:	ec 01       	movw	r28, r24
    31ba:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    31bc:	bc 01       	movw	r22, r24
    31be:	c8 01       	movw	r24, r16
    31c0:	0e 94 c8 18 	call	0x3190	; 0x3190 <_ZlsR8emstreamR8frt_task>
    31c4:	66 e0       	ldi	r22, 0x06	; 6
    31c6:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    31ca:	8c 81       	ldd	r24, Y+4	; 0x04
    31cc:	9d 81       	ldd	r25, Y+5	; 0x05
    31ce:	00 97       	sbiw	r24, 0x00	; 0
    31d0:	19 f0       	breq	.+6      	; 0x31d8 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    31d2:	b8 01       	movw	r22, r16
    31d4:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    31d8:	df 91       	pop	r29
    31da:	cf 91       	pop	r28
    31dc:	1f 91       	pop	r17
    31de:	0f 91       	pop	r16
    31e0:	08 95       	ret

000031e2 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    31e2:	0f 93       	push	r16
    31e4:	1f 93       	push	r17
    31e6:	cf 93       	push	r28
    31e8:	df 93       	push	r29
    31ea:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    31ec:	6a e0       	ldi	r22, 0x0A	; 10
    31ee:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    31f2:	8c 01       	movw	r16, r24
    31f4:	68 e1       	ldi	r22, 0x18	; 24
    31f6:	76 e0       	ldi	r23, 0x06	; 6
    31f8:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    31fc:	6a e0       	ldi	r22, 0x0A	; 10
    31fe:	c8 01       	movw	r24, r16
    3200:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3204:	8c 01       	movw	r16, r24
    3206:	61 e1       	ldi	r22, 0x11	; 17
    3208:	76 e0       	ldi	r23, 0x06	; 6
    320a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    320e:	66 e0       	ldi	r22, 0x06	; 6
    3210:	c8 01       	movw	r24, r16
    3212:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3216:	6a e0       	ldi	r22, 0x0A	; 10
    3218:	ce 01       	movw	r24, r28
    321a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    321e:	8c 01       	movw	r16, r24
    3220:	60 e0       	ldi	r22, 0x00	; 0
    3222:	76 e0       	ldi	r23, 0x06	; 6
    3224:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3228:	6a e0       	ldi	r22, 0x0A	; 10
    322a:	c8 01       	movw	r24, r16
    322c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3230:	8c 01       	movw	r16, r24
    3232:	64 ef       	ldi	r22, 0xF4	; 244
    3234:	75 e0       	ldi	r23, 0x05	; 5
    3236:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    323a:	6a e0       	ldi	r22, 0x0A	; 10
    323c:	c8 01       	movw	r24, r16
    323e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3242:	8c 01       	movw	r16, r24
    3244:	6e ee       	ldi	r22, 0xEE	; 238
    3246:	75 e0       	ldi	r23, 0x05	; 5
    3248:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    324c:	66 e0       	ldi	r22, 0x06	; 6
    324e:	c8 01       	movw	r24, r16
    3250:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3254:	6a e0       	ldi	r22, 0x0A	; 10
    3256:	ce 01       	movw	r24, r28
    3258:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    325c:	8c 01       	movw	r16, r24
    325e:	6d ed       	ldi	r22, 0xDD	; 221
    3260:	75 e0       	ldi	r23, 0x05	; 5
    3262:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3266:	6a e0       	ldi	r22, 0x0A	; 10
    3268:	c8 01       	movw	r24, r16
    326a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    326e:	8c 01       	movw	r16, r24
    3270:	61 ed       	ldi	r22, 0xD1	; 209
    3272:	75 e0       	ldi	r23, 0x05	; 5
    3274:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    3278:	6a e0       	ldi	r22, 0x0A	; 10
    327a:	c8 01       	movw	r24, r16
    327c:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    3280:	8c 01       	movw	r16, r24
    3282:	6b ec       	ldi	r22, 0xCB	; 203
    3284:	75 e0       	ldi	r23, 0x05	; 5
    3286:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    328a:	66 e0       	ldi	r22, 0x06	; 6
    328c:	c8 01       	movw	r24, r16
    328e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3292:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    3296:	90 91 d3 31 	lds	r25, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    329a:	00 97       	sbiw	r24, 0x00	; 0
    329c:	19 f0       	breq	.+6      	; 0x32a4 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    329e:	be 01       	movw	r22, r28
    32a0:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32a4:	0e 94 2b 13 	call	0x2656	; 0x2656 <xTaskGetIdleTaskHandle>
    32a8:	0e 94 29 16 	call	0x2c52	; 0x2c52 <uxTaskGetStackHighWaterMark>
    32ac:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    32ae:	6a e0       	ldi	r22, 0x0A	; 10
    32b0:	ce 01       	movw	r24, r28
    32b2:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    32b6:	ec 01       	movw	r28, r24
    32b8:	60 ec       	ldi	r22, 0xC0	; 192
    32ba:	75 e0       	ldi	r23, 0x05	; 5
    32bc:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32c0:	61 2f       	mov	r22, r17
    32c2:	ce 01       	movw	r24, r28
    32c4:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    32c8:	6a e0       	ldi	r22, 0x0A	; 10
    32ca:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    32ce:	ec 01       	movw	r28, r24
    32d0:	6e eb       	ldi	r22, 0xBE	; 190
    32d2:	75 e0       	ldi	r23, 0x05	; 5
    32d4:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    32d8:	64 e6       	ldi	r22, 0x64	; 100
    32da:	70 e0       	ldi	r23, 0x00	; 0
    32dc:	ce 01       	movw	r24, r28
    32de:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    32e2:	6a e0       	ldi	r22, 0x0A	; 10
    32e4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    32e8:	ec 01       	movw	r28, r24
    32ea:	6b eb       	ldi	r22, 0xBB	; 187
    32ec:	75 e0       	ldi	r23, 0x05	; 5
    32ee:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    32f2:	66 e0       	ldi	r22, 0x06	; 6
    32f4:	ce 01       	movw	r24, r28
    32f6:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
}
    32fa:	df 91       	pop	r29
    32fc:	cf 91       	pop	r28
    32fe:	1f 91       	pop	r17
    3300:	0f 91       	pop	r16
    3302:	08 95       	ret

00003304 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3304:	0f 93       	push	r16
    3306:	cf 93       	push	r28
    3308:	df 93       	push	r29
    330a:	1f 92       	push	r1
    330c:	cd b7       	in	r28, 0x3d	; 61
    330e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3310:	00 e0       	ldi	r16, 0x00	; 0
    3312:	2f ef       	ldi	r18, 0xFF	; 255
    3314:	3f ef       	ldi	r19, 0xFF	; 255
    3316:	a9 01       	movw	r20, r18
    3318:	be 01       	movw	r22, r28
    331a:	6f 5f       	subi	r22, 0xFF	; 255
    331c:	7f 4f       	sbci	r23, 0xFF	; 255
    331e:	fc 01       	movw	r30, r24
    3320:	80 85       	ldd	r24, Z+8	; 0x08
    3322:	91 85       	ldd	r25, Z+9	; 0x09
    3324:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
    3328:	81 30       	cpi	r24, 0x01	; 1
    332a:	19 f4       	brne	.+6      	; 0x3332 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    332c:	89 81       	ldd	r24, Y+1	; 0x01
    332e:	90 e0       	ldi	r25, 0x00	; 0
    3330:	02 c0       	rjmp	.+4      	; 0x3336 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3332:	8f ef       	ldi	r24, 0xFF	; 255
    3334:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3336:	0f 90       	pop	r0
    3338:	df 91       	pop	r29
    333a:	cf 91       	pop	r28
    333c:	0f 91       	pop	r16
    333e:	08 95       	ret

00003340 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3340:	fc 01       	movw	r30, r24
    3342:	80 85       	ldd	r24, Z+8	; 0x08
    3344:	91 85       	ldd	r25, Z+9	; 0x09
    3346:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
    334a:	91 e0       	ldi	r25, 0x01	; 1
    334c:	81 11       	cpse	r24, r1
    334e:	01 c0       	rjmp	.+2      	; 0x3352 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3350:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3352:	89 2f       	mov	r24, r25
    3354:	08 95       	ret

00003356 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3356:	0f 93       	push	r16
    3358:	cf 93       	push	r28
    335a:	df 93       	push	r29
    335c:	1f 92       	push	r1
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
    3362:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3364:	fc 01       	movw	r30, r24
    3366:	22 85       	ldd	r18, Z+10	; 0x0a
    3368:	33 85       	ldd	r19, Z+11	; 0x0b
    336a:	44 85       	ldd	r20, Z+12	; 0x0c
    336c:	55 85       	ldd	r21, Z+13	; 0x0d
    336e:	00 e0       	ldi	r16, 0x00	; 0
    3370:	be 01       	movw	r22, r28
    3372:	6f 5f       	subi	r22, 0xFF	; 255
    3374:	7f 4f       	sbci	r23, 0xFF	; 255
    3376:	80 85       	ldd	r24, Z+8	; 0x08
    3378:	91 85       	ldd	r25, Z+9	; 0x09
    337a:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
    337e:	91 e0       	ldi	r25, 0x01	; 1
    3380:	81 11       	cpse	r24, r1
    3382:	01 c0       	rjmp	.+2      	; 0x3386 <_ZN14frt_text_queue7putcharEc+0x30>
    3384:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3386:	89 2f       	mov	r24, r25
    3388:	0f 90       	pop	r0
    338a:	df 91       	pop	r29
    338c:	cf 91       	pop	r28
    338e:	0f 91       	pop	r16
    3390:	08 95       	ret

00003392 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3392:	8f 92       	push	r8
    3394:	9f 92       	push	r9
    3396:	bf 92       	push	r11
    3398:	cf 92       	push	r12
    339a:	df 92       	push	r13
    339c:	ef 92       	push	r14
    339e:	ff 92       	push	r15
    33a0:	0f 93       	push	r16
    33a2:	1f 93       	push	r17
    33a4:	cf 93       	push	r28
    33a6:	df 93       	push	r29
    33a8:	ec 01       	movw	r28, r24
    33aa:	b6 2e       	mov	r11, r22
    33ac:	4a 01       	movw	r8, r20
    33ae:	68 01       	movw	r12, r16
    33b0:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    33b2:	0e 94 03 1c 	call	0x3806	; 0x3806 <_ZN8emstreamC1Ev>
    33b6:	87 ec       	ldi	r24, 0xC7	; 199
    33b8:	90 e2       	ldi	r25, 0x20	; 32
    33ba:	88 83       	st	Y, r24
    33bc:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    33be:	8e 86       	std	Y+14, r8	; 0x0e
    33c0:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    33c2:	40 e0       	ldi	r20, 0x00	; 0
    33c4:	61 e0       	ldi	r22, 0x01	; 1
    33c6:	8b 2d       	mov	r24, r11
    33c8:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    33cc:	88 87       	std	Y+8, r24	; 0x08
    33ce:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    33d0:	ca 86       	std	Y+10, r12	; 0x0a
    33d2:	db 86       	std	Y+11, r13	; 0x0b
    33d4:	ec 86       	std	Y+12, r14	; 0x0c
    33d6:	fd 86       	std	Y+13, r15	; 0x0d
}
    33d8:	df 91       	pop	r29
    33da:	cf 91       	pop	r28
    33dc:	1f 91       	pop	r17
    33de:	0f 91       	pop	r16
    33e0:	ff 90       	pop	r15
    33e2:	ef 90       	pop	r14
    33e4:	df 90       	pop	r13
    33e6:	cf 90       	pop	r12
    33e8:	bf 90       	pop	r11
    33ea:	9f 90       	pop	r9
    33ec:	8f 90       	pop	r8
    33ee:	08 95       	ret

000033f0 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    33f0:	cf 92       	push	r12
    33f2:	df 92       	push	r13
    33f4:	ef 92       	push	r14
    33f6:	ff 92       	push	r15
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    33fe:	68 81       	ld	r22, Y
    3400:	79 81       	ldd	r23, Y+1	; 0x01
    3402:	8a 81       	ldd	r24, Y+2	; 0x02
    3404:	9b 81       	ldd	r25, Y+3	; 0x03
    3406:	0f 2e       	mov	r0, r31
    3408:	f8 ee       	ldi	r31, 0xE8	; 232
    340a:	cf 2e       	mov	r12, r31
    340c:	f3 e0       	ldi	r31, 0x03	; 3
    340e:	df 2e       	mov	r13, r31
    3410:	e1 2c       	mov	r14, r1
    3412:	f1 2c       	mov	r15, r1
    3414:	f0 2d       	mov	r31, r0
    3416:	a7 01       	movw	r20, r14
    3418:	96 01       	movw	r18, r12
    341a:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
    341e:	9b 01       	movw	r18, r22
    3420:	ac 01       	movw	r20, r24
    3422:	60 e4       	ldi	r22, 0x40	; 64
    3424:	72 e4       	ldi	r23, 0x42	; 66
    3426:	8f e0       	ldi	r24, 0x0F	; 15
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	0e 94 5d 23 	call	0x46ba	; 0x46ba <__mulsi3>
    342e:	a7 01       	movw	r20, r14
    3430:	96 01       	movw	r18, r12
    3432:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
    3436:	69 01       	movw	r12, r18
    3438:	7a 01       	movw	r14, r20
    343a:	ac 81       	ldd	r26, Y+4	; 0x04
    343c:	bd 81       	ldd	r27, Y+5	; 0x05
    343e:	20 e4       	ldi	r18, 0x40	; 64
    3440:	32 e4       	ldi	r19, 0x42	; 66
    3442:	4f e0       	ldi	r20, 0x0F	; 15
    3444:	50 e0       	ldi	r21, 0x00	; 0
    3446:	0e 94 b7 23 	call	0x476e	; 0x476e <__muluhisi3>
    344a:	20 e0       	ldi	r18, 0x00	; 0
    344c:	38 e4       	ldi	r19, 0x48	; 72
    344e:	48 ee       	ldi	r20, 0xE8	; 232
    3450:	51 e0       	ldi	r21, 0x01	; 1
    3452:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
    3456:	c7 01       	movw	r24, r14
    3458:	b6 01       	movw	r22, r12
    345a:	62 0f       	add	r22, r18
    345c:	73 1f       	adc	r23, r19
    345e:	84 1f       	adc	r24, r20
    3460:	95 1f       	adc	r25, r21
}
    3462:	df 91       	pop	r29
    3464:	cf 91       	pop	r28
    3466:	ff 90       	pop	r15
    3468:	ef 90       	pop	r14
    346a:	df 90       	pop	r13
    346c:	cf 90       	pop	r12
    346e:	08 95       	ret

00003470 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3470:	cf 92       	push	r12
    3472:	df 92       	push	r13
    3474:	ef 92       	push	r14
    3476:	ff 92       	push	r15
    3478:	0f 93       	push	r16
    347a:	1f 93       	push	r17
    347c:	cf 93       	push	r28
    347e:	df 93       	push	r29
    3480:	cd b7       	in	r28, 0x3d	; 61
    3482:	de b7       	in	r29, 0x3e	; 62
    3484:	2f 97       	sbiw	r28, 0x0f	; 15
    3486:	cd bf       	out	0x3d, r28	; 61
    3488:	de bf       	out	0x3e, r29	; 62
    348a:	6c 01       	movw	r12, r24
    348c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    348e:	db 01       	movw	r26, r22
    3490:	6d 91       	ld	r22, X+
    3492:	7d 91       	ld	r23, X+
    3494:	8d 91       	ld	r24, X+
    3496:	9c 91       	ld	r25, X
    3498:	28 ee       	ldi	r18, 0xE8	; 232
    349a:	33 e0       	ldi	r19, 0x03	; 3
    349c:	40 e0       	ldi	r20, 0x00	; 0
    349e:	50 e0       	ldi	r21, 0x00	; 0
    34a0:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
    34a4:	ba 01       	movw	r22, r20
    34a6:	a9 01       	movw	r20, r18
    34a8:	c6 01       	movw	r24, r12
    34aa:	0e 94 c3 1c 	call	0x3986	; 0x3986 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    34ae:	d6 01       	movw	r26, r12
    34b0:	ed 91       	ld	r30, X+
    34b2:	fc 91       	ld	r31, X
    34b4:	02 80       	ldd	r0, Z+2	; 0x02
    34b6:	f3 81       	ldd	r31, Z+3	; 0x03
    34b8:	e0 2d       	mov	r30, r0
    34ba:	6e e2       	ldi	r22, 0x2E	; 46
    34bc:	c6 01       	movw	r24, r12
    34be:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    34c0:	c8 01       	movw	r24, r16
    34c2:	0e 94 f8 19 	call	0x33f0	; 0x33f0 <_ZN10time_stamp12get_microsecEv>
    34c6:	8e 01       	movw	r16, r28
    34c8:	09 5f       	subi	r16, 0xF9	; 249
    34ca:	1f 4f       	sbci	r17, 0xFF	; 255
    34cc:	fe 01       	movw	r30, r28
    34ce:	31 96       	adiw	r30, 0x01	; 1
    34d0:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    34d2:	2a e0       	ldi	r18, 0x0A	; 10
    34d4:	30 e0       	ldi	r19, 0x00	; 0
    34d6:	40 e0       	ldi	r20, 0x00	; 0
    34d8:	50 e0       	ldi	r21, 0x00	; 0
    34da:	0e 94 8f 23 	call	0x471e	; 0x471e <__divmodsi4>
    34de:	e6 2f       	mov	r30, r22
    34e0:	28 87       	std	Y+8, r18	; 0x08
    34e2:	39 87       	std	Y+9, r19	; 0x09
    34e4:	4a 87       	std	Y+10, r20	; 0x0a
    34e6:	5b 87       	std	Y+11, r21	; 0x0b
    34e8:	68 85       	ldd	r22, Y+8	; 0x08
    34ea:	79 85       	ldd	r23, Y+9	; 0x09
    34ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    34ee:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    34f0:	20 e3       	ldi	r18, 0x30	; 48
    34f2:	2e 0f       	add	r18, r30
    34f4:	d8 01       	movw	r26, r16
    34f6:	2e 93       	st	-X, r18
    34f8:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    34fa:	ae 15       	cp	r26, r14
    34fc:	bf 05       	cpc	r27, r15
    34fe:	49 f7       	brne	.-46     	; 0x34d2 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3500:	1f 82       	std	Y+7, r1	; 0x07
    3502:	be 01       	movw	r22, r28
    3504:	6f 5f       	subi	r22, 0xFF	; 255
    3506:	7f 4f       	sbci	r23, 0xFF	; 255
    3508:	c6 01       	movw	r24, r12
    350a:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    350e:	c6 01       	movw	r24, r12
    3510:	2f 96       	adiw	r28, 0x0f	; 15
    3512:	cd bf       	out	0x3d, r28	; 61
    3514:	de bf       	out	0x3e, r29	; 62
    3516:	df 91       	pop	r29
    3518:	cf 91       	pop	r28
    351a:	1f 91       	pop	r17
    351c:	0f 91       	pop	r16
    351e:	ff 90       	pop	r15
    3520:	ef 90       	pop	r14
    3522:	df 90       	pop	r13
    3524:	cf 90       	pop	r12
    3526:	08 95       	ret

00003528 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3528:	cf 93       	push	r28
    352a:	df 93       	push	r29
    352c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    352e:	0f b6       	in	r0, 0x3f	; 63
    3530:	f8 94       	cli
    3532:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3534:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3538:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    353c:	8c 83       	std	Y+4, r24	; 0x04
    353e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3540:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskGetTickCount>
    3544:	68 83       	st	Y, r22
    3546:	79 83       	std	Y+1, r23	; 0x01
    3548:	8a 83       	std	Y+2, r24	; 0x02
    354a:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    354c:	0f 90       	pop	r0
    354e:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3550:	ce 01       	movw	r24, r28
    3552:	df 91       	pop	r29
    3554:	cf 91       	pop	r28
    3556:	08 95       	ret

00003558 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3558:	5f 92       	push	r5
    355a:	6f 92       	push	r6
    355c:	7f 92       	push	r7
    355e:	8f 92       	push	r8
    3560:	9f 92       	push	r9
    3562:	af 92       	push	r10
    3564:	bf 92       	push	r11
    3566:	cf 92       	push	r12
    3568:	df 92       	push	r13
    356a:	ef 92       	push	r14
    356c:	ff 92       	push	r15
    356e:	0f 93       	push	r16
    3570:	1f 93       	push	r17
    3572:	cf 93       	push	r28
    3574:	df 93       	push	r29
    3576:	5c 01       	movw	r10, r24
    3578:	4b 01       	movw	r8, r22
    357a:	7a 01       	movw	r14, r20
    357c:	12 2f       	mov	r17, r18
    357e:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3580:	63 e0       	ldi	r22, 0x03	; 3
    3582:	ca 01       	movw	r24, r20
    3584:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3588:	a8 14       	cp	r10, r8
    358a:	b9 04       	cpc	r11, r9
    358c:	08 f0       	brcs	.+2      	; 0x3590 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    358e:	7d c0       	rjmp	.+250    	; 0x368a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3590:	65 01       	movw	r12, r10
    3592:	84 e1       	ldi	r24, 0x14	; 20
    3594:	c8 0e       	add	r12, r24
    3596:	d1 1c       	adc	r13, r1
    3598:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    359a:	6a 2c       	mov	r6, r10
    359c:	5b 2c       	mov	r5, r11
    359e:	b5 01       	movw	r22, r10
    35a0:	c7 01       	movw	r24, r14
    35a2:	0e 94 8f 1c 	call	0x391e	; 0x391e <_ZN8emstreamlsEj>
    35a6:	6a e0       	ldi	r22, 0x0A	; 10
    35a8:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    35ac:	6d e3       	ldi	r22, 0x3D	; 61
    35ae:	76 e0       	ldi	r23, 0x06	; 6
    35b0:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    35b4:	11 23       	and	r17, r17
    35b6:	09 f4       	brne	.+2      	; 0x35ba <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    35b8:	6d c0       	rjmp	.+218    	; 0x3694 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    35ba:	00 23       	and	r16, r16
    35bc:	09 f4       	brne	.+2      	; 0x35c0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    35be:	6a c0       	rjmp	.+212    	; 0x3694 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    35c0:	6a e0       	ldi	r22, 0x0A	; 10
    35c2:	c7 01       	movw	r24, r14
    35c4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    35c8:	68 e3       	ldi	r22, 0x38	; 56
    35ca:	76 e0       	ldi	r23, 0x06	; 6
    35cc:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    35d0:	61 c0       	rjmp	.+194    	; 0x3694 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    35d2:	11 23       	and	r17, r17
    35d4:	71 f0       	breq	.+28     	; 0x35f2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    35d6:	01 11       	cpse	r16, r1
    35d8:	0c c0       	rjmp	.+24     	; 0x35f2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    35da:	88 81       	ld	r24, Y
    35dc:	87 15       	cp	r24, r7
    35de:	49 f0       	breq	.+18     	; 0x35f2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    35e0:	6a e0       	ldi	r22, 0x0A	; 10
    35e2:	c7 01       	movw	r24, r14
    35e4:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    35e8:	63 e3       	ldi	r22, 0x33	; 51
    35ea:	76 e0       	ldi	r23, 0x06	; 6
    35ec:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    35f0:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    35f2:	69 91       	ld	r22, Y+
    35f4:	c7 01       	movw	r24, r14
    35f6:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    35fa:	dc 01       	movw	r26, r24
    35fc:	ed 91       	ld	r30, X+
    35fe:	fc 91       	ld	r31, X
    3600:	02 80       	ldd	r0, Z+2	; 0x02
    3602:	f3 81       	ldd	r31, Z+3	; 0x03
    3604:	e0 2d       	mov	r30, r0
    3606:	60 e2       	ldi	r22, 0x20	; 32
    3608:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    360a:	cc 16       	cp	r12, r28
    360c:	dd 06       	cpc	r13, r29
    360e:	09 f7       	brne	.-62     	; 0x35d2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3610:	11 23       	and	r17, r17
    3612:	89 f0       	breq	.+34     	; 0x3636 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3614:	6a e0       	ldi	r22, 0x0A	; 10
    3616:	c7 01       	movw	r24, r14
    3618:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    361c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    361e:	6d e2       	ldi	r22, 0x2D	; 45
    3620:	76 e0       	ldi	r23, 0x06	; 6
    3622:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3626:	e8 81       	ld	r30, Y
    3628:	f9 81       	ldd	r31, Y+1	; 0x01
    362a:	02 80       	ldd	r0, Z+2	; 0x02
    362c:	f3 81       	ldd	r31, Z+3	; 0x03
    362e:	e0 2d       	mov	r30, r0
    3630:	60 e2       	ldi	r22, 0x20	; 32
    3632:	ce 01       	movw	r24, r28
    3634:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3636:	c6 2d       	mov	r28, r6
    3638:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    363a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    363c:	80 ee       	ldi	r24, 0xE0	; 224
    363e:	86 0f       	add	r24, r22
    3640:	8f 35       	cpi	r24, 0x5F	; 95
    3642:	48 f4       	brcc	.+18     	; 0x3656 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3644:	d7 01       	movw	r26, r14
    3646:	ed 91       	ld	r30, X+
    3648:	fc 91       	ld	r31, X
    364a:	02 80       	ldd	r0, Z+2	; 0x02
    364c:	f3 81       	ldd	r31, Z+3	; 0x03
    364e:	e0 2d       	mov	r30, r0
    3650:	c7 01       	movw	r24, r14
    3652:	19 95       	eicall
    3654:	09 c0       	rjmp	.+18     	; 0x3668 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3656:	d7 01       	movw	r26, r14
    3658:	ed 91       	ld	r30, X+
    365a:	fc 91       	ld	r31, X
    365c:	02 80       	ldd	r0, Z+2	; 0x02
    365e:	f3 81       	ldd	r31, Z+3	; 0x03
    3660:	e0 2d       	mov	r30, r0
    3662:	6e e2       	ldi	r22, 0x2E	; 46
    3664:	c7 01       	movw	r24, r14
    3666:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3668:	cc 16       	cp	r12, r28
    366a:	dd 06       	cpc	r13, r29
    366c:	31 f7       	brne	.-52     	; 0x363a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    366e:	b4 e1       	ldi	r27, 0x14	; 20
    3670:	ab 0e       	add	r10, r27
    3672:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3674:	66 e0       	ldi	r22, 0x06	; 6
    3676:	c7 01       	movw	r24, r14
    3678:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    367c:	84 e1       	ldi	r24, 0x14	; 20
    367e:	c8 0e       	add	r12, r24
    3680:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3682:	a8 14       	cp	r10, r8
    3684:	b9 04       	cpc	r11, r9
    3686:	08 f4       	brcc	.+2      	; 0x368a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3688:	88 cf       	rjmp	.-240    	; 0x359a <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    368a:	62 e0       	ldi	r22, 0x02	; 2
    368c:	c7 01       	movw	r24, r14
    368e:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
}
    3692:	03 c0       	rjmp	.+6      	; 0x369a <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3694:	c6 2d       	mov	r28, r6
    3696:	d5 2d       	mov	r29, r5
    3698:	9c cf       	rjmp	.-200    	; 0x35d2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    369a:	df 91       	pop	r29
    369c:	cf 91       	pop	r28
    369e:	1f 91       	pop	r17
    36a0:	0f 91       	pop	r16
    36a2:	ff 90       	pop	r15
    36a4:	ef 90       	pop	r14
    36a6:	df 90       	pop	r13
    36a8:	cf 90       	pop	r12
    36aa:	bf 90       	pop	r11
    36ac:	af 90       	pop	r10
    36ae:	9f 90       	pop	r9
    36b0:	8f 90       	pop	r8
    36b2:	7f 90       	pop	r7
    36b4:	6f 90       	pop	r6
    36b6:	5f 90       	pop	r5
    36b8:	08 95       	ret

000036ba <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    36ba:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    36be:	08 95       	ret

000036c0 <_Znaj>:
    36c0:	0e 94 9f 0b 	call	0x173e	; 0x173e <pvPortMalloc>
    36c4:	08 95       	ret

000036c6 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    36c6:	08 95       	ret

000036c8 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29
    36cc:	fc 01       	movw	r30, r24
    36ce:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    36d0:	40 3a       	cpi	r20, 0xA0	; 160
    36d2:	68 e0       	ldi	r22, 0x08	; 8
    36d4:	56 07       	cpc	r21, r22
    36d6:	49 f4       	brne	.+18     	; 0x36ea <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    36d8:	80 e4       	ldi	r24, 0x40	; 64
    36da:	96 e0       	ldi	r25, 0x06	; 6
    36dc:	82 83       	std	Z+2, r24	; 0x02
    36de:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    36e0:	82 e0       	ldi	r24, 0x02	; 2
    36e2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    36e4:	83 e0       	ldi	r24, 0x03	; 3
    36e6:	85 83       	std	Z+5, r24	; 0x05
    36e8:	32 c0       	rjmp	.+100    	; 0x374e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    36ea:	40 3b       	cpi	r20, 0xB0	; 176
    36ec:	78 e0       	ldi	r23, 0x08	; 8
    36ee:	57 07       	cpc	r21, r23
    36f0:	49 f4       	brne	.+18     	; 0x3704 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    36f2:	80 e4       	ldi	r24, 0x40	; 64
    36f4:	96 e0       	ldi	r25, 0x06	; 6
    36f6:	82 83       	std	Z+2, r24	; 0x02
    36f8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    36fa:	86 e0       	ldi	r24, 0x06	; 6
    36fc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    36fe:	87 e0       	ldi	r24, 0x07	; 7
    3700:	85 83       	std	Z+5, r24	; 0x05
    3702:	25 c0       	rjmp	.+74     	; 0x374e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3704:	40 3a       	cpi	r20, 0xA0	; 160
    3706:	89 e0       	ldi	r24, 0x09	; 9
    3708:	58 07       	cpc	r21, r24
    370a:	49 f4       	brne	.+18     	; 0x371e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    370c:	80 e6       	ldi	r24, 0x60	; 96
    370e:	96 e0       	ldi	r25, 0x06	; 6
    3710:	82 83       	std	Z+2, r24	; 0x02
    3712:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3714:	82 e0       	ldi	r24, 0x02	; 2
    3716:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3718:	83 e0       	ldi	r24, 0x03	; 3
    371a:	85 83       	std	Z+5, r24	; 0x05
    371c:	18 c0       	rjmp	.+48     	; 0x374e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    371e:	40 3b       	cpi	r20, 0xB0	; 176
    3720:	69 e0       	ldi	r22, 0x09	; 9
    3722:	56 07       	cpc	r21, r22
    3724:	49 f4       	brne	.+18     	; 0x3738 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3726:	80 e6       	ldi	r24, 0x60	; 96
    3728:	96 e0       	ldi	r25, 0x06	; 6
    372a:	82 83       	std	Z+2, r24	; 0x02
    372c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    372e:	86 e0       	ldi	r24, 0x06	; 6
    3730:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3732:	87 e0       	ldi	r24, 0x07	; 7
    3734:	85 83       	std	Z+5, r24	; 0x05
    3736:	0b c0       	rjmp	.+22     	; 0x374e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3738:	40 3a       	cpi	r20, 0xA0	; 160
    373a:	5a 40       	sbci	r21, 0x0A	; 10
    373c:	41 f4       	brne	.+16     	; 0x374e <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    373e:	80 e8       	ldi	r24, 0x80	; 128
    3740:	96 e0       	ldi	r25, 0x06	; 6
    3742:	82 83       	std	Z+2, r24	; 0x02
    3744:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3746:	82 e0       	ldi	r24, 0x02	; 2
    3748:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    374a:	83 e0       	ldi	r24, 0x03	; 3
    374c:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    374e:	a6 83       	std	Z+6, r26	; 0x06
    3750:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3752:	cd 01       	movw	r24, r26
    3754:	01 96       	adiw	r24, 0x01	; 1
    3756:	80 87       	std	Z+8, r24	; 0x08
    3758:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    375a:	03 96       	adiw	r24, 0x03	; 3
    375c:	82 87       	std	Z+10, r24	; 0x0a
    375e:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3760:	25 81       	ldd	r18, Z+5	; 0x05
    3762:	c2 81       	ldd	r28, Z+2	; 0x02
    3764:	d3 81       	ldd	r29, Z+3	; 0x03
    3766:	4c 81       	ldd	r20, Y+4	; 0x04
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	90 e0       	ldi	r25, 0x00	; 0
    376c:	bc 01       	movw	r22, r24
    376e:	02 c0       	rjmp	.+4      	; 0x3774 <_ZN7base232C1EjP12USART_struct+0xac>
    3770:	66 0f       	add	r22, r22
    3772:	77 1f       	adc	r23, r23
    3774:	2a 95       	dec	r18
    3776:	e2 f7       	brpl	.-8      	; 0x3770 <_ZN7base232C1EjP12USART_struct+0xa8>
    3778:	9b 01       	movw	r18, r22
    377a:	24 2b       	or	r18, r20
    377c:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    377e:	25 81       	ldd	r18, Z+5	; 0x05
    3780:	c2 81       	ldd	r28, Z+2	; 0x02
    3782:	d3 81       	ldd	r29, Z+3	; 0x03
    3784:	48 81       	ld	r20, Y
    3786:	bc 01       	movw	r22, r24
    3788:	02 c0       	rjmp	.+4      	; 0x378e <_ZN7base232C1EjP12USART_struct+0xc6>
    378a:	66 0f       	add	r22, r22
    378c:	77 1f       	adc	r23, r23
    378e:	2a 95       	dec	r18
    3790:	e2 f7       	brpl	.-8      	; 0x378a <_ZN7base232C1EjP12USART_struct+0xc2>
    3792:	9b 01       	movw	r18, r22
    3794:	24 2b       	or	r18, r20
    3796:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3798:	34 81       	ldd	r19, Z+4	; 0x04
    379a:	c2 81       	ldd	r28, Z+2	; 0x02
    379c:	d3 81       	ldd	r29, Z+3	; 0x03
    379e:	28 81       	ld	r18, Y
    37a0:	02 c0       	rjmp	.+4      	; 0x37a6 <_ZN7base232C1EjP12USART_struct+0xde>
    37a2:	88 0f       	add	r24, r24
    37a4:	99 1f       	adc	r25, r25
    37a6:	3a 95       	dec	r19
    37a8:	e2 f7       	brpl	.-8      	; 0x37a2 <_ZN7base232C1EjP12USART_struct+0xda>
    37aa:	80 95       	com	r24
    37ac:	90 95       	com	r25
    37ae:	82 23       	and	r24, r18
    37b0:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    37b2:	80 e1       	ldi	r24, 0x10	; 16
    37b4:	13 96       	adiw	r26, 0x03	; 3
    37b6:	8c 93       	st	X, r24
    37b8:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    37ba:	83 e0       	ldi	r24, 0x03	; 3
    37bc:	15 96       	adiw	r26, 0x05	; 5
    37be:	8c 93       	st	X, r24
    37c0:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    37c2:	80 ef       	ldi	r24, 0xF0	; 240
    37c4:	17 96       	adiw	r26, 0x07	; 7
    37c6:	8c 93       	st	X, r24
    37c8:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    37ca:	81 e2       	ldi	r24, 0x21	; 33
    37cc:	16 96       	adiw	r26, 0x06	; 6
    37ce:	8c 93       	st	X, r24
    37d0:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    37d2:	88 e1       	ldi	r24, 0x18	; 24
    37d4:	14 96       	adiw	r26, 0x04	; 4
    37d6:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    37d8:	80 e8       	ldi	r24, 0x80	; 128
    37da:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    37dc:	80 e4       	ldi	r24, 0x40	; 64
    37de:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    37e0:	80 e2       	ldi	r24, 0x20	; 32
    37e2:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    37e4:	06 80       	ldd	r0, Z+6	; 0x06
    37e6:	f7 81       	ldd	r31, Z+7	; 0x07
    37e8:	e0 2d       	mov	r30, r0
    37ea:	80 81       	ld	r24, Z
    37ec:	80 81       	ld	r24, Z
}
    37ee:	df 91       	pop	r29
    37f0:	cf 91       	pop	r28
    37f2:	08 95       	ret

000037f4 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    37f4:	81 e0       	ldi	r24, 0x01	; 1
    37f6:	08 95       	ret

000037f8 <_ZN8emstream7getcharEv>:
    37f8:	80 e0       	ldi	r24, 0x00	; 0
    37fa:	90 e0       	ldi	r25, 0x00	; 0
    37fc:	08 95       	ret

000037fe <_ZN8emstream14check_for_charEv>:
    37fe:	80 e0       	ldi	r24, 0x00	; 0
    3800:	08 95       	ret

00003802 <_ZN8emstream12transmit_nowEv>:
    3802:	08 95       	ret

00003804 <_ZN8emstream12clear_screenEv>:
    3804:	08 95       	ret

00003806 <_ZN8emstreamC1Ev>:
    3806:	fc 01       	movw	r30, r24
    3808:	87 ed       	ldi	r24, 0xD7	; 215
    380a:	90 e2       	ldi	r25, 0x20	; 32
    380c:	80 83       	st	Z, r24
    380e:	91 83       	std	Z+1, r25	; 0x01
    3810:	8a e0       	ldi	r24, 0x0A	; 10
    3812:	82 83       	std	Z+2, r24	; 0x02
    3814:	13 82       	std	Z+3, r1	; 0x03
    3816:	83 e0       	ldi	r24, 0x03	; 3
    3818:	85 83       	std	Z+5, r24	; 0x05
    381a:	14 82       	std	Z+4, r1	; 0x04
    381c:	16 82       	std	Z+6, r1	; 0x06
    381e:	17 82       	std	Z+7, r1	; 0x07
    3820:	08 95       	ret

00003822 <_ZN8emstream4putsEPKc>:
    3822:	0f 93       	push	r16
    3824:	1f 93       	push	r17
    3826:	cf 93       	push	r28
    3828:	df 93       	push	r29
    382a:	8c 01       	movw	r16, r24
    382c:	fb 01       	movw	r30, r22
    382e:	dc 01       	movw	r26, r24
    3830:	14 96       	adiw	r26, 0x04	; 4
    3832:	8c 91       	ld	r24, X
    3834:	81 11       	cpse	r24, r1
    3836:	04 c0       	rjmp	.+8      	; 0x3840 <_ZN8emstream4putsEPKc+0x1e>
    3838:	60 81       	ld	r22, Z
    383a:	61 11       	cpse	r22, r1
    383c:	17 c0       	rjmp	.+46     	; 0x386c <_ZN8emstream4putsEPKc+0x4a>
    383e:	23 c0       	rjmp	.+70     	; 0x3886 <_ZN8emstream4putsEPKc+0x64>
    3840:	d8 01       	movw	r26, r16
    3842:	14 96       	adiw	r26, 0x04	; 4
    3844:	1c 92       	st	X, r1
    3846:	eb 01       	movw	r28, r22
    3848:	21 96       	adiw	r28, 0x01	; 1
    384a:	64 91       	lpm	r22, Z
    384c:	66 23       	and	r22, r22
    384e:	d9 f0       	breq	.+54     	; 0x3886 <_ZN8emstream4putsEPKc+0x64>
    3850:	d8 01       	movw	r26, r16
    3852:	ed 91       	ld	r30, X+
    3854:	fc 91       	ld	r31, X
    3856:	02 80       	ldd	r0, Z+2	; 0x02
    3858:	f3 81       	ldd	r31, Z+3	; 0x03
    385a:	e0 2d       	mov	r30, r0
    385c:	c8 01       	movw	r24, r16
    385e:	19 95       	eicall
    3860:	fe 01       	movw	r30, r28
    3862:	64 91       	lpm	r22, Z
    3864:	21 96       	adiw	r28, 0x01	; 1
    3866:	61 11       	cpse	r22, r1
    3868:	f3 cf       	rjmp	.-26     	; 0x3850 <_ZN8emstream4putsEPKc+0x2e>
    386a:	0d c0       	rjmp	.+26     	; 0x3886 <_ZN8emstream4putsEPKc+0x64>
    386c:	ef 01       	movw	r28, r30
    386e:	21 96       	adiw	r28, 0x01	; 1
    3870:	d8 01       	movw	r26, r16
    3872:	ed 91       	ld	r30, X+
    3874:	fc 91       	ld	r31, X
    3876:	02 80       	ldd	r0, Z+2	; 0x02
    3878:	f3 81       	ldd	r31, Z+3	; 0x03
    387a:	e0 2d       	mov	r30, r0
    387c:	c8 01       	movw	r24, r16
    387e:	19 95       	eicall
    3880:	69 91       	ld	r22, Y+
    3882:	61 11       	cpse	r22, r1
    3884:	f5 cf       	rjmp	.-22     	; 0x3870 <_ZN8emstream4putsEPKc+0x4e>
    3886:	df 91       	pop	r29
    3888:	cf 91       	pop	r28
    388a:	1f 91       	pop	r17
    388c:	0f 91       	pop	r16
    388e:	08 95       	ret

00003890 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3890:	cf 93       	push	r28
    3892:	df 93       	push	r29
    3894:	ec 01       	movw	r28, r24
	switch (new_manip)
    3896:	86 2f       	mov	r24, r22
    3898:	90 e0       	ldi	r25, 0x00	; 0
    389a:	8b 30       	cpi	r24, 0x0B	; 11
    389c:	91 05       	cpc	r25, r1
    389e:	d8 f5       	brcc	.+118    	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
    38a0:	fc 01       	movw	r30, r24
    38a2:	88 27       	eor	r24, r24
    38a4:	e2 50       	subi	r30, 0x02	; 2
    38a6:	ff 4f       	sbci	r31, 0xFF	; 255
    38a8:	8f 4f       	sbci	r24, 0xFF	; 255
    38aa:	0c 94 ae 23 	jmp	0x475c	; 0x475c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    38ae:	82 e0       	ldi	r24, 0x02	; 2
    38b0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38b2:	31 c0       	rjmp	.+98     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    38b4:	88 e0       	ldi	r24, 0x08	; 8
    38b6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38b8:	2e c0       	rjmp	.+92     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    38ba:	8a e0       	ldi	r24, 0x0A	; 10
    38bc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38be:	2b c0       	rjmp	.+86     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    38c0:	80 e1       	ldi	r24, 0x10	; 16
    38c2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38c4:	28 c0       	rjmp	.+80     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    38c6:	81 e0       	ldi	r24, 0x01	; 1
    38c8:	8b 83       	std	Y+3, r24	; 0x03
			break;
    38ca:	25 c0       	rjmp	.+74     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    38cc:	1b 82       	std	Y+3, r1	; 0x03
			break;
    38ce:	23 c0       	rjmp	.+70     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    38d0:	e8 81       	ld	r30, Y
    38d2:	f9 81       	ldd	r31, Y+1	; 0x01
    38d4:	02 80       	ldd	r0, Z+2	; 0x02
    38d6:	f3 81       	ldd	r31, Z+3	; 0x03
    38d8:	e0 2d       	mov	r30, r0
    38da:	6d e0       	ldi	r22, 0x0D	; 13
    38dc:	ce 01       	movw	r24, r28
    38de:	19 95       	eicall
    38e0:	e8 81       	ld	r30, Y
    38e2:	f9 81       	ldd	r31, Y+1	; 0x01
    38e4:	02 80       	ldd	r0, Z+2	; 0x02
    38e6:	f3 81       	ldd	r31, Z+3	; 0x03
    38e8:	e0 2d       	mov	r30, r0
    38ea:	6a e0       	ldi	r22, 0x0A	; 10
    38ec:	ce 01       	movw	r24, r28
    38ee:	19 95       	eicall
			break;
    38f0:	12 c0       	rjmp	.+36     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    38f2:	e8 81       	ld	r30, Y
    38f4:	f9 81       	ldd	r31, Y+1	; 0x01
    38f6:	02 84       	ldd	r0, Z+10	; 0x0a
    38f8:	f3 85       	ldd	r31, Z+11	; 0x0b
    38fa:	e0 2d       	mov	r30, r0
    38fc:	ce 01       	movw	r24, r28
    38fe:	19 95       	eicall
			break;
    3900:	0a c0       	rjmp	.+20     	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3902:	e8 81       	ld	r30, Y
    3904:	f9 81       	ldd	r31, Y+1	; 0x01
    3906:	00 84       	ldd	r0, Z+8	; 0x08
    3908:	f1 85       	ldd	r31, Z+9	; 0x09
    390a:	e0 2d       	mov	r30, r0
    390c:	ce 01       	movw	r24, r28
    390e:	19 95       	eicall
			break;
    3910:	02 c0       	rjmp	.+4      	; 0x3916 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3912:	81 e0       	ldi	r24, 0x01	; 1
    3914:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3916:	ce 01       	movw	r24, r28
    3918:	df 91       	pop	r29
    391a:	cf 91       	pop	r28
    391c:	08 95       	ret

0000391e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    391e:	ff 92       	push	r15
    3920:	0f 93       	push	r16
    3922:	1f 93       	push	r17
    3924:	cf 93       	push	r28
    3926:	df 93       	push	r29
    3928:	cd b7       	in	r28, 0x3d	; 61
    392a:	de b7       	in	r29, 0x3e	; 62
    392c:	61 97       	sbiw	r28, 0x11	; 17
    392e:	cd bf       	out	0x3d, r28	; 61
    3930:	de bf       	out	0x3e, r29	; 62
    3932:	8c 01       	movw	r16, r24
    3934:	f6 2e       	mov	r15, r22
    3936:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3938:	f8 01       	movw	r30, r16
    393a:	42 81       	ldd	r20, Z+2	; 0x02
    393c:	40 31       	cpi	r20, 0x10	; 16
    393e:	21 f0       	breq	.+8      	; 0x3948 <_ZN8emstreamlsEj+0x2a>
    3940:	48 30       	cpi	r20, 0x08	; 8
    3942:	11 f0       	breq	.+4      	; 0x3948 <_ZN8emstreamlsEj+0x2a>
    3944:	42 30       	cpi	r20, 0x02	; 2
    3946:	41 f4       	brne	.+16     	; 0x3958 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3948:	69 2f       	mov	r22, r25
    394a:	c8 01       	movw	r24, r16
    394c:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    3950:	6f 2d       	mov	r22, r15
    3952:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    3956:	0d c0       	rjmp	.+26     	; 0x3972 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3958:	50 e0       	ldi	r21, 0x00	; 0
    395a:	be 01       	movw	r22, r28
    395c:	6f 5f       	subi	r22, 0xFF	; 255
    395e:	7f 4f       	sbci	r23, 0xFF	; 255
    3960:	8f 2d       	mov	r24, r15
    3962:	0e 94 1d 24 	call	0x483a	; 0x483a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3966:	be 01       	movw	r22, r28
    3968:	6f 5f       	subi	r22, 0xFF	; 255
    396a:	7f 4f       	sbci	r23, 0xFF	; 255
    396c:	c8 01       	movw	r24, r16
    396e:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3972:	c8 01       	movw	r24, r16
    3974:	61 96       	adiw	r28, 0x11	; 17
    3976:	cd bf       	out	0x3d, r28	; 61
    3978:	de bf       	out	0x3e, r29	; 62
    397a:	df 91       	pop	r29
    397c:	cf 91       	pop	r28
    397e:	1f 91       	pop	r17
    3980:	0f 91       	pop	r16
    3982:	ff 90       	pop	r15
    3984:	08 95       	ret

00003986 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3986:	df 92       	push	r13
    3988:	ef 92       	push	r14
    398a:	ff 92       	push	r15
    398c:	0f 93       	push	r16
    398e:	1f 93       	push	r17
    3990:	cf 93       	push	r28
    3992:	df 93       	push	r29
    3994:	cd b7       	in	r28, 0x3d	; 61
    3996:	de b7       	in	r29, 0x3e	; 62
    3998:	a1 97       	sbiw	r28, 0x21	; 33
    399a:	cd bf       	out	0x3d, r28	; 61
    399c:	de bf       	out	0x3e, r29	; 62
    399e:	8c 01       	movw	r16, r24
    39a0:	d4 2e       	mov	r13, r20
    39a2:	e5 2e       	mov	r14, r21
    39a4:	f6 2e       	mov	r15, r22
    39a6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    39a8:	f8 01       	movw	r30, r16
    39aa:	22 81       	ldd	r18, Z+2	; 0x02
    39ac:	20 31       	cpi	r18, 0x10	; 16
    39ae:	21 f0       	breq	.+8      	; 0x39b8 <_ZN8emstreamlsEm+0x32>
    39b0:	28 30       	cpi	r18, 0x08	; 8
    39b2:	11 f0       	breq	.+4      	; 0x39b8 <_ZN8emstreamlsEm+0x32>
    39b4:	22 30       	cpi	r18, 0x02	; 2
    39b6:	71 f4       	brne	.+28     	; 0x39d4 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    39b8:	69 2f       	mov	r22, r25
    39ba:	c8 01       	movw	r24, r16
    39bc:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    39c0:	6f 2d       	mov	r22, r15
    39c2:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    39c6:	6e 2d       	mov	r22, r14
    39c8:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    39cc:	6d 2d       	mov	r22, r13
    39ce:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <_ZN8emstreamlsEh>
    39d2:	0f c0       	rjmp	.+30     	; 0x39f2 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    39d4:	30 e0       	ldi	r19, 0x00	; 0
    39d6:	ae 01       	movw	r20, r28
    39d8:	4f 5f       	subi	r20, 0xFF	; 255
    39da:	5f 4f       	sbci	r21, 0xFF	; 255
    39dc:	6d 2d       	mov	r22, r13
    39de:	7e 2d       	mov	r23, r14
    39e0:	8f 2d       	mov	r24, r15
    39e2:	0e 94 f0 23 	call	0x47e0	; 0x47e0 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    39e6:	be 01       	movw	r22, r28
    39e8:	6f 5f       	subi	r22, 0xFF	; 255
    39ea:	7f 4f       	sbci	r23, 0xFF	; 255
    39ec:	c8 01       	movw	r24, r16
    39ee:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    39f2:	c8 01       	movw	r24, r16
    39f4:	a1 96       	adiw	r28, 0x21	; 33
    39f6:	cd bf       	out	0x3d, r28	; 61
    39f8:	de bf       	out	0x3e, r29	; 62
    39fa:	df 91       	pop	r29
    39fc:	cf 91       	pop	r28
    39fe:	1f 91       	pop	r17
    3a00:	0f 91       	pop	r16
    3a02:	ff 90       	pop	r15
    3a04:	ef 90       	pop	r14
    3a06:	df 90       	pop	r13
    3a08:	08 95       	ret

00003a0a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3a0a:	cf 92       	push	r12
    3a0c:	df 92       	push	r13
    3a0e:	ef 92       	push	r14
    3a10:	ff 92       	push	r15
    3a12:	0f 93       	push	r16
    3a14:	1f 93       	push	r17
    3a16:	cf 93       	push	r28
    3a18:	df 93       	push	r29
    3a1a:	cd b7       	in	r28, 0x3d	; 61
    3a1c:	de b7       	in	r29, 0x3e	; 62
    3a1e:	29 97       	sbiw	r28, 0x09	; 9
    3a20:	cd bf       	out	0x3d, r28	; 61
    3a22:	de bf       	out	0x3e, r29	; 62
    3a24:	8c 01       	movw	r16, r24
    3a26:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3a28:	dc 01       	movw	r26, r24
    3a2a:	13 96       	adiw	r26, 0x03	; 3
    3a2c:	8c 91       	ld	r24, X
    3a2e:	13 97       	sbiw	r26, 0x03	; 3
    3a30:	88 23       	and	r24, r24
    3a32:	41 f0       	breq	.+16     	; 0x3a44 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3a34:	ed 91       	ld	r30, X+
    3a36:	fc 91       	ld	r31, X
    3a38:	02 80       	ldd	r0, Z+2	; 0x02
    3a3a:	f3 81       	ldd	r31, Z+3	; 0x03
    3a3c:	e0 2d       	mov	r30, r0
    3a3e:	c8 01       	movw	r24, r16
    3a40:	19 95       	eicall
    3a42:	56 c0       	rjmp	.+172    	; 0x3af0 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3a44:	f8 01       	movw	r30, r16
    3a46:	42 81       	ldd	r20, Z+2	; 0x02
    3a48:	42 30       	cpi	r20, 0x02	; 2
    3a4a:	19 f5       	brne	.+70     	; 0x3a92 <_ZN8emstreamlsEh+0x88>
    3a4c:	68 94       	set
    3a4e:	cc 24       	eor	r12, r12
    3a50:	c3 f8       	bld	r12, 3
    3a52:	d1 2c       	mov	r13, r1
    3a54:	68 94       	set
    3a56:	ff 24       	eor	r15, r15
    3a58:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3a5a:	8e 2d       	mov	r24, r14
    3a5c:	8f 21       	and	r24, r15
    3a5e:	51 f0       	breq	.+20     	; 0x3a74 <_ZN8emstreamlsEh+0x6a>
    3a60:	d8 01       	movw	r26, r16
    3a62:	ed 91       	ld	r30, X+
    3a64:	fc 91       	ld	r31, X
    3a66:	02 80       	ldd	r0, Z+2	; 0x02
    3a68:	f3 81       	ldd	r31, Z+3	; 0x03
    3a6a:	e0 2d       	mov	r30, r0
    3a6c:	61 e3       	ldi	r22, 0x31	; 49
    3a6e:	c8 01       	movw	r24, r16
    3a70:	19 95       	eicall
    3a72:	09 c0       	rjmp	.+18     	; 0x3a86 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3a74:	d8 01       	movw	r26, r16
    3a76:	ed 91       	ld	r30, X+
    3a78:	fc 91       	ld	r31, X
    3a7a:	02 80       	ldd	r0, Z+2	; 0x02
    3a7c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a7e:	e0 2d       	mov	r30, r0
    3a80:	60 e3       	ldi	r22, 0x30	; 48
    3a82:	c8 01       	movw	r24, r16
    3a84:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3a86:	f6 94       	lsr	r15
    3a88:	b1 e0       	ldi	r27, 0x01	; 1
    3a8a:	cb 1a       	sub	r12, r27
    3a8c:	d1 08       	sbc	r13, r1
    3a8e:	29 f7       	brne	.-54     	; 0x3a5a <_ZN8emstreamlsEh+0x50>
    3a90:	2f c0       	rjmp	.+94     	; 0x3af0 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3a92:	40 31       	cpi	r20, 0x10	; 16
    3a94:	f9 f4       	brne	.+62     	; 0x3ad4 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3a96:	62 95       	swap	r22
    3a98:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3a9a:	01 90       	ld	r0, Z+
    3a9c:	f0 81       	ld	r31, Z
    3a9e:	e0 2d       	mov	r30, r0
    3aa0:	02 80       	ldd	r0, Z+2	; 0x02
    3aa2:	f3 81       	ldd	r31, Z+3	; 0x03
    3aa4:	e0 2d       	mov	r30, r0
    3aa6:	6a 30       	cpi	r22, 0x0A	; 10
    3aa8:	10 f0       	brcs	.+4      	; 0x3aae <_ZN8emstreamlsEh+0xa4>
    3aaa:	69 5c       	subi	r22, 0xC9	; 201
    3aac:	01 c0       	rjmp	.+2      	; 0x3ab0 <_ZN8emstreamlsEh+0xa6>
    3aae:	60 5d       	subi	r22, 0xD0	; 208
    3ab0:	c8 01       	movw	r24, r16
    3ab2:	19 95       	eicall
		temp_char = num & 0x0F;
    3ab4:	6e 2d       	mov	r22, r14
    3ab6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3ab8:	d8 01       	movw	r26, r16
    3aba:	ed 91       	ld	r30, X+
    3abc:	fc 91       	ld	r31, X
    3abe:	02 80       	ldd	r0, Z+2	; 0x02
    3ac0:	f3 81       	ldd	r31, Z+3	; 0x03
    3ac2:	e0 2d       	mov	r30, r0
    3ac4:	6a 30       	cpi	r22, 0x0A	; 10
    3ac6:	10 f0       	brcs	.+4      	; 0x3acc <_ZN8emstreamlsEh+0xc2>
    3ac8:	69 5c       	subi	r22, 0xC9	; 201
    3aca:	01 c0       	rjmp	.+2      	; 0x3ace <_ZN8emstreamlsEh+0xc4>
    3acc:	60 5d       	subi	r22, 0xD0	; 208
    3ace:	c8 01       	movw	r24, r16
    3ad0:	19 95       	eicall
    3ad2:	0e c0       	rjmp	.+28     	; 0x3af0 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3ad4:	50 e0       	ldi	r21, 0x00	; 0
    3ad6:	be 01       	movw	r22, r28
    3ad8:	6f 5f       	subi	r22, 0xFF	; 255
    3ada:	7f 4f       	sbci	r23, 0xFF	; 255
    3adc:	8e 2d       	mov	r24, r14
    3ade:	90 e0       	ldi	r25, 0x00	; 0
    3ae0:	0e 94 1d 24 	call	0x483a	; 0x483a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3ae4:	be 01       	movw	r22, r28
    3ae6:	6f 5f       	subi	r22, 0xFF	; 255
    3ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aea:	c8 01       	movw	r24, r16
    3aec:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3af0:	c8 01       	movw	r24, r16
    3af2:	29 96       	adiw	r28, 0x09	; 9
    3af4:	cd bf       	out	0x3d, r28	; 61
    3af6:	de bf       	out	0x3e, r29	; 62
    3af8:	df 91       	pop	r29
    3afa:	cf 91       	pop	r28
    3afc:	1f 91       	pop	r17
    3afe:	0f 91       	pop	r16
    3b00:	ff 90       	pop	r15
    3b02:	ef 90       	pop	r14
    3b04:	df 90       	pop	r13
    3b06:	cf 90       	pop	r12
    3b08:	08 95       	ret

00003b0a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3b0a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b0c:	50 96       	adiw	r26, 0x10	; 16
    3b0e:	ed 91       	ld	r30, X+
    3b10:	fc 91       	ld	r31, X
    3b12:	51 97       	sbiw	r26, 0x11	; 17
    3b14:	80 81       	ld	r24, Z
    3b16:	54 96       	adiw	r26, 0x14	; 20
    3b18:	4c 91       	ld	r20, X
    3b1a:	54 97       	sbiw	r26, 0x14	; 20
    3b1c:	84 23       	and	r24, r20
    3b1e:	29 f0       	breq	.+10     	; 0x3b2a <_ZN5rs2327putcharEc+0x20>
    3b20:	09 c0       	rjmp	.+18     	; 0x3b34 <_ZN5rs2327putcharEc+0x2a>
    3b22:	21 50       	subi	r18, 0x01	; 1
    3b24:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3b26:	19 f4       	brne	.+6      	; 0x3b2e <_ZN5rs2327putcharEc+0x24>
    3b28:	12 c0       	rjmp	.+36     	; 0x3b4e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b2a:	21 e2       	ldi	r18, 0x21	; 33
    3b2c:	3e e4       	ldi	r19, 0x4E	; 78
    3b2e:	90 81       	ld	r25, Z
    3b30:	94 23       	and	r25, r20
    3b32:	b9 f3       	breq	.-18     	; 0x3b22 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3b34:	90 81       	ld	r25, Z
    3b36:	56 96       	adiw	r26, 0x16	; 22
    3b38:	8c 91       	ld	r24, X
    3b3a:	56 97       	sbiw	r26, 0x16	; 22
    3b3c:	89 2b       	or	r24, r25
    3b3e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3b40:	1e 96       	adiw	r26, 0x0e	; 14
    3b42:	ed 91       	ld	r30, X+
    3b44:	fc 91       	ld	r31, X
    3b46:	1f 97       	sbiw	r26, 0x0f	; 15
    3b48:	60 83       	st	Z, r22
	return (true);
    3b4a:	81 e0       	ldi	r24, 0x01	; 1
    3b4c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3b4e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3b50:	08 95       	ret

00003b52 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3b52:	cf 93       	push	r28
    3b54:	df 93       	push	r29
    3b56:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3b58:	c1 8d       	ldd	r28, Z+25	; 0x19
    3b5a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3b5c:	28 81       	ld	r18, Y
    3b5e:	39 81       	ldd	r19, Y+1	; 0x01
    3b60:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3b62:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3b64:	4d 91       	ld	r20, X+
    3b66:	5c 91       	ld	r21, X
    3b68:	24 17       	cp	r18, r20
    3b6a:	35 07       	cpc	r19, r21
    3b6c:	e9 f3       	breq	.-6      	; 0x3b68 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3b6e:	a7 89       	ldd	r26, Z+23	; 0x17
    3b70:	b0 8d       	ldd	r27, Z+24	; 0x18
    3b72:	0d 90       	ld	r0, X+
    3b74:	bc 91       	ld	r27, X
    3b76:	a0 2d       	mov	r26, r0
    3b78:	a2 0f       	add	r26, r18
    3b7a:	b3 1f       	adc	r27, r19
    3b7c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3b7e:	2f 5f       	subi	r18, 0xFF	; 255
    3b80:	3f 4f       	sbci	r19, 0xFF	; 255
    3b82:	28 83       	st	Y, r18
    3b84:	39 83       	std	Y+1, r19	; 0x01
    3b86:	24 36       	cpi	r18, 0x64	; 100
    3b88:	31 05       	cpc	r19, r1
    3b8a:	28 f0       	brcs	.+10     	; 0x3b96 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3b8c:	01 8c       	ldd	r0, Z+25	; 0x19
    3b8e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3b90:	e0 2d       	mov	r30, r0
    3b92:	10 82       	st	Z, r1
    3b94:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3b96:	90 e0       	ldi	r25, 0x00	; 0
    3b98:	df 91       	pop	r29
    3b9a:	cf 91       	pop	r28
    3b9c:	08 95       	ret

00003b9e <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3ba2:	ec 01       	movw	r28, r24
    3ba4:	a9 8d       	ldd	r26, Y+25	; 0x19
    3ba6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3ba8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3baa:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3bac:	81 e0       	ldi	r24, 0x01	; 1
    3bae:	4d 91       	ld	r20, X+
    3bb0:	5c 91       	ld	r21, X
    3bb2:	20 81       	ld	r18, Z
    3bb4:	31 81       	ldd	r19, Z+1	; 0x01
    3bb6:	42 17       	cp	r20, r18
    3bb8:	53 07       	cpc	r21, r19
    3bba:	09 f4       	brne	.+2      	; 0x3bbe <_ZN5rs23214check_for_charEv+0x20>
    3bbc:	80 e0       	ldi	r24, 0x00	; 0
}
    3bbe:	df 91       	pop	r29
    3bc0:	cf 91       	pop	r28
    3bc2:	08 95       	ret

00003bc4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3bc4:	dc 01       	movw	r26, r24
    3bc6:	ed 91       	ld	r30, X+
    3bc8:	fc 91       	ld	r31, X
    3bca:	02 80       	ldd	r0, Z+2	; 0x02
    3bcc:	f3 81       	ldd	r31, Z+3	; 0x03
    3bce:	e0 2d       	mov	r30, r0
    3bd0:	6c e0       	ldi	r22, 0x0C	; 12
    3bd2:	19 95       	eicall
    3bd4:	08 95       	ret

00003bd6 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3bd6:	ef 92       	push	r14
    3bd8:	ff 92       	push	r15
    3bda:	0f 93       	push	r16
    3bdc:	1f 93       	push	r17
    3bde:	cf 93       	push	r28
    3be0:	df 93       	push	r29
    3be2:	ec 01       	movw	r28, r24
    3be4:	7b 01       	movw	r14, r22
    3be6:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3be8:	0e 94 03 1c 	call	0x3806	; 0x3806 <_ZN8emstreamC1Ev>
    3bec:	a8 01       	movw	r20, r16
    3bee:	b7 01       	movw	r22, r14
    3bf0:	ce 01       	movw	r24, r28
    3bf2:	08 96       	adiw	r24, 0x08	; 8
    3bf4:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <_ZN7base232C1EjP12USART_struct>
    3bf8:	87 ee       	ldi	r24, 0xE7	; 231
    3bfa:	90 e2       	ldi	r25, 0x20	; 32
    3bfc:	88 83       	st	Y, r24
    3bfe:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3c00:	00 3a       	cpi	r16, 0xA0	; 160
    3c02:	88 e0       	ldi	r24, 0x08	; 8
    3c04:	18 07       	cpc	r17, r24
    3c06:	69 f4       	brne	.+26     	; 0x3c22 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3c08:	80 ef       	ldi	r24, 0xF0	; 240
    3c0a:	91 e3       	ldi	r25, 0x31	; 49
    3c0c:	8f 8b       	std	Y+23, r24	; 0x17
    3c0e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3c10:	86 ee       	ldi	r24, 0xE6	; 230
    3c12:	91 e3       	ldi	r25, 0x31	; 49
    3c14:	89 8f       	std	Y+25, r24	; 0x19
    3c16:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3c18:	8c ed       	ldi	r24, 0xDC	; 220
    3c1a:	91 e3       	ldi	r25, 0x31	; 49
    3c1c:	8b 8f       	std	Y+27, r24	; 0x1b
    3c1e:	9c 8f       	std	Y+28, r25	; 0x1c
    3c20:	42 c0       	rjmp	.+132    	; 0x3ca6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3c22:	00 3b       	cpi	r16, 0xB0	; 176
    3c24:	e8 e0       	ldi	r30, 0x08	; 8
    3c26:	1e 07       	cpc	r17, r30
    3c28:	69 f4       	brne	.+26     	; 0x3c44 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3c2a:	8e ee       	ldi	r24, 0xEE	; 238
    3c2c:	91 e3       	ldi	r25, 0x31	; 49
    3c2e:	8f 8b       	std	Y+23, r24	; 0x17
    3c30:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3c32:	84 ee       	ldi	r24, 0xE4	; 228
    3c34:	91 e3       	ldi	r25, 0x31	; 49
    3c36:	89 8f       	std	Y+25, r24	; 0x19
    3c38:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3c3a:	8a ed       	ldi	r24, 0xDA	; 218
    3c3c:	91 e3       	ldi	r25, 0x31	; 49
    3c3e:	8b 8f       	std	Y+27, r24	; 0x1b
    3c40:	9c 8f       	std	Y+28, r25	; 0x1c
    3c42:	31 c0       	rjmp	.+98     	; 0x3ca6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3c44:	00 3a       	cpi	r16, 0xA0	; 160
    3c46:	f9 e0       	ldi	r31, 0x09	; 9
    3c48:	1f 07       	cpc	r17, r31
    3c4a:	69 f4       	brne	.+26     	; 0x3c66 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3c4c:	8c ee       	ldi	r24, 0xEC	; 236
    3c4e:	91 e3       	ldi	r25, 0x31	; 49
    3c50:	8f 8b       	std	Y+23, r24	; 0x17
    3c52:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3c54:	82 ee       	ldi	r24, 0xE2	; 226
    3c56:	91 e3       	ldi	r25, 0x31	; 49
    3c58:	89 8f       	std	Y+25, r24	; 0x19
    3c5a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3c5c:	88 ed       	ldi	r24, 0xD8	; 216
    3c5e:	91 e3       	ldi	r25, 0x31	; 49
    3c60:	8b 8f       	std	Y+27, r24	; 0x1b
    3c62:	9c 8f       	std	Y+28, r25	; 0x1c
    3c64:	20 c0       	rjmp	.+64     	; 0x3ca6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3c66:	00 3b       	cpi	r16, 0xB0	; 176
    3c68:	89 e0       	ldi	r24, 0x09	; 9
    3c6a:	18 07       	cpc	r17, r24
    3c6c:	69 f4       	brne	.+26     	; 0x3c88 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3c6e:	8a ee       	ldi	r24, 0xEA	; 234
    3c70:	91 e3       	ldi	r25, 0x31	; 49
    3c72:	8f 8b       	std	Y+23, r24	; 0x17
    3c74:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3c76:	80 ee       	ldi	r24, 0xE0	; 224
    3c78:	91 e3       	ldi	r25, 0x31	; 49
    3c7a:	89 8f       	std	Y+25, r24	; 0x19
    3c7c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3c7e:	86 ed       	ldi	r24, 0xD6	; 214
    3c80:	91 e3       	ldi	r25, 0x31	; 49
    3c82:	8b 8f       	std	Y+27, r24	; 0x1b
    3c84:	9c 8f       	std	Y+28, r25	; 0x1c
    3c86:	0f c0       	rjmp	.+30     	; 0x3ca6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3c88:	00 3a       	cpi	r16, 0xA0	; 160
    3c8a:	1a 40       	sbci	r17, 0x0A	; 10
    3c8c:	61 f4       	brne	.+24     	; 0x3ca6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3c8e:	88 ee       	ldi	r24, 0xE8	; 232
    3c90:	91 e3       	ldi	r25, 0x31	; 49
    3c92:	8f 8b       	std	Y+23, r24	; 0x17
    3c94:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3c96:	8e ed       	ldi	r24, 0xDE	; 222
    3c98:	91 e3       	ldi	r25, 0x31	; 49
    3c9a:	89 8f       	std	Y+25, r24	; 0x19
    3c9c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3c9e:	84 ed       	ldi	r24, 0xD4	; 212
    3ca0:	91 e3       	ldi	r25, 0x31	; 49
    3ca2:	8b 8f       	std	Y+27, r24	; 0x1b
    3ca4:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3ca6:	0f 89       	ldd	r16, Y+23	; 0x17
    3ca8:	18 8d       	ldd	r17, Y+24	; 0x18
    3caa:	84 e6       	ldi	r24, 0x64	; 100
    3cac:	90 e0       	ldi	r25, 0x00	; 0
    3cae:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <_Znaj>
    3cb2:	f8 01       	movw	r30, r16
    3cb4:	80 83       	st	Z, r24
    3cb6:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3cb8:	e9 8d       	ldd	r30, Y+25	; 0x19
    3cba:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3cbc:	10 82       	st	Z, r1
    3cbe:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3cc0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3cc2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3cc4:	10 82       	st	Z, r1
    3cc6:	11 82       	std	Z+1, r1	; 0x01
}
    3cc8:	df 91       	pop	r29
    3cca:	cf 91       	pop	r28
    3ccc:	1f 91       	pop	r17
    3cce:	0f 91       	pop	r16
    3cd0:	ff 90       	pop	r15
    3cd2:	ef 90       	pop	r14
    3cd4:	08 95       	ret

00003cd6 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3cd6:	1f 92       	push	r1
    3cd8:	0f 92       	push	r0
    3cda:	0f b6       	in	r0, 0x3f	; 63
    3cdc:	0f 92       	push	r0
    3cde:	11 24       	eor	r1, r1
    3ce0:	08 b6       	in	r0, 0x38	; 56
    3ce2:	0f 92       	push	r0
    3ce4:	18 be       	out	0x38, r1	; 56
    3ce6:	0b b6       	in	r0, 0x3b	; 59
    3ce8:	0f 92       	push	r0
    3cea:	1b be       	out	0x3b, r1	; 59
    3cec:	2f 93       	push	r18
    3cee:	3f 93       	push	r19
    3cf0:	8f 93       	push	r24
    3cf2:	9f 93       	push	r25
    3cf4:	ef 93       	push	r30
    3cf6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3cf8:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3cfc:	e0 91 f0 31 	lds	r30, 0x31F0	; 0x8031f0 <rcvC0_buffer>
    3d00:	f0 91 f1 31 	lds	r31, 0x31F1	; 0x8031f1 <rcvC0_buffer+0x1>
    3d04:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3d08:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3d0c:	e8 0f       	add	r30, r24
    3d0e:	f9 1f       	adc	r31, r25
    3d10:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3d12:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3d16:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3d1a:	01 96       	adiw	r24, 0x01	; 1
    3d1c:	84 36       	cpi	r24, 0x64	; 100
    3d1e:	91 05       	cpc	r25, r1
    3d20:	60 f4       	brcc	.+24     	; 0x3d3a <__vector_25+0x64>
    3d22:	80 93 dc 31 	sts	0x31DC, r24	; 0x8031dc <rcvC0_write_index>
    3d26:	90 93 dd 31 	sts	0x31DD, r25	; 0x8031dd <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d2a:	20 91 e6 31 	lds	r18, 0x31E6	; 0x8031e6 <rcvC0_read_index>
    3d2e:	30 91 e7 31 	lds	r19, 0x31E7	; 0x8031e7 <rcvC0_read_index+0x1>
    3d32:	82 17       	cp	r24, r18
    3d34:	93 07       	cpc	r25, r19
    3d36:	f1 f4       	brne	.+60     	; 0x3d74 <__vector_25+0x9e>
    3d38:	0c c0       	rjmp	.+24     	; 0x3d52 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3d3a:	10 92 dc 31 	sts	0x31DC, r1	; 0x8031dc <rcvC0_write_index>
    3d3e:	10 92 dd 31 	sts	0x31DD, r1	; 0x8031dd <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d42:	80 91 e6 31 	lds	r24, 0x31E6	; 0x8031e6 <rcvC0_read_index>
    3d46:	90 91 e7 31 	lds	r25, 0x31E7	; 0x8031e7 <rcvC0_read_index+0x1>
    3d4a:	18 16       	cp	r1, r24
    3d4c:	19 06       	cpc	r1, r25
    3d4e:	91 f4       	brne	.+36     	; 0x3d74 <__vector_25+0x9e>
    3d50:	0e c0       	rjmp	.+28     	; 0x3d6e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d52:	01 96       	adiw	r24, 0x01	; 1
    3d54:	84 36       	cpi	r24, 0x64	; 100
    3d56:	91 05       	cpc	r25, r1
    3d58:	28 f4       	brcc	.+10     	; 0x3d64 <__vector_25+0x8e>
    3d5a:	80 93 e6 31 	sts	0x31E6, r24	; 0x8031e6 <rcvC0_read_index>
    3d5e:	90 93 e7 31 	sts	0x31E7, r25	; 0x8031e7 <rcvC0_read_index+0x1>
    3d62:	08 c0       	rjmp	.+16     	; 0x3d74 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3d64:	10 92 e6 31 	sts	0x31E6, r1	; 0x8031e6 <rcvC0_read_index>
    3d68:	10 92 e7 31 	sts	0x31E7, r1	; 0x8031e7 <rcvC0_read_index+0x1>
}
    3d6c:	03 c0       	rjmp	.+6      	; 0x3d74 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d6e:	81 e0       	ldi	r24, 0x01	; 1
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	f3 cf       	rjmp	.-26     	; 0x3d5a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3d74:	ff 91       	pop	r31
    3d76:	ef 91       	pop	r30
    3d78:	9f 91       	pop	r25
    3d7a:	8f 91       	pop	r24
    3d7c:	3f 91       	pop	r19
    3d7e:	2f 91       	pop	r18
    3d80:	0f 90       	pop	r0
    3d82:	0b be       	out	0x3b, r0	; 59
    3d84:	0f 90       	pop	r0
    3d86:	08 be       	out	0x38, r0	; 56
    3d88:	0f 90       	pop	r0
    3d8a:	0f be       	out	0x3f, r0	; 63
    3d8c:	0f 90       	pop	r0
    3d8e:	1f 90       	pop	r1
    3d90:	18 95       	reti

00003d92 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3d92:	1f 92       	push	r1
    3d94:	0f 92       	push	r0
    3d96:	0f b6       	in	r0, 0x3f	; 63
    3d98:	0f 92       	push	r0
    3d9a:	11 24       	eor	r1, r1
    3d9c:	08 b6       	in	r0, 0x38	; 56
    3d9e:	0f 92       	push	r0
    3da0:	18 be       	out	0x38, r1	; 56
    3da2:	0b b6       	in	r0, 0x3b	; 59
    3da4:	0f 92       	push	r0
    3da6:	1b be       	out	0x3b, r1	; 59
    3da8:	2f 93       	push	r18
    3daa:	3f 93       	push	r19
    3dac:	8f 93       	push	r24
    3dae:	9f 93       	push	r25
    3db0:	ef 93       	push	r30
    3db2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3db4:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3db8:	e0 91 ee 31 	lds	r30, 0x31EE	; 0x8031ee <rcvC1_buffer>
    3dbc:	f0 91 ef 31 	lds	r31, 0x31EF	; 0x8031ef <rcvC1_buffer+0x1>
    3dc0:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <rcvC1_write_index>
    3dc4:	90 91 db 31 	lds	r25, 0x31DB	; 0x8031db <rcvC1_write_index+0x1>
    3dc8:	e8 0f       	add	r30, r24
    3dca:	f9 1f       	adc	r31, r25
    3dcc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3dce:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <rcvC1_write_index>
    3dd2:	90 91 db 31 	lds	r25, 0x31DB	; 0x8031db <rcvC1_write_index+0x1>
    3dd6:	01 96       	adiw	r24, 0x01	; 1
    3dd8:	84 36       	cpi	r24, 0x64	; 100
    3dda:	91 05       	cpc	r25, r1
    3ddc:	60 f4       	brcc	.+24     	; 0x3df6 <__vector_28+0x64>
    3dde:	80 93 da 31 	sts	0x31DA, r24	; 0x8031da <rcvC1_write_index>
    3de2:	90 93 db 31 	sts	0x31DB, r25	; 0x8031db <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3de6:	20 91 e4 31 	lds	r18, 0x31E4	; 0x8031e4 <rcvC1_read_index>
    3dea:	30 91 e5 31 	lds	r19, 0x31E5	; 0x8031e5 <rcvC1_read_index+0x1>
    3dee:	82 17       	cp	r24, r18
    3df0:	93 07       	cpc	r25, r19
    3df2:	f1 f4       	brne	.+60     	; 0x3e30 <__vector_28+0x9e>
    3df4:	0c c0       	rjmp	.+24     	; 0x3e0e <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3df6:	10 92 da 31 	sts	0x31DA, r1	; 0x8031da <rcvC1_write_index>
    3dfa:	10 92 db 31 	sts	0x31DB, r1	; 0x8031db <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3dfe:	80 91 e4 31 	lds	r24, 0x31E4	; 0x8031e4 <rcvC1_read_index>
    3e02:	90 91 e5 31 	lds	r25, 0x31E5	; 0x8031e5 <rcvC1_read_index+0x1>
    3e06:	18 16       	cp	r1, r24
    3e08:	19 06       	cpc	r1, r25
    3e0a:	91 f4       	brne	.+36     	; 0x3e30 <__vector_28+0x9e>
    3e0c:	0e c0       	rjmp	.+28     	; 0x3e2a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e0e:	01 96       	adiw	r24, 0x01	; 1
    3e10:	84 36       	cpi	r24, 0x64	; 100
    3e12:	91 05       	cpc	r25, r1
    3e14:	28 f4       	brcc	.+10     	; 0x3e20 <__vector_28+0x8e>
    3e16:	80 93 e4 31 	sts	0x31E4, r24	; 0x8031e4 <rcvC1_read_index>
    3e1a:	90 93 e5 31 	sts	0x31E5, r25	; 0x8031e5 <rcvC1_read_index+0x1>
    3e1e:	08 c0       	rjmp	.+16     	; 0x3e30 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3e20:	10 92 e4 31 	sts	0x31E4, r1	; 0x8031e4 <rcvC1_read_index>
    3e24:	10 92 e5 31 	sts	0x31E5, r1	; 0x8031e5 <rcvC1_read_index+0x1>
}
    3e28:	03 c0       	rjmp	.+6      	; 0x3e30 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e2a:	81 e0       	ldi	r24, 0x01	; 1
    3e2c:	90 e0       	ldi	r25, 0x00	; 0
    3e2e:	f3 cf       	rjmp	.-26     	; 0x3e16 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3e30:	ff 91       	pop	r31
    3e32:	ef 91       	pop	r30
    3e34:	9f 91       	pop	r25
    3e36:	8f 91       	pop	r24
    3e38:	3f 91       	pop	r19
    3e3a:	2f 91       	pop	r18
    3e3c:	0f 90       	pop	r0
    3e3e:	0b be       	out	0x3b, r0	; 59
    3e40:	0f 90       	pop	r0
    3e42:	08 be       	out	0x38, r0	; 56
    3e44:	0f 90       	pop	r0
    3e46:	0f be       	out	0x3f, r0	; 63
    3e48:	0f 90       	pop	r0
    3e4a:	1f 90       	pop	r1
    3e4c:	18 95       	reti

00003e4e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3e4e:	1f 92       	push	r1
    3e50:	0f 92       	push	r0
    3e52:	0f b6       	in	r0, 0x3f	; 63
    3e54:	0f 92       	push	r0
    3e56:	11 24       	eor	r1, r1
    3e58:	08 b6       	in	r0, 0x38	; 56
    3e5a:	0f 92       	push	r0
    3e5c:	18 be       	out	0x38, r1	; 56
    3e5e:	0b b6       	in	r0, 0x3b	; 59
    3e60:	0f 92       	push	r0
    3e62:	1b be       	out	0x3b, r1	; 59
    3e64:	2f 93       	push	r18
    3e66:	3f 93       	push	r19
    3e68:	8f 93       	push	r24
    3e6a:	9f 93       	push	r25
    3e6c:	ef 93       	push	r30
    3e6e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3e70:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3e74:	e0 91 ec 31 	lds	r30, 0x31EC	; 0x8031ec <rcvD0_buffer>
    3e78:	f0 91 ed 31 	lds	r31, 0x31ED	; 0x8031ed <rcvD0_buffer+0x1>
    3e7c:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3e80:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3e84:	e8 0f       	add	r30, r24
    3e86:	f9 1f       	adc	r31, r25
    3e88:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3e8a:	80 91 d8 31 	lds	r24, 0x31D8	; 0x8031d8 <rcvD0_write_index>
    3e8e:	90 91 d9 31 	lds	r25, 0x31D9	; 0x8031d9 <rcvD0_write_index+0x1>
    3e92:	01 96       	adiw	r24, 0x01	; 1
    3e94:	84 36       	cpi	r24, 0x64	; 100
    3e96:	91 05       	cpc	r25, r1
    3e98:	60 f4       	brcc	.+24     	; 0x3eb2 <__vector_88+0x64>
    3e9a:	80 93 d8 31 	sts	0x31D8, r24	; 0x8031d8 <rcvD0_write_index>
    3e9e:	90 93 d9 31 	sts	0x31D9, r25	; 0x8031d9 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3ea2:	20 91 e2 31 	lds	r18, 0x31E2	; 0x8031e2 <rcvD0_read_index>
    3ea6:	30 91 e3 31 	lds	r19, 0x31E3	; 0x8031e3 <rcvD0_read_index+0x1>
    3eaa:	82 17       	cp	r24, r18
    3eac:	93 07       	cpc	r25, r19
    3eae:	f1 f4       	brne	.+60     	; 0x3eec <__vector_88+0x9e>
    3eb0:	0c c0       	rjmp	.+24     	; 0x3eca <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3eb2:	10 92 d8 31 	sts	0x31D8, r1	; 0x8031d8 <rcvD0_write_index>
    3eb6:	10 92 d9 31 	sts	0x31D9, r1	; 0x8031d9 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3eba:	80 91 e2 31 	lds	r24, 0x31E2	; 0x8031e2 <rcvD0_read_index>
    3ebe:	90 91 e3 31 	lds	r25, 0x31E3	; 0x8031e3 <rcvD0_read_index+0x1>
    3ec2:	18 16       	cp	r1, r24
    3ec4:	19 06       	cpc	r1, r25
    3ec6:	91 f4       	brne	.+36     	; 0x3eec <__vector_88+0x9e>
    3ec8:	0e c0       	rjmp	.+28     	; 0x3ee6 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3eca:	01 96       	adiw	r24, 0x01	; 1
    3ecc:	84 36       	cpi	r24, 0x64	; 100
    3ece:	91 05       	cpc	r25, r1
    3ed0:	28 f4       	brcc	.+10     	; 0x3edc <__vector_88+0x8e>
    3ed2:	80 93 e2 31 	sts	0x31E2, r24	; 0x8031e2 <rcvD0_read_index>
    3ed6:	90 93 e3 31 	sts	0x31E3, r25	; 0x8031e3 <rcvD0_read_index+0x1>
    3eda:	08 c0       	rjmp	.+16     	; 0x3eec <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3edc:	10 92 e2 31 	sts	0x31E2, r1	; 0x8031e2 <rcvD0_read_index>
    3ee0:	10 92 e3 31 	sts	0x31E3, r1	; 0x8031e3 <rcvD0_read_index+0x1>
}
    3ee4:	03 c0       	rjmp	.+6      	; 0x3eec <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ee6:	81 e0       	ldi	r24, 0x01	; 1
    3ee8:	90 e0       	ldi	r25, 0x00	; 0
    3eea:	f3 cf       	rjmp	.-26     	; 0x3ed2 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3eec:	ff 91       	pop	r31
    3eee:	ef 91       	pop	r30
    3ef0:	9f 91       	pop	r25
    3ef2:	8f 91       	pop	r24
    3ef4:	3f 91       	pop	r19
    3ef6:	2f 91       	pop	r18
    3ef8:	0f 90       	pop	r0
    3efa:	0b be       	out	0x3b, r0	; 59
    3efc:	0f 90       	pop	r0
    3efe:	08 be       	out	0x38, r0	; 56
    3f00:	0f 90       	pop	r0
    3f02:	0f be       	out	0x3f, r0	; 63
    3f04:	0f 90       	pop	r0
    3f06:	1f 90       	pop	r1
    3f08:	18 95       	reti

00003f0a <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3f0a:	1f 92       	push	r1
    3f0c:	0f 92       	push	r0
    3f0e:	0f b6       	in	r0, 0x3f	; 63
    3f10:	0f 92       	push	r0
    3f12:	11 24       	eor	r1, r1
    3f14:	08 b6       	in	r0, 0x38	; 56
    3f16:	0f 92       	push	r0
    3f18:	18 be       	out	0x38, r1	; 56
    3f1a:	0b b6       	in	r0, 0x3b	; 59
    3f1c:	0f 92       	push	r0
    3f1e:	1b be       	out	0x3b, r1	; 59
    3f20:	2f 93       	push	r18
    3f22:	3f 93       	push	r19
    3f24:	8f 93       	push	r24
    3f26:	9f 93       	push	r25
    3f28:	ef 93       	push	r30
    3f2a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3f2c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3f30:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <rcvD1_buffer>
    3f34:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <rcvD1_buffer+0x1>
    3f38:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <rcvD1_write_index>
    3f3c:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <rcvD1_write_index+0x1>
    3f40:	e8 0f       	add	r30, r24
    3f42:	f9 1f       	adc	r31, r25
    3f44:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3f46:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <rcvD1_write_index>
    3f4a:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <rcvD1_write_index+0x1>
    3f4e:	01 96       	adiw	r24, 0x01	; 1
    3f50:	84 36       	cpi	r24, 0x64	; 100
    3f52:	91 05       	cpc	r25, r1
    3f54:	60 f4       	brcc	.+24     	; 0x3f6e <__vector_91+0x64>
    3f56:	80 93 d6 31 	sts	0x31D6, r24	; 0x8031d6 <rcvD1_write_index>
    3f5a:	90 93 d7 31 	sts	0x31D7, r25	; 0x8031d7 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3f5e:	20 91 e0 31 	lds	r18, 0x31E0	; 0x8031e0 <rcvD1_read_index>
    3f62:	30 91 e1 31 	lds	r19, 0x31E1	; 0x8031e1 <rcvD1_read_index+0x1>
    3f66:	82 17       	cp	r24, r18
    3f68:	93 07       	cpc	r25, r19
    3f6a:	f1 f4       	brne	.+60     	; 0x3fa8 <__vector_91+0x9e>
    3f6c:	0c c0       	rjmp	.+24     	; 0x3f86 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3f6e:	10 92 d6 31 	sts	0x31D6, r1	; 0x8031d6 <rcvD1_write_index>
    3f72:	10 92 d7 31 	sts	0x31D7, r1	; 0x8031d7 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3f76:	80 91 e0 31 	lds	r24, 0x31E0	; 0x8031e0 <rcvD1_read_index>
    3f7a:	90 91 e1 31 	lds	r25, 0x31E1	; 0x8031e1 <rcvD1_read_index+0x1>
    3f7e:	18 16       	cp	r1, r24
    3f80:	19 06       	cpc	r1, r25
    3f82:	91 f4       	brne	.+36     	; 0x3fa8 <__vector_91+0x9e>
    3f84:	0e c0       	rjmp	.+28     	; 0x3fa2 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3f86:	01 96       	adiw	r24, 0x01	; 1
    3f88:	84 36       	cpi	r24, 0x64	; 100
    3f8a:	91 05       	cpc	r25, r1
    3f8c:	28 f4       	brcc	.+10     	; 0x3f98 <__vector_91+0x8e>
    3f8e:	80 93 e0 31 	sts	0x31E0, r24	; 0x8031e0 <rcvD1_read_index>
    3f92:	90 93 e1 31 	sts	0x31E1, r25	; 0x8031e1 <rcvD1_read_index+0x1>
    3f96:	08 c0       	rjmp	.+16     	; 0x3fa8 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3f98:	10 92 e0 31 	sts	0x31E0, r1	; 0x8031e0 <rcvD1_read_index>
    3f9c:	10 92 e1 31 	sts	0x31E1, r1	; 0x8031e1 <rcvD1_read_index+0x1>
}
    3fa0:	03 c0       	rjmp	.+6      	; 0x3fa8 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
    3fa4:	90 e0       	ldi	r25, 0x00	; 0
    3fa6:	f3 cf       	rjmp	.-26     	; 0x3f8e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3fa8:	ff 91       	pop	r31
    3faa:	ef 91       	pop	r30
    3fac:	9f 91       	pop	r25
    3fae:	8f 91       	pop	r24
    3fb0:	3f 91       	pop	r19
    3fb2:	2f 91       	pop	r18
    3fb4:	0f 90       	pop	r0
    3fb6:	0b be       	out	0x3b, r0	; 59
    3fb8:	0f 90       	pop	r0
    3fba:	08 be       	out	0x38, r0	; 56
    3fbc:	0f 90       	pop	r0
    3fbe:	0f be       	out	0x3f, r0	; 63
    3fc0:	0f 90       	pop	r0
    3fc2:	1f 90       	pop	r1
    3fc4:	18 95       	reti

00003fc6 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3fc6:	1f 92       	push	r1
    3fc8:	0f 92       	push	r0
    3fca:	0f b6       	in	r0, 0x3f	; 63
    3fcc:	0f 92       	push	r0
    3fce:	11 24       	eor	r1, r1
    3fd0:	08 b6       	in	r0, 0x38	; 56
    3fd2:	0f 92       	push	r0
    3fd4:	18 be       	out	0x38, r1	; 56
    3fd6:	0b b6       	in	r0, 0x3b	; 59
    3fd8:	0f 92       	push	r0
    3fda:	1b be       	out	0x3b, r1	; 59
    3fdc:	2f 93       	push	r18
    3fde:	3f 93       	push	r19
    3fe0:	8f 93       	push	r24
    3fe2:	9f 93       	push	r25
    3fe4:	ef 93       	push	r30
    3fe6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3fe8:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3fec:	e0 91 e8 31 	lds	r30, 0x31E8	; 0x8031e8 <rcvE0_buffer>
    3ff0:	f0 91 e9 31 	lds	r31, 0x31E9	; 0x8031e9 <rcvE0_buffer+0x1>
    3ff4:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <rcvE0_write_index>
    3ff8:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <rcvE0_write_index+0x1>
    3ffc:	e8 0f       	add	r30, r24
    3ffe:	f9 1f       	adc	r31, r25
    4000:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4002:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <rcvE0_write_index>
    4006:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <rcvE0_write_index+0x1>
    400a:	01 96       	adiw	r24, 0x01	; 1
    400c:	84 36       	cpi	r24, 0x64	; 100
    400e:	91 05       	cpc	r25, r1
    4010:	60 f4       	brcc	.+24     	; 0x402a <__stack+0x2b>
    4012:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <rcvE0_write_index>
    4016:	90 93 d5 31 	sts	0x31D5, r25	; 0x8031d5 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    401a:	20 91 de 31 	lds	r18, 0x31DE	; 0x8031de <rcvE0_read_index>
    401e:	30 91 df 31 	lds	r19, 0x31DF	; 0x8031df <rcvE0_read_index+0x1>
    4022:	82 17       	cp	r24, r18
    4024:	93 07       	cpc	r25, r19
    4026:	f1 f4       	brne	.+60     	; 0x4064 <__stack+0x65>
    4028:	0c c0       	rjmp	.+24     	; 0x4042 <__stack+0x43>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    402a:	10 92 d4 31 	sts	0x31D4, r1	; 0x8031d4 <rcvE0_write_index>
    402e:	10 92 d5 31 	sts	0x31D5, r1	; 0x8031d5 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4032:	80 91 de 31 	lds	r24, 0x31DE	; 0x8031de <rcvE0_read_index>
    4036:	90 91 df 31 	lds	r25, 0x31DF	; 0x8031df <rcvE0_read_index+0x1>
    403a:	18 16       	cp	r1, r24
    403c:	19 06       	cpc	r1, r25
    403e:	91 f4       	brne	.+36     	; 0x4064 <__stack+0x65>
    4040:	0e c0       	rjmp	.+28     	; 0x405e <__stack+0x5f>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4042:	01 96       	adiw	r24, 0x01	; 1
    4044:	84 36       	cpi	r24, 0x64	; 100
    4046:	91 05       	cpc	r25, r1
    4048:	28 f4       	brcc	.+10     	; 0x4054 <__stack+0x55>
    404a:	80 93 de 31 	sts	0x31DE, r24	; 0x8031de <rcvE0_read_index>
    404e:	90 93 df 31 	sts	0x31DF, r25	; 0x8031df <rcvE0_read_index+0x1>
    4052:	08 c0       	rjmp	.+16     	; 0x4064 <__stack+0x65>
	rcvE0_read_index = 0;
    4054:	10 92 de 31 	sts	0x31DE, r1	; 0x8031de <rcvE0_read_index>
    4058:	10 92 df 31 	sts	0x31DF, r1	; 0x8031df <rcvE0_read_index+0x1>
}
    405c:	03 c0       	rjmp	.+6      	; 0x4064 <__stack+0x65>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    405e:	81 e0       	ldi	r24, 0x01	; 1
    4060:	90 e0       	ldi	r25, 0x00	; 0
    4062:	f3 cf       	rjmp	.-26     	; 0x404a <__stack+0x4b>
	rcvE0_read_index = 0;
}
    4064:	ff 91       	pop	r31
    4066:	ef 91       	pop	r30
    4068:	9f 91       	pop	r25
    406a:	8f 91       	pop	r24
    406c:	3f 91       	pop	r19
    406e:	2f 91       	pop	r18
    4070:	0f 90       	pop	r0
    4072:	0b be       	out	0x3b, r0	; 59
    4074:	0f 90       	pop	r0
    4076:	08 be       	out	0x38, r0	; 56
    4078:	0f 90       	pop	r0
    407a:	0f be       	out	0x3f, r0	; 63
    407c:	0f 90       	pop	r0
    407e:	1f 90       	pop	r1
    4080:	18 95       	reti

00004082 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4082:	fc 01       	movw	r30, r24
    4084:	84 81       	ldd	r24, Z+4	; 0x04
    4086:	95 81       	ldd	r25, Z+5	; 0x05
    4088:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
		}
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	08 95       	ret

00004090 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4090:	fc 01       	movw	r30, r24
    4092:	84 81       	ldd	r24, Z+4	; 0x04
    4094:	95 81       	ldd	r25, Z+5	; 0x05
    4096:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
    409a:	91 e0       	ldi	r25, 0x01	; 1
    409c:	81 11       	cpse	r24, r1
    409e:	01 c0       	rjmp	.+2      	; 0x40a2 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    40a0:	90 e0       	ldi	r25, 0x00	; 0
		}
    40a2:	89 2f       	mov	r24, r25
    40a4:	08 95       	ret

000040a6 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    40a6:	fc 01       	movw	r30, r24
    40a8:	84 81       	ldd	r24, Z+4	; 0x04
    40aa:	95 81       	ldd	r25, Z+5	; 0x05
    40ac:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
    40b0:	91 e0       	ldi	r25, 0x01	; 1
    40b2:	81 11       	cpse	r24, r1
    40b4:	90 e0       	ldi	r25, 0x00	; 0
		}
    40b6:	89 2f       	mov	r24, r25
    40b8:	08 95       	ret

000040ba <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    40ba:	fc 01       	movw	r30, r24
    40bc:	84 81       	ldd	r24, Z+4	; 0x04
    40be:	95 81       	ldd	r25, Z+5	; 0x05
    40c0:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
		}
    40c4:	90 e0       	ldi	r25, 0x00	; 0
    40c6:	08 95       	ret

000040c8 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    40c8:	fc 01       	movw	r30, r24
    40ca:	84 81       	ldd	r24, Z+4	; 0x04
    40cc:	95 81       	ldd	r25, Z+5	; 0x05
    40ce:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
    40d2:	91 e0       	ldi	r25, 0x01	; 1
    40d4:	81 11       	cpse	r24, r1
    40d6:	01 c0       	rjmp	.+2      	; 0x40da <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    40d8:	90 e0       	ldi	r25, 0x00	; 0
		}
    40da:	89 2f       	mov	r24, r25
    40dc:	08 95       	ret

000040de <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    40de:	fc 01       	movw	r30, r24
    40e0:	84 81       	ldd	r24, Z+4	; 0x04
    40e2:	95 81       	ldd	r25, Z+5	; 0x05
    40e4:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaitingFromISR>
    40e8:	91 e0       	ldi	r25, 0x01	; 1
    40ea:	81 11       	cpse	r24, r1
    40ec:	90 e0       	ldi	r25, 0x00	; 0
		}
    40ee:	89 2f       	mov	r24, r25
    40f0:	08 95       	ret

000040f2 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    40f2:	fc 01       	movw	r30, r24
    40f4:	84 81       	ldd	r24, Z+4	; 0x04
    40f6:	95 81       	ldd	r25, Z+5	; 0x05
    40f8:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
		}
    40fc:	90 e0       	ldi	r25, 0x00	; 0
    40fe:	08 95       	ret

00004100 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4100:	fc 01       	movw	r30, r24
    4102:	84 81       	ldd	r24, Z+4	; 0x04
    4104:	95 81       	ldd	r25, Z+5	; 0x05
    4106:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
    410a:	91 e0       	ldi	r25, 0x01	; 1
    410c:	81 11       	cpse	r24, r1
    410e:	01 c0       	rjmp	.+2      	; 0x4112 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4110:	90 e0       	ldi	r25, 0x00	; 0
		}
    4112:	89 2f       	mov	r24, r25
    4114:	08 95       	ret

00004116 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4116:	fc 01       	movw	r30, r24
    4118:	84 81       	ldd	r24, Z+4	; 0x04
    411a:	95 81       	ldd	r25, Z+5	; 0x05
    411c:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
    4120:	91 e0       	ldi	r25, 0x01	; 1
    4122:	81 11       	cpse	r24, r1
    4124:	90 e0       	ldi	r25, 0x00	; 0
		}
    4126:	89 2f       	mov	r24, r25
    4128:	08 95       	ret

0000412a <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    412a:	fc 01       	movw	r30, r24
    412c:	84 81       	ldd	r24, Z+4	; 0x04
    412e:	95 81       	ldd	r25, Z+5	; 0x05
    4130:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
		}
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	08 95       	ret

00004138 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4138:	fc 01       	movw	r30, r24
    413a:	84 81       	ldd	r24, Z+4	; 0x04
    413c:	95 81       	ldd	r25, Z+5	; 0x05
    413e:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
    4142:	91 e0       	ldi	r25, 0x01	; 1
    4144:	81 11       	cpse	r24, r1
    4146:	01 c0       	rjmp	.+2      	; 0x414a <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4148:	90 e0       	ldi	r25, 0x00	; 0
		}
    414a:	89 2f       	mov	r24, r25
    414c:	08 95       	ret

0000414e <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    414e:	fc 01       	movw	r30, r24
    4150:	84 81       	ldd	r24, Z+4	; 0x04
    4152:	95 81       	ldd	r25, Z+5	; 0x05
    4154:	0e 94 6b 11 	call	0x22d6	; 0x22d6 <uxQueueMessagesWaiting>
    4158:	91 e0       	ldi	r25, 0x01	; 1
    415a:	81 11       	cpse	r24, r1
    415c:	90 e0       	ldi	r25, 0x00	; 0
		}
    415e:	89 2f       	mov	r24, r25
    4160:	08 95       	ret

00004162 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4162:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4164:	01 e0       	ldi	r16, 0x01	; 1
    4166:	2f ef       	ldi	r18, 0xFF	; 255
    4168:	3f ef       	ldi	r19, 0xFF	; 255
    416a:	a9 01       	movw	r20, r18
    416c:	fc 01       	movw	r30, r24
    416e:	84 81       	ldd	r24, Z+4	; 0x04
    4170:	95 81       	ldd	r25, Z+5	; 0x05
    4172:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
}
    4176:	0f 91       	pop	r16
    4178:	08 95       	ret

0000417a <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    417a:	0f 93       	push	r16
    417c:	cf 93       	push	r28
    417e:	df 93       	push	r29
    4180:	1f 92       	push	r1
    4182:	1f 92       	push	r1
    4184:	cd b7       	in	r28, 0x3d	; 61
    4186:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4188:	01 e0       	ldi	r16, 0x01	; 1
    418a:	2f ef       	ldi	r18, 0xFF	; 255
    418c:	3f ef       	ldi	r19, 0xFF	; 255
    418e:	a9 01       	movw	r20, r18
    4190:	be 01       	movw	r22, r28
    4192:	6f 5f       	subi	r22, 0xFF	; 255
    4194:	7f 4f       	sbci	r23, 0xFF	; 255
    4196:	fc 01       	movw	r30, r24
    4198:	84 81       	ldd	r24, Z+4	; 0x04
    419a:	95 81       	ldd	r25, Z+5	; 0x05
    419c:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
	return (recv_item);
}
    41a0:	89 81       	ldd	r24, Y+1	; 0x01
    41a2:	9a 81       	ldd	r25, Y+2	; 0x02
    41a4:	0f 90       	pop	r0
    41a6:	0f 90       	pop	r0
    41a8:	df 91       	pop	r29
    41aa:	cf 91       	pop	r28
    41ac:	0f 91       	pop	r16
    41ae:	08 95       	ret

000041b0 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    41b0:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    41b2:	00 e0       	ldi	r16, 0x00	; 0
    41b4:	2f ef       	ldi	r18, 0xFF	; 255
    41b6:	3f ef       	ldi	r19, 0xFF	; 255
    41b8:	a9 01       	movw	r20, r18
    41ba:	fc 01       	movw	r30, r24
    41bc:	84 81       	ldd	r24, Z+4	; 0x04
    41be:	95 81       	ldd	r25, Z+5	; 0x05
    41c0:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
}
    41c4:	0f 91       	pop	r16
    41c6:	08 95       	ret

000041c8 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    41c8:	0f 93       	push	r16
    41ca:	cf 93       	push	r28
    41cc:	df 93       	push	r29
    41ce:	1f 92       	push	r1
    41d0:	1f 92       	push	r1
    41d2:	cd b7       	in	r28, 0x3d	; 61
    41d4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    41d6:	00 e0       	ldi	r16, 0x00	; 0
    41d8:	2f ef       	ldi	r18, 0xFF	; 255
    41da:	3f ef       	ldi	r19, 0xFF	; 255
    41dc:	a9 01       	movw	r20, r18
    41de:	be 01       	movw	r22, r28
    41e0:	6f 5f       	subi	r22, 0xFF	; 255
    41e2:	7f 4f       	sbci	r23, 0xFF	; 255
    41e4:	fc 01       	movw	r30, r24
    41e6:	84 81       	ldd	r24, Z+4	; 0x04
    41e8:	95 81       	ldd	r25, Z+5	; 0x05
    41ea:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
	return (recv_item);
}
    41ee:	89 81       	ldd	r24, Y+1	; 0x01
    41f0:	9a 81       	ldd	r25, Y+2	; 0x02
    41f2:	0f 90       	pop	r0
    41f4:	0f 90       	pop	r0
    41f6:	df 91       	pop	r29
    41f8:	cf 91       	pop	r28
    41fa:	0f 91       	pop	r16
    41fc:	08 95       	ret

000041fe <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    41fe:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4200:	01 e0       	ldi	r16, 0x01	; 1
    4202:	2f ef       	ldi	r18, 0xFF	; 255
    4204:	3f ef       	ldi	r19, 0xFF	; 255
    4206:	a9 01       	movw	r20, r18
    4208:	fc 01       	movw	r30, r24
    420a:	84 81       	ldd	r24, Z+4	; 0x04
    420c:	95 81       	ldd	r25, Z+5	; 0x05
    420e:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
}
    4212:	0f 91       	pop	r16
    4214:	08 95       	ret

00004216 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4216:	0f 93       	push	r16
    4218:	cf 93       	push	r28
    421a:	df 93       	push	r29
    421c:	1f 92       	push	r1
    421e:	1f 92       	push	r1
    4220:	cd b7       	in	r28, 0x3d	; 61
    4222:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4224:	01 e0       	ldi	r16, 0x01	; 1
    4226:	2f ef       	ldi	r18, 0xFF	; 255
    4228:	3f ef       	ldi	r19, 0xFF	; 255
    422a:	a9 01       	movw	r20, r18
    422c:	be 01       	movw	r22, r28
    422e:	6f 5f       	subi	r22, 0xFF	; 255
    4230:	7f 4f       	sbci	r23, 0xFF	; 255
    4232:	fc 01       	movw	r30, r24
    4234:	84 81       	ldd	r24, Z+4	; 0x04
    4236:	95 81       	ldd	r25, Z+5	; 0x05
    4238:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
	return (recv_item);
}
    423c:	89 81       	ldd	r24, Y+1	; 0x01
    423e:	9a 81       	ldd	r25, Y+2	; 0x02
    4240:	0f 90       	pop	r0
    4242:	0f 90       	pop	r0
    4244:	df 91       	pop	r29
    4246:	cf 91       	pop	r28
    4248:	0f 91       	pop	r16
    424a:	08 95       	ret

0000424c <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    424c:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    424e:	00 e0       	ldi	r16, 0x00	; 0
    4250:	2f ef       	ldi	r18, 0xFF	; 255
    4252:	3f ef       	ldi	r19, 0xFF	; 255
    4254:	a9 01       	movw	r20, r18
    4256:	fc 01       	movw	r30, r24
    4258:	84 81       	ldd	r24, Z+4	; 0x04
    425a:	95 81       	ldd	r25, Z+5	; 0x05
    425c:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
}
    4260:	0f 91       	pop	r16
    4262:	08 95       	ret

00004264 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4264:	0f 93       	push	r16
    4266:	cf 93       	push	r28
    4268:	df 93       	push	r29
    426a:	1f 92       	push	r1
    426c:	1f 92       	push	r1
    426e:	cd b7       	in	r28, 0x3d	; 61
    4270:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4272:	00 e0       	ldi	r16, 0x00	; 0
    4274:	2f ef       	ldi	r18, 0xFF	; 255
    4276:	3f ef       	ldi	r19, 0xFF	; 255
    4278:	a9 01       	movw	r20, r18
    427a:	be 01       	movw	r22, r28
    427c:	6f 5f       	subi	r22, 0xFF	; 255
    427e:	7f 4f       	sbci	r23, 0xFF	; 255
    4280:	fc 01       	movw	r30, r24
    4282:	84 81       	ldd	r24, Z+4	; 0x04
    4284:	95 81       	ldd	r25, Z+5	; 0x05
    4286:	0e 94 7a 10 	call	0x20f4	; 0x20f4 <xQueueGenericReceive>
	return (recv_item);
}
    428a:	89 81       	ldd	r24, Y+1	; 0x01
    428c:	9a 81       	ldd	r25, Y+2	; 0x02
    428e:	0f 90       	pop	r0
    4290:	0f 90       	pop	r0
    4292:	df 91       	pop	r29
    4294:	cf 91       	pop	r28
    4296:	0f 91       	pop	r16
    4298:	08 95       	ret

0000429a <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    429a:	cf 93       	push	r28
    429c:	df 93       	push	r29
    429e:	1f 92       	push	r1
    42a0:	cd b7       	in	r28, 0x3d	; 61
    42a2:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    42a4:	ae 01       	movw	r20, r28
    42a6:	4f 5f       	subi	r20, 0xFF	; 255
    42a8:	5f 4f       	sbci	r21, 0xFF	; 255
    42aa:	fc 01       	movw	r30, r24
    42ac:	84 81       	ldd	r24, Z+4	; 0x04
    42ae:	95 81       	ldd	r25, Z+5	; 0x05
    42b0:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
}
    42b4:	0f 90       	pop	r0
    42b6:	df 91       	pop	r29
    42b8:	cf 91       	pop	r28
    42ba:	08 95       	ret

000042bc <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    42bc:	cf 93       	push	r28
    42be:	df 93       	push	r29
    42c0:	00 d0       	rcall	.+0      	; 0x42c2 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    42c2:	cd b7       	in	r28, 0x3d	; 61
    42c4:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    42c6:	ae 01       	movw	r20, r28
    42c8:	4d 5f       	subi	r20, 0xFD	; 253
    42ca:	5f 4f       	sbci	r21, 0xFF	; 255
    42cc:	be 01       	movw	r22, r28
    42ce:	6f 5f       	subi	r22, 0xFF	; 255
    42d0:	7f 4f       	sbci	r23, 0xFF	; 255
    42d2:	fc 01       	movw	r30, r24
    42d4:	84 81       	ldd	r24, Z+4	; 0x04
    42d6:	95 81       	ldd	r25, Z+5	; 0x05
    42d8:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
	return (recv_item);
}
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	9a 81       	ldd	r25, Y+2	; 0x02
    42e0:	23 96       	adiw	r28, 0x03	; 3
    42e2:	cd bf       	out	0x3d, r28	; 61
    42e4:	de bf       	out	0x3e, r29	; 62
    42e6:	df 91       	pop	r29
    42e8:	cf 91       	pop	r28
    42ea:	08 95       	ret

000042ec <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    42ec:	cf 93       	push	r28
    42ee:	df 93       	push	r29
    42f0:	1f 92       	push	r1
    42f2:	cd b7       	in	r28, 0x3d	; 61
    42f4:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    42f6:	ae 01       	movw	r20, r28
    42f8:	4f 5f       	subi	r20, 0xFF	; 255
    42fa:	5f 4f       	sbci	r21, 0xFF	; 255
    42fc:	fc 01       	movw	r30, r24
    42fe:	84 81       	ldd	r24, Z+4	; 0x04
    4300:	95 81       	ldd	r25, Z+5	; 0x05
    4302:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
}
    4306:	0f 90       	pop	r0
    4308:	df 91       	pop	r29
    430a:	cf 91       	pop	r28
    430c:	08 95       	ret

0000430e <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    430e:	cf 93       	push	r28
    4310:	df 93       	push	r29
    4312:	00 d0       	rcall	.+0      	; 0x4314 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4314:	cd b7       	in	r28, 0x3d	; 61
    4316:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4318:	ae 01       	movw	r20, r28
    431a:	4d 5f       	subi	r20, 0xFD	; 253
    431c:	5f 4f       	sbci	r21, 0xFF	; 255
    431e:	be 01       	movw	r22, r28
    4320:	6f 5f       	subi	r22, 0xFF	; 255
    4322:	7f 4f       	sbci	r23, 0xFF	; 255
    4324:	fc 01       	movw	r30, r24
    4326:	84 81       	ldd	r24, Z+4	; 0x04
    4328:	95 81       	ldd	r25, Z+5	; 0x05
    432a:	0e 94 3e 11 	call	0x227c	; 0x227c <xQueueReceiveFromISR>
	return (recv_item);
}
    432e:	89 81       	ldd	r24, Y+1	; 0x01
    4330:	9a 81       	ldd	r25, Y+2	; 0x02
    4332:	23 96       	adiw	r28, 0x03	; 3
    4334:	cd bf       	out	0x3d, r28	; 61
    4336:	de bf       	out	0x3e, r29	; 62
    4338:	df 91       	pop	r29
    433a:	cf 91       	pop	r28
    433c:	08 95       	ret

0000433e <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    433e:	cf 93       	push	r28
    4340:	df 93       	push	r29
    4342:	1f 92       	push	r1
    4344:	cd b7       	in	r28, 0x3d	; 61
    4346:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4348:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    434a:	21 e0       	ldi	r18, 0x01	; 1
    434c:	ae 01       	movw	r20, r28
    434e:	4f 5f       	subi	r20, 0xFF	; 255
    4350:	5f 4f       	sbci	r21, 0xFF	; 255
    4352:	fc 01       	movw	r30, r24
    4354:	84 81       	ldd	r24, Z+4	; 0x04
    4356:	95 81       	ldd	r25, Z+5	; 0x05
    4358:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    435c:	91 e0       	ldi	r25, 0x01	; 1
    435e:	81 11       	cpse	r24, r1
    4360:	01 c0       	rjmp	.+2      	; 0x4364 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4362:	90 e0       	ldi	r25, 0x00	; 0
}
    4364:	89 2f       	mov	r24, r25
    4366:	0f 90       	pop	r0
    4368:	df 91       	pop	r29
    436a:	cf 91       	pop	r28
    436c:	08 95       	ret

0000436e <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    436e:	cf 93       	push	r28
    4370:	df 93       	push	r29
    4372:	1f 92       	push	r1
    4374:	cd b7       	in	r28, 0x3d	; 61
    4376:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4378:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    437a:	20 e0       	ldi	r18, 0x00	; 0
    437c:	ae 01       	movw	r20, r28
    437e:	4f 5f       	subi	r20, 0xFF	; 255
    4380:	5f 4f       	sbci	r21, 0xFF	; 255
    4382:	fc 01       	movw	r30, r24
    4384:	84 81       	ldd	r24, Z+4	; 0x04
    4386:	95 81       	ldd	r25, Z+5	; 0x05
    4388:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    438c:	91 e0       	ldi	r25, 0x01	; 1
    438e:	81 11       	cpse	r24, r1
    4390:	01 c0       	rjmp	.+2      	; 0x4394 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    4392:	90 e0       	ldi	r25, 0x00	; 0
}
    4394:	89 2f       	mov	r24, r25
    4396:	0f 90       	pop	r0
    4398:	df 91       	pop	r29
    439a:	cf 91       	pop	r28
    439c:	08 95       	ret

0000439e <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    439e:	cf 93       	push	r28
    43a0:	df 93       	push	r29
    43a2:	1f 92       	push	r1
    43a4:	cd b7       	in	r28, 0x3d	; 61
    43a6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    43a8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    43aa:	21 e0       	ldi	r18, 0x01	; 1
    43ac:	ae 01       	movw	r20, r28
    43ae:	4f 5f       	subi	r20, 0xFF	; 255
    43b0:	5f 4f       	sbci	r21, 0xFF	; 255
    43b2:	fc 01       	movw	r30, r24
    43b4:	84 81       	ldd	r24, Z+4	; 0x04
    43b6:	95 81       	ldd	r25, Z+5	; 0x05
    43b8:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    43bc:	91 e0       	ldi	r25, 0x01	; 1
    43be:	81 11       	cpse	r24, r1
    43c0:	01 c0       	rjmp	.+2      	; 0x43c4 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    43c2:	90 e0       	ldi	r25, 0x00	; 0
}
    43c4:	89 2f       	mov	r24, r25
    43c6:	0f 90       	pop	r0
    43c8:	df 91       	pop	r29
    43ca:	cf 91       	pop	r28
    43cc:	08 95       	ret

000043ce <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    43ce:	cf 93       	push	r28
    43d0:	df 93       	push	r29
    43d2:	1f 92       	push	r1
    43d4:	cd b7       	in	r28, 0x3d	; 61
    43d6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    43d8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    43da:	20 e0       	ldi	r18, 0x00	; 0
    43dc:	ae 01       	movw	r20, r28
    43de:	4f 5f       	subi	r20, 0xFF	; 255
    43e0:	5f 4f       	sbci	r21, 0xFF	; 255
    43e2:	fc 01       	movw	r30, r24
    43e4:	84 81       	ldd	r24, Z+4	; 0x04
    43e6:	95 81       	ldd	r25, Z+5	; 0x05
    43e8:	0e 94 4e 10 	call	0x209c	; 0x209c <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    43ec:	91 e0       	ldi	r25, 0x01	; 1
    43ee:	81 11       	cpse	r24, r1
    43f0:	01 c0       	rjmp	.+2      	; 0x43f4 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    43f2:	90 e0       	ldi	r25, 0x00	; 0
}
    43f4:	89 2f       	mov	r24, r25
    43f6:	0f 90       	pop	r0
    43f8:	df 91       	pop	r29
    43fa:	cf 91       	pop	r28
    43fc:	08 95       	ret

000043fe <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    43fe:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4400:	fc 01       	movw	r30, r24
    4402:	26 81       	ldd	r18, Z+6	; 0x06
    4404:	37 81       	ldd	r19, Z+7	; 0x07
    4406:	40 85       	ldd	r20, Z+8	; 0x08
    4408:	51 85       	ldd	r21, Z+9	; 0x09
    440a:	01 e0       	ldi	r16, 0x01	; 1
    440c:	84 81       	ldd	r24, Z+4	; 0x04
    440e:	95 81       	ldd	r25, Z+5	; 0x05
    4410:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
    4414:	91 e0       	ldi	r25, 0x01	; 1
    4416:	81 11       	cpse	r24, r1
    4418:	01 c0       	rjmp	.+2      	; 0x441c <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    441a:	90 e0       	ldi	r25, 0x00	; 0
		}
    441c:	89 2f       	mov	r24, r25
    441e:	0f 91       	pop	r16
    4420:	08 95       	ret

00004422 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4422:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4424:	fc 01       	movw	r30, r24
    4426:	26 81       	ldd	r18, Z+6	; 0x06
    4428:	37 81       	ldd	r19, Z+7	; 0x07
    442a:	40 85       	ldd	r20, Z+8	; 0x08
    442c:	51 85       	ldd	r21, Z+9	; 0x09
    442e:	00 e0       	ldi	r16, 0x00	; 0
    4430:	84 81       	ldd	r24, Z+4	; 0x04
    4432:	95 81       	ldd	r25, Z+5	; 0x05
    4434:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
    4438:	91 e0       	ldi	r25, 0x01	; 1
    443a:	81 11       	cpse	r24, r1
    443c:	01 c0       	rjmp	.+2      	; 0x4440 <_ZN9frt_queueIjE3putERKj+0x1e>
    443e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4440:	89 2f       	mov	r24, r25
    4442:	0f 91       	pop	r16
    4444:	08 95       	ret

00004446 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4446:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4448:	fc 01       	movw	r30, r24
    444a:	26 81       	ldd	r18, Z+6	; 0x06
    444c:	37 81       	ldd	r19, Z+7	; 0x07
    444e:	40 85       	ldd	r20, Z+8	; 0x08
    4450:	51 85       	ldd	r21, Z+9	; 0x09
    4452:	01 e0       	ldi	r16, 0x01	; 1
    4454:	84 81       	ldd	r24, Z+4	; 0x04
    4456:	95 81       	ldd	r25, Z+5	; 0x05
    4458:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
    445c:	91 e0       	ldi	r25, 0x01	; 1
    445e:	81 11       	cpse	r24, r1
    4460:	01 c0       	rjmp	.+2      	; 0x4464 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4462:	90 e0       	ldi	r25, 0x00	; 0
		}
    4464:	89 2f       	mov	r24, r25
    4466:	0f 91       	pop	r16
    4468:	08 95       	ret

0000446a <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    446a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    446c:	fc 01       	movw	r30, r24
    446e:	26 81       	ldd	r18, Z+6	; 0x06
    4470:	37 81       	ldd	r19, Z+7	; 0x07
    4472:	40 85       	ldd	r20, Z+8	; 0x08
    4474:	51 85       	ldd	r21, Z+9	; 0x09
    4476:	00 e0       	ldi	r16, 0x00	; 0
    4478:	84 81       	ldd	r24, Z+4	; 0x04
    447a:	95 81       	ldd	r25, Z+5	; 0x05
    447c:	0e 94 b3 0f 	call	0x1f66	; 0x1f66 <xQueueGenericSend>
    4480:	91 e0       	ldi	r25, 0x01	; 1
    4482:	81 11       	cpse	r24, r1
    4484:	01 c0       	rjmp	.+2      	; 0x4488 <_ZN9frt_queueIiE3putERKi+0x1e>
    4486:	90 e0       	ldi	r25, 0x00	; 0
		}
    4488:	89 2f       	mov	r24, r25
    448a:	0f 91       	pop	r16
    448c:	08 95       	ret

0000448e <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    448e:	0f 93       	push	r16
    4490:	cf 93       	push	r28
    4492:	df 93       	push	r29
    4494:	1f 92       	push	r1
    4496:	cd b7       	in	r28, 0x3d	; 61
    4498:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    449a:	2f b7       	in	r18, 0x3f	; 63
    449c:	29 83       	std	Y+1, r18	; 0x01
	cli();
    449e:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    44a0:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    44a2:	fc 01       	movw	r30, r24
    44a4:	08 ed       	ldi	r16, 0xD8	; 216
    44a6:	04 bf       	out	0x34, r16	; 52
    44a8:	60 83       	st	Z, r22

	SREG = saved_sreg;
    44aa:	89 81       	ldd	r24, Y+1	; 0x01
    44ac:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    44ae:	0f 90       	pop	r0
    44b0:	df 91       	pop	r29
    44b2:	cf 91       	pop	r28
    44b4:	0f 91       	pop	r16
    44b6:	08 95       	ret

000044b8 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    44b8:	ef 92       	push	r14
    44ba:	ff 92       	push	r15
    44bc:	0f 93       	push	r16
    44be:	1f 93       	push	r17
    44c0:	cf 93       	push	r28
    44c2:	df 93       	push	r29
    44c4:	cd b7       	in	r28, 0x3d	; 61
    44c6:	de b7       	in	r29, 0x3e	; 62
    44c8:	c3 54       	subi	r28, 0x43	; 67
    44ca:	d1 09       	sbc	r29, r1
    44cc:	cd bf       	out	0x3d, r28	; 61
    44ce:	de bf       	out	0x3e, r29	; 62
	cli();
    44d0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    44d2:	e0 e5       	ldi	r30, 0x50	; 80
    44d4:	f0 e0       	ldi	r31, 0x00	; 0
    44d6:	80 81       	ld	r24, Z
    44d8:	82 60       	ori	r24, 0x02	; 2
    44da:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    44dc:	81 81       	ldd	r24, Z+1	; 0x01
    44de:	81 ff       	sbrs	r24, 1
    44e0:	fd cf       	rjmp	.-6      	; 0x44dc <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    44e2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    44e6:	68 7f       	andi	r22, 0xF8	; 248
    44e8:	61 60       	ori	r22, 0x01	; 1
    44ea:	80 e4       	ldi	r24, 0x40	; 64
    44ec:	90 e0       	ldi	r25, 0x00	; 0
    44ee:	0e 94 47 22 	call	0x448e	; 0x448e <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    44f2:	e0 e5       	ldi	r30, 0x50	; 80
    44f4:	f0 e0       	ldi	r31, 0x00	; 0
    44f6:	80 81       	ld	r24, Z
    44f8:	8e 7f       	andi	r24, 0xFE	; 254
    44fa:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    44fc:	9d ef       	ldi	r25, 0xFD	; 253
    44fe:	88 ed       	ldi	r24, 0xD8	; 216
    4500:	08 b6       	in	r0, 0x38	; 56
    4502:	18 be       	out	0x38, r1	; 56
    4504:	84 bf       	out	0x34, r24	; 52
    4506:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    450a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    450c:	40 ea       	ldi	r20, 0xA0	; 160
    450e:	5a e0       	ldi	r21, 0x0A	; 10
    4510:	60 e0       	ldi	r22, 0x00	; 0
    4512:	70 e0       	ldi	r23, 0x00	; 0
    4514:	ce 01       	movw	r24, r28
    4516:	01 96       	adiw	r24, 0x01	; 1
    4518:	0e 94 eb 1d 	call	0x3bd6	; 0x3bd6 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    451c:	67 e0       	ldi	r22, 0x07	; 7
    451e:	ce 01       	movw	r24, r28
    4520:	01 96       	adiw	r24, 0x01	; 1
    4522:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    4526:	8c 01       	movw	r16, r24
    4528:	63 ef       	ldi	r22, 0xF3	; 243
    452a:	70 e2       	ldi	r23, 0x20	; 32
    452c:	0e 94 11 1c 	call	0x3822	; 0x3822 <_ZN8emstream4putsEPKc>
    4530:	66 e0       	ldi	r22, 0x06	; 6
    4532:	c8 01       	movw	r24, r16
    4534:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
    4538:	66 e0       	ldi	r22, 0x06	; 6
    453a:	0e 94 48 1c 	call	0x3890	; 0x3890 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    453e:	20 e3       	ldi	r18, 0x30	; 48
    4540:	32 ef       	ldi	r19, 0xF2	; 242
    4542:	40 e0       	ldi	r20, 0x00	; 0
    4544:	50 e0       	ldi	r21, 0x00	; 0
    4546:	60 ea       	ldi	r22, 0xA0	; 160
    4548:	74 e0       	ldi	r23, 0x04	; 4
    454a:	ce 01       	movw	r24, r28
    454c:	4e 96       	adiw	r24, 0x1e	; 30
    454e:	0e 94 97 06 	call	0xd2e	; 0xd2e <_ZN9I2CMasterC1EP10TWI_structm>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c);
    4552:	be 01       	movw	r22, r28
    4554:	62 5e       	subi	r22, 0xE2	; 226
    4556:	7f 4f       	sbci	r23, 0xFF	; 255
    4558:	ce 01       	movw	r24, r28
    455a:	c5 96       	adiw	r24, 0x35	; 53
    455c:	0e 94 fd 07 	call	0xffa	; 0xffa <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4560:	82 e1       	ldi	r24, 0x12	; 18
    4562:	90 e0       	ldi	r25, 0x00	; 0
    4564:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
    4568:	8e 01       	movw	r16, r28
    456a:	0f 5f       	subi	r16, 0xFF	; 255
    456c:	1f 4f       	sbci	r17, 0xFF	; 255
    456e:	20 e8       	ldi	r18, 0x80	; 128
    4570:	30 e0       	ldi	r19, 0x00	; 0
    4572:	40 e0       	ldi	r20, 0x00	; 0
    4574:	62 e1       	ldi	r22, 0x12	; 18
    4576:	71 e2       	ldi	r23, 0x21	; 33
    4578:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    457c:	88 e1       	ldi	r24, 0x18	; 24
    457e:	90 e0       	ldi	r25, 0x00	; 0
    4580:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <_Znwj>
    4584:	9e 01       	movw	r18, r28
    4586:	2b 5c       	subi	r18, 0xCB	; 203
    4588:	3f 4f       	sbci	r19, 0xFF	; 255
    458a:	79 01       	movw	r14, r18
    458c:	20 e8       	ldi	r18, 0x80	; 128
    458e:	30 e0       	ldi	r19, 0x00	; 0
    4590:	42 e0       	ldi	r20, 0x02	; 2
    4592:	6a e1       	ldi	r22, 0x1A	; 26
    4594:	71 e2       	ldi	r23, 0x21	; 33
    4596:	0e 94 12 09 	call	0x1224	; 0x1224 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    459a:	87 e0       	ldi	r24, 0x07	; 7
    459c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    45a0:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    45a2:	0e 94 dc 12 	call	0x25b8	; 0x25b8 <vTaskStartScheduler>
}
    45a6:	80 e0       	ldi	r24, 0x00	; 0
    45a8:	90 e0       	ldi	r25, 0x00	; 0
    45aa:	cd 5b       	subi	r28, 0xBD	; 189
    45ac:	df 4f       	sbci	r29, 0xFF	; 255
    45ae:	cd bf       	out	0x3d, r28	; 61
    45b0:	de bf       	out	0x3e, r29	; 62
    45b2:	df 91       	pop	r29
    45b4:	cf 91       	pop	r28
    45b6:	1f 91       	pop	r17
    45b8:	0f 91       	pop	r16
    45ba:	ff 90       	pop	r15
    45bc:	ef 90       	pop	r14
    45be:	08 95       	ret

000045c0 <_GLOBAL__sub_I_counter>:
    45c0:	cf 92       	push	r12
    45c2:	df 92       	push	r13
    45c4:	ef 92       	push	r14
    45c6:	ff 92       	push	r15
    45c8:	0f 93       	push	r16
    45ca:	1f 93       	push	r17
    45cc:	cf 93       	push	r28
    45ce:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    45d0:	0a e0       	ldi	r16, 0x0A	; 10
    45d2:	10 e0       	ldi	r17, 0x00	; 0
    45d4:	20 e0       	ldi	r18, 0x00	; 0
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	40 e0       	ldi	r20, 0x00	; 0
    45da:	50 e0       	ldi	r21, 0x00	; 0
    45dc:	60 e2       	ldi	r22, 0x20	; 32
    45de:	70 e0       	ldi	r23, 0x00	; 0
    45e0:	84 e2       	ldi	r24, 0x24	; 36
    45e2:	92 e3       	ldi	r25, 0x32	; 50
    45e4:	0e 94 c9 19 	call	0x3392	; 0x3392 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    45e8:	ca e1       	ldi	r28, 0x1A	; 26
    45ea:	d2 e3       	ldi	r29, 0x32	; 50
    45ec:	1a 82       	std	Y+2, r1	; 0x02
    45ee:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    45f0:	84 e2       	ldi	r24, 0x24	; 36
    45f2:	91 e2       	ldi	r25, 0x21	; 33
    45f4:	88 83       	st	Y, r24
    45f6:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    45f8:	40 e0       	ldi	r20, 0x00	; 0
    45fa:	62 e0       	ldi	r22, 0x02	; 2
    45fc:	8f ef       	ldi	r24, 0xFF	; 255
    45fe:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    4602:	8c 83       	std	Y+4, r24	; 0x04
    4604:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4606:	0f 2e       	mov	r0, r31
    4608:	fa e0       	ldi	r31, 0x0A	; 10
    460a:	cf 2e       	mov	r12, r31
    460c:	d1 2c       	mov	r13, r1
    460e:	e1 2c       	mov	r14, r1
    4610:	f1 2c       	mov	r15, r1
    4612:	f0 2d       	mov	r31, r0
    4614:	ce 82       	std	Y+6, r12	; 0x06
    4616:	df 82       	std	Y+7, r13	; 0x07
    4618:	e8 86       	std	Y+8, r14	; 0x08
    461a:	f9 86       	std	Y+9, r15	; 0x09
    461c:	c0 e1       	ldi	r28, 0x10	; 16
    461e:	d2 e3       	ldi	r29, 0x32	; 50
    4620:	1a 82       	std	Y+2, r1	; 0x02
    4622:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4624:	08 e4       	ldi	r16, 0x48	; 72
    4626:	11 e2       	ldi	r17, 0x21	; 33
    4628:	08 83       	st	Y, r16
    462a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    462c:	40 e0       	ldi	r20, 0x00	; 0
    462e:	62 e0       	ldi	r22, 0x02	; 2
    4630:	8f ef       	ldi	r24, 0xFF	; 255
    4632:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    4636:	8c 83       	std	Y+4, r24	; 0x04
    4638:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    463a:	ce 82       	std	Y+6, r12	; 0x06
    463c:	df 82       	std	Y+7, r13	; 0x07
    463e:	e8 86       	std	Y+8, r14	; 0x08
    4640:	f9 86       	std	Y+9, r15	; 0x09
    4642:	c6 e0       	ldi	r28, 0x06	; 6
    4644:	d2 e3       	ldi	r29, 0x32	; 50
    4646:	1a 82       	std	Y+2, r1	; 0x02
    4648:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    464a:	08 83       	st	Y, r16
    464c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    464e:	40 e0       	ldi	r20, 0x00	; 0
    4650:	62 e0       	ldi	r22, 0x02	; 2
    4652:	8f ef       	ldi	r24, 0xFF	; 255
    4654:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    4658:	8c 83       	std	Y+4, r24	; 0x04
    465a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    465c:	ce 82       	std	Y+6, r12	; 0x06
    465e:	df 82       	std	Y+7, r13	; 0x07
    4660:	e8 86       	std	Y+8, r14	; 0x08
    4662:	f9 86       	std	Y+9, r15	; 0x09
    4664:	cc ef       	ldi	r28, 0xFC	; 252
    4666:	d1 e3       	ldi	r29, 0x31	; 49
    4668:	1a 82       	std	Y+2, r1	; 0x02
    466a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    466c:	08 83       	st	Y, r16
    466e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4670:	40 e0       	ldi	r20, 0x00	; 0
    4672:	62 e0       	ldi	r22, 0x02	; 2
    4674:	8f ef       	ldi	r24, 0xFF	; 255
    4676:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    467a:	8c 83       	std	Y+4, r24	; 0x04
    467c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    467e:	ce 82       	std	Y+6, r12	; 0x06
    4680:	df 82       	std	Y+7, r13	; 0x07
    4682:	e8 86       	std	Y+8, r14	; 0x08
    4684:	f9 86       	std	Y+9, r15	; 0x09
    4686:	c2 ef       	ldi	r28, 0xF2	; 242
    4688:	d1 e3       	ldi	r29, 0x31	; 49
    468a:	1a 82       	std	Y+2, r1	; 0x02
    468c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    468e:	08 83       	st	Y, r16
    4690:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4692:	40 e0       	ldi	r20, 0x00	; 0
    4694:	62 e0       	ldi	r22, 0x02	; 2
    4696:	8f ef       	ldi	r24, 0xFF	; 255
    4698:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xQueueGenericCreate>
    469c:	8c 83       	std	Y+4, r24	; 0x04
    469e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    46a0:	ce 82       	std	Y+6, r12	; 0x06
    46a2:	df 82       	std	Y+7, r13	; 0x07
    46a4:	e8 86       	std	Y+8, r14	; 0x08
    46a6:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    46a8:	df 91       	pop	r29
    46aa:	cf 91       	pop	r28
    46ac:	1f 91       	pop	r17
    46ae:	0f 91       	pop	r16
    46b0:	ff 90       	pop	r15
    46b2:	ef 90       	pop	r14
    46b4:	df 90       	pop	r13
    46b6:	cf 90       	pop	r12
    46b8:	08 95       	ret

000046ba <__mulsi3>:
    46ba:	db 01       	movw	r26, r22
    46bc:	8f 93       	push	r24
    46be:	9f 93       	push	r25
    46c0:	0e 94 b7 23 	call	0x476e	; 0x476e <__muluhisi3>
    46c4:	bf 91       	pop	r27
    46c6:	af 91       	pop	r26
    46c8:	a2 9f       	mul	r26, r18
    46ca:	80 0d       	add	r24, r0
    46cc:	91 1d       	adc	r25, r1
    46ce:	a3 9f       	mul	r26, r19
    46d0:	90 0d       	add	r25, r0
    46d2:	b2 9f       	mul	r27, r18
    46d4:	90 0d       	add	r25, r0
    46d6:	11 24       	eor	r1, r1
    46d8:	08 95       	ret

000046da <__udivmodsi4>:
    46da:	a1 e2       	ldi	r26, 0x21	; 33
    46dc:	1a 2e       	mov	r1, r26
    46de:	aa 1b       	sub	r26, r26
    46e0:	bb 1b       	sub	r27, r27
    46e2:	fd 01       	movw	r30, r26
    46e4:	0d c0       	rjmp	.+26     	; 0x4700 <__udivmodsi4_ep>

000046e6 <__udivmodsi4_loop>:
    46e6:	aa 1f       	adc	r26, r26
    46e8:	bb 1f       	adc	r27, r27
    46ea:	ee 1f       	adc	r30, r30
    46ec:	ff 1f       	adc	r31, r31
    46ee:	a2 17       	cp	r26, r18
    46f0:	b3 07       	cpc	r27, r19
    46f2:	e4 07       	cpc	r30, r20
    46f4:	f5 07       	cpc	r31, r21
    46f6:	20 f0       	brcs	.+8      	; 0x4700 <__udivmodsi4_ep>
    46f8:	a2 1b       	sub	r26, r18
    46fa:	b3 0b       	sbc	r27, r19
    46fc:	e4 0b       	sbc	r30, r20
    46fe:	f5 0b       	sbc	r31, r21

00004700 <__udivmodsi4_ep>:
    4700:	66 1f       	adc	r22, r22
    4702:	77 1f       	adc	r23, r23
    4704:	88 1f       	adc	r24, r24
    4706:	99 1f       	adc	r25, r25
    4708:	1a 94       	dec	r1
    470a:	69 f7       	brne	.-38     	; 0x46e6 <__udivmodsi4_loop>
    470c:	60 95       	com	r22
    470e:	70 95       	com	r23
    4710:	80 95       	com	r24
    4712:	90 95       	com	r25
    4714:	9b 01       	movw	r18, r22
    4716:	ac 01       	movw	r20, r24
    4718:	bd 01       	movw	r22, r26
    471a:	cf 01       	movw	r24, r30
    471c:	08 95       	ret

0000471e <__divmodsi4>:
    471e:	05 2e       	mov	r0, r21
    4720:	97 fb       	bst	r25, 7
    4722:	1e f4       	brtc	.+6      	; 0x472a <__divmodsi4+0xc>
    4724:	00 94       	com	r0
    4726:	0e 94 a6 23 	call	0x474c	; 0x474c <__negsi2>
    472a:	57 fd       	sbrc	r21, 7
    472c:	07 d0       	rcall	.+14     	; 0x473c <__divmodsi4_neg2>
    472e:	0e 94 6d 23 	call	0x46da	; 0x46da <__udivmodsi4>
    4732:	07 fc       	sbrc	r0, 7
    4734:	03 d0       	rcall	.+6      	; 0x473c <__divmodsi4_neg2>
    4736:	4e f4       	brtc	.+18     	; 0x474a <__divmodsi4_exit>
    4738:	0c 94 a6 23 	jmp	0x474c	; 0x474c <__negsi2>

0000473c <__divmodsi4_neg2>:
    473c:	50 95       	com	r21
    473e:	40 95       	com	r20
    4740:	30 95       	com	r19
    4742:	21 95       	neg	r18
    4744:	3f 4f       	sbci	r19, 0xFF	; 255
    4746:	4f 4f       	sbci	r20, 0xFF	; 255
    4748:	5f 4f       	sbci	r21, 0xFF	; 255

0000474a <__divmodsi4_exit>:
    474a:	08 95       	ret

0000474c <__negsi2>:
    474c:	90 95       	com	r25
    474e:	80 95       	com	r24
    4750:	70 95       	com	r23
    4752:	61 95       	neg	r22
    4754:	7f 4f       	sbci	r23, 0xFF	; 255
    4756:	8f 4f       	sbci	r24, 0xFF	; 255
    4758:	9f 4f       	sbci	r25, 0xFF	; 255
    475a:	08 95       	ret

0000475c <__tablejump2__>:
    475c:	ee 0f       	add	r30, r30
    475e:	ff 1f       	adc	r31, r31
    4760:	88 1f       	adc	r24, r24
    4762:	8b bf       	out	0x3b, r24	; 59
    4764:	07 90       	elpm	r0, Z+
    4766:	f6 91       	elpm	r31, Z
    4768:	e0 2d       	mov	r30, r0
    476a:	1b be       	out	0x3b, r1	; 59
    476c:	19 94       	eijmp

0000476e <__muluhisi3>:
    476e:	0e 94 c2 23 	call	0x4784	; 0x4784 <__umulhisi3>
    4772:	a5 9f       	mul	r26, r21
    4774:	90 0d       	add	r25, r0
    4776:	b4 9f       	mul	r27, r20
    4778:	90 0d       	add	r25, r0
    477a:	a4 9f       	mul	r26, r20
    477c:	80 0d       	add	r24, r0
    477e:	91 1d       	adc	r25, r1
    4780:	11 24       	eor	r1, r1
    4782:	08 95       	ret

00004784 <__umulhisi3>:
    4784:	a2 9f       	mul	r26, r18
    4786:	b0 01       	movw	r22, r0
    4788:	b3 9f       	mul	r27, r19
    478a:	c0 01       	movw	r24, r0
    478c:	a3 9f       	mul	r26, r19
    478e:	70 0d       	add	r23, r0
    4790:	81 1d       	adc	r24, r1
    4792:	11 24       	eor	r1, r1
    4794:	91 1d       	adc	r25, r1
    4796:	b2 9f       	mul	r27, r18
    4798:	70 0d       	add	r23, r0
    479a:	81 1d       	adc	r24, r1
    479c:	11 24       	eor	r1, r1
    479e:	91 1d       	adc	r25, r1
    47a0:	08 95       	ret

000047a2 <memcpy>:
    47a2:	fb 01       	movw	r30, r22
    47a4:	dc 01       	movw	r26, r24
    47a6:	02 c0       	rjmp	.+4      	; 0x47ac <memcpy+0xa>
    47a8:	01 90       	ld	r0, Z+
    47aa:	0d 92       	st	X+, r0
    47ac:	41 50       	subi	r20, 0x01	; 1
    47ae:	50 40       	sbci	r21, 0x00	; 0
    47b0:	d8 f7       	brcc	.-10     	; 0x47a8 <memcpy+0x6>
    47b2:	08 95       	ret

000047b4 <memset>:
    47b4:	dc 01       	movw	r26, r24
    47b6:	01 c0       	rjmp	.+2      	; 0x47ba <memset+0x6>
    47b8:	6d 93       	st	X+, r22
    47ba:	41 50       	subi	r20, 0x01	; 1
    47bc:	50 40       	sbci	r21, 0x00	; 0
    47be:	e0 f7       	brcc	.-8      	; 0x47b8 <memset+0x4>
    47c0:	08 95       	ret

000047c2 <strncpy>:
    47c2:	fb 01       	movw	r30, r22
    47c4:	dc 01       	movw	r26, r24
    47c6:	41 50       	subi	r20, 0x01	; 1
    47c8:	50 40       	sbci	r21, 0x00	; 0
    47ca:	48 f0       	brcs	.+18     	; 0x47de <strncpy+0x1c>
    47cc:	01 90       	ld	r0, Z+
    47ce:	0d 92       	st	X+, r0
    47d0:	00 20       	and	r0, r0
    47d2:	c9 f7       	brne	.-14     	; 0x47c6 <strncpy+0x4>
    47d4:	01 c0       	rjmp	.+2      	; 0x47d8 <strncpy+0x16>
    47d6:	1d 92       	st	X+, r1
    47d8:	41 50       	subi	r20, 0x01	; 1
    47da:	50 40       	sbci	r21, 0x00	; 0
    47dc:	e0 f7       	brcc	.-8      	; 0x47d6 <strncpy+0x14>
    47de:	08 95       	ret

000047e0 <ultoa>:
    47e0:	25 32       	cpi	r18, 0x25	; 37
    47e2:	31 05       	cpc	r19, r1
    47e4:	20 f4       	brcc	.+8      	; 0x47ee <ultoa+0xe>
    47e6:	22 30       	cpi	r18, 0x02	; 2
    47e8:	10 f0       	brcs	.+4      	; 0x47ee <ultoa+0xe>
    47ea:	0c 94 fb 23 	jmp	0x47f6	; 0x47f6 <__ultoa_ncheck>
    47ee:	fa 01       	movw	r30, r20
    47f0:	10 82       	st	Z, r1
    47f2:	ca 01       	movw	r24, r20
    47f4:	08 95       	ret

000047f6 <__ultoa_ncheck>:
    47f6:	bb 27       	eor	r27, r27

000047f8 <__ultoa_common>:
    47f8:	fa 01       	movw	r30, r20
    47fa:	a6 2f       	mov	r26, r22
    47fc:	62 17       	cp	r22, r18
    47fe:	71 05       	cpc	r23, r1
    4800:	81 05       	cpc	r24, r1
    4802:	91 05       	cpc	r25, r1
    4804:	33 0b       	sbc	r19, r19
    4806:	30 fb       	bst	r19, 0
    4808:	66 f0       	brts	.+24     	; 0x4822 <__ultoa_common+0x2a>
    480a:	aa 27       	eor	r26, r26
    480c:	66 0f       	add	r22, r22
    480e:	77 1f       	adc	r23, r23
    4810:	88 1f       	adc	r24, r24
    4812:	99 1f       	adc	r25, r25
    4814:	aa 1f       	adc	r26, r26
    4816:	a2 17       	cp	r26, r18
    4818:	10 f0       	brcs	.+4      	; 0x481e <__ultoa_common+0x26>
    481a:	a2 1b       	sub	r26, r18
    481c:	63 95       	inc	r22
    481e:	38 50       	subi	r19, 0x08	; 8
    4820:	a9 f7       	brne	.-22     	; 0x480c <__ultoa_common+0x14>
    4822:	a0 5d       	subi	r26, 0xD0	; 208
    4824:	aa 33       	cpi	r26, 0x3A	; 58
    4826:	08 f0       	brcs	.+2      	; 0x482a <__ultoa_common+0x32>
    4828:	a9 5d       	subi	r26, 0xD9	; 217
    482a:	a1 93       	st	Z+, r26
    482c:	36 f7       	brtc	.-52     	; 0x47fa <__ultoa_common+0x2>
    482e:	b1 11       	cpse	r27, r1
    4830:	b1 93       	st	Z+, r27
    4832:	10 82       	st	Z, r1
    4834:	ca 01       	movw	r24, r20
    4836:	0c 94 42 24 	jmp	0x4884	; 0x4884 <strrev>

0000483a <utoa>:
    483a:	45 32       	cpi	r20, 0x25	; 37
    483c:	51 05       	cpc	r21, r1
    483e:	20 f4       	brcc	.+8      	; 0x4848 <utoa+0xe>
    4840:	42 30       	cpi	r20, 0x02	; 2
    4842:	10 f0       	brcs	.+4      	; 0x4848 <utoa+0xe>
    4844:	0c 94 28 24 	jmp	0x4850	; 0x4850 <__utoa_ncheck>
    4848:	fb 01       	movw	r30, r22
    484a:	10 82       	st	Z, r1
    484c:	cb 01       	movw	r24, r22
    484e:	08 95       	ret

00004850 <__utoa_ncheck>:
    4850:	bb 27       	eor	r27, r27

00004852 <__utoa_common>:
    4852:	fb 01       	movw	r30, r22
    4854:	55 27       	eor	r21, r21
    4856:	aa 27       	eor	r26, r26
    4858:	88 0f       	add	r24, r24
    485a:	99 1f       	adc	r25, r25
    485c:	aa 1f       	adc	r26, r26
    485e:	a4 17       	cp	r26, r20
    4860:	10 f0       	brcs	.+4      	; 0x4866 <__utoa_common+0x14>
    4862:	a4 1b       	sub	r26, r20
    4864:	83 95       	inc	r24
    4866:	50 51       	subi	r21, 0x10	; 16
    4868:	b9 f7       	brne	.-18     	; 0x4858 <__utoa_common+0x6>
    486a:	a0 5d       	subi	r26, 0xD0	; 208
    486c:	aa 33       	cpi	r26, 0x3A	; 58
    486e:	08 f0       	brcs	.+2      	; 0x4872 <__utoa_common+0x20>
    4870:	a9 5d       	subi	r26, 0xD9	; 217
    4872:	a1 93       	st	Z+, r26
    4874:	00 97       	sbiw	r24, 0x00	; 0
    4876:	79 f7       	brne	.-34     	; 0x4856 <__utoa_common+0x4>
    4878:	b1 11       	cpse	r27, r1
    487a:	b1 93       	st	Z+, r27
    487c:	11 92       	st	Z+, r1
    487e:	cb 01       	movw	r24, r22
    4880:	0c 94 42 24 	jmp	0x4884	; 0x4884 <strrev>

00004884 <strrev>:
    4884:	dc 01       	movw	r26, r24
    4886:	fc 01       	movw	r30, r24
    4888:	67 2f       	mov	r22, r23
    488a:	71 91       	ld	r23, Z+
    488c:	77 23       	and	r23, r23
    488e:	e1 f7       	brne	.-8      	; 0x4888 <strrev+0x4>
    4890:	32 97       	sbiw	r30, 0x02	; 2
    4892:	04 c0       	rjmp	.+8      	; 0x489c <strrev+0x18>
    4894:	7c 91       	ld	r23, X
    4896:	6d 93       	st	X+, r22
    4898:	70 83       	st	Z, r23
    489a:	62 91       	ld	r22, -Z
    489c:	ae 17       	cp	r26, r30
    489e:	bf 07       	cpc	r27, r31
    48a0:	c8 f3       	brcs	.-14     	; 0x4894 <strrev+0x10>
    48a2:	08 95       	ret

000048a4 <_exit>:
    48a4:	f8 94       	cli

000048a6 <__stop_program>:
    48a6:	ff cf       	rjmp	.-2      	; 0x48a6 <__stop_program>
