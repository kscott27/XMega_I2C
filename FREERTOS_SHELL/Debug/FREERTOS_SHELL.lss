
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003f6a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000de  00802000  00003f6a  00003ffe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020de  008020de  000040dc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000040dc  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000410c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d8  00000000  00000000  0000414c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000128e1  00000000  00000000  00004924  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005bc6  00000000  00000000  00017205  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000051a8  00000000  00000000  0001cdcb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001768  00000000  00000000  00021f74  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000668d  00000000  00000000  000236dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000075e9  00000000  00000000  00029d69  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000738  00000000  00000000  00031352  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__ctors_end>
       4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      10:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      14:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      18:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      1c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      20:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      24:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      28:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      2c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      30:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      34:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      38:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      3c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      40:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      44:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      48:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      4c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      50:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      54:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      58:	0c 94 13 0a 	jmp	0x1426	; 0x1426 <__vector_22>
      5c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      60:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      64:	0c 94 e8 19 	jmp	0x33d0	; 0x33d0 <__vector_25>
      68:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      6c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      70:	0c 94 46 1a 	jmp	0x348c	; 0x348c <__vector_28>
      74:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      78:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      7c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      80:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      84:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      88:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      8c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      90:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      94:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      98:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      9c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e8:	0c 94 60 1b 	jmp	0x36c0	; 0x36c0 <__vector_58>
      ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      fc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     100:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     104:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     108:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     10c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     110:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     114:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     118:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     11c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     120:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     124:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     128:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     12c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     130:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     134:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     138:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     13c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     140:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     144:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     148:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     14c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     150:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     154:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     158:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     15c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     160:	0c 94 a4 1a 	jmp	0x3548	; 0x3548 <__vector_88>
     164:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     168:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     16c:	0c 94 02 1b 	jmp	0x3604	; 0x3604 <__vector_91>
     170:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     174:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     178:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     17c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     180:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     184:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     188:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     18c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     190:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     194:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     198:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     19c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1fc:	d4 17       	cp	r29, r20
     1fe:	d7 17       	cp	r29, r23
     200:	da 17       	cp	r29, r26
     202:	dd 17       	cp	r29, r29
     204:	e0 17       	cp	r30, r16
     206:	e3 17       	cp	r30, r19
     208:	e5 17       	cp	r30, r21
     20a:	f6 17       	cp	r31, r22
     20c:	fe 17       	cp	r31, r30
     20e:	08 18       	sub	r0, r8
     210:	06 18       	sub	r0, r6

00000212 <__trampolines_start>:
     212:	0c 94 8e 1d 	jmp	0x3b1c	; 0x3b1c <_ZN9frt_queueIjE3putERKj>
     216:	0c 94 a3 1c 	jmp	0x3946	; 0x3946 <_ZN9frt_queueIiE3getEPi>
     21a:	0c 94 26 19 	jmp	0x324c	; 0x324c <_ZN5rs2327getcharEv>
     21e:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <_ZN9frt_queueIiE7ISR_getEPi>
     222:	0c 94 fe 17 	jmp	0x2ffc	; 0x2ffc <_ZN8emstreamlsE15ser_manipulator+0x72>
     226:	0c 94 f6 17 	jmp	0x2fec	; 0x2fec <_ZN8emstreamlsE15ser_manipulator+0x62>
     22a:	0c 94 a8 03 	jmp	0x750	; 0x750 <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>
     22e:	0c 94 f3 0c 	jmp	0x19e6	; 0x19e6 <prvIdleTask>
     232:	0c 94 7e 17 	jmp	0x2efc	; 0x2efc <_ZN8emstream12transmit_nowEv>
     236:	0c 94 41 1e 	jmp	0x3c82	; 0x3c82 <_GLOBAL__sub_I_counter>
     23a:	0c 94 af 1c 	jmp	0x395e	; 0x395e <_ZN9frt_queueIiE3getEv>
     23e:	0c 94 ef 05 	jmp	0xbde	; 0xbde <_ZN9task_user3runEv>
     242:	0c 94 12 1c 	jmp	0x3824	; 0x3824 <_ZN9frt_queueIiE12num_items_inEv>
     246:	0c 94 ff 14 	jmp	0x29fe	; 0x29fe <_ZN14frt_text_queue7getcharEv>
     24a:	0c 94 a0 1d 	jmp	0x3b40	; 0x3b40 <_ZN9frt_queueIiE7butt_inERKi>
     24e:	0c 94 3b 03 	jmp	0x676	; 0x676 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     252:	0c 94 02 19 	jmp	0x3204	; 0x3204 <_ZN5rs2327putcharEc>
     256:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <_ZN9frt_queueIiE9not_emptyEv>
     25a:	0c 94 7f 17 	jmp	0x2efe	; 0x2efe <_ZN8emstream12clear_screenEv>
     25e:	0c 94 ec 1b 	jmp	0x37d8	; 0x37d8 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     262:	0c 94 24 1c 	jmp	0x3848	; 0x3848 <_ZN9frt_queueIiE8is_emptyEv>
     266:	0c 94 e0 17 	jmp	0x2fc0	; 0x2fc0 <_ZN8emstreamlsE15ser_manipulator+0x36>
     26a:	0c 94 7c 1d 	jmp	0x3af8	; 0x3af8 <_ZN9frt_queueIjE7butt_inERKj>
     26e:	0c 94 d4 17 	jmp	0x2fa8	; 0x2fa8 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     272:	0c 94 fd 1b 	jmp	0x37fa	; 0x37fa <_ZN9frt_queueIjE9not_emptyEv>
     276:	0c 94 b2 1d 	jmp	0x3b64	; 0x3b64 <_ZN9frt_queueIiE3putERKi>
     27a:	0c 94 e3 17 	jmp	0x2fc6	; 0x2fc6 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     27e:	0c 94 08 1c 	jmp	0x3810	; 0x3810 <_ZN9frt_queueIjE8is_emptyEv>
     282:	0c 94 55 1c 	jmp	0x38aa	; 0x38aa <_ZN9frt_queueIjE3getEPj>
     286:	0c 94 d7 17 	jmp	0x2fae	; 0x2fae <_ZN8emstreamlsE15ser_manipulator+0x24>
     28a:	0c 94 e8 02 	jmp	0x5d0	; 0x5d0 <_call_static_run_method>
     28e:	0c 94 e1 1b 	jmp	0x37c2	; 0x37c2 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     292:	0c 94 5f 19 	jmp	0x32be	; 0x32be <_ZN5rs23212clear_screenEv>
     296:	0c 94 93 03 	jmp	0x726	; 0x726 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     29a:	0c 94 2e 1c 	jmp	0x385c	; 0x385c <_ZN9frt_queueIjE10get_a_copyERj>
     29e:	0c 94 23 03 	jmp	0x646	; 0x646 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>
     2a2:	0c 94 34 1d 	jmp	0x3a68	; 0x3a68 <_ZN9frt_queueIjE7ISR_putERKj>
     2a6:	0c 94 e0 16 	jmp	0x2dc0	; 0x2dc0 <__cxa_pure_virtual>
     2aa:	0c 94 ca 1c 	jmp	0x3994	; 0x3994 <_ZN9frt_queueIjE7ISR_getEPj>
     2ae:	0c 94 f6 1b 	jmp	0x37ec	; 0x37ec <_ZN9frt_queueIjE12num_items_inEv>
     2b2:	0c 94 db 1c 	jmp	0x39b6	; 0x39b6 <_ZN9frt_queueIjE7ISR_getEv>
     2b6:	0c 94 88 1c 	jmp	0x3910	; 0x3910 <_ZN9frt_queueIiE10get_a_copyEv>
     2ba:	0c 94 4c 1d 	jmp	0x3a98	; 0x3a98 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     2be:	0c 94 7c 1c 	jmp	0x38f8	; 0x38f8 <_ZN9frt_queueIiE10get_a_copyERi>
     2c2:	0c 94 79 17 	jmp	0x2ef2	; 0x2ef2 <_ZN8emstream7getcharEv>
     2c6:	0c 94 c5 1b 	jmp	0x378a	; 0x378a <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2ca:	0c 94 77 17 	jmp	0x2eee	; 0x2eee <_ZN8emstream13ready_to_sendEv>
     2ce:	0c 94 7c 17 	jmp	0x2ef8	; 0x2ef8 <_ZN8emstream14check_for_charEv>
     2d2:	0c 94 06 18 	jmp	0x300c	; 0x300c <_ZN8emstreamlsE15ser_manipulator+0x82>
     2d6:	0c 94 08 18 	jmp	0x3010	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
     2da:	0c 94 04 1d 	jmp	0x3a08	; 0x3a08 <_ZN9frt_queueIiE7ISR_getEv>
     2de:	0c 94 ac 03 	jmp	0x758	; 0x758 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>
     2e2:	0c 94 b5 13 	jmp	0x276a	; 0x276a <_ZN8frt_task12print_statusER8emstream>
     2e6:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     2ea:	0c 94 da 17 	jmp	0x2fb4	; 0x2fb4 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2ee:	0c 94 6c 03 	jmp	0x6d8	; 0x6d8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2f2:	0c 94 d0 1b 	jmp	0x37a0	; 0x37a0 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     2f6:	0c 94 dd 17 	jmp	0x2fba	; 0x2fba <_ZN8emstreamlsE15ser_manipulator+0x30>
     2fa:	0c 94 e5 17 	jmp	0x2fca	; 0x2fca <_ZN8emstreamlsE15ser_manipulator+0x40>
     2fe:	0c 94 4c 19 	jmp	0x3298	; 0x3298 <_ZN5rs23214check_for_charEv>
     302:	0c 94 3a 1c 	jmp	0x3874	; 0x3874 <_ZN9frt_queueIjE10get_a_copyEv>
     306:	0c 94 61 1c 	jmp	0x38c2	; 0x38c2 <_ZN9frt_queueIjE3getEv>
     30a:	0c 94 1d 15 	jmp	0x2a3a	; 0x2a3a <_ZN14frt_text_queue14check_for_charEv>
     30e:	0c 94 64 1d 	jmp	0x3ac8	; 0x3ac8 <_ZN9frt_queueIiE7ISR_putERKi>
     312:	0c 94 28 15 	jmp	0x2a50	; 0x2a50 <_ZN14frt_text_queue7putcharEc>
     316:	0c 94 da 1b 	jmp	0x37b4	; 0x37b4 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     31a:	0c 94 be 1b 	jmp	0x377c	; 0x377c <_ZN9frt_queueIjE16ISR_num_items_inEv>

0000031e <__trampolines_end>:
     31e:	2c 20       	and	r2, r12
     320:	54 43       	sbci	r21, 0x34	; 52
     322:	43 30       	cpi	r20, 0x03	; 3
     324:	43 43       	sbci	r20, 0x33	; 51
     326:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000329 <_ZZN9task_user11show_statusEvE3__c_3>:
     329:	2f 00                                               /.

0000032b <_ZZN9task_user11show_statusEvE3__c_2>:
     32b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000339 <_ZZN9task_user11show_statusEvE3__c_1>:
     339:	54 69 6d 65 3a 20 00                                Time: .

00000340 <_ZZN9task_user11show_statusEvE3__c_0>:
     340:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

0000034c <_ZZN9task_user11show_statusEvE3__c>:
     34c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     35c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000036b <_ZZN9task_user18print_help_messageEvE3__c_10>:
     36b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000037a <_ZZN9task_user18print_help_messageEvE3__c_9>:
     37a:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     38a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000395 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     395:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3a5:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003b3 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3b3:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3c3:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3d3:	6d 61 74 69 6f 6e 00                                mation.

000003da <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3da:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3ea:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003fb <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3fb:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     40b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000413 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     413:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     423:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000042f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     42f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     43f:	68 65 20 41 56 52 00                                he AVR.

00000446 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     446:	20 68 65 6c 70 00                                    help.

0000044c <_ZZN9task_user18print_help_messageEvE3__c_1>:
     44c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     45c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000046b <_ZZN9task_user18print_help_messageEvE3__c_0>:
     46b:	1b 5b 33 30 6d 00                                   .[30m.

00000471 <_ZZN9task_user18print_help_messageEvE3__c>:
     471:	1b 5b 34 36 6d 00                                   .[46m.

00000477 <_ZZN9task_user3runEvE3__c_3>:
     477:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     487:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000494 <_ZZN9task_user3runEvE3__c_2>:
     494:	3a 57 54 46 3f 00                                   :WTF?.

0000049a <_ZZN9task_user3runEvE3__c_1>:
     49a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4aa:	65 00                                               e.

000004ac <_ZZN9task_user3runEvE3__c_0>:
     4ac:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004ba <_ZZN9task_user3runEvE3__c>:
     4ba:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4ca:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004d8 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4d8:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004e2 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4e2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004f1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4f1:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     501:	61 73 6b 20 00                                      ask .

00000506 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     506:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000514 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     514:	20 63 72 65 61 74 65 64 00                           created.

0000051d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     51d:	54 61 73 6b 20 00                                   Task .

00000523 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     523:	1b 5b 32 32 6d 00                                   .[22m.

00000529 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     529:	54 61 73 6b 3a 20 00                                Task: .

00000530 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     530:	1b 5b 31 6d 00                                      .[1m.

00000535 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     53b:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000546 <_ZZ17print_task_stacksP8emstreamE3__c>:
     546:	1b 5b 31 6d 00                                      .[1m.

0000054b <_ZZ15print_task_listP8emstreamE3__c_9>:
     54b:	09 09 00                                            ...

0000054e <_ZZ15print_task_listP8emstreamE3__c_8>:
     54e:	2f 00                                               /.

00000550 <_ZZ15print_task_listP8emstreamE3__c_7>:
     550:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000055b <_ZZ15print_task_listP8emstreamE3__c_6>:
     55b:	09 2d 2d 2d 2d 00                                   .----.

00000561 <_ZZ15print_task_listP8emstreamE3__c_5>:
     561:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000056d <_ZZ15print_task_listP8emstreamE3__c_4>:
     56d:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000057e <_ZZ15print_task_listP8emstreamE3__c_3>:
     57e:	09 52 75 6e 73 00                                   .Runs.

00000584 <_ZZ15print_task_listP8emstreamE3__c_2>:
     584:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000590 <_ZZ15print_task_listP8emstreamE3__c_1>:
     590:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005a1 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5a1:	09 53 74 61 63 6b 00                                .Stack.

000005a8 <_ZZ15print_task_listP8emstreamE3__c>:
     5a8:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005b3 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5b3:	09 00                                               ..

000005b5 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5b5:	09 00                                               ..

000005b7 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5b7:	2f 00                                               /.

000005b9 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5b9:	09 00                                               ..

000005bb <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5bb:	09 00                                               ..

000005bd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5bd:	1b 5b 32 32 6d 00                                   .[22m.

000005c3 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5c3:	1b 5b 31 6d 00                                      .[1m.

000005c8 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5cd:	20 20 00                                              .

000005d0 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5d0:	0e 94 4d 12 	call	0x249a	; 0x249a <_ZN8frt_task22_call_users_run_methodEPS_>

000005d4 <__ctors_start>:
     5d4:	41 1e       	adc	r4, r17

000005d6 <__ctors_end>:
     5d6:	11 24       	eor	r1, r1
     5d8:	1f be       	out	0x3f, r1	; 63
     5da:	cf ef       	ldi	r28, 0xFF	; 255
     5dc:	cd bf       	out	0x3d, r28	; 61
     5de:	df e3       	ldi	r29, 0x3F	; 63
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	00 e0       	ldi	r16, 0x00	; 0
     5e4:	0c bf       	out	0x3c, r16	; 60
     5e6:	18 be       	out	0x38, r1	; 56
     5e8:	19 be       	out	0x39, r1	; 57
     5ea:	1a be       	out	0x3a, r1	; 58
     5ec:	1b be       	out	0x3b, r1	; 59

000005ee <__do_copy_data>:
     5ee:	10 e2       	ldi	r17, 0x20	; 32
     5f0:	a0 e0       	ldi	r26, 0x00	; 0
     5f2:	b0 e2       	ldi	r27, 0x20	; 32
     5f4:	ea e6       	ldi	r30, 0x6A	; 106
     5f6:	ff e3       	ldi	r31, 0x3F	; 63
     5f8:	00 e0       	ldi	r16, 0x00	; 0
     5fa:	0b bf       	out	0x3b, r16	; 59
     5fc:	02 c0       	rjmp	.+4      	; 0x602 <__do_copy_data+0x14>
     5fe:	07 90       	elpm	r0, Z+
     600:	0d 92       	st	X+, r0
     602:	ae 3d       	cpi	r26, 0xDE	; 222
     604:	b1 07       	cpc	r27, r17
     606:	d9 f7       	brne	.-10     	; 0x5fe <__do_copy_data+0x10>
     608:	1b be       	out	0x3b, r1	; 59

0000060a <__do_clear_bss>:
     60a:	21 e3       	ldi	r18, 0x31	; 49
     60c:	ae ed       	ldi	r26, 0xDE	; 222
     60e:	b0 e2       	ldi	r27, 0x20	; 32
     610:	01 c0       	rjmp	.+2      	; 0x614 <.do_clear_bss_start>

00000612 <.do_clear_bss_loop>:
     612:	1d 92       	st	X+, r1

00000614 <.do_clear_bss_start>:
     614:	ac 3a       	cpi	r26, 0xAC	; 172
     616:	b2 07       	cpc	r27, r18
     618:	e1 f7       	brne	.-8      	; 0x612 <.do_clear_bss_loop>

0000061a <__do_global_ctors>:
     61a:	12 e0       	ldi	r17, 0x02	; 2
     61c:	cb ee       	ldi	r28, 0xEB	; 235
     61e:	d2 e0       	ldi	r29, 0x02	; 2
     620:	00 e0       	ldi	r16, 0x00	; 0
     622:	06 c0       	rjmp	.+12     	; 0x630 <__do_global_ctors+0x16>
     624:	21 97       	sbiw	r28, 0x01	; 1
     626:	01 09       	sbc	r16, r1
     628:	80 2f       	mov	r24, r16
     62a:	fe 01       	movw	r30, r28
     62c:	0e 94 0f 1f 	call	0x3e1e	; 0x3e1e <__tablejump2__>
     630:	ca 3e       	cpi	r28, 0xEA	; 234
     632:	d1 07       	cpc	r29, r17
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	08 07       	cpc	r16, r24
     638:	a9 f7       	brne	.-22     	; 0x624 <__do_global_ctors+0xa>
     63a:	0e 94 d9 1d 	call	0x3bb2	; 0x3bb2 <main>
     63e:	0c 94 b3 1f 	jmp	0x3f66	; 0x3f66 <_exit>

00000642 <__bad_interrupt>:
     642:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000646 <_ZN9I2CMaster11Transmitter10StartState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     646:	0f 93       	push	r16
     648:	1f 93       	push	r17
     64a:	cf 93       	push	r28
     64c:	df 93       	push	r29
     64e:	ec 01       	movw	r28, r24
     650:	cb 01       	movw	r24, r22
     652:	0e 81       	ldd	r16, Y+6	; 0x06
     654:	1f 81       	ldd	r17, Y+7	; 0x07
     656:	db 01       	movw	r26, r22
     658:	ed 91       	ld	r30, X+
     65a:	fc 91       	ld	r31, X
     65c:	00 84       	ldd	r0, Z+8	; 0x08
     65e:	f1 85       	ldd	r31, Z+9	; 0x09
     660:	e0 2d       	mov	r30, r0
     662:	19 95       	eicall
     664:	f8 01       	movw	r30, r16
     666:	86 83       	std	Z+6, r24	; 0x06
     668:	8a 81       	ldd	r24, Y+2	; 0x02
     66a:	9b 81       	ldd	r25, Y+3	; 0x03
     66c:	df 91       	pop	r29
     66e:	cf 91       	pop	r28
     670:	1f 91       	pop	r17
     672:	0f 91       	pop	r16
     674:	08 95       	ret

00000676 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
     67a:	1f 92       	push	r1
     67c:	1f 92       	push	r1
     67e:	cd b7       	in	r28, 0x3d	; 61
     680:	de b7       	in	r29, 0x3e	; 62
     682:	dc 01       	movw	r26, r24
     684:	18 96       	adiw	r26, 0x08	; 8
     686:	8d 91       	ld	r24, X+
     688:	9c 91       	ld	r25, X
     68a:	19 97       	sbiw	r26, 0x09	; 9
     68c:	89 83       	std	Y+1, r24	; 0x01
     68e:	9a 83       	std	Y+2, r25	; 0x02
     690:	29 81       	ldd	r18, Y+1	; 0x01
     692:	3a 81       	ldd	r19, Y+2	; 0x02
     694:	21 50       	subi	r18, 0x01	; 1
     696:	31 09       	sbc	r19, r1
     698:	29 83       	std	Y+1, r18	; 0x01
     69a:	3a 83       	std	Y+2, r19	; 0x02
     69c:	23 2b       	or	r18, r19
     69e:	91 f0       	breq	.+36     	; 0x6c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     6a0:	16 96       	adiw	r26, 0x06	; 6
     6a2:	ed 91       	ld	r30, X+
     6a4:	fc 91       	ld	r31, X
     6a6:	17 97       	sbiw	r26, 0x07	; 7
     6a8:	94 81       	ldd	r25, Z+4	; 0x04
     6aa:	90 75       	andi	r25, 0x50	; 80
     6ac:	89 f7       	brne	.-30     	; 0x690 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
     6ae:	0a c0       	rjmp	.+20     	; 0x6c4 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x4e>
     6b0:	14 96       	adiw	r26, 0x04	; 4
     6b2:	8d 91       	ld	r24, X+
     6b4:	9c 91       	ld	r25, X
     6b6:	15 97       	sbiw	r26, 0x05	; 5
     6b8:	0a c0       	rjmp	.+20     	; 0x6ce <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     6ba:	12 96       	adiw	r26, 0x02	; 2
     6bc:	8d 91       	ld	r24, X+
     6be:	9c 91       	ld	r25, X
     6c0:	13 97       	sbiw	r26, 0x03	; 3
     6c2:	05 c0       	rjmp	.+10     	; 0x6ce <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
     6c4:	29 81       	ldd	r18, Y+1	; 0x01
     6c6:	3a 81       	ldd	r19, Y+2	; 0x02
     6c8:	23 2b       	or	r18, r19
     6ca:	b9 f7       	brne	.-18     	; 0x6ba <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x44>
     6cc:	f1 cf       	rjmp	.-30     	; 0x6b0 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3a>
     6ce:	0f 90       	pop	r0
     6d0:	0f 90       	pop	r0
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	08 95       	ret

000006d8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     6d8:	ef 92       	push	r14
     6da:	ff 92       	push	r15
     6dc:	0f 93       	push	r16
     6de:	1f 93       	push	r17
     6e0:	cf 93       	push	r28
     6e2:	df 93       	push	r29
     6e4:	8c 01       	movw	r16, r24
     6e6:	eb 01       	movw	r28, r22
     6e8:	e8 81       	ld	r30, Y
     6ea:	f9 81       	ldd	r31, Y+1	; 0x01
     6ec:	00 8c       	ldd	r0, Z+24	; 0x18
     6ee:	f1 8d       	ldd	r31, Z+25	; 0x19
     6f0:	e0 2d       	mov	r30, r0
     6f2:	cb 01       	movw	r24, r22
     6f4:	19 95       	eicall
     6f6:	88 23       	and	r24, r24
     6f8:	61 f0       	breq	.+24     	; 0x712 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x3a>
     6fa:	f8 01       	movw	r30, r16
     6fc:	e6 80       	ldd	r14, Z+6	; 0x06
     6fe:	f7 80       	ldd	r15, Z+7	; 0x07
     700:	e8 81       	ld	r30, Y
     702:	f9 81       	ldd	r31, Y+1	; 0x01
     704:	00 84       	ldd	r0, Z+8	; 0x08
     706:	f1 85       	ldd	r31, Z+9	; 0x09
     708:	e0 2d       	mov	r30, r0
     70a:	ce 01       	movw	r24, r28
     70c:	19 95       	eicall
     70e:	f7 01       	movw	r30, r14
     710:	87 83       	std	Z+7, r24	; 0x07
     712:	f8 01       	movw	r30, r16
     714:	82 81       	ldd	r24, Z+2	; 0x02
     716:	93 81       	ldd	r25, Z+3	; 0x03
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	1f 91       	pop	r17
     71e:	0f 91       	pop	r16
     720:	ff 90       	pop	r15
     722:	ef 90       	pop	r14
     724:	08 95       	ret

00000726 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     726:	cf 93       	push	r28
     728:	df 93       	push	r29
     72a:	ec 01       	movw	r28, r24
     72c:	cb 01       	movw	r24, r22
     72e:	db 01       	movw	r26, r22
     730:	ed 91       	ld	r30, X+
     732:	fc 91       	ld	r31, X
     734:	04 88       	ldd	r0, Z+20	; 0x14
     736:	f5 89       	ldd	r31, Z+21	; 0x15
     738:	e0 2d       	mov	r30, r0
     73a:	19 95       	eicall
     73c:	88 23       	and	r24, r24
     73e:	19 f0       	breq	.+6      	; 0x746 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     740:	8a 81       	ldd	r24, Y+2	; 0x02
     742:	9b 81       	ldd	r25, Y+3	; 0x03
     744:	02 c0       	rjmp	.+4      	; 0x74a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     746:	8c 81       	ldd	r24, Y+4	; 0x04
     748:	9d 81       	ldd	r25, Y+5	; 0x05
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <_ZN9I2CMaster11Transmitter9DoneState7executeER6Packet>:
     750:	fc 01       	movw	r30, r24
     752:	82 81       	ldd	r24, Z+2	; 0x02
     754:	93 81       	ldd	r25, Z+3	; 0x03
     756:	08 95       	ret

00000758 <_ZN9I2CMaster11Transmitter10ErrorState7executeER6Packet>:
     758:	fc 01       	movw	r30, r24
     75a:	82 81       	ldd	r24, Z+2	; 0x02
     75c:	93 81       	ldd	r25, Z+3	; 0x03
     75e:	08 95       	ret

00000760 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     760:	0f 93       	push	r16
     762:	1f 93       	push	r17
     764:	cf 93       	push	r28
     766:	df 93       	push	r29
     768:	ec 01       	movw	r28, r24
     76a:	8b 01       	movw	r16, r22
     76c:	88 e0       	ldi	r24, 0x08	; 8
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     774:	2a e0       	ldi	r18, 0x0A	; 10
     776:	30 e2       	ldi	r19, 0x20	; 32
     778:	fc 01       	movw	r30, r24
     77a:	20 83       	st	Z, r18
     77c:	31 83       	std	Z+1, r19	; 0x01
     77e:	06 83       	std	Z+6, r16	; 0x06
     780:	17 83       	std	Z+7, r17	; 0x07
     782:	8a 83       	std	Y+2, r24	; 0x02
     784:	9b 83       	std	Y+3, r25	; 0x03
     786:	8a e0       	ldi	r24, 0x0A	; 10
     788:	90 e0       	ldi	r25, 0x00	; 0
     78a:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     78e:	fc 01       	movw	r30, r24
     790:	89 89       	ldd	r24, Y+17	; 0x11
     792:	9a 89       	ldd	r25, Y+18	; 0x12
     794:	20 e1       	ldi	r18, 0x10	; 16
     796:	30 e2       	ldi	r19, 0x20	; 32
     798:	20 83       	st	Z, r18
     79a:	31 83       	std	Z+1, r19	; 0x01
     79c:	06 83       	std	Z+6, r16	; 0x06
     79e:	17 83       	std	Z+7, r17	; 0x07
     7a0:	80 87       	std	Z+8, r24	; 0x08
     7a2:	91 87       	std	Z+9, r25	; 0x09
     7a4:	ec 83       	std	Y+4, r30	; 0x04
     7a6:	fd 83       	std	Y+5, r31	; 0x05
     7a8:	88 e0       	ldi	r24, 0x08	; 8
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     7b0:	26 e1       	ldi	r18, 0x16	; 22
     7b2:	30 e2       	ldi	r19, 0x20	; 32
     7b4:	fc 01       	movw	r30, r24
     7b6:	20 83       	st	Z, r18
     7b8:	31 83       	std	Z+1, r19	; 0x01
     7ba:	06 83       	std	Z+6, r16	; 0x06
     7bc:	17 83       	std	Z+7, r17	; 0x07
     7be:	8e 83       	std	Y+6, r24	; 0x06
     7c0:	9f 83       	std	Y+7, r25	; 0x07
     7c2:	88 e0       	ldi	r24, 0x08	; 8
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     7ca:	2c e1       	ldi	r18, 0x1C	; 28
     7cc:	30 e2       	ldi	r19, 0x20	; 32
     7ce:	fc 01       	movw	r30, r24
     7d0:	20 83       	st	Z, r18
     7d2:	31 83       	std	Z+1, r19	; 0x01
     7d4:	06 83       	std	Z+6, r16	; 0x06
     7d6:	17 83       	std	Z+7, r17	; 0x07
     7d8:	88 87       	std	Y+8, r24	; 0x08
     7da:	99 87       	std	Y+9, r25	; 0x09
     7dc:	88 e0       	ldi	r24, 0x08	; 8
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     7e4:	28 e2       	ldi	r18, 0x28	; 40
     7e6:	30 e2       	ldi	r19, 0x20	; 32
     7e8:	fc 01       	movw	r30, r24
     7ea:	20 83       	st	Z, r18
     7ec:	31 83       	std	Z+1, r19	; 0x01
     7ee:	06 83       	std	Z+6, r16	; 0x06
     7f0:	17 83       	std	Z+7, r17	; 0x07
     7f2:	8a 87       	std	Y+10, r24	; 0x0a
     7f4:	9b 87       	std	Y+11, r25	; 0x0b
     7f6:	88 e0       	ldi	r24, 0x08	; 8
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     7fe:	22 e2       	ldi	r18, 0x22	; 34
     800:	30 e2       	ldi	r19, 0x20	; 32
     802:	fc 01       	movw	r30, r24
     804:	20 83       	st	Z, r18
     806:	31 83       	std	Z+1, r19	; 0x01
     808:	06 83       	std	Z+6, r16	; 0x06
     80a:	17 83       	std	Z+7, r17	; 0x07
     80c:	8c 87       	std	Y+12, r24	; 0x0c
     80e:	9d 87       	std	Y+13, r25	; 0x0d
     810:	80 e1       	ldi	r24, 0x10	; 16
     812:	97 e2       	ldi	r25, 0x27	; 39
     814:	89 8b       	std	Y+17, r24	; 0x11
     816:	9a 8b       	std	Y+18, r25	; 0x12
     818:	8c 81       	ldd	r24, Y+4	; 0x04
     81a:	9d 81       	ldd	r25, Y+5	; 0x05
     81c:	ea 81       	ldd	r30, Y+2	; 0x02
     81e:	fb 81       	ldd	r31, Y+3	; 0x03
     820:	82 83       	std	Z+2, r24	; 0x02
     822:	93 83       	std	Z+3, r25	; 0x03
     824:	84 83       	std	Z+4, r24	; 0x04
     826:	95 83       	std	Z+5, r25	; 0x05
     828:	8a 85       	ldd	r24, Y+10	; 0x0a
     82a:	9b 85       	ldd	r25, Y+11	; 0x0b
     82c:	2e 81       	ldd	r18, Y+6	; 0x06
     82e:	3f 81       	ldd	r19, Y+7	; 0x07
     830:	ec 81       	ldd	r30, Y+4	; 0x04
     832:	fd 81       	ldd	r31, Y+5	; 0x05
     834:	22 83       	std	Z+2, r18	; 0x02
     836:	33 83       	std	Z+3, r19	; 0x03
     838:	84 83       	std	Z+4, r24	; 0x04
     83a:	95 83       	std	Z+5, r25	; 0x05
     83c:	88 85       	ldd	r24, Y+8	; 0x08
     83e:	99 85       	ldd	r25, Y+9	; 0x09
     840:	ee 81       	ldd	r30, Y+6	; 0x06
     842:	ff 81       	ldd	r31, Y+7	; 0x07
     844:	82 83       	std	Z+2, r24	; 0x02
     846:	93 83       	std	Z+3, r25	; 0x03
     848:	84 83       	std	Z+4, r24	; 0x04
     84a:	95 83       	std	Z+5, r25	; 0x05
     84c:	8c 81       	ldd	r24, Y+4	; 0x04
     84e:	9d 81       	ldd	r25, Y+5	; 0x05
     850:	2c 85       	ldd	r18, Y+12	; 0x0c
     852:	3d 85       	ldd	r19, Y+13	; 0x0d
     854:	e8 85       	ldd	r30, Y+8	; 0x08
     856:	f9 85       	ldd	r31, Y+9	; 0x09
     858:	22 83       	std	Z+2, r18	; 0x02
     85a:	33 83       	std	Z+3, r19	; 0x03
     85c:	84 83       	std	Z+4, r24	; 0x04
     85e:	95 83       	std	Z+5, r25	; 0x05
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	1f 91       	pop	r17
     866:	0f 91       	pop	r16
     868:	08 95       	ret

0000086a <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     870:	9a 01       	movw	r18, r20
     872:	ab 01       	movw	r20, r22
     874:	22 0f       	add	r18, r18
     876:	33 1f       	adc	r19, r19
     878:	44 1f       	adc	r20, r20
     87a:	55 1f       	adc	r21, r21
     87c:	60 e0       	ldi	r22, 0x00	; 0
     87e:	78 e4       	ldi	r23, 0x48	; 72
     880:	88 ee       	ldi	r24, 0xE8	; 232
     882:	91 e0       	ldi	r25, 0x01	; 1
     884:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
     888:	25 50       	subi	r18, 0x05	; 5
     88a:	2e 83       	std	Y+6, r18	; 0x06
  interface->MASTER.BAUD = baudrate;
     88c:	ea 81       	ldd	r30, Y+2	; 0x02
     88e:	fb 81       	ldd	r31, Y+3	; 0x03
     890:	25 83       	std	Z+5, r18	; 0x05
}
     892:	df 91       	pop	r29
     894:	cf 91       	pop	r28
     896:	08 95       	ret

00000898 <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t* interface, uint32_t i2c_freq)
     898:	af 92       	push	r10
     89a:	bf 92       	push	r11
     89c:	cf 92       	push	r12
     89e:	df 92       	push	r13
     8a0:	ef 92       	push	r14
     8a2:	ff 92       	push	r15
     8a4:	0f 93       	push	r16
     8a6:	1f 93       	push	r17
     8a8:	cf 93       	push	r28
     8aa:	df 93       	push	r29
     8ac:	8c 01       	movw	r16, r24
     8ae:	eb 01       	movw	r28, r22
     8b0:	69 01       	movw	r12, r18
     8b2:	7a 01       	movw	r14, r20
  : interface(interface), 
    i2c_freq(i2c_freq),
    transmitter_( new Transmitter(interface) )
     8b4:	83 e1       	ldi	r24, 0x13	; 19
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
     8bc:	5c 01       	movw	r10, r24
     8be:	be 01       	movw	r22, r28
     8c0:	0e 94 b0 03 	call	0x760	; 0x760 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     8c4:	d8 01       	movw	r26, r16
     8c6:	ad 92       	st	X+, r10
     8c8:	bc 92       	st	X, r11
     8ca:	11 97       	sbiw	r26, 0x01	; 1
     8cc:	12 96       	adiw	r26, 0x02	; 2
     8ce:	cd 93       	st	X+, r28
     8d0:	dc 93       	st	X, r29
     8d2:	13 97       	sbiw	r26, 0x03	; 3
     8d4:	f8 01       	movw	r30, r16
     8d6:	c7 82       	std	Z+7, r12	; 0x07
     8d8:	d0 86       	std	Z+8, r13	; 0x08
     8da:	e1 86       	std	Z+9, r14	; 0x09
     8dc:	f2 86       	std	Z+10, r15	; 0x0a
{ 
  if (interface == &TWIC)
     8de:	c0 38       	cpi	r28, 0x80	; 128
     8e0:	f4 e0       	ldi	r31, 0x04	; 4
     8e2:	df 07       	cpc	r29, r31
     8e4:	39 f4       	brne	.+14     	; 0x8f4 <_ZN9I2CMasterC1EP10TWI_structm+0x5c>
  {
    bus_port = &PORTC;
     8e6:	80 e4       	ldi	r24, 0x40	; 64
     8e8:	96 e0       	ldi	r25, 0x06	; 6
     8ea:	14 96       	adiw	r26, 0x04	; 4
     8ec:	8d 93       	st	X+, r24
     8ee:	9c 93       	st	X, r25
     8f0:	15 97       	sbiw	r26, 0x05	; 5
     8f2:	09 c0       	rjmp	.+18     	; 0x906 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  }
  if (interface == &TWIE)
     8f4:	c0 3a       	cpi	r28, 0xA0	; 160
     8f6:	b4 e0       	ldi	r27, 0x04	; 4
     8f8:	db 07       	cpc	r29, r27
     8fa:	29 f4       	brne	.+10     	; 0x906 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
  {
    bus_port = &PORTE;
     8fc:	80 e8       	ldi	r24, 0x80	; 128
     8fe:	96 e0       	ldi	r25, 0x06	; 6
     900:	f8 01       	movw	r30, r16
     902:	84 83       	std	Z+4, r24	; 0x04
     904:	95 83       	std	Z+5, r25	; 0x05
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     906:	d8 01       	movw	r26, r16
     908:	14 96       	adiw	r26, 0x04	; 4
     90a:	ed 91       	ld	r30, X+
     90c:	fc 91       	ld	r31, X
     90e:	15 97       	sbiw	r26, 0x05	; 5
     910:	83 e0       	ldi	r24, 0x03	; 3
     912:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     914:	14 96       	adiw	r26, 0x04	; 4
     916:	ed 91       	ld	r30, X+
     918:	fc 91       	ld	r31, X
     91a:	15 97       	sbiw	r26, 0x05	; 5
     91c:	88 e3       	ldi	r24, 0x38	; 56
     91e:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     920:	14 96       	adiw	r26, 0x04	; 4
     922:	ed 91       	ld	r30, X+
     924:	fc 91       	ld	r31, X
     926:	15 97       	sbiw	r26, 0x05	; 5
     928:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     92a:	82 e0       	ldi	r24, 0x02	; 2
     92c:	8a 83       	std	Y+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     92e:	b7 01       	movw	r22, r14
     930:	a6 01       	movw	r20, r12
     932:	c8 01       	movw	r24, r16
     934:	0e 94 35 04 	call	0x86a	; 0x86a <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     938:	8c 81       	ldd	r24, Y+4	; 0x04
     93a:	8d 6c       	ori	r24, 0xCD	; 205
     93c:	8c 83       	std	Y+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     93e:	88 e0       	ldi	r24, 0x08	; 8
     940:	89 83       	std	Y+1, r24	; 0x01
}
     942:	df 91       	pop	r29
     944:	cf 91       	pop	r28
     946:	1f 91       	pop	r17
     948:	0f 91       	pop	r16
     94a:	ff 90       	pop	r15
     94c:	ef 90       	pop	r14
     94e:	df 90       	pop	r13
     950:	cf 90       	pop	r12
     952:	bf 90       	pop	r11
     954:	af 90       	pop	r10
     956:	08 95       	ret

00000958 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	cf 93       	push	r28
     95e:	df 93       	push	r29
     960:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     962:	0e 94 60 12 	call	0x24c0	; 0x24c0 <_ZN8frt_taskC1EPKchjP8emstream>
     966:	8e e2       	ldi	r24, 0x2E	; 46
     968:	90 e2       	ldi	r25, 0x20	; 32
     96a:	88 83       	st	Y, r24
     96c:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	08 95       	ret

00000978 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     978:	0f 93       	push	r16
     97a:	1f 93       	push	r17
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
     980:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     982:	6a e0       	ldi	r22, 0x0A	; 10
     984:	8e 81       	ldd	r24, Y+6	; 0x06
     986:	9f 81       	ldd	r25, Y+7	; 0x07
     988:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     98c:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     98e:	61 e7       	ldi	r22, 0x71	; 113
     990:	74 e0       	ldi	r23, 0x04	; 4
     992:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     996:	6a e0       	ldi	r22, 0x0A	; 10
     998:	c8 01       	movw	r24, r16
     99a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     99e:	8c 01       	movw	r16, r24
     9a0:	6b e6       	ldi	r22, 0x6B	; 107
     9a2:	74 e0       	ldi	r23, 0x04	; 4
     9a4:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     9a8:	67 e0       	ldi	r22, 0x07	; 7
     9aa:	c8 01       	movw	r24, r16
     9ac:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     9b0:	6a e0       	ldi	r22, 0x0A	; 10
     9b2:	8e 81       	ldd	r24, Y+6	; 0x06
     9b4:	9f 81       	ldd	r25, Y+7	; 0x07
     9b6:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     9ba:	8c 01       	movw	r16, r24
     9bc:	6c e4       	ldi	r22, 0x4C	; 76
     9be:	74 e0       	ldi	r23, 0x04	; 4
     9c0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     9c4:	6a e0       	ldi	r22, 0x0A	; 10
     9c6:	c8 01       	movw	r24, r16
     9c8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     9cc:	8c 01       	movw	r16, r24
     9ce:	66 e4       	ldi	r22, 0x46	; 70
     9d0:	74 e0       	ldi	r23, 0x04	; 4
     9d2:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     9d6:	66 e0       	ldi	r22, 0x06	; 6
     9d8:	c8 01       	movw	r24, r16
     9da:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     9de:	6a e0       	ldi	r22, 0x0A	; 10
     9e0:	8e 81       	ldd	r24, Y+6	; 0x06
     9e2:	9f 81       	ldd	r25, Y+7	; 0x07
     9e4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     9e8:	8c 01       	movw	r16, r24
     9ea:	6f e2       	ldi	r22, 0x2F	; 47
     9ec:	74 e0       	ldi	r23, 0x04	; 4
     9ee:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     9f2:	66 e0       	ldi	r22, 0x06	; 6
     9f4:	c8 01       	movw	r24, r16
     9f6:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     9fa:	6a e0       	ldi	r22, 0x0A	; 10
     9fc:	8e 81       	ldd	r24, Y+6	; 0x06
     9fe:	9f 81       	ldd	r25, Y+7	; 0x07
     a00:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a04:	8c 01       	movw	r16, r24
     a06:	63 e1       	ldi	r22, 0x13	; 19
     a08:	74 e0       	ldi	r23, 0x04	; 4
     a0a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a0e:	66 e0       	ldi	r22, 0x06	; 6
     a10:	c8 01       	movw	r24, r16
     a12:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     a16:	6a e0       	ldi	r22, 0x0A	; 10
     a18:	8e 81       	ldd	r24, Y+6	; 0x06
     a1a:	9f 81       	ldd	r25, Y+7	; 0x07
     a1c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a20:	8c 01       	movw	r16, r24
     a22:	6b ef       	ldi	r22, 0xFB	; 251
     a24:	73 e0       	ldi	r23, 0x03	; 3
     a26:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a2a:	66 e0       	ldi	r22, 0x06	; 6
     a2c:	c8 01       	movw	r24, r16
     a2e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     a32:	6a e0       	ldi	r22, 0x0A	; 10
     a34:	8e 81       	ldd	r24, Y+6	; 0x06
     a36:	9f 81       	ldd	r25, Y+7	; 0x07
     a38:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a3c:	8c 01       	movw	r16, r24
     a3e:	6a ed       	ldi	r22, 0xDA	; 218
     a40:	73 e0       	ldi	r23, 0x03	; 3
     a42:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a46:	66 e0       	ldi	r22, 0x06	; 6
     a48:	c8 01       	movw	r24, r16
     a4a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     a4e:	6a e0       	ldi	r22, 0x0A	; 10
     a50:	8e 81       	ldd	r24, Y+6	; 0x06
     a52:	9f 81       	ldd	r25, Y+7	; 0x07
     a54:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a58:	8c 01       	movw	r16, r24
     a5a:	63 eb       	ldi	r22, 0xB3	; 179
     a5c:	73 e0       	ldi	r23, 0x03	; 3
     a5e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a62:	66 e0       	ldi	r22, 0x06	; 6
     a64:	c8 01       	movw	r24, r16
     a66:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     a6a:	6a e0       	ldi	r22, 0x0A	; 10
     a6c:	8e 81       	ldd	r24, Y+6	; 0x06
     a6e:	9f 81       	ldd	r25, Y+7	; 0x07
     a70:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a74:	8c 01       	movw	r16, r24
     a76:	65 e9       	ldi	r22, 0x95	; 149
     a78:	73 e0       	ldi	r23, 0x03	; 3
     a7a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a7e:	66 e0       	ldi	r22, 0x06	; 6
     a80:	c8 01       	movw	r24, r16
     a82:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     a86:	6a e0       	ldi	r22, 0x0A	; 10
     a88:	8e 81       	ldd	r24, Y+6	; 0x06
     a8a:	9f 81       	ldd	r25, Y+7	; 0x07
     a8c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     a90:	8c 01       	movw	r16, r24
     a92:	6a e7       	ldi	r22, 0x7A	; 122
     a94:	73 e0       	ldi	r23, 0x03	; 3
     a96:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     a9a:	66 e0       	ldi	r22, 0x06	; 6
     a9c:	c8 01       	movw	r24, r16
     a9e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     aa2:	6a e0       	ldi	r22, 0x0A	; 10
     aa4:	8e 81       	ldd	r24, Y+6	; 0x06
     aa6:	9f 81       	ldd	r25, Y+7	; 0x07
     aa8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     aac:	ec 01       	movw	r28, r24
     aae:	6b e6       	ldi	r22, 0x6B	; 107
     ab0:	73 e0       	ldi	r23, 0x03	; 3
     ab2:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     ab6:	66 e0       	ldi	r22, 0x06	; 6
     ab8:	ce 01       	movw	r24, r28
     aba:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
}
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	1f 91       	pop	r17
     ac4:	0f 91       	pop	r16
     ac6:	08 95       	ret

00000ac8 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     ac8:	af 92       	push	r10
     aca:	bf 92       	push	r11
     acc:	cf 92       	push	r12
     ace:	df 92       	push	r13
     ad0:	ef 92       	push	r14
     ad2:	ff 92       	push	r15
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	00 d0       	rcall	.+0      	; 0xade <_ZN9task_user11show_statusEv+0x16>
     ade:	00 d0       	rcall	.+0      	; 0xae0 <_ZN9task_user11show_statusEv+0x18>
     ae0:	cd b7       	in	r28, 0x3d	; 61
     ae2:	de b7       	in	r29, 0x3e	; 62
     ae4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ae6:	19 82       	std	Y+1, r1	; 0x01
     ae8:	1a 82       	std	Y+2, r1	; 0x02
     aea:	1b 82       	std	Y+3, r1	; 0x03
     aec:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     aee:	1d 82       	std	Y+5, r1	; 0x05
     af0:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     af2:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <xPortGetFreeHeapSize>
     af6:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     af8:	ce 01       	movw	r24, r28
     afa:	01 96       	adiw	r24, 0x01	; 1
     afc:	0e 94 11 16 	call	0x2c22	; 0x2c22 <_ZN10time_stamp10set_to_nowEv>
     b00:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     b02:	66 e0       	ldi	r22, 0x06	; 6
     b04:	f8 01       	movw	r30, r16
     b06:	86 81       	ldd	r24, Z+6	; 0x06
     b08:	97 81       	ldd	r25, Z+7	; 0x07
     b0a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b0e:	6a e0       	ldi	r22, 0x0A	; 10
     b10:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b14:	7c 01       	movw	r14, r24
     b16:	6c e4       	ldi	r22, 0x4C	; 76
     b18:	73 e0       	ldi	r23, 0x03	; 3
     b1a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     b1e:	6a e0       	ldi	r22, 0x0A	; 10
     b20:	c7 01       	movw	r24, r14
     b22:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b26:	7c 01       	movw	r14, r24
     b28:	60 e4       	ldi	r22, 0x40	; 64
     b2a:	73 e0       	ldi	r23, 0x03	; 3
     b2c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     b30:	66 e0       	ldi	r22, 0x06	; 6
     b32:	c7 01       	movw	r24, r14
     b34:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     b38:	6a e0       	ldi	r22, 0x0A	; 10
     b3a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b3e:	7c 01       	movw	r14, r24
     b40:	69 e3       	ldi	r22, 0x39	; 57
     b42:	73 e0       	ldi	r23, 0x03	; 3
     b44:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     b48:	b5 01       	movw	r22, r10
     b4a:	c7 01       	movw	r24, r14
     b4c:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     b50:	6a e0       	ldi	r22, 0x0A	; 10
     b52:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b56:	7c 01       	movw	r14, r24
     b58:	6b e2       	ldi	r22, 0x2B	; 43
     b5a:	73 e0       	ldi	r23, 0x03	; 3
     b5c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     b60:	b6 01       	movw	r22, r12
     b62:	c7 01       	movw	r24, r14
     b64:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
     b68:	6a e0       	ldi	r22, 0x0A	; 10
     b6a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b6e:	7c 01       	movw	r14, r24
     b70:	69 e2       	ldi	r22, 0x29	; 41
     b72:	73 e0       	ldi	r23, 0x03	; 3
     b74:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     b78:	4f ef       	ldi	r20, 0xFF	; 255
     b7a:	5f e0       	ldi	r21, 0x0F	; 15
     b7c:	60 e0       	ldi	r22, 0x00	; 0
     b7e:	70 e0       	ldi	r23, 0x00	; 0
     b80:	c7 01       	movw	r24, r14
     b82:	0e 94 40 18 	call	0x3080	; 0x3080 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     b86:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     b8a:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     b8e:	6a e0       	ldi	r22, 0x0A	; 10
     b90:	f8 01       	movw	r30, r16
     b92:	86 81       	ldd	r24, Z+6	; 0x06
     b94:	97 81       	ldd	r25, Z+7	; 0x07
     b96:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     b9a:	7c 01       	movw	r14, r24
     b9c:	6e e1       	ldi	r22, 0x1E	; 30
     b9e:	73 e0       	ldi	r23, 0x03	; 3
     ba0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     ba4:	b6 01       	movw	r22, r12
     ba6:	c7 01       	movw	r24, r14
     ba8:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
     bac:	66 e0       	ldi	r22, 0x06	; 6
     bae:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     bb2:	66 e0       	ldi	r22, 0x06	; 6
     bb4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     bb8:	f8 01       	movw	r30, r16
     bba:	86 81       	ldd	r24, Z+6	; 0x06
     bbc:	97 81       	ldd	r25, Z+7	; 0x07
     bbe:	0e 94 6e 14 	call	0x28dc	; 0x28dc <_Z15print_task_listP8emstream>
}
     bc2:	26 96       	adiw	r28, 0x06	; 6
     bc4:	cd bf       	out	0x3d, r28	; 61
     bc6:	de bf       	out	0x3e, r29	; 62
     bc8:	df 91       	pop	r29
     bca:	cf 91       	pop	r28
     bcc:	1f 91       	pop	r17
     bce:	0f 91       	pop	r16
     bd0:	ff 90       	pop	r15
     bd2:	ef 90       	pop	r14
     bd4:	df 90       	pop	r13
     bd6:	cf 90       	pop	r12
     bd8:	bf 90       	pop	r11
     bda:	af 90       	pop	r10
     bdc:	08 95       	ret

00000bde <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     bde:	cf 93       	push	r28
     be0:	df 93       	push	r29
     be2:	00 d0       	rcall	.+0      	; 0xbe4 <_ZN9task_user3runEv+0x6>
     be4:	00 d0       	rcall	.+0      	; 0xbe6 <_ZN9task_user3runEv+0x8>
     be6:	cd b7       	in	r28, 0x3d	; 61
     be8:	de b7       	in	r29, 0x3e	; 62
     bea:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     bec:	19 82       	std	Y+1, r1	; 0x01
     bee:	1a 82       	std	Y+2, r1	; 0x02
     bf0:	1b 82       	std	Y+3, r1	; 0x03
     bf2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     bf4:	1d 82       	std	Y+5, r1	; 0x05
     bf6:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     bf8:	6a e0       	ldi	r22, 0x0A	; 10
     bfa:	dc 01       	movw	r26, r24
     bfc:	16 96       	adiw	r26, 0x06	; 6
     bfe:	8d 91       	ld	r24, X+
     c00:	9c 91       	ld	r25, X
     c02:	17 97       	sbiw	r26, 0x07	; 7
     c04:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     c08:	7c 01       	movw	r14, r24
     c0a:	6a eb       	ldi	r22, 0xBA	; 186
     c0c:	74 e0       	ldi	r23, 0x04	; 4
     c0e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     c12:	66 e0       	ldi	r22, 0x06	; 6
     c14:	c7 01       	movw	r24, r14
     c16:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     c1a:	f8 01       	movw	r30, r16
     c1c:	84 85       	ldd	r24, Z+12	; 0x0c
     c1e:	88 23       	and	r24, r24
     c20:	21 f0       	breq	.+8      	; 0xc2a <_ZN9task_user3runEv+0x4c>
     c22:	81 30       	cpi	r24, 0x01	; 1
     c24:	09 f4       	brne	.+2      	; 0xc28 <_ZN9task_user3runEv+0x4a>
     c26:	5d c0       	rjmp	.+186    	; 0xce2 <_ZN9task_user3runEv+0x104>
     c28:	d8 c0       	rjmp	.+432    	; 0xdda <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     c2a:	86 81       	ldd	r24, Z+6	; 0x06
     c2c:	97 81       	ldd	r25, Z+7	; 0x07
     c2e:	dc 01       	movw	r26, r24
     c30:	ed 91       	ld	r30, X+
     c32:	fc 91       	ld	r31, X
     c34:	04 80       	ldd	r0, Z+4	; 0x04
     c36:	f5 81       	ldd	r31, Z+5	; 0x05
     c38:	e0 2d       	mov	r30, r0
     c3a:	19 95       	eicall
     c3c:	88 23       	and	r24, r24
     c3e:	a9 f1       	breq	.+106    	; 0xcaa <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     c40:	f8 01       	movw	r30, r16
     c42:	86 81       	ldd	r24, Z+6	; 0x06
     c44:	97 81       	ldd	r25, Z+7	; 0x07
     c46:	dc 01       	movw	r26, r24
     c48:	ed 91       	ld	r30, X+
     c4a:	fc 91       	ld	r31, X
     c4c:	06 80       	ldd	r0, Z+6	; 0x06
     c4e:	f7 81       	ldd	r31, Z+7	; 0x07
     c50:	e0 2d       	mov	r30, r0
     c52:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     c54:	99 27       	eor	r25, r25
     c56:	81 30       	cpi	r24, 0x01	; 1
     c58:	91 05       	cpc	r25, r1
     c5a:	f9 f0       	breq	.+62     	; 0xc9a <_ZN9task_user3runEv+0xbc>
     c5c:	03 97       	sbiw	r24, 0x03	; 3
     c5e:	09 f0       	breq	.+2      	; 0xc62 <_ZN9task_user3runEv+0x84>
     c60:	d8 c0       	rjmp	.+432    	; 0xe12 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     c62:	6a e0       	ldi	r22, 0x0A	; 10
     c64:	f8 01       	movw	r30, r16
     c66:	86 81       	ldd	r24, Z+6	; 0x06
     c68:	97 81       	ldd	r25, Z+7	; 0x07
     c6a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     c6e:	8c 01       	movw	r16, r24
     c70:	6c ea       	ldi	r22, 0xAC	; 172
     c72:	74 e0       	ldi	r23, 0x04	; 4
     c74:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     c78:	66 e0       	ldi	r22, 0x06	; 6
     c7a:	c8 01       	movw	r24, r16
     c7c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     c80:	93 e0       	ldi	r25, 0x03	; 3
     c82:	88 ed       	ldi	r24, 0xD8	; 216
     c84:	08 b6       	in	r0, 0x38	; 56
     c86:	18 be       	out	0x38, r1	; 56
     c88:	84 bf       	out	0x34, r24	; 52
     c8a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     c8e:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     c92:	81 fd       	sbrc	r24, 1
     c94:	fc cf       	rjmp	.-8      	; 0xc8e <_ZN9task_user3runEv+0xb0>
     c96:	08 be       	out	0x38, r0	; 56
     c98:	ff cf       	rjmp	.-2      	; 0xc98 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     c9a:	c8 01       	movw	r24, r16
     c9c:	0e 94 bc 04 	call	0x978	; 0x978 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     ca0:	61 e0       	ldi	r22, 0x01	; 1
     ca2:	c8 01       	movw	r24, r16
     ca4:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <_ZN8frt_task13transition_toEh>
							break;
     ca8:	b4 c0       	rjmp	.+360    	; 0xe12 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     caa:	8a e9       	ldi	r24, 0x9A	; 154
     cac:	91 e3       	ldi	r25, 0x31	; 49
     cae:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <_ZN14frt_text_queue14check_for_charEv>
     cb2:	88 23       	and	r24, r24
     cb4:	09 f4       	brne	.+2      	; 0xcb8 <_ZN9task_user3runEv+0xda>
     cb6:	ad c0       	rjmp	.+346    	; 0xe12 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     cb8:	d8 01       	movw	r26, r16
     cba:	16 96       	adiw	r26, 0x06	; 6
     cbc:	ed 91       	ld	r30, X+
     cbe:	fc 91       	ld	r31, X
     cc0:	17 97       	sbiw	r26, 0x07	; 7
     cc2:	01 90       	ld	r0, Z+
     cc4:	f0 81       	ld	r31, Z
     cc6:	e0 2d       	mov	r30, r0
     cc8:	e2 80       	ldd	r14, Z+2	; 0x02
     cca:	f3 80       	ldd	r15, Z+3	; 0x03
     ccc:	8a e9       	ldi	r24, 0x9A	; 154
     cce:	91 e3       	ldi	r25, 0x31	; 49
     cd0:	0e 94 ff 14 	call	0x29fe	; 0x29fe <_ZN14frt_text_queue7getcharEv>
     cd4:	68 2f       	mov	r22, r24
     cd6:	f8 01       	movw	r30, r16
     cd8:	86 81       	ldd	r24, Z+6	; 0x06
     cda:	97 81       	ldd	r25, Z+7	; 0x07
     cdc:	f7 01       	movw	r30, r14
     cde:	19 95       	eicall
     ce0:	98 c0       	rjmp	.+304    	; 0xe12 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     ce2:	86 81       	ldd	r24, Z+6	; 0x06
     ce4:	97 81       	ldd	r25, Z+7	; 0x07
     ce6:	dc 01       	movw	r26, r24
     ce8:	ed 91       	ld	r30, X+
     cea:	fc 91       	ld	r31, X
     cec:	04 80       	ldd	r0, Z+4	; 0x04
     cee:	f5 81       	ldd	r31, Z+5	; 0x05
     cf0:	e0 2d       	mov	r30, r0
     cf2:	19 95       	eicall
     cf4:	88 23       	and	r24, r24
     cf6:	09 f4       	brne	.+2      	; 0xcfa <_ZN9task_user3runEv+0x11c>
     cf8:	8c c0       	rjmp	.+280    	; 0xe12 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     cfa:	f8 01       	movw	r30, r16
     cfc:	86 81       	ldd	r24, Z+6	; 0x06
     cfe:	97 81       	ldd	r25, Z+7	; 0x07
     d00:	dc 01       	movw	r26, r24
     d02:	ed 91       	ld	r30, X+
     d04:	fc 91       	ld	r31, X
     d06:	06 80       	ldd	r0, Z+6	; 0x06
     d08:	f7 81       	ldd	r31, Z+7	; 0x07
     d0a:	e0 2d       	mov	r30, r0
     d0c:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     d0e:	9c 01       	movw	r18, r24
     d10:	33 27       	eor	r19, r19
     d12:	28 36       	cpi	r18, 0x68	; 104
     d14:	31 05       	cpc	r19, r1
     d16:	59 f1       	breq	.+86     	; 0xd6e <_ZN9task_user3runEv+0x190>
     d18:	3c f4       	brge	.+14     	; 0xd28 <_ZN9task_user3runEv+0x14a>
     d1a:	2b 31       	cpi	r18, 0x1B	; 27
     d1c:	31 05       	cpc	r19, r1
     d1e:	59 f1       	breq	.+86     	; 0xd76 <_ZN9task_user3runEv+0x198>
     d20:	25 36       	cpi	r18, 0x65	; 101
     d22:	31 05       	cpc	r19, r1
     d24:	41 f1       	breq	.+80     	; 0xd76 <_ZN9task_user3runEv+0x198>
     d26:	3b c0       	rjmp	.+118    	; 0xd9e <_ZN9task_user3runEv+0x1c0>
     d28:	23 37       	cpi	r18, 0x73	; 115
     d2a:	31 05       	cpc	r19, r1
     d2c:	c1 f0       	breq	.+48     	; 0xd5e <_ZN9task_user3runEv+0x180>
     d2e:	26 37       	cpi	r18, 0x76	; 118
     d30:	31 05       	cpc	r19, r1
     d32:	89 f0       	breq	.+34     	; 0xd56 <_ZN9task_user3runEv+0x178>
     d34:	2e 36       	cpi	r18, 0x6E	; 110
     d36:	31 05       	cpc	r19, r1
     d38:	91 f5       	brne	.+100    	; 0xd9e <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     d3a:	ce 01       	movw	r24, r28
     d3c:	01 96       	adiw	r24, 0x01	; 1
     d3e:	0e 94 11 16 	call	0x2c22	; 0x2c22 <_ZN10time_stamp10set_to_nowEv>
     d42:	bc 01       	movw	r22, r24
     d44:	f8 01       	movw	r30, r16
     d46:	86 81       	ldd	r24, Z+6	; 0x06
     d48:	97 81       	ldd	r25, Z+7	; 0x07
     d4a:	0e 94 b5 15 	call	0x2b6a	; 0x2b6a <_ZlsR8emstreamR10time_stamp>
     d4e:	66 e0       	ldi	r22, 0x06	; 6
     d50:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
							break;
     d54:	5e c0       	rjmp	.+188    	; 0xe12 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     d56:	c8 01       	movw	r24, r16
     d58:	0e 94 64 05 	call	0xac8	; 0xac8 <_ZN9task_user11show_statusEv>
							break;
     d5c:	5a c0       	rjmp	.+180    	; 0xe12 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     d5e:	d8 01       	movw	r26, r16
     d60:	16 96       	adiw	r26, 0x06	; 6
     d62:	8d 91       	ld	r24, X+
     d64:	9c 91       	ld	r25, X
     d66:	17 97       	sbiw	r26, 0x07	; 7
     d68:	0e 94 75 13 	call	0x26ea	; 0x26ea <_Z17print_task_stacksP8emstream>
							break;
     d6c:	52 c0       	rjmp	.+164    	; 0xe12 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     d6e:	c8 01       	movw	r24, r16
     d70:	0e 94 bc 04 	call	0x978	; 0x978 <_ZN9task_user18print_help_messageEv>
							break;
     d74:	4e c0       	rjmp	.+156    	; 0xe12 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     d76:	6a e0       	ldi	r22, 0x0A	; 10
     d78:	f8 01       	movw	r30, r16
     d7a:	86 81       	ldd	r24, Z+6	; 0x06
     d7c:	97 81       	ldd	r25, Z+7	; 0x07
     d7e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     d82:	7c 01       	movw	r14, r24
     d84:	6a e9       	ldi	r22, 0x9A	; 154
     d86:	74 e0       	ldi	r23, 0x04	; 4
     d88:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     d8c:	66 e0       	ldi	r22, 0x06	; 6
     d8e:	c7 01       	movw	r24, r14
     d90:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     d94:	60 e0       	ldi	r22, 0x00	; 0
     d96:	c8 01       	movw	r24, r16
     d98:	0e 94 5c 12 	call	0x24b8	; 0x24b8 <_ZN8frt_task13transition_toEh>
							break;
     d9c:	3a c0       	rjmp	.+116    	; 0xe12 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     d9e:	f8 01       	movw	r30, r16
     da0:	a6 81       	ldd	r26, Z+6	; 0x06
     da2:	b7 81       	ldd	r27, Z+7	; 0x07
     da4:	ed 91       	ld	r30, X+
     da6:	fc 91       	ld	r31, X
     da8:	11 97       	sbiw	r26, 0x01	; 1
     daa:	02 80       	ldd	r0, Z+2	; 0x02
     dac:	f3 81       	ldd	r31, Z+3	; 0x03
     dae:	e0 2d       	mov	r30, r0
     db0:	68 2f       	mov	r22, r24
     db2:	cd 01       	movw	r24, r26
     db4:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     db6:	6a e0       	ldi	r22, 0x0A	; 10
     db8:	d8 01       	movw	r26, r16
     dba:	16 96       	adiw	r26, 0x06	; 6
     dbc:	8d 91       	ld	r24, X+
     dbe:	9c 91       	ld	r25, X
     dc0:	17 97       	sbiw	r26, 0x07	; 7
     dc2:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     dc6:	7c 01       	movw	r14, r24
     dc8:	64 e9       	ldi	r22, 0x94	; 148
     dca:	74 e0       	ldi	r23, 0x04	; 4
     dcc:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     dd0:	66 e0       	ldi	r22, 0x06	; 6
     dd2:	c7 01       	movw	r24, r14
     dd4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
							break;
     dd8:	1c c0       	rjmp	.+56     	; 0xe12 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     dda:	6a e0       	ldi	r22, 0x0A	; 10
     ddc:	f8 01       	movw	r30, r16
     dde:	86 81       	ldd	r24, Z+6	; 0x06
     de0:	97 81       	ldd	r25, Z+7	; 0x07
     de2:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
     de6:	8c 01       	movw	r16, r24
     de8:	67 e7       	ldi	r22, 0x77	; 119
     dea:	74 e0       	ldi	r23, 0x04	; 4
     dec:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
     df0:	66 e0       	ldi	r22, 0x06	; 6
     df2:	c8 01       	movw	r24, r16
     df4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     df8:	93 e0       	ldi	r25, 0x03	; 3
     dfa:	88 ed       	ldi	r24, 0xD8	; 216
     dfc:	08 b6       	in	r0, 0x38	; 56
     dfe:	18 be       	out	0x38, r1	; 56
     e00:	84 bf       	out	0x34, r24	; 52
     e02:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e06:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e0a:	81 fd       	sbrc	r24, 1
     e0c:	fc cf       	rjmp	.-8      	; 0xe06 <_ZN9task_user3runEv+0x228>
     e0e:	08 be       	out	0x38, r0	; 56
     e10:	ff cf       	rjmp	.-2      	; 0xe10 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     e12:	f8 01       	movw	r30, r16
     e14:	86 85       	ldd	r24, Z+14	; 0x0e
     e16:	97 85       	ldd	r25, Z+15	; 0x0f
     e18:	a0 89       	ldd	r26, Z+16	; 0x10
     e1a:	b1 89       	ldd	r27, Z+17	; 0x11
     e1c:	01 96       	adiw	r24, 0x01	; 1
     e1e:	a1 1d       	adc	r26, r1
     e20:	b1 1d       	adc	r27, r1
     e22:	86 87       	std	Z+14, r24	; 0x0e
     e24:	97 87       	std	Z+15, r25	; 0x0f
     e26:	a0 8b       	std	Z+16, r26	; 0x10
     e28:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     e2a:	61 e0       	ldi	r22, 0x01	; 1
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	80 e0       	ldi	r24, 0x00	; 0
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	0e 94 30 10 	call	0x2060	; 0x2060 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     e36:	f1 ce       	rjmp	.-542    	; 0xc1a <_ZN9task_user3runEv+0x3c>

00000e38 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     e42:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     e46:	80 91 de 20 	lds	r24, 0x20DE	; 0x8020de <__data_end>
     e4a:	81 11       	cpse	r24, r1
     e4c:	1d c0       	rjmp	.+58     	; 0xe88 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     e4e:	a3 ee       	ldi	r26, 0xE3	; 227
     e50:	b0 e2       	ldi	r27, 0x20	; 32
     e52:	e7 ee       	ldi	r30, 0xE7	; 231
     e54:	f0 e2       	ldi	r31, 0x20	; 32
     e56:	ed 93       	st	X+, r30
     e58:	fc 93       	st	X, r31
     e5a:	11 97       	sbiw	r26, 0x01	; 1
     e5c:	12 96       	adiw	r26, 0x02	; 2
     e5e:	1d 92       	st	X+, r1
     e60:	1c 92       	st	X, r1
     e62:	13 97       	sbiw	r26, 0x03	; 3
     e64:	af ed       	ldi	r26, 0xDF	; 223
     e66:	b0 e2       	ldi	r27, 0x20	; 32
     e68:	8f ef       	ldi	r24, 0xFF	; 255
     e6a:	9f e0       	ldi	r25, 0x0F	; 15
     e6c:	12 96       	adiw	r26, 0x02	; 2
     e6e:	8d 93       	st	X+, r24
     e70:	9c 93       	st	X, r25
     e72:	13 97       	sbiw	r26, 0x03	; 3
     e74:	1d 92       	st	X+, r1
     e76:	1c 92       	st	X, r1
     e78:	11 97       	sbiw	r26, 0x01	; 1
     e7a:	82 83       	std	Z+2, r24	; 0x02
     e7c:	93 83       	std	Z+3, r25	; 0x03
     e7e:	a0 83       	st	Z, r26
     e80:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	80 93 de 20 	sts	0x20DE, r24	; 0x8020de <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     e88:	20 97       	sbiw	r28, 0x00	; 0
     e8a:	09 f4       	brne	.+2      	; 0xe8e <pvPortMalloc+0x56>
     e8c:	5f c0       	rjmp	.+190    	; 0xf4c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e8e:	9e 01       	movw	r18, r28
     e90:	2b 5f       	subi	r18, 0xFB	; 251
     e92:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     e94:	24 96       	adiw	r28, 0x04	; 4
     e96:	ce 3f       	cpi	r28, 0xFE	; 254
     e98:	df 40       	sbci	r29, 0x0F	; 15
     e9a:	08 f0       	brcs	.+2      	; 0xe9e <pvPortMalloc+0x66>
     e9c:	5a c0       	rjmp	.+180    	; 0xf52 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     e9e:	e0 91 e3 20 	lds	r30, 0x20E3	; 0x8020e3 <xStart>
     ea2:	f0 91 e4 20 	lds	r31, 0x20E4	; 0x8020e4 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     ea6:	a3 ee       	ldi	r26, 0xE3	; 227
     ea8:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <pvPortMalloc+0x78>
     eac:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     eae:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     eb0:	82 81       	ldd	r24, Z+2	; 0x02
     eb2:	93 81       	ldd	r25, Z+3	; 0x03
     eb4:	82 17       	cp	r24, r18
     eb6:	93 07       	cpc	r25, r19
     eb8:	20 f4       	brcc	.+8      	; 0xec2 <pvPortMalloc+0x8a>
     eba:	80 81       	ld	r24, Z
     ebc:	91 81       	ldd	r25, Z+1	; 0x01
     ebe:	00 97       	sbiw	r24, 0x00	; 0
     ec0:	a9 f7       	brne	.-22     	; 0xeac <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     ec2:	c0 e2       	ldi	r28, 0x20	; 32
     ec4:	ef 3d       	cpi	r30, 0xDF	; 223
     ec6:	fc 07       	cpc	r31, r28
     ec8:	09 f4       	brne	.+2      	; 0xecc <pvPortMalloc+0x94>
     eca:	46 c0       	rjmp	.+140    	; 0xf58 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     ecc:	cd 91       	ld	r28, X+
     ece:	dc 91       	ld	r29, X
     ed0:	11 97       	sbiw	r26, 0x01	; 1
     ed2:	8e 01       	movw	r16, r28
     ed4:	0b 5f       	subi	r16, 0xFB	; 251
     ed6:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     ed8:	80 81       	ld	r24, Z
     eda:	91 81       	ldd	r25, Z+1	; 0x01
     edc:	8d 93       	st	X+, r24
     ede:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     ee0:	82 81       	ldd	r24, Z+2	; 0x02
     ee2:	93 81       	ldd	r25, Z+3	; 0x03
     ee4:	82 1b       	sub	r24, r18
     ee6:	93 0b       	sbc	r25, r19
     ee8:	8b 30       	cpi	r24, 0x0B	; 11
     eea:	91 05       	cpc	r25, r1
     eec:	10 f1       	brcs	.+68     	; 0xf32 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     eee:	bf 01       	movw	r22, r30
     ef0:	62 0f       	add	r22, r18
     ef2:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     ef4:	db 01       	movw	r26, r22
     ef6:	12 96       	adiw	r26, 0x02	; 2
     ef8:	8d 93       	st	X+, r24
     efa:	9c 93       	st	X, r25
     efc:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     efe:	22 83       	std	Z+2, r18	; 0x02
     f00:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f02:	12 96       	adiw	r26, 0x02	; 2
     f04:	4d 91       	ld	r20, X+
     f06:	5c 91       	ld	r21, X
     f08:	13 97       	sbiw	r26, 0x03	; 3
     f0a:	83 ee       	ldi	r24, 0xE3	; 227
     f0c:	90 e2       	ldi	r25, 0x20	; 32
     f0e:	01 c0       	rjmp	.+2      	; 0xf12 <pvPortMalloc+0xda>
     f10:	cd 01       	movw	r24, r26
     f12:	ec 01       	movw	r28, r24
     f14:	a8 81       	ld	r26, Y
     f16:	b9 81       	ldd	r27, Y+1	; 0x01
     f18:	12 96       	adiw	r26, 0x02	; 2
     f1a:	2d 91       	ld	r18, X+
     f1c:	3c 91       	ld	r19, X
     f1e:	13 97       	sbiw	r26, 0x03	; 3
     f20:	24 17       	cp	r18, r20
     f22:	35 07       	cpc	r19, r21
     f24:	a8 f3       	brcs	.-22     	; 0xf10 <pvPortMalloc+0xd8>
     f26:	eb 01       	movw	r28, r22
     f28:	a8 83       	st	Y, r26
     f2a:	b9 83       	std	Y+1, r27	; 0x01
     f2c:	dc 01       	movw	r26, r24
     f2e:	6d 93       	st	X+, r22
     f30:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     f32:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     f36:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     f3a:	22 81       	ldd	r18, Z+2	; 0x02
     f3c:	33 81       	ldd	r19, Z+3	; 0x03
     f3e:	82 1b       	sub	r24, r18
     f40:	93 0b       	sbc	r25, r19
     f42:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     f46:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     f4a:	08 c0       	rjmp	.+16     	; 0xf5c <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     f4c:	00 e0       	ldi	r16, 0x00	; 0
     f4e:	10 e0       	ldi	r17, 0x00	; 0
     f50:	05 c0       	rjmp	.+10     	; 0xf5c <pvPortMalloc+0x124>
     f52:	00 e0       	ldi	r16, 0x00	; 0
     f54:	10 e0       	ldi	r17, 0x00	; 0
     f56:	02 c0       	rjmp	.+4      	; 0xf5c <pvPortMalloc+0x124>
     f58:	00 e0       	ldi	r16, 0x00	; 0
     f5a:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     f5c:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     f60:	c8 01       	movw	r24, r16
     f62:	df 91       	pop	r29
     f64:	cf 91       	pop	r28
     f66:	1f 91       	pop	r17
     f68:	0f 91       	pop	r16
     f6a:	08 95       	ret

00000f6c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     f74:	00 97       	sbiw	r24, 0x00	; 0
     f76:	41 f1       	breq	.+80     	; 0xfc8 <vPortFree+0x5c>
     f78:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     f7a:	8c 01       	movw	r16, r24
     f7c:	05 50       	subi	r16, 0x05	; 5
     f7e:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     f80:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     f84:	f8 01       	movw	r30, r16
     f86:	42 81       	ldd	r20, Z+2	; 0x02
     f88:	53 81       	ldd	r21, Z+3	; 0x03
     f8a:	a3 ee       	ldi	r26, 0xE3	; 227
     f8c:	b0 e2       	ldi	r27, 0x20	; 32
     f8e:	01 c0       	rjmp	.+2      	; 0xf92 <vPortFree+0x26>
     f90:	df 01       	movw	r26, r30
     f92:	ed 91       	ld	r30, X+
     f94:	fc 91       	ld	r31, X
     f96:	11 97       	sbiw	r26, 0x01	; 1
     f98:	22 81       	ldd	r18, Z+2	; 0x02
     f9a:	33 81       	ldd	r19, Z+3	; 0x03
     f9c:	24 17       	cp	r18, r20
     f9e:	35 07       	cpc	r19, r21
     fa0:	b8 f3       	brcs	.-18     	; 0xf90 <vPortFree+0x24>
     fa2:	25 97       	sbiw	r28, 0x05	; 5
     fa4:	e8 83       	st	Y, r30
     fa6:	f9 83       	std	Y+1, r31	; 0x01
     fa8:	0d 93       	st	X+, r16
     faa:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     fac:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     fb0:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     fb4:	8a 81       	ldd	r24, Y+2	; 0x02
     fb6:	9b 81       	ldd	r25, Y+3	; 0x03
     fb8:	82 0f       	add	r24, r18
     fba:	93 1f       	adc	r25, r19
     fbc:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     fc0:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     fc4:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
	}
}
     fc8:	df 91       	pop	r29
     fca:	cf 91       	pop	r28
     fcc:	1f 91       	pop	r17
     fce:	0f 91       	pop	r16
     fd0:	08 95       	ret

00000fd2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     fd2:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     fd6:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     fda:	08 95       	ret

00000fdc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     fdc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     fde:	03 96       	adiw	r24, 0x03	; 3
     fe0:	81 83       	std	Z+1, r24	; 0x01
     fe2:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     fe4:	4f ef       	ldi	r20, 0xFF	; 255
     fe6:	5f ef       	ldi	r21, 0xFF	; 255
     fe8:	ba 01       	movw	r22, r20
     fea:	43 83       	std	Z+3, r20	; 0x03
     fec:	54 83       	std	Z+4, r21	; 0x04
     fee:	65 83       	std	Z+5, r22	; 0x05
     ff0:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     ff2:	87 83       	std	Z+7, r24	; 0x07
     ff4:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     ff6:	81 87       	std	Z+9, r24	; 0x09
     ff8:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     ffa:	10 82       	st	Z, r1
     ffc:	08 95       	ret

00000ffe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     ffe:	fc 01       	movw	r30, r24
    1000:	12 86       	std	Z+10, r1	; 0x0a
    1002:	13 86       	std	Z+11, r1	; 0x0b
    1004:	08 95       	ret

00001006 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
    100a:	fc 01       	movw	r30, r24
    100c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    100e:	21 81       	ldd	r18, Z+1	; 0x01
    1010:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1012:	e9 01       	movw	r28, r18
    1014:	8c 81       	ldd	r24, Y+4	; 0x04
    1016:	9d 81       	ldd	r25, Y+5	; 0x05
    1018:	14 96       	adiw	r26, 0x04	; 4
    101a:	8d 93       	st	X+, r24
    101c:	9c 93       	st	X, r25
    101e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1020:	81 81       	ldd	r24, Z+1	; 0x01
    1022:	92 81       	ldd	r25, Z+2	; 0x02
    1024:	16 96       	adiw	r26, 0x06	; 6
    1026:	8d 93       	st	X+, r24
    1028:	9c 93       	st	X, r25
    102a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    102c:	8c 81       	ldd	r24, Y+4	; 0x04
    102e:	9d 81       	ldd	r25, Y+5	; 0x05
    1030:	ec 01       	movw	r28, r24
    1032:	6e 83       	std	Y+6, r22	; 0x06
    1034:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1036:	e9 01       	movw	r28, r18
    1038:	6c 83       	std	Y+4, r22	; 0x04
    103a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    103c:	61 83       	std	Z+1, r22	; 0x01
    103e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1040:	1a 96       	adiw	r26, 0x0a	; 10
    1042:	ed 93       	st	X+, r30
    1044:	fc 93       	st	X, r31
    1046:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1048:	80 81       	ld	r24, Z
    104a:	8f 5f       	subi	r24, 0xFF	; 255
    104c:	80 83       	st	Z, r24
}
    104e:	df 91       	pop	r29
    1050:	cf 91       	pop	r28
    1052:	08 95       	ret

00001054 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1054:	0f 93       	push	r16
    1056:	1f 93       	push	r17
    1058:	cf 93       	push	r28
    105a:	df 93       	push	r29
    105c:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    105e:	08 81       	ld	r16, Y
    1060:	19 81       	ldd	r17, Y+1	; 0x01
    1062:	2a 81       	ldd	r18, Y+2	; 0x02
    1064:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1066:	0f 3f       	cpi	r16, 0xFF	; 255
    1068:	4f ef       	ldi	r20, 0xFF	; 255
    106a:	14 07       	cpc	r17, r20
    106c:	24 07       	cpc	r18, r20
    106e:	34 07       	cpc	r19, r20
    1070:	31 f4       	brne	.+12     	; 0x107e <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1072:	dc 01       	movw	r26, r24
    1074:	19 96       	adiw	r26, 0x09	; 9
    1076:	ed 91       	ld	r30, X+
    1078:	fc 91       	ld	r31, X
    107a:	1a 97       	sbiw	r26, 0x0a	; 10
    107c:	1f c0       	rjmp	.+62     	; 0x10bc <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    107e:	fc 01       	movw	r30, r24
    1080:	33 96       	adiw	r30, 0x03	; 3
    1082:	dc 01       	movw	r26, r24
    1084:	17 96       	adiw	r26, 0x07	; 7
    1086:	4d 91       	ld	r20, X+
    1088:	5c 91       	ld	r21, X
    108a:	18 97       	sbiw	r26, 0x08	; 8
    108c:	da 01       	movw	r26, r20
    108e:	4d 91       	ld	r20, X+
    1090:	5d 91       	ld	r21, X+
    1092:	6d 91       	ld	r22, X+
    1094:	7c 91       	ld	r23, X
    1096:	04 17       	cp	r16, r20
    1098:	15 07       	cpc	r17, r21
    109a:	26 07       	cpc	r18, r22
    109c:	37 07       	cpc	r19, r23
    109e:	70 f0       	brcs	.+28     	; 0x10bc <vListInsert+0x68>
    10a0:	04 80       	ldd	r0, Z+4	; 0x04
    10a2:	f5 81       	ldd	r31, Z+5	; 0x05
    10a4:	e0 2d       	mov	r30, r0
    10a6:	a4 81       	ldd	r26, Z+4	; 0x04
    10a8:	b5 81       	ldd	r27, Z+5	; 0x05
    10aa:	4d 91       	ld	r20, X+
    10ac:	5d 91       	ld	r21, X+
    10ae:	6d 91       	ld	r22, X+
    10b0:	7c 91       	ld	r23, X
    10b2:	04 17       	cp	r16, r20
    10b4:	15 07       	cpc	r17, r21
    10b6:	26 07       	cpc	r18, r22
    10b8:	37 07       	cpc	r19, r23
    10ba:	90 f7       	brcc	.-28     	; 0x10a0 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    10bc:	a4 81       	ldd	r26, Z+4	; 0x04
    10be:	b5 81       	ldd	r27, Z+5	; 0x05
    10c0:	ac 83       	std	Y+4, r26	; 0x04
    10c2:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10c4:	16 96       	adiw	r26, 0x06	; 6
    10c6:	cd 93       	st	X+, r28
    10c8:	dc 93       	st	X, r29
    10ca:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    10cc:	ee 83       	std	Y+6, r30	; 0x06
    10ce:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    10d0:	c4 83       	std	Z+4, r28	; 0x04
    10d2:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10d4:	8a 87       	std	Y+10, r24	; 0x0a
    10d6:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    10d8:	fc 01       	movw	r30, r24
    10da:	20 81       	ld	r18, Z
    10dc:	2f 5f       	subi	r18, 0xFF	; 255
    10de:	20 83       	st	Z, r18
}
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	08 95       	ret

000010ea <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    10ea:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    10ec:	a4 81       	ldd	r26, Z+4	; 0x04
    10ee:	b5 81       	ldd	r27, Z+5	; 0x05
    10f0:	86 81       	ldd	r24, Z+6	; 0x06
    10f2:	97 81       	ldd	r25, Z+7	; 0x07
    10f4:	16 96       	adiw	r26, 0x06	; 6
    10f6:	8d 93       	st	X+, r24
    10f8:	9c 93       	st	X, r25
    10fa:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    10fc:	a6 81       	ldd	r26, Z+6	; 0x06
    10fe:	b7 81       	ldd	r27, Z+7	; 0x07
    1100:	84 81       	ldd	r24, Z+4	; 0x04
    1102:	95 81       	ldd	r25, Z+5	; 0x05
    1104:	14 96       	adiw	r26, 0x04	; 4
    1106:	8d 93       	st	X+, r24
    1108:	9c 93       	st	X, r25
    110a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    110c:	a2 85       	ldd	r26, Z+10	; 0x0a
    110e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1110:	11 96       	adiw	r26, 0x01	; 1
    1112:	8d 91       	ld	r24, X+
    1114:	9c 91       	ld	r25, X
    1116:	12 97       	sbiw	r26, 0x02	; 2
    1118:	e8 17       	cp	r30, r24
    111a:	f9 07       	cpc	r31, r25
    111c:	31 f4       	brne	.+12     	; 0x112a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    111e:	86 81       	ldd	r24, Z+6	; 0x06
    1120:	97 81       	ldd	r25, Z+7	; 0x07
    1122:	11 96       	adiw	r26, 0x01	; 1
    1124:	8d 93       	st	X+, r24
    1126:	9c 93       	st	X, r25
    1128:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    112a:	12 86       	std	Z+10, r1	; 0x0a
    112c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    112e:	8c 91       	ld	r24, X
    1130:	81 50       	subi	r24, 0x01	; 1
    1132:	8c 93       	st	X, r24
    1134:	08 95       	ret

00001136 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1136:	80 93 aa 31 	sts	0x31AA, r24	; 0x8031aa <portStackTopForTask>
    113a:	90 93 ab 31 	sts	0x31AB, r25	; 0x8031ab <portStackTopForTask+0x1>
    113e:	31 e1       	ldi	r19, 0x11	; 17
    1140:	fc 01       	movw	r30, r24
    1142:	30 83       	st	Z, r19
    1144:	31 97       	sbiw	r30, 0x01	; 1
    1146:	22 e2       	ldi	r18, 0x22	; 34
    1148:	20 83       	st	Z, r18
    114a:	31 97       	sbiw	r30, 0x01	; 1
    114c:	a3 e3       	ldi	r26, 0x33	; 51
    114e:	a0 83       	st	Z, r26
    1150:	31 97       	sbiw	r30, 0x01	; 1
    1152:	60 83       	st	Z, r22
    1154:	31 97       	sbiw	r30, 0x01	; 1
    1156:	70 83       	st	Z, r23
    1158:	31 97       	sbiw	r30, 0x01	; 1
    115a:	10 82       	st	Z, r1
    115c:	31 97       	sbiw	r30, 0x01	; 1
    115e:	10 82       	st	Z, r1
    1160:	31 97       	sbiw	r30, 0x01	; 1
    1162:	60 e8       	ldi	r22, 0x80	; 128
    1164:	60 83       	st	Z, r22
    1166:	31 97       	sbiw	r30, 0x01	; 1
    1168:	10 82       	st	Z, r1
    116a:	31 97       	sbiw	r30, 0x01	; 1
    116c:	10 82       	st	Z, r1
    116e:	31 97       	sbiw	r30, 0x01	; 1
    1170:	10 82       	st	Z, r1
    1172:	31 97       	sbiw	r30, 0x01	; 1
    1174:	62 e0       	ldi	r22, 0x02	; 2
    1176:	60 83       	st	Z, r22
    1178:	31 97       	sbiw	r30, 0x01	; 1
    117a:	63 e0       	ldi	r22, 0x03	; 3
    117c:	60 83       	st	Z, r22
    117e:	31 97       	sbiw	r30, 0x01	; 1
    1180:	64 e0       	ldi	r22, 0x04	; 4
    1182:	60 83       	st	Z, r22
    1184:	31 97       	sbiw	r30, 0x01	; 1
    1186:	65 e0       	ldi	r22, 0x05	; 5
    1188:	60 83       	st	Z, r22
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	66 e0       	ldi	r22, 0x06	; 6
    118e:	60 83       	st	Z, r22
    1190:	31 97       	sbiw	r30, 0x01	; 1
    1192:	67 e0       	ldi	r22, 0x07	; 7
    1194:	60 83       	st	Z, r22
    1196:	31 97       	sbiw	r30, 0x01	; 1
    1198:	68 e0       	ldi	r22, 0x08	; 8
    119a:	60 83       	st	Z, r22
    119c:	31 97       	sbiw	r30, 0x01	; 1
    119e:	69 e0       	ldi	r22, 0x09	; 9
    11a0:	60 83       	st	Z, r22
    11a2:	31 97       	sbiw	r30, 0x01	; 1
    11a4:	60 e1       	ldi	r22, 0x10	; 16
    11a6:	60 83       	st	Z, r22
    11a8:	31 97       	sbiw	r30, 0x01	; 1
    11aa:	30 83       	st	Z, r19
    11ac:	31 97       	sbiw	r30, 0x01	; 1
    11ae:	32 e1       	ldi	r19, 0x12	; 18
    11b0:	30 83       	st	Z, r19
    11b2:	31 97       	sbiw	r30, 0x01	; 1
    11b4:	33 e1       	ldi	r19, 0x13	; 19
    11b6:	30 83       	st	Z, r19
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	34 e1       	ldi	r19, 0x14	; 20
    11bc:	30 83       	st	Z, r19
    11be:	31 97       	sbiw	r30, 0x01	; 1
    11c0:	35 e1       	ldi	r19, 0x15	; 21
    11c2:	30 83       	st	Z, r19
    11c4:	31 97       	sbiw	r30, 0x01	; 1
    11c6:	36 e1       	ldi	r19, 0x16	; 22
    11c8:	30 83       	st	Z, r19
    11ca:	31 97       	sbiw	r30, 0x01	; 1
    11cc:	37 e1       	ldi	r19, 0x17	; 23
    11ce:	30 83       	st	Z, r19
    11d0:	31 97       	sbiw	r30, 0x01	; 1
    11d2:	38 e1       	ldi	r19, 0x18	; 24
    11d4:	30 83       	st	Z, r19
    11d6:	31 97       	sbiw	r30, 0x01	; 1
    11d8:	39 e1       	ldi	r19, 0x19	; 25
    11da:	30 83       	st	Z, r19
    11dc:	31 97       	sbiw	r30, 0x01	; 1
    11de:	30 e2       	ldi	r19, 0x20	; 32
    11e0:	30 83       	st	Z, r19
    11e2:	31 97       	sbiw	r30, 0x01	; 1
    11e4:	31 e2       	ldi	r19, 0x21	; 33
    11e6:	30 83       	st	Z, r19
    11e8:	31 97       	sbiw	r30, 0x01	; 1
    11ea:	20 83       	st	Z, r18
    11ec:	31 97       	sbiw	r30, 0x01	; 1
    11ee:	23 e2       	ldi	r18, 0x23	; 35
    11f0:	20 83       	st	Z, r18
    11f2:	31 97       	sbiw	r30, 0x01	; 1
    11f4:	40 83       	st	Z, r20
    11f6:	31 97       	sbiw	r30, 0x01	; 1
    11f8:	50 83       	st	Z, r21
    11fa:	31 97       	sbiw	r30, 0x01	; 1
    11fc:	26 e2       	ldi	r18, 0x26	; 38
    11fe:	20 83       	st	Z, r18
    1200:	31 97       	sbiw	r30, 0x01	; 1
    1202:	27 e2       	ldi	r18, 0x27	; 39
    1204:	20 83       	st	Z, r18
    1206:	31 97       	sbiw	r30, 0x01	; 1
    1208:	28 e2       	ldi	r18, 0x28	; 40
    120a:	20 83       	st	Z, r18
    120c:	31 97       	sbiw	r30, 0x01	; 1
    120e:	29 e2       	ldi	r18, 0x29	; 41
    1210:	20 83       	st	Z, r18
    1212:	31 97       	sbiw	r30, 0x01	; 1
    1214:	20 e3       	ldi	r18, 0x30	; 48
    1216:	20 83       	st	Z, r18
    1218:	31 97       	sbiw	r30, 0x01	; 1
    121a:	21 e3       	ldi	r18, 0x31	; 49
    121c:	20 83       	st	Z, r18
    121e:	89 97       	sbiw	r24, 0x29	; 41
    1220:	08 95       	ret

00001222 <xPortStartScheduler>:
    1222:	8c e7       	ldi	r24, 0x7C	; 124
    1224:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1228:	8f ef       	ldi	r24, 0xFF	; 255
    122a:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    122e:	81 e0       	ldi	r24, 0x01	; 1
    1230:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1234:	91 e1       	ldi	r25, 0x11	; 17
    1236:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    123a:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    123e:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    1242:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1246:	cd 91       	ld	r28, X+
    1248:	cd bf       	out	0x3d, r28	; 61
    124a:	dd 91       	ld	r29, X+
    124c:	de bf       	out	0x3e, r29	; 62
    124e:	ff 91       	pop	r31
    1250:	ef 91       	pop	r30
    1252:	df 91       	pop	r29
    1254:	cf 91       	pop	r28
    1256:	bf 91       	pop	r27
    1258:	af 91       	pop	r26
    125a:	9f 91       	pop	r25
    125c:	8f 91       	pop	r24
    125e:	7f 91       	pop	r23
    1260:	6f 91       	pop	r22
    1262:	5f 91       	pop	r21
    1264:	4f 91       	pop	r20
    1266:	3f 91       	pop	r19
    1268:	2f 91       	pop	r18
    126a:	1f 91       	pop	r17
    126c:	0f 91       	pop	r16
    126e:	ff 90       	pop	r15
    1270:	ef 90       	pop	r14
    1272:	df 90       	pop	r13
    1274:	cf 90       	pop	r12
    1276:	bf 90       	pop	r11
    1278:	af 90       	pop	r10
    127a:	9f 90       	pop	r9
    127c:	8f 90       	pop	r8
    127e:	7f 90       	pop	r7
    1280:	6f 90       	pop	r6
    1282:	5f 90       	pop	r5
    1284:	4f 90       	pop	r4
    1286:	3f 90       	pop	r3
    1288:	2f 90       	pop	r2
    128a:	1f 90       	pop	r1
    128c:	0f 90       	pop	r0
    128e:	0c be       	out	0x3c, r0	; 60
    1290:	0f 90       	pop	r0
    1292:	0b be       	out	0x3b, r0	; 59
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
    1298:	0f 90       	pop	r0
    129a:	08 95       	ret
    129c:	08 95       	ret

0000129e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    129e:	0f 92       	push	r0
    12a0:	0f b6       	in	r0, 0x3f	; 63
    12a2:	f8 94       	cli
    12a4:	0f 92       	push	r0
    12a6:	0b b6       	in	r0, 0x3b	; 59
    12a8:	0f 92       	push	r0
    12aa:	0c b6       	in	r0, 0x3c	; 60
    12ac:	0f 92       	push	r0
    12ae:	1f 92       	push	r1
    12b0:	11 24       	eor	r1, r1
    12b2:	2f 92       	push	r2
    12b4:	3f 92       	push	r3
    12b6:	4f 92       	push	r4
    12b8:	5f 92       	push	r5
    12ba:	6f 92       	push	r6
    12bc:	7f 92       	push	r7
    12be:	8f 92       	push	r8
    12c0:	9f 92       	push	r9
    12c2:	af 92       	push	r10
    12c4:	bf 92       	push	r11
    12c6:	cf 92       	push	r12
    12c8:	df 92       	push	r13
    12ca:	ef 92       	push	r14
    12cc:	ff 92       	push	r15
    12ce:	0f 93       	push	r16
    12d0:	1f 93       	push	r17
    12d2:	2f 93       	push	r18
    12d4:	3f 93       	push	r19
    12d6:	4f 93       	push	r20
    12d8:	5f 93       	push	r21
    12da:	6f 93       	push	r22
    12dc:	7f 93       	push	r23
    12de:	8f 93       	push	r24
    12e0:	9f 93       	push	r25
    12e2:	af 93       	push	r26
    12e4:	bf 93       	push	r27
    12e6:	cf 93       	push	r28
    12e8:	df 93       	push	r29
    12ea:	ef 93       	push	r30
    12ec:	ff 93       	push	r31
    12ee:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    12f2:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    12f6:	0d b6       	in	r0, 0x3d	; 61
    12f8:	0d 92       	st	X+, r0
    12fa:	0e b6       	in	r0, 0x3e	; 62
    12fc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    12fe:	0e 94 5e 10 	call	0x20bc	; 0x20bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1302:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    1306:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    130a:	cd 91       	ld	r28, X+
    130c:	cd bf       	out	0x3d, r28	; 61
    130e:	dd 91       	ld	r29, X+
    1310:	de bf       	out	0x3e, r29	; 62
    1312:	ff 91       	pop	r31
    1314:	ef 91       	pop	r30
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	bf 91       	pop	r27
    131c:	af 91       	pop	r26
    131e:	9f 91       	pop	r25
    1320:	8f 91       	pop	r24
    1322:	7f 91       	pop	r23
    1324:	6f 91       	pop	r22
    1326:	5f 91       	pop	r21
    1328:	4f 91       	pop	r20
    132a:	3f 91       	pop	r19
    132c:	2f 91       	pop	r18
    132e:	1f 91       	pop	r17
    1330:	0f 91       	pop	r16
    1332:	ff 90       	pop	r15
    1334:	ef 90       	pop	r14
    1336:	df 90       	pop	r13
    1338:	cf 90       	pop	r12
    133a:	bf 90       	pop	r11
    133c:	af 90       	pop	r10
    133e:	9f 90       	pop	r9
    1340:	8f 90       	pop	r8
    1342:	7f 90       	pop	r7
    1344:	6f 90       	pop	r6
    1346:	5f 90       	pop	r5
    1348:	4f 90       	pop	r4
    134a:	3f 90       	pop	r3
    134c:	2f 90       	pop	r2
    134e:	1f 90       	pop	r1
    1350:	0f 90       	pop	r0
    1352:	0c be       	out	0x3c, r0	; 60
    1354:	0f 90       	pop	r0
    1356:	0b be       	out	0x3b, r0	; 59
    1358:	0f 90       	pop	r0
    135a:	0f be       	out	0x3f, r0	; 63
    135c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    135e:	08 95       	ret

00001360 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1360:	0f 92       	push	r0
    1362:	0f b6       	in	r0, 0x3f	; 63
    1364:	f8 94       	cli
    1366:	0f 92       	push	r0
    1368:	0b b6       	in	r0, 0x3b	; 59
    136a:	0f 92       	push	r0
    136c:	0c b6       	in	r0, 0x3c	; 60
    136e:	0f 92       	push	r0
    1370:	1f 92       	push	r1
    1372:	11 24       	eor	r1, r1
    1374:	2f 92       	push	r2
    1376:	3f 92       	push	r3
    1378:	4f 92       	push	r4
    137a:	5f 92       	push	r5
    137c:	6f 92       	push	r6
    137e:	7f 92       	push	r7
    1380:	8f 92       	push	r8
    1382:	9f 92       	push	r9
    1384:	af 92       	push	r10
    1386:	bf 92       	push	r11
    1388:	cf 92       	push	r12
    138a:	df 92       	push	r13
    138c:	ef 92       	push	r14
    138e:	ff 92       	push	r15
    1390:	0f 93       	push	r16
    1392:	1f 93       	push	r17
    1394:	2f 93       	push	r18
    1396:	3f 93       	push	r19
    1398:	4f 93       	push	r20
    139a:	5f 93       	push	r21
    139c:	6f 93       	push	r22
    139e:	7f 93       	push	r23
    13a0:	8f 93       	push	r24
    13a2:	9f 93       	push	r25
    13a4:	af 93       	push	r26
    13a6:	bf 93       	push	r27
    13a8:	cf 93       	push	r28
    13aa:	df 93       	push	r29
    13ac:	ef 93       	push	r30
    13ae:	ff 93       	push	r31
    13b0:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    13b4:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    13b8:	0d b6       	in	r0, 0x3d	; 61
    13ba:	0d 92       	st	X+, r0
    13bc:	0e b6       	in	r0, 0x3e	; 62
    13be:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    13c0:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <vTaskIncrementTick>
	vTaskSwitchContext();
    13c4:	0e 94 5e 10 	call	0x20bc	; 0x20bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13c8:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    13cc:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    13d0:	cd 91       	ld	r28, X+
    13d2:	cd bf       	out	0x3d, r28	; 61
    13d4:	dd 91       	ld	r29, X+
    13d6:	de bf       	out	0x3e, r29	; 62
    13d8:	ff 91       	pop	r31
    13da:	ef 91       	pop	r30
    13dc:	df 91       	pop	r29
    13de:	cf 91       	pop	r28
    13e0:	bf 91       	pop	r27
    13e2:	af 91       	pop	r26
    13e4:	9f 91       	pop	r25
    13e6:	8f 91       	pop	r24
    13e8:	7f 91       	pop	r23
    13ea:	6f 91       	pop	r22
    13ec:	5f 91       	pop	r21
    13ee:	4f 91       	pop	r20
    13f0:	3f 91       	pop	r19
    13f2:	2f 91       	pop	r18
    13f4:	1f 91       	pop	r17
    13f6:	0f 91       	pop	r16
    13f8:	ff 90       	pop	r15
    13fa:	ef 90       	pop	r14
    13fc:	df 90       	pop	r13
    13fe:	cf 90       	pop	r12
    1400:	bf 90       	pop	r11
    1402:	af 90       	pop	r10
    1404:	9f 90       	pop	r9
    1406:	8f 90       	pop	r8
    1408:	7f 90       	pop	r7
    140a:	6f 90       	pop	r6
    140c:	5f 90       	pop	r5
    140e:	4f 90       	pop	r4
    1410:	3f 90       	pop	r3
    1412:	2f 90       	pop	r2
    1414:	1f 90       	pop	r1
    1416:	0f 90       	pop	r0
    1418:	0c be       	out	0x3c, r0	; 60
    141a:	0f 90       	pop	r0
    141c:	0b be       	out	0x3b, r0	; 59
    141e:	0f 90       	pop	r0
    1420:	0f be       	out	0x3f, r0	; 63
    1422:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1424:	08 95       	ret

00001426 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1426:	0e 94 b0 09 	call	0x1360	; 0x1360 <vPortYieldFromTick>
		asm volatile ( "reti" );
    142a:	18 95       	reti

0000142c <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	ec 01       	movw	r28, r24
    1432:	88 a1       	ldd	r24, Y+32	; 0x20
    1434:	81 11       	cpse	r24, r1
    1436:	0b c0       	rjmp	.+22     	; 0x144e <prvCopyDataToQueue+0x22>
    1438:	88 81       	ld	r24, Y
    143a:	99 81       	ldd	r25, Y+1	; 0x01
    143c:	89 2b       	or	r24, r25
    143e:	e1 f5       	brne	.+120    	; 0x14b8 <prvCopyDataToQueue+0x8c>
    1440:	8a 81       	ldd	r24, Y+2	; 0x02
    1442:	9b 81       	ldd	r25, Y+3	; 0x03
    1444:	0e 94 19 12 	call	0x2432	; 0x2432 <vTaskPriorityDisinherit>
    1448:	1a 82       	std	Y+2, r1	; 0x02
    144a:	1b 82       	std	Y+3, r1	; 0x03
    144c:	35 c0       	rjmp	.+106    	; 0x14b8 <prvCopyDataToQueue+0x8c>
    144e:	41 11       	cpse	r20, r1
    1450:	17 c0       	rjmp	.+46     	; 0x1480 <prvCopyDataToQueue+0x54>
    1452:	48 2f       	mov	r20, r24
    1454:	50 e0       	ldi	r21, 0x00	; 0
    1456:	8c 81       	ldd	r24, Y+4	; 0x04
    1458:	9d 81       	ldd	r25, Y+5	; 0x05
    145a:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <memcpy>
    145e:	28 a1       	ldd	r18, Y+32	; 0x20
    1460:	8c 81       	ldd	r24, Y+4	; 0x04
    1462:	9d 81       	ldd	r25, Y+5	; 0x05
    1464:	82 0f       	add	r24, r18
    1466:	91 1d       	adc	r25, r1
    1468:	8c 83       	std	Y+4, r24	; 0x04
    146a:	9d 83       	std	Y+5, r25	; 0x05
    146c:	2a 81       	ldd	r18, Y+2	; 0x02
    146e:	3b 81       	ldd	r19, Y+3	; 0x03
    1470:	82 17       	cp	r24, r18
    1472:	93 07       	cpc	r25, r19
    1474:	08 f1       	brcs	.+66     	; 0x14b8 <prvCopyDataToQueue+0x8c>
    1476:	88 81       	ld	r24, Y
    1478:	99 81       	ldd	r25, Y+1	; 0x01
    147a:	8c 83       	std	Y+4, r24	; 0x04
    147c:	9d 83       	std	Y+5, r25	; 0x05
    147e:	1c c0       	rjmp	.+56     	; 0x14b8 <prvCopyDataToQueue+0x8c>
    1480:	48 2f       	mov	r20, r24
    1482:	50 e0       	ldi	r21, 0x00	; 0
    1484:	8e 81       	ldd	r24, Y+6	; 0x06
    1486:	9f 81       	ldd	r25, Y+7	; 0x07
    1488:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <memcpy>
    148c:	88 a1       	ldd	r24, Y+32	; 0x20
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	91 95       	neg	r25
    1492:	81 95       	neg	r24
    1494:	91 09       	sbc	r25, r1
    1496:	2e 81       	ldd	r18, Y+6	; 0x06
    1498:	3f 81       	ldd	r19, Y+7	; 0x07
    149a:	28 0f       	add	r18, r24
    149c:	39 1f       	adc	r19, r25
    149e:	2e 83       	std	Y+6, r18	; 0x06
    14a0:	3f 83       	std	Y+7, r19	; 0x07
    14a2:	48 81       	ld	r20, Y
    14a4:	59 81       	ldd	r21, Y+1	; 0x01
    14a6:	24 17       	cp	r18, r20
    14a8:	35 07       	cpc	r19, r21
    14aa:	30 f4       	brcc	.+12     	; 0x14b8 <prvCopyDataToQueue+0x8c>
    14ac:	2a 81       	ldd	r18, Y+2	; 0x02
    14ae:	3b 81       	ldd	r19, Y+3	; 0x03
    14b0:	82 0f       	add	r24, r18
    14b2:	93 1f       	adc	r25, r19
    14b4:	8e 83       	std	Y+6, r24	; 0x06
    14b6:	9f 83       	std	Y+7, r25	; 0x07
    14b8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14ba:	8f 5f       	subi	r24, 0xFF	; 255
    14bc:	8e 8f       	std	Y+30, r24	; 0x1e
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	08 95       	ret

000014c4 <prvCopyDataFromQueue>:
    14c4:	fc 01       	movw	r30, r24
    14c6:	80 81       	ld	r24, Z
    14c8:	91 81       	ldd	r25, Z+1	; 0x01
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	a1 f0       	breq	.+40     	; 0x14f6 <prvCopyDataFromQueue+0x32>
    14ce:	40 a1       	ldd	r20, Z+32	; 0x20
    14d0:	50 e0       	ldi	r21, 0x00	; 0
    14d2:	26 81       	ldd	r18, Z+6	; 0x06
    14d4:	37 81       	ldd	r19, Z+7	; 0x07
    14d6:	24 0f       	add	r18, r20
    14d8:	35 1f       	adc	r19, r21
    14da:	26 83       	std	Z+6, r18	; 0x06
    14dc:	37 83       	std	Z+7, r19	; 0x07
    14de:	a2 81       	ldd	r26, Z+2	; 0x02
    14e0:	b3 81       	ldd	r27, Z+3	; 0x03
    14e2:	2a 17       	cp	r18, r26
    14e4:	3b 07       	cpc	r19, r27
    14e6:	10 f0       	brcs	.+4      	; 0x14ec <prvCopyDataFromQueue+0x28>
    14e8:	86 83       	std	Z+6, r24	; 0x06
    14ea:	97 83       	std	Z+7, r25	; 0x07
    14ec:	cb 01       	movw	r24, r22
    14ee:	66 81       	ldd	r22, Z+6	; 0x06
    14f0:	77 81       	ldd	r23, Z+7	; 0x07
    14f2:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <memcpy>
    14f6:	08 95       	ret

000014f8 <prvUnlockQueue>:
    14f8:	0f 93       	push	r16
    14fa:	1f 93       	push	r17
    14fc:	cf 93       	push	r28
    14fe:	df 93       	push	r29
    1500:	ec 01       	movw	r28, r24
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	0f 92       	push	r0
    1508:	8a a1       	ldd	r24, Y+34	; 0x22
    150a:	18 16       	cp	r1, r24
    150c:	b4 f4       	brge	.+44     	; 0x153a <prvUnlockQueue+0x42>
    150e:	8b 89       	ldd	r24, Y+19	; 0x13
    1510:	81 11       	cpse	r24, r1
    1512:	05 c0       	rjmp	.+10     	; 0x151e <prvUnlockQueue+0x26>
    1514:	12 c0       	rjmp	.+36     	; 0x153a <prvUnlockQueue+0x42>
    1516:	8b 89       	ldd	r24, Y+19	; 0x13
    1518:	81 11       	cpse	r24, r1
    151a:	04 c0       	rjmp	.+8      	; 0x1524 <prvUnlockQueue+0x2c>
    151c:	0e c0       	rjmp	.+28     	; 0x153a <prvUnlockQueue+0x42>
    151e:	8e 01       	movw	r16, r28
    1520:	0d 5e       	subi	r16, 0xED	; 237
    1522:	1f 4f       	sbci	r17, 0xFF	; 255
    1524:	c8 01       	movw	r24, r16
    1526:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    152a:	81 11       	cpse	r24, r1
    152c:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskMissedYield>
    1530:	8a a1       	ldd	r24, Y+34	; 0x22
    1532:	81 50       	subi	r24, 0x01	; 1
    1534:	8a a3       	std	Y+34, r24	; 0x22
    1536:	18 16       	cp	r1, r24
    1538:	74 f3       	brlt	.-36     	; 0x1516 <prvUnlockQueue+0x1e>
    153a:	8f ef       	ldi	r24, 0xFF	; 255
    153c:	8a a3       	std	Y+34, r24	; 0x22
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	0f b6       	in	r0, 0x3f	; 63
    1544:	f8 94       	cli
    1546:	0f 92       	push	r0
    1548:	89 a1       	ldd	r24, Y+33	; 0x21
    154a:	18 16       	cp	r1, r24
    154c:	b4 f4       	brge	.+44     	; 0x157a <prvUnlockQueue+0x82>
    154e:	88 85       	ldd	r24, Y+8	; 0x08
    1550:	81 11       	cpse	r24, r1
    1552:	05 c0       	rjmp	.+10     	; 0x155e <prvUnlockQueue+0x66>
    1554:	12 c0       	rjmp	.+36     	; 0x157a <prvUnlockQueue+0x82>
    1556:	88 85       	ldd	r24, Y+8	; 0x08
    1558:	81 11       	cpse	r24, r1
    155a:	04 c0       	rjmp	.+8      	; 0x1564 <prvUnlockQueue+0x6c>
    155c:	0e c0       	rjmp	.+28     	; 0x157a <prvUnlockQueue+0x82>
    155e:	8e 01       	movw	r16, r28
    1560:	08 5f       	subi	r16, 0xF8	; 248
    1562:	1f 4f       	sbci	r17, 0xFF	; 255
    1564:	c8 01       	movw	r24, r16
    1566:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    156a:	81 11       	cpse	r24, r1
    156c:	0e 94 a2 11 	call	0x2344	; 0x2344 <vTaskMissedYield>
    1570:	89 a1       	ldd	r24, Y+33	; 0x21
    1572:	81 50       	subi	r24, 0x01	; 1
    1574:	89 a3       	std	Y+33, r24	; 0x21
    1576:	18 16       	cp	r1, r24
    1578:	74 f3       	brlt	.-36     	; 0x1556 <prvUnlockQueue+0x5e>
    157a:	8f ef       	ldi	r24, 0xFF	; 255
    157c:	89 a3       	std	Y+33, r24	; 0x21
    157e:	0f 90       	pop	r0
    1580:	0f be       	out	0x3f, r0	; 63
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	1f 91       	pop	r17
    1588:	0f 91       	pop	r16
    158a:	08 95       	ret

0000158c <xQueueGenericReset>:
    158c:	1f 93       	push	r17
    158e:	cf 93       	push	r28
    1590:	df 93       	push	r29
    1592:	61 30       	cpi	r22, 0x01	; 1
    1594:	59 f0       	breq	.+22     	; 0x15ac <xQueueGenericReset+0x20>
    1596:	fc 01       	movw	r30, r24
    1598:	23 89       	ldd	r18, Z+19	; 0x13
    159a:	30 85       	ldd	r19, Z+8	; 0x08
    159c:	31 11       	cpse	r19, r1
    159e:	2c c0       	rjmp	.+88     	; 0x15f8 <xQueueGenericReset+0x6c>
    15a0:	11 e0       	ldi	r17, 0x01	; 1
    15a2:	21 11       	cpse	r18, r1
    15a4:	10 e0       	ldi	r17, 0x00	; 0
    15a6:	21 11       	cpse	r18, r1
    15a8:	28 c0       	rjmp	.+80     	; 0x15fa <xQueueGenericReset+0x6e>
    15aa:	01 c0       	rjmp	.+2      	; 0x15ae <xQueueGenericReset+0x22>
    15ac:	11 e0       	ldi	r17, 0x01	; 1
    15ae:	ec 01       	movw	r28, r24
    15b0:	48 81       	ld	r20, Y
    15b2:	59 81       	ldd	r21, Y+1	; 0x01
    15b4:	28 a1       	ldd	r18, Y+32	; 0x20
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    15ba:	62 9f       	mul	r22, r18
    15bc:	c0 01       	movw	r24, r0
    15be:	63 9f       	mul	r22, r19
    15c0:	90 0d       	add	r25, r0
    15c2:	11 24       	eor	r1, r1
    15c4:	ba 01       	movw	r22, r20
    15c6:	68 0f       	add	r22, r24
    15c8:	79 1f       	adc	r23, r25
    15ca:	6a 83       	std	Y+2, r22	; 0x02
    15cc:	7b 83       	std	Y+3, r23	; 0x03
    15ce:	1e 8e       	std	Y+30, r1	; 0x1e
    15d0:	4c 83       	std	Y+4, r20	; 0x04
    15d2:	5d 83       	std	Y+5, r21	; 0x05
    15d4:	82 1b       	sub	r24, r18
    15d6:	93 0b       	sbc	r25, r19
    15d8:	84 0f       	add	r24, r20
    15da:	95 1f       	adc	r25, r21
    15dc:	8e 83       	std	Y+6, r24	; 0x06
    15de:	9f 83       	std	Y+7, r25	; 0x07
    15e0:	8f ef       	ldi	r24, 0xFF	; 255
    15e2:	89 a3       	std	Y+33, r24	; 0x21
    15e4:	8a a3       	std	Y+34, r24	; 0x22
    15e6:	ce 01       	movw	r24, r28
    15e8:	08 96       	adiw	r24, 0x08	; 8
    15ea:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    15ee:	ce 01       	movw	r24, r28
    15f0:	43 96       	adiw	r24, 0x13	; 19
    15f2:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    15f6:	01 c0       	rjmp	.+2      	; 0x15fa <xQueueGenericReset+0x6e>
    15f8:	10 e0       	ldi	r17, 0x00	; 0
    15fa:	81 2f       	mov	r24, r17
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	1f 91       	pop	r17
    1602:	08 95       	ret

00001604 <xQueueGenericCreate>:
    1604:	0f 93       	push	r16
    1606:	1f 93       	push	r17
    1608:	cf 93       	push	r28
    160a:	df 93       	push	r29
    160c:	88 23       	and	r24, r24
    160e:	01 f1       	breq	.+64     	; 0x1650 <xQueueGenericCreate+0x4c>
    1610:	06 2f       	mov	r16, r22
    1612:	18 2f       	mov	r17, r24
    1614:	83 e2       	ldi	r24, 0x23	; 35
    1616:	90 e0       	ldi	r25, 0x00	; 0
    1618:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    161c:	ec 01       	movw	r28, r24
    161e:	89 2b       	or	r24, r25
    1620:	c9 f0       	breq	.+50     	; 0x1654 <xQueueGenericCreate+0x50>
    1622:	10 9f       	mul	r17, r16
    1624:	c0 01       	movw	r24, r0
    1626:	11 24       	eor	r1, r1
    1628:	01 96       	adiw	r24, 0x01	; 1
    162a:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    162e:	88 83       	st	Y, r24
    1630:	99 83       	std	Y+1, r25	; 0x01
    1632:	89 2b       	or	r24, r25
    1634:	39 f0       	breq	.+14     	; 0x1644 <xQueueGenericCreate+0x40>
    1636:	1f 8f       	std	Y+31, r17	; 0x1f
    1638:	08 a3       	std	Y+32, r16	; 0x20
    163a:	61 e0       	ldi	r22, 0x01	; 1
    163c:	ce 01       	movw	r24, r28
    163e:	0e 94 c6 0a 	call	0x158c	; 0x158c <xQueueGenericReset>
    1642:	08 c0       	rjmp	.+16     	; 0x1654 <xQueueGenericCreate+0x50>
    1644:	ce 01       	movw	r24, r28
    1646:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vPortFree>
    164a:	c0 e0       	ldi	r28, 0x00	; 0
    164c:	d0 e0       	ldi	r29, 0x00	; 0
    164e:	02 c0       	rjmp	.+4      	; 0x1654 <xQueueGenericCreate+0x50>
    1650:	c0 e0       	ldi	r28, 0x00	; 0
    1652:	d0 e0       	ldi	r29, 0x00	; 0
    1654:	ce 01       	movw	r24, r28
    1656:	df 91       	pop	r29
    1658:	cf 91       	pop	r28
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	08 95       	ret

00001660 <xQueueGenericSend>:
    1660:	af 92       	push	r10
    1662:	bf 92       	push	r11
    1664:	cf 92       	push	r12
    1666:	df 92       	push	r13
    1668:	ef 92       	push	r14
    166a:	ff 92       	push	r15
    166c:	0f 93       	push	r16
    166e:	1f 93       	push	r17
    1670:	cf 93       	push	r28
    1672:	df 93       	push	r29
    1674:	cd b7       	in	r28, 0x3d	; 61
    1676:	de b7       	in	r29, 0x3e	; 62
    1678:	29 97       	sbiw	r28, 0x09	; 9
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	de bf       	out	0x3e, r29	; 62
    167e:	7c 01       	movw	r14, r24
    1680:	5b 01       	movw	r10, r22
    1682:	2e 83       	std	Y+6, r18	; 0x06
    1684:	3f 83       	std	Y+7, r19	; 0x07
    1686:	48 87       	std	Y+8, r20	; 0x08
    1688:	59 87       	std	Y+9, r21	; 0x09
    168a:	10 e0       	ldi	r17, 0x00	; 0
    168c:	6c 01       	movw	r12, r24
    168e:	88 e0       	ldi	r24, 0x08	; 8
    1690:	c8 0e       	add	r12, r24
    1692:	d1 1c       	adc	r13, r1
    1694:	0f b6       	in	r0, 0x3f	; 63
    1696:	f8 94       	cli
    1698:	0f 92       	push	r0
    169a:	f7 01       	movw	r30, r14
    169c:	96 8d       	ldd	r25, Z+30	; 0x1e
    169e:	87 8d       	ldd	r24, Z+31	; 0x1f
    16a0:	98 17       	cp	r25, r24
    16a2:	a8 f4       	brcc	.+42     	; 0x16ce <xQueueGenericSend+0x6e>
    16a4:	40 2f       	mov	r20, r16
    16a6:	b5 01       	movw	r22, r10
    16a8:	c7 01       	movw	r24, r14
    16aa:	0e 94 16 0a 	call	0x142c	; 0x142c <prvCopyDataToQueue>
    16ae:	f7 01       	movw	r30, r14
    16b0:	83 89       	ldd	r24, Z+19	; 0x13
    16b2:	88 23       	and	r24, r24
    16b4:	41 f0       	breq	.+16     	; 0x16c6 <xQueueGenericSend+0x66>
    16b6:	c7 01       	movw	r24, r14
    16b8:	43 96       	adiw	r24, 0x13	; 19
    16ba:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	11 f4       	brne	.+4      	; 0x16c6 <xQueueGenericSend+0x66>
    16c2:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    16c6:	0f 90       	pop	r0
    16c8:	0f be       	out	0x3f, r0	; 63
    16ca:	81 e0       	ldi	r24, 0x01	; 1
    16cc:	56 c0       	rjmp	.+172    	; 0x177a <xQueueGenericSend+0x11a>
    16ce:	8e 81       	ldd	r24, Y+6	; 0x06
    16d0:	9f 81       	ldd	r25, Y+7	; 0x07
    16d2:	a8 85       	ldd	r26, Y+8	; 0x08
    16d4:	b9 85       	ldd	r27, Y+9	; 0x09
    16d6:	89 2b       	or	r24, r25
    16d8:	8a 2b       	or	r24, r26
    16da:	8b 2b       	or	r24, r27
    16dc:	21 f4       	brne	.+8      	; 0x16e6 <xQueueGenericSend+0x86>
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	80 e0       	ldi	r24, 0x00	; 0
    16e4:	4a c0       	rjmp	.+148    	; 0x177a <xQueueGenericSend+0x11a>
    16e6:	11 11       	cpse	r17, r1
    16e8:	05 c0       	rjmp	.+10     	; 0x16f4 <xQueueGenericSend+0x94>
    16ea:	ce 01       	movw	r24, r28
    16ec:	01 96       	adiw	r24, 0x01	; 1
    16ee:	0e 94 24 11 	call	0x2248	; 0x2248 <vTaskSetTimeOutState>
    16f2:	11 e0       	ldi	r17, 0x01	; 1
    16f4:	0f 90       	pop	r0
    16f6:	0f be       	out	0x3f, r0	; 63
    16f8:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <vTaskSuspendAll>
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	f8 94       	cli
    1700:	0f 92       	push	r0
    1702:	f7 01       	movw	r30, r14
    1704:	81 a1       	ldd	r24, Z+33	; 0x21
    1706:	8f 3f       	cpi	r24, 0xFF	; 255
    1708:	09 f4       	brne	.+2      	; 0x170c <xQueueGenericSend+0xac>
    170a:	11 a2       	std	Z+33, r1	; 0x21
    170c:	f7 01       	movw	r30, r14
    170e:	82 a1       	ldd	r24, Z+34	; 0x22
    1710:	8f 3f       	cpi	r24, 0xFF	; 255
    1712:	09 f4       	brne	.+2      	; 0x1716 <xQueueGenericSend+0xb6>
    1714:	12 a2       	std	Z+34, r1	; 0x22
    1716:	0f 90       	pop	r0
    1718:	0f be       	out	0x3f, r0	; 63
    171a:	be 01       	movw	r22, r28
    171c:	6a 5f       	subi	r22, 0xFA	; 250
    171e:	7f 4f       	sbci	r23, 0xFF	; 255
    1720:	ce 01       	movw	r24, r28
    1722:	01 96       	adiw	r24, 0x01	; 1
    1724:	0e 94 35 11 	call	0x226a	; 0x226a <xTaskCheckForTimeOut>
    1728:	81 11       	cpse	r24, r1
    172a:	21 c0       	rjmp	.+66     	; 0x176e <xQueueGenericSend+0x10e>
    172c:	0f b6       	in	r0, 0x3f	; 63
    172e:	f8 94       	cli
    1730:	0f 92       	push	r0
    1732:	f7 01       	movw	r30, r14
    1734:	96 8d       	ldd	r25, Z+30	; 0x1e
    1736:	0f 90       	pop	r0
    1738:	0f be       	out	0x3f, r0	; 63
    173a:	87 8d       	ldd	r24, Z+31	; 0x1f
    173c:	98 13       	cpse	r25, r24
    173e:	11 c0       	rjmp	.+34     	; 0x1762 <xQueueGenericSend+0x102>
    1740:	4e 81       	ldd	r20, Y+6	; 0x06
    1742:	5f 81       	ldd	r21, Y+7	; 0x07
    1744:	68 85       	ldd	r22, Y+8	; 0x08
    1746:	79 85       	ldd	r23, Y+9	; 0x09
    1748:	c6 01       	movw	r24, r12
    174a:	0e 94 bb 10 	call	0x2176	; 0x2176 <vTaskPlaceOnEventList>
    174e:	c7 01       	movw	r24, r14
    1750:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
    1754:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
    1758:	81 11       	cpse	r24, r1
    175a:	9c cf       	rjmp	.-200    	; 0x1694 <xQueueGenericSend+0x34>
    175c:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    1760:	99 cf       	rjmp	.-206    	; 0x1694 <xQueueGenericSend+0x34>
    1762:	c7 01       	movw	r24, r14
    1764:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
    1768:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
    176c:	93 cf       	rjmp	.-218    	; 0x1694 <xQueueGenericSend+0x34>
    176e:	c7 01       	movw	r24, r14
    1770:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
    1774:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
    1778:	80 e0       	ldi	r24, 0x00	; 0
    177a:	29 96       	adiw	r28, 0x09	; 9
    177c:	cd bf       	out	0x3d, r28	; 61
    177e:	de bf       	out	0x3e, r29	; 62
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	1f 91       	pop	r17
    1786:	0f 91       	pop	r16
    1788:	ff 90       	pop	r15
    178a:	ef 90       	pop	r14
    178c:	df 90       	pop	r13
    178e:	cf 90       	pop	r12
    1790:	bf 90       	pop	r11
    1792:	af 90       	pop	r10
    1794:	08 95       	ret

00001796 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1796:	0f 93       	push	r16
    1798:	1f 93       	push	r17
    179a:	cf 93       	push	r28
    179c:	df 93       	push	r29
    179e:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    17a0:	fc 01       	movw	r30, r24
    17a2:	56 8d       	ldd	r21, Z+30	; 0x1e
    17a4:	37 8d       	ldd	r19, Z+31	; 0x1f
    17a6:	53 17       	cp	r21, r19
    17a8:	c0 f4       	brcc	.+48     	; 0x17da <xQueueGenericSendFromISR+0x44>
    17aa:	42 2f       	mov	r20, r18
    17ac:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17ae:	0e 94 16 0a 	call	0x142c	; 0x142c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    17b2:	8a a1       	ldd	r24, Y+34	; 0x22
    17b4:	8f 3f       	cpi	r24, 0xFF	; 255
    17b6:	69 f4       	brne	.+26     	; 0x17d2 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17b8:	8b 89       	ldd	r24, Y+19	; 0x13
    17ba:	88 23       	and	r24, r24
    17bc:	81 f0       	breq	.+32     	; 0x17de <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17be:	ce 01       	movw	r24, r28
    17c0:	43 96       	adiw	r24, 0x13	; 19
    17c2:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    17c6:	88 23       	and	r24, r24
    17c8:	61 f0       	breq	.+24     	; 0x17e2 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    17ca:	81 e0       	ldi	r24, 0x01	; 1
    17cc:	f8 01       	movw	r30, r16
    17ce:	80 83       	st	Z, r24
    17d0:	09 c0       	rjmp	.+18     	; 0x17e4 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17d2:	8f 5f       	subi	r24, 0xFF	; 255
    17d4:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	05 c0       	rjmp	.+10     	; 0x17e4 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17da:	80 e0       	ldi	r24, 0x00	; 0
    17dc:	03 c0       	rjmp	.+6      	; 0x17e4 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    17de:	81 e0       	ldi	r24, 0x01	; 1
    17e0:	01 c0       	rjmp	.+2      	; 0x17e4 <xQueueGenericSendFromISR+0x4e>
    17e2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    17e4:	df 91       	pop	r29
    17e6:	cf 91       	pop	r28
    17e8:	1f 91       	pop	r17
    17ea:	0f 91       	pop	r16
    17ec:	08 95       	ret

000017ee <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    17ee:	af 92       	push	r10
    17f0:	bf 92       	push	r11
    17f2:	cf 92       	push	r12
    17f4:	df 92       	push	r13
    17f6:	ef 92       	push	r14
    17f8:	ff 92       	push	r15
    17fa:	0f 93       	push	r16
    17fc:	1f 93       	push	r17
    17fe:	cf 93       	push	r28
    1800:	df 93       	push	r29
    1802:	cd b7       	in	r28, 0x3d	; 61
    1804:	de b7       	in	r29, 0x3e	; 62
    1806:	29 97       	sbiw	r28, 0x09	; 9
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	de bf       	out	0x3e, r29	; 62
    180c:	7c 01       	movw	r14, r24
    180e:	5b 01       	movw	r10, r22
    1810:	2e 83       	std	Y+6, r18	; 0x06
    1812:	3f 83       	std	Y+7, r19	; 0x07
    1814:	48 87       	std	Y+8, r20	; 0x08
    1816:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1818:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    181a:	6c 01       	movw	r12, r24
    181c:	83 e1       	ldi	r24, 0x13	; 19
    181e:	c8 0e       	add	r12, r24
    1820:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1828:	f7 01       	movw	r30, r14
    182a:	86 8d       	ldd	r24, Z+30	; 0x1e
    182c:	88 23       	and	r24, r24
    182e:	99 f1       	breq	.+102    	; 0x1896 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1830:	c6 80       	ldd	r12, Z+6	; 0x06
    1832:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1834:	b5 01       	movw	r22, r10
    1836:	c7 01       	movw	r24, r14
    1838:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    183c:	01 11       	cpse	r16, r1
    183e:	1a c0       	rjmp	.+52     	; 0x1874 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1840:	f7 01       	movw	r30, r14
    1842:	86 8d       	ldd	r24, Z+30	; 0x1e
    1844:	81 50       	subi	r24, 0x01	; 1
    1846:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1848:	80 81       	ld	r24, Z
    184a:	91 81       	ldd	r25, Z+1	; 0x01
    184c:	89 2b       	or	r24, r25
    184e:	29 f4       	brne	.+10     	; 0x185a <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1850:	0e 94 bf 11 	call	0x237e	; 0x237e <xTaskGetCurrentTaskHandle>
    1854:	f7 01       	movw	r30, r14
    1856:	82 83       	std	Z+2, r24	; 0x02
    1858:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    185a:	f7 01       	movw	r30, r14
    185c:	80 85       	ldd	r24, Z+8	; 0x08
    185e:	88 23       	and	r24, r24
    1860:	b1 f0       	breq	.+44     	; 0x188e <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1862:	c7 01       	movw	r24, r14
    1864:	08 96       	adiw	r24, 0x08	; 8
    1866:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    186a:	81 30       	cpi	r24, 0x01	; 1
    186c:	81 f4       	brne	.+32     	; 0x188e <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    186e:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    1872:	0d c0       	rjmp	.+26     	; 0x188e <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1874:	f7 01       	movw	r30, r14
    1876:	c6 82       	std	Z+6, r12	; 0x06
    1878:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    187a:	83 89       	ldd	r24, Z+19	; 0x13
    187c:	88 23       	and	r24, r24
    187e:	39 f0       	breq	.+14     	; 0x188e <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1880:	c7 01       	movw	r24, r14
    1882:	43 96       	adiw	r24, 0x13	; 19
    1884:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    1888:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    188a:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1892:	81 e0       	ldi	r24, 0x01	; 1
    1894:	62 c0       	rjmp	.+196    	; 0x195a <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1896:	8e 81       	ldd	r24, Y+6	; 0x06
    1898:	9f 81       	ldd	r25, Y+7	; 0x07
    189a:	a8 85       	ldd	r26, Y+8	; 0x08
    189c:	b9 85       	ldd	r27, Y+9	; 0x09
    189e:	89 2b       	or	r24, r25
    18a0:	8a 2b       	or	r24, r26
    18a2:	8b 2b       	or	r24, r27
    18a4:	21 f4       	brne	.+8      	; 0x18ae <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18a6:	0f 90       	pop	r0
    18a8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    18aa:	80 e0       	ldi	r24, 0x00	; 0
    18ac:	56 c0       	rjmp	.+172    	; 0x195a <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    18ae:	11 11       	cpse	r17, r1
    18b0:	05 c0       	rjmp	.+10     	; 0x18bc <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18b2:	ce 01       	movw	r24, r28
    18b4:	01 96       	adiw	r24, 0x01	; 1
    18b6:	0e 94 24 11 	call	0x2248	; 0x2248 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18ba:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18c0:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18c4:	0f b6       	in	r0, 0x3f	; 63
    18c6:	f8 94       	cli
    18c8:	0f 92       	push	r0
    18ca:	f7 01       	movw	r30, r14
    18cc:	81 a1       	ldd	r24, Z+33	; 0x21
    18ce:	8f 3f       	cpi	r24, 0xFF	; 255
    18d0:	09 f4       	brne	.+2      	; 0x18d4 <xQueueGenericReceive+0xe6>
    18d2:	11 a2       	std	Z+33, r1	; 0x21
    18d4:	f7 01       	movw	r30, r14
    18d6:	82 a1       	ldd	r24, Z+34	; 0x22
    18d8:	8f 3f       	cpi	r24, 0xFF	; 255
    18da:	09 f4       	brne	.+2      	; 0x18de <xQueueGenericReceive+0xf0>
    18dc:	12 a2       	std	Z+34, r1	; 0x22
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    18e2:	be 01       	movw	r22, r28
    18e4:	6a 5f       	subi	r22, 0xFA	; 250
    18e6:	7f 4f       	sbci	r23, 0xFF	; 255
    18e8:	ce 01       	movw	r24, r28
    18ea:	01 96       	adiw	r24, 0x01	; 1
    18ec:	0e 94 35 11 	call	0x226a	; 0x226a <xTaskCheckForTimeOut>
    18f0:	81 11       	cpse	r24, r1
    18f2:	2d c0       	rjmp	.+90     	; 0x194e <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18f4:	0f b6       	in	r0, 0x3f	; 63
    18f6:	f8 94       	cli
    18f8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18fa:	f7 01       	movw	r30, r14
    18fc:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    18fe:	0f 90       	pop	r0
    1900:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1902:	81 11       	cpse	r24, r1
    1904:	1e c0       	rjmp	.+60     	; 0x1942 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1906:	80 81       	ld	r24, Z
    1908:	91 81       	ldd	r25, Z+1	; 0x01
    190a:	89 2b       	or	r24, r25
    190c:	49 f4       	brne	.+18     	; 0x1920 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    190e:	0f b6       	in	r0, 0x3f	; 63
    1910:	f8 94       	cli
    1912:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1914:	82 81       	ldd	r24, Z+2	; 0x02
    1916:	93 81       	ldd	r25, Z+3	; 0x03
    1918:	0e 94 c4 11 	call	0x2388	; 0x2388 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1920:	4e 81       	ldd	r20, Y+6	; 0x06
    1922:	5f 81       	ldd	r21, Y+7	; 0x07
    1924:	68 85       	ldd	r22, Y+8	; 0x08
    1926:	79 85       	ldd	r23, Y+9	; 0x09
    1928:	c6 01       	movw	r24, r12
    192a:	0e 94 bb 10 	call	0x2176	; 0x2176 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    192e:	c7 01       	movw	r24, r14
    1930:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1934:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
    1938:	81 11       	cpse	r24, r1
    193a:	73 cf       	rjmp	.-282    	; 0x1822 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    193c:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    1940:	70 cf       	rjmp	.-288    	; 0x1822 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1942:	c7 01       	movw	r24, r14
    1944:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1948:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
    194c:	6a cf       	rjmp	.-300    	; 0x1822 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    194e:	c7 01       	movw	r24, r14
    1950:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1954:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1958:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    195a:	29 96       	adiw	r28, 0x09	; 9
    195c:	cd bf       	out	0x3d, r28	; 61
    195e:	de bf       	out	0x3e, r29	; 62
    1960:	df 91       	pop	r29
    1962:	cf 91       	pop	r28
    1964:	1f 91       	pop	r17
    1966:	0f 91       	pop	r16
    1968:	ff 90       	pop	r15
    196a:	ef 90       	pop	r14
    196c:	df 90       	pop	r13
    196e:	cf 90       	pop	r12
    1970:	bf 90       	pop	r11
    1972:	af 90       	pop	r10
    1974:	08 95       	ret

00001976 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1976:	0f 93       	push	r16
    1978:	1f 93       	push	r17
    197a:	cf 93       	push	r28
    197c:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    197e:	fc 01       	movw	r30, r24
    1980:	26 8d       	ldd	r18, Z+30	; 0x1e
    1982:	22 23       	and	r18, r18
    1984:	d9 f0       	breq	.+54     	; 0x19bc <xQueueReceiveFromISR+0x46>
    1986:	8a 01       	movw	r16, r20
    1988:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    198a:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    198e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1990:	81 50       	subi	r24, 0x01	; 1
    1992:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1994:	89 a1       	ldd	r24, Y+33	; 0x21
    1996:	8f 3f       	cpi	r24, 0xFF	; 255
    1998:	69 f4       	brne	.+26     	; 0x19b4 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    199a:	88 85       	ldd	r24, Y+8	; 0x08
    199c:	88 23       	and	r24, r24
    199e:	81 f0       	breq	.+32     	; 0x19c0 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19a0:	ce 01       	movw	r24, r28
    19a2:	08 96       	adiw	r24, 0x08	; 8
    19a4:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xTaskRemoveFromEventList>
    19a8:	88 23       	and	r24, r24
    19aa:	61 f0       	breq	.+24     	; 0x19c4 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    19ac:	81 e0       	ldi	r24, 0x01	; 1
    19ae:	f8 01       	movw	r30, r16
    19b0:	80 83       	st	Z, r24
    19b2:	09 c0       	rjmp	.+18     	; 0x19c6 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    19b4:	8f 5f       	subi	r24, 0xFF	; 255
    19b6:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    19b8:	81 e0       	ldi	r24, 0x01	; 1
    19ba:	05 c0       	rjmp	.+10     	; 0x19c6 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    19bc:	80 e0       	ldi	r24, 0x00	; 0
    19be:	03 c0       	rjmp	.+6      	; 0x19c6 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    19c0:	81 e0       	ldi	r24, 0x01	; 1
    19c2:	01 c0       	rjmp	.+2      	; 0x19c6 <xQueueReceiveFromISR+0x50>
    19c4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19c6:	df 91       	pop	r29
    19c8:	cf 91       	pop	r28
    19ca:	1f 91       	pop	r17
    19cc:	0f 91       	pop	r16
    19ce:	08 95       	ret

000019d0 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    19d0:	0f b6       	in	r0, 0x3f	; 63
    19d2:	f8 94       	cli
    19d4:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    19d6:	fc 01       	movw	r30, r24
    19d8:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    19da:	0f 90       	pop	r0
    19dc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    19de:	08 95       	ret

000019e0 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    19e0:	fc 01       	movw	r30, r24
    19e2:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    19e4:	08 95       	ret

000019e6 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    19e6:	ca e1       	ldi	r28, 0x1A	; 26
    19e8:	d1 e3       	ldi	r29, 0x31	; 49
    19ea:	88 81       	ld	r24, Y
    19ec:	82 30       	cpi	r24, 0x02	; 2
    19ee:	e8 f3       	brcs	.-6      	; 0x19ea <prvIdleTask+0x4>
    19f0:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    19f4:	fa cf       	rjmp	.-12     	; 0x19ea <prvIdleTask+0x4>

000019f6 <prvAddCurrentTaskToDelayedList>:
    19f6:	cf 92       	push	r12
    19f8:	df 92       	push	r13
    19fa:	ef 92       	push	r14
    19fc:	ff 92       	push	r15
    19fe:	6b 01       	movw	r12, r22
    1a00:	7c 01       	movw	r14, r24
    1a02:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1a06:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a0a:	62 83       	std	Z+2, r22	; 0x02
    1a0c:	73 83       	std	Z+3, r23	; 0x03
    1a0e:	84 83       	std	Z+4, r24	; 0x04
    1a10:	95 83       	std	Z+5, r25	; 0x05
    1a12:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1a16:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1a1a:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1a1e:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1a22:	c8 16       	cp	r12, r24
    1a24:	d9 06       	cpc	r13, r25
    1a26:	ea 06       	cpc	r14, r26
    1a28:	fb 06       	cpc	r15, r27
    1a2a:	68 f4       	brcc	.+26     	; 0x1a46 <prvAddCurrentTaskToDelayedList+0x50>
    1a2c:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    1a30:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a34:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <pxOverflowDelayedTaskList>
    1a38:	90 91 01 31 	lds	r25, 0x3101	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1a3c:	6e 5f       	subi	r22, 0xFE	; 254
    1a3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a40:	0e 94 2a 08 	call	0x1054	; 0x1054 <vListInsert>
    1a44:	21 c0       	rjmp	.+66     	; 0x1a88 <prvAddCurrentTaskToDelayedList+0x92>
    1a46:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    1a4a:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1a4e:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxDelayedTaskList>
    1a52:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1a56:	6e 5f       	subi	r22, 0xFE	; 254
    1a58:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5a:	0e 94 2a 08 	call	0x1054	; 0x1054 <vListInsert>
    1a5e:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1a62:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a66:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a6a:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a6e:	c8 16       	cp	r12, r24
    1a70:	d9 06       	cpc	r13, r25
    1a72:	ea 06       	cpc	r14, r26
    1a74:	fb 06       	cpc	r15, r27
    1a76:	40 f4       	brcc	.+16     	; 0x1a88 <prvAddCurrentTaskToDelayedList+0x92>
    1a78:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1a7c:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1a80:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1a84:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1a88:	ff 90       	pop	r15
    1a8a:	ef 90       	pop	r14
    1a8c:	df 90       	pop	r13
    1a8e:	cf 90       	pop	r12
    1a90:	08 95       	ret

00001a92 <xTaskGenericCreate>:
    1a92:	4f 92       	push	r4
    1a94:	5f 92       	push	r5
    1a96:	6f 92       	push	r6
    1a98:	7f 92       	push	r7
    1a9a:	8f 92       	push	r8
    1a9c:	9f 92       	push	r9
    1a9e:	af 92       	push	r10
    1aa0:	bf 92       	push	r11
    1aa2:	cf 92       	push	r12
    1aa4:	df 92       	push	r13
    1aa6:	ef 92       	push	r14
    1aa8:	ff 92       	push	r15
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
    1ab2:	5c 01       	movw	r10, r24
    1ab4:	4b 01       	movw	r8, r22
    1ab6:	3a 01       	movw	r6, r20
    1ab8:	29 01       	movw	r4, r18
    1aba:	88 e2       	ldi	r24, 0x28	; 40
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    1ac2:	ec 01       	movw	r28, r24
    1ac4:	89 2b       	or	r24, r25
    1ac6:	09 f4       	brne	.+2      	; 0x1aca <xTaskGenericCreate+0x38>
    1ac8:	d4 c0       	rjmp	.+424    	; 0x1c72 <xTaskGenericCreate+0x1e0>
    1aca:	c1 14       	cp	r12, r1
    1acc:	d1 04       	cpc	r13, r1
    1ace:	09 f0       	breq	.+2      	; 0x1ad2 <xTaskGenericCreate+0x40>
    1ad0:	cc c0       	rjmp	.+408    	; 0x1c6a <xTaskGenericCreate+0x1d8>
    1ad2:	c3 01       	movw	r24, r6
    1ad4:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    1ad8:	8b 8f       	std	Y+27, r24	; 0x1b
    1ada:	9c 8f       	std	Y+28, r25	; 0x1c
    1adc:	00 97       	sbiw	r24, 0x00	; 0
    1ade:	21 f4       	brne	.+8      	; 0x1ae8 <xTaskGenericCreate+0x56>
    1ae0:	ce 01       	movw	r24, r28
    1ae2:	0e 94 b6 07 	call	0xf6c	; 0xf6c <vPortFree>
    1ae6:	c5 c0       	rjmp	.+394    	; 0x1c72 <xTaskGenericCreate+0x1e0>
    1ae8:	a3 01       	movw	r20, r6
    1aea:	61 e1       	ldi	r22, 0x11	; 17
    1aec:	70 e0       	ldi	r23, 0x00	; 0
    1aee:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <memset>
    1af2:	93 01       	movw	r18, r6
    1af4:	21 50       	subi	r18, 0x01	; 1
    1af6:	31 09       	sbc	r19, r1
    1af8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1afa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1afc:	3c 01       	movw	r6, r24
    1afe:	62 0e       	add	r6, r18
    1b00:	73 1e       	adc	r7, r19
    1b02:	4a e0       	ldi	r20, 0x0A	; 10
    1b04:	50 e0       	ldi	r21, 0x00	; 0
    1b06:	b4 01       	movw	r22, r8
    1b08:	ce 01       	movw	r24, r28
    1b0a:	4d 96       	adiw	r24, 0x1d	; 29
    1b0c:	0e 94 42 1f 	call	0x3e84	; 0x3e84 <strncpy>
    1b10:	1e a2       	std	Y+38, r1	; 0x26
    1b12:	10 2f       	mov	r17, r16
    1b14:	04 30       	cpi	r16, 0x04	; 4
    1b16:	08 f0       	brcs	.+2      	; 0x1b1a <xTaskGenericCreate+0x88>
    1b18:	13 e0       	ldi	r17, 0x03	; 3
    1b1a:	1a 8f       	std	Y+26, r17	; 0x1a
    1b1c:	1f a3       	std	Y+39, r17	; 0x27
    1b1e:	6e 01       	movw	r12, r28
    1b20:	22 e0       	ldi	r18, 0x02	; 2
    1b22:	c2 0e       	add	r12, r18
    1b24:	d1 1c       	adc	r13, r1
    1b26:	c6 01       	movw	r24, r12
    1b28:	0e 94 ff 07 	call	0xffe	; 0xffe <vListInitialiseItem>
    1b2c:	ce 01       	movw	r24, r28
    1b2e:	0e 96       	adiw	r24, 0x0e	; 14
    1b30:	0e 94 ff 07 	call	0xffe	; 0xffe <vListInitialiseItem>
    1b34:	ca 87       	std	Y+10, r28	; 0x0a
    1b36:	db 87       	std	Y+11, r29	; 0x0b
    1b38:	84 e0       	ldi	r24, 0x04	; 4
    1b3a:	90 e0       	ldi	r25, 0x00	; 0
    1b3c:	a0 e0       	ldi	r26, 0x00	; 0
    1b3e:	b0 e0       	ldi	r27, 0x00	; 0
    1b40:	81 1b       	sub	r24, r17
    1b42:	91 09       	sbc	r25, r1
    1b44:	a1 09       	sbc	r26, r1
    1b46:	b1 09       	sbc	r27, r1
    1b48:	8e 87       	std	Y+14, r24	; 0x0e
    1b4a:	9f 87       	std	Y+15, r25	; 0x0f
    1b4c:	a8 8b       	std	Y+16, r26	; 0x10
    1b4e:	b9 8b       	std	Y+17, r27	; 0x11
    1b50:	ce 8b       	std	Y+22, r28	; 0x16
    1b52:	df 8b       	std	Y+23, r29	; 0x17
    1b54:	a2 01       	movw	r20, r4
    1b56:	b5 01       	movw	r22, r10
    1b58:	c3 01       	movw	r24, r6
    1b5a:	0e 94 9b 08 	call	0x1136	; 0x1136 <pxPortInitialiseStack>
    1b5e:	88 83       	st	Y, r24
    1b60:	99 83       	std	Y+1, r25	; 0x01
    1b62:	e1 14       	cp	r14, r1
    1b64:	f1 04       	cpc	r15, r1
    1b66:	19 f0       	breq	.+6      	; 0x1b6e <xTaskGenericCreate+0xdc>
    1b68:	f7 01       	movw	r30, r14
    1b6a:	c0 83       	st	Z, r28
    1b6c:	d1 83       	std	Z+1, r29	; 0x01
    1b6e:	0f b6       	in	r0, 0x3f	; 63
    1b70:	f8 94       	cli
    1b72:	0f 92       	push	r0
    1b74:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1b78:	8f 5f       	subi	r24, 0xFF	; 255
    1b7a:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <uxCurrentNumberOfTasks>
    1b7e:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1b82:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1b86:	89 2b       	or	r24, r25
    1b88:	89 f5       	brne	.+98     	; 0x1bec <xTaskGenericCreate+0x15a>
    1b8a:	c0 93 46 31 	sts	0x3146, r28	; 0x803146 <pxCurrentTCB>
    1b8e:	d0 93 47 31 	sts	0x3147, r29	; 0x803147 <pxCurrentTCB+0x1>
    1b92:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1b96:	81 30       	cpi	r24, 0x01	; 1
    1b98:	c1 f5       	brne	.+112    	; 0x1c0a <xTaskGenericCreate+0x178>
    1b9a:	8a e1       	ldi	r24, 0x1A	; 26
    1b9c:	91 e3       	ldi	r25, 0x31	; 49
    1b9e:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1ba2:	85 e2       	ldi	r24, 0x25	; 37
    1ba4:	91 e3       	ldi	r25, 0x31	; 49
    1ba6:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1baa:	80 e3       	ldi	r24, 0x30	; 48
    1bac:	91 e3       	ldi	r25, 0x31	; 49
    1bae:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1bb2:	8b e3       	ldi	r24, 0x3B	; 59
    1bb4:	91 e3       	ldi	r25, 0x31	; 49
    1bb6:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1bba:	8f e0       	ldi	r24, 0x0F	; 15
    1bbc:	91 e3       	ldi	r25, 0x31	; 49
    1bbe:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1bc2:	84 e0       	ldi	r24, 0x04	; 4
    1bc4:	91 e3       	ldi	r25, 0x31	; 49
    1bc6:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1bca:	85 ef       	ldi	r24, 0xF5	; 245
    1bcc:	90 e3       	ldi	r25, 0x30	; 48
    1bce:	0e 94 ee 07 	call	0xfdc	; 0xfdc <vListInitialise>
    1bd2:	8f e0       	ldi	r24, 0x0F	; 15
    1bd4:	91 e3       	ldi	r25, 0x31	; 49
    1bd6:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxDelayedTaskList>
    1bda:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxDelayedTaskList+0x1>
    1bde:	84 e0       	ldi	r24, 0x04	; 4
    1be0:	91 e3       	ldi	r25, 0x31	; 49
    1be2:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <pxOverflowDelayedTaskList>
    1be6:	90 93 01 31 	sts	0x3101, r25	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1bea:	0f c0       	rjmp	.+30     	; 0x1c0a <xTaskGenericCreate+0x178>
    1bec:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xSchedulerRunning>
    1bf0:	81 11       	cpse	r24, r1
    1bf2:	0b c0       	rjmp	.+22     	; 0x1c0a <xTaskGenericCreate+0x178>
    1bf4:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1bf8:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1bfc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bfe:	08 17       	cp	r16, r24
    1c00:	20 f0       	brcs	.+8      	; 0x1c0a <xTaskGenericCreate+0x178>
    1c02:	c0 93 46 31 	sts	0x3146, r28	; 0x803146 <pxCurrentTCB>
    1c06:	d0 93 47 31 	sts	0x3147, r29	; 0x803147 <pxCurrentTCB+0x1>
    1c0a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c0c:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <uxTopUsedPriority>
    1c10:	98 17       	cp	r25, r24
    1c12:	10 f4       	brcc	.+4      	; 0x1c18 <xTaskGenericCreate+0x186>
    1c14:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <uxTopUsedPriority>
    1c18:	90 91 e6 30 	lds	r25, 0x30E6	; 0x8030e6 <uxTaskNumber>
    1c1c:	9f 5f       	subi	r25, 0xFF	; 255
    1c1e:	90 93 e6 30 	sts	0x30E6, r25	; 0x8030e6 <uxTaskNumber>
    1c22:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1c26:	98 17       	cp	r25, r24
    1c28:	10 f4       	brcc	.+4      	; 0x1c2e <xTaskGenericCreate+0x19c>
    1c2a:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1c2e:	fb e0       	ldi	r31, 0x0B	; 11
    1c30:	8f 9f       	mul	r24, r31
    1c32:	c0 01       	movw	r24, r0
    1c34:	11 24       	eor	r1, r1
    1c36:	b6 01       	movw	r22, r12
    1c38:	86 5e       	subi	r24, 0xE6	; 230
    1c3a:	9e 4c       	sbci	r25, 0xCE	; 206
    1c3c:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
    1c40:	0f 90       	pop	r0
    1c42:	0f be       	out	0x3f, r0	; 63
    1c44:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <xSchedulerRunning>
    1c48:	88 23       	and	r24, r24
    1c4a:	59 f0       	breq	.+22     	; 0x1c62 <xTaskGenericCreate+0x1d0>
    1c4c:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1c50:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1c54:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c56:	80 17       	cp	r24, r16
    1c58:	30 f4       	brcc	.+12     	; 0x1c66 <xTaskGenericCreate+0x1d4>
    1c5a:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    1c5e:	81 e0       	ldi	r24, 0x01	; 1
    1c60:	09 c0       	rjmp	.+18     	; 0x1c74 <xTaskGenericCreate+0x1e2>
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	07 c0       	rjmp	.+14     	; 0x1c74 <xTaskGenericCreate+0x1e2>
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	05 c0       	rjmp	.+10     	; 0x1c74 <xTaskGenericCreate+0x1e2>
    1c6a:	cb 8e       	std	Y+27, r12	; 0x1b
    1c6c:	dc 8e       	std	Y+28, r13	; 0x1c
    1c6e:	c6 01       	movw	r24, r12
    1c70:	3b cf       	rjmp	.-394    	; 0x1ae8 <xTaskGenericCreate+0x56>
    1c72:	8f ef       	ldi	r24, 0xFF	; 255
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	ff 90       	pop	r15
    1c7e:	ef 90       	pop	r14
    1c80:	df 90       	pop	r13
    1c82:	cf 90       	pop	r12
    1c84:	bf 90       	pop	r11
    1c86:	af 90       	pop	r10
    1c88:	9f 90       	pop	r9
    1c8a:	8f 90       	pop	r8
    1c8c:	7f 90       	pop	r7
    1c8e:	6f 90       	pop	r6
    1c90:	5f 90       	pop	r5
    1c92:	4f 90       	pop	r4
    1c94:	08 95       	ret

00001c96 <uxTaskPriorityGet>:
    1c96:	0f b6       	in	r0, 0x3f	; 63
    1c98:	f8 94       	cli
    1c9a:	0f 92       	push	r0
    1c9c:	00 97       	sbiw	r24, 0x00	; 0
    1c9e:	21 f4       	brne	.+8      	; 0x1ca8 <uxTaskPriorityGet+0x12>
    1ca0:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1ca4:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	fc 01       	movw	r30, r24
    1cae:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cb0:	08 95       	ret

00001cb2 <vTaskStartScheduler>:
    1cb2:	af 92       	push	r10
    1cb4:	bf 92       	push	r11
    1cb6:	cf 92       	push	r12
    1cb8:	df 92       	push	r13
    1cba:	ef 92       	push	r14
    1cbc:	ff 92       	push	r15
    1cbe:	0f 93       	push	r16
    1cc0:	a1 2c       	mov	r10, r1
    1cc2:	b1 2c       	mov	r11, r1
    1cc4:	c1 2c       	mov	r12, r1
    1cc6:	d1 2c       	mov	r13, r1
    1cc8:	0f 2e       	mov	r0, r31
    1cca:	f3 ef       	ldi	r31, 0xF3	; 243
    1ccc:	ef 2e       	mov	r14, r31
    1cce:	f0 e3       	ldi	r31, 0x30	; 48
    1cd0:	ff 2e       	mov	r15, r31
    1cd2:	f0 2d       	mov	r31, r0
    1cd4:	00 e0       	ldi	r16, 0x00	; 0
    1cd6:	20 e0       	ldi	r18, 0x00	; 0
    1cd8:	30 e0       	ldi	r19, 0x00	; 0
    1cda:	44 e6       	ldi	r20, 0x64	; 100
    1cdc:	50 e0       	ldi	r21, 0x00	; 0
    1cde:	62 e3       	ldi	r22, 0x32	; 50
    1ce0:	70 e2       	ldi	r23, 0x20	; 32
    1ce2:	83 ef       	ldi	r24, 0xF3	; 243
    1ce4:	9c e0       	ldi	r25, 0x0C	; 12
    1ce6:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <xTaskGenericCreate>
    1cea:	81 30       	cpi	r24, 0x01	; 1
    1cec:	69 f4       	brne	.+26     	; 0x1d08 <vTaskStartScheduler+0x56>
    1cee:	f8 94       	cli
    1cf0:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <xSchedulerRunning>
    1cf4:	10 92 ee 30 	sts	0x30EE, r1	; 0x8030ee <xTickCount>
    1cf8:	10 92 ef 30 	sts	0x30EF, r1	; 0x8030ef <xTickCount+0x1>
    1cfc:	10 92 f0 30 	sts	0x30F0, r1	; 0x8030f0 <xTickCount+0x2>
    1d00:	10 92 f1 30 	sts	0x30F1, r1	; 0x8030f1 <xTickCount+0x3>
    1d04:	0e 94 11 09 	call	0x1222	; 0x1222 <xPortStartScheduler>
    1d08:	0f 91       	pop	r16
    1d0a:	ff 90       	pop	r15
    1d0c:	ef 90       	pop	r14
    1d0e:	df 90       	pop	r13
    1d10:	cf 90       	pop	r12
    1d12:	bf 90       	pop	r11
    1d14:	af 90       	pop	r10
    1d16:	08 95       	ret

00001d18 <vTaskSuspendAll>:
    1d18:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1d1c:	8f 5f       	subi	r24, 0xFF	; 255
    1d1e:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <uxSchedulerSuspended>
    1d22:	08 95       	ret

00001d24 <xTaskGetTickCount>:
    1d24:	0f b6       	in	r0, 0x3f	; 63
    1d26:	f8 94       	cli
    1d28:	0f 92       	push	r0
    1d2a:	60 91 ee 30 	lds	r22, 0x30EE	; 0x8030ee <xTickCount>
    1d2e:	70 91 ef 30 	lds	r23, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1d32:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1d36:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1d3a:	0f 90       	pop	r0
    1d3c:	0f be       	out	0x3f, r0	; 63
    1d3e:	08 95       	ret

00001d40 <pcTaskGetTaskName>:
    1d40:	00 97       	sbiw	r24, 0x00	; 0
    1d42:	21 f4       	brne	.+8      	; 0x1d4c <pcTaskGetTaskName+0xc>
    1d44:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    1d48:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1d4c:	4d 96       	adiw	r24, 0x1d	; 29
    1d4e:	08 95       	ret

00001d50 <xTaskGetIdleTaskHandle>:
    1d50:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <xIdleTaskHandle>
    1d54:	90 91 f4 30 	lds	r25, 0x30F4	; 0x8030f4 <xIdleTaskHandle+0x1>
    1d58:	08 95       	ret

00001d5a <vTaskIncrementTick>:
    1d5a:	ff 92       	push	r15
    1d5c:	0f 93       	push	r16
    1d5e:	1f 93       	push	r17
    1d60:	cf 93       	push	r28
    1d62:	df 93       	push	r29
    1d64:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1d68:	81 11       	cpse	r24, r1
    1d6a:	ed c0       	rjmp	.+474    	; 0x1f46 <vTaskIncrementTick+0x1ec>
    1d6c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1d70:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1d74:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1d78:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1d7c:	01 96       	adiw	r24, 0x01	; 1
    1d7e:	a1 1d       	adc	r26, r1
    1d80:	b1 1d       	adc	r27, r1
    1d82:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <xTickCount>
    1d86:	90 93 ef 30 	sts	0x30EF, r25	; 0x8030ef <xTickCount+0x1>
    1d8a:	a0 93 f0 30 	sts	0x30F0, r26	; 0x8030f0 <xTickCount+0x2>
    1d8e:	b0 93 f1 30 	sts	0x30F1, r27	; 0x8030f1 <xTickCount+0x3>
    1d92:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    1d96:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1d9a:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1d9e:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1da2:	89 2b       	or	r24, r25
    1da4:	8a 2b       	or	r24, r26
    1da6:	8b 2b       	or	r24, r27
    1da8:	f1 f5       	brne	.+124    	; 0x1e26 <vTaskIncrementTick+0xcc>
    1daa:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxDelayedTaskList>
    1dae:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1db2:	20 91 00 31 	lds	r18, 0x3100	; 0x803100 <pxOverflowDelayedTaskList>
    1db6:	30 91 01 31 	lds	r19, 0x3101	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1dba:	20 93 02 31 	sts	0x3102, r18	; 0x803102 <pxDelayedTaskList>
    1dbe:	30 93 03 31 	sts	0x3103, r19	; 0x803103 <pxDelayedTaskList+0x1>
    1dc2:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <pxOverflowDelayedTaskList>
    1dc6:	90 93 01 31 	sts	0x3101, r25	; 0x803101 <pxOverflowDelayedTaskList+0x1>
    1dca:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    1dce:	8f 5f       	subi	r24, 0xFF	; 255
    1dd0:	80 93 e7 30 	sts	0x30E7, r24	; 0x8030e7 <xNumOfOverflows>
    1dd4:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1dd8:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1ddc:	80 81       	ld	r24, Z
    1dde:	81 11       	cpse	r24, r1
    1de0:	0c c0       	rjmp	.+24     	; 0x1dfa <vTaskIncrementTick+0xa0>
    1de2:	8f ef       	ldi	r24, 0xFF	; 255
    1de4:	9f ef       	ldi	r25, 0xFF	; 255
    1de6:	dc 01       	movw	r26, r24
    1de8:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1dec:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1df0:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1df4:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1df8:	16 c0       	rjmp	.+44     	; 0x1e26 <vTaskIncrementTick+0xcc>
    1dfa:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1dfe:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e02:	07 80       	ldd	r0, Z+7	; 0x07
    1e04:	f0 85       	ldd	r31, Z+8	; 0x08
    1e06:	e0 2d       	mov	r30, r0
    1e08:	00 84       	ldd	r0, Z+8	; 0x08
    1e0a:	f1 85       	ldd	r31, Z+9	; 0x09
    1e0c:	e0 2d       	mov	r30, r0
    1e0e:	82 81       	ldd	r24, Z+2	; 0x02
    1e10:	93 81       	ldd	r25, Z+3	; 0x03
    1e12:	a4 81       	ldd	r26, Z+4	; 0x04
    1e14:	b5 81       	ldd	r27, Z+5	; 0x05
    1e16:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e1a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e1e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e22:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e26:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1e2a:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1e2e:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1e32:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1e36:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e3a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e3e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e42:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e46:	48 17       	cp	r20, r24
    1e48:	59 07       	cpc	r21, r25
    1e4a:	6a 07       	cpc	r22, r26
    1e4c:	7b 07       	cpc	r23, r27
    1e4e:	08 f4       	brcc	.+2      	; 0x1e52 <vTaskIncrementTick+0xf8>
    1e50:	7f c0       	rjmp	.+254    	; 0x1f50 <vTaskIncrementTick+0x1f6>
    1e52:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1e56:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e5a:	80 81       	ld	r24, Z
    1e5c:	88 23       	and	r24, r24
    1e5e:	f9 f0       	breq	.+62     	; 0x1e9e <vTaskIncrementTick+0x144>
    1e60:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1e64:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1e68:	07 80       	ldd	r0, Z+7	; 0x07
    1e6a:	f0 85       	ldd	r31, Z+8	; 0x08
    1e6c:	e0 2d       	mov	r30, r0
    1e6e:	c0 85       	ldd	r28, Z+8	; 0x08
    1e70:	d1 85       	ldd	r29, Z+9	; 0x09
    1e72:	8a 81       	ldd	r24, Y+2	; 0x02
    1e74:	9b 81       	ldd	r25, Y+3	; 0x03
    1e76:	ac 81       	ldd	r26, Y+4	; 0x04
    1e78:	bd 81       	ldd	r27, Y+5	; 0x05
    1e7a:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1e7e:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1e82:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1e86:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1e8a:	48 17       	cp	r20, r24
    1e8c:	59 07       	cpc	r21, r25
    1e8e:	6a 07       	cpc	r22, r26
    1e90:	7b 07       	cpc	r23, r27
    1e92:	58 f1       	brcs	.+86     	; 0x1eea <vTaskIncrementTick+0x190>
    1e94:	0f 2e       	mov	r0, r31
    1e96:	fb e0       	ldi	r31, 0x0B	; 11
    1e98:	ff 2e       	mov	r15, r31
    1e9a:	f0 2d       	mov	r31, r0
    1e9c:	2f c0       	rjmp	.+94     	; 0x1efc <vTaskIncrementTick+0x1a2>
    1e9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ea0:	9f ef       	ldi	r25, 0xFF	; 255
    1ea2:	dc 01       	movw	r26, r24
    1ea4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1ea8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1eac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1eb0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1eb4:	4d c0       	rjmp	.+154    	; 0x1f50 <vTaskIncrementTick+0x1f6>
    1eb6:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1eba:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1ebe:	07 80       	ldd	r0, Z+7	; 0x07
    1ec0:	f0 85       	ldd	r31, Z+8	; 0x08
    1ec2:	e0 2d       	mov	r30, r0
    1ec4:	c0 85       	ldd	r28, Z+8	; 0x08
    1ec6:	d1 85       	ldd	r29, Z+9	; 0x09
    1ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    1eca:	9b 81       	ldd	r25, Y+3	; 0x03
    1ecc:	ac 81       	ldd	r26, Y+4	; 0x04
    1ece:	bd 81       	ldd	r27, Y+5	; 0x05
    1ed0:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    1ed4:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    1ed8:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    1edc:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    1ee0:	48 17       	cp	r20, r24
    1ee2:	59 07       	cpc	r21, r25
    1ee4:	6a 07       	cpc	r22, r26
    1ee6:	7b 07       	cpc	r23, r27
    1ee8:	48 f4       	brcc	.+18     	; 0x1efc <vTaskIncrementTick+0x1a2>
    1eea:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1eee:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ef2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ef6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1efa:	2a c0       	rjmp	.+84     	; 0x1f50 <vTaskIncrementTick+0x1f6>
    1efc:	8e 01       	movw	r16, r28
    1efe:	0e 5f       	subi	r16, 0xFE	; 254
    1f00:	1f 4f       	sbci	r17, 0xFF	; 255
    1f02:	c8 01       	movw	r24, r16
    1f04:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
    1f08:	88 8d       	ldd	r24, Y+24	; 0x18
    1f0a:	99 8d       	ldd	r25, Y+25	; 0x19
    1f0c:	89 2b       	or	r24, r25
    1f0e:	21 f0       	breq	.+8      	; 0x1f18 <vTaskIncrementTick+0x1be>
    1f10:	ce 01       	movw	r24, r28
    1f12:	0e 96       	adiw	r24, 0x0e	; 14
    1f14:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
    1f18:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f1a:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1f1e:	98 17       	cp	r25, r24
    1f20:	10 f4       	brcc	.+4      	; 0x1f26 <vTaskIncrementTick+0x1cc>
    1f22:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1f26:	f8 9e       	mul	r15, r24
    1f28:	c0 01       	movw	r24, r0
    1f2a:	11 24       	eor	r1, r1
    1f2c:	b8 01       	movw	r22, r16
    1f2e:	86 5e       	subi	r24, 0xE6	; 230
    1f30:	9e 4c       	sbci	r25, 0xCE	; 206
    1f32:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
    1f36:	e0 91 02 31 	lds	r30, 0x3102	; 0x803102 <pxDelayedTaskList>
    1f3a:	f0 91 03 31 	lds	r31, 0x3103	; 0x803103 <pxDelayedTaskList+0x1>
    1f3e:	80 81       	ld	r24, Z
    1f40:	81 11       	cpse	r24, r1
    1f42:	b9 cf       	rjmp	.-142    	; 0x1eb6 <vTaskIncrementTick+0x15c>
    1f44:	ac cf       	rjmp	.-168    	; 0x1e9e <vTaskIncrementTick+0x144>
    1f46:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    1f4a:	8f 5f       	subi	r24, 0xFF	; 255
    1f4c:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxMissedTicks>
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	1f 91       	pop	r17
    1f56:	0f 91       	pop	r16
    1f58:	ff 90       	pop	r15
    1f5a:	08 95       	ret

00001f5c <xTaskResumeAll>:
    1f5c:	cf 92       	push	r12
    1f5e:	df 92       	push	r13
    1f60:	ef 92       	push	r14
    1f62:	ff 92       	push	r15
    1f64:	0f 93       	push	r16
    1f66:	1f 93       	push	r17
    1f68:	cf 93       	push	r28
    1f6a:	df 93       	push	r29
    1f6c:	0f b6       	in	r0, 0x3f	; 63
    1f6e:	f8 94       	cli
    1f70:	0f 92       	push	r0
    1f72:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1f76:	81 50       	subi	r24, 0x01	; 1
    1f78:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <uxSchedulerSuspended>
    1f7c:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    1f80:	81 11       	cpse	r24, r1
    1f82:	60 c0       	rjmp	.+192    	; 0x2044 <xTaskResumeAll+0xe8>
    1f84:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <uxCurrentNumberOfTasks>
    1f88:	81 11       	cpse	r24, r1
    1f8a:	2c c0       	rjmp	.+88     	; 0x1fe4 <xTaskResumeAll+0x88>
    1f8c:	5e c0       	rjmp	.+188    	; 0x204a <xTaskResumeAll+0xee>
    1f8e:	d7 01       	movw	r26, r14
    1f90:	17 96       	adiw	r26, 0x07	; 7
    1f92:	ed 91       	ld	r30, X+
    1f94:	fc 91       	ld	r31, X
    1f96:	18 97       	sbiw	r26, 0x08	; 8
    1f98:	c0 85       	ldd	r28, Z+8	; 0x08
    1f9a:	d1 85       	ldd	r29, Z+9	; 0x09
    1f9c:	ce 01       	movw	r24, r28
    1f9e:	0e 96       	adiw	r24, 0x0e	; 14
    1fa0:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
    1fa4:	8e 01       	movw	r16, r28
    1fa6:	0e 5f       	subi	r16, 0xFE	; 254
    1fa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1faa:	c8 01       	movw	r24, r16
    1fac:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
    1fb0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1fb2:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    1fb6:	98 17       	cp	r25, r24
    1fb8:	10 f4       	brcc	.+4      	; 0x1fbe <xTaskResumeAll+0x62>
    1fba:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    1fbe:	d8 9e       	mul	r13, r24
    1fc0:	c0 01       	movw	r24, r0
    1fc2:	11 24       	eor	r1, r1
    1fc4:	b8 01       	movw	r22, r16
    1fc6:	86 5e       	subi	r24, 0xE6	; 230
    1fc8:	9e 4c       	sbci	r25, 0xCE	; 206
    1fca:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
    1fce:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    1fd2:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    1fd6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1fd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fda:	98 17       	cp	r25, r24
    1fdc:	70 f0       	brcs	.+28     	; 0x1ffa <xTaskResumeAll+0x9e>
    1fde:	cc 24       	eor	r12, r12
    1fe0:	c3 94       	inc	r12
    1fe2:	0b c0       	rjmp	.+22     	; 0x1ffa <xTaskResumeAll+0x9e>
    1fe4:	c1 2c       	mov	r12, r1
    1fe6:	0f 2e       	mov	r0, r31
    1fe8:	f5 ef       	ldi	r31, 0xF5	; 245
    1fea:	ef 2e       	mov	r14, r31
    1fec:	f0 e3       	ldi	r31, 0x30	; 48
    1fee:	ff 2e       	mov	r15, r31
    1ff0:	f0 2d       	mov	r31, r0
    1ff2:	0f 2e       	mov	r0, r31
    1ff4:	fb e0       	ldi	r31, 0x0B	; 11
    1ff6:	df 2e       	mov	r13, r31
    1ff8:	f0 2d       	mov	r31, r0
    1ffa:	f7 01       	movw	r30, r14
    1ffc:	80 81       	ld	r24, Z
    1ffe:	81 11       	cpse	r24, r1
    2000:	c6 cf       	rjmp	.-116    	; 0x1f8e <xTaskResumeAll+0x32>
    2002:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    2006:	88 23       	and	r24, r24
    2008:	81 f0       	breq	.+32     	; 0x202a <xTaskResumeAll+0xce>
    200a:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    200e:	88 23       	and	r24, r24
    2010:	99 f0       	breq	.+38     	; 0x2038 <xTaskResumeAll+0xdc>
    2012:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <vTaskIncrementTick>
    2016:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    201a:	81 50       	subi	r24, 0x01	; 1
    201c:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxMissedTicks>
    2020:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <uxMissedTicks>
    2024:	81 11       	cpse	r24, r1
    2026:	f5 cf       	rjmp	.-22     	; 0x2012 <xTaskResumeAll+0xb6>
    2028:	07 c0       	rjmp	.+14     	; 0x2038 <xTaskResumeAll+0xdc>
    202a:	f1 e0       	ldi	r31, 0x01	; 1
    202c:	cf 16       	cp	r12, r31
    202e:	21 f0       	breq	.+8      	; 0x2038 <xTaskResumeAll+0xdc>
    2030:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <xMissedYield>
    2034:	81 30       	cpi	r24, 0x01	; 1
    2036:	41 f4       	brne	.+16     	; 0x2048 <xTaskResumeAll+0xec>
    2038:	10 92 e8 30 	sts	0x30E8, r1	; 0x8030e8 <xMissedYield>
    203c:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
    2040:	81 e0       	ldi	r24, 0x01	; 1
    2042:	03 c0       	rjmp	.+6      	; 0x204a <xTaskResumeAll+0xee>
    2044:	80 e0       	ldi	r24, 0x00	; 0
    2046:	01 c0       	rjmp	.+2      	; 0x204a <xTaskResumeAll+0xee>
    2048:	80 e0       	ldi	r24, 0x00	; 0
    204a:	0f 90       	pop	r0
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	df 91       	pop	r29
    2050:	cf 91       	pop	r28
    2052:	1f 91       	pop	r17
    2054:	0f 91       	pop	r16
    2056:	ff 90       	pop	r15
    2058:	ef 90       	pop	r14
    205a:	df 90       	pop	r13
    205c:	cf 90       	pop	r12
    205e:	08 95       	ret

00002060 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2060:	cf 92       	push	r12
    2062:	df 92       	push	r13
    2064:	ef 92       	push	r14
    2066:	ff 92       	push	r15
    2068:	6b 01       	movw	r12, r22
    206a:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    206c:	67 2b       	or	r22, r23
    206e:	68 2b       	or	r22, r24
    2070:	69 2b       	or	r22, r25
    2072:	e9 f0       	breq	.+58     	; 0x20ae <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2074:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2078:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    207c:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    2080:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    2084:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    2088:	c8 0e       	add	r12, r24
    208a:	d9 1e       	adc	r13, r25
    208c:	ea 1e       	adc	r14, r26
    208e:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2090:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    2094:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    2098:	02 96       	adiw	r24, 0x02	; 2
    209a:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    209e:	c7 01       	movw	r24, r14
    20a0:	b6 01       	movw	r22, r12
    20a2:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    20a6:	0e 94 ae 0f 	call	0x1f5c	; 0x1f5c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    20aa:	81 11       	cpse	r24, r1
    20ac:	02 c0       	rjmp	.+4      	; 0x20b2 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    20ae:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortYield>
		}
	}
    20b2:	ff 90       	pop	r15
    20b4:	ef 90       	pop	r14
    20b6:	df 90       	pop	r13
    20b8:	cf 90       	pop	r12
    20ba:	08 95       	ret

000020bc <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20bc:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    20c0:	81 11       	cpse	r24, r1
    20c2:	0c c0       	rjmp	.+24     	; 0x20dc <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20c4:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    20c8:	4b e0       	ldi	r20, 0x0B	; 11
    20ca:	e4 9f       	mul	r30, r20
    20cc:	f0 01       	movw	r30, r0
    20ce:	11 24       	eor	r1, r1
    20d0:	e6 5e       	subi	r30, 0xE6	; 230
    20d2:	fe 4c       	sbci	r31, 0xCE	; 206
    20d4:	80 81       	ld	r24, Z
    20d6:	88 23       	and	r24, r24
    20d8:	29 f0       	breq	.+10     	; 0x20e4 <vTaskSwitchContext+0x28>
    20da:	14 c0       	rjmp	.+40     	; 0x2104 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <xMissedYield>
    20e2:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20e4:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20e6:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    20ea:	81 50       	subi	r24, 0x01	; 1
    20ec:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20f0:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    20f4:	9e 9f       	mul	r25, r30
    20f6:	f0 01       	movw	r30, r0
    20f8:	11 24       	eor	r1, r1
    20fa:	e6 5e       	subi	r30, 0xE6	; 230
    20fc:	fe 4c       	sbci	r31, 0xCE	; 206
    20fe:	80 81       	ld	r24, Z
    2100:	88 23       	and	r24, r24
    2102:	89 f3       	breq	.-30     	; 0x20e6 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2104:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2108:	28 2f       	mov	r18, r24
    210a:	30 e0       	ldi	r19, 0x00	; 0
    210c:	4b e0       	ldi	r20, 0x0B	; 11
    210e:	84 9f       	mul	r24, r20
    2110:	c0 01       	movw	r24, r0
    2112:	11 24       	eor	r1, r1
    2114:	dc 01       	movw	r26, r24
    2116:	a6 5e       	subi	r26, 0xE6	; 230
    2118:	be 4c       	sbci	r27, 0xCE	; 206
    211a:	11 96       	adiw	r26, 0x01	; 1
    211c:	ed 91       	ld	r30, X+
    211e:	fc 91       	ld	r31, X
    2120:	12 97       	sbiw	r26, 0x02	; 2
    2122:	04 80       	ldd	r0, Z+4	; 0x04
    2124:	f5 81       	ldd	r31, Z+5	; 0x05
    2126:	e0 2d       	mov	r30, r0
    2128:	11 96       	adiw	r26, 0x01	; 1
    212a:	ed 93       	st	X+, r30
    212c:	fc 93       	st	X, r31
    212e:	12 97       	sbiw	r26, 0x02	; 2
    2130:	83 5e       	subi	r24, 0xE3	; 227
    2132:	9e 4c       	sbci	r25, 0xCE	; 206
    2134:	e8 17       	cp	r30, r24
    2136:	f9 07       	cpc	r31, r25
    2138:	61 f4       	brne	.+24     	; 0x2152 <vTaskSwitchContext+0x96>
    213a:	84 81       	ldd	r24, Z+4	; 0x04
    213c:	95 81       	ldd	r25, Z+5	; 0x05
    213e:	4b e0       	ldi	r20, 0x0B	; 11
    2140:	42 9f       	mul	r20, r18
    2142:	f0 01       	movw	r30, r0
    2144:	43 9f       	mul	r20, r19
    2146:	f0 0d       	add	r31, r0
    2148:	11 24       	eor	r1, r1
    214a:	e6 5e       	subi	r30, 0xE6	; 230
    214c:	fe 4c       	sbci	r31, 0xCE	; 206
    214e:	81 83       	std	Z+1, r24	; 0x01
    2150:	92 83       	std	Z+2, r25	; 0x02
    2152:	8b e0       	ldi	r24, 0x0B	; 11
    2154:	82 9f       	mul	r24, r18
    2156:	f0 01       	movw	r30, r0
    2158:	83 9f       	mul	r24, r19
    215a:	f0 0d       	add	r31, r0
    215c:	11 24       	eor	r1, r1
    215e:	e6 5e       	subi	r30, 0xE6	; 230
    2160:	fe 4c       	sbci	r31, 0xCE	; 206
    2162:	01 80       	ldd	r0, Z+1	; 0x01
    2164:	f2 81       	ldd	r31, Z+2	; 0x02
    2166:	e0 2d       	mov	r30, r0
    2168:	80 85       	ldd	r24, Z+8	; 0x08
    216a:	91 85       	ldd	r25, Z+9	; 0x09
    216c:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <pxCurrentTCB>
    2170:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <pxCurrentTCB+0x1>
    2174:	08 95       	ret

00002176 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2176:	cf 92       	push	r12
    2178:	df 92       	push	r13
    217a:	ef 92       	push	r14
    217c:	ff 92       	push	r15
    217e:	6a 01       	movw	r12, r20
    2180:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2182:	60 91 46 31 	lds	r22, 0x3146	; 0x803146 <pxCurrentTCB>
    2186:	70 91 47 31 	lds	r23, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    218a:	62 5f       	subi	r22, 0xF2	; 242
    218c:	7f 4f       	sbci	r23, 0xFF	; 255
    218e:	0e 94 2a 08 	call	0x1054	; 0x1054 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2192:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    2196:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    219a:	02 96       	adiw	r24, 0x02	; 2
    219c:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21a0:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    21a4:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    21a8:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    21ac:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21b0:	bc 01       	movw	r22, r24
    21b2:	cd 01       	movw	r24, r26
    21b4:	6c 0d       	add	r22, r12
    21b6:	7d 1d       	adc	r23, r13
    21b8:	8e 1d       	adc	r24, r14
    21ba:	9f 1d       	adc	r25, r15
    21bc:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21c0:	ff 90       	pop	r15
    21c2:	ef 90       	pop	r14
    21c4:	df 90       	pop	r13
    21c6:	cf 90       	pop	r12
    21c8:	08 95       	ret

000021ca <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    21ca:	0f 93       	push	r16
    21cc:	1f 93       	push	r17
    21ce:	cf 93       	push	r28
    21d0:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    21d2:	dc 01       	movw	r26, r24
    21d4:	17 96       	adiw	r26, 0x07	; 7
    21d6:	ed 91       	ld	r30, X+
    21d8:	fc 91       	ld	r31, X
    21da:	18 97       	sbiw	r26, 0x08	; 8
    21dc:	c0 85       	ldd	r28, Z+8	; 0x08
    21de:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    21e0:	8e 01       	movw	r16, r28
    21e2:	02 5f       	subi	r16, 0xF2	; 242
    21e4:	1f 4f       	sbci	r17, 0xFF	; 255
    21e6:	c8 01       	movw	r24, r16
    21e8:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21ec:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <uxSchedulerSuspended>
    21f0:	81 11       	cpse	r24, r1
    21f2:	16 c0       	rjmp	.+44     	; 0x2220 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    21f4:	0c 50       	subi	r16, 0x0C	; 12
    21f6:	11 09       	sbc	r17, r1
    21f8:	c8 01       	movw	r24, r16
    21fa:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    21fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2200:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2204:	98 17       	cp	r25, r24
    2206:	10 f4       	brcc	.+4      	; 0x220c <xTaskRemoveFromEventList+0x42>
    2208:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    220c:	bb e0       	ldi	r27, 0x0B	; 11
    220e:	8b 9f       	mul	r24, r27
    2210:	c0 01       	movw	r24, r0
    2212:	11 24       	eor	r1, r1
    2214:	b8 01       	movw	r22, r16
    2216:	86 5e       	subi	r24, 0xE6	; 230
    2218:	9e 4c       	sbci	r25, 0xCE	; 206
    221a:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
    221e:	05 c0       	rjmp	.+10     	; 0x222a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2220:	b8 01       	movw	r22, r16
    2222:	85 ef       	ldi	r24, 0xF5	; 245
    2224:	90 e3       	ldi	r25, 0x30	; 48
    2226:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    222a:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    222e:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2232:	81 e0       	ldi	r24, 0x01	; 1
    2234:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2236:	92 8d       	ldd	r25, Z+26	; 0x1a
    2238:	29 17       	cp	r18, r25
    223a:	08 f4       	brcc	.+2      	; 0x223e <xTaskRemoveFromEventList+0x74>
    223c:	80 e0       	ldi	r24, 0x00	; 0
}
    223e:	df 91       	pop	r29
    2240:	cf 91       	pop	r28
    2242:	1f 91       	pop	r17
    2244:	0f 91       	pop	r16
    2246:	08 95       	ret

00002248 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2248:	20 91 e7 30 	lds	r18, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    224c:	fc 01       	movw	r30, r24
    224e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2250:	40 91 ee 30 	lds	r20, 0x30EE	; 0x8030ee <xTickCount>
    2254:	50 91 ef 30 	lds	r21, 0x30EF	; 0x8030ef <xTickCount+0x1>
    2258:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    225c:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    2260:	41 83       	std	Z+1, r20	; 0x01
    2262:	52 83       	std	Z+2, r21	; 0x02
    2264:	63 83       	std	Z+3, r22	; 0x03
    2266:	74 83       	std	Z+4, r23	; 0x04
    2268:	08 95       	ret

0000226a <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    226a:	8f 92       	push	r8
    226c:	9f 92       	push	r9
    226e:	af 92       	push	r10
    2270:	bf 92       	push	r11
    2272:	cf 92       	push	r12
    2274:	df 92       	push	r13
    2276:	ef 92       	push	r14
    2278:	ff 92       	push	r15
    227a:	0f 93       	push	r16
    227c:	1f 93       	push	r17
    227e:	cf 93       	push	r28
    2280:	df 93       	push	r29
    2282:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2284:	0f b6       	in	r0, 0x3f	; 63
    2286:	f8 94       	cli
    2288:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    228a:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xNumOfOverflows>
    228e:	90 81       	ld	r25, Z
    2290:	98 17       	cp	r25, r24
    2292:	89 f0       	breq	.+34     	; 0x22b6 <xTaskCheckForTimeOut+0x4c>
    2294:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    2298:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    229c:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    22a0:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    22a4:	01 81       	ldd	r16, Z+1	; 0x01
    22a6:	12 81       	ldd	r17, Z+2	; 0x02
    22a8:	23 81       	ldd	r18, Z+3	; 0x03
    22aa:	34 81       	ldd	r19, Z+4	; 0x04
    22ac:	80 17       	cp	r24, r16
    22ae:	91 07       	cpc	r25, r17
    22b0:	a2 07       	cpc	r26, r18
    22b2:	b3 07       	cpc	r27, r19
    22b4:	a8 f5       	brcc	.+106    	; 0x2320 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    22b6:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <xTickCount>
    22ba:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <xTickCount+0x1>
    22be:	a0 91 f0 30 	lds	r26, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    22c2:	b0 91 f1 30 	lds	r27, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    22c6:	c1 80       	ldd	r12, Z+1	; 0x01
    22c8:	d2 80       	ldd	r13, Z+2	; 0x02
    22ca:	e3 80       	ldd	r14, Z+3	; 0x03
    22cc:	f4 80       	ldd	r15, Z+4	; 0x04
    22ce:	eb 01       	movw	r28, r22
    22d0:	08 81       	ld	r16, Y
    22d2:	19 81       	ldd	r17, Y+1	; 0x01
    22d4:	2a 81       	ldd	r18, Y+2	; 0x02
    22d6:	3b 81       	ldd	r19, Y+3	; 0x03
    22d8:	8c 19       	sub	r24, r12
    22da:	9d 09       	sbc	r25, r13
    22dc:	ae 09       	sbc	r26, r14
    22de:	bf 09       	sbc	r27, r15
    22e0:	80 17       	cp	r24, r16
    22e2:	91 07       	cpc	r25, r17
    22e4:	a2 07       	cpc	r26, r18
    22e6:	b3 07       	cpc	r27, r19
    22e8:	e8 f4       	brcc	.+58     	; 0x2324 <xTaskCheckForTimeOut+0xba>
    22ea:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    22ec:	80 90 ee 30 	lds	r8, 0x30EE	; 0x8030ee <xTickCount>
    22f0:	90 90 ef 30 	lds	r9, 0x30EF	; 0x8030ef <xTickCount+0x1>
    22f4:	a0 90 f0 30 	lds	r10, 0x30F0	; 0x8030f0 <xTickCount+0x2>
    22f8:	b0 90 f1 30 	lds	r11, 0x30F1	; 0x8030f1 <xTickCount+0x3>
    22fc:	b5 01       	movw	r22, r10
    22fe:	a4 01       	movw	r20, r8
    2300:	4c 19       	sub	r20, r12
    2302:	5d 09       	sbc	r21, r13
    2304:	6e 09       	sbc	r22, r14
    2306:	7f 09       	sbc	r23, r15
    2308:	04 1b       	sub	r16, r20
    230a:	15 0b       	sbc	r17, r21
    230c:	26 0b       	sbc	r18, r22
    230e:	37 0b       	sbc	r19, r23
    2310:	08 83       	st	Y, r16
    2312:	19 83       	std	Y+1, r17	; 0x01
    2314:	2a 83       	std	Y+2, r18	; 0x02
    2316:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2318:	0e 94 24 11 	call	0x2248	; 0x2248 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    231c:	80 e0       	ldi	r24, 0x00	; 0
    231e:	03 c0       	rjmp	.+6      	; 0x2326 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	01 c0       	rjmp	.+2      	; 0x2326 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2324:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2326:	0f 90       	pop	r0
    2328:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    232a:	df 91       	pop	r29
    232c:	cf 91       	pop	r28
    232e:	1f 91       	pop	r17
    2330:	0f 91       	pop	r16
    2332:	ff 90       	pop	r15
    2334:	ef 90       	pop	r14
    2336:	df 90       	pop	r13
    2338:	cf 90       	pop	r12
    233a:	bf 90       	pop	r11
    233c:	af 90       	pop	r10
    233e:	9f 90       	pop	r9
    2340:	8f 90       	pop	r8
    2342:	08 95       	ret

00002344 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2344:	81 e0       	ldi	r24, 0x01	; 1
    2346:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <xMissedYield>
    234a:	08 95       	ret

0000234c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    234c:	00 97       	sbiw	r24, 0x00	; 0
    234e:	21 f4       	brne	.+8      	; 0x2358 <uxTaskGetStackHighWaterMark+0xc>
    2350:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    2354:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2358:	dc 01       	movw	r26, r24
    235a:	5b 96       	adiw	r26, 0x1b	; 27
    235c:	ed 91       	ld	r30, X+
    235e:	fc 91       	ld	r31, X
    2360:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2362:	80 81       	ld	r24, Z
    2364:	81 31       	cpi	r24, 0x11	; 17
    2366:	41 f4       	brne	.+16     	; 0x2378 <uxTaskGetStackHighWaterMark+0x2c>
    2368:	31 96       	adiw	r30, 0x01	; 1
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    236e:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2370:	21 91       	ld	r18, Z+
    2372:	21 31       	cpi	r18, 0x11	; 17
    2374:	e1 f3       	breq	.-8      	; 0x236e <uxTaskGetStackHighWaterMark+0x22>
    2376:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2378:	80 e0       	ldi	r24, 0x00	; 0
    237a:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    237c:	08 95       	ret

0000237e <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    237e:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <pxCurrentTCB>
    2382:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2386:	08 95       	ret

00002388 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2388:	0f 93       	push	r16
    238a:	1f 93       	push	r17
    238c:	cf 93       	push	r28
    238e:	df 93       	push	r29
    2390:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2392:	22 8d       	ldd	r18, Z+26	; 0x1a
    2394:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    2398:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    239c:	5a 96       	adiw	r26, 0x1a	; 26
    239e:	8c 91       	ld	r24, X
    23a0:	28 17       	cp	r18, r24
    23a2:	08 f0       	brcs	.+2      	; 0x23a6 <vTaskPriorityInherit+0x1e>
    23a4:	41 c0       	rjmp	.+130    	; 0x2428 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    23a6:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    23aa:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    23ae:	5a 96       	adiw	r26, 0x1a	; 26
    23b0:	3c 91       	ld	r19, X
    23b2:	84 e0       	ldi	r24, 0x04	; 4
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	a0 e0       	ldi	r26, 0x00	; 0
    23b8:	b0 e0       	ldi	r27, 0x00	; 0
    23ba:	83 1b       	sub	r24, r19
    23bc:	91 09       	sbc	r25, r1
    23be:	a1 09       	sbc	r26, r1
    23c0:	b1 09       	sbc	r27, r1
    23c2:	86 87       	std	Z+14, r24	; 0x0e
    23c4:	97 87       	std	Z+15, r25	; 0x0f
    23c6:	a0 8b       	std	Z+16, r26	; 0x10
    23c8:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    23ca:	8b e0       	ldi	r24, 0x0B	; 11
    23cc:	28 9f       	mul	r18, r24
    23ce:	90 01       	movw	r18, r0
    23d0:	11 24       	eor	r1, r1
    23d2:	26 5e       	subi	r18, 0xE6	; 230
    23d4:	3e 4c       	sbci	r19, 0xCE	; 206
    23d6:	84 85       	ldd	r24, Z+12	; 0x0c
    23d8:	95 85       	ldd	r25, Z+13	; 0x0d
    23da:	82 17       	cp	r24, r18
    23dc:	93 07       	cpc	r25, r19
    23de:	e9 f4       	brne	.+58     	; 0x241a <vTaskPriorityInherit+0x92>
    23e0:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    23e2:	ef 01       	movw	r28, r30
    23e4:	22 96       	adiw	r28, 0x02	; 2
    23e6:	ce 01       	movw	r24, r28
    23e8:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    23ec:	e0 91 46 31 	lds	r30, 0x3146	; 0x803146 <pxCurrentTCB>
    23f0:	f0 91 47 31 	lds	r31, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    23f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    23f6:	f8 01       	movw	r30, r16
    23f8:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    23fa:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    23fe:	98 17       	cp	r25, r24
    2400:	10 f4       	brcc	.+4      	; 0x2406 <vTaskPriorityInherit+0x7e>
    2402:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    2406:	fb e0       	ldi	r31, 0x0B	; 11
    2408:	8f 9f       	mul	r24, r31
    240a:	c0 01       	movw	r24, r0
    240c:	11 24       	eor	r1, r1
    240e:	be 01       	movw	r22, r28
    2410:	86 5e       	subi	r24, 0xE6	; 230
    2412:	9e 4c       	sbci	r25, 0xCE	; 206
    2414:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
    2418:	07 c0       	rjmp	.+14     	; 0x2428 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    241a:	a0 91 46 31 	lds	r26, 0x3146	; 0x803146 <pxCurrentTCB>
    241e:	b0 91 47 31 	lds	r27, 0x3147	; 0x803147 <pxCurrentTCB+0x1>
    2422:	5a 96       	adiw	r26, 0x1a	; 26
    2424:	8c 91       	ld	r24, X
    2426:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2428:	df 91       	pop	r29
    242a:	cf 91       	pop	r28
    242c:	1f 91       	pop	r17
    242e:	0f 91       	pop	r16
    2430:	08 95       	ret

00002432 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2432:	0f 93       	push	r16
    2434:	1f 93       	push	r17
    2436:	cf 93       	push	r28
    2438:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    243a:	00 97       	sbiw	r24, 0x00	; 0
    243c:	49 f1       	breq	.+82     	; 0x2490 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    243e:	fc 01       	movw	r30, r24
    2440:	32 8d       	ldd	r19, Z+26	; 0x1a
    2442:	27 a1       	ldd	r18, Z+39	; 0x27
    2444:	32 17       	cp	r19, r18
    2446:	21 f1       	breq	.+72     	; 0x2490 <vTaskPriorityDisinherit+0x5e>
    2448:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    244a:	8c 01       	movw	r16, r24
    244c:	0e 5f       	subi	r16, 0xFE	; 254
    244e:	1f 4f       	sbci	r17, 0xFF	; 255
    2450:	c8 01       	movw	r24, r16
    2452:	0e 94 75 08 	call	0x10ea	; 0x10ea <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2456:	8f a1       	ldd	r24, Y+39	; 0x27
    2458:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    245a:	44 e0       	ldi	r20, 0x04	; 4
    245c:	50 e0       	ldi	r21, 0x00	; 0
    245e:	60 e0       	ldi	r22, 0x00	; 0
    2460:	70 e0       	ldi	r23, 0x00	; 0
    2462:	48 1b       	sub	r20, r24
    2464:	51 09       	sbc	r21, r1
    2466:	61 09       	sbc	r22, r1
    2468:	71 09       	sbc	r23, r1
    246a:	4e 87       	std	Y+14, r20	; 0x0e
    246c:	5f 87       	std	Y+15, r21	; 0x0f
    246e:	68 8b       	std	Y+16, r22	; 0x10
    2470:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2472:	90 91 ec 30 	lds	r25, 0x30EC	; 0x8030ec <uxTopReadyPriority>
    2476:	98 17       	cp	r25, r24
    2478:	10 f4       	brcc	.+4      	; 0x247e <vTaskPriorityDisinherit+0x4c>
    247a:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxTopReadyPriority>
    247e:	fb e0       	ldi	r31, 0x0B	; 11
    2480:	8f 9f       	mul	r24, r31
    2482:	c0 01       	movw	r24, r0
    2484:	11 24       	eor	r1, r1
    2486:	b8 01       	movw	r22, r16
    2488:	86 5e       	subi	r24, 0xE6	; 230
    248a:	9e 4c       	sbci	r25, 0xCE	; 206
    248c:	0e 94 03 08 	call	0x1006	; 0x1006 <vListInsertEnd>
			}
		}
	}
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	1f 91       	pop	r17
    2496:	0f 91       	pop	r16
    2498:	08 95       	ret

0000249a <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    249a:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    249c:	e8 81       	ld	r30, Y
    249e:	f9 81       	ldd	r31, Y+1	; 0x01
    24a0:	01 90       	ld	r0, Z+
    24a2:	f0 81       	ld	r31, Z
    24a4:	e0 2d       	mov	r30, r0
    24a6:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    24a8:	1a 82       	std	Y+2, r1	; 0x02
    24aa:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    24ac:	6f ef       	ldi	r22, 0xFF	; 255
    24ae:	7f ef       	ldi	r23, 0xFF	; 255
    24b0:	cb 01       	movw	r24, r22
    24b2:	0e 94 30 10 	call	0x2060	; 0x2060 <vTaskDelay>
    24b6:	fa cf       	rjmp	.-12     	; 0x24ac <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000024b8 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    24b8:	fc 01       	movw	r30, r24
    24ba:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    24bc:	65 87       	std	Z+13, r22	; 0x0d
    24be:	08 95       	ret

000024c0 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    24c0:	4f 92       	push	r4
    24c2:	5f 92       	push	r5
    24c4:	6f 92       	push	r6
    24c6:	7f 92       	push	r7
    24c8:	8f 92       	push	r8
    24ca:	9f 92       	push	r9
    24cc:	af 92       	push	r10
    24ce:	bf 92       	push	r11
    24d0:	cf 92       	push	r12
    24d2:	df 92       	push	r13
    24d4:	ef 92       	push	r14
    24d6:	ff 92       	push	r15
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
    24e4:	2a 97       	sbiw	r28, 0x0a	; 10
    24e6:	cd bf       	out	0x3d, r28	; 61
    24e8:	de bf       	out	0x3e, r29	; 62
    24ea:	4c 01       	movw	r8, r24
    24ec:	29 01       	movw	r4, r18
    24ee:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    24f0:	8b e3       	ldi	r24, 0x3B	; 59
    24f2:	90 e2       	ldi	r25, 0x20	; 32
    24f4:	f4 01       	movw	r30, r8
    24f6:	80 83       	st	Z, r24
    24f8:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    24fa:	fb 01       	movw	r30, r22
    24fc:	80 81       	ld	r24, Z
    24fe:	88 23       	and	r24, r24
    2500:	69 f0       	breq	.+26     	; 0x251c <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2502:	de 01       	movw	r26, r28
    2504:	11 96       	adiw	r26, 0x01	; 1
    2506:	31 96       	adiw	r30, 0x01	; 1
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	02 c0       	rjmp	.+4      	; 0x2510 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    250c:	99 30       	cpi	r25, 0x09	; 9
    250e:	39 f0       	breq	.+14     	; 0x251e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2510:	9f 5f       	subi	r25, 0xFF	; 255
    2512:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2514:	81 91       	ld	r24, Z+
    2516:	81 11       	cpse	r24, r1
    2518:	f9 cf       	rjmp	.-14     	; 0x250c <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    251a:	01 c0       	rjmp	.+2      	; 0x251e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    251c:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    251e:	e1 e0       	ldi	r30, 0x01	; 1
    2520:	f0 e0       	ldi	r31, 0x00	; 0
    2522:	ec 0f       	add	r30, r28
    2524:	fd 1f       	adc	r31, r29
    2526:	e9 0f       	add	r30, r25
    2528:	f1 1d       	adc	r31, r1
    252a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    252c:	74 01       	movw	r14, r8
    252e:	f2 e0       	ldi	r31, 0x02	; 2
    2530:	ef 0e       	add	r14, r31
    2532:	f1 1c       	adc	r15, r1
    2534:	a1 2c       	mov	r10, r1
    2536:	b1 2c       	mov	r11, r1
    2538:	c1 2c       	mov	r12, r1
    253a:	d1 2c       	mov	r13, r1
    253c:	04 2f       	mov	r16, r20
    253e:	94 01       	movw	r18, r8
    2540:	a2 01       	movw	r20, r4
    2542:	be 01       	movw	r22, r28
    2544:	6f 5f       	subi	r22, 0xFF	; 255
    2546:	7f 4f       	sbci	r23, 0xFF	; 255
    2548:	88 ee       	ldi	r24, 0xE8	; 232
    254a:	92 e0       	ldi	r25, 0x02	; 2
    254c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2550:	f4 01       	movw	r30, r8
    2552:	66 82       	std	Z+6, r6	; 0x06
    2554:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2556:	40 86       	std	Z+8, r4	; 0x08
    2558:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    255a:	20 91 48 31 	lds	r18, 0x3148	; 0x803148 <last_created_task_pointer>
    255e:	30 91 49 31 	lds	r19, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    2562:	24 83       	std	Z+4, r18	; 0x04
    2564:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2566:	80 92 48 31 	sts	0x3148, r8	; 0x803148 <last_created_task_pointer>
    256a:	90 92 49 31 	sts	0x3149, r9	; 0x803149 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    256e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2570:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2572:	40 90 aa 31 	lds	r4, 0x31AA	; 0x8031aa <portStackTopForTask>
    2576:	50 90 ab 31 	lds	r5, 0x31AB	; 0x8031ab <portStackTopForTask+0x1>
    257a:	ff ef       	ldi	r31, 0xFF	; 255
    257c:	4f 1a       	sub	r4, r31
    257e:	5f 0a       	sbc	r5, r31
    2580:	40 92 aa 31 	sts	0x31AA, r4	; 0x8031aa <portStackTopForTask>
    2584:	50 92 ab 31 	sts	0x31AB, r5	; 0x8031ab <portStackTopForTask+0x1>
    2588:	f4 01       	movw	r30, r8
    258a:	42 86       	std	Z+10, r4	; 0x0a
    258c:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    258e:	16 86       	std	Z+14, r1	; 0x0e
    2590:	17 86       	std	Z+15, r1	; 0x0f
    2592:	10 8a       	std	Z+16, r1	; 0x10
    2594:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2596:	61 14       	cp	r6, r1
    2598:	71 04       	cpc	r7, r1
    259a:	09 f4       	brne	.+2      	; 0x259e <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    259c:	44 c0       	rjmp	.+136    	; 0x2626 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    259e:	81 30       	cpi	r24, 0x01	; 1
    25a0:	79 f5       	brne	.+94     	; 0x2600 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    25a2:	6a e0       	ldi	r22, 0x0A	; 10
    25a4:	c3 01       	movw	r24, r6
    25a6:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25aa:	7c 01       	movw	r14, r24
    25ac:	6d e1       	ldi	r22, 0x1D	; 29
    25ae:	75 e0       	ldi	r23, 0x05	; 5
    25b0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    25b4:	be 01       	movw	r22, r28
    25b6:	6f 5f       	subi	r22, 0xFF	; 255
    25b8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ba:	c7 01       	movw	r24, r14
    25bc:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    25c0:	6a e0       	ldi	r22, 0x0A	; 10
    25c2:	c7 01       	movw	r24, r14
    25c4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25c8:	7c 01       	movw	r14, r24
    25ca:	64 e1       	ldi	r22, 0x14	; 20
    25cc:	75 e0       	ldi	r23, 0x05	; 5
    25ce:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    25d2:	6a e0       	ldi	r22, 0x0A	; 10
    25d4:	c7 01       	movw	r24, r14
    25d6:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25da:	7c 01       	movw	r14, r24
    25dc:	66 e0       	ldi	r22, 0x06	; 6
    25de:	75 e0       	ldi	r23, 0x05	; 5
    25e0:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    25e4:	63 e0       	ldi	r22, 0x03	; 3
    25e6:	c7 01       	movw	r24, r14
    25e8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25ec:	b2 01       	movw	r22, r4
    25ee:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
    25f2:	62 e0       	ldi	r22, 0x02	; 2
    25f4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25f8:	66 e0       	ldi	r22, 0x06	; 6
    25fa:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    25fe:	13 c0       	rjmp	.+38     	; 0x2626 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2600:	6a e0       	ldi	r22, 0x0A	; 10
    2602:	c3 01       	movw	r24, r6
    2604:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2608:	4c 01       	movw	r8, r24
    260a:	61 ef       	ldi	r22, 0xF1	; 241
    260c:	74 e0       	ldi	r23, 0x04	; 4
    260e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2612:	be 01       	movw	r22, r28
    2614:	6f 5f       	subi	r22, 0xFF	; 255
    2616:	7f 4f       	sbci	r23, 0xFF	; 255
    2618:	c4 01       	movw	r24, r8
    261a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    261e:	66 e0       	ldi	r22, 0x06	; 6
    2620:	c4 01       	movw	r24, r8
    2622:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2626:	2a 96       	adiw	r28, 0x0a	; 10
    2628:	cd bf       	out	0x3d, r28	; 61
    262a:	de bf       	out	0x3e, r29	; 62
    262c:	df 91       	pop	r29
    262e:	cf 91       	pop	r28
    2630:	1f 91       	pop	r17
    2632:	0f 91       	pop	r16
    2634:	ff 90       	pop	r15
    2636:	ef 90       	pop	r14
    2638:	df 90       	pop	r13
    263a:	cf 90       	pop	r12
    263c:	bf 90       	pop	r11
    263e:	af 90       	pop	r10
    2640:	9f 90       	pop	r9
    2642:	8f 90       	pop	r8
    2644:	7f 90       	pop	r7
    2646:	6f 90       	pop	r6
    2648:	5f 90       	pop	r5
    264a:	4f 90       	pop	r4
    264c:	08 95       	ret

0000264e <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    264e:	cf 92       	push	r12
    2650:	df 92       	push	r13
    2652:	ef 92       	push	r14
    2654:	ff 92       	push	r15
    2656:	0f 93       	push	r16
    2658:	1f 93       	push	r17
    265a:	cf 93       	push	r28
    265c:	df 93       	push	r29
    265e:	ec 01       	movw	r28, r24
    2660:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2662:	8a 81       	ldd	r24, Y+2	; 0x02
    2664:	9b 81       	ldd	r25, Y+3	; 0x03
    2666:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <pcTaskGetTaskName>
    266a:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    266c:	6a e0       	ldi	r22, 0x0A	; 10
    266e:	c7 01       	movw	r24, r14
    2670:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2674:	8c 01       	movw	r16, r24
    2676:	60 e3       	ldi	r22, 0x30	; 48
    2678:	75 e0       	ldi	r23, 0x05	; 5
    267a:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    267e:	6a e0       	ldi	r22, 0x0A	; 10
    2680:	c8 01       	movw	r24, r16
    2682:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2686:	8c 01       	movw	r16, r24
    2688:	69 e2       	ldi	r22, 0x29	; 41
    268a:	75 e0       	ldi	r23, 0x05	; 5
    268c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2690:	b6 01       	movw	r22, r12
    2692:	c8 01       	movw	r24, r16
    2694:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2698:	6a e0       	ldi	r22, 0x0A	; 10
    269a:	c8 01       	movw	r24, r16
    269c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    26a0:	8c 01       	movw	r16, r24
    26a2:	63 e2       	ldi	r22, 0x23	; 35
    26a4:	75 e0       	ldi	r23, 0x05	; 5
    26a6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    26aa:	66 e0       	ldi	r22, 0x06	; 6
    26ac:	c8 01       	movw	r24, r16
    26ae:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    26b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    26b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    26b6:	e8 85       	ldd	r30, Y+8	; 0x08
    26b8:	f9 85       	ldd	r31, Y+9	; 0x09
    26ba:	01 e1       	ldi	r16, 0x11	; 17
    26bc:	21 e0       	ldi	r18, 0x01	; 1
    26be:	a7 01       	movw	r20, r14
    26c0:	bc 01       	movw	r22, r24
    26c2:	8e 1b       	sub	r24, r30
    26c4:	9f 0b       	sbc	r25, r31
    26c6:	0e 94 29 16 	call	0x2c52	; 0x2c52 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    26ca:	8c 81       	ldd	r24, Y+4	; 0x04
    26cc:	9d 81       	ldd	r25, Y+5	; 0x05
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	19 f0       	breq	.+6      	; 0x26d8 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    26d2:	b7 01       	movw	r22, r14
    26d4:	0e 94 27 13 	call	0x264e	; 0x264e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    26d8:	df 91       	pop	r29
    26da:	cf 91       	pop	r28
    26dc:	1f 91       	pop	r17
    26de:	0f 91       	pop	r16
    26e0:	ff 90       	pop	r15
    26e2:	ef 90       	pop	r14
    26e4:	df 90       	pop	r13
    26e6:	cf 90       	pop	r12
    26e8:	08 95       	ret

000026ea <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    26ea:	0f 93       	push	r16
    26ec:	1f 93       	push	r17
    26ee:	cf 93       	push	r28
    26f0:	df 93       	push	r29
    26f2:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    26f4:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <last_created_task_pointer>
    26f8:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    26fc:	00 97       	sbiw	r24, 0x00	; 0
    26fe:	19 f0       	breq	.+6      	; 0x2706 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2700:	be 01       	movw	r22, r28
    2702:	0e 94 27 13 	call	0x264e	; 0x264e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2706:	6a e0       	ldi	r22, 0x0A	; 10
    2708:	ce 01       	movw	r24, r28
    270a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    270e:	8c 01       	movw	r16, r24
    2710:	66 e4       	ldi	r22, 0x46	; 70
    2712:	75 e0       	ldi	r23, 0x05	; 5
    2714:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2718:	6a e0       	ldi	r22, 0x0A	; 10
    271a:	c8 01       	movw	r24, r16
    271c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2720:	8c 01       	movw	r16, r24
    2722:	6b e3       	ldi	r22, 0x3B	; 59
    2724:	75 e0       	ldi	r23, 0x05	; 5
    2726:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    272a:	6a e0       	ldi	r22, 0x0A	; 10
    272c:	c8 01       	movw	r24, r16
    272e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2732:	8c 01       	movw	r16, r24
    2734:	65 e3       	ldi	r22, 0x35	; 53
    2736:	75 e0       	ldi	r23, 0x05	; 5
    2738:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    273c:	66 e0       	ldi	r22, 0x06	; 6
    273e:	c8 01       	movw	r24, r16
    2740:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2744:	80 91 aa 31 	lds	r24, 0x31AA	; 0x8031aa <portStackTopForTask>
    2748:	90 91 ab 31 	lds	r25, 0x31AB	; 0x8031ab <portStackTopForTask+0x1>
    274c:	bc 01       	movw	r22, r24
    274e:	6f 5f       	subi	r22, 0xFF	; 255
    2750:	7f 4f       	sbci	r23, 0xFF	; 255
    2752:	01 e1       	ldi	r16, 0x11	; 17
    2754:	21 e0       	ldi	r18, 0x01	; 1
    2756:	ae 01       	movw	r20, r28
    2758:	83 56       	subi	r24, 0x63	; 99
    275a:	91 09       	sbc	r25, r1
    275c:	0e 94 29 16 	call	0x2c52	; 0x2c52 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2760:	df 91       	pop	r29
    2762:	cf 91       	pop	r28
    2764:	1f 91       	pop	r17
    2766:	0f 91       	pop	r16
    2768:	08 95       	ret

0000276a <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    276a:	8f 92       	push	r8
    276c:	9f 92       	push	r9
    276e:	af 92       	push	r10
    2770:	bf 92       	push	r11
    2772:	cf 92       	push	r12
    2774:	df 92       	push	r13
    2776:	ef 92       	push	r14
    2778:	ff 92       	push	r15
    277a:	0f 93       	push	r16
    277c:	1f 93       	push	r17
    277e:	cf 93       	push	r28
    2780:	df 93       	push	r29
    2782:	ec 01       	movw	r28, r24
    2784:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2786:	8a 81       	ldd	r24, Y+2	; 0x02
    2788:	9b 81       	ldd	r25, Y+3	; 0x03
    278a:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <pcTaskGetTaskName>
    278e:	bc 01       	movw	r22, r24
    2790:	c8 01       	movw	r24, r16
    2792:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2796:	d8 01       	movw	r26, r16
    2798:	ed 91       	ld	r30, X+
    279a:	fc 91       	ld	r31, X
    279c:	02 80       	ldd	r0, Z+2	; 0x02
    279e:	f3 81       	ldd	r31, Z+3	; 0x03
    27a0:	e0 2d       	mov	r30, r0
    27a2:	69 e0       	ldi	r22, 0x09	; 9
    27a4:	c8 01       	movw	r24, r16
    27a6:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    27a8:	8a 81       	ldd	r24, Y+2	; 0x02
    27aa:	9b 81       	ldd	r25, Y+3	; 0x03
    27ac:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <pcTaskGetTaskName>
    27b0:	fc 01       	movw	r30, r24
    27b2:	01 90       	ld	r0, Z+
    27b4:	00 20       	and	r0, r0
    27b6:	e9 f7       	brne	.-6      	; 0x27b2 <_ZN8frt_task12print_statusER8emstream+0x48>
    27b8:	31 97       	sbiw	r30, 0x01	; 1
    27ba:	e8 1b       	sub	r30, r24
    27bc:	f9 0b       	sbc	r31, r25
    27be:	38 97       	sbiw	r30, 0x08	; 8
    27c0:	48 f4       	brcc	.+18     	; 0x27d4 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    27c2:	d8 01       	movw	r26, r16
    27c4:	ed 91       	ld	r30, X+
    27c6:	fc 91       	ld	r31, X
    27c8:	02 80       	ldd	r0, Z+2	; 0x02
    27ca:	f3 81       	ldd	r31, Z+3	; 0x03
    27cc:	e0 2d       	mov	r30, r0
    27ce:	69 e0       	ldi	r22, 0x09	; 9
    27d0:	c8 01       	movw	r24, r16
    27d2:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    27d4:	ce 84       	ldd	r12, Y+14	; 0x0e
    27d6:	df 84       	ldd	r13, Y+15	; 0x0f
    27d8:	e8 88       	ldd	r14, Y+16	; 0x10
    27da:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    27dc:	a8 84       	ldd	r10, Y+8	; 0x08
    27de:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    27e0:	8a 81       	ldd	r24, Y+2	; 0x02
    27e2:	9b 81       	ldd	r25, Y+3	; 0x03
    27e4:	0e 94 a6 11 	call	0x234c	; 0x234c <uxTaskGetStackHighWaterMark>
    27e8:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    27ea:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    27ec:	8a 81       	ldd	r24, Y+2	; 0x02
    27ee:	9b 81       	ldd	r25, Y+3	; 0x03
    27f0:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <uxTaskPriorityGet>
    27f4:	68 2f       	mov	r22, r24
    27f6:	c8 01       	movw	r24, r16
    27f8:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    27fc:	6a e0       	ldi	r22, 0x0A	; 10
    27fe:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2802:	ec 01       	movw	r28, r24
    2804:	6b eb       	ldi	r22, 0xBB	; 187
    2806:	75 e0       	ldi	r23, 0x05	; 5
    2808:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
			<< get_state ()
    280c:	68 2d       	mov	r22, r8
    280e:	ce 01       	movw	r24, r28
    2810:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2814:	6a e0       	ldi	r22, 0x0A	; 10
    2816:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    281a:	ec 01       	movw	r28, r24
    281c:	69 eb       	ldi	r22, 0xB9	; 185
    281e:	75 e0       	ldi	r23, 0x05	; 5
    2820:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2824:	69 2d       	mov	r22, r9
    2826:	ce 01       	movw	r24, r28
    2828:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    282c:	6a e0       	ldi	r22, 0x0A	; 10
    282e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2832:	ec 01       	movw	r28, r24
    2834:	67 eb       	ldi	r22, 0xB7	; 183
    2836:	75 e0       	ldi	r23, 0x05	; 5
    2838:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    283c:	b5 01       	movw	r22, r10
    283e:	ce 01       	movw	r24, r28
    2840:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
    2844:	6a e0       	ldi	r22, 0x0A	; 10
    2846:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    284a:	ec 01       	movw	r28, r24
    284c:	65 eb       	ldi	r22, 0xB5	; 181
    284e:	75 e0       	ldi	r23, 0x05	; 5
    2850:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2854:	6a e0       	ldi	r22, 0x0A	; 10
    2856:	ce 01       	movw	r24, r28
    2858:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    285c:	ec 01       	movw	r28, r24
    285e:	63 eb       	ldi	r22, 0xB3	; 179
    2860:	75 e0       	ldi	r23, 0x05	; 5
    2862:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2866:	b7 01       	movw	r22, r14
    2868:	a6 01       	movw	r20, r12
    286a:	ce 01       	movw	r24, r28
    286c:	0e 94 40 18 	call	0x3080	; 0x3080 <_ZN8emstreamlsEm>
}
    2870:	df 91       	pop	r29
    2872:	cf 91       	pop	r28
    2874:	1f 91       	pop	r17
    2876:	0f 91       	pop	r16
    2878:	ff 90       	pop	r15
    287a:	ef 90       	pop	r14
    287c:	df 90       	pop	r13
    287e:	cf 90       	pop	r12
    2880:	bf 90       	pop	r11
    2882:	af 90       	pop	r10
    2884:	9f 90       	pop	r9
    2886:	8f 90       	pop	r8
    2888:	08 95       	ret

0000288a <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
    288e:	ec 01       	movw	r28, r24
    2890:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2892:	db 01       	movw	r26, r22
    2894:	ed 91       	ld	r30, X+
    2896:	fc 91       	ld	r31, X
    2898:	02 80       	ldd	r0, Z+2	; 0x02
    289a:	f3 81       	ldd	r31, Z+3	; 0x03
    289c:	e0 2d       	mov	r30, r0
    289e:	be 01       	movw	r22, r28
    28a0:	19 95       	eicall
	return (ser_dev);
}
    28a2:	ce 01       	movw	r24, r28
    28a4:	df 91       	pop	r29
    28a6:	cf 91       	pop	r28
    28a8:	08 95       	ret

000028aa <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    28aa:	0f 93       	push	r16
    28ac:	1f 93       	push	r17
    28ae:	cf 93       	push	r28
    28b0:	df 93       	push	r29
    28b2:	ec 01       	movw	r28, r24
    28b4:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    28b6:	bc 01       	movw	r22, r24
    28b8:	c8 01       	movw	r24, r16
    28ba:	0e 94 45 14 	call	0x288a	; 0x288a <_ZlsR8emstreamR8frt_task>
    28be:	66 e0       	ldi	r22, 0x06	; 6
    28c0:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    28c4:	8c 81       	ldd	r24, Y+4	; 0x04
    28c6:	9d 81       	ldd	r25, Y+5	; 0x05
    28c8:	00 97       	sbiw	r24, 0x00	; 0
    28ca:	19 f0       	breq	.+6      	; 0x28d2 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    28cc:	b8 01       	movw	r22, r16
    28ce:	0e 94 55 14 	call	0x28aa	; 0x28aa <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    28d2:	df 91       	pop	r29
    28d4:	cf 91       	pop	r28
    28d6:	1f 91       	pop	r17
    28d8:	0f 91       	pop	r16
    28da:	08 95       	ret

000028dc <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    28dc:	0f 93       	push	r16
    28de:	1f 93       	push	r17
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    28e6:	6a e0       	ldi	r22, 0x0A	; 10
    28e8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    28ec:	8c 01       	movw	r16, r24
    28ee:	68 ea       	ldi	r22, 0xA8	; 168
    28f0:	75 e0       	ldi	r23, 0x05	; 5
    28f2:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    28f6:	6a e0       	ldi	r22, 0x0A	; 10
    28f8:	c8 01       	movw	r24, r16
    28fa:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    28fe:	8c 01       	movw	r16, r24
    2900:	61 ea       	ldi	r22, 0xA1	; 161
    2902:	75 e0       	ldi	r23, 0x05	; 5
    2904:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2908:	66 e0       	ldi	r22, 0x06	; 6
    290a:	c8 01       	movw	r24, r16
    290c:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2910:	6a e0       	ldi	r22, 0x0A	; 10
    2912:	ce 01       	movw	r24, r28
    2914:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2918:	8c 01       	movw	r16, r24
    291a:	60 e9       	ldi	r22, 0x90	; 144
    291c:	75 e0       	ldi	r23, 0x05	; 5
    291e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2922:	6a e0       	ldi	r22, 0x0A	; 10
    2924:	c8 01       	movw	r24, r16
    2926:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    292a:	8c 01       	movw	r16, r24
    292c:	64 e8       	ldi	r22, 0x84	; 132
    292e:	75 e0       	ldi	r23, 0x05	; 5
    2930:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2934:	6a e0       	ldi	r22, 0x0A	; 10
    2936:	c8 01       	movw	r24, r16
    2938:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    293c:	8c 01       	movw	r16, r24
    293e:	6e e7       	ldi	r22, 0x7E	; 126
    2940:	75 e0       	ldi	r23, 0x05	; 5
    2942:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2946:	66 e0       	ldi	r22, 0x06	; 6
    2948:	c8 01       	movw	r24, r16
    294a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    294e:	6a e0       	ldi	r22, 0x0A	; 10
    2950:	ce 01       	movw	r24, r28
    2952:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2956:	8c 01       	movw	r16, r24
    2958:	6d e6       	ldi	r22, 0x6D	; 109
    295a:	75 e0       	ldi	r23, 0x05	; 5
    295c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2960:	6a e0       	ldi	r22, 0x0A	; 10
    2962:	c8 01       	movw	r24, r16
    2964:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2968:	8c 01       	movw	r16, r24
    296a:	61 e6       	ldi	r22, 0x61	; 97
    296c:	75 e0       	ldi	r23, 0x05	; 5
    296e:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2972:	6a e0       	ldi	r22, 0x0A	; 10
    2974:	c8 01       	movw	r24, r16
    2976:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    297a:	8c 01       	movw	r16, r24
    297c:	6b e5       	ldi	r22, 0x5B	; 91
    297e:	75 e0       	ldi	r23, 0x05	; 5
    2980:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2984:	66 e0       	ldi	r22, 0x06	; 6
    2986:	c8 01       	movw	r24, r16
    2988:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    298c:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <last_created_task_pointer>
    2990:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <last_created_task_pointer+0x1>
    2994:	00 97       	sbiw	r24, 0x00	; 0
    2996:	19 f0       	breq	.+6      	; 0x299e <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2998:	be 01       	movw	r22, r28
    299a:	0e 94 55 14 	call	0x28aa	; 0x28aa <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    299e:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <xTaskGetIdleTaskHandle>
    29a2:	0e 94 a6 11 	call	0x234c	; 0x234c <uxTaskGetStackHighWaterMark>
    29a6:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    29a8:	6a e0       	ldi	r22, 0x0A	; 10
    29aa:	ce 01       	movw	r24, r28
    29ac:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    29b0:	ec 01       	movw	r28, r24
    29b2:	60 e5       	ldi	r22, 0x50	; 80
    29b4:	75 e0       	ldi	r23, 0x05	; 5
    29b6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29ba:	61 2f       	mov	r22, r17
    29bc:	ce 01       	movw	r24, r28
    29be:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    29c2:	6a e0       	ldi	r22, 0x0A	; 10
    29c4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    29c8:	ec 01       	movw	r28, r24
    29ca:	6e e4       	ldi	r22, 0x4E	; 78
    29cc:	75 e0       	ldi	r23, 0x05	; 5
    29ce:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    29d2:	64 e6       	ldi	r22, 0x64	; 100
    29d4:	70 e0       	ldi	r23, 0x00	; 0
    29d6:	ce 01       	movw	r24, r28
    29d8:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
    29dc:	6a e0       	ldi	r22, 0x0A	; 10
    29de:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    29e2:	ec 01       	movw	r28, r24
    29e4:	6b e4       	ldi	r22, 0x4B	; 75
    29e6:	75 e0       	ldi	r23, 0x05	; 5
    29e8:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    29ec:	66 e0       	ldi	r22, 0x06	; 6
    29ee:	ce 01       	movw	r24, r28
    29f0:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
}
    29f4:	df 91       	pop	r29
    29f6:	cf 91       	pop	r28
    29f8:	1f 91       	pop	r17
    29fa:	0f 91       	pop	r16
    29fc:	08 95       	ret

000029fe <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    29fe:	0f 93       	push	r16
    2a00:	cf 93       	push	r28
    2a02:	df 93       	push	r29
    2a04:	1f 92       	push	r1
    2a06:	cd b7       	in	r28, 0x3d	; 61
    2a08:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2a0a:	00 e0       	ldi	r16, 0x00	; 0
    2a0c:	2f ef       	ldi	r18, 0xFF	; 255
    2a0e:	3f ef       	ldi	r19, 0xFF	; 255
    2a10:	a9 01       	movw	r20, r18
    2a12:	be 01       	movw	r22, r28
    2a14:	6f 5f       	subi	r22, 0xFF	; 255
    2a16:	7f 4f       	sbci	r23, 0xFF	; 255
    2a18:	fc 01       	movw	r30, r24
    2a1a:	80 85       	ldd	r24, Z+8	; 0x08
    2a1c:	91 85       	ldd	r25, Z+9	; 0x09
    2a1e:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
    2a22:	81 30       	cpi	r24, 0x01	; 1
    2a24:	19 f4       	brne	.+6      	; 0x2a2c <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2a26:	89 81       	ldd	r24, Y+1	; 0x01
    2a28:	90 e0       	ldi	r25, 0x00	; 0
    2a2a:	02 c0       	rjmp	.+4      	; 0x2a30 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2a2c:	8f ef       	ldi	r24, 0xFF	; 255
    2a2e:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2a30:	0f 90       	pop	r0
    2a32:	df 91       	pop	r29
    2a34:	cf 91       	pop	r28
    2a36:	0f 91       	pop	r16
    2a38:	08 95       	ret

00002a3a <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	80 85       	ldd	r24, Z+8	; 0x08
    2a3e:	91 85       	ldd	r25, Z+9	; 0x09
    2a40:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
    2a44:	91 e0       	ldi	r25, 0x01	; 1
    2a46:	81 11       	cpse	r24, r1
    2a48:	01 c0       	rjmp	.+2      	; 0x2a4c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2a4a:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2a4c:	89 2f       	mov	r24, r25
    2a4e:	08 95       	ret

00002a50 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2a50:	0f 93       	push	r16
    2a52:	cf 93       	push	r28
    2a54:	df 93       	push	r29
    2a56:	1f 92       	push	r1
    2a58:	cd b7       	in	r28, 0x3d	; 61
    2a5a:	de b7       	in	r29, 0x3e	; 62
    2a5c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2a5e:	fc 01       	movw	r30, r24
    2a60:	22 85       	ldd	r18, Z+10	; 0x0a
    2a62:	33 85       	ldd	r19, Z+11	; 0x0b
    2a64:	44 85       	ldd	r20, Z+12	; 0x0c
    2a66:	55 85       	ldd	r21, Z+13	; 0x0d
    2a68:	00 e0       	ldi	r16, 0x00	; 0
    2a6a:	be 01       	movw	r22, r28
    2a6c:	6f 5f       	subi	r22, 0xFF	; 255
    2a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a70:	80 85       	ldd	r24, Z+8	; 0x08
    2a72:	91 85       	ldd	r25, Z+9	; 0x09
    2a74:	0e 94 30 0b 	call	0x1660	; 0x1660 <xQueueGenericSend>
    2a78:	91 e0       	ldi	r25, 0x01	; 1
    2a7a:	81 11       	cpse	r24, r1
    2a7c:	01 c0       	rjmp	.+2      	; 0x2a80 <_ZN14frt_text_queue7putcharEc+0x30>
    2a7e:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2a80:	89 2f       	mov	r24, r25
    2a82:	0f 90       	pop	r0
    2a84:	df 91       	pop	r29
    2a86:	cf 91       	pop	r28
    2a88:	0f 91       	pop	r16
    2a8a:	08 95       	ret

00002a8c <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2a8c:	8f 92       	push	r8
    2a8e:	9f 92       	push	r9
    2a90:	bf 92       	push	r11
    2a92:	cf 92       	push	r12
    2a94:	df 92       	push	r13
    2a96:	ef 92       	push	r14
    2a98:	ff 92       	push	r15
    2a9a:	0f 93       	push	r16
    2a9c:	1f 93       	push	r17
    2a9e:	cf 93       	push	r28
    2aa0:	df 93       	push	r29
    2aa2:	ec 01       	movw	r28, r24
    2aa4:	b6 2e       	mov	r11, r22
    2aa6:	4a 01       	movw	r8, r20
    2aa8:	68 01       	movw	r12, r16
    2aaa:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2aac:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_ZN8emstreamC1Ev>
    2ab0:	83 e4       	ldi	r24, 0x43	; 67
    2ab2:	90 e2       	ldi	r25, 0x20	; 32
    2ab4:	88 83       	st	Y, r24
    2ab6:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ab8:	8e 86       	std	Y+14, r8	; 0x0e
    2aba:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2abc:	40 e0       	ldi	r20, 0x00	; 0
    2abe:	61 e0       	ldi	r22, 0x01	; 1
    2ac0:	8b 2d       	mov	r24, r11
    2ac2:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    2ac6:	88 87       	std	Y+8, r24	; 0x08
    2ac8:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2aca:	ca 86       	std	Y+10, r12	; 0x0a
    2acc:	db 86       	std	Y+11, r13	; 0x0b
    2ace:	ec 86       	std	Y+12, r14	; 0x0c
    2ad0:	fd 86       	std	Y+13, r15	; 0x0d
}
    2ad2:	df 91       	pop	r29
    2ad4:	cf 91       	pop	r28
    2ad6:	1f 91       	pop	r17
    2ad8:	0f 91       	pop	r16
    2ada:	ff 90       	pop	r15
    2adc:	ef 90       	pop	r14
    2ade:	df 90       	pop	r13
    2ae0:	cf 90       	pop	r12
    2ae2:	bf 90       	pop	r11
    2ae4:	9f 90       	pop	r9
    2ae6:	8f 90       	pop	r8
    2ae8:	08 95       	ret

00002aea <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2aea:	cf 92       	push	r12
    2aec:	df 92       	push	r13
    2aee:	ef 92       	push	r14
    2af0:	ff 92       	push	r15
    2af2:	cf 93       	push	r28
    2af4:	df 93       	push	r29
    2af6:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2af8:	68 81       	ld	r22, Y
    2afa:	79 81       	ldd	r23, Y+1	; 0x01
    2afc:	8a 81       	ldd	r24, Y+2	; 0x02
    2afe:	9b 81       	ldd	r25, Y+3	; 0x03
    2b00:	0f 2e       	mov	r0, r31
    2b02:	f8 ee       	ldi	r31, 0xE8	; 232
    2b04:	cf 2e       	mov	r12, r31
    2b06:	f3 e0       	ldi	r31, 0x03	; 3
    2b08:	df 2e       	mov	r13, r31
    2b0a:	e1 2c       	mov	r14, r1
    2b0c:	f1 2c       	mov	r15, r1
    2b0e:	f0 2d       	mov	r31, r0
    2b10:	a7 01       	movw	r20, r14
    2b12:	96 01       	movw	r18, r12
    2b14:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
    2b18:	9b 01       	movw	r18, r22
    2b1a:	ac 01       	movw	r20, r24
    2b1c:	60 e4       	ldi	r22, 0x40	; 64
    2b1e:	72 e4       	ldi	r23, 0x42	; 66
    2b20:	8f e0       	ldi	r24, 0x0F	; 15
    2b22:	90 e0       	ldi	r25, 0x00	; 0
    2b24:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <__mulsi3>
    2b28:	a7 01       	movw	r20, r14
    2b2a:	96 01       	movw	r18, r12
    2b2c:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
    2b30:	69 01       	movw	r12, r18
    2b32:	7a 01       	movw	r14, r20
    2b34:	ac 81       	ldd	r26, Y+4	; 0x04
    2b36:	bd 81       	ldd	r27, Y+5	; 0x05
    2b38:	20 e4       	ldi	r18, 0x40	; 64
    2b3a:	32 e4       	ldi	r19, 0x42	; 66
    2b3c:	4f e0       	ldi	r20, 0x0F	; 15
    2b3e:	50 e0       	ldi	r21, 0x00	; 0
    2b40:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__muluhisi3>
    2b44:	20 e0       	ldi	r18, 0x00	; 0
    2b46:	38 e4       	ldi	r19, 0x48	; 72
    2b48:	48 ee       	ldi	r20, 0xE8	; 232
    2b4a:	51 e0       	ldi	r21, 0x01	; 1
    2b4c:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
    2b50:	c7 01       	movw	r24, r14
    2b52:	b6 01       	movw	r22, r12
    2b54:	62 0f       	add	r22, r18
    2b56:	73 1f       	adc	r23, r19
    2b58:	84 1f       	adc	r24, r20
    2b5a:	95 1f       	adc	r25, r21
}
    2b5c:	df 91       	pop	r29
    2b5e:	cf 91       	pop	r28
    2b60:	ff 90       	pop	r15
    2b62:	ef 90       	pop	r14
    2b64:	df 90       	pop	r13
    2b66:	cf 90       	pop	r12
    2b68:	08 95       	ret

00002b6a <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2b6a:	cf 92       	push	r12
    2b6c:	df 92       	push	r13
    2b6e:	ef 92       	push	r14
    2b70:	ff 92       	push	r15
    2b72:	0f 93       	push	r16
    2b74:	1f 93       	push	r17
    2b76:	cf 93       	push	r28
    2b78:	df 93       	push	r29
    2b7a:	cd b7       	in	r28, 0x3d	; 61
    2b7c:	de b7       	in	r29, 0x3e	; 62
    2b7e:	2f 97       	sbiw	r28, 0x0f	; 15
    2b80:	cd bf       	out	0x3d, r28	; 61
    2b82:	de bf       	out	0x3e, r29	; 62
    2b84:	6c 01       	movw	r12, r24
    2b86:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2b88:	db 01       	movw	r26, r22
    2b8a:	6d 91       	ld	r22, X+
    2b8c:	7d 91       	ld	r23, X+
    2b8e:	8d 91       	ld	r24, X+
    2b90:	9c 91       	ld	r25, X
    2b92:	28 ee       	ldi	r18, 0xE8	; 232
    2b94:	33 e0       	ldi	r19, 0x03	; 3
    2b96:	40 e0       	ldi	r20, 0x00	; 0
    2b98:	50 e0       	ldi	r21, 0x00	; 0
    2b9a:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
    2b9e:	ba 01       	movw	r22, r20
    2ba0:	a9 01       	movw	r20, r18
    2ba2:	c6 01       	movw	r24, r12
    2ba4:	0e 94 40 18 	call	0x3080	; 0x3080 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2ba8:	d6 01       	movw	r26, r12
    2baa:	ed 91       	ld	r30, X+
    2bac:	fc 91       	ld	r31, X
    2bae:	02 80       	ldd	r0, Z+2	; 0x02
    2bb0:	f3 81       	ldd	r31, Z+3	; 0x03
    2bb2:	e0 2d       	mov	r30, r0
    2bb4:	6e e2       	ldi	r22, 0x2E	; 46
    2bb6:	c6 01       	movw	r24, r12
    2bb8:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2bba:	c8 01       	movw	r24, r16
    2bbc:	0e 94 75 15 	call	0x2aea	; 0x2aea <_ZN10time_stamp12get_microsecEv>
    2bc0:	8e 01       	movw	r16, r28
    2bc2:	09 5f       	subi	r16, 0xF9	; 249
    2bc4:	1f 4f       	sbci	r17, 0xFF	; 255
    2bc6:	fe 01       	movw	r30, r28
    2bc8:	31 96       	adiw	r30, 0x01	; 1
    2bca:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2bcc:	2a e0       	ldi	r18, 0x0A	; 10
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	40 e0       	ldi	r20, 0x00	; 0
    2bd2:	50 e0       	ldi	r21, 0x00	; 0
    2bd4:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <__divmodsi4>
    2bd8:	e6 2f       	mov	r30, r22
    2bda:	28 87       	std	Y+8, r18	; 0x08
    2bdc:	39 87       	std	Y+9, r19	; 0x09
    2bde:	4a 87       	std	Y+10, r20	; 0x0a
    2be0:	5b 87       	std	Y+11, r21	; 0x0b
    2be2:	68 85       	ldd	r22, Y+8	; 0x08
    2be4:	79 85       	ldd	r23, Y+9	; 0x09
    2be6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2be8:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2bea:	20 e3       	ldi	r18, 0x30	; 48
    2bec:	2e 0f       	add	r18, r30
    2bee:	d8 01       	movw	r26, r16
    2bf0:	2e 93       	st	-X, r18
    2bf2:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2bf4:	ae 15       	cp	r26, r14
    2bf6:	bf 05       	cpc	r27, r15
    2bf8:	49 f7       	brne	.-46     	; 0x2bcc <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2bfa:	1f 82       	std	Y+7, r1	; 0x07
    2bfc:	be 01       	movw	r22, r28
    2bfe:	6f 5f       	subi	r22, 0xFF	; 255
    2c00:	7f 4f       	sbci	r23, 0xFF	; 255
    2c02:	c6 01       	movw	r24, r12
    2c04:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2c08:	c6 01       	movw	r24, r12
    2c0a:	2f 96       	adiw	r28, 0x0f	; 15
    2c0c:	cd bf       	out	0x3d, r28	; 61
    2c0e:	de bf       	out	0x3e, r29	; 62
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	1f 91       	pop	r17
    2c16:	0f 91       	pop	r16
    2c18:	ff 90       	pop	r15
    2c1a:	ef 90       	pop	r14
    2c1c:	df 90       	pop	r13
    2c1e:	cf 90       	pop	r12
    2c20:	08 95       	ret

00002c22 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2c22:	cf 93       	push	r28
    2c24:	df 93       	push	r29
    2c26:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2c28:	0f b6       	in	r0, 0x3f	; 63
    2c2a:	f8 94       	cli
    2c2c:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2c2e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c32:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c36:	8c 83       	std	Y+4, r24	; 0x04
    2c38:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2c3a:	0e 94 92 0e 	call	0x1d24	; 0x1d24 <xTaskGetTickCount>
    2c3e:	68 83       	st	Y, r22
    2c40:	79 83       	std	Y+1, r23	; 0x01
    2c42:	8a 83       	std	Y+2, r24	; 0x02
    2c44:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2c46:	0f 90       	pop	r0
    2c48:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2c4a:	ce 01       	movw	r24, r28
    2c4c:	df 91       	pop	r29
    2c4e:	cf 91       	pop	r28
    2c50:	08 95       	ret

00002c52 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2c52:	5f 92       	push	r5
    2c54:	6f 92       	push	r6
    2c56:	7f 92       	push	r7
    2c58:	8f 92       	push	r8
    2c5a:	9f 92       	push	r9
    2c5c:	af 92       	push	r10
    2c5e:	bf 92       	push	r11
    2c60:	cf 92       	push	r12
    2c62:	df 92       	push	r13
    2c64:	ef 92       	push	r14
    2c66:	ff 92       	push	r15
    2c68:	0f 93       	push	r16
    2c6a:	1f 93       	push	r17
    2c6c:	cf 93       	push	r28
    2c6e:	df 93       	push	r29
    2c70:	5c 01       	movw	r10, r24
    2c72:	4b 01       	movw	r8, r22
    2c74:	7a 01       	movw	r14, r20
    2c76:	12 2f       	mov	r17, r18
    2c78:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2c7a:	63 e0       	ldi	r22, 0x03	; 3
    2c7c:	ca 01       	movw	r24, r20
    2c7e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2c82:	a8 14       	cp	r10, r8
    2c84:	b9 04       	cpc	r11, r9
    2c86:	08 f0       	brcs	.+2      	; 0x2c8a <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2c88:	7d c0       	rjmp	.+250    	; 0x2d84 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2c8a:	65 01       	movw	r12, r10
    2c8c:	84 e1       	ldi	r24, 0x14	; 20
    2c8e:	c8 0e       	add	r12, r24
    2c90:	d1 1c       	adc	r13, r1
    2c92:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2c94:	6a 2c       	mov	r6, r10
    2c96:	5b 2c       	mov	r5, r11
    2c98:	b5 01       	movw	r22, r10
    2c9a:	c7 01       	movw	r24, r14
    2c9c:	0e 94 0c 18 	call	0x3018	; 0x3018 <_ZN8emstreamlsEj>
    2ca0:	6a e0       	ldi	r22, 0x0A	; 10
    2ca2:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2ca6:	6d ec       	ldi	r22, 0xCD	; 205
    2ca8:	75 e0       	ldi	r23, 0x05	; 5
    2caa:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2cae:	11 23       	and	r17, r17
    2cb0:	09 f4       	brne	.+2      	; 0x2cb4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2cb2:	6d c0       	rjmp	.+218    	; 0x2d8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2cb4:	00 23       	and	r16, r16
    2cb6:	09 f4       	brne	.+2      	; 0x2cba <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2cb8:	6a c0       	rjmp	.+212    	; 0x2d8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2cba:	6a e0       	ldi	r22, 0x0A	; 10
    2cbc:	c7 01       	movw	r24, r14
    2cbe:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2cc2:	68 ec       	ldi	r22, 0xC8	; 200
    2cc4:	75 e0       	ldi	r23, 0x05	; 5
    2cc6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    2cca:	61 c0       	rjmp	.+194    	; 0x2d8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2ccc:	11 23       	and	r17, r17
    2cce:	71 f0       	breq	.+28     	; 0x2cec <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2cd0:	01 11       	cpse	r16, r1
    2cd2:	0c c0       	rjmp	.+24     	; 0x2cec <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2cd4:	88 81       	ld	r24, Y
    2cd6:	87 15       	cp	r24, r7
    2cd8:	49 f0       	breq	.+18     	; 0x2cec <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2cda:	6a e0       	ldi	r22, 0x0A	; 10
    2cdc:	c7 01       	movw	r24, r14
    2cde:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2ce2:	63 ec       	ldi	r22, 0xC3	; 195
    2ce4:	75 e0       	ldi	r23, 0x05	; 5
    2ce6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2cea:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2cec:	69 91       	ld	r22, Y+
    2cee:	c7 01       	movw	r24, r14
    2cf0:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2cf4:	dc 01       	movw	r26, r24
    2cf6:	ed 91       	ld	r30, X+
    2cf8:	fc 91       	ld	r31, X
    2cfa:	02 80       	ldd	r0, Z+2	; 0x02
    2cfc:	f3 81       	ldd	r31, Z+3	; 0x03
    2cfe:	e0 2d       	mov	r30, r0
    2d00:	60 e2       	ldi	r22, 0x20	; 32
    2d02:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2d04:	cc 16       	cp	r12, r28
    2d06:	dd 06       	cpc	r13, r29
    2d08:	09 f7       	brne	.-62     	; 0x2ccc <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2d0a:	11 23       	and	r17, r17
    2d0c:	89 f0       	breq	.+34     	; 0x2d30 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2d0e:	6a e0       	ldi	r22, 0x0A	; 10
    2d10:	c7 01       	movw	r24, r14
    2d12:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2d16:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2d18:	6d eb       	ldi	r22, 0xBD	; 189
    2d1a:	75 e0       	ldi	r23, 0x05	; 5
    2d1c:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d20:	e8 81       	ld	r30, Y
    2d22:	f9 81       	ldd	r31, Y+1	; 0x01
    2d24:	02 80       	ldd	r0, Z+2	; 0x02
    2d26:	f3 81       	ldd	r31, Z+3	; 0x03
    2d28:	e0 2d       	mov	r30, r0
    2d2a:	60 e2       	ldi	r22, 0x20	; 32
    2d2c:	ce 01       	movw	r24, r28
    2d2e:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d30:	c6 2d       	mov	r28, r6
    2d32:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2d34:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2d36:	80 ee       	ldi	r24, 0xE0	; 224
    2d38:	86 0f       	add	r24, r22
    2d3a:	8f 35       	cpi	r24, 0x5F	; 95
    2d3c:	48 f4       	brcc	.+18     	; 0x2d50 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2d3e:	d7 01       	movw	r26, r14
    2d40:	ed 91       	ld	r30, X+
    2d42:	fc 91       	ld	r31, X
    2d44:	02 80       	ldd	r0, Z+2	; 0x02
    2d46:	f3 81       	ldd	r31, Z+3	; 0x03
    2d48:	e0 2d       	mov	r30, r0
    2d4a:	c7 01       	movw	r24, r14
    2d4c:	19 95       	eicall
    2d4e:	09 c0       	rjmp	.+18     	; 0x2d62 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2d50:	d7 01       	movw	r26, r14
    2d52:	ed 91       	ld	r30, X+
    2d54:	fc 91       	ld	r31, X
    2d56:	02 80       	ldd	r0, Z+2	; 0x02
    2d58:	f3 81       	ldd	r31, Z+3	; 0x03
    2d5a:	e0 2d       	mov	r30, r0
    2d5c:	6e e2       	ldi	r22, 0x2E	; 46
    2d5e:	c7 01       	movw	r24, r14
    2d60:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2d62:	cc 16       	cp	r12, r28
    2d64:	dd 06       	cpc	r13, r29
    2d66:	31 f7       	brne	.-52     	; 0x2d34 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2d68:	b4 e1       	ldi	r27, 0x14	; 20
    2d6a:	ab 0e       	add	r10, r27
    2d6c:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2d6e:	66 e0       	ldi	r22, 0x06	; 6
    2d70:	c7 01       	movw	r24, r14
    2d72:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    2d76:	84 e1       	ldi	r24, 0x14	; 20
    2d78:	c8 0e       	add	r12, r24
    2d7a:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d7c:	a8 14       	cp	r10, r8
    2d7e:	b9 04       	cpc	r11, r9
    2d80:	08 f4       	brcc	.+2      	; 0x2d84 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2d82:	88 cf       	rjmp	.-240    	; 0x2c94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2d84:	62 e0       	ldi	r22, 0x02	; 2
    2d86:	c7 01       	movw	r24, r14
    2d88:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
}
    2d8c:	03 c0       	rjmp	.+6      	; 0x2d94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d8e:	c6 2d       	mov	r28, r6
    2d90:	d5 2d       	mov	r29, r5
    2d92:	9c cf       	rjmp	.-200    	; 0x2ccc <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2d94:	df 91       	pop	r29
    2d96:	cf 91       	pop	r28
    2d98:	1f 91       	pop	r17
    2d9a:	0f 91       	pop	r16
    2d9c:	ff 90       	pop	r15
    2d9e:	ef 90       	pop	r14
    2da0:	df 90       	pop	r13
    2da2:	cf 90       	pop	r12
    2da4:	bf 90       	pop	r11
    2da6:	af 90       	pop	r10
    2da8:	9f 90       	pop	r9
    2daa:	8f 90       	pop	r8
    2dac:	7f 90       	pop	r7
    2dae:	6f 90       	pop	r6
    2db0:	5f 90       	pop	r5
    2db2:	08 95       	ret

00002db4 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2db4:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    2db8:	08 95       	ret

00002dba <_Znaj>:
    2dba:	0e 94 1c 07 	call	0xe38	; 0xe38 <pvPortMalloc>
    2dbe:	08 95       	ret

00002dc0 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2dc0:	08 95       	ret

00002dc2 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2dc2:	cf 93       	push	r28
    2dc4:	df 93       	push	r29
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2dca:	40 3a       	cpi	r20, 0xA0	; 160
    2dcc:	68 e0       	ldi	r22, 0x08	; 8
    2dce:	56 07       	cpc	r21, r22
    2dd0:	49 f4       	brne	.+18     	; 0x2de4 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2dd2:	80 e4       	ldi	r24, 0x40	; 64
    2dd4:	96 e0       	ldi	r25, 0x06	; 6
    2dd6:	82 83       	std	Z+2, r24	; 0x02
    2dd8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2dda:	82 e0       	ldi	r24, 0x02	; 2
    2ddc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2dde:	83 e0       	ldi	r24, 0x03	; 3
    2de0:	85 83       	std	Z+5, r24	; 0x05
    2de2:	32 c0       	rjmp	.+100    	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2de4:	40 3b       	cpi	r20, 0xB0	; 176
    2de6:	78 e0       	ldi	r23, 0x08	; 8
    2de8:	57 07       	cpc	r21, r23
    2dea:	49 f4       	brne	.+18     	; 0x2dfe <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2dec:	80 e4       	ldi	r24, 0x40	; 64
    2dee:	96 e0       	ldi	r25, 0x06	; 6
    2df0:	82 83       	std	Z+2, r24	; 0x02
    2df2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2df4:	86 e0       	ldi	r24, 0x06	; 6
    2df6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2df8:	87 e0       	ldi	r24, 0x07	; 7
    2dfa:	85 83       	std	Z+5, r24	; 0x05
    2dfc:	25 c0       	rjmp	.+74     	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2dfe:	40 3a       	cpi	r20, 0xA0	; 160
    2e00:	89 e0       	ldi	r24, 0x09	; 9
    2e02:	58 07       	cpc	r21, r24
    2e04:	49 f4       	brne	.+18     	; 0x2e18 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2e06:	80 e6       	ldi	r24, 0x60	; 96
    2e08:	96 e0       	ldi	r25, 0x06	; 6
    2e0a:	82 83       	std	Z+2, r24	; 0x02
    2e0c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e0e:	82 e0       	ldi	r24, 0x02	; 2
    2e10:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e12:	83 e0       	ldi	r24, 0x03	; 3
    2e14:	85 83       	std	Z+5, r24	; 0x05
    2e16:	18 c0       	rjmp	.+48     	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2e18:	40 3b       	cpi	r20, 0xB0	; 176
    2e1a:	69 e0       	ldi	r22, 0x09	; 9
    2e1c:	56 07       	cpc	r21, r22
    2e1e:	49 f4       	brne	.+18     	; 0x2e32 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2e20:	80 e6       	ldi	r24, 0x60	; 96
    2e22:	96 e0       	ldi	r25, 0x06	; 6
    2e24:	82 83       	std	Z+2, r24	; 0x02
    2e26:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e28:	86 e0       	ldi	r24, 0x06	; 6
    2e2a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e2c:	87 e0       	ldi	r24, 0x07	; 7
    2e2e:	85 83       	std	Z+5, r24	; 0x05
    2e30:	0b c0       	rjmp	.+22     	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2e32:	40 3a       	cpi	r20, 0xA0	; 160
    2e34:	5a 40       	sbci	r21, 0x0A	; 10
    2e36:	41 f4       	brne	.+16     	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    2e38:	80 e8       	ldi	r24, 0x80	; 128
    2e3a:	96 e0       	ldi	r25, 0x06	; 6
    2e3c:	82 83       	std	Z+2, r24	; 0x02
    2e3e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e40:	82 e0       	ldi	r24, 0x02	; 2
    2e42:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e44:	83 e0       	ldi	r24, 0x03	; 3
    2e46:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2e48:	a6 83       	std	Z+6, r26	; 0x06
    2e4a:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2e4c:	cd 01       	movw	r24, r26
    2e4e:	01 96       	adiw	r24, 0x01	; 1
    2e50:	80 87       	std	Z+8, r24	; 0x08
    2e52:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2e54:	03 96       	adiw	r24, 0x03	; 3
    2e56:	82 87       	std	Z+10, r24	; 0x0a
    2e58:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2e5a:	25 81       	ldd	r18, Z+5	; 0x05
    2e5c:	c2 81       	ldd	r28, Z+2	; 0x02
    2e5e:	d3 81       	ldd	r29, Z+3	; 0x03
    2e60:	4c 81       	ldd	r20, Y+4	; 0x04
    2e62:	81 e0       	ldi	r24, 0x01	; 1
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	bc 01       	movw	r22, r24
    2e68:	02 c0       	rjmp	.+4      	; 0x2e6e <_ZN7base232C1EjP12USART_struct+0xac>
    2e6a:	66 0f       	add	r22, r22
    2e6c:	77 1f       	adc	r23, r23
    2e6e:	2a 95       	dec	r18
    2e70:	e2 f7       	brpl	.-8      	; 0x2e6a <_ZN7base232C1EjP12USART_struct+0xa8>
    2e72:	9b 01       	movw	r18, r22
    2e74:	24 2b       	or	r18, r20
    2e76:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2e78:	25 81       	ldd	r18, Z+5	; 0x05
    2e7a:	c2 81       	ldd	r28, Z+2	; 0x02
    2e7c:	d3 81       	ldd	r29, Z+3	; 0x03
    2e7e:	48 81       	ld	r20, Y
    2e80:	bc 01       	movw	r22, r24
    2e82:	02 c0       	rjmp	.+4      	; 0x2e88 <_ZN7base232C1EjP12USART_struct+0xc6>
    2e84:	66 0f       	add	r22, r22
    2e86:	77 1f       	adc	r23, r23
    2e88:	2a 95       	dec	r18
    2e8a:	e2 f7       	brpl	.-8      	; 0x2e84 <_ZN7base232C1EjP12USART_struct+0xc2>
    2e8c:	9b 01       	movw	r18, r22
    2e8e:	24 2b       	or	r18, r20
    2e90:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2e92:	34 81       	ldd	r19, Z+4	; 0x04
    2e94:	c2 81       	ldd	r28, Z+2	; 0x02
    2e96:	d3 81       	ldd	r29, Z+3	; 0x03
    2e98:	28 81       	ld	r18, Y
    2e9a:	02 c0       	rjmp	.+4      	; 0x2ea0 <_ZN7base232C1EjP12USART_struct+0xde>
    2e9c:	88 0f       	add	r24, r24
    2e9e:	99 1f       	adc	r25, r25
    2ea0:	3a 95       	dec	r19
    2ea2:	e2 f7       	brpl	.-8      	; 0x2e9c <_ZN7base232C1EjP12USART_struct+0xda>
    2ea4:	80 95       	com	r24
    2ea6:	90 95       	com	r25
    2ea8:	82 23       	and	r24, r18
    2eaa:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2eac:	80 e1       	ldi	r24, 0x10	; 16
    2eae:	13 96       	adiw	r26, 0x03	; 3
    2eb0:	8c 93       	st	X, r24
    2eb2:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2eb4:	83 e0       	ldi	r24, 0x03	; 3
    2eb6:	15 96       	adiw	r26, 0x05	; 5
    2eb8:	8c 93       	st	X, r24
    2eba:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2ebc:	80 ef       	ldi	r24, 0xF0	; 240
    2ebe:	17 96       	adiw	r26, 0x07	; 7
    2ec0:	8c 93       	st	X, r24
    2ec2:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2ec4:	81 e2       	ldi	r24, 0x21	; 33
    2ec6:	16 96       	adiw	r26, 0x06	; 6
    2ec8:	8c 93       	st	X, r24
    2eca:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2ecc:	88 e1       	ldi	r24, 0x18	; 24
    2ece:	14 96       	adiw	r26, 0x04	; 4
    2ed0:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2ed2:	80 e8       	ldi	r24, 0x80	; 128
    2ed4:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2ed6:	80 e4       	ldi	r24, 0x40	; 64
    2ed8:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2eda:	80 e2       	ldi	r24, 0x20	; 32
    2edc:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2ede:	06 80       	ldd	r0, Z+6	; 0x06
    2ee0:	f7 81       	ldd	r31, Z+7	; 0x07
    2ee2:	e0 2d       	mov	r30, r0
    2ee4:	80 81       	ld	r24, Z
    2ee6:	80 81       	ld	r24, Z
}
    2ee8:	df 91       	pop	r29
    2eea:	cf 91       	pop	r28
    2eec:	08 95       	ret

00002eee <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2eee:	81 e0       	ldi	r24, 0x01	; 1
    2ef0:	08 95       	ret

00002ef2 <_ZN8emstream7getcharEv>:
    2ef2:	80 e0       	ldi	r24, 0x00	; 0
    2ef4:	90 e0       	ldi	r25, 0x00	; 0
    2ef6:	08 95       	ret

00002ef8 <_ZN8emstream14check_for_charEv>:
    2ef8:	80 e0       	ldi	r24, 0x00	; 0
    2efa:	08 95       	ret

00002efc <_ZN8emstream12transmit_nowEv>:
    2efc:	08 95       	ret

00002efe <_ZN8emstream12clear_screenEv>:
    2efe:	08 95       	ret

00002f00 <_ZN8emstreamC1Ev>:
    2f00:	fc 01       	movw	r30, r24
    2f02:	83 e5       	ldi	r24, 0x53	; 83
    2f04:	90 e2       	ldi	r25, 0x20	; 32
    2f06:	80 83       	st	Z, r24
    2f08:	91 83       	std	Z+1, r25	; 0x01
    2f0a:	8a e0       	ldi	r24, 0x0A	; 10
    2f0c:	82 83       	std	Z+2, r24	; 0x02
    2f0e:	13 82       	std	Z+3, r1	; 0x03
    2f10:	83 e0       	ldi	r24, 0x03	; 3
    2f12:	85 83       	std	Z+5, r24	; 0x05
    2f14:	14 82       	std	Z+4, r1	; 0x04
    2f16:	16 82       	std	Z+6, r1	; 0x06
    2f18:	17 82       	std	Z+7, r1	; 0x07
    2f1a:	08 95       	ret

00002f1c <_ZN8emstream4putsEPKc>:
    2f1c:	0f 93       	push	r16
    2f1e:	1f 93       	push	r17
    2f20:	cf 93       	push	r28
    2f22:	df 93       	push	r29
    2f24:	8c 01       	movw	r16, r24
    2f26:	fb 01       	movw	r30, r22
    2f28:	dc 01       	movw	r26, r24
    2f2a:	14 96       	adiw	r26, 0x04	; 4
    2f2c:	8c 91       	ld	r24, X
    2f2e:	81 11       	cpse	r24, r1
    2f30:	04 c0       	rjmp	.+8      	; 0x2f3a <_ZN8emstream4putsEPKc+0x1e>
    2f32:	60 81       	ld	r22, Z
    2f34:	61 11       	cpse	r22, r1
    2f36:	17 c0       	rjmp	.+46     	; 0x2f66 <_ZN8emstream4putsEPKc+0x4a>
    2f38:	23 c0       	rjmp	.+70     	; 0x2f80 <_ZN8emstream4putsEPKc+0x64>
    2f3a:	d8 01       	movw	r26, r16
    2f3c:	14 96       	adiw	r26, 0x04	; 4
    2f3e:	1c 92       	st	X, r1
    2f40:	eb 01       	movw	r28, r22
    2f42:	21 96       	adiw	r28, 0x01	; 1
    2f44:	64 91       	lpm	r22, Z
    2f46:	66 23       	and	r22, r22
    2f48:	d9 f0       	breq	.+54     	; 0x2f80 <_ZN8emstream4putsEPKc+0x64>
    2f4a:	d8 01       	movw	r26, r16
    2f4c:	ed 91       	ld	r30, X+
    2f4e:	fc 91       	ld	r31, X
    2f50:	02 80       	ldd	r0, Z+2	; 0x02
    2f52:	f3 81       	ldd	r31, Z+3	; 0x03
    2f54:	e0 2d       	mov	r30, r0
    2f56:	c8 01       	movw	r24, r16
    2f58:	19 95       	eicall
    2f5a:	fe 01       	movw	r30, r28
    2f5c:	64 91       	lpm	r22, Z
    2f5e:	21 96       	adiw	r28, 0x01	; 1
    2f60:	61 11       	cpse	r22, r1
    2f62:	f3 cf       	rjmp	.-26     	; 0x2f4a <_ZN8emstream4putsEPKc+0x2e>
    2f64:	0d c0       	rjmp	.+26     	; 0x2f80 <_ZN8emstream4putsEPKc+0x64>
    2f66:	ef 01       	movw	r28, r30
    2f68:	21 96       	adiw	r28, 0x01	; 1
    2f6a:	d8 01       	movw	r26, r16
    2f6c:	ed 91       	ld	r30, X+
    2f6e:	fc 91       	ld	r31, X
    2f70:	02 80       	ldd	r0, Z+2	; 0x02
    2f72:	f3 81       	ldd	r31, Z+3	; 0x03
    2f74:	e0 2d       	mov	r30, r0
    2f76:	c8 01       	movw	r24, r16
    2f78:	19 95       	eicall
    2f7a:	69 91       	ld	r22, Y+
    2f7c:	61 11       	cpse	r22, r1
    2f7e:	f5 cf       	rjmp	.-22     	; 0x2f6a <_ZN8emstream4putsEPKc+0x4e>
    2f80:	df 91       	pop	r29
    2f82:	cf 91       	pop	r28
    2f84:	1f 91       	pop	r17
    2f86:	0f 91       	pop	r16
    2f88:	08 95       	ret

00002f8a <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2f8a:	cf 93       	push	r28
    2f8c:	df 93       	push	r29
    2f8e:	ec 01       	movw	r28, r24
	switch (new_manip)
    2f90:	86 2f       	mov	r24, r22
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	8b 30       	cpi	r24, 0x0B	; 11
    2f96:	91 05       	cpc	r25, r1
    2f98:	d8 f5       	brcc	.+118    	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
    2f9a:	fc 01       	movw	r30, r24
    2f9c:	88 27       	eor	r24, r24
    2f9e:	e2 50       	subi	r30, 0x02	; 2
    2fa0:	ff 4f       	sbci	r31, 0xFF	; 255
    2fa2:	8f 4f       	sbci	r24, 0xFF	; 255
    2fa4:	0c 94 0f 1f 	jmp	0x3e1e	; 0x3e1e <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2fa8:	82 e0       	ldi	r24, 0x02	; 2
    2faa:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fac:	31 c0       	rjmp	.+98     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2fae:	88 e0       	ldi	r24, 0x08	; 8
    2fb0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fb2:	2e c0       	rjmp	.+92     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2fb4:	8a e0       	ldi	r24, 0x0A	; 10
    2fb6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fb8:	2b c0       	rjmp	.+86     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2fba:	80 e1       	ldi	r24, 0x10	; 16
    2fbc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2fbe:	28 c0       	rjmp	.+80     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2fc0:	81 e0       	ldi	r24, 0x01	; 1
    2fc2:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2fc4:	25 c0       	rjmp	.+74     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2fc6:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2fc8:	23 c0       	rjmp	.+70     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2fca:	e8 81       	ld	r30, Y
    2fcc:	f9 81       	ldd	r31, Y+1	; 0x01
    2fce:	02 80       	ldd	r0, Z+2	; 0x02
    2fd0:	f3 81       	ldd	r31, Z+3	; 0x03
    2fd2:	e0 2d       	mov	r30, r0
    2fd4:	6d e0       	ldi	r22, 0x0D	; 13
    2fd6:	ce 01       	movw	r24, r28
    2fd8:	19 95       	eicall
    2fda:	e8 81       	ld	r30, Y
    2fdc:	f9 81       	ldd	r31, Y+1	; 0x01
    2fde:	02 80       	ldd	r0, Z+2	; 0x02
    2fe0:	f3 81       	ldd	r31, Z+3	; 0x03
    2fe2:	e0 2d       	mov	r30, r0
    2fe4:	6a e0       	ldi	r22, 0x0A	; 10
    2fe6:	ce 01       	movw	r24, r28
    2fe8:	19 95       	eicall
			break;
    2fea:	12 c0       	rjmp	.+36     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2fec:	e8 81       	ld	r30, Y
    2fee:	f9 81       	ldd	r31, Y+1	; 0x01
    2ff0:	02 84       	ldd	r0, Z+10	; 0x0a
    2ff2:	f3 85       	ldd	r31, Z+11	; 0x0b
    2ff4:	e0 2d       	mov	r30, r0
    2ff6:	ce 01       	movw	r24, r28
    2ff8:	19 95       	eicall
			break;
    2ffa:	0a c0       	rjmp	.+20     	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2ffc:	e8 81       	ld	r30, Y
    2ffe:	f9 81       	ldd	r31, Y+1	; 0x01
    3000:	00 84       	ldd	r0, Z+8	; 0x08
    3002:	f1 85       	ldd	r31, Z+9	; 0x09
    3004:	e0 2d       	mov	r30, r0
    3006:	ce 01       	movw	r24, r28
    3008:	19 95       	eicall
			break;
    300a:	02 c0       	rjmp	.+4      	; 0x3010 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    300c:	81 e0       	ldi	r24, 0x01	; 1
    300e:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3010:	ce 01       	movw	r24, r28
    3012:	df 91       	pop	r29
    3014:	cf 91       	pop	r28
    3016:	08 95       	ret

00003018 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3018:	ff 92       	push	r15
    301a:	0f 93       	push	r16
    301c:	1f 93       	push	r17
    301e:	cf 93       	push	r28
    3020:	df 93       	push	r29
    3022:	cd b7       	in	r28, 0x3d	; 61
    3024:	de b7       	in	r29, 0x3e	; 62
    3026:	61 97       	sbiw	r28, 0x11	; 17
    3028:	cd bf       	out	0x3d, r28	; 61
    302a:	de bf       	out	0x3e, r29	; 62
    302c:	8c 01       	movw	r16, r24
    302e:	f6 2e       	mov	r15, r22
    3030:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3032:	f8 01       	movw	r30, r16
    3034:	42 81       	ldd	r20, Z+2	; 0x02
    3036:	40 31       	cpi	r20, 0x10	; 16
    3038:	21 f0       	breq	.+8      	; 0x3042 <_ZN8emstreamlsEj+0x2a>
    303a:	48 30       	cpi	r20, 0x08	; 8
    303c:	11 f0       	breq	.+4      	; 0x3042 <_ZN8emstreamlsEj+0x2a>
    303e:	42 30       	cpi	r20, 0x02	; 2
    3040:	41 f4       	brne	.+16     	; 0x3052 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3042:	69 2f       	mov	r22, r25
    3044:	c8 01       	movw	r24, r16
    3046:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    304a:	6f 2d       	mov	r22, r15
    304c:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    3050:	0d c0       	rjmp	.+26     	; 0x306c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3052:	50 e0       	ldi	r21, 0x00	; 0
    3054:	be 01       	movw	r22, r28
    3056:	6f 5f       	subi	r22, 0xFF	; 255
    3058:	7f 4f       	sbci	r23, 0xFF	; 255
    305a:	8f 2d       	mov	r24, r15
    305c:	0e 94 7e 1f 	call	0x3efc	; 0x3efc <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3060:	be 01       	movw	r22, r28
    3062:	6f 5f       	subi	r22, 0xFF	; 255
    3064:	7f 4f       	sbci	r23, 0xFF	; 255
    3066:	c8 01       	movw	r24, r16
    3068:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    306c:	c8 01       	movw	r24, r16
    306e:	61 96       	adiw	r28, 0x11	; 17
    3070:	cd bf       	out	0x3d, r28	; 61
    3072:	de bf       	out	0x3e, r29	; 62
    3074:	df 91       	pop	r29
    3076:	cf 91       	pop	r28
    3078:	1f 91       	pop	r17
    307a:	0f 91       	pop	r16
    307c:	ff 90       	pop	r15
    307e:	08 95       	ret

00003080 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3080:	df 92       	push	r13
    3082:	ef 92       	push	r14
    3084:	ff 92       	push	r15
    3086:	0f 93       	push	r16
    3088:	1f 93       	push	r17
    308a:	cf 93       	push	r28
    308c:	df 93       	push	r29
    308e:	cd b7       	in	r28, 0x3d	; 61
    3090:	de b7       	in	r29, 0x3e	; 62
    3092:	a1 97       	sbiw	r28, 0x21	; 33
    3094:	cd bf       	out	0x3d, r28	; 61
    3096:	de bf       	out	0x3e, r29	; 62
    3098:	8c 01       	movw	r16, r24
    309a:	d4 2e       	mov	r13, r20
    309c:	e5 2e       	mov	r14, r21
    309e:	f6 2e       	mov	r15, r22
    30a0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    30a2:	f8 01       	movw	r30, r16
    30a4:	22 81       	ldd	r18, Z+2	; 0x02
    30a6:	20 31       	cpi	r18, 0x10	; 16
    30a8:	21 f0       	breq	.+8      	; 0x30b2 <_ZN8emstreamlsEm+0x32>
    30aa:	28 30       	cpi	r18, 0x08	; 8
    30ac:	11 f0       	breq	.+4      	; 0x30b2 <_ZN8emstreamlsEm+0x32>
    30ae:	22 30       	cpi	r18, 0x02	; 2
    30b0:	71 f4       	brne	.+28     	; 0x30ce <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    30b2:	69 2f       	mov	r22, r25
    30b4:	c8 01       	movw	r24, r16
    30b6:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    30ba:	6f 2d       	mov	r22, r15
    30bc:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    30c0:	6e 2d       	mov	r22, r14
    30c2:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    30c6:	6d 2d       	mov	r22, r13
    30c8:	0e 94 82 18 	call	0x3104	; 0x3104 <_ZN8emstreamlsEh>
    30cc:	0f c0       	rjmp	.+30     	; 0x30ec <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    30ce:	30 e0       	ldi	r19, 0x00	; 0
    30d0:	ae 01       	movw	r20, r28
    30d2:	4f 5f       	subi	r20, 0xFF	; 255
    30d4:	5f 4f       	sbci	r21, 0xFF	; 255
    30d6:	6d 2d       	mov	r22, r13
    30d8:	7e 2d       	mov	r23, r14
    30da:	8f 2d       	mov	r24, r15
    30dc:	0e 94 51 1f 	call	0x3ea2	; 0x3ea2 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    30e0:	be 01       	movw	r22, r28
    30e2:	6f 5f       	subi	r22, 0xFF	; 255
    30e4:	7f 4f       	sbci	r23, 0xFF	; 255
    30e6:	c8 01       	movw	r24, r16
    30e8:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30ec:	c8 01       	movw	r24, r16
    30ee:	a1 96       	adiw	r28, 0x21	; 33
    30f0:	cd bf       	out	0x3d, r28	; 61
    30f2:	de bf       	out	0x3e, r29	; 62
    30f4:	df 91       	pop	r29
    30f6:	cf 91       	pop	r28
    30f8:	1f 91       	pop	r17
    30fa:	0f 91       	pop	r16
    30fc:	ff 90       	pop	r15
    30fe:	ef 90       	pop	r14
    3100:	df 90       	pop	r13
    3102:	08 95       	ret

00003104 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3104:	cf 92       	push	r12
    3106:	df 92       	push	r13
    3108:	ef 92       	push	r14
    310a:	ff 92       	push	r15
    310c:	0f 93       	push	r16
    310e:	1f 93       	push	r17
    3110:	cf 93       	push	r28
    3112:	df 93       	push	r29
    3114:	cd b7       	in	r28, 0x3d	; 61
    3116:	de b7       	in	r29, 0x3e	; 62
    3118:	29 97       	sbiw	r28, 0x09	; 9
    311a:	cd bf       	out	0x3d, r28	; 61
    311c:	de bf       	out	0x3e, r29	; 62
    311e:	8c 01       	movw	r16, r24
    3120:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3122:	dc 01       	movw	r26, r24
    3124:	13 96       	adiw	r26, 0x03	; 3
    3126:	8c 91       	ld	r24, X
    3128:	13 97       	sbiw	r26, 0x03	; 3
    312a:	88 23       	and	r24, r24
    312c:	41 f0       	breq	.+16     	; 0x313e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    312e:	ed 91       	ld	r30, X+
    3130:	fc 91       	ld	r31, X
    3132:	02 80       	ldd	r0, Z+2	; 0x02
    3134:	f3 81       	ldd	r31, Z+3	; 0x03
    3136:	e0 2d       	mov	r30, r0
    3138:	c8 01       	movw	r24, r16
    313a:	19 95       	eicall
    313c:	56 c0       	rjmp	.+172    	; 0x31ea <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    313e:	f8 01       	movw	r30, r16
    3140:	42 81       	ldd	r20, Z+2	; 0x02
    3142:	42 30       	cpi	r20, 0x02	; 2
    3144:	19 f5       	brne	.+70     	; 0x318c <_ZN8emstreamlsEh+0x88>
    3146:	68 94       	set
    3148:	cc 24       	eor	r12, r12
    314a:	c3 f8       	bld	r12, 3
    314c:	d1 2c       	mov	r13, r1
    314e:	68 94       	set
    3150:	ff 24       	eor	r15, r15
    3152:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3154:	8e 2d       	mov	r24, r14
    3156:	8f 21       	and	r24, r15
    3158:	51 f0       	breq	.+20     	; 0x316e <_ZN8emstreamlsEh+0x6a>
    315a:	d8 01       	movw	r26, r16
    315c:	ed 91       	ld	r30, X+
    315e:	fc 91       	ld	r31, X
    3160:	02 80       	ldd	r0, Z+2	; 0x02
    3162:	f3 81       	ldd	r31, Z+3	; 0x03
    3164:	e0 2d       	mov	r30, r0
    3166:	61 e3       	ldi	r22, 0x31	; 49
    3168:	c8 01       	movw	r24, r16
    316a:	19 95       	eicall
    316c:	09 c0       	rjmp	.+18     	; 0x3180 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    316e:	d8 01       	movw	r26, r16
    3170:	ed 91       	ld	r30, X+
    3172:	fc 91       	ld	r31, X
    3174:	02 80       	ldd	r0, Z+2	; 0x02
    3176:	f3 81       	ldd	r31, Z+3	; 0x03
    3178:	e0 2d       	mov	r30, r0
    317a:	60 e3       	ldi	r22, 0x30	; 48
    317c:	c8 01       	movw	r24, r16
    317e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3180:	f6 94       	lsr	r15
    3182:	b1 e0       	ldi	r27, 0x01	; 1
    3184:	cb 1a       	sub	r12, r27
    3186:	d1 08       	sbc	r13, r1
    3188:	29 f7       	brne	.-54     	; 0x3154 <_ZN8emstreamlsEh+0x50>
    318a:	2f c0       	rjmp	.+94     	; 0x31ea <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    318c:	40 31       	cpi	r20, 0x10	; 16
    318e:	f9 f4       	brne	.+62     	; 0x31ce <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3190:	62 95       	swap	r22
    3192:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3194:	01 90       	ld	r0, Z+
    3196:	f0 81       	ld	r31, Z
    3198:	e0 2d       	mov	r30, r0
    319a:	02 80       	ldd	r0, Z+2	; 0x02
    319c:	f3 81       	ldd	r31, Z+3	; 0x03
    319e:	e0 2d       	mov	r30, r0
    31a0:	6a 30       	cpi	r22, 0x0A	; 10
    31a2:	10 f0       	brcs	.+4      	; 0x31a8 <_ZN8emstreamlsEh+0xa4>
    31a4:	69 5c       	subi	r22, 0xC9	; 201
    31a6:	01 c0       	rjmp	.+2      	; 0x31aa <_ZN8emstreamlsEh+0xa6>
    31a8:	60 5d       	subi	r22, 0xD0	; 208
    31aa:	c8 01       	movw	r24, r16
    31ac:	19 95       	eicall
		temp_char = num & 0x0F;
    31ae:	6e 2d       	mov	r22, r14
    31b0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    31b2:	d8 01       	movw	r26, r16
    31b4:	ed 91       	ld	r30, X+
    31b6:	fc 91       	ld	r31, X
    31b8:	02 80       	ldd	r0, Z+2	; 0x02
    31ba:	f3 81       	ldd	r31, Z+3	; 0x03
    31bc:	e0 2d       	mov	r30, r0
    31be:	6a 30       	cpi	r22, 0x0A	; 10
    31c0:	10 f0       	brcs	.+4      	; 0x31c6 <_ZN8emstreamlsEh+0xc2>
    31c2:	69 5c       	subi	r22, 0xC9	; 201
    31c4:	01 c0       	rjmp	.+2      	; 0x31c8 <_ZN8emstreamlsEh+0xc4>
    31c6:	60 5d       	subi	r22, 0xD0	; 208
    31c8:	c8 01       	movw	r24, r16
    31ca:	19 95       	eicall
    31cc:	0e c0       	rjmp	.+28     	; 0x31ea <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    31ce:	50 e0       	ldi	r21, 0x00	; 0
    31d0:	be 01       	movw	r22, r28
    31d2:	6f 5f       	subi	r22, 0xFF	; 255
    31d4:	7f 4f       	sbci	r23, 0xFF	; 255
    31d6:	8e 2d       	mov	r24, r14
    31d8:	90 e0       	ldi	r25, 0x00	; 0
    31da:	0e 94 7e 1f 	call	0x3efc	; 0x3efc <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    31de:	be 01       	movw	r22, r28
    31e0:	6f 5f       	subi	r22, 0xFF	; 255
    31e2:	7f 4f       	sbci	r23, 0xFF	; 255
    31e4:	c8 01       	movw	r24, r16
    31e6:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    31ea:	c8 01       	movw	r24, r16
    31ec:	29 96       	adiw	r28, 0x09	; 9
    31ee:	cd bf       	out	0x3d, r28	; 61
    31f0:	de bf       	out	0x3e, r29	; 62
    31f2:	df 91       	pop	r29
    31f4:	cf 91       	pop	r28
    31f6:	1f 91       	pop	r17
    31f8:	0f 91       	pop	r16
    31fa:	ff 90       	pop	r15
    31fc:	ef 90       	pop	r14
    31fe:	df 90       	pop	r13
    3200:	cf 90       	pop	r12
    3202:	08 95       	ret

00003204 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3204:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3206:	50 96       	adiw	r26, 0x10	; 16
    3208:	ed 91       	ld	r30, X+
    320a:	fc 91       	ld	r31, X
    320c:	51 97       	sbiw	r26, 0x11	; 17
    320e:	80 81       	ld	r24, Z
    3210:	54 96       	adiw	r26, 0x14	; 20
    3212:	4c 91       	ld	r20, X
    3214:	54 97       	sbiw	r26, 0x14	; 20
    3216:	84 23       	and	r24, r20
    3218:	29 f0       	breq	.+10     	; 0x3224 <_ZN5rs2327putcharEc+0x20>
    321a:	09 c0       	rjmp	.+18     	; 0x322e <_ZN5rs2327putcharEc+0x2a>
    321c:	21 50       	subi	r18, 0x01	; 1
    321e:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3220:	19 f4       	brne	.+6      	; 0x3228 <_ZN5rs2327putcharEc+0x24>
    3222:	12 c0       	rjmp	.+36     	; 0x3248 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3224:	21 e2       	ldi	r18, 0x21	; 33
    3226:	3e e4       	ldi	r19, 0x4E	; 78
    3228:	90 81       	ld	r25, Z
    322a:	94 23       	and	r25, r20
    322c:	b9 f3       	breq	.-18     	; 0x321c <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    322e:	90 81       	ld	r25, Z
    3230:	56 96       	adiw	r26, 0x16	; 22
    3232:	8c 91       	ld	r24, X
    3234:	56 97       	sbiw	r26, 0x16	; 22
    3236:	89 2b       	or	r24, r25
    3238:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    323a:	1e 96       	adiw	r26, 0x0e	; 14
    323c:	ed 91       	ld	r30, X+
    323e:	fc 91       	ld	r31, X
    3240:	1f 97       	sbiw	r26, 0x0f	; 15
    3242:	60 83       	st	Z, r22
	return (true);
    3244:	81 e0       	ldi	r24, 0x01	; 1
    3246:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3248:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    324a:	08 95       	ret

0000324c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    324c:	cf 93       	push	r28
    324e:	df 93       	push	r29
    3250:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3252:	c1 8d       	ldd	r28, Z+25	; 0x19
    3254:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3256:	28 81       	ld	r18, Y
    3258:	39 81       	ldd	r19, Y+1	; 0x01
    325a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    325c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    325e:	4d 91       	ld	r20, X+
    3260:	5c 91       	ld	r21, X
    3262:	24 17       	cp	r18, r20
    3264:	35 07       	cpc	r19, r21
    3266:	e9 f3       	breq	.-6      	; 0x3262 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3268:	a7 89       	ldd	r26, Z+23	; 0x17
    326a:	b0 8d       	ldd	r27, Z+24	; 0x18
    326c:	0d 90       	ld	r0, X+
    326e:	bc 91       	ld	r27, X
    3270:	a0 2d       	mov	r26, r0
    3272:	a2 0f       	add	r26, r18
    3274:	b3 1f       	adc	r27, r19
    3276:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3278:	2f 5f       	subi	r18, 0xFF	; 255
    327a:	3f 4f       	sbci	r19, 0xFF	; 255
    327c:	28 83       	st	Y, r18
    327e:	39 83       	std	Y+1, r19	; 0x01
    3280:	24 36       	cpi	r18, 0x64	; 100
    3282:	31 05       	cpc	r19, r1
    3284:	28 f0       	brcs	.+10     	; 0x3290 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3286:	01 8c       	ldd	r0, Z+25	; 0x19
    3288:	f2 8d       	ldd	r31, Z+26	; 0x1a
    328a:	e0 2d       	mov	r30, r0
    328c:	10 82       	st	Z, r1
    328e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3290:	90 e0       	ldi	r25, 0x00	; 0
    3292:	df 91       	pop	r29
    3294:	cf 91       	pop	r28
    3296:	08 95       	ret

00003298 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3298:	cf 93       	push	r28
    329a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    329c:	ec 01       	movw	r28, r24
    329e:	a9 8d       	ldd	r26, Y+25	; 0x19
    32a0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    32a2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    32a4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    32a6:	81 e0       	ldi	r24, 0x01	; 1
    32a8:	4d 91       	ld	r20, X+
    32aa:	5c 91       	ld	r21, X
    32ac:	20 81       	ld	r18, Z
    32ae:	31 81       	ldd	r19, Z+1	; 0x01
    32b0:	42 17       	cp	r20, r18
    32b2:	53 07       	cpc	r21, r19
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <_ZN5rs23214check_for_charEv+0x20>
    32b6:	80 e0       	ldi	r24, 0x00	; 0
}
    32b8:	df 91       	pop	r29
    32ba:	cf 91       	pop	r28
    32bc:	08 95       	ret

000032be <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    32be:	dc 01       	movw	r26, r24
    32c0:	ed 91       	ld	r30, X+
    32c2:	fc 91       	ld	r31, X
    32c4:	02 80       	ldd	r0, Z+2	; 0x02
    32c6:	f3 81       	ldd	r31, Z+3	; 0x03
    32c8:	e0 2d       	mov	r30, r0
    32ca:	6c e0       	ldi	r22, 0x0C	; 12
    32cc:	19 95       	eicall
    32ce:	08 95       	ret

000032d0 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    32d0:	ef 92       	push	r14
    32d2:	ff 92       	push	r15
    32d4:	0f 93       	push	r16
    32d6:	1f 93       	push	r17
    32d8:	cf 93       	push	r28
    32da:	df 93       	push	r29
    32dc:	ec 01       	movw	r28, r24
    32de:	7b 01       	movw	r14, r22
    32e0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    32e2:	0e 94 80 17 	call	0x2f00	; 0x2f00 <_ZN8emstreamC1Ev>
    32e6:	a8 01       	movw	r20, r16
    32e8:	b7 01       	movw	r22, r14
    32ea:	ce 01       	movw	r24, r28
    32ec:	08 96       	adiw	r24, 0x08	; 8
    32ee:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <_ZN7base232C1EjP12USART_struct>
    32f2:	83 e6       	ldi	r24, 0x63	; 99
    32f4:	90 e2       	ldi	r25, 0x20	; 32
    32f6:	88 83       	st	Y, r24
    32f8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    32fa:	00 3a       	cpi	r16, 0xA0	; 160
    32fc:	88 e0       	ldi	r24, 0x08	; 8
    32fe:	18 07       	cpc	r17, r24
    3300:	69 f4       	brne	.+26     	; 0x331c <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3302:	86 e6       	ldi	r24, 0x66	; 102
    3304:	91 e3       	ldi	r25, 0x31	; 49
    3306:	8f 8b       	std	Y+23, r24	; 0x17
    3308:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    330a:	8c e5       	ldi	r24, 0x5C	; 92
    330c:	91 e3       	ldi	r25, 0x31	; 49
    330e:	89 8f       	std	Y+25, r24	; 0x19
    3310:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3312:	82 e5       	ldi	r24, 0x52	; 82
    3314:	91 e3       	ldi	r25, 0x31	; 49
    3316:	8b 8f       	std	Y+27, r24	; 0x1b
    3318:	9c 8f       	std	Y+28, r25	; 0x1c
    331a:	42 c0       	rjmp	.+132    	; 0x33a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    331c:	00 3b       	cpi	r16, 0xB0	; 176
    331e:	e8 e0       	ldi	r30, 0x08	; 8
    3320:	1e 07       	cpc	r17, r30
    3322:	69 f4       	brne	.+26     	; 0x333e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3324:	84 e6       	ldi	r24, 0x64	; 100
    3326:	91 e3       	ldi	r25, 0x31	; 49
    3328:	8f 8b       	std	Y+23, r24	; 0x17
    332a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    332c:	8a e5       	ldi	r24, 0x5A	; 90
    332e:	91 e3       	ldi	r25, 0x31	; 49
    3330:	89 8f       	std	Y+25, r24	; 0x19
    3332:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3334:	80 e5       	ldi	r24, 0x50	; 80
    3336:	91 e3       	ldi	r25, 0x31	; 49
    3338:	8b 8f       	std	Y+27, r24	; 0x1b
    333a:	9c 8f       	std	Y+28, r25	; 0x1c
    333c:	31 c0       	rjmp	.+98     	; 0x33a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    333e:	00 3a       	cpi	r16, 0xA0	; 160
    3340:	f9 e0       	ldi	r31, 0x09	; 9
    3342:	1f 07       	cpc	r17, r31
    3344:	69 f4       	brne	.+26     	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3346:	82 e6       	ldi	r24, 0x62	; 98
    3348:	91 e3       	ldi	r25, 0x31	; 49
    334a:	8f 8b       	std	Y+23, r24	; 0x17
    334c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    334e:	88 e5       	ldi	r24, 0x58	; 88
    3350:	91 e3       	ldi	r25, 0x31	; 49
    3352:	89 8f       	std	Y+25, r24	; 0x19
    3354:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3356:	8e e4       	ldi	r24, 0x4E	; 78
    3358:	91 e3       	ldi	r25, 0x31	; 49
    335a:	8b 8f       	std	Y+27, r24	; 0x1b
    335c:	9c 8f       	std	Y+28, r25	; 0x1c
    335e:	20 c0       	rjmp	.+64     	; 0x33a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3360:	00 3b       	cpi	r16, 0xB0	; 176
    3362:	89 e0       	ldi	r24, 0x09	; 9
    3364:	18 07       	cpc	r17, r24
    3366:	69 f4       	brne	.+26     	; 0x3382 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3368:	80 e6       	ldi	r24, 0x60	; 96
    336a:	91 e3       	ldi	r25, 0x31	; 49
    336c:	8f 8b       	std	Y+23, r24	; 0x17
    336e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3370:	86 e5       	ldi	r24, 0x56	; 86
    3372:	91 e3       	ldi	r25, 0x31	; 49
    3374:	89 8f       	std	Y+25, r24	; 0x19
    3376:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3378:	8c e4       	ldi	r24, 0x4C	; 76
    337a:	91 e3       	ldi	r25, 0x31	; 49
    337c:	8b 8f       	std	Y+27, r24	; 0x1b
    337e:	9c 8f       	std	Y+28, r25	; 0x1c
    3380:	0f c0       	rjmp	.+30     	; 0x33a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3382:	00 3a       	cpi	r16, 0xA0	; 160
    3384:	1a 40       	sbci	r17, 0x0A	; 10
    3386:	61 f4       	brne	.+24     	; 0x33a0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3388:	8e e5       	ldi	r24, 0x5E	; 94
    338a:	91 e3       	ldi	r25, 0x31	; 49
    338c:	8f 8b       	std	Y+23, r24	; 0x17
    338e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3390:	84 e5       	ldi	r24, 0x54	; 84
    3392:	91 e3       	ldi	r25, 0x31	; 49
    3394:	89 8f       	std	Y+25, r24	; 0x19
    3396:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3398:	8a e4       	ldi	r24, 0x4A	; 74
    339a:	91 e3       	ldi	r25, 0x31	; 49
    339c:	8b 8f       	std	Y+27, r24	; 0x1b
    339e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    33a0:	0f 89       	ldd	r16, Y+23	; 0x17
    33a2:	18 8d       	ldd	r17, Y+24	; 0x18
    33a4:	84 e6       	ldi	r24, 0x64	; 100
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	0e 94 dd 16 	call	0x2dba	; 0x2dba <_Znaj>
    33ac:	f8 01       	movw	r30, r16
    33ae:	80 83       	st	Z, r24
    33b0:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    33b2:	e9 8d       	ldd	r30, Y+25	; 0x19
    33b4:	fa 8d       	ldd	r31, Y+26	; 0x1a
    33b6:	10 82       	st	Z, r1
    33b8:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    33ba:	eb 8d       	ldd	r30, Y+27	; 0x1b
    33bc:	fc 8d       	ldd	r31, Y+28	; 0x1c
    33be:	10 82       	st	Z, r1
    33c0:	11 82       	std	Z+1, r1	; 0x01
}
    33c2:	df 91       	pop	r29
    33c4:	cf 91       	pop	r28
    33c6:	1f 91       	pop	r17
    33c8:	0f 91       	pop	r16
    33ca:	ff 90       	pop	r15
    33cc:	ef 90       	pop	r14
    33ce:	08 95       	ret

000033d0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    33d0:	1f 92       	push	r1
    33d2:	0f 92       	push	r0
    33d4:	0f b6       	in	r0, 0x3f	; 63
    33d6:	0f 92       	push	r0
    33d8:	11 24       	eor	r1, r1
    33da:	08 b6       	in	r0, 0x38	; 56
    33dc:	0f 92       	push	r0
    33de:	18 be       	out	0x38, r1	; 56
    33e0:	0b b6       	in	r0, 0x3b	; 59
    33e2:	0f 92       	push	r0
    33e4:	1b be       	out	0x3b, r1	; 59
    33e6:	2f 93       	push	r18
    33e8:	3f 93       	push	r19
    33ea:	8f 93       	push	r24
    33ec:	9f 93       	push	r25
    33ee:	ef 93       	push	r30
    33f0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    33f2:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    33f6:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvC0_buffer>
    33fa:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvC0_buffer+0x1>
    33fe:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    3402:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3406:	e8 0f       	add	r30, r24
    3408:	f9 1f       	adc	r31, r25
    340a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    340c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    3410:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    3414:	01 96       	adiw	r24, 0x01	; 1
    3416:	84 36       	cpi	r24, 0x64	; 100
    3418:	91 05       	cpc	r25, r1
    341a:	60 f4       	brcc	.+24     	; 0x3434 <__vector_25+0x64>
    341c:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvC0_write_index>
    3420:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3424:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvC0_read_index>
    3428:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvC0_read_index+0x1>
    342c:	82 17       	cp	r24, r18
    342e:	93 07       	cpc	r25, r19
    3430:	f1 f4       	brne	.+60     	; 0x346e <__vector_25+0x9e>
    3432:	0c c0       	rjmp	.+24     	; 0x344c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3434:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvC0_write_index>
    3438:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    343c:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC0_read_index>
    3440:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC0_read_index+0x1>
    3444:	18 16       	cp	r1, r24
    3446:	19 06       	cpc	r1, r25
    3448:	91 f4       	brne	.+36     	; 0x346e <__vector_25+0x9e>
    344a:	0e c0       	rjmp	.+28     	; 0x3468 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    344c:	01 96       	adiw	r24, 0x01	; 1
    344e:	84 36       	cpi	r24, 0x64	; 100
    3450:	91 05       	cpc	r25, r1
    3452:	28 f4       	brcc	.+10     	; 0x345e <__vector_25+0x8e>
    3454:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC0_read_index>
    3458:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC0_read_index+0x1>
    345c:	08 c0       	rjmp	.+16     	; 0x346e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    345e:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC0_read_index>
    3462:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC0_read_index+0x1>
}
    3466:	03 c0       	rjmp	.+6      	; 0x346e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3468:	81 e0       	ldi	r24, 0x01	; 1
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	f3 cf       	rjmp	.-26     	; 0x3454 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    346e:	ff 91       	pop	r31
    3470:	ef 91       	pop	r30
    3472:	9f 91       	pop	r25
    3474:	8f 91       	pop	r24
    3476:	3f 91       	pop	r19
    3478:	2f 91       	pop	r18
    347a:	0f 90       	pop	r0
    347c:	0b be       	out	0x3b, r0	; 59
    347e:	0f 90       	pop	r0
    3480:	08 be       	out	0x38, r0	; 56
    3482:	0f 90       	pop	r0
    3484:	0f be       	out	0x3f, r0	; 63
    3486:	0f 90       	pop	r0
    3488:	1f 90       	pop	r1
    348a:	18 95       	reti

0000348c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    348c:	1f 92       	push	r1
    348e:	0f 92       	push	r0
    3490:	0f b6       	in	r0, 0x3f	; 63
    3492:	0f 92       	push	r0
    3494:	11 24       	eor	r1, r1
    3496:	08 b6       	in	r0, 0x38	; 56
    3498:	0f 92       	push	r0
    349a:	18 be       	out	0x38, r1	; 56
    349c:	0b b6       	in	r0, 0x3b	; 59
    349e:	0f 92       	push	r0
    34a0:	1b be       	out	0x3b, r1	; 59
    34a2:	2f 93       	push	r18
    34a4:	3f 93       	push	r19
    34a6:	8f 93       	push	r24
    34a8:	9f 93       	push	r25
    34aa:	ef 93       	push	r30
    34ac:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    34ae:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    34b2:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvC1_buffer>
    34b6:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvC1_buffer+0x1>
    34ba:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    34be:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    34c2:	e8 0f       	add	r30, r24
    34c4:	f9 1f       	adc	r31, r25
    34c6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    34c8:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvC1_write_index>
    34cc:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvC1_write_index+0x1>
    34d0:	01 96       	adiw	r24, 0x01	; 1
    34d2:	84 36       	cpi	r24, 0x64	; 100
    34d4:	91 05       	cpc	r25, r1
    34d6:	60 f4       	brcc	.+24     	; 0x34f0 <__vector_28+0x64>
    34d8:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvC1_write_index>
    34dc:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34e0:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvC1_read_index>
    34e4:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvC1_read_index+0x1>
    34e8:	82 17       	cp	r24, r18
    34ea:	93 07       	cpc	r25, r19
    34ec:	f1 f4       	brne	.+60     	; 0x352a <__vector_28+0x9e>
    34ee:	0c c0       	rjmp	.+24     	; 0x3508 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    34f0:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvC1_write_index>
    34f4:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34f8:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvC1_read_index>
    34fc:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvC1_read_index+0x1>
    3500:	18 16       	cp	r1, r24
    3502:	19 06       	cpc	r1, r25
    3504:	91 f4       	brne	.+36     	; 0x352a <__vector_28+0x9e>
    3506:	0e c0       	rjmp	.+28     	; 0x3524 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3508:	01 96       	adiw	r24, 0x01	; 1
    350a:	84 36       	cpi	r24, 0x64	; 100
    350c:	91 05       	cpc	r25, r1
    350e:	28 f4       	brcc	.+10     	; 0x351a <__vector_28+0x8e>
    3510:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvC1_read_index>
    3514:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvC1_read_index+0x1>
    3518:	08 c0       	rjmp	.+16     	; 0x352a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    351a:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvC1_read_index>
    351e:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvC1_read_index+0x1>
}
    3522:	03 c0       	rjmp	.+6      	; 0x352a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3524:	81 e0       	ldi	r24, 0x01	; 1
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	f3 cf       	rjmp	.-26     	; 0x3510 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    352a:	ff 91       	pop	r31
    352c:	ef 91       	pop	r30
    352e:	9f 91       	pop	r25
    3530:	8f 91       	pop	r24
    3532:	3f 91       	pop	r19
    3534:	2f 91       	pop	r18
    3536:	0f 90       	pop	r0
    3538:	0b be       	out	0x3b, r0	; 59
    353a:	0f 90       	pop	r0
    353c:	08 be       	out	0x38, r0	; 56
    353e:	0f 90       	pop	r0
    3540:	0f be       	out	0x3f, r0	; 63
    3542:	0f 90       	pop	r0
    3544:	1f 90       	pop	r1
    3546:	18 95       	reti

00003548 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3548:	1f 92       	push	r1
    354a:	0f 92       	push	r0
    354c:	0f b6       	in	r0, 0x3f	; 63
    354e:	0f 92       	push	r0
    3550:	11 24       	eor	r1, r1
    3552:	08 b6       	in	r0, 0x38	; 56
    3554:	0f 92       	push	r0
    3556:	18 be       	out	0x38, r1	; 56
    3558:	0b b6       	in	r0, 0x3b	; 59
    355a:	0f 92       	push	r0
    355c:	1b be       	out	0x3b, r1	; 59
    355e:	2f 93       	push	r18
    3560:	3f 93       	push	r19
    3562:	8f 93       	push	r24
    3564:	9f 93       	push	r25
    3566:	ef 93       	push	r30
    3568:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    356a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    356e:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvD0_buffer>
    3572:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvD0_buffer+0x1>
    3576:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC0_write_index>
    357a:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC0_write_index+0x1>
    357e:	e8 0f       	add	r30, r24
    3580:	f9 1f       	adc	r31, r25
    3582:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3584:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD0_write_index>
    3588:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD0_write_index+0x1>
    358c:	01 96       	adiw	r24, 0x01	; 1
    358e:	84 36       	cpi	r24, 0x64	; 100
    3590:	91 05       	cpc	r25, r1
    3592:	60 f4       	brcc	.+24     	; 0x35ac <__vector_88+0x64>
    3594:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvD0_write_index>
    3598:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    359c:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvD0_read_index>
    35a0:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvD0_read_index+0x1>
    35a4:	82 17       	cp	r24, r18
    35a6:	93 07       	cpc	r25, r19
    35a8:	f1 f4       	brne	.+60     	; 0x35e6 <__vector_88+0x9e>
    35aa:	0c c0       	rjmp	.+24     	; 0x35c4 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    35ac:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvD0_write_index>
    35b0:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35b4:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD0_read_index>
    35b8:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD0_read_index+0x1>
    35bc:	18 16       	cp	r1, r24
    35be:	19 06       	cpc	r1, r25
    35c0:	91 f4       	brne	.+36     	; 0x35e6 <__vector_88+0x9e>
    35c2:	0e c0       	rjmp	.+28     	; 0x35e0 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35c4:	01 96       	adiw	r24, 0x01	; 1
    35c6:	84 36       	cpi	r24, 0x64	; 100
    35c8:	91 05       	cpc	r25, r1
    35ca:	28 f4       	brcc	.+10     	; 0x35d6 <__vector_88+0x8e>
    35cc:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD0_read_index>
    35d0:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD0_read_index+0x1>
    35d4:	08 c0       	rjmp	.+16     	; 0x35e6 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    35d6:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD0_read_index>
    35da:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD0_read_index+0x1>
}
    35de:	03 c0       	rjmp	.+6      	; 0x35e6 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35e0:	81 e0       	ldi	r24, 0x01	; 1
    35e2:	90 e0       	ldi	r25, 0x00	; 0
    35e4:	f3 cf       	rjmp	.-26     	; 0x35cc <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    35e6:	ff 91       	pop	r31
    35e8:	ef 91       	pop	r30
    35ea:	9f 91       	pop	r25
    35ec:	8f 91       	pop	r24
    35ee:	3f 91       	pop	r19
    35f0:	2f 91       	pop	r18
    35f2:	0f 90       	pop	r0
    35f4:	0b be       	out	0x3b, r0	; 59
    35f6:	0f 90       	pop	r0
    35f8:	08 be       	out	0x38, r0	; 56
    35fa:	0f 90       	pop	r0
    35fc:	0f be       	out	0x3f, r0	; 63
    35fe:	0f 90       	pop	r0
    3600:	1f 90       	pop	r1
    3602:	18 95       	reti

00003604 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3604:	1f 92       	push	r1
    3606:	0f 92       	push	r0
    3608:	0f b6       	in	r0, 0x3f	; 63
    360a:	0f 92       	push	r0
    360c:	11 24       	eor	r1, r1
    360e:	08 b6       	in	r0, 0x38	; 56
    3610:	0f 92       	push	r0
    3612:	18 be       	out	0x38, r1	; 56
    3614:	0b b6       	in	r0, 0x3b	; 59
    3616:	0f 92       	push	r0
    3618:	1b be       	out	0x3b, r1	; 59
    361a:	2f 93       	push	r18
    361c:	3f 93       	push	r19
    361e:	8f 93       	push	r24
    3620:	9f 93       	push	r25
    3622:	ef 93       	push	r30
    3624:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3626:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    362a:	e0 91 60 31 	lds	r30, 0x3160	; 0x803160 <rcvD1_buffer>
    362e:	f0 91 61 31 	lds	r31, 0x3161	; 0x803161 <rcvD1_buffer+0x1>
    3632:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3636:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    363a:	e8 0f       	add	r30, r24
    363c:	f9 1f       	adc	r31, r25
    363e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3640:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvD1_write_index>
    3644:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvD1_write_index+0x1>
    3648:	01 96       	adiw	r24, 0x01	; 1
    364a:	84 36       	cpi	r24, 0x64	; 100
    364c:	91 05       	cpc	r25, r1
    364e:	60 f4       	brcc	.+24     	; 0x3668 <__vector_91+0x64>
    3650:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvD1_write_index>
    3654:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3658:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvD1_read_index>
    365c:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvD1_read_index+0x1>
    3660:	82 17       	cp	r24, r18
    3662:	93 07       	cpc	r25, r19
    3664:	f1 f4       	brne	.+60     	; 0x36a2 <__vector_91+0x9e>
    3666:	0c c0       	rjmp	.+24     	; 0x3680 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3668:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvD1_write_index>
    366c:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3670:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvD1_read_index>
    3674:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvD1_read_index+0x1>
    3678:	18 16       	cp	r1, r24
    367a:	19 06       	cpc	r1, r25
    367c:	91 f4       	brne	.+36     	; 0x36a2 <__vector_91+0x9e>
    367e:	0e c0       	rjmp	.+28     	; 0x369c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3680:	01 96       	adiw	r24, 0x01	; 1
    3682:	84 36       	cpi	r24, 0x64	; 100
    3684:	91 05       	cpc	r25, r1
    3686:	28 f4       	brcc	.+10     	; 0x3692 <__vector_91+0x8e>
    3688:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvD1_read_index>
    368c:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvD1_read_index+0x1>
    3690:	08 c0       	rjmp	.+16     	; 0x36a2 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3692:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvD1_read_index>
    3696:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvD1_read_index+0x1>
}
    369a:	03 c0       	rjmp	.+6      	; 0x36a2 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	f3 cf       	rjmp	.-26     	; 0x3688 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    36a2:	ff 91       	pop	r31
    36a4:	ef 91       	pop	r30
    36a6:	9f 91       	pop	r25
    36a8:	8f 91       	pop	r24
    36aa:	3f 91       	pop	r19
    36ac:	2f 91       	pop	r18
    36ae:	0f 90       	pop	r0
    36b0:	0b be       	out	0x3b, r0	; 59
    36b2:	0f 90       	pop	r0
    36b4:	08 be       	out	0x38, r0	; 56
    36b6:	0f 90       	pop	r0
    36b8:	0f be       	out	0x3f, r0	; 63
    36ba:	0f 90       	pop	r0
    36bc:	1f 90       	pop	r1
    36be:	18 95       	reti

000036c0 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    36c0:	1f 92       	push	r1
    36c2:	0f 92       	push	r0
    36c4:	0f b6       	in	r0, 0x3f	; 63
    36c6:	0f 92       	push	r0
    36c8:	11 24       	eor	r1, r1
    36ca:	08 b6       	in	r0, 0x38	; 56
    36cc:	0f 92       	push	r0
    36ce:	18 be       	out	0x38, r1	; 56
    36d0:	0b b6       	in	r0, 0x3b	; 59
    36d2:	0f 92       	push	r0
    36d4:	1b be       	out	0x3b, r1	; 59
    36d6:	2f 93       	push	r18
    36d8:	3f 93       	push	r19
    36da:	8f 93       	push	r24
    36dc:	9f 93       	push	r25
    36de:	ef 93       	push	r30
    36e0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    36e2:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    36e6:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvE0_buffer>
    36ea:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvE0_buffer+0x1>
    36ee:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    36f2:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    36f6:	e8 0f       	add	r30, r24
    36f8:	f9 1f       	adc	r31, r25
    36fa:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    36fc:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvE0_write_index>
    3700:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvE0_write_index+0x1>
    3704:	01 96       	adiw	r24, 0x01	; 1
    3706:	84 36       	cpi	r24, 0x64	; 100
    3708:	91 05       	cpc	r25, r1
    370a:	60 f4       	brcc	.+24     	; 0x3724 <__vector_58+0x64>
    370c:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvE0_write_index>
    3710:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3714:	20 91 54 31 	lds	r18, 0x3154	; 0x803154 <rcvE0_read_index>
    3718:	30 91 55 31 	lds	r19, 0x3155	; 0x803155 <rcvE0_read_index+0x1>
    371c:	82 17       	cp	r24, r18
    371e:	93 07       	cpc	r25, r19
    3720:	f1 f4       	brne	.+60     	; 0x375e <__vector_58+0x9e>
    3722:	0c c0       	rjmp	.+24     	; 0x373c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3724:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvE0_write_index>
    3728:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    372c:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvE0_read_index>
    3730:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvE0_read_index+0x1>
    3734:	18 16       	cp	r1, r24
    3736:	19 06       	cpc	r1, r25
    3738:	91 f4       	brne	.+36     	; 0x375e <__vector_58+0x9e>
    373a:	0e c0       	rjmp	.+28     	; 0x3758 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    373c:	01 96       	adiw	r24, 0x01	; 1
    373e:	84 36       	cpi	r24, 0x64	; 100
    3740:	91 05       	cpc	r25, r1
    3742:	28 f4       	brcc	.+10     	; 0x374e <__vector_58+0x8e>
    3744:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvE0_read_index>
    3748:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvE0_read_index+0x1>
    374c:	08 c0       	rjmp	.+16     	; 0x375e <__vector_58+0x9e>
	rcvE0_read_index = 0;
    374e:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvE0_read_index>
    3752:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvE0_read_index+0x1>
}
    3756:	03 c0       	rjmp	.+6      	; 0x375e <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3758:	81 e0       	ldi	r24, 0x01	; 1
    375a:	90 e0       	ldi	r25, 0x00	; 0
    375c:	f3 cf       	rjmp	.-26     	; 0x3744 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    375e:	ff 91       	pop	r31
    3760:	ef 91       	pop	r30
    3762:	9f 91       	pop	r25
    3764:	8f 91       	pop	r24
    3766:	3f 91       	pop	r19
    3768:	2f 91       	pop	r18
    376a:	0f 90       	pop	r0
    376c:	0b be       	out	0x3b, r0	; 59
    376e:	0f 90       	pop	r0
    3770:	08 be       	out	0x38, r0	; 56
    3772:	0f 90       	pop	r0
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	0f 90       	pop	r0
    3778:	1f 90       	pop	r1
    377a:	18 95       	reti

0000377c <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    377c:	fc 01       	movw	r30, r24
    377e:	84 81       	ldd	r24, Z+4	; 0x04
    3780:	95 81       	ldd	r25, Z+5	; 0x05
    3782:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
		}
    3786:	90 e0       	ldi	r25, 0x00	; 0
    3788:	08 95       	ret

0000378a <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    378a:	fc 01       	movw	r30, r24
    378c:	84 81       	ldd	r24, Z+4	; 0x04
    378e:	95 81       	ldd	r25, Z+5	; 0x05
    3790:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
    3794:	91 e0       	ldi	r25, 0x01	; 1
    3796:	81 11       	cpse	r24, r1
    3798:	01 c0       	rjmp	.+2      	; 0x379c <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    379a:	90 e0       	ldi	r25, 0x00	; 0
		}
    379c:	89 2f       	mov	r24, r25
    379e:	08 95       	ret

000037a0 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    37a0:	fc 01       	movw	r30, r24
    37a2:	84 81       	ldd	r24, Z+4	; 0x04
    37a4:	95 81       	ldd	r25, Z+5	; 0x05
    37a6:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
    37aa:	91 e0       	ldi	r25, 0x01	; 1
    37ac:	81 11       	cpse	r24, r1
    37ae:	90 e0       	ldi	r25, 0x00	; 0
		}
    37b0:	89 2f       	mov	r24, r25
    37b2:	08 95       	ret

000037b4 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    37b4:	fc 01       	movw	r30, r24
    37b6:	84 81       	ldd	r24, Z+4	; 0x04
    37b8:	95 81       	ldd	r25, Z+5	; 0x05
    37ba:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
		}
    37be:	90 e0       	ldi	r25, 0x00	; 0
    37c0:	08 95       	ret

000037c2 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    37c2:	fc 01       	movw	r30, r24
    37c4:	84 81       	ldd	r24, Z+4	; 0x04
    37c6:	95 81       	ldd	r25, Z+5	; 0x05
    37c8:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
    37cc:	91 e0       	ldi	r25, 0x01	; 1
    37ce:	81 11       	cpse	r24, r1
    37d0:	01 c0       	rjmp	.+2      	; 0x37d4 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    37d2:	90 e0       	ldi	r25, 0x00	; 0
		}
    37d4:	89 2f       	mov	r24, r25
    37d6:	08 95       	ret

000037d8 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    37d8:	fc 01       	movw	r30, r24
    37da:	84 81       	ldd	r24, Z+4	; 0x04
    37dc:	95 81       	ldd	r25, Z+5	; 0x05
    37de:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <uxQueueMessagesWaitingFromISR>
    37e2:	91 e0       	ldi	r25, 0x01	; 1
    37e4:	81 11       	cpse	r24, r1
    37e6:	90 e0       	ldi	r25, 0x00	; 0
		}
    37e8:	89 2f       	mov	r24, r25
    37ea:	08 95       	ret

000037ec <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    37ec:	fc 01       	movw	r30, r24
    37ee:	84 81       	ldd	r24, Z+4	; 0x04
    37f0:	95 81       	ldd	r25, Z+5	; 0x05
    37f2:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
		}
    37f6:	90 e0       	ldi	r25, 0x00	; 0
    37f8:	08 95       	ret

000037fa <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    37fa:	fc 01       	movw	r30, r24
    37fc:	84 81       	ldd	r24, Z+4	; 0x04
    37fe:	95 81       	ldd	r25, Z+5	; 0x05
    3800:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
    3804:	91 e0       	ldi	r25, 0x01	; 1
    3806:	81 11       	cpse	r24, r1
    3808:	01 c0       	rjmp	.+2      	; 0x380c <_ZN9frt_queueIjE9not_emptyEv+0x12>
    380a:	90 e0       	ldi	r25, 0x00	; 0
		}
    380c:	89 2f       	mov	r24, r25
    380e:	08 95       	ret

00003810 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3810:	fc 01       	movw	r30, r24
    3812:	84 81       	ldd	r24, Z+4	; 0x04
    3814:	95 81       	ldd	r25, Z+5	; 0x05
    3816:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
    381a:	91 e0       	ldi	r25, 0x01	; 1
    381c:	81 11       	cpse	r24, r1
    381e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3820:	89 2f       	mov	r24, r25
    3822:	08 95       	ret

00003824 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3824:	fc 01       	movw	r30, r24
    3826:	84 81       	ldd	r24, Z+4	; 0x04
    3828:	95 81       	ldd	r25, Z+5	; 0x05
    382a:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
		}
    382e:	90 e0       	ldi	r25, 0x00	; 0
    3830:	08 95       	ret

00003832 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3832:	fc 01       	movw	r30, r24
    3834:	84 81       	ldd	r24, Z+4	; 0x04
    3836:	95 81       	ldd	r25, Z+5	; 0x05
    3838:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
    383c:	91 e0       	ldi	r25, 0x01	; 1
    383e:	81 11       	cpse	r24, r1
    3840:	01 c0       	rjmp	.+2      	; 0x3844 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3842:	90 e0       	ldi	r25, 0x00	; 0
		}
    3844:	89 2f       	mov	r24, r25
    3846:	08 95       	ret

00003848 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3848:	fc 01       	movw	r30, r24
    384a:	84 81       	ldd	r24, Z+4	; 0x04
    384c:	95 81       	ldd	r25, Z+5	; 0x05
    384e:	0e 94 e8 0c 	call	0x19d0	; 0x19d0 <uxQueueMessagesWaiting>
    3852:	91 e0       	ldi	r25, 0x01	; 1
    3854:	81 11       	cpse	r24, r1
    3856:	90 e0       	ldi	r25, 0x00	; 0
		}
    3858:	89 2f       	mov	r24, r25
    385a:	08 95       	ret

0000385c <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    385c:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    385e:	01 e0       	ldi	r16, 0x01	; 1
    3860:	2f ef       	ldi	r18, 0xFF	; 255
    3862:	3f ef       	ldi	r19, 0xFF	; 255
    3864:	a9 01       	movw	r20, r18
    3866:	fc 01       	movw	r30, r24
    3868:	84 81       	ldd	r24, Z+4	; 0x04
    386a:	95 81       	ldd	r25, Z+5	; 0x05
    386c:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
}
    3870:	0f 91       	pop	r16
    3872:	08 95       	ret

00003874 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3874:	0f 93       	push	r16
    3876:	cf 93       	push	r28
    3878:	df 93       	push	r29
    387a:	1f 92       	push	r1
    387c:	1f 92       	push	r1
    387e:	cd b7       	in	r28, 0x3d	; 61
    3880:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3882:	01 e0       	ldi	r16, 0x01	; 1
    3884:	2f ef       	ldi	r18, 0xFF	; 255
    3886:	3f ef       	ldi	r19, 0xFF	; 255
    3888:	a9 01       	movw	r20, r18
    388a:	be 01       	movw	r22, r28
    388c:	6f 5f       	subi	r22, 0xFF	; 255
    388e:	7f 4f       	sbci	r23, 0xFF	; 255
    3890:	fc 01       	movw	r30, r24
    3892:	84 81       	ldd	r24, Z+4	; 0x04
    3894:	95 81       	ldd	r25, Z+5	; 0x05
    3896:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
	return (recv_item);
}
    389a:	89 81       	ldd	r24, Y+1	; 0x01
    389c:	9a 81       	ldd	r25, Y+2	; 0x02
    389e:	0f 90       	pop	r0
    38a0:	0f 90       	pop	r0
    38a2:	df 91       	pop	r29
    38a4:	cf 91       	pop	r28
    38a6:	0f 91       	pop	r16
    38a8:	08 95       	ret

000038aa <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    38aa:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    38ac:	00 e0       	ldi	r16, 0x00	; 0
    38ae:	2f ef       	ldi	r18, 0xFF	; 255
    38b0:	3f ef       	ldi	r19, 0xFF	; 255
    38b2:	a9 01       	movw	r20, r18
    38b4:	fc 01       	movw	r30, r24
    38b6:	84 81       	ldd	r24, Z+4	; 0x04
    38b8:	95 81       	ldd	r25, Z+5	; 0x05
    38ba:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
}
    38be:	0f 91       	pop	r16
    38c0:	08 95       	ret

000038c2 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    38c2:	0f 93       	push	r16
    38c4:	cf 93       	push	r28
    38c6:	df 93       	push	r29
    38c8:	1f 92       	push	r1
    38ca:	1f 92       	push	r1
    38cc:	cd b7       	in	r28, 0x3d	; 61
    38ce:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    38d0:	00 e0       	ldi	r16, 0x00	; 0
    38d2:	2f ef       	ldi	r18, 0xFF	; 255
    38d4:	3f ef       	ldi	r19, 0xFF	; 255
    38d6:	a9 01       	movw	r20, r18
    38d8:	be 01       	movw	r22, r28
    38da:	6f 5f       	subi	r22, 0xFF	; 255
    38dc:	7f 4f       	sbci	r23, 0xFF	; 255
    38de:	fc 01       	movw	r30, r24
    38e0:	84 81       	ldd	r24, Z+4	; 0x04
    38e2:	95 81       	ldd	r25, Z+5	; 0x05
    38e4:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
	return (recv_item);
}
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	9a 81       	ldd	r25, Y+2	; 0x02
    38ec:	0f 90       	pop	r0
    38ee:	0f 90       	pop	r0
    38f0:	df 91       	pop	r29
    38f2:	cf 91       	pop	r28
    38f4:	0f 91       	pop	r16
    38f6:	08 95       	ret

000038f8 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    38f8:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    38fa:	01 e0       	ldi	r16, 0x01	; 1
    38fc:	2f ef       	ldi	r18, 0xFF	; 255
    38fe:	3f ef       	ldi	r19, 0xFF	; 255
    3900:	a9 01       	movw	r20, r18
    3902:	fc 01       	movw	r30, r24
    3904:	84 81       	ldd	r24, Z+4	; 0x04
    3906:	95 81       	ldd	r25, Z+5	; 0x05
    3908:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
}
    390c:	0f 91       	pop	r16
    390e:	08 95       	ret

00003910 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3910:	0f 93       	push	r16
    3912:	cf 93       	push	r28
    3914:	df 93       	push	r29
    3916:	1f 92       	push	r1
    3918:	1f 92       	push	r1
    391a:	cd b7       	in	r28, 0x3d	; 61
    391c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    391e:	01 e0       	ldi	r16, 0x01	; 1
    3920:	2f ef       	ldi	r18, 0xFF	; 255
    3922:	3f ef       	ldi	r19, 0xFF	; 255
    3924:	a9 01       	movw	r20, r18
    3926:	be 01       	movw	r22, r28
    3928:	6f 5f       	subi	r22, 0xFF	; 255
    392a:	7f 4f       	sbci	r23, 0xFF	; 255
    392c:	fc 01       	movw	r30, r24
    392e:	84 81       	ldd	r24, Z+4	; 0x04
    3930:	95 81       	ldd	r25, Z+5	; 0x05
    3932:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
	return (recv_item);
}
    3936:	89 81       	ldd	r24, Y+1	; 0x01
    3938:	9a 81       	ldd	r25, Y+2	; 0x02
    393a:	0f 90       	pop	r0
    393c:	0f 90       	pop	r0
    393e:	df 91       	pop	r29
    3940:	cf 91       	pop	r28
    3942:	0f 91       	pop	r16
    3944:	08 95       	ret

00003946 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3946:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3948:	00 e0       	ldi	r16, 0x00	; 0
    394a:	2f ef       	ldi	r18, 0xFF	; 255
    394c:	3f ef       	ldi	r19, 0xFF	; 255
    394e:	a9 01       	movw	r20, r18
    3950:	fc 01       	movw	r30, r24
    3952:	84 81       	ldd	r24, Z+4	; 0x04
    3954:	95 81       	ldd	r25, Z+5	; 0x05
    3956:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
}
    395a:	0f 91       	pop	r16
    395c:	08 95       	ret

0000395e <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    395e:	0f 93       	push	r16
    3960:	cf 93       	push	r28
    3962:	df 93       	push	r29
    3964:	1f 92       	push	r1
    3966:	1f 92       	push	r1
    3968:	cd b7       	in	r28, 0x3d	; 61
    396a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    396c:	00 e0       	ldi	r16, 0x00	; 0
    396e:	2f ef       	ldi	r18, 0xFF	; 255
    3970:	3f ef       	ldi	r19, 0xFF	; 255
    3972:	a9 01       	movw	r20, r18
    3974:	be 01       	movw	r22, r28
    3976:	6f 5f       	subi	r22, 0xFF	; 255
    3978:	7f 4f       	sbci	r23, 0xFF	; 255
    397a:	fc 01       	movw	r30, r24
    397c:	84 81       	ldd	r24, Z+4	; 0x04
    397e:	95 81       	ldd	r25, Z+5	; 0x05
    3980:	0e 94 f7 0b 	call	0x17ee	; 0x17ee <xQueueGenericReceive>
	return (recv_item);
}
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
    3988:	0f 90       	pop	r0
    398a:	0f 90       	pop	r0
    398c:	df 91       	pop	r29
    398e:	cf 91       	pop	r28
    3990:	0f 91       	pop	r16
    3992:	08 95       	ret

00003994 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3994:	cf 93       	push	r28
    3996:	df 93       	push	r29
    3998:	1f 92       	push	r1
    399a:	cd b7       	in	r28, 0x3d	; 61
    399c:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    399e:	ae 01       	movw	r20, r28
    39a0:	4f 5f       	subi	r20, 0xFF	; 255
    39a2:	5f 4f       	sbci	r21, 0xFF	; 255
    39a4:	fc 01       	movw	r30, r24
    39a6:	84 81       	ldd	r24, Z+4	; 0x04
    39a8:	95 81       	ldd	r25, Z+5	; 0x05
    39aa:	0e 94 bb 0c 	call	0x1976	; 0x1976 <xQueueReceiveFromISR>
}
    39ae:	0f 90       	pop	r0
    39b0:	df 91       	pop	r29
    39b2:	cf 91       	pop	r28
    39b4:	08 95       	ret

000039b6 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    39b6:	cf 93       	push	r28
    39b8:	df 93       	push	r29
    39ba:	00 d0       	rcall	.+0      	; 0x39bc <_ZN9frt_queueIjE7ISR_getEv+0x6>
    39bc:	cd b7       	in	r28, 0x3d	; 61
    39be:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    39c0:	ae 01       	movw	r20, r28
    39c2:	4d 5f       	subi	r20, 0xFD	; 253
    39c4:	5f 4f       	sbci	r21, 0xFF	; 255
    39c6:	be 01       	movw	r22, r28
    39c8:	6f 5f       	subi	r22, 0xFF	; 255
    39ca:	7f 4f       	sbci	r23, 0xFF	; 255
    39cc:	fc 01       	movw	r30, r24
    39ce:	84 81       	ldd	r24, Z+4	; 0x04
    39d0:	95 81       	ldd	r25, Z+5	; 0x05
    39d2:	0e 94 bb 0c 	call	0x1976	; 0x1976 <xQueueReceiveFromISR>
	return (recv_item);
}
    39d6:	89 81       	ldd	r24, Y+1	; 0x01
    39d8:	9a 81       	ldd	r25, Y+2	; 0x02
    39da:	23 96       	adiw	r28, 0x03	; 3
    39dc:	cd bf       	out	0x3d, r28	; 61
    39de:	de bf       	out	0x3e, r29	; 62
    39e0:	df 91       	pop	r29
    39e2:	cf 91       	pop	r28
    39e4:	08 95       	ret

000039e6 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    39e6:	cf 93       	push	r28
    39e8:	df 93       	push	r29
    39ea:	1f 92       	push	r1
    39ec:	cd b7       	in	r28, 0x3d	; 61
    39ee:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    39f0:	ae 01       	movw	r20, r28
    39f2:	4f 5f       	subi	r20, 0xFF	; 255
    39f4:	5f 4f       	sbci	r21, 0xFF	; 255
    39f6:	fc 01       	movw	r30, r24
    39f8:	84 81       	ldd	r24, Z+4	; 0x04
    39fa:	95 81       	ldd	r25, Z+5	; 0x05
    39fc:	0e 94 bb 0c 	call	0x1976	; 0x1976 <xQueueReceiveFromISR>
}
    3a00:	0f 90       	pop	r0
    3a02:	df 91       	pop	r29
    3a04:	cf 91       	pop	r28
    3a06:	08 95       	ret

00003a08 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3a08:	cf 93       	push	r28
    3a0a:	df 93       	push	r29
    3a0c:	00 d0       	rcall	.+0      	; 0x3a0e <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3a0e:	cd b7       	in	r28, 0x3d	; 61
    3a10:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3a12:	ae 01       	movw	r20, r28
    3a14:	4d 5f       	subi	r20, 0xFD	; 253
    3a16:	5f 4f       	sbci	r21, 0xFF	; 255
    3a18:	be 01       	movw	r22, r28
    3a1a:	6f 5f       	subi	r22, 0xFF	; 255
    3a1c:	7f 4f       	sbci	r23, 0xFF	; 255
    3a1e:	fc 01       	movw	r30, r24
    3a20:	84 81       	ldd	r24, Z+4	; 0x04
    3a22:	95 81       	ldd	r25, Z+5	; 0x05
    3a24:	0e 94 bb 0c 	call	0x1976	; 0x1976 <xQueueReceiveFromISR>
	return (recv_item);
}
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a2c:	23 96       	adiw	r28, 0x03	; 3
    3a2e:	cd bf       	out	0x3d, r28	; 61
    3a30:	de bf       	out	0x3e, r29	; 62
    3a32:	df 91       	pop	r29
    3a34:	cf 91       	pop	r28
    3a36:	08 95       	ret

00003a38 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3a38:	cf 93       	push	r28
    3a3a:	df 93       	push	r29
    3a3c:	1f 92       	push	r1
    3a3e:	cd b7       	in	r28, 0x3d	; 61
    3a40:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3a42:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3a44:	21 e0       	ldi	r18, 0x01	; 1
    3a46:	ae 01       	movw	r20, r28
    3a48:	4f 5f       	subi	r20, 0xFF	; 255
    3a4a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a4c:	fc 01       	movw	r30, r24
    3a4e:	84 81       	ldd	r24, Z+4	; 0x04
    3a50:	95 81       	ldd	r25, Z+5	; 0x05
    3a52:	0e 94 cb 0b 	call	0x1796	; 0x1796 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3a56:	91 e0       	ldi	r25, 0x01	; 1
    3a58:	81 11       	cpse	r24, r1
    3a5a:	01 c0       	rjmp	.+2      	; 0x3a5e <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
}
    3a5e:	89 2f       	mov	r24, r25
    3a60:	0f 90       	pop	r0
    3a62:	df 91       	pop	r29
    3a64:	cf 91       	pop	r28
    3a66:	08 95       	ret

00003a68 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3a68:	cf 93       	push	r28
    3a6a:	df 93       	push	r29
    3a6c:	1f 92       	push	r1
    3a6e:	cd b7       	in	r28, 0x3d	; 61
    3a70:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3a72:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3a74:	20 e0       	ldi	r18, 0x00	; 0
    3a76:	ae 01       	movw	r20, r28
    3a78:	4f 5f       	subi	r20, 0xFF	; 255
    3a7a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a7c:	fc 01       	movw	r30, r24
    3a7e:	84 81       	ldd	r24, Z+4	; 0x04
    3a80:	95 81       	ldd	r25, Z+5	; 0x05
    3a82:	0e 94 cb 0b 	call	0x1796	; 0x1796 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3a86:	91 e0       	ldi	r25, 0x01	; 1
    3a88:	81 11       	cpse	r24, r1
    3a8a:	01 c0       	rjmp	.+2      	; 0x3a8e <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3a8c:	90 e0       	ldi	r25, 0x00	; 0
}
    3a8e:	89 2f       	mov	r24, r25
    3a90:	0f 90       	pop	r0
    3a92:	df 91       	pop	r29
    3a94:	cf 91       	pop	r28
    3a96:	08 95       	ret

00003a98 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3a98:	cf 93       	push	r28
    3a9a:	df 93       	push	r29
    3a9c:	1f 92       	push	r1
    3a9e:	cd b7       	in	r28, 0x3d	; 61
    3aa0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3aa2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3aa4:	21 e0       	ldi	r18, 0x01	; 1
    3aa6:	ae 01       	movw	r20, r28
    3aa8:	4f 5f       	subi	r20, 0xFF	; 255
    3aaa:	5f 4f       	sbci	r21, 0xFF	; 255
    3aac:	fc 01       	movw	r30, r24
    3aae:	84 81       	ldd	r24, Z+4	; 0x04
    3ab0:	95 81       	ldd	r25, Z+5	; 0x05
    3ab2:	0e 94 cb 0b 	call	0x1796	; 0x1796 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ab6:	91 e0       	ldi	r25, 0x01	; 1
    3ab8:	81 11       	cpse	r24, r1
    3aba:	01 c0       	rjmp	.+2      	; 0x3abe <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3abc:	90 e0       	ldi	r25, 0x00	; 0
}
    3abe:	89 2f       	mov	r24, r25
    3ac0:	0f 90       	pop	r0
    3ac2:	df 91       	pop	r29
    3ac4:	cf 91       	pop	r28
    3ac6:	08 95       	ret

00003ac8 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3ac8:	cf 93       	push	r28
    3aca:	df 93       	push	r29
    3acc:	1f 92       	push	r1
    3ace:	cd b7       	in	r28, 0x3d	; 61
    3ad0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3ad2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3ad4:	20 e0       	ldi	r18, 0x00	; 0
    3ad6:	ae 01       	movw	r20, r28
    3ad8:	4f 5f       	subi	r20, 0xFF	; 255
    3ada:	5f 4f       	sbci	r21, 0xFF	; 255
    3adc:	fc 01       	movw	r30, r24
    3ade:	84 81       	ldd	r24, Z+4	; 0x04
    3ae0:	95 81       	ldd	r25, Z+5	; 0x05
    3ae2:	0e 94 cb 0b 	call	0x1796	; 0x1796 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ae6:	91 e0       	ldi	r25, 0x01	; 1
    3ae8:	81 11       	cpse	r24, r1
    3aea:	01 c0       	rjmp	.+2      	; 0x3aee <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3aec:	90 e0       	ldi	r25, 0x00	; 0
}
    3aee:	89 2f       	mov	r24, r25
    3af0:	0f 90       	pop	r0
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	08 95       	ret

00003af8 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3af8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3afa:	fc 01       	movw	r30, r24
    3afc:	26 81       	ldd	r18, Z+6	; 0x06
    3afe:	37 81       	ldd	r19, Z+7	; 0x07
    3b00:	40 85       	ldd	r20, Z+8	; 0x08
    3b02:	51 85       	ldd	r21, Z+9	; 0x09
    3b04:	01 e0       	ldi	r16, 0x01	; 1
    3b06:	84 81       	ldd	r24, Z+4	; 0x04
    3b08:	95 81       	ldd	r25, Z+5	; 0x05
    3b0a:	0e 94 30 0b 	call	0x1660	; 0x1660 <xQueueGenericSend>
    3b0e:	91 e0       	ldi	r25, 0x01	; 1
    3b10:	81 11       	cpse	r24, r1
    3b12:	01 c0       	rjmp	.+2      	; 0x3b16 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3b14:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b16:	89 2f       	mov	r24, r25
    3b18:	0f 91       	pop	r16
    3b1a:	08 95       	ret

00003b1c <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3b1c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3b1e:	fc 01       	movw	r30, r24
    3b20:	26 81       	ldd	r18, Z+6	; 0x06
    3b22:	37 81       	ldd	r19, Z+7	; 0x07
    3b24:	40 85       	ldd	r20, Z+8	; 0x08
    3b26:	51 85       	ldd	r21, Z+9	; 0x09
    3b28:	00 e0       	ldi	r16, 0x00	; 0
    3b2a:	84 81       	ldd	r24, Z+4	; 0x04
    3b2c:	95 81       	ldd	r25, Z+5	; 0x05
    3b2e:	0e 94 30 0b 	call	0x1660	; 0x1660 <xQueueGenericSend>
    3b32:	91 e0       	ldi	r25, 0x01	; 1
    3b34:	81 11       	cpse	r24, r1
    3b36:	01 c0       	rjmp	.+2      	; 0x3b3a <_ZN9frt_queueIjE3putERKj+0x1e>
    3b38:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b3a:	89 2f       	mov	r24, r25
    3b3c:	0f 91       	pop	r16
    3b3e:	08 95       	ret

00003b40 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3b40:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3b42:	fc 01       	movw	r30, r24
    3b44:	26 81       	ldd	r18, Z+6	; 0x06
    3b46:	37 81       	ldd	r19, Z+7	; 0x07
    3b48:	40 85       	ldd	r20, Z+8	; 0x08
    3b4a:	51 85       	ldd	r21, Z+9	; 0x09
    3b4c:	01 e0       	ldi	r16, 0x01	; 1
    3b4e:	84 81       	ldd	r24, Z+4	; 0x04
    3b50:	95 81       	ldd	r25, Z+5	; 0x05
    3b52:	0e 94 30 0b 	call	0x1660	; 0x1660 <xQueueGenericSend>
    3b56:	91 e0       	ldi	r25, 0x01	; 1
    3b58:	81 11       	cpse	r24, r1
    3b5a:	01 c0       	rjmp	.+2      	; 0x3b5e <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b5e:	89 2f       	mov	r24, r25
    3b60:	0f 91       	pop	r16
    3b62:	08 95       	ret

00003b64 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3b64:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3b66:	fc 01       	movw	r30, r24
    3b68:	26 81       	ldd	r18, Z+6	; 0x06
    3b6a:	37 81       	ldd	r19, Z+7	; 0x07
    3b6c:	40 85       	ldd	r20, Z+8	; 0x08
    3b6e:	51 85       	ldd	r21, Z+9	; 0x09
    3b70:	00 e0       	ldi	r16, 0x00	; 0
    3b72:	84 81       	ldd	r24, Z+4	; 0x04
    3b74:	95 81       	ldd	r25, Z+5	; 0x05
    3b76:	0e 94 30 0b 	call	0x1660	; 0x1660 <xQueueGenericSend>
    3b7a:	91 e0       	ldi	r25, 0x01	; 1
    3b7c:	81 11       	cpse	r24, r1
    3b7e:	01 c0       	rjmp	.+2      	; 0x3b82 <_ZN9frt_queueIiE3putERKi+0x1e>
    3b80:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b82:	89 2f       	mov	r24, r25
    3b84:	0f 91       	pop	r16
    3b86:	08 95       	ret

00003b88 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3b88:	0f 93       	push	r16
    3b8a:	cf 93       	push	r28
    3b8c:	df 93       	push	r29
    3b8e:	1f 92       	push	r1
    3b90:	cd b7       	in	r28, 0x3d	; 61
    3b92:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3b94:	2f b7       	in	r18, 0x3f	; 63
    3b96:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3b98:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3b9a:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3b9c:	fc 01       	movw	r30, r24
    3b9e:	08 ed       	ldi	r16, 0xD8	; 216
    3ba0:	04 bf       	out	0x34, r16	; 52
    3ba2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3ba4:	89 81       	ldd	r24, Y+1	; 0x01
    3ba6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3ba8:	0f 90       	pop	r0
    3baa:	df 91       	pop	r29
    3bac:	cf 91       	pop	r28
    3bae:	0f 91       	pop	r16
    3bb0:	08 95       	ret

00003bb2 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3bb2:	0f 93       	push	r16
    3bb4:	1f 93       	push	r17
    3bb6:	cf 93       	push	r28
    3bb8:	df 93       	push	r29
    3bba:	cd b7       	in	r28, 0x3d	; 61
    3bbc:	de b7       	in	r29, 0x3e	; 62
    3bbe:	e2 97       	sbiw	r28, 0x32	; 50
    3bc0:	cd bf       	out	0x3d, r28	; 61
    3bc2:	de bf       	out	0x3e, r29	; 62
	cli();
    3bc4:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3bc6:	e0 e5       	ldi	r30, 0x50	; 80
    3bc8:	f0 e0       	ldi	r31, 0x00	; 0
    3bca:	80 81       	ld	r24, Z
    3bcc:	82 60       	ori	r24, 0x02	; 2
    3bce:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3bd0:	81 81       	ldd	r24, Z+1	; 0x01
    3bd2:	81 ff       	sbrs	r24, 1
    3bd4:	fd cf       	rjmp	.-6      	; 0x3bd0 <main+0x1e>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3bd6:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3bda:	68 7f       	andi	r22, 0xF8	; 248
    3bdc:	61 60       	ori	r22, 0x01	; 1
    3bde:	80 e4       	ldi	r24, 0x40	; 64
    3be0:	90 e0       	ldi	r25, 0x00	; 0
    3be2:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3be6:	e0 e5       	ldi	r30, 0x50	; 80
    3be8:	f0 e0       	ldi	r31, 0x00	; 0
    3bea:	80 81       	ld	r24, Z
    3bec:	8e 7f       	andi	r24, 0xFE	; 254
    3bee:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3bf0:	9d ef       	ldi	r25, 0xFD	; 253
    3bf2:	88 ed       	ldi	r24, 0xD8	; 216
    3bf4:	08 b6       	in	r0, 0x38	; 56
    3bf6:	18 be       	out	0x38, r1	; 56
    3bf8:	84 bf       	out	0x34, r24	; 52
    3bfa:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3bfe:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3c00:	40 ea       	ldi	r20, 0xA0	; 160
    3c02:	5a e0       	ldi	r21, 0x0A	; 10
    3c04:	60 e0       	ldi	r22, 0x00	; 0
    3c06:	70 e0       	ldi	r23, 0x00	; 0
    3c08:	ce 01       	movw	r24, r28
    3c0a:	01 96       	adiw	r24, 0x01	; 1
    3c0c:	0e 94 68 19 	call	0x32d0	; 0x32d0 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3c10:	67 e0       	ldi	r22, 0x07	; 7
    3c12:	ce 01       	movw	r24, r28
    3c14:	01 96       	adiw	r24, 0x01	; 1
    3c16:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    3c1a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c1c:	6f e6       	ldi	r22, 0x6F	; 111
    3c1e:	70 e2       	ldi	r23, 0x20	; 32
    3c20:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_ZN8emstream4putsEPKc>
    3c24:	66 e0       	ldi	r22, 0x06	; 6
    3c26:	c8 01       	movw	r24, r16
    3c28:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
    3c2c:	66 e0       	ldi	r22, 0x06	; 6
    3c2e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    3c32:	20 e3       	ldi	r18, 0x30	; 48
    3c34:	32 ef       	ldi	r19, 0xF2	; 242
    3c36:	40 e0       	ldi	r20, 0x00	; 0
    3c38:	50 e0       	ldi	r21, 0x00	; 0
    3c3a:	60 ea       	ldi	r22, 0xA0	; 160
    3c3c:	74 e0       	ldi	r23, 0x04	; 4
    3c3e:	ce 01       	movw	r24, r28
    3c40:	4e 96       	adiw	r24, 0x1e	; 30
    3c42:	0e 94 4c 04 	call	0x898	; 0x898 <_ZN9I2CMasterC1EP10TWI_structm>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3c46:	82 e1       	ldi	r24, 0x12	; 18
    3c48:	90 e0       	ldi	r25, 0x00	; 0
    3c4a:	0e 94 da 16 	call	0x2db4	; 0x2db4 <_Znwj>
    3c4e:	8e 01       	movw	r16, r28
    3c50:	0f 5f       	subi	r16, 0xFF	; 255
    3c52:	1f 4f       	sbci	r17, 0xFF	; 255
    3c54:	20 e8       	ldi	r18, 0x80	; 128
    3c56:	30 e0       	ldi	r19, 0x00	; 0
    3c58:	40 e0       	ldi	r20, 0x00	; 0
    3c5a:	6e e8       	ldi	r22, 0x8E	; 142
    3c5c:	70 e2       	ldi	r23, 0x20	; 32
    3c5e:	0e 94 ac 04 	call	0x958	; 0x958 <_ZN9task_userC1EPKchjP8emstream>
	
	// new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3c62:	87 e0       	ldi	r24, 0x07	; 7
    3c64:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3c68:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3c6a:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <vTaskStartScheduler>
}
    3c6e:	80 e0       	ldi	r24, 0x00	; 0
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	e2 96       	adiw	r28, 0x32	; 50
    3c74:	cd bf       	out	0x3d, r28	; 61
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	df 91       	pop	r29
    3c7a:	cf 91       	pop	r28
    3c7c:	1f 91       	pop	r17
    3c7e:	0f 91       	pop	r16
    3c80:	08 95       	ret

00003c82 <_GLOBAL__sub_I_counter>:
    3c82:	cf 92       	push	r12
    3c84:	df 92       	push	r13
    3c86:	ef 92       	push	r14
    3c88:	ff 92       	push	r15
    3c8a:	0f 93       	push	r16
    3c8c:	1f 93       	push	r17
    3c8e:	cf 93       	push	r28
    3c90:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3c92:	0a e0       	ldi	r16, 0x0A	; 10
    3c94:	10 e0       	ldi	r17, 0x00	; 0
    3c96:	20 e0       	ldi	r18, 0x00	; 0
    3c98:	30 e0       	ldi	r19, 0x00	; 0
    3c9a:	40 e0       	ldi	r20, 0x00	; 0
    3c9c:	50 e0       	ldi	r21, 0x00	; 0
    3c9e:	60 e2       	ldi	r22, 0x20	; 32
    3ca0:	70 e0       	ldi	r23, 0x00	; 0
    3ca2:	8a e9       	ldi	r24, 0x9A	; 154
    3ca4:	91 e3       	ldi	r25, 0x31	; 49
    3ca6:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3caa:	c0 e9       	ldi	r28, 0x90	; 144
    3cac:	d1 e3       	ldi	r29, 0x31	; 49
    3cae:	1a 82       	std	Y+2, r1	; 0x02
    3cb0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3cb2:	8a e9       	ldi	r24, 0x9A	; 154
    3cb4:	90 e2       	ldi	r25, 0x20	; 32
    3cb6:	88 83       	st	Y, r24
    3cb8:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3cba:	40 e0       	ldi	r20, 0x00	; 0
    3cbc:	62 e0       	ldi	r22, 0x02	; 2
    3cbe:	8f ef       	ldi	r24, 0xFF	; 255
    3cc0:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    3cc4:	8c 83       	std	Y+4, r24	; 0x04
    3cc6:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3cc8:	0f 2e       	mov	r0, r31
    3cca:	fa e0       	ldi	r31, 0x0A	; 10
    3ccc:	cf 2e       	mov	r12, r31
    3cce:	d1 2c       	mov	r13, r1
    3cd0:	e1 2c       	mov	r14, r1
    3cd2:	f1 2c       	mov	r15, r1
    3cd4:	f0 2d       	mov	r31, r0
    3cd6:	ce 82       	std	Y+6, r12	; 0x06
    3cd8:	df 82       	std	Y+7, r13	; 0x07
    3cda:	e8 86       	std	Y+8, r14	; 0x08
    3cdc:	f9 86       	std	Y+9, r15	; 0x09
    3cde:	c6 e8       	ldi	r28, 0x86	; 134
    3ce0:	d1 e3       	ldi	r29, 0x31	; 49
    3ce2:	1a 82       	std	Y+2, r1	; 0x02
    3ce4:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3ce6:	0e eb       	ldi	r16, 0xBE	; 190
    3ce8:	10 e2       	ldi	r17, 0x20	; 32
    3cea:	08 83       	st	Y, r16
    3cec:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3cee:	40 e0       	ldi	r20, 0x00	; 0
    3cf0:	62 e0       	ldi	r22, 0x02	; 2
    3cf2:	8f ef       	ldi	r24, 0xFF	; 255
    3cf4:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    3cf8:	8c 83       	std	Y+4, r24	; 0x04
    3cfa:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3cfc:	ce 82       	std	Y+6, r12	; 0x06
    3cfe:	df 82       	std	Y+7, r13	; 0x07
    3d00:	e8 86       	std	Y+8, r14	; 0x08
    3d02:	f9 86       	std	Y+9, r15	; 0x09
    3d04:	cc e7       	ldi	r28, 0x7C	; 124
    3d06:	d1 e3       	ldi	r29, 0x31	; 49
    3d08:	1a 82       	std	Y+2, r1	; 0x02
    3d0a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d0c:	08 83       	st	Y, r16
    3d0e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d10:	40 e0       	ldi	r20, 0x00	; 0
    3d12:	62 e0       	ldi	r22, 0x02	; 2
    3d14:	8f ef       	ldi	r24, 0xFF	; 255
    3d16:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    3d1a:	8c 83       	std	Y+4, r24	; 0x04
    3d1c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d1e:	ce 82       	std	Y+6, r12	; 0x06
    3d20:	df 82       	std	Y+7, r13	; 0x07
    3d22:	e8 86       	std	Y+8, r14	; 0x08
    3d24:	f9 86       	std	Y+9, r15	; 0x09
    3d26:	c2 e7       	ldi	r28, 0x72	; 114
    3d28:	d1 e3       	ldi	r29, 0x31	; 49
    3d2a:	1a 82       	std	Y+2, r1	; 0x02
    3d2c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d2e:	08 83       	st	Y, r16
    3d30:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d32:	40 e0       	ldi	r20, 0x00	; 0
    3d34:	62 e0       	ldi	r22, 0x02	; 2
    3d36:	8f ef       	ldi	r24, 0xFF	; 255
    3d38:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    3d3c:	8c 83       	std	Y+4, r24	; 0x04
    3d3e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d40:	ce 82       	std	Y+6, r12	; 0x06
    3d42:	df 82       	std	Y+7, r13	; 0x07
    3d44:	e8 86       	std	Y+8, r14	; 0x08
    3d46:	f9 86       	std	Y+9, r15	; 0x09
    3d48:	c8 e6       	ldi	r28, 0x68	; 104
    3d4a:	d1 e3       	ldi	r29, 0x31	; 49
    3d4c:	1a 82       	std	Y+2, r1	; 0x02
    3d4e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d50:	08 83       	st	Y, r16
    3d52:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d54:	40 e0       	ldi	r20, 0x00	; 0
    3d56:	62 e0       	ldi	r22, 0x02	; 2
    3d58:	8f ef       	ldi	r24, 0xFF	; 255
    3d5a:	0e 94 02 0b 	call	0x1604	; 0x1604 <xQueueGenericCreate>
    3d5e:	8c 83       	std	Y+4, r24	; 0x04
    3d60:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d62:	ce 82       	std	Y+6, r12	; 0x06
    3d64:	df 82       	std	Y+7, r13	; 0x07
    3d66:	e8 86       	std	Y+8, r14	; 0x08
    3d68:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3d6a:	df 91       	pop	r29
    3d6c:	cf 91       	pop	r28
    3d6e:	1f 91       	pop	r17
    3d70:	0f 91       	pop	r16
    3d72:	ff 90       	pop	r15
    3d74:	ef 90       	pop	r14
    3d76:	df 90       	pop	r13
    3d78:	cf 90       	pop	r12
    3d7a:	08 95       	ret

00003d7c <__mulsi3>:
    3d7c:	db 01       	movw	r26, r22
    3d7e:	8f 93       	push	r24
    3d80:	9f 93       	push	r25
    3d82:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__muluhisi3>
    3d86:	bf 91       	pop	r27
    3d88:	af 91       	pop	r26
    3d8a:	a2 9f       	mul	r26, r18
    3d8c:	80 0d       	add	r24, r0
    3d8e:	91 1d       	adc	r25, r1
    3d90:	a3 9f       	mul	r26, r19
    3d92:	90 0d       	add	r25, r0
    3d94:	b2 9f       	mul	r27, r18
    3d96:	90 0d       	add	r25, r0
    3d98:	11 24       	eor	r1, r1
    3d9a:	08 95       	ret

00003d9c <__udivmodsi4>:
    3d9c:	a1 e2       	ldi	r26, 0x21	; 33
    3d9e:	1a 2e       	mov	r1, r26
    3da0:	aa 1b       	sub	r26, r26
    3da2:	bb 1b       	sub	r27, r27
    3da4:	fd 01       	movw	r30, r26
    3da6:	0d c0       	rjmp	.+26     	; 0x3dc2 <__udivmodsi4_ep>

00003da8 <__udivmodsi4_loop>:
    3da8:	aa 1f       	adc	r26, r26
    3daa:	bb 1f       	adc	r27, r27
    3dac:	ee 1f       	adc	r30, r30
    3dae:	ff 1f       	adc	r31, r31
    3db0:	a2 17       	cp	r26, r18
    3db2:	b3 07       	cpc	r27, r19
    3db4:	e4 07       	cpc	r30, r20
    3db6:	f5 07       	cpc	r31, r21
    3db8:	20 f0       	brcs	.+8      	; 0x3dc2 <__udivmodsi4_ep>
    3dba:	a2 1b       	sub	r26, r18
    3dbc:	b3 0b       	sbc	r27, r19
    3dbe:	e4 0b       	sbc	r30, r20
    3dc0:	f5 0b       	sbc	r31, r21

00003dc2 <__udivmodsi4_ep>:
    3dc2:	66 1f       	adc	r22, r22
    3dc4:	77 1f       	adc	r23, r23
    3dc6:	88 1f       	adc	r24, r24
    3dc8:	99 1f       	adc	r25, r25
    3dca:	1a 94       	dec	r1
    3dcc:	69 f7       	brne	.-38     	; 0x3da8 <__udivmodsi4_loop>
    3dce:	60 95       	com	r22
    3dd0:	70 95       	com	r23
    3dd2:	80 95       	com	r24
    3dd4:	90 95       	com	r25
    3dd6:	9b 01       	movw	r18, r22
    3dd8:	ac 01       	movw	r20, r24
    3dda:	bd 01       	movw	r22, r26
    3ddc:	cf 01       	movw	r24, r30
    3dde:	08 95       	ret

00003de0 <__divmodsi4>:
    3de0:	05 2e       	mov	r0, r21
    3de2:	97 fb       	bst	r25, 7
    3de4:	1e f4       	brtc	.+6      	; 0x3dec <__divmodsi4+0xc>
    3de6:	00 94       	com	r0
    3de8:	0e 94 07 1f 	call	0x3e0e	; 0x3e0e <__negsi2>
    3dec:	57 fd       	sbrc	r21, 7
    3dee:	07 d0       	rcall	.+14     	; 0x3dfe <__divmodsi4_neg2>
    3df0:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <__udivmodsi4>
    3df4:	07 fc       	sbrc	r0, 7
    3df6:	03 d0       	rcall	.+6      	; 0x3dfe <__divmodsi4_neg2>
    3df8:	4e f4       	brtc	.+18     	; 0x3e0c <__divmodsi4_exit>
    3dfa:	0c 94 07 1f 	jmp	0x3e0e	; 0x3e0e <__negsi2>

00003dfe <__divmodsi4_neg2>:
    3dfe:	50 95       	com	r21
    3e00:	40 95       	com	r20
    3e02:	30 95       	com	r19
    3e04:	21 95       	neg	r18
    3e06:	3f 4f       	sbci	r19, 0xFF	; 255
    3e08:	4f 4f       	sbci	r20, 0xFF	; 255
    3e0a:	5f 4f       	sbci	r21, 0xFF	; 255

00003e0c <__divmodsi4_exit>:
    3e0c:	08 95       	ret

00003e0e <__negsi2>:
    3e0e:	90 95       	com	r25
    3e10:	80 95       	com	r24
    3e12:	70 95       	com	r23
    3e14:	61 95       	neg	r22
    3e16:	7f 4f       	sbci	r23, 0xFF	; 255
    3e18:	8f 4f       	sbci	r24, 0xFF	; 255
    3e1a:	9f 4f       	sbci	r25, 0xFF	; 255
    3e1c:	08 95       	ret

00003e1e <__tablejump2__>:
    3e1e:	ee 0f       	add	r30, r30
    3e20:	ff 1f       	adc	r31, r31
    3e22:	88 1f       	adc	r24, r24
    3e24:	8b bf       	out	0x3b, r24	; 59
    3e26:	07 90       	elpm	r0, Z+
    3e28:	f6 91       	elpm	r31, Z
    3e2a:	e0 2d       	mov	r30, r0
    3e2c:	1b be       	out	0x3b, r1	; 59
    3e2e:	19 94       	eijmp

00003e30 <__muluhisi3>:
    3e30:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <__umulhisi3>
    3e34:	a5 9f       	mul	r26, r21
    3e36:	90 0d       	add	r25, r0
    3e38:	b4 9f       	mul	r27, r20
    3e3a:	90 0d       	add	r25, r0
    3e3c:	a4 9f       	mul	r26, r20
    3e3e:	80 0d       	add	r24, r0
    3e40:	91 1d       	adc	r25, r1
    3e42:	11 24       	eor	r1, r1
    3e44:	08 95       	ret

00003e46 <__umulhisi3>:
    3e46:	a2 9f       	mul	r26, r18
    3e48:	b0 01       	movw	r22, r0
    3e4a:	b3 9f       	mul	r27, r19
    3e4c:	c0 01       	movw	r24, r0
    3e4e:	a3 9f       	mul	r26, r19
    3e50:	70 0d       	add	r23, r0
    3e52:	81 1d       	adc	r24, r1
    3e54:	11 24       	eor	r1, r1
    3e56:	91 1d       	adc	r25, r1
    3e58:	b2 9f       	mul	r27, r18
    3e5a:	70 0d       	add	r23, r0
    3e5c:	81 1d       	adc	r24, r1
    3e5e:	11 24       	eor	r1, r1
    3e60:	91 1d       	adc	r25, r1
    3e62:	08 95       	ret

00003e64 <memcpy>:
    3e64:	fb 01       	movw	r30, r22
    3e66:	dc 01       	movw	r26, r24
    3e68:	02 c0       	rjmp	.+4      	; 0x3e6e <memcpy+0xa>
    3e6a:	01 90       	ld	r0, Z+
    3e6c:	0d 92       	st	X+, r0
    3e6e:	41 50       	subi	r20, 0x01	; 1
    3e70:	50 40       	sbci	r21, 0x00	; 0
    3e72:	d8 f7       	brcc	.-10     	; 0x3e6a <memcpy+0x6>
    3e74:	08 95       	ret

00003e76 <memset>:
    3e76:	dc 01       	movw	r26, r24
    3e78:	01 c0       	rjmp	.+2      	; 0x3e7c <memset+0x6>
    3e7a:	6d 93       	st	X+, r22
    3e7c:	41 50       	subi	r20, 0x01	; 1
    3e7e:	50 40       	sbci	r21, 0x00	; 0
    3e80:	e0 f7       	brcc	.-8      	; 0x3e7a <memset+0x4>
    3e82:	08 95       	ret

00003e84 <strncpy>:
    3e84:	fb 01       	movw	r30, r22
    3e86:	dc 01       	movw	r26, r24
    3e88:	41 50       	subi	r20, 0x01	; 1
    3e8a:	50 40       	sbci	r21, 0x00	; 0
    3e8c:	48 f0       	brcs	.+18     	; 0x3ea0 <strncpy+0x1c>
    3e8e:	01 90       	ld	r0, Z+
    3e90:	0d 92       	st	X+, r0
    3e92:	00 20       	and	r0, r0
    3e94:	c9 f7       	brne	.-14     	; 0x3e88 <strncpy+0x4>
    3e96:	01 c0       	rjmp	.+2      	; 0x3e9a <strncpy+0x16>
    3e98:	1d 92       	st	X+, r1
    3e9a:	41 50       	subi	r20, 0x01	; 1
    3e9c:	50 40       	sbci	r21, 0x00	; 0
    3e9e:	e0 f7       	brcc	.-8      	; 0x3e98 <strncpy+0x14>
    3ea0:	08 95       	ret

00003ea2 <ultoa>:
    3ea2:	25 32       	cpi	r18, 0x25	; 37
    3ea4:	31 05       	cpc	r19, r1
    3ea6:	20 f4       	brcc	.+8      	; 0x3eb0 <ultoa+0xe>
    3ea8:	22 30       	cpi	r18, 0x02	; 2
    3eaa:	10 f0       	brcs	.+4      	; 0x3eb0 <ultoa+0xe>
    3eac:	0c 94 5c 1f 	jmp	0x3eb8	; 0x3eb8 <__ultoa_ncheck>
    3eb0:	fa 01       	movw	r30, r20
    3eb2:	10 82       	st	Z, r1
    3eb4:	ca 01       	movw	r24, r20
    3eb6:	08 95       	ret

00003eb8 <__ultoa_ncheck>:
    3eb8:	bb 27       	eor	r27, r27

00003eba <__ultoa_common>:
    3eba:	fa 01       	movw	r30, r20
    3ebc:	a6 2f       	mov	r26, r22
    3ebe:	62 17       	cp	r22, r18
    3ec0:	71 05       	cpc	r23, r1
    3ec2:	81 05       	cpc	r24, r1
    3ec4:	91 05       	cpc	r25, r1
    3ec6:	33 0b       	sbc	r19, r19
    3ec8:	30 fb       	bst	r19, 0
    3eca:	66 f0       	brts	.+24     	; 0x3ee4 <__ultoa_common+0x2a>
    3ecc:	aa 27       	eor	r26, r26
    3ece:	66 0f       	add	r22, r22
    3ed0:	77 1f       	adc	r23, r23
    3ed2:	88 1f       	adc	r24, r24
    3ed4:	99 1f       	adc	r25, r25
    3ed6:	aa 1f       	adc	r26, r26
    3ed8:	a2 17       	cp	r26, r18
    3eda:	10 f0       	brcs	.+4      	; 0x3ee0 <__ultoa_common+0x26>
    3edc:	a2 1b       	sub	r26, r18
    3ede:	63 95       	inc	r22
    3ee0:	38 50       	subi	r19, 0x08	; 8
    3ee2:	a9 f7       	brne	.-22     	; 0x3ece <__ultoa_common+0x14>
    3ee4:	a0 5d       	subi	r26, 0xD0	; 208
    3ee6:	aa 33       	cpi	r26, 0x3A	; 58
    3ee8:	08 f0       	brcs	.+2      	; 0x3eec <__ultoa_common+0x32>
    3eea:	a9 5d       	subi	r26, 0xD9	; 217
    3eec:	a1 93       	st	Z+, r26
    3eee:	36 f7       	brtc	.-52     	; 0x3ebc <__ultoa_common+0x2>
    3ef0:	b1 11       	cpse	r27, r1
    3ef2:	b1 93       	st	Z+, r27
    3ef4:	10 82       	st	Z, r1
    3ef6:	ca 01       	movw	r24, r20
    3ef8:	0c 94 a3 1f 	jmp	0x3f46	; 0x3f46 <strrev>

00003efc <utoa>:
    3efc:	45 32       	cpi	r20, 0x25	; 37
    3efe:	51 05       	cpc	r21, r1
    3f00:	20 f4       	brcc	.+8      	; 0x3f0a <utoa+0xe>
    3f02:	42 30       	cpi	r20, 0x02	; 2
    3f04:	10 f0       	brcs	.+4      	; 0x3f0a <utoa+0xe>
    3f06:	0c 94 89 1f 	jmp	0x3f12	; 0x3f12 <__utoa_ncheck>
    3f0a:	fb 01       	movw	r30, r22
    3f0c:	10 82       	st	Z, r1
    3f0e:	cb 01       	movw	r24, r22
    3f10:	08 95       	ret

00003f12 <__utoa_ncheck>:
    3f12:	bb 27       	eor	r27, r27

00003f14 <__utoa_common>:
    3f14:	fb 01       	movw	r30, r22
    3f16:	55 27       	eor	r21, r21
    3f18:	aa 27       	eor	r26, r26
    3f1a:	88 0f       	add	r24, r24
    3f1c:	99 1f       	adc	r25, r25
    3f1e:	aa 1f       	adc	r26, r26
    3f20:	a4 17       	cp	r26, r20
    3f22:	10 f0       	brcs	.+4      	; 0x3f28 <__utoa_common+0x14>
    3f24:	a4 1b       	sub	r26, r20
    3f26:	83 95       	inc	r24
    3f28:	50 51       	subi	r21, 0x10	; 16
    3f2a:	b9 f7       	brne	.-18     	; 0x3f1a <__utoa_common+0x6>
    3f2c:	a0 5d       	subi	r26, 0xD0	; 208
    3f2e:	aa 33       	cpi	r26, 0x3A	; 58
    3f30:	08 f0       	brcs	.+2      	; 0x3f34 <__utoa_common+0x20>
    3f32:	a9 5d       	subi	r26, 0xD9	; 217
    3f34:	a1 93       	st	Z+, r26
    3f36:	00 97       	sbiw	r24, 0x00	; 0
    3f38:	79 f7       	brne	.-34     	; 0x3f18 <__utoa_common+0x4>
    3f3a:	b1 11       	cpse	r27, r1
    3f3c:	b1 93       	st	Z+, r27
    3f3e:	11 92       	st	Z+, r1
    3f40:	cb 01       	movw	r24, r22
    3f42:	0c 94 a3 1f 	jmp	0x3f46	; 0x3f46 <strrev>

00003f46 <strrev>:
    3f46:	dc 01       	movw	r26, r24
    3f48:	fc 01       	movw	r30, r24
    3f4a:	67 2f       	mov	r22, r23
    3f4c:	71 91       	ld	r23, Z+
    3f4e:	77 23       	and	r23, r23
    3f50:	e1 f7       	brne	.-8      	; 0x3f4a <strrev+0x4>
    3f52:	32 97       	sbiw	r30, 0x02	; 2
    3f54:	04 c0       	rjmp	.+8      	; 0x3f5e <strrev+0x18>
    3f56:	7c 91       	ld	r23, X
    3f58:	6d 93       	st	X+, r22
    3f5a:	70 83       	st	Z, r23
    3f5c:	62 91       	ld	r22, -Z
    3f5e:	ae 17       	cp	r26, r30
    3f60:	bf 07       	cpc	r27, r31
    3f62:	c8 f3       	brcs	.-14     	; 0x3f56 <strrev+0x10>
    3f64:	08 95       	ret

00003f66 <_exit>:
    3f66:	f8 94       	cli

00003f68 <__stop_program>:
    3f68:	ff cf       	rjmp	.-2      	; 0x3f68 <__stop_program>
