
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004158  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000da  00802000  00004158  000041ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020da  008020da  000042c6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000042c6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000042f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000800  00000000  00000000  00004338  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012a16  00000000  00000000  00004b38  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006052  00000000  00000000  0001754e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000528e  00000000  00000000  0001d5a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001740  00000000  00000000  00022830  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005daf  00000000  00000000  00023f70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007078  00000000  00000000  00029d1f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000740  00000000  00000000  00030d97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 eb 02 	jmp	0x5d6	; 0x5d6 <__ctors_end>
       4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      10:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      14:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      18:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      1c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      20:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      24:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      28:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      2c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      30:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      34:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      38:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      3c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      40:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      44:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      48:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      4c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      50:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      54:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      58:	0c 94 f0 0a 	jmp	0x15e0	; 0x15e0 <__vector_22>
      5c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      60:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      64:	0c 94 c5 1a 	jmp	0x358a	; 0x358a <__vector_25>
      68:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      6c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      70:	0c 94 23 1b 	jmp	0x3646	; 0x3646 <__vector_28>
      74:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      78:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      7c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      80:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      84:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      88:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      8c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      90:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      94:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      98:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      9c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e8:	0c 94 3d 1c 	jmp	0x387a	; 0x387a <__vector_58>
      ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      fc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     100:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     104:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     108:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     10c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     110:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     114:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     118:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     11c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     120:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     124:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     128:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     12c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     130:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     134:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     138:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     13c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     140:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     144:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     148:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     14c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     150:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     154:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     158:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     15c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     160:	0c 94 81 1b 	jmp	0x3702	; 0x3702 <__vector_88>
     164:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     168:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     16c:	0c 94 df 1b 	jmp	0x37be	; 0x37be <__vector_91>
     170:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     174:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     178:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     17c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     180:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     184:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     188:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     18c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     190:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     194:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     198:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     19c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1dc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1fc:	b1 18       	sub	r11, r1
     1fe:	b4 18       	sub	r11, r4
     200:	b7 18       	sub	r11, r7
     202:	ba 18       	sub	r11, r10
     204:	bd 18       	sub	r11, r13
     206:	c0 18       	sub	r12, r0
     208:	c2 18       	sub	r12, r2
     20a:	d3 18       	sub	r13, r3
     20c:	db 18       	sub	r13, r11
     20e:	e5 18       	sub	r14, r5
     210:	e3 18       	sub	r14, r3

00000212 <__trampolines_start>:
     212:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <_ZN9frt_queueIjE10get_a_copyEv>
     216:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <_ZN9frt_queueIjE12num_items_inEv>
     21a:	0c 94 d3 18 	jmp	0x31a6	; 0x31a6 <_ZN8emstreamlsE15ser_manipulator+0x62>
     21e:	0c 94 54 18 	jmp	0x30a8	; 0x30a8 <_ZN8emstream13ready_to_sendEv>
     222:	0c 94 df 19 	jmp	0x33be	; 0x33be <_ZN5rs2327putcharEc>
     226:	0c 94 01 1d 	jmp	0x3a02	; 0x3a02 <_ZN9frt_queueIiE8is_emptyEv>
     22a:	0c 94 a7 1d 	jmp	0x3b4e	; 0x3b4e <_ZN9frt_queueIjE7ISR_getEPj>
     22e:	0c 94 be 1c 	jmp	0x397c	; 0x397c <_ZN9frt_queueIiE13ISR_not_emptyEv>
     232:	0c 94 bd 17 	jmp	0x2f7a	; 0x2f7a <__cxa_pure_virtual>
     236:	0c 94 c9 1c 	jmp	0x3992	; 0x3992 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     23a:	0c 94 a2 1c 	jmp	0x3944	; 0x3944 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     23e:	0c 94 cc 06 	jmp	0xd98	; 0xd98 <_ZN9task_user3runEv>
     242:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     246:	0c 94 5c 18 	jmp	0x30b8	; 0x30b8 <_ZN8emstream12clear_screenEv>
     24a:	0c 94 32 03 	jmp	0x664	; 0x664 <_ZN9I2CMaster11Transmitter11StatusState7executeERh>
     24e:	0c 94 e5 1c 	jmp	0x39ca	; 0x39ca <_ZN9frt_queueIjE8is_emptyEv>
     252:	0c 94 b4 18 	jmp	0x3168	; 0x3168 <_ZN8emstreamlsE15ser_manipulator+0x24>
     256:	0c 94 0b 1d 	jmp	0x3a16	; 0x3a16 <_ZN9frt_queueIjE10get_a_copyERj>
     25a:	0c 94 59 1e 	jmp	0x3cb2	; 0x3cb2 <_ZN9frt_queueIjE7butt_inERKj>
     25e:	0c 94 56 18 	jmp	0x30ac	; 0x30ac <_ZN8emstream7getcharEv>
     262:	0c 94 11 1e 	jmp	0x3c22	; 0x3c22 <_ZN9frt_queueIjE7ISR_putERKj>
     266:	0c 94 dc 15 	jmp	0x2bb8	; 0x2bb8 <_ZN14frt_text_queue7getcharEv>
     26a:	0c 94 db 18 	jmp	0x31b6	; 0x31b6 <_ZN8emstreamlsE15ser_manipulator+0x72>
     26e:	0c 94 65 1d 	jmp	0x3aca	; 0x3aca <_ZN9frt_queueIiE10get_a_copyEv>
     272:	0c 94 59 1d 	jmp	0x3ab2	; 0x3ab2 <_ZN9frt_queueIiE10get_a_copyERi>
     276:	0c 94 2e 05 	jmp	0xa5c	; 0xa5c <_ZN10task_sonar3runEv>
     27a:	0c 94 c0 18 	jmp	0x3180	; 0x3180 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     27e:	0c 94 b7 1c 	jmp	0x396e	; 0x396e <_ZN9frt_queueIiE16ISR_num_items_inEv>
     282:	0c 94 23 03 	jmp	0x646	; 0x646 <_ZN9I2CMaster11Transmitter10StartState7executeERh>
     286:	0c 94 fa 15 	jmp	0x2bf4	; 0x2bf4 <_ZN14frt_text_queue14check_for_charEv>
     28a:	0c 94 29 1e 	jmp	0x3c52	; 0x3c52 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     28e:	0c 94 5b 18 	jmp	0x30b6	; 0x30b6 <_ZN8emstream12transmit_nowEv>
     292:	0c 94 e1 1d 	jmp	0x3bc2	; 0x3bc2 <_ZN9frt_queueIiE7ISR_getEv>
     296:	0c 94 b8 1d 	jmp	0x3b70	; 0x3b70 <_ZN9frt_queueIjE7ISR_getEv>
     29a:	0c 94 ad 1c 	jmp	0x395a	; 0x395a <_ZN9frt_queueIjE12ISR_is_emptyEv>
     29e:	0c 94 05 16 	jmp	0x2c0a	; 0x2c0a <_ZN14frt_text_queue7putcharEc>
     2a2:	0c 94 e5 18 	jmp	0x31ca	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
     2a6:	0c 94 ef 1c 	jmp	0x39de	; 0x39de <_ZN9frt_queueIiE12num_items_inEv>
     2aa:	0c 94 7d 1e 	jmp	0x3cfa	; 0x3cfa <_ZN9frt_queueIiE7butt_inERKi>
     2ae:	0c 94 80 1d 	jmp	0x3b00	; 0x3b00 <_ZN9frt_queueIiE3getEPi>
     2b2:	0c 94 29 1a 	jmp	0x3452	; 0x3452 <_ZN5rs23214check_for_charEv>
     2b6:	0c 94 b1 18 	jmp	0x3162	; 0x3162 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2ba:	0c 94 6b 1e 	jmp	0x3cd6	; 0x3cd6 <_ZN9frt_queueIjE3putERKj>
     2be:	0c 94 ba 18 	jmp	0x3174	; 0x3174 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2c2:	0c 94 59 18 	jmp	0x30b2	; 0x30b2 <_ZN8emstream14check_for_charEv>
     2c6:	0c 94 41 1e 	jmp	0x3c82	; 0x3c82 <_ZN9frt_queueIiE7ISR_putERKi>
     2ca:	0c 94 8c 1d 	jmp	0x3b18	; 0x3b18 <_ZN9frt_queueIiE3getEv>
     2ce:	0c 94 b7 18 	jmp	0x316e	; 0x316e <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2d2:	0c 94 e3 18 	jmp	0x31c6	; 0x31c6 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2d6:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <_ZN9I2CMaster11Transmitter9DoneState7executeERh>
     2da:	0c 94 c2 18 	jmp	0x3184	; 0x3184 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2de:	0c 94 d0 1d 	jmp	0x3ba0	; 0x3ba0 <_ZN9frt_queueIiE7ISR_getEPi>
     2e2:	0c 94 da 1c 	jmp	0x39b4	; 0x39b4 <_ZN9frt_queueIjE9not_emptyEv>
     2e6:	0c 94 f9 1d 	jmp	0x3bf2	; 0x3bf2 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     2ea:	0c 94 03 1a 	jmp	0x3406	; 0x3406 <_ZN5rs2327getcharEv>
     2ee:	0c 94 d0 0d 	jmp	0x1ba0	; 0x1ba0 <prvIdleTask>
     2f2:	0c 94 f6 1c 	jmp	0x39ec	; 0x39ec <_ZN9frt_queueIiE9not_emptyEv>
     2f6:	0c 94 38 1f 	jmp	0x3e70	; 0x3e70 <_GLOBAL__sub_I_counter>
     2fa:	0c 94 92 14 	jmp	0x2924	; 0x2924 <_ZN8frt_task12print_statusER8emstream>
     2fe:	0c 94 32 1d 	jmp	0x3a64	; 0x3a64 <_ZN9frt_queueIjE3getEPj>
     302:	0c 94 8f 1e 	jmp	0x3d1e	; 0x3d1e <_ZN9frt_queueIiE3putERKi>
     306:	0c 94 3e 1d 	jmp	0x3a7c	; 0x3a7c <_ZN9frt_queueIjE3getEv>
     30a:	0c 94 3c 1a 	jmp	0x3478	; 0x3478 <_ZN5rs23212clear_screenEv>
     30e:	0c 94 e8 02 	jmp	0x5d0	; 0x5d0 <_call_static_run_method>
     312:	0c 94 bd 18 	jmp	0x317a	; 0x317a <_ZN8emstreamlsE15ser_manipulator+0x36>

00000316 <__trampolines_end>:
     316:	53 6f       	ori	r21, 0xF3	; 243
     318:	6e 61       	ori	r22, 0x1E	; 30
     31a:	72 3a       	cpi	r23, 0xA2	; 162
     31c:	20 00       	.word	0x0020	; ????

0000031e <_ZZN9task_user11show_statusEvE3__c_4>:
     31e:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

00000329 <_ZZN9task_user11show_statusEvE3__c_3>:
     329:	2f 00                                               /.

0000032b <_ZZN9task_user11show_statusEvE3__c_2>:
     32b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000339 <_ZZN9task_user11show_statusEvE3__c_1>:
     339:	54 69 6d 65 3a 20 00                                Time: .

00000340 <_ZZN9task_user11show_statusEvE3__c_0>:
     340:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

0000034c <_ZZN9task_user11show_statusEvE3__c>:
     34c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     35c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000036b <_ZZN9task_user18print_help_messageEvE3__c_10>:
     36b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000037a <_ZZN9task_user18print_help_messageEvE3__c_9>:
     37a:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     38a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000395 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     395:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3a5:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003b3 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3b3:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3c3:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3d3:	6d 61 74 69 6f 6e 00                                mation.

000003da <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3da:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3ea:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003fb <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3fb:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     40b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000413 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     413:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     423:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000042f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     42f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     43f:	68 65 20 41 56 52 00                                he AVR.

00000446 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     446:	20 68 65 6c 70 00                                    help.

0000044c <_ZZN9task_user18print_help_messageEvE3__c_1>:
     44c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     45c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000046b <_ZZN9task_user18print_help_messageEvE3__c_0>:
     46b:	1b 5b 33 30 6d 00                                   .[30m.

00000471 <_ZZN9task_user18print_help_messageEvE3__c>:
     471:	1b 5b 34 36 6d 00                                   .[46m.

00000477 <_ZZN9task_user3runEvE3__c_3>:
     477:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     487:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000494 <_ZZN9task_user3runEvE3__c_2>:
     494:	3a 57 54 46 3f 00                                   :WTF?.

0000049a <_ZZN9task_user3runEvE3__c_1>:
     49a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4aa:	65 00                                               e.

000004ac <_ZZN9task_user3runEvE3__c_0>:
     4ac:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004ba <_ZZN9task_user3runEvE3__c>:
     4ba:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4ca:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004d8 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4d8:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004e2 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4e2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004f1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4f1:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     501:	61 73 6b 20 00                                      ask .

00000506 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     506:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000514 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     514:	20 63 72 65 61 74 65 64 00                           created.

0000051d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     51d:	54 61 73 6b 20 00                                   Task .

00000523 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     523:	1b 5b 32 32 6d 00                                   .[22m.

00000529 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     529:	54 61 73 6b 3a 20 00                                Task: .

00000530 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     530:	1b 5b 31 6d 00                                      .[1m.

00000535 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     535:	1b 5b 32 32 6d 00                                   .[22m.

0000053b <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     53b:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000546 <_ZZ17print_task_stacksP8emstreamE3__c>:
     546:	1b 5b 31 6d 00                                      .[1m.

0000054b <_ZZ15print_task_listP8emstreamE3__c_9>:
     54b:	09 09 00                                            ...

0000054e <_ZZ15print_task_listP8emstreamE3__c_8>:
     54e:	2f 00                                               /.

00000550 <_ZZ15print_task_listP8emstreamE3__c_7>:
     550:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000055b <_ZZ15print_task_listP8emstreamE3__c_6>:
     55b:	09 2d 2d 2d 2d 00                                   .----.

00000561 <_ZZ15print_task_listP8emstreamE3__c_5>:
     561:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000056d <_ZZ15print_task_listP8emstreamE3__c_4>:
     56d:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000057e <_ZZ15print_task_listP8emstreamE3__c_3>:
     57e:	09 52 75 6e 73 00                                   .Runs.

00000584 <_ZZ15print_task_listP8emstreamE3__c_2>:
     584:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000590 <_ZZ15print_task_listP8emstreamE3__c_1>:
     590:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005a1 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5a1:	09 53 74 61 63 6b 00                                .Stack.

000005a8 <_ZZ15print_task_listP8emstreamE3__c>:
     5a8:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005b3 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5b3:	09 00                                               ..

000005b5 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5b5:	09 00                                               ..

000005b7 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5b7:	2f 00                                               /.

000005b9 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5b9:	09 00                                               ..

000005bb <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5bb:	09 00                                               ..

000005bd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5bd:	1b 5b 32 32 6d 00                                   .[22m.

000005c3 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5c3:	1b 5b 31 6d 00                                      .[1m.

000005c8 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5c8:	1b 5b 31 6d 00                                      .[1m.

000005cd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5cd:	20 20 00                                              .

000005d0 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5d0:	0e 94 2a 13 	call	0x2654	; 0x2654 <_ZN8frt_task22_call_users_run_methodEPS_>

000005d4 <__ctors_start>:
     5d4:	38 1f       	adc	r19, r24

000005d6 <__ctors_end>:
     5d6:	11 24       	eor	r1, r1
     5d8:	1f be       	out	0x3f, r1	; 63
     5da:	cf ef       	ldi	r28, 0xFF	; 255
     5dc:	cd bf       	out	0x3d, r28	; 61
     5de:	df e3       	ldi	r29, 0x3F	; 63
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	00 e0       	ldi	r16, 0x00	; 0
     5e4:	0c bf       	out	0x3c, r16	; 60
     5e6:	18 be       	out	0x38, r1	; 56
     5e8:	19 be       	out	0x39, r1	; 57
     5ea:	1a be       	out	0x3a, r1	; 58
     5ec:	1b be       	out	0x3b, r1	; 59

000005ee <__do_copy_data>:
     5ee:	10 e2       	ldi	r17, 0x20	; 32
     5f0:	a0 e0       	ldi	r26, 0x00	; 0
     5f2:	b0 e2       	ldi	r27, 0x20	; 32
     5f4:	e8 e5       	ldi	r30, 0x58	; 88
     5f6:	f1 e4       	ldi	r31, 0x41	; 65
     5f8:	00 e0       	ldi	r16, 0x00	; 0
     5fa:	0b bf       	out	0x3b, r16	; 59
     5fc:	02 c0       	rjmp	.+4      	; 0x602 <__do_copy_data+0x14>
     5fe:	07 90       	elpm	r0, Z+
     600:	0d 92       	st	X+, r0
     602:	aa 3d       	cpi	r26, 0xDA	; 218
     604:	b1 07       	cpc	r27, r17
     606:	d9 f7       	brne	.-10     	; 0x5fe <__do_copy_data+0x10>
     608:	1b be       	out	0x3b, r1	; 59

0000060a <__do_clear_bss>:
     60a:	21 e3       	ldi	r18, 0x31	; 49
     60c:	aa ed       	ldi	r26, 0xDA	; 218
     60e:	b0 e2       	ldi	r27, 0x20	; 32
     610:	01 c0       	rjmp	.+2      	; 0x614 <.do_clear_bss_start>

00000612 <.do_clear_bss_loop>:
     612:	1d 92       	st	X+, r1

00000614 <.do_clear_bss_start>:
     614:	a8 3a       	cpi	r26, 0xA8	; 168
     616:	b2 07       	cpc	r27, r18
     618:	e1 f7       	brne	.-8      	; 0x612 <.do_clear_bss_loop>

0000061a <__do_global_ctors>:
     61a:	12 e0       	ldi	r17, 0x02	; 2
     61c:	cb ee       	ldi	r28, 0xEB	; 235
     61e:	d2 e0       	ldi	r29, 0x02	; 2
     620:	00 e0       	ldi	r16, 0x00	; 0
     622:	06 c0       	rjmp	.+12     	; 0x630 <__do_global_ctors+0x16>
     624:	21 97       	sbiw	r28, 0x01	; 1
     626:	01 09       	sbc	r16, r1
     628:	80 2f       	mov	r24, r16
     62a:	fe 01       	movw	r30, r28
     62c:	0e 94 06 20 	call	0x400c	; 0x400c <__tablejump2__>
     630:	ca 3e       	cpi	r28, 0xEA	; 234
     632:	d1 07       	cpc	r29, r17
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	08 07       	cpc	r16, r24
     638:	a9 f7       	brne	.-22     	; 0x624 <__do_global_ctors+0xa>
     63a:	0e 94 b6 1e 	call	0x3d6c	; 0x3d6c <main>
     63e:	0c 94 aa 20 	jmp	0x4154	; 0x4154 <_exit>

00000642 <__bad_interrupt>:
     642:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000646 <_ZN9I2CMaster11Transmitter10StartState7executeERh>:
	}
	else
	{
		return false;
	}
}
     646:	cf 93       	push	r28
     648:	df 93       	push	r29
     64a:	fc 01       	movw	r30, r24
     64c:	a6 81       	ldd	r26, Z+6	; 0x06
     64e:	b7 81       	ldd	r27, Z+7	; 0x07
     650:	eb 01       	movw	r28, r22
     652:	98 81       	ld	r25, Y
     654:	99 0f       	add	r25, r25
     656:	16 96       	adiw	r26, 0x06	; 6
     658:	9c 93       	st	X, r25
     65a:	82 81       	ldd	r24, Z+2	; 0x02
     65c:	93 81       	ldd	r25, Z+3	; 0x03
     65e:	df 91       	pop	r29
     660:	cf 91       	pop	r28
     662:	08 95       	ret

00000664 <_ZN9I2CMaster11Transmitter11StatusState7executeERh>:
     664:	cf 93       	push	r28
     666:	df 93       	push	r29
     668:	1f 92       	push	r1
     66a:	1f 92       	push	r1
     66c:	cd b7       	in	r28, 0x3d	; 61
     66e:	de b7       	in	r29, 0x3e	; 62
     670:	dc 01       	movw	r26, r24
     672:	18 96       	adiw	r26, 0x08	; 8
     674:	8d 91       	ld	r24, X+
     676:	9c 91       	ld	r25, X
     678:	19 97       	sbiw	r26, 0x09	; 9
     67a:	89 83       	std	Y+1, r24	; 0x01
     67c:	9a 83       	std	Y+2, r25	; 0x02
     67e:	29 81       	ldd	r18, Y+1	; 0x01
     680:	3a 81       	ldd	r19, Y+2	; 0x02
     682:	21 50       	subi	r18, 0x01	; 1
     684:	31 09       	sbc	r19, r1
     686:	29 83       	std	Y+1, r18	; 0x01
     688:	3a 83       	std	Y+2, r19	; 0x02
     68a:	23 2b       	or	r18, r19
     68c:	91 f0       	breq	.+36     	; 0x6b2 <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x4e>
     68e:	16 96       	adiw	r26, 0x06	; 6
     690:	ed 91       	ld	r30, X+
     692:	fc 91       	ld	r31, X
     694:	17 97       	sbiw	r26, 0x07	; 7
     696:	94 81       	ldd	r25, Z+4	; 0x04
     698:	94 fd       	sbrc	r25, 4
     69a:	f1 cf       	rjmp	.-30     	; 0x67e <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x1a>
     69c:	0a c0       	rjmp	.+20     	; 0x6b2 <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x4e>
     69e:	14 96       	adiw	r26, 0x04	; 4
     6a0:	8d 91       	ld	r24, X+
     6a2:	9c 91       	ld	r25, X
     6a4:	15 97       	sbiw	r26, 0x05	; 5
     6a6:	0a c0       	rjmp	.+20     	; 0x6bc <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x58>
     6a8:	12 96       	adiw	r26, 0x02	; 2
     6aa:	8d 91       	ld	r24, X+
     6ac:	9c 91       	ld	r25, X
     6ae:	13 97       	sbiw	r26, 0x03	; 3
     6b0:	05 c0       	rjmp	.+10     	; 0x6bc <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x58>
     6b2:	29 81       	ldd	r18, Y+1	; 0x01
     6b4:	3a 81       	ldd	r19, Y+2	; 0x02
     6b6:	23 2b       	or	r18, r19
     6b8:	b9 f7       	brne	.-18     	; 0x6a8 <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x44>
     6ba:	f1 cf       	rjmp	.-30     	; 0x69e <_ZN9I2CMaster11Transmitter11StatusState7executeERh+0x3a>
     6bc:	0f 90       	pop	r0
     6be:	0f 90       	pop	r0
     6c0:	df 91       	pop	r29
     6c2:	cf 91       	pop	r28
     6c4:	08 95       	ret

000006c6 <_ZN9I2CMaster11Transmitter9DoneState7executeERh>:
     6c6:	fc 01       	movw	r30, r24
     6c8:	82 81       	ldd	r24, Z+2	; 0x02
     6ca:	93 81       	ldd	r25, Z+3	; 0x03
     6cc:	08 95       	ret

000006ce <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     6ce:	0f 93       	push	r16
     6d0:	1f 93       	push	r17
     6d2:	cf 93       	push	r28
     6d4:	df 93       	push	r29
     6d6:	ec 01       	movw	r28, r24
     6d8:	8b 01       	movw	r16, r22
     6da:	80 e1       	ldi	r24, 0x10	; 16
     6dc:	97 e2       	ldi	r25, 0x27	; 39
     6de:	8d 87       	std	Y+13, r24	; 0x0d
     6e0:	9e 87       	std	Y+14, r25	; 0x0e
     6e2:	88 e0       	ldi	r24, 0x08	; 8
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
     6ea:	2a e0       	ldi	r18, 0x0A	; 10
     6ec:	30 e2       	ldi	r19, 0x20	; 32
     6ee:	fc 01       	movw	r30, r24
     6f0:	20 83       	st	Z, r18
     6f2:	31 83       	std	Z+1, r19	; 0x01
     6f4:	06 83       	std	Z+6, r16	; 0x06
     6f6:	17 83       	std	Z+7, r17	; 0x07
     6f8:	8a 83       	std	Y+2, r24	; 0x02
     6fa:	9b 83       	std	Y+3, r25	; 0x03
     6fc:	8a e0       	ldi	r24, 0x0A	; 10
     6fe:	90 e0       	ldi	r25, 0x00	; 0
     700:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
     704:	fc 01       	movw	r30, r24
     706:	8d 85       	ldd	r24, Y+13	; 0x0d
     708:	9e 85       	ldd	r25, Y+14	; 0x0e
     70a:	20 e1       	ldi	r18, 0x10	; 16
     70c:	30 e2       	ldi	r19, 0x20	; 32
     70e:	20 83       	st	Z, r18
     710:	31 83       	std	Z+1, r19	; 0x01
     712:	06 83       	std	Z+6, r16	; 0x06
     714:	17 83       	std	Z+7, r17	; 0x07
     716:	80 87       	std	Z+8, r24	; 0x08
     718:	91 87       	std	Z+9, r25	; 0x09
     71a:	ec 83       	std	Y+4, r30	; 0x04
     71c:	fd 83       	std	Y+5, r31	; 0x05
     71e:	88 e0       	ldi	r24, 0x08	; 8
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
     726:	26 e1       	ldi	r18, 0x16	; 22
     728:	30 e2       	ldi	r19, 0x20	; 32
     72a:	fc 01       	movw	r30, r24
     72c:	20 83       	st	Z, r18
     72e:	31 83       	std	Z+1, r19	; 0x01
     730:	06 83       	std	Z+6, r16	; 0x06
     732:	17 83       	std	Z+7, r17	; 0x07
     734:	88 87       	std	Y+8, r24	; 0x08
     736:	99 87       	std	Y+9, r25	; 0x09
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	08 95       	ret

00000742 <_ZN9I2CMaster12set_baudrateEm>:
     742:	cf 93       	push	r28
     744:	df 93       	push	r29
     746:	ec 01       	movw	r28, r24
     748:	9a 01       	movw	r18, r20
     74a:	ab 01       	movw	r20, r22
     74c:	22 0f       	add	r18, r18
     74e:	33 1f       	adc	r19, r19
     750:	44 1f       	adc	r20, r20
     752:	55 1f       	adc	r21, r21
     754:	60 e0       	ldi	r22, 0x00	; 0
     756:	78 e4       	ldi	r23, 0x48	; 72
     758:	88 ee       	ldi	r24, 0xE8	; 232
     75a:	91 e0       	ldi	r25, 0x01	; 1
     75c:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
     760:	25 50       	subi	r18, 0x05	; 5
     762:	2c 83       	std	Y+4, r18	; 0x04
     764:	e8 81       	ld	r30, Y
     766:	f9 81       	ldd	r31, Y+1	; 0x01
     768:	25 83       	std	Z+5, r18	; 0x05
     76a:	df 91       	pop	r29
     76c:	cf 91       	pop	r28
     76e:	08 95       	ret

00000770 <_ZN9I2CMasterC1EP10TWI_structm>:
     770:	af 92       	push	r10
     772:	bf 92       	push	r11
     774:	cf 92       	push	r12
     776:	df 92       	push	r13
     778:	ef 92       	push	r14
     77a:	ff 92       	push	r15
     77c:	0f 93       	push	r16
     77e:	1f 93       	push	r17
     780:	cf 93       	push	r28
     782:	df 93       	push	r29
     784:	8c 01       	movw	r16, r24
     786:	eb 01       	movw	r28, r22
     788:	69 01       	movw	r12, r18
     78a:	7a 01       	movw	r14, r20
     78c:	dc 01       	movw	r26, r24
     78e:	6d 93       	st	X+, r22
     790:	7c 93       	st	X, r23
     792:	fc 01       	movw	r30, r24
     794:	25 83       	std	Z+5, r18	; 0x05
     796:	36 83       	std	Z+6, r19	; 0x06
     798:	47 83       	std	Z+7, r20	; 0x07
     79a:	50 87       	std	Z+8, r21	; 0x08
     79c:	8f e0       	ldi	r24, 0x0F	; 15
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
     7a4:	5c 01       	movw	r10, r24
     7a6:	be 01       	movw	r22, r28
     7a8:	0e 94 67 03 	call	0x6ce	; 0x6ce <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     7ac:	d8 01       	movw	r26, r16
     7ae:	53 96       	adiw	r26, 0x13	; 19
     7b0:	ad 92       	st	X+, r10
     7b2:	bc 92       	st	X, r11
     7b4:	54 97       	sbiw	r26, 0x14	; 20
     7b6:	c0 38       	cpi	r28, 0x80	; 128
     7b8:	b4 e0       	ldi	r27, 0x04	; 4
     7ba:	db 07       	cpc	r29, r27
     7bc:	31 f4       	brne	.+12     	; 0x7ca <_ZN9I2CMasterC1EP10TWI_structm+0x5a>
     7be:	80 e4       	ldi	r24, 0x40	; 64
     7c0:	96 e0       	ldi	r25, 0x06	; 6
     7c2:	f8 01       	movw	r30, r16
     7c4:	82 83       	std	Z+2, r24	; 0x02
     7c6:	93 83       	std	Z+3, r25	; 0x03
     7c8:	0b c0       	rjmp	.+22     	; 0x7e0 <_ZN9I2CMasterC1EP10TWI_structm+0x70>
     7ca:	c0 3a       	cpi	r28, 0xA0	; 160
     7cc:	f4 e0       	ldi	r31, 0x04	; 4
     7ce:	df 07       	cpc	r29, r31
     7d0:	39 f4       	brne	.+14     	; 0x7e0 <_ZN9I2CMasterC1EP10TWI_structm+0x70>
     7d2:	80 e8       	ldi	r24, 0x80	; 128
     7d4:	96 e0       	ldi	r25, 0x06	; 6
     7d6:	d8 01       	movw	r26, r16
     7d8:	12 96       	adiw	r26, 0x02	; 2
     7da:	8d 93       	st	X+, r24
     7dc:	9c 93       	st	X, r25
     7de:	13 97       	sbiw	r26, 0x03	; 3
     7e0:	d8 01       	movw	r26, r16
     7e2:	12 96       	adiw	r26, 0x02	; 2
     7e4:	ed 91       	ld	r30, X+
     7e6:	fc 91       	ld	r31, X
     7e8:	13 97       	sbiw	r26, 0x03	; 3
     7ea:	83 e0       	ldi	r24, 0x03	; 3
     7ec:	81 83       	std	Z+1, r24	; 0x01
     7ee:	12 96       	adiw	r26, 0x02	; 2
     7f0:	ed 91       	ld	r30, X+
     7f2:	fc 91       	ld	r31, X
     7f4:	13 97       	sbiw	r26, 0x03	; 3
     7f6:	88 e3       	ldi	r24, 0x38	; 56
     7f8:	80 8b       	std	Z+16, r24	; 0x10
     7fa:	12 96       	adiw	r26, 0x02	; 2
     7fc:	ed 91       	ld	r30, X+
     7fe:	fc 91       	ld	r31, X
     800:	13 97       	sbiw	r26, 0x03	; 3
     802:	81 8b       	std	Z+17, r24	; 0x11
     804:	82 e0       	ldi	r24, 0x02	; 2
     806:	8a 83       	std	Y+2, r24	; 0x02
     808:	b7 01       	movw	r22, r14
     80a:	a6 01       	movw	r20, r12
     80c:	c8 01       	movw	r24, r16
     80e:	0e 94 a1 03 	call	0x742	; 0x742 <_ZN9I2CMaster12set_baudrateEm>
     812:	8c 81       	ldd	r24, Y+4	; 0x04
     814:	8d 6c       	ori	r24, 0xCD	; 205
     816:	8c 83       	std	Y+4, r24	; 0x04
     818:	88 e0       	ldi	r24, 0x08	; 8
     81a:	89 83       	std	Y+1, r24	; 0x01
     81c:	df 91       	pop	r29
     81e:	cf 91       	pop	r28
     820:	1f 91       	pop	r17
     822:	0f 91       	pop	r16
     824:	ff 90       	pop	r15
     826:	ef 90       	pop	r14
     828:	df 90       	pop	r13
     82a:	cf 90       	pop	r12
     82c:	bf 90       	pop	r11
     82e:	af 90       	pop	r10
     830:	08 95       	ret

00000832 <_ZN9I2CMaster5writeEhPhhj>:
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	1f 92       	push	r1
     83c:	1f 92       	push	r1
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	dc 01       	movw	r26, r24
     844:	09 83       	std	Y+1, r16	; 0x01
     846:	1a 83       	std	Y+2, r17	; 0x02
     848:	ed 91       	ld	r30, X+
     84a:	fc 91       	ld	r31, X
     84c:	11 97       	sbiw	r26, 0x01	; 1
     84e:	66 0f       	add	r22, r22
     850:	66 83       	std	Z+6, r22	; 0x06
     852:	89 81       	ldd	r24, Y+1	; 0x01
     854:	9a 81       	ldd	r25, Y+2	; 0x02
     856:	01 97       	sbiw	r24, 0x01	; 1
     858:	89 83       	std	Y+1, r24	; 0x01
     85a:	9a 83       	std	Y+2, r25	; 0x02
     85c:	89 2b       	or	r24, r25
     85e:	d1 f1       	breq	.+116    	; 0x8d4 <_ZN9I2CMaster5writeEhPhhj+0xa2>
     860:	ed 91       	ld	r30, X+
     862:	fc 91       	ld	r31, X
     864:	11 97       	sbiw	r26, 0x01	; 1
     866:	84 81       	ldd	r24, Z+4	; 0x04
     868:	86 ff       	sbrs	r24, 6
     86a:	f3 cf       	rjmp	.-26     	; 0x852 <_ZN9I2CMaster5writeEhPhhj+0x20>
     86c:	33 c0       	rjmp	.+102    	; 0x8d4 <_ZN9I2CMaster5writeEhPhhj+0xa2>
     86e:	22 23       	and	r18, r18
     870:	49 f1       	breq	.+82     	; 0x8c4 <_ZN9I2CMaster5writeEhPhhj+0x92>
     872:	ba 01       	movw	r22, r20
     874:	21 50       	subi	r18, 0x01	; 1
     876:	82 2f       	mov	r24, r18
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	01 96       	adiw	r24, 0x01	; 1
     87c:	48 0f       	add	r20, r24
     87e:	59 1f       	adc	r21, r25
     880:	09 83       	std	Y+1, r16	; 0x01
     882:	1a 83       	std	Y+2, r17	; 0x02
     884:	2d 91       	ld	r18, X+
     886:	3c 91       	ld	r19, X
     888:	11 97       	sbiw	r26, 0x01	; 1
     88a:	fb 01       	movw	r30, r22
     88c:	81 91       	ld	r24, Z+
     88e:	bf 01       	movw	r22, r30
     890:	f9 01       	movw	r30, r18
     892:	87 83       	std	Z+7, r24	; 0x07
     894:	29 81       	ldd	r18, Y+1	; 0x01
     896:	3a 81       	ldd	r19, Y+2	; 0x02
     898:	21 50       	subi	r18, 0x01	; 1
     89a:	31 09       	sbc	r19, r1
     89c:	29 83       	std	Y+1, r18	; 0x01
     89e:	3a 83       	std	Y+2, r19	; 0x02
     8a0:	23 2b       	or	r18, r19
     8a2:	f1 f0       	breq	.+60     	; 0x8e0 <_ZN9I2CMaster5writeEhPhhj+0xae>
     8a4:	ed 91       	ld	r30, X+
     8a6:	fc 91       	ld	r31, X
     8a8:	11 97       	sbiw	r26, 0x01	; 1
     8aa:	94 81       	ldd	r25, Z+4	; 0x04
     8ac:	94 fd       	sbrc	r25, 4
     8ae:	f2 cf       	rjmp	.-28     	; 0x894 <_ZN9I2CMaster5writeEhPhhj+0x62>
     8b0:	17 c0       	rjmp	.+46     	; 0x8e0 <_ZN9I2CMaster5writeEhPhhj+0xae>
     8b2:	ed 91       	ld	r30, X+
     8b4:	fc 91       	ld	r31, X
     8b6:	11 97       	sbiw	r26, 0x01	; 1
     8b8:	84 81       	ldd	r24, Z+4	; 0x04
     8ba:	80 64       	ori	r24, 0x40	; 64
     8bc:	84 83       	std	Z+4, r24	; 0x04
     8be:	46 17       	cp	r20, r22
     8c0:	57 07       	cpc	r21, r23
     8c2:	f1 f6       	brne	.-68     	; 0x880 <_ZN9I2CMaster5writeEhPhhj+0x4e>
     8c4:	ed 91       	ld	r30, X+
     8c6:	fc 91       	ld	r31, X
     8c8:	83 e0       	ldi	r24, 0x03	; 3
     8ca:	83 83       	std	Z+3, r24	; 0x03
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	0d c0       	rjmp	.+26     	; 0x8ea <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8d0:	80 e0       	ldi	r24, 0x00	; 0
     8d2:	0b c0       	rjmp	.+22     	; 0x8ea <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8d4:	89 81       	ldd	r24, Y+1	; 0x01
     8d6:	9a 81       	ldd	r25, Y+2	; 0x02
     8d8:	89 2b       	or	r24, r25
     8da:	49 f6       	brne	.-110    	; 0x86e <_ZN9I2CMaster5writeEhPhhj+0x3c>
     8dc:	80 e0       	ldi	r24, 0x00	; 0
     8de:	05 c0       	rjmp	.+10     	; 0x8ea <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8e0:	29 81       	ldd	r18, Y+1	; 0x01
     8e2:	3a 81       	ldd	r19, Y+2	; 0x02
     8e4:	23 2b       	or	r18, r19
     8e6:	29 f7       	brne	.-54     	; 0x8b2 <_ZN9I2CMaster5writeEhPhhj+0x80>
     8e8:	f3 cf       	rjmp	.-26     	; 0x8d0 <_ZN9I2CMaster5writeEhPhhj+0x9e>
     8ea:	0f 90       	pop	r0
     8ec:	0f 90       	pop	r0
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	08 95       	ret

000008f8 <_ZN9I2CMaster4readEhPhhj>:

bool I2CMaster::read (uint8_t slave_addr, uint8_t* data, uint8_t packet_len, uint16_t timeout)
{
     8f8:	0f 93       	push	r16
     8fa:	1f 93       	push	r17
     8fc:	cf 93       	push	r28
     8fe:	df 93       	push	r29
     900:	00 d0       	rcall	.+0      	; 0x902 <_ZN9I2CMaster4readEhPhhj+0xa>
     902:	cd b7       	in	r28, 0x3d	; 61
     904:	de b7       	in	r29, 0x3e	; 62
     906:	dc 01       	movw	r26, r24
	volatile uint16_t counter;
	volatile uint8_t i;
	counter = timeout;
     908:	09 83       	std	Y+1, r16	; 0x01
     90a:	1a 83       	std	Y+2, r17	; 0x02
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
     90c:	ed 91       	ld	r30, X+
     90e:	fc 91       	ld	r31, X
     910:	11 97       	sbiw	r26, 0x01	; 1
     912:	66 0f       	add	r22, r22
     914:	61 60       	ori	r22, 0x01	; 1
     916:	66 83       	std	Z+6, r22	; 0x06
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
     918:	89 81       	ldd	r24, Y+1	; 0x01
     91a:	9a 81       	ldd	r25, Y+2	; 0x02
     91c:	01 97       	sbiw	r24, 0x01	; 1
     91e:	89 83       	std	Y+1, r24	; 0x01
     920:	9a 83       	std	Y+2, r25	; 0x02
     922:	89 2b       	or	r24, r25
     924:	09 f4       	brne	.+2      	; 0x928 <_ZN9I2CMaster4readEhPhhj+0x30>
     926:	47 c0       	rjmp	.+142    	; 0x9b6 <_ZN9I2CMaster4readEhPhhj+0xbe>
     928:	ed 91       	ld	r30, X+
     92a:	fc 91       	ld	r31, X
     92c:	11 97       	sbiw	r26, 0x01	; 1
     92e:	84 81       	ldd	r24, Z+4	; 0x04
     930:	88 23       	and	r24, r24
     932:	94 f7       	brge	.-28     	; 0x918 <_ZN9I2CMaster4readEhPhhj+0x20>
     934:	40 c0       	rjmp	.+128    	; 0x9b6 <_ZN9I2CMaster4readEhPhhj+0xbe>
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     936:	1b 82       	std	Y+3, r1	; 0x03
     938:	8b 81       	ldd	r24, Y+3	; 0x03
     93a:	82 17       	cp	r24, r18
     93c:	d8 f5       	brcc	.+118    	; 0x9b4 <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     93e:	32 e0       	ldi	r19, 0x02	; 2
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
     940:	09 83       	std	Y+1, r16	; 0x01
     942:	1a 83       	std	Y+2, r17	; 0x02
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
     944:	69 81       	ldd	r22, Y+1	; 0x01
     946:	7a 81       	ldd	r23, Y+2	; 0x02
     948:	61 50       	subi	r22, 0x01	; 1
     94a:	71 09       	sbc	r23, r1
     94c:	69 83       	std	Y+1, r22	; 0x01
     94e:	7a 83       	std	Y+2, r23	; 0x02
     950:	67 2b       	or	r22, r23
     952:	c1 f1       	breq	.+112    	; 0x9c4 <_ZN9I2CMaster4readEhPhhj+0xcc>
     954:	ed 91       	ld	r30, X+
     956:	fc 91       	ld	r31, X
     958:	11 97       	sbiw	r26, 0x01	; 1
     95a:	94 81       	ldd	r25, Z+4	; 0x04
     95c:	99 23       	and	r25, r25
     95e:	94 f7       	brge	.-28     	; 0x944 <_ZN9I2CMaster4readEhPhhj+0x4c>
     960:	31 c0       	rjmp	.+98     	; 0x9c4 <_ZN9I2CMaster4readEhPhhj+0xcc>
			if (counter != 0)
			{
				data[i] = interface->MASTER.DATA;
     962:	9b 81       	ldd	r25, Y+3	; 0x03
     964:	ed 91       	ld	r30, X+
     966:	fc 91       	ld	r31, X
     968:	11 97       	sbiw	r26, 0x01	; 1
     96a:	87 81       	ldd	r24, Z+7	; 0x07
     96c:	fa 01       	movw	r30, r20
     96e:	e9 0f       	add	r30, r25
     970:	f1 1d       	adc	r31, r1
     972:	80 83       	st	Z, r24
				if (i < packet_len)
     974:	8b 81       	ldd	r24, Y+3	; 0x03
     976:	82 17       	cp	r24, r18
     978:	88 f4       	brcc	.+34     	; 0x99c <_ZN9I2CMaster4readEhPhhj+0xa4>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     97a:	ed 91       	ld	r30, X+
     97c:	fc 91       	ld	r31, X
     97e:	11 97       	sbiw	r26, 0x01	; 1
     980:	33 83       	std	Z+3, r19	; 0x03
			{
				data[i] = interface->MASTER.DATA;
				if (i < packet_len)
				{
					byte_recv();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     982:	ed 91       	ld	r30, X+
     984:	fc 91       	ld	r31, X
     986:	11 97       	sbiw	r26, 0x01	; 1
     988:	84 81       	ldd	r24, Z+4	; 0x04
     98a:	80 68       	ori	r24, 0x80	; 128
     98c:	84 83       	std	Z+4, r24	; 0x04
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     98e:	8b 81       	ldd	r24, Y+3	; 0x03
     990:	8f 5f       	subi	r24, 0xFF	; 255
     992:	8b 83       	std	Y+3, r24	; 0x03
     994:	8b 81       	ldd	r24, Y+3	; 0x03
     996:	82 17       	cp	r24, r18
     998:	98 f2       	brcs	.-90     	; 0x940 <_ZN9I2CMaster4readEhPhhj+0x48>
     99a:	0c c0       	rjmp	.+24     	; 0x9b4 <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
     99c:	ed 91       	ld	r30, X+
     99e:	fc 91       	ld	r31, X
     9a0:	11 97       	sbiw	r26, 0x01	; 1
     9a2:	87 e0       	ldi	r24, 0x07	; 7
     9a4:	83 83       	std	Z+3, r24	; 0x03
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
				}
				else
				{
					send_nack_stop();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     9a6:	ed 91       	ld	r30, X+
     9a8:	fc 91       	ld	r31, X
     9aa:	84 81       	ldd	r24, Z+4	; 0x04
     9ac:	80 68       	ori	r24, 0x80	; 128
     9ae:	84 83       	std	Z+4, r24	; 0x04
					return true;
     9b0:	81 e0       	ldi	r24, 0x01	; 1
     9b2:	0d c0       	rjmp	.+26     	; 0x9ce <_ZN9I2CMaster4readEhPhhj+0xd6>
	}
	else
	{
		return false;
	}
}
     9b4:	0c c0       	rjmp	.+24     	; 0x9ce <_ZN9I2CMaster4readEhPhhj+0xd6>
	counter = timeout;
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
     9b6:	89 81       	ldd	r24, Y+1	; 0x01
     9b8:	9a 81       	ldd	r25, Y+2	; 0x02
     9ba:	89 2b       	or	r24, r25
     9bc:	09 f0       	breq	.+2      	; 0x9c0 <_ZN9I2CMaster4readEhPhhj+0xc8>
     9be:	bb cf       	rjmp	.-138    	; 0x936 <_ZN9I2CMaster4readEhPhhj+0x3e>
			}		
		}
	}
	else
	{
		return false;
     9c0:	80 e0       	ldi	r24, 0x00	; 0
     9c2:	05 c0       	rjmp	.+10     	; 0x9ce <_ZN9I2CMaster4readEhPhhj+0xd6>
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
			if (counter != 0)
     9c4:	69 81       	ldd	r22, Y+1	; 0x01
     9c6:	7a 81       	ldd	r23, Y+2	; 0x02
     9c8:	67 2b       	or	r22, r23
     9ca:	59 f6       	brne	.-106    	; 0x962 <_ZN9I2CMaster4readEhPhhj+0x6a>
					return true;
				}
			}
			else
			{
				return false;
     9cc:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return false;
	}
}
     9ce:	23 96       	adiw	r28, 0x03	; 3
     9d0:	cd bf       	out	0x3d, r28	; 61
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	1f 91       	pop	r17
     9da:	0f 91       	pop	r16
     9dc:	08 95       	ret

000009de <_ZN6MB1202C1EP9I2CMaster>:
};

bool MB1202::is_ready (void)
{
	return i2c->is_ready(slave_addr);
};
     9de:	fc 01       	movw	r30, r24
     9e0:	60 83       	st	Z, r22
     9e2:	71 83       	std	Z+1, r23	; 0x01
     9e4:	14 82       	std	Z+4, r1	; 0x04
     9e6:	15 82       	std	Z+5, r1	; 0x05
     9e8:	16 82       	std	Z+6, r1	; 0x06
     9ea:	17 82       	std	Z+7, r1	; 0x07
     9ec:	10 86       	std	Z+8, r1	; 0x08
     9ee:	80 e7       	ldi	r24, 0x70	; 112
     9f0:	82 83       	std	Z+2, r24	; 0x02
     9f2:	81 e5       	ldi	r24, 0x51	; 81
     9f4:	83 83       	std	Z+3, r24	; 0x03
     9f6:	8a ea       	ldi	r24, 0xAA	; 170
     9f8:	84 83       	std	Z+4, r24	; 0x04
     9fa:	85 ea       	ldi	r24, 0xA5	; 165
     9fc:	85 83       	std	Z+5, r24	; 0x05
     9fe:	08 95       	ret

00000a00 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
     a00:	0f 93       	push	r16
     a02:	1f 93       	push	r17
	return i2c->write (slave_addr, range_cmd, 1);
     a04:	ac 01       	movw	r20, r24
     a06:	4d 5f       	subi	r20, 0xFD	; 253
     a08:	5f 4f       	sbci	r21, 0xFF	; 255
     a0a:	08 ee       	ldi	r16, 0xE8	; 232
     a0c:	13 e0       	ldi	r17, 0x03	; 3
     a0e:	21 e0       	ldi	r18, 0x01	; 1
     a10:	fc 01       	movw	r30, r24
     a12:	62 81       	ldd	r22, Z+2	; 0x02
     a14:	80 81       	ld	r24, Z
     a16:	91 81       	ldd	r25, Z+1	; 0x01
     a18:	0e 94 19 04 	call	0x832	; 0x832 <_ZN9I2CMaster5writeEhPhhj>
};
     a1c:	1f 91       	pop	r17
     a1e:	0f 91       	pop	r16
     a20:	08 95       	ret

00000a22 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     a22:	0f 93       	push	r16
     a24:	1f 93       	push	r17
     a26:	cf 93       	push	r28
     a28:	df 93       	push	r29
     a2a:	ec 01       	movw	r28, r24
	i2c->read (slave_addr, bytes_received, 2);
     a2c:	ac 01       	movw	r20, r24
     a2e:	49 5f       	subi	r20, 0xF9	; 249
     a30:	5f 4f       	sbci	r21, 0xFF	; 255
     a32:	08 ee       	ldi	r16, 0xE8	; 232
     a34:	13 e0       	ldi	r17, 0x03	; 3
     a36:	22 e0       	ldi	r18, 0x02	; 2
     a38:	6a 81       	ldd	r22, Y+2	; 0x02
     a3a:	88 81       	ld	r24, Y
     a3c:	99 81       	ldd	r25, Y+1	; 0x01
     a3e:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <_ZN9I2CMaster4readEhPhhj>
	range_reading = ((uint16_t) bytes_received[0] << 8) | ((uint16_t) bytes_received[1]);
     a42:	8f 81       	ldd	r24, Y+7	; 0x07
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	98 2f       	mov	r25, r24
     a48:	88 27       	eor	r24, r24
     a4a:	28 85       	ldd	r18, Y+8	; 0x08
     a4c:	82 2b       	or	r24, r18
     a4e:	89 87       	std	Y+9, r24	; 0x09
     a50:	9a 87       	std	Y+10, r25	; 0x0a
	return range_reading;
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	08 95       	ret

00000a5c <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     a5c:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     a5e:	8c 85       	ldd	r24, Y+12	; 0x0c
     a60:	88 23       	and	r24, r24
     a62:	19 f0       	breq	.+6      	; 0xa6a <_ZN10task_sonar3runEv+0xe>
     a64:	81 30       	cpi	r24, 0x01	; 1
     a66:	51 f0       	breq	.+20     	; 0xa7c <_ZN10task_sonar3runEv+0x20>
     a68:	25 c0       	rjmp	.+74     	; 0xab4 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     a6a:	8c 89       	ldd	r24, Y+20	; 0x14
     a6c:	9d 89       	ldd	r25, Y+21	; 0x15
     a6e:	0e 94 00 05 	call	0xa00	; 0xa00 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     a72:	61 e0       	ldi	r22, 0x01	; 1
     a74:	ce 01       	movw	r24, r28
     a76:	0e 94 39 13 	call	0x2672	; 0x2672 <_ZN8frt_task13transition_toEh>
			
			    break;
     a7a:	1c c0       	rjmp	.+56     	; 0xab4 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     a7c:	8c 89       	ldd	r24, Y+20	; 0x14
     a7e:	9d 89       	ldd	r25, Y+21	; 0x15
     a80:	0e 94 11 05 	call	0xa22	; 0xa22 <_ZN6MB120211get_readingEv>
     a84:	7c 01       	movw	r14, r24
     a86:	8a 8b       	std	Y+18, r24	; 0x12
     a88:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     a8a:	6a e0       	ldi	r22, 0x0A	; 10
     a8c:	8e 81       	ldd	r24, Y+6	; 0x06
     a8e:	9f 81       	ldd	r25, Y+7	; 0x07
     a90:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     a94:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     a96:	66 e1       	ldi	r22, 0x16	; 22
     a98:	73 e0       	ldi	r23, 0x03	; 3
     a9a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     a9e:	b7 01       	movw	r22, r14
     aa0:	c8 01       	movw	r24, r16
     aa2:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
     aa6:	66 e0       	ldi	r22, 0x06	; 6
     aa8:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     aac:	60 e0       	ldi	r22, 0x00	; 0
     aae:	ce 01       	movw	r24, r28
     ab0:	0e 94 39 13 	call	0x2672	; 0x2672 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     ab4:	8e 85       	ldd	r24, Y+14	; 0x0e
     ab6:	9f 85       	ldd	r25, Y+15	; 0x0f
     ab8:	a8 89       	ldd	r26, Y+16	; 0x10
     aba:	b9 89       	ldd	r27, Y+17	; 0x11
     abc:	01 96       	adiw	r24, 0x01	; 1
     abe:	a1 1d       	adc	r26, r1
     ac0:	b1 1d       	adc	r27, r1
     ac2:	8e 87       	std	Y+14, r24	; 0x0e
     ac4:	9f 87       	std	Y+15, r25	; 0x0f
     ac6:	a8 8b       	std	Y+16, r26	; 0x10
     ac8:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     aca:	64 ef       	ldi	r22, 0xF4	; 244
     acc:	71 e0       	ldi	r23, 0x01	; 1
     ace:	80 e0       	ldi	r24, 0x00	; 0
     ad0:	90 e0       	ldi	r25, 0x00	; 0
     ad2:	0e 94 0d 11 	call	0x221a	; 0x221a <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     ad6:	c3 cf       	rjmp	.-122    	; 0xa5e <_ZN10task_sonar3runEv+0x2>

00000ad8 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     ad8:	cf 92       	push	r12
     ada:	df 92       	push	r13
     adc:	ef 92       	push	r14
     ade:	ff 92       	push	r15
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	ec 01       	movw	r28, r24
     aea:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     aec:	0e 94 3d 13 	call	0x267a	; 0x267a <_ZN8frt_taskC1EPKchjP8emstream>
     af0:	8c e1       	ldi	r24, 0x1C	; 28
     af2:	90 e2       	ldi	r25, 0x20	; 32
     af4:	88 83       	st	Y, r24
     af6:	99 83       	std	Y+1, r25	; 0x01
     af8:	ec 8a       	std	Y+20, r14	; 0x14
     afa:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     afc:	ce 8a       	std	Y+22, r12	; 0x16
     afe:	df 8a       	std	Y+23, r13	; 0x17
}
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	ef 90       	pop	r14
     b0c:	df 90       	pop	r13
     b0e:	cf 90       	pop	r12
     b10:	08 95       	ret

00000b12 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b1c:	0e 94 3d 13 	call	0x267a	; 0x267a <_ZN8frt_taskC1EPKchjP8emstream>
     b20:	84 e2       	ldi	r24, 0x24	; 36
     b22:	90 e2       	ldi	r25, 0x20	; 32
     b24:	88 83       	st	Y, r24
     b26:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     b28:	df 91       	pop	r29
     b2a:	cf 91       	pop	r28
     b2c:	1f 91       	pop	r17
     b2e:	0f 91       	pop	r16
     b30:	08 95       	ret

00000b32 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     b32:	0f 93       	push	r16
     b34:	1f 93       	push	r17
     b36:	cf 93       	push	r28
     b38:	df 93       	push	r29
     b3a:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     b3c:	6a e0       	ldi	r22, 0x0A	; 10
     b3e:	8e 81       	ldd	r24, Y+6	; 0x06
     b40:	9f 81       	ldd	r25, Y+7	; 0x07
     b42:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     b46:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     b48:	61 e7       	ldi	r22, 0x71	; 113
     b4a:	74 e0       	ldi	r23, 0x04	; 4
     b4c:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     b50:	6a e0       	ldi	r22, 0x0A	; 10
     b52:	c8 01       	movw	r24, r16
     b54:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     b58:	8c 01       	movw	r16, r24
     b5a:	6b e6       	ldi	r22, 0x6B	; 107
     b5c:	74 e0       	ldi	r23, 0x04	; 4
     b5e:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     b62:	67 e0       	ldi	r22, 0x07	; 7
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     b6a:	6a e0       	ldi	r22, 0x0A	; 10
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	9f 81       	ldd	r25, Y+7	; 0x07
     b70:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     b74:	8c 01       	movw	r16, r24
     b76:	6c e4       	ldi	r22, 0x4C	; 76
     b78:	74 e0       	ldi	r23, 0x04	; 4
     b7a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     b7e:	6a e0       	ldi	r22, 0x0A	; 10
     b80:	c8 01       	movw	r24, r16
     b82:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     b86:	8c 01       	movw	r16, r24
     b88:	66 e4       	ldi	r22, 0x46	; 70
     b8a:	74 e0       	ldi	r23, 0x04	; 4
     b8c:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     b90:	66 e0       	ldi	r22, 0x06	; 6
     b92:	c8 01       	movw	r24, r16
     b94:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     b98:	6a e0       	ldi	r22, 0x0A	; 10
     b9a:	8e 81       	ldd	r24, Y+6	; 0x06
     b9c:	9f 81       	ldd	r25, Y+7	; 0x07
     b9e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     ba2:	8c 01       	movw	r16, r24
     ba4:	6f e2       	ldi	r22, 0x2F	; 47
     ba6:	74 e0       	ldi	r23, 0x04	; 4
     ba8:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     bac:	66 e0       	ldi	r22, 0x06	; 6
     bae:	c8 01       	movw	r24, r16
     bb0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     bb4:	6a e0       	ldi	r22, 0x0A	; 10
     bb6:	8e 81       	ldd	r24, Y+6	; 0x06
     bb8:	9f 81       	ldd	r25, Y+7	; 0x07
     bba:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     bbe:	8c 01       	movw	r16, r24
     bc0:	63 e1       	ldi	r22, 0x13	; 19
     bc2:	74 e0       	ldi	r23, 0x04	; 4
     bc4:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     bc8:	66 e0       	ldi	r22, 0x06	; 6
     bca:	c8 01       	movw	r24, r16
     bcc:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     bd0:	6a e0       	ldi	r22, 0x0A	; 10
     bd2:	8e 81       	ldd	r24, Y+6	; 0x06
     bd4:	9f 81       	ldd	r25, Y+7	; 0x07
     bd6:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     bda:	8c 01       	movw	r16, r24
     bdc:	6b ef       	ldi	r22, 0xFB	; 251
     bde:	73 e0       	ldi	r23, 0x03	; 3
     be0:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     be4:	66 e0       	ldi	r22, 0x06	; 6
     be6:	c8 01       	movw	r24, r16
     be8:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     bec:	6a e0       	ldi	r22, 0x0A	; 10
     bee:	8e 81       	ldd	r24, Y+6	; 0x06
     bf0:	9f 81       	ldd	r25, Y+7	; 0x07
     bf2:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     bf6:	8c 01       	movw	r16, r24
     bf8:	6a ed       	ldi	r22, 0xDA	; 218
     bfa:	73 e0       	ldi	r23, 0x03	; 3
     bfc:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     c00:	66 e0       	ldi	r22, 0x06	; 6
     c02:	c8 01       	movw	r24, r16
     c04:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     c08:	6a e0       	ldi	r22, 0x0A	; 10
     c0a:	8e 81       	ldd	r24, Y+6	; 0x06
     c0c:	9f 81       	ldd	r25, Y+7	; 0x07
     c0e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     c12:	8c 01       	movw	r16, r24
     c14:	63 eb       	ldi	r22, 0xB3	; 179
     c16:	73 e0       	ldi	r23, 0x03	; 3
     c18:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     c1c:	66 e0       	ldi	r22, 0x06	; 6
     c1e:	c8 01       	movw	r24, r16
     c20:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     c24:	6a e0       	ldi	r22, 0x0A	; 10
     c26:	8e 81       	ldd	r24, Y+6	; 0x06
     c28:	9f 81       	ldd	r25, Y+7	; 0x07
     c2a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     c2e:	8c 01       	movw	r16, r24
     c30:	65 e9       	ldi	r22, 0x95	; 149
     c32:	73 e0       	ldi	r23, 0x03	; 3
     c34:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     c38:	66 e0       	ldi	r22, 0x06	; 6
     c3a:	c8 01       	movw	r24, r16
     c3c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     c40:	6a e0       	ldi	r22, 0x0A	; 10
     c42:	8e 81       	ldd	r24, Y+6	; 0x06
     c44:	9f 81       	ldd	r25, Y+7	; 0x07
     c46:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     c4a:	8c 01       	movw	r16, r24
     c4c:	6a e7       	ldi	r22, 0x7A	; 122
     c4e:	73 e0       	ldi	r23, 0x03	; 3
     c50:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     c54:	66 e0       	ldi	r22, 0x06	; 6
     c56:	c8 01       	movw	r24, r16
     c58:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     c5c:	6a e0       	ldi	r22, 0x0A	; 10
     c5e:	8e 81       	ldd	r24, Y+6	; 0x06
     c60:	9f 81       	ldd	r25, Y+7	; 0x07
     c62:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     c66:	ec 01       	movw	r28, r24
     c68:	6b e6       	ldi	r22, 0x6B	; 107
     c6a:	73 e0       	ldi	r23, 0x03	; 3
     c6c:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     c70:	66 e0       	ldi	r22, 0x06	; 6
     c72:	ce 01       	movw	r24, r28
     c74:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	1f 91       	pop	r17
     c7e:	0f 91       	pop	r16
     c80:	08 95       	ret

00000c82 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     c82:	af 92       	push	r10
     c84:	bf 92       	push	r11
     c86:	cf 92       	push	r12
     c88:	df 92       	push	r13
     c8a:	ef 92       	push	r14
     c8c:	ff 92       	push	r15
     c8e:	0f 93       	push	r16
     c90:	1f 93       	push	r17
     c92:	cf 93       	push	r28
     c94:	df 93       	push	r29
     c96:	00 d0       	rcall	.+0      	; 0xc98 <_ZN9task_user11show_statusEv+0x16>
     c98:	00 d0       	rcall	.+0      	; 0xc9a <_ZN9task_user11show_statusEv+0x18>
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
     c9e:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     ca0:	19 82       	std	Y+1, r1	; 0x01
     ca2:	1a 82       	std	Y+2, r1	; 0x02
     ca4:	1b 82       	std	Y+3, r1	; 0x03
     ca6:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     ca8:	1d 82       	std	Y+5, r1	; 0x05
     caa:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     cac:	0e 94 c6 08 	call	0x118c	; 0x118c <xPortGetFreeHeapSize>
     cb0:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     cb2:	ce 01       	movw	r24, r28
     cb4:	01 96       	adiw	r24, 0x01	; 1
     cb6:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN10time_stamp10set_to_nowEv>
     cba:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     cbc:	66 e0       	ldi	r22, 0x06	; 6
     cbe:	f8 01       	movw	r30, r16
     cc0:	86 81       	ldd	r24, Z+6	; 0x06
     cc2:	97 81       	ldd	r25, Z+7	; 0x07
     cc4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     cc8:	6a e0       	ldi	r22, 0x0A	; 10
     cca:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     cce:	7c 01       	movw	r14, r24
     cd0:	6c e4       	ldi	r22, 0x4C	; 76
     cd2:	73 e0       	ldi	r23, 0x03	; 3
     cd4:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     cd8:	6a e0       	ldi	r22, 0x0A	; 10
     cda:	c7 01       	movw	r24, r14
     cdc:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     ce0:	7c 01       	movw	r14, r24
     ce2:	60 e4       	ldi	r22, 0x40	; 64
     ce4:	73 e0       	ldi	r23, 0x03	; 3
     ce6:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     cea:	66 e0       	ldi	r22, 0x06	; 6
     cec:	c7 01       	movw	r24, r14
     cee:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     cf2:	6a e0       	ldi	r22, 0x0A	; 10
     cf4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     cf8:	7c 01       	movw	r14, r24
     cfa:	69 e3       	ldi	r22, 0x39	; 57
     cfc:	73 e0       	ldi	r23, 0x03	; 3
     cfe:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     d02:	b5 01       	movw	r22, r10
     d04:	c7 01       	movw	r24, r14
     d06:	0e 94 92 16 	call	0x2d24	; 0x2d24 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     d0a:	6a e0       	ldi	r22, 0x0A	; 10
     d0c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     d10:	7c 01       	movw	r14, r24
     d12:	6b e2       	ldi	r22, 0x2B	; 43
     d14:	73 e0       	ldi	r23, 0x03	; 3
     d16:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     d1a:	b6 01       	movw	r22, r12
     d1c:	c7 01       	movw	r24, r14
     d1e:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
     d22:	6a e0       	ldi	r22, 0x0A	; 10
     d24:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     d28:	7c 01       	movw	r14, r24
     d2a:	69 e2       	ldi	r22, 0x29	; 41
     d2c:	73 e0       	ldi	r23, 0x03	; 3
     d2e:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     d32:	4f ef       	ldi	r20, 0xFF	; 255
     d34:	5f e0       	ldi	r21, 0x0F	; 15
     d36:	60 e0       	ldi	r22, 0x00	; 0
     d38:	70 e0       	ldi	r23, 0x00	; 0
     d3a:	c7 01       	movw	r24, r14
     d3c:	0e 94 1d 19 	call	0x323a	; 0x323a <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     d40:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     d44:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     d48:	6a e0       	ldi	r22, 0x0A	; 10
     d4a:	f8 01       	movw	r30, r16
     d4c:	86 81       	ldd	r24, Z+6	; 0x06
     d4e:	97 81       	ldd	r25, Z+7	; 0x07
     d50:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     d54:	7c 01       	movw	r14, r24
     d56:	6e e1       	ldi	r22, 0x1E	; 30
     d58:	73 e0       	ldi	r23, 0x03	; 3
     d5a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     d5e:	b6 01       	movw	r22, r12
     d60:	c7 01       	movw	r24, r14
     d62:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
     d66:	66 e0       	ldi	r22, 0x06	; 6
     d68:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     d6c:	66 e0       	ldi	r22, 0x06	; 6
     d6e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     d72:	f8 01       	movw	r30, r16
     d74:	86 81       	ldd	r24, Z+6	; 0x06
     d76:	97 81       	ldd	r25, Z+7	; 0x07
     d78:	0e 94 4b 15 	call	0x2a96	; 0x2a96 <_Z15print_task_listP8emstream>
}
     d7c:	26 96       	adiw	r28, 0x06	; 6
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	1f 91       	pop	r17
     d88:	0f 91       	pop	r16
     d8a:	ff 90       	pop	r15
     d8c:	ef 90       	pop	r14
     d8e:	df 90       	pop	r13
     d90:	cf 90       	pop	r12
     d92:	bf 90       	pop	r11
     d94:	af 90       	pop	r10
     d96:	08 95       	ret

00000d98 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	00 d0       	rcall	.+0      	; 0xd9e <_ZN9task_user3runEv+0x6>
     d9e:	00 d0       	rcall	.+0      	; 0xda0 <_ZN9task_user3runEv+0x8>
     da0:	cd b7       	in	r28, 0x3d	; 61
     da2:	de b7       	in	r29, 0x3e	; 62
     da4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     da6:	19 82       	std	Y+1, r1	; 0x01
     da8:	1a 82       	std	Y+2, r1	; 0x02
     daa:	1b 82       	std	Y+3, r1	; 0x03
     dac:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     dae:	1d 82       	std	Y+5, r1	; 0x05
     db0:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     db2:	6a e0       	ldi	r22, 0x0A	; 10
     db4:	dc 01       	movw	r26, r24
     db6:	16 96       	adiw	r26, 0x06	; 6
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	17 97       	sbiw	r26, 0x07	; 7
     dbe:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     dc2:	7c 01       	movw	r14, r24
     dc4:	6a eb       	ldi	r22, 0xBA	; 186
     dc6:	74 e0       	ldi	r23, 0x04	; 4
     dc8:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     dcc:	66 e0       	ldi	r22, 0x06	; 6
     dce:	c7 01       	movw	r24, r14
     dd0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     dd4:	f8 01       	movw	r30, r16
     dd6:	84 85       	ldd	r24, Z+12	; 0x0c
     dd8:	88 23       	and	r24, r24
     dda:	21 f0       	breq	.+8      	; 0xde4 <_ZN9task_user3runEv+0x4c>
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	09 f4       	brne	.+2      	; 0xde2 <_ZN9task_user3runEv+0x4a>
     de0:	5d c0       	rjmp	.+186    	; 0xe9c <_ZN9task_user3runEv+0x104>
     de2:	d8 c0       	rjmp	.+432    	; 0xf94 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     de4:	86 81       	ldd	r24, Z+6	; 0x06
     de6:	97 81       	ldd	r25, Z+7	; 0x07
     de8:	dc 01       	movw	r26, r24
     dea:	ed 91       	ld	r30, X+
     dec:	fc 91       	ld	r31, X
     dee:	04 80       	ldd	r0, Z+4	; 0x04
     df0:	f5 81       	ldd	r31, Z+5	; 0x05
     df2:	e0 2d       	mov	r30, r0
     df4:	19 95       	eicall
     df6:	88 23       	and	r24, r24
     df8:	a9 f1       	breq	.+106    	; 0xe64 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     dfa:	f8 01       	movw	r30, r16
     dfc:	86 81       	ldd	r24, Z+6	; 0x06
     dfe:	97 81       	ldd	r25, Z+7	; 0x07
     e00:	dc 01       	movw	r26, r24
     e02:	ed 91       	ld	r30, X+
     e04:	fc 91       	ld	r31, X
     e06:	06 80       	ldd	r0, Z+6	; 0x06
     e08:	f7 81       	ldd	r31, Z+7	; 0x07
     e0a:	e0 2d       	mov	r30, r0
     e0c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     e0e:	99 27       	eor	r25, r25
     e10:	81 30       	cpi	r24, 0x01	; 1
     e12:	91 05       	cpc	r25, r1
     e14:	f9 f0       	breq	.+62     	; 0xe54 <_ZN9task_user3runEv+0xbc>
     e16:	03 97       	sbiw	r24, 0x03	; 3
     e18:	09 f0       	breq	.+2      	; 0xe1c <_ZN9task_user3runEv+0x84>
     e1a:	d8 c0       	rjmp	.+432    	; 0xfcc <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     e1c:	6a e0       	ldi	r22, 0x0A	; 10
     e1e:	f8 01       	movw	r30, r16
     e20:	86 81       	ldd	r24, Z+6	; 0x06
     e22:	97 81       	ldd	r25, Z+7	; 0x07
     e24:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     e28:	8c 01       	movw	r16, r24
     e2a:	6c ea       	ldi	r22, 0xAC	; 172
     e2c:	74 e0       	ldi	r23, 0x04	; 4
     e2e:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     e32:	66 e0       	ldi	r22, 0x06	; 6
     e34:	c8 01       	movw	r24, r16
     e36:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     e3a:	93 e0       	ldi	r25, 0x03	; 3
     e3c:	88 ed       	ldi	r24, 0xD8	; 216
     e3e:	08 b6       	in	r0, 0x38	; 56
     e40:	18 be       	out	0x38, r1	; 56
     e42:	84 bf       	out	0x34, r24	; 52
     e44:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e48:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e4c:	81 fd       	sbrc	r24, 1
     e4e:	fc cf       	rjmp	.-8      	; 0xe48 <_ZN9task_user3runEv+0xb0>
     e50:	08 be       	out	0x38, r0	; 56
     e52:	ff cf       	rjmp	.-2      	; 0xe52 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     e54:	c8 01       	movw	r24, r16
     e56:	0e 94 99 05 	call	0xb32	; 0xb32 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     e5a:	61 e0       	ldi	r22, 0x01	; 1
     e5c:	c8 01       	movw	r24, r16
     e5e:	0e 94 39 13 	call	0x2672	; 0x2672 <_ZN8frt_task13transition_toEh>
							break;
     e62:	b4 c0       	rjmp	.+360    	; 0xfcc <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     e64:	86 e9       	ldi	r24, 0x96	; 150
     e66:	91 e3       	ldi	r25, 0x31	; 49
     e68:	0e 94 fa 15 	call	0x2bf4	; 0x2bf4 <_ZN14frt_text_queue14check_for_charEv>
     e6c:	88 23       	and	r24, r24
     e6e:	09 f4       	brne	.+2      	; 0xe72 <_ZN9task_user3runEv+0xda>
     e70:	ad c0       	rjmp	.+346    	; 0xfcc <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     e72:	d8 01       	movw	r26, r16
     e74:	16 96       	adiw	r26, 0x06	; 6
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	17 97       	sbiw	r26, 0x07	; 7
     e7c:	01 90       	ld	r0, Z+
     e7e:	f0 81       	ld	r31, Z
     e80:	e0 2d       	mov	r30, r0
     e82:	e2 80       	ldd	r14, Z+2	; 0x02
     e84:	f3 80       	ldd	r15, Z+3	; 0x03
     e86:	86 e9       	ldi	r24, 0x96	; 150
     e88:	91 e3       	ldi	r25, 0x31	; 49
     e8a:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <_ZN14frt_text_queue7getcharEv>
     e8e:	68 2f       	mov	r22, r24
     e90:	f8 01       	movw	r30, r16
     e92:	86 81       	ldd	r24, Z+6	; 0x06
     e94:	97 81       	ldd	r25, Z+7	; 0x07
     e96:	f7 01       	movw	r30, r14
     e98:	19 95       	eicall
     e9a:	98 c0       	rjmp	.+304    	; 0xfcc <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     e9c:	86 81       	ldd	r24, Z+6	; 0x06
     e9e:	97 81       	ldd	r25, Z+7	; 0x07
     ea0:	dc 01       	movw	r26, r24
     ea2:	ed 91       	ld	r30, X+
     ea4:	fc 91       	ld	r31, X
     ea6:	04 80       	ldd	r0, Z+4	; 0x04
     ea8:	f5 81       	ldd	r31, Z+5	; 0x05
     eaa:	e0 2d       	mov	r30, r0
     eac:	19 95       	eicall
     eae:	88 23       	and	r24, r24
     eb0:	09 f4       	brne	.+2      	; 0xeb4 <_ZN9task_user3runEv+0x11c>
     eb2:	8c c0       	rjmp	.+280    	; 0xfcc <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     eb4:	f8 01       	movw	r30, r16
     eb6:	86 81       	ldd	r24, Z+6	; 0x06
     eb8:	97 81       	ldd	r25, Z+7	; 0x07
     eba:	dc 01       	movw	r26, r24
     ebc:	ed 91       	ld	r30, X+
     ebe:	fc 91       	ld	r31, X
     ec0:	06 80       	ldd	r0, Z+6	; 0x06
     ec2:	f7 81       	ldd	r31, Z+7	; 0x07
     ec4:	e0 2d       	mov	r30, r0
     ec6:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     ec8:	9c 01       	movw	r18, r24
     eca:	33 27       	eor	r19, r19
     ecc:	28 36       	cpi	r18, 0x68	; 104
     ece:	31 05       	cpc	r19, r1
     ed0:	59 f1       	breq	.+86     	; 0xf28 <_ZN9task_user3runEv+0x190>
     ed2:	3c f4       	brge	.+14     	; 0xee2 <_ZN9task_user3runEv+0x14a>
     ed4:	2b 31       	cpi	r18, 0x1B	; 27
     ed6:	31 05       	cpc	r19, r1
     ed8:	59 f1       	breq	.+86     	; 0xf30 <_ZN9task_user3runEv+0x198>
     eda:	25 36       	cpi	r18, 0x65	; 101
     edc:	31 05       	cpc	r19, r1
     ede:	41 f1       	breq	.+80     	; 0xf30 <_ZN9task_user3runEv+0x198>
     ee0:	3b c0       	rjmp	.+118    	; 0xf58 <_ZN9task_user3runEv+0x1c0>
     ee2:	23 37       	cpi	r18, 0x73	; 115
     ee4:	31 05       	cpc	r19, r1
     ee6:	c1 f0       	breq	.+48     	; 0xf18 <_ZN9task_user3runEv+0x180>
     ee8:	26 37       	cpi	r18, 0x76	; 118
     eea:	31 05       	cpc	r19, r1
     eec:	89 f0       	breq	.+34     	; 0xf10 <_ZN9task_user3runEv+0x178>
     eee:	2e 36       	cpi	r18, 0x6E	; 110
     ef0:	31 05       	cpc	r19, r1
     ef2:	91 f5       	brne	.+100    	; 0xf58 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     ef4:	ce 01       	movw	r24, r28
     ef6:	01 96       	adiw	r24, 0x01	; 1
     ef8:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN10time_stamp10set_to_nowEv>
     efc:	bc 01       	movw	r22, r24
     efe:	f8 01       	movw	r30, r16
     f00:	86 81       	ldd	r24, Z+6	; 0x06
     f02:	97 81       	ldd	r25, Z+7	; 0x07
     f04:	0e 94 92 16 	call	0x2d24	; 0x2d24 <_ZlsR8emstreamR10time_stamp>
     f08:	66 e0       	ldi	r22, 0x06	; 6
     f0a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
							break;
     f0e:	5e c0       	rjmp	.+188    	; 0xfcc <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     f10:	c8 01       	movw	r24, r16
     f12:	0e 94 41 06 	call	0xc82	; 0xc82 <_ZN9task_user11show_statusEv>
							break;
     f16:	5a c0       	rjmp	.+180    	; 0xfcc <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     f18:	d8 01       	movw	r26, r16
     f1a:	16 96       	adiw	r26, 0x06	; 6
     f1c:	8d 91       	ld	r24, X+
     f1e:	9c 91       	ld	r25, X
     f20:	17 97       	sbiw	r26, 0x07	; 7
     f22:	0e 94 52 14 	call	0x28a4	; 0x28a4 <_Z17print_task_stacksP8emstream>
							break;
     f26:	52 c0       	rjmp	.+164    	; 0xfcc <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     f28:	c8 01       	movw	r24, r16
     f2a:	0e 94 99 05 	call	0xb32	; 0xb32 <_ZN9task_user18print_help_messageEv>
							break;
     f2e:	4e c0       	rjmp	.+156    	; 0xfcc <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     f30:	6a e0       	ldi	r22, 0x0A	; 10
     f32:	f8 01       	movw	r30, r16
     f34:	86 81       	ldd	r24, Z+6	; 0x06
     f36:	97 81       	ldd	r25, Z+7	; 0x07
     f38:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     f3c:	7c 01       	movw	r14, r24
     f3e:	6a e9       	ldi	r22, 0x9A	; 154
     f40:	74 e0       	ldi	r23, 0x04	; 4
     f42:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     f46:	66 e0       	ldi	r22, 0x06	; 6
     f48:	c7 01       	movw	r24, r14
     f4a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	c8 01       	movw	r24, r16
     f52:	0e 94 39 13 	call	0x2672	; 0x2672 <_ZN8frt_task13transition_toEh>
							break;
     f56:	3a c0       	rjmp	.+116    	; 0xfcc <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     f58:	f8 01       	movw	r30, r16
     f5a:	a6 81       	ldd	r26, Z+6	; 0x06
     f5c:	b7 81       	ldd	r27, Z+7	; 0x07
     f5e:	ed 91       	ld	r30, X+
     f60:	fc 91       	ld	r31, X
     f62:	11 97       	sbiw	r26, 0x01	; 1
     f64:	02 80       	ldd	r0, Z+2	; 0x02
     f66:	f3 81       	ldd	r31, Z+3	; 0x03
     f68:	e0 2d       	mov	r30, r0
     f6a:	68 2f       	mov	r22, r24
     f6c:	cd 01       	movw	r24, r26
     f6e:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     f70:	6a e0       	ldi	r22, 0x0A	; 10
     f72:	d8 01       	movw	r26, r16
     f74:	16 96       	adiw	r26, 0x06	; 6
     f76:	8d 91       	ld	r24, X+
     f78:	9c 91       	ld	r25, X
     f7a:	17 97       	sbiw	r26, 0x07	; 7
     f7c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     f80:	7c 01       	movw	r14, r24
     f82:	64 e9       	ldi	r22, 0x94	; 148
     f84:	74 e0       	ldi	r23, 0x04	; 4
     f86:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     f8a:	66 e0       	ldi	r22, 0x06	; 6
     f8c:	c7 01       	movw	r24, r14
     f8e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
							break;
     f92:	1c c0       	rjmp	.+56     	; 0xfcc <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     f94:	6a e0       	ldi	r22, 0x0A	; 10
     f96:	f8 01       	movw	r30, r16
     f98:	86 81       	ldd	r24, Z+6	; 0x06
     f9a:	97 81       	ldd	r25, Z+7	; 0x07
     f9c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
     fa0:	8c 01       	movw	r16, r24
     fa2:	67 e7       	ldi	r22, 0x77	; 119
     fa4:	74 e0       	ldi	r23, 0x04	; 4
     fa6:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
     faa:	66 e0       	ldi	r22, 0x06	; 6
     fac:	c8 01       	movw	r24, r16
     fae:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     fb2:	93 e0       	ldi	r25, 0x03	; 3
     fb4:	88 ed       	ldi	r24, 0xD8	; 216
     fb6:	08 b6       	in	r0, 0x38	; 56
     fb8:	18 be       	out	0x38, r1	; 56
     fba:	84 bf       	out	0x34, r24	; 52
     fbc:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     fc0:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     fc4:	81 fd       	sbrc	r24, 1
     fc6:	fc cf       	rjmp	.-8      	; 0xfc0 <_ZN9task_user3runEv+0x228>
     fc8:	08 be       	out	0x38, r0	; 56
     fca:	ff cf       	rjmp	.-2      	; 0xfca <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     fcc:	f8 01       	movw	r30, r16
     fce:	86 85       	ldd	r24, Z+14	; 0x0e
     fd0:	97 85       	ldd	r25, Z+15	; 0x0f
     fd2:	a0 89       	ldd	r26, Z+16	; 0x10
     fd4:	b1 89       	ldd	r27, Z+17	; 0x11
     fd6:	01 96       	adiw	r24, 0x01	; 1
     fd8:	a1 1d       	adc	r26, r1
     fda:	b1 1d       	adc	r27, r1
     fdc:	86 87       	std	Z+14, r24	; 0x0e
     fde:	97 87       	std	Z+15, r25	; 0x0f
     fe0:	a0 8b       	std	Z+16, r26	; 0x10
     fe2:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     fe4:	61 e0       	ldi	r22, 0x01	; 1
     fe6:	70 e0       	ldi	r23, 0x00	; 0
     fe8:	80 e0       	ldi	r24, 0x00	; 0
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	0e 94 0d 11 	call	0x221a	; 0x221a <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     ff0:	f1 ce       	rjmp	.-542    	; 0xdd4 <_ZN9task_user3runEv+0x3c>

00000ff2 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     ff2:	0f 93       	push	r16
     ff4:	1f 93       	push	r17
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     ffc:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1000:	80 91 da 20 	lds	r24, 0x20DA	; 0x8020da <__data_end>
    1004:	81 11       	cpse	r24, r1
    1006:	1d c0       	rjmp	.+58     	; 0x1042 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1008:	af ed       	ldi	r26, 0xDF	; 223
    100a:	b0 e2       	ldi	r27, 0x20	; 32
    100c:	e3 ee       	ldi	r30, 0xE3	; 227
    100e:	f0 e2       	ldi	r31, 0x20	; 32
    1010:	ed 93       	st	X+, r30
    1012:	fc 93       	st	X, r31
    1014:	11 97       	sbiw	r26, 0x01	; 1
    1016:	12 96       	adiw	r26, 0x02	; 2
    1018:	1d 92       	st	X+, r1
    101a:	1c 92       	st	X, r1
    101c:	13 97       	sbiw	r26, 0x03	; 3
    101e:	ab ed       	ldi	r26, 0xDB	; 219
    1020:	b0 e2       	ldi	r27, 0x20	; 32
    1022:	8f ef       	ldi	r24, 0xFF	; 255
    1024:	9f e0       	ldi	r25, 0x0F	; 15
    1026:	12 96       	adiw	r26, 0x02	; 2
    1028:	8d 93       	st	X+, r24
    102a:	9c 93       	st	X, r25
    102c:	13 97       	sbiw	r26, 0x03	; 3
    102e:	1d 92       	st	X+, r1
    1030:	1c 92       	st	X, r1
    1032:	11 97       	sbiw	r26, 0x01	; 1
    1034:	82 83       	std	Z+2, r24	; 0x02
    1036:	93 83       	std	Z+3, r25	; 0x03
    1038:	a0 83       	st	Z, r26
    103a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	80 93 da 20 	sts	0x20DA, r24	; 0x8020da <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1042:	20 97       	sbiw	r28, 0x00	; 0
    1044:	09 f4       	brne	.+2      	; 0x1048 <pvPortMalloc+0x56>
    1046:	5f c0       	rjmp	.+190    	; 0x1106 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1048:	9e 01       	movw	r18, r28
    104a:	2b 5f       	subi	r18, 0xFB	; 251
    104c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    104e:	24 96       	adiw	r28, 0x04	; 4
    1050:	ce 3f       	cpi	r28, 0xFE	; 254
    1052:	df 40       	sbci	r29, 0x0F	; 15
    1054:	08 f0       	brcs	.+2      	; 0x1058 <pvPortMalloc+0x66>
    1056:	5a c0       	rjmp	.+180    	; 0x110c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1058:	e0 91 df 20 	lds	r30, 0x20DF	; 0x8020df <xStart>
    105c:	f0 91 e0 20 	lds	r31, 0x20E0	; 0x8020e0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1060:	af ed       	ldi	r26, 0xDF	; 223
    1062:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1064:	02 c0       	rjmp	.+4      	; 0x106a <pvPortMalloc+0x78>
    1066:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1068:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    106a:	82 81       	ldd	r24, Z+2	; 0x02
    106c:	93 81       	ldd	r25, Z+3	; 0x03
    106e:	82 17       	cp	r24, r18
    1070:	93 07       	cpc	r25, r19
    1072:	20 f4       	brcc	.+8      	; 0x107c <pvPortMalloc+0x8a>
    1074:	80 81       	ld	r24, Z
    1076:	91 81       	ldd	r25, Z+1	; 0x01
    1078:	00 97       	sbiw	r24, 0x00	; 0
    107a:	a9 f7       	brne	.-22     	; 0x1066 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    107c:	c0 e2       	ldi	r28, 0x20	; 32
    107e:	eb 3d       	cpi	r30, 0xDB	; 219
    1080:	fc 07       	cpc	r31, r28
    1082:	09 f4       	brne	.+2      	; 0x1086 <pvPortMalloc+0x94>
    1084:	46 c0       	rjmp	.+140    	; 0x1112 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1086:	cd 91       	ld	r28, X+
    1088:	dc 91       	ld	r29, X
    108a:	11 97       	sbiw	r26, 0x01	; 1
    108c:	8e 01       	movw	r16, r28
    108e:	0b 5f       	subi	r16, 0xFB	; 251
    1090:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1092:	80 81       	ld	r24, Z
    1094:	91 81       	ldd	r25, Z+1	; 0x01
    1096:	8d 93       	st	X+, r24
    1098:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    109a:	82 81       	ldd	r24, Z+2	; 0x02
    109c:	93 81       	ldd	r25, Z+3	; 0x03
    109e:	82 1b       	sub	r24, r18
    10a0:	93 0b       	sbc	r25, r19
    10a2:	8b 30       	cpi	r24, 0x0B	; 11
    10a4:	91 05       	cpc	r25, r1
    10a6:	10 f1       	brcs	.+68     	; 0x10ec <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    10a8:	bf 01       	movw	r22, r30
    10aa:	62 0f       	add	r22, r18
    10ac:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    10ae:	db 01       	movw	r26, r22
    10b0:	12 96       	adiw	r26, 0x02	; 2
    10b2:	8d 93       	st	X+, r24
    10b4:	9c 93       	st	X, r25
    10b6:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    10b8:	22 83       	std	Z+2, r18	; 0x02
    10ba:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    10bc:	12 96       	adiw	r26, 0x02	; 2
    10be:	4d 91       	ld	r20, X+
    10c0:	5c 91       	ld	r21, X
    10c2:	13 97       	sbiw	r26, 0x03	; 3
    10c4:	8f ed       	ldi	r24, 0xDF	; 223
    10c6:	90 e2       	ldi	r25, 0x20	; 32
    10c8:	01 c0       	rjmp	.+2      	; 0x10cc <pvPortMalloc+0xda>
    10ca:	cd 01       	movw	r24, r26
    10cc:	ec 01       	movw	r28, r24
    10ce:	a8 81       	ld	r26, Y
    10d0:	b9 81       	ldd	r27, Y+1	; 0x01
    10d2:	12 96       	adiw	r26, 0x02	; 2
    10d4:	2d 91       	ld	r18, X+
    10d6:	3c 91       	ld	r19, X
    10d8:	13 97       	sbiw	r26, 0x03	; 3
    10da:	24 17       	cp	r18, r20
    10dc:	35 07       	cpc	r19, r21
    10de:	a8 f3       	brcs	.-22     	; 0x10ca <pvPortMalloc+0xd8>
    10e0:	eb 01       	movw	r28, r22
    10e2:	a8 83       	st	Y, r26
    10e4:	b9 83       	std	Y+1, r27	; 0x01
    10e6:	dc 01       	movw	r26, r24
    10e8:	6d 93       	st	X+, r22
    10ea:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    10ec:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    10f0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    10f4:	22 81       	ldd	r18, Z+2	; 0x02
    10f6:	33 81       	ldd	r19, Z+3	; 0x03
    10f8:	82 1b       	sub	r24, r18
    10fa:	93 0b       	sbc	r25, r19
    10fc:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1100:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1104:	08 c0       	rjmp	.+16     	; 0x1116 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1106:	00 e0       	ldi	r16, 0x00	; 0
    1108:	10 e0       	ldi	r17, 0x00	; 0
    110a:	05 c0       	rjmp	.+10     	; 0x1116 <pvPortMalloc+0x124>
    110c:	00 e0       	ldi	r16, 0x00	; 0
    110e:	10 e0       	ldi	r17, 0x00	; 0
    1110:	02 c0       	rjmp	.+4      	; 0x1116 <pvPortMalloc+0x124>
    1112:	00 e0       	ldi	r16, 0x00	; 0
    1114:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1116:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    111a:	c8 01       	movw	r24, r16
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	1f 91       	pop	r17
    1122:	0f 91       	pop	r16
    1124:	08 95       	ret

00001126 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1126:	0f 93       	push	r16
    1128:	1f 93       	push	r17
    112a:	cf 93       	push	r28
    112c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    112e:	00 97       	sbiw	r24, 0x00	; 0
    1130:	41 f1       	breq	.+80     	; 0x1182 <vPortFree+0x5c>
    1132:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1134:	8c 01       	movw	r16, r24
    1136:	05 50       	subi	r16, 0x05	; 5
    1138:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    113a:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    113e:	f8 01       	movw	r30, r16
    1140:	42 81       	ldd	r20, Z+2	; 0x02
    1142:	53 81       	ldd	r21, Z+3	; 0x03
    1144:	af ed       	ldi	r26, 0xDF	; 223
    1146:	b0 e2       	ldi	r27, 0x20	; 32
    1148:	01 c0       	rjmp	.+2      	; 0x114c <vPortFree+0x26>
    114a:	df 01       	movw	r26, r30
    114c:	ed 91       	ld	r30, X+
    114e:	fc 91       	ld	r31, X
    1150:	11 97       	sbiw	r26, 0x01	; 1
    1152:	22 81       	ldd	r18, Z+2	; 0x02
    1154:	33 81       	ldd	r19, Z+3	; 0x03
    1156:	24 17       	cp	r18, r20
    1158:	35 07       	cpc	r19, r21
    115a:	b8 f3       	brcs	.-18     	; 0x114a <vPortFree+0x24>
    115c:	25 97       	sbiw	r28, 0x05	; 5
    115e:	e8 83       	st	Y, r30
    1160:	f9 83       	std	Y+1, r31	; 0x01
    1162:	0d 93       	st	X+, r16
    1164:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1166:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    116a:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    116e:	8a 81       	ldd	r24, Y+2	; 0x02
    1170:	9b 81       	ldd	r25, Y+3	; 0x03
    1172:	82 0f       	add	r24, r18
    1174:	93 1f       	adc	r25, r19
    1176:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    117a:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    117e:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
	}
}
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	1f 91       	pop	r17
    1188:	0f 91       	pop	r16
    118a:	08 95       	ret

0000118c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    118c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1190:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1194:	08 95       	ret

00001196 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1196:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1198:	03 96       	adiw	r24, 0x03	; 3
    119a:	81 83       	std	Z+1, r24	; 0x01
    119c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    119e:	4f ef       	ldi	r20, 0xFF	; 255
    11a0:	5f ef       	ldi	r21, 0xFF	; 255
    11a2:	ba 01       	movw	r22, r20
    11a4:	43 83       	std	Z+3, r20	; 0x03
    11a6:	54 83       	std	Z+4, r21	; 0x04
    11a8:	65 83       	std	Z+5, r22	; 0x05
    11aa:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11ac:	87 83       	std	Z+7, r24	; 0x07
    11ae:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    11b0:	81 87       	std	Z+9, r24	; 0x09
    11b2:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    11b4:	10 82       	st	Z, r1
    11b6:	08 95       	ret

000011b8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    11b8:	fc 01       	movw	r30, r24
    11ba:	12 86       	std	Z+10, r1	; 0x0a
    11bc:	13 86       	std	Z+11, r1	; 0x0b
    11be:	08 95       	ret

000011c0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    11c0:	cf 93       	push	r28
    11c2:	df 93       	push	r29
    11c4:	fc 01       	movw	r30, r24
    11c6:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    11c8:	21 81       	ldd	r18, Z+1	; 0x01
    11ca:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    11cc:	e9 01       	movw	r28, r18
    11ce:	8c 81       	ldd	r24, Y+4	; 0x04
    11d0:	9d 81       	ldd	r25, Y+5	; 0x05
    11d2:	14 96       	adiw	r26, 0x04	; 4
    11d4:	8d 93       	st	X+, r24
    11d6:	9c 93       	st	X, r25
    11d8:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    11da:	81 81       	ldd	r24, Z+1	; 0x01
    11dc:	92 81       	ldd	r25, Z+2	; 0x02
    11de:	16 96       	adiw	r26, 0x06	; 6
    11e0:	8d 93       	st	X+, r24
    11e2:	9c 93       	st	X, r25
    11e4:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    11e6:	8c 81       	ldd	r24, Y+4	; 0x04
    11e8:	9d 81       	ldd	r25, Y+5	; 0x05
    11ea:	ec 01       	movw	r28, r24
    11ec:	6e 83       	std	Y+6, r22	; 0x06
    11ee:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    11f0:	e9 01       	movw	r28, r18
    11f2:	6c 83       	std	Y+4, r22	; 0x04
    11f4:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    11f6:	61 83       	std	Z+1, r22	; 0x01
    11f8:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    11fa:	1a 96       	adiw	r26, 0x0a	; 10
    11fc:	ed 93       	st	X+, r30
    11fe:	fc 93       	st	X, r31
    1200:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1202:	80 81       	ld	r24, Z
    1204:	8f 5f       	subi	r24, 0xFF	; 255
    1206:	80 83       	st	Z, r24
}
    1208:	df 91       	pop	r29
    120a:	cf 91       	pop	r28
    120c:	08 95       	ret

0000120e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    120e:	0f 93       	push	r16
    1210:	1f 93       	push	r17
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1218:	08 81       	ld	r16, Y
    121a:	19 81       	ldd	r17, Y+1	; 0x01
    121c:	2a 81       	ldd	r18, Y+2	; 0x02
    121e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1220:	0f 3f       	cpi	r16, 0xFF	; 255
    1222:	4f ef       	ldi	r20, 0xFF	; 255
    1224:	14 07       	cpc	r17, r20
    1226:	24 07       	cpc	r18, r20
    1228:	34 07       	cpc	r19, r20
    122a:	31 f4       	brne	.+12     	; 0x1238 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    122c:	dc 01       	movw	r26, r24
    122e:	19 96       	adiw	r26, 0x09	; 9
    1230:	ed 91       	ld	r30, X+
    1232:	fc 91       	ld	r31, X
    1234:	1a 97       	sbiw	r26, 0x0a	; 10
    1236:	1f c0       	rjmp	.+62     	; 0x1276 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1238:	fc 01       	movw	r30, r24
    123a:	33 96       	adiw	r30, 0x03	; 3
    123c:	dc 01       	movw	r26, r24
    123e:	17 96       	adiw	r26, 0x07	; 7
    1240:	4d 91       	ld	r20, X+
    1242:	5c 91       	ld	r21, X
    1244:	18 97       	sbiw	r26, 0x08	; 8
    1246:	da 01       	movw	r26, r20
    1248:	4d 91       	ld	r20, X+
    124a:	5d 91       	ld	r21, X+
    124c:	6d 91       	ld	r22, X+
    124e:	7c 91       	ld	r23, X
    1250:	04 17       	cp	r16, r20
    1252:	15 07       	cpc	r17, r21
    1254:	26 07       	cpc	r18, r22
    1256:	37 07       	cpc	r19, r23
    1258:	70 f0       	brcs	.+28     	; 0x1276 <vListInsert+0x68>
    125a:	04 80       	ldd	r0, Z+4	; 0x04
    125c:	f5 81       	ldd	r31, Z+5	; 0x05
    125e:	e0 2d       	mov	r30, r0
    1260:	a4 81       	ldd	r26, Z+4	; 0x04
    1262:	b5 81       	ldd	r27, Z+5	; 0x05
    1264:	4d 91       	ld	r20, X+
    1266:	5d 91       	ld	r21, X+
    1268:	6d 91       	ld	r22, X+
    126a:	7c 91       	ld	r23, X
    126c:	04 17       	cp	r16, r20
    126e:	15 07       	cpc	r17, r21
    1270:	26 07       	cpc	r18, r22
    1272:	37 07       	cpc	r19, r23
    1274:	90 f7       	brcc	.-28     	; 0x125a <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1276:	a4 81       	ldd	r26, Z+4	; 0x04
    1278:	b5 81       	ldd	r27, Z+5	; 0x05
    127a:	ac 83       	std	Y+4, r26	; 0x04
    127c:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    127e:	16 96       	adiw	r26, 0x06	; 6
    1280:	cd 93       	st	X+, r28
    1282:	dc 93       	st	X, r29
    1284:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1286:	ee 83       	std	Y+6, r30	; 0x06
    1288:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    128a:	c4 83       	std	Z+4, r28	; 0x04
    128c:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    128e:	8a 87       	std	Y+10, r24	; 0x0a
    1290:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1292:	fc 01       	movw	r30, r24
    1294:	20 81       	ld	r18, Z
    1296:	2f 5f       	subi	r18, 0xFF	; 255
    1298:	20 83       	st	Z, r18
}
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	1f 91       	pop	r17
    12a0:	0f 91       	pop	r16
    12a2:	08 95       	ret

000012a4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    12a4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    12a6:	a4 81       	ldd	r26, Z+4	; 0x04
    12a8:	b5 81       	ldd	r27, Z+5	; 0x05
    12aa:	86 81       	ldd	r24, Z+6	; 0x06
    12ac:	97 81       	ldd	r25, Z+7	; 0x07
    12ae:	16 96       	adiw	r26, 0x06	; 6
    12b0:	8d 93       	st	X+, r24
    12b2:	9c 93       	st	X, r25
    12b4:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    12b6:	a6 81       	ldd	r26, Z+6	; 0x06
    12b8:	b7 81       	ldd	r27, Z+7	; 0x07
    12ba:	84 81       	ldd	r24, Z+4	; 0x04
    12bc:	95 81       	ldd	r25, Z+5	; 0x05
    12be:	14 96       	adiw	r26, 0x04	; 4
    12c0:	8d 93       	st	X+, r24
    12c2:	9c 93       	st	X, r25
    12c4:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    12c6:	a2 85       	ldd	r26, Z+10	; 0x0a
    12c8:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    12ca:	11 96       	adiw	r26, 0x01	; 1
    12cc:	8d 91       	ld	r24, X+
    12ce:	9c 91       	ld	r25, X
    12d0:	12 97       	sbiw	r26, 0x02	; 2
    12d2:	e8 17       	cp	r30, r24
    12d4:	f9 07       	cpc	r31, r25
    12d6:	31 f4       	brne	.+12     	; 0x12e4 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    12d8:	86 81       	ldd	r24, Z+6	; 0x06
    12da:	97 81       	ldd	r25, Z+7	; 0x07
    12dc:	11 96       	adiw	r26, 0x01	; 1
    12de:	8d 93       	st	X+, r24
    12e0:	9c 93       	st	X, r25
    12e2:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    12e4:	12 86       	std	Z+10, r1	; 0x0a
    12e6:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    12e8:	8c 91       	ld	r24, X
    12ea:	81 50       	subi	r24, 0x01	; 1
    12ec:	8c 93       	st	X, r24
    12ee:	08 95       	ret

000012f0 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12f0:	80 93 a6 31 	sts	0x31A6, r24	; 0x8031a6 <portStackTopForTask>
    12f4:	90 93 a7 31 	sts	0x31A7, r25	; 0x8031a7 <portStackTopForTask+0x1>
    12f8:	31 e1       	ldi	r19, 0x11	; 17
    12fa:	fc 01       	movw	r30, r24
    12fc:	30 83       	st	Z, r19
    12fe:	31 97       	sbiw	r30, 0x01	; 1
    1300:	22 e2       	ldi	r18, 0x22	; 34
    1302:	20 83       	st	Z, r18
    1304:	31 97       	sbiw	r30, 0x01	; 1
    1306:	a3 e3       	ldi	r26, 0x33	; 51
    1308:	a0 83       	st	Z, r26
    130a:	31 97       	sbiw	r30, 0x01	; 1
    130c:	60 83       	st	Z, r22
    130e:	31 97       	sbiw	r30, 0x01	; 1
    1310:	70 83       	st	Z, r23
    1312:	31 97       	sbiw	r30, 0x01	; 1
    1314:	10 82       	st	Z, r1
    1316:	31 97       	sbiw	r30, 0x01	; 1
    1318:	10 82       	st	Z, r1
    131a:	31 97       	sbiw	r30, 0x01	; 1
    131c:	60 e8       	ldi	r22, 0x80	; 128
    131e:	60 83       	st	Z, r22
    1320:	31 97       	sbiw	r30, 0x01	; 1
    1322:	10 82       	st	Z, r1
    1324:	31 97       	sbiw	r30, 0x01	; 1
    1326:	10 82       	st	Z, r1
    1328:	31 97       	sbiw	r30, 0x01	; 1
    132a:	10 82       	st	Z, r1
    132c:	31 97       	sbiw	r30, 0x01	; 1
    132e:	62 e0       	ldi	r22, 0x02	; 2
    1330:	60 83       	st	Z, r22
    1332:	31 97       	sbiw	r30, 0x01	; 1
    1334:	63 e0       	ldi	r22, 0x03	; 3
    1336:	60 83       	st	Z, r22
    1338:	31 97       	sbiw	r30, 0x01	; 1
    133a:	64 e0       	ldi	r22, 0x04	; 4
    133c:	60 83       	st	Z, r22
    133e:	31 97       	sbiw	r30, 0x01	; 1
    1340:	65 e0       	ldi	r22, 0x05	; 5
    1342:	60 83       	st	Z, r22
    1344:	31 97       	sbiw	r30, 0x01	; 1
    1346:	66 e0       	ldi	r22, 0x06	; 6
    1348:	60 83       	st	Z, r22
    134a:	31 97       	sbiw	r30, 0x01	; 1
    134c:	67 e0       	ldi	r22, 0x07	; 7
    134e:	60 83       	st	Z, r22
    1350:	31 97       	sbiw	r30, 0x01	; 1
    1352:	68 e0       	ldi	r22, 0x08	; 8
    1354:	60 83       	st	Z, r22
    1356:	31 97       	sbiw	r30, 0x01	; 1
    1358:	69 e0       	ldi	r22, 0x09	; 9
    135a:	60 83       	st	Z, r22
    135c:	31 97       	sbiw	r30, 0x01	; 1
    135e:	60 e1       	ldi	r22, 0x10	; 16
    1360:	60 83       	st	Z, r22
    1362:	31 97       	sbiw	r30, 0x01	; 1
    1364:	30 83       	st	Z, r19
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	32 e1       	ldi	r19, 0x12	; 18
    136a:	30 83       	st	Z, r19
    136c:	31 97       	sbiw	r30, 0x01	; 1
    136e:	33 e1       	ldi	r19, 0x13	; 19
    1370:	30 83       	st	Z, r19
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	34 e1       	ldi	r19, 0x14	; 20
    1376:	30 83       	st	Z, r19
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	35 e1       	ldi	r19, 0x15	; 21
    137c:	30 83       	st	Z, r19
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	36 e1       	ldi	r19, 0x16	; 22
    1382:	30 83       	st	Z, r19
    1384:	31 97       	sbiw	r30, 0x01	; 1
    1386:	37 e1       	ldi	r19, 0x17	; 23
    1388:	30 83       	st	Z, r19
    138a:	31 97       	sbiw	r30, 0x01	; 1
    138c:	38 e1       	ldi	r19, 0x18	; 24
    138e:	30 83       	st	Z, r19
    1390:	31 97       	sbiw	r30, 0x01	; 1
    1392:	39 e1       	ldi	r19, 0x19	; 25
    1394:	30 83       	st	Z, r19
    1396:	31 97       	sbiw	r30, 0x01	; 1
    1398:	30 e2       	ldi	r19, 0x20	; 32
    139a:	30 83       	st	Z, r19
    139c:	31 97       	sbiw	r30, 0x01	; 1
    139e:	31 e2       	ldi	r19, 0x21	; 33
    13a0:	30 83       	st	Z, r19
    13a2:	31 97       	sbiw	r30, 0x01	; 1
    13a4:	20 83       	st	Z, r18
    13a6:	31 97       	sbiw	r30, 0x01	; 1
    13a8:	23 e2       	ldi	r18, 0x23	; 35
    13aa:	20 83       	st	Z, r18
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	40 83       	st	Z, r20
    13b0:	31 97       	sbiw	r30, 0x01	; 1
    13b2:	50 83       	st	Z, r21
    13b4:	31 97       	sbiw	r30, 0x01	; 1
    13b6:	26 e2       	ldi	r18, 0x26	; 38
    13b8:	20 83       	st	Z, r18
    13ba:	31 97       	sbiw	r30, 0x01	; 1
    13bc:	27 e2       	ldi	r18, 0x27	; 39
    13be:	20 83       	st	Z, r18
    13c0:	31 97       	sbiw	r30, 0x01	; 1
    13c2:	28 e2       	ldi	r18, 0x28	; 40
    13c4:	20 83       	st	Z, r18
    13c6:	31 97       	sbiw	r30, 0x01	; 1
    13c8:	29 e2       	ldi	r18, 0x29	; 41
    13ca:	20 83       	st	Z, r18
    13cc:	31 97       	sbiw	r30, 0x01	; 1
    13ce:	20 e3       	ldi	r18, 0x30	; 48
    13d0:	20 83       	st	Z, r18
    13d2:	31 97       	sbiw	r30, 0x01	; 1
    13d4:	21 e3       	ldi	r18, 0x31	; 49
    13d6:	20 83       	st	Z, r18
    13d8:	89 97       	sbiw	r24, 0x29	; 41
    13da:	08 95       	ret

000013dc <xPortStartScheduler>:
    13dc:	8c e7       	ldi	r24, 0x7C	; 124
    13de:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    13e2:	8f ef       	ldi	r24, 0xFF	; 255
    13e4:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    13ee:	91 e1       	ldi	r25, 0x11	; 17
    13f0:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    13f4:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    13f8:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    13fc:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1400:	cd 91       	ld	r28, X+
    1402:	cd bf       	out	0x3d, r28	; 61
    1404:	dd 91       	ld	r29, X+
    1406:	de bf       	out	0x3e, r29	; 62
    1408:	ff 91       	pop	r31
    140a:	ef 91       	pop	r30
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	bf 91       	pop	r27
    1412:	af 91       	pop	r26
    1414:	9f 91       	pop	r25
    1416:	8f 91       	pop	r24
    1418:	7f 91       	pop	r23
    141a:	6f 91       	pop	r22
    141c:	5f 91       	pop	r21
    141e:	4f 91       	pop	r20
    1420:	3f 91       	pop	r19
    1422:	2f 91       	pop	r18
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	ff 90       	pop	r15
    142a:	ef 90       	pop	r14
    142c:	df 90       	pop	r13
    142e:	cf 90       	pop	r12
    1430:	bf 90       	pop	r11
    1432:	af 90       	pop	r10
    1434:	9f 90       	pop	r9
    1436:	8f 90       	pop	r8
    1438:	7f 90       	pop	r7
    143a:	6f 90       	pop	r6
    143c:	5f 90       	pop	r5
    143e:	4f 90       	pop	r4
    1440:	3f 90       	pop	r3
    1442:	2f 90       	pop	r2
    1444:	1f 90       	pop	r1
    1446:	0f 90       	pop	r0
    1448:	0c be       	out	0x3c, r0	; 60
    144a:	0f 90       	pop	r0
    144c:	0b be       	out	0x3b, r0	; 59
    144e:	0f 90       	pop	r0
    1450:	0f be       	out	0x3f, r0	; 63
    1452:	0f 90       	pop	r0
    1454:	08 95       	ret
    1456:	08 95       	ret

00001458 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1458:	0f 92       	push	r0
    145a:	0f b6       	in	r0, 0x3f	; 63
    145c:	f8 94       	cli
    145e:	0f 92       	push	r0
    1460:	0b b6       	in	r0, 0x3b	; 59
    1462:	0f 92       	push	r0
    1464:	0c b6       	in	r0, 0x3c	; 60
    1466:	0f 92       	push	r0
    1468:	1f 92       	push	r1
    146a:	11 24       	eor	r1, r1
    146c:	2f 92       	push	r2
    146e:	3f 92       	push	r3
    1470:	4f 92       	push	r4
    1472:	5f 92       	push	r5
    1474:	6f 92       	push	r6
    1476:	7f 92       	push	r7
    1478:	8f 92       	push	r8
    147a:	9f 92       	push	r9
    147c:	af 92       	push	r10
    147e:	bf 92       	push	r11
    1480:	cf 92       	push	r12
    1482:	df 92       	push	r13
    1484:	ef 92       	push	r14
    1486:	ff 92       	push	r15
    1488:	0f 93       	push	r16
    148a:	1f 93       	push	r17
    148c:	2f 93       	push	r18
    148e:	3f 93       	push	r19
    1490:	4f 93       	push	r20
    1492:	5f 93       	push	r21
    1494:	6f 93       	push	r22
    1496:	7f 93       	push	r23
    1498:	8f 93       	push	r24
    149a:	9f 93       	push	r25
    149c:	af 93       	push	r26
    149e:	bf 93       	push	r27
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	ef 93       	push	r30
    14a6:	ff 93       	push	r31
    14a8:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    14ac:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    14b0:	0d b6       	in	r0, 0x3d	; 61
    14b2:	0d 92       	st	X+, r0
    14b4:	0e b6       	in	r0, 0x3e	; 62
    14b6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    14b8:	0e 94 3b 11 	call	0x2276	; 0x2276 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    14bc:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    14c0:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    14c4:	cd 91       	ld	r28, X+
    14c6:	cd bf       	out	0x3d, r28	; 61
    14c8:	dd 91       	ld	r29, X+
    14ca:	de bf       	out	0x3e, r29	; 62
    14cc:	ff 91       	pop	r31
    14ce:	ef 91       	pop	r30
    14d0:	df 91       	pop	r29
    14d2:	cf 91       	pop	r28
    14d4:	bf 91       	pop	r27
    14d6:	af 91       	pop	r26
    14d8:	9f 91       	pop	r25
    14da:	8f 91       	pop	r24
    14dc:	7f 91       	pop	r23
    14de:	6f 91       	pop	r22
    14e0:	5f 91       	pop	r21
    14e2:	4f 91       	pop	r20
    14e4:	3f 91       	pop	r19
    14e6:	2f 91       	pop	r18
    14e8:	1f 91       	pop	r17
    14ea:	0f 91       	pop	r16
    14ec:	ff 90       	pop	r15
    14ee:	ef 90       	pop	r14
    14f0:	df 90       	pop	r13
    14f2:	cf 90       	pop	r12
    14f4:	bf 90       	pop	r11
    14f6:	af 90       	pop	r10
    14f8:	9f 90       	pop	r9
    14fa:	8f 90       	pop	r8
    14fc:	7f 90       	pop	r7
    14fe:	6f 90       	pop	r6
    1500:	5f 90       	pop	r5
    1502:	4f 90       	pop	r4
    1504:	3f 90       	pop	r3
    1506:	2f 90       	pop	r2
    1508:	1f 90       	pop	r1
    150a:	0f 90       	pop	r0
    150c:	0c be       	out	0x3c, r0	; 60
    150e:	0f 90       	pop	r0
    1510:	0b be       	out	0x3b, r0	; 59
    1512:	0f 90       	pop	r0
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1518:	08 95       	ret

0000151a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    151a:	0f 92       	push	r0
    151c:	0f b6       	in	r0, 0x3f	; 63
    151e:	f8 94       	cli
    1520:	0f 92       	push	r0
    1522:	0b b6       	in	r0, 0x3b	; 59
    1524:	0f 92       	push	r0
    1526:	0c b6       	in	r0, 0x3c	; 60
    1528:	0f 92       	push	r0
    152a:	1f 92       	push	r1
    152c:	11 24       	eor	r1, r1
    152e:	2f 92       	push	r2
    1530:	3f 92       	push	r3
    1532:	4f 92       	push	r4
    1534:	5f 92       	push	r5
    1536:	6f 92       	push	r6
    1538:	7f 92       	push	r7
    153a:	8f 92       	push	r8
    153c:	9f 92       	push	r9
    153e:	af 92       	push	r10
    1540:	bf 92       	push	r11
    1542:	cf 92       	push	r12
    1544:	df 92       	push	r13
    1546:	ef 92       	push	r14
    1548:	ff 92       	push	r15
    154a:	0f 93       	push	r16
    154c:	1f 93       	push	r17
    154e:	2f 93       	push	r18
    1550:	3f 93       	push	r19
    1552:	4f 93       	push	r20
    1554:	5f 93       	push	r21
    1556:	6f 93       	push	r22
    1558:	7f 93       	push	r23
    155a:	8f 93       	push	r24
    155c:	9f 93       	push	r25
    155e:	af 93       	push	r26
    1560:	bf 93       	push	r27
    1562:	cf 93       	push	r28
    1564:	df 93       	push	r29
    1566:	ef 93       	push	r30
    1568:	ff 93       	push	r31
    156a:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    156e:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1572:	0d b6       	in	r0, 0x3d	; 61
    1574:	0d 92       	st	X+, r0
    1576:	0e b6       	in	r0, 0x3e	; 62
    1578:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    157a:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vTaskIncrementTick>
	vTaskSwitchContext();
    157e:	0e 94 3b 11 	call	0x2276	; 0x2276 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1582:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    1586:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    158a:	cd 91       	ld	r28, X+
    158c:	cd bf       	out	0x3d, r28	; 61
    158e:	dd 91       	ld	r29, X+
    1590:	de bf       	out	0x3e, r29	; 62
    1592:	ff 91       	pop	r31
    1594:	ef 91       	pop	r30
    1596:	df 91       	pop	r29
    1598:	cf 91       	pop	r28
    159a:	bf 91       	pop	r27
    159c:	af 91       	pop	r26
    159e:	9f 91       	pop	r25
    15a0:	8f 91       	pop	r24
    15a2:	7f 91       	pop	r23
    15a4:	6f 91       	pop	r22
    15a6:	5f 91       	pop	r21
    15a8:	4f 91       	pop	r20
    15aa:	3f 91       	pop	r19
    15ac:	2f 91       	pop	r18
    15ae:	1f 91       	pop	r17
    15b0:	0f 91       	pop	r16
    15b2:	ff 90       	pop	r15
    15b4:	ef 90       	pop	r14
    15b6:	df 90       	pop	r13
    15b8:	cf 90       	pop	r12
    15ba:	bf 90       	pop	r11
    15bc:	af 90       	pop	r10
    15be:	9f 90       	pop	r9
    15c0:	8f 90       	pop	r8
    15c2:	7f 90       	pop	r7
    15c4:	6f 90       	pop	r6
    15c6:	5f 90       	pop	r5
    15c8:	4f 90       	pop	r4
    15ca:	3f 90       	pop	r3
    15cc:	2f 90       	pop	r2
    15ce:	1f 90       	pop	r1
    15d0:	0f 90       	pop	r0
    15d2:	0c be       	out	0x3c, r0	; 60
    15d4:	0f 90       	pop	r0
    15d6:	0b be       	out	0x3b, r0	; 59
    15d8:	0f 90       	pop	r0
    15da:	0f be       	out	0x3f, r0	; 63
    15dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    15de:	08 95       	ret

000015e0 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    15e0:	0e 94 8d 0a 	call	0x151a	; 0x151a <vPortYieldFromTick>
		asm volatile ( "reti" );
    15e4:	18 95       	reti

000015e6 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    15e6:	cf 93       	push	r28
    15e8:	df 93       	push	r29
    15ea:	ec 01       	movw	r28, r24
    15ec:	88 a1       	ldd	r24, Y+32	; 0x20
    15ee:	81 11       	cpse	r24, r1
    15f0:	0b c0       	rjmp	.+22     	; 0x1608 <prvCopyDataToQueue+0x22>
    15f2:	88 81       	ld	r24, Y
    15f4:	99 81       	ldd	r25, Y+1	; 0x01
    15f6:	89 2b       	or	r24, r25
    15f8:	e1 f5       	brne	.+120    	; 0x1672 <prvCopyDataToQueue+0x8c>
    15fa:	8a 81       	ldd	r24, Y+2	; 0x02
    15fc:	9b 81       	ldd	r25, Y+3	; 0x03
    15fe:	0e 94 f6 12 	call	0x25ec	; 0x25ec <vTaskPriorityDisinherit>
    1602:	1a 82       	std	Y+2, r1	; 0x02
    1604:	1b 82       	std	Y+3, r1	; 0x03
    1606:	35 c0       	rjmp	.+106    	; 0x1672 <prvCopyDataToQueue+0x8c>
    1608:	41 11       	cpse	r20, r1
    160a:	17 c0       	rjmp	.+46     	; 0x163a <prvCopyDataToQueue+0x54>
    160c:	48 2f       	mov	r20, r24
    160e:	50 e0       	ldi	r21, 0x00	; 0
    1610:	8c 81       	ldd	r24, Y+4	; 0x04
    1612:	9d 81       	ldd	r25, Y+5	; 0x05
    1614:	0e 94 29 20 	call	0x4052	; 0x4052 <memcpy>
    1618:	28 a1       	ldd	r18, Y+32	; 0x20
    161a:	8c 81       	ldd	r24, Y+4	; 0x04
    161c:	9d 81       	ldd	r25, Y+5	; 0x05
    161e:	82 0f       	add	r24, r18
    1620:	91 1d       	adc	r25, r1
    1622:	8c 83       	std	Y+4, r24	; 0x04
    1624:	9d 83       	std	Y+5, r25	; 0x05
    1626:	2a 81       	ldd	r18, Y+2	; 0x02
    1628:	3b 81       	ldd	r19, Y+3	; 0x03
    162a:	82 17       	cp	r24, r18
    162c:	93 07       	cpc	r25, r19
    162e:	08 f1       	brcs	.+66     	; 0x1672 <prvCopyDataToQueue+0x8c>
    1630:	88 81       	ld	r24, Y
    1632:	99 81       	ldd	r25, Y+1	; 0x01
    1634:	8c 83       	std	Y+4, r24	; 0x04
    1636:	9d 83       	std	Y+5, r25	; 0x05
    1638:	1c c0       	rjmp	.+56     	; 0x1672 <prvCopyDataToQueue+0x8c>
    163a:	48 2f       	mov	r20, r24
    163c:	50 e0       	ldi	r21, 0x00	; 0
    163e:	8e 81       	ldd	r24, Y+6	; 0x06
    1640:	9f 81       	ldd	r25, Y+7	; 0x07
    1642:	0e 94 29 20 	call	0x4052	; 0x4052 <memcpy>
    1646:	88 a1       	ldd	r24, Y+32	; 0x20
    1648:	90 e0       	ldi	r25, 0x00	; 0
    164a:	91 95       	neg	r25
    164c:	81 95       	neg	r24
    164e:	91 09       	sbc	r25, r1
    1650:	2e 81       	ldd	r18, Y+6	; 0x06
    1652:	3f 81       	ldd	r19, Y+7	; 0x07
    1654:	28 0f       	add	r18, r24
    1656:	39 1f       	adc	r19, r25
    1658:	2e 83       	std	Y+6, r18	; 0x06
    165a:	3f 83       	std	Y+7, r19	; 0x07
    165c:	48 81       	ld	r20, Y
    165e:	59 81       	ldd	r21, Y+1	; 0x01
    1660:	24 17       	cp	r18, r20
    1662:	35 07       	cpc	r19, r21
    1664:	30 f4       	brcc	.+12     	; 0x1672 <prvCopyDataToQueue+0x8c>
    1666:	2a 81       	ldd	r18, Y+2	; 0x02
    1668:	3b 81       	ldd	r19, Y+3	; 0x03
    166a:	82 0f       	add	r24, r18
    166c:	93 1f       	adc	r25, r19
    166e:	8e 83       	std	Y+6, r24	; 0x06
    1670:	9f 83       	std	Y+7, r25	; 0x07
    1672:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1674:	8f 5f       	subi	r24, 0xFF	; 255
    1676:	8e 8f       	std	Y+30, r24	; 0x1e
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	08 95       	ret

0000167e <prvCopyDataFromQueue>:
    167e:	fc 01       	movw	r30, r24
    1680:	80 81       	ld	r24, Z
    1682:	91 81       	ldd	r25, Z+1	; 0x01
    1684:	00 97       	sbiw	r24, 0x00	; 0
    1686:	a1 f0       	breq	.+40     	; 0x16b0 <prvCopyDataFromQueue+0x32>
    1688:	40 a1       	ldd	r20, Z+32	; 0x20
    168a:	50 e0       	ldi	r21, 0x00	; 0
    168c:	26 81       	ldd	r18, Z+6	; 0x06
    168e:	37 81       	ldd	r19, Z+7	; 0x07
    1690:	24 0f       	add	r18, r20
    1692:	35 1f       	adc	r19, r21
    1694:	26 83       	std	Z+6, r18	; 0x06
    1696:	37 83       	std	Z+7, r19	; 0x07
    1698:	a2 81       	ldd	r26, Z+2	; 0x02
    169a:	b3 81       	ldd	r27, Z+3	; 0x03
    169c:	2a 17       	cp	r18, r26
    169e:	3b 07       	cpc	r19, r27
    16a0:	10 f0       	brcs	.+4      	; 0x16a6 <prvCopyDataFromQueue+0x28>
    16a2:	86 83       	std	Z+6, r24	; 0x06
    16a4:	97 83       	std	Z+7, r25	; 0x07
    16a6:	cb 01       	movw	r24, r22
    16a8:	66 81       	ldd	r22, Z+6	; 0x06
    16aa:	77 81       	ldd	r23, Z+7	; 0x07
    16ac:	0e 94 29 20 	call	0x4052	; 0x4052 <memcpy>
    16b0:	08 95       	ret

000016b2 <prvUnlockQueue>:
    16b2:	0f 93       	push	r16
    16b4:	1f 93       	push	r17
    16b6:	cf 93       	push	r28
    16b8:	df 93       	push	r29
    16ba:	ec 01       	movw	r28, r24
    16bc:	0f b6       	in	r0, 0x3f	; 63
    16be:	f8 94       	cli
    16c0:	0f 92       	push	r0
    16c2:	8a a1       	ldd	r24, Y+34	; 0x22
    16c4:	18 16       	cp	r1, r24
    16c6:	b4 f4       	brge	.+44     	; 0x16f4 <prvUnlockQueue+0x42>
    16c8:	8b 89       	ldd	r24, Y+19	; 0x13
    16ca:	81 11       	cpse	r24, r1
    16cc:	05 c0       	rjmp	.+10     	; 0x16d8 <prvUnlockQueue+0x26>
    16ce:	12 c0       	rjmp	.+36     	; 0x16f4 <prvUnlockQueue+0x42>
    16d0:	8b 89       	ldd	r24, Y+19	; 0x13
    16d2:	81 11       	cpse	r24, r1
    16d4:	04 c0       	rjmp	.+8      	; 0x16de <prvUnlockQueue+0x2c>
    16d6:	0e c0       	rjmp	.+28     	; 0x16f4 <prvUnlockQueue+0x42>
    16d8:	8e 01       	movw	r16, r28
    16da:	0d 5e       	subi	r16, 0xED	; 237
    16dc:	1f 4f       	sbci	r17, 0xFF	; 255
    16de:	c8 01       	movw	r24, r16
    16e0:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    16e4:	81 11       	cpse	r24, r1
    16e6:	0e 94 7f 12 	call	0x24fe	; 0x24fe <vTaskMissedYield>
    16ea:	8a a1       	ldd	r24, Y+34	; 0x22
    16ec:	81 50       	subi	r24, 0x01	; 1
    16ee:	8a a3       	std	Y+34, r24	; 0x22
    16f0:	18 16       	cp	r1, r24
    16f2:	74 f3       	brlt	.-36     	; 0x16d0 <prvUnlockQueue+0x1e>
    16f4:	8f ef       	ldi	r24, 0xFF	; 255
    16f6:	8a a3       	std	Y+34, r24	; 0x22
    16f8:	0f 90       	pop	r0
    16fa:	0f be       	out	0x3f, r0	; 63
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	f8 94       	cli
    1700:	0f 92       	push	r0
    1702:	89 a1       	ldd	r24, Y+33	; 0x21
    1704:	18 16       	cp	r1, r24
    1706:	b4 f4       	brge	.+44     	; 0x1734 <prvUnlockQueue+0x82>
    1708:	88 85       	ldd	r24, Y+8	; 0x08
    170a:	81 11       	cpse	r24, r1
    170c:	05 c0       	rjmp	.+10     	; 0x1718 <prvUnlockQueue+0x66>
    170e:	12 c0       	rjmp	.+36     	; 0x1734 <prvUnlockQueue+0x82>
    1710:	88 85       	ldd	r24, Y+8	; 0x08
    1712:	81 11       	cpse	r24, r1
    1714:	04 c0       	rjmp	.+8      	; 0x171e <prvUnlockQueue+0x6c>
    1716:	0e c0       	rjmp	.+28     	; 0x1734 <prvUnlockQueue+0x82>
    1718:	8e 01       	movw	r16, r28
    171a:	08 5f       	subi	r16, 0xF8	; 248
    171c:	1f 4f       	sbci	r17, 0xFF	; 255
    171e:	c8 01       	movw	r24, r16
    1720:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1724:	81 11       	cpse	r24, r1
    1726:	0e 94 7f 12 	call	0x24fe	; 0x24fe <vTaskMissedYield>
    172a:	89 a1       	ldd	r24, Y+33	; 0x21
    172c:	81 50       	subi	r24, 0x01	; 1
    172e:	89 a3       	std	Y+33, r24	; 0x21
    1730:	18 16       	cp	r1, r24
    1732:	74 f3       	brlt	.-36     	; 0x1710 <prvUnlockQueue+0x5e>
    1734:	8f ef       	ldi	r24, 0xFF	; 255
    1736:	89 a3       	std	Y+33, r24	; 0x21
    1738:	0f 90       	pop	r0
    173a:	0f be       	out	0x3f, r0	; 63
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	1f 91       	pop	r17
    1742:	0f 91       	pop	r16
    1744:	08 95       	ret

00001746 <xQueueGenericReset>:
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	61 30       	cpi	r22, 0x01	; 1
    174e:	59 f0       	breq	.+22     	; 0x1766 <xQueueGenericReset+0x20>
    1750:	fc 01       	movw	r30, r24
    1752:	23 89       	ldd	r18, Z+19	; 0x13
    1754:	30 85       	ldd	r19, Z+8	; 0x08
    1756:	31 11       	cpse	r19, r1
    1758:	2c c0       	rjmp	.+88     	; 0x17b2 <xQueueGenericReset+0x6c>
    175a:	11 e0       	ldi	r17, 0x01	; 1
    175c:	21 11       	cpse	r18, r1
    175e:	10 e0       	ldi	r17, 0x00	; 0
    1760:	21 11       	cpse	r18, r1
    1762:	28 c0       	rjmp	.+80     	; 0x17b4 <xQueueGenericReset+0x6e>
    1764:	01 c0       	rjmp	.+2      	; 0x1768 <xQueueGenericReset+0x22>
    1766:	11 e0       	ldi	r17, 0x01	; 1
    1768:	ec 01       	movw	r28, r24
    176a:	48 81       	ld	r20, Y
    176c:	59 81       	ldd	r21, Y+1	; 0x01
    176e:	28 a1       	ldd	r18, Y+32	; 0x20
    1770:	30 e0       	ldi	r19, 0x00	; 0
    1772:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1774:	62 9f       	mul	r22, r18
    1776:	c0 01       	movw	r24, r0
    1778:	63 9f       	mul	r22, r19
    177a:	90 0d       	add	r25, r0
    177c:	11 24       	eor	r1, r1
    177e:	ba 01       	movw	r22, r20
    1780:	68 0f       	add	r22, r24
    1782:	79 1f       	adc	r23, r25
    1784:	6a 83       	std	Y+2, r22	; 0x02
    1786:	7b 83       	std	Y+3, r23	; 0x03
    1788:	1e 8e       	std	Y+30, r1	; 0x1e
    178a:	4c 83       	std	Y+4, r20	; 0x04
    178c:	5d 83       	std	Y+5, r21	; 0x05
    178e:	82 1b       	sub	r24, r18
    1790:	93 0b       	sbc	r25, r19
    1792:	84 0f       	add	r24, r20
    1794:	95 1f       	adc	r25, r21
    1796:	8e 83       	std	Y+6, r24	; 0x06
    1798:	9f 83       	std	Y+7, r25	; 0x07
    179a:	8f ef       	ldi	r24, 0xFF	; 255
    179c:	89 a3       	std	Y+33, r24	; 0x21
    179e:	8a a3       	std	Y+34, r24	; 0x22
    17a0:	ce 01       	movw	r24, r28
    17a2:	08 96       	adiw	r24, 0x08	; 8
    17a4:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    17a8:	ce 01       	movw	r24, r28
    17aa:	43 96       	adiw	r24, 0x13	; 19
    17ac:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    17b0:	01 c0       	rjmp	.+2      	; 0x17b4 <xQueueGenericReset+0x6e>
    17b2:	10 e0       	ldi	r17, 0x00	; 0
    17b4:	81 2f       	mov	r24, r17
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	1f 91       	pop	r17
    17bc:	08 95       	ret

000017be <xQueueGenericCreate>:
    17be:	0f 93       	push	r16
    17c0:	1f 93       	push	r17
    17c2:	cf 93       	push	r28
    17c4:	df 93       	push	r29
    17c6:	88 23       	and	r24, r24
    17c8:	01 f1       	breq	.+64     	; 0x180a <xQueueGenericCreate+0x4c>
    17ca:	06 2f       	mov	r16, r22
    17cc:	18 2f       	mov	r17, r24
    17ce:	83 e2       	ldi	r24, 0x23	; 35
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    17d6:	ec 01       	movw	r28, r24
    17d8:	89 2b       	or	r24, r25
    17da:	c9 f0       	breq	.+50     	; 0x180e <xQueueGenericCreate+0x50>
    17dc:	10 9f       	mul	r17, r16
    17de:	c0 01       	movw	r24, r0
    17e0:	11 24       	eor	r1, r1
    17e2:	01 96       	adiw	r24, 0x01	; 1
    17e4:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    17e8:	88 83       	st	Y, r24
    17ea:	99 83       	std	Y+1, r25	; 0x01
    17ec:	89 2b       	or	r24, r25
    17ee:	39 f0       	breq	.+14     	; 0x17fe <xQueueGenericCreate+0x40>
    17f0:	1f 8f       	std	Y+31, r17	; 0x1f
    17f2:	08 a3       	std	Y+32, r16	; 0x20
    17f4:	61 e0       	ldi	r22, 0x01	; 1
    17f6:	ce 01       	movw	r24, r28
    17f8:	0e 94 a3 0b 	call	0x1746	; 0x1746 <xQueueGenericReset>
    17fc:	08 c0       	rjmp	.+16     	; 0x180e <xQueueGenericCreate+0x50>
    17fe:	ce 01       	movw	r24, r28
    1800:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortFree>
    1804:	c0 e0       	ldi	r28, 0x00	; 0
    1806:	d0 e0       	ldi	r29, 0x00	; 0
    1808:	02 c0       	rjmp	.+4      	; 0x180e <xQueueGenericCreate+0x50>
    180a:	c0 e0       	ldi	r28, 0x00	; 0
    180c:	d0 e0       	ldi	r29, 0x00	; 0
    180e:	ce 01       	movw	r24, r28
    1810:	df 91       	pop	r29
    1812:	cf 91       	pop	r28
    1814:	1f 91       	pop	r17
    1816:	0f 91       	pop	r16
    1818:	08 95       	ret

0000181a <xQueueGenericSend>:
    181a:	af 92       	push	r10
    181c:	bf 92       	push	r11
    181e:	cf 92       	push	r12
    1820:	df 92       	push	r13
    1822:	ef 92       	push	r14
    1824:	ff 92       	push	r15
    1826:	0f 93       	push	r16
    1828:	1f 93       	push	r17
    182a:	cf 93       	push	r28
    182c:	df 93       	push	r29
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
    1832:	29 97       	sbiw	r28, 0x09	; 9
    1834:	cd bf       	out	0x3d, r28	; 61
    1836:	de bf       	out	0x3e, r29	; 62
    1838:	7c 01       	movw	r14, r24
    183a:	5b 01       	movw	r10, r22
    183c:	2e 83       	std	Y+6, r18	; 0x06
    183e:	3f 83       	std	Y+7, r19	; 0x07
    1840:	48 87       	std	Y+8, r20	; 0x08
    1842:	59 87       	std	Y+9, r21	; 0x09
    1844:	10 e0       	ldi	r17, 0x00	; 0
    1846:	6c 01       	movw	r12, r24
    1848:	88 e0       	ldi	r24, 0x08	; 8
    184a:	c8 0e       	add	r12, r24
    184c:	d1 1c       	adc	r13, r1
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	f7 01       	movw	r30, r14
    1856:	96 8d       	ldd	r25, Z+30	; 0x1e
    1858:	87 8d       	ldd	r24, Z+31	; 0x1f
    185a:	98 17       	cp	r25, r24
    185c:	a8 f4       	brcc	.+42     	; 0x1888 <xQueueGenericSend+0x6e>
    185e:	40 2f       	mov	r20, r16
    1860:	b5 01       	movw	r22, r10
    1862:	c7 01       	movw	r24, r14
    1864:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <prvCopyDataToQueue>
    1868:	f7 01       	movw	r30, r14
    186a:	83 89       	ldd	r24, Z+19	; 0x13
    186c:	88 23       	and	r24, r24
    186e:	41 f0       	breq	.+16     	; 0x1880 <xQueueGenericSend+0x66>
    1870:	c7 01       	movw	r24, r14
    1872:	43 96       	adiw	r24, 0x13	; 19
    1874:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1878:	81 30       	cpi	r24, 0x01	; 1
    187a:	11 f4       	brne	.+4      	; 0x1880 <xQueueGenericSend+0x66>
    187c:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    1880:	0f 90       	pop	r0
    1882:	0f be       	out	0x3f, r0	; 63
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	56 c0       	rjmp	.+172    	; 0x1934 <xQueueGenericSend+0x11a>
    1888:	8e 81       	ldd	r24, Y+6	; 0x06
    188a:	9f 81       	ldd	r25, Y+7	; 0x07
    188c:	a8 85       	ldd	r26, Y+8	; 0x08
    188e:	b9 85       	ldd	r27, Y+9	; 0x09
    1890:	89 2b       	or	r24, r25
    1892:	8a 2b       	or	r24, r26
    1894:	8b 2b       	or	r24, r27
    1896:	21 f4       	brne	.+8      	; 0x18a0 <xQueueGenericSend+0x86>
    1898:	0f 90       	pop	r0
    189a:	0f be       	out	0x3f, r0	; 63
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	4a c0       	rjmp	.+148    	; 0x1934 <xQueueGenericSend+0x11a>
    18a0:	11 11       	cpse	r17, r1
    18a2:	05 c0       	rjmp	.+10     	; 0x18ae <xQueueGenericSend+0x94>
    18a4:	ce 01       	movw	r24, r28
    18a6:	01 96       	adiw	r24, 0x01	; 1
    18a8:	0e 94 01 12 	call	0x2402	; 0x2402 <vTaskSetTimeOutState>
    18ac:	11 e0       	ldi	r17, 0x01	; 1
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vTaskSuspendAll>
    18b6:	0f b6       	in	r0, 0x3f	; 63
    18b8:	f8 94       	cli
    18ba:	0f 92       	push	r0
    18bc:	f7 01       	movw	r30, r14
    18be:	81 a1       	ldd	r24, Z+33	; 0x21
    18c0:	8f 3f       	cpi	r24, 0xFF	; 255
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <xQueueGenericSend+0xac>
    18c4:	11 a2       	std	Z+33, r1	; 0x21
    18c6:	f7 01       	movw	r30, r14
    18c8:	82 a1       	ldd	r24, Z+34	; 0x22
    18ca:	8f 3f       	cpi	r24, 0xFF	; 255
    18cc:	09 f4       	brne	.+2      	; 0x18d0 <xQueueGenericSend+0xb6>
    18ce:	12 a2       	std	Z+34, r1	; 0x22
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	be 01       	movw	r22, r28
    18d6:	6a 5f       	subi	r22, 0xFA	; 250
    18d8:	7f 4f       	sbci	r23, 0xFF	; 255
    18da:	ce 01       	movw	r24, r28
    18dc:	01 96       	adiw	r24, 0x01	; 1
    18de:	0e 94 12 12 	call	0x2424	; 0x2424 <xTaskCheckForTimeOut>
    18e2:	81 11       	cpse	r24, r1
    18e4:	21 c0       	rjmp	.+66     	; 0x1928 <xQueueGenericSend+0x10e>
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	0f 92       	push	r0
    18ec:	f7 01       	movw	r30, r14
    18ee:	96 8d       	ldd	r25, Z+30	; 0x1e
    18f0:	0f 90       	pop	r0
    18f2:	0f be       	out	0x3f, r0	; 63
    18f4:	87 8d       	ldd	r24, Z+31	; 0x1f
    18f6:	98 13       	cpse	r25, r24
    18f8:	11 c0       	rjmp	.+34     	; 0x191c <xQueueGenericSend+0x102>
    18fa:	4e 81       	ldd	r20, Y+6	; 0x06
    18fc:	5f 81       	ldd	r21, Y+7	; 0x07
    18fe:	68 85       	ldd	r22, Y+8	; 0x08
    1900:	79 85       	ldd	r23, Y+9	; 0x09
    1902:	c6 01       	movw	r24, r12
    1904:	0e 94 98 11 	call	0x2330	; 0x2330 <vTaskPlaceOnEventList>
    1908:	c7 01       	movw	r24, r14
    190a:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
    190e:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
    1912:	81 11       	cpse	r24, r1
    1914:	9c cf       	rjmp	.-200    	; 0x184e <xQueueGenericSend+0x34>
    1916:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    191a:	99 cf       	rjmp	.-206    	; 0x184e <xQueueGenericSend+0x34>
    191c:	c7 01       	movw	r24, r14
    191e:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
    1922:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
    1926:	93 cf       	rjmp	.-218    	; 0x184e <xQueueGenericSend+0x34>
    1928:	c7 01       	movw	r24, r14
    192a:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
    192e:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
    1932:	80 e0       	ldi	r24, 0x00	; 0
    1934:	29 96       	adiw	r28, 0x09	; 9
    1936:	cd bf       	out	0x3d, r28	; 61
    1938:	de bf       	out	0x3e, r29	; 62
    193a:	df 91       	pop	r29
    193c:	cf 91       	pop	r28
    193e:	1f 91       	pop	r17
    1940:	0f 91       	pop	r16
    1942:	ff 90       	pop	r15
    1944:	ef 90       	pop	r14
    1946:	df 90       	pop	r13
    1948:	cf 90       	pop	r12
    194a:	bf 90       	pop	r11
    194c:	af 90       	pop	r10
    194e:	08 95       	ret

00001950 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1950:	0f 93       	push	r16
    1952:	1f 93       	push	r17
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    195a:	fc 01       	movw	r30, r24
    195c:	56 8d       	ldd	r21, Z+30	; 0x1e
    195e:	37 8d       	ldd	r19, Z+31	; 0x1f
    1960:	53 17       	cp	r21, r19
    1962:	c0 f4       	brcc	.+48     	; 0x1994 <xQueueGenericSendFromISR+0x44>
    1964:	42 2f       	mov	r20, r18
    1966:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1968:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    196c:	8a a1       	ldd	r24, Y+34	; 0x22
    196e:	8f 3f       	cpi	r24, 0xFF	; 255
    1970:	69 f4       	brne	.+26     	; 0x198c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1972:	8b 89       	ldd	r24, Y+19	; 0x13
    1974:	88 23       	and	r24, r24
    1976:	81 f0       	breq	.+32     	; 0x1998 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1978:	ce 01       	movw	r24, r28
    197a:	43 96       	adiw	r24, 0x13	; 19
    197c:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1980:	88 23       	and	r24, r24
    1982:	61 f0       	breq	.+24     	; 0x199c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	f8 01       	movw	r30, r16
    1988:	80 83       	st	Z, r24
    198a:	09 c0       	rjmp	.+18     	; 0x199e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    198c:	8f 5f       	subi	r24, 0xFF	; 255
    198e:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	05 c0       	rjmp	.+10     	; 0x199e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1994:	80 e0       	ldi	r24, 0x00	; 0
    1996:	03 c0       	rjmp	.+6      	; 0x199e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	01 c0       	rjmp	.+2      	; 0x199e <xQueueGenericSendFromISR+0x4e>
    199c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    199e:	df 91       	pop	r29
    19a0:	cf 91       	pop	r28
    19a2:	1f 91       	pop	r17
    19a4:	0f 91       	pop	r16
    19a6:	08 95       	ret

000019a8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    19a8:	af 92       	push	r10
    19aa:	bf 92       	push	r11
    19ac:	cf 92       	push	r12
    19ae:	df 92       	push	r13
    19b0:	ef 92       	push	r14
    19b2:	ff 92       	push	r15
    19b4:	0f 93       	push	r16
    19b6:	1f 93       	push	r17
    19b8:	cf 93       	push	r28
    19ba:	df 93       	push	r29
    19bc:	cd b7       	in	r28, 0x3d	; 61
    19be:	de b7       	in	r29, 0x3e	; 62
    19c0:	29 97       	sbiw	r28, 0x09	; 9
    19c2:	cd bf       	out	0x3d, r28	; 61
    19c4:	de bf       	out	0x3e, r29	; 62
    19c6:	7c 01       	movw	r14, r24
    19c8:	5b 01       	movw	r10, r22
    19ca:	2e 83       	std	Y+6, r18	; 0x06
    19cc:	3f 83       	std	Y+7, r19	; 0x07
    19ce:	48 87       	std	Y+8, r20	; 0x08
    19d0:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    19d2:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19d4:	6c 01       	movw	r12, r24
    19d6:	83 e1       	ldi	r24, 0x13	; 19
    19d8:	c8 0e       	add	r12, r24
    19da:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    19dc:	0f b6       	in	r0, 0x3f	; 63
    19de:	f8 94       	cli
    19e0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19e2:	f7 01       	movw	r30, r14
    19e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    19e6:	88 23       	and	r24, r24
    19e8:	99 f1       	breq	.+102    	; 0x1a50 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    19ea:	c6 80       	ldd	r12, Z+6	; 0x06
    19ec:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    19ee:	b5 01       	movw	r22, r10
    19f0:	c7 01       	movw	r24, r14
    19f2:	0e 94 3f 0b 	call	0x167e	; 0x167e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    19f6:	01 11       	cpse	r16, r1
    19f8:	1a c0       	rjmp	.+52     	; 0x1a2e <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    19fa:	f7 01       	movw	r30, r14
    19fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    19fe:	81 50       	subi	r24, 0x01	; 1
    1a00:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a02:	80 81       	ld	r24, Z
    1a04:	91 81       	ldd	r25, Z+1	; 0x01
    1a06:	89 2b       	or	r24, r25
    1a08:	29 f4       	brne	.+10     	; 0x1a14 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1a0a:	0e 94 9c 12 	call	0x2538	; 0x2538 <xTaskGetCurrentTaskHandle>
    1a0e:	f7 01       	movw	r30, r14
    1a10:	82 83       	std	Z+2, r24	; 0x02
    1a12:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a14:	f7 01       	movw	r30, r14
    1a16:	80 85       	ldd	r24, Z+8	; 0x08
    1a18:	88 23       	and	r24, r24
    1a1a:	b1 f0       	breq	.+44     	; 0x1a48 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a1c:	c7 01       	movw	r24, r14
    1a1e:	08 96       	adiw	r24, 0x08	; 8
    1a20:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1a24:	81 30       	cpi	r24, 0x01	; 1
    1a26:	81 f4       	brne	.+32     	; 0x1a48 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1a28:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    1a2c:	0d c0       	rjmp	.+26     	; 0x1a48 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1a2e:	f7 01       	movw	r30, r14
    1a30:	c6 82       	std	Z+6, r12	; 0x06
    1a32:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a34:	83 89       	ldd	r24, Z+19	; 0x13
    1a36:	88 23       	and	r24, r24
    1a38:	39 f0       	breq	.+14     	; 0x1a48 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a3a:	c7 01       	movw	r24, r14
    1a3c:	43 96       	adiw	r24, 0x13	; 19
    1a3e:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1a42:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1a44:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1a48:	0f 90       	pop	r0
    1a4a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a4c:	81 e0       	ldi	r24, 0x01	; 1
    1a4e:	62 c0       	rjmp	.+196    	; 0x1b14 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1a50:	8e 81       	ldd	r24, Y+6	; 0x06
    1a52:	9f 81       	ldd	r25, Y+7	; 0x07
    1a54:	a8 85       	ldd	r26, Y+8	; 0x08
    1a56:	b9 85       	ldd	r27, Y+9	; 0x09
    1a58:	89 2b       	or	r24, r25
    1a5a:	8a 2b       	or	r24, r26
    1a5c:	8b 2b       	or	r24, r27
    1a5e:	21 f4       	brne	.+8      	; 0x1a68 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1a60:	0f 90       	pop	r0
    1a62:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1a64:	80 e0       	ldi	r24, 0x00	; 0
    1a66:	56 c0       	rjmp	.+172    	; 0x1b14 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1a68:	11 11       	cpse	r17, r1
    1a6a:	05 c0       	rjmp	.+10     	; 0x1a76 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1a6c:	ce 01       	movw	r24, r28
    1a6e:	01 96       	adiw	r24, 0x01	; 1
    1a70:	0e 94 01 12 	call	0x2402	; 0x2402 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1a74:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1a76:	0f 90       	pop	r0
    1a78:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1a7a:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
    1a84:	f7 01       	movw	r30, r14
    1a86:	81 a1       	ldd	r24, Z+33	; 0x21
    1a88:	8f 3f       	cpi	r24, 0xFF	; 255
    1a8a:	09 f4       	brne	.+2      	; 0x1a8e <xQueueGenericReceive+0xe6>
    1a8c:	11 a2       	std	Z+33, r1	; 0x21
    1a8e:	f7 01       	movw	r30, r14
    1a90:	82 a1       	ldd	r24, Z+34	; 0x22
    1a92:	8f 3f       	cpi	r24, 0xFF	; 255
    1a94:	09 f4       	brne	.+2      	; 0x1a98 <xQueueGenericReceive+0xf0>
    1a96:	12 a2       	std	Z+34, r1	; 0x22
    1a98:	0f 90       	pop	r0
    1a9a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1a9c:	be 01       	movw	r22, r28
    1a9e:	6a 5f       	subi	r22, 0xFA	; 250
    1aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa2:	ce 01       	movw	r24, r28
    1aa4:	01 96       	adiw	r24, 0x01	; 1
    1aa6:	0e 94 12 12 	call	0x2424	; 0x2424 <xTaskCheckForTimeOut>
    1aaa:	81 11       	cpse	r24, r1
    1aac:	2d c0       	rjmp	.+90     	; 0x1b08 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1ab4:	f7 01       	movw	r30, r14
    1ab6:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1abc:	81 11       	cpse	r24, r1
    1abe:	1e c0       	rjmp	.+60     	; 0x1afc <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ac0:	80 81       	ld	r24, Z
    1ac2:	91 81       	ldd	r25, Z+1	; 0x01
    1ac4:	89 2b       	or	r24, r25
    1ac6:	49 f4       	brne	.+18     	; 0x1ada <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	0e 94 a1 12 	call	0x2542	; 0x2542 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1ad6:	0f 90       	pop	r0
    1ad8:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ada:	4e 81       	ldd	r20, Y+6	; 0x06
    1adc:	5f 81       	ldd	r21, Y+7	; 0x07
    1ade:	68 85       	ldd	r22, Y+8	; 0x08
    1ae0:	79 85       	ldd	r23, Y+9	; 0x09
    1ae2:	c6 01       	movw	r24, r12
    1ae4:	0e 94 98 11 	call	0x2330	; 0x2330 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1ae8:	c7 01       	movw	r24, r14
    1aea:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1aee:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
    1af2:	81 11       	cpse	r24, r1
    1af4:	73 cf       	rjmp	.-282    	; 0x19dc <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1af6:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    1afa:	70 cf       	rjmp	.-288    	; 0x19dc <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1afc:	c7 01       	movw	r24, r14
    1afe:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b02:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
    1b06:	6a cf       	rjmp	.-300    	; 0x19dc <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b08:	c7 01       	movw	r24, r14
    1b0a:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b0e:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b12:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b14:	29 96       	adiw	r28, 0x09	; 9
    1b16:	cd bf       	out	0x3d, r28	; 61
    1b18:	de bf       	out	0x3e, r29	; 62
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	1f 91       	pop	r17
    1b20:	0f 91       	pop	r16
    1b22:	ff 90       	pop	r15
    1b24:	ef 90       	pop	r14
    1b26:	df 90       	pop	r13
    1b28:	cf 90       	pop	r12
    1b2a:	bf 90       	pop	r11
    1b2c:	af 90       	pop	r10
    1b2e:	08 95       	ret

00001b30 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1b30:	0f 93       	push	r16
    1b32:	1f 93       	push	r17
    1b34:	cf 93       	push	r28
    1b36:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b38:	fc 01       	movw	r30, r24
    1b3a:	26 8d       	ldd	r18, Z+30	; 0x1e
    1b3c:	22 23       	and	r18, r18
    1b3e:	d9 f0       	breq	.+54     	; 0x1b76 <xQueueReceiveFromISR+0x46>
    1b40:	8a 01       	movw	r16, r20
    1b42:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b44:	0e 94 3f 0b 	call	0x167e	; 0x167e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1b48:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b4a:	81 50       	subi	r24, 0x01	; 1
    1b4c:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1b4e:	89 a1       	ldd	r24, Y+33	; 0x21
    1b50:	8f 3f       	cpi	r24, 0xFF	; 255
    1b52:	69 f4       	brne	.+26     	; 0x1b6e <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b54:	88 85       	ldd	r24, Y+8	; 0x08
    1b56:	88 23       	and	r24, r24
    1b58:	81 f0       	breq	.+32     	; 0x1b7a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b5a:	ce 01       	movw	r24, r28
    1b5c:	08 96       	adiw	r24, 0x08	; 8
    1b5e:	0e 94 c2 11 	call	0x2384	; 0x2384 <xTaskRemoveFromEventList>
    1b62:	88 23       	and	r24, r24
    1b64:	61 f0       	breq	.+24     	; 0x1b7e <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1b66:	81 e0       	ldi	r24, 0x01	; 1
    1b68:	f8 01       	movw	r30, r16
    1b6a:	80 83       	st	Z, r24
    1b6c:	09 c0       	rjmp	.+18     	; 0x1b80 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1b6e:	8f 5f       	subi	r24, 0xFF	; 255
    1b70:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	05 c0       	rjmp	.+10     	; 0x1b80 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1b76:	80 e0       	ldi	r24, 0x00	; 0
    1b78:	03 c0       	rjmp	.+6      	; 0x1b80 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	01 c0       	rjmp	.+2      	; 0x1b80 <xQueueReceiveFromISR+0x50>
    1b7e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b80:	df 91       	pop	r29
    1b82:	cf 91       	pop	r28
    1b84:	1f 91       	pop	r17
    1b86:	0f 91       	pop	r16
    1b88:	08 95       	ret

00001b8a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b8a:	0f b6       	in	r0, 0x3f	; 63
    1b8c:	f8 94       	cli
    1b8e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1b90:	fc 01       	movw	r30, r24
    1b92:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b94:	0f 90       	pop	r0
    1b96:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1b98:	08 95       	ret

00001b9a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1b9a:	fc 01       	movw	r30, r24
    1b9c:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1b9e:	08 95       	ret

00001ba0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1ba0:	c6 e1       	ldi	r28, 0x16	; 22
    1ba2:	d1 e3       	ldi	r29, 0x31	; 49
    1ba4:	88 81       	ld	r24, Y
    1ba6:	82 30       	cpi	r24, 0x02	; 2
    1ba8:	e8 f3       	brcs	.-6      	; 0x1ba4 <prvIdleTask+0x4>
    1baa:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    1bae:	fa cf       	rjmp	.-12     	; 0x1ba4 <prvIdleTask+0x4>

00001bb0 <prvAddCurrentTaskToDelayedList>:
    1bb0:	cf 92       	push	r12
    1bb2:	df 92       	push	r13
    1bb4:	ef 92       	push	r14
    1bb6:	ff 92       	push	r15
    1bb8:	6b 01       	movw	r12, r22
    1bba:	7c 01       	movw	r14, r24
    1bbc:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1bc0:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1bc4:	62 83       	std	Z+2, r22	; 0x02
    1bc6:	73 83       	std	Z+3, r23	; 0x03
    1bc8:	84 83       	std	Z+4, r24	; 0x04
    1bca:	95 83       	std	Z+5, r25	; 0x05
    1bcc:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    1bd0:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1bd4:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1bd8:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1bdc:	c8 16       	cp	r12, r24
    1bde:	d9 06       	cpc	r13, r25
    1be0:	ea 06       	cpc	r14, r26
    1be2:	fb 06       	cpc	r15, r27
    1be4:	68 f4       	brcc	.+26     	; 0x1c00 <prvAddCurrentTaskToDelayedList+0x50>
    1be6:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    1bea:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1bee:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <pxOverflowDelayedTaskList>
    1bf2:	90 91 fd 30 	lds	r25, 0x30FD	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1bf6:	6e 5f       	subi	r22, 0xFE	; 254
    1bf8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bfa:	0e 94 07 09 	call	0x120e	; 0x120e <vListInsert>
    1bfe:	21 c0       	rjmp	.+66     	; 0x1c42 <prvAddCurrentTaskToDelayedList+0x92>
    1c00:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    1c04:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1c08:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    1c0c:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    1c10:	6e 5f       	subi	r22, 0xFE	; 254
    1c12:	7f 4f       	sbci	r23, 0xFF	; 255
    1c14:	0e 94 07 09 	call	0x120e	; 0x120e <vListInsert>
    1c18:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1c1c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c20:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c24:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c28:	c8 16       	cp	r12, r24
    1c2a:	d9 06       	cpc	r13, r25
    1c2c:	ea 06       	cpc	r14, r26
    1c2e:	fb 06       	cpc	r15, r27
    1c30:	40 f4       	brcc	.+16     	; 0x1c42 <prvAddCurrentTaskToDelayedList+0x92>
    1c32:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1c36:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c3a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c3e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	08 95       	ret

00001c4c <xTaskGenericCreate>:
    1c4c:	4f 92       	push	r4
    1c4e:	5f 92       	push	r5
    1c50:	6f 92       	push	r6
    1c52:	7f 92       	push	r7
    1c54:	8f 92       	push	r8
    1c56:	9f 92       	push	r9
    1c58:	af 92       	push	r10
    1c5a:	bf 92       	push	r11
    1c5c:	cf 92       	push	r12
    1c5e:	df 92       	push	r13
    1c60:	ef 92       	push	r14
    1c62:	ff 92       	push	r15
    1c64:	0f 93       	push	r16
    1c66:	1f 93       	push	r17
    1c68:	cf 93       	push	r28
    1c6a:	df 93       	push	r29
    1c6c:	5c 01       	movw	r10, r24
    1c6e:	4b 01       	movw	r8, r22
    1c70:	3a 01       	movw	r6, r20
    1c72:	29 01       	movw	r4, r18
    1c74:	88 e2       	ldi	r24, 0x28	; 40
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    1c7c:	ec 01       	movw	r28, r24
    1c7e:	89 2b       	or	r24, r25
    1c80:	09 f4       	brne	.+2      	; 0x1c84 <xTaskGenericCreate+0x38>
    1c82:	d4 c0       	rjmp	.+424    	; 0x1e2c <xTaskGenericCreate+0x1e0>
    1c84:	c1 14       	cp	r12, r1
    1c86:	d1 04       	cpc	r13, r1
    1c88:	09 f0       	breq	.+2      	; 0x1c8c <xTaskGenericCreate+0x40>
    1c8a:	cc c0       	rjmp	.+408    	; 0x1e24 <xTaskGenericCreate+0x1d8>
    1c8c:	c3 01       	movw	r24, r6
    1c8e:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    1c92:	8b 8f       	std	Y+27, r24	; 0x1b
    1c94:	9c 8f       	std	Y+28, r25	; 0x1c
    1c96:	00 97       	sbiw	r24, 0x00	; 0
    1c98:	21 f4       	brne	.+8      	; 0x1ca2 <xTaskGenericCreate+0x56>
    1c9a:	ce 01       	movw	r24, r28
    1c9c:	0e 94 93 08 	call	0x1126	; 0x1126 <vPortFree>
    1ca0:	c5 c0       	rjmp	.+394    	; 0x1e2c <xTaskGenericCreate+0x1e0>
    1ca2:	a3 01       	movw	r20, r6
    1ca4:	61 e1       	ldi	r22, 0x11	; 17
    1ca6:	70 e0       	ldi	r23, 0x00	; 0
    1ca8:	0e 94 32 20 	call	0x4064	; 0x4064 <memset>
    1cac:	93 01       	movw	r18, r6
    1cae:	21 50       	subi	r18, 0x01	; 1
    1cb0:	31 09       	sbc	r19, r1
    1cb2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cb4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1cb6:	3c 01       	movw	r6, r24
    1cb8:	62 0e       	add	r6, r18
    1cba:	73 1e       	adc	r7, r19
    1cbc:	4a e0       	ldi	r20, 0x0A	; 10
    1cbe:	50 e0       	ldi	r21, 0x00	; 0
    1cc0:	b4 01       	movw	r22, r8
    1cc2:	ce 01       	movw	r24, r28
    1cc4:	4d 96       	adiw	r24, 0x1d	; 29
    1cc6:	0e 94 39 20 	call	0x4072	; 0x4072 <strncpy>
    1cca:	1e a2       	std	Y+38, r1	; 0x26
    1ccc:	10 2f       	mov	r17, r16
    1cce:	04 30       	cpi	r16, 0x04	; 4
    1cd0:	08 f0       	brcs	.+2      	; 0x1cd4 <xTaskGenericCreate+0x88>
    1cd2:	13 e0       	ldi	r17, 0x03	; 3
    1cd4:	1a 8f       	std	Y+26, r17	; 0x1a
    1cd6:	1f a3       	std	Y+39, r17	; 0x27
    1cd8:	6e 01       	movw	r12, r28
    1cda:	22 e0       	ldi	r18, 0x02	; 2
    1cdc:	c2 0e       	add	r12, r18
    1cde:	d1 1c       	adc	r13, r1
    1ce0:	c6 01       	movw	r24, r12
    1ce2:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <vListInitialiseItem>
    1ce6:	ce 01       	movw	r24, r28
    1ce8:	0e 96       	adiw	r24, 0x0e	; 14
    1cea:	0e 94 dc 08 	call	0x11b8	; 0x11b8 <vListInitialiseItem>
    1cee:	ca 87       	std	Y+10, r28	; 0x0a
    1cf0:	db 87       	std	Y+11, r29	; 0x0b
    1cf2:	84 e0       	ldi	r24, 0x04	; 4
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	a0 e0       	ldi	r26, 0x00	; 0
    1cf8:	b0 e0       	ldi	r27, 0x00	; 0
    1cfa:	81 1b       	sub	r24, r17
    1cfc:	91 09       	sbc	r25, r1
    1cfe:	a1 09       	sbc	r26, r1
    1d00:	b1 09       	sbc	r27, r1
    1d02:	8e 87       	std	Y+14, r24	; 0x0e
    1d04:	9f 87       	std	Y+15, r25	; 0x0f
    1d06:	a8 8b       	std	Y+16, r26	; 0x10
    1d08:	b9 8b       	std	Y+17, r27	; 0x11
    1d0a:	ce 8b       	std	Y+22, r28	; 0x16
    1d0c:	df 8b       	std	Y+23, r29	; 0x17
    1d0e:	a2 01       	movw	r20, r4
    1d10:	b5 01       	movw	r22, r10
    1d12:	c3 01       	movw	r24, r6
    1d14:	0e 94 78 09 	call	0x12f0	; 0x12f0 <pxPortInitialiseStack>
    1d18:	88 83       	st	Y, r24
    1d1a:	99 83       	std	Y+1, r25	; 0x01
    1d1c:	e1 14       	cp	r14, r1
    1d1e:	f1 04       	cpc	r15, r1
    1d20:	19 f0       	breq	.+6      	; 0x1d28 <xTaskGenericCreate+0xdc>
    1d22:	f7 01       	movw	r30, r14
    1d24:	c0 83       	st	Z, r28
    1d26:	d1 83       	std	Z+1, r29	; 0x01
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	0f 92       	push	r0
    1d2e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    1d32:	8f 5f       	subi	r24, 0xFF	; 255
    1d34:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxCurrentNumberOfTasks>
    1d38:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    1d3c:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1d40:	89 2b       	or	r24, r25
    1d42:	89 f5       	brne	.+98     	; 0x1da6 <xTaskGenericCreate+0x15a>
    1d44:	c0 93 42 31 	sts	0x3142, r28	; 0x803142 <pxCurrentTCB>
    1d48:	d0 93 43 31 	sts	0x3143, r29	; 0x803143 <pxCurrentTCB+0x1>
    1d4c:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    1d50:	81 30       	cpi	r24, 0x01	; 1
    1d52:	c1 f5       	brne	.+112    	; 0x1dc4 <xTaskGenericCreate+0x178>
    1d54:	86 e1       	ldi	r24, 0x16	; 22
    1d56:	91 e3       	ldi	r25, 0x31	; 49
    1d58:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d5c:	81 e2       	ldi	r24, 0x21	; 33
    1d5e:	91 e3       	ldi	r25, 0x31	; 49
    1d60:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d64:	8c e2       	ldi	r24, 0x2C	; 44
    1d66:	91 e3       	ldi	r25, 0x31	; 49
    1d68:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d6c:	87 e3       	ldi	r24, 0x37	; 55
    1d6e:	91 e3       	ldi	r25, 0x31	; 49
    1d70:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d74:	8b e0       	ldi	r24, 0x0B	; 11
    1d76:	91 e3       	ldi	r25, 0x31	; 49
    1d78:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d7c:	80 e0       	ldi	r24, 0x00	; 0
    1d7e:	91 e3       	ldi	r25, 0x31	; 49
    1d80:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d84:	81 ef       	ldi	r24, 0xF1	; 241
    1d86:	90 e3       	ldi	r25, 0x30	; 48
    1d88:	0e 94 cb 08 	call	0x1196	; 0x1196 <vListInitialise>
    1d8c:	8b e0       	ldi	r24, 0x0B	; 11
    1d8e:	91 e3       	ldi	r25, 0x31	; 49
    1d90:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <pxDelayedTaskList>
    1d94:	90 93 ff 30 	sts	0x30FF, r25	; 0x8030ff <pxDelayedTaskList+0x1>
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	91 e3       	ldi	r25, 0x31	; 49
    1d9c:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <pxOverflowDelayedTaskList>
    1da0:	90 93 fd 30 	sts	0x30FD, r25	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1da4:	0f c0       	rjmp	.+30     	; 0x1dc4 <xTaskGenericCreate+0x178>
    1da6:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xSchedulerRunning>
    1daa:	81 11       	cpse	r24, r1
    1dac:	0b c0       	rjmp	.+22     	; 0x1dc4 <xTaskGenericCreate+0x178>
    1dae:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1db2:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1db6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1db8:	08 17       	cp	r16, r24
    1dba:	20 f0       	brcs	.+8      	; 0x1dc4 <xTaskGenericCreate+0x178>
    1dbc:	c0 93 42 31 	sts	0x3142, r28	; 0x803142 <pxCurrentTCB>
    1dc0:	d0 93 43 31 	sts	0x3143, r29	; 0x803143 <pxCurrentTCB+0x1>
    1dc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dc6:	90 91 e9 30 	lds	r25, 0x30E9	; 0x8030e9 <uxTopUsedPriority>
    1dca:	98 17       	cp	r25, r24
    1dcc:	10 f4       	brcc	.+4      	; 0x1dd2 <xTaskGenericCreate+0x186>
    1dce:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <uxTopUsedPriority>
    1dd2:	90 91 e2 30 	lds	r25, 0x30E2	; 0x8030e2 <uxTaskNumber>
    1dd6:	9f 5f       	subi	r25, 0xFF	; 255
    1dd8:	90 93 e2 30 	sts	0x30E2, r25	; 0x8030e2 <uxTaskNumber>
    1ddc:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    1de0:	98 17       	cp	r25, r24
    1de2:	10 f4       	brcc	.+4      	; 0x1de8 <xTaskGenericCreate+0x19c>
    1de4:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    1de8:	fb e0       	ldi	r31, 0x0B	; 11
    1dea:	8f 9f       	mul	r24, r31
    1dec:	c0 01       	movw	r24, r0
    1dee:	11 24       	eor	r1, r1
    1df0:	b6 01       	movw	r22, r12
    1df2:	8a 5e       	subi	r24, 0xEA	; 234
    1df4:	9e 4c       	sbci	r25, 0xCE	; 206
    1df6:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
    1dfa:	0f 90       	pop	r0
    1dfc:	0f be       	out	0x3f, r0	; 63
    1dfe:	80 91 e7 30 	lds	r24, 0x30E7	; 0x8030e7 <xSchedulerRunning>
    1e02:	88 23       	and	r24, r24
    1e04:	59 f0       	breq	.+22     	; 0x1e1c <xTaskGenericCreate+0x1d0>
    1e06:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    1e0a:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1e0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e10:	80 17       	cp	r24, r16
    1e12:	30 f4       	brcc	.+12     	; 0x1e20 <xTaskGenericCreate+0x1d4>
    1e14:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	09 c0       	rjmp	.+18     	; 0x1e2e <xTaskGenericCreate+0x1e2>
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	07 c0       	rjmp	.+14     	; 0x1e2e <xTaskGenericCreate+0x1e2>
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	05 c0       	rjmp	.+10     	; 0x1e2e <xTaskGenericCreate+0x1e2>
    1e24:	cb 8e       	std	Y+27, r12	; 0x1b
    1e26:	dc 8e       	std	Y+28, r13	; 0x1c
    1e28:	c6 01       	movw	r24, r12
    1e2a:	3b cf       	rjmp	.-394    	; 0x1ca2 <xTaskGenericCreate+0x56>
    1e2c:	8f ef       	ldi	r24, 0xFF	; 255
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16
    1e36:	ff 90       	pop	r15
    1e38:	ef 90       	pop	r14
    1e3a:	df 90       	pop	r13
    1e3c:	cf 90       	pop	r12
    1e3e:	bf 90       	pop	r11
    1e40:	af 90       	pop	r10
    1e42:	9f 90       	pop	r9
    1e44:	8f 90       	pop	r8
    1e46:	7f 90       	pop	r7
    1e48:	6f 90       	pop	r6
    1e4a:	5f 90       	pop	r5
    1e4c:	4f 90       	pop	r4
    1e4e:	08 95       	ret

00001e50 <uxTaskPriorityGet>:
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
    1e56:	00 97       	sbiw	r24, 0x00	; 0
    1e58:	21 f4       	brne	.+8      	; 0x1e62 <uxTaskPriorityGet+0x12>
    1e5a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    1e5e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1e62:	0f 90       	pop	r0
    1e64:	0f be       	out	0x3f, r0	; 63
    1e66:	fc 01       	movw	r30, r24
    1e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e6a:	08 95       	ret

00001e6c <vTaskStartScheduler>:
    1e6c:	af 92       	push	r10
    1e6e:	bf 92       	push	r11
    1e70:	cf 92       	push	r12
    1e72:	df 92       	push	r13
    1e74:	ef 92       	push	r14
    1e76:	ff 92       	push	r15
    1e78:	0f 93       	push	r16
    1e7a:	a1 2c       	mov	r10, r1
    1e7c:	b1 2c       	mov	r11, r1
    1e7e:	c1 2c       	mov	r12, r1
    1e80:	d1 2c       	mov	r13, r1
    1e82:	0f 2e       	mov	r0, r31
    1e84:	ff ee       	ldi	r31, 0xEF	; 239
    1e86:	ef 2e       	mov	r14, r31
    1e88:	f0 e3       	ldi	r31, 0x30	; 48
    1e8a:	ff 2e       	mov	r15, r31
    1e8c:	f0 2d       	mov	r31, r0
    1e8e:	00 e0       	ldi	r16, 0x00	; 0
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	44 e6       	ldi	r20, 0x64	; 100
    1e96:	50 e0       	ldi	r21, 0x00	; 0
    1e98:	68 e2       	ldi	r22, 0x28	; 40
    1e9a:	70 e2       	ldi	r23, 0x20	; 32
    1e9c:	80 ed       	ldi	r24, 0xD0	; 208
    1e9e:	9d e0       	ldi	r25, 0x0D	; 13
    1ea0:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <xTaskGenericCreate>
    1ea4:	81 30       	cpi	r24, 0x01	; 1
    1ea6:	69 f4       	brne	.+26     	; 0x1ec2 <vTaskStartScheduler+0x56>
    1ea8:	f8 94       	cli
    1eaa:	80 93 e7 30 	sts	0x30E7, r24	; 0x8030e7 <xSchedulerRunning>
    1eae:	10 92 ea 30 	sts	0x30EA, r1	; 0x8030ea <xTickCount>
    1eb2:	10 92 eb 30 	sts	0x30EB, r1	; 0x8030eb <xTickCount+0x1>
    1eb6:	10 92 ec 30 	sts	0x30EC, r1	; 0x8030ec <xTickCount+0x2>
    1eba:	10 92 ed 30 	sts	0x30ED, r1	; 0x8030ed <xTickCount+0x3>
    1ebe:	0e 94 ee 09 	call	0x13dc	; 0x13dc <xPortStartScheduler>
    1ec2:	0f 91       	pop	r16
    1ec4:	ff 90       	pop	r15
    1ec6:	ef 90       	pop	r14
    1ec8:	df 90       	pop	r13
    1eca:	cf 90       	pop	r12
    1ecc:	bf 90       	pop	r11
    1ece:	af 90       	pop	r10
    1ed0:	08 95       	ret

00001ed2 <vTaskSuspendAll>:
    1ed2:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    1ed6:	8f 5f       	subi	r24, 0xFF	; 255
    1ed8:	80 93 e6 30 	sts	0x30E6, r24	; 0x8030e6 <uxSchedulerSuspended>
    1edc:	08 95       	ret

00001ede <xTaskGetTickCount>:
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	0f 92       	push	r0
    1ee4:	60 91 ea 30 	lds	r22, 0x30EA	; 0x8030ea <xTickCount>
    1ee8:	70 91 eb 30 	lds	r23, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1eec:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1ef0:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	08 95       	ret

00001efa <pcTaskGetTaskName>:
    1efa:	00 97       	sbiw	r24, 0x00	; 0
    1efc:	21 f4       	brne	.+8      	; 0x1f06 <pcTaskGetTaskName+0xc>
    1efe:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    1f02:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    1f06:	4d 96       	adiw	r24, 0x1d	; 29
    1f08:	08 95       	ret

00001f0a <xTaskGetIdleTaskHandle>:
    1f0a:	80 91 ef 30 	lds	r24, 0x30EF	; 0x8030ef <xIdleTaskHandle>
    1f0e:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <xIdleTaskHandle+0x1>
    1f12:	08 95       	ret

00001f14 <vTaskIncrementTick>:
    1f14:	ff 92       	push	r15
    1f16:	0f 93       	push	r16
    1f18:	1f 93       	push	r17
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    1f22:	81 11       	cpse	r24, r1
    1f24:	ed c0       	rjmp	.+474    	; 0x2100 <vTaskIncrementTick+0x1ec>
    1f26:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    1f2a:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1f2e:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1f32:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1f36:	01 96       	adiw	r24, 0x01	; 1
    1f38:	a1 1d       	adc	r26, r1
    1f3a:	b1 1d       	adc	r27, r1
    1f3c:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xTickCount>
    1f40:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <xTickCount+0x1>
    1f44:	a0 93 ec 30 	sts	0x30EC, r26	; 0x8030ec <xTickCount+0x2>
    1f48:	b0 93 ed 30 	sts	0x30ED, r27	; 0x8030ed <xTickCount+0x3>
    1f4c:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    1f50:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1f54:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1f58:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1f5c:	89 2b       	or	r24, r25
    1f5e:	8a 2b       	or	r24, r26
    1f60:	8b 2b       	or	r24, r27
    1f62:	f1 f5       	brne	.+124    	; 0x1fe0 <vTaskIncrementTick+0xcc>
    1f64:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    1f68:	90 91 ff 30 	lds	r25, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    1f6c:	20 91 fc 30 	lds	r18, 0x30FC	; 0x8030fc <pxOverflowDelayedTaskList>
    1f70:	30 91 fd 30 	lds	r19, 0x30FD	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1f74:	20 93 fe 30 	sts	0x30FE, r18	; 0x8030fe <pxDelayedTaskList>
    1f78:	30 93 ff 30 	sts	0x30FF, r19	; 0x8030ff <pxDelayedTaskList+0x1>
    1f7c:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <pxOverflowDelayedTaskList>
    1f80:	90 93 fd 30 	sts	0x30FD, r25	; 0x8030fd <pxOverflowDelayedTaskList+0x1>
    1f84:	80 91 e3 30 	lds	r24, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    1f88:	8f 5f       	subi	r24, 0xFF	; 255
    1f8a:	80 93 e3 30 	sts	0x30E3, r24	; 0x8030e3 <xNumOfOverflows>
    1f8e:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    1f92:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    1f96:	80 81       	ld	r24, Z
    1f98:	81 11       	cpse	r24, r1
    1f9a:	0c c0       	rjmp	.+24     	; 0x1fb4 <vTaskIncrementTick+0xa0>
    1f9c:	8f ef       	ldi	r24, 0xFF	; 255
    1f9e:	9f ef       	ldi	r25, 0xFF	; 255
    1fa0:	dc 01       	movw	r26, r24
    1fa2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1fa6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1faa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1fae:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1fb2:	16 c0       	rjmp	.+44     	; 0x1fe0 <vTaskIncrementTick+0xcc>
    1fb4:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    1fb8:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    1fbc:	07 80       	ldd	r0, Z+7	; 0x07
    1fbe:	f0 85       	ldd	r31, Z+8	; 0x08
    1fc0:	e0 2d       	mov	r30, r0
    1fc2:	00 84       	ldd	r0, Z+8	; 0x08
    1fc4:	f1 85       	ldd	r31, Z+9	; 0x09
    1fc6:	e0 2d       	mov	r30, r0
    1fc8:	82 81       	ldd	r24, Z+2	; 0x02
    1fca:	93 81       	ldd	r25, Z+3	; 0x03
    1fcc:	a4 81       	ldd	r26, Z+4	; 0x04
    1fce:	b5 81       	ldd	r27, Z+5	; 0x05
    1fd0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1fd4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1fd8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1fdc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1fe0:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    1fe4:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    1fe8:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    1fec:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    1ff0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1ff4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ff8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ffc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2000:	48 17       	cp	r20, r24
    2002:	59 07       	cpc	r21, r25
    2004:	6a 07       	cpc	r22, r26
    2006:	7b 07       	cpc	r23, r27
    2008:	08 f4       	brcc	.+2      	; 0x200c <vTaskIncrementTick+0xf8>
    200a:	7f c0       	rjmp	.+254    	; 0x210a <vTaskIncrementTick+0x1f6>
    200c:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    2010:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    2014:	80 81       	ld	r24, Z
    2016:	88 23       	and	r24, r24
    2018:	f9 f0       	breq	.+62     	; 0x2058 <vTaskIncrementTick+0x144>
    201a:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    201e:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    2022:	07 80       	ldd	r0, Z+7	; 0x07
    2024:	f0 85       	ldd	r31, Z+8	; 0x08
    2026:	e0 2d       	mov	r30, r0
    2028:	c0 85       	ldd	r28, Z+8	; 0x08
    202a:	d1 85       	ldd	r29, Z+9	; 0x09
    202c:	8a 81       	ldd	r24, Y+2	; 0x02
    202e:	9b 81       	ldd	r25, Y+3	; 0x03
    2030:	ac 81       	ldd	r26, Y+4	; 0x04
    2032:	bd 81       	ldd	r27, Y+5	; 0x05
    2034:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    2038:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    203c:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2040:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2044:	48 17       	cp	r20, r24
    2046:	59 07       	cpc	r21, r25
    2048:	6a 07       	cpc	r22, r26
    204a:	7b 07       	cpc	r23, r27
    204c:	58 f1       	brcs	.+86     	; 0x20a4 <vTaskIncrementTick+0x190>
    204e:	0f 2e       	mov	r0, r31
    2050:	fb e0       	ldi	r31, 0x0B	; 11
    2052:	ff 2e       	mov	r15, r31
    2054:	f0 2d       	mov	r31, r0
    2056:	2f c0       	rjmp	.+94     	; 0x20b6 <vTaskIncrementTick+0x1a2>
    2058:	8f ef       	ldi	r24, 0xFF	; 255
    205a:	9f ef       	ldi	r25, 0xFF	; 255
    205c:	dc 01       	movw	r26, r24
    205e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2062:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2066:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    206a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    206e:	4d c0       	rjmp	.+154    	; 0x210a <vTaskIncrementTick+0x1f6>
    2070:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    2074:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    2078:	07 80       	ldd	r0, Z+7	; 0x07
    207a:	f0 85       	ldd	r31, Z+8	; 0x08
    207c:	e0 2d       	mov	r30, r0
    207e:	c0 85       	ldd	r28, Z+8	; 0x08
    2080:	d1 85       	ldd	r29, Z+9	; 0x09
    2082:	8a 81       	ldd	r24, Y+2	; 0x02
    2084:	9b 81       	ldd	r25, Y+3	; 0x03
    2086:	ac 81       	ldd	r26, Y+4	; 0x04
    2088:	bd 81       	ldd	r27, Y+5	; 0x05
    208a:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    208e:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2092:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2096:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    209a:	48 17       	cp	r20, r24
    209c:	59 07       	cpc	r21, r25
    209e:	6a 07       	cpc	r22, r26
    20a0:	7b 07       	cpc	r23, r27
    20a2:	48 f4       	brcc	.+18     	; 0x20b6 <vTaskIncrementTick+0x1a2>
    20a4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20a8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20ac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20b0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    20b4:	2a c0       	rjmp	.+84     	; 0x210a <vTaskIncrementTick+0x1f6>
    20b6:	8e 01       	movw	r16, r28
    20b8:	0e 5f       	subi	r16, 0xFE	; 254
    20ba:	1f 4f       	sbci	r17, 0xFF	; 255
    20bc:	c8 01       	movw	r24, r16
    20be:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
    20c2:	88 8d       	ldd	r24, Y+24	; 0x18
    20c4:	99 8d       	ldd	r25, Y+25	; 0x19
    20c6:	89 2b       	or	r24, r25
    20c8:	21 f0       	breq	.+8      	; 0x20d2 <vTaskIncrementTick+0x1be>
    20ca:	ce 01       	movw	r24, r28
    20cc:	0e 96       	adiw	r24, 0x0e	; 14
    20ce:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
    20d2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20d4:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    20d8:	98 17       	cp	r25, r24
    20da:	10 f4       	brcc	.+4      	; 0x20e0 <vTaskIncrementTick+0x1cc>
    20dc:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    20e0:	f8 9e       	mul	r15, r24
    20e2:	c0 01       	movw	r24, r0
    20e4:	11 24       	eor	r1, r1
    20e6:	b8 01       	movw	r22, r16
    20e8:	8a 5e       	subi	r24, 0xEA	; 234
    20ea:	9e 4c       	sbci	r25, 0xCE	; 206
    20ec:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
    20f0:	e0 91 fe 30 	lds	r30, 0x30FE	; 0x8030fe <pxDelayedTaskList>
    20f4:	f0 91 ff 30 	lds	r31, 0x30FF	; 0x8030ff <pxDelayedTaskList+0x1>
    20f8:	80 81       	ld	r24, Z
    20fa:	81 11       	cpse	r24, r1
    20fc:	b9 cf       	rjmp	.-142    	; 0x2070 <vTaskIncrementTick+0x15c>
    20fe:	ac cf       	rjmp	.-168    	; 0x2058 <vTaskIncrementTick+0x144>
    2100:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    2104:	8f 5f       	subi	r24, 0xFF	; 255
    2106:	80 93 e5 30 	sts	0x30E5, r24	; 0x8030e5 <uxMissedTicks>
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	1f 91       	pop	r17
    2110:	0f 91       	pop	r16
    2112:	ff 90       	pop	r15
    2114:	08 95       	ret

00002116 <xTaskResumeAll>:
    2116:	cf 92       	push	r12
    2118:	df 92       	push	r13
    211a:	ef 92       	push	r14
    211c:	ff 92       	push	r15
    211e:	0f 93       	push	r16
    2120:	1f 93       	push	r17
    2122:	cf 93       	push	r28
    2124:	df 93       	push	r29
    2126:	0f b6       	in	r0, 0x3f	; 63
    2128:	f8 94       	cli
    212a:	0f 92       	push	r0
    212c:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    2130:	81 50       	subi	r24, 0x01	; 1
    2132:	80 93 e6 30 	sts	0x30E6, r24	; 0x8030e6 <uxSchedulerSuspended>
    2136:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    213a:	81 11       	cpse	r24, r1
    213c:	60 c0       	rjmp	.+192    	; 0x21fe <xTaskResumeAll+0xe8>
    213e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxCurrentNumberOfTasks>
    2142:	81 11       	cpse	r24, r1
    2144:	2c c0       	rjmp	.+88     	; 0x219e <xTaskResumeAll+0x88>
    2146:	5e c0       	rjmp	.+188    	; 0x2204 <xTaskResumeAll+0xee>
    2148:	d7 01       	movw	r26, r14
    214a:	17 96       	adiw	r26, 0x07	; 7
    214c:	ed 91       	ld	r30, X+
    214e:	fc 91       	ld	r31, X
    2150:	18 97       	sbiw	r26, 0x08	; 8
    2152:	c0 85       	ldd	r28, Z+8	; 0x08
    2154:	d1 85       	ldd	r29, Z+9	; 0x09
    2156:	ce 01       	movw	r24, r28
    2158:	0e 96       	adiw	r24, 0x0e	; 14
    215a:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
    215e:	8e 01       	movw	r16, r28
    2160:	0e 5f       	subi	r16, 0xFE	; 254
    2162:	1f 4f       	sbci	r17, 0xFF	; 255
    2164:	c8 01       	movw	r24, r16
    2166:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
    216a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    216c:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2170:	98 17       	cp	r25, r24
    2172:	10 f4       	brcc	.+4      	; 0x2178 <xTaskResumeAll+0x62>
    2174:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    2178:	d8 9e       	mul	r13, r24
    217a:	c0 01       	movw	r24, r0
    217c:	11 24       	eor	r1, r1
    217e:	b8 01       	movw	r22, r16
    2180:	8a 5e       	subi	r24, 0xEA	; 234
    2182:	9e 4c       	sbci	r25, 0xCE	; 206
    2184:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
    2188:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    218c:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2190:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2192:	82 8d       	ldd	r24, Z+26	; 0x1a
    2194:	98 17       	cp	r25, r24
    2196:	70 f0       	brcs	.+28     	; 0x21b4 <xTaskResumeAll+0x9e>
    2198:	cc 24       	eor	r12, r12
    219a:	c3 94       	inc	r12
    219c:	0b c0       	rjmp	.+22     	; 0x21b4 <xTaskResumeAll+0x9e>
    219e:	c1 2c       	mov	r12, r1
    21a0:	0f 2e       	mov	r0, r31
    21a2:	f1 ef       	ldi	r31, 0xF1	; 241
    21a4:	ef 2e       	mov	r14, r31
    21a6:	f0 e3       	ldi	r31, 0x30	; 48
    21a8:	ff 2e       	mov	r15, r31
    21aa:	f0 2d       	mov	r31, r0
    21ac:	0f 2e       	mov	r0, r31
    21ae:	fb e0       	ldi	r31, 0x0B	; 11
    21b0:	df 2e       	mov	r13, r31
    21b2:	f0 2d       	mov	r31, r0
    21b4:	f7 01       	movw	r30, r14
    21b6:	80 81       	ld	r24, Z
    21b8:	81 11       	cpse	r24, r1
    21ba:	c6 cf       	rjmp	.-116    	; 0x2148 <xTaskResumeAll+0x32>
    21bc:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    21c0:	88 23       	and	r24, r24
    21c2:	81 f0       	breq	.+32     	; 0x21e4 <xTaskResumeAll+0xce>
    21c4:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    21c8:	88 23       	and	r24, r24
    21ca:	99 f0       	breq	.+38     	; 0x21f2 <xTaskResumeAll+0xdc>
    21cc:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <vTaskIncrementTick>
    21d0:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    21d4:	81 50       	subi	r24, 0x01	; 1
    21d6:	80 93 e5 30 	sts	0x30E5, r24	; 0x8030e5 <uxMissedTicks>
    21da:	80 91 e5 30 	lds	r24, 0x30E5	; 0x8030e5 <uxMissedTicks>
    21de:	81 11       	cpse	r24, r1
    21e0:	f5 cf       	rjmp	.-22     	; 0x21cc <xTaskResumeAll+0xb6>
    21e2:	07 c0       	rjmp	.+14     	; 0x21f2 <xTaskResumeAll+0xdc>
    21e4:	f1 e0       	ldi	r31, 0x01	; 1
    21e6:	cf 16       	cp	r12, r31
    21e8:	21 f0       	breq	.+8      	; 0x21f2 <xTaskResumeAll+0xdc>
    21ea:	80 91 e4 30 	lds	r24, 0x30E4	; 0x8030e4 <xMissedYield>
    21ee:	81 30       	cpi	r24, 0x01	; 1
    21f0:	41 f4       	brne	.+16     	; 0x2202 <xTaskResumeAll+0xec>
    21f2:	10 92 e4 30 	sts	0x30E4, r1	; 0x8030e4 <xMissedYield>
    21f6:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
    21fa:	81 e0       	ldi	r24, 0x01	; 1
    21fc:	03 c0       	rjmp	.+6      	; 0x2204 <xTaskResumeAll+0xee>
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	01 c0       	rjmp	.+2      	; 0x2204 <xTaskResumeAll+0xee>
    2202:	80 e0       	ldi	r24, 0x00	; 0
    2204:	0f 90       	pop	r0
    2206:	0f be       	out	0x3f, r0	; 63
    2208:	df 91       	pop	r29
    220a:	cf 91       	pop	r28
    220c:	1f 91       	pop	r17
    220e:	0f 91       	pop	r16
    2210:	ff 90       	pop	r15
    2212:	ef 90       	pop	r14
    2214:	df 90       	pop	r13
    2216:	cf 90       	pop	r12
    2218:	08 95       	ret

0000221a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    221a:	cf 92       	push	r12
    221c:	df 92       	push	r13
    221e:	ef 92       	push	r14
    2220:	ff 92       	push	r15
    2222:	6b 01       	movw	r12, r22
    2224:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2226:	67 2b       	or	r22, r23
    2228:	68 2b       	or	r22, r24
    222a:	69 2b       	or	r22, r25
    222c:	e9 f0       	breq	.+58     	; 0x2268 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    222e:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2232:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2236:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    223a:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    223e:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2242:	c8 0e       	add	r12, r24
    2244:	d9 1e       	adc	r13, r25
    2246:	ea 1e       	adc	r14, r26
    2248:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    224a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    224e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2252:	02 96       	adiw	r24, 0x02	; 2
    2254:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2258:	c7 01       	movw	r24, r14
    225a:	b6 01       	movw	r22, r12
    225c:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2260:	0e 94 8b 10 	call	0x2116	; 0x2116 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2264:	81 11       	cpse	r24, r1
    2266:	02 c0       	rjmp	.+4      	; 0x226c <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2268:	0e 94 2c 0a 	call	0x1458	; 0x1458 <vPortYield>
		}
	}
    226c:	ff 90       	pop	r15
    226e:	ef 90       	pop	r14
    2270:	df 90       	pop	r13
    2272:	cf 90       	pop	r12
    2274:	08 95       	ret

00002276 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2276:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    227a:	81 11       	cpse	r24, r1
    227c:	0c c0       	rjmp	.+24     	; 0x2296 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    227e:	e0 91 e8 30 	lds	r30, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2282:	4b e0       	ldi	r20, 0x0B	; 11
    2284:	e4 9f       	mul	r30, r20
    2286:	f0 01       	movw	r30, r0
    2288:	11 24       	eor	r1, r1
    228a:	ea 5e       	subi	r30, 0xEA	; 234
    228c:	fe 4c       	sbci	r31, 0xCE	; 206
    228e:	80 81       	ld	r24, Z
    2290:	88 23       	and	r24, r24
    2292:	29 f0       	breq	.+10     	; 0x229e <vTaskSwitchContext+0x28>
    2294:	14 c0       	rjmp	.+40     	; 0x22be <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	80 93 e4 30 	sts	0x30E4, r24	; 0x8030e4 <xMissedYield>
    229c:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    229e:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    22a0:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    22a4:	81 50       	subi	r24, 0x01	; 1
    22a6:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22aa:	e0 91 e8 30 	lds	r30, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    22ae:	9e 9f       	mul	r25, r30
    22b0:	f0 01       	movw	r30, r0
    22b2:	11 24       	eor	r1, r1
    22b4:	ea 5e       	subi	r30, 0xEA	; 234
    22b6:	fe 4c       	sbci	r31, 0xCE	; 206
    22b8:	80 81       	ld	r24, Z
    22ba:	88 23       	and	r24, r24
    22bc:	89 f3       	breq	.-30     	; 0x22a0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    22be:	80 91 e8 30 	lds	r24, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    22c2:	28 2f       	mov	r18, r24
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	4b e0       	ldi	r20, 0x0B	; 11
    22c8:	84 9f       	mul	r24, r20
    22ca:	c0 01       	movw	r24, r0
    22cc:	11 24       	eor	r1, r1
    22ce:	dc 01       	movw	r26, r24
    22d0:	aa 5e       	subi	r26, 0xEA	; 234
    22d2:	be 4c       	sbci	r27, 0xCE	; 206
    22d4:	11 96       	adiw	r26, 0x01	; 1
    22d6:	ed 91       	ld	r30, X+
    22d8:	fc 91       	ld	r31, X
    22da:	12 97       	sbiw	r26, 0x02	; 2
    22dc:	04 80       	ldd	r0, Z+4	; 0x04
    22de:	f5 81       	ldd	r31, Z+5	; 0x05
    22e0:	e0 2d       	mov	r30, r0
    22e2:	11 96       	adiw	r26, 0x01	; 1
    22e4:	ed 93       	st	X+, r30
    22e6:	fc 93       	st	X, r31
    22e8:	12 97       	sbiw	r26, 0x02	; 2
    22ea:	87 5e       	subi	r24, 0xE7	; 231
    22ec:	9e 4c       	sbci	r25, 0xCE	; 206
    22ee:	e8 17       	cp	r30, r24
    22f0:	f9 07       	cpc	r31, r25
    22f2:	61 f4       	brne	.+24     	; 0x230c <vTaskSwitchContext+0x96>
    22f4:	84 81       	ldd	r24, Z+4	; 0x04
    22f6:	95 81       	ldd	r25, Z+5	; 0x05
    22f8:	4b e0       	ldi	r20, 0x0B	; 11
    22fa:	42 9f       	mul	r20, r18
    22fc:	f0 01       	movw	r30, r0
    22fe:	43 9f       	mul	r20, r19
    2300:	f0 0d       	add	r31, r0
    2302:	11 24       	eor	r1, r1
    2304:	ea 5e       	subi	r30, 0xEA	; 234
    2306:	fe 4c       	sbci	r31, 0xCE	; 206
    2308:	81 83       	std	Z+1, r24	; 0x01
    230a:	92 83       	std	Z+2, r25	; 0x02
    230c:	8b e0       	ldi	r24, 0x0B	; 11
    230e:	82 9f       	mul	r24, r18
    2310:	f0 01       	movw	r30, r0
    2312:	83 9f       	mul	r24, r19
    2314:	f0 0d       	add	r31, r0
    2316:	11 24       	eor	r1, r1
    2318:	ea 5e       	subi	r30, 0xEA	; 234
    231a:	fe 4c       	sbci	r31, 0xCE	; 206
    231c:	01 80       	ldd	r0, Z+1	; 0x01
    231e:	f2 81       	ldd	r31, Z+2	; 0x02
    2320:	e0 2d       	mov	r30, r0
    2322:	80 85       	ldd	r24, Z+8	; 0x08
    2324:	91 85       	ldd	r25, Z+9	; 0x09
    2326:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <pxCurrentTCB>
    232a:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <pxCurrentTCB+0x1>
    232e:	08 95       	ret

00002330 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2330:	cf 92       	push	r12
    2332:	df 92       	push	r13
    2334:	ef 92       	push	r14
    2336:	ff 92       	push	r15
    2338:	6a 01       	movw	r12, r20
    233a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    233c:	60 91 42 31 	lds	r22, 0x3142	; 0x803142 <pxCurrentTCB>
    2340:	70 91 43 31 	lds	r23, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2344:	62 5f       	subi	r22, 0xF2	; 242
    2346:	7f 4f       	sbci	r23, 0xFF	; 255
    2348:	0e 94 07 09 	call	0x120e	; 0x120e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    234c:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    2350:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2354:	02 96       	adiw	r24, 0x02	; 2
    2356:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    235a:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    235e:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2362:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2366:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    236a:	bc 01       	movw	r22, r24
    236c:	cd 01       	movw	r24, r26
    236e:	6c 0d       	add	r22, r12
    2370:	7d 1d       	adc	r23, r13
    2372:	8e 1d       	adc	r24, r14
    2374:	9f 1d       	adc	r25, r15
    2376:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    237a:	ff 90       	pop	r15
    237c:	ef 90       	pop	r14
    237e:	df 90       	pop	r13
    2380:	cf 90       	pop	r12
    2382:	08 95       	ret

00002384 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2384:	0f 93       	push	r16
    2386:	1f 93       	push	r17
    2388:	cf 93       	push	r28
    238a:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    238c:	dc 01       	movw	r26, r24
    238e:	17 96       	adiw	r26, 0x07	; 7
    2390:	ed 91       	ld	r30, X+
    2392:	fc 91       	ld	r31, X
    2394:	18 97       	sbiw	r26, 0x08	; 8
    2396:	c0 85       	ldd	r28, Z+8	; 0x08
    2398:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    239a:	8e 01       	movw	r16, r28
    239c:	02 5f       	subi	r16, 0xF2	; 242
    239e:	1f 4f       	sbci	r17, 0xFF	; 255
    23a0:	c8 01       	movw	r24, r16
    23a2:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23a6:	80 91 e6 30 	lds	r24, 0x30E6	; 0x8030e6 <uxSchedulerSuspended>
    23aa:	81 11       	cpse	r24, r1
    23ac:	16 c0       	rjmp	.+44     	; 0x23da <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23ae:	0c 50       	subi	r16, 0x0C	; 12
    23b0:	11 09       	sbc	r17, r1
    23b2:	c8 01       	movw	r24, r16
    23b4:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    23b8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    23ba:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    23be:	98 17       	cp	r25, r24
    23c0:	10 f4       	brcc	.+4      	; 0x23c6 <xTaskRemoveFromEventList+0x42>
    23c2:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    23c6:	bb e0       	ldi	r27, 0x0B	; 11
    23c8:	8b 9f       	mul	r24, r27
    23ca:	c0 01       	movw	r24, r0
    23cc:	11 24       	eor	r1, r1
    23ce:	b8 01       	movw	r22, r16
    23d0:	8a 5e       	subi	r24, 0xEA	; 234
    23d2:	9e 4c       	sbci	r25, 0xCE	; 206
    23d4:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
    23d8:	05 c0       	rjmp	.+10     	; 0x23e4 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    23da:	b8 01       	movw	r22, r16
    23dc:	81 ef       	ldi	r24, 0xF1	; 241
    23de:	90 e3       	ldi	r25, 0x30	; 48
    23e0:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23e4:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    23e8:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	2a 8d       	ldd	r18, Y+26	; 0x1a
    23f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    23f2:	29 17       	cp	r18, r25
    23f4:	08 f4       	brcc	.+2      	; 0x23f8 <xTaskRemoveFromEventList+0x74>
    23f6:	80 e0       	ldi	r24, 0x00	; 0
}
    23f8:	df 91       	pop	r29
    23fa:	cf 91       	pop	r28
    23fc:	1f 91       	pop	r17
    23fe:	0f 91       	pop	r16
    2400:	08 95       	ret

00002402 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2402:	20 91 e3 30 	lds	r18, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    2406:	fc 01       	movw	r30, r24
    2408:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    240a:	40 91 ea 30 	lds	r20, 0x30EA	; 0x8030ea <xTickCount>
    240e:	50 91 eb 30 	lds	r21, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2412:	60 91 ec 30 	lds	r22, 0x30EC	; 0x8030ec <xTickCount+0x2>
    2416:	70 91 ed 30 	lds	r23, 0x30ED	; 0x8030ed <xTickCount+0x3>
    241a:	41 83       	std	Z+1, r20	; 0x01
    241c:	52 83       	std	Z+2, r21	; 0x02
    241e:	63 83       	std	Z+3, r22	; 0x03
    2420:	74 83       	std	Z+4, r23	; 0x04
    2422:	08 95       	ret

00002424 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2424:	8f 92       	push	r8
    2426:	9f 92       	push	r9
    2428:	af 92       	push	r10
    242a:	bf 92       	push	r11
    242c:	cf 92       	push	r12
    242e:	df 92       	push	r13
    2430:	ef 92       	push	r14
    2432:	ff 92       	push	r15
    2434:	0f 93       	push	r16
    2436:	1f 93       	push	r17
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2444:	80 91 e3 30 	lds	r24, 0x30E3	; 0x8030e3 <xNumOfOverflows>
    2448:	90 81       	ld	r25, Z
    244a:	98 17       	cp	r25, r24
    244c:	89 f0       	breq	.+34     	; 0x2470 <xTaskCheckForTimeOut+0x4c>
    244e:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2452:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2456:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    245a:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    245e:	01 81       	ldd	r16, Z+1	; 0x01
    2460:	12 81       	ldd	r17, Z+2	; 0x02
    2462:	23 81       	ldd	r18, Z+3	; 0x03
    2464:	34 81       	ldd	r19, Z+4	; 0x04
    2466:	80 17       	cp	r24, r16
    2468:	91 07       	cpc	r25, r17
    246a:	a2 07       	cpc	r26, r18
    246c:	b3 07       	cpc	r27, r19
    246e:	a8 f5       	brcc	.+106    	; 0x24da <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2470:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xTickCount>
    2474:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <xTickCount+0x1>
    2478:	a0 91 ec 30 	lds	r26, 0x30EC	; 0x8030ec <xTickCount+0x2>
    247c:	b0 91 ed 30 	lds	r27, 0x30ED	; 0x8030ed <xTickCount+0x3>
    2480:	c1 80       	ldd	r12, Z+1	; 0x01
    2482:	d2 80       	ldd	r13, Z+2	; 0x02
    2484:	e3 80       	ldd	r14, Z+3	; 0x03
    2486:	f4 80       	ldd	r15, Z+4	; 0x04
    2488:	eb 01       	movw	r28, r22
    248a:	08 81       	ld	r16, Y
    248c:	19 81       	ldd	r17, Y+1	; 0x01
    248e:	2a 81       	ldd	r18, Y+2	; 0x02
    2490:	3b 81       	ldd	r19, Y+3	; 0x03
    2492:	8c 19       	sub	r24, r12
    2494:	9d 09       	sbc	r25, r13
    2496:	ae 09       	sbc	r26, r14
    2498:	bf 09       	sbc	r27, r15
    249a:	80 17       	cp	r24, r16
    249c:	91 07       	cpc	r25, r17
    249e:	a2 07       	cpc	r26, r18
    24a0:	b3 07       	cpc	r27, r19
    24a2:	e8 f4       	brcc	.+58     	; 0x24de <xTaskCheckForTimeOut+0xba>
    24a4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    24a6:	80 90 ea 30 	lds	r8, 0x30EA	; 0x8030ea <xTickCount>
    24aa:	90 90 eb 30 	lds	r9, 0x30EB	; 0x8030eb <xTickCount+0x1>
    24ae:	a0 90 ec 30 	lds	r10, 0x30EC	; 0x8030ec <xTickCount+0x2>
    24b2:	b0 90 ed 30 	lds	r11, 0x30ED	; 0x8030ed <xTickCount+0x3>
    24b6:	b5 01       	movw	r22, r10
    24b8:	a4 01       	movw	r20, r8
    24ba:	4c 19       	sub	r20, r12
    24bc:	5d 09       	sbc	r21, r13
    24be:	6e 09       	sbc	r22, r14
    24c0:	7f 09       	sbc	r23, r15
    24c2:	04 1b       	sub	r16, r20
    24c4:	15 0b       	sbc	r17, r21
    24c6:	26 0b       	sbc	r18, r22
    24c8:	37 0b       	sbc	r19, r23
    24ca:	08 83       	st	Y, r16
    24cc:	19 83       	std	Y+1, r17	; 0x01
    24ce:	2a 83       	std	Y+2, r18	; 0x02
    24d0:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    24d2:	0e 94 01 12 	call	0x2402	; 0x2402 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    24d6:	80 e0       	ldi	r24, 0x00	; 0
    24d8:	03 c0       	rjmp	.+6      	; 0x24e0 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	01 c0       	rjmp	.+2      	; 0x24e0 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    24de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    24e0:	0f 90       	pop	r0
    24e2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    24e4:	df 91       	pop	r29
    24e6:	cf 91       	pop	r28
    24e8:	1f 91       	pop	r17
    24ea:	0f 91       	pop	r16
    24ec:	ff 90       	pop	r15
    24ee:	ef 90       	pop	r14
    24f0:	df 90       	pop	r13
    24f2:	cf 90       	pop	r12
    24f4:	bf 90       	pop	r11
    24f6:	af 90       	pop	r10
    24f8:	9f 90       	pop	r9
    24fa:	8f 90       	pop	r8
    24fc:	08 95       	ret

000024fe <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    24fe:	81 e0       	ldi	r24, 0x01	; 1
    2500:	80 93 e4 30 	sts	0x30E4, r24	; 0x8030e4 <xMissedYield>
    2504:	08 95       	ret

00002506 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2506:	00 97       	sbiw	r24, 0x00	; 0
    2508:	21 f4       	brne	.+8      	; 0x2512 <uxTaskGetStackHighWaterMark+0xc>
    250a:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    250e:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2512:	dc 01       	movw	r26, r24
    2514:	5b 96       	adiw	r26, 0x1b	; 27
    2516:	ed 91       	ld	r30, X+
    2518:	fc 91       	ld	r31, X
    251a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    251c:	80 81       	ld	r24, Z
    251e:	81 31       	cpi	r24, 0x11	; 17
    2520:	41 f4       	brne	.+16     	; 0x2532 <uxTaskGetStackHighWaterMark+0x2c>
    2522:	31 96       	adiw	r30, 0x01	; 1
    2524:	80 e0       	ldi	r24, 0x00	; 0
    2526:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2528:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    252a:	21 91       	ld	r18, Z+
    252c:	21 31       	cpi	r18, 0x11	; 17
    252e:	e1 f3       	breq	.-8      	; 0x2528 <uxTaskGetStackHighWaterMark+0x22>
    2530:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2532:	80 e0       	ldi	r24, 0x00	; 0
    2534:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2536:	08 95       	ret

00002538 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2538:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <pxCurrentTCB>
    253c:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2540:	08 95       	ret

00002542 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2542:	0f 93       	push	r16
    2544:	1f 93       	push	r17
    2546:	cf 93       	push	r28
    2548:	df 93       	push	r29
    254a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    254c:	22 8d       	ldd	r18, Z+26	; 0x1a
    254e:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    2552:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2556:	5a 96       	adiw	r26, 0x1a	; 26
    2558:	8c 91       	ld	r24, X
    255a:	28 17       	cp	r18, r24
    255c:	08 f0       	brcs	.+2      	; 0x2560 <vTaskPriorityInherit+0x1e>
    255e:	41 c0       	rjmp	.+130    	; 0x25e2 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2560:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    2564:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    2568:	5a 96       	adiw	r26, 0x1a	; 26
    256a:	3c 91       	ld	r19, X
    256c:	84 e0       	ldi	r24, 0x04	; 4
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	a0 e0       	ldi	r26, 0x00	; 0
    2572:	b0 e0       	ldi	r27, 0x00	; 0
    2574:	83 1b       	sub	r24, r19
    2576:	91 09       	sbc	r25, r1
    2578:	a1 09       	sbc	r26, r1
    257a:	b1 09       	sbc	r27, r1
    257c:	86 87       	std	Z+14, r24	; 0x0e
    257e:	97 87       	std	Z+15, r25	; 0x0f
    2580:	a0 8b       	std	Z+16, r26	; 0x10
    2582:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2584:	8b e0       	ldi	r24, 0x0B	; 11
    2586:	28 9f       	mul	r18, r24
    2588:	90 01       	movw	r18, r0
    258a:	11 24       	eor	r1, r1
    258c:	2a 5e       	subi	r18, 0xEA	; 234
    258e:	3e 4c       	sbci	r19, 0xCE	; 206
    2590:	84 85       	ldd	r24, Z+12	; 0x0c
    2592:	95 85       	ldd	r25, Z+13	; 0x0d
    2594:	82 17       	cp	r24, r18
    2596:	93 07       	cpc	r25, r19
    2598:	e9 f4       	brne	.+58     	; 0x25d4 <vTaskPriorityInherit+0x92>
    259a:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    259c:	ef 01       	movw	r28, r30
    259e:	22 96       	adiw	r28, 0x02	; 2
    25a0:	ce 01       	movw	r24, r28
    25a2:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25a6:	e0 91 42 31 	lds	r30, 0x3142	; 0x803142 <pxCurrentTCB>
    25aa:	f0 91 43 31 	lds	r31, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    25ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    25b0:	f8 01       	movw	r30, r16
    25b2:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    25b4:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    25b8:	98 17       	cp	r25, r24
    25ba:	10 f4       	brcc	.+4      	; 0x25c0 <vTaskPriorityInherit+0x7e>
    25bc:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    25c0:	fb e0       	ldi	r31, 0x0B	; 11
    25c2:	8f 9f       	mul	r24, r31
    25c4:	c0 01       	movw	r24, r0
    25c6:	11 24       	eor	r1, r1
    25c8:	be 01       	movw	r22, r28
    25ca:	8a 5e       	subi	r24, 0xEA	; 234
    25cc:	9e 4c       	sbci	r25, 0xCE	; 206
    25ce:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
    25d2:	07 c0       	rjmp	.+14     	; 0x25e2 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25d4:	a0 91 42 31 	lds	r26, 0x3142	; 0x803142 <pxCurrentTCB>
    25d8:	b0 91 43 31 	lds	r27, 0x3143	; 0x803143 <pxCurrentTCB+0x1>
    25dc:	5a 96       	adiw	r26, 0x1a	; 26
    25de:	8c 91       	ld	r24, X
    25e0:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    25e2:	df 91       	pop	r29
    25e4:	cf 91       	pop	r28
    25e6:	1f 91       	pop	r17
    25e8:	0f 91       	pop	r16
    25ea:	08 95       	ret

000025ec <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    25ec:	0f 93       	push	r16
    25ee:	1f 93       	push	r17
    25f0:	cf 93       	push	r28
    25f2:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    25f4:	00 97       	sbiw	r24, 0x00	; 0
    25f6:	49 f1       	breq	.+82     	; 0x264a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    25f8:	fc 01       	movw	r30, r24
    25fa:	32 8d       	ldd	r19, Z+26	; 0x1a
    25fc:	27 a1       	ldd	r18, Z+39	; 0x27
    25fe:	32 17       	cp	r19, r18
    2600:	21 f1       	breq	.+72     	; 0x264a <vTaskPriorityDisinherit+0x5e>
    2602:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2604:	8c 01       	movw	r16, r24
    2606:	0e 5f       	subi	r16, 0xFE	; 254
    2608:	1f 4f       	sbci	r17, 0xFF	; 255
    260a:	c8 01       	movw	r24, r16
    260c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2610:	8f a1       	ldd	r24, Y+39	; 0x27
    2612:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2614:	44 e0       	ldi	r20, 0x04	; 4
    2616:	50 e0       	ldi	r21, 0x00	; 0
    2618:	60 e0       	ldi	r22, 0x00	; 0
    261a:	70 e0       	ldi	r23, 0x00	; 0
    261c:	48 1b       	sub	r20, r24
    261e:	51 09       	sbc	r21, r1
    2620:	61 09       	sbc	r22, r1
    2622:	71 09       	sbc	r23, r1
    2624:	4e 87       	std	Y+14, r20	; 0x0e
    2626:	5f 87       	std	Y+15, r21	; 0x0f
    2628:	68 8b       	std	Y+16, r22	; 0x10
    262a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    262c:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTopReadyPriority>
    2630:	98 17       	cp	r25, r24
    2632:	10 f4       	brcc	.+4      	; 0x2638 <vTaskPriorityDisinherit+0x4c>
    2634:	80 93 e8 30 	sts	0x30E8, r24	; 0x8030e8 <uxTopReadyPriority>
    2638:	fb e0       	ldi	r31, 0x0B	; 11
    263a:	8f 9f       	mul	r24, r31
    263c:	c0 01       	movw	r24, r0
    263e:	11 24       	eor	r1, r1
    2640:	b8 01       	movw	r22, r16
    2642:	8a 5e       	subi	r24, 0xEA	; 234
    2644:	9e 4c       	sbci	r25, 0xCE	; 206
    2646:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vListInsertEnd>
			}
		}
	}
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	1f 91       	pop	r17
    2650:	0f 91       	pop	r16
    2652:	08 95       	ret

00002654 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2654:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2656:	e8 81       	ld	r30, Y
    2658:	f9 81       	ldd	r31, Y+1	; 0x01
    265a:	01 90       	ld	r0, Z+
    265c:	f0 81       	ld	r31, Z
    265e:	e0 2d       	mov	r30, r0
    2660:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2662:	1a 82       	std	Y+2, r1	; 0x02
    2664:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2666:	6f ef       	ldi	r22, 0xFF	; 255
    2668:	7f ef       	ldi	r23, 0xFF	; 255
    266a:	cb 01       	movw	r24, r22
    266c:	0e 94 0d 11 	call	0x221a	; 0x221a <vTaskDelay>
    2670:	fa cf       	rjmp	.-12     	; 0x2666 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002672 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2672:	fc 01       	movw	r30, r24
    2674:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2676:	65 87       	std	Z+13, r22	; 0x0d
    2678:	08 95       	ret

0000267a <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    267a:	4f 92       	push	r4
    267c:	5f 92       	push	r5
    267e:	6f 92       	push	r6
    2680:	7f 92       	push	r7
    2682:	8f 92       	push	r8
    2684:	9f 92       	push	r9
    2686:	af 92       	push	r10
    2688:	bf 92       	push	r11
    268a:	cf 92       	push	r12
    268c:	df 92       	push	r13
    268e:	ef 92       	push	r14
    2690:	ff 92       	push	r15
    2692:	0f 93       	push	r16
    2694:	1f 93       	push	r17
    2696:	cf 93       	push	r28
    2698:	df 93       	push	r29
    269a:	cd b7       	in	r28, 0x3d	; 61
    269c:	de b7       	in	r29, 0x3e	; 62
    269e:	2a 97       	sbiw	r28, 0x0a	; 10
    26a0:	cd bf       	out	0x3d, r28	; 61
    26a2:	de bf       	out	0x3e, r29	; 62
    26a4:	4c 01       	movw	r8, r24
    26a6:	29 01       	movw	r4, r18
    26a8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    26aa:	81 e3       	ldi	r24, 0x31	; 49
    26ac:	90 e2       	ldi	r25, 0x20	; 32
    26ae:	f4 01       	movw	r30, r8
    26b0:	80 83       	st	Z, r24
    26b2:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    26b4:	fb 01       	movw	r30, r22
    26b6:	80 81       	ld	r24, Z
    26b8:	88 23       	and	r24, r24
    26ba:	69 f0       	breq	.+26     	; 0x26d6 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    26bc:	de 01       	movw	r26, r28
    26be:	11 96       	adiw	r26, 0x01	; 1
    26c0:	31 96       	adiw	r30, 0x01	; 1
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	02 c0       	rjmp	.+4      	; 0x26ca <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    26c6:	99 30       	cpi	r25, 0x09	; 9
    26c8:	39 f0       	breq	.+14     	; 0x26d8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    26ca:	9f 5f       	subi	r25, 0xFF	; 255
    26cc:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    26ce:	81 91       	ld	r24, Z+
    26d0:	81 11       	cpse	r24, r1
    26d2:	f9 cf       	rjmp	.-14     	; 0x26c6 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    26d4:	01 c0       	rjmp	.+2      	; 0x26d8 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    26d6:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    26d8:	e1 e0       	ldi	r30, 0x01	; 1
    26da:	f0 e0       	ldi	r31, 0x00	; 0
    26dc:	ec 0f       	add	r30, r28
    26de:	fd 1f       	adc	r31, r29
    26e0:	e9 0f       	add	r30, r25
    26e2:	f1 1d       	adc	r31, r1
    26e4:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    26e6:	74 01       	movw	r14, r8
    26e8:	f2 e0       	ldi	r31, 0x02	; 2
    26ea:	ef 0e       	add	r14, r31
    26ec:	f1 1c       	adc	r15, r1
    26ee:	a1 2c       	mov	r10, r1
    26f0:	b1 2c       	mov	r11, r1
    26f2:	c1 2c       	mov	r12, r1
    26f4:	d1 2c       	mov	r13, r1
    26f6:	04 2f       	mov	r16, r20
    26f8:	94 01       	movw	r18, r8
    26fa:	a2 01       	movw	r20, r4
    26fc:	be 01       	movw	r22, r28
    26fe:	6f 5f       	subi	r22, 0xFF	; 255
    2700:	7f 4f       	sbci	r23, 0xFF	; 255
    2702:	88 ee       	ldi	r24, 0xE8	; 232
    2704:	92 e0       	ldi	r25, 0x02	; 2
    2706:	0e 94 26 0e 	call	0x1c4c	; 0x1c4c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    270a:	f4 01       	movw	r30, r8
    270c:	66 82       	std	Z+6, r6	; 0x06
    270e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2710:	40 86       	std	Z+8, r4	; 0x08
    2712:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2714:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <last_created_task_pointer>
    2718:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    271c:	24 83       	std	Z+4, r18	; 0x04
    271e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2720:	80 92 44 31 	sts	0x3144, r8	; 0x803144 <last_created_task_pointer>
    2724:	90 92 45 31 	sts	0x3145, r9	; 0x803145 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2728:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    272a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    272c:	40 90 a6 31 	lds	r4, 0x31A6	; 0x8031a6 <portStackTopForTask>
    2730:	50 90 a7 31 	lds	r5, 0x31A7	; 0x8031a7 <portStackTopForTask+0x1>
    2734:	ff ef       	ldi	r31, 0xFF	; 255
    2736:	4f 1a       	sub	r4, r31
    2738:	5f 0a       	sbc	r5, r31
    273a:	40 92 a6 31 	sts	0x31A6, r4	; 0x8031a6 <portStackTopForTask>
    273e:	50 92 a7 31 	sts	0x31A7, r5	; 0x8031a7 <portStackTopForTask+0x1>
    2742:	f4 01       	movw	r30, r8
    2744:	42 86       	std	Z+10, r4	; 0x0a
    2746:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2748:	16 86       	std	Z+14, r1	; 0x0e
    274a:	17 86       	std	Z+15, r1	; 0x0f
    274c:	10 8a       	std	Z+16, r1	; 0x10
    274e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2750:	61 14       	cp	r6, r1
    2752:	71 04       	cpc	r7, r1
    2754:	09 f4       	brne	.+2      	; 0x2758 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2756:	44 c0       	rjmp	.+136    	; 0x27e0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2758:	81 30       	cpi	r24, 0x01	; 1
    275a:	79 f5       	brne	.+94     	; 0x27ba <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    275c:	6a e0       	ldi	r22, 0x0A	; 10
    275e:	c3 01       	movw	r24, r6
    2760:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2764:	7c 01       	movw	r14, r24
    2766:	6d e1       	ldi	r22, 0x1D	; 29
    2768:	75 e0       	ldi	r23, 0x05	; 5
    276a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    276e:	be 01       	movw	r22, r28
    2770:	6f 5f       	subi	r22, 0xFF	; 255
    2772:	7f 4f       	sbci	r23, 0xFF	; 255
    2774:	c7 01       	movw	r24, r14
    2776:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    277a:	6a e0       	ldi	r22, 0x0A	; 10
    277c:	c7 01       	movw	r24, r14
    277e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2782:	7c 01       	movw	r14, r24
    2784:	64 e1       	ldi	r22, 0x14	; 20
    2786:	75 e0       	ldi	r23, 0x05	; 5
    2788:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    278c:	6a e0       	ldi	r22, 0x0A	; 10
    278e:	c7 01       	movw	r24, r14
    2790:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2794:	7c 01       	movw	r14, r24
    2796:	66 e0       	ldi	r22, 0x06	; 6
    2798:	75 e0       	ldi	r23, 0x05	; 5
    279a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    279e:	63 e0       	ldi	r22, 0x03	; 3
    27a0:	c7 01       	movw	r24, r14
    27a2:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    27a6:	b2 01       	movw	r22, r4
    27a8:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
    27ac:	62 e0       	ldi	r22, 0x02	; 2
    27ae:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    27b2:	66 e0       	ldi	r22, 0x06	; 6
    27b4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    27b8:	13 c0       	rjmp	.+38     	; 0x27e0 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    27ba:	6a e0       	ldi	r22, 0x0A	; 10
    27bc:	c3 01       	movw	r24, r6
    27be:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    27c2:	4c 01       	movw	r8, r24
    27c4:	61 ef       	ldi	r22, 0xF1	; 241
    27c6:	74 e0       	ldi	r23, 0x04	; 4
    27c8:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    27cc:	be 01       	movw	r22, r28
    27ce:	6f 5f       	subi	r22, 0xFF	; 255
    27d0:	7f 4f       	sbci	r23, 0xFF	; 255
    27d2:	c4 01       	movw	r24, r8
    27d4:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    27d8:	66 e0       	ldi	r22, 0x06	; 6
    27da:	c4 01       	movw	r24, r8
    27dc:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    27e0:	2a 96       	adiw	r28, 0x0a	; 10
    27e2:	cd bf       	out	0x3d, r28	; 61
    27e4:	de bf       	out	0x3e, r29	; 62
    27e6:	df 91       	pop	r29
    27e8:	cf 91       	pop	r28
    27ea:	1f 91       	pop	r17
    27ec:	0f 91       	pop	r16
    27ee:	ff 90       	pop	r15
    27f0:	ef 90       	pop	r14
    27f2:	df 90       	pop	r13
    27f4:	cf 90       	pop	r12
    27f6:	bf 90       	pop	r11
    27f8:	af 90       	pop	r10
    27fa:	9f 90       	pop	r9
    27fc:	8f 90       	pop	r8
    27fe:	7f 90       	pop	r7
    2800:	6f 90       	pop	r6
    2802:	5f 90       	pop	r5
    2804:	4f 90       	pop	r4
    2806:	08 95       	ret

00002808 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2808:	cf 92       	push	r12
    280a:	df 92       	push	r13
    280c:	ef 92       	push	r14
    280e:	ff 92       	push	r15
    2810:	0f 93       	push	r16
    2812:	1f 93       	push	r17
    2814:	cf 93       	push	r28
    2816:	df 93       	push	r29
    2818:	ec 01       	movw	r28, r24
    281a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    281c:	8a 81       	ldd	r24, Y+2	; 0x02
    281e:	9b 81       	ldd	r25, Y+3	; 0x03
    2820:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <pcTaskGetTaskName>
    2824:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2826:	6a e0       	ldi	r22, 0x0A	; 10
    2828:	c7 01       	movw	r24, r14
    282a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    282e:	8c 01       	movw	r16, r24
    2830:	60 e3       	ldi	r22, 0x30	; 48
    2832:	75 e0       	ldi	r23, 0x05	; 5
    2834:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2838:	6a e0       	ldi	r22, 0x0A	; 10
    283a:	c8 01       	movw	r24, r16
    283c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2840:	8c 01       	movw	r16, r24
    2842:	69 e2       	ldi	r22, 0x29	; 41
    2844:	75 e0       	ldi	r23, 0x05	; 5
    2846:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    284a:	b6 01       	movw	r22, r12
    284c:	c8 01       	movw	r24, r16
    284e:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2852:	6a e0       	ldi	r22, 0x0A	; 10
    2854:	c8 01       	movw	r24, r16
    2856:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    285a:	8c 01       	movw	r16, r24
    285c:	63 e2       	ldi	r22, 0x23	; 35
    285e:	75 e0       	ldi	r23, 0x05	; 5
    2860:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2864:	66 e0       	ldi	r22, 0x06	; 6
    2866:	c8 01       	movw	r24, r16
    2868:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    286c:	8a 85       	ldd	r24, Y+10	; 0x0a
    286e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2870:	e8 85       	ldd	r30, Y+8	; 0x08
    2872:	f9 85       	ldd	r31, Y+9	; 0x09
    2874:	01 e1       	ldi	r16, 0x11	; 17
    2876:	21 e0       	ldi	r18, 0x01	; 1
    2878:	a7 01       	movw	r20, r14
    287a:	bc 01       	movw	r22, r24
    287c:	8e 1b       	sub	r24, r30
    287e:	9f 0b       	sbc	r25, r31
    2880:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2884:	8c 81       	ldd	r24, Y+4	; 0x04
    2886:	9d 81       	ldd	r25, Y+5	; 0x05
    2888:	00 97       	sbiw	r24, 0x00	; 0
    288a:	19 f0       	breq	.+6      	; 0x2892 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    288c:	b7 01       	movw	r22, r14
    288e:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	ff 90       	pop	r15
    289c:	ef 90       	pop	r14
    289e:	df 90       	pop	r13
    28a0:	cf 90       	pop	r12
    28a2:	08 95       	ret

000028a4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    28a4:	0f 93       	push	r16
    28a6:	1f 93       	push	r17
    28a8:	cf 93       	push	r28
    28aa:	df 93       	push	r29
    28ac:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    28ae:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <last_created_task_pointer>
    28b2:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    28b6:	00 97       	sbiw	r24, 0x00	; 0
    28b8:	19 f0       	breq	.+6      	; 0x28c0 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    28ba:	be 01       	movw	r22, r28
    28bc:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    28c0:	6a e0       	ldi	r22, 0x0A	; 10
    28c2:	ce 01       	movw	r24, r28
    28c4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    28c8:	8c 01       	movw	r16, r24
    28ca:	66 e4       	ldi	r22, 0x46	; 70
    28cc:	75 e0       	ldi	r23, 0x05	; 5
    28ce:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    28d2:	6a e0       	ldi	r22, 0x0A	; 10
    28d4:	c8 01       	movw	r24, r16
    28d6:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    28da:	8c 01       	movw	r16, r24
    28dc:	6b e3       	ldi	r22, 0x3B	; 59
    28de:	75 e0       	ldi	r23, 0x05	; 5
    28e0:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    28e4:	6a e0       	ldi	r22, 0x0A	; 10
    28e6:	c8 01       	movw	r24, r16
    28e8:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    28ec:	8c 01       	movw	r16, r24
    28ee:	65 e3       	ldi	r22, 0x35	; 53
    28f0:	75 e0       	ldi	r23, 0x05	; 5
    28f2:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    28f6:	66 e0       	ldi	r22, 0x06	; 6
    28f8:	c8 01       	movw	r24, r16
    28fa:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    28fe:	80 91 a6 31 	lds	r24, 0x31A6	; 0x8031a6 <portStackTopForTask>
    2902:	90 91 a7 31 	lds	r25, 0x31A7	; 0x8031a7 <portStackTopForTask+0x1>
    2906:	bc 01       	movw	r22, r24
    2908:	6f 5f       	subi	r22, 0xFF	; 255
    290a:	7f 4f       	sbci	r23, 0xFF	; 255
    290c:	01 e1       	ldi	r16, 0x11	; 17
    290e:	21 e0       	ldi	r18, 0x01	; 1
    2910:	ae 01       	movw	r20, r28
    2912:	83 56       	subi	r24, 0x63	; 99
    2914:	91 09       	sbc	r25, r1
    2916:	0e 94 06 17 	call	0x2e0c	; 0x2e0c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    291a:	df 91       	pop	r29
    291c:	cf 91       	pop	r28
    291e:	1f 91       	pop	r17
    2920:	0f 91       	pop	r16
    2922:	08 95       	ret

00002924 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2924:	8f 92       	push	r8
    2926:	9f 92       	push	r9
    2928:	af 92       	push	r10
    292a:	bf 92       	push	r11
    292c:	cf 92       	push	r12
    292e:	df 92       	push	r13
    2930:	ef 92       	push	r14
    2932:	ff 92       	push	r15
    2934:	0f 93       	push	r16
    2936:	1f 93       	push	r17
    2938:	cf 93       	push	r28
    293a:	df 93       	push	r29
    293c:	ec 01       	movw	r28, r24
    293e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2940:	8a 81       	ldd	r24, Y+2	; 0x02
    2942:	9b 81       	ldd	r25, Y+3	; 0x03
    2944:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <pcTaskGetTaskName>
    2948:	bc 01       	movw	r22, r24
    294a:	c8 01       	movw	r24, r16
    294c:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2950:	d8 01       	movw	r26, r16
    2952:	ed 91       	ld	r30, X+
    2954:	fc 91       	ld	r31, X
    2956:	02 80       	ldd	r0, Z+2	; 0x02
    2958:	f3 81       	ldd	r31, Z+3	; 0x03
    295a:	e0 2d       	mov	r30, r0
    295c:	69 e0       	ldi	r22, 0x09	; 9
    295e:	c8 01       	movw	r24, r16
    2960:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2962:	8a 81       	ldd	r24, Y+2	; 0x02
    2964:	9b 81       	ldd	r25, Y+3	; 0x03
    2966:	0e 94 7d 0f 	call	0x1efa	; 0x1efa <pcTaskGetTaskName>
    296a:	fc 01       	movw	r30, r24
    296c:	01 90       	ld	r0, Z+
    296e:	00 20       	and	r0, r0
    2970:	e9 f7       	brne	.-6      	; 0x296c <_ZN8frt_task12print_statusER8emstream+0x48>
    2972:	31 97       	sbiw	r30, 0x01	; 1
    2974:	e8 1b       	sub	r30, r24
    2976:	f9 0b       	sbc	r31, r25
    2978:	38 97       	sbiw	r30, 0x08	; 8
    297a:	48 f4       	brcc	.+18     	; 0x298e <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    297c:	d8 01       	movw	r26, r16
    297e:	ed 91       	ld	r30, X+
    2980:	fc 91       	ld	r31, X
    2982:	02 80       	ldd	r0, Z+2	; 0x02
    2984:	f3 81       	ldd	r31, Z+3	; 0x03
    2986:	e0 2d       	mov	r30, r0
    2988:	69 e0       	ldi	r22, 0x09	; 9
    298a:	c8 01       	movw	r24, r16
    298c:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    298e:	ce 84       	ldd	r12, Y+14	; 0x0e
    2990:	df 84       	ldd	r13, Y+15	; 0x0f
    2992:	e8 88       	ldd	r14, Y+16	; 0x10
    2994:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2996:	a8 84       	ldd	r10, Y+8	; 0x08
    2998:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    299a:	8a 81       	ldd	r24, Y+2	; 0x02
    299c:	9b 81       	ldd	r25, Y+3	; 0x03
    299e:	0e 94 83 12 	call	0x2506	; 0x2506 <uxTaskGetStackHighWaterMark>
    29a2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    29a4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    29a6:	8a 81       	ldd	r24, Y+2	; 0x02
    29a8:	9b 81       	ldd	r25, Y+3	; 0x03
    29aa:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <uxTaskPriorityGet>
    29ae:	68 2f       	mov	r22, r24
    29b0:	c8 01       	movw	r24, r16
    29b2:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    29b6:	6a e0       	ldi	r22, 0x0A	; 10
    29b8:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    29bc:	ec 01       	movw	r28, r24
    29be:	6b eb       	ldi	r22, 0xBB	; 187
    29c0:	75 e0       	ldi	r23, 0x05	; 5
    29c2:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
			<< get_state ()
    29c6:	68 2d       	mov	r22, r8
    29c8:	ce 01       	movw	r24, r28
    29ca:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    29ce:	6a e0       	ldi	r22, 0x0A	; 10
    29d0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    29d4:	ec 01       	movw	r28, r24
    29d6:	69 eb       	ldi	r22, 0xB9	; 185
    29d8:	75 e0       	ldi	r23, 0x05	; 5
    29da:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    29de:	69 2d       	mov	r22, r9
    29e0:	ce 01       	movw	r24, r28
    29e2:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    29e6:	6a e0       	ldi	r22, 0x0A	; 10
    29e8:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    29ec:	ec 01       	movw	r28, r24
    29ee:	67 eb       	ldi	r22, 0xB7	; 183
    29f0:	75 e0       	ldi	r23, 0x05	; 5
    29f2:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    29f6:	b5 01       	movw	r22, r10
    29f8:	ce 01       	movw	r24, r28
    29fa:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
    29fe:	6a e0       	ldi	r22, 0x0A	; 10
    2a00:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2a04:	ec 01       	movw	r28, r24
    2a06:	65 eb       	ldi	r22, 0xB5	; 181
    2a08:	75 e0       	ldi	r23, 0x05	; 5
    2a0a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2a0e:	6a e0       	ldi	r22, 0x0A	; 10
    2a10:	ce 01       	movw	r24, r28
    2a12:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2a16:	ec 01       	movw	r28, r24
    2a18:	63 eb       	ldi	r22, 0xB3	; 179
    2a1a:	75 e0       	ldi	r23, 0x05	; 5
    2a1c:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2a20:	b7 01       	movw	r22, r14
    2a22:	a6 01       	movw	r20, r12
    2a24:	ce 01       	movw	r24, r28
    2a26:	0e 94 1d 19 	call	0x323a	; 0x323a <_ZN8emstreamlsEm>
}
    2a2a:	df 91       	pop	r29
    2a2c:	cf 91       	pop	r28
    2a2e:	1f 91       	pop	r17
    2a30:	0f 91       	pop	r16
    2a32:	ff 90       	pop	r15
    2a34:	ef 90       	pop	r14
    2a36:	df 90       	pop	r13
    2a38:	cf 90       	pop	r12
    2a3a:	bf 90       	pop	r11
    2a3c:	af 90       	pop	r10
    2a3e:	9f 90       	pop	r9
    2a40:	8f 90       	pop	r8
    2a42:	08 95       	ret

00002a44 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2a44:	cf 93       	push	r28
    2a46:	df 93       	push	r29
    2a48:	ec 01       	movw	r28, r24
    2a4a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2a4c:	db 01       	movw	r26, r22
    2a4e:	ed 91       	ld	r30, X+
    2a50:	fc 91       	ld	r31, X
    2a52:	02 80       	ldd	r0, Z+2	; 0x02
    2a54:	f3 81       	ldd	r31, Z+3	; 0x03
    2a56:	e0 2d       	mov	r30, r0
    2a58:	be 01       	movw	r22, r28
    2a5a:	19 95       	eicall
	return (ser_dev);
}
    2a5c:	ce 01       	movw	r24, r28
    2a5e:	df 91       	pop	r29
    2a60:	cf 91       	pop	r28
    2a62:	08 95       	ret

00002a64 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2a64:	0f 93       	push	r16
    2a66:	1f 93       	push	r17
    2a68:	cf 93       	push	r28
    2a6a:	df 93       	push	r29
    2a6c:	ec 01       	movw	r28, r24
    2a6e:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2a70:	bc 01       	movw	r22, r24
    2a72:	c8 01       	movw	r24, r16
    2a74:	0e 94 22 15 	call	0x2a44	; 0x2a44 <_ZlsR8emstreamR8frt_task>
    2a78:	66 e0       	ldi	r22, 0x06	; 6
    2a7a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2a7e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a80:	9d 81       	ldd	r25, Y+5	; 0x05
    2a82:	00 97       	sbiw	r24, 0x00	; 0
    2a84:	19 f0       	breq	.+6      	; 0x2a8c <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2a86:	b8 01       	movw	r22, r16
    2a88:	0e 94 32 15 	call	0x2a64	; 0x2a64 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2a8c:	df 91       	pop	r29
    2a8e:	cf 91       	pop	r28
    2a90:	1f 91       	pop	r17
    2a92:	0f 91       	pop	r16
    2a94:	08 95       	ret

00002a96 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2a96:	0f 93       	push	r16
    2a98:	1f 93       	push	r17
    2a9a:	cf 93       	push	r28
    2a9c:	df 93       	push	r29
    2a9e:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2aa0:	6a e0       	ldi	r22, 0x0A	; 10
    2aa2:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2aa6:	8c 01       	movw	r16, r24
    2aa8:	68 ea       	ldi	r22, 0xA8	; 168
    2aaa:	75 e0       	ldi	r23, 0x05	; 5
    2aac:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2ab0:	6a e0       	ldi	r22, 0x0A	; 10
    2ab2:	c8 01       	movw	r24, r16
    2ab4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2ab8:	8c 01       	movw	r16, r24
    2aba:	61 ea       	ldi	r22, 0xA1	; 161
    2abc:	75 e0       	ldi	r23, 0x05	; 5
    2abe:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2ac2:	66 e0       	ldi	r22, 0x06	; 6
    2ac4:	c8 01       	movw	r24, r16
    2ac6:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2aca:	6a e0       	ldi	r22, 0x0A	; 10
    2acc:	ce 01       	movw	r24, r28
    2ace:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2ad2:	8c 01       	movw	r16, r24
    2ad4:	60 e9       	ldi	r22, 0x90	; 144
    2ad6:	75 e0       	ldi	r23, 0x05	; 5
    2ad8:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2adc:	6a e0       	ldi	r22, 0x0A	; 10
    2ade:	c8 01       	movw	r24, r16
    2ae0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2ae4:	8c 01       	movw	r16, r24
    2ae6:	64 e8       	ldi	r22, 0x84	; 132
    2ae8:	75 e0       	ldi	r23, 0x05	; 5
    2aea:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2aee:	6a e0       	ldi	r22, 0x0A	; 10
    2af0:	c8 01       	movw	r24, r16
    2af2:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2af6:	8c 01       	movw	r16, r24
    2af8:	6e e7       	ldi	r22, 0x7E	; 126
    2afa:	75 e0       	ldi	r23, 0x05	; 5
    2afc:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2b00:	66 e0       	ldi	r22, 0x06	; 6
    2b02:	c8 01       	movw	r24, r16
    2b04:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2b08:	6a e0       	ldi	r22, 0x0A	; 10
    2b0a:	ce 01       	movw	r24, r28
    2b0c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b10:	8c 01       	movw	r16, r24
    2b12:	6d e6       	ldi	r22, 0x6D	; 109
    2b14:	75 e0       	ldi	r23, 0x05	; 5
    2b16:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2b1a:	6a e0       	ldi	r22, 0x0A	; 10
    2b1c:	c8 01       	movw	r24, r16
    2b1e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b22:	8c 01       	movw	r16, r24
    2b24:	61 e6       	ldi	r22, 0x61	; 97
    2b26:	75 e0       	ldi	r23, 0x05	; 5
    2b28:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2b2c:	6a e0       	ldi	r22, 0x0A	; 10
    2b2e:	c8 01       	movw	r24, r16
    2b30:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b34:	8c 01       	movw	r16, r24
    2b36:	6b e5       	ldi	r22, 0x5B	; 91
    2b38:	75 e0       	ldi	r23, 0x05	; 5
    2b3a:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2b3e:	66 e0       	ldi	r22, 0x06	; 6
    2b40:	c8 01       	movw	r24, r16
    2b42:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2b46:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <last_created_task_pointer>
    2b4a:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <last_created_task_pointer+0x1>
    2b4e:	00 97       	sbiw	r24, 0x00	; 0
    2b50:	19 f0       	breq	.+6      	; 0x2b58 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2b52:	be 01       	movw	r22, r28
    2b54:	0e 94 32 15 	call	0x2a64	; 0x2a64 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2b58:	0e 94 85 0f 	call	0x1f0a	; 0x1f0a <xTaskGetIdleTaskHandle>
    2b5c:	0e 94 83 12 	call	0x2506	; 0x2506 <uxTaskGetStackHighWaterMark>
    2b60:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2b62:	6a e0       	ldi	r22, 0x0A	; 10
    2b64:	ce 01       	movw	r24, r28
    2b66:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b6a:	ec 01       	movw	r28, r24
    2b6c:	60 e5       	ldi	r22, 0x50	; 80
    2b6e:	75 e0       	ldi	r23, 0x05	; 5
    2b70:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2b74:	61 2f       	mov	r22, r17
    2b76:	ce 01       	movw	r24, r28
    2b78:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2b7c:	6a e0       	ldi	r22, 0x0A	; 10
    2b7e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b82:	ec 01       	movw	r28, r24
    2b84:	6e e4       	ldi	r22, 0x4E	; 78
    2b86:	75 e0       	ldi	r23, 0x05	; 5
    2b88:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2b8c:	64 e6       	ldi	r22, 0x64	; 100
    2b8e:	70 e0       	ldi	r23, 0x00	; 0
    2b90:	ce 01       	movw	r24, r28
    2b92:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
    2b96:	6a e0       	ldi	r22, 0x0A	; 10
    2b98:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2b9c:	ec 01       	movw	r28, r24
    2b9e:	6b e4       	ldi	r22, 0x4B	; 75
    2ba0:	75 e0       	ldi	r23, 0x05	; 5
    2ba2:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2ba6:	66 e0       	ldi	r22, 0x06	; 6
    2ba8:	ce 01       	movw	r24, r28
    2baa:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
}
    2bae:	df 91       	pop	r29
    2bb0:	cf 91       	pop	r28
    2bb2:	1f 91       	pop	r17
    2bb4:	0f 91       	pop	r16
    2bb6:	08 95       	ret

00002bb8 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2bb8:	0f 93       	push	r16
    2bba:	cf 93       	push	r28
    2bbc:	df 93       	push	r29
    2bbe:	1f 92       	push	r1
    2bc0:	cd b7       	in	r28, 0x3d	; 61
    2bc2:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2bc4:	00 e0       	ldi	r16, 0x00	; 0
    2bc6:	2f ef       	ldi	r18, 0xFF	; 255
    2bc8:	3f ef       	ldi	r19, 0xFF	; 255
    2bca:	a9 01       	movw	r20, r18
    2bcc:	be 01       	movw	r22, r28
    2bce:	6f 5f       	subi	r22, 0xFF	; 255
    2bd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	80 85       	ldd	r24, Z+8	; 0x08
    2bd6:	91 85       	ldd	r25, Z+9	; 0x09
    2bd8:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
    2bdc:	81 30       	cpi	r24, 0x01	; 1
    2bde:	19 f4       	brne	.+6      	; 0x2be6 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2be0:	89 81       	ldd	r24, Y+1	; 0x01
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	02 c0       	rjmp	.+4      	; 0x2bea <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2be6:	8f ef       	ldi	r24, 0xFF	; 255
    2be8:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2bea:	0f 90       	pop	r0
    2bec:	df 91       	pop	r29
    2bee:	cf 91       	pop	r28
    2bf0:	0f 91       	pop	r16
    2bf2:	08 95       	ret

00002bf4 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	80 85       	ldd	r24, Z+8	; 0x08
    2bf8:	91 85       	ldd	r25, Z+9	; 0x09
    2bfa:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
    2bfe:	91 e0       	ldi	r25, 0x01	; 1
    2c00:	81 11       	cpse	r24, r1
    2c02:	01 c0       	rjmp	.+2      	; 0x2c06 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2c04:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2c06:	89 2f       	mov	r24, r25
    2c08:	08 95       	ret

00002c0a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2c0a:	0f 93       	push	r16
    2c0c:	cf 93       	push	r28
    2c0e:	df 93       	push	r29
    2c10:	1f 92       	push	r1
    2c12:	cd b7       	in	r28, 0x3d	; 61
    2c14:	de b7       	in	r29, 0x3e	; 62
    2c16:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2c18:	fc 01       	movw	r30, r24
    2c1a:	22 85       	ldd	r18, Z+10	; 0x0a
    2c1c:	33 85       	ldd	r19, Z+11	; 0x0b
    2c1e:	44 85       	ldd	r20, Z+12	; 0x0c
    2c20:	55 85       	ldd	r21, Z+13	; 0x0d
    2c22:	00 e0       	ldi	r16, 0x00	; 0
    2c24:	be 01       	movw	r22, r28
    2c26:	6f 5f       	subi	r22, 0xFF	; 255
    2c28:	7f 4f       	sbci	r23, 0xFF	; 255
    2c2a:	80 85       	ldd	r24, Z+8	; 0x08
    2c2c:	91 85       	ldd	r25, Z+9	; 0x09
    2c2e:	0e 94 0d 0c 	call	0x181a	; 0x181a <xQueueGenericSend>
    2c32:	91 e0       	ldi	r25, 0x01	; 1
    2c34:	81 11       	cpse	r24, r1
    2c36:	01 c0       	rjmp	.+2      	; 0x2c3a <_ZN14frt_text_queue7putcharEc+0x30>
    2c38:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2c3a:	89 2f       	mov	r24, r25
    2c3c:	0f 90       	pop	r0
    2c3e:	df 91       	pop	r29
    2c40:	cf 91       	pop	r28
    2c42:	0f 91       	pop	r16
    2c44:	08 95       	ret

00002c46 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2c46:	8f 92       	push	r8
    2c48:	9f 92       	push	r9
    2c4a:	bf 92       	push	r11
    2c4c:	cf 92       	push	r12
    2c4e:	df 92       	push	r13
    2c50:	ef 92       	push	r14
    2c52:	ff 92       	push	r15
    2c54:	0f 93       	push	r16
    2c56:	1f 93       	push	r17
    2c58:	cf 93       	push	r28
    2c5a:	df 93       	push	r29
    2c5c:	ec 01       	movw	r28, r24
    2c5e:	b6 2e       	mov	r11, r22
    2c60:	4a 01       	movw	r8, r20
    2c62:	68 01       	movw	r12, r16
    2c64:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2c66:	0e 94 5d 18 	call	0x30ba	; 0x30ba <_ZN8emstreamC1Ev>
    2c6a:	89 e3       	ldi	r24, 0x39	; 57
    2c6c:	90 e2       	ldi	r25, 0x20	; 32
    2c6e:	88 83       	st	Y, r24
    2c70:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2c72:	8e 86       	std	Y+14, r8	; 0x0e
    2c74:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2c76:	40 e0       	ldi	r20, 0x00	; 0
    2c78:	61 e0       	ldi	r22, 0x01	; 1
    2c7a:	8b 2d       	mov	r24, r11
    2c7c:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    2c80:	88 87       	std	Y+8, r24	; 0x08
    2c82:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2c84:	ca 86       	std	Y+10, r12	; 0x0a
    2c86:	db 86       	std	Y+11, r13	; 0x0b
    2c88:	ec 86       	std	Y+12, r14	; 0x0c
    2c8a:	fd 86       	std	Y+13, r15	; 0x0d
}
    2c8c:	df 91       	pop	r29
    2c8e:	cf 91       	pop	r28
    2c90:	1f 91       	pop	r17
    2c92:	0f 91       	pop	r16
    2c94:	ff 90       	pop	r15
    2c96:	ef 90       	pop	r14
    2c98:	df 90       	pop	r13
    2c9a:	cf 90       	pop	r12
    2c9c:	bf 90       	pop	r11
    2c9e:	9f 90       	pop	r9
    2ca0:	8f 90       	pop	r8
    2ca2:	08 95       	ret

00002ca4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2ca4:	cf 92       	push	r12
    2ca6:	df 92       	push	r13
    2ca8:	ef 92       	push	r14
    2caa:	ff 92       	push	r15
    2cac:	cf 93       	push	r28
    2cae:	df 93       	push	r29
    2cb0:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2cb2:	68 81       	ld	r22, Y
    2cb4:	79 81       	ldd	r23, Y+1	; 0x01
    2cb6:	8a 81       	ldd	r24, Y+2	; 0x02
    2cb8:	9b 81       	ldd	r25, Y+3	; 0x03
    2cba:	0f 2e       	mov	r0, r31
    2cbc:	f8 ee       	ldi	r31, 0xE8	; 232
    2cbe:	cf 2e       	mov	r12, r31
    2cc0:	f3 e0       	ldi	r31, 0x03	; 3
    2cc2:	df 2e       	mov	r13, r31
    2cc4:	e1 2c       	mov	r14, r1
    2cc6:	f1 2c       	mov	r15, r1
    2cc8:	f0 2d       	mov	r31, r0
    2cca:	a7 01       	movw	r20, r14
    2ccc:	96 01       	movw	r18, r12
    2cce:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
    2cd2:	9b 01       	movw	r18, r22
    2cd4:	ac 01       	movw	r20, r24
    2cd6:	60 e4       	ldi	r22, 0x40	; 64
    2cd8:	72 e4       	ldi	r23, 0x42	; 66
    2cda:	8f e0       	ldi	r24, 0x0F	; 15
    2cdc:	90 e0       	ldi	r25, 0x00	; 0
    2cde:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <__mulsi3>
    2ce2:	a7 01       	movw	r20, r14
    2ce4:	96 01       	movw	r18, r12
    2ce6:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
    2cea:	69 01       	movw	r12, r18
    2cec:	7a 01       	movw	r14, r20
    2cee:	ac 81       	ldd	r26, Y+4	; 0x04
    2cf0:	bd 81       	ldd	r27, Y+5	; 0x05
    2cf2:	20 e4       	ldi	r18, 0x40	; 64
    2cf4:	32 e4       	ldi	r19, 0x42	; 66
    2cf6:	4f e0       	ldi	r20, 0x0F	; 15
    2cf8:	50 e0       	ldi	r21, 0x00	; 0
    2cfa:	0e 94 0f 20 	call	0x401e	; 0x401e <__muluhisi3>
    2cfe:	20 e0       	ldi	r18, 0x00	; 0
    2d00:	38 e4       	ldi	r19, 0x48	; 72
    2d02:	48 ee       	ldi	r20, 0xE8	; 232
    2d04:	51 e0       	ldi	r21, 0x01	; 1
    2d06:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
    2d0a:	c7 01       	movw	r24, r14
    2d0c:	b6 01       	movw	r22, r12
    2d0e:	62 0f       	add	r22, r18
    2d10:	73 1f       	adc	r23, r19
    2d12:	84 1f       	adc	r24, r20
    2d14:	95 1f       	adc	r25, r21
}
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    2d1a:	ff 90       	pop	r15
    2d1c:	ef 90       	pop	r14
    2d1e:	df 90       	pop	r13
    2d20:	cf 90       	pop	r12
    2d22:	08 95       	ret

00002d24 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2d24:	cf 92       	push	r12
    2d26:	df 92       	push	r13
    2d28:	ef 92       	push	r14
    2d2a:	ff 92       	push	r15
    2d2c:	0f 93       	push	r16
    2d2e:	1f 93       	push	r17
    2d30:	cf 93       	push	r28
    2d32:	df 93       	push	r29
    2d34:	cd b7       	in	r28, 0x3d	; 61
    2d36:	de b7       	in	r29, 0x3e	; 62
    2d38:	2f 97       	sbiw	r28, 0x0f	; 15
    2d3a:	cd bf       	out	0x3d, r28	; 61
    2d3c:	de bf       	out	0x3e, r29	; 62
    2d3e:	6c 01       	movw	r12, r24
    2d40:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2d42:	db 01       	movw	r26, r22
    2d44:	6d 91       	ld	r22, X+
    2d46:	7d 91       	ld	r23, X+
    2d48:	8d 91       	ld	r24, X+
    2d4a:	9c 91       	ld	r25, X
    2d4c:	28 ee       	ldi	r18, 0xE8	; 232
    2d4e:	33 e0       	ldi	r19, 0x03	; 3
    2d50:	40 e0       	ldi	r20, 0x00	; 0
    2d52:	50 e0       	ldi	r21, 0x00	; 0
    2d54:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
    2d58:	ba 01       	movw	r22, r20
    2d5a:	a9 01       	movw	r20, r18
    2d5c:	c6 01       	movw	r24, r12
    2d5e:	0e 94 1d 19 	call	0x323a	; 0x323a <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2d62:	d6 01       	movw	r26, r12
    2d64:	ed 91       	ld	r30, X+
    2d66:	fc 91       	ld	r31, X
    2d68:	02 80       	ldd	r0, Z+2	; 0x02
    2d6a:	f3 81       	ldd	r31, Z+3	; 0x03
    2d6c:	e0 2d       	mov	r30, r0
    2d6e:	6e e2       	ldi	r22, 0x2E	; 46
    2d70:	c6 01       	movw	r24, r12
    2d72:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2d74:	c8 01       	movw	r24, r16
    2d76:	0e 94 52 16 	call	0x2ca4	; 0x2ca4 <_ZN10time_stamp12get_microsecEv>
    2d7a:	8e 01       	movw	r16, r28
    2d7c:	09 5f       	subi	r16, 0xF9	; 249
    2d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    2d80:	fe 01       	movw	r30, r28
    2d82:	31 96       	adiw	r30, 0x01	; 1
    2d84:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2d86:	2a e0       	ldi	r18, 0x0A	; 10
    2d88:	30 e0       	ldi	r19, 0x00	; 0
    2d8a:	40 e0       	ldi	r20, 0x00	; 0
    2d8c:	50 e0       	ldi	r21, 0x00	; 0
    2d8e:	0e 94 e7 1f 	call	0x3fce	; 0x3fce <__divmodsi4>
    2d92:	e6 2f       	mov	r30, r22
    2d94:	28 87       	std	Y+8, r18	; 0x08
    2d96:	39 87       	std	Y+9, r19	; 0x09
    2d98:	4a 87       	std	Y+10, r20	; 0x0a
    2d9a:	5b 87       	std	Y+11, r21	; 0x0b
    2d9c:	68 85       	ldd	r22, Y+8	; 0x08
    2d9e:	79 85       	ldd	r23, Y+9	; 0x09
    2da0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2da2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2da4:	20 e3       	ldi	r18, 0x30	; 48
    2da6:	2e 0f       	add	r18, r30
    2da8:	d8 01       	movw	r26, r16
    2daa:	2e 93       	st	-X, r18
    2dac:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2dae:	ae 15       	cp	r26, r14
    2db0:	bf 05       	cpc	r27, r15
    2db2:	49 f7       	brne	.-46     	; 0x2d86 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2db4:	1f 82       	std	Y+7, r1	; 0x07
    2db6:	be 01       	movw	r22, r28
    2db8:	6f 5f       	subi	r22, 0xFF	; 255
    2dba:	7f 4f       	sbci	r23, 0xFF	; 255
    2dbc:	c6 01       	movw	r24, r12
    2dbe:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2dc2:	c6 01       	movw	r24, r12
    2dc4:	2f 96       	adiw	r28, 0x0f	; 15
    2dc6:	cd bf       	out	0x3d, r28	; 61
    2dc8:	de bf       	out	0x3e, r29	; 62
    2dca:	df 91       	pop	r29
    2dcc:	cf 91       	pop	r28
    2dce:	1f 91       	pop	r17
    2dd0:	0f 91       	pop	r16
    2dd2:	ff 90       	pop	r15
    2dd4:	ef 90       	pop	r14
    2dd6:	df 90       	pop	r13
    2dd8:	cf 90       	pop	r12
    2dda:	08 95       	ret

00002ddc <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2ddc:	cf 93       	push	r28
    2dde:	df 93       	push	r29
    2de0:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2de2:	0f b6       	in	r0, 0x3f	; 63
    2de4:	f8 94       	cli
    2de6:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2de8:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2dec:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2df0:	8c 83       	std	Y+4, r24	; 0x04
    2df2:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2df4:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <xTaskGetTickCount>
    2df8:	68 83       	st	Y, r22
    2dfa:	79 83       	std	Y+1, r23	; 0x01
    2dfc:	8a 83       	std	Y+2, r24	; 0x02
    2dfe:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2e00:	0f 90       	pop	r0
    2e02:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2e04:	ce 01       	movw	r24, r28
    2e06:	df 91       	pop	r29
    2e08:	cf 91       	pop	r28
    2e0a:	08 95       	ret

00002e0c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2e0c:	5f 92       	push	r5
    2e0e:	6f 92       	push	r6
    2e10:	7f 92       	push	r7
    2e12:	8f 92       	push	r8
    2e14:	9f 92       	push	r9
    2e16:	af 92       	push	r10
    2e18:	bf 92       	push	r11
    2e1a:	cf 92       	push	r12
    2e1c:	df 92       	push	r13
    2e1e:	ef 92       	push	r14
    2e20:	ff 92       	push	r15
    2e22:	0f 93       	push	r16
    2e24:	1f 93       	push	r17
    2e26:	cf 93       	push	r28
    2e28:	df 93       	push	r29
    2e2a:	5c 01       	movw	r10, r24
    2e2c:	4b 01       	movw	r8, r22
    2e2e:	7a 01       	movw	r14, r20
    2e30:	12 2f       	mov	r17, r18
    2e32:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2e34:	63 e0       	ldi	r22, 0x03	; 3
    2e36:	ca 01       	movw	r24, r20
    2e38:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2e3c:	a8 14       	cp	r10, r8
    2e3e:	b9 04       	cpc	r11, r9
    2e40:	08 f0       	brcs	.+2      	; 0x2e44 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2e42:	7d c0       	rjmp	.+250    	; 0x2f3e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2e44:	65 01       	movw	r12, r10
    2e46:	84 e1       	ldi	r24, 0x14	; 20
    2e48:	c8 0e       	add	r12, r24
    2e4a:	d1 1c       	adc	r13, r1
    2e4c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2e4e:	6a 2c       	mov	r6, r10
    2e50:	5b 2c       	mov	r5, r11
    2e52:	b5 01       	movw	r22, r10
    2e54:	c7 01       	movw	r24, r14
    2e56:	0e 94 e9 18 	call	0x31d2	; 0x31d2 <_ZN8emstreamlsEj>
    2e5a:	6a e0       	ldi	r22, 0x0A	; 10
    2e5c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2e60:	6d ec       	ldi	r22, 0xCD	; 205
    2e62:	75 e0       	ldi	r23, 0x05	; 5
    2e64:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2e68:	11 23       	and	r17, r17
    2e6a:	09 f4       	brne	.+2      	; 0x2e6e <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2e6c:	6d c0       	rjmp	.+218    	; 0x2f48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2e6e:	00 23       	and	r16, r16
    2e70:	09 f4       	brne	.+2      	; 0x2e74 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2e72:	6a c0       	rjmp	.+212    	; 0x2f48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2e74:	6a e0       	ldi	r22, 0x0A	; 10
    2e76:	c7 01       	movw	r24, r14
    2e78:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2e7c:	68 ec       	ldi	r22, 0xC8	; 200
    2e7e:	75 e0       	ldi	r23, 0x05	; 5
    2e80:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    2e84:	61 c0       	rjmp	.+194    	; 0x2f48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2e86:	11 23       	and	r17, r17
    2e88:	71 f0       	breq	.+28     	; 0x2ea6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2e8a:	01 11       	cpse	r16, r1
    2e8c:	0c c0       	rjmp	.+24     	; 0x2ea6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2e8e:	88 81       	ld	r24, Y
    2e90:	87 15       	cp	r24, r7
    2e92:	49 f0       	breq	.+18     	; 0x2ea6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2e94:	6a e0       	ldi	r22, 0x0A	; 10
    2e96:	c7 01       	movw	r24, r14
    2e98:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2e9c:	63 ec       	ldi	r22, 0xC3	; 195
    2e9e:	75 e0       	ldi	r23, 0x05	; 5
    2ea0:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2ea4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2ea6:	69 91       	ld	r22, Y+
    2ea8:	c7 01       	movw	r24, r14
    2eaa:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2eae:	dc 01       	movw	r26, r24
    2eb0:	ed 91       	ld	r30, X+
    2eb2:	fc 91       	ld	r31, X
    2eb4:	02 80       	ldd	r0, Z+2	; 0x02
    2eb6:	f3 81       	ldd	r31, Z+3	; 0x03
    2eb8:	e0 2d       	mov	r30, r0
    2eba:	60 e2       	ldi	r22, 0x20	; 32
    2ebc:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2ebe:	cc 16       	cp	r12, r28
    2ec0:	dd 06       	cpc	r13, r29
    2ec2:	09 f7       	brne	.-62     	; 0x2e86 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2ec4:	11 23       	and	r17, r17
    2ec6:	89 f0       	breq	.+34     	; 0x2eea <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2ec8:	6a e0       	ldi	r22, 0x0A	; 10
    2eca:	c7 01       	movw	r24, r14
    2ecc:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2ed0:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2ed2:	6d eb       	ldi	r22, 0xBD	; 189
    2ed4:	75 e0       	ldi	r23, 0x05	; 5
    2ed6:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2eda:	e8 81       	ld	r30, Y
    2edc:	f9 81       	ldd	r31, Y+1	; 0x01
    2ede:	02 80       	ldd	r0, Z+2	; 0x02
    2ee0:	f3 81       	ldd	r31, Z+3	; 0x03
    2ee2:	e0 2d       	mov	r30, r0
    2ee4:	60 e2       	ldi	r22, 0x20	; 32
    2ee6:	ce 01       	movw	r24, r28
    2ee8:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2eea:	c6 2d       	mov	r28, r6
    2eec:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2eee:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2ef0:	80 ee       	ldi	r24, 0xE0	; 224
    2ef2:	86 0f       	add	r24, r22
    2ef4:	8f 35       	cpi	r24, 0x5F	; 95
    2ef6:	48 f4       	brcc	.+18     	; 0x2f0a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2ef8:	d7 01       	movw	r26, r14
    2efa:	ed 91       	ld	r30, X+
    2efc:	fc 91       	ld	r31, X
    2efe:	02 80       	ldd	r0, Z+2	; 0x02
    2f00:	f3 81       	ldd	r31, Z+3	; 0x03
    2f02:	e0 2d       	mov	r30, r0
    2f04:	c7 01       	movw	r24, r14
    2f06:	19 95       	eicall
    2f08:	09 c0       	rjmp	.+18     	; 0x2f1c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2f0a:	d7 01       	movw	r26, r14
    2f0c:	ed 91       	ld	r30, X+
    2f0e:	fc 91       	ld	r31, X
    2f10:	02 80       	ldd	r0, Z+2	; 0x02
    2f12:	f3 81       	ldd	r31, Z+3	; 0x03
    2f14:	e0 2d       	mov	r30, r0
    2f16:	6e e2       	ldi	r22, 0x2E	; 46
    2f18:	c7 01       	movw	r24, r14
    2f1a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2f1c:	cc 16       	cp	r12, r28
    2f1e:	dd 06       	cpc	r13, r29
    2f20:	31 f7       	brne	.-52     	; 0x2eee <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2f22:	b4 e1       	ldi	r27, 0x14	; 20
    2f24:	ab 0e       	add	r10, r27
    2f26:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2f28:	66 e0       	ldi	r22, 0x06	; 6
    2f2a:	c7 01       	movw	r24, r14
    2f2c:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    2f30:	84 e1       	ldi	r24, 0x14	; 20
    2f32:	c8 0e       	add	r12, r24
    2f34:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f36:	a8 14       	cp	r10, r8
    2f38:	b9 04       	cpc	r11, r9
    2f3a:	08 f4       	brcc	.+2      	; 0x2f3e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2f3c:	88 cf       	rjmp	.-240    	; 0x2e4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2f3e:	62 e0       	ldi	r22, 0x02	; 2
    2f40:	c7 01       	movw	r24, r14
    2f42:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
}
    2f46:	03 c0       	rjmp	.+6      	; 0x2f4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f48:	c6 2d       	mov	r28, r6
    2f4a:	d5 2d       	mov	r29, r5
    2f4c:	9c cf       	rjmp	.-200    	; 0x2e86 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2f4e:	df 91       	pop	r29
    2f50:	cf 91       	pop	r28
    2f52:	1f 91       	pop	r17
    2f54:	0f 91       	pop	r16
    2f56:	ff 90       	pop	r15
    2f58:	ef 90       	pop	r14
    2f5a:	df 90       	pop	r13
    2f5c:	cf 90       	pop	r12
    2f5e:	bf 90       	pop	r11
    2f60:	af 90       	pop	r10
    2f62:	9f 90       	pop	r9
    2f64:	8f 90       	pop	r8
    2f66:	7f 90       	pop	r7
    2f68:	6f 90       	pop	r6
    2f6a:	5f 90       	pop	r5
    2f6c:	08 95       	ret

00002f6e <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2f6e:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    2f72:	08 95       	ret

00002f74 <_Znaj>:
    2f74:	0e 94 f9 07 	call	0xff2	; 0xff2 <pvPortMalloc>
    2f78:	08 95       	ret

00002f7a <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2f7a:	08 95       	ret

00002f7c <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2f7c:	cf 93       	push	r28
    2f7e:	df 93       	push	r29
    2f80:	fc 01       	movw	r30, r24
    2f82:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2f84:	40 3a       	cpi	r20, 0xA0	; 160
    2f86:	68 e0       	ldi	r22, 0x08	; 8
    2f88:	56 07       	cpc	r21, r22
    2f8a:	49 f4       	brne	.+18     	; 0x2f9e <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2f8c:	80 e4       	ldi	r24, 0x40	; 64
    2f8e:	96 e0       	ldi	r25, 0x06	; 6
    2f90:	82 83       	std	Z+2, r24	; 0x02
    2f92:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2f94:	82 e0       	ldi	r24, 0x02	; 2
    2f96:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2f98:	83 e0       	ldi	r24, 0x03	; 3
    2f9a:	85 83       	std	Z+5, r24	; 0x05
    2f9c:	32 c0       	rjmp	.+100    	; 0x3002 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2f9e:	40 3b       	cpi	r20, 0xB0	; 176
    2fa0:	78 e0       	ldi	r23, 0x08	; 8
    2fa2:	57 07       	cpc	r21, r23
    2fa4:	49 f4       	brne	.+18     	; 0x2fb8 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2fa6:	80 e4       	ldi	r24, 0x40	; 64
    2fa8:	96 e0       	ldi	r25, 0x06	; 6
    2faa:	82 83       	std	Z+2, r24	; 0x02
    2fac:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2fae:	86 e0       	ldi	r24, 0x06	; 6
    2fb0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2fb2:	87 e0       	ldi	r24, 0x07	; 7
    2fb4:	85 83       	std	Z+5, r24	; 0x05
    2fb6:	25 c0       	rjmp	.+74     	; 0x3002 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2fb8:	40 3a       	cpi	r20, 0xA0	; 160
    2fba:	89 e0       	ldi	r24, 0x09	; 9
    2fbc:	58 07       	cpc	r21, r24
    2fbe:	49 f4       	brne	.+18     	; 0x2fd2 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2fc0:	80 e6       	ldi	r24, 0x60	; 96
    2fc2:	96 e0       	ldi	r25, 0x06	; 6
    2fc4:	82 83       	std	Z+2, r24	; 0x02
    2fc6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2fc8:	82 e0       	ldi	r24, 0x02	; 2
    2fca:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2fcc:	83 e0       	ldi	r24, 0x03	; 3
    2fce:	85 83       	std	Z+5, r24	; 0x05
    2fd0:	18 c0       	rjmp	.+48     	; 0x3002 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2fd2:	40 3b       	cpi	r20, 0xB0	; 176
    2fd4:	69 e0       	ldi	r22, 0x09	; 9
    2fd6:	56 07       	cpc	r21, r22
    2fd8:	49 f4       	brne	.+18     	; 0x2fec <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2fda:	80 e6       	ldi	r24, 0x60	; 96
    2fdc:	96 e0       	ldi	r25, 0x06	; 6
    2fde:	82 83       	std	Z+2, r24	; 0x02
    2fe0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2fe2:	86 e0       	ldi	r24, 0x06	; 6
    2fe4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2fe6:	87 e0       	ldi	r24, 0x07	; 7
    2fe8:	85 83       	std	Z+5, r24	; 0x05
    2fea:	0b c0       	rjmp	.+22     	; 0x3002 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2fec:	40 3a       	cpi	r20, 0xA0	; 160
    2fee:	5a 40       	sbci	r21, 0x0A	; 10
    2ff0:	41 f4       	brne	.+16     	; 0x3002 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    2ff2:	80 e8       	ldi	r24, 0x80	; 128
    2ff4:	96 e0       	ldi	r25, 0x06	; 6
    2ff6:	82 83       	std	Z+2, r24	; 0x02
    2ff8:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2ffa:	82 e0       	ldi	r24, 0x02	; 2
    2ffc:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ffe:	83 e0       	ldi	r24, 0x03	; 3
    3000:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3002:	a6 83       	std	Z+6, r26	; 0x06
    3004:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3006:	cd 01       	movw	r24, r26
    3008:	01 96       	adiw	r24, 0x01	; 1
    300a:	80 87       	std	Z+8, r24	; 0x08
    300c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    300e:	03 96       	adiw	r24, 0x03	; 3
    3010:	82 87       	std	Z+10, r24	; 0x0a
    3012:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3014:	25 81       	ldd	r18, Z+5	; 0x05
    3016:	c2 81       	ldd	r28, Z+2	; 0x02
    3018:	d3 81       	ldd	r29, Z+3	; 0x03
    301a:	4c 81       	ldd	r20, Y+4	; 0x04
    301c:	81 e0       	ldi	r24, 0x01	; 1
    301e:	90 e0       	ldi	r25, 0x00	; 0
    3020:	bc 01       	movw	r22, r24
    3022:	02 c0       	rjmp	.+4      	; 0x3028 <_ZN7base232C1EjP12USART_struct+0xac>
    3024:	66 0f       	add	r22, r22
    3026:	77 1f       	adc	r23, r23
    3028:	2a 95       	dec	r18
    302a:	e2 f7       	brpl	.-8      	; 0x3024 <_ZN7base232C1EjP12USART_struct+0xa8>
    302c:	9b 01       	movw	r18, r22
    302e:	24 2b       	or	r18, r20
    3030:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3032:	25 81       	ldd	r18, Z+5	; 0x05
    3034:	c2 81       	ldd	r28, Z+2	; 0x02
    3036:	d3 81       	ldd	r29, Z+3	; 0x03
    3038:	48 81       	ld	r20, Y
    303a:	bc 01       	movw	r22, r24
    303c:	02 c0       	rjmp	.+4      	; 0x3042 <_ZN7base232C1EjP12USART_struct+0xc6>
    303e:	66 0f       	add	r22, r22
    3040:	77 1f       	adc	r23, r23
    3042:	2a 95       	dec	r18
    3044:	e2 f7       	brpl	.-8      	; 0x303e <_ZN7base232C1EjP12USART_struct+0xc2>
    3046:	9b 01       	movw	r18, r22
    3048:	24 2b       	or	r18, r20
    304a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    304c:	34 81       	ldd	r19, Z+4	; 0x04
    304e:	c2 81       	ldd	r28, Z+2	; 0x02
    3050:	d3 81       	ldd	r29, Z+3	; 0x03
    3052:	28 81       	ld	r18, Y
    3054:	02 c0       	rjmp	.+4      	; 0x305a <_ZN7base232C1EjP12USART_struct+0xde>
    3056:	88 0f       	add	r24, r24
    3058:	99 1f       	adc	r25, r25
    305a:	3a 95       	dec	r19
    305c:	e2 f7       	brpl	.-8      	; 0x3056 <_ZN7base232C1EjP12USART_struct+0xda>
    305e:	80 95       	com	r24
    3060:	90 95       	com	r25
    3062:	82 23       	and	r24, r18
    3064:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3066:	80 e1       	ldi	r24, 0x10	; 16
    3068:	13 96       	adiw	r26, 0x03	; 3
    306a:	8c 93       	st	X, r24
    306c:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    306e:	83 e0       	ldi	r24, 0x03	; 3
    3070:	15 96       	adiw	r26, 0x05	; 5
    3072:	8c 93       	st	X, r24
    3074:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3076:	80 ef       	ldi	r24, 0xF0	; 240
    3078:	17 96       	adiw	r26, 0x07	; 7
    307a:	8c 93       	st	X, r24
    307c:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    307e:	81 e2       	ldi	r24, 0x21	; 33
    3080:	16 96       	adiw	r26, 0x06	; 6
    3082:	8c 93       	st	X, r24
    3084:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3086:	88 e1       	ldi	r24, 0x18	; 24
    3088:	14 96       	adiw	r26, 0x04	; 4
    308a:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    308c:	80 e8       	ldi	r24, 0x80	; 128
    308e:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3090:	80 e4       	ldi	r24, 0x40	; 64
    3092:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3094:	80 e2       	ldi	r24, 0x20	; 32
    3096:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3098:	06 80       	ldd	r0, Z+6	; 0x06
    309a:	f7 81       	ldd	r31, Z+7	; 0x07
    309c:	e0 2d       	mov	r30, r0
    309e:	80 81       	ld	r24, Z
    30a0:	80 81       	ld	r24, Z
}
    30a2:	df 91       	pop	r29
    30a4:	cf 91       	pop	r28
    30a6:	08 95       	ret

000030a8 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	08 95       	ret

000030ac <_ZN8emstream7getcharEv>:
    30ac:	80 e0       	ldi	r24, 0x00	; 0
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	08 95       	ret

000030b2 <_ZN8emstream14check_for_charEv>:
    30b2:	80 e0       	ldi	r24, 0x00	; 0
    30b4:	08 95       	ret

000030b6 <_ZN8emstream12transmit_nowEv>:
    30b6:	08 95       	ret

000030b8 <_ZN8emstream12clear_screenEv>:
    30b8:	08 95       	ret

000030ba <_ZN8emstreamC1Ev>:
    30ba:	fc 01       	movw	r30, r24
    30bc:	89 e4       	ldi	r24, 0x49	; 73
    30be:	90 e2       	ldi	r25, 0x20	; 32
    30c0:	80 83       	st	Z, r24
    30c2:	91 83       	std	Z+1, r25	; 0x01
    30c4:	8a e0       	ldi	r24, 0x0A	; 10
    30c6:	82 83       	std	Z+2, r24	; 0x02
    30c8:	13 82       	std	Z+3, r1	; 0x03
    30ca:	83 e0       	ldi	r24, 0x03	; 3
    30cc:	85 83       	std	Z+5, r24	; 0x05
    30ce:	14 82       	std	Z+4, r1	; 0x04
    30d0:	16 82       	std	Z+6, r1	; 0x06
    30d2:	17 82       	std	Z+7, r1	; 0x07
    30d4:	08 95       	ret

000030d6 <_ZN8emstream4putsEPKc>:
    30d6:	0f 93       	push	r16
    30d8:	1f 93       	push	r17
    30da:	cf 93       	push	r28
    30dc:	df 93       	push	r29
    30de:	8c 01       	movw	r16, r24
    30e0:	fb 01       	movw	r30, r22
    30e2:	dc 01       	movw	r26, r24
    30e4:	14 96       	adiw	r26, 0x04	; 4
    30e6:	8c 91       	ld	r24, X
    30e8:	81 11       	cpse	r24, r1
    30ea:	04 c0       	rjmp	.+8      	; 0x30f4 <_ZN8emstream4putsEPKc+0x1e>
    30ec:	60 81       	ld	r22, Z
    30ee:	61 11       	cpse	r22, r1
    30f0:	17 c0       	rjmp	.+46     	; 0x3120 <_ZN8emstream4putsEPKc+0x4a>
    30f2:	23 c0       	rjmp	.+70     	; 0x313a <_ZN8emstream4putsEPKc+0x64>
    30f4:	d8 01       	movw	r26, r16
    30f6:	14 96       	adiw	r26, 0x04	; 4
    30f8:	1c 92       	st	X, r1
    30fa:	eb 01       	movw	r28, r22
    30fc:	21 96       	adiw	r28, 0x01	; 1
    30fe:	64 91       	lpm	r22, Z
    3100:	66 23       	and	r22, r22
    3102:	d9 f0       	breq	.+54     	; 0x313a <_ZN8emstream4putsEPKc+0x64>
    3104:	d8 01       	movw	r26, r16
    3106:	ed 91       	ld	r30, X+
    3108:	fc 91       	ld	r31, X
    310a:	02 80       	ldd	r0, Z+2	; 0x02
    310c:	f3 81       	ldd	r31, Z+3	; 0x03
    310e:	e0 2d       	mov	r30, r0
    3110:	c8 01       	movw	r24, r16
    3112:	19 95       	eicall
    3114:	fe 01       	movw	r30, r28
    3116:	64 91       	lpm	r22, Z
    3118:	21 96       	adiw	r28, 0x01	; 1
    311a:	61 11       	cpse	r22, r1
    311c:	f3 cf       	rjmp	.-26     	; 0x3104 <_ZN8emstream4putsEPKc+0x2e>
    311e:	0d c0       	rjmp	.+26     	; 0x313a <_ZN8emstream4putsEPKc+0x64>
    3120:	ef 01       	movw	r28, r30
    3122:	21 96       	adiw	r28, 0x01	; 1
    3124:	d8 01       	movw	r26, r16
    3126:	ed 91       	ld	r30, X+
    3128:	fc 91       	ld	r31, X
    312a:	02 80       	ldd	r0, Z+2	; 0x02
    312c:	f3 81       	ldd	r31, Z+3	; 0x03
    312e:	e0 2d       	mov	r30, r0
    3130:	c8 01       	movw	r24, r16
    3132:	19 95       	eicall
    3134:	69 91       	ld	r22, Y+
    3136:	61 11       	cpse	r22, r1
    3138:	f5 cf       	rjmp	.-22     	; 0x3124 <_ZN8emstream4putsEPKc+0x4e>
    313a:	df 91       	pop	r29
    313c:	cf 91       	pop	r28
    313e:	1f 91       	pop	r17
    3140:	0f 91       	pop	r16
    3142:	08 95       	ret

00003144 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3144:	cf 93       	push	r28
    3146:	df 93       	push	r29
    3148:	ec 01       	movw	r28, r24
	switch (new_manip)
    314a:	86 2f       	mov	r24, r22
    314c:	90 e0       	ldi	r25, 0x00	; 0
    314e:	8b 30       	cpi	r24, 0x0B	; 11
    3150:	91 05       	cpc	r25, r1
    3152:	d8 f5       	brcc	.+118    	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
    3154:	fc 01       	movw	r30, r24
    3156:	88 27       	eor	r24, r24
    3158:	e2 50       	subi	r30, 0x02	; 2
    315a:	ff 4f       	sbci	r31, 0xFF	; 255
    315c:	8f 4f       	sbci	r24, 0xFF	; 255
    315e:	0c 94 06 20 	jmp	0x400c	; 0x400c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3162:	82 e0       	ldi	r24, 0x02	; 2
    3164:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3166:	31 c0       	rjmp	.+98     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3168:	88 e0       	ldi	r24, 0x08	; 8
    316a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    316c:	2e c0       	rjmp	.+92     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    316e:	8a e0       	ldi	r24, 0x0A	; 10
    3170:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3172:	2b c0       	rjmp	.+86     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3174:	80 e1       	ldi	r24, 0x10	; 16
    3176:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3178:	28 c0       	rjmp	.+80     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    317a:	81 e0       	ldi	r24, 0x01	; 1
    317c:	8b 83       	std	Y+3, r24	; 0x03
			break;
    317e:	25 c0       	rjmp	.+74     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3180:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3182:	23 c0       	rjmp	.+70     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3184:	e8 81       	ld	r30, Y
    3186:	f9 81       	ldd	r31, Y+1	; 0x01
    3188:	02 80       	ldd	r0, Z+2	; 0x02
    318a:	f3 81       	ldd	r31, Z+3	; 0x03
    318c:	e0 2d       	mov	r30, r0
    318e:	6d e0       	ldi	r22, 0x0D	; 13
    3190:	ce 01       	movw	r24, r28
    3192:	19 95       	eicall
    3194:	e8 81       	ld	r30, Y
    3196:	f9 81       	ldd	r31, Y+1	; 0x01
    3198:	02 80       	ldd	r0, Z+2	; 0x02
    319a:	f3 81       	ldd	r31, Z+3	; 0x03
    319c:	e0 2d       	mov	r30, r0
    319e:	6a e0       	ldi	r22, 0x0A	; 10
    31a0:	ce 01       	movw	r24, r28
    31a2:	19 95       	eicall
			break;
    31a4:	12 c0       	rjmp	.+36     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    31a6:	e8 81       	ld	r30, Y
    31a8:	f9 81       	ldd	r31, Y+1	; 0x01
    31aa:	02 84       	ldd	r0, Z+10	; 0x0a
    31ac:	f3 85       	ldd	r31, Z+11	; 0x0b
    31ae:	e0 2d       	mov	r30, r0
    31b0:	ce 01       	movw	r24, r28
    31b2:	19 95       	eicall
			break;
    31b4:	0a c0       	rjmp	.+20     	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    31b6:	e8 81       	ld	r30, Y
    31b8:	f9 81       	ldd	r31, Y+1	; 0x01
    31ba:	00 84       	ldd	r0, Z+8	; 0x08
    31bc:	f1 85       	ldd	r31, Z+9	; 0x09
    31be:	e0 2d       	mov	r30, r0
    31c0:	ce 01       	movw	r24, r28
    31c2:	19 95       	eicall
			break;
    31c4:	02 c0       	rjmp	.+4      	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    31c6:	81 e0       	ldi	r24, 0x01	; 1
    31c8:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    31ca:	ce 01       	movw	r24, r28
    31cc:	df 91       	pop	r29
    31ce:	cf 91       	pop	r28
    31d0:	08 95       	ret

000031d2 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    31d2:	ff 92       	push	r15
    31d4:	0f 93       	push	r16
    31d6:	1f 93       	push	r17
    31d8:	cf 93       	push	r28
    31da:	df 93       	push	r29
    31dc:	cd b7       	in	r28, 0x3d	; 61
    31de:	de b7       	in	r29, 0x3e	; 62
    31e0:	61 97       	sbiw	r28, 0x11	; 17
    31e2:	cd bf       	out	0x3d, r28	; 61
    31e4:	de bf       	out	0x3e, r29	; 62
    31e6:	8c 01       	movw	r16, r24
    31e8:	f6 2e       	mov	r15, r22
    31ea:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    31ec:	f8 01       	movw	r30, r16
    31ee:	42 81       	ldd	r20, Z+2	; 0x02
    31f0:	40 31       	cpi	r20, 0x10	; 16
    31f2:	21 f0       	breq	.+8      	; 0x31fc <_ZN8emstreamlsEj+0x2a>
    31f4:	48 30       	cpi	r20, 0x08	; 8
    31f6:	11 f0       	breq	.+4      	; 0x31fc <_ZN8emstreamlsEj+0x2a>
    31f8:	42 30       	cpi	r20, 0x02	; 2
    31fa:	41 f4       	brne	.+16     	; 0x320c <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    31fc:	69 2f       	mov	r22, r25
    31fe:	c8 01       	movw	r24, r16
    3200:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    3204:	6f 2d       	mov	r22, r15
    3206:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    320a:	0d c0       	rjmp	.+26     	; 0x3226 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    320c:	50 e0       	ldi	r21, 0x00	; 0
    320e:	be 01       	movw	r22, r28
    3210:	6f 5f       	subi	r22, 0xFF	; 255
    3212:	7f 4f       	sbci	r23, 0xFF	; 255
    3214:	8f 2d       	mov	r24, r15
    3216:	0e 94 75 20 	call	0x40ea	; 0x40ea <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    321a:	be 01       	movw	r22, r28
    321c:	6f 5f       	subi	r22, 0xFF	; 255
    321e:	7f 4f       	sbci	r23, 0xFF	; 255
    3220:	c8 01       	movw	r24, r16
    3222:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3226:	c8 01       	movw	r24, r16
    3228:	61 96       	adiw	r28, 0x11	; 17
    322a:	cd bf       	out	0x3d, r28	; 61
    322c:	de bf       	out	0x3e, r29	; 62
    322e:	df 91       	pop	r29
    3230:	cf 91       	pop	r28
    3232:	1f 91       	pop	r17
    3234:	0f 91       	pop	r16
    3236:	ff 90       	pop	r15
    3238:	08 95       	ret

0000323a <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    323a:	df 92       	push	r13
    323c:	ef 92       	push	r14
    323e:	ff 92       	push	r15
    3240:	0f 93       	push	r16
    3242:	1f 93       	push	r17
    3244:	cf 93       	push	r28
    3246:	df 93       	push	r29
    3248:	cd b7       	in	r28, 0x3d	; 61
    324a:	de b7       	in	r29, 0x3e	; 62
    324c:	a1 97       	sbiw	r28, 0x21	; 33
    324e:	cd bf       	out	0x3d, r28	; 61
    3250:	de bf       	out	0x3e, r29	; 62
    3252:	8c 01       	movw	r16, r24
    3254:	d4 2e       	mov	r13, r20
    3256:	e5 2e       	mov	r14, r21
    3258:	f6 2e       	mov	r15, r22
    325a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    325c:	f8 01       	movw	r30, r16
    325e:	22 81       	ldd	r18, Z+2	; 0x02
    3260:	20 31       	cpi	r18, 0x10	; 16
    3262:	21 f0       	breq	.+8      	; 0x326c <_ZN8emstreamlsEm+0x32>
    3264:	28 30       	cpi	r18, 0x08	; 8
    3266:	11 f0       	breq	.+4      	; 0x326c <_ZN8emstreamlsEm+0x32>
    3268:	22 30       	cpi	r18, 0x02	; 2
    326a:	71 f4       	brne	.+28     	; 0x3288 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    326c:	69 2f       	mov	r22, r25
    326e:	c8 01       	movw	r24, r16
    3270:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    3274:	6f 2d       	mov	r22, r15
    3276:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    327a:	6e 2d       	mov	r22, r14
    327c:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    3280:	6d 2d       	mov	r22, r13
    3282:	0e 94 5f 19 	call	0x32be	; 0x32be <_ZN8emstreamlsEh>
    3286:	0f c0       	rjmp	.+30     	; 0x32a6 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3288:	30 e0       	ldi	r19, 0x00	; 0
    328a:	ae 01       	movw	r20, r28
    328c:	4f 5f       	subi	r20, 0xFF	; 255
    328e:	5f 4f       	sbci	r21, 0xFF	; 255
    3290:	6d 2d       	mov	r22, r13
    3292:	7e 2d       	mov	r23, r14
    3294:	8f 2d       	mov	r24, r15
    3296:	0e 94 48 20 	call	0x4090	; 0x4090 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    329a:	be 01       	movw	r22, r28
    329c:	6f 5f       	subi	r22, 0xFF	; 255
    329e:	7f 4f       	sbci	r23, 0xFF	; 255
    32a0:	c8 01       	movw	r24, r16
    32a2:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    32a6:	c8 01       	movw	r24, r16
    32a8:	a1 96       	adiw	r28, 0x21	; 33
    32aa:	cd bf       	out	0x3d, r28	; 61
    32ac:	de bf       	out	0x3e, r29	; 62
    32ae:	df 91       	pop	r29
    32b0:	cf 91       	pop	r28
    32b2:	1f 91       	pop	r17
    32b4:	0f 91       	pop	r16
    32b6:	ff 90       	pop	r15
    32b8:	ef 90       	pop	r14
    32ba:	df 90       	pop	r13
    32bc:	08 95       	ret

000032be <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    32be:	cf 92       	push	r12
    32c0:	df 92       	push	r13
    32c2:	ef 92       	push	r14
    32c4:	ff 92       	push	r15
    32c6:	0f 93       	push	r16
    32c8:	1f 93       	push	r17
    32ca:	cf 93       	push	r28
    32cc:	df 93       	push	r29
    32ce:	cd b7       	in	r28, 0x3d	; 61
    32d0:	de b7       	in	r29, 0x3e	; 62
    32d2:	29 97       	sbiw	r28, 0x09	; 9
    32d4:	cd bf       	out	0x3d, r28	; 61
    32d6:	de bf       	out	0x3e, r29	; 62
    32d8:	8c 01       	movw	r16, r24
    32da:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    32dc:	dc 01       	movw	r26, r24
    32de:	13 96       	adiw	r26, 0x03	; 3
    32e0:	8c 91       	ld	r24, X
    32e2:	13 97       	sbiw	r26, 0x03	; 3
    32e4:	88 23       	and	r24, r24
    32e6:	41 f0       	breq	.+16     	; 0x32f8 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    32e8:	ed 91       	ld	r30, X+
    32ea:	fc 91       	ld	r31, X
    32ec:	02 80       	ldd	r0, Z+2	; 0x02
    32ee:	f3 81       	ldd	r31, Z+3	; 0x03
    32f0:	e0 2d       	mov	r30, r0
    32f2:	c8 01       	movw	r24, r16
    32f4:	19 95       	eicall
    32f6:	56 c0       	rjmp	.+172    	; 0x33a4 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    32f8:	f8 01       	movw	r30, r16
    32fa:	42 81       	ldd	r20, Z+2	; 0x02
    32fc:	42 30       	cpi	r20, 0x02	; 2
    32fe:	19 f5       	brne	.+70     	; 0x3346 <_ZN8emstreamlsEh+0x88>
    3300:	68 94       	set
    3302:	cc 24       	eor	r12, r12
    3304:	c3 f8       	bld	r12, 3
    3306:	d1 2c       	mov	r13, r1
    3308:	68 94       	set
    330a:	ff 24       	eor	r15, r15
    330c:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    330e:	8e 2d       	mov	r24, r14
    3310:	8f 21       	and	r24, r15
    3312:	51 f0       	breq	.+20     	; 0x3328 <_ZN8emstreamlsEh+0x6a>
    3314:	d8 01       	movw	r26, r16
    3316:	ed 91       	ld	r30, X+
    3318:	fc 91       	ld	r31, X
    331a:	02 80       	ldd	r0, Z+2	; 0x02
    331c:	f3 81       	ldd	r31, Z+3	; 0x03
    331e:	e0 2d       	mov	r30, r0
    3320:	61 e3       	ldi	r22, 0x31	; 49
    3322:	c8 01       	movw	r24, r16
    3324:	19 95       	eicall
    3326:	09 c0       	rjmp	.+18     	; 0x333a <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3328:	d8 01       	movw	r26, r16
    332a:	ed 91       	ld	r30, X+
    332c:	fc 91       	ld	r31, X
    332e:	02 80       	ldd	r0, Z+2	; 0x02
    3330:	f3 81       	ldd	r31, Z+3	; 0x03
    3332:	e0 2d       	mov	r30, r0
    3334:	60 e3       	ldi	r22, 0x30	; 48
    3336:	c8 01       	movw	r24, r16
    3338:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    333a:	f6 94       	lsr	r15
    333c:	b1 e0       	ldi	r27, 0x01	; 1
    333e:	cb 1a       	sub	r12, r27
    3340:	d1 08       	sbc	r13, r1
    3342:	29 f7       	brne	.-54     	; 0x330e <_ZN8emstreamlsEh+0x50>
    3344:	2f c0       	rjmp	.+94     	; 0x33a4 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3346:	40 31       	cpi	r20, 0x10	; 16
    3348:	f9 f4       	brne	.+62     	; 0x3388 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    334a:	62 95       	swap	r22
    334c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    334e:	01 90       	ld	r0, Z+
    3350:	f0 81       	ld	r31, Z
    3352:	e0 2d       	mov	r30, r0
    3354:	02 80       	ldd	r0, Z+2	; 0x02
    3356:	f3 81       	ldd	r31, Z+3	; 0x03
    3358:	e0 2d       	mov	r30, r0
    335a:	6a 30       	cpi	r22, 0x0A	; 10
    335c:	10 f0       	brcs	.+4      	; 0x3362 <_ZN8emstreamlsEh+0xa4>
    335e:	69 5c       	subi	r22, 0xC9	; 201
    3360:	01 c0       	rjmp	.+2      	; 0x3364 <_ZN8emstreamlsEh+0xa6>
    3362:	60 5d       	subi	r22, 0xD0	; 208
    3364:	c8 01       	movw	r24, r16
    3366:	19 95       	eicall
		temp_char = num & 0x0F;
    3368:	6e 2d       	mov	r22, r14
    336a:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    336c:	d8 01       	movw	r26, r16
    336e:	ed 91       	ld	r30, X+
    3370:	fc 91       	ld	r31, X
    3372:	02 80       	ldd	r0, Z+2	; 0x02
    3374:	f3 81       	ldd	r31, Z+3	; 0x03
    3376:	e0 2d       	mov	r30, r0
    3378:	6a 30       	cpi	r22, 0x0A	; 10
    337a:	10 f0       	brcs	.+4      	; 0x3380 <_ZN8emstreamlsEh+0xc2>
    337c:	69 5c       	subi	r22, 0xC9	; 201
    337e:	01 c0       	rjmp	.+2      	; 0x3382 <_ZN8emstreamlsEh+0xc4>
    3380:	60 5d       	subi	r22, 0xD0	; 208
    3382:	c8 01       	movw	r24, r16
    3384:	19 95       	eicall
    3386:	0e c0       	rjmp	.+28     	; 0x33a4 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3388:	50 e0       	ldi	r21, 0x00	; 0
    338a:	be 01       	movw	r22, r28
    338c:	6f 5f       	subi	r22, 0xFF	; 255
    338e:	7f 4f       	sbci	r23, 0xFF	; 255
    3390:	8e 2d       	mov	r24, r14
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	0e 94 75 20 	call	0x40ea	; 0x40ea <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3398:	be 01       	movw	r22, r28
    339a:	6f 5f       	subi	r22, 0xFF	; 255
    339c:	7f 4f       	sbci	r23, 0xFF	; 255
    339e:	c8 01       	movw	r24, r16
    33a0:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    33a4:	c8 01       	movw	r24, r16
    33a6:	29 96       	adiw	r28, 0x09	; 9
    33a8:	cd bf       	out	0x3d, r28	; 61
    33aa:	de bf       	out	0x3e, r29	; 62
    33ac:	df 91       	pop	r29
    33ae:	cf 91       	pop	r28
    33b0:	1f 91       	pop	r17
    33b2:	0f 91       	pop	r16
    33b4:	ff 90       	pop	r15
    33b6:	ef 90       	pop	r14
    33b8:	df 90       	pop	r13
    33ba:	cf 90       	pop	r12
    33bc:	08 95       	ret

000033be <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    33be:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    33c0:	50 96       	adiw	r26, 0x10	; 16
    33c2:	ed 91       	ld	r30, X+
    33c4:	fc 91       	ld	r31, X
    33c6:	51 97       	sbiw	r26, 0x11	; 17
    33c8:	80 81       	ld	r24, Z
    33ca:	54 96       	adiw	r26, 0x14	; 20
    33cc:	4c 91       	ld	r20, X
    33ce:	54 97       	sbiw	r26, 0x14	; 20
    33d0:	84 23       	and	r24, r20
    33d2:	29 f0       	breq	.+10     	; 0x33de <_ZN5rs2327putcharEc+0x20>
    33d4:	09 c0       	rjmp	.+18     	; 0x33e8 <_ZN5rs2327putcharEc+0x2a>
    33d6:	21 50       	subi	r18, 0x01	; 1
    33d8:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    33da:	19 f4       	brne	.+6      	; 0x33e2 <_ZN5rs2327putcharEc+0x24>
    33dc:	12 c0       	rjmp	.+36     	; 0x3402 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    33de:	21 e2       	ldi	r18, 0x21	; 33
    33e0:	3e e4       	ldi	r19, 0x4E	; 78
    33e2:	90 81       	ld	r25, Z
    33e4:	94 23       	and	r25, r20
    33e6:	b9 f3       	breq	.-18     	; 0x33d6 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    33e8:	90 81       	ld	r25, Z
    33ea:	56 96       	adiw	r26, 0x16	; 22
    33ec:	8c 91       	ld	r24, X
    33ee:	56 97       	sbiw	r26, 0x16	; 22
    33f0:	89 2b       	or	r24, r25
    33f2:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    33f4:	1e 96       	adiw	r26, 0x0e	; 14
    33f6:	ed 91       	ld	r30, X+
    33f8:	fc 91       	ld	r31, X
    33fa:	1f 97       	sbiw	r26, 0x0f	; 15
    33fc:	60 83       	st	Z, r22
	return (true);
    33fe:	81 e0       	ldi	r24, 0x01	; 1
    3400:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3402:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3404:	08 95       	ret

00003406 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3406:	cf 93       	push	r28
    3408:	df 93       	push	r29
    340a:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    340c:	c1 8d       	ldd	r28, Z+25	; 0x19
    340e:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3410:	28 81       	ld	r18, Y
    3412:	39 81       	ldd	r19, Y+1	; 0x01
    3414:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3416:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3418:	4d 91       	ld	r20, X+
    341a:	5c 91       	ld	r21, X
    341c:	24 17       	cp	r18, r20
    341e:	35 07       	cpc	r19, r21
    3420:	e9 f3       	breq	.-6      	; 0x341c <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3422:	a7 89       	ldd	r26, Z+23	; 0x17
    3424:	b0 8d       	ldd	r27, Z+24	; 0x18
    3426:	0d 90       	ld	r0, X+
    3428:	bc 91       	ld	r27, X
    342a:	a0 2d       	mov	r26, r0
    342c:	a2 0f       	add	r26, r18
    342e:	b3 1f       	adc	r27, r19
    3430:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3432:	2f 5f       	subi	r18, 0xFF	; 255
    3434:	3f 4f       	sbci	r19, 0xFF	; 255
    3436:	28 83       	st	Y, r18
    3438:	39 83       	std	Y+1, r19	; 0x01
    343a:	24 36       	cpi	r18, 0x64	; 100
    343c:	31 05       	cpc	r19, r1
    343e:	28 f0       	brcs	.+10     	; 0x344a <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3440:	01 8c       	ldd	r0, Z+25	; 0x19
    3442:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3444:	e0 2d       	mov	r30, r0
    3446:	10 82       	st	Z, r1
    3448:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    344a:	90 e0       	ldi	r25, 0x00	; 0
    344c:	df 91       	pop	r29
    344e:	cf 91       	pop	r28
    3450:	08 95       	ret

00003452 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3452:	cf 93       	push	r28
    3454:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3456:	ec 01       	movw	r28, r24
    3458:	a9 8d       	ldd	r26, Y+25	; 0x19
    345a:	ba 8d       	ldd	r27, Y+26	; 0x1a
    345c:	eb 8d       	ldd	r30, Y+27	; 0x1b
    345e:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3460:	81 e0       	ldi	r24, 0x01	; 1
    3462:	4d 91       	ld	r20, X+
    3464:	5c 91       	ld	r21, X
    3466:	20 81       	ld	r18, Z
    3468:	31 81       	ldd	r19, Z+1	; 0x01
    346a:	42 17       	cp	r20, r18
    346c:	53 07       	cpc	r21, r19
    346e:	09 f4       	brne	.+2      	; 0x3472 <_ZN5rs23214check_for_charEv+0x20>
    3470:	80 e0       	ldi	r24, 0x00	; 0
}
    3472:	df 91       	pop	r29
    3474:	cf 91       	pop	r28
    3476:	08 95       	ret

00003478 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3478:	dc 01       	movw	r26, r24
    347a:	ed 91       	ld	r30, X+
    347c:	fc 91       	ld	r31, X
    347e:	02 80       	ldd	r0, Z+2	; 0x02
    3480:	f3 81       	ldd	r31, Z+3	; 0x03
    3482:	e0 2d       	mov	r30, r0
    3484:	6c e0       	ldi	r22, 0x0C	; 12
    3486:	19 95       	eicall
    3488:	08 95       	ret

0000348a <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    348a:	ef 92       	push	r14
    348c:	ff 92       	push	r15
    348e:	0f 93       	push	r16
    3490:	1f 93       	push	r17
    3492:	cf 93       	push	r28
    3494:	df 93       	push	r29
    3496:	ec 01       	movw	r28, r24
    3498:	7b 01       	movw	r14, r22
    349a:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    349c:	0e 94 5d 18 	call	0x30ba	; 0x30ba <_ZN8emstreamC1Ev>
    34a0:	a8 01       	movw	r20, r16
    34a2:	b7 01       	movw	r22, r14
    34a4:	ce 01       	movw	r24, r28
    34a6:	08 96       	adiw	r24, 0x08	; 8
    34a8:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN7base232C1EjP12USART_struct>
    34ac:	89 e5       	ldi	r24, 0x59	; 89
    34ae:	90 e2       	ldi	r25, 0x20	; 32
    34b0:	88 83       	st	Y, r24
    34b2:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    34b4:	00 3a       	cpi	r16, 0xA0	; 160
    34b6:	88 e0       	ldi	r24, 0x08	; 8
    34b8:	18 07       	cpc	r17, r24
    34ba:	69 f4       	brne	.+26     	; 0x34d6 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    34bc:	82 e6       	ldi	r24, 0x62	; 98
    34be:	91 e3       	ldi	r25, 0x31	; 49
    34c0:	8f 8b       	std	Y+23, r24	; 0x17
    34c2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    34c4:	88 e5       	ldi	r24, 0x58	; 88
    34c6:	91 e3       	ldi	r25, 0x31	; 49
    34c8:	89 8f       	std	Y+25, r24	; 0x19
    34ca:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    34cc:	8e e4       	ldi	r24, 0x4E	; 78
    34ce:	91 e3       	ldi	r25, 0x31	; 49
    34d0:	8b 8f       	std	Y+27, r24	; 0x1b
    34d2:	9c 8f       	std	Y+28, r25	; 0x1c
    34d4:	42 c0       	rjmp	.+132    	; 0x355a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    34d6:	00 3b       	cpi	r16, 0xB0	; 176
    34d8:	e8 e0       	ldi	r30, 0x08	; 8
    34da:	1e 07       	cpc	r17, r30
    34dc:	69 f4       	brne	.+26     	; 0x34f8 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    34de:	80 e6       	ldi	r24, 0x60	; 96
    34e0:	91 e3       	ldi	r25, 0x31	; 49
    34e2:	8f 8b       	std	Y+23, r24	; 0x17
    34e4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    34e6:	86 e5       	ldi	r24, 0x56	; 86
    34e8:	91 e3       	ldi	r25, 0x31	; 49
    34ea:	89 8f       	std	Y+25, r24	; 0x19
    34ec:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    34ee:	8c e4       	ldi	r24, 0x4C	; 76
    34f0:	91 e3       	ldi	r25, 0x31	; 49
    34f2:	8b 8f       	std	Y+27, r24	; 0x1b
    34f4:	9c 8f       	std	Y+28, r25	; 0x1c
    34f6:	31 c0       	rjmp	.+98     	; 0x355a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    34f8:	00 3a       	cpi	r16, 0xA0	; 160
    34fa:	f9 e0       	ldi	r31, 0x09	; 9
    34fc:	1f 07       	cpc	r17, r31
    34fe:	69 f4       	brne	.+26     	; 0x351a <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3500:	8e e5       	ldi	r24, 0x5E	; 94
    3502:	91 e3       	ldi	r25, 0x31	; 49
    3504:	8f 8b       	std	Y+23, r24	; 0x17
    3506:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3508:	84 e5       	ldi	r24, 0x54	; 84
    350a:	91 e3       	ldi	r25, 0x31	; 49
    350c:	89 8f       	std	Y+25, r24	; 0x19
    350e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3510:	8a e4       	ldi	r24, 0x4A	; 74
    3512:	91 e3       	ldi	r25, 0x31	; 49
    3514:	8b 8f       	std	Y+27, r24	; 0x1b
    3516:	9c 8f       	std	Y+28, r25	; 0x1c
    3518:	20 c0       	rjmp	.+64     	; 0x355a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    351a:	00 3b       	cpi	r16, 0xB0	; 176
    351c:	89 e0       	ldi	r24, 0x09	; 9
    351e:	18 07       	cpc	r17, r24
    3520:	69 f4       	brne	.+26     	; 0x353c <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3522:	8c e5       	ldi	r24, 0x5C	; 92
    3524:	91 e3       	ldi	r25, 0x31	; 49
    3526:	8f 8b       	std	Y+23, r24	; 0x17
    3528:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    352a:	82 e5       	ldi	r24, 0x52	; 82
    352c:	91 e3       	ldi	r25, 0x31	; 49
    352e:	89 8f       	std	Y+25, r24	; 0x19
    3530:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3532:	88 e4       	ldi	r24, 0x48	; 72
    3534:	91 e3       	ldi	r25, 0x31	; 49
    3536:	8b 8f       	std	Y+27, r24	; 0x1b
    3538:	9c 8f       	std	Y+28, r25	; 0x1c
    353a:	0f c0       	rjmp	.+30     	; 0x355a <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    353c:	00 3a       	cpi	r16, 0xA0	; 160
    353e:	1a 40       	sbci	r17, 0x0A	; 10
    3540:	61 f4       	brne	.+24     	; 0x355a <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3542:	8a e5       	ldi	r24, 0x5A	; 90
    3544:	91 e3       	ldi	r25, 0x31	; 49
    3546:	8f 8b       	std	Y+23, r24	; 0x17
    3548:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    354a:	80 e5       	ldi	r24, 0x50	; 80
    354c:	91 e3       	ldi	r25, 0x31	; 49
    354e:	89 8f       	std	Y+25, r24	; 0x19
    3550:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3552:	86 e4       	ldi	r24, 0x46	; 70
    3554:	91 e3       	ldi	r25, 0x31	; 49
    3556:	8b 8f       	std	Y+27, r24	; 0x1b
    3558:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    355a:	0f 89       	ldd	r16, Y+23	; 0x17
    355c:	18 8d       	ldd	r17, Y+24	; 0x18
    355e:	84 e6       	ldi	r24, 0x64	; 100
    3560:	90 e0       	ldi	r25, 0x00	; 0
    3562:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <_Znaj>
    3566:	f8 01       	movw	r30, r16
    3568:	80 83       	st	Z, r24
    356a:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    356c:	e9 8d       	ldd	r30, Y+25	; 0x19
    356e:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3570:	10 82       	st	Z, r1
    3572:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3574:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3576:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3578:	10 82       	st	Z, r1
    357a:	11 82       	std	Z+1, r1	; 0x01
}
    357c:	df 91       	pop	r29
    357e:	cf 91       	pop	r28
    3580:	1f 91       	pop	r17
    3582:	0f 91       	pop	r16
    3584:	ff 90       	pop	r15
    3586:	ef 90       	pop	r14
    3588:	08 95       	ret

0000358a <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    358a:	1f 92       	push	r1
    358c:	0f 92       	push	r0
    358e:	0f b6       	in	r0, 0x3f	; 63
    3590:	0f 92       	push	r0
    3592:	11 24       	eor	r1, r1
    3594:	08 b6       	in	r0, 0x38	; 56
    3596:	0f 92       	push	r0
    3598:	18 be       	out	0x38, r1	; 56
    359a:	0b b6       	in	r0, 0x3b	; 59
    359c:	0f 92       	push	r0
    359e:	1b be       	out	0x3b, r1	; 59
    35a0:	2f 93       	push	r18
    35a2:	3f 93       	push	r19
    35a4:	8f 93       	push	r24
    35a6:	9f 93       	push	r25
    35a8:	ef 93       	push	r30
    35aa:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    35ac:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    35b0:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvC0_buffer>
    35b4:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvC0_buffer+0x1>
    35b8:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC0_write_index>
    35bc:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC0_write_index+0x1>
    35c0:	e8 0f       	add	r30, r24
    35c2:	f9 1f       	adc	r31, r25
    35c4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    35c6:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC0_write_index>
    35ca:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC0_write_index+0x1>
    35ce:	01 96       	adiw	r24, 0x01	; 1
    35d0:	84 36       	cpi	r24, 0x64	; 100
    35d2:	91 05       	cpc	r25, r1
    35d4:	60 f4       	brcc	.+24     	; 0x35ee <__vector_25+0x64>
    35d6:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvC0_write_index>
    35da:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    35de:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvC0_read_index>
    35e2:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvC0_read_index+0x1>
    35e6:	82 17       	cp	r24, r18
    35e8:	93 07       	cpc	r25, r19
    35ea:	f1 f4       	brne	.+60     	; 0x3628 <__vector_25+0x9e>
    35ec:	0c c0       	rjmp	.+24     	; 0x3606 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    35ee:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvC0_write_index>
    35f2:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    35f6:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvC0_read_index>
    35fa:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvC0_read_index+0x1>
    35fe:	18 16       	cp	r1, r24
    3600:	19 06       	cpc	r1, r25
    3602:	91 f4       	brne	.+36     	; 0x3628 <__vector_25+0x9e>
    3604:	0e c0       	rjmp	.+28     	; 0x3622 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3606:	01 96       	adiw	r24, 0x01	; 1
    3608:	84 36       	cpi	r24, 0x64	; 100
    360a:	91 05       	cpc	r25, r1
    360c:	28 f4       	brcc	.+10     	; 0x3618 <__vector_25+0x8e>
    360e:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvC0_read_index>
    3612:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvC0_read_index+0x1>
    3616:	08 c0       	rjmp	.+16     	; 0x3628 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3618:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvC0_read_index>
    361c:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvC0_read_index+0x1>
}
    3620:	03 c0       	rjmp	.+6      	; 0x3628 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3622:	81 e0       	ldi	r24, 0x01	; 1
    3624:	90 e0       	ldi	r25, 0x00	; 0
    3626:	f3 cf       	rjmp	.-26     	; 0x360e <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3628:	ff 91       	pop	r31
    362a:	ef 91       	pop	r30
    362c:	9f 91       	pop	r25
    362e:	8f 91       	pop	r24
    3630:	3f 91       	pop	r19
    3632:	2f 91       	pop	r18
    3634:	0f 90       	pop	r0
    3636:	0b be       	out	0x3b, r0	; 59
    3638:	0f 90       	pop	r0
    363a:	08 be       	out	0x38, r0	; 56
    363c:	0f 90       	pop	r0
    363e:	0f be       	out	0x3f, r0	; 63
    3640:	0f 90       	pop	r0
    3642:	1f 90       	pop	r1
    3644:	18 95       	reti

00003646 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3646:	1f 92       	push	r1
    3648:	0f 92       	push	r0
    364a:	0f b6       	in	r0, 0x3f	; 63
    364c:	0f 92       	push	r0
    364e:	11 24       	eor	r1, r1
    3650:	08 b6       	in	r0, 0x38	; 56
    3652:	0f 92       	push	r0
    3654:	18 be       	out	0x38, r1	; 56
    3656:	0b b6       	in	r0, 0x3b	; 59
    3658:	0f 92       	push	r0
    365a:	1b be       	out	0x3b, r1	; 59
    365c:	2f 93       	push	r18
    365e:	3f 93       	push	r19
    3660:	8f 93       	push	r24
    3662:	9f 93       	push	r25
    3664:	ef 93       	push	r30
    3666:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3668:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    366c:	e0 91 60 31 	lds	r30, 0x3160	; 0x803160 <rcvC1_buffer>
    3670:	f0 91 61 31 	lds	r31, 0x3161	; 0x803161 <rcvC1_buffer+0x1>
    3674:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvC1_write_index>
    3678:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvC1_write_index+0x1>
    367c:	e8 0f       	add	r30, r24
    367e:	f9 1f       	adc	r31, r25
    3680:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3682:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvC1_write_index>
    3686:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvC1_write_index+0x1>
    368a:	01 96       	adiw	r24, 0x01	; 1
    368c:	84 36       	cpi	r24, 0x64	; 100
    368e:	91 05       	cpc	r25, r1
    3690:	60 f4       	brcc	.+24     	; 0x36aa <__vector_28+0x64>
    3692:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvC1_write_index>
    3696:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    369a:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvC1_read_index>
    369e:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvC1_read_index+0x1>
    36a2:	82 17       	cp	r24, r18
    36a4:	93 07       	cpc	r25, r19
    36a6:	f1 f4       	brne	.+60     	; 0x36e4 <__vector_28+0x9e>
    36a8:	0c c0       	rjmp	.+24     	; 0x36c2 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    36aa:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvC1_write_index>
    36ae:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    36b2:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvC1_read_index>
    36b6:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvC1_read_index+0x1>
    36ba:	18 16       	cp	r1, r24
    36bc:	19 06       	cpc	r1, r25
    36be:	91 f4       	brne	.+36     	; 0x36e4 <__vector_28+0x9e>
    36c0:	0e c0       	rjmp	.+28     	; 0x36de <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    36c2:	01 96       	adiw	r24, 0x01	; 1
    36c4:	84 36       	cpi	r24, 0x64	; 100
    36c6:	91 05       	cpc	r25, r1
    36c8:	28 f4       	brcc	.+10     	; 0x36d4 <__vector_28+0x8e>
    36ca:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvC1_read_index>
    36ce:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvC1_read_index+0x1>
    36d2:	08 c0       	rjmp	.+16     	; 0x36e4 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    36d4:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvC1_read_index>
    36d8:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvC1_read_index+0x1>
}
    36dc:	03 c0       	rjmp	.+6      	; 0x36e4 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    36de:	81 e0       	ldi	r24, 0x01	; 1
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	f3 cf       	rjmp	.-26     	; 0x36ca <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    36e4:	ff 91       	pop	r31
    36e6:	ef 91       	pop	r30
    36e8:	9f 91       	pop	r25
    36ea:	8f 91       	pop	r24
    36ec:	3f 91       	pop	r19
    36ee:	2f 91       	pop	r18
    36f0:	0f 90       	pop	r0
    36f2:	0b be       	out	0x3b, r0	; 59
    36f4:	0f 90       	pop	r0
    36f6:	08 be       	out	0x38, r0	; 56
    36f8:	0f 90       	pop	r0
    36fa:	0f be       	out	0x3f, r0	; 63
    36fc:	0f 90       	pop	r0
    36fe:	1f 90       	pop	r1
    3700:	18 95       	reti

00003702 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3702:	1f 92       	push	r1
    3704:	0f 92       	push	r0
    3706:	0f b6       	in	r0, 0x3f	; 63
    3708:	0f 92       	push	r0
    370a:	11 24       	eor	r1, r1
    370c:	08 b6       	in	r0, 0x38	; 56
    370e:	0f 92       	push	r0
    3710:	18 be       	out	0x38, r1	; 56
    3712:	0b b6       	in	r0, 0x3b	; 59
    3714:	0f 92       	push	r0
    3716:	1b be       	out	0x3b, r1	; 59
    3718:	2f 93       	push	r18
    371a:	3f 93       	push	r19
    371c:	8f 93       	push	r24
    371e:	9f 93       	push	r25
    3720:	ef 93       	push	r30
    3722:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3724:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3728:	e0 91 5e 31 	lds	r30, 0x315E	; 0x80315e <rcvD0_buffer>
    372c:	f0 91 5f 31 	lds	r31, 0x315F	; 0x80315f <rcvD0_buffer+0x1>
    3730:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvC0_write_index>
    3734:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvC0_write_index+0x1>
    3738:	e8 0f       	add	r30, r24
    373a:	f9 1f       	adc	r31, r25
    373c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    373e:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <rcvD0_write_index>
    3742:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <rcvD0_write_index+0x1>
    3746:	01 96       	adiw	r24, 0x01	; 1
    3748:	84 36       	cpi	r24, 0x64	; 100
    374a:	91 05       	cpc	r25, r1
    374c:	60 f4       	brcc	.+24     	; 0x3766 <__vector_88+0x64>
    374e:	80 93 4a 31 	sts	0x314A, r24	; 0x80314a <rcvD0_write_index>
    3752:	90 93 4b 31 	sts	0x314B, r25	; 0x80314b <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3756:	20 91 54 31 	lds	r18, 0x3154	; 0x803154 <rcvD0_read_index>
    375a:	30 91 55 31 	lds	r19, 0x3155	; 0x803155 <rcvD0_read_index+0x1>
    375e:	82 17       	cp	r24, r18
    3760:	93 07       	cpc	r25, r19
    3762:	f1 f4       	brne	.+60     	; 0x37a0 <__vector_88+0x9e>
    3764:	0c c0       	rjmp	.+24     	; 0x377e <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3766:	10 92 4a 31 	sts	0x314A, r1	; 0x80314a <rcvD0_write_index>
    376a:	10 92 4b 31 	sts	0x314B, r1	; 0x80314b <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    376e:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvD0_read_index>
    3772:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvD0_read_index+0x1>
    3776:	18 16       	cp	r1, r24
    3778:	19 06       	cpc	r1, r25
    377a:	91 f4       	brne	.+36     	; 0x37a0 <__vector_88+0x9e>
    377c:	0e c0       	rjmp	.+28     	; 0x379a <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    377e:	01 96       	adiw	r24, 0x01	; 1
    3780:	84 36       	cpi	r24, 0x64	; 100
    3782:	91 05       	cpc	r25, r1
    3784:	28 f4       	brcc	.+10     	; 0x3790 <__vector_88+0x8e>
    3786:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvD0_read_index>
    378a:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvD0_read_index+0x1>
    378e:	08 c0       	rjmp	.+16     	; 0x37a0 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3790:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvD0_read_index>
    3794:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvD0_read_index+0x1>
}
    3798:	03 c0       	rjmp	.+6      	; 0x37a0 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    379a:	81 e0       	ldi	r24, 0x01	; 1
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	f3 cf       	rjmp	.-26     	; 0x3786 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    37a0:	ff 91       	pop	r31
    37a2:	ef 91       	pop	r30
    37a4:	9f 91       	pop	r25
    37a6:	8f 91       	pop	r24
    37a8:	3f 91       	pop	r19
    37aa:	2f 91       	pop	r18
    37ac:	0f 90       	pop	r0
    37ae:	0b be       	out	0x3b, r0	; 59
    37b0:	0f 90       	pop	r0
    37b2:	08 be       	out	0x38, r0	; 56
    37b4:	0f 90       	pop	r0
    37b6:	0f be       	out	0x3f, r0	; 63
    37b8:	0f 90       	pop	r0
    37ba:	1f 90       	pop	r1
    37bc:	18 95       	reti

000037be <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    37be:	1f 92       	push	r1
    37c0:	0f 92       	push	r0
    37c2:	0f b6       	in	r0, 0x3f	; 63
    37c4:	0f 92       	push	r0
    37c6:	11 24       	eor	r1, r1
    37c8:	08 b6       	in	r0, 0x38	; 56
    37ca:	0f 92       	push	r0
    37cc:	18 be       	out	0x38, r1	; 56
    37ce:	0b b6       	in	r0, 0x3b	; 59
    37d0:	0f 92       	push	r0
    37d2:	1b be       	out	0x3b, r1	; 59
    37d4:	2f 93       	push	r18
    37d6:	3f 93       	push	r19
    37d8:	8f 93       	push	r24
    37da:	9f 93       	push	r25
    37dc:	ef 93       	push	r30
    37de:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    37e0:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    37e4:	e0 91 5c 31 	lds	r30, 0x315C	; 0x80315c <rcvD1_buffer>
    37e8:	f0 91 5d 31 	lds	r31, 0x315D	; 0x80315d <rcvD1_buffer+0x1>
    37ec:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvD1_write_index>
    37f0:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvD1_write_index+0x1>
    37f4:	e8 0f       	add	r30, r24
    37f6:	f9 1f       	adc	r31, r25
    37f8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    37fa:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <rcvD1_write_index>
    37fe:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <rcvD1_write_index+0x1>
    3802:	01 96       	adiw	r24, 0x01	; 1
    3804:	84 36       	cpi	r24, 0x64	; 100
    3806:	91 05       	cpc	r25, r1
    3808:	60 f4       	brcc	.+24     	; 0x3822 <__vector_91+0x64>
    380a:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <rcvD1_write_index>
    380e:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3812:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <rcvD1_read_index>
    3816:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <rcvD1_read_index+0x1>
    381a:	82 17       	cp	r24, r18
    381c:	93 07       	cpc	r25, r19
    381e:	f1 f4       	brne	.+60     	; 0x385c <__vector_91+0x9e>
    3820:	0c c0       	rjmp	.+24     	; 0x383a <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3822:	10 92 48 31 	sts	0x3148, r1	; 0x803148 <rcvD1_write_index>
    3826:	10 92 49 31 	sts	0x3149, r1	; 0x803149 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    382a:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvD1_read_index>
    382e:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvD1_read_index+0x1>
    3832:	18 16       	cp	r1, r24
    3834:	19 06       	cpc	r1, r25
    3836:	91 f4       	brne	.+36     	; 0x385c <__vector_91+0x9e>
    3838:	0e c0       	rjmp	.+28     	; 0x3856 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    383a:	01 96       	adiw	r24, 0x01	; 1
    383c:	84 36       	cpi	r24, 0x64	; 100
    383e:	91 05       	cpc	r25, r1
    3840:	28 f4       	brcc	.+10     	; 0x384c <__vector_91+0x8e>
    3842:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvD1_read_index>
    3846:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvD1_read_index+0x1>
    384a:	08 c0       	rjmp	.+16     	; 0x385c <__vector_91+0x9e>
	rcvD1_read_index = 0;
    384c:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvD1_read_index>
    3850:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvD1_read_index+0x1>
}
    3854:	03 c0       	rjmp	.+6      	; 0x385c <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3856:	81 e0       	ldi	r24, 0x01	; 1
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	f3 cf       	rjmp	.-26     	; 0x3842 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    385c:	ff 91       	pop	r31
    385e:	ef 91       	pop	r30
    3860:	9f 91       	pop	r25
    3862:	8f 91       	pop	r24
    3864:	3f 91       	pop	r19
    3866:	2f 91       	pop	r18
    3868:	0f 90       	pop	r0
    386a:	0b be       	out	0x3b, r0	; 59
    386c:	0f 90       	pop	r0
    386e:	08 be       	out	0x38, r0	; 56
    3870:	0f 90       	pop	r0
    3872:	0f be       	out	0x3f, r0	; 63
    3874:	0f 90       	pop	r0
    3876:	1f 90       	pop	r1
    3878:	18 95       	reti

0000387a <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    387a:	1f 92       	push	r1
    387c:	0f 92       	push	r0
    387e:	0f b6       	in	r0, 0x3f	; 63
    3880:	0f 92       	push	r0
    3882:	11 24       	eor	r1, r1
    3884:	08 b6       	in	r0, 0x38	; 56
    3886:	0f 92       	push	r0
    3888:	18 be       	out	0x38, r1	; 56
    388a:	0b b6       	in	r0, 0x3b	; 59
    388c:	0f 92       	push	r0
    388e:	1b be       	out	0x3b, r1	; 59
    3890:	2f 93       	push	r18
    3892:	3f 93       	push	r19
    3894:	8f 93       	push	r24
    3896:	9f 93       	push	r25
    3898:	ef 93       	push	r30
    389a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    389c:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    38a0:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <rcvE0_buffer>
    38a4:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <rcvE0_buffer+0x1>
    38a8:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE0_write_index>
    38ac:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE0_write_index+0x1>
    38b0:	e8 0f       	add	r30, r24
    38b2:	f9 1f       	adc	r31, r25
    38b4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    38b6:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvE0_write_index>
    38ba:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvE0_write_index+0x1>
    38be:	01 96       	adiw	r24, 0x01	; 1
    38c0:	84 36       	cpi	r24, 0x64	; 100
    38c2:	91 05       	cpc	r25, r1
    38c4:	60 f4       	brcc	.+24     	; 0x38de <__vector_58+0x64>
    38c6:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvE0_write_index>
    38ca:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    38ce:	20 91 50 31 	lds	r18, 0x3150	; 0x803150 <rcvE0_read_index>
    38d2:	30 91 51 31 	lds	r19, 0x3151	; 0x803151 <rcvE0_read_index+0x1>
    38d6:	82 17       	cp	r24, r18
    38d8:	93 07       	cpc	r25, r19
    38da:	f1 f4       	brne	.+60     	; 0x3918 <__vector_58+0x9e>
    38dc:	0c c0       	rjmp	.+24     	; 0x38f6 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    38de:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvE0_write_index>
    38e2:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    38e6:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvE0_read_index>
    38ea:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvE0_read_index+0x1>
    38ee:	18 16       	cp	r1, r24
    38f0:	19 06       	cpc	r1, r25
    38f2:	91 f4       	brne	.+36     	; 0x3918 <__vector_58+0x9e>
    38f4:	0e c0       	rjmp	.+28     	; 0x3912 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    38f6:	01 96       	adiw	r24, 0x01	; 1
    38f8:	84 36       	cpi	r24, 0x64	; 100
    38fa:	91 05       	cpc	r25, r1
    38fc:	28 f4       	brcc	.+10     	; 0x3908 <__vector_58+0x8e>
    38fe:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvE0_read_index>
    3902:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvE0_read_index+0x1>
    3906:	08 c0       	rjmp	.+16     	; 0x3918 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3908:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvE0_read_index>
    390c:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvE0_read_index+0x1>
}
    3910:	03 c0       	rjmp	.+6      	; 0x3918 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3912:	81 e0       	ldi	r24, 0x01	; 1
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	f3 cf       	rjmp	.-26     	; 0x38fe <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3918:	ff 91       	pop	r31
    391a:	ef 91       	pop	r30
    391c:	9f 91       	pop	r25
    391e:	8f 91       	pop	r24
    3920:	3f 91       	pop	r19
    3922:	2f 91       	pop	r18
    3924:	0f 90       	pop	r0
    3926:	0b be       	out	0x3b, r0	; 59
    3928:	0f 90       	pop	r0
    392a:	08 be       	out	0x38, r0	; 56
    392c:	0f 90       	pop	r0
    392e:	0f be       	out	0x3f, r0	; 63
    3930:	0f 90       	pop	r0
    3932:	1f 90       	pop	r1
    3934:	18 95       	reti

00003936 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3936:	fc 01       	movw	r30, r24
    3938:	84 81       	ldd	r24, Z+4	; 0x04
    393a:	95 81       	ldd	r25, Z+5	; 0x05
    393c:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
		}
    3940:	90 e0       	ldi	r25, 0x00	; 0
    3942:	08 95       	ret

00003944 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3944:	fc 01       	movw	r30, r24
    3946:	84 81       	ldd	r24, Z+4	; 0x04
    3948:	95 81       	ldd	r25, Z+5	; 0x05
    394a:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
    394e:	91 e0       	ldi	r25, 0x01	; 1
    3950:	81 11       	cpse	r24, r1
    3952:	01 c0       	rjmp	.+2      	; 0x3956 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    3954:	90 e0       	ldi	r25, 0x00	; 0
		}
    3956:	89 2f       	mov	r24, r25
    3958:	08 95       	ret

0000395a <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    395a:	fc 01       	movw	r30, r24
    395c:	84 81       	ldd	r24, Z+4	; 0x04
    395e:	95 81       	ldd	r25, Z+5	; 0x05
    3960:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
    3964:	91 e0       	ldi	r25, 0x01	; 1
    3966:	81 11       	cpse	r24, r1
    3968:	90 e0       	ldi	r25, 0x00	; 0
		}
    396a:	89 2f       	mov	r24, r25
    396c:	08 95       	ret

0000396e <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    396e:	fc 01       	movw	r30, r24
    3970:	84 81       	ldd	r24, Z+4	; 0x04
    3972:	95 81       	ldd	r25, Z+5	; 0x05
    3974:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
		}
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	08 95       	ret

0000397c <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    397c:	fc 01       	movw	r30, r24
    397e:	84 81       	ldd	r24, Z+4	; 0x04
    3980:	95 81       	ldd	r25, Z+5	; 0x05
    3982:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
    3986:	91 e0       	ldi	r25, 0x01	; 1
    3988:	81 11       	cpse	r24, r1
    398a:	01 c0       	rjmp	.+2      	; 0x398e <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    398c:	90 e0       	ldi	r25, 0x00	; 0
		}
    398e:	89 2f       	mov	r24, r25
    3990:	08 95       	ret

00003992 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3992:	fc 01       	movw	r30, r24
    3994:	84 81       	ldd	r24, Z+4	; 0x04
    3996:	95 81       	ldd	r25, Z+5	; 0x05
    3998:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <uxQueueMessagesWaitingFromISR>
    399c:	91 e0       	ldi	r25, 0x01	; 1
    399e:	81 11       	cpse	r24, r1
    39a0:	90 e0       	ldi	r25, 0x00	; 0
		}
    39a2:	89 2f       	mov	r24, r25
    39a4:	08 95       	ret

000039a6 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    39a6:	fc 01       	movw	r30, r24
    39a8:	84 81       	ldd	r24, Z+4	; 0x04
    39aa:	95 81       	ldd	r25, Z+5	; 0x05
    39ac:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
		}
    39b0:	90 e0       	ldi	r25, 0x00	; 0
    39b2:	08 95       	ret

000039b4 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    39b4:	fc 01       	movw	r30, r24
    39b6:	84 81       	ldd	r24, Z+4	; 0x04
    39b8:	95 81       	ldd	r25, Z+5	; 0x05
    39ba:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
    39be:	91 e0       	ldi	r25, 0x01	; 1
    39c0:	81 11       	cpse	r24, r1
    39c2:	01 c0       	rjmp	.+2      	; 0x39c6 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    39c4:	90 e0       	ldi	r25, 0x00	; 0
		}
    39c6:	89 2f       	mov	r24, r25
    39c8:	08 95       	ret

000039ca <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    39ca:	fc 01       	movw	r30, r24
    39cc:	84 81       	ldd	r24, Z+4	; 0x04
    39ce:	95 81       	ldd	r25, Z+5	; 0x05
    39d0:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
    39d4:	91 e0       	ldi	r25, 0x01	; 1
    39d6:	81 11       	cpse	r24, r1
    39d8:	90 e0       	ldi	r25, 0x00	; 0
		}
    39da:	89 2f       	mov	r24, r25
    39dc:	08 95       	ret

000039de <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    39de:	fc 01       	movw	r30, r24
    39e0:	84 81       	ldd	r24, Z+4	; 0x04
    39e2:	95 81       	ldd	r25, Z+5	; 0x05
    39e4:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
		}
    39e8:	90 e0       	ldi	r25, 0x00	; 0
    39ea:	08 95       	ret

000039ec <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    39ec:	fc 01       	movw	r30, r24
    39ee:	84 81       	ldd	r24, Z+4	; 0x04
    39f0:	95 81       	ldd	r25, Z+5	; 0x05
    39f2:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
    39f6:	91 e0       	ldi	r25, 0x01	; 1
    39f8:	81 11       	cpse	r24, r1
    39fa:	01 c0       	rjmp	.+2      	; 0x39fe <_ZN9frt_queueIiE9not_emptyEv+0x12>
    39fc:	90 e0       	ldi	r25, 0x00	; 0
		}
    39fe:	89 2f       	mov	r24, r25
    3a00:	08 95       	ret

00003a02 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3a02:	fc 01       	movw	r30, r24
    3a04:	84 81       	ldd	r24, Z+4	; 0x04
    3a06:	95 81       	ldd	r25, Z+5	; 0x05
    3a08:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uxQueueMessagesWaiting>
    3a0c:	91 e0       	ldi	r25, 0x01	; 1
    3a0e:	81 11       	cpse	r24, r1
    3a10:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a12:	89 2f       	mov	r24, r25
    3a14:	08 95       	ret

00003a16 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3a16:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3a18:	01 e0       	ldi	r16, 0x01	; 1
    3a1a:	2f ef       	ldi	r18, 0xFF	; 255
    3a1c:	3f ef       	ldi	r19, 0xFF	; 255
    3a1e:	a9 01       	movw	r20, r18
    3a20:	fc 01       	movw	r30, r24
    3a22:	84 81       	ldd	r24, Z+4	; 0x04
    3a24:	95 81       	ldd	r25, Z+5	; 0x05
    3a26:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
}
    3a2a:	0f 91       	pop	r16
    3a2c:	08 95       	ret

00003a2e <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3a2e:	0f 93       	push	r16
    3a30:	cf 93       	push	r28
    3a32:	df 93       	push	r29
    3a34:	1f 92       	push	r1
    3a36:	1f 92       	push	r1
    3a38:	cd b7       	in	r28, 0x3d	; 61
    3a3a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3a3c:	01 e0       	ldi	r16, 0x01	; 1
    3a3e:	2f ef       	ldi	r18, 0xFF	; 255
    3a40:	3f ef       	ldi	r19, 0xFF	; 255
    3a42:	a9 01       	movw	r20, r18
    3a44:	be 01       	movw	r22, r28
    3a46:	6f 5f       	subi	r22, 0xFF	; 255
    3a48:	7f 4f       	sbci	r23, 0xFF	; 255
    3a4a:	fc 01       	movw	r30, r24
    3a4c:	84 81       	ldd	r24, Z+4	; 0x04
    3a4e:	95 81       	ldd	r25, Z+5	; 0x05
    3a50:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
	return (recv_item);
}
    3a54:	89 81       	ldd	r24, Y+1	; 0x01
    3a56:	9a 81       	ldd	r25, Y+2	; 0x02
    3a58:	0f 90       	pop	r0
    3a5a:	0f 90       	pop	r0
    3a5c:	df 91       	pop	r29
    3a5e:	cf 91       	pop	r28
    3a60:	0f 91       	pop	r16
    3a62:	08 95       	ret

00003a64 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3a64:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3a66:	00 e0       	ldi	r16, 0x00	; 0
    3a68:	2f ef       	ldi	r18, 0xFF	; 255
    3a6a:	3f ef       	ldi	r19, 0xFF	; 255
    3a6c:	a9 01       	movw	r20, r18
    3a6e:	fc 01       	movw	r30, r24
    3a70:	84 81       	ldd	r24, Z+4	; 0x04
    3a72:	95 81       	ldd	r25, Z+5	; 0x05
    3a74:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
}
    3a78:	0f 91       	pop	r16
    3a7a:	08 95       	ret

00003a7c <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3a7c:	0f 93       	push	r16
    3a7e:	cf 93       	push	r28
    3a80:	df 93       	push	r29
    3a82:	1f 92       	push	r1
    3a84:	1f 92       	push	r1
    3a86:	cd b7       	in	r28, 0x3d	; 61
    3a88:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3a8a:	00 e0       	ldi	r16, 0x00	; 0
    3a8c:	2f ef       	ldi	r18, 0xFF	; 255
    3a8e:	3f ef       	ldi	r19, 0xFF	; 255
    3a90:	a9 01       	movw	r20, r18
    3a92:	be 01       	movw	r22, r28
    3a94:	6f 5f       	subi	r22, 0xFF	; 255
    3a96:	7f 4f       	sbci	r23, 0xFF	; 255
    3a98:	fc 01       	movw	r30, r24
    3a9a:	84 81       	ldd	r24, Z+4	; 0x04
    3a9c:	95 81       	ldd	r25, Z+5	; 0x05
    3a9e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
	return (recv_item);
}
    3aa2:	89 81       	ldd	r24, Y+1	; 0x01
    3aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa6:	0f 90       	pop	r0
    3aa8:	0f 90       	pop	r0
    3aaa:	df 91       	pop	r29
    3aac:	cf 91       	pop	r28
    3aae:	0f 91       	pop	r16
    3ab0:	08 95       	ret

00003ab2 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3ab2:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3ab4:	01 e0       	ldi	r16, 0x01	; 1
    3ab6:	2f ef       	ldi	r18, 0xFF	; 255
    3ab8:	3f ef       	ldi	r19, 0xFF	; 255
    3aba:	a9 01       	movw	r20, r18
    3abc:	fc 01       	movw	r30, r24
    3abe:	84 81       	ldd	r24, Z+4	; 0x04
    3ac0:	95 81       	ldd	r25, Z+5	; 0x05
    3ac2:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
}
    3ac6:	0f 91       	pop	r16
    3ac8:	08 95       	ret

00003aca <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3aca:	0f 93       	push	r16
    3acc:	cf 93       	push	r28
    3ace:	df 93       	push	r29
    3ad0:	1f 92       	push	r1
    3ad2:	1f 92       	push	r1
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3ad8:	01 e0       	ldi	r16, 0x01	; 1
    3ada:	2f ef       	ldi	r18, 0xFF	; 255
    3adc:	3f ef       	ldi	r19, 0xFF	; 255
    3ade:	a9 01       	movw	r20, r18
    3ae0:	be 01       	movw	r22, r28
    3ae2:	6f 5f       	subi	r22, 0xFF	; 255
    3ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    3ae6:	fc 01       	movw	r30, r24
    3ae8:	84 81       	ldd	r24, Z+4	; 0x04
    3aea:	95 81       	ldd	r25, Z+5	; 0x05
    3aec:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
	return (recv_item);
}
    3af0:	89 81       	ldd	r24, Y+1	; 0x01
    3af2:	9a 81       	ldd	r25, Y+2	; 0x02
    3af4:	0f 90       	pop	r0
    3af6:	0f 90       	pop	r0
    3af8:	df 91       	pop	r29
    3afa:	cf 91       	pop	r28
    3afc:	0f 91       	pop	r16
    3afe:	08 95       	ret

00003b00 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3b00:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3b02:	00 e0       	ldi	r16, 0x00	; 0
    3b04:	2f ef       	ldi	r18, 0xFF	; 255
    3b06:	3f ef       	ldi	r19, 0xFF	; 255
    3b08:	a9 01       	movw	r20, r18
    3b0a:	fc 01       	movw	r30, r24
    3b0c:	84 81       	ldd	r24, Z+4	; 0x04
    3b0e:	95 81       	ldd	r25, Z+5	; 0x05
    3b10:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
}
    3b14:	0f 91       	pop	r16
    3b16:	08 95       	ret

00003b18 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3b18:	0f 93       	push	r16
    3b1a:	cf 93       	push	r28
    3b1c:	df 93       	push	r29
    3b1e:	1f 92       	push	r1
    3b20:	1f 92       	push	r1
    3b22:	cd b7       	in	r28, 0x3d	; 61
    3b24:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3b26:	00 e0       	ldi	r16, 0x00	; 0
    3b28:	2f ef       	ldi	r18, 0xFF	; 255
    3b2a:	3f ef       	ldi	r19, 0xFF	; 255
    3b2c:	a9 01       	movw	r20, r18
    3b2e:	be 01       	movw	r22, r28
    3b30:	6f 5f       	subi	r22, 0xFF	; 255
    3b32:	7f 4f       	sbci	r23, 0xFF	; 255
    3b34:	fc 01       	movw	r30, r24
    3b36:	84 81       	ldd	r24, Z+4	; 0x04
    3b38:	95 81       	ldd	r25, Z+5	; 0x05
    3b3a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <xQueueGenericReceive>
	return (recv_item);
}
    3b3e:	89 81       	ldd	r24, Y+1	; 0x01
    3b40:	9a 81       	ldd	r25, Y+2	; 0x02
    3b42:	0f 90       	pop	r0
    3b44:	0f 90       	pop	r0
    3b46:	df 91       	pop	r29
    3b48:	cf 91       	pop	r28
    3b4a:	0f 91       	pop	r16
    3b4c:	08 95       	ret

00003b4e <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3b4e:	cf 93       	push	r28
    3b50:	df 93       	push	r29
    3b52:	1f 92       	push	r1
    3b54:	cd b7       	in	r28, 0x3d	; 61
    3b56:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3b58:	ae 01       	movw	r20, r28
    3b5a:	4f 5f       	subi	r20, 0xFF	; 255
    3b5c:	5f 4f       	sbci	r21, 0xFF	; 255
    3b5e:	fc 01       	movw	r30, r24
    3b60:	84 81       	ldd	r24, Z+4	; 0x04
    3b62:	95 81       	ldd	r25, Z+5	; 0x05
    3b64:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <xQueueReceiveFromISR>
}
    3b68:	0f 90       	pop	r0
    3b6a:	df 91       	pop	r29
    3b6c:	cf 91       	pop	r28
    3b6e:	08 95       	ret

00003b70 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3b70:	cf 93       	push	r28
    3b72:	df 93       	push	r29
    3b74:	00 d0       	rcall	.+0      	; 0x3b76 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3b76:	cd b7       	in	r28, 0x3d	; 61
    3b78:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3b7a:	ae 01       	movw	r20, r28
    3b7c:	4d 5f       	subi	r20, 0xFD	; 253
    3b7e:	5f 4f       	sbci	r21, 0xFF	; 255
    3b80:	be 01       	movw	r22, r28
    3b82:	6f 5f       	subi	r22, 0xFF	; 255
    3b84:	7f 4f       	sbci	r23, 0xFF	; 255
    3b86:	fc 01       	movw	r30, r24
    3b88:	84 81       	ldd	r24, Z+4	; 0x04
    3b8a:	95 81       	ldd	r25, Z+5	; 0x05
    3b8c:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <xQueueReceiveFromISR>
	return (recv_item);
}
    3b90:	89 81       	ldd	r24, Y+1	; 0x01
    3b92:	9a 81       	ldd	r25, Y+2	; 0x02
    3b94:	23 96       	adiw	r28, 0x03	; 3
    3b96:	cd bf       	out	0x3d, r28	; 61
    3b98:	de bf       	out	0x3e, r29	; 62
    3b9a:	df 91       	pop	r29
    3b9c:	cf 91       	pop	r28
    3b9e:	08 95       	ret

00003ba0 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3ba0:	cf 93       	push	r28
    3ba2:	df 93       	push	r29
    3ba4:	1f 92       	push	r1
    3ba6:	cd b7       	in	r28, 0x3d	; 61
    3ba8:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3baa:	ae 01       	movw	r20, r28
    3bac:	4f 5f       	subi	r20, 0xFF	; 255
    3bae:	5f 4f       	sbci	r21, 0xFF	; 255
    3bb0:	fc 01       	movw	r30, r24
    3bb2:	84 81       	ldd	r24, Z+4	; 0x04
    3bb4:	95 81       	ldd	r25, Z+5	; 0x05
    3bb6:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <xQueueReceiveFromISR>
}
    3bba:	0f 90       	pop	r0
    3bbc:	df 91       	pop	r29
    3bbe:	cf 91       	pop	r28
    3bc0:	08 95       	ret

00003bc2 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3bc2:	cf 93       	push	r28
    3bc4:	df 93       	push	r29
    3bc6:	00 d0       	rcall	.+0      	; 0x3bc8 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3bc8:	cd b7       	in	r28, 0x3d	; 61
    3bca:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3bcc:	ae 01       	movw	r20, r28
    3bce:	4d 5f       	subi	r20, 0xFD	; 253
    3bd0:	5f 4f       	sbci	r21, 0xFF	; 255
    3bd2:	be 01       	movw	r22, r28
    3bd4:	6f 5f       	subi	r22, 0xFF	; 255
    3bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3bd8:	fc 01       	movw	r30, r24
    3bda:	84 81       	ldd	r24, Z+4	; 0x04
    3bdc:	95 81       	ldd	r25, Z+5	; 0x05
    3bde:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <xQueueReceiveFromISR>
	return (recv_item);
}
    3be2:	89 81       	ldd	r24, Y+1	; 0x01
    3be4:	9a 81       	ldd	r25, Y+2	; 0x02
    3be6:	23 96       	adiw	r28, 0x03	; 3
    3be8:	cd bf       	out	0x3d, r28	; 61
    3bea:	de bf       	out	0x3e, r29	; 62
    3bec:	df 91       	pop	r29
    3bee:	cf 91       	pop	r28
    3bf0:	08 95       	ret

00003bf2 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3bf2:	cf 93       	push	r28
    3bf4:	df 93       	push	r29
    3bf6:	1f 92       	push	r1
    3bf8:	cd b7       	in	r28, 0x3d	; 61
    3bfa:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3bfc:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3bfe:	21 e0       	ldi	r18, 0x01	; 1
    3c00:	ae 01       	movw	r20, r28
    3c02:	4f 5f       	subi	r20, 0xFF	; 255
    3c04:	5f 4f       	sbci	r21, 0xFF	; 255
    3c06:	fc 01       	movw	r30, r24
    3c08:	84 81       	ldd	r24, Z+4	; 0x04
    3c0a:	95 81       	ldd	r25, Z+5	; 0x05
    3c0c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c10:	91 e0       	ldi	r25, 0x01	; 1
    3c12:	81 11       	cpse	r24, r1
    3c14:	01 c0       	rjmp	.+2      	; 0x3c18 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3c16:	90 e0       	ldi	r25, 0x00	; 0
}
    3c18:	89 2f       	mov	r24, r25
    3c1a:	0f 90       	pop	r0
    3c1c:	df 91       	pop	r29
    3c1e:	cf 91       	pop	r28
    3c20:	08 95       	ret

00003c22 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3c22:	cf 93       	push	r28
    3c24:	df 93       	push	r29
    3c26:	1f 92       	push	r1
    3c28:	cd b7       	in	r28, 0x3d	; 61
    3c2a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c2c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3c2e:	20 e0       	ldi	r18, 0x00	; 0
    3c30:	ae 01       	movw	r20, r28
    3c32:	4f 5f       	subi	r20, 0xFF	; 255
    3c34:	5f 4f       	sbci	r21, 0xFF	; 255
    3c36:	fc 01       	movw	r30, r24
    3c38:	84 81       	ldd	r24, Z+4	; 0x04
    3c3a:	95 81       	ldd	r25, Z+5	; 0x05
    3c3c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c40:	91 e0       	ldi	r25, 0x01	; 1
    3c42:	81 11       	cpse	r24, r1
    3c44:	01 c0       	rjmp	.+2      	; 0x3c48 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3c46:	90 e0       	ldi	r25, 0x00	; 0
}
    3c48:	89 2f       	mov	r24, r25
    3c4a:	0f 90       	pop	r0
    3c4c:	df 91       	pop	r29
    3c4e:	cf 91       	pop	r28
    3c50:	08 95       	ret

00003c52 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3c52:	cf 93       	push	r28
    3c54:	df 93       	push	r29
    3c56:	1f 92       	push	r1
    3c58:	cd b7       	in	r28, 0x3d	; 61
    3c5a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c5c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3c5e:	21 e0       	ldi	r18, 0x01	; 1
    3c60:	ae 01       	movw	r20, r28
    3c62:	4f 5f       	subi	r20, 0xFF	; 255
    3c64:	5f 4f       	sbci	r21, 0xFF	; 255
    3c66:	fc 01       	movw	r30, r24
    3c68:	84 81       	ldd	r24, Z+4	; 0x04
    3c6a:	95 81       	ldd	r25, Z+5	; 0x05
    3c6c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c70:	91 e0       	ldi	r25, 0x01	; 1
    3c72:	81 11       	cpse	r24, r1
    3c74:	01 c0       	rjmp	.+2      	; 0x3c78 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3c76:	90 e0       	ldi	r25, 0x00	; 0
}
    3c78:	89 2f       	mov	r24, r25
    3c7a:	0f 90       	pop	r0
    3c7c:	df 91       	pop	r29
    3c7e:	cf 91       	pop	r28
    3c80:	08 95       	ret

00003c82 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3c82:	cf 93       	push	r28
    3c84:	df 93       	push	r29
    3c86:	1f 92       	push	r1
    3c88:	cd b7       	in	r28, 0x3d	; 61
    3c8a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c8c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3c8e:	20 e0       	ldi	r18, 0x00	; 0
    3c90:	ae 01       	movw	r20, r28
    3c92:	4f 5f       	subi	r20, 0xFF	; 255
    3c94:	5f 4f       	sbci	r21, 0xFF	; 255
    3c96:	fc 01       	movw	r30, r24
    3c98:	84 81       	ldd	r24, Z+4	; 0x04
    3c9a:	95 81       	ldd	r25, Z+5	; 0x05
    3c9c:	0e 94 a8 0c 	call	0x1950	; 0x1950 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ca0:	91 e0       	ldi	r25, 0x01	; 1
    3ca2:	81 11       	cpse	r24, r1
    3ca4:	01 c0       	rjmp	.+2      	; 0x3ca8 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3ca6:	90 e0       	ldi	r25, 0x00	; 0
}
    3ca8:	89 2f       	mov	r24, r25
    3caa:	0f 90       	pop	r0
    3cac:	df 91       	pop	r29
    3cae:	cf 91       	pop	r28
    3cb0:	08 95       	ret

00003cb2 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3cb2:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	26 81       	ldd	r18, Z+6	; 0x06
    3cb8:	37 81       	ldd	r19, Z+7	; 0x07
    3cba:	40 85       	ldd	r20, Z+8	; 0x08
    3cbc:	51 85       	ldd	r21, Z+9	; 0x09
    3cbe:	01 e0       	ldi	r16, 0x01	; 1
    3cc0:	84 81       	ldd	r24, Z+4	; 0x04
    3cc2:	95 81       	ldd	r25, Z+5	; 0x05
    3cc4:	0e 94 0d 0c 	call	0x181a	; 0x181a <xQueueGenericSend>
    3cc8:	91 e0       	ldi	r25, 0x01	; 1
    3cca:	81 11       	cpse	r24, r1
    3ccc:	01 c0       	rjmp	.+2      	; 0x3cd0 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3cce:	90 e0       	ldi	r25, 0x00	; 0
		}
    3cd0:	89 2f       	mov	r24, r25
    3cd2:	0f 91       	pop	r16
    3cd4:	08 95       	ret

00003cd6 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3cd6:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3cd8:	fc 01       	movw	r30, r24
    3cda:	26 81       	ldd	r18, Z+6	; 0x06
    3cdc:	37 81       	ldd	r19, Z+7	; 0x07
    3cde:	40 85       	ldd	r20, Z+8	; 0x08
    3ce0:	51 85       	ldd	r21, Z+9	; 0x09
    3ce2:	00 e0       	ldi	r16, 0x00	; 0
    3ce4:	84 81       	ldd	r24, Z+4	; 0x04
    3ce6:	95 81       	ldd	r25, Z+5	; 0x05
    3ce8:	0e 94 0d 0c 	call	0x181a	; 0x181a <xQueueGenericSend>
    3cec:	91 e0       	ldi	r25, 0x01	; 1
    3cee:	81 11       	cpse	r24, r1
    3cf0:	01 c0       	rjmp	.+2      	; 0x3cf4 <_ZN9frt_queueIjE3putERKj+0x1e>
    3cf2:	90 e0       	ldi	r25, 0x00	; 0
		}
    3cf4:	89 2f       	mov	r24, r25
    3cf6:	0f 91       	pop	r16
    3cf8:	08 95       	ret

00003cfa <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3cfa:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3cfc:	fc 01       	movw	r30, r24
    3cfe:	26 81       	ldd	r18, Z+6	; 0x06
    3d00:	37 81       	ldd	r19, Z+7	; 0x07
    3d02:	40 85       	ldd	r20, Z+8	; 0x08
    3d04:	51 85       	ldd	r21, Z+9	; 0x09
    3d06:	01 e0       	ldi	r16, 0x01	; 1
    3d08:	84 81       	ldd	r24, Z+4	; 0x04
    3d0a:	95 81       	ldd	r25, Z+5	; 0x05
    3d0c:	0e 94 0d 0c 	call	0x181a	; 0x181a <xQueueGenericSend>
    3d10:	91 e0       	ldi	r25, 0x01	; 1
    3d12:	81 11       	cpse	r24, r1
    3d14:	01 c0       	rjmp	.+2      	; 0x3d18 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3d16:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d18:	89 2f       	mov	r24, r25
    3d1a:	0f 91       	pop	r16
    3d1c:	08 95       	ret

00003d1e <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3d1e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3d20:	fc 01       	movw	r30, r24
    3d22:	26 81       	ldd	r18, Z+6	; 0x06
    3d24:	37 81       	ldd	r19, Z+7	; 0x07
    3d26:	40 85       	ldd	r20, Z+8	; 0x08
    3d28:	51 85       	ldd	r21, Z+9	; 0x09
    3d2a:	00 e0       	ldi	r16, 0x00	; 0
    3d2c:	84 81       	ldd	r24, Z+4	; 0x04
    3d2e:	95 81       	ldd	r25, Z+5	; 0x05
    3d30:	0e 94 0d 0c 	call	0x181a	; 0x181a <xQueueGenericSend>
    3d34:	91 e0       	ldi	r25, 0x01	; 1
    3d36:	81 11       	cpse	r24, r1
    3d38:	01 c0       	rjmp	.+2      	; 0x3d3c <_ZN9frt_queueIiE3putERKi+0x1e>
    3d3a:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d3c:	89 2f       	mov	r24, r25
    3d3e:	0f 91       	pop	r16
    3d40:	08 95       	ret

00003d42 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d42:	0f 93       	push	r16
    3d44:	cf 93       	push	r28
    3d46:	df 93       	push	r29
    3d48:	1f 92       	push	r1
    3d4a:	cd b7       	in	r28, 0x3d	; 61
    3d4c:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3d4e:	2f b7       	in	r18, 0x3f	; 63
    3d50:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3d52:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3d54:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3d56:	fc 01       	movw	r30, r24
    3d58:	08 ed       	ldi	r16, 0xD8	; 216
    3d5a:	04 bf       	out	0x34, r16	; 52
    3d5c:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3d5e:	89 81       	ldd	r24, Y+1	; 0x01
    3d60:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3d62:	0f 90       	pop	r0
    3d64:	df 91       	pop	r29
    3d66:	cf 91       	pop	r28
    3d68:	0f 91       	pop	r16
    3d6a:	08 95       	ret

00003d6c <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3d6c:	ef 92       	push	r14
    3d6e:	ff 92       	push	r15
    3d70:	0f 93       	push	r16
    3d72:	1f 93       	push	r17
    3d74:	cf 93       	push	r28
    3d76:	df 93       	push	r29
    3d78:	cd b7       	in	r28, 0x3d	; 61
    3d7a:	de b7       	in	r29, 0x3e	; 62
    3d7c:	ed 97       	sbiw	r28, 0x3d	; 61
    3d7e:	cd bf       	out	0x3d, r28	; 61
    3d80:	de bf       	out	0x3e, r29	; 62
	cli();
    3d82:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3d84:	e0 e5       	ldi	r30, 0x50	; 80
    3d86:	f0 e0       	ldi	r31, 0x00	; 0
    3d88:	80 81       	ld	r24, Z
    3d8a:	82 60       	ori	r24, 0x02	; 2
    3d8c:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3d8e:	81 81       	ldd	r24, Z+1	; 0x01
    3d90:	81 ff       	sbrs	r24, 1
    3d92:	fd cf       	rjmp	.-6      	; 0x3d8e <main+0x22>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3d94:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3d98:	68 7f       	andi	r22, 0xF8	; 248
    3d9a:	61 60       	ori	r22, 0x01	; 1
    3d9c:	80 e4       	ldi	r24, 0x40	; 64
    3d9e:	90 e0       	ldi	r25, 0x00	; 0
    3da0:	0e 94 a1 1e 	call	0x3d42	; 0x3d42 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3da4:	e0 e5       	ldi	r30, 0x50	; 80
    3da6:	f0 e0       	ldi	r31, 0x00	; 0
    3da8:	80 81       	ld	r24, Z
    3daa:	8e 7f       	andi	r24, 0xFE	; 254
    3dac:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3dae:	9d ef       	ldi	r25, 0xFD	; 253
    3db0:	88 ed       	ldi	r24, 0xD8	; 216
    3db2:	08 b6       	in	r0, 0x38	; 56
    3db4:	18 be       	out	0x38, r1	; 56
    3db6:	84 bf       	out	0x34, r24	; 52
    3db8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3dbc:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3dbe:	40 ea       	ldi	r20, 0xA0	; 160
    3dc0:	5a e0       	ldi	r21, 0x0A	; 10
    3dc2:	60 e0       	ldi	r22, 0x00	; 0
    3dc4:	70 e0       	ldi	r23, 0x00	; 0
    3dc6:	ce 01       	movw	r24, r28
    3dc8:	01 96       	adiw	r24, 0x01	; 1
    3dca:	0e 94 45 1a 	call	0x348a	; 0x348a <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3dce:	67 e0       	ldi	r22, 0x07	; 7
    3dd0:	ce 01       	movw	r24, r28
    3dd2:	01 96       	adiw	r24, 0x01	; 1
    3dd4:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    3dd8:	8c 01       	movw	r16, r24
    3dda:	65 e6       	ldi	r22, 0x65	; 101
    3ddc:	70 e2       	ldi	r23, 0x20	; 32
    3dde:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <_ZN8emstream4putsEPKc>
    3de2:	66 e0       	ldi	r22, 0x06	; 6
    3de4:	c8 01       	movw	r24, r16
    3de6:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
    3dea:	66 e0       	ldi	r22, 0x06	; 6
    3dec:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c (&TWIE, 62000);
    3df0:	20 e3       	ldi	r18, 0x30	; 48
    3df2:	32 ef       	ldi	r19, 0xF2	; 242
    3df4:	40 e0       	ldi	r20, 0x00	; 0
    3df6:	50 e0       	ldi	r21, 0x00	; 0
    3df8:	60 ea       	ldi	r22, 0xA0	; 160
    3dfa:	74 e0       	ldi	r23, 0x04	; 4
    3dfc:	ce 01       	movw	r24, r28
    3dfe:	4e 96       	adiw	r24, 0x1e	; 30
    3e00:	0e 94 b8 03 	call	0x770	; 0x770 <_ZN9I2CMasterC1EP10TWI_structm>
	
	MB1202 mb1202 (&i2c);
    3e04:	be 01       	movw	r22, r28
    3e06:	62 5e       	subi	r22, 0xE2	; 226
    3e08:	7f 4f       	sbci	r23, 0xFF	; 255
    3e0a:	ce 01       	movw	r24, r28
    3e0c:	c3 96       	adiw	r24, 0x33	; 51
    3e0e:	0e 94 ef 04 	call	0x9de	; 0x9de <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3e12:	82 e1       	ldi	r24, 0x12	; 18
    3e14:	90 e0       	ldi	r25, 0x00	; 0
    3e16:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
    3e1a:	8e 01       	movw	r16, r28
    3e1c:	0f 5f       	subi	r16, 0xFF	; 255
    3e1e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e20:	20 e8       	ldi	r18, 0x80	; 128
    3e22:	30 e0       	ldi	r19, 0x00	; 0
    3e24:	40 e0       	ldi	r20, 0x00	; 0
    3e26:	64 e8       	ldi	r22, 0x84	; 132
    3e28:	70 e2       	ldi	r23, 0x20	; 32
    3e2a:	0e 94 89 05 	call	0xb12	; 0xb12 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    3e2e:	88 e1       	ldi	r24, 0x18	; 24
    3e30:	90 e0       	ldi	r25, 0x00	; 0
    3e32:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_Znwj>
    3e36:	9e 01       	movw	r18, r28
    3e38:	2d 5c       	subi	r18, 0xCD	; 205
    3e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e3c:	79 01       	movw	r14, r18
    3e3e:	20 e8       	ldi	r18, 0x80	; 128
    3e40:	30 e0       	ldi	r19, 0x00	; 0
    3e42:	42 e0       	ldi	r20, 0x02	; 2
    3e44:	6c e8       	ldi	r22, 0x8C	; 140
    3e46:	70 e2       	ldi	r23, 0x20	; 32
    3e48:	0e 94 6c 05 	call	0xad8	; 0xad8 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e4c:	87 e0       	ldi	r24, 0x07	; 7
    3e4e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3e52:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3e54:	0e 94 36 0f 	call	0x1e6c	; 0x1e6c <vTaskStartScheduler>
}
    3e58:	80 e0       	ldi	r24, 0x00	; 0
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	ed 96       	adiw	r28, 0x3d	; 61
    3e5e:	cd bf       	out	0x3d, r28	; 61
    3e60:	de bf       	out	0x3e, r29	; 62
    3e62:	df 91       	pop	r29
    3e64:	cf 91       	pop	r28
    3e66:	1f 91       	pop	r17
    3e68:	0f 91       	pop	r16
    3e6a:	ff 90       	pop	r15
    3e6c:	ef 90       	pop	r14
    3e6e:	08 95       	ret

00003e70 <_GLOBAL__sub_I_counter>:
    3e70:	cf 92       	push	r12
    3e72:	df 92       	push	r13
    3e74:	ef 92       	push	r14
    3e76:	ff 92       	push	r15
    3e78:	0f 93       	push	r16
    3e7a:	1f 93       	push	r17
    3e7c:	cf 93       	push	r28
    3e7e:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3e80:	0a e0       	ldi	r16, 0x0A	; 10
    3e82:	10 e0       	ldi	r17, 0x00	; 0
    3e84:	20 e0       	ldi	r18, 0x00	; 0
    3e86:	30 e0       	ldi	r19, 0x00	; 0
    3e88:	40 e0       	ldi	r20, 0x00	; 0
    3e8a:	50 e0       	ldi	r21, 0x00	; 0
    3e8c:	60 e2       	ldi	r22, 0x20	; 32
    3e8e:	70 e0       	ldi	r23, 0x00	; 0
    3e90:	86 e9       	ldi	r24, 0x96	; 150
    3e92:	91 e3       	ldi	r25, 0x31	; 49
    3e94:	0e 94 23 16 	call	0x2c46	; 0x2c46 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3e98:	cc e8       	ldi	r28, 0x8C	; 140
    3e9a:	d1 e3       	ldi	r29, 0x31	; 49
    3e9c:	1a 82       	std	Y+2, r1	; 0x02
    3e9e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3ea0:	86 e9       	ldi	r24, 0x96	; 150
    3ea2:	90 e2       	ldi	r25, 0x20	; 32
    3ea4:	88 83       	st	Y, r24
    3ea6:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3ea8:	40 e0       	ldi	r20, 0x00	; 0
    3eaa:	62 e0       	ldi	r22, 0x02	; 2
    3eac:	8f ef       	ldi	r24, 0xFF	; 255
    3eae:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    3eb2:	8c 83       	std	Y+4, r24	; 0x04
    3eb4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3eb6:	0f 2e       	mov	r0, r31
    3eb8:	fa e0       	ldi	r31, 0x0A	; 10
    3eba:	cf 2e       	mov	r12, r31
    3ebc:	d1 2c       	mov	r13, r1
    3ebe:	e1 2c       	mov	r14, r1
    3ec0:	f1 2c       	mov	r15, r1
    3ec2:	f0 2d       	mov	r31, r0
    3ec4:	ce 82       	std	Y+6, r12	; 0x06
    3ec6:	df 82       	std	Y+7, r13	; 0x07
    3ec8:	e8 86       	std	Y+8, r14	; 0x08
    3eca:	f9 86       	std	Y+9, r15	; 0x09
    3ecc:	c2 e8       	ldi	r28, 0x82	; 130
    3ece:	d1 e3       	ldi	r29, 0x31	; 49
    3ed0:	1a 82       	std	Y+2, r1	; 0x02
    3ed2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3ed4:	0a eb       	ldi	r16, 0xBA	; 186
    3ed6:	10 e2       	ldi	r17, 0x20	; 32
    3ed8:	08 83       	st	Y, r16
    3eda:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3edc:	40 e0       	ldi	r20, 0x00	; 0
    3ede:	62 e0       	ldi	r22, 0x02	; 2
    3ee0:	8f ef       	ldi	r24, 0xFF	; 255
    3ee2:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    3ee6:	8c 83       	std	Y+4, r24	; 0x04
    3ee8:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3eea:	ce 82       	std	Y+6, r12	; 0x06
    3eec:	df 82       	std	Y+7, r13	; 0x07
    3eee:	e8 86       	std	Y+8, r14	; 0x08
    3ef0:	f9 86       	std	Y+9, r15	; 0x09
    3ef2:	c8 e7       	ldi	r28, 0x78	; 120
    3ef4:	d1 e3       	ldi	r29, 0x31	; 49
    3ef6:	1a 82       	std	Y+2, r1	; 0x02
    3ef8:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3efa:	08 83       	st	Y, r16
    3efc:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3efe:	40 e0       	ldi	r20, 0x00	; 0
    3f00:	62 e0       	ldi	r22, 0x02	; 2
    3f02:	8f ef       	ldi	r24, 0xFF	; 255
    3f04:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    3f08:	8c 83       	std	Y+4, r24	; 0x04
    3f0a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f0c:	ce 82       	std	Y+6, r12	; 0x06
    3f0e:	df 82       	std	Y+7, r13	; 0x07
    3f10:	e8 86       	std	Y+8, r14	; 0x08
    3f12:	f9 86       	std	Y+9, r15	; 0x09
    3f14:	ce e6       	ldi	r28, 0x6E	; 110
    3f16:	d1 e3       	ldi	r29, 0x31	; 49
    3f18:	1a 82       	std	Y+2, r1	; 0x02
    3f1a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f1c:	08 83       	st	Y, r16
    3f1e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f20:	40 e0       	ldi	r20, 0x00	; 0
    3f22:	62 e0       	ldi	r22, 0x02	; 2
    3f24:	8f ef       	ldi	r24, 0xFF	; 255
    3f26:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    3f2a:	8c 83       	std	Y+4, r24	; 0x04
    3f2c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f2e:	ce 82       	std	Y+6, r12	; 0x06
    3f30:	df 82       	std	Y+7, r13	; 0x07
    3f32:	e8 86       	std	Y+8, r14	; 0x08
    3f34:	f9 86       	std	Y+9, r15	; 0x09
    3f36:	c4 e6       	ldi	r28, 0x64	; 100
    3f38:	d1 e3       	ldi	r29, 0x31	; 49
    3f3a:	1a 82       	std	Y+2, r1	; 0x02
    3f3c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f3e:	08 83       	st	Y, r16
    3f40:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f42:	40 e0       	ldi	r20, 0x00	; 0
    3f44:	62 e0       	ldi	r22, 0x02	; 2
    3f46:	8f ef       	ldi	r24, 0xFF	; 255
    3f48:	0e 94 df 0b 	call	0x17be	; 0x17be <xQueueGenericCreate>
    3f4c:	8c 83       	std	Y+4, r24	; 0x04
    3f4e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f50:	ce 82       	std	Y+6, r12	; 0x06
    3f52:	df 82       	std	Y+7, r13	; 0x07
    3f54:	e8 86       	std	Y+8, r14	; 0x08
    3f56:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3f58:	df 91       	pop	r29
    3f5a:	cf 91       	pop	r28
    3f5c:	1f 91       	pop	r17
    3f5e:	0f 91       	pop	r16
    3f60:	ff 90       	pop	r15
    3f62:	ef 90       	pop	r14
    3f64:	df 90       	pop	r13
    3f66:	cf 90       	pop	r12
    3f68:	08 95       	ret

00003f6a <__mulsi3>:
    3f6a:	db 01       	movw	r26, r22
    3f6c:	8f 93       	push	r24
    3f6e:	9f 93       	push	r25
    3f70:	0e 94 0f 20 	call	0x401e	; 0x401e <__muluhisi3>
    3f74:	bf 91       	pop	r27
    3f76:	af 91       	pop	r26
    3f78:	a2 9f       	mul	r26, r18
    3f7a:	80 0d       	add	r24, r0
    3f7c:	91 1d       	adc	r25, r1
    3f7e:	a3 9f       	mul	r26, r19
    3f80:	90 0d       	add	r25, r0
    3f82:	b2 9f       	mul	r27, r18
    3f84:	90 0d       	add	r25, r0
    3f86:	11 24       	eor	r1, r1
    3f88:	08 95       	ret

00003f8a <__udivmodsi4>:
    3f8a:	a1 e2       	ldi	r26, 0x21	; 33
    3f8c:	1a 2e       	mov	r1, r26
    3f8e:	aa 1b       	sub	r26, r26
    3f90:	bb 1b       	sub	r27, r27
    3f92:	fd 01       	movw	r30, r26
    3f94:	0d c0       	rjmp	.+26     	; 0x3fb0 <__udivmodsi4_ep>

00003f96 <__udivmodsi4_loop>:
    3f96:	aa 1f       	adc	r26, r26
    3f98:	bb 1f       	adc	r27, r27
    3f9a:	ee 1f       	adc	r30, r30
    3f9c:	ff 1f       	adc	r31, r31
    3f9e:	a2 17       	cp	r26, r18
    3fa0:	b3 07       	cpc	r27, r19
    3fa2:	e4 07       	cpc	r30, r20
    3fa4:	f5 07       	cpc	r31, r21
    3fa6:	20 f0       	brcs	.+8      	; 0x3fb0 <__udivmodsi4_ep>
    3fa8:	a2 1b       	sub	r26, r18
    3faa:	b3 0b       	sbc	r27, r19
    3fac:	e4 0b       	sbc	r30, r20
    3fae:	f5 0b       	sbc	r31, r21

00003fb0 <__udivmodsi4_ep>:
    3fb0:	66 1f       	adc	r22, r22
    3fb2:	77 1f       	adc	r23, r23
    3fb4:	88 1f       	adc	r24, r24
    3fb6:	99 1f       	adc	r25, r25
    3fb8:	1a 94       	dec	r1
    3fba:	69 f7       	brne	.-38     	; 0x3f96 <__udivmodsi4_loop>
    3fbc:	60 95       	com	r22
    3fbe:	70 95       	com	r23
    3fc0:	80 95       	com	r24
    3fc2:	90 95       	com	r25
    3fc4:	9b 01       	movw	r18, r22
    3fc6:	ac 01       	movw	r20, r24
    3fc8:	bd 01       	movw	r22, r26
    3fca:	cf 01       	movw	r24, r30
    3fcc:	08 95       	ret

00003fce <__divmodsi4>:
    3fce:	05 2e       	mov	r0, r21
    3fd0:	97 fb       	bst	r25, 7
    3fd2:	1e f4       	brtc	.+6      	; 0x3fda <__divmodsi4+0xc>
    3fd4:	00 94       	com	r0
    3fd6:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <__negsi2>
    3fda:	57 fd       	sbrc	r21, 7
    3fdc:	07 d0       	rcall	.+14     	; 0x3fec <__divmodsi4_neg2>
    3fde:	0e 94 c5 1f 	call	0x3f8a	; 0x3f8a <__udivmodsi4>
    3fe2:	07 fc       	sbrc	r0, 7
    3fe4:	03 d0       	rcall	.+6      	; 0x3fec <__divmodsi4_neg2>
    3fe6:	4e f4       	brtc	.+18     	; 0x3ffa <__divmodsi4_exit>
    3fe8:	0c 94 fe 1f 	jmp	0x3ffc	; 0x3ffc <__negsi2>

00003fec <__divmodsi4_neg2>:
    3fec:	50 95       	com	r21
    3fee:	40 95       	com	r20
    3ff0:	30 95       	com	r19
    3ff2:	21 95       	neg	r18
    3ff4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ff6:	4f 4f       	sbci	r20, 0xFF	; 255
    3ff8:	5f 4f       	sbci	r21, 0xFF	; 255

00003ffa <__divmodsi4_exit>:
    3ffa:	08 95       	ret

00003ffc <__negsi2>:
    3ffc:	90 95       	com	r25
    3ffe:	80 95       	com	r24
    4000:	70 95       	com	r23
    4002:	61 95       	neg	r22
    4004:	7f 4f       	sbci	r23, 0xFF	; 255
    4006:	8f 4f       	sbci	r24, 0xFF	; 255
    4008:	9f 4f       	sbci	r25, 0xFF	; 255
    400a:	08 95       	ret

0000400c <__tablejump2__>:
    400c:	ee 0f       	add	r30, r30
    400e:	ff 1f       	adc	r31, r31
    4010:	88 1f       	adc	r24, r24
    4012:	8b bf       	out	0x3b, r24	; 59
    4014:	07 90       	elpm	r0, Z+
    4016:	f6 91       	elpm	r31, Z
    4018:	e0 2d       	mov	r30, r0
    401a:	1b be       	out	0x3b, r1	; 59
    401c:	19 94       	eijmp

0000401e <__muluhisi3>:
    401e:	0e 94 1a 20 	call	0x4034	; 0x4034 <__umulhisi3>
    4022:	a5 9f       	mul	r26, r21
    4024:	90 0d       	add	r25, r0
    4026:	b4 9f       	mul	r27, r20
    4028:	90 0d       	add	r25, r0
    402a:	a4 9f       	mul	r26, r20
    402c:	80 0d       	add	r24, r0
    402e:	91 1d       	adc	r25, r1
    4030:	11 24       	eor	r1, r1
    4032:	08 95       	ret

00004034 <__umulhisi3>:
    4034:	a2 9f       	mul	r26, r18
    4036:	b0 01       	movw	r22, r0
    4038:	b3 9f       	mul	r27, r19
    403a:	c0 01       	movw	r24, r0
    403c:	a3 9f       	mul	r26, r19
    403e:	70 0d       	add	r23, r0
    4040:	81 1d       	adc	r24, r1
    4042:	11 24       	eor	r1, r1
    4044:	91 1d       	adc	r25, r1
    4046:	b2 9f       	mul	r27, r18
    4048:	70 0d       	add	r23, r0
    404a:	81 1d       	adc	r24, r1
    404c:	11 24       	eor	r1, r1
    404e:	91 1d       	adc	r25, r1
    4050:	08 95       	ret

00004052 <memcpy>:
    4052:	fb 01       	movw	r30, r22
    4054:	dc 01       	movw	r26, r24
    4056:	02 c0       	rjmp	.+4      	; 0x405c <memcpy+0xa>
    4058:	01 90       	ld	r0, Z+
    405a:	0d 92       	st	X+, r0
    405c:	41 50       	subi	r20, 0x01	; 1
    405e:	50 40       	sbci	r21, 0x00	; 0
    4060:	d8 f7       	brcc	.-10     	; 0x4058 <memcpy+0x6>
    4062:	08 95       	ret

00004064 <memset>:
    4064:	dc 01       	movw	r26, r24
    4066:	01 c0       	rjmp	.+2      	; 0x406a <memset+0x6>
    4068:	6d 93       	st	X+, r22
    406a:	41 50       	subi	r20, 0x01	; 1
    406c:	50 40       	sbci	r21, 0x00	; 0
    406e:	e0 f7       	brcc	.-8      	; 0x4068 <memset+0x4>
    4070:	08 95       	ret

00004072 <strncpy>:
    4072:	fb 01       	movw	r30, r22
    4074:	dc 01       	movw	r26, r24
    4076:	41 50       	subi	r20, 0x01	; 1
    4078:	50 40       	sbci	r21, 0x00	; 0
    407a:	48 f0       	brcs	.+18     	; 0x408e <strncpy+0x1c>
    407c:	01 90       	ld	r0, Z+
    407e:	0d 92       	st	X+, r0
    4080:	00 20       	and	r0, r0
    4082:	c9 f7       	brne	.-14     	; 0x4076 <strncpy+0x4>
    4084:	01 c0       	rjmp	.+2      	; 0x4088 <strncpy+0x16>
    4086:	1d 92       	st	X+, r1
    4088:	41 50       	subi	r20, 0x01	; 1
    408a:	50 40       	sbci	r21, 0x00	; 0
    408c:	e0 f7       	brcc	.-8      	; 0x4086 <strncpy+0x14>
    408e:	08 95       	ret

00004090 <ultoa>:
    4090:	25 32       	cpi	r18, 0x25	; 37
    4092:	31 05       	cpc	r19, r1
    4094:	20 f4       	brcc	.+8      	; 0x409e <ultoa+0xe>
    4096:	22 30       	cpi	r18, 0x02	; 2
    4098:	10 f0       	brcs	.+4      	; 0x409e <ultoa+0xe>
    409a:	0c 94 53 20 	jmp	0x40a6	; 0x40a6 <__ultoa_ncheck>
    409e:	fa 01       	movw	r30, r20
    40a0:	10 82       	st	Z, r1
    40a2:	ca 01       	movw	r24, r20
    40a4:	08 95       	ret

000040a6 <__ultoa_ncheck>:
    40a6:	bb 27       	eor	r27, r27

000040a8 <__ultoa_common>:
    40a8:	fa 01       	movw	r30, r20
    40aa:	a6 2f       	mov	r26, r22
    40ac:	62 17       	cp	r22, r18
    40ae:	71 05       	cpc	r23, r1
    40b0:	81 05       	cpc	r24, r1
    40b2:	91 05       	cpc	r25, r1
    40b4:	33 0b       	sbc	r19, r19
    40b6:	30 fb       	bst	r19, 0
    40b8:	66 f0       	brts	.+24     	; 0x40d2 <__ultoa_common+0x2a>
    40ba:	aa 27       	eor	r26, r26
    40bc:	66 0f       	add	r22, r22
    40be:	77 1f       	adc	r23, r23
    40c0:	88 1f       	adc	r24, r24
    40c2:	99 1f       	adc	r25, r25
    40c4:	aa 1f       	adc	r26, r26
    40c6:	a2 17       	cp	r26, r18
    40c8:	10 f0       	brcs	.+4      	; 0x40ce <__ultoa_common+0x26>
    40ca:	a2 1b       	sub	r26, r18
    40cc:	63 95       	inc	r22
    40ce:	38 50       	subi	r19, 0x08	; 8
    40d0:	a9 f7       	brne	.-22     	; 0x40bc <__ultoa_common+0x14>
    40d2:	a0 5d       	subi	r26, 0xD0	; 208
    40d4:	aa 33       	cpi	r26, 0x3A	; 58
    40d6:	08 f0       	brcs	.+2      	; 0x40da <__ultoa_common+0x32>
    40d8:	a9 5d       	subi	r26, 0xD9	; 217
    40da:	a1 93       	st	Z+, r26
    40dc:	36 f7       	brtc	.-52     	; 0x40aa <__ultoa_common+0x2>
    40de:	b1 11       	cpse	r27, r1
    40e0:	b1 93       	st	Z+, r27
    40e2:	10 82       	st	Z, r1
    40e4:	ca 01       	movw	r24, r20
    40e6:	0c 94 9a 20 	jmp	0x4134	; 0x4134 <strrev>

000040ea <utoa>:
    40ea:	45 32       	cpi	r20, 0x25	; 37
    40ec:	51 05       	cpc	r21, r1
    40ee:	20 f4       	brcc	.+8      	; 0x40f8 <utoa+0xe>
    40f0:	42 30       	cpi	r20, 0x02	; 2
    40f2:	10 f0       	brcs	.+4      	; 0x40f8 <utoa+0xe>
    40f4:	0c 94 80 20 	jmp	0x4100	; 0x4100 <__utoa_ncheck>
    40f8:	fb 01       	movw	r30, r22
    40fa:	10 82       	st	Z, r1
    40fc:	cb 01       	movw	r24, r22
    40fe:	08 95       	ret

00004100 <__utoa_ncheck>:
    4100:	bb 27       	eor	r27, r27

00004102 <__utoa_common>:
    4102:	fb 01       	movw	r30, r22
    4104:	55 27       	eor	r21, r21
    4106:	aa 27       	eor	r26, r26
    4108:	88 0f       	add	r24, r24
    410a:	99 1f       	adc	r25, r25
    410c:	aa 1f       	adc	r26, r26
    410e:	a4 17       	cp	r26, r20
    4110:	10 f0       	brcs	.+4      	; 0x4116 <__utoa_common+0x14>
    4112:	a4 1b       	sub	r26, r20
    4114:	83 95       	inc	r24
    4116:	50 51       	subi	r21, 0x10	; 16
    4118:	b9 f7       	brne	.-18     	; 0x4108 <__utoa_common+0x6>
    411a:	a0 5d       	subi	r26, 0xD0	; 208
    411c:	aa 33       	cpi	r26, 0x3A	; 58
    411e:	08 f0       	brcs	.+2      	; 0x4122 <__utoa_common+0x20>
    4120:	a9 5d       	subi	r26, 0xD9	; 217
    4122:	a1 93       	st	Z+, r26
    4124:	00 97       	sbiw	r24, 0x00	; 0
    4126:	79 f7       	brne	.-34     	; 0x4106 <__utoa_common+0x4>
    4128:	b1 11       	cpse	r27, r1
    412a:	b1 93       	st	Z+, r27
    412c:	11 92       	st	Z+, r1
    412e:	cb 01       	movw	r24, r22
    4130:	0c 94 9a 20 	jmp	0x4134	; 0x4134 <strrev>

00004134 <strrev>:
    4134:	dc 01       	movw	r26, r24
    4136:	fc 01       	movw	r30, r24
    4138:	67 2f       	mov	r22, r23
    413a:	71 91       	ld	r23, Z+
    413c:	77 23       	and	r23, r23
    413e:	e1 f7       	brne	.-8      	; 0x4138 <strrev+0x4>
    4140:	32 97       	sbiw	r30, 0x02	; 2
    4142:	04 c0       	rjmp	.+8      	; 0x414c <strrev+0x18>
    4144:	7c 91       	ld	r23, X
    4146:	6d 93       	st	X+, r22
    4148:	70 83       	st	Z, r23
    414a:	62 91       	ld	r22, -Z
    414c:	ae 17       	cp	r26, r30
    414e:	bf 07       	cpc	r27, r31
    4150:	c8 f3       	brcs	.-14     	; 0x4144 <strrev+0x10>
    4152:	08 95       	ret

00004154 <_exit>:
    4154:	f8 94       	cli

00004156 <__stop_program>:
    4156:	ff cf       	rjmp	.-2      	; 0x4156 <__stop_program>
