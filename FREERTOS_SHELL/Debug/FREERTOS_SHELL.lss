
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004f1c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000236  00802000  00004f1c  00004fb0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802236  00802236  000051e6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000051e6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005218  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a78  00000000  00000000  00005258  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001caef  00000000  00000000  00005cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000072af  00000000  00000000  000227bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006921  00000000  00000000  00029a6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001f98  00000000  00000000  00030390  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000072a2  00000000  00000000  00032328  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a1ce  00000000  00000000  000395ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009d0  00000000  00000000  00043798  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 39 03 	jmp	0x672	; 0x672 <__ctors_end>
       4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
       c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      10:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      14:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      18:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      1c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      20:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      24:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      28:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      2c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      30:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      34:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      38:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      3c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      40:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      44:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      48:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      4c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      50:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      54:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      58:	0c 94 c6 11 	jmp	0x238c	; 0x238c <__vector_22>
      5c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      60:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      64:	0c 94 9b 21 	jmp	0x4336	; 0x4336 <__vector_25>
      68:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      6c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      70:	0c 94 f9 21 	jmp	0x43f2	; 0x43f2 <__vector_28>
      74:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      78:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      7c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      80:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      84:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      88:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      8c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      90:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      94:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      98:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      9c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      e8:	0c 94 13 23 	jmp	0x4626	; 0x4626 <__vector_58>
      ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
      fc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     100:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     104:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     108:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     10c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     110:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     114:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     118:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     11c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     120:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     124:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     128:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     12c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     130:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     134:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     138:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     13c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     140:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     144:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     148:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     14c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     150:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     154:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     158:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     15c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     160:	0c 94 57 22 	jmp	0x44ae	; 0x44ae <__vector_88>
     164:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     168:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     16c:	0c 94 b5 22 	jmp	0x456a	; 0x456a <__vector_91>
     170:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     174:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     178:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     17c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     180:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     184:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     188:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     18c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     190:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     194:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     198:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     19c:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1a8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ac:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1b8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1bc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1c8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1cc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1d8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1dc:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1e8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1ec:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f0:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f4:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1f8:	0c 94 6f 03 	jmp	0x6de	; 0x6de <__bad_interrupt>
     1fc:	87 1f       	adc	r24, r23
     1fe:	8a 1f       	adc	r24, r26
     200:	8d 1f       	adc	r24, r29
     202:	90 1f       	adc	r25, r16
     204:	93 1f       	adc	r25, r19
     206:	96 1f       	adc	r25, r22
     208:	98 1f       	adc	r25, r24
     20a:	a9 1f       	adc	r26, r25
     20c:	b1 1f       	adc	r27, r17
     20e:	bb 1f       	adc	r27, r27
     210:	b9 1f       	adc	r27, r25

00000212 <__trampolines_start>:
     212:	0c 94 3b 24 	jmp	0x4876	; 0x4876 <_ZN9frt_queueIiE10get_a_copyEv>
     216:	0c 94 ff 20 	jmp	0x41fe	; 0x41fe <_ZN5rs23214check_for_charEv>
     21a:	0c 94 cf 24 	jmp	0x499e	; 0x499e <_ZN9frt_queueIjE11ISR_butt_inERKj>
     21e:	0c 94 83 23 	jmp	0x4706	; 0x4706 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     222:	0c 94 db 1c 	jmp	0x39b6	; 0x39b6 <_ZN14frt_text_queue7putcharEc>
     226:	0c 94 31 1f 	jmp	0x3e62	; 0x3e62 <_ZN8emstream12transmit_nowEv>
     22a:	0c 94 e7 24 	jmp	0x49ce	; 0x49ce <_ZN9frt_queueIjE7ISR_putERKj>
     22e:	0c 94 ed 23 	jmp	0x47da	; 0x47da <_ZN9frt_queueIjE10get_a_copyEv>
     232:	0c 94 d1 08 	jmp	0x11a2	; 0x11a2 <_ZN9frt_queueIhE7ISR_getEPh>
     236:	0c 94 bb 1f 	jmp	0x3f76	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23a:	0c 94 b1 1f 	jmp	0x3f62	; 0x3f62 <_ZN8emstreamlsE15ser_manipulator+0x72>
     23e:	0c 94 5f 05 	jmp	0xabe	; 0xabe <_ZN9I2CMaster10StartState11serialDebugEv>
     242:	0c 94 2f 25 	jmp	0x4a5e	; 0x4a5e <_ZN9frt_queueIjE7butt_inERKj>
     246:	0c 94 7d 24 	jmp	0x48fa	; 0x48fa <_ZN9frt_queueIjE7ISR_getEPj>
     24a:	0c 94 b2 1c 	jmp	0x3964	; 0x3964 <_ZN14frt_text_queue7getcharEv>
     24e:	0c 94 2f 24 	jmp	0x485e	; 0x485e <_ZN9frt_queueIiE10get_a_copyERi>
     252:	0c 94 b9 1f 	jmp	0x3f72	; 0x3f72 <_ZN8emstreamlsE15ser_manipulator+0x82>
     256:	0c 94 62 24 	jmp	0x48c4	; 0x48c4 <_ZN9frt_queueIiE3getEv>
     25a:	0c 94 12 21 	jmp	0x4224	; 0x4224 <_ZN5rs23212clear_screenEv>
     25e:	0c 94 b0 23 	jmp	0x4760	; 0x4760 <_ZN9frt_queueIjE9not_emptyEv>
     262:	0c 94 32 1f 	jmp	0x3e64	; 0x3e64 <_ZN8emstream12clear_screenEv>
     266:	0c 94 08 24 	jmp	0x4810	; 0x4810 <_ZN9frt_queueIjE3getEPj>
     26a:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     26e:	0c 94 1a 26 	jmp	0x4c34	; 0x4c34 <_GLOBAL__sub_I_counter>
     272:	0c 94 26 0a 	jmp	0x144c	; 0x144c <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>
     276:	0c 94 7f 08 	jmp	0x10fe	; 0x10fe <_ZN9frt_queueIhE8is_emptyEv>
     27a:	0c 94 6d 08 	jmp	0x10da	; 0x10da <_ZN9frt_queueIhE12num_items_inEv>
     27e:	0c 94 74 05 	jmp	0xae8	; 0xae8 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     282:	0c 94 b7 24 	jmp	0x496e	; 0x496e <_ZN9frt_queueIiE7ISR_getEv>
     286:	0c 94 8a 1f 	jmp	0x3f14	; 0x3f14 <_ZN8emstreamlsE15ser_manipulator+0x24>
     28a:	0c 94 92 05 	jmp	0xb24	; 0xb24 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     28e:	0c 94 d9 20 	jmp	0x41b2	; 0x41b2 <_ZN5rs2327getcharEv>
     292:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <_ZN9frt_queueIiE7ISR_putERKi>
     296:	0c 94 44 08 	jmp	0x1088	; 0x1088 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     29a:	0c 94 6f 04 	jmp	0x8de	; 0x8de <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     29e:	0c 94 8d 1f 	jmp	0x3f1a	; 0x3f1a <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2a2:	0c 94 bb 23 	jmp	0x4776	; 0x4776 <_ZN9frt_queueIjE8is_emptyEv>
     2a6:	0c 94 8d 23 	jmp	0x471a	; 0x471a <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2aa:	0c 94 96 1f 	jmp	0x3f2c	; 0x3f2c <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2ae:	0c 94 9f 04 	jmp	0x93e	; 0x93e <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     2b2:	0c 94 41 25 	jmp	0x4a82	; 0x4a82 <_ZN9frt_queueIjE3putERKj>
     2b6:	0c 94 f3 0b 	jmp	0x17e6	; 0x17e6 <_ZN11task_sensor3runEv>
     2ba:	0c 94 ee 03 	jmp	0x7dc	; 0x7dc <_ZN8I2CAgent11resetPacketER6Packet>
     2be:	0c 94 2c 1f 	jmp	0x3e58	; 0x3e58 <_ZN8emstream7getcharEv>
     2c2:	0c 94 11 09 	jmp	0x1222	; 0x1222 <_ZN9frt_queueIhE7ISR_putERKh>
     2c6:	0c 94 a2 0d 	jmp	0x1b44	; 0x1b44 <_ZN9task_user3runEv>
     2ca:	0c 94 91 03 	jmp	0x722	; 0x722 <_ZN8I2CAgent7receiveEv>
     2ce:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <_ZN9frt_queueIhE9not_emptyEv>
     2d2:	0c 94 98 1f 	jmp	0x3f30	; 0x3f30 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2d6:	0c 94 63 08 	jmp	0x10c6	; 0x10c6 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2da:	0c 94 14 24 	jmp	0x4828	; 0x4828 <_ZN9frt_queueIjE3getEv>
     2de:	0c 94 d7 23 	jmp	0x47ae	; 0x47ae <_ZN9frt_queueIiE8is_emptyEv>
     2e2:	0c 94 68 1b 	jmp	0x36d0	; 0x36d0 <_ZN8frt_task12print_statusER8emstream>
     2e6:	0c 94 a9 23 	jmp	0x4752	; 0x4752 <_ZN9frt_queueIjE12num_items_inEv>
     2ea:	0c 94 a6 24 	jmp	0x494c	; 0x494c <_ZN9frt_queueIiE7ISR_getEPi>
     2ee:	0c 94 87 1f 	jmp	0x3f0e	; 0x3f0e <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2f2:	0c 94 35 04 	jmp	0x86a	; 0x86a <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     2f6:	0c 94 0b 05 	jmp	0xa16	; 0xa16 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     2fa:	0c 94 71 23 	jmp	0x46e2	; 0x46e2 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2fe:	0c 94 56 24 	jmp	0x48ac	; 0x48ac <_ZN9frt_queueIiE3getEPi>
     302:	0c 94 21 08 	jmp	0x1042	; 0x1042 <_ZN9I2CMaster10StartState7executeER6Packet>
     306:	0c 94 c5 04 	jmp	0x98a	; 0x98a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     30a:	0c 94 78 23 	jmp	0x46f0	; 0x46f0 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     30e:	0c 94 d0 1c 	jmp	0x39a0	; 0x39a0 <_ZN14frt_text_queue14check_for_charEv>
     312:	0c 94 90 1f 	jmp	0x3f20	; 0x3f20 <_ZN8emstreamlsE15ser_manipulator+0x30>
     316:	0c 94 b9 08 	jmp	0x1172	; 0x1172 <_ZN9frt_queueIhE3getEv>
     31a:	0c 94 0c 0a 	jmp	0x1418	; 0x1418 <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>
     31e:	0c 94 bc 03 	jmp	0x778	; 0x778 <_ZN8I2CAgent11writePacketER7Command>
     322:	0c 94 8e 24 	jmp	0x491c	; 0x491c <_ZN9frt_queueIjE7ISR_getEv>
     326:	0c 94 19 0a 	jmp	0x1432	; 0x1432 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>
     32a:	0c 94 a9 1f 	jmp	0x3f52	; 0x3f52 <_ZN8emstreamlsE15ser_manipulator+0x62>
     32e:	0c 94 35 05 	jmp	0xa6a	; 0xa6a <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     332:	0c 94 93 1f 	jmp	0x3f26	; 0x3f26 <_ZN8emstreamlsE15ser_manipulator+0x36>
     336:	0c 94 c5 23 	jmp	0x478a	; 0x478a <_ZN9frt_queueIiE12num_items_inEv>
     33a:	0c 94 36 03 	jmp	0x66c	; 0x66c <_call_static_run_method>
     33e:	0c 94 fb 03 	jmp	0x7f6	; 0x7f6 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     342:	0c 94 da 04 	jmp	0x9b4	; 0x9b4 <_ZN9I2CMaster9DoneState7executeER6Packet>
     346:	0c 94 a6 14 	jmp	0x294c	; 0x294c <prvIdleTask>
     34a:	0c 94 cc 23 	jmp	0x4798	; 0x4798 <_ZN9frt_queueIiE9not_emptyEv>
     34e:	0c 94 95 08 	jmp	0x112a	; 0x112a <_ZN9frt_queueIhE10get_a_copyEv>
     352:	0c 94 e1 23 	jmp	0x47c2	; 0x47c2 <_ZN9frt_queueIjE10get_a_copyERj>
     356:	0c 94 2f 1f 	jmp	0x3e5e	; 0x3e5e <_ZN8emstream14check_for_charEv>
     35a:	0c 94 53 25 	jmp	0x4aa6	; 0x4aa6 <_ZN9frt_queueIiE7butt_inERKi>
     35e:	0c 94 51 08 	jmp	0x10a2	; 0x10a2 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     362:	0c 94 b0 05 	jmp	0xb60	; 0xb60 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     366:	0c 94 71 03 	jmp	0x6e2	; 0x6e2 <_ZN8I2CAgent10readPacketEv>
     36a:	0c 94 94 23 	jmp	0x4728	; 0x4728 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     36e:	0c 94 20 05 	jmp	0xa40	; 0xa40 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     372:	0c 94 ff 24 	jmp	0x49fe	; 0x49fe <_ZN9frt_queueIiE11ISR_butt_inERKi>
     376:	0c 94 93 1e 	jmp	0x3d26	; 0x3d26 <__cxa_pure_virtual>
     37a:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <_ZN9I2CMaster10ErrorState11serialDebugEv>
     37e:	0c 94 f9 08 	jmp	0x11f2	; 0x11f2 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     382:	0c 94 ad 08 	jmp	0x115a	; 0x115a <_ZN9frt_queueIhE3getEPh>
     386:	0c 94 f6 04 	jmp	0x9ec	; 0x9ec <_ZN9I2CMaster9DoneState11serialDebugEv>
     38a:	0c 94 4a 05 	jmp	0xa94	; 0xa94 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     38e:	0c 94 65 25 	jmp	0x4aca	; 0x4aca <_ZN9frt_queueIiE3putERKi>
     392:	0c 94 58 08 	jmp	0x10b0	; 0x10b0 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     396:	0c 94 29 09 	jmp	0x1252	; 0x1252 <_ZN9frt_queueIhE7butt_inERKh>
     39a:	0c 94 ed 09 	jmp	0x13da	; 0x13da <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>
     39e:	0c 94 89 08 	jmp	0x1112	; 0x1112 <_ZN9frt_queueIhE10get_a_copyERh>
     3a2:	0c 94 9f 23 	jmp	0x473e	; 0x473e <_ZN9frt_queueIiE12ISR_is_emptyEv>
     3a6:	0c 94 b5 20 	jmp	0x416a	; 0x416a <_ZN5rs2327putcharEc>
     3aa:	0c 94 e2 08 	jmp	0x11c4	; 0x11c4 <_ZN9frt_queueIhE7ISR_getEv>
     3ae:	0c 94 3b 09 	jmp	0x1276	; 0x1276 <_ZN9frt_queueIhE3putERKh>
     3b2:	0c 94 7c 03 	jmp	0x6f8	; 0x6f8 <_ZN8I2CAgent8transmitER7Command>
     3b6:	0c 94 2a 1f 	jmp	0x3e54	; 0x3e54 <_ZN8emstream13ready_to_sendEv>

000003ba <__trampolines_end>:
     3ba:	2c 20       	and	r2, r12
     3bc:	54 43       	sbci	r21, 0x34	; 52
     3be:	43 30       	cpi	r20, 0x03	; 3
     3c0:	43 43       	sbci	r20, 0x33	; 51
     3c2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000003c5 <_ZZN9task_user11show_statusEvE3__c_3>:
     3c5:	2f 00                                               /.

000003c7 <_ZZN9task_user11show_statusEvE3__c_2>:
     3c7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003d5 <_ZZN9task_user11show_statusEvE3__c_1>:
     3d5:	54 69 6d 65 3a 20 00                                Time: .

000003dc <_ZZN9task_user11show_statusEvE3__c_0>:
     3dc:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e8 <_ZZN9task_user11show_statusEvE3__c>:
     3e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000407 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     407:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000416 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     416:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     426:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000431 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     431:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     441:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000044f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     44f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     45f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     46f:	6d 61 74 69 6f 6e 00                                mation.

00000476 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     476:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     486:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000497 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     497:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     4a7:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004af <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4af:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4bf:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004cb <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4cb:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4db:	68 65 20 41 56 52 00                                he AVR.

000004e2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4e2:	20 68 65 6c 70 00                                    help.

000004e8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000507 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     507:	1b 5b 33 30 6d 00                                   .[30m.

0000050d <_ZZN9task_user18print_help_messageEvE3__c>:
     50d:	1b 5b 34 36 6d 00                                   .[46m.

00000513 <_ZZN9task_user3runEvE3__c_3>:
     513:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     523:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000530 <_ZZN9task_user3runEvE3__c_2>:
     530:	3a 57 54 46 3f 00                                   :WTF?.

00000536 <_ZZN9task_user3runEvE3__c_1>:
     536:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     546:	65 00                                               e.

00000548 <_ZZN9task_user3runEvE3__c_0>:
     548:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000556 <_ZZN9task_user3runEvE3__c>:
     556:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     566:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000574 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     574:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000057e <_ZZN8frt_task15emergency_resetEvE3__c>:
     57e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000058d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     58d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     59d:	61 73 6b 20 00                                      ask .

000005a2 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     5a2:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005b0 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5b0:	20 63 72 65 61 74 65 64 00                           created.

000005b9 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b9:	54 61 73 6b 20 00                                   Task .

000005bf <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5bf:	1b 5b 32 32 6d 00                                   .[22m.

000005c5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5c5:	54 61 73 6b 3a 20 00                                Task: .

000005cc <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5cc:	1b 5b 31 6d 00                                      .[1m.

000005d1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5d1:	1b 5b 32 32 6d 00                                   .[22m.

000005d7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5d7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005e2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5e2:	1b 5b 31 6d 00                                      .[1m.

000005e7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     5e7:	09 09 00                                            ...

000005ea <_ZZ15print_task_listP8emstreamE3__c_8>:
     5ea:	2f 00                                               /.

000005ec <_ZZ15print_task_listP8emstreamE3__c_7>:
     5ec:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005f7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     5f7:	09 2d 2d 2d 2d 00                                   .----.

000005fd <_ZZ15print_task_listP8emstreamE3__c_5>:
     5fd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000609 <_ZZ15print_task_listP8emstreamE3__c_4>:
     609:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000061a <_ZZ15print_task_listP8emstreamE3__c_3>:
     61a:	09 52 75 6e 73 00                                   .Runs.

00000620 <_ZZ15print_task_listP8emstreamE3__c_2>:
     620:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000062c <_ZZ15print_task_listP8emstreamE3__c_1>:
     62c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000063d <_ZZ15print_task_listP8emstreamE3__c_0>:
     63d:	09 53 74 61 63 6b 00                                .Stack.

00000644 <_ZZ15print_task_listP8emstreamE3__c>:
     644:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     64f:	09 00                                               ..

00000651 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     651:	09 00                                               ..

00000653 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     653:	2f 00                                               /.

00000655 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     655:	09 00                                               ..

00000657 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     657:	09 00                                               ..

00000659 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     659:	1b 5b 32 32 6d 00                                   .[22m.

0000065f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     65f:	1b 5b 31 6d 00                                      .[1m.

00000664 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     664:	1b 5b 31 6d 00                                      .[1m.

00000669 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     669:	20 20 00                                              .

0000066c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     66c:	0e 94 00 1a 	call	0x3400	; 0x3400 <_ZN8frt_task22_call_users_run_methodEPS_>

00000670 <__ctors_start>:
     670:	1a 26       	eor	r1, r26

00000672 <__ctors_end>:
     672:	11 24       	eor	r1, r1
     674:	1f be       	out	0x3f, r1	; 63
     676:	cf ef       	ldi	r28, 0xFF	; 255
     678:	cd bf       	out	0x3d, r28	; 61
     67a:	df e3       	ldi	r29, 0x3F	; 63
     67c:	de bf       	out	0x3e, r29	; 62
     67e:	00 e0       	ldi	r16, 0x00	; 0
     680:	0c bf       	out	0x3c, r16	; 60
     682:	18 be       	out	0x38, r1	; 56
     684:	19 be       	out	0x39, r1	; 57
     686:	1a be       	out	0x3a, r1	; 58
     688:	1b be       	out	0x3b, r1	; 59

0000068a <__do_copy_data>:
     68a:	12 e2       	ldi	r17, 0x22	; 34
     68c:	a0 e0       	ldi	r26, 0x00	; 0
     68e:	b0 e2       	ldi	r27, 0x20	; 32
     690:	ec e1       	ldi	r30, 0x1C	; 28
     692:	ff e4       	ldi	r31, 0x4F	; 79
     694:	00 e0       	ldi	r16, 0x00	; 0
     696:	0b bf       	out	0x3b, r16	; 59
     698:	02 c0       	rjmp	.+4      	; 0x69e <__do_copy_data+0x14>
     69a:	07 90       	elpm	r0, Z+
     69c:	0d 92       	st	X+, r0
     69e:	a6 33       	cpi	r26, 0x36	; 54
     6a0:	b1 07       	cpc	r27, r17
     6a2:	d9 f7       	brne	.-10     	; 0x69a <__do_copy_data+0x10>
     6a4:	1b be       	out	0x3b, r1	; 59

000006a6 <__do_clear_bss>:
     6a6:	23 e3       	ldi	r18, 0x33	; 51
     6a8:	a6 e3       	ldi	r26, 0x36	; 54
     6aa:	b2 e2       	ldi	r27, 0x22	; 34
     6ac:	01 c0       	rjmp	.+2      	; 0x6b0 <.do_clear_bss_start>

000006ae <.do_clear_bss_loop>:
     6ae:	1d 92       	st	X+, r1

000006b0 <.do_clear_bss_start>:
     6b0:	a4 30       	cpi	r26, 0x04	; 4
     6b2:	b2 07       	cpc	r27, r18
     6b4:	e1 f7       	brne	.-8      	; 0x6ae <.do_clear_bss_loop>

000006b6 <__do_global_ctors>:
     6b6:	13 e0       	ldi	r17, 0x03	; 3
     6b8:	c9 e3       	ldi	r28, 0x39	; 57
     6ba:	d3 e0       	ldi	r29, 0x03	; 3
     6bc:	00 e0       	ldi	r16, 0x00	; 0
     6be:	06 c0       	rjmp	.+12     	; 0x6cc <__do_global_ctors+0x16>
     6c0:	21 97       	sbiw	r28, 0x01	; 1
     6c2:	01 09       	sbc	r16, r1
     6c4:	80 2f       	mov	r24, r16
     6c6:	fe 01       	movw	r30, r28
     6c8:	0e 94 e8 26 	call	0x4dd0	; 0x4dd0 <__tablejump2__>
     6cc:	c8 33       	cpi	r28, 0x38	; 56
     6ce:	d1 07       	cpc	r29, r17
     6d0:	80 e0       	ldi	r24, 0x00	; 0
     6d2:	08 07       	cpc	r16, r24
     6d4:	a9 f7       	brne	.-22     	; 0x6c0 <__do_global_ctors+0xa>
     6d6:	0e 94 8c 25 	call	0x4b18	; 0x4b18 <main>
     6da:	0c 94 8c 27 	jmp	0x4f18	; 0x4f18 <_exit>

000006de <__bad_interrupt>:
     6de:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006e2 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6e2:	bc 01       	movw	r22, r24
     6e4:	6e 5f       	subi	r22, 0xFE	; 254
     6e6:	7f 4f       	sbci	r23, 0xFF	; 255
     6e8:	dc 01       	movw	r26, r24
     6ea:	ed 91       	ld	r30, X+
     6ec:	fc 91       	ld	r31, X
     6ee:	00 84       	ldd	r0, Z+8	; 0x08
     6f0:	f1 85       	ldd	r31, Z+9	; 0x09
     6f2:	e0 2d       	mov	r30, r0
     6f4:	19 95       	eicall
     6f6:	08 95       	ret

000006f8 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	ec 01       	movw	r28, r24
  writePacket(cmd);
     6fe:	e8 81       	ld	r30, Y
     700:	f9 81       	ldd	r31, Y+1	; 0x01
     702:	04 80       	ldd	r0, Z+4	; 0x04
     704:	f5 81       	ldd	r31, Z+5	; 0x05
     706:	e0 2d       	mov	r30, r0
     708:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     70a:	be 01       	movw	r22, r28
     70c:	62 5f       	subi	r22, 0xF2	; 242
     70e:	7f 4f       	sbci	r23, 0xFF	; 255

  };

  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     710:	ec 8d       	ldd	r30, Y+28	; 0x1c
     712:	fd 8d       	ldd	r31, Y+29	; 0x1d
     714:	80 81       	ld	r24, Z
     716:	91 81       	ldd	r25, Z+1	; 0x01
     718:	0e 94 20 07 	call	0xe40	; 0xe40 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     722:	ef 92       	push	r14
     724:	ff 92       	push	r15
     726:	0f 93       	push	r16
     728:	cf 93       	push	r28
     72a:	df 93       	push	r29
     72c:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     72e:	7c 01       	movw	r14, r24
     730:	82 e0       	ldi	r24, 0x02	; 2
     732:	e8 0e       	add	r14, r24
     734:	f1 1c       	adc	r15, r1
     736:	e8 81       	ld	r30, Y
     738:	f9 81       	ldd	r31, Y+1	; 0x01
     73a:	00 84       	ldd	r0, Z+8	; 0x08
     73c:	f1 85       	ldd	r31, Z+9	; 0x09
     73e:	e0 2d       	mov	r30, r0
     740:	b7 01       	movw	r22, r14
     742:	ce 01       	movw	r24, r28
     744:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     746:	28 85       	ldd	r18, Y+8	; 0x08
     748:	39 85       	ldd	r19, Y+9	; 0x09
     74a:	4a 85       	ldd	r20, Y+10	; 0x0a
     74c:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     74e:	be 01       	movw	r22, r28
     750:	60 5e       	subi	r22, 0xE0	; 224
     752:	7f 4f       	sbci	r23, 0xFF	; 255
     754:	00 e0       	ldi	r16, 0x00	; 0
     756:	8e 81       	ldd	r24, Y+6	; 0x06
     758:	9f 81       	ldd	r25, Y+7	; 0x07
     75a:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     75e:	ec 8d       	ldd	r30, Y+28	; 0x1c
     760:	fd 8d       	ldd	r31, Y+29	; 0x1d
  return driver_->getReceiver()->run(inPacket_);
     762:	b7 01       	movw	r22, r14
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	0e 94 63 07 	call	0xec6	; 0xec6 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     76c:	df 91       	pop	r29
     76e:	cf 91       	pop	r28
     770:	0f 91       	pop	r16
     772:	ff 90       	pop	r15
     774:	ef 90       	pop	r14
     776:	08 95       	ret

00000778 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     778:	cf 92       	push	r12
     77a:	df 92       	push	r13
     77c:	ef 92       	push	r14
     77e:	ff 92       	push	r15
     780:	0f 93       	push	r16
     782:	cf 93       	push	r28
     784:	df 93       	push	r29
     786:	ec 01       	movw	r28, r24
     788:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     78a:	6c 01       	movw	r12, r24
     78c:	8e e0       	ldi	r24, 0x0E	; 14
     78e:	c8 0e       	add	r12, r24
     790:	d1 1c       	adc	r13, r1
     792:	e8 81       	ld	r30, Y
     794:	f9 81       	ldd	r31, Y+1	; 0x01
     796:	00 84       	ldd	r0, Z+8	; 0x08
     798:	f1 85       	ldd	r31, Z+9	; 0x09
     79a:	e0 2d       	mov	r30, r0
     79c:	b6 01       	movw	r22, r12
     79e:	ce 01       	movw	r24, r28
     7a0:	19 95       	eicall
     7a2:	2c 89       	ldd	r18, Y+20	; 0x14
     7a4:	3d 89       	ldd	r19, Y+21	; 0x15
     7a6:	4e 89       	ldd	r20, Y+22	; 0x16
     7a8:	5f 89       	ldd	r21, Y+23	; 0x17
  outPacket_.put(writeCommand_);
     7aa:	be 01       	movw	r22, r28
     7ac:	61 5e       	subi	r22, 0xE1	; 225
     7ae:	7f 4f       	sbci	r23, 0xFF	; 255
     7b0:	00 e0       	ldi	r16, 0x00	; 0
     7b2:	8a 89       	ldd	r24, Y+18	; 0x12
     7b4:	9b 89       	ldd	r25, Y+19	; 0x13
     7b6:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7ba:	d7 01       	movw	r26, r14
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	01 90       	ld	r0, Z+
     7c2:	f0 81       	ld	r31, Z
     7c4:	e0 2d       	mov	r30, r0
     7c6:	b6 01       	movw	r22, r12
     7c8:	c7 01       	movw	r24, r14
     7ca:	19 95       	eicall
}
     7cc:	df 91       	pop	r29
     7ce:	cf 91       	pop	r28
     7d0:	0f 91       	pop	r16
     7d2:	ff 90       	pop	r15
     7d4:	ef 90       	pop	r14
     7d6:	df 90       	pop	r13
     7d8:	cf 90       	pop	r12
     7da:	08 95       	ret

000007dc <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     7dc:	cb 01       	movw	r24, r22
  packet.resetContent();
     7de:	0e 94 db 0b 	call	0x17b6	; 0x17b6 <_ZN6Packet12resetContentEv>
     7e2:	08 95       	ret

000007e4 <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7e4:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e6:	66 8f       	std	Z+30, r22	; 0x1e
  writeCommand_ = addr << 1;
     7e8:	86 2f       	mov	r24, r22
     7ea:	88 0f       	add	r24, r24
     7ec:	87 8f       	std	Z+31, r24	; 0x1f
  readCommand_ = addr << 1 | 1 << 0;
     7ee:	68 2f       	mov	r22, r24
     7f0:	61 60       	ori	r22, 0x01	; 1
     7f2:	60 a3       	std	Z+32, r22	; 0x20
     7f4:	08 95       	ret

000007f6 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     7f6:	cf 93       	push	r28
     7f8:	df 93       	push	r29
     7fa:	1f 92       	push	r1
     7fc:	1f 92       	push	r1
     7fe:	cd b7       	in	r28, 0x3d	; 61
     800:	de b7       	in	r29, 0x3e	; 62
     802:	dc 01       	movw	r26, r24
     804:	19 96       	adiw	r26, 0x09	; 9
     806:	8d 91       	ld	r24, X+
     808:	9c 91       	ld	r25, X
     80a:	1a 97       	sbiw	r26, 0x0a	; 10
     80c:	89 83       	std	Y+1, r24	; 0x01
     80e:	9a 83       	std	Y+2, r25	; 0x02
     810:	29 81       	ldd	r18, Y+1	; 0x01
     812:	3a 81       	ldd	r19, Y+2	; 0x02
     814:	21 50       	subi	r18, 0x01	; 1
     816:	31 09       	sbc	r19, r1
     818:	29 83       	std	Y+1, r18	; 0x01
     81a:	3a 83       	std	Y+2, r19	; 0x02
     81c:	23 2b       	or	r18, r19
     81e:	51 f0       	breq	.+20     	; 0x834 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3e>
     820:	17 96       	adiw	r26, 0x07	; 7
     822:	ed 91       	ld	r30, X+
     824:	fc 91       	ld	r31, X
     826:	18 97       	sbiw	r26, 0x08	; 8
     828:	04 80       	ldd	r0, Z+4	; 0x04
     82a:	f5 81       	ldd	r31, Z+5	; 0x05
     82c:	e0 2d       	mov	r30, r0
     82e:	94 81       	ldd	r25, Z+4	; 0x04
     830:	96 ff       	sbrs	r25, 6
     832:	ee cf       	rjmp	.-36     	; 0x810 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
     834:	17 96       	adiw	r26, 0x07	; 7
     836:	ed 91       	ld	r30, X+
     838:	fc 91       	ld	r31, X
     83a:	18 97       	sbiw	r26, 0x08	; 8
     83c:	04 80       	ldd	r0, Z+4	; 0x04
     83e:	f5 81       	ldd	r31, Z+5	; 0x05
     840:	e0 2d       	mov	r30, r0
     842:	84 81       	ldd	r24, Z+4	; 0x04
     844:	84 fd       	sbrc	r24, 4
     846:	08 c0       	rjmp	.+16     	; 0x858 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x62>
     848:	84 81       	ldd	r24, Z+4	; 0x04
     84a:	86 ff       	sbrs	r24, 6
     84c:	05 c0       	rjmp	.+10     	; 0x858 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x62>
     84e:	12 96       	adiw	r26, 0x02	; 2
     850:	8d 91       	ld	r24, X+
     852:	9c 91       	ld	r25, X
     854:	13 97       	sbiw	r26, 0x03	; 3
     856:	04 c0       	rjmp	.+8      	; 0x860 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x6a>
     858:	14 96       	adiw	r26, 0x04	; 4
     85a:	8d 91       	ld	r24, X+
     85c:	9c 91       	ld	r25, X
     85e:	15 97       	sbiw	r26, 0x05	; 5
     860:	0f 90       	pop	r0
     862:	0f 90       	pop	r0
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	08 95       	ret

0000086a <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     86a:	cf 93       	push	r28
     86c:	df 93       	push	r29
     86e:	1f 92       	push	r1
     870:	1f 92       	push	r1
     872:	cd b7       	in	r28, 0x3d	; 61
     874:	de b7       	in	r29, 0x3e	; 62
     876:	dc 01       	movw	r26, r24
     878:	19 96       	adiw	r26, 0x09	; 9
     87a:	8d 91       	ld	r24, X+
     87c:	9c 91       	ld	r25, X
     87e:	1a 97       	sbiw	r26, 0x0a	; 10
     880:	89 83       	std	Y+1, r24	; 0x01
     882:	9a 83       	std	Y+2, r25	; 0x02
     884:	29 81       	ldd	r18, Y+1	; 0x01
     886:	3a 81       	ldd	r19, Y+2	; 0x02
     888:	21 50       	subi	r18, 0x01	; 1
     88a:	31 09       	sbc	r19, r1
     88c:	29 83       	std	Y+1, r18	; 0x01
     88e:	3a 83       	std	Y+2, r19	; 0x02
     890:	23 2b       	or	r18, r19
     892:	51 f0       	breq	.+20     	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x3e>
     894:	17 96       	adiw	r26, 0x07	; 7
     896:	ed 91       	ld	r30, X+
     898:	fc 91       	ld	r31, X
     89a:	18 97       	sbiw	r26, 0x08	; 8
     89c:	04 80       	ldd	r0, Z+4	; 0x04
     89e:	f5 81       	ldd	r31, Z+5	; 0x05
     8a0:	e0 2d       	mov	r30, r0
     8a2:	94 81       	ldd	r25, Z+4	; 0x04
     8a4:	99 23       	and	r25, r25
     8a6:	74 f7       	brge	.-36     	; 0x884 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x1a>
     8a8:	17 96       	adiw	r26, 0x07	; 7
     8aa:	ed 91       	ld	r30, X+
     8ac:	fc 91       	ld	r31, X
     8ae:	18 97       	sbiw	r26, 0x08	; 8
     8b0:	04 80       	ldd	r0, Z+4	; 0x04
     8b2:	f5 81       	ldd	r31, Z+5	; 0x05
     8b4:	e0 2d       	mov	r30, r0
     8b6:	84 81       	ldd	r24, Z+4	; 0x04
     8b8:	84 fd       	sbrc	r24, 4
     8ba:	08 c0       	rjmp	.+16     	; 0x8cc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x62>
     8bc:	84 81       	ldd	r24, Z+4	; 0x04
     8be:	88 23       	and	r24, r24
     8c0:	2c f4       	brge	.+10     	; 0x8cc <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x62>
     8c2:	12 96       	adiw	r26, 0x02	; 2
     8c4:	8d 91       	ld	r24, X+
     8c6:	9c 91       	ld	r25, X
     8c8:	13 97       	sbiw	r26, 0x03	; 3
     8ca:	04 c0       	rjmp	.+8      	; 0x8d4 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x6a>
     8cc:	14 96       	adiw	r26, 0x04	; 4
     8ce:	8d 91       	ld	r24, X+
     8d0:	9c 91       	ld	r25, X
     8d2:	15 97       	sbiw	r26, 0x05	; 5
     8d4:	0f 90       	pop	r0
     8d6:	0f 90       	pop	r0
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	08 95       	ret

000008de <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     8de:	ef 92       	push	r14
     8e0:	ff 92       	push	r15
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
     8e6:	cf 93       	push	r28
     8e8:	df 93       	push	r29
     8ea:	8c 01       	movw	r16, r24
     8ec:	eb 01       	movw	r28, r22
     8ee:	e8 81       	ld	r30, Y
     8f0:	f9 81       	ldd	r31, Y+1	; 0x01
     8f2:	00 8c       	ldd	r0, Z+24	; 0x18
     8f4:	f1 8d       	ldd	r31, Z+25	; 0x19
     8f6:	e0 2d       	mov	r30, r0
     8f8:	cb 01       	movw	r24, r22
     8fa:	19 95       	eicall
     8fc:	88 23       	and	r24, r24
     8fe:	a9 f0       	breq	.+42     	; 0x92a <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
     900:	e8 81       	ld	r30, Y
     902:	f9 81       	ldd	r31, Y+1	; 0x01
     904:	02 84       	ldd	r0, Z+10	; 0x0a
     906:	f3 85       	ldd	r31, Z+11	; 0x0b
     908:	e0 2d       	mov	r30, r0
     90a:	e1 2c       	mov	r14, r1
     90c:	f1 2c       	mov	r15, r1
     90e:	b7 01       	movw	r22, r14
     910:	ce 01       	movw	r24, r28
     912:	19 95       	eicall
     914:	d8 01       	movw	r26, r16
     916:	17 96       	adiw	r26, 0x07	; 7
     918:	ed 91       	ld	r30, X+
     91a:	fc 91       	ld	r31, X
     91c:	18 97       	sbiw	r26, 0x08	; 8
     91e:	04 80       	ldd	r0, Z+4	; 0x04
     920:	f5 81       	ldd	r31, Z+5	; 0x05
     922:	e0 2d       	mov	r30, r0
     924:	d7 01       	movw	r26, r14
     926:	8c 91       	ld	r24, X
     928:	87 83       	std	Z+7, r24	; 0x07
     92a:	f8 01       	movw	r30, r16
     92c:	82 81       	ldd	r24, Z+2	; 0x02
     92e:	93 81       	ldd	r25, Z+3	; 0x03
     930:	df 91       	pop	r29
     932:	cf 91       	pop	r28
     934:	1f 91       	pop	r17
     936:	0f 91       	pop	r16
     938:	ff 90       	pop	r15
     93a:	ef 90       	pop	r14
     93c:	08 95       	ret

0000093e <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     93e:	0f 93       	push	r16
     940:	1f 93       	push	r17
     942:	cf 93       	push	r28
     944:	df 93       	push	r29
     946:	1f 92       	push	r1
     948:	cd b7       	in	r28, 0x3d	; 61
     94a:	de b7       	in	r29, 0x3e	; 62
     94c:	8c 01       	movw	r16, r24
     94e:	cb 01       	movw	r24, r22
     950:	d8 01       	movw	r26, r16
     952:	17 96       	adiw	r26, 0x07	; 7
     954:	ed 91       	ld	r30, X+
     956:	fc 91       	ld	r31, X
     958:	18 97       	sbiw	r26, 0x08	; 8
     95a:	04 80       	ldd	r0, Z+4	; 0x04
     95c:	f5 81       	ldd	r31, Z+5	; 0x05
     95e:	e0 2d       	mov	r30, r0
     960:	27 81       	ldd	r18, Z+7	; 0x07
     962:	29 83       	std	Y+1, r18	; 0x01
     964:	db 01       	movw	r26, r22
     966:	ed 91       	ld	r30, X+
     968:	fc 91       	ld	r31, X
     96a:	01 90       	ld	r0, Z+
     96c:	f0 81       	ld	r31, Z
     96e:	e0 2d       	mov	r30, r0
     970:	be 01       	movw	r22, r28
     972:	6f 5f       	subi	r22, 0xFF	; 255
     974:	7f 4f       	sbci	r23, 0xFF	; 255
     976:	19 95       	eicall
     978:	f8 01       	movw	r30, r16
     97a:	82 81       	ldd	r24, Z+2	; 0x02
     97c:	93 81       	ldd	r25, Z+3	; 0x03
     97e:	0f 90       	pop	r0
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	1f 91       	pop	r17
     986:	0f 91       	pop	r16
     988:	08 95       	ret

0000098a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     98a:	cf 93       	push	r28
     98c:	df 93       	push	r29
     98e:	ec 01       	movw	r28, r24
     990:	cb 01       	movw	r24, r22
     992:	db 01       	movw	r26, r22
     994:	ed 91       	ld	r30, X+
     996:	fc 91       	ld	r31, X
     998:	04 88       	ldd	r0, Z+20	; 0x14
     99a:	f5 89       	ldd	r31, Z+21	; 0x15
     99c:	e0 2d       	mov	r30, r0
     99e:	19 95       	eicall
     9a0:	88 23       	and	r24, r24
     9a2:	19 f0       	breq	.+6      	; 0x9aa <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     9a4:	8a 81       	ldd	r24, Y+2	; 0x02
     9a6:	9b 81       	ldd	r25, Y+3	; 0x03
     9a8:	02 c0       	rjmp	.+4      	; 0x9ae <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     9aa:	8c 81       	ldd	r24, Y+4	; 0x04
     9ac:	9d 81       	ldd	r25, Y+5	; 0x05
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	08 95       	ret

000009b4 <_ZN9I2CMaster9DoneState7executeER6Packet>:
     9b4:	21 e0       	ldi	r18, 0x01	; 1
     9b6:	fb 01       	movw	r30, r22
     9b8:	23 87       	std	Z+11, r18	; 0x0b
     9ba:	fc 01       	movw	r30, r24
     9bc:	82 81       	ldd	r24, Z+2	; 0x02
     9be:	93 81       	ldd	r25, Z+3	; 0x03
     9c0:	08 95       	ret

000009c2 <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     9c2:	cf 93       	push	r28
     9c4:	df 93       	push	r29
     9c6:	dc 01       	movw	r26, r24
     9c8:	17 96       	adiw	r26, 0x07	; 7
     9ca:	ed 91       	ld	r30, X+
     9cc:	fc 91       	ld	r31, X
     9ce:	18 97       	sbiw	r26, 0x08	; 8
     9d0:	c6 81       	ldd	r28, Z+6	; 0x06
     9d2:	d7 81       	ldd	r29, Z+7	; 0x07
     9d4:	64 e1       	ldi	r22, 0x14	; 20
     9d6:	70 e2       	ldi	r23, 0x20	; 32
     9d8:	ce 01       	movw	r24, r28
     9da:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     9de:	66 e0       	ldi	r22, 0x06	; 6
     9e0:	ce 01       	movw	r24, r28
     9e2:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	08 95       	ret

000009ec <_ZN9I2CMaster9DoneState11serialDebugEv>:
     9ec:	cf 93       	push	r28
     9ee:	df 93       	push	r29
     9f0:	dc 01       	movw	r26, r24
     9f2:	17 96       	adiw	r26, 0x07	; 7
     9f4:	ed 91       	ld	r30, X+
     9f6:	fc 91       	ld	r31, X
     9f8:	18 97       	sbiw	r26, 0x08	; 8
     9fa:	c6 81       	ldd	r28, Z+6	; 0x06
     9fc:	d7 81       	ldd	r29, Z+7	; 0x07
     9fe:	6a e1       	ldi	r22, 0x1A	; 26
     a00:	70 e2       	ldi	r23, 0x20	; 32
     a02:	ce 01       	movw	r24, r28
     a04:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     a08:	66 e0       	ldi	r22, 0x06	; 6
     a0a:	ce 01       	movw	r24, r28
     a0c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	08 95       	ret

00000a16 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	dc 01       	movw	r26, r24
     a1c:	17 96       	adiw	r26, 0x07	; 7
     a1e:	ed 91       	ld	r30, X+
     a20:	fc 91       	ld	r31, X
     a22:	18 97       	sbiw	r26, 0x08	; 8
     a24:	c6 81       	ldd	r28, Z+6	; 0x06
     a26:	d7 81       	ldd	r29, Z+7	; 0x07
     a28:	6f e1       	ldi	r22, 0x1F	; 31
     a2a:	70 e2       	ldi	r23, 0x20	; 32
     a2c:	ce 01       	movw	r24, r28
     a2e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     a32:	66 e0       	ldi	r22, 0x06	; 6
     a34:	ce 01       	movw	r24, r28
     a36:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	08 95       	ret

00000a40 <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	dc 01       	movw	r26, r24
     a46:	17 96       	adiw	r26, 0x07	; 7
     a48:	ed 91       	ld	r30, X+
     a4a:	fc 91       	ld	r31, X
     a4c:	18 97       	sbiw	r26, 0x08	; 8
     a4e:	c6 81       	ldd	r28, Z+6	; 0x06
     a50:	d7 81       	ldd	r29, Z+7	; 0x07
     a52:	68 e2       	ldi	r22, 0x28	; 40
     a54:	70 e2       	ldi	r23, 0x20	; 32
     a56:	ce 01       	movw	r24, r28
     a58:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     a5c:	66 e0       	ldi	r22, 0x06	; 6
     a5e:	ce 01       	movw	r24, r28
     a60:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	08 95       	ret

00000a6a <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     a6a:	cf 93       	push	r28
     a6c:	df 93       	push	r29
     a6e:	dc 01       	movw	r26, r24
     a70:	17 96       	adiw	r26, 0x07	; 7
     a72:	ed 91       	ld	r30, X+
     a74:	fc 91       	ld	r31, X
     a76:	18 97       	sbiw	r26, 0x08	; 8
     a78:	c6 81       	ldd	r28, Z+6	; 0x06
     a7a:	d7 81       	ldd	r29, Z+7	; 0x07
     a7c:	61 e3       	ldi	r22, 0x31	; 49
     a7e:	70 e2       	ldi	r23, 0x20	; 32
     a80:	ce 01       	movw	r24, r28
     a82:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     a86:	66 e0       	ldi	r22, 0x06	; 6
     a88:	ce 01       	movw	r24, r28
     a8a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	dc 01       	movw	r26, r24
     a9a:	17 96       	adiw	r26, 0x07	; 7
     a9c:	ed 91       	ld	r30, X+
     a9e:	fc 91       	ld	r31, X
     aa0:	18 97       	sbiw	r26, 0x08	; 8
     aa2:	c6 81       	ldd	r28, Z+6	; 0x06
     aa4:	d7 81       	ldd	r29, Z+7	; 0x07
     aa6:	6c e3       	ldi	r22, 0x3C	; 60
     aa8:	70 e2       	ldi	r23, 0x20	; 32
     aaa:	ce 01       	movw	r24, r28
     aac:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     ab0:	66 e0       	ldi	r22, 0x06	; 6
     ab2:	ce 01       	movw	r24, r28
     ab4:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <_ZN9I2CMaster10StartState11serialDebugEv>:
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	dc 01       	movw	r26, r24
     ac4:	17 96       	adiw	r26, 0x07	; 7
     ac6:	ed 91       	ld	r30, X+
     ac8:	fc 91       	ld	r31, X
     aca:	18 97       	sbiw	r26, 0x08	; 8
     acc:	c6 81       	ldd	r28, Z+6	; 0x06
     ace:	d7 81       	ldd	r29, Z+7	; 0x07
     ad0:	67 e4       	ldi	r22, 0x47	; 71
     ad2:	70 e2       	ldi	r23, 0x20	; 32
     ad4:	ce 01       	movw	r24, r28
     ad6:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     ada:	66 e0       	ldi	r22, 0x06	; 6
     adc:	ce 01       	movw	r24, r28
     ade:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	08 95       	ret

00000ae8 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
     ae8:	1f 93       	push	r17
     aea:	cf 93       	push	r28
     aec:	df 93       	push	r29
     aee:	dc 01       	movw	r26, r24
     af0:	17 96       	adiw	r26, 0x07	; 7
     af2:	ed 91       	ld	r30, X+
     af4:	fc 91       	ld	r31, X
     af6:	18 97       	sbiw	r26, 0x08	; 8
     af8:	a4 81       	ldd	r26, Z+4	; 0x04
     afa:	b5 81       	ldd	r27, Z+5	; 0x05
     afc:	14 96       	adiw	r26, 0x04	; 4
     afe:	1c 91       	ld	r17, X
     b00:	c6 81       	ldd	r28, Z+6	; 0x06
     b02:	d7 81       	ldd	r29, Z+7	; 0x07
     b04:	6d e4       	ldi	r22, 0x4D	; 77
     b06:	70 e2       	ldi	r23, 0x20	; 32
     b08:	ce 01       	movw	r24, r28
     b0a:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     b0e:	61 2f       	mov	r22, r17
     b10:	ce 01       	movw	r24, r28
     b12:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
     b16:	66 e0       	ldi	r22, 0x06	; 6
     b18:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     b1c:	df 91       	pop	r29
     b1e:	cf 91       	pop	r28
     b20:	1f 91       	pop	r17
     b22:	08 95       	ret

00000b24 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     b24:	1f 93       	push	r17
     b26:	cf 93       	push	r28
     b28:	df 93       	push	r29
     b2a:	dc 01       	movw	r26, r24
     b2c:	17 96       	adiw	r26, 0x07	; 7
     b2e:	ed 91       	ld	r30, X+
     b30:	fc 91       	ld	r31, X
     b32:	18 97       	sbiw	r26, 0x08	; 8
     b34:	a4 81       	ldd	r26, Z+4	; 0x04
     b36:	b5 81       	ldd	r27, Z+5	; 0x05
     b38:	14 96       	adiw	r26, 0x04	; 4
     b3a:	1c 91       	ld	r17, X
     b3c:	c6 81       	ldd	r28, Z+6	; 0x06
     b3e:	d7 81       	ldd	r29, Z+7	; 0x07
     b40:	68 e5       	ldi	r22, 0x58	; 88
     b42:	70 e2       	ldi	r23, 0x20	; 32
     b44:	ce 01       	movw	r24, r28
     b46:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     b4a:	61 2f       	mov	r22, r17
     b4c:	ce 01       	movw	r24, r28
     b4e:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
     b52:	66 e0       	ldi	r22, 0x06	; 6
     b54:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	08 95       	ret

00000b60 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	ec 01       	movw	r28, r24
     b6c:	ef 81       	ldd	r30, Y+7	; 0x07
     b6e:	f8 85       	ldd	r31, Y+8	; 0x08
     b70:	a4 81       	ldd	r26, Z+4	; 0x04
     b72:	b5 81       	ldd	r27, Z+5	; 0x05
     b74:	14 96       	adiw	r26, 0x04	; 4
     b76:	fc 90       	ld	r15, X
     b78:	06 81       	ldd	r16, Z+6	; 0x06
     b7a:	17 81       	ldd	r17, Z+7	; 0x07
     b7c:	63 e6       	ldi	r22, 0x63	; 99
     b7e:	70 e2       	ldi	r23, 0x20	; 32
     b80:	c8 01       	movw	r24, r16
     b82:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
     b86:	6f 2d       	mov	r22, r15
     b88:	c8 01       	movw	r24, r16
     b8a:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
     b8e:	66 e0       	ldi	r22, 0x06	; 6
     b90:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
     b94:	8a 81       	ldd	r24, Y+2	; 0x02
     b96:	9b 81       	ldd	r25, Y+3	; 0x03
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	08 95       	ret

00000ba4 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	8c 01       	movw	r16, r24
     bae:	eb 01       	movw	r28, r22
     bb0:	e8 81       	ld	r30, Y
     bb2:	f9 81       	ldd	r31, Y+1	; 0x01
     bb4:	04 8c       	ldd	r0, Z+28	; 0x1c
     bb6:	f5 8d       	ldd	r31, Z+29	; 0x1d
     bb8:	e0 2d       	mov	r30, r0
     bba:	cb 01       	movw	r24, r22
     bbc:	19 95       	eicall
     bbe:	2a 85       	ldd	r18, Y+10	; 0x0a
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	82 17       	cp	r24, r18
     bc4:	93 07       	cpc	r25, r19
     bc6:	79 f4       	brne	.+30     	; 0xbe6 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
     bc8:	d8 01       	movw	r26, r16
     bca:	17 96       	adiw	r26, 0x07	; 7
     bcc:	ed 91       	ld	r30, X+
     bce:	fc 91       	ld	r31, X
     bd0:	18 97       	sbiw	r26, 0x08	; 8
     bd2:	04 80       	ldd	r0, Z+4	; 0x04
     bd4:	f5 81       	ldd	r31, Z+5	; 0x05
     bd6:	e0 2d       	mov	r30, r0
     bd8:	87 e0       	ldi	r24, 0x07	; 7
     bda:	83 83       	std	Z+3, r24	; 0x03
     bdc:	12 96       	adiw	r26, 0x02	; 2
     bde:	8d 91       	ld	r24, X+
     be0:	9c 91       	ld	r25, X
     be2:	13 97       	sbiw	r26, 0x03	; 3
     be4:	0e c0       	rjmp	.+28     	; 0xc02 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     be6:	d8 01       	movw	r26, r16
     be8:	17 96       	adiw	r26, 0x07	; 7
     bea:	ed 91       	ld	r30, X+
     bec:	fc 91       	ld	r31, X
     bee:	18 97       	sbiw	r26, 0x08	; 8
     bf0:	04 80       	ldd	r0, Z+4	; 0x04
     bf2:	f5 81       	ldd	r31, Z+5	; 0x05
     bf4:	e0 2d       	mov	r30, r0
     bf6:	82 e0       	ldi	r24, 0x02	; 2
     bf8:	83 83       	std	Z+3, r24	; 0x03
     bfa:	14 96       	adiw	r26, 0x04	; 4
     bfc:	8d 91       	ld	r24, X+
     bfe:	9c 91       	ld	r25, X
     c00:	15 97       	sbiw	r26, 0x05	; 5
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	1f 91       	pop	r17
     c08:	0f 91       	pop	r16
     c0a:	08 95       	ret

00000c0c <_ZN9I2CMaster11TransmitterC1EPS_>:
     c0c:	0f 93       	push	r16
     c0e:	1f 93       	push	r17
     c10:	cf 93       	push	r28
     c12:	df 93       	push	r29
     c14:	ec 01       	movw	r28, r24
     c16:	8b 01       	movw	r16, r22
     c18:	68 83       	st	Y, r22
     c1a:	79 83       	std	Y+1, r23	; 0x01
     c1c:	89 e0       	ldi	r24, 0x09	; 9
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     c24:	fc 01       	movw	r30, r24
     c26:	16 82       	std	Z+6, r1	; 0x06
     c28:	8f ea       	ldi	r24, 0xAF	; 175
     c2a:	90 e2       	ldi	r25, 0x20	; 32
     c2c:	80 83       	st	Z, r24
     c2e:	91 83       	std	Z+1, r25	; 0x01
     c30:	07 83       	std	Z+7, r16	; 0x07
     c32:	10 87       	std	Z+8, r17	; 0x08
     c34:	ec 83       	std	Y+4, r30	; 0x04
     c36:	fd 83       	std	Y+5, r31	; 0x05
     c38:	8b e0       	ldi	r24, 0x0B	; 11
     c3a:	90 e0       	ldi	r25, 0x00	; 0
     c3c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     c40:	fc 01       	movw	r30, r24
     c42:	89 89       	ldd	r24, Y+17	; 0x11
     c44:	9a 89       	ldd	r25, Y+18	; 0x12
     c46:	16 82       	std	Z+6, r1	; 0x06
     c48:	27 eb       	ldi	r18, 0xB7	; 183
     c4a:	30 e2       	ldi	r19, 0x20	; 32
     c4c:	20 83       	st	Z, r18
     c4e:	31 83       	std	Z+1, r19	; 0x01
     c50:	07 83       	std	Z+7, r16	; 0x07
     c52:	10 87       	std	Z+8, r17	; 0x08
     c54:	81 87       	std	Z+9, r24	; 0x09
     c56:	92 87       	std	Z+10, r25	; 0x0a
     c58:	ee 83       	std	Y+6, r30	; 0x06
     c5a:	ff 83       	std	Y+7, r31	; 0x07
     c5c:	89 e0       	ldi	r24, 0x09	; 9
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     c64:	fc 01       	movw	r30, r24
     c66:	16 82       	std	Z+6, r1	; 0x06
     c68:	87 ec       	ldi	r24, 0xC7	; 199
     c6a:	90 e2       	ldi	r25, 0x20	; 32
     c6c:	80 83       	st	Z, r24
     c6e:	91 83       	std	Z+1, r25	; 0x01
     c70:	07 83       	std	Z+7, r16	; 0x07
     c72:	10 87       	std	Z+8, r17	; 0x08
     c74:	e8 87       	std	Y+8, r30	; 0x08
     c76:	f9 87       	std	Y+9, r31	; 0x09
     c78:	89 e0       	ldi	r24, 0x09	; 9
     c7a:	90 e0       	ldi	r25, 0x00	; 0
     c7c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     c80:	fc 01       	movw	r30, r24
     c82:	16 82       	std	Z+6, r1	; 0x06
     c84:	87 ed       	ldi	r24, 0xD7	; 215
     c86:	90 e2       	ldi	r25, 0x20	; 32
     c88:	80 83       	st	Z, r24
     c8a:	91 83       	std	Z+1, r25	; 0x01
     c8c:	07 83       	std	Z+7, r16	; 0x07
     c8e:	10 87       	std	Z+8, r17	; 0x08
     c90:	ea 87       	std	Y+10, r30	; 0x0a
     c92:	fb 87       	std	Y+11, r31	; 0x0b
     c94:	89 e0       	ldi	r24, 0x09	; 9
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     c9c:	fc 01       	movw	r30, r24
     c9e:	16 82       	std	Z+6, r1	; 0x06
     ca0:	8f ee       	ldi	r24, 0xEF	; 239
     ca2:	90 e2       	ldi	r25, 0x20	; 32
     ca4:	80 83       	st	Z, r24
     ca6:	91 83       	std	Z+1, r25	; 0x01
     ca8:	07 83       	std	Z+7, r16	; 0x07
     caa:	10 87       	std	Z+8, r17	; 0x08
     cac:	ec 87       	std	Y+12, r30	; 0x0c
     cae:	fd 87       	std	Y+13, r31	; 0x0d
     cb0:	89 e0       	ldi	r24, 0x09	; 9
     cb2:	90 e0       	ldi	r25, 0x00	; 0
     cb4:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     cb8:	fc 01       	movw	r30, r24
     cba:	16 82       	std	Z+6, r1	; 0x06
     cbc:	87 ee       	ldi	r24, 0xE7	; 231
     cbe:	90 e2       	ldi	r25, 0x20	; 32
     cc0:	80 83       	st	Z, r24
     cc2:	91 83       	std	Z+1, r25	; 0x01
     cc4:	07 83       	std	Z+7, r16	; 0x07
     cc6:	10 87       	std	Z+8, r17	; 0x08
     cc8:	ee 87       	std	Y+14, r30	; 0x0e
     cca:	ff 87       	std	Y+15, r31	; 0x0f
     ccc:	80 e1       	ldi	r24, 0x10	; 16
     cce:	97 e2       	ldi	r25, 0x27	; 39
     cd0:	89 8b       	std	Y+17, r24	; 0x11
     cd2:	9a 8b       	std	Y+18, r25	; 0x12
     cd4:	8e 81       	ldd	r24, Y+6	; 0x06
     cd6:	9f 81       	ldd	r25, Y+7	; 0x07
     cd8:	ec 81       	ldd	r30, Y+4	; 0x04
     cda:	fd 81       	ldd	r31, Y+5	; 0x05
     cdc:	82 83       	std	Z+2, r24	; 0x02
     cde:	93 83       	std	Z+3, r25	; 0x03
     ce0:	84 83       	std	Z+4, r24	; 0x04
     ce2:	95 83       	std	Z+5, r25	; 0x05
     ce4:	8c 85       	ldd	r24, Y+12	; 0x0c
     ce6:	9d 85       	ldd	r25, Y+13	; 0x0d
     ce8:	28 85       	ldd	r18, Y+8	; 0x08
     cea:	39 85       	ldd	r19, Y+9	; 0x09
     cec:	ee 81       	ldd	r30, Y+6	; 0x06
     cee:	ff 81       	ldd	r31, Y+7	; 0x07
     cf0:	22 83       	std	Z+2, r18	; 0x02
     cf2:	33 83       	std	Z+3, r19	; 0x03
     cf4:	84 83       	std	Z+4, r24	; 0x04
     cf6:	95 83       	std	Z+5, r25	; 0x05
     cf8:	8a 85       	ldd	r24, Y+10	; 0x0a
     cfa:	9b 85       	ldd	r25, Y+11	; 0x0b
     cfc:	e8 85       	ldd	r30, Y+8	; 0x08
     cfe:	f9 85       	ldd	r31, Y+9	; 0x09
     d00:	82 83       	std	Z+2, r24	; 0x02
     d02:	93 83       	std	Z+3, r25	; 0x03
     d04:	84 83       	std	Z+4, r24	; 0x04
     d06:	95 83       	std	Z+5, r25	; 0x05
     d08:	8e 81       	ldd	r24, Y+6	; 0x06
     d0a:	9f 81       	ldd	r25, Y+7	; 0x07
     d0c:	2e 85       	ldd	r18, Y+14	; 0x0e
     d0e:	3f 85       	ldd	r19, Y+15	; 0x0f
     d10:	ea 85       	ldd	r30, Y+10	; 0x0a
     d12:	fb 85       	ldd	r31, Y+11	; 0x0b
     d14:	22 83       	std	Z+2, r18	; 0x02
     d16:	33 83       	std	Z+3, r19	; 0x03
     d18:	84 83       	std	Z+4, r24	; 0x04
     d1a:	95 83       	std	Z+5, r25	; 0x05
     d1c:	df 91       	pop	r29
     d1e:	cf 91       	pop	r28
     d20:	1f 91       	pop	r17
     d22:	0f 91       	pop	r16
     d24:	08 95       	ret

00000d26 <_ZN9I2CMaster8ReceiverC1EPS_>:
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	ec 01       	movw	r28, r24
     d30:	8b 01       	movw	r16, r22
     d32:	68 83       	st	Y, r22
     d34:	79 83       	std	Y+1, r23	; 0x01
     d36:	89 e0       	ldi	r24, 0x09	; 9
     d38:	90 e0       	ldi	r25, 0x00	; 0
     d3a:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     d3e:	fc 01       	movw	r30, r24
     d40:	16 82       	std	Z+6, r1	; 0x06
     d42:	8f ea       	ldi	r24, 0xAF	; 175
     d44:	90 e2       	ldi	r25, 0x20	; 32
     d46:	80 83       	st	Z, r24
     d48:	91 83       	std	Z+1, r25	; 0x01
     d4a:	07 83       	std	Z+7, r16	; 0x07
     d4c:	10 87       	std	Z+8, r17	; 0x08
     d4e:	ec 83       	std	Y+4, r30	; 0x04
     d50:	fd 83       	std	Y+5, r31	; 0x05
     d52:	8b e0       	ldi	r24, 0x0B	; 11
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     d5a:	fc 01       	movw	r30, r24
     d5c:	89 89       	ldd	r24, Y+17	; 0x11
     d5e:	9a 89       	ldd	r25, Y+18	; 0x12
     d60:	16 82       	std	Z+6, r1	; 0x06
     d62:	2f eb       	ldi	r18, 0xBF	; 191
     d64:	30 e2       	ldi	r19, 0x20	; 32
     d66:	20 83       	st	Z, r18
     d68:	31 83       	std	Z+1, r19	; 0x01
     d6a:	07 83       	std	Z+7, r16	; 0x07
     d6c:	10 87       	std	Z+8, r17	; 0x08
     d6e:	81 87       	std	Z+9, r24	; 0x09
     d70:	92 87       	std	Z+10, r25	; 0x0a
     d72:	ee 83       	std	Y+6, r30	; 0x06
     d74:	ff 83       	std	Y+7, r31	; 0x07
     d76:	89 e0       	ldi	r24, 0x09	; 9
     d78:	90 e0       	ldi	r25, 0x00	; 0
     d7a:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     d7e:	fc 01       	movw	r30, r24
     d80:	16 82       	std	Z+6, r1	; 0x06
     d82:	8f ec       	ldi	r24, 0xCF	; 207
     d84:	90 e2       	ldi	r25, 0x20	; 32
     d86:	80 83       	st	Z, r24
     d88:	91 83       	std	Z+1, r25	; 0x01
     d8a:	07 83       	std	Z+7, r16	; 0x07
     d8c:	10 87       	std	Z+8, r17	; 0x08
     d8e:	e8 87       	std	Y+8, r30	; 0x08
     d90:	f9 87       	std	Y+9, r31	; 0x09
     d92:	89 e0       	ldi	r24, 0x09	; 9
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     d9a:	fc 01       	movw	r30, r24
     d9c:	16 82       	std	Z+6, r1	; 0x06
     d9e:	8f ed       	ldi	r24, 0xDF	; 223
     da0:	90 e2       	ldi	r25, 0x20	; 32
     da2:	80 83       	st	Z, r24
     da4:	91 83       	std	Z+1, r25	; 0x01
     da6:	07 83       	std	Z+7, r16	; 0x07
     da8:	10 87       	std	Z+8, r17	; 0x08
     daa:	ea 87       	std	Y+10, r30	; 0x0a
     dac:	fb 87       	std	Y+11, r31	; 0x0b
     dae:	89 e0       	ldi	r24, 0x09	; 9
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     db6:	fc 01       	movw	r30, r24
     db8:	16 82       	std	Z+6, r1	; 0x06
     dba:	8f ee       	ldi	r24, 0xEF	; 239
     dbc:	90 e2       	ldi	r25, 0x20	; 32
     dbe:	80 83       	st	Z, r24
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	07 83       	std	Z+7, r16	; 0x07
     dc4:	10 87       	std	Z+8, r17	; 0x08
     dc6:	ec 87       	std	Y+12, r30	; 0x0c
     dc8:	fd 87       	std	Y+13, r31	; 0x0d
     dca:	89 e0       	ldi	r24, 0x09	; 9
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     dd2:	fc 01       	movw	r30, r24
     dd4:	16 82       	std	Z+6, r1	; 0x06
     dd6:	87 ee       	ldi	r24, 0xE7	; 231
     dd8:	90 e2       	ldi	r25, 0x20	; 32
     dda:	80 83       	st	Z, r24
     ddc:	91 83       	std	Z+1, r25	; 0x01
     dde:	07 83       	std	Z+7, r16	; 0x07
     de0:	10 87       	std	Z+8, r17	; 0x08
     de2:	ee 87       	std	Y+14, r30	; 0x0e
     de4:	ff 87       	std	Y+15, r31	; 0x0f
     de6:	80 e1       	ldi	r24, 0x10	; 16
     de8:	97 e2       	ldi	r25, 0x27	; 39
     dea:	89 8b       	std	Y+17, r24	; 0x11
     dec:	9a 8b       	std	Y+18, r25	; 0x12
     dee:	8e 81       	ldd	r24, Y+6	; 0x06
     df0:	9f 81       	ldd	r25, Y+7	; 0x07
     df2:	ec 81       	ldd	r30, Y+4	; 0x04
     df4:	fd 81       	ldd	r31, Y+5	; 0x05
     df6:	82 83       	std	Z+2, r24	; 0x02
     df8:	93 83       	std	Z+3, r25	; 0x03
     dfa:	84 83       	std	Z+4, r24	; 0x04
     dfc:	95 83       	std	Z+5, r25	; 0x05
     dfe:	8c 85       	ldd	r24, Y+12	; 0x0c
     e00:	9d 85       	ldd	r25, Y+13	; 0x0d
     e02:	28 85       	ldd	r18, Y+8	; 0x08
     e04:	39 85       	ldd	r19, Y+9	; 0x09
     e06:	ee 81       	ldd	r30, Y+6	; 0x06
     e08:	ff 81       	ldd	r31, Y+7	; 0x07
     e0a:	22 83       	std	Z+2, r18	; 0x02
     e0c:	33 83       	std	Z+3, r19	; 0x03
     e0e:	84 83       	std	Z+4, r24	; 0x04
     e10:	95 83       	std	Z+5, r25	; 0x05
     e12:	8a 85       	ldd	r24, Y+10	; 0x0a
     e14:	9b 85       	ldd	r25, Y+11	; 0x0b
     e16:	e8 85       	ldd	r30, Y+8	; 0x08
     e18:	f9 85       	ldd	r31, Y+9	; 0x09
     e1a:	82 83       	std	Z+2, r24	; 0x02
     e1c:	93 83       	std	Z+3, r25	; 0x03
     e1e:	84 83       	std	Z+4, r24	; 0x04
     e20:	95 83       	std	Z+5, r25	; 0x05
     e22:	8e 81       	ldd	r24, Y+6	; 0x06
     e24:	9f 81       	ldd	r25, Y+7	; 0x07
     e26:	2e 85       	ldd	r18, Y+14	; 0x0e
     e28:	3f 85       	ldd	r19, Y+15	; 0x0f
     e2a:	ea 85       	ldd	r30, Y+10	; 0x0a
     e2c:	fb 85       	ldd	r31, Y+11	; 0x0b
     e2e:	22 83       	std	Z+2, r18	; 0x02
     e30:	33 83       	std	Z+3, r19	; 0x03
     e32:	84 83       	std	Z+4, r24	; 0x04
     e34:	95 83       	std	Z+5, r25	; 0x05
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	1f 91       	pop	r17
     e3c:	0f 91       	pop	r16
     e3e:	08 95       	ret

00000e40 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     e40:	0f 93       	push	r16
     e42:	1f 93       	push	r17
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	ec 01       	movw	r28, r24
     e4a:	8b 01       	movw	r16, r22
     e4c:	8c 81       	ldd	r24, Y+4	; 0x04
     e4e:	9d 81       	ldd	r25, Y+5	; 0x05
     e50:	8a 83       	std	Y+2, r24	; 0x02
     e52:	9b 83       	std	Y+3, r25	; 0x03
     e54:	2e 85       	ldd	r18, Y+14	; 0x0e
     e56:	3f 85       	ldd	r19, Y+15	; 0x0f
     e58:	82 17       	cp	r24, r18
     e5a:	93 07       	cpc	r25, r19
     e5c:	d9 f0       	breq	.+54     	; 0xe94 <_ZN9I2CMaster11Transmitter3runER6Packet+0x54>
     e5e:	2c 85       	ldd	r18, Y+12	; 0x0c
     e60:	3d 85       	ldd	r19, Y+13	; 0x0d
     e62:	82 17       	cp	r24, r18
     e64:	93 07       	cpc	r25, r19
     e66:	31 f4       	brne	.+12     	; 0xe74 <_ZN9I2CMaster11Transmitter3runER6Packet+0x34>
     e68:	17 c0       	rjmp	.+46     	; 0xe98 <_ZN9I2CMaster11Transmitter3runER6Packet+0x58>
     e6a:	2c 85       	ldd	r18, Y+12	; 0x0c
     e6c:	3d 85       	ldd	r19, Y+13	; 0x0d
     e6e:	28 17       	cp	r18, r24
     e70:	39 07       	cpc	r19, r25
     e72:	99 f0       	breq	.+38     	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e74:	dc 01       	movw	r26, r24
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	01 90       	ld	r0, Z+
     e7c:	f0 81       	ld	r31, Z
     e7e:	e0 2d       	mov	r30, r0
     e80:	b8 01       	movw	r22, r16
     e82:	19 95       	eicall
     e84:	8a 83       	std	Y+2, r24	; 0x02
     e86:	9b 83       	std	Y+3, r25	; 0x03
     e88:	2e 85       	ldd	r18, Y+14	; 0x0e
     e8a:	3f 85       	ldd	r19, Y+15	; 0x0f
     e8c:	28 17       	cp	r18, r24
     e8e:	39 07       	cpc	r19, r25
     e90:	61 f7       	brne	.-40     	; 0xe6a <_ZN9I2CMaster11Transmitter3runER6Packet+0x2a>
     e92:	03 c0       	rjmp	.+6      	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e94:	c9 01       	movw	r24, r18
     e96:	01 c0       	rjmp	.+2      	; 0xe9a <_ZN9I2CMaster11Transmitter3runER6Packet+0x5a>
     e98:	c9 01       	movw	r24, r18
     e9a:	dc 01       	movw	r26, r24
     e9c:	ed 91       	ld	r30, X+
     e9e:	fc 91       	ld	r31, X
     ea0:	01 90       	ld	r0, Z+
     ea2:	f0 81       	ld	r31, Z
     ea4:	e0 2d       	mov	r30, r0
     ea6:	b8 01       	movw	r22, r16
     ea8:	19 95       	eicall
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	4a 81       	ldd	r20, Y+2	; 0x02
     eae:	5b 81       	ldd	r21, Y+3	; 0x03
     eb0:	2e 85       	ldd	r18, Y+14	; 0x0e
     eb2:	3f 85       	ldd	r19, Y+15	; 0x0f
     eb4:	42 17       	cp	r20, r18
     eb6:	53 07       	cpc	r21, r19
     eb8:	09 f0       	breq	.+2      	; 0xebc <_ZN9I2CMaster11Transmitter3runER6Packet+0x7c>
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	df 91       	pop	r29
     ebe:	cf 91       	pop	r28
     ec0:	1f 91       	pop	r17
     ec2:	0f 91       	pop	r16
     ec4:	08 95       	ret

00000ec6 <_ZN9I2CMaster8Receiver3runER6Packet>:
     ec6:	0f 93       	push	r16
     ec8:	1f 93       	push	r17
     eca:	cf 93       	push	r28
     ecc:	df 93       	push	r29
     ece:	ec 01       	movw	r28, r24
     ed0:	8b 01       	movw	r16, r22
     ed2:	8c 81       	ldd	r24, Y+4	; 0x04
     ed4:	9d 81       	ldd	r25, Y+5	; 0x05
     ed6:	8a 83       	std	Y+2, r24	; 0x02
     ed8:	9b 83       	std	Y+3, r25	; 0x03
     eda:	2e 85       	ldd	r18, Y+14	; 0x0e
     edc:	3f 85       	ldd	r19, Y+15	; 0x0f
     ede:	82 17       	cp	r24, r18
     ee0:	93 07       	cpc	r25, r19
     ee2:	d9 f0       	breq	.+54     	; 0xf1a <_ZN9I2CMaster8Receiver3runER6Packet+0x54>
     ee4:	2c 85       	ldd	r18, Y+12	; 0x0c
     ee6:	3d 85       	ldd	r19, Y+13	; 0x0d
     ee8:	82 17       	cp	r24, r18
     eea:	93 07       	cpc	r25, r19
     eec:	31 f4       	brne	.+12     	; 0xefa <_ZN9I2CMaster8Receiver3runER6Packet+0x34>
     eee:	17 c0       	rjmp	.+46     	; 0xf1e <_ZN9I2CMaster8Receiver3runER6Packet+0x58>
     ef0:	2c 85       	ldd	r18, Y+12	; 0x0c
     ef2:	3d 85       	ldd	r19, Y+13	; 0x0d
     ef4:	28 17       	cp	r18, r24
     ef6:	39 07       	cpc	r19, r25
     ef8:	99 f0       	breq	.+38     	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     efa:	dc 01       	movw	r26, r24
     efc:	ed 91       	ld	r30, X+
     efe:	fc 91       	ld	r31, X
     f00:	01 90       	ld	r0, Z+
     f02:	f0 81       	ld	r31, Z
     f04:	e0 2d       	mov	r30, r0
     f06:	b8 01       	movw	r22, r16
     f08:	19 95       	eicall
     f0a:	8a 83       	std	Y+2, r24	; 0x02
     f0c:	9b 83       	std	Y+3, r25	; 0x03
     f0e:	2e 85       	ldd	r18, Y+14	; 0x0e
     f10:	3f 85       	ldd	r19, Y+15	; 0x0f
     f12:	28 17       	cp	r18, r24
     f14:	39 07       	cpc	r19, r25
     f16:	61 f7       	brne	.-40     	; 0xef0 <_ZN9I2CMaster8Receiver3runER6Packet+0x2a>
     f18:	03 c0       	rjmp	.+6      	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f1a:	c9 01       	movw	r24, r18
     f1c:	01 c0       	rjmp	.+2      	; 0xf20 <_ZN9I2CMaster8Receiver3runER6Packet+0x5a>
     f1e:	c9 01       	movw	r24, r18
     f20:	dc 01       	movw	r26, r24
     f22:	ed 91       	ld	r30, X+
     f24:	fc 91       	ld	r31, X
     f26:	01 90       	ld	r0, Z+
     f28:	f0 81       	ld	r31, Z
     f2a:	e0 2d       	mov	r30, r0
     f2c:	b8 01       	movw	r22, r16
     f2e:	19 95       	eicall
     f30:	c8 01       	movw	r24, r16
     f32:	df 91       	pop	r29
     f34:	cf 91       	pop	r28
     f36:	1f 91       	pop	r17
     f38:	0f 91       	pop	r16
     f3a:	08 95       	ret

00000f3c <_ZN9I2CMaster12set_baudrateEm>:
     f3c:	cf 93       	push	r28
     f3e:	df 93       	push	r29
     f40:	ec 01       	movw	r28, r24
     f42:	9a 01       	movw	r18, r20
     f44:	ab 01       	movw	r20, r22
     f46:	22 0f       	add	r18, r18
     f48:	33 1f       	adc	r19, r19
     f4a:	44 1f       	adc	r20, r20
     f4c:	55 1f       	adc	r21, r21
     f4e:	60 e0       	ldi	r22, 0x00	; 0
     f50:	78 e4       	ldi	r23, 0x48	; 72
     f52:	88 ee       	ldi	r24, 0xE8	; 232
     f54:	91 e0       	ldi	r25, 0x01	; 1
     f56:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
     f5a:	25 50       	subi	r18, 0x05	; 5
     f5c:	2a 87       	std	Y+10, r18	; 0x0a
     f5e:	ec 81       	ldd	r30, Y+4	; 0x04
     f60:	fd 81       	ldd	r31, Y+5	; 0x05
     f62:	25 83       	std	Z+5, r18	; 0x05
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	08 95       	ret

00000f6a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
     f6a:	ef 92       	push	r14
     f6c:	ff 92       	push	r15
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	ec 01       	movw	r28, r24
     f78:	7b 01       	movw	r14, r22
     f7a:	ba 01       	movw	r22, r20
     f7c:	a9 01       	movw	r20, r18
     f7e:	ec 82       	std	Y+4, r14	; 0x04
     f80:	fd 82       	std	Y+5, r15	; 0x05
     f82:	0e 83       	std	Y+6, r16	; 0x06
     f84:	1f 83       	std	Y+7, r17	; 0x07
     f86:	4b 87       	std	Y+11, r20	; 0x0b
     f88:	5c 87       	std	Y+12, r21	; 0x0c
     f8a:	6d 87       	std	Y+13, r22	; 0x0d
     f8c:	7e 87       	std	Y+14, r23	; 0x0e
     f8e:	80 e8       	ldi	r24, 0x80	; 128
     f90:	e8 16       	cp	r14, r24
     f92:	84 e0       	ldi	r24, 0x04	; 4
     f94:	f8 06       	cpc	r15, r24
     f96:	29 f4       	brne	.+10     	; 0xfa2 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
     f98:	80 e4       	ldi	r24, 0x40	; 64
     f9a:	96 e0       	ldi	r25, 0x06	; 6
     f9c:	88 87       	std	Y+8, r24	; 0x08
     f9e:	99 87       	std	Y+9, r25	; 0x09
     fa0:	09 c0       	rjmp	.+18     	; 0xfb4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     fa2:	e0 ea       	ldi	r30, 0xA0	; 160
     fa4:	ee 16       	cp	r14, r30
     fa6:	e4 e0       	ldi	r30, 0x04	; 4
     fa8:	fe 06       	cpc	r15, r30
     faa:	21 f4       	brne	.+8      	; 0xfb4 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
     fac:	80 e8       	ldi	r24, 0x80	; 128
     fae:	96 e0       	ldi	r25, 0x06	; 6
     fb0:	88 87       	std	Y+8, r24	; 0x08
     fb2:	99 87       	std	Y+9, r25	; 0x09
     fb4:	e8 85       	ldd	r30, Y+8	; 0x08
     fb6:	f9 85       	ldd	r31, Y+9	; 0x09
     fb8:	83 e0       	ldi	r24, 0x03	; 3
     fba:	81 83       	std	Z+1, r24	; 0x01
     fbc:	e8 85       	ldd	r30, Y+8	; 0x08
     fbe:	f9 85       	ldd	r31, Y+9	; 0x09
     fc0:	88 e3       	ldi	r24, 0x38	; 56
     fc2:	80 8b       	std	Z+16, r24	; 0x10
     fc4:	e8 85       	ldd	r30, Y+8	; 0x08
     fc6:	f9 85       	ldd	r31, Y+9	; 0x09
     fc8:	81 8b       	std	Z+17, r24	; 0x11
     fca:	82 e0       	ldi	r24, 0x02	; 2
     fcc:	f7 01       	movw	r30, r14
     fce:	82 83       	std	Z+2, r24	; 0x02
     fd0:	ce 01       	movw	r24, r28
     fd2:	0e 94 9e 07 	call	0xf3c	; 0xf3c <_ZN9I2CMaster12set_baudrateEm>
     fd6:	f7 01       	movw	r30, r14
     fd8:	84 81       	ldd	r24, Z+4	; 0x04
     fda:	8d 6c       	ori	r24, 0xCD	; 205
     fdc:	84 83       	std	Z+4, r24	; 0x04
     fde:	88 e0       	ldi	r24, 0x08	; 8
     fe0:	81 83       	std	Z+1, r24	; 0x01
     fe2:	83 e1       	ldi	r24, 0x13	; 19
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     fea:	7c 01       	movw	r14, r24
     fec:	be 01       	movw	r22, r28
     fee:	0e 94 06 06 	call	0xc0c	; 0xc0c <_ZN9I2CMaster11TransmitterC1EPS_>
     ff2:	e8 82       	st	Y, r14
     ff4:	f9 82       	std	Y+1, r15	; 0x01
     ff6:	84 e1       	ldi	r24, 0x14	; 20
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
     ffe:	7c 01       	movw	r14, r24
    1000:	be 01       	movw	r22, r28
    1002:	0e 94 93 06 	call	0xd26	; 0xd26 <_ZN9I2CMaster8ReceiverC1EPS_>
    1006:	ea 82       	std	Y+2, r14	; 0x02
    1008:	fb 82       	std	Y+3, r15	; 0x03
    100a:	0e 80       	ldd	r0, Y+6	; 0x06
    100c:	df 81       	ldd	r29, Y+7	; 0x07
    100e:	c0 2d       	mov	r28, r0
    1010:	65 e8       	ldi	r22, 0x85	; 133
    1012:	70 e2       	ldi	r23, 0x20	; 32
    1014:	ce 01       	movw	r24, r28
    1016:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    101a:	66 e0       	ldi	r22, 0x06	; 6
    101c:	ce 01       	movw	r24, r28
    101e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1022:	df 91       	pop	r29
    1024:	cf 91       	pop	r28
    1026:	1f 91       	pop	r17
    1028:	0f 91       	pop	r16
    102a:	ff 90       	pop	r15
    102c:	ef 90       	pop	r14
    102e:	08 95       	ret

00001030 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1030:	dc 01       	movw	r26, r24
    1032:	14 96       	adiw	r26, 0x04	; 4
    1034:	ed 91       	ld	r30, X+
    1036:	fc 91       	ld	r31, X
    1038:	15 97       	sbiw	r26, 0x05	; 5
    103a:	83 81       	ldd	r24, Z+3	; 0x03
    103c:	81 60       	ori	r24, 0x01	; 1
    103e:	83 83       	std	Z+3, r24	; 0x03
    1040:	08 95       	ret

00001042 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1042:	0f 93       	push	r16
    1044:	1f 93       	push	r17
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
    104a:	ec 01       	movw	r28, r24
    104c:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    104e:	db 01       	movw	r26, r22
    1050:	ed 91       	ld	r30, X+
    1052:	fc 91       	ld	r31, X
    1054:	02 84       	ldd	r0, Z+10	; 0x0a
    1056:	f3 85       	ldd	r31, Z+11	; 0x0b
    1058:	e0 2d       	mov	r30, r0
    105a:	00 e0       	ldi	r16, 0x00	; 0
    105c:	10 e0       	ldi	r17, 0x00	; 0
    105e:	b8 01       	movw	r22, r16
    1060:	19 95       	eicall
  driver_->send_start();
    1062:	8f 81       	ldd	r24, Y+7	; 0x07
    1064:	98 85       	ldd	r25, Y+8	; 0x08
    1066:	0e 94 18 08 	call	0x1030	; 0x1030 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    106a:	ef 81       	ldd	r30, Y+7	; 0x07
    106c:	f8 85       	ldd	r31, Y+8	; 0x08
    106e:	04 80       	ldd	r0, Z+4	; 0x04
    1070:	f5 81       	ldd	r31, Z+5	; 0x05
    1072:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1074:	d8 01       	movw	r26, r16
    1076:	8c 91       	ld	r24, X
    1078:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    107a:	8a 81       	ldd	r24, Y+2	; 0x02
    107c:	9b 81       	ldd	r25, Y+3	; 0x03
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	1f 91       	pop	r17
    1084:	0f 91       	pop	r16
    1086:	08 95       	ret

00001088 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
		 */
		virtual bool ISR_butt_in (const data_type& item)
		{
			(void) item;                    // This just shuts up a compiler warning
			return (false);
		}
    1088:	db 01       	movw	r26, r22
    108a:	bc 01       	movw	r22, r24
    108c:	6e 5f       	subi	r22, 0xFE	; 254
    108e:	7f 4f       	sbci	r23, 0xFF	; 255
    1090:	ed 91       	ld	r30, X+
    1092:	fc 91       	ld	r31, X
    1094:	11 97       	sbiw	r26, 0x01	; 1
    1096:	01 90       	ld	r0, Z+
    1098:	f0 81       	ld	r31, Z
    109a:	e0 2d       	mov	r30, r0
    109c:	cd 01       	movw	r24, r26
    109e:	19 95       	eicall
    10a0:	08 95       	ret

000010a2 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    10a2:	fc 01       	movw	r30, r24
    10a4:	84 81       	ldd	r24, Z+4	; 0x04
    10a6:	95 81       	ldd	r25, Z+5	; 0x05
    10a8:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
		}
    10ac:	90 e0       	ldi	r25, 0x00	; 0
    10ae:	08 95       	ret

000010b0 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    10b0:	fc 01       	movw	r30, r24
    10b2:	84 81       	ldd	r24, Z+4	; 0x04
    10b4:	95 81       	ldd	r25, Z+5	; 0x05
    10b6:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    10ba:	91 e0       	ldi	r25, 0x01	; 1
    10bc:	81 11       	cpse	r24, r1
    10be:	01 c0       	rjmp	.+2      	; 0x10c2 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    10c0:	90 e0       	ldi	r25, 0x00	; 0
		}
    10c2:	89 2f       	mov	r24, r25
    10c4:	08 95       	ret

000010c6 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    10c6:	fc 01       	movw	r30, r24
    10c8:	84 81       	ldd	r24, Z+4	; 0x04
    10ca:	95 81       	ldd	r25, Z+5	; 0x05
    10cc:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    10d0:	91 e0       	ldi	r25, 0x01	; 1
    10d2:	81 11       	cpse	r24, r1
    10d4:	90 e0       	ldi	r25, 0x00	; 0
		}
    10d6:	89 2f       	mov	r24, r25
    10d8:	08 95       	ret

000010da <_ZN9frt_queueIhE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    10da:	fc 01       	movw	r30, r24
    10dc:	84 81       	ldd	r24, Z+4	; 0x04
    10de:	95 81       	ldd	r25, Z+5	; 0x05
    10e0:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
		}
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	08 95       	ret

000010e8 <_ZN9frt_queueIhE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    10e8:	fc 01       	movw	r30, r24
    10ea:	84 81       	ldd	r24, Z+4	; 0x04
    10ec:	95 81       	ldd	r25, Z+5	; 0x05
    10ee:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	81 11       	cpse	r24, r1
    10f6:	01 c0       	rjmp	.+2      	; 0x10fa <_ZN9frt_queueIhE9not_emptyEv+0x12>
    10f8:	90 e0       	ldi	r25, 0x00	; 0
		}
    10fa:	89 2f       	mov	r24, r25
    10fc:	08 95       	ret

000010fe <_ZN9frt_queueIhE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    10fe:	fc 01       	movw	r30, r24
    1100:	84 81       	ldd	r24, Z+4	; 0x04
    1102:	95 81       	ldd	r25, Z+5	; 0x05
    1104:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    1108:	91 e0       	ldi	r25, 0x01	; 1
    110a:	81 11       	cpse	r24, r1
    110c:	90 e0       	ldi	r25, 0x00	; 0
		}
    110e:	89 2f       	mov	r24, r25
    1110:	08 95       	ret

00001112 <_ZN9frt_queueIhE10get_a_copyERh>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    1112:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    1114:	01 e0       	ldi	r16, 0x01	; 1
    1116:	2f ef       	ldi	r18, 0xFF	; 255
    1118:	3f ef       	ldi	r19, 0xFF	; 255
    111a:	a9 01       	movw	r20, r18
    111c:	fc 01       	movw	r30, r24
    111e:	84 81       	ldd	r24, Z+4	; 0x04
    1120:	95 81       	ldd	r25, Z+5	; 0x05
    1122:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    1126:	0f 91       	pop	r16
    1128:	08 95       	ret

0000112a <_ZN9frt_queueIhE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    112a:	0f 93       	push	r16
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	1f 92       	push	r1
    1132:	cd b7       	in	r28, 0x3d	; 61
    1134:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    1136:	01 e0       	ldi	r16, 0x01	; 1
    1138:	2f ef       	ldi	r18, 0xFF	; 255
    113a:	3f ef       	ldi	r19, 0xFF	; 255
    113c:	a9 01       	movw	r20, r18
    113e:	be 01       	movw	r22, r28
    1140:	6f 5f       	subi	r22, 0xFF	; 255
    1142:	7f 4f       	sbci	r23, 0xFF	; 255
    1144:	fc 01       	movw	r30, r24
    1146:	84 81       	ldd	r24, Z+4	; 0x04
    1148:	95 81       	ldd	r25, Z+5	; 0x05
    114a:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	0f 90       	pop	r0
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	0f 91       	pop	r16
    1158:	08 95       	ret

0000115a <_ZN9frt_queueIhE3getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    115a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    115c:	00 e0       	ldi	r16, 0x00	; 0
    115e:	2f ef       	ldi	r18, 0xFF	; 255
    1160:	3f ef       	ldi	r19, 0xFF	; 255
    1162:	a9 01       	movw	r20, r18
    1164:	fc 01       	movw	r30, r24
    1166:	84 81       	ldd	r24, Z+4	; 0x04
    1168:	95 81       	ldd	r25, Z+5	; 0x05
    116a:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    116e:	0f 91       	pop	r16
    1170:	08 95       	ret

00001172 <_ZN9frt_queueIhE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    1172:	0f 93       	push	r16
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	1f 92       	push	r1
    117a:	cd b7       	in	r28, 0x3d	; 61
    117c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    117e:	00 e0       	ldi	r16, 0x00	; 0
    1180:	2f ef       	ldi	r18, 0xFF	; 255
    1182:	3f ef       	ldi	r19, 0xFF	; 255
    1184:	a9 01       	movw	r20, r18
    1186:	be 01       	movw	r22, r28
    1188:	6f 5f       	subi	r22, 0xFF	; 255
    118a:	7f 4f       	sbci	r23, 0xFF	; 255
    118c:	fc 01       	movw	r30, r24
    118e:	84 81       	ldd	r24, Z+4	; 0x04
    1190:	95 81       	ldd	r25, Z+5	; 0x05
    1192:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    1196:	89 81       	ldd	r24, Y+1	; 0x01
    1198:	0f 90       	pop	r0
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	0f 91       	pop	r16
    11a0:	08 95       	ret

000011a2 <_ZN9frt_queueIhE7ISR_getEPh>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    11a2:	cf 93       	push	r28
    11a4:	df 93       	push	r29
    11a6:	1f 92       	push	r1
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    11ac:	ae 01       	movw	r20, r28
    11ae:	4f 5f       	subi	r20, 0xFF	; 255
    11b0:	5f 4f       	sbci	r21, 0xFF	; 255
    11b2:	fc 01       	movw	r30, r24
    11b4:	84 81       	ldd	r24, Z+4	; 0x04
    11b6:	95 81       	ldd	r25, Z+5	; 0x05
    11b8:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
}
    11bc:	0f 90       	pop	r0
    11be:	df 91       	pop	r29
    11c0:	cf 91       	pop	r28
    11c2:	08 95       	ret

000011c4 <_ZN9frt_queueIhE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    11c4:	cf 93       	push	r28
    11c6:	df 93       	push	r29
    11c8:	1f 92       	push	r1
    11ca:	1f 92       	push	r1
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    11d0:	ae 01       	movw	r20, r28
    11d2:	4e 5f       	subi	r20, 0xFE	; 254
    11d4:	5f 4f       	sbci	r21, 0xFF	; 255
    11d6:	be 01       	movw	r22, r28
    11d8:	6f 5f       	subi	r22, 0xFF	; 255
    11da:	7f 4f       	sbci	r23, 0xFF	; 255
    11dc:	fc 01       	movw	r30, r24
    11de:	84 81       	ldd	r24, Z+4	; 0x04
    11e0:	95 81       	ldd	r25, Z+5	; 0x05
    11e2:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
	return (recv_item);
}
    11e6:	89 81       	ldd	r24, Y+1	; 0x01
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	08 95       	ret

000011f2 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    11f2:	cf 93       	push	r28
    11f4:	df 93       	push	r29
    11f6:	1f 92       	push	r1
    11f8:	cd b7       	in	r28, 0x3d	; 61
    11fa:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    11fc:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    11fe:	21 e0       	ldi	r18, 0x01	; 1
    1200:	ae 01       	movw	r20, r28
    1202:	4f 5f       	subi	r20, 0xFF	; 255
    1204:	5f 4f       	sbci	r21, 0xFF	; 255
    1206:	fc 01       	movw	r30, r24
    1208:	84 81       	ldd	r24, Z+4	; 0x04
    120a:	95 81       	ldd	r25, Z+5	; 0x05
    120c:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1210:	91 e0       	ldi	r25, 0x01	; 1
    1212:	81 11       	cpse	r24, r1
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    1216:	90 e0       	ldi	r25, 0x00	; 0
}
    1218:	89 2f       	mov	r24, r25
    121a:	0f 90       	pop	r0
    121c:	df 91       	pop	r29
    121e:	cf 91       	pop	r28
    1220:	08 95       	ret

00001222 <_ZN9frt_queueIhE7ISR_putERKh>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	1f 92       	push	r1
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    122c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	ae 01       	movw	r20, r28
    1232:	4f 5f       	subi	r20, 0xFF	; 255
    1234:	5f 4f       	sbci	r21, 0xFF	; 255
    1236:	fc 01       	movw	r30, r24
    1238:	84 81       	ldd	r24, Z+4	; 0x04
    123a:	95 81       	ldd	r25, Z+5	; 0x05
    123c:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    1240:	91 e0       	ldi	r25, 0x01	; 1
    1242:	81 11       	cpse	r24, r1
    1244:	01 c0       	rjmp	.+2      	; 0x1248 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    1246:	90 e0       	ldi	r25, 0x00	; 0
}
    1248:	89 2f       	mov	r24, r25
    124a:	0f 90       	pop	r0
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <_ZN9frt_queueIhE7butt_inERKh>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    1252:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    1254:	fc 01       	movw	r30, r24
    1256:	26 81       	ldd	r18, Z+6	; 0x06
    1258:	37 81       	ldd	r19, Z+7	; 0x07
    125a:	40 85       	ldd	r20, Z+8	; 0x08
    125c:	51 85       	ldd	r21, Z+9	; 0x09
    125e:	01 e0       	ldi	r16, 0x01	; 1
    1260:	84 81       	ldd	r24, Z+4	; 0x04
    1262:	95 81       	ldd	r25, Z+5	; 0x05
    1264:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    1268:	91 e0       	ldi	r25, 0x01	; 1
    126a:	81 11       	cpse	r24, r1
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    126e:	90 e0       	ldi	r25, 0x00	; 0
		}
    1270:	89 2f       	mov	r24, r25
    1272:	0f 91       	pop	r16
    1274:	08 95       	ret

00001276 <_ZN9frt_queueIhE3putERKh>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    1276:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    1278:	fc 01       	movw	r30, r24
    127a:	26 81       	ldd	r18, Z+6	; 0x06
    127c:	37 81       	ldd	r19, Z+7	; 0x07
    127e:	40 85       	ldd	r20, Z+8	; 0x08
    1280:	51 85       	ldd	r21, Z+9	; 0x09
    1282:	00 e0       	ldi	r16, 0x00	; 0
    1284:	84 81       	ldd	r24, Z+4	; 0x04
    1286:	95 81       	ldd	r25, Z+5	; 0x05
    1288:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    128c:	91 e0       	ldi	r25, 0x01	; 1
    128e:	81 11       	cpse	r24, r1
    1290:	01 c0       	rjmp	.+2      	; 0x1294 <_ZN9frt_queueIhE3putERKh+0x1e>
    1292:	90 e0       	ldi	r25, 0x00	; 0
		}
    1294:	89 2f       	mov	r24, r25
    1296:	0f 91       	pop	r16
    1298:	08 95       	ret

0000129a <_ZN6MB1202C1EP9I2CMasterP8emstream>:
//-------------------------------------------------------------------------------------
/** This constructor creates an object to use when interacting with the SPI registers on the MAX31855
    Thermocouple Analog to Digital Converter chip.
 *  @param SPIM A pointer to an SPI_master object
 */
MB1202::MB1202(I2CMaster * d, emstream * s)
    129a:	3f 92       	push	r3
    129c:	4f 92       	push	r4
    129e:	5f 92       	push	r5
    12a0:	6f 92       	push	r6
    12a2:	7f 92       	push	r7
    12a4:	8f 92       	push	r8
    12a6:	9f 92       	push	r9
    12a8:	af 92       	push	r10
    12aa:	bf 92       	push	r11
    12ac:	cf 92       	push	r12
    12ae:	df 92       	push	r13
    12b0:	ef 92       	push	r14
    12b2:	ff 92       	push	r15
    12b4:	0f 93       	push	r16
    12b6:	1f 93       	push	r17
    12b8:	cf 93       	push	r28
    12ba:	df 93       	push	r29
    12bc:	8c 01       	movw	r16, r24
    12be:	7b 01       	movw	r14, r22
    12c0:	6a 01       	movw	r12, r20
  : driver_(d),
  	p_serial(s),
  	i2cAgent_(new I2CAgent(s, outPacketSize_, inPacketSize_)),
  	slaveAddr_(SLAVE_ADDR),
  	rangeCommand_(new RangeCommand())
    12c2:	dc 01       	movw	r26, r24
    12c4:	6d 93       	st	X+, r22
    12c6:	7c 93       	st	X, r23
    12c8:	11 97       	sbiw	r26, 0x01	; 1
    12ca:	12 96       	adiw	r26, 0x02	; 2
    12cc:	4d 93       	st	X+, r20
    12ce:	5c 93       	st	X, r21
    12d0:	13 97       	sbiw	r26, 0x03	; 3
    12d2:	81 e2       	ldi	r24, 0x21	; 33
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    12da:	ec 01       	movw	r28, r24
class CommAgent
{
public:
  CommAgent( uint8_t outPacketSize, uint8_t inPacketSize)
    : inPacket_(inPacketSize,NULL,10),
      outPacket_(outPacketSize,NULL,10)
    12dc:	8f e3       	ldi	r24, 0x3F	; 63
    12de:	91 e2       	ldi	r25, 0x21	; 33
    12e0:	88 83       	st	Y, r24
    12e2:	99 83       	std	Y+1, r25	; 0x01

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    12e4:	1c 82       	std	Y+4, r1	; 0x04
    12e6:	1d 82       	std	Y+5, r1	; 0x05
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    12e8:	0f 2e       	mov	r0, r31
    12ea:	f7 ef       	ldi	r31, 0xF7	; 247
    12ec:	af 2e       	mov	r10, r31
    12ee:	f0 e2       	ldi	r31, 0x20	; 32
    12f0:	bf 2e       	mov	r11, r31
    12f2:	f0 2d       	mov	r31, r0
    12f4:	aa 82       	std	Y+2, r10	; 0x02
    12f6:	bb 82       	std	Y+3, r11	; 0x03
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    12f8:	40 e0       	ldi	r20, 0x00	; 0
    12fa:	61 e0       	ldi	r22, 0x01	; 1
    12fc:	82 e0       	ldi	r24, 0x02	; 2
    12fe:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    1302:	8e 83       	std	Y+6, r24	; 0x06
    1304:	9f 83       	std	Y+7, r25	; 0x07

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    1306:	0f 2e       	mov	r0, r31
    1308:	fa e0       	ldi	r31, 0x0A	; 10
    130a:	4f 2e       	mov	r4, r31
    130c:	51 2c       	mov	r5, r1
    130e:	61 2c       	mov	r6, r1
    1310:	71 2c       	mov	r7, r1
    1312:	f0 2d       	mov	r31, r0
    1314:	48 86       	std	Y+8, r4	; 0x08
    1316:	59 86       	std	Y+9, r5	; 0x09
    1318:	6a 86       	std	Y+10, r6	; 0x0a
    131a:	7b 86       	std	Y+11, r7	; 0x0b
  : public frt_queue< uint8_t >
{
public:
  inline Packet( uint8_t queue_size = 10, emstream * p_ser_dev = NULL, portTickType wait_time = 10 )
    : frt_queue(queue_size, p_ser_dev, wait_time),
      size_(queue_size)
    131c:	0f 2e       	mov	r0, r31
    131e:	fb e1       	ldi	r31, 0x1B	; 27
    1320:	8f 2e       	mov	r8, r31
    1322:	f1 e2       	ldi	r31, 0x21	; 33
    1324:	9f 2e       	mov	r9, r31
    1326:	f0 2d       	mov	r31, r0
    1328:	8a 82       	std	Y+2, r8	; 0x02
    132a:	9b 82       	std	Y+3, r9	; 0x03
    132c:	68 94       	set
    132e:	33 24       	eor	r3, r3
    1330:	31 f8       	bld	r3, 1
    1332:	3c 86       	std	Y+12, r3	; 0x0c
    1334:	18 8a       	std	Y+16, r1	; 0x10
    1336:	19 8a       	std	Y+17, r1	; 0x11
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    1338:	ae 86       	std	Y+14, r10	; 0x0e
    133a:	bf 86       	std	Y+15, r11	; 0x0f
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	61 e0       	ldi	r22, 0x01	; 1
    1340:	82 e0       	ldi	r24, 0x02	; 2
    1342:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    1346:	8a 8b       	std	Y+18, r24	; 0x12
    1348:	9b 8b       	std	Y+19, r25	; 0x13

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    134a:	4c 8a       	std	Y+20, r4	; 0x14
    134c:	5d 8a       	std	Y+21, r5	; 0x15
    134e:	6e 8a       	std	Y+22, r6	; 0x16
    1350:	7f 8a       	std	Y+23, r7	; 0x17
    1352:	8e 86       	std	Y+14, r8	; 0x0e
    1354:	9f 86       	std	Y+15, r9	; 0x0f
    1356:	38 8e       	std	Y+24, r3	; 0x18
  inline I2CAgent( uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize)
  {}
  inline I2CAgent( emstream * s, uint8_t outPacketSize = 2, uint8_t inPacketSize = 1 ) 
    : CommAgent(outPacketSize, inPacketSize),
      p_serial(s)
    1358:	8a e0       	ldi	r24, 0x0A	; 10
    135a:	90 e2       	ldi	r25, 0x20	; 32
    135c:	88 83       	st	Y, r24
    135e:	99 83       	std	Y+1, r25	; 0x01
    1360:	ca 8e       	std	Y+26, r12	; 0x1a
    1362:	db 8e       	std	Y+27, r13	; 0x1b
    1364:	f8 01       	movw	r30, r16
    1366:	c4 83       	std	Z+4, r28	; 0x04
    1368:	d5 83       	std	Z+5, r29	; 0x05
    136a:	80 e7       	ldi	r24, 0x70	; 112
    136c:	86 83       	std	Z+6, r24	; 0x06
    136e:	10 86       	std	Z+8, r1	; 0x08
    1370:	11 86       	std	Z+9, r1	; 0x09
    1372:	12 86       	std	Z+10, r1	; 0x0a
    1374:	13 86       	std	Z+11, r1	; 0x0b
    1376:	14 86       	std	Z+12, r1	; 0x0c
    1378:	83 e0       	ldi	r24, 0x03	; 3
    137a:	90 e0       	ldi	r25, 0x00	; 0
    137c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
		: public Command
	{
	public:
		typedef frt_queue< uint8_t > Packet;
		inline RangeCommand()
			: commandCode_(RANGE_CMD)
    1380:	2d e4       	ldi	r18, 0x4D	; 77
    1382:	31 e2       	ldi	r19, 0x21	; 33
    1384:	fc 01       	movw	r30, r24
    1386:	20 83       	st	Z, r18
    1388:	31 83       	std	Z+1, r19	; 0x01
    138a:	21 e5       	ldi	r18, 0x51	; 81
    138c:	22 83       	std	Z+2, r18	; 0x02
    138e:	d8 01       	movw	r26, r16
    1390:	1f 96       	adiw	r26, 0x0f	; 15
    1392:	8d 93       	st	X+, r24
    1394:	9c 93       	st	X, r25
    1396:	50 97       	sbiw	r26, 0x10	; 16
{
	i2cAgent_->setI2CDriver(d);
    1398:	14 96       	adiw	r26, 0x04	; 4
    139a:	ed 91       	ld	r30, X+
    139c:	fc 91       	ld	r31, X
    139e:	15 97       	sbiw	r26, 0x05	; 5
  {}
  virtual bool transmit( Command & cmd );
  virtual Packet & receive();
  void setI2CDriver( I2CMaster * d ) { driver_ = d; }
    13a0:	e4 8e       	std	Z+28, r14	; 0x1c
    13a2:	f5 8e       	std	Z+29, r15	; 0x1d
	i2cAgent_->setSlaveAddr(slaveAddr_);
    13a4:	16 96       	adiw	r26, 0x06	; 6
    13a6:	6c 91       	ld	r22, X
    13a8:	16 97       	sbiw	r26, 0x06	; 6
    13aa:	14 96       	adiw	r26, 0x04	; 4
    13ac:	8d 91       	ld	r24, X+
    13ae:	9c 91       	ld	r25, X
    13b0:	15 97       	sbiw	r26, 0x05	; 5
    13b2:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	ff 90       	pop	r15
    13c0:	ef 90       	pop	r14
    13c2:	df 90       	pop	r13
    13c4:	cf 90       	pop	r12
    13c6:	bf 90       	pop	r11
    13c8:	af 90       	pop	r10
    13ca:	9f 90       	pop	r9
    13cc:	8f 90       	pop	r8
    13ce:	7f 90       	pop	r7
    13d0:	6f 90       	pop	r6
    13d2:	5f 90       	pop	r5
    13d4:	4f 90       	pop	r4
    13d6:	3f 90       	pop	r3
    13d8:	08 95       	ret

000013da <_ZN7MMA845113ActiveCommand11writePacketER9frt_queueIhE>:
}

bool MMA8451::is_ready()
{
  return driver_->is_ready(slaveAddr_);
}
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	8c 01       	movw	r16, r24
    13e4:	eb 01       	movw	r28, r22
    13e6:	bc 01       	movw	r22, r24
    13e8:	6e 5f       	subi	r22, 0xFE	; 254
    13ea:	7f 4f       	sbci	r23, 0xFF	; 255
    13ec:	e8 81       	ld	r30, Y
    13ee:	f9 81       	ldd	r31, Y+1	; 0x01
    13f0:	01 90       	ld	r0, Z+
    13f2:	f0 81       	ld	r31, Z
    13f4:	e0 2d       	mov	r30, r0
    13f6:	ce 01       	movw	r24, r28
    13f8:	19 95       	eicall
    13fa:	b8 01       	movw	r22, r16
    13fc:	6d 5f       	subi	r22, 0xFD	; 253
    13fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1400:	e8 81       	ld	r30, Y
    1402:	f9 81       	ldd	r31, Y+1	; 0x01
    1404:	01 90       	ld	r0, Z+
    1406:	f0 81       	ld	r31, Z
    1408:	e0 2d       	mov	r30, r0
    140a:	ce 01       	movw	r24, r28
    140c:	19 95       	eicall
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	1f 91       	pop	r17
    1414:	0f 91       	pop	r16
    1416:	08 95       	ret

00001418 <_ZN7MMA845116QueryXRegCommand11writePacketER9frt_queueIhE>:
    1418:	db 01       	movw	r26, r22
    141a:	bc 01       	movw	r22, r24
    141c:	6e 5f       	subi	r22, 0xFE	; 254
    141e:	7f 4f       	sbci	r23, 0xFF	; 255
    1420:	ed 91       	ld	r30, X+
    1422:	fc 91       	ld	r31, X
    1424:	11 97       	sbiw	r26, 0x01	; 1
    1426:	01 90       	ld	r0, Z+
    1428:	f0 81       	ld	r31, Z
    142a:	e0 2d       	mov	r30, r0
    142c:	cd 01       	movw	r24, r26
    142e:	19 95       	eicall
    1430:	08 95       	ret

00001432 <_ZN7MMA845116QueryYRegCommand11writePacketER9frt_queueIhE>:
    1432:	db 01       	movw	r26, r22
    1434:	bc 01       	movw	r22, r24
    1436:	6e 5f       	subi	r22, 0xFE	; 254
    1438:	7f 4f       	sbci	r23, 0xFF	; 255
    143a:	ed 91       	ld	r30, X+
    143c:	fc 91       	ld	r31, X
    143e:	11 97       	sbiw	r26, 0x01	; 1
    1440:	01 90       	ld	r0, Z+
    1442:	f0 81       	ld	r31, Z
    1444:	e0 2d       	mov	r30, r0
    1446:	cd 01       	movw	r24, r26
    1448:	19 95       	eicall
    144a:	08 95       	ret

0000144c <_ZN7MMA845116QueryZRegCommand11writePacketER9frt_queueIhE>:
    144c:	db 01       	movw	r26, r22
    144e:	bc 01       	movw	r22, r24
    1450:	6e 5f       	subi	r22, 0xFE	; 254
    1452:	7f 4f       	sbci	r23, 0xFF	; 255
    1454:	ed 91       	ld	r30, X+
    1456:	fc 91       	ld	r31, X
    1458:	11 97       	sbiw	r26, 0x01	; 1
    145a:	01 90       	ld	r0, Z+
    145c:	f0 81       	ld	r31, Z
    145e:	e0 2d       	mov	r30, r0
    1460:	cd 01       	movw	r24, r26
    1462:	19 95       	eicall
    1464:	08 95       	ret

00001466 <_ZN7MMA8451C1EP9I2CMasterP8emstream>:
    1466:	4f 92       	push	r4
    1468:	5f 92       	push	r5
    146a:	6f 92       	push	r6
    146c:	7f 92       	push	r7
    146e:	8f 92       	push	r8
    1470:	9f 92       	push	r9
    1472:	af 92       	push	r10
    1474:	bf 92       	push	r11
    1476:	cf 92       	push	r12
    1478:	df 92       	push	r13
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	8c 01       	movw	r16, r24
    1488:	7b 01       	movw	r14, r22
    148a:	6a 01       	movw	r12, r20
    148c:	dc 01       	movw	r26, r24
    148e:	6d 93       	st	X+, r22
    1490:	7c 93       	st	X, r23
    1492:	11 97       	sbiw	r26, 0x01	; 1
    1494:	12 96       	adiw	r26, 0x02	; 2
    1496:	4d 93       	st	X+, r20
    1498:	5c 93       	st	X, r21
    149a:	13 97       	sbiw	r26, 0x03	; 3
    149c:	81 e2       	ldi	r24, 0x21	; 33
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    14a4:	ec 01       	movw	r28, r24
    14a6:	8f e3       	ldi	r24, 0x3F	; 63
    14a8:	91 e2       	ldi	r25, 0x21	; 33
    14aa:	88 83       	st	Y, r24
    14ac:	99 83       	std	Y+1, r25	; 0x01
    14ae:	1c 82       	std	Y+4, r1	; 0x04
    14b0:	1d 82       	std	Y+5, r1	; 0x05
    14b2:	0f 2e       	mov	r0, r31
    14b4:	f7 ef       	ldi	r31, 0xF7	; 247
    14b6:	af 2e       	mov	r10, r31
    14b8:	f0 e2       	ldi	r31, 0x20	; 32
    14ba:	bf 2e       	mov	r11, r31
    14bc:	f0 2d       	mov	r31, r0
    14be:	aa 82       	std	Y+2, r10	; 0x02
    14c0:	bb 82       	std	Y+3, r11	; 0x03
    14c2:	40 e0       	ldi	r20, 0x00	; 0
    14c4:	61 e0       	ldi	r22, 0x01	; 1
    14c6:	82 e0       	ldi	r24, 0x02	; 2
    14c8:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    14cc:	8e 83       	std	Y+6, r24	; 0x06
    14ce:	9f 83       	std	Y+7, r25	; 0x07
    14d0:	0f 2e       	mov	r0, r31
    14d2:	fa e0       	ldi	r31, 0x0A	; 10
    14d4:	4f 2e       	mov	r4, r31
    14d6:	51 2c       	mov	r5, r1
    14d8:	61 2c       	mov	r6, r1
    14da:	71 2c       	mov	r7, r1
    14dc:	f0 2d       	mov	r31, r0
    14de:	48 86       	std	Y+8, r4	; 0x08
    14e0:	59 86       	std	Y+9, r5	; 0x09
    14e2:	6a 86       	std	Y+10, r6	; 0x0a
    14e4:	7b 86       	std	Y+11, r7	; 0x0b
    14e6:	0f 2e       	mov	r0, r31
    14e8:	fb e1       	ldi	r31, 0x1B	; 27
    14ea:	8f 2e       	mov	r8, r31
    14ec:	f1 e2       	ldi	r31, 0x21	; 33
    14ee:	9f 2e       	mov	r9, r31
    14f0:	f0 2d       	mov	r31, r0
    14f2:	8a 82       	std	Y+2, r8	; 0x02
    14f4:	9b 82       	std	Y+3, r9	; 0x03
    14f6:	82 e0       	ldi	r24, 0x02	; 2
    14f8:	8c 87       	std	Y+12, r24	; 0x0c
    14fa:	18 8a       	std	Y+16, r1	; 0x10
    14fc:	19 8a       	std	Y+17, r1	; 0x11
    14fe:	ae 86       	std	Y+14, r10	; 0x0e
    1500:	bf 86       	std	Y+15, r11	; 0x0f
    1502:	40 e0       	ldi	r20, 0x00	; 0
    1504:	61 e0       	ldi	r22, 0x01	; 1
    1506:	83 e0       	ldi	r24, 0x03	; 3
    1508:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    150c:	8a 8b       	std	Y+18, r24	; 0x12
    150e:	9b 8b       	std	Y+19, r25	; 0x13
    1510:	4c 8a       	std	Y+20, r4	; 0x14
    1512:	5d 8a       	std	Y+21, r5	; 0x15
    1514:	6e 8a       	std	Y+22, r6	; 0x16
    1516:	7f 8a       	std	Y+23, r7	; 0x17
    1518:	8e 86       	std	Y+14, r8	; 0x0e
    151a:	9f 86       	std	Y+15, r9	; 0x0f
    151c:	0f 2e       	mov	r0, r31
    151e:	f3 e0       	ldi	r31, 0x03	; 3
    1520:	bf 2e       	mov	r11, r31
    1522:	f0 2d       	mov	r31, r0
    1524:	b8 8e       	std	Y+24, r11	; 0x18
    1526:	8a e0       	ldi	r24, 0x0A	; 10
    1528:	90 e2       	ldi	r25, 0x20	; 32
    152a:	88 83       	st	Y, r24
    152c:	99 83       	std	Y+1, r25	; 0x01
    152e:	ca 8e       	std	Y+26, r12	; 0x1a
    1530:	db 8e       	std	Y+27, r13	; 0x1b
    1532:	f8 01       	movw	r30, r16
    1534:	c4 83       	std	Z+4, r28	; 0x04
    1536:	d5 83       	std	Z+5, r29	; 0x05
    1538:	86 e0       	ldi	r24, 0x06	; 6
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    1540:	fc 01       	movw	r30, r24
    1542:	10 82       	st	Z, r1
    1544:	11 82       	std	Z+1, r1	; 0x01
    1546:	12 82       	std	Z+2, r1	; 0x02
    1548:	13 82       	std	Z+3, r1	; 0x03
    154a:	14 82       	std	Z+4, r1	; 0x04
    154c:	15 82       	std	Z+5, r1	; 0x05
    154e:	d8 01       	movw	r26, r16
    1550:	16 96       	adiw	r26, 0x06	; 6
    1552:	8d 93       	st	X+, r24
    1554:	9c 93       	st	X, r25
    1556:	17 97       	sbiw	r26, 0x07	; 7
    1558:	8d e1       	ldi	r24, 0x1D	; 29
    155a:	18 96       	adiw	r26, 0x08	; 8
    155c:	8c 93       	st	X, r24
    155e:	84 e0       	ldi	r24, 0x04	; 4
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    1566:	fc 01       	movw	r30, r24
    1568:	83 e5       	ldi	r24, 0x53	; 83
    156a:	91 e2       	ldi	r25, 0x21	; 33
    156c:	80 83       	st	Z, r24
    156e:	91 83       	std	Z+1, r25	; 0x01
    1570:	8a e2       	ldi	r24, 0x2A	; 42
    1572:	82 83       	std	Z+2, r24	; 0x02
    1574:	c1 e0       	ldi	r28, 0x01	; 1
    1576:	c3 83       	std	Z+3, r28	; 0x03
    1578:	d8 01       	movw	r26, r16
    157a:	1b 96       	adiw	r26, 0x0b	; 11
    157c:	ed 93       	st	X+, r30
    157e:	fc 93       	st	X, r31
    1580:	1c 97       	sbiw	r26, 0x0c	; 12
    1582:	83 e0       	ldi	r24, 0x03	; 3
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    158a:	29 e5       	ldi	r18, 0x59	; 89
    158c:	31 e2       	ldi	r19, 0x21	; 33
    158e:	fc 01       	movw	r30, r24
    1590:	20 83       	st	Z, r18
    1592:	31 83       	std	Z+1, r19	; 0x01
    1594:	c2 83       	std	Z+2, r28	; 0x02
    1596:	d8 01       	movw	r26, r16
    1598:	1d 96       	adiw	r26, 0x0d	; 13
    159a:	8d 93       	st	X+, r24
    159c:	9c 93       	st	X, r25
    159e:	1e 97       	sbiw	r26, 0x0e	; 14
    15a0:	83 e0       	ldi	r24, 0x03	; 3
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    15a8:	2f e5       	ldi	r18, 0x5F	; 95
    15aa:	31 e2       	ldi	r19, 0x21	; 33
    15ac:	fc 01       	movw	r30, r24
    15ae:	20 83       	st	Z, r18
    15b0:	31 83       	std	Z+1, r19	; 0x01
    15b2:	b2 82       	std	Z+2, r11	; 0x02
    15b4:	d8 01       	movw	r26, r16
    15b6:	1f 96       	adiw	r26, 0x0f	; 15
    15b8:	8d 93       	st	X+, r24
    15ba:	9c 93       	st	X, r25
    15bc:	50 97       	sbiw	r26, 0x10	; 16
    15be:	83 e0       	ldi	r24, 0x03	; 3
    15c0:	90 e0       	ldi	r25, 0x00	; 0
    15c2:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    15c6:	25 e6       	ldi	r18, 0x65	; 101
    15c8:	31 e2       	ldi	r19, 0x21	; 33
    15ca:	fc 01       	movw	r30, r24
    15cc:	20 83       	st	Z, r18
    15ce:	31 83       	std	Z+1, r19	; 0x01
    15d0:	25 e0       	ldi	r18, 0x05	; 5
    15d2:	22 83       	std	Z+2, r18	; 0x02
    15d4:	d8 01       	movw	r26, r16
    15d6:	51 96       	adiw	r26, 0x11	; 17
    15d8:	8d 93       	st	X+, r24
    15da:	9c 93       	st	X, r25
    15dc:	52 97       	sbiw	r26, 0x12	; 18
    15de:	14 96       	adiw	r26, 0x04	; 4
    15e0:	ed 91       	ld	r30, X+
    15e2:	fc 91       	ld	r31, X
    15e4:	15 97       	sbiw	r26, 0x05	; 5
    15e6:	e4 8e       	std	Z+28, r14	; 0x1c
    15e8:	f5 8e       	std	Z+29, r15	; 0x1d
    15ea:	18 96       	adiw	r26, 0x08	; 8
    15ec:	6c 91       	ld	r22, X
    15ee:	18 97       	sbiw	r26, 0x08	; 8
    15f0:	14 96       	adiw	r26, 0x04	; 4
    15f2:	8d 91       	ld	r24, X+
    15f4:	9c 91       	ld	r25, X
    15f6:	15 97       	sbiw	r26, 0x05	; 5
    15f8:	0e 94 f2 03 	call	0x7e4	; 0x7e4 <_ZN8I2CAgent12setSlaveAddrEh>
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	1f 91       	pop	r17
    1602:	0f 91       	pop	r16
    1604:	ff 90       	pop	r15
    1606:	ef 90       	pop	r14
    1608:	df 90       	pop	r13
    160a:	cf 90       	pop	r12
    160c:	bf 90       	pop	r11
    160e:	af 90       	pop	r10
    1610:	9f 90       	pop	r9
    1612:	8f 90       	pop	r8
    1614:	7f 90       	pop	r7
    1616:	6f 90       	pop	r6
    1618:	5f 90       	pop	r5
    161a:	4f 90       	pop	r4
    161c:	08 95       	ret

0000161e <_ZN7MMA845111getXReadingEv>:

uint16_t MMA8451::getXReading()
{
    161e:	1f 93       	push	r17
    1620:	cf 93       	push	r28
    1622:	df 93       	push	r29
    1624:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1626:	8c 81       	ldd	r24, Y+4	; 0x04
    1628:	9d 81       	ldd	r25, Y+5	; 0x05
    162a:	6b 85       	ldd	r22, Y+11	; 0x0b
    162c:	7c 85       	ldd	r23, Y+12	; 0x0c
    162e:	dc 01       	movw	r26, r24
    1630:	ed 91       	ld	r30, X+
    1632:	fc 91       	ld	r31, X
    1634:	01 90       	ld	r0, Z+
    1636:	f0 81       	ld	r31, Z
    1638:	e0 2d       	mov	r30, r0
    163a:	19 95       	eicall
  i2cAgent_->transmit(*queryX_);
    163c:	8c 81       	ldd	r24, Y+4	; 0x04
    163e:	9d 81       	ldd	r25, Y+5	; 0x05
    1640:	6d 85       	ldd	r22, Y+13	; 0x0d
    1642:	7e 85       	ldd	r23, Y+14	; 0x0e
    1644:	dc 01       	movw	r26, r24
    1646:	ed 91       	ld	r30, X+
    1648:	fc 91       	ld	r31, X
    164a:	01 90       	ld	r0, Z+
    164c:	f0 81       	ld	r31, Z
    164e:	e0 2d       	mov	r30, r0
    1650:	19 95       	eicall
  Packet & xData = i2cAgent_->receive();
    1652:	8c 81       	ldd	r24, Y+4	; 0x04
    1654:	9d 81       	ldd	r25, Y+5	; 0x05
    1656:	dc 01       	movw	r26, r24
    1658:	ed 91       	ld	r30, X+
    165a:	fc 91       	ld	r31, X
    165c:	02 80       	ldd	r0, Z+2	; 0x02
    165e:	f3 81       	ldd	r31, Z+3	; 0x03
    1660:	e0 2d       	mov	r30, r0
    1662:	19 95       	eicall
    1664:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(xData.validData())
    1666:	8b 85       	ldd	r24, Y+11	; 0x0b
    1668:	88 23       	and	r24, r24
    166a:	b9 f0       	breq	.+46     	; 0x169a <_ZN7MMA845111getXReadingEv+0x7c>
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
    166c:	e8 81       	ld	r30, Y
    166e:	f9 81       	ldd	r31, Y+1	; 0x01
    1670:	00 84       	ldd	r0, Z+8	; 0x08
    1672:	f1 85       	ldd	r31, Z+9	; 0x09
    1674:	e0 2d       	mov	r30, r0
    1676:	ce 01       	movw	r24, r28
    1678:	19 95       	eicall
    167a:	18 2f       	mov	r17, r24
    167c:	e8 81       	ld	r30, Y
    167e:	f9 81       	ldd	r31, Y+1	; 0x01
    1680:	00 84       	ldd	r0, Z+8	; 0x08
    1682:	f1 85       	ldd	r31, Z+9	; 0x09
    1684:	e0 2d       	mov	r30, r0
    1686:	ce 01       	movw	r24, r28
    1688:	19 95       	eicall
    168a:	21 2f       	mov	r18, r17
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	32 2f       	mov	r19, r18
    1690:	22 27       	eor	r18, r18
    1692:	a9 01       	movw	r20, r18
    1694:	48 2b       	or	r20, r24
    1696:	ca 01       	movw	r24, r20
    1698:	02 c0       	rjmp	.+4      	; 0x169e <_ZN7MMA845111getXReadingEv+0x80>
uint16_t MMA8451::getXReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryX_);
  Packet & xData = i2cAgent_->receive();
  uint16_t data = 0;
    169a:	80 e0       	ldi	r24, 0x00	; 0
    169c:	90 e0       	ldi	r25, 0x00	; 0
  if(xData.validData())
    data = ((uint16_t) xData.get() << 8) | ((uint16_t) xData.get());
  return data;
}
    169e:	df 91       	pop	r29
    16a0:	cf 91       	pop	r28
    16a2:	1f 91       	pop	r17
    16a4:	08 95       	ret

000016a6 <_ZN7MMA845111getYReadingEv>:

uint16_t MMA8451::getYReading()
{
    16a6:	1f 93       	push	r17
    16a8:	cf 93       	push	r28
    16aa:	df 93       	push	r29
    16ac:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    16ae:	8c 81       	ldd	r24, Y+4	; 0x04
    16b0:	9d 81       	ldd	r25, Y+5	; 0x05
    16b2:	6b 85       	ldd	r22, Y+11	; 0x0b
    16b4:	7c 85       	ldd	r23, Y+12	; 0x0c
    16b6:	dc 01       	movw	r26, r24
    16b8:	ed 91       	ld	r30, X+
    16ba:	fc 91       	ld	r31, X
    16bc:	01 90       	ld	r0, Z+
    16be:	f0 81       	ld	r31, Z
    16c0:	e0 2d       	mov	r30, r0
    16c2:	19 95       	eicall
  i2cAgent_->transmit(*queryY_);
    16c4:	8c 81       	ldd	r24, Y+4	; 0x04
    16c6:	9d 81       	ldd	r25, Y+5	; 0x05
    16c8:	6f 85       	ldd	r22, Y+15	; 0x0f
    16ca:	78 89       	ldd	r23, Y+16	; 0x10
    16cc:	dc 01       	movw	r26, r24
    16ce:	ed 91       	ld	r30, X+
    16d0:	fc 91       	ld	r31, X
    16d2:	01 90       	ld	r0, Z+
    16d4:	f0 81       	ld	r31, Z
    16d6:	e0 2d       	mov	r30, r0
    16d8:	19 95       	eicall
  Packet & yData = i2cAgent_->receive();
    16da:	8c 81       	ldd	r24, Y+4	; 0x04
    16dc:	9d 81       	ldd	r25, Y+5	; 0x05
    16de:	dc 01       	movw	r26, r24
    16e0:	ed 91       	ld	r30, X+
    16e2:	fc 91       	ld	r31, X
    16e4:	02 80       	ldd	r0, Z+2	; 0x02
    16e6:	f3 81       	ldd	r31, Z+3	; 0x03
    16e8:	e0 2d       	mov	r30, r0
    16ea:	19 95       	eicall
    16ec:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(yData.validData())
    16ee:	8b 85       	ldd	r24, Y+11	; 0x0b
    16f0:	88 23       	and	r24, r24
    16f2:	b9 f0       	breq	.+46     	; 0x1722 <_ZN7MMA845111getYReadingEv+0x7c>
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
    16f4:	e8 81       	ld	r30, Y
    16f6:	f9 81       	ldd	r31, Y+1	; 0x01
    16f8:	00 84       	ldd	r0, Z+8	; 0x08
    16fa:	f1 85       	ldd	r31, Z+9	; 0x09
    16fc:	e0 2d       	mov	r30, r0
    16fe:	ce 01       	movw	r24, r28
    1700:	19 95       	eicall
    1702:	18 2f       	mov	r17, r24
    1704:	e8 81       	ld	r30, Y
    1706:	f9 81       	ldd	r31, Y+1	; 0x01
    1708:	00 84       	ldd	r0, Z+8	; 0x08
    170a:	f1 85       	ldd	r31, Z+9	; 0x09
    170c:	e0 2d       	mov	r30, r0
    170e:	ce 01       	movw	r24, r28
    1710:	19 95       	eicall
    1712:	21 2f       	mov	r18, r17
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	32 2f       	mov	r19, r18
    1718:	22 27       	eor	r18, r18
    171a:	a9 01       	movw	r20, r18
    171c:	48 2b       	or	r20, r24
    171e:	ca 01       	movw	r24, r20
    1720:	02 c0       	rjmp	.+4      	; 0x1726 <_ZN7MMA845111getYReadingEv+0x80>
uint16_t MMA8451::getYReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryY_);
  Packet & yData = i2cAgent_->receive();
  uint16_t data = 0;
    1722:	80 e0       	ldi	r24, 0x00	; 0
    1724:	90 e0       	ldi	r25, 0x00	; 0
  if(yData.validData())
    data = ((uint16_t) yData.get() << 8) | ((uint16_t) yData.get());
  return data;
}
    1726:	df 91       	pop	r29
    1728:	cf 91       	pop	r28
    172a:	1f 91       	pop	r17
    172c:	08 95       	ret

0000172e <_ZN7MMA845111getZReadingEv>:

uint16_t MMA8451::getZReading()
{
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
    1734:	ec 01       	movw	r28, r24
  i2cAgent_->transmit(*activeCommand_);
    1736:	8c 81       	ldd	r24, Y+4	; 0x04
    1738:	9d 81       	ldd	r25, Y+5	; 0x05
    173a:	6b 85       	ldd	r22, Y+11	; 0x0b
    173c:	7c 85       	ldd	r23, Y+12	; 0x0c
    173e:	dc 01       	movw	r26, r24
    1740:	ed 91       	ld	r30, X+
    1742:	fc 91       	ld	r31, X
    1744:	01 90       	ld	r0, Z+
    1746:	f0 81       	ld	r31, Z
    1748:	e0 2d       	mov	r30, r0
    174a:	19 95       	eicall
  i2cAgent_->transmit(*queryZ_);
    174c:	8c 81       	ldd	r24, Y+4	; 0x04
    174e:	9d 81       	ldd	r25, Y+5	; 0x05
    1750:	69 89       	ldd	r22, Y+17	; 0x11
    1752:	7a 89       	ldd	r23, Y+18	; 0x12
    1754:	dc 01       	movw	r26, r24
    1756:	ed 91       	ld	r30, X+
    1758:	fc 91       	ld	r31, X
    175a:	01 90       	ld	r0, Z+
    175c:	f0 81       	ld	r31, Z
    175e:	e0 2d       	mov	r30, r0
    1760:	19 95       	eicall
  Packet & zData = i2cAgent_->receive();
    1762:	8c 81       	ldd	r24, Y+4	; 0x04
    1764:	9d 81       	ldd	r25, Y+5	; 0x05
    1766:	dc 01       	movw	r26, r24
    1768:	ed 91       	ld	r30, X+
    176a:	fc 91       	ld	r31, X
    176c:	02 80       	ldd	r0, Z+2	; 0x02
    176e:	f3 81       	ldd	r31, Z+3	; 0x03
    1770:	e0 2d       	mov	r30, r0
    1772:	19 95       	eicall
    1774:	ec 01       	movw	r28, r24
  uint16_t data = 0;
  if(zData.validData())
    1776:	8b 85       	ldd	r24, Y+11	; 0x0b
    1778:	88 23       	and	r24, r24
    177a:	b9 f0       	breq	.+46     	; 0x17aa <_ZN7MMA845111getZReadingEv+0x7c>
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
    177c:	e8 81       	ld	r30, Y
    177e:	f9 81       	ldd	r31, Y+1	; 0x01
    1780:	00 84       	ldd	r0, Z+8	; 0x08
    1782:	f1 85       	ldd	r31, Z+9	; 0x09
    1784:	e0 2d       	mov	r30, r0
    1786:	ce 01       	movw	r24, r28
    1788:	19 95       	eicall
    178a:	18 2f       	mov	r17, r24
    178c:	e8 81       	ld	r30, Y
    178e:	f9 81       	ldd	r31, Y+1	; 0x01
    1790:	00 84       	ldd	r0, Z+8	; 0x08
    1792:	f1 85       	ldd	r31, Z+9	; 0x09
    1794:	e0 2d       	mov	r30, r0
    1796:	ce 01       	movw	r24, r28
    1798:	19 95       	eicall
    179a:	21 2f       	mov	r18, r17
    179c:	30 e0       	ldi	r19, 0x00	; 0
    179e:	32 2f       	mov	r19, r18
    17a0:	22 27       	eor	r18, r18
    17a2:	a9 01       	movw	r20, r18
    17a4:	48 2b       	or	r20, r24
    17a6:	ca 01       	movw	r24, r20
    17a8:	02 c0       	rjmp	.+4      	; 0x17ae <_ZN7MMA845111getZReadingEv+0x80>
uint16_t MMA8451::getZReading()
{
  i2cAgent_->transmit(*activeCommand_);
  i2cAgent_->transmit(*queryZ_);
  Packet & zData = i2cAgent_->receive();
  uint16_t data = 0;
    17aa:	80 e0       	ldi	r24, 0x00	; 0
    17ac:	90 e0       	ldi	r25, 0x00	; 0
  if(zData.validData())
    data = ((uint16_t) zData.get() << 8) | ((uint16_t) zData.get());
  return data;
}
    17ae:	df 91       	pop	r29
    17b0:	cf 91       	pop	r28
    17b2:	1f 91       	pop	r17
    17b4:	08 95       	ret

000017b6 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	ec 01       	movw	r28, r24
  success_ = false;
    17bc:	1b 86       	std	Y+11, r1	; 0x0b
  while( not_empty() )
    17be:	e8 81       	ld	r30, Y
    17c0:	f9 81       	ldd	r31, Y+1	; 0x01
    17c2:	00 8c       	ldd	r0, Z+24	; 0x18
    17c4:	f1 8d       	ldd	r31, Z+25	; 0x19
    17c6:	e0 2d       	mov	r30, r0
    17c8:	ce 01       	movw	r24, r28
    17ca:	19 95       	eicall
    17cc:	88 23       	and	r24, r24
    17ce:	41 f0       	breq	.+16     	; 0x17e0 <_ZN6Packet12resetContentEv+0x2a>
  {
    get();
    17d0:	e8 81       	ld	r30, Y
    17d2:	f9 81       	ldd	r31, Y+1	; 0x01
    17d4:	00 84       	ldd	r0, Z+8	; 0x08
    17d6:	f1 85       	ldd	r31, Z+9	; 0x09
    17d8:	e0 2d       	mov	r30, r0
    17da:	ce 01       	movw	r24, r28
    17dc:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  success_ = false;
  while( not_empty() )
    17de:	ef cf       	rjmp	.-34     	; 0x17be <_ZN6Packet12resetContentEv+0x8>
  {
    get();
  }
    17e0:	df 91       	pop	r29
    17e2:	cf 91       	pop	r28
    17e4:	08 95       	ret

000017e6 <_ZN11task_sensor3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sensor::run (void)
{
    17e6:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    17e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    17ea:	81 11       	cpse	r24, r1
    17ec:	39 c0       	rjmp	.+114    	; 0x1860 <_ZN11task_sensor3runEv+0x7a>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			  
				*p_serial << "x: " << mma8451_->getXReading() << endl;
    17ee:	8c 89       	ldd	r24, Y+20	; 0x14
    17f0:	9d 89       	ldd	r25, Y+21	; 0x15
    17f2:	0e 94 0f 0b 	call	0x161e	; 0x161e <_ZN7MMA845111getXReadingEv>
    17f6:	7c 01       	movw	r14, r24
    17f8:	0e 81       	ldd	r16, Y+6	; 0x06
    17fa:	1f 81       	ldd	r17, Y+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    17fc:	67 e6       	ldi	r22, 0x67	; 103
    17fe:	71 e2       	ldi	r23, 0x21	; 33
    1800:	c8 01       	movw	r24, r16
    1802:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1806:	b7 01       	movw	r22, r14
    1808:	c8 01       	movw	r24, r16
    180a:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    180e:	66 e0       	ldi	r22, 0x06	; 6
    1810:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "y: " << mma8451_->getYReading() << endl;
    1814:	8c 89       	ldd	r24, Y+20	; 0x14
    1816:	9d 89       	ldd	r25, Y+21	; 0x15
    1818:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <_ZN7MMA845111getYReadingEv>
    181c:	7c 01       	movw	r14, r24
    181e:	0e 81       	ldd	r16, Y+6	; 0x06
    1820:	1f 81       	ldd	r17, Y+7	; 0x07
    1822:	6b e6       	ldi	r22, 0x6B	; 107
    1824:	71 e2       	ldi	r23, 0x21	; 33
    1826:	c8 01       	movw	r24, r16
    1828:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    182c:	b7 01       	movw	r22, r14
    182e:	c8 01       	movw	r24, r16
    1830:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    1834:	66 e0       	ldi	r22, 0x06	; 6
    1836:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
				*p_serial << "z: " << mma8451_->getZReading() << endl;
    183a:	8c 89       	ldd	r24, Y+20	; 0x14
    183c:	9d 89       	ldd	r25, Y+21	; 0x15
    183e:	0e 94 97 0b 	call	0x172e	; 0x172e <_ZN7MMA845111getZReadingEv>
    1842:	7c 01       	movw	r14, r24
    1844:	0e 81       	ldd	r16, Y+6	; 0x06
    1846:	1f 81       	ldd	r17, Y+7	; 0x07
    1848:	6f e6       	ldi	r22, 0x6F	; 111
    184a:	71 e2       	ldi	r23, 0x21	; 33
    184c:	c8 01       	movw	r24, r16
    184e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1852:	b7 01       	movw	r22, r14
    1854:	c8 01       	movw	r24, r16
    1856:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    185a:	66 e0       	ldi	r22, 0x06	; 6
    185c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
				// break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1860:	8e 85       	ldd	r24, Y+14	; 0x0e
    1862:	9f 85       	ldd	r25, Y+15	; 0x0f
    1864:	a8 89       	ldd	r26, Y+16	; 0x10
    1866:	b9 89       	ldd	r27, Y+17	; 0x11
    1868:	01 96       	adiw	r24, 0x01	; 1
    186a:	a1 1d       	adc	r26, r1
    186c:	b1 1d       	adc	r27, r1
    186e:	8e 87       	std	Y+14, r24	; 0x0e
    1870:	9f 87       	std	Y+15, r25	; 0x0f
    1872:	a8 8b       	std	Y+16, r26	; 0x10
    1874:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1876:	68 ee       	ldi	r22, 0xE8	; 232
    1878:	73 e0       	ldi	r23, 0x03	; 3
    187a:	80 e0       	ldi	r24, 0x00	; 0
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	0e 94 e3 17 	call	0x2fc6	; 0x2fc6 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1882:	b2 cf       	rjmp	.-156    	; 0x17e8 <_ZN11task_sensor3runEv+0x2>

00001884 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sensor::task_sensor (const char* a_name, 
    1884:	cf 92       	push	r12
    1886:	df 92       	push	r13
    1888:	ef 92       	push	r14
    188a:	ff 92       	push	r15
    188c:	0f 93       	push	r16
    188e:	1f 93       	push	r17
    1890:	cf 93       	push	r28
    1892:	df 93       	push	r29
    1894:	ec 01       	movw	r28, r24
    1896:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MMA8451 * mma8451
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mma8451_(mma8451)
    1898:	0e 94 13 1a 	call	0x3426	; 0x3426 <_ZN8frt_taskC1EPKchjP8emstream>
    189c:	87 e7       	ldi	r24, 0x77	; 119
    189e:	91 e2       	ldi	r25, 0x21	; 33
    18a0:	88 83       	st	Y, r24
    18a2:	99 83       	std	Y+1, r25	; 0x01
    18a4:	ec 8a       	std	Y+20, r14	; 0x14
    18a6:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    18a8:	ce 8a       	std	Y+22, r12	; 0x16
    18aa:	df 8a       	std	Y+23, r13	; 0x17
}
    18ac:	df 91       	pop	r29
    18ae:	cf 91       	pop	r28
    18b0:	1f 91       	pop	r17
    18b2:	0f 91       	pop	r16
    18b4:	ff 90       	pop	r15
    18b6:	ef 90       	pop	r14
    18b8:	df 90       	pop	r13
    18ba:	cf 90       	pop	r12
    18bc:	08 95       	ret

000018be <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    18be:	0f 93       	push	r16
    18c0:	1f 93       	push	r17
    18c2:	cf 93       	push	r28
    18c4:	df 93       	push	r29
    18c6:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    18c8:	0e 94 13 1a 	call	0x3426	; 0x3426 <_ZN8frt_taskC1EPKchjP8emstream>
    18cc:	8f e7       	ldi	r24, 0x7F	; 127
    18ce:	91 e2       	ldi	r25, 0x21	; 33
    18d0:	88 83       	st	Y, r24
    18d2:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    18d4:	df 91       	pop	r29
    18d6:	cf 91       	pop	r28
    18d8:	1f 91       	pop	r17
    18da:	0f 91       	pop	r16
    18dc:	08 95       	ret

000018de <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    18de:	0f 93       	push	r16
    18e0:	1f 93       	push	r17
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    18e8:	6a e0       	ldi	r22, 0x0A	; 10
    18ea:	8e 81       	ldd	r24, Y+6	; 0x06
    18ec:	9f 81       	ldd	r25, Y+7	; 0x07
    18ee:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    18f2:	8c 01       	movw	r16, r24
    18f4:	6d e0       	ldi	r22, 0x0D	; 13
    18f6:	75 e0       	ldi	r23, 0x05	; 5
    18f8:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    18fc:	6a e0       	ldi	r22, 0x0A	; 10
    18fe:	c8 01       	movw	r24, r16
    1900:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1904:	8c 01       	movw	r16, r24
    1906:	67 e0       	ldi	r22, 0x07	; 7
    1908:	75 e0       	ldi	r23, 0x05	; 5
    190a:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    190e:	67 e0       	ldi	r22, 0x07	; 7
    1910:	c8 01       	movw	r24, r16
    1912:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    1916:	6a e0       	ldi	r22, 0x0A	; 10
    1918:	8e 81       	ldd	r24, Y+6	; 0x06
    191a:	9f 81       	ldd	r25, Y+7	; 0x07
    191c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1920:	8c 01       	movw	r16, r24
    1922:	68 ee       	ldi	r22, 0xE8	; 232
    1924:	74 e0       	ldi	r23, 0x04	; 4
    1926:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    192a:	6a e0       	ldi	r22, 0x0A	; 10
    192c:	c8 01       	movw	r24, r16
    192e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1932:	8c 01       	movw	r16, r24
    1934:	62 ee       	ldi	r22, 0xE2	; 226
    1936:	74 e0       	ldi	r23, 0x04	; 4
    1938:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    193c:	66 e0       	ldi	r22, 0x06	; 6
    193e:	c8 01       	movw	r24, r16
    1940:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    1944:	6a e0       	ldi	r22, 0x0A	; 10
    1946:	8e 81       	ldd	r24, Y+6	; 0x06
    1948:	9f 81       	ldd	r25, Y+7	; 0x07
    194a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    194e:	8c 01       	movw	r16, r24
    1950:	6b ec       	ldi	r22, 0xCB	; 203
    1952:	74 e0       	ldi	r23, 0x04	; 4
    1954:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1958:	66 e0       	ldi	r22, 0x06	; 6
    195a:	c8 01       	movw	r24, r16
    195c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1960:	6a e0       	ldi	r22, 0x0A	; 10
    1962:	8e 81       	ldd	r24, Y+6	; 0x06
    1964:	9f 81       	ldd	r25, Y+7	; 0x07
    1966:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    196a:	8c 01       	movw	r16, r24
    196c:	6f ea       	ldi	r22, 0xAF	; 175
    196e:	74 e0       	ldi	r23, 0x04	; 4
    1970:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1974:	66 e0       	ldi	r22, 0x06	; 6
    1976:	c8 01       	movw	r24, r16
    1978:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    197c:	6a e0       	ldi	r22, 0x0A	; 10
    197e:	8e 81       	ldd	r24, Y+6	; 0x06
    1980:	9f 81       	ldd	r25, Y+7	; 0x07
    1982:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1986:	8c 01       	movw	r16, r24
    1988:	67 e9       	ldi	r22, 0x97	; 151
    198a:	74 e0       	ldi	r23, 0x04	; 4
    198c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1990:	66 e0       	ldi	r22, 0x06	; 6
    1992:	c8 01       	movw	r24, r16
    1994:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1998:	6a e0       	ldi	r22, 0x0A	; 10
    199a:	8e 81       	ldd	r24, Y+6	; 0x06
    199c:	9f 81       	ldd	r25, Y+7	; 0x07
    199e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    19a2:	8c 01       	movw	r16, r24
    19a4:	66 e7       	ldi	r22, 0x76	; 118
    19a6:	74 e0       	ldi	r23, 0x04	; 4
    19a8:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    19ac:	66 e0       	ldi	r22, 0x06	; 6
    19ae:	c8 01       	movw	r24, r16
    19b0:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    19b4:	6a e0       	ldi	r22, 0x0A	; 10
    19b6:	8e 81       	ldd	r24, Y+6	; 0x06
    19b8:	9f 81       	ldd	r25, Y+7	; 0x07
    19ba:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    19be:	8c 01       	movw	r16, r24
    19c0:	6f e4       	ldi	r22, 0x4F	; 79
    19c2:	74 e0       	ldi	r23, 0x04	; 4
    19c4:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    19c8:	66 e0       	ldi	r22, 0x06	; 6
    19ca:	c8 01       	movw	r24, r16
    19cc:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    19d0:	6a e0       	ldi	r22, 0x0A	; 10
    19d2:	8e 81       	ldd	r24, Y+6	; 0x06
    19d4:	9f 81       	ldd	r25, Y+7	; 0x07
    19d6:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    19da:	8c 01       	movw	r16, r24
    19dc:	61 e3       	ldi	r22, 0x31	; 49
    19de:	74 e0       	ldi	r23, 0x04	; 4
    19e0:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    19e4:	66 e0       	ldi	r22, 0x06	; 6
    19e6:	c8 01       	movw	r24, r16
    19e8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    19ec:	6a e0       	ldi	r22, 0x0A	; 10
    19ee:	8e 81       	ldd	r24, Y+6	; 0x06
    19f0:	9f 81       	ldd	r25, Y+7	; 0x07
    19f2:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    19f6:	8c 01       	movw	r16, r24
    19f8:	66 e1       	ldi	r22, 0x16	; 22
    19fa:	74 e0       	ldi	r23, 0x04	; 4
    19fc:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1a00:	66 e0       	ldi	r22, 0x06	; 6
    1a02:	c8 01       	movw	r24, r16
    1a04:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    1a08:	6a e0       	ldi	r22, 0x0A	; 10
    1a0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a0e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1a12:	ec 01       	movw	r28, r24
    1a14:	67 e0       	ldi	r22, 0x07	; 7
    1a16:	74 e0       	ldi	r23, 0x04	; 4
    1a18:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1a1c:	66 e0       	ldi	r22, 0x06	; 6
    1a1e:	ce 01       	movw	r24, r28
    1a20:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
}
    1a24:	df 91       	pop	r29
    1a26:	cf 91       	pop	r28
    1a28:	1f 91       	pop	r17
    1a2a:	0f 91       	pop	r16
    1a2c:	08 95       	ret

00001a2e <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    1a2e:	af 92       	push	r10
    1a30:	bf 92       	push	r11
    1a32:	cf 92       	push	r12
    1a34:	df 92       	push	r13
    1a36:	ef 92       	push	r14
    1a38:	ff 92       	push	r15
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <_ZN9task_user11show_statusEv+0x16>
    1a44:	00 d0       	rcall	.+0      	; 0x1a46 <_ZN9task_user11show_statusEv+0x18>
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
    1a4a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1a4c:	19 82       	std	Y+1, r1	; 0x01
    1a4e:	1a 82       	std	Y+2, r1	; 0x02
    1a50:	1b 82       	std	Y+3, r1	; 0x03
    1a52:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1a54:	1d 82       	std	Y+5, r1	; 0x05
    1a56:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1a58:	0e 94 9c 0f 	call	0x1f38	; 0x1f38 <xPortGetFreeHeapSize>
    1a5c:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a5e:	ce 01       	movw	r24, r28
    1a60:	01 96       	adiw	r24, 0x01	; 1
    1a62:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <_ZN10time_stamp10set_to_nowEv>
    1a66:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1a68:	66 e0       	ldi	r22, 0x06	; 6
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	86 81       	ldd	r24, Z+6	; 0x06
    1a6e:	97 81       	ldd	r25, Z+7	; 0x07
    1a70:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1a74:	6a e0       	ldi	r22, 0x0A	; 10
    1a76:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1a7a:	7c 01       	movw	r14, r24
    1a7c:	68 ee       	ldi	r22, 0xE8	; 232
    1a7e:	73 e0       	ldi	r23, 0x03	; 3
    1a80:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1a84:	6a e0       	ldi	r22, 0x0A	; 10
    1a86:	c7 01       	movw	r24, r14
    1a88:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1a8c:	7c 01       	movw	r14, r24
    1a8e:	6c ed       	ldi	r22, 0xDC	; 220
    1a90:	73 e0       	ldi	r23, 0x03	; 3
    1a92:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1a96:	66 e0       	ldi	r22, 0x06	; 6
    1a98:	c7 01       	movw	r24, r14
    1a9a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1a9e:	6a e0       	ldi	r22, 0x0A	; 10
    1aa0:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1aa4:	7c 01       	movw	r14, r24
    1aa6:	65 ed       	ldi	r22, 0xD5	; 213
    1aa8:	73 e0       	ldi	r23, 0x03	; 3
    1aaa:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1aae:	b5 01       	movw	r22, r10
    1ab0:	c7 01       	movw	r24, r14
    1ab2:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1ab6:	6a e0       	ldi	r22, 0x0A	; 10
    1ab8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1abc:	7c 01       	movw	r14, r24
    1abe:	67 ec       	ldi	r22, 0xC7	; 199
    1ac0:	73 e0       	ldi	r23, 0x03	; 3
    1ac2:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1ac6:	b6 01       	movw	r22, r12
    1ac8:	c7 01       	movw	r24, r14
    1aca:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    1ace:	6a e0       	ldi	r22, 0x0A	; 10
    1ad0:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1ad4:	7c 01       	movw	r14, r24
    1ad6:	65 ec       	ldi	r22, 0xC5	; 197
    1ad8:	73 e0       	ldi	r23, 0x03	; 3
    1ada:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1ade:	4f ef       	ldi	r20, 0xFF	; 255
    1ae0:	5f e0       	ldi	r21, 0x0F	; 15
    1ae2:	60 e0       	ldi	r22, 0x00	; 0
    1ae4:	70 e0       	ldi	r23, 0x00	; 0
    1ae6:	c7 01       	movw	r24, r14
    1ae8:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1aec:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1af0:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1af4:	6a e0       	ldi	r22, 0x0A	; 10
    1af6:	f8 01       	movw	r30, r16
    1af8:	86 81       	ldd	r24, Z+6	; 0x06
    1afa:	97 81       	ldd	r25, Z+7	; 0x07
    1afc:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1b00:	7c 01       	movw	r14, r24
    1b02:	6a eb       	ldi	r22, 0xBA	; 186
    1b04:	73 e0       	ldi	r23, 0x03	; 3
    1b06:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1b0a:	b6 01       	movw	r22, r12
    1b0c:	c7 01       	movw	r24, r14
    1b0e:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    1b12:	66 e0       	ldi	r22, 0x06	; 6
    1b14:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1b18:	66 e0       	ldi	r22, 0x06	; 6
    1b1a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    1b1e:	f8 01       	movw	r30, r16
    1b20:	86 81       	ldd	r24, Z+6	; 0x06
    1b22:	97 81       	ldd	r25, Z+7	; 0x07
    1b24:	0e 94 21 1c 	call	0x3842	; 0x3842 <_Z15print_task_listP8emstream>
}
    1b28:	26 96       	adiw	r28, 0x06	; 6
    1b2a:	cd bf       	out	0x3d, r28	; 61
    1b2c:	de bf       	out	0x3e, r29	; 62
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	ff 90       	pop	r15
    1b38:	ef 90       	pop	r14
    1b3a:	df 90       	pop	r13
    1b3c:	cf 90       	pop	r12
    1b3e:	bf 90       	pop	r11
    1b40:	af 90       	pop	r10
    1b42:	08 95       	ret

00001b44 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    1b44:	cf 93       	push	r28
    1b46:	df 93       	push	r29
    1b48:	00 d0       	rcall	.+0      	; 0x1b4a <_ZN9task_user3runEv+0x6>
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <_ZN9task_user3runEv+0x8>
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
    1b50:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1b52:	19 82       	std	Y+1, r1	; 0x01
    1b54:	1a 82       	std	Y+2, r1	; 0x02
    1b56:	1b 82       	std	Y+3, r1	; 0x03
    1b58:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1b5a:	1d 82       	std	Y+5, r1	; 0x05
    1b5c:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1b5e:	6a e0       	ldi	r22, 0x0A	; 10
    1b60:	dc 01       	movw	r26, r24
    1b62:	16 96       	adiw	r26, 0x06	; 6
    1b64:	8d 91       	ld	r24, X+
    1b66:	9c 91       	ld	r25, X
    1b68:	17 97       	sbiw	r26, 0x07	; 7
    1b6a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1b6e:	7c 01       	movw	r14, r24
    1b70:	66 e5       	ldi	r22, 0x56	; 86
    1b72:	75 e0       	ldi	r23, 0x05	; 5
    1b74:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1b78:	66 e0       	ldi	r22, 0x06	; 6
    1b7a:	c7 01       	movw	r24, r14
    1b7c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1b80:	f8 01       	movw	r30, r16
    1b82:	84 85       	ldd	r24, Z+12	; 0x0c
    1b84:	88 23       	and	r24, r24
    1b86:	21 f0       	breq	.+8      	; 0x1b90 <_ZN9task_user3runEv+0x4c>
    1b88:	81 30       	cpi	r24, 0x01	; 1
    1b8a:	09 f4       	brne	.+2      	; 0x1b8e <_ZN9task_user3runEv+0x4a>
    1b8c:	5d c0       	rjmp	.+186    	; 0x1c48 <_ZN9task_user3runEv+0x104>
    1b8e:	d8 c0       	rjmp	.+432    	; 0x1d40 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1b90:	86 81       	ldd	r24, Z+6	; 0x06
    1b92:	97 81       	ldd	r25, Z+7	; 0x07
    1b94:	dc 01       	movw	r26, r24
    1b96:	ed 91       	ld	r30, X+
    1b98:	fc 91       	ld	r31, X
    1b9a:	04 80       	ldd	r0, Z+4	; 0x04
    1b9c:	f5 81       	ldd	r31, Z+5	; 0x05
    1b9e:	e0 2d       	mov	r30, r0
    1ba0:	19 95       	eicall
    1ba2:	88 23       	and	r24, r24
    1ba4:	a9 f1       	breq	.+106    	; 0x1c10 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	86 81       	ldd	r24, Z+6	; 0x06
    1baa:	97 81       	ldd	r25, Z+7	; 0x07
    1bac:	dc 01       	movw	r26, r24
    1bae:	ed 91       	ld	r30, X+
    1bb0:	fc 91       	ld	r31, X
    1bb2:	06 80       	ldd	r0, Z+6	; 0x06
    1bb4:	f7 81       	ldd	r31, Z+7	; 0x07
    1bb6:	e0 2d       	mov	r30, r0
    1bb8:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1bba:	99 27       	eor	r25, r25
    1bbc:	81 30       	cpi	r24, 0x01	; 1
    1bbe:	91 05       	cpc	r25, r1
    1bc0:	f9 f0       	breq	.+62     	; 0x1c00 <_ZN9task_user3runEv+0xbc>
    1bc2:	03 97       	sbiw	r24, 0x03	; 3
    1bc4:	09 f0       	breq	.+2      	; 0x1bc8 <_ZN9task_user3runEv+0x84>
    1bc6:	d8 c0       	rjmp	.+432    	; 0x1d78 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1bc8:	6a e0       	ldi	r22, 0x0A	; 10
    1bca:	f8 01       	movw	r30, r16
    1bcc:	86 81       	ldd	r24, Z+6	; 0x06
    1bce:	97 81       	ldd	r25, Z+7	; 0x07
    1bd0:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1bd4:	8c 01       	movw	r16, r24
    1bd6:	68 e4       	ldi	r22, 0x48	; 72
    1bd8:	75 e0       	ldi	r23, 0x05	; 5
    1bda:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1bde:	66 e0       	ldi	r22, 0x06	; 6
    1be0:	c8 01       	movw	r24, r16
    1be2:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1be6:	93 e0       	ldi	r25, 0x03	; 3
    1be8:	88 ed       	ldi	r24, 0xD8	; 216
    1bea:	08 b6       	in	r0, 0x38	; 56
    1bec:	18 be       	out	0x38, r1	; 56
    1bee:	84 bf       	out	0x34, r24	; 52
    1bf0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1bf4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1bf8:	81 fd       	sbrc	r24, 1
    1bfa:	fc cf       	rjmp	.-8      	; 0x1bf4 <_ZN9task_user3runEv+0xb0>
    1bfc:	08 be       	out	0x38, r0	; 56
    1bfe:	ff cf       	rjmp	.-2      	; 0x1bfe <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1c00:	c8 01       	movw	r24, r16
    1c02:	0e 94 6f 0c 	call	0x18de	; 0x18de <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1c06:	61 e0       	ldi	r22, 0x01	; 1
    1c08:	c8 01       	movw	r24, r16
    1c0a:	0e 94 0f 1a 	call	0x341e	; 0x341e <_ZN8frt_task13transition_toEh>
							break;
    1c0e:	b4 c0       	rjmp	.+360    	; 0x1d78 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1c10:	82 ef       	ldi	r24, 0xF2	; 242
    1c12:	92 e3       	ldi	r25, 0x32	; 50
    1c14:	0e 94 d0 1c 	call	0x39a0	; 0x39a0 <_ZN14frt_text_queue14check_for_charEv>
    1c18:	88 23       	and	r24, r24
    1c1a:	09 f4       	brne	.+2      	; 0x1c1e <_ZN9task_user3runEv+0xda>
    1c1c:	ad c0       	rjmp	.+346    	; 0x1d78 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1c1e:	d8 01       	movw	r26, r16
    1c20:	16 96       	adiw	r26, 0x06	; 6
    1c22:	ed 91       	ld	r30, X+
    1c24:	fc 91       	ld	r31, X
    1c26:	17 97       	sbiw	r26, 0x07	; 7
    1c28:	01 90       	ld	r0, Z+
    1c2a:	f0 81       	ld	r31, Z
    1c2c:	e0 2d       	mov	r30, r0
    1c2e:	e2 80       	ldd	r14, Z+2	; 0x02
    1c30:	f3 80       	ldd	r15, Z+3	; 0x03
    1c32:	82 ef       	ldi	r24, 0xF2	; 242
    1c34:	92 e3       	ldi	r25, 0x32	; 50
    1c36:	0e 94 b2 1c 	call	0x3964	; 0x3964 <_ZN14frt_text_queue7getcharEv>
    1c3a:	68 2f       	mov	r22, r24
    1c3c:	f8 01       	movw	r30, r16
    1c3e:	86 81       	ldd	r24, Z+6	; 0x06
    1c40:	97 81       	ldd	r25, Z+7	; 0x07
    1c42:	f7 01       	movw	r30, r14
    1c44:	19 95       	eicall
    1c46:	98 c0       	rjmp	.+304    	; 0x1d78 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1c48:	86 81       	ldd	r24, Z+6	; 0x06
    1c4a:	97 81       	ldd	r25, Z+7	; 0x07
    1c4c:	dc 01       	movw	r26, r24
    1c4e:	ed 91       	ld	r30, X+
    1c50:	fc 91       	ld	r31, X
    1c52:	04 80       	ldd	r0, Z+4	; 0x04
    1c54:	f5 81       	ldd	r31, Z+5	; 0x05
    1c56:	e0 2d       	mov	r30, r0
    1c58:	19 95       	eicall
    1c5a:	88 23       	and	r24, r24
    1c5c:	09 f4       	brne	.+2      	; 0x1c60 <_ZN9task_user3runEv+0x11c>
    1c5e:	8c c0       	rjmp	.+280    	; 0x1d78 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1c60:	f8 01       	movw	r30, r16
    1c62:	86 81       	ldd	r24, Z+6	; 0x06
    1c64:	97 81       	ldd	r25, Z+7	; 0x07
    1c66:	dc 01       	movw	r26, r24
    1c68:	ed 91       	ld	r30, X+
    1c6a:	fc 91       	ld	r31, X
    1c6c:	06 80       	ldd	r0, Z+6	; 0x06
    1c6e:	f7 81       	ldd	r31, Z+7	; 0x07
    1c70:	e0 2d       	mov	r30, r0
    1c72:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1c74:	9c 01       	movw	r18, r24
    1c76:	33 27       	eor	r19, r19
    1c78:	28 36       	cpi	r18, 0x68	; 104
    1c7a:	31 05       	cpc	r19, r1
    1c7c:	59 f1       	breq	.+86     	; 0x1cd4 <_ZN9task_user3runEv+0x190>
    1c7e:	3c f4       	brge	.+14     	; 0x1c8e <_ZN9task_user3runEv+0x14a>
    1c80:	2b 31       	cpi	r18, 0x1B	; 27
    1c82:	31 05       	cpc	r19, r1
    1c84:	59 f1       	breq	.+86     	; 0x1cdc <_ZN9task_user3runEv+0x198>
    1c86:	25 36       	cpi	r18, 0x65	; 101
    1c88:	31 05       	cpc	r19, r1
    1c8a:	41 f1       	breq	.+80     	; 0x1cdc <_ZN9task_user3runEv+0x198>
    1c8c:	3b c0       	rjmp	.+118    	; 0x1d04 <_ZN9task_user3runEv+0x1c0>
    1c8e:	23 37       	cpi	r18, 0x73	; 115
    1c90:	31 05       	cpc	r19, r1
    1c92:	c1 f0       	breq	.+48     	; 0x1cc4 <_ZN9task_user3runEv+0x180>
    1c94:	26 37       	cpi	r18, 0x76	; 118
    1c96:	31 05       	cpc	r19, r1
    1c98:	89 f0       	breq	.+34     	; 0x1cbc <_ZN9task_user3runEv+0x178>
    1c9a:	2e 36       	cpi	r18, 0x6E	; 110
    1c9c:	31 05       	cpc	r19, r1
    1c9e:	91 f5       	brne	.+100    	; 0x1d04 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1ca0:	ce 01       	movw	r24, r28
    1ca2:	01 96       	adiw	r24, 0x01	; 1
    1ca4:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <_ZN10time_stamp10set_to_nowEv>
    1ca8:	bc 01       	movw	r22, r24
    1caa:	f8 01       	movw	r30, r16
    1cac:	86 81       	ldd	r24, Z+6	; 0x06
    1cae:	97 81       	ldd	r25, Z+7	; 0x07
    1cb0:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <_ZlsR8emstreamR10time_stamp>
    1cb4:	66 e0       	ldi	r22, 0x06	; 6
    1cb6:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1cba:	5e c0       	rjmp	.+188    	; 0x1d78 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1cbc:	c8 01       	movw	r24, r16
    1cbe:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <_ZN9task_user11show_statusEv>
							break;
    1cc2:	5a c0       	rjmp	.+180    	; 0x1d78 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1cc4:	d8 01       	movw	r26, r16
    1cc6:	16 96       	adiw	r26, 0x06	; 6
    1cc8:	8d 91       	ld	r24, X+
    1cca:	9c 91       	ld	r25, X
    1ccc:	17 97       	sbiw	r26, 0x07	; 7
    1cce:	0e 94 28 1b 	call	0x3650	; 0x3650 <_Z17print_task_stacksP8emstream>
							break;
    1cd2:	52 c0       	rjmp	.+164    	; 0x1d78 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	0e 94 6f 0c 	call	0x18de	; 0x18de <_ZN9task_user18print_help_messageEv>
							break;
    1cda:	4e c0       	rjmp	.+156    	; 0x1d78 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1cdc:	6a e0       	ldi	r22, 0x0A	; 10
    1cde:	f8 01       	movw	r30, r16
    1ce0:	86 81       	ldd	r24, Z+6	; 0x06
    1ce2:	97 81       	ldd	r25, Z+7	; 0x07
    1ce4:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1ce8:	7c 01       	movw	r14, r24
    1cea:	66 e3       	ldi	r22, 0x36	; 54
    1cec:	75 e0       	ldi	r23, 0x05	; 5
    1cee:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1cf2:	66 e0       	ldi	r22, 0x06	; 6
    1cf4:	c7 01       	movw	r24, r14
    1cf6:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1cfa:	60 e0       	ldi	r22, 0x00	; 0
    1cfc:	c8 01       	movw	r24, r16
    1cfe:	0e 94 0f 1a 	call	0x341e	; 0x341e <_ZN8frt_task13transition_toEh>
							break;
    1d02:	3a c0       	rjmp	.+116    	; 0x1d78 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1d04:	f8 01       	movw	r30, r16
    1d06:	a6 81       	ldd	r26, Z+6	; 0x06
    1d08:	b7 81       	ldd	r27, Z+7	; 0x07
    1d0a:	ed 91       	ld	r30, X+
    1d0c:	fc 91       	ld	r31, X
    1d0e:	11 97       	sbiw	r26, 0x01	; 1
    1d10:	02 80       	ldd	r0, Z+2	; 0x02
    1d12:	f3 81       	ldd	r31, Z+3	; 0x03
    1d14:	e0 2d       	mov	r30, r0
    1d16:	68 2f       	mov	r22, r24
    1d18:	cd 01       	movw	r24, r26
    1d1a:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1d1c:	6a e0       	ldi	r22, 0x0A	; 10
    1d1e:	d8 01       	movw	r26, r16
    1d20:	16 96       	adiw	r26, 0x06	; 6
    1d22:	8d 91       	ld	r24, X+
    1d24:	9c 91       	ld	r25, X
    1d26:	17 97       	sbiw	r26, 0x07	; 7
    1d28:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1d2c:	7c 01       	movw	r14, r24
    1d2e:	60 e3       	ldi	r22, 0x30	; 48
    1d30:	75 e0       	ldi	r23, 0x05	; 5
    1d32:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1d36:	66 e0       	ldi	r22, 0x06	; 6
    1d38:	c7 01       	movw	r24, r14
    1d3a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1d3e:	1c c0       	rjmp	.+56     	; 0x1d78 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1d40:	6a e0       	ldi	r22, 0x0A	; 10
    1d42:	f8 01       	movw	r30, r16
    1d44:	86 81       	ldd	r24, Z+6	; 0x06
    1d46:	97 81       	ldd	r25, Z+7	; 0x07
    1d48:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    1d4c:	8c 01       	movw	r16, r24
    1d4e:	63 e1       	ldi	r22, 0x13	; 19
    1d50:	75 e0       	ldi	r23, 0x05	; 5
    1d52:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    1d56:	66 e0       	ldi	r22, 0x06	; 6
    1d58:	c8 01       	movw	r24, r16
    1d5a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1d5e:	93 e0       	ldi	r25, 0x03	; 3
    1d60:	88 ed       	ldi	r24, 0xD8	; 216
    1d62:	08 b6       	in	r0, 0x38	; 56
    1d64:	18 be       	out	0x38, r1	; 56
    1d66:	84 bf       	out	0x34, r24	; 52
    1d68:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1d6c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1d70:	81 fd       	sbrc	r24, 1
    1d72:	fc cf       	rjmp	.-8      	; 0x1d6c <_ZN9task_user3runEv+0x228>
    1d74:	08 be       	out	0x38, r0	; 56
    1d76:	ff cf       	rjmp	.-2      	; 0x1d76 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1d78:	f8 01       	movw	r30, r16
    1d7a:	86 85       	ldd	r24, Z+14	; 0x0e
    1d7c:	97 85       	ldd	r25, Z+15	; 0x0f
    1d7e:	a0 89       	ldd	r26, Z+16	; 0x10
    1d80:	b1 89       	ldd	r27, Z+17	; 0x11
    1d82:	01 96       	adiw	r24, 0x01	; 1
    1d84:	a1 1d       	adc	r26, r1
    1d86:	b1 1d       	adc	r27, r1
    1d88:	86 87       	std	Z+14, r24	; 0x0e
    1d8a:	97 87       	std	Z+15, r25	; 0x0f
    1d8c:	a0 8b       	std	Z+16, r26	; 0x10
    1d8e:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1d90:	68 ee       	ldi	r22, 0xE8	; 232
    1d92:	73 e0       	ldi	r23, 0x03	; 3
    1d94:	80 e0       	ldi	r24, 0x00	; 0
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	0e 94 e3 17 	call	0x2fc6	; 0x2fc6 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1d9c:	f1 ce       	rjmp	.-542    	; 0x1b80 <_ZN9task_user3runEv+0x3c>

00001d9e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1d9e:	0f 93       	push	r16
    1da0:	1f 93       	push	r17
    1da2:	cf 93       	push	r28
    1da4:	df 93       	push	r29
    1da6:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1da8:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1dac:	80 91 36 22 	lds	r24, 0x2236	; 0x802236 <__data_end>
    1db0:	81 11       	cpse	r24, r1
    1db2:	1d c0       	rjmp	.+58     	; 0x1dee <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1db4:	ab e3       	ldi	r26, 0x3B	; 59
    1db6:	b2 e2       	ldi	r27, 0x22	; 34
    1db8:	ef e3       	ldi	r30, 0x3F	; 63
    1dba:	f2 e2       	ldi	r31, 0x22	; 34
    1dbc:	ed 93       	st	X+, r30
    1dbe:	fc 93       	st	X, r31
    1dc0:	11 97       	sbiw	r26, 0x01	; 1
    1dc2:	12 96       	adiw	r26, 0x02	; 2
    1dc4:	1d 92       	st	X+, r1
    1dc6:	1c 92       	st	X, r1
    1dc8:	13 97       	sbiw	r26, 0x03	; 3
    1dca:	a7 e3       	ldi	r26, 0x37	; 55
    1dcc:	b2 e2       	ldi	r27, 0x22	; 34
    1dce:	8f ef       	ldi	r24, 0xFF	; 255
    1dd0:	9f e0       	ldi	r25, 0x0F	; 15
    1dd2:	12 96       	adiw	r26, 0x02	; 2
    1dd4:	8d 93       	st	X+, r24
    1dd6:	9c 93       	st	X, r25
    1dd8:	13 97       	sbiw	r26, 0x03	; 3
    1dda:	1d 92       	st	X+, r1
    1ddc:	1c 92       	st	X, r1
    1dde:	11 97       	sbiw	r26, 0x01	; 1
    1de0:	82 83       	std	Z+2, r24	; 0x02
    1de2:	93 83       	std	Z+3, r25	; 0x03
    1de4:	a0 83       	st	Z, r26
    1de6:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	80 93 36 22 	sts	0x2236, r24	; 0x802236 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1dee:	20 97       	sbiw	r28, 0x00	; 0
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <pvPortMalloc+0x56>
    1df2:	5f c0       	rjmp	.+190    	; 0x1eb2 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1df4:	9e 01       	movw	r18, r28
    1df6:	2b 5f       	subi	r18, 0xFB	; 251
    1df8:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1dfa:	24 96       	adiw	r28, 0x04	; 4
    1dfc:	ce 3f       	cpi	r28, 0xFE	; 254
    1dfe:	df 40       	sbci	r29, 0x0F	; 15
    1e00:	08 f0       	brcs	.+2      	; 0x1e04 <pvPortMalloc+0x66>
    1e02:	5a c0       	rjmp	.+180    	; 0x1eb8 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1e04:	e0 91 3b 22 	lds	r30, 0x223B	; 0x80223b <xStart>
    1e08:	f0 91 3c 22 	lds	r31, 0x223C	; 0x80223c <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1e0c:	ab e3       	ldi	r26, 0x3B	; 59
    1e0e:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e10:	02 c0       	rjmp	.+4      	; 0x1e16 <pvPortMalloc+0x78>
    1e12:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1e14:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1e16:	82 81       	ldd	r24, Z+2	; 0x02
    1e18:	93 81       	ldd	r25, Z+3	; 0x03
    1e1a:	82 17       	cp	r24, r18
    1e1c:	93 07       	cpc	r25, r19
    1e1e:	20 f4       	brcc	.+8      	; 0x1e28 <pvPortMalloc+0x8a>
    1e20:	80 81       	ld	r24, Z
    1e22:	91 81       	ldd	r25, Z+1	; 0x01
    1e24:	00 97       	sbiw	r24, 0x00	; 0
    1e26:	a9 f7       	brne	.-22     	; 0x1e12 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1e28:	c2 e2       	ldi	r28, 0x22	; 34
    1e2a:	e7 33       	cpi	r30, 0x37	; 55
    1e2c:	fc 07       	cpc	r31, r28
    1e2e:	09 f4       	brne	.+2      	; 0x1e32 <pvPortMalloc+0x94>
    1e30:	46 c0       	rjmp	.+140    	; 0x1ebe <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1e32:	cd 91       	ld	r28, X+
    1e34:	dc 91       	ld	r29, X
    1e36:	11 97       	sbiw	r26, 0x01	; 1
    1e38:	8e 01       	movw	r16, r28
    1e3a:	0b 5f       	subi	r16, 0xFB	; 251
    1e3c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1e3e:	80 81       	ld	r24, Z
    1e40:	91 81       	ldd	r25, Z+1	; 0x01
    1e42:	8d 93       	st	X+, r24
    1e44:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1e46:	82 81       	ldd	r24, Z+2	; 0x02
    1e48:	93 81       	ldd	r25, Z+3	; 0x03
    1e4a:	82 1b       	sub	r24, r18
    1e4c:	93 0b       	sbc	r25, r19
    1e4e:	8b 30       	cpi	r24, 0x0B	; 11
    1e50:	91 05       	cpc	r25, r1
    1e52:	10 f1       	brcs	.+68     	; 0x1e98 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1e54:	bf 01       	movw	r22, r30
    1e56:	62 0f       	add	r22, r18
    1e58:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1e5a:	db 01       	movw	r26, r22
    1e5c:	12 96       	adiw	r26, 0x02	; 2
    1e5e:	8d 93       	st	X+, r24
    1e60:	9c 93       	st	X, r25
    1e62:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1e64:	22 83       	std	Z+2, r18	; 0x02
    1e66:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1e68:	12 96       	adiw	r26, 0x02	; 2
    1e6a:	4d 91       	ld	r20, X+
    1e6c:	5c 91       	ld	r21, X
    1e6e:	13 97       	sbiw	r26, 0x03	; 3
    1e70:	8b e3       	ldi	r24, 0x3B	; 59
    1e72:	92 e2       	ldi	r25, 0x22	; 34
    1e74:	01 c0       	rjmp	.+2      	; 0x1e78 <pvPortMalloc+0xda>
    1e76:	cd 01       	movw	r24, r26
    1e78:	ec 01       	movw	r28, r24
    1e7a:	a8 81       	ld	r26, Y
    1e7c:	b9 81       	ldd	r27, Y+1	; 0x01
    1e7e:	12 96       	adiw	r26, 0x02	; 2
    1e80:	2d 91       	ld	r18, X+
    1e82:	3c 91       	ld	r19, X
    1e84:	13 97       	sbiw	r26, 0x03	; 3
    1e86:	24 17       	cp	r18, r20
    1e88:	35 07       	cpc	r19, r21
    1e8a:	a8 f3       	brcs	.-22     	; 0x1e76 <pvPortMalloc+0xd8>
    1e8c:	eb 01       	movw	r28, r22
    1e8e:	a8 83       	st	Y, r26
    1e90:	b9 83       	std	Y+1, r27	; 0x01
    1e92:	dc 01       	movw	r26, r24
    1e94:	6d 93       	st	X+, r22
    1e96:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1e98:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1e9c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1ea0:	22 81       	ldd	r18, Z+2	; 0x02
    1ea2:	33 81       	ldd	r19, Z+3	; 0x03
    1ea4:	82 1b       	sub	r24, r18
    1ea6:	93 0b       	sbc	r25, r19
    1ea8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1eac:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1eb0:	08 c0       	rjmp	.+16     	; 0x1ec2 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1eb2:	00 e0       	ldi	r16, 0x00	; 0
    1eb4:	10 e0       	ldi	r17, 0x00	; 0
    1eb6:	05 c0       	rjmp	.+10     	; 0x1ec2 <pvPortMalloc+0x124>
    1eb8:	00 e0       	ldi	r16, 0x00	; 0
    1eba:	10 e0       	ldi	r17, 0x00	; 0
    1ebc:	02 c0       	rjmp	.+4      	; 0x1ec2 <pvPortMalloc+0x124>
    1ebe:	00 e0       	ldi	r16, 0x00	; 0
    1ec0:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1ec2:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1ec6:	c8 01       	movw	r24, r16
    1ec8:	df 91       	pop	r29
    1eca:	cf 91       	pop	r28
    1ecc:	1f 91       	pop	r17
    1ece:	0f 91       	pop	r16
    1ed0:	08 95       	ret

00001ed2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ed2:	0f 93       	push	r16
    1ed4:	1f 93       	push	r17
    1ed6:	cf 93       	push	r28
    1ed8:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1eda:	00 97       	sbiw	r24, 0x00	; 0
    1edc:	41 f1       	breq	.+80     	; 0x1f2e <vPortFree+0x5c>
    1ede:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1ee0:	8c 01       	movw	r16, r24
    1ee2:	05 50       	subi	r16, 0x05	; 5
    1ee4:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1ee6:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1eea:	f8 01       	movw	r30, r16
    1eec:	42 81       	ldd	r20, Z+2	; 0x02
    1eee:	53 81       	ldd	r21, Z+3	; 0x03
    1ef0:	ab e3       	ldi	r26, 0x3B	; 59
    1ef2:	b2 e2       	ldi	r27, 0x22	; 34
    1ef4:	01 c0       	rjmp	.+2      	; 0x1ef8 <vPortFree+0x26>
    1ef6:	df 01       	movw	r26, r30
    1ef8:	ed 91       	ld	r30, X+
    1efa:	fc 91       	ld	r31, X
    1efc:	11 97       	sbiw	r26, 0x01	; 1
    1efe:	22 81       	ldd	r18, Z+2	; 0x02
    1f00:	33 81       	ldd	r19, Z+3	; 0x03
    1f02:	24 17       	cp	r18, r20
    1f04:	35 07       	cpc	r19, r21
    1f06:	b8 f3       	brcs	.-18     	; 0x1ef6 <vPortFree+0x24>
    1f08:	25 97       	sbiw	r28, 0x05	; 5
    1f0a:	e8 83       	st	Y, r30
    1f0c:	f9 83       	std	Y+1, r31	; 0x01
    1f0e:	0d 93       	st	X+, r16
    1f10:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1f12:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1f16:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f1c:	9b 81       	ldd	r25, Y+3	; 0x03
    1f1e:	82 0f       	add	r24, r18
    1f20:	93 1f       	adc	r25, r19
    1f22:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1f26:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1f2a:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
	}
}
    1f2e:	df 91       	pop	r29
    1f30:	cf 91       	pop	r28
    1f32:	1f 91       	pop	r17
    1f34:	0f 91       	pop	r16
    1f36:	08 95       	ret

00001f38 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1f38:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1f3c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1f40:	08 95       	ret

00001f42 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1f42:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1f44:	03 96       	adiw	r24, 0x03	; 3
    1f46:	81 83       	std	Z+1, r24	; 0x01
    1f48:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f4a:	4f ef       	ldi	r20, 0xFF	; 255
    1f4c:	5f ef       	ldi	r21, 0xFF	; 255
    1f4e:	ba 01       	movw	r22, r20
    1f50:	43 83       	std	Z+3, r20	; 0x03
    1f52:	54 83       	std	Z+4, r21	; 0x04
    1f54:	65 83       	std	Z+5, r22	; 0x05
    1f56:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1f58:	87 83       	std	Z+7, r24	; 0x07
    1f5a:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1f5c:	81 87       	std	Z+9, r24	; 0x09
    1f5e:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1f60:	10 82       	st	Z, r1
    1f62:	08 95       	ret

00001f64 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f64:	fc 01       	movw	r30, r24
    1f66:	12 86       	std	Z+10, r1	; 0x0a
    1f68:	13 86       	std	Z+11, r1	; 0x0b
    1f6a:	08 95       	ret

00001f6c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1f6c:	cf 93       	push	r28
    1f6e:	df 93       	push	r29
    1f70:	fc 01       	movw	r30, r24
    1f72:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1f74:	21 81       	ldd	r18, Z+1	; 0x01
    1f76:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1f78:	e9 01       	movw	r28, r18
    1f7a:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7c:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7e:	14 96       	adiw	r26, 0x04	; 4
    1f80:	8d 93       	st	X+, r24
    1f82:	9c 93       	st	X, r25
    1f84:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1f86:	81 81       	ldd	r24, Z+1	; 0x01
    1f88:	92 81       	ldd	r25, Z+2	; 0x02
    1f8a:	16 96       	adiw	r26, 0x06	; 6
    1f8c:	8d 93       	st	X+, r24
    1f8e:	9c 93       	st	X, r25
    1f90:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1f92:	8c 81       	ldd	r24, Y+4	; 0x04
    1f94:	9d 81       	ldd	r25, Y+5	; 0x05
    1f96:	ec 01       	movw	r28, r24
    1f98:	6e 83       	std	Y+6, r22	; 0x06
    1f9a:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1f9c:	e9 01       	movw	r28, r18
    1f9e:	6c 83       	std	Y+4, r22	; 0x04
    1fa0:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1fa2:	61 83       	std	Z+1, r22	; 0x01
    1fa4:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fa6:	1a 96       	adiw	r26, 0x0a	; 10
    1fa8:	ed 93       	st	X+, r30
    1faa:	fc 93       	st	X, r31
    1fac:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1fae:	80 81       	ld	r24, Z
    1fb0:	8f 5f       	subi	r24, 0xFF	; 255
    1fb2:	80 83       	st	Z, r24
}
    1fb4:	df 91       	pop	r29
    1fb6:	cf 91       	pop	r28
    1fb8:	08 95       	ret

00001fba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1fba:	0f 93       	push	r16
    1fbc:	1f 93       	push	r17
    1fbe:	cf 93       	push	r28
    1fc0:	df 93       	push	r29
    1fc2:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1fc4:	08 81       	ld	r16, Y
    1fc6:	19 81       	ldd	r17, Y+1	; 0x01
    1fc8:	2a 81       	ldd	r18, Y+2	; 0x02
    1fca:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1fcc:	0f 3f       	cpi	r16, 0xFF	; 255
    1fce:	4f ef       	ldi	r20, 0xFF	; 255
    1fd0:	14 07       	cpc	r17, r20
    1fd2:	24 07       	cpc	r18, r20
    1fd4:	34 07       	cpc	r19, r20
    1fd6:	31 f4       	brne	.+12     	; 0x1fe4 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1fd8:	dc 01       	movw	r26, r24
    1fda:	19 96       	adiw	r26, 0x09	; 9
    1fdc:	ed 91       	ld	r30, X+
    1fde:	fc 91       	ld	r31, X
    1fe0:	1a 97       	sbiw	r26, 0x0a	; 10
    1fe2:	1f c0       	rjmp	.+62     	; 0x2022 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1fe4:	fc 01       	movw	r30, r24
    1fe6:	33 96       	adiw	r30, 0x03	; 3
    1fe8:	dc 01       	movw	r26, r24
    1fea:	17 96       	adiw	r26, 0x07	; 7
    1fec:	4d 91       	ld	r20, X+
    1fee:	5c 91       	ld	r21, X
    1ff0:	18 97       	sbiw	r26, 0x08	; 8
    1ff2:	da 01       	movw	r26, r20
    1ff4:	4d 91       	ld	r20, X+
    1ff6:	5d 91       	ld	r21, X+
    1ff8:	6d 91       	ld	r22, X+
    1ffa:	7c 91       	ld	r23, X
    1ffc:	04 17       	cp	r16, r20
    1ffe:	15 07       	cpc	r17, r21
    2000:	26 07       	cpc	r18, r22
    2002:	37 07       	cpc	r19, r23
    2004:	70 f0       	brcs	.+28     	; 0x2022 <vListInsert+0x68>
    2006:	04 80       	ldd	r0, Z+4	; 0x04
    2008:	f5 81       	ldd	r31, Z+5	; 0x05
    200a:	e0 2d       	mov	r30, r0
    200c:	a4 81       	ldd	r26, Z+4	; 0x04
    200e:	b5 81       	ldd	r27, Z+5	; 0x05
    2010:	4d 91       	ld	r20, X+
    2012:	5d 91       	ld	r21, X+
    2014:	6d 91       	ld	r22, X+
    2016:	7c 91       	ld	r23, X
    2018:	04 17       	cp	r16, r20
    201a:	15 07       	cpc	r17, r21
    201c:	26 07       	cpc	r18, r22
    201e:	37 07       	cpc	r19, r23
    2020:	90 f7       	brcc	.-28     	; 0x2006 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2022:	a4 81       	ldd	r26, Z+4	; 0x04
    2024:	b5 81       	ldd	r27, Z+5	; 0x05
    2026:	ac 83       	std	Y+4, r26	; 0x04
    2028:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    202a:	16 96       	adiw	r26, 0x06	; 6
    202c:	cd 93       	st	X+, r28
    202e:	dc 93       	st	X, r29
    2030:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    2032:	ee 83       	std	Y+6, r30	; 0x06
    2034:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2036:	c4 83       	std	Z+4, r28	; 0x04
    2038:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    203a:	8a 87       	std	Y+10, r24	; 0x0a
    203c:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    203e:	fc 01       	movw	r30, r24
    2040:	20 81       	ld	r18, Z
    2042:	2f 5f       	subi	r18, 0xFF	; 255
    2044:	20 83       	st	Z, r18
}
    2046:	df 91       	pop	r29
    2048:	cf 91       	pop	r28
    204a:	1f 91       	pop	r17
    204c:	0f 91       	pop	r16
    204e:	08 95       	ret

00002050 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2050:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2052:	a4 81       	ldd	r26, Z+4	; 0x04
    2054:	b5 81       	ldd	r27, Z+5	; 0x05
    2056:	86 81       	ldd	r24, Z+6	; 0x06
    2058:	97 81       	ldd	r25, Z+7	; 0x07
    205a:	16 96       	adiw	r26, 0x06	; 6
    205c:	8d 93       	st	X+, r24
    205e:	9c 93       	st	X, r25
    2060:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2062:	a6 81       	ldd	r26, Z+6	; 0x06
    2064:	b7 81       	ldd	r27, Z+7	; 0x07
    2066:	84 81       	ldd	r24, Z+4	; 0x04
    2068:	95 81       	ldd	r25, Z+5	; 0x05
    206a:	14 96       	adiw	r26, 0x04	; 4
    206c:	8d 93       	st	X+, r24
    206e:	9c 93       	st	X, r25
    2070:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2072:	a2 85       	ldd	r26, Z+10	; 0x0a
    2074:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2076:	11 96       	adiw	r26, 0x01	; 1
    2078:	8d 91       	ld	r24, X+
    207a:	9c 91       	ld	r25, X
    207c:	12 97       	sbiw	r26, 0x02	; 2
    207e:	e8 17       	cp	r30, r24
    2080:	f9 07       	cpc	r31, r25
    2082:	31 f4       	brne	.+12     	; 0x2090 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2084:	86 81       	ldd	r24, Z+6	; 0x06
    2086:	97 81       	ldd	r25, Z+7	; 0x07
    2088:	11 96       	adiw	r26, 0x01	; 1
    208a:	8d 93       	st	X+, r24
    208c:	9c 93       	st	X, r25
    208e:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    2090:	12 86       	std	Z+10, r1	; 0x0a
    2092:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    2094:	8c 91       	ld	r24, X
    2096:	81 50       	subi	r24, 0x01	; 1
    2098:	8c 93       	st	X, r24
    209a:	08 95       	ret

0000209c <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    209c:	80 93 02 33 	sts	0x3302, r24	; 0x803302 <portStackTopForTask>
    20a0:	90 93 03 33 	sts	0x3303, r25	; 0x803303 <portStackTopForTask+0x1>
    20a4:	31 e1       	ldi	r19, 0x11	; 17
    20a6:	fc 01       	movw	r30, r24
    20a8:	30 83       	st	Z, r19
    20aa:	31 97       	sbiw	r30, 0x01	; 1
    20ac:	22 e2       	ldi	r18, 0x22	; 34
    20ae:	20 83       	st	Z, r18
    20b0:	31 97       	sbiw	r30, 0x01	; 1
    20b2:	a3 e3       	ldi	r26, 0x33	; 51
    20b4:	a0 83       	st	Z, r26
    20b6:	31 97       	sbiw	r30, 0x01	; 1
    20b8:	60 83       	st	Z, r22
    20ba:	31 97       	sbiw	r30, 0x01	; 1
    20bc:	70 83       	st	Z, r23
    20be:	31 97       	sbiw	r30, 0x01	; 1
    20c0:	10 82       	st	Z, r1
    20c2:	31 97       	sbiw	r30, 0x01	; 1
    20c4:	10 82       	st	Z, r1
    20c6:	31 97       	sbiw	r30, 0x01	; 1
    20c8:	60 e8       	ldi	r22, 0x80	; 128
    20ca:	60 83       	st	Z, r22
    20cc:	31 97       	sbiw	r30, 0x01	; 1
    20ce:	10 82       	st	Z, r1
    20d0:	31 97       	sbiw	r30, 0x01	; 1
    20d2:	10 82       	st	Z, r1
    20d4:	31 97       	sbiw	r30, 0x01	; 1
    20d6:	10 82       	st	Z, r1
    20d8:	31 97       	sbiw	r30, 0x01	; 1
    20da:	62 e0       	ldi	r22, 0x02	; 2
    20dc:	60 83       	st	Z, r22
    20de:	31 97       	sbiw	r30, 0x01	; 1
    20e0:	63 e0       	ldi	r22, 0x03	; 3
    20e2:	60 83       	st	Z, r22
    20e4:	31 97       	sbiw	r30, 0x01	; 1
    20e6:	64 e0       	ldi	r22, 0x04	; 4
    20e8:	60 83       	st	Z, r22
    20ea:	31 97       	sbiw	r30, 0x01	; 1
    20ec:	65 e0       	ldi	r22, 0x05	; 5
    20ee:	60 83       	st	Z, r22
    20f0:	31 97       	sbiw	r30, 0x01	; 1
    20f2:	66 e0       	ldi	r22, 0x06	; 6
    20f4:	60 83       	st	Z, r22
    20f6:	31 97       	sbiw	r30, 0x01	; 1
    20f8:	67 e0       	ldi	r22, 0x07	; 7
    20fa:	60 83       	st	Z, r22
    20fc:	31 97       	sbiw	r30, 0x01	; 1
    20fe:	68 e0       	ldi	r22, 0x08	; 8
    2100:	60 83       	st	Z, r22
    2102:	31 97       	sbiw	r30, 0x01	; 1
    2104:	69 e0       	ldi	r22, 0x09	; 9
    2106:	60 83       	st	Z, r22
    2108:	31 97       	sbiw	r30, 0x01	; 1
    210a:	60 e1       	ldi	r22, 0x10	; 16
    210c:	60 83       	st	Z, r22
    210e:	31 97       	sbiw	r30, 0x01	; 1
    2110:	30 83       	st	Z, r19
    2112:	31 97       	sbiw	r30, 0x01	; 1
    2114:	32 e1       	ldi	r19, 0x12	; 18
    2116:	30 83       	st	Z, r19
    2118:	31 97       	sbiw	r30, 0x01	; 1
    211a:	33 e1       	ldi	r19, 0x13	; 19
    211c:	30 83       	st	Z, r19
    211e:	31 97       	sbiw	r30, 0x01	; 1
    2120:	34 e1       	ldi	r19, 0x14	; 20
    2122:	30 83       	st	Z, r19
    2124:	31 97       	sbiw	r30, 0x01	; 1
    2126:	35 e1       	ldi	r19, 0x15	; 21
    2128:	30 83       	st	Z, r19
    212a:	31 97       	sbiw	r30, 0x01	; 1
    212c:	36 e1       	ldi	r19, 0x16	; 22
    212e:	30 83       	st	Z, r19
    2130:	31 97       	sbiw	r30, 0x01	; 1
    2132:	37 e1       	ldi	r19, 0x17	; 23
    2134:	30 83       	st	Z, r19
    2136:	31 97       	sbiw	r30, 0x01	; 1
    2138:	38 e1       	ldi	r19, 0x18	; 24
    213a:	30 83       	st	Z, r19
    213c:	31 97       	sbiw	r30, 0x01	; 1
    213e:	39 e1       	ldi	r19, 0x19	; 25
    2140:	30 83       	st	Z, r19
    2142:	31 97       	sbiw	r30, 0x01	; 1
    2144:	30 e2       	ldi	r19, 0x20	; 32
    2146:	30 83       	st	Z, r19
    2148:	31 97       	sbiw	r30, 0x01	; 1
    214a:	31 e2       	ldi	r19, 0x21	; 33
    214c:	30 83       	st	Z, r19
    214e:	31 97       	sbiw	r30, 0x01	; 1
    2150:	20 83       	st	Z, r18
    2152:	31 97       	sbiw	r30, 0x01	; 1
    2154:	23 e2       	ldi	r18, 0x23	; 35
    2156:	20 83       	st	Z, r18
    2158:	31 97       	sbiw	r30, 0x01	; 1
    215a:	40 83       	st	Z, r20
    215c:	31 97       	sbiw	r30, 0x01	; 1
    215e:	50 83       	st	Z, r21
    2160:	31 97       	sbiw	r30, 0x01	; 1
    2162:	26 e2       	ldi	r18, 0x26	; 38
    2164:	20 83       	st	Z, r18
    2166:	31 97       	sbiw	r30, 0x01	; 1
    2168:	27 e2       	ldi	r18, 0x27	; 39
    216a:	20 83       	st	Z, r18
    216c:	31 97       	sbiw	r30, 0x01	; 1
    216e:	28 e2       	ldi	r18, 0x28	; 40
    2170:	20 83       	st	Z, r18
    2172:	31 97       	sbiw	r30, 0x01	; 1
    2174:	29 e2       	ldi	r18, 0x29	; 41
    2176:	20 83       	st	Z, r18
    2178:	31 97       	sbiw	r30, 0x01	; 1
    217a:	20 e3       	ldi	r18, 0x30	; 48
    217c:	20 83       	st	Z, r18
    217e:	31 97       	sbiw	r30, 0x01	; 1
    2180:	21 e3       	ldi	r18, 0x31	; 49
    2182:	20 83       	st	Z, r18
    2184:	89 97       	sbiw	r24, 0x29	; 41
    2186:	08 95       	ret

00002188 <xPortStartScheduler>:
    2188:	8c e7       	ldi	r24, 0x7C	; 124
    218a:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    218e:	8f ef       	ldi	r24, 0xFF	; 255
    2190:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    2194:	81 e0       	ldi	r24, 0x01	; 1
    2196:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    219a:	91 e1       	ldi	r25, 0x11	; 17
    219c:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    21a0:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    21a4:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    21a8:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    21ac:	cd 91       	ld	r28, X+
    21ae:	cd bf       	out	0x3d, r28	; 61
    21b0:	dd 91       	ld	r29, X+
    21b2:	de bf       	out	0x3e, r29	; 62
    21b4:	ff 91       	pop	r31
    21b6:	ef 91       	pop	r30
    21b8:	df 91       	pop	r29
    21ba:	cf 91       	pop	r28
    21bc:	bf 91       	pop	r27
    21be:	af 91       	pop	r26
    21c0:	9f 91       	pop	r25
    21c2:	8f 91       	pop	r24
    21c4:	7f 91       	pop	r23
    21c6:	6f 91       	pop	r22
    21c8:	5f 91       	pop	r21
    21ca:	4f 91       	pop	r20
    21cc:	3f 91       	pop	r19
    21ce:	2f 91       	pop	r18
    21d0:	1f 91       	pop	r17
    21d2:	0f 91       	pop	r16
    21d4:	ff 90       	pop	r15
    21d6:	ef 90       	pop	r14
    21d8:	df 90       	pop	r13
    21da:	cf 90       	pop	r12
    21dc:	bf 90       	pop	r11
    21de:	af 90       	pop	r10
    21e0:	9f 90       	pop	r9
    21e2:	8f 90       	pop	r8
    21e4:	7f 90       	pop	r7
    21e6:	6f 90       	pop	r6
    21e8:	5f 90       	pop	r5
    21ea:	4f 90       	pop	r4
    21ec:	3f 90       	pop	r3
    21ee:	2f 90       	pop	r2
    21f0:	1f 90       	pop	r1
    21f2:	0f 90       	pop	r0
    21f4:	0c be       	out	0x3c, r0	; 60
    21f6:	0f 90       	pop	r0
    21f8:	0b be       	out	0x3b, r0	; 59
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	0f 90       	pop	r0
    2200:	08 95       	ret
    2202:	08 95       	ret

00002204 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2204:	0f 92       	push	r0
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	0f 92       	push	r0
    220c:	0b b6       	in	r0, 0x3b	; 59
    220e:	0f 92       	push	r0
    2210:	0c b6       	in	r0, 0x3c	; 60
    2212:	0f 92       	push	r0
    2214:	1f 92       	push	r1
    2216:	11 24       	eor	r1, r1
    2218:	2f 92       	push	r2
    221a:	3f 92       	push	r3
    221c:	4f 92       	push	r4
    221e:	5f 92       	push	r5
    2220:	6f 92       	push	r6
    2222:	7f 92       	push	r7
    2224:	8f 92       	push	r8
    2226:	9f 92       	push	r9
    2228:	af 92       	push	r10
    222a:	bf 92       	push	r11
    222c:	cf 92       	push	r12
    222e:	df 92       	push	r13
    2230:	ef 92       	push	r14
    2232:	ff 92       	push	r15
    2234:	0f 93       	push	r16
    2236:	1f 93       	push	r17
    2238:	2f 93       	push	r18
    223a:	3f 93       	push	r19
    223c:	4f 93       	push	r20
    223e:	5f 93       	push	r21
    2240:	6f 93       	push	r22
    2242:	7f 93       	push	r23
    2244:	8f 93       	push	r24
    2246:	9f 93       	push	r25
    2248:	af 93       	push	r26
    224a:	bf 93       	push	r27
    224c:	cf 93       	push	r28
    224e:	df 93       	push	r29
    2250:	ef 93       	push	r30
    2252:	ff 93       	push	r31
    2254:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    2258:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    225c:	0d b6       	in	r0, 0x3d	; 61
    225e:	0d 92       	st	X+, r0
    2260:	0e b6       	in	r0, 0x3e	; 62
    2262:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2264:	0e 94 11 18 	call	0x3022	; 0x3022 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2268:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    226c:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2270:	cd 91       	ld	r28, X+
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	dd 91       	ld	r29, X+
    2276:	de bf       	out	0x3e, r29	; 62
    2278:	ff 91       	pop	r31
    227a:	ef 91       	pop	r30
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	bf 91       	pop	r27
    2282:	af 91       	pop	r26
    2284:	9f 91       	pop	r25
    2286:	8f 91       	pop	r24
    2288:	7f 91       	pop	r23
    228a:	6f 91       	pop	r22
    228c:	5f 91       	pop	r21
    228e:	4f 91       	pop	r20
    2290:	3f 91       	pop	r19
    2292:	2f 91       	pop	r18
    2294:	1f 91       	pop	r17
    2296:	0f 91       	pop	r16
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	df 90       	pop	r13
    229e:	cf 90       	pop	r12
    22a0:	bf 90       	pop	r11
    22a2:	af 90       	pop	r10
    22a4:	9f 90       	pop	r9
    22a6:	8f 90       	pop	r8
    22a8:	7f 90       	pop	r7
    22aa:	6f 90       	pop	r6
    22ac:	5f 90       	pop	r5
    22ae:	4f 90       	pop	r4
    22b0:	3f 90       	pop	r3
    22b2:	2f 90       	pop	r2
    22b4:	1f 90       	pop	r1
    22b6:	0f 90       	pop	r0
    22b8:	0c be       	out	0x3c, r0	; 60
    22ba:	0f 90       	pop	r0
    22bc:	0b be       	out	0x3b, r0	; 59
    22be:	0f 90       	pop	r0
    22c0:	0f be       	out	0x3f, r0	; 63
    22c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    22c4:	08 95       	ret

000022c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    22c6:	0f 92       	push	r0
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	0f 92       	push	r0
    22ce:	0b b6       	in	r0, 0x3b	; 59
    22d0:	0f 92       	push	r0
    22d2:	0c b6       	in	r0, 0x3c	; 60
    22d4:	0f 92       	push	r0
    22d6:	1f 92       	push	r1
    22d8:	11 24       	eor	r1, r1
    22da:	2f 92       	push	r2
    22dc:	3f 92       	push	r3
    22de:	4f 92       	push	r4
    22e0:	5f 92       	push	r5
    22e2:	6f 92       	push	r6
    22e4:	7f 92       	push	r7
    22e6:	8f 92       	push	r8
    22e8:	9f 92       	push	r9
    22ea:	af 92       	push	r10
    22ec:	bf 92       	push	r11
    22ee:	cf 92       	push	r12
    22f0:	df 92       	push	r13
    22f2:	ef 92       	push	r14
    22f4:	ff 92       	push	r15
    22f6:	0f 93       	push	r16
    22f8:	1f 93       	push	r17
    22fa:	2f 93       	push	r18
    22fc:	3f 93       	push	r19
    22fe:	4f 93       	push	r20
    2300:	5f 93       	push	r21
    2302:	6f 93       	push	r22
    2304:	7f 93       	push	r23
    2306:	8f 93       	push	r24
    2308:	9f 93       	push	r25
    230a:	af 93       	push	r26
    230c:	bf 93       	push	r27
    230e:	cf 93       	push	r28
    2310:	df 93       	push	r29
    2312:	ef 93       	push	r30
    2314:	ff 93       	push	r31
    2316:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    231a:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    231e:	0d b6       	in	r0, 0x3d	; 61
    2320:	0d 92       	st	X+, r0
    2322:	0e b6       	in	r0, 0x3e	; 62
    2324:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2326:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <vTaskIncrementTick>
	vTaskSwitchContext();
    232a:	0e 94 11 18 	call	0x3022	; 0x3022 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    232e:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    2332:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2336:	cd 91       	ld	r28, X+
    2338:	cd bf       	out	0x3d, r28	; 61
    233a:	dd 91       	ld	r29, X+
    233c:	de bf       	out	0x3e, r29	; 62
    233e:	ff 91       	pop	r31
    2340:	ef 91       	pop	r30
    2342:	df 91       	pop	r29
    2344:	cf 91       	pop	r28
    2346:	bf 91       	pop	r27
    2348:	af 91       	pop	r26
    234a:	9f 91       	pop	r25
    234c:	8f 91       	pop	r24
    234e:	7f 91       	pop	r23
    2350:	6f 91       	pop	r22
    2352:	5f 91       	pop	r21
    2354:	4f 91       	pop	r20
    2356:	3f 91       	pop	r19
    2358:	2f 91       	pop	r18
    235a:	1f 91       	pop	r17
    235c:	0f 91       	pop	r16
    235e:	ff 90       	pop	r15
    2360:	ef 90       	pop	r14
    2362:	df 90       	pop	r13
    2364:	cf 90       	pop	r12
    2366:	bf 90       	pop	r11
    2368:	af 90       	pop	r10
    236a:	9f 90       	pop	r9
    236c:	8f 90       	pop	r8
    236e:	7f 90       	pop	r7
    2370:	6f 90       	pop	r6
    2372:	5f 90       	pop	r5
    2374:	4f 90       	pop	r4
    2376:	3f 90       	pop	r3
    2378:	2f 90       	pop	r2
    237a:	1f 90       	pop	r1
    237c:	0f 90       	pop	r0
    237e:	0c be       	out	0x3c, r0	; 60
    2380:	0f 90       	pop	r0
    2382:	0b be       	out	0x3b, r0	; 59
    2384:	0f 90       	pop	r0
    2386:	0f be       	out	0x3f, r0	; 63
    2388:	0f 90       	pop	r0

	asm volatile ( "ret" );
    238a:	08 95       	ret

0000238c <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    238c:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2390:	18 95       	reti

00002392 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2392:	cf 93       	push	r28
    2394:	df 93       	push	r29
    2396:	ec 01       	movw	r28, r24
    2398:	88 a1       	ldd	r24, Y+32	; 0x20
    239a:	81 11       	cpse	r24, r1
    239c:	0b c0       	rjmp	.+22     	; 0x23b4 <prvCopyDataToQueue+0x22>
    239e:	88 81       	ld	r24, Y
    23a0:	99 81       	ldd	r25, Y+1	; 0x01
    23a2:	89 2b       	or	r24, r25
    23a4:	e1 f5       	brne	.+120    	; 0x241e <prvCopyDataToQueue+0x8c>
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	9b 81       	ldd	r25, Y+3	; 0x03
    23aa:	0e 94 cc 19 	call	0x3398	; 0x3398 <vTaskPriorityDisinherit>
    23ae:	1a 82       	std	Y+2, r1	; 0x02
    23b0:	1b 82       	std	Y+3, r1	; 0x03
    23b2:	35 c0       	rjmp	.+106    	; 0x241e <prvCopyDataToQueue+0x8c>
    23b4:	41 11       	cpse	r20, r1
    23b6:	17 c0       	rjmp	.+46     	; 0x23e6 <prvCopyDataToQueue+0x54>
    23b8:	48 2f       	mov	r20, r24
    23ba:	50 e0       	ldi	r21, 0x00	; 0
    23bc:	8c 81       	ldd	r24, Y+4	; 0x04
    23be:	9d 81       	ldd	r25, Y+5	; 0x05
    23c0:	0e 94 0b 27 	call	0x4e16	; 0x4e16 <memcpy>
    23c4:	28 a1       	ldd	r18, Y+32	; 0x20
    23c6:	8c 81       	ldd	r24, Y+4	; 0x04
    23c8:	9d 81       	ldd	r25, Y+5	; 0x05
    23ca:	82 0f       	add	r24, r18
    23cc:	91 1d       	adc	r25, r1
    23ce:	8c 83       	std	Y+4, r24	; 0x04
    23d0:	9d 83       	std	Y+5, r25	; 0x05
    23d2:	2a 81       	ldd	r18, Y+2	; 0x02
    23d4:	3b 81       	ldd	r19, Y+3	; 0x03
    23d6:	82 17       	cp	r24, r18
    23d8:	93 07       	cpc	r25, r19
    23da:	08 f1       	brcs	.+66     	; 0x241e <prvCopyDataToQueue+0x8c>
    23dc:	88 81       	ld	r24, Y
    23de:	99 81       	ldd	r25, Y+1	; 0x01
    23e0:	8c 83       	std	Y+4, r24	; 0x04
    23e2:	9d 83       	std	Y+5, r25	; 0x05
    23e4:	1c c0       	rjmp	.+56     	; 0x241e <prvCopyDataToQueue+0x8c>
    23e6:	48 2f       	mov	r20, r24
    23e8:	50 e0       	ldi	r21, 0x00	; 0
    23ea:	8e 81       	ldd	r24, Y+6	; 0x06
    23ec:	9f 81       	ldd	r25, Y+7	; 0x07
    23ee:	0e 94 0b 27 	call	0x4e16	; 0x4e16 <memcpy>
    23f2:	88 a1       	ldd	r24, Y+32	; 0x20
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	91 95       	neg	r25
    23f8:	81 95       	neg	r24
    23fa:	91 09       	sbc	r25, r1
    23fc:	2e 81       	ldd	r18, Y+6	; 0x06
    23fe:	3f 81       	ldd	r19, Y+7	; 0x07
    2400:	28 0f       	add	r18, r24
    2402:	39 1f       	adc	r19, r25
    2404:	2e 83       	std	Y+6, r18	; 0x06
    2406:	3f 83       	std	Y+7, r19	; 0x07
    2408:	48 81       	ld	r20, Y
    240a:	59 81       	ldd	r21, Y+1	; 0x01
    240c:	24 17       	cp	r18, r20
    240e:	35 07       	cpc	r19, r21
    2410:	30 f4       	brcc	.+12     	; 0x241e <prvCopyDataToQueue+0x8c>
    2412:	2a 81       	ldd	r18, Y+2	; 0x02
    2414:	3b 81       	ldd	r19, Y+3	; 0x03
    2416:	82 0f       	add	r24, r18
    2418:	93 1f       	adc	r25, r19
    241a:	8e 83       	std	Y+6, r24	; 0x06
    241c:	9f 83       	std	Y+7, r25	; 0x07
    241e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2420:	8f 5f       	subi	r24, 0xFF	; 255
    2422:	8e 8f       	std	Y+30, r24	; 0x1e
    2424:	df 91       	pop	r29
    2426:	cf 91       	pop	r28
    2428:	08 95       	ret

0000242a <prvCopyDataFromQueue>:
    242a:	fc 01       	movw	r30, r24
    242c:	80 81       	ld	r24, Z
    242e:	91 81       	ldd	r25, Z+1	; 0x01
    2430:	00 97       	sbiw	r24, 0x00	; 0
    2432:	a1 f0       	breq	.+40     	; 0x245c <prvCopyDataFromQueue+0x32>
    2434:	40 a1       	ldd	r20, Z+32	; 0x20
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	26 81       	ldd	r18, Z+6	; 0x06
    243a:	37 81       	ldd	r19, Z+7	; 0x07
    243c:	24 0f       	add	r18, r20
    243e:	35 1f       	adc	r19, r21
    2440:	26 83       	std	Z+6, r18	; 0x06
    2442:	37 83       	std	Z+7, r19	; 0x07
    2444:	a2 81       	ldd	r26, Z+2	; 0x02
    2446:	b3 81       	ldd	r27, Z+3	; 0x03
    2448:	2a 17       	cp	r18, r26
    244a:	3b 07       	cpc	r19, r27
    244c:	10 f0       	brcs	.+4      	; 0x2452 <prvCopyDataFromQueue+0x28>
    244e:	86 83       	std	Z+6, r24	; 0x06
    2450:	97 83       	std	Z+7, r25	; 0x07
    2452:	cb 01       	movw	r24, r22
    2454:	66 81       	ldd	r22, Z+6	; 0x06
    2456:	77 81       	ldd	r23, Z+7	; 0x07
    2458:	0e 94 0b 27 	call	0x4e16	; 0x4e16 <memcpy>
    245c:	08 95       	ret

0000245e <prvUnlockQueue>:
    245e:	0f 93       	push	r16
    2460:	1f 93       	push	r17
    2462:	cf 93       	push	r28
    2464:	df 93       	push	r29
    2466:	ec 01       	movw	r28, r24
    2468:	0f b6       	in	r0, 0x3f	; 63
    246a:	f8 94       	cli
    246c:	0f 92       	push	r0
    246e:	8a a1       	ldd	r24, Y+34	; 0x22
    2470:	18 16       	cp	r1, r24
    2472:	b4 f4       	brge	.+44     	; 0x24a0 <prvUnlockQueue+0x42>
    2474:	8b 89       	ldd	r24, Y+19	; 0x13
    2476:	81 11       	cpse	r24, r1
    2478:	05 c0       	rjmp	.+10     	; 0x2484 <prvUnlockQueue+0x26>
    247a:	12 c0       	rjmp	.+36     	; 0x24a0 <prvUnlockQueue+0x42>
    247c:	8b 89       	ldd	r24, Y+19	; 0x13
    247e:	81 11       	cpse	r24, r1
    2480:	04 c0       	rjmp	.+8      	; 0x248a <prvUnlockQueue+0x2c>
    2482:	0e c0       	rjmp	.+28     	; 0x24a0 <prvUnlockQueue+0x42>
    2484:	8e 01       	movw	r16, r28
    2486:	0d 5e       	subi	r16, 0xED	; 237
    2488:	1f 4f       	sbci	r17, 0xFF	; 255
    248a:	c8 01       	movw	r24, r16
    248c:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    2490:	81 11       	cpse	r24, r1
    2492:	0e 94 55 19 	call	0x32aa	; 0x32aa <vTaskMissedYield>
    2496:	8a a1       	ldd	r24, Y+34	; 0x22
    2498:	81 50       	subi	r24, 0x01	; 1
    249a:	8a a3       	std	Y+34, r24	; 0x22
    249c:	18 16       	cp	r1, r24
    249e:	74 f3       	brlt	.-36     	; 0x247c <prvUnlockQueue+0x1e>
    24a0:	8f ef       	ldi	r24, 0xFF	; 255
    24a2:	8a a3       	std	Y+34, r24	; 0x22
    24a4:	0f 90       	pop	r0
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	0f b6       	in	r0, 0x3f	; 63
    24aa:	f8 94       	cli
    24ac:	0f 92       	push	r0
    24ae:	89 a1       	ldd	r24, Y+33	; 0x21
    24b0:	18 16       	cp	r1, r24
    24b2:	b4 f4       	brge	.+44     	; 0x24e0 <prvUnlockQueue+0x82>
    24b4:	88 85       	ldd	r24, Y+8	; 0x08
    24b6:	81 11       	cpse	r24, r1
    24b8:	05 c0       	rjmp	.+10     	; 0x24c4 <prvUnlockQueue+0x66>
    24ba:	12 c0       	rjmp	.+36     	; 0x24e0 <prvUnlockQueue+0x82>
    24bc:	88 85       	ldd	r24, Y+8	; 0x08
    24be:	81 11       	cpse	r24, r1
    24c0:	04 c0       	rjmp	.+8      	; 0x24ca <prvUnlockQueue+0x6c>
    24c2:	0e c0       	rjmp	.+28     	; 0x24e0 <prvUnlockQueue+0x82>
    24c4:	8e 01       	movw	r16, r28
    24c6:	08 5f       	subi	r16, 0xF8	; 248
    24c8:	1f 4f       	sbci	r17, 0xFF	; 255
    24ca:	c8 01       	movw	r24, r16
    24cc:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    24d0:	81 11       	cpse	r24, r1
    24d2:	0e 94 55 19 	call	0x32aa	; 0x32aa <vTaskMissedYield>
    24d6:	89 a1       	ldd	r24, Y+33	; 0x21
    24d8:	81 50       	subi	r24, 0x01	; 1
    24da:	89 a3       	std	Y+33, r24	; 0x21
    24dc:	18 16       	cp	r1, r24
    24de:	74 f3       	brlt	.-36     	; 0x24bc <prvUnlockQueue+0x5e>
    24e0:	8f ef       	ldi	r24, 0xFF	; 255
    24e2:	89 a3       	std	Y+33, r24	; 0x21
    24e4:	0f 90       	pop	r0
    24e6:	0f be       	out	0x3f, r0	; 63
    24e8:	df 91       	pop	r29
    24ea:	cf 91       	pop	r28
    24ec:	1f 91       	pop	r17
    24ee:	0f 91       	pop	r16
    24f0:	08 95       	ret

000024f2 <xQueueGenericReset>:
    24f2:	1f 93       	push	r17
    24f4:	cf 93       	push	r28
    24f6:	df 93       	push	r29
    24f8:	61 30       	cpi	r22, 0x01	; 1
    24fa:	59 f0       	breq	.+22     	; 0x2512 <xQueueGenericReset+0x20>
    24fc:	fc 01       	movw	r30, r24
    24fe:	23 89       	ldd	r18, Z+19	; 0x13
    2500:	30 85       	ldd	r19, Z+8	; 0x08
    2502:	31 11       	cpse	r19, r1
    2504:	2c c0       	rjmp	.+88     	; 0x255e <xQueueGenericReset+0x6c>
    2506:	11 e0       	ldi	r17, 0x01	; 1
    2508:	21 11       	cpse	r18, r1
    250a:	10 e0       	ldi	r17, 0x00	; 0
    250c:	21 11       	cpse	r18, r1
    250e:	28 c0       	rjmp	.+80     	; 0x2560 <xQueueGenericReset+0x6e>
    2510:	01 c0       	rjmp	.+2      	; 0x2514 <xQueueGenericReset+0x22>
    2512:	11 e0       	ldi	r17, 0x01	; 1
    2514:	ec 01       	movw	r28, r24
    2516:	48 81       	ld	r20, Y
    2518:	59 81       	ldd	r21, Y+1	; 0x01
    251a:	28 a1       	ldd	r18, Y+32	; 0x20
    251c:	30 e0       	ldi	r19, 0x00	; 0
    251e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2520:	62 9f       	mul	r22, r18
    2522:	c0 01       	movw	r24, r0
    2524:	63 9f       	mul	r22, r19
    2526:	90 0d       	add	r25, r0
    2528:	11 24       	eor	r1, r1
    252a:	ba 01       	movw	r22, r20
    252c:	68 0f       	add	r22, r24
    252e:	79 1f       	adc	r23, r25
    2530:	6a 83       	std	Y+2, r22	; 0x02
    2532:	7b 83       	std	Y+3, r23	; 0x03
    2534:	1e 8e       	std	Y+30, r1	; 0x1e
    2536:	4c 83       	std	Y+4, r20	; 0x04
    2538:	5d 83       	std	Y+5, r21	; 0x05
    253a:	82 1b       	sub	r24, r18
    253c:	93 0b       	sbc	r25, r19
    253e:	84 0f       	add	r24, r20
    2540:	95 1f       	adc	r25, r21
    2542:	8e 83       	std	Y+6, r24	; 0x06
    2544:	9f 83       	std	Y+7, r25	; 0x07
    2546:	8f ef       	ldi	r24, 0xFF	; 255
    2548:	89 a3       	std	Y+33, r24	; 0x21
    254a:	8a a3       	std	Y+34, r24	; 0x22
    254c:	ce 01       	movw	r24, r28
    254e:	08 96       	adiw	r24, 0x08	; 8
    2550:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2554:	ce 01       	movw	r24, r28
    2556:	43 96       	adiw	r24, 0x13	; 19
    2558:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    255c:	01 c0       	rjmp	.+2      	; 0x2560 <xQueueGenericReset+0x6e>
    255e:	10 e0       	ldi	r17, 0x00	; 0
    2560:	81 2f       	mov	r24, r17
    2562:	df 91       	pop	r29
    2564:	cf 91       	pop	r28
    2566:	1f 91       	pop	r17
    2568:	08 95       	ret

0000256a <xQueueGenericCreate>:
    256a:	0f 93       	push	r16
    256c:	1f 93       	push	r17
    256e:	cf 93       	push	r28
    2570:	df 93       	push	r29
    2572:	88 23       	and	r24, r24
    2574:	01 f1       	breq	.+64     	; 0x25b6 <xQueueGenericCreate+0x4c>
    2576:	06 2f       	mov	r16, r22
    2578:	18 2f       	mov	r17, r24
    257a:	83 e2       	ldi	r24, 0x23	; 35
    257c:	90 e0       	ldi	r25, 0x00	; 0
    257e:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    2582:	ec 01       	movw	r28, r24
    2584:	89 2b       	or	r24, r25
    2586:	c9 f0       	breq	.+50     	; 0x25ba <xQueueGenericCreate+0x50>
    2588:	10 9f       	mul	r17, r16
    258a:	c0 01       	movw	r24, r0
    258c:	11 24       	eor	r1, r1
    258e:	01 96       	adiw	r24, 0x01	; 1
    2590:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    2594:	88 83       	st	Y, r24
    2596:	99 83       	std	Y+1, r25	; 0x01
    2598:	89 2b       	or	r24, r25
    259a:	39 f0       	breq	.+14     	; 0x25aa <xQueueGenericCreate+0x40>
    259c:	1f 8f       	std	Y+31, r17	; 0x1f
    259e:	08 a3       	std	Y+32, r16	; 0x20
    25a0:	61 e0       	ldi	r22, 0x01	; 1
    25a2:	ce 01       	movw	r24, r28
    25a4:	0e 94 79 12 	call	0x24f2	; 0x24f2 <xQueueGenericReset>
    25a8:	08 c0       	rjmp	.+16     	; 0x25ba <xQueueGenericCreate+0x50>
    25aa:	ce 01       	movw	r24, r28
    25ac:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vPortFree>
    25b0:	c0 e0       	ldi	r28, 0x00	; 0
    25b2:	d0 e0       	ldi	r29, 0x00	; 0
    25b4:	02 c0       	rjmp	.+4      	; 0x25ba <xQueueGenericCreate+0x50>
    25b6:	c0 e0       	ldi	r28, 0x00	; 0
    25b8:	d0 e0       	ldi	r29, 0x00	; 0
    25ba:	ce 01       	movw	r24, r28
    25bc:	df 91       	pop	r29
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	08 95       	ret

000025c6 <xQueueGenericSend>:
    25c6:	af 92       	push	r10
    25c8:	bf 92       	push	r11
    25ca:	cf 92       	push	r12
    25cc:	df 92       	push	r13
    25ce:	ef 92       	push	r14
    25d0:	ff 92       	push	r15
    25d2:	0f 93       	push	r16
    25d4:	1f 93       	push	r17
    25d6:	cf 93       	push	r28
    25d8:	df 93       	push	r29
    25da:	cd b7       	in	r28, 0x3d	; 61
    25dc:	de b7       	in	r29, 0x3e	; 62
    25de:	29 97       	sbiw	r28, 0x09	; 9
    25e0:	cd bf       	out	0x3d, r28	; 61
    25e2:	de bf       	out	0x3e, r29	; 62
    25e4:	7c 01       	movw	r14, r24
    25e6:	5b 01       	movw	r10, r22
    25e8:	2e 83       	std	Y+6, r18	; 0x06
    25ea:	3f 83       	std	Y+7, r19	; 0x07
    25ec:	48 87       	std	Y+8, r20	; 0x08
    25ee:	59 87       	std	Y+9, r21	; 0x09
    25f0:	10 e0       	ldi	r17, 0x00	; 0
    25f2:	6c 01       	movw	r12, r24
    25f4:	88 e0       	ldi	r24, 0x08	; 8
    25f6:	c8 0e       	add	r12, r24
    25f8:	d1 1c       	adc	r13, r1
    25fa:	0f b6       	in	r0, 0x3f	; 63
    25fc:	f8 94       	cli
    25fe:	0f 92       	push	r0
    2600:	f7 01       	movw	r30, r14
    2602:	96 8d       	ldd	r25, Z+30	; 0x1e
    2604:	87 8d       	ldd	r24, Z+31	; 0x1f
    2606:	98 17       	cp	r25, r24
    2608:	a8 f4       	brcc	.+42     	; 0x2634 <xQueueGenericSend+0x6e>
    260a:	40 2f       	mov	r20, r16
    260c:	b5 01       	movw	r22, r10
    260e:	c7 01       	movw	r24, r14
    2610:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataToQueue>
    2614:	f7 01       	movw	r30, r14
    2616:	83 89       	ldd	r24, Z+19	; 0x13
    2618:	88 23       	and	r24, r24
    261a:	41 f0       	breq	.+16     	; 0x262c <xQueueGenericSend+0x66>
    261c:	c7 01       	movw	r24, r14
    261e:	43 96       	adiw	r24, 0x13	; 19
    2620:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    2624:	81 30       	cpi	r24, 0x01	; 1
    2626:	11 f4       	brne	.+4      	; 0x262c <xQueueGenericSend+0x66>
    2628:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    262c:	0f 90       	pop	r0
    262e:	0f be       	out	0x3f, r0	; 63
    2630:	81 e0       	ldi	r24, 0x01	; 1
    2632:	56 c0       	rjmp	.+172    	; 0x26e0 <xQueueGenericSend+0x11a>
    2634:	8e 81       	ldd	r24, Y+6	; 0x06
    2636:	9f 81       	ldd	r25, Y+7	; 0x07
    2638:	a8 85       	ldd	r26, Y+8	; 0x08
    263a:	b9 85       	ldd	r27, Y+9	; 0x09
    263c:	89 2b       	or	r24, r25
    263e:	8a 2b       	or	r24, r26
    2640:	8b 2b       	or	r24, r27
    2642:	21 f4       	brne	.+8      	; 0x264c <xQueueGenericSend+0x86>
    2644:	0f 90       	pop	r0
    2646:	0f be       	out	0x3f, r0	; 63
    2648:	80 e0       	ldi	r24, 0x00	; 0
    264a:	4a c0       	rjmp	.+148    	; 0x26e0 <xQueueGenericSend+0x11a>
    264c:	11 11       	cpse	r17, r1
    264e:	05 c0       	rjmp	.+10     	; 0x265a <xQueueGenericSend+0x94>
    2650:	ce 01       	movw	r24, r28
    2652:	01 96       	adiw	r24, 0x01	; 1
    2654:	0e 94 d7 18 	call	0x31ae	; 0x31ae <vTaskSetTimeOutState>
    2658:	11 e0       	ldi	r17, 0x01	; 1
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
    265e:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <vTaskSuspendAll>
    2662:	0f b6       	in	r0, 0x3f	; 63
    2664:	f8 94       	cli
    2666:	0f 92       	push	r0
    2668:	f7 01       	movw	r30, r14
    266a:	81 a1       	ldd	r24, Z+33	; 0x21
    266c:	8f 3f       	cpi	r24, 0xFF	; 255
    266e:	09 f4       	brne	.+2      	; 0x2672 <xQueueGenericSend+0xac>
    2670:	11 a2       	std	Z+33, r1	; 0x21
    2672:	f7 01       	movw	r30, r14
    2674:	82 a1       	ldd	r24, Z+34	; 0x22
    2676:	8f 3f       	cpi	r24, 0xFF	; 255
    2678:	09 f4       	brne	.+2      	; 0x267c <xQueueGenericSend+0xb6>
    267a:	12 a2       	std	Z+34, r1	; 0x22
    267c:	0f 90       	pop	r0
    267e:	0f be       	out	0x3f, r0	; 63
    2680:	be 01       	movw	r22, r28
    2682:	6a 5f       	subi	r22, 0xFA	; 250
    2684:	7f 4f       	sbci	r23, 0xFF	; 255
    2686:	ce 01       	movw	r24, r28
    2688:	01 96       	adiw	r24, 0x01	; 1
    268a:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskCheckForTimeOut>
    268e:	81 11       	cpse	r24, r1
    2690:	21 c0       	rjmp	.+66     	; 0x26d4 <xQueueGenericSend+0x10e>
    2692:	0f b6       	in	r0, 0x3f	; 63
    2694:	f8 94       	cli
    2696:	0f 92       	push	r0
    2698:	f7 01       	movw	r30, r14
    269a:	96 8d       	ldd	r25, Z+30	; 0x1e
    269c:	0f 90       	pop	r0
    269e:	0f be       	out	0x3f, r0	; 63
    26a0:	87 8d       	ldd	r24, Z+31	; 0x1f
    26a2:	98 13       	cpse	r25, r24
    26a4:	11 c0       	rjmp	.+34     	; 0x26c8 <xQueueGenericSend+0x102>
    26a6:	4e 81       	ldd	r20, Y+6	; 0x06
    26a8:	5f 81       	ldd	r21, Y+7	; 0x07
    26aa:	68 85       	ldd	r22, Y+8	; 0x08
    26ac:	79 85       	ldd	r23, Y+9	; 0x09
    26ae:	c6 01       	movw	r24, r12
    26b0:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vTaskPlaceOnEventList>
    26b4:	c7 01       	movw	r24, r14
    26b6:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
    26ba:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
    26be:	81 11       	cpse	r24, r1
    26c0:	9c cf       	rjmp	.-200    	; 0x25fa <xQueueGenericSend+0x34>
    26c2:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    26c6:	99 cf       	rjmp	.-206    	; 0x25fa <xQueueGenericSend+0x34>
    26c8:	c7 01       	movw	r24, r14
    26ca:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
    26ce:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
    26d2:	93 cf       	rjmp	.-218    	; 0x25fa <xQueueGenericSend+0x34>
    26d4:	c7 01       	movw	r24, r14
    26d6:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
    26da:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
    26de:	80 e0       	ldi	r24, 0x00	; 0
    26e0:	29 96       	adiw	r28, 0x09	; 9
    26e2:	cd bf       	out	0x3d, r28	; 61
    26e4:	de bf       	out	0x3e, r29	; 62
    26e6:	df 91       	pop	r29
    26e8:	cf 91       	pop	r28
    26ea:	1f 91       	pop	r17
    26ec:	0f 91       	pop	r16
    26ee:	ff 90       	pop	r15
    26f0:	ef 90       	pop	r14
    26f2:	df 90       	pop	r13
    26f4:	cf 90       	pop	r12
    26f6:	bf 90       	pop	r11
    26f8:	af 90       	pop	r10
    26fa:	08 95       	ret

000026fc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    26fc:	0f 93       	push	r16
    26fe:	1f 93       	push	r17
    2700:	cf 93       	push	r28
    2702:	df 93       	push	r29
    2704:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2706:	fc 01       	movw	r30, r24
    2708:	56 8d       	ldd	r21, Z+30	; 0x1e
    270a:	37 8d       	ldd	r19, Z+31	; 0x1f
    270c:	53 17       	cp	r21, r19
    270e:	c0 f4       	brcc	.+48     	; 0x2740 <xQueueGenericSendFromISR+0x44>
    2710:	42 2f       	mov	r20, r18
    2712:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2714:	0e 94 c9 11 	call	0x2392	; 0x2392 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2718:	8a a1       	ldd	r24, Y+34	; 0x22
    271a:	8f 3f       	cpi	r24, 0xFF	; 255
    271c:	69 f4       	brne	.+26     	; 0x2738 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    271e:	8b 89       	ldd	r24, Y+19	; 0x13
    2720:	88 23       	and	r24, r24
    2722:	81 f0       	breq	.+32     	; 0x2744 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2724:	ce 01       	movw	r24, r28
    2726:	43 96       	adiw	r24, 0x13	; 19
    2728:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    272c:	88 23       	and	r24, r24
    272e:	61 f0       	breq	.+24     	; 0x2748 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	f8 01       	movw	r30, r16
    2734:	80 83       	st	Z, r24
    2736:	09 c0       	rjmp	.+18     	; 0x274a <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2738:	8f 5f       	subi	r24, 0xFF	; 255
    273a:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    273c:	81 e0       	ldi	r24, 0x01	; 1
    273e:	05 c0       	rjmp	.+10     	; 0x274a <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	03 c0       	rjmp	.+6      	; 0x274a <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	01 c0       	rjmp	.+2      	; 0x274a <xQueueGenericSendFromISR+0x4e>
    2748:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    274a:	df 91       	pop	r29
    274c:	cf 91       	pop	r28
    274e:	1f 91       	pop	r17
    2750:	0f 91       	pop	r16
    2752:	08 95       	ret

00002754 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2754:	af 92       	push	r10
    2756:	bf 92       	push	r11
    2758:	cf 92       	push	r12
    275a:	df 92       	push	r13
    275c:	ef 92       	push	r14
    275e:	ff 92       	push	r15
    2760:	0f 93       	push	r16
    2762:	1f 93       	push	r17
    2764:	cf 93       	push	r28
    2766:	df 93       	push	r29
    2768:	cd b7       	in	r28, 0x3d	; 61
    276a:	de b7       	in	r29, 0x3e	; 62
    276c:	29 97       	sbiw	r28, 0x09	; 9
    276e:	cd bf       	out	0x3d, r28	; 61
    2770:	de bf       	out	0x3e, r29	; 62
    2772:	7c 01       	movw	r14, r24
    2774:	5b 01       	movw	r10, r22
    2776:	2e 83       	std	Y+6, r18	; 0x06
    2778:	3f 83       	std	Y+7, r19	; 0x07
    277a:	48 87       	std	Y+8, r20	; 0x08
    277c:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    277e:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2780:	6c 01       	movw	r12, r24
    2782:	83 e1       	ldi	r24, 0x13	; 19
    2784:	c8 0e       	add	r12, r24
    2786:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2788:	0f b6       	in	r0, 0x3f	; 63
    278a:	f8 94       	cli
    278c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    278e:	f7 01       	movw	r30, r14
    2790:	86 8d       	ldd	r24, Z+30	; 0x1e
    2792:	88 23       	and	r24, r24
    2794:	99 f1       	breq	.+102    	; 0x27fc <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2796:	c6 80       	ldd	r12, Z+6	; 0x06
    2798:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    279a:	b5 01       	movw	r22, r10
    279c:	c7 01       	movw	r24, r14
    279e:	0e 94 15 12 	call	0x242a	; 0x242a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    27a2:	01 11       	cpse	r16, r1
    27a4:	1a c0       	rjmp	.+52     	; 0x27da <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    27a6:	f7 01       	movw	r30, r14
    27a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    27aa:	81 50       	subi	r24, 0x01	; 1
    27ac:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    27ae:	80 81       	ld	r24, Z
    27b0:	91 81       	ldd	r25, Z+1	; 0x01
    27b2:	89 2b       	or	r24, r25
    27b4:	29 f4       	brne	.+10     	; 0x27c0 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    27b6:	0e 94 72 19 	call	0x32e4	; 0x32e4 <xTaskGetCurrentTaskHandle>
    27ba:	f7 01       	movw	r30, r14
    27bc:	82 83       	std	Z+2, r24	; 0x02
    27be:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27c0:	f7 01       	movw	r30, r14
    27c2:	80 85       	ldd	r24, Z+8	; 0x08
    27c4:	88 23       	and	r24, r24
    27c6:	b1 f0       	breq	.+44     	; 0x27f4 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    27c8:	c7 01       	movw	r24, r14
    27ca:	08 96       	adiw	r24, 0x08	; 8
    27cc:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    27d0:	81 30       	cpi	r24, 0x01	; 1
    27d2:	81 f4       	brne	.+32     	; 0x27f4 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    27d4:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    27d8:	0d c0       	rjmp	.+26     	; 0x27f4 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    27da:	f7 01       	movw	r30, r14
    27dc:	c6 82       	std	Z+6, r12	; 0x06
    27de:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    27e0:	83 89       	ldd	r24, Z+19	; 0x13
    27e2:	88 23       	and	r24, r24
    27e4:	39 f0       	breq	.+14     	; 0x27f4 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    27e6:	c7 01       	movw	r24, r14
    27e8:	43 96       	adiw	r24, 0x13	; 19
    27ea:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    27ee:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    27f0:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    27f4:	0f 90       	pop	r0
    27f6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	62 c0       	rjmp	.+196    	; 0x28c0 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    27fc:	8e 81       	ldd	r24, Y+6	; 0x06
    27fe:	9f 81       	ldd	r25, Y+7	; 0x07
    2800:	a8 85       	ldd	r26, Y+8	; 0x08
    2802:	b9 85       	ldd	r27, Y+9	; 0x09
    2804:	89 2b       	or	r24, r25
    2806:	8a 2b       	or	r24, r26
    2808:	8b 2b       	or	r24, r27
    280a:	21 f4       	brne	.+8      	; 0x2814 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    280c:	0f 90       	pop	r0
    280e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2810:	80 e0       	ldi	r24, 0x00	; 0
    2812:	56 c0       	rjmp	.+172    	; 0x28c0 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2814:	11 11       	cpse	r17, r1
    2816:	05 c0       	rjmp	.+10     	; 0x2822 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2818:	ce 01       	movw	r24, r28
    281a:	01 96       	adiw	r24, 0x01	; 1
    281c:	0e 94 d7 18 	call	0x31ae	; 0x31ae <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2820:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2826:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    282a:	0f b6       	in	r0, 0x3f	; 63
    282c:	f8 94       	cli
    282e:	0f 92       	push	r0
    2830:	f7 01       	movw	r30, r14
    2832:	81 a1       	ldd	r24, Z+33	; 0x21
    2834:	8f 3f       	cpi	r24, 0xFF	; 255
    2836:	09 f4       	brne	.+2      	; 0x283a <xQueueGenericReceive+0xe6>
    2838:	11 a2       	std	Z+33, r1	; 0x21
    283a:	f7 01       	movw	r30, r14
    283c:	82 a1       	ldd	r24, Z+34	; 0x22
    283e:	8f 3f       	cpi	r24, 0xFF	; 255
    2840:	09 f4       	brne	.+2      	; 0x2844 <xQueueGenericReceive+0xf0>
    2842:	12 a2       	std	Z+34, r1	; 0x22
    2844:	0f 90       	pop	r0
    2846:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2848:	be 01       	movw	r22, r28
    284a:	6a 5f       	subi	r22, 0xFA	; 250
    284c:	7f 4f       	sbci	r23, 0xFF	; 255
    284e:	ce 01       	movw	r24, r28
    2850:	01 96       	adiw	r24, 0x01	; 1
    2852:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskCheckForTimeOut>
    2856:	81 11       	cpse	r24, r1
    2858:	2d c0       	rjmp	.+90     	; 0x28b4 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    285a:	0f b6       	in	r0, 0x3f	; 63
    285c:	f8 94       	cli
    285e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2860:	f7 01       	movw	r30, r14
    2862:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2864:	0f 90       	pop	r0
    2866:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2868:	81 11       	cpse	r24, r1
    286a:	1e c0       	rjmp	.+60     	; 0x28a8 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    286c:	80 81       	ld	r24, Z
    286e:	91 81       	ldd	r25, Z+1	; 0x01
    2870:	89 2b       	or	r24, r25
    2872:	49 f4       	brne	.+18     	; 0x2886 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2874:	0f b6       	in	r0, 0x3f	; 63
    2876:	f8 94       	cli
    2878:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    287a:	82 81       	ldd	r24, Z+2	; 0x02
    287c:	93 81       	ldd	r25, Z+3	; 0x03
    287e:	0e 94 77 19 	call	0x32ee	; 0x32ee <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2882:	0f 90       	pop	r0
    2884:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2886:	4e 81       	ldd	r20, Y+6	; 0x06
    2888:	5f 81       	ldd	r21, Y+7	; 0x07
    288a:	68 85       	ldd	r22, Y+8	; 0x08
    288c:	79 85       	ldd	r23, Y+9	; 0x09
    288e:	c6 01       	movw	r24, r12
    2890:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2894:	c7 01       	movw	r24, r14
    2896:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    289a:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
    289e:	81 11       	cpse	r24, r1
    28a0:	73 cf       	rjmp	.-282    	; 0x2788 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    28a2:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    28a6:	70 cf       	rjmp	.-288    	; 0x2788 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    28a8:	c7 01       	movw	r24, r14
    28aa:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    28ae:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
    28b2:	6a cf       	rjmp	.-300    	; 0x2788 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    28b4:	c7 01       	movw	r24, r14
    28b6:	0e 94 2f 12 	call	0x245e	; 0x245e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    28ba:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    28be:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    28c0:	29 96       	adiw	r28, 0x09	; 9
    28c2:	cd bf       	out	0x3d, r28	; 61
    28c4:	de bf       	out	0x3e, r29	; 62
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	1f 91       	pop	r17
    28cc:	0f 91       	pop	r16
    28ce:	ff 90       	pop	r15
    28d0:	ef 90       	pop	r14
    28d2:	df 90       	pop	r13
    28d4:	cf 90       	pop	r12
    28d6:	bf 90       	pop	r11
    28d8:	af 90       	pop	r10
    28da:	08 95       	ret

000028dc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    28dc:	0f 93       	push	r16
    28de:	1f 93       	push	r17
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    28e4:	fc 01       	movw	r30, r24
    28e6:	26 8d       	ldd	r18, Z+30	; 0x1e
    28e8:	22 23       	and	r18, r18
    28ea:	d9 f0       	breq	.+54     	; 0x2922 <xQueueReceiveFromISR+0x46>
    28ec:	8a 01       	movw	r16, r20
    28ee:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    28f0:	0e 94 15 12 	call	0x242a	; 0x242a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    28f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    28f6:	81 50       	subi	r24, 0x01	; 1
    28f8:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    28fa:	89 a1       	ldd	r24, Y+33	; 0x21
    28fc:	8f 3f       	cpi	r24, 0xFF	; 255
    28fe:	69 f4       	brne	.+26     	; 0x291a <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2900:	88 85       	ldd	r24, Y+8	; 0x08
    2902:	88 23       	and	r24, r24
    2904:	81 f0       	breq	.+32     	; 0x2926 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2906:	ce 01       	movw	r24, r28
    2908:	08 96       	adiw	r24, 0x08	; 8
    290a:	0e 94 98 18 	call	0x3130	; 0x3130 <xTaskRemoveFromEventList>
    290e:	88 23       	and	r24, r24
    2910:	61 f0       	breq	.+24     	; 0x292a <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2912:	81 e0       	ldi	r24, 0x01	; 1
    2914:	f8 01       	movw	r30, r16
    2916:	80 83       	st	Z, r24
    2918:	09 c0       	rjmp	.+18     	; 0x292c <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    291a:	8f 5f       	subi	r24, 0xFF	; 255
    291c:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    291e:	81 e0       	ldi	r24, 0x01	; 1
    2920:	05 c0       	rjmp	.+10     	; 0x292c <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    2922:	80 e0       	ldi	r24, 0x00	; 0
    2924:	03 c0       	rjmp	.+6      	; 0x292c <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2926:	81 e0       	ldi	r24, 0x01	; 1
    2928:	01 c0       	rjmp	.+2      	; 0x292c <xQueueReceiveFromISR+0x50>
    292a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    292c:	df 91       	pop	r29
    292e:	cf 91       	pop	r28
    2930:	1f 91       	pop	r17
    2932:	0f 91       	pop	r16
    2934:	08 95       	ret

00002936 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2936:	0f b6       	in	r0, 0x3f	; 63
    2938:	f8 94       	cli
    293a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    293c:	fc 01       	movw	r30, r24
    293e:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2940:	0f 90       	pop	r0
    2942:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2944:	08 95       	ret

00002946 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2946:	fc 01       	movw	r30, r24
    2948:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    294a:	08 95       	ret

0000294c <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    294c:	c2 e7       	ldi	r28, 0x72	; 114
    294e:	d2 e3       	ldi	r29, 0x32	; 50
    2950:	88 81       	ld	r24, Y
    2952:	82 30       	cpi	r24, 0x02	; 2
    2954:	e8 f3       	brcs	.-6      	; 0x2950 <prvIdleTask+0x4>
    2956:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    295a:	fa cf       	rjmp	.-12     	; 0x2950 <prvIdleTask+0x4>

0000295c <prvAddCurrentTaskToDelayedList>:
    295c:	cf 92       	push	r12
    295e:	df 92       	push	r13
    2960:	ef 92       	push	r14
    2962:	ff 92       	push	r15
    2964:	6b 01       	movw	r12, r22
    2966:	7c 01       	movw	r14, r24
    2968:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    296c:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2970:	62 83       	std	Z+2, r22	; 0x02
    2972:	73 83       	std	Z+3, r23	; 0x03
    2974:	84 83       	std	Z+4, r24	; 0x04
    2976:	95 83       	std	Z+5, r25	; 0x05
    2978:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    297c:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2980:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2984:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2988:	c8 16       	cp	r12, r24
    298a:	d9 06       	cpc	r13, r25
    298c:	ea 06       	cpc	r14, r26
    298e:	fb 06       	cpc	r15, r27
    2990:	68 f4       	brcc	.+26     	; 0x29ac <prvAddCurrentTaskToDelayedList+0x50>
    2992:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    2996:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    299a:	80 91 58 32 	lds	r24, 0x3258	; 0x803258 <pxOverflowDelayedTaskList>
    299e:	90 91 59 32 	lds	r25, 0x3259	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    29a2:	6e 5f       	subi	r22, 0xFE	; 254
    29a4:	7f 4f       	sbci	r23, 0xFF	; 255
    29a6:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vListInsert>
    29aa:	21 c0       	rjmp	.+66     	; 0x29ee <prvAddCurrentTaskToDelayedList+0x92>
    29ac:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    29b0:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    29b4:	80 91 5a 32 	lds	r24, 0x325A	; 0x80325a <pxDelayedTaskList>
    29b8:	90 91 5b 32 	lds	r25, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    29bc:	6e 5f       	subi	r22, 0xFE	; 254
    29be:	7f 4f       	sbci	r23, 0xFF	; 255
    29c0:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vListInsert>
    29c4:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    29c8:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    29cc:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    29d0:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    29d4:	c8 16       	cp	r12, r24
    29d6:	d9 06       	cpc	r13, r25
    29d8:	ea 06       	cpc	r14, r26
    29da:	fb 06       	cpc	r15, r27
    29dc:	40 f4       	brcc	.+16     	; 0x29ee <prvAddCurrentTaskToDelayedList+0x92>
    29de:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    29e2:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    29e6:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    29ea:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    29ee:	ff 90       	pop	r15
    29f0:	ef 90       	pop	r14
    29f2:	df 90       	pop	r13
    29f4:	cf 90       	pop	r12
    29f6:	08 95       	ret

000029f8 <xTaskGenericCreate>:
    29f8:	4f 92       	push	r4
    29fa:	5f 92       	push	r5
    29fc:	6f 92       	push	r6
    29fe:	7f 92       	push	r7
    2a00:	8f 92       	push	r8
    2a02:	9f 92       	push	r9
    2a04:	af 92       	push	r10
    2a06:	bf 92       	push	r11
    2a08:	cf 92       	push	r12
    2a0a:	df 92       	push	r13
    2a0c:	ef 92       	push	r14
    2a0e:	ff 92       	push	r15
    2a10:	0f 93       	push	r16
    2a12:	1f 93       	push	r17
    2a14:	cf 93       	push	r28
    2a16:	df 93       	push	r29
    2a18:	5c 01       	movw	r10, r24
    2a1a:	4b 01       	movw	r8, r22
    2a1c:	3a 01       	movw	r6, r20
    2a1e:	29 01       	movw	r4, r18
    2a20:	88 e2       	ldi	r24, 0x28	; 40
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    2a28:	ec 01       	movw	r28, r24
    2a2a:	89 2b       	or	r24, r25
    2a2c:	09 f4       	brne	.+2      	; 0x2a30 <xTaskGenericCreate+0x38>
    2a2e:	d4 c0       	rjmp	.+424    	; 0x2bd8 <xTaskGenericCreate+0x1e0>
    2a30:	c1 14       	cp	r12, r1
    2a32:	d1 04       	cpc	r13, r1
    2a34:	09 f0       	breq	.+2      	; 0x2a38 <xTaskGenericCreate+0x40>
    2a36:	cc c0       	rjmp	.+408    	; 0x2bd0 <xTaskGenericCreate+0x1d8>
    2a38:	c3 01       	movw	r24, r6
    2a3a:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    2a3e:	8b 8f       	std	Y+27, r24	; 0x1b
    2a40:	9c 8f       	std	Y+28, r25	; 0x1c
    2a42:	00 97       	sbiw	r24, 0x00	; 0
    2a44:	21 f4       	brne	.+8      	; 0x2a4e <xTaskGenericCreate+0x56>
    2a46:	ce 01       	movw	r24, r28
    2a48:	0e 94 69 0f 	call	0x1ed2	; 0x1ed2 <vPortFree>
    2a4c:	c5 c0       	rjmp	.+394    	; 0x2bd8 <xTaskGenericCreate+0x1e0>
    2a4e:	a3 01       	movw	r20, r6
    2a50:	61 e1       	ldi	r22, 0x11	; 17
    2a52:	70 e0       	ldi	r23, 0x00	; 0
    2a54:	0e 94 14 27 	call	0x4e28	; 0x4e28 <memset>
    2a58:	93 01       	movw	r18, r6
    2a5a:	21 50       	subi	r18, 0x01	; 1
    2a5c:	31 09       	sbc	r19, r1
    2a5e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a60:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a62:	3c 01       	movw	r6, r24
    2a64:	62 0e       	add	r6, r18
    2a66:	73 1e       	adc	r7, r19
    2a68:	4a e0       	ldi	r20, 0x0A	; 10
    2a6a:	50 e0       	ldi	r21, 0x00	; 0
    2a6c:	b4 01       	movw	r22, r8
    2a6e:	ce 01       	movw	r24, r28
    2a70:	4d 96       	adiw	r24, 0x1d	; 29
    2a72:	0e 94 1b 27 	call	0x4e36	; 0x4e36 <strncpy>
    2a76:	1e a2       	std	Y+38, r1	; 0x26
    2a78:	10 2f       	mov	r17, r16
    2a7a:	04 30       	cpi	r16, 0x04	; 4
    2a7c:	08 f0       	brcs	.+2      	; 0x2a80 <xTaskGenericCreate+0x88>
    2a7e:	13 e0       	ldi	r17, 0x03	; 3
    2a80:	1a 8f       	std	Y+26, r17	; 0x1a
    2a82:	1f a3       	std	Y+39, r17	; 0x27
    2a84:	6e 01       	movw	r12, r28
    2a86:	22 e0       	ldi	r18, 0x02	; 2
    2a88:	c2 0e       	add	r12, r18
    2a8a:	d1 1c       	adc	r13, r1
    2a8c:	c6 01       	movw	r24, r12
    2a8e:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <vListInitialiseItem>
    2a92:	ce 01       	movw	r24, r28
    2a94:	0e 96       	adiw	r24, 0x0e	; 14
    2a96:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <vListInitialiseItem>
    2a9a:	ca 87       	std	Y+10, r28	; 0x0a
    2a9c:	db 87       	std	Y+11, r29	; 0x0b
    2a9e:	84 e0       	ldi	r24, 0x04	; 4
    2aa0:	90 e0       	ldi	r25, 0x00	; 0
    2aa2:	a0 e0       	ldi	r26, 0x00	; 0
    2aa4:	b0 e0       	ldi	r27, 0x00	; 0
    2aa6:	81 1b       	sub	r24, r17
    2aa8:	91 09       	sbc	r25, r1
    2aaa:	a1 09       	sbc	r26, r1
    2aac:	b1 09       	sbc	r27, r1
    2aae:	8e 87       	std	Y+14, r24	; 0x0e
    2ab0:	9f 87       	std	Y+15, r25	; 0x0f
    2ab2:	a8 8b       	std	Y+16, r26	; 0x10
    2ab4:	b9 8b       	std	Y+17, r27	; 0x11
    2ab6:	ce 8b       	std	Y+22, r28	; 0x16
    2ab8:	df 8b       	std	Y+23, r29	; 0x17
    2aba:	a2 01       	movw	r20, r4
    2abc:	b5 01       	movw	r22, r10
    2abe:	c3 01       	movw	r24, r6
    2ac0:	0e 94 4e 10 	call	0x209c	; 0x209c <pxPortInitialiseStack>
    2ac4:	88 83       	st	Y, r24
    2ac6:	99 83       	std	Y+1, r25	; 0x01
    2ac8:	e1 14       	cp	r14, r1
    2aca:	f1 04       	cpc	r15, r1
    2acc:	19 f0       	breq	.+6      	; 0x2ad4 <xTaskGenericCreate+0xdc>
    2ace:	f7 01       	movw	r30, r14
    2ad0:	c0 83       	st	Z, r28
    2ad2:	d1 83       	std	Z+1, r29	; 0x01
    2ad4:	0f b6       	in	r0, 0x3f	; 63
    2ad6:	f8 94       	cli
    2ad8:	0f 92       	push	r0
    2ada:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2ade:	8f 5f       	subi	r24, 0xFF	; 255
    2ae0:	80 93 4a 32 	sts	0x324A, r24	; 0x80324a <uxCurrentNumberOfTasks>
    2ae4:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2ae8:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2aec:	89 2b       	or	r24, r25
    2aee:	89 f5       	brne	.+98     	; 0x2b52 <xTaskGenericCreate+0x15a>
    2af0:	c0 93 9e 32 	sts	0x329E, r28	; 0x80329e <pxCurrentTCB>
    2af4:	d0 93 9f 32 	sts	0x329F, r29	; 0x80329f <pxCurrentTCB+0x1>
    2af8:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2afc:	81 30       	cpi	r24, 0x01	; 1
    2afe:	c1 f5       	brne	.+112    	; 0x2b70 <xTaskGenericCreate+0x178>
    2b00:	82 e7       	ldi	r24, 0x72	; 114
    2b02:	92 e3       	ldi	r25, 0x32	; 50
    2b04:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b08:	8d e7       	ldi	r24, 0x7D	; 125
    2b0a:	92 e3       	ldi	r25, 0x32	; 50
    2b0c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b10:	88 e8       	ldi	r24, 0x88	; 136
    2b12:	92 e3       	ldi	r25, 0x32	; 50
    2b14:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b18:	83 e9       	ldi	r24, 0x93	; 147
    2b1a:	92 e3       	ldi	r25, 0x32	; 50
    2b1c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b20:	87 e6       	ldi	r24, 0x67	; 103
    2b22:	92 e3       	ldi	r25, 0x32	; 50
    2b24:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b28:	8c e5       	ldi	r24, 0x5C	; 92
    2b2a:	92 e3       	ldi	r25, 0x32	; 50
    2b2c:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b30:	8d e4       	ldi	r24, 0x4D	; 77
    2b32:	92 e3       	ldi	r25, 0x32	; 50
    2b34:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <vListInitialise>
    2b38:	87 e6       	ldi	r24, 0x67	; 103
    2b3a:	92 e3       	ldi	r25, 0x32	; 50
    2b3c:	80 93 5a 32 	sts	0x325A, r24	; 0x80325a <pxDelayedTaskList>
    2b40:	90 93 5b 32 	sts	0x325B, r25	; 0x80325b <pxDelayedTaskList+0x1>
    2b44:	8c e5       	ldi	r24, 0x5C	; 92
    2b46:	92 e3       	ldi	r25, 0x32	; 50
    2b48:	80 93 58 32 	sts	0x3258, r24	; 0x803258 <pxOverflowDelayedTaskList>
    2b4c:	90 93 59 32 	sts	0x3259, r25	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2b50:	0f c0       	rjmp	.+30     	; 0x2b70 <xTaskGenericCreate+0x178>
    2b52:	80 91 43 32 	lds	r24, 0x3243	; 0x803243 <xSchedulerRunning>
    2b56:	81 11       	cpse	r24, r1
    2b58:	0b c0       	rjmp	.+22     	; 0x2b70 <xTaskGenericCreate+0x178>
    2b5a:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2b5e:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2b62:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b64:	08 17       	cp	r16, r24
    2b66:	20 f0       	brcs	.+8      	; 0x2b70 <xTaskGenericCreate+0x178>
    2b68:	c0 93 9e 32 	sts	0x329E, r28	; 0x80329e <pxCurrentTCB>
    2b6c:	d0 93 9f 32 	sts	0x329F, r29	; 0x80329f <pxCurrentTCB+0x1>
    2b70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b72:	90 91 45 32 	lds	r25, 0x3245	; 0x803245 <uxTopUsedPriority>
    2b76:	98 17       	cp	r25, r24
    2b78:	10 f4       	brcc	.+4      	; 0x2b7e <xTaskGenericCreate+0x186>
    2b7a:	80 93 45 32 	sts	0x3245, r24	; 0x803245 <uxTopUsedPriority>
    2b7e:	90 91 3e 32 	lds	r25, 0x323E	; 0x80323e <uxTaskNumber>
    2b82:	9f 5f       	subi	r25, 0xFF	; 255
    2b84:	90 93 3e 32 	sts	0x323E, r25	; 0x80323e <uxTaskNumber>
    2b88:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2b8c:	98 17       	cp	r25, r24
    2b8e:	10 f4       	brcc	.+4      	; 0x2b94 <xTaskGenericCreate+0x19c>
    2b90:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2b94:	fb e0       	ldi	r31, 0x0B	; 11
    2b96:	8f 9f       	mul	r24, r31
    2b98:	c0 01       	movw	r24, r0
    2b9a:	11 24       	eor	r1, r1
    2b9c:	b6 01       	movw	r22, r12
    2b9e:	8e 58       	subi	r24, 0x8E	; 142
    2ba0:	9d 4c       	sbci	r25, 0xCD	; 205
    2ba2:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    2ba6:	0f 90       	pop	r0
    2ba8:	0f be       	out	0x3f, r0	; 63
    2baa:	80 91 43 32 	lds	r24, 0x3243	; 0x803243 <xSchedulerRunning>
    2bae:	88 23       	and	r24, r24
    2bb0:	59 f0       	breq	.+22     	; 0x2bc8 <xTaskGenericCreate+0x1d0>
    2bb2:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2bb6:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2bba:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bbc:	80 17       	cp	r24, r16
    2bbe:	30 f4       	brcc	.+12     	; 0x2bcc <xTaskGenericCreate+0x1d4>
    2bc0:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    2bc4:	81 e0       	ldi	r24, 0x01	; 1
    2bc6:	09 c0       	rjmp	.+18     	; 0x2bda <xTaskGenericCreate+0x1e2>
    2bc8:	81 e0       	ldi	r24, 0x01	; 1
    2bca:	07 c0       	rjmp	.+14     	; 0x2bda <xTaskGenericCreate+0x1e2>
    2bcc:	81 e0       	ldi	r24, 0x01	; 1
    2bce:	05 c0       	rjmp	.+10     	; 0x2bda <xTaskGenericCreate+0x1e2>
    2bd0:	cb 8e       	std	Y+27, r12	; 0x1b
    2bd2:	dc 8e       	std	Y+28, r13	; 0x1c
    2bd4:	c6 01       	movw	r24, r12
    2bd6:	3b cf       	rjmp	.-394    	; 0x2a4e <xTaskGenericCreate+0x56>
    2bd8:	8f ef       	ldi	r24, 0xFF	; 255
    2bda:	df 91       	pop	r29
    2bdc:	cf 91       	pop	r28
    2bde:	1f 91       	pop	r17
    2be0:	0f 91       	pop	r16
    2be2:	ff 90       	pop	r15
    2be4:	ef 90       	pop	r14
    2be6:	df 90       	pop	r13
    2be8:	cf 90       	pop	r12
    2bea:	bf 90       	pop	r11
    2bec:	af 90       	pop	r10
    2bee:	9f 90       	pop	r9
    2bf0:	8f 90       	pop	r8
    2bf2:	7f 90       	pop	r7
    2bf4:	6f 90       	pop	r6
    2bf6:	5f 90       	pop	r5
    2bf8:	4f 90       	pop	r4
    2bfa:	08 95       	ret

00002bfc <uxTaskPriorityGet>:
    2bfc:	0f b6       	in	r0, 0x3f	; 63
    2bfe:	f8 94       	cli
    2c00:	0f 92       	push	r0
    2c02:	00 97       	sbiw	r24, 0x00	; 0
    2c04:	21 f4       	brne	.+8      	; 0x2c0e <uxTaskPriorityGet+0x12>
    2c06:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2c0a:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2c0e:	0f 90       	pop	r0
    2c10:	0f be       	out	0x3f, r0	; 63
    2c12:	fc 01       	movw	r30, r24
    2c14:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c16:	08 95       	ret

00002c18 <vTaskStartScheduler>:
    2c18:	af 92       	push	r10
    2c1a:	bf 92       	push	r11
    2c1c:	cf 92       	push	r12
    2c1e:	df 92       	push	r13
    2c20:	ef 92       	push	r14
    2c22:	ff 92       	push	r15
    2c24:	0f 93       	push	r16
    2c26:	a1 2c       	mov	r10, r1
    2c28:	b1 2c       	mov	r11, r1
    2c2a:	c1 2c       	mov	r12, r1
    2c2c:	d1 2c       	mov	r13, r1
    2c2e:	0f 2e       	mov	r0, r31
    2c30:	fb e4       	ldi	r31, 0x4B	; 75
    2c32:	ef 2e       	mov	r14, r31
    2c34:	f2 e3       	ldi	r31, 0x32	; 50
    2c36:	ff 2e       	mov	r15, r31
    2c38:	f0 2d       	mov	r31, r0
    2c3a:	00 e0       	ldi	r16, 0x00	; 0
    2c3c:	20 e0       	ldi	r18, 0x00	; 0
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	44 e6       	ldi	r20, 0x64	; 100
    2c42:	50 e0       	ldi	r21, 0x00	; 0
    2c44:	63 e8       	ldi	r22, 0x83	; 131
    2c46:	71 e2       	ldi	r23, 0x21	; 33
    2c48:	86 ea       	ldi	r24, 0xA6	; 166
    2c4a:	94 e1       	ldi	r25, 0x14	; 20
    2c4c:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <xTaskGenericCreate>
    2c50:	81 30       	cpi	r24, 0x01	; 1
    2c52:	69 f4       	brne	.+26     	; 0x2c6e <vTaskStartScheduler+0x56>
    2c54:	f8 94       	cli
    2c56:	80 93 43 32 	sts	0x3243, r24	; 0x803243 <xSchedulerRunning>
    2c5a:	10 92 46 32 	sts	0x3246, r1	; 0x803246 <xTickCount>
    2c5e:	10 92 47 32 	sts	0x3247, r1	; 0x803247 <xTickCount+0x1>
    2c62:	10 92 48 32 	sts	0x3248, r1	; 0x803248 <xTickCount+0x2>
    2c66:	10 92 49 32 	sts	0x3249, r1	; 0x803249 <xTickCount+0x3>
    2c6a:	0e 94 c4 10 	call	0x2188	; 0x2188 <xPortStartScheduler>
    2c6e:	0f 91       	pop	r16
    2c70:	ff 90       	pop	r15
    2c72:	ef 90       	pop	r14
    2c74:	df 90       	pop	r13
    2c76:	cf 90       	pop	r12
    2c78:	bf 90       	pop	r11
    2c7a:	af 90       	pop	r10
    2c7c:	08 95       	ret

00002c7e <vTaskSuspendAll>:
    2c7e:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2c82:	8f 5f       	subi	r24, 0xFF	; 255
    2c84:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxSchedulerSuspended>
    2c88:	08 95       	ret

00002c8a <xTaskGetTickCount>:
    2c8a:	0f b6       	in	r0, 0x3f	; 63
    2c8c:	f8 94       	cli
    2c8e:	0f 92       	push	r0
    2c90:	60 91 46 32 	lds	r22, 0x3246	; 0x803246 <xTickCount>
    2c94:	70 91 47 32 	lds	r23, 0x3247	; 0x803247 <xTickCount+0x1>
    2c98:	80 91 48 32 	lds	r24, 0x3248	; 0x803248 <xTickCount+0x2>
    2c9c:	90 91 49 32 	lds	r25, 0x3249	; 0x803249 <xTickCount+0x3>
    2ca0:	0f 90       	pop	r0
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	08 95       	ret

00002ca6 <pcTaskGetTaskName>:
    2ca6:	00 97       	sbiw	r24, 0x00	; 0
    2ca8:	21 f4       	brne	.+8      	; 0x2cb2 <pcTaskGetTaskName+0xc>
    2caa:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2cae:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2cb2:	4d 96       	adiw	r24, 0x1d	; 29
    2cb4:	08 95       	ret

00002cb6 <xTaskGetIdleTaskHandle>:
    2cb6:	80 91 4b 32 	lds	r24, 0x324B	; 0x80324b <xIdleTaskHandle>
    2cba:	90 91 4c 32 	lds	r25, 0x324C	; 0x80324c <xIdleTaskHandle+0x1>
    2cbe:	08 95       	ret

00002cc0 <vTaskIncrementTick>:
    2cc0:	ff 92       	push	r15
    2cc2:	0f 93       	push	r16
    2cc4:	1f 93       	push	r17
    2cc6:	cf 93       	push	r28
    2cc8:	df 93       	push	r29
    2cca:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2cce:	81 11       	cpse	r24, r1
    2cd0:	ed c0       	rjmp	.+474    	; 0x2eac <vTaskIncrementTick+0x1ec>
    2cd2:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2cd6:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2cda:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2cde:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2ce2:	01 96       	adiw	r24, 0x01	; 1
    2ce4:	a1 1d       	adc	r26, r1
    2ce6:	b1 1d       	adc	r27, r1
    2ce8:	80 93 46 32 	sts	0x3246, r24	; 0x803246 <xTickCount>
    2cec:	90 93 47 32 	sts	0x3247, r25	; 0x803247 <xTickCount+0x1>
    2cf0:	a0 93 48 32 	sts	0x3248, r26	; 0x803248 <xTickCount+0x2>
    2cf4:	b0 93 49 32 	sts	0x3249, r27	; 0x803249 <xTickCount+0x3>
    2cf8:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2cfc:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2d00:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2d04:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2d08:	89 2b       	or	r24, r25
    2d0a:	8a 2b       	or	r24, r26
    2d0c:	8b 2b       	or	r24, r27
    2d0e:	f1 f5       	brne	.+124    	; 0x2d8c <vTaskIncrementTick+0xcc>
    2d10:	80 91 5a 32 	lds	r24, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d14:	90 91 5b 32 	lds	r25, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d18:	20 91 58 32 	lds	r18, 0x3258	; 0x803258 <pxOverflowDelayedTaskList>
    2d1c:	30 91 59 32 	lds	r19, 0x3259	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2d20:	20 93 5a 32 	sts	0x325A, r18	; 0x80325a <pxDelayedTaskList>
    2d24:	30 93 5b 32 	sts	0x325B, r19	; 0x80325b <pxDelayedTaskList+0x1>
    2d28:	80 93 58 32 	sts	0x3258, r24	; 0x803258 <pxOverflowDelayedTaskList>
    2d2c:	90 93 59 32 	sts	0x3259, r25	; 0x803259 <pxOverflowDelayedTaskList+0x1>
    2d30:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <xNumOfOverflows>
    2d34:	8f 5f       	subi	r24, 0xFF	; 255
    2d36:	80 93 3f 32 	sts	0x323F, r24	; 0x80323f <xNumOfOverflows>
    2d3a:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d3e:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d42:	80 81       	ld	r24, Z
    2d44:	81 11       	cpse	r24, r1
    2d46:	0c c0       	rjmp	.+24     	; 0x2d60 <vTaskIncrementTick+0xa0>
    2d48:	8f ef       	ldi	r24, 0xFF	; 255
    2d4a:	9f ef       	ldi	r25, 0xFF	; 255
    2d4c:	dc 01       	movw	r26, r24
    2d4e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d52:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d56:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d5a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d5e:	16 c0       	rjmp	.+44     	; 0x2d8c <vTaskIncrementTick+0xcc>
    2d60:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2d64:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2d68:	07 80       	ldd	r0, Z+7	; 0x07
    2d6a:	f0 85       	ldd	r31, Z+8	; 0x08
    2d6c:	e0 2d       	mov	r30, r0
    2d6e:	00 84       	ldd	r0, Z+8	; 0x08
    2d70:	f1 85       	ldd	r31, Z+9	; 0x09
    2d72:	e0 2d       	mov	r30, r0
    2d74:	82 81       	ldd	r24, Z+2	; 0x02
    2d76:	93 81       	ldd	r25, Z+3	; 0x03
    2d78:	a4 81       	ldd	r26, Z+4	; 0x04
    2d7a:	b5 81       	ldd	r27, Z+5	; 0x05
    2d7c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2d80:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2d84:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d88:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d8c:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2d90:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2d94:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2d98:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2d9c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2da0:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2da4:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2da8:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2dac:	48 17       	cp	r20, r24
    2dae:	59 07       	cpc	r21, r25
    2db0:	6a 07       	cpc	r22, r26
    2db2:	7b 07       	cpc	r23, r27
    2db4:	08 f4       	brcc	.+2      	; 0x2db8 <vTaskIncrementTick+0xf8>
    2db6:	7f c0       	rjmp	.+254    	; 0x2eb6 <vTaskIncrementTick+0x1f6>
    2db8:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2dbc:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2dc0:	80 81       	ld	r24, Z
    2dc2:	88 23       	and	r24, r24
    2dc4:	f9 f0       	breq	.+62     	; 0x2e04 <vTaskIncrementTick+0x144>
    2dc6:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2dca:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2dce:	07 80       	ldd	r0, Z+7	; 0x07
    2dd0:	f0 85       	ldd	r31, Z+8	; 0x08
    2dd2:	e0 2d       	mov	r30, r0
    2dd4:	c0 85       	ldd	r28, Z+8	; 0x08
    2dd6:	d1 85       	ldd	r29, Z+9	; 0x09
    2dd8:	8a 81       	ldd	r24, Y+2	; 0x02
    2dda:	9b 81       	ldd	r25, Y+3	; 0x03
    2ddc:	ac 81       	ldd	r26, Y+4	; 0x04
    2dde:	bd 81       	ldd	r27, Y+5	; 0x05
    2de0:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2de4:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2de8:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2dec:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2df0:	48 17       	cp	r20, r24
    2df2:	59 07       	cpc	r21, r25
    2df4:	6a 07       	cpc	r22, r26
    2df6:	7b 07       	cpc	r23, r27
    2df8:	58 f1       	brcs	.+86     	; 0x2e50 <vTaskIncrementTick+0x190>
    2dfa:	0f 2e       	mov	r0, r31
    2dfc:	fb e0       	ldi	r31, 0x0B	; 11
    2dfe:	ff 2e       	mov	r15, r31
    2e00:	f0 2d       	mov	r31, r0
    2e02:	2f c0       	rjmp	.+94     	; 0x2e62 <vTaskIncrementTick+0x1a2>
    2e04:	8f ef       	ldi	r24, 0xFF	; 255
    2e06:	9f ef       	ldi	r25, 0xFF	; 255
    2e08:	dc 01       	movw	r26, r24
    2e0a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e0e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e12:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e16:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e1a:	4d c0       	rjmp	.+154    	; 0x2eb6 <vTaskIncrementTick+0x1f6>
    2e1c:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2e20:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2e24:	07 80       	ldd	r0, Z+7	; 0x07
    2e26:	f0 85       	ldd	r31, Z+8	; 0x08
    2e28:	e0 2d       	mov	r30, r0
    2e2a:	c0 85       	ldd	r28, Z+8	; 0x08
    2e2c:	d1 85       	ldd	r29, Z+9	; 0x09
    2e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e30:	9b 81       	ldd	r25, Y+3	; 0x03
    2e32:	ac 81       	ldd	r26, Y+4	; 0x04
    2e34:	bd 81       	ldd	r27, Y+5	; 0x05
    2e36:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    2e3a:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    2e3e:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    2e42:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    2e46:	48 17       	cp	r20, r24
    2e48:	59 07       	cpc	r21, r25
    2e4a:	6a 07       	cpc	r22, r26
    2e4c:	7b 07       	cpc	r23, r27
    2e4e:	48 f4       	brcc	.+18     	; 0x2e62 <vTaskIncrementTick+0x1a2>
    2e50:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2e54:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2e58:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2e5c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2e60:	2a c0       	rjmp	.+84     	; 0x2eb6 <vTaskIncrementTick+0x1f6>
    2e62:	8e 01       	movw	r16, r28
    2e64:	0e 5f       	subi	r16, 0xFE	; 254
    2e66:	1f 4f       	sbci	r17, 0xFF	; 255
    2e68:	c8 01       	movw	r24, r16
    2e6a:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
    2e6e:	88 8d       	ldd	r24, Y+24	; 0x18
    2e70:	99 8d       	ldd	r25, Y+25	; 0x19
    2e72:	89 2b       	or	r24, r25
    2e74:	21 f0       	breq	.+8      	; 0x2e7e <vTaskIncrementTick+0x1be>
    2e76:	ce 01       	movw	r24, r28
    2e78:	0e 96       	adiw	r24, 0x0e	; 14
    2e7a:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
    2e7e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2e80:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2e84:	98 17       	cp	r25, r24
    2e86:	10 f4       	brcc	.+4      	; 0x2e8c <vTaskIncrementTick+0x1cc>
    2e88:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2e8c:	f8 9e       	mul	r15, r24
    2e8e:	c0 01       	movw	r24, r0
    2e90:	11 24       	eor	r1, r1
    2e92:	b8 01       	movw	r22, r16
    2e94:	8e 58       	subi	r24, 0x8E	; 142
    2e96:	9d 4c       	sbci	r25, 0xCD	; 205
    2e98:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    2e9c:	e0 91 5a 32 	lds	r30, 0x325A	; 0x80325a <pxDelayedTaskList>
    2ea0:	f0 91 5b 32 	lds	r31, 0x325B	; 0x80325b <pxDelayedTaskList+0x1>
    2ea4:	80 81       	ld	r24, Z
    2ea6:	81 11       	cpse	r24, r1
    2ea8:	b9 cf       	rjmp	.-142    	; 0x2e1c <vTaskIncrementTick+0x15c>
    2eaa:	ac cf       	rjmp	.-168    	; 0x2e04 <vTaskIncrementTick+0x144>
    2eac:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2eb0:	8f 5f       	subi	r24, 0xFF	; 255
    2eb2:	80 93 41 32 	sts	0x3241, r24	; 0x803241 <uxMissedTicks>
    2eb6:	df 91       	pop	r29
    2eb8:	cf 91       	pop	r28
    2eba:	1f 91       	pop	r17
    2ebc:	0f 91       	pop	r16
    2ebe:	ff 90       	pop	r15
    2ec0:	08 95       	ret

00002ec2 <xTaskResumeAll>:
    2ec2:	cf 92       	push	r12
    2ec4:	df 92       	push	r13
    2ec6:	ef 92       	push	r14
    2ec8:	ff 92       	push	r15
    2eca:	0f 93       	push	r16
    2ecc:	1f 93       	push	r17
    2ece:	cf 93       	push	r28
    2ed0:	df 93       	push	r29
    2ed2:	0f b6       	in	r0, 0x3f	; 63
    2ed4:	f8 94       	cli
    2ed6:	0f 92       	push	r0
    2ed8:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2edc:	81 50       	subi	r24, 0x01	; 1
    2ede:	80 93 42 32 	sts	0x3242, r24	; 0x803242 <uxSchedulerSuspended>
    2ee2:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    2ee6:	81 11       	cpse	r24, r1
    2ee8:	60 c0       	rjmp	.+192    	; 0x2faa <xTaskResumeAll+0xe8>
    2eea:	80 91 4a 32 	lds	r24, 0x324A	; 0x80324a <uxCurrentNumberOfTasks>
    2eee:	81 11       	cpse	r24, r1
    2ef0:	2c c0       	rjmp	.+88     	; 0x2f4a <xTaskResumeAll+0x88>
    2ef2:	5e c0       	rjmp	.+188    	; 0x2fb0 <xTaskResumeAll+0xee>
    2ef4:	d7 01       	movw	r26, r14
    2ef6:	17 96       	adiw	r26, 0x07	; 7
    2ef8:	ed 91       	ld	r30, X+
    2efa:	fc 91       	ld	r31, X
    2efc:	18 97       	sbiw	r26, 0x08	; 8
    2efe:	c0 85       	ldd	r28, Z+8	; 0x08
    2f00:	d1 85       	ldd	r29, Z+9	; 0x09
    2f02:	ce 01       	movw	r24, r28
    2f04:	0e 96       	adiw	r24, 0x0e	; 14
    2f06:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
    2f0a:	8e 01       	movw	r16, r28
    2f0c:	0e 5f       	subi	r16, 0xFE	; 254
    2f0e:	1f 4f       	sbci	r17, 0xFF	; 255
    2f10:	c8 01       	movw	r24, r16
    2f12:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
    2f16:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f18:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    2f1c:	98 17       	cp	r25, r24
    2f1e:	10 f4       	brcc	.+4      	; 0x2f24 <xTaskResumeAll+0x62>
    2f20:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    2f24:	d8 9e       	mul	r13, r24
    2f26:	c0 01       	movw	r24, r0
    2f28:	11 24       	eor	r1, r1
    2f2a:	b8 01       	movw	r22, r16
    2f2c:	8e 58       	subi	r24, 0x8E	; 142
    2f2e:	9d 4c       	sbci	r25, 0xCD	; 205
    2f30:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    2f34:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    2f38:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2f3c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2f3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f40:	98 17       	cp	r25, r24
    2f42:	70 f0       	brcs	.+28     	; 0x2f60 <xTaskResumeAll+0x9e>
    2f44:	cc 24       	eor	r12, r12
    2f46:	c3 94       	inc	r12
    2f48:	0b c0       	rjmp	.+22     	; 0x2f60 <xTaskResumeAll+0x9e>
    2f4a:	c1 2c       	mov	r12, r1
    2f4c:	0f 2e       	mov	r0, r31
    2f4e:	fd e4       	ldi	r31, 0x4D	; 77
    2f50:	ef 2e       	mov	r14, r31
    2f52:	f2 e3       	ldi	r31, 0x32	; 50
    2f54:	ff 2e       	mov	r15, r31
    2f56:	f0 2d       	mov	r31, r0
    2f58:	0f 2e       	mov	r0, r31
    2f5a:	fb e0       	ldi	r31, 0x0B	; 11
    2f5c:	df 2e       	mov	r13, r31
    2f5e:	f0 2d       	mov	r31, r0
    2f60:	f7 01       	movw	r30, r14
    2f62:	80 81       	ld	r24, Z
    2f64:	81 11       	cpse	r24, r1
    2f66:	c6 cf       	rjmp	.-116    	; 0x2ef4 <xTaskResumeAll+0x32>
    2f68:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f6c:	88 23       	and	r24, r24
    2f6e:	81 f0       	breq	.+32     	; 0x2f90 <xTaskResumeAll+0xce>
    2f70:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f74:	88 23       	and	r24, r24
    2f76:	99 f0       	breq	.+38     	; 0x2f9e <xTaskResumeAll+0xdc>
    2f78:	0e 94 60 16 	call	0x2cc0	; 0x2cc0 <vTaskIncrementTick>
    2f7c:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f80:	81 50       	subi	r24, 0x01	; 1
    2f82:	80 93 41 32 	sts	0x3241, r24	; 0x803241 <uxMissedTicks>
    2f86:	80 91 41 32 	lds	r24, 0x3241	; 0x803241 <uxMissedTicks>
    2f8a:	81 11       	cpse	r24, r1
    2f8c:	f5 cf       	rjmp	.-22     	; 0x2f78 <xTaskResumeAll+0xb6>
    2f8e:	07 c0       	rjmp	.+14     	; 0x2f9e <xTaskResumeAll+0xdc>
    2f90:	f1 e0       	ldi	r31, 0x01	; 1
    2f92:	cf 16       	cp	r12, r31
    2f94:	21 f0       	breq	.+8      	; 0x2f9e <xTaskResumeAll+0xdc>
    2f96:	80 91 40 32 	lds	r24, 0x3240	; 0x803240 <xMissedYield>
    2f9a:	81 30       	cpi	r24, 0x01	; 1
    2f9c:	41 f4       	brne	.+16     	; 0x2fae <xTaskResumeAll+0xec>
    2f9e:	10 92 40 32 	sts	0x3240, r1	; 0x803240 <xMissedYield>
    2fa2:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
    2fa6:	81 e0       	ldi	r24, 0x01	; 1
    2fa8:	03 c0       	rjmp	.+6      	; 0x2fb0 <xTaskResumeAll+0xee>
    2faa:	80 e0       	ldi	r24, 0x00	; 0
    2fac:	01 c0       	rjmp	.+2      	; 0x2fb0 <xTaskResumeAll+0xee>
    2fae:	80 e0       	ldi	r24, 0x00	; 0
    2fb0:	0f 90       	pop	r0
    2fb2:	0f be       	out	0x3f, r0	; 63
    2fb4:	df 91       	pop	r29
    2fb6:	cf 91       	pop	r28
    2fb8:	1f 91       	pop	r17
    2fba:	0f 91       	pop	r16
    2fbc:	ff 90       	pop	r15
    2fbe:	ef 90       	pop	r14
    2fc0:	df 90       	pop	r13
    2fc2:	cf 90       	pop	r12
    2fc4:	08 95       	ret

00002fc6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2fc6:	cf 92       	push	r12
    2fc8:	df 92       	push	r13
    2fca:	ef 92       	push	r14
    2fcc:	ff 92       	push	r15
    2fce:	6b 01       	movw	r12, r22
    2fd0:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2fd2:	67 2b       	or	r22, r23
    2fd4:	68 2b       	or	r22, r24
    2fd6:	69 2b       	or	r22, r25
    2fd8:	e9 f0       	breq	.+58     	; 0x3014 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2fda:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2fde:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    2fe2:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    2fe6:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    2fea:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    2fee:	c8 0e       	add	r12, r24
    2ff0:	d9 1e       	adc	r13, r25
    2ff2:	ea 1e       	adc	r14, r26
    2ff4:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ff6:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    2ffa:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    2ffe:	02 96       	adiw	r24, 0x02	; 2
    3000:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3004:	c7 01       	movw	r24, r14
    3006:	b6 01       	movw	r22, r12
    3008:	0e 94 ae 14 	call	0x295c	; 0x295c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    300c:	0e 94 61 17 	call	0x2ec2	; 0x2ec2 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3010:	81 11       	cpse	r24, r1
    3012:	02 c0       	rjmp	.+4      	; 0x3018 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    3014:	0e 94 02 11 	call	0x2204	; 0x2204 <vPortYield>
		}
	}
    3018:	ff 90       	pop	r15
    301a:	ef 90       	pop	r14
    301c:	df 90       	pop	r13
    301e:	cf 90       	pop	r12
    3020:	08 95       	ret

00003022 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3022:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    3026:	81 11       	cpse	r24, r1
    3028:	0c c0       	rjmp	.+24     	; 0x3042 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    302a:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <uxTopReadyPriority>
    302e:	4b e0       	ldi	r20, 0x0B	; 11
    3030:	e4 9f       	mul	r30, r20
    3032:	f0 01       	movw	r30, r0
    3034:	11 24       	eor	r1, r1
    3036:	ee 58       	subi	r30, 0x8E	; 142
    3038:	fd 4c       	sbci	r31, 0xCD	; 205
    303a:	80 81       	ld	r24, Z
    303c:	88 23       	and	r24, r24
    303e:	29 f0       	breq	.+10     	; 0x304a <vTaskSwitchContext+0x28>
    3040:	14 c0       	rjmp	.+40     	; 0x306a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3042:	81 e0       	ldi	r24, 0x01	; 1
    3044:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <xMissedYield>
    3048:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    304a:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    304c:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <uxTopReadyPriority>
    3050:	81 50       	subi	r24, 0x01	; 1
    3052:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3056:	e0 91 44 32 	lds	r30, 0x3244	; 0x803244 <uxTopReadyPriority>
    305a:	9e 9f       	mul	r25, r30
    305c:	f0 01       	movw	r30, r0
    305e:	11 24       	eor	r1, r1
    3060:	ee 58       	subi	r30, 0x8E	; 142
    3062:	fd 4c       	sbci	r31, 0xCD	; 205
    3064:	80 81       	ld	r24, Z
    3066:	88 23       	and	r24, r24
    3068:	89 f3       	breq	.-30     	; 0x304c <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    306a:	80 91 44 32 	lds	r24, 0x3244	; 0x803244 <uxTopReadyPriority>
    306e:	28 2f       	mov	r18, r24
    3070:	30 e0       	ldi	r19, 0x00	; 0
    3072:	4b e0       	ldi	r20, 0x0B	; 11
    3074:	84 9f       	mul	r24, r20
    3076:	c0 01       	movw	r24, r0
    3078:	11 24       	eor	r1, r1
    307a:	dc 01       	movw	r26, r24
    307c:	ae 58       	subi	r26, 0x8E	; 142
    307e:	bd 4c       	sbci	r27, 0xCD	; 205
    3080:	11 96       	adiw	r26, 0x01	; 1
    3082:	ed 91       	ld	r30, X+
    3084:	fc 91       	ld	r31, X
    3086:	12 97       	sbiw	r26, 0x02	; 2
    3088:	04 80       	ldd	r0, Z+4	; 0x04
    308a:	f5 81       	ldd	r31, Z+5	; 0x05
    308c:	e0 2d       	mov	r30, r0
    308e:	11 96       	adiw	r26, 0x01	; 1
    3090:	ed 93       	st	X+, r30
    3092:	fc 93       	st	X, r31
    3094:	12 97       	sbiw	r26, 0x02	; 2
    3096:	8b 58       	subi	r24, 0x8B	; 139
    3098:	9d 4c       	sbci	r25, 0xCD	; 205
    309a:	e8 17       	cp	r30, r24
    309c:	f9 07       	cpc	r31, r25
    309e:	61 f4       	brne	.+24     	; 0x30b8 <vTaskSwitchContext+0x96>
    30a0:	84 81       	ldd	r24, Z+4	; 0x04
    30a2:	95 81       	ldd	r25, Z+5	; 0x05
    30a4:	4b e0       	ldi	r20, 0x0B	; 11
    30a6:	42 9f       	mul	r20, r18
    30a8:	f0 01       	movw	r30, r0
    30aa:	43 9f       	mul	r20, r19
    30ac:	f0 0d       	add	r31, r0
    30ae:	11 24       	eor	r1, r1
    30b0:	ee 58       	subi	r30, 0x8E	; 142
    30b2:	fd 4c       	sbci	r31, 0xCD	; 205
    30b4:	81 83       	std	Z+1, r24	; 0x01
    30b6:	92 83       	std	Z+2, r25	; 0x02
    30b8:	8b e0       	ldi	r24, 0x0B	; 11
    30ba:	82 9f       	mul	r24, r18
    30bc:	f0 01       	movw	r30, r0
    30be:	83 9f       	mul	r24, r19
    30c0:	f0 0d       	add	r31, r0
    30c2:	11 24       	eor	r1, r1
    30c4:	ee 58       	subi	r30, 0x8E	; 142
    30c6:	fd 4c       	sbci	r31, 0xCD	; 205
    30c8:	01 80       	ldd	r0, Z+1	; 0x01
    30ca:	f2 81       	ldd	r31, Z+2	; 0x02
    30cc:	e0 2d       	mov	r30, r0
    30ce:	80 85       	ldd	r24, Z+8	; 0x08
    30d0:	91 85       	ldd	r25, Z+9	; 0x09
    30d2:	80 93 9e 32 	sts	0x329E, r24	; 0x80329e <pxCurrentTCB>
    30d6:	90 93 9f 32 	sts	0x329F, r25	; 0x80329f <pxCurrentTCB+0x1>
    30da:	08 95       	ret

000030dc <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    30dc:	cf 92       	push	r12
    30de:	df 92       	push	r13
    30e0:	ef 92       	push	r14
    30e2:	ff 92       	push	r15
    30e4:	6a 01       	movw	r12, r20
    30e6:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    30e8:	60 91 9e 32 	lds	r22, 0x329E	; 0x80329e <pxCurrentTCB>
    30ec:	70 91 9f 32 	lds	r23, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    30f0:	62 5f       	subi	r22, 0xF2	; 242
    30f2:	7f 4f       	sbci	r23, 0xFF	; 255
    30f4:	0e 94 dd 0f 	call	0x1fba	; 0x1fba <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    30f8:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    30fc:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3100:	02 96       	adiw	r24, 0x02	; 2
    3102:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3106:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    310a:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    310e:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    3112:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3116:	bc 01       	movw	r22, r24
    3118:	cd 01       	movw	r24, r26
    311a:	6c 0d       	add	r22, r12
    311c:	7d 1d       	adc	r23, r13
    311e:	8e 1d       	adc	r24, r14
    3120:	9f 1d       	adc	r25, r15
    3122:	0e 94 ae 14 	call	0x295c	; 0x295c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3126:	ff 90       	pop	r15
    3128:	ef 90       	pop	r14
    312a:	df 90       	pop	r13
    312c:	cf 90       	pop	r12
    312e:	08 95       	ret

00003130 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3130:	0f 93       	push	r16
    3132:	1f 93       	push	r17
    3134:	cf 93       	push	r28
    3136:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3138:	dc 01       	movw	r26, r24
    313a:	17 96       	adiw	r26, 0x07	; 7
    313c:	ed 91       	ld	r30, X+
    313e:	fc 91       	ld	r31, X
    3140:	18 97       	sbiw	r26, 0x08	; 8
    3142:	c0 85       	ldd	r28, Z+8	; 0x08
    3144:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3146:	8e 01       	movw	r16, r28
    3148:	02 5f       	subi	r16, 0xF2	; 242
    314a:	1f 4f       	sbci	r17, 0xFF	; 255
    314c:	c8 01       	movw	r24, r16
    314e:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3152:	80 91 42 32 	lds	r24, 0x3242	; 0x803242 <uxSchedulerSuspended>
    3156:	81 11       	cpse	r24, r1
    3158:	16 c0       	rjmp	.+44     	; 0x3186 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    315a:	0c 50       	subi	r16, 0x0C	; 12
    315c:	11 09       	sbc	r17, r1
    315e:	c8 01       	movw	r24, r16
    3160:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3164:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3166:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    316a:	98 17       	cp	r25, r24
    316c:	10 f4       	brcc	.+4      	; 0x3172 <xTaskRemoveFromEventList+0x42>
    316e:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    3172:	bb e0       	ldi	r27, 0x0B	; 11
    3174:	8b 9f       	mul	r24, r27
    3176:	c0 01       	movw	r24, r0
    3178:	11 24       	eor	r1, r1
    317a:	b8 01       	movw	r22, r16
    317c:	8e 58       	subi	r24, 0x8E	; 142
    317e:	9d 4c       	sbci	r25, 0xCD	; 205
    3180:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    3184:	05 c0       	rjmp	.+10     	; 0x3190 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3186:	b8 01       	movw	r22, r16
    3188:	8d e4       	ldi	r24, 0x4D	; 77
    318a:	92 e3       	ldi	r25, 0x32	; 50
    318c:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3190:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    3194:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    319c:	92 8d       	ldd	r25, Z+26	; 0x1a
    319e:	29 17       	cp	r18, r25
    31a0:	08 f4       	brcc	.+2      	; 0x31a4 <xTaskRemoveFromEventList+0x74>
    31a2:	80 e0       	ldi	r24, 0x00	; 0
}
    31a4:	df 91       	pop	r29
    31a6:	cf 91       	pop	r28
    31a8:	1f 91       	pop	r17
    31aa:	0f 91       	pop	r16
    31ac:	08 95       	ret

000031ae <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    31ae:	20 91 3f 32 	lds	r18, 0x323F	; 0x80323f <xNumOfOverflows>
    31b2:	fc 01       	movw	r30, r24
    31b4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    31b6:	40 91 46 32 	lds	r20, 0x3246	; 0x803246 <xTickCount>
    31ba:	50 91 47 32 	lds	r21, 0x3247	; 0x803247 <xTickCount+0x1>
    31be:	60 91 48 32 	lds	r22, 0x3248	; 0x803248 <xTickCount+0x2>
    31c2:	70 91 49 32 	lds	r23, 0x3249	; 0x803249 <xTickCount+0x3>
    31c6:	41 83       	std	Z+1, r20	; 0x01
    31c8:	52 83       	std	Z+2, r21	; 0x02
    31ca:	63 83       	std	Z+3, r22	; 0x03
    31cc:	74 83       	std	Z+4, r23	; 0x04
    31ce:	08 95       	ret

000031d0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    31d0:	8f 92       	push	r8
    31d2:	9f 92       	push	r9
    31d4:	af 92       	push	r10
    31d6:	bf 92       	push	r11
    31d8:	cf 92       	push	r12
    31da:	df 92       	push	r13
    31dc:	ef 92       	push	r14
    31de:	ff 92       	push	r15
    31e0:	0f 93       	push	r16
    31e2:	1f 93       	push	r17
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    31ea:	0f b6       	in	r0, 0x3f	; 63
    31ec:	f8 94       	cli
    31ee:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    31f0:	80 91 3f 32 	lds	r24, 0x323F	; 0x80323f <xNumOfOverflows>
    31f4:	90 81       	ld	r25, Z
    31f6:	98 17       	cp	r25, r24
    31f8:	89 f0       	breq	.+34     	; 0x321c <xTaskCheckForTimeOut+0x4c>
    31fa:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    31fe:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    3202:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    3206:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    320a:	01 81       	ldd	r16, Z+1	; 0x01
    320c:	12 81       	ldd	r17, Z+2	; 0x02
    320e:	23 81       	ldd	r18, Z+3	; 0x03
    3210:	34 81       	ldd	r19, Z+4	; 0x04
    3212:	80 17       	cp	r24, r16
    3214:	91 07       	cpc	r25, r17
    3216:	a2 07       	cpc	r26, r18
    3218:	b3 07       	cpc	r27, r19
    321a:	a8 f5       	brcc	.+106    	; 0x3286 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    321c:	80 91 46 32 	lds	r24, 0x3246	; 0x803246 <xTickCount>
    3220:	90 91 47 32 	lds	r25, 0x3247	; 0x803247 <xTickCount+0x1>
    3224:	a0 91 48 32 	lds	r26, 0x3248	; 0x803248 <xTickCount+0x2>
    3228:	b0 91 49 32 	lds	r27, 0x3249	; 0x803249 <xTickCount+0x3>
    322c:	c1 80       	ldd	r12, Z+1	; 0x01
    322e:	d2 80       	ldd	r13, Z+2	; 0x02
    3230:	e3 80       	ldd	r14, Z+3	; 0x03
    3232:	f4 80       	ldd	r15, Z+4	; 0x04
    3234:	eb 01       	movw	r28, r22
    3236:	08 81       	ld	r16, Y
    3238:	19 81       	ldd	r17, Y+1	; 0x01
    323a:	2a 81       	ldd	r18, Y+2	; 0x02
    323c:	3b 81       	ldd	r19, Y+3	; 0x03
    323e:	8c 19       	sub	r24, r12
    3240:	9d 09       	sbc	r25, r13
    3242:	ae 09       	sbc	r26, r14
    3244:	bf 09       	sbc	r27, r15
    3246:	80 17       	cp	r24, r16
    3248:	91 07       	cpc	r25, r17
    324a:	a2 07       	cpc	r26, r18
    324c:	b3 07       	cpc	r27, r19
    324e:	e8 f4       	brcc	.+58     	; 0x328a <xTaskCheckForTimeOut+0xba>
    3250:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3252:	80 90 46 32 	lds	r8, 0x3246	; 0x803246 <xTickCount>
    3256:	90 90 47 32 	lds	r9, 0x3247	; 0x803247 <xTickCount+0x1>
    325a:	a0 90 48 32 	lds	r10, 0x3248	; 0x803248 <xTickCount+0x2>
    325e:	b0 90 49 32 	lds	r11, 0x3249	; 0x803249 <xTickCount+0x3>
    3262:	b5 01       	movw	r22, r10
    3264:	a4 01       	movw	r20, r8
    3266:	4c 19       	sub	r20, r12
    3268:	5d 09       	sbc	r21, r13
    326a:	6e 09       	sbc	r22, r14
    326c:	7f 09       	sbc	r23, r15
    326e:	04 1b       	sub	r16, r20
    3270:	15 0b       	sbc	r17, r21
    3272:	26 0b       	sbc	r18, r22
    3274:	37 0b       	sbc	r19, r23
    3276:	08 83       	st	Y, r16
    3278:	19 83       	std	Y+1, r17	; 0x01
    327a:	2a 83       	std	Y+2, r18	; 0x02
    327c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    327e:	0e 94 d7 18 	call	0x31ae	; 0x31ae <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3282:	80 e0       	ldi	r24, 0x00	; 0
    3284:	03 c0       	rjmp	.+6      	; 0x328c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	01 c0       	rjmp	.+2      	; 0x328c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    328a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    328c:	0f 90       	pop	r0
    328e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3290:	df 91       	pop	r29
    3292:	cf 91       	pop	r28
    3294:	1f 91       	pop	r17
    3296:	0f 91       	pop	r16
    3298:	ff 90       	pop	r15
    329a:	ef 90       	pop	r14
    329c:	df 90       	pop	r13
    329e:	cf 90       	pop	r12
    32a0:	bf 90       	pop	r11
    32a2:	af 90       	pop	r10
    32a4:	9f 90       	pop	r9
    32a6:	8f 90       	pop	r8
    32a8:	08 95       	ret

000032aa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    32aa:	81 e0       	ldi	r24, 0x01	; 1
    32ac:	80 93 40 32 	sts	0x3240, r24	; 0x803240 <xMissedYield>
    32b0:	08 95       	ret

000032b2 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    32b2:	00 97       	sbiw	r24, 0x00	; 0
    32b4:	21 f4       	brne	.+8      	; 0x32be <uxTaskGetStackHighWaterMark+0xc>
    32b6:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    32ba:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    32be:	dc 01       	movw	r26, r24
    32c0:	5b 96       	adiw	r26, 0x1b	; 27
    32c2:	ed 91       	ld	r30, X+
    32c4:	fc 91       	ld	r31, X
    32c6:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32c8:	80 81       	ld	r24, Z
    32ca:	81 31       	cpi	r24, 0x11	; 17
    32cc:	41 f4       	brne	.+16     	; 0x32de <uxTaskGetStackHighWaterMark+0x2c>
    32ce:	31 96       	adiw	r30, 0x01	; 1
    32d0:	80 e0       	ldi	r24, 0x00	; 0
    32d2:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    32d4:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    32d6:	21 91       	ld	r18, Z+
    32d8:	21 31       	cpi	r18, 0x11	; 17
    32da:	e1 f3       	breq	.-8      	; 0x32d4 <uxTaskGetStackHighWaterMark+0x22>
    32dc:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    32de:	80 e0       	ldi	r24, 0x00	; 0
    32e0:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    32e2:	08 95       	ret

000032e4 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    32e4:	80 91 9e 32 	lds	r24, 0x329E	; 0x80329e <pxCurrentTCB>
    32e8:	90 91 9f 32 	lds	r25, 0x329F	; 0x80329f <pxCurrentTCB+0x1>

		return xReturn;
	}
    32ec:	08 95       	ret

000032ee <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    32ee:	0f 93       	push	r16
    32f0:	1f 93       	push	r17
    32f2:	cf 93       	push	r28
    32f4:	df 93       	push	r29
    32f6:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    32f8:	22 8d       	ldd	r18, Z+26	; 0x1a
    32fa:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    32fe:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3302:	5a 96       	adiw	r26, 0x1a	; 26
    3304:	8c 91       	ld	r24, X
    3306:	28 17       	cp	r18, r24
    3308:	08 f0       	brcs	.+2      	; 0x330c <vTaskPriorityInherit+0x1e>
    330a:	41 c0       	rjmp	.+130    	; 0x338e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    330c:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    3310:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3314:	5a 96       	adiw	r26, 0x1a	; 26
    3316:	3c 91       	ld	r19, X
    3318:	84 e0       	ldi	r24, 0x04	; 4
    331a:	90 e0       	ldi	r25, 0x00	; 0
    331c:	a0 e0       	ldi	r26, 0x00	; 0
    331e:	b0 e0       	ldi	r27, 0x00	; 0
    3320:	83 1b       	sub	r24, r19
    3322:	91 09       	sbc	r25, r1
    3324:	a1 09       	sbc	r26, r1
    3326:	b1 09       	sbc	r27, r1
    3328:	86 87       	std	Z+14, r24	; 0x0e
    332a:	97 87       	std	Z+15, r25	; 0x0f
    332c:	a0 8b       	std	Z+16, r26	; 0x10
    332e:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    3330:	8b e0       	ldi	r24, 0x0B	; 11
    3332:	28 9f       	mul	r18, r24
    3334:	90 01       	movw	r18, r0
    3336:	11 24       	eor	r1, r1
    3338:	2e 58       	subi	r18, 0x8E	; 142
    333a:	3d 4c       	sbci	r19, 0xCD	; 205
    333c:	84 85       	ldd	r24, Z+12	; 0x0c
    333e:	95 85       	ldd	r25, Z+13	; 0x0d
    3340:	82 17       	cp	r24, r18
    3342:	93 07       	cpc	r25, r19
    3344:	e9 f4       	brne	.+58     	; 0x3380 <vTaskPriorityInherit+0x92>
    3346:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    3348:	ef 01       	movw	r28, r30
    334a:	22 96       	adiw	r28, 0x02	; 2
    334c:	ce 01       	movw	r24, r28
    334e:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3352:	e0 91 9e 32 	lds	r30, 0x329E	; 0x80329e <pxCurrentTCB>
    3356:	f0 91 9f 32 	lds	r31, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    335a:	82 8d       	ldd	r24, Z+26	; 0x1a
    335c:	f8 01       	movw	r30, r16
    335e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    3360:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    3364:	98 17       	cp	r25, r24
    3366:	10 f4       	brcc	.+4      	; 0x336c <vTaskPriorityInherit+0x7e>
    3368:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    336c:	fb e0       	ldi	r31, 0x0B	; 11
    336e:	8f 9f       	mul	r24, r31
    3370:	c0 01       	movw	r24, r0
    3372:	11 24       	eor	r1, r1
    3374:	be 01       	movw	r22, r28
    3376:	8e 58       	subi	r24, 0x8E	; 142
    3378:	9d 4c       	sbci	r25, 0xCD	; 205
    337a:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
    337e:	07 c0       	rjmp	.+14     	; 0x338e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3380:	a0 91 9e 32 	lds	r26, 0x329E	; 0x80329e <pxCurrentTCB>
    3384:	b0 91 9f 32 	lds	r27, 0x329F	; 0x80329f <pxCurrentTCB+0x1>
    3388:	5a 96       	adiw	r26, 0x1a	; 26
    338a:	8c 91       	ld	r24, X
    338c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    338e:	df 91       	pop	r29
    3390:	cf 91       	pop	r28
    3392:	1f 91       	pop	r17
    3394:	0f 91       	pop	r16
    3396:	08 95       	ret

00003398 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    3398:	0f 93       	push	r16
    339a:	1f 93       	push	r17
    339c:	cf 93       	push	r28
    339e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    33a0:	00 97       	sbiw	r24, 0x00	; 0
    33a2:	49 f1       	breq	.+82     	; 0x33f6 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    33a4:	fc 01       	movw	r30, r24
    33a6:	32 8d       	ldd	r19, Z+26	; 0x1a
    33a8:	27 a1       	ldd	r18, Z+39	; 0x27
    33aa:	32 17       	cp	r19, r18
    33ac:	21 f1       	breq	.+72     	; 0x33f6 <vTaskPriorityDisinherit+0x5e>
    33ae:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    33b0:	8c 01       	movw	r16, r24
    33b2:	0e 5f       	subi	r16, 0xFE	; 254
    33b4:	1f 4f       	sbci	r17, 0xFF	; 255
    33b6:	c8 01       	movw	r24, r16
    33b8:	0e 94 28 10 	call	0x2050	; 0x2050 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    33bc:	8f a1       	ldd	r24, Y+39	; 0x27
    33be:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    33c0:	44 e0       	ldi	r20, 0x04	; 4
    33c2:	50 e0       	ldi	r21, 0x00	; 0
    33c4:	60 e0       	ldi	r22, 0x00	; 0
    33c6:	70 e0       	ldi	r23, 0x00	; 0
    33c8:	48 1b       	sub	r20, r24
    33ca:	51 09       	sbc	r21, r1
    33cc:	61 09       	sbc	r22, r1
    33ce:	71 09       	sbc	r23, r1
    33d0:	4e 87       	std	Y+14, r20	; 0x0e
    33d2:	5f 87       	std	Y+15, r21	; 0x0f
    33d4:	68 8b       	std	Y+16, r22	; 0x10
    33d6:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    33d8:	90 91 44 32 	lds	r25, 0x3244	; 0x803244 <uxTopReadyPriority>
    33dc:	98 17       	cp	r25, r24
    33de:	10 f4       	brcc	.+4      	; 0x33e4 <vTaskPriorityDisinherit+0x4c>
    33e0:	80 93 44 32 	sts	0x3244, r24	; 0x803244 <uxTopReadyPriority>
    33e4:	fb e0       	ldi	r31, 0x0B	; 11
    33e6:	8f 9f       	mul	r24, r31
    33e8:	c0 01       	movw	r24, r0
    33ea:	11 24       	eor	r1, r1
    33ec:	b8 01       	movw	r22, r16
    33ee:	8e 58       	subi	r24, 0x8E	; 142
    33f0:	9d 4c       	sbci	r25, 0xCD	; 205
    33f2:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <vListInsertEnd>
			}
		}
	}
    33f6:	df 91       	pop	r29
    33f8:	cf 91       	pop	r28
    33fa:	1f 91       	pop	r17
    33fc:	0f 91       	pop	r16
    33fe:	08 95       	ret

00003400 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    3400:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    3402:	e8 81       	ld	r30, Y
    3404:	f9 81       	ldd	r31, Y+1	; 0x01
    3406:	01 90       	ld	r0, Z+
    3408:	f0 81       	ld	r31, Z
    340a:	e0 2d       	mov	r30, r0
    340c:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    340e:	1a 82       	std	Y+2, r1	; 0x02
    3410:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    3412:	6f ef       	ldi	r22, 0xFF	; 255
    3414:	7f ef       	ldi	r23, 0xFF	; 255
    3416:	cb 01       	movw	r24, r22
    3418:	0e 94 e3 17 	call	0x2fc6	; 0x2fc6 <vTaskDelay>
    341c:	fa cf       	rjmp	.-12     	; 0x3412 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000341e <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    341e:	fc 01       	movw	r30, r24
    3420:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    3422:	65 87       	std	Z+13, r22	; 0x0d
    3424:	08 95       	ret

00003426 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    3426:	4f 92       	push	r4
    3428:	5f 92       	push	r5
    342a:	6f 92       	push	r6
    342c:	7f 92       	push	r7
    342e:	8f 92       	push	r8
    3430:	9f 92       	push	r9
    3432:	af 92       	push	r10
    3434:	bf 92       	push	r11
    3436:	cf 92       	push	r12
    3438:	df 92       	push	r13
    343a:	ef 92       	push	r14
    343c:	ff 92       	push	r15
    343e:	0f 93       	push	r16
    3440:	1f 93       	push	r17
    3442:	cf 93       	push	r28
    3444:	df 93       	push	r29
    3446:	cd b7       	in	r28, 0x3d	; 61
    3448:	de b7       	in	r29, 0x3e	; 62
    344a:	2a 97       	sbiw	r28, 0x0a	; 10
    344c:	cd bf       	out	0x3d, r28	; 61
    344e:	de bf       	out	0x3e, r29	; 62
    3450:	4c 01       	movw	r8, r24
    3452:	29 01       	movw	r4, r18
    3454:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    3456:	8c e8       	ldi	r24, 0x8C	; 140
    3458:	91 e2       	ldi	r25, 0x21	; 33
    345a:	f4 01       	movw	r30, r8
    345c:	80 83       	st	Z, r24
    345e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3460:	fb 01       	movw	r30, r22
    3462:	80 81       	ld	r24, Z
    3464:	88 23       	and	r24, r24
    3466:	69 f0       	breq	.+26     	; 0x3482 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    3468:	de 01       	movw	r26, r28
    346a:	11 96       	adiw	r26, 0x01	; 1
    346c:	31 96       	adiw	r30, 0x01	; 1
    346e:	90 e0       	ldi	r25, 0x00	; 0
    3470:	02 c0       	rjmp	.+4      	; 0x3476 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3472:	99 30       	cpi	r25, 0x09	; 9
    3474:	39 f0       	breq	.+14     	; 0x3484 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    3476:	9f 5f       	subi	r25, 0xFF	; 255
    3478:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    347a:	81 91       	ld	r24, Z+
    347c:	81 11       	cpse	r24, r1
    347e:	f9 cf       	rjmp	.-14     	; 0x3472 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3480:	01 c0       	rjmp	.+2      	; 0x3484 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3482:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3484:	e1 e0       	ldi	r30, 0x01	; 1
    3486:	f0 e0       	ldi	r31, 0x00	; 0
    3488:	ec 0f       	add	r30, r28
    348a:	fd 1f       	adc	r31, r29
    348c:	e9 0f       	add	r30, r25
    348e:	f1 1d       	adc	r31, r1
    3490:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3492:	74 01       	movw	r14, r8
    3494:	f2 e0       	ldi	r31, 0x02	; 2
    3496:	ef 0e       	add	r14, r31
    3498:	f1 1c       	adc	r15, r1
    349a:	a1 2c       	mov	r10, r1
    349c:	b1 2c       	mov	r11, r1
    349e:	c1 2c       	mov	r12, r1
    34a0:	d1 2c       	mov	r13, r1
    34a2:	04 2f       	mov	r16, r20
    34a4:	94 01       	movw	r18, r8
    34a6:	a2 01       	movw	r20, r4
    34a8:	be 01       	movw	r22, r28
    34aa:	6f 5f       	subi	r22, 0xFF	; 255
    34ac:	7f 4f       	sbci	r23, 0xFF	; 255
    34ae:	86 e3       	ldi	r24, 0x36	; 54
    34b0:	93 e0       	ldi	r25, 0x03	; 3
    34b2:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    34b6:	f4 01       	movw	r30, r8
    34b8:	66 82       	std	Z+6, r6	; 0x06
    34ba:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    34bc:	40 86       	std	Z+8, r4	; 0x08
    34be:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    34c0:	20 91 a0 32 	lds	r18, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    34c4:	30 91 a1 32 	lds	r19, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    34c8:	24 83       	std	Z+4, r18	; 0x04
    34ca:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    34cc:	80 92 a0 32 	sts	0x32A0, r8	; 0x8032a0 <last_created_task_pointer>
    34d0:	90 92 a1 32 	sts	0x32A1, r9	; 0x8032a1 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    34d4:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    34d6:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    34d8:	40 90 02 33 	lds	r4, 0x3302	; 0x803302 <portStackTopForTask>
    34dc:	50 90 03 33 	lds	r5, 0x3303	; 0x803303 <portStackTopForTask+0x1>
    34e0:	ff ef       	ldi	r31, 0xFF	; 255
    34e2:	4f 1a       	sub	r4, r31
    34e4:	5f 0a       	sbc	r5, r31
    34e6:	40 92 02 33 	sts	0x3302, r4	; 0x803302 <portStackTopForTask>
    34ea:	50 92 03 33 	sts	0x3303, r5	; 0x803303 <portStackTopForTask+0x1>
    34ee:	f4 01       	movw	r30, r8
    34f0:	42 86       	std	Z+10, r4	; 0x0a
    34f2:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    34f4:	16 86       	std	Z+14, r1	; 0x0e
    34f6:	17 86       	std	Z+15, r1	; 0x0f
    34f8:	10 8a       	std	Z+16, r1	; 0x10
    34fa:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    34fc:	61 14       	cp	r6, r1
    34fe:	71 04       	cpc	r7, r1
    3500:	09 f4       	brne	.+2      	; 0x3504 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    3502:	44 c0       	rjmp	.+136    	; 0x358c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    3504:	81 30       	cpi	r24, 0x01	; 1
    3506:	79 f5       	brne	.+94     	; 0x3566 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    3508:	6a e0       	ldi	r22, 0x0A	; 10
    350a:	c3 01       	movw	r24, r6
    350c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3510:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3512:	69 eb       	ldi	r22, 0xB9	; 185
    3514:	75 e0       	ldi	r23, 0x05	; 5
    3516:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    351a:	be 01       	movw	r22, r28
    351c:	6f 5f       	subi	r22, 0xFF	; 255
    351e:	7f 4f       	sbci	r23, 0xFF	; 255
    3520:	c7 01       	movw	r24, r14
    3522:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3526:	6a e0       	ldi	r22, 0x0A	; 10
    3528:	c7 01       	movw	r24, r14
    352a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    352e:	7c 01       	movw	r14, r24
    3530:	60 eb       	ldi	r22, 0xB0	; 176
    3532:	75 e0       	ldi	r23, 0x05	; 5
    3534:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    3538:	6a e0       	ldi	r22, 0x0A	; 10
    353a:	c7 01       	movw	r24, r14
    353c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3540:	7c 01       	movw	r14, r24
    3542:	62 ea       	ldi	r22, 0xA2	; 162
    3544:	75 e0       	ldi	r23, 0x05	; 5
    3546:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    354a:	63 e0       	ldi	r22, 0x03	; 3
    354c:	c7 01       	movw	r24, r14
    354e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3552:	b2 01       	movw	r22, r4
    3554:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    3558:	62 e0       	ldi	r22, 0x02	; 2
    355a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    355e:	66 e0       	ldi	r22, 0x06	; 6
    3560:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3564:	13 c0       	rjmp	.+38     	; 0x358c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    3566:	6a e0       	ldi	r22, 0x0A	; 10
    3568:	c3 01       	movw	r24, r6
    356a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    356e:	4c 01       	movw	r8, r24
    3570:	6d e8       	ldi	r22, 0x8D	; 141
    3572:	75 e0       	ldi	r23, 0x05	; 5
    3574:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3578:	be 01       	movw	r22, r28
    357a:	6f 5f       	subi	r22, 0xFF	; 255
    357c:	7f 4f       	sbci	r23, 0xFF	; 255
    357e:	c4 01       	movw	r24, r8
    3580:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3584:	66 e0       	ldi	r22, 0x06	; 6
    3586:	c4 01       	movw	r24, r8
    3588:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    358c:	2a 96       	adiw	r28, 0x0a	; 10
    358e:	cd bf       	out	0x3d, r28	; 61
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	df 91       	pop	r29
    3594:	cf 91       	pop	r28
    3596:	1f 91       	pop	r17
    3598:	0f 91       	pop	r16
    359a:	ff 90       	pop	r15
    359c:	ef 90       	pop	r14
    359e:	df 90       	pop	r13
    35a0:	cf 90       	pop	r12
    35a2:	bf 90       	pop	r11
    35a4:	af 90       	pop	r10
    35a6:	9f 90       	pop	r9
    35a8:	8f 90       	pop	r8
    35aa:	7f 90       	pop	r7
    35ac:	6f 90       	pop	r6
    35ae:	5f 90       	pop	r5
    35b0:	4f 90       	pop	r4
    35b2:	08 95       	ret

000035b4 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    35b4:	cf 92       	push	r12
    35b6:	df 92       	push	r13
    35b8:	ef 92       	push	r14
    35ba:	ff 92       	push	r15
    35bc:	0f 93       	push	r16
    35be:	1f 93       	push	r17
    35c0:	cf 93       	push	r28
    35c2:	df 93       	push	r29
    35c4:	ec 01       	movw	r28, r24
    35c6:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    35c8:	8a 81       	ldd	r24, Y+2	; 0x02
    35ca:	9b 81       	ldd	r25, Y+3	; 0x03
    35cc:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <pcTaskGetTaskName>
    35d0:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    35d2:	6a e0       	ldi	r22, 0x0A	; 10
    35d4:	c7 01       	movw	r24, r14
    35d6:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    35da:	8c 01       	movw	r16, r24
    35dc:	6c ec       	ldi	r22, 0xCC	; 204
    35de:	75 e0       	ldi	r23, 0x05	; 5
    35e0:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    35e4:	6a e0       	ldi	r22, 0x0A	; 10
    35e6:	c8 01       	movw	r24, r16
    35e8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    35ec:	8c 01       	movw	r16, r24
    35ee:	65 ec       	ldi	r22, 0xC5	; 197
    35f0:	75 e0       	ldi	r23, 0x05	; 5
    35f2:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    35f6:	b6 01       	movw	r22, r12
    35f8:	c8 01       	movw	r24, r16
    35fa:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    35fe:	6a e0       	ldi	r22, 0x0A	; 10
    3600:	c8 01       	movw	r24, r16
    3602:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3606:	8c 01       	movw	r16, r24
    3608:	6f eb       	ldi	r22, 0xBF	; 191
    360a:	75 e0       	ldi	r23, 0x05	; 5
    360c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3610:	66 e0       	ldi	r22, 0x06	; 6
    3612:	c8 01       	movw	r24, r16
    3614:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    3618:	8a 85       	ldd	r24, Y+10	; 0x0a
    361a:	9b 85       	ldd	r25, Y+11	; 0x0b
    361c:	e8 85       	ldd	r30, Y+8	; 0x08
    361e:	f9 85       	ldd	r31, Y+9	; 0x09
    3620:	01 e1       	ldi	r16, 0x11	; 17
    3622:	21 e0       	ldi	r18, 0x01	; 1
    3624:	a7 01       	movw	r20, r14
    3626:	bc 01       	movw	r22, r24
    3628:	8e 1b       	sub	r24, r30
    362a:	9f 0b       	sbc	r25, r31
    362c:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    3630:	8c 81       	ldd	r24, Y+4	; 0x04
    3632:	9d 81       	ldd	r25, Y+5	; 0x05
    3634:	00 97       	sbiw	r24, 0x00	; 0
    3636:	19 f0       	breq	.+6      	; 0x363e <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    3638:	b7 01       	movw	r22, r14
    363a:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    363e:	df 91       	pop	r29
    3640:	cf 91       	pop	r28
    3642:	1f 91       	pop	r17
    3644:	0f 91       	pop	r16
    3646:	ff 90       	pop	r15
    3648:	ef 90       	pop	r14
    364a:	df 90       	pop	r13
    364c:	cf 90       	pop	r12
    364e:	08 95       	ret

00003650 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3650:	0f 93       	push	r16
    3652:	1f 93       	push	r17
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    365a:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    365e:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    3662:	00 97       	sbiw	r24, 0x00	; 0
    3664:	19 f0       	breq	.+6      	; 0x366c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3666:	be 01       	movw	r22, r28
    3668:	0e 94 da 1a 	call	0x35b4	; 0x35b4 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    366c:	6a e0       	ldi	r22, 0x0A	; 10
    366e:	ce 01       	movw	r24, r28
    3670:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3674:	8c 01       	movw	r16, r24
    3676:	62 ee       	ldi	r22, 0xE2	; 226
    3678:	75 e0       	ldi	r23, 0x05	; 5
    367a:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    367e:	6a e0       	ldi	r22, 0x0A	; 10
    3680:	c8 01       	movw	r24, r16
    3682:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3686:	8c 01       	movw	r16, r24
    3688:	67 ed       	ldi	r22, 0xD7	; 215
    368a:	75 e0       	ldi	r23, 0x05	; 5
    368c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3690:	6a e0       	ldi	r22, 0x0A	; 10
    3692:	c8 01       	movw	r24, r16
    3694:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3698:	8c 01       	movw	r16, r24
    369a:	61 ed       	ldi	r22, 0xD1	; 209
    369c:	75 e0       	ldi	r23, 0x05	; 5
    369e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    36a2:	66 e0       	ldi	r22, 0x06	; 6
    36a4:	c8 01       	movw	r24, r16
    36a6:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    36aa:	80 91 02 33 	lds	r24, 0x3302	; 0x803302 <portStackTopForTask>
    36ae:	90 91 03 33 	lds	r25, 0x3303	; 0x803303 <portStackTopForTask+0x1>
    36b2:	bc 01       	movw	r22, r24
    36b4:	6f 5f       	subi	r22, 0xFF	; 255
    36b6:	7f 4f       	sbci	r23, 0xFF	; 255
    36b8:	01 e1       	ldi	r16, 0x11	; 17
    36ba:	21 e0       	ldi	r18, 0x01	; 1
    36bc:	ae 01       	movw	r20, r28
    36be:	83 56       	subi	r24, 0x63	; 99
    36c0:	91 09       	sbc	r25, r1
    36c2:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	1f 91       	pop	r17
    36cc:	0f 91       	pop	r16
    36ce:	08 95       	ret

000036d0 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    36d0:	8f 92       	push	r8
    36d2:	9f 92       	push	r9
    36d4:	af 92       	push	r10
    36d6:	bf 92       	push	r11
    36d8:	cf 92       	push	r12
    36da:	df 92       	push	r13
    36dc:	ef 92       	push	r14
    36de:	ff 92       	push	r15
    36e0:	0f 93       	push	r16
    36e2:	1f 93       	push	r17
    36e4:	cf 93       	push	r28
    36e6:	df 93       	push	r29
    36e8:	ec 01       	movw	r28, r24
    36ea:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    36ec:	8a 81       	ldd	r24, Y+2	; 0x02
    36ee:	9b 81       	ldd	r25, Y+3	; 0x03
    36f0:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <pcTaskGetTaskName>
    36f4:	bc 01       	movw	r22, r24
    36f6:	c8 01       	movw	r24, r16
    36f8:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    36fc:	d8 01       	movw	r26, r16
    36fe:	ed 91       	ld	r30, X+
    3700:	fc 91       	ld	r31, X
    3702:	02 80       	ldd	r0, Z+2	; 0x02
    3704:	f3 81       	ldd	r31, Z+3	; 0x03
    3706:	e0 2d       	mov	r30, r0
    3708:	69 e0       	ldi	r22, 0x09	; 9
    370a:	c8 01       	movw	r24, r16
    370c:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    370e:	8a 81       	ldd	r24, Y+2	; 0x02
    3710:	9b 81       	ldd	r25, Y+3	; 0x03
    3712:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <pcTaskGetTaskName>
    3716:	fc 01       	movw	r30, r24
    3718:	01 90       	ld	r0, Z+
    371a:	00 20       	and	r0, r0
    371c:	e9 f7       	brne	.-6      	; 0x3718 <_ZN8frt_task12print_statusER8emstream+0x48>
    371e:	31 97       	sbiw	r30, 0x01	; 1
    3720:	e8 1b       	sub	r30, r24
    3722:	f9 0b       	sbc	r31, r25
    3724:	38 97       	sbiw	r30, 0x08	; 8
    3726:	48 f4       	brcc	.+18     	; 0x373a <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    3728:	d8 01       	movw	r26, r16
    372a:	ed 91       	ld	r30, X+
    372c:	fc 91       	ld	r31, X
    372e:	02 80       	ldd	r0, Z+2	; 0x02
    3730:	f3 81       	ldd	r31, Z+3	; 0x03
    3732:	e0 2d       	mov	r30, r0
    3734:	69 e0       	ldi	r22, 0x09	; 9
    3736:	c8 01       	movw	r24, r16
    3738:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    373a:	ce 84       	ldd	r12, Y+14	; 0x0e
    373c:	df 84       	ldd	r13, Y+15	; 0x0f
    373e:	e8 88       	ldd	r14, Y+16	; 0x10
    3740:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    3742:	a8 84       	ldd	r10, Y+8	; 0x08
    3744:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    3746:	8a 81       	ldd	r24, Y+2	; 0x02
    3748:	9b 81       	ldd	r25, Y+3	; 0x03
    374a:	0e 94 59 19 	call	0x32b2	; 0x32b2 <uxTaskGetStackHighWaterMark>
    374e:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3750:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3752:	8a 81       	ldd	r24, Y+2	; 0x02
    3754:	9b 81       	ldd	r25, Y+3	; 0x03
    3756:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <uxTaskPriorityGet>
    375a:	68 2f       	mov	r22, r24
    375c:	c8 01       	movw	r24, r16
    375e:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    3762:	6a e0       	ldi	r22, 0x0A	; 10
    3764:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3768:	ec 01       	movw	r28, r24
    376a:	67 e5       	ldi	r22, 0x57	; 87
    376c:	76 e0       	ldi	r23, 0x06	; 6
    376e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3772:	68 2d       	mov	r22, r8
    3774:	ce 01       	movw	r24, r28
    3776:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    377a:	6a e0       	ldi	r22, 0x0A	; 10
    377c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3780:	ec 01       	movw	r28, r24
    3782:	65 e5       	ldi	r22, 0x55	; 85
    3784:	76 e0       	ldi	r23, 0x06	; 6
    3786:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    378a:	69 2d       	mov	r22, r9
    378c:	ce 01       	movw	r24, r28
    378e:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    3792:	6a e0       	ldi	r22, 0x0A	; 10
    3794:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3798:	ec 01       	movw	r28, r24
    379a:	63 e5       	ldi	r22, 0x53	; 83
    379c:	76 e0       	ldi	r23, 0x06	; 6
    379e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    37a2:	b5 01       	movw	r22, r10
    37a4:	ce 01       	movw	r24, r28
    37a6:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    37aa:	6a e0       	ldi	r22, 0x0A	; 10
    37ac:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    37b0:	ec 01       	movw	r28, r24
    37b2:	61 e5       	ldi	r22, 0x51	; 81
    37b4:	76 e0       	ldi	r23, 0x06	; 6
    37b6:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    37ba:	6a e0       	ldi	r22, 0x0A	; 10
    37bc:	ce 01       	movw	r24, r28
    37be:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    37c2:	ec 01       	movw	r28, r24
    37c4:	6f e4       	ldi	r22, 0x4F	; 79
    37c6:	76 e0       	ldi	r23, 0x06	; 6
    37c8:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    37cc:	b7 01       	movw	r22, r14
    37ce:	a6 01       	movw	r20, r12
    37d0:	ce 01       	movw	r24, r28
    37d2:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <_ZN8emstreamlsEm>
}
    37d6:	df 91       	pop	r29
    37d8:	cf 91       	pop	r28
    37da:	1f 91       	pop	r17
    37dc:	0f 91       	pop	r16
    37de:	ff 90       	pop	r15
    37e0:	ef 90       	pop	r14
    37e2:	df 90       	pop	r13
    37e4:	cf 90       	pop	r12
    37e6:	bf 90       	pop	r11
    37e8:	af 90       	pop	r10
    37ea:	9f 90       	pop	r9
    37ec:	8f 90       	pop	r8
    37ee:	08 95       	ret

000037f0 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    37f0:	cf 93       	push	r28
    37f2:	df 93       	push	r29
    37f4:	ec 01       	movw	r28, r24
    37f6:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    37f8:	db 01       	movw	r26, r22
    37fa:	ed 91       	ld	r30, X+
    37fc:	fc 91       	ld	r31, X
    37fe:	02 80       	ldd	r0, Z+2	; 0x02
    3800:	f3 81       	ldd	r31, Z+3	; 0x03
    3802:	e0 2d       	mov	r30, r0
    3804:	be 01       	movw	r22, r28
    3806:	19 95       	eicall
	return (ser_dev);
}
    3808:	ce 01       	movw	r24, r28
    380a:	df 91       	pop	r29
    380c:	cf 91       	pop	r28
    380e:	08 95       	ret

00003810 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    3810:	0f 93       	push	r16
    3812:	1f 93       	push	r17
    3814:	cf 93       	push	r28
    3816:	df 93       	push	r29
    3818:	ec 01       	movw	r28, r24
    381a:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    381c:	bc 01       	movw	r22, r24
    381e:	c8 01       	movw	r24, r16
    3820:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <_ZlsR8emstreamR8frt_task>
    3824:	66 e0       	ldi	r22, 0x06	; 6
    3826:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    382a:	8c 81       	ldd	r24, Y+4	; 0x04
    382c:	9d 81       	ldd	r25, Y+5	; 0x05
    382e:	00 97       	sbiw	r24, 0x00	; 0
    3830:	19 f0       	breq	.+6      	; 0x3838 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    3832:	b8 01       	movw	r22, r16
    3834:	0e 94 08 1c 	call	0x3810	; 0x3810 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    3838:	df 91       	pop	r29
    383a:	cf 91       	pop	r28
    383c:	1f 91       	pop	r17
    383e:	0f 91       	pop	r16
    3840:	08 95       	ret

00003842 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    3842:	0f 93       	push	r16
    3844:	1f 93       	push	r17
    3846:	cf 93       	push	r28
    3848:	df 93       	push	r29
    384a:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    384c:	6a e0       	ldi	r22, 0x0A	; 10
    384e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3852:	8c 01       	movw	r16, r24
    3854:	64 e4       	ldi	r22, 0x44	; 68
    3856:	76 e0       	ldi	r23, 0x06	; 6
    3858:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    385c:	6a e0       	ldi	r22, 0x0A	; 10
    385e:	c8 01       	movw	r24, r16
    3860:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3864:	8c 01       	movw	r16, r24
    3866:	6d e3       	ldi	r22, 0x3D	; 61
    3868:	76 e0       	ldi	r23, 0x06	; 6
    386a:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    386e:	66 e0       	ldi	r22, 0x06	; 6
    3870:	c8 01       	movw	r24, r16
    3872:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3876:	6a e0       	ldi	r22, 0x0A	; 10
    3878:	ce 01       	movw	r24, r28
    387a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    387e:	8c 01       	movw	r16, r24
    3880:	6c e2       	ldi	r22, 0x2C	; 44
    3882:	76 e0       	ldi	r23, 0x06	; 6
    3884:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3888:	6a e0       	ldi	r22, 0x0A	; 10
    388a:	c8 01       	movw	r24, r16
    388c:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3890:	8c 01       	movw	r16, r24
    3892:	60 e2       	ldi	r22, 0x20	; 32
    3894:	76 e0       	ldi	r23, 0x06	; 6
    3896:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    389a:	6a e0       	ldi	r22, 0x0A	; 10
    389c:	c8 01       	movw	r24, r16
    389e:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    38a2:	8c 01       	movw	r16, r24
    38a4:	6a e1       	ldi	r22, 0x1A	; 26
    38a6:	76 e0       	ldi	r23, 0x06	; 6
    38a8:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    38ac:	66 e0       	ldi	r22, 0x06	; 6
    38ae:	c8 01       	movw	r24, r16
    38b0:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    38b4:	6a e0       	ldi	r22, 0x0A	; 10
    38b6:	ce 01       	movw	r24, r28
    38b8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    38bc:	8c 01       	movw	r16, r24
    38be:	69 e0       	ldi	r22, 0x09	; 9
    38c0:	76 e0       	ldi	r23, 0x06	; 6
    38c2:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    38c6:	6a e0       	ldi	r22, 0x0A	; 10
    38c8:	c8 01       	movw	r24, r16
    38ca:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    38ce:	8c 01       	movw	r16, r24
    38d0:	6d ef       	ldi	r22, 0xFD	; 253
    38d2:	75 e0       	ldi	r23, 0x05	; 5
    38d4:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    38d8:	6a e0       	ldi	r22, 0x0A	; 10
    38da:	c8 01       	movw	r24, r16
    38dc:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    38e0:	8c 01       	movw	r16, r24
    38e2:	67 ef       	ldi	r22, 0xF7	; 247
    38e4:	75 e0       	ldi	r23, 0x05	; 5
    38e6:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    38ea:	66 e0       	ldi	r22, 0x06	; 6
    38ec:	c8 01       	movw	r24, r16
    38ee:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    38f2:	80 91 a0 32 	lds	r24, 0x32A0	; 0x8032a0 <last_created_task_pointer>
    38f6:	90 91 a1 32 	lds	r25, 0x32A1	; 0x8032a1 <last_created_task_pointer+0x1>
    38fa:	00 97       	sbiw	r24, 0x00	; 0
    38fc:	19 f0       	breq	.+6      	; 0x3904 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    38fe:	be 01       	movw	r22, r28
    3900:	0e 94 08 1c 	call	0x3810	; 0x3810 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3904:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <xTaskGetIdleTaskHandle>
    3908:	0e 94 59 19 	call	0x32b2	; 0x32b2 <uxTaskGetStackHighWaterMark>
    390c:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    390e:	6a e0       	ldi	r22, 0x0A	; 10
    3910:	ce 01       	movw	r24, r28
    3912:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3916:	ec 01       	movw	r28, r24
    3918:	6c ee       	ldi	r22, 0xEC	; 236
    391a:	75 e0       	ldi	r23, 0x05	; 5
    391c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    3920:	61 2f       	mov	r22, r17
    3922:	ce 01       	movw	r24, r28
    3924:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    3928:	6a e0       	ldi	r22, 0x0A	; 10
    392a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    392e:	ec 01       	movw	r28, r24
    3930:	6a ee       	ldi	r22, 0xEA	; 234
    3932:	75 e0       	ldi	r23, 0x05	; 5
    3934:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3938:	64 e6       	ldi	r22, 0x64	; 100
    393a:	70 e0       	ldi	r23, 0x00	; 0
    393c:	ce 01       	movw	r24, r28
    393e:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    3942:	6a e0       	ldi	r22, 0x0A	; 10
    3944:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3948:	ec 01       	movw	r28, r24
    394a:	67 ee       	ldi	r22, 0xE7	; 231
    394c:	75 e0       	ldi	r23, 0x05	; 5
    394e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3952:	66 e0       	ldi	r22, 0x06	; 6
    3954:	ce 01       	movw	r24, r28
    3956:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
}
    395a:	df 91       	pop	r29
    395c:	cf 91       	pop	r28
    395e:	1f 91       	pop	r17
    3960:	0f 91       	pop	r16
    3962:	08 95       	ret

00003964 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3964:	0f 93       	push	r16
    3966:	cf 93       	push	r28
    3968:	df 93       	push	r29
    396a:	1f 92       	push	r1
    396c:	cd b7       	in	r28, 0x3d	; 61
    396e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3970:	00 e0       	ldi	r16, 0x00	; 0
    3972:	2f ef       	ldi	r18, 0xFF	; 255
    3974:	3f ef       	ldi	r19, 0xFF	; 255
    3976:	a9 01       	movw	r20, r18
    3978:	be 01       	movw	r22, r28
    397a:	6f 5f       	subi	r22, 0xFF	; 255
    397c:	7f 4f       	sbci	r23, 0xFF	; 255
    397e:	fc 01       	movw	r30, r24
    3980:	80 85       	ldd	r24, Z+8	; 0x08
    3982:	91 85       	ldd	r25, Z+9	; 0x09
    3984:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
    3988:	81 30       	cpi	r24, 0x01	; 1
    398a:	19 f4       	brne	.+6      	; 0x3992 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    398c:	89 81       	ldd	r24, Y+1	; 0x01
    398e:	90 e0       	ldi	r25, 0x00	; 0
    3990:	02 c0       	rjmp	.+4      	; 0x3996 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3992:	8f ef       	ldi	r24, 0xFF	; 255
    3994:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3996:	0f 90       	pop	r0
    3998:	df 91       	pop	r29
    399a:	cf 91       	pop	r28
    399c:	0f 91       	pop	r16
    399e:	08 95       	ret

000039a0 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    39a0:	fc 01       	movw	r30, r24
    39a2:	80 85       	ldd	r24, Z+8	; 0x08
    39a4:	91 85       	ldd	r25, Z+9	; 0x09
    39a6:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    39aa:	91 e0       	ldi	r25, 0x01	; 1
    39ac:	81 11       	cpse	r24, r1
    39ae:	01 c0       	rjmp	.+2      	; 0x39b2 <_ZN14frt_text_queue14check_for_charEv+0x12>
    39b0:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    39b2:	89 2f       	mov	r24, r25
    39b4:	08 95       	ret

000039b6 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    39b6:	0f 93       	push	r16
    39b8:	cf 93       	push	r28
    39ba:	df 93       	push	r29
    39bc:	1f 92       	push	r1
    39be:	cd b7       	in	r28, 0x3d	; 61
    39c0:	de b7       	in	r29, 0x3e	; 62
    39c2:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    39c4:	fc 01       	movw	r30, r24
    39c6:	22 85       	ldd	r18, Z+10	; 0x0a
    39c8:	33 85       	ldd	r19, Z+11	; 0x0b
    39ca:	44 85       	ldd	r20, Z+12	; 0x0c
    39cc:	55 85       	ldd	r21, Z+13	; 0x0d
    39ce:	00 e0       	ldi	r16, 0x00	; 0
    39d0:	be 01       	movw	r22, r28
    39d2:	6f 5f       	subi	r22, 0xFF	; 255
    39d4:	7f 4f       	sbci	r23, 0xFF	; 255
    39d6:	80 85       	ldd	r24, Z+8	; 0x08
    39d8:	91 85       	ldd	r25, Z+9	; 0x09
    39da:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    39de:	91 e0       	ldi	r25, 0x01	; 1
    39e0:	81 11       	cpse	r24, r1
    39e2:	01 c0       	rjmp	.+2      	; 0x39e6 <_ZN14frt_text_queue7putcharEc+0x30>
    39e4:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    39e6:	89 2f       	mov	r24, r25
    39e8:	0f 90       	pop	r0
    39ea:	df 91       	pop	r29
    39ec:	cf 91       	pop	r28
    39ee:	0f 91       	pop	r16
    39f0:	08 95       	ret

000039f2 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    39f2:	8f 92       	push	r8
    39f4:	9f 92       	push	r9
    39f6:	bf 92       	push	r11
    39f8:	cf 92       	push	r12
    39fa:	df 92       	push	r13
    39fc:	ef 92       	push	r14
    39fe:	ff 92       	push	r15
    3a00:	0f 93       	push	r16
    3a02:	1f 93       	push	r17
    3a04:	cf 93       	push	r28
    3a06:	df 93       	push	r29
    3a08:	ec 01       	movw	r28, r24
    3a0a:	b6 2e       	mov	r11, r22
    3a0c:	4a 01       	movw	r8, r20
    3a0e:	68 01       	movw	r12, r16
    3a10:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    3a12:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstreamC1Ev>
    3a16:	84 e9       	ldi	r24, 0x94	; 148
    3a18:	91 e2       	ldi	r25, 0x21	; 33
    3a1a:	88 83       	st	Y, r24
    3a1c:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    3a1e:	8e 86       	std	Y+14, r8	; 0x0e
    3a20:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    3a22:	40 e0       	ldi	r20, 0x00	; 0
    3a24:	61 e0       	ldi	r22, 0x01	; 1
    3a26:	8b 2d       	mov	r24, r11
    3a28:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    3a2c:	88 87       	std	Y+8, r24	; 0x08
    3a2e:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    3a30:	ca 86       	std	Y+10, r12	; 0x0a
    3a32:	db 86       	std	Y+11, r13	; 0x0b
    3a34:	ec 86       	std	Y+12, r14	; 0x0c
    3a36:	fd 86       	std	Y+13, r15	; 0x0d
}
    3a38:	df 91       	pop	r29
    3a3a:	cf 91       	pop	r28
    3a3c:	1f 91       	pop	r17
    3a3e:	0f 91       	pop	r16
    3a40:	ff 90       	pop	r15
    3a42:	ef 90       	pop	r14
    3a44:	df 90       	pop	r13
    3a46:	cf 90       	pop	r12
    3a48:	bf 90       	pop	r11
    3a4a:	9f 90       	pop	r9
    3a4c:	8f 90       	pop	r8
    3a4e:	08 95       	ret

00003a50 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3a50:	cf 92       	push	r12
    3a52:	df 92       	push	r13
    3a54:	ef 92       	push	r14
    3a56:	ff 92       	push	r15
    3a58:	cf 93       	push	r28
    3a5a:	df 93       	push	r29
    3a5c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3a5e:	68 81       	ld	r22, Y
    3a60:	79 81       	ldd	r23, Y+1	; 0x01
    3a62:	8a 81       	ldd	r24, Y+2	; 0x02
    3a64:	9b 81       	ldd	r25, Y+3	; 0x03
    3a66:	0f 2e       	mov	r0, r31
    3a68:	f8 ee       	ldi	r31, 0xE8	; 232
    3a6a:	cf 2e       	mov	r12, r31
    3a6c:	f3 e0       	ldi	r31, 0x03	; 3
    3a6e:	df 2e       	mov	r13, r31
    3a70:	e1 2c       	mov	r14, r1
    3a72:	f1 2c       	mov	r15, r1
    3a74:	f0 2d       	mov	r31, r0
    3a76:	a7 01       	movw	r20, r14
    3a78:	96 01       	movw	r18, r12
    3a7a:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
    3a7e:	9b 01       	movw	r18, r22
    3a80:	ac 01       	movw	r20, r24
    3a82:	60 e4       	ldi	r22, 0x40	; 64
    3a84:	72 e4       	ldi	r23, 0x42	; 66
    3a86:	8f e0       	ldi	r24, 0x0F	; 15
    3a88:	90 e0       	ldi	r25, 0x00	; 0
    3a8a:	0e 94 97 26 	call	0x4d2e	; 0x4d2e <__mulsi3>
    3a8e:	a7 01       	movw	r20, r14
    3a90:	96 01       	movw	r18, r12
    3a92:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
    3a96:	69 01       	movw	r12, r18
    3a98:	7a 01       	movw	r14, r20
    3a9a:	ac 81       	ldd	r26, Y+4	; 0x04
    3a9c:	bd 81       	ldd	r27, Y+5	; 0x05
    3a9e:	20 e4       	ldi	r18, 0x40	; 64
    3aa0:	32 e4       	ldi	r19, 0x42	; 66
    3aa2:	4f e0       	ldi	r20, 0x0F	; 15
    3aa4:	50 e0       	ldi	r21, 0x00	; 0
    3aa6:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <__muluhisi3>
    3aaa:	20 e0       	ldi	r18, 0x00	; 0
    3aac:	38 e4       	ldi	r19, 0x48	; 72
    3aae:	48 ee       	ldi	r20, 0xE8	; 232
    3ab0:	51 e0       	ldi	r21, 0x01	; 1
    3ab2:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
    3ab6:	c7 01       	movw	r24, r14
    3ab8:	b6 01       	movw	r22, r12
    3aba:	62 0f       	add	r22, r18
    3abc:	73 1f       	adc	r23, r19
    3abe:	84 1f       	adc	r24, r20
    3ac0:	95 1f       	adc	r25, r21
}
    3ac2:	df 91       	pop	r29
    3ac4:	cf 91       	pop	r28
    3ac6:	ff 90       	pop	r15
    3ac8:	ef 90       	pop	r14
    3aca:	df 90       	pop	r13
    3acc:	cf 90       	pop	r12
    3ace:	08 95       	ret

00003ad0 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3ad0:	cf 92       	push	r12
    3ad2:	df 92       	push	r13
    3ad4:	ef 92       	push	r14
    3ad6:	ff 92       	push	r15
    3ad8:	0f 93       	push	r16
    3ada:	1f 93       	push	r17
    3adc:	cf 93       	push	r28
    3ade:	df 93       	push	r29
    3ae0:	cd b7       	in	r28, 0x3d	; 61
    3ae2:	de b7       	in	r29, 0x3e	; 62
    3ae4:	2f 97       	sbiw	r28, 0x0f	; 15
    3ae6:	cd bf       	out	0x3d, r28	; 61
    3ae8:	de bf       	out	0x3e, r29	; 62
    3aea:	6c 01       	movw	r12, r24
    3aec:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3aee:	db 01       	movw	r26, r22
    3af0:	6d 91       	ld	r22, X+
    3af2:	7d 91       	ld	r23, X+
    3af4:	8d 91       	ld	r24, X+
    3af6:	9c 91       	ld	r25, X
    3af8:	28 ee       	ldi	r18, 0xE8	; 232
    3afa:	33 e0       	ldi	r19, 0x03	; 3
    3afc:	40 e0       	ldi	r20, 0x00	; 0
    3afe:	50 e0       	ldi	r21, 0x00	; 0
    3b00:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
    3b04:	ba 01       	movw	r22, r20
    3b06:	a9 01       	movw	r20, r18
    3b08:	c6 01       	movw	r24, r12
    3b0a:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    3b0e:	d6 01       	movw	r26, r12
    3b10:	ed 91       	ld	r30, X+
    3b12:	fc 91       	ld	r31, X
    3b14:	02 80       	ldd	r0, Z+2	; 0x02
    3b16:	f3 81       	ldd	r31, Z+3	; 0x03
    3b18:	e0 2d       	mov	r30, r0
    3b1a:	6e e2       	ldi	r22, 0x2E	; 46
    3b1c:	c6 01       	movw	r24, r12
    3b1e:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    3b20:	c8 01       	movw	r24, r16
    3b22:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <_ZN10time_stamp12get_microsecEv>
    3b26:	8e 01       	movw	r16, r28
    3b28:	09 5f       	subi	r16, 0xF9	; 249
    3b2a:	1f 4f       	sbci	r17, 0xFF	; 255
    3b2c:	fe 01       	movw	r30, r28
    3b2e:	31 96       	adiw	r30, 0x01	; 1
    3b30:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    3b32:	2a e0       	ldi	r18, 0x0A	; 10
    3b34:	30 e0       	ldi	r19, 0x00	; 0
    3b36:	40 e0       	ldi	r20, 0x00	; 0
    3b38:	50 e0       	ldi	r21, 0x00	; 0
    3b3a:	0e 94 c9 26 	call	0x4d92	; 0x4d92 <__divmodsi4>
    3b3e:	e6 2f       	mov	r30, r22
    3b40:	28 87       	std	Y+8, r18	; 0x08
    3b42:	39 87       	std	Y+9, r19	; 0x09
    3b44:	4a 87       	std	Y+10, r20	; 0x0a
    3b46:	5b 87       	std	Y+11, r21	; 0x0b
    3b48:	68 85       	ldd	r22, Y+8	; 0x08
    3b4a:	79 85       	ldd	r23, Y+9	; 0x09
    3b4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3b4e:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3b50:	20 e3       	ldi	r18, 0x30	; 48
    3b52:	2e 0f       	add	r18, r30
    3b54:	d8 01       	movw	r26, r16
    3b56:	2e 93       	st	-X, r18
    3b58:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    3b5a:	ae 15       	cp	r26, r14
    3b5c:	bf 05       	cpc	r27, r15
    3b5e:	49 f7       	brne	.-46     	; 0x3b32 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3b60:	1f 82       	std	Y+7, r1	; 0x07
    3b62:	be 01       	movw	r22, r28
    3b64:	6f 5f       	subi	r22, 0xFF	; 255
    3b66:	7f 4f       	sbci	r23, 0xFF	; 255
    3b68:	c6 01       	movw	r24, r12
    3b6a:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3b6e:	c6 01       	movw	r24, r12
    3b70:	2f 96       	adiw	r28, 0x0f	; 15
    3b72:	cd bf       	out	0x3d, r28	; 61
    3b74:	de bf       	out	0x3e, r29	; 62
    3b76:	df 91       	pop	r29
    3b78:	cf 91       	pop	r28
    3b7a:	1f 91       	pop	r17
    3b7c:	0f 91       	pop	r16
    3b7e:	ff 90       	pop	r15
    3b80:	ef 90       	pop	r14
    3b82:	df 90       	pop	r13
    3b84:	cf 90       	pop	r12
    3b86:	08 95       	ret

00003b88 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3b88:	cf 93       	push	r28
    3b8a:	df 93       	push	r29
    3b8c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3b8e:	0f b6       	in	r0, 0x3f	; 63
    3b90:	f8 94       	cli
    3b92:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3b94:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3b98:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3b9c:	8c 83       	std	Y+4, r24	; 0x04
    3b9e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3ba0:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <xTaskGetTickCount>
    3ba4:	68 83       	st	Y, r22
    3ba6:	79 83       	std	Y+1, r23	; 0x01
    3ba8:	8a 83       	std	Y+2, r24	; 0x02
    3baa:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3bac:	0f 90       	pop	r0
    3bae:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3bb0:	ce 01       	movw	r24, r28
    3bb2:	df 91       	pop	r29
    3bb4:	cf 91       	pop	r28
    3bb6:	08 95       	ret

00003bb8 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3bb8:	5f 92       	push	r5
    3bba:	6f 92       	push	r6
    3bbc:	7f 92       	push	r7
    3bbe:	8f 92       	push	r8
    3bc0:	9f 92       	push	r9
    3bc2:	af 92       	push	r10
    3bc4:	bf 92       	push	r11
    3bc6:	cf 92       	push	r12
    3bc8:	df 92       	push	r13
    3bca:	ef 92       	push	r14
    3bcc:	ff 92       	push	r15
    3bce:	0f 93       	push	r16
    3bd0:	1f 93       	push	r17
    3bd2:	cf 93       	push	r28
    3bd4:	df 93       	push	r29
    3bd6:	5c 01       	movw	r10, r24
    3bd8:	4b 01       	movw	r8, r22
    3bda:	7a 01       	movw	r14, r20
    3bdc:	12 2f       	mov	r17, r18
    3bde:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3be0:	63 e0       	ldi	r22, 0x03	; 3
    3be2:	ca 01       	movw	r24, r20
    3be4:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3be8:	a8 14       	cp	r10, r8
    3bea:	b9 04       	cpc	r11, r9
    3bec:	08 f0       	brcs	.+2      	; 0x3bf0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3bee:	7d c0       	rjmp	.+250    	; 0x3cea <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3bf0:	65 01       	movw	r12, r10
    3bf2:	84 e1       	ldi	r24, 0x14	; 20
    3bf4:	c8 0e       	add	r12, r24
    3bf6:	d1 1c       	adc	r13, r1
    3bf8:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3bfa:	6a 2c       	mov	r6, r10
    3bfc:	5b 2c       	mov	r5, r11
    3bfe:	b5 01       	movw	r22, r10
    3c00:	c7 01       	movw	r24, r14
    3c02:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <_ZN8emstreamlsEj>
    3c06:	6a e0       	ldi	r22, 0x0A	; 10
    3c08:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3c0c:	69 e6       	ldi	r22, 0x69	; 105
    3c0e:	76 e0       	ldi	r23, 0x06	; 6
    3c10:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3c14:	11 23       	and	r17, r17
    3c16:	09 f4       	brne	.+2      	; 0x3c1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3c18:	6d c0       	rjmp	.+218    	; 0x3cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3c1a:	00 23       	and	r16, r16
    3c1c:	09 f4       	brne	.+2      	; 0x3c20 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3c1e:	6a c0       	rjmp	.+212    	; 0x3cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3c20:	6a e0       	ldi	r22, 0x0A	; 10
    3c22:	c7 01       	movw	r24, r14
    3c24:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3c28:	64 e6       	ldi	r22, 0x64	; 100
    3c2a:	76 e0       	ldi	r23, 0x06	; 6
    3c2c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    3c30:	61 c0       	rjmp	.+194    	; 0x3cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3c32:	11 23       	and	r17, r17
    3c34:	71 f0       	breq	.+28     	; 0x3c52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c36:	01 11       	cpse	r16, r1
    3c38:	0c c0       	rjmp	.+24     	; 0x3c52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3c3a:	88 81       	ld	r24, Y
    3c3c:	87 15       	cp	r24, r7
    3c3e:	49 f0       	breq	.+18     	; 0x3c52 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3c40:	6a e0       	ldi	r22, 0x0A	; 10
    3c42:	c7 01       	movw	r24, r14
    3c44:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3c48:	6f e5       	ldi	r22, 0x5F	; 95
    3c4a:	76 e0       	ldi	r23, 0x06	; 6
    3c4c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c50:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3c52:	69 91       	ld	r22, Y+
    3c54:	c7 01       	movw	r24, r14
    3c56:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c5a:	dc 01       	movw	r26, r24
    3c5c:	ed 91       	ld	r30, X+
    3c5e:	fc 91       	ld	r31, X
    3c60:	02 80       	ldd	r0, Z+2	; 0x02
    3c62:	f3 81       	ldd	r31, Z+3	; 0x03
    3c64:	e0 2d       	mov	r30, r0
    3c66:	60 e2       	ldi	r22, 0x20	; 32
    3c68:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3c6a:	cc 16       	cp	r12, r28
    3c6c:	dd 06       	cpc	r13, r29
    3c6e:	09 f7       	brne	.-62     	; 0x3c32 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3c70:	11 23       	and	r17, r17
    3c72:	89 f0       	breq	.+34     	; 0x3c96 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3c74:	6a e0       	ldi	r22, 0x0A	; 10
    3c76:	c7 01       	movw	r24, r14
    3c78:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3c7c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c7e:	69 e5       	ldi	r22, 0x59	; 89
    3c80:	76 e0       	ldi	r23, 0x06	; 6
    3c82:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3c86:	e8 81       	ld	r30, Y
    3c88:	f9 81       	ldd	r31, Y+1	; 0x01
    3c8a:	02 80       	ldd	r0, Z+2	; 0x02
    3c8c:	f3 81       	ldd	r31, Z+3	; 0x03
    3c8e:	e0 2d       	mov	r30, r0
    3c90:	60 e2       	ldi	r22, 0x20	; 32
    3c92:	ce 01       	movw	r24, r28
    3c94:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3c96:	c6 2d       	mov	r28, r6
    3c98:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3c9a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3c9c:	80 ee       	ldi	r24, 0xE0	; 224
    3c9e:	86 0f       	add	r24, r22
    3ca0:	8f 35       	cpi	r24, 0x5F	; 95
    3ca2:	48 f4       	brcc	.+18     	; 0x3cb6 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3ca4:	d7 01       	movw	r26, r14
    3ca6:	ed 91       	ld	r30, X+
    3ca8:	fc 91       	ld	r31, X
    3caa:	02 80       	ldd	r0, Z+2	; 0x02
    3cac:	f3 81       	ldd	r31, Z+3	; 0x03
    3cae:	e0 2d       	mov	r30, r0
    3cb0:	c7 01       	movw	r24, r14
    3cb2:	19 95       	eicall
    3cb4:	09 c0       	rjmp	.+18     	; 0x3cc8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3cb6:	d7 01       	movw	r26, r14
    3cb8:	ed 91       	ld	r30, X+
    3cba:	fc 91       	ld	r31, X
    3cbc:	02 80       	ldd	r0, Z+2	; 0x02
    3cbe:	f3 81       	ldd	r31, Z+3	; 0x03
    3cc0:	e0 2d       	mov	r30, r0
    3cc2:	6e e2       	ldi	r22, 0x2E	; 46
    3cc4:	c7 01       	movw	r24, r14
    3cc6:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3cc8:	cc 16       	cp	r12, r28
    3cca:	dd 06       	cpc	r13, r29
    3ccc:	31 f7       	brne	.-52     	; 0x3c9a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3cce:	b4 e1       	ldi	r27, 0x14	; 20
    3cd0:	ab 0e       	add	r10, r27
    3cd2:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3cd4:	66 e0       	ldi	r22, 0x06	; 6
    3cd6:	c7 01       	movw	r24, r14
    3cd8:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    3cdc:	84 e1       	ldi	r24, 0x14	; 20
    3cde:	c8 0e       	add	r12, r24
    3ce0:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3ce2:	a8 14       	cp	r10, r8
    3ce4:	b9 04       	cpc	r11, r9
    3ce6:	08 f4       	brcc	.+2      	; 0x3cea <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3ce8:	88 cf       	rjmp	.-240    	; 0x3bfa <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3cea:	62 e0       	ldi	r22, 0x02	; 2
    3cec:	c7 01       	movw	r24, r14
    3cee:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
}
    3cf2:	03 c0       	rjmp	.+6      	; 0x3cfa <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3cf4:	c6 2d       	mov	r28, r6
    3cf6:	d5 2d       	mov	r29, r5
    3cf8:	9c cf       	rjmp	.-200    	; 0x3c32 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3cfa:	df 91       	pop	r29
    3cfc:	cf 91       	pop	r28
    3cfe:	1f 91       	pop	r17
    3d00:	0f 91       	pop	r16
    3d02:	ff 90       	pop	r15
    3d04:	ef 90       	pop	r14
    3d06:	df 90       	pop	r13
    3d08:	cf 90       	pop	r12
    3d0a:	bf 90       	pop	r11
    3d0c:	af 90       	pop	r10
    3d0e:	9f 90       	pop	r9
    3d10:	8f 90       	pop	r8
    3d12:	7f 90       	pop	r7
    3d14:	6f 90       	pop	r6
    3d16:	5f 90       	pop	r5
    3d18:	08 95       	ret

00003d1a <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3d1a:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    3d1e:	08 95       	ret

00003d20 <_Znaj>:
    3d20:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <pvPortMalloc>
    3d24:	08 95       	ret

00003d26 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3d26:	08 95       	ret

00003d28 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3d28:	cf 93       	push	r28
    3d2a:	df 93       	push	r29
    3d2c:	fc 01       	movw	r30, r24
    3d2e:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3d30:	40 3a       	cpi	r20, 0xA0	; 160
    3d32:	68 e0       	ldi	r22, 0x08	; 8
    3d34:	56 07       	cpc	r21, r22
    3d36:	49 f4       	brne	.+18     	; 0x3d4a <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3d38:	80 e4       	ldi	r24, 0x40	; 64
    3d3a:	96 e0       	ldi	r25, 0x06	; 6
    3d3c:	82 83       	std	Z+2, r24	; 0x02
    3d3e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d40:	82 e0       	ldi	r24, 0x02	; 2
    3d42:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d44:	83 e0       	ldi	r24, 0x03	; 3
    3d46:	85 83       	std	Z+5, r24	; 0x05
    3d48:	32 c0       	rjmp	.+100    	; 0x3dae <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3d4a:	40 3b       	cpi	r20, 0xB0	; 176
    3d4c:	78 e0       	ldi	r23, 0x08	; 8
    3d4e:	57 07       	cpc	r21, r23
    3d50:	49 f4       	brne	.+18     	; 0x3d64 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3d52:	80 e4       	ldi	r24, 0x40	; 64
    3d54:	96 e0       	ldi	r25, 0x06	; 6
    3d56:	82 83       	std	Z+2, r24	; 0x02
    3d58:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d5a:	86 e0       	ldi	r24, 0x06	; 6
    3d5c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d5e:	87 e0       	ldi	r24, 0x07	; 7
    3d60:	85 83       	std	Z+5, r24	; 0x05
    3d62:	25 c0       	rjmp	.+74     	; 0x3dae <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3d64:	40 3a       	cpi	r20, 0xA0	; 160
    3d66:	89 e0       	ldi	r24, 0x09	; 9
    3d68:	58 07       	cpc	r21, r24
    3d6a:	49 f4       	brne	.+18     	; 0x3d7e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3d6c:	80 e6       	ldi	r24, 0x60	; 96
    3d6e:	96 e0       	ldi	r25, 0x06	; 6
    3d70:	82 83       	std	Z+2, r24	; 0x02
    3d72:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3d74:	82 e0       	ldi	r24, 0x02	; 2
    3d76:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3d78:	83 e0       	ldi	r24, 0x03	; 3
    3d7a:	85 83       	std	Z+5, r24	; 0x05
    3d7c:	18 c0       	rjmp	.+48     	; 0x3dae <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3d7e:	40 3b       	cpi	r20, 0xB0	; 176
    3d80:	69 e0       	ldi	r22, 0x09	; 9
    3d82:	56 07       	cpc	r21, r22
    3d84:	49 f4       	brne	.+18     	; 0x3d98 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3d86:	80 e6       	ldi	r24, 0x60	; 96
    3d88:	96 e0       	ldi	r25, 0x06	; 6
    3d8a:	82 83       	std	Z+2, r24	; 0x02
    3d8c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3d8e:	86 e0       	ldi	r24, 0x06	; 6
    3d90:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3d92:	87 e0       	ldi	r24, 0x07	; 7
    3d94:	85 83       	std	Z+5, r24	; 0x05
    3d96:	0b c0       	rjmp	.+22     	; 0x3dae <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3d98:	40 3a       	cpi	r20, 0xA0	; 160
    3d9a:	5a 40       	sbci	r21, 0x0A	; 10
    3d9c:	41 f4       	brne	.+16     	; 0x3dae <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3d9e:	80 e8       	ldi	r24, 0x80	; 128
    3da0:	96 e0       	ldi	r25, 0x06	; 6
    3da2:	82 83       	std	Z+2, r24	; 0x02
    3da4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3da6:	82 e0       	ldi	r24, 0x02	; 2
    3da8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3daa:	83 e0       	ldi	r24, 0x03	; 3
    3dac:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3dae:	a6 83       	std	Z+6, r26	; 0x06
    3db0:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3db2:	cd 01       	movw	r24, r26
    3db4:	01 96       	adiw	r24, 0x01	; 1
    3db6:	80 87       	std	Z+8, r24	; 0x08
    3db8:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3dba:	03 96       	adiw	r24, 0x03	; 3
    3dbc:	82 87       	std	Z+10, r24	; 0x0a
    3dbe:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3dc0:	25 81       	ldd	r18, Z+5	; 0x05
    3dc2:	c2 81       	ldd	r28, Z+2	; 0x02
    3dc4:	d3 81       	ldd	r29, Z+3	; 0x03
    3dc6:	4c 81       	ldd	r20, Y+4	; 0x04
    3dc8:	81 e0       	ldi	r24, 0x01	; 1
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	bc 01       	movw	r22, r24
    3dce:	02 c0       	rjmp	.+4      	; 0x3dd4 <_ZN7base232C1EjP12USART_struct+0xac>
    3dd0:	66 0f       	add	r22, r22
    3dd2:	77 1f       	adc	r23, r23
    3dd4:	2a 95       	dec	r18
    3dd6:	e2 f7       	brpl	.-8      	; 0x3dd0 <_ZN7base232C1EjP12USART_struct+0xa8>
    3dd8:	9b 01       	movw	r18, r22
    3dda:	24 2b       	or	r18, r20
    3ddc:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3dde:	25 81       	ldd	r18, Z+5	; 0x05
    3de0:	c2 81       	ldd	r28, Z+2	; 0x02
    3de2:	d3 81       	ldd	r29, Z+3	; 0x03
    3de4:	48 81       	ld	r20, Y
    3de6:	bc 01       	movw	r22, r24
    3de8:	02 c0       	rjmp	.+4      	; 0x3dee <_ZN7base232C1EjP12USART_struct+0xc6>
    3dea:	66 0f       	add	r22, r22
    3dec:	77 1f       	adc	r23, r23
    3dee:	2a 95       	dec	r18
    3df0:	e2 f7       	brpl	.-8      	; 0x3dea <_ZN7base232C1EjP12USART_struct+0xc2>
    3df2:	9b 01       	movw	r18, r22
    3df4:	24 2b       	or	r18, r20
    3df6:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3df8:	34 81       	ldd	r19, Z+4	; 0x04
    3dfa:	c2 81       	ldd	r28, Z+2	; 0x02
    3dfc:	d3 81       	ldd	r29, Z+3	; 0x03
    3dfe:	28 81       	ld	r18, Y
    3e00:	02 c0       	rjmp	.+4      	; 0x3e06 <_ZN7base232C1EjP12USART_struct+0xde>
    3e02:	88 0f       	add	r24, r24
    3e04:	99 1f       	adc	r25, r25
    3e06:	3a 95       	dec	r19
    3e08:	e2 f7       	brpl	.-8      	; 0x3e02 <_ZN7base232C1EjP12USART_struct+0xda>
    3e0a:	80 95       	com	r24
    3e0c:	90 95       	com	r25
    3e0e:	82 23       	and	r24, r18
    3e10:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3e12:	80 e1       	ldi	r24, 0x10	; 16
    3e14:	13 96       	adiw	r26, 0x03	; 3
    3e16:	8c 93       	st	X, r24
    3e18:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3e1a:	83 e0       	ldi	r24, 0x03	; 3
    3e1c:	15 96       	adiw	r26, 0x05	; 5
    3e1e:	8c 93       	st	X, r24
    3e20:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3e22:	80 ef       	ldi	r24, 0xF0	; 240
    3e24:	17 96       	adiw	r26, 0x07	; 7
    3e26:	8c 93       	st	X, r24
    3e28:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3e2a:	81 e2       	ldi	r24, 0x21	; 33
    3e2c:	16 96       	adiw	r26, 0x06	; 6
    3e2e:	8c 93       	st	X, r24
    3e30:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3e32:	88 e1       	ldi	r24, 0x18	; 24
    3e34:	14 96       	adiw	r26, 0x04	; 4
    3e36:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3e38:	80 e8       	ldi	r24, 0x80	; 128
    3e3a:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3e3c:	80 e4       	ldi	r24, 0x40	; 64
    3e3e:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3e40:	80 e2       	ldi	r24, 0x20	; 32
    3e42:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3e44:	06 80       	ldd	r0, Z+6	; 0x06
    3e46:	f7 81       	ldd	r31, Z+7	; 0x07
    3e48:	e0 2d       	mov	r30, r0
    3e4a:	80 81       	ld	r24, Z
    3e4c:	80 81       	ld	r24, Z
}
    3e4e:	df 91       	pop	r29
    3e50:	cf 91       	pop	r28
    3e52:	08 95       	ret

00003e54 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3e54:	81 e0       	ldi	r24, 0x01	; 1
    3e56:	08 95       	ret

00003e58 <_ZN8emstream7getcharEv>:
    3e58:	80 e0       	ldi	r24, 0x00	; 0
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	08 95       	ret

00003e5e <_ZN8emstream14check_for_charEv>:
    3e5e:	80 e0       	ldi	r24, 0x00	; 0
    3e60:	08 95       	ret

00003e62 <_ZN8emstream12transmit_nowEv>:
    3e62:	08 95       	ret

00003e64 <_ZN8emstream12clear_screenEv>:
    3e64:	08 95       	ret

00003e66 <_ZN8emstreamC1Ev>:
    3e66:	fc 01       	movw	r30, r24
    3e68:	84 ea       	ldi	r24, 0xA4	; 164
    3e6a:	91 e2       	ldi	r25, 0x21	; 33
    3e6c:	80 83       	st	Z, r24
    3e6e:	91 83       	std	Z+1, r25	; 0x01
    3e70:	8a e0       	ldi	r24, 0x0A	; 10
    3e72:	82 83       	std	Z+2, r24	; 0x02
    3e74:	13 82       	std	Z+3, r1	; 0x03
    3e76:	83 e0       	ldi	r24, 0x03	; 3
    3e78:	85 83       	std	Z+5, r24	; 0x05
    3e7a:	14 82       	std	Z+4, r1	; 0x04
    3e7c:	16 82       	std	Z+6, r1	; 0x06
    3e7e:	17 82       	std	Z+7, r1	; 0x07
    3e80:	08 95       	ret

00003e82 <_ZN8emstream4putsEPKc>:
    3e82:	0f 93       	push	r16
    3e84:	1f 93       	push	r17
    3e86:	cf 93       	push	r28
    3e88:	df 93       	push	r29
    3e8a:	8c 01       	movw	r16, r24
    3e8c:	fb 01       	movw	r30, r22
    3e8e:	dc 01       	movw	r26, r24
    3e90:	14 96       	adiw	r26, 0x04	; 4
    3e92:	8c 91       	ld	r24, X
    3e94:	81 11       	cpse	r24, r1
    3e96:	04 c0       	rjmp	.+8      	; 0x3ea0 <_ZN8emstream4putsEPKc+0x1e>
    3e98:	60 81       	ld	r22, Z
    3e9a:	61 11       	cpse	r22, r1
    3e9c:	17 c0       	rjmp	.+46     	; 0x3ecc <_ZN8emstream4putsEPKc+0x4a>
    3e9e:	23 c0       	rjmp	.+70     	; 0x3ee6 <_ZN8emstream4putsEPKc+0x64>
    3ea0:	d8 01       	movw	r26, r16
    3ea2:	14 96       	adiw	r26, 0x04	; 4
    3ea4:	1c 92       	st	X, r1
    3ea6:	eb 01       	movw	r28, r22
    3ea8:	21 96       	adiw	r28, 0x01	; 1
    3eaa:	64 91       	lpm	r22, Z
    3eac:	66 23       	and	r22, r22
    3eae:	d9 f0       	breq	.+54     	; 0x3ee6 <_ZN8emstream4putsEPKc+0x64>
    3eb0:	d8 01       	movw	r26, r16
    3eb2:	ed 91       	ld	r30, X+
    3eb4:	fc 91       	ld	r31, X
    3eb6:	02 80       	ldd	r0, Z+2	; 0x02
    3eb8:	f3 81       	ldd	r31, Z+3	; 0x03
    3eba:	e0 2d       	mov	r30, r0
    3ebc:	c8 01       	movw	r24, r16
    3ebe:	19 95       	eicall
    3ec0:	fe 01       	movw	r30, r28
    3ec2:	64 91       	lpm	r22, Z
    3ec4:	21 96       	adiw	r28, 0x01	; 1
    3ec6:	61 11       	cpse	r22, r1
    3ec8:	f3 cf       	rjmp	.-26     	; 0x3eb0 <_ZN8emstream4putsEPKc+0x2e>
    3eca:	0d c0       	rjmp	.+26     	; 0x3ee6 <_ZN8emstream4putsEPKc+0x64>
    3ecc:	ef 01       	movw	r28, r30
    3ece:	21 96       	adiw	r28, 0x01	; 1
    3ed0:	d8 01       	movw	r26, r16
    3ed2:	ed 91       	ld	r30, X+
    3ed4:	fc 91       	ld	r31, X
    3ed6:	02 80       	ldd	r0, Z+2	; 0x02
    3ed8:	f3 81       	ldd	r31, Z+3	; 0x03
    3eda:	e0 2d       	mov	r30, r0
    3edc:	c8 01       	movw	r24, r16
    3ede:	19 95       	eicall
    3ee0:	69 91       	ld	r22, Y+
    3ee2:	61 11       	cpse	r22, r1
    3ee4:	f5 cf       	rjmp	.-22     	; 0x3ed0 <_ZN8emstream4putsEPKc+0x4e>
    3ee6:	df 91       	pop	r29
    3ee8:	cf 91       	pop	r28
    3eea:	1f 91       	pop	r17
    3eec:	0f 91       	pop	r16
    3eee:	08 95       	ret

00003ef0 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3ef0:	cf 93       	push	r28
    3ef2:	df 93       	push	r29
    3ef4:	ec 01       	movw	r28, r24
	switch (new_manip)
    3ef6:	86 2f       	mov	r24, r22
    3ef8:	90 e0       	ldi	r25, 0x00	; 0
    3efa:	8b 30       	cpi	r24, 0x0B	; 11
    3efc:	91 05       	cpc	r25, r1
    3efe:	d8 f5       	brcc	.+118    	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
    3f00:	fc 01       	movw	r30, r24
    3f02:	88 27       	eor	r24, r24
    3f04:	e2 50       	subi	r30, 0x02	; 2
    3f06:	ff 4f       	sbci	r31, 0xFF	; 255
    3f08:	8f 4f       	sbci	r24, 0xFF	; 255
    3f0a:	0c 94 e8 26 	jmp	0x4dd0	; 0x4dd0 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3f0e:	82 e0       	ldi	r24, 0x02	; 2
    3f10:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f12:	31 c0       	rjmp	.+98     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3f14:	88 e0       	ldi	r24, 0x08	; 8
    3f16:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f18:	2e c0       	rjmp	.+92     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3f1a:	8a e0       	ldi	r24, 0x0A	; 10
    3f1c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f1e:	2b c0       	rjmp	.+86     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3f20:	80 e1       	ldi	r24, 0x10	; 16
    3f22:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3f24:	28 c0       	rjmp	.+80     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3f26:	81 e0       	ldi	r24, 0x01	; 1
    3f28:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3f2a:	25 c0       	rjmp	.+74     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3f2c:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3f2e:	23 c0       	rjmp	.+70     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3f30:	e8 81       	ld	r30, Y
    3f32:	f9 81       	ldd	r31, Y+1	; 0x01
    3f34:	02 80       	ldd	r0, Z+2	; 0x02
    3f36:	f3 81       	ldd	r31, Z+3	; 0x03
    3f38:	e0 2d       	mov	r30, r0
    3f3a:	6d e0       	ldi	r22, 0x0D	; 13
    3f3c:	ce 01       	movw	r24, r28
    3f3e:	19 95       	eicall
    3f40:	e8 81       	ld	r30, Y
    3f42:	f9 81       	ldd	r31, Y+1	; 0x01
    3f44:	02 80       	ldd	r0, Z+2	; 0x02
    3f46:	f3 81       	ldd	r31, Z+3	; 0x03
    3f48:	e0 2d       	mov	r30, r0
    3f4a:	6a e0       	ldi	r22, 0x0A	; 10
    3f4c:	ce 01       	movw	r24, r28
    3f4e:	19 95       	eicall
			break;
    3f50:	12 c0       	rjmp	.+36     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3f52:	e8 81       	ld	r30, Y
    3f54:	f9 81       	ldd	r31, Y+1	; 0x01
    3f56:	02 84       	ldd	r0, Z+10	; 0x0a
    3f58:	f3 85       	ldd	r31, Z+11	; 0x0b
    3f5a:	e0 2d       	mov	r30, r0
    3f5c:	ce 01       	movw	r24, r28
    3f5e:	19 95       	eicall
			break;
    3f60:	0a c0       	rjmp	.+20     	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3f62:	e8 81       	ld	r30, Y
    3f64:	f9 81       	ldd	r31, Y+1	; 0x01
    3f66:	00 84       	ldd	r0, Z+8	; 0x08
    3f68:	f1 85       	ldd	r31, Z+9	; 0x09
    3f6a:	e0 2d       	mov	r30, r0
    3f6c:	ce 01       	movw	r24, r28
    3f6e:	19 95       	eicall
			break;
    3f70:	02 c0       	rjmp	.+4      	; 0x3f76 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3f72:	81 e0       	ldi	r24, 0x01	; 1
    3f74:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3f76:	ce 01       	movw	r24, r28
    3f78:	df 91       	pop	r29
    3f7a:	cf 91       	pop	r28
    3f7c:	08 95       	ret

00003f7e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3f7e:	ff 92       	push	r15
    3f80:	0f 93       	push	r16
    3f82:	1f 93       	push	r17
    3f84:	cf 93       	push	r28
    3f86:	df 93       	push	r29
    3f88:	cd b7       	in	r28, 0x3d	; 61
    3f8a:	de b7       	in	r29, 0x3e	; 62
    3f8c:	61 97       	sbiw	r28, 0x11	; 17
    3f8e:	cd bf       	out	0x3d, r28	; 61
    3f90:	de bf       	out	0x3e, r29	; 62
    3f92:	8c 01       	movw	r16, r24
    3f94:	f6 2e       	mov	r15, r22
    3f96:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3f98:	f8 01       	movw	r30, r16
    3f9a:	42 81       	ldd	r20, Z+2	; 0x02
    3f9c:	40 31       	cpi	r20, 0x10	; 16
    3f9e:	21 f0       	breq	.+8      	; 0x3fa8 <_ZN8emstreamlsEj+0x2a>
    3fa0:	48 30       	cpi	r20, 0x08	; 8
    3fa2:	11 f0       	breq	.+4      	; 0x3fa8 <_ZN8emstreamlsEj+0x2a>
    3fa4:	42 30       	cpi	r20, 0x02	; 2
    3fa6:	41 f4       	brne	.+16     	; 0x3fb8 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3fa8:	69 2f       	mov	r22, r25
    3faa:	c8 01       	movw	r24, r16
    3fac:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    3fb0:	6f 2d       	mov	r22, r15
    3fb2:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    3fb6:	0d c0       	rjmp	.+26     	; 0x3fd2 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3fb8:	50 e0       	ldi	r21, 0x00	; 0
    3fba:	be 01       	movw	r22, r28
    3fbc:	6f 5f       	subi	r22, 0xFF	; 255
    3fbe:	7f 4f       	sbci	r23, 0xFF	; 255
    3fc0:	8f 2d       	mov	r24, r15
    3fc2:	0e 94 57 27 	call	0x4eae	; 0x4eae <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3fc6:	be 01       	movw	r22, r28
    3fc8:	6f 5f       	subi	r22, 0xFF	; 255
    3fca:	7f 4f       	sbci	r23, 0xFF	; 255
    3fcc:	c8 01       	movw	r24, r16
    3fce:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3fd2:	c8 01       	movw	r24, r16
    3fd4:	61 96       	adiw	r28, 0x11	; 17
    3fd6:	cd bf       	out	0x3d, r28	; 61
    3fd8:	de bf       	out	0x3e, r29	; 62
    3fda:	df 91       	pop	r29
    3fdc:	cf 91       	pop	r28
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	ff 90       	pop	r15
    3fe4:	08 95       	ret

00003fe6 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3fe6:	df 92       	push	r13
    3fe8:	ef 92       	push	r14
    3fea:	ff 92       	push	r15
    3fec:	0f 93       	push	r16
    3fee:	1f 93       	push	r17
    3ff0:	cf 93       	push	r28
    3ff2:	df 93       	push	r29
    3ff4:	cd b7       	in	r28, 0x3d	; 61
    3ff6:	de b7       	in	r29, 0x3e	; 62
    3ff8:	a1 97       	sbiw	r28, 0x21	; 33
    3ffa:	cd bf       	out	0x3d, r28	; 61
    3ffc:	de bf       	out	0x3e, r29	; 62
    3ffe:	8c 01       	movw	r16, r24
    4000:	d4 2e       	mov	r13, r20
    4002:	e5 2e       	mov	r14, r21
    4004:	f6 2e       	mov	r15, r22
    4006:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    4008:	f8 01       	movw	r30, r16
    400a:	22 81       	ldd	r18, Z+2	; 0x02
    400c:	20 31       	cpi	r18, 0x10	; 16
    400e:	21 f0       	breq	.+8      	; 0x4018 <__stack+0x19>
    4010:	28 30       	cpi	r18, 0x08	; 8
    4012:	11 f0       	breq	.+4      	; 0x4018 <__stack+0x19>
    4014:	22 30       	cpi	r18, 0x02	; 2
    4016:	71 f4       	brne	.+28     	; 0x4034 <__stack+0x35>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    4018:	69 2f       	mov	r22, r25
    401a:	c8 01       	movw	r24, r16
    401c:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    4020:	6f 2d       	mov	r22, r15
    4022:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    4026:	6e 2d       	mov	r22, r14
    4028:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    402c:	6d 2d       	mov	r22, r13
    402e:	0e 94 35 20 	call	0x406a	; 0x406a <_ZN8emstreamlsEh>
    4032:	0f c0       	rjmp	.+30     	; 0x4052 <__stack+0x53>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    4034:	30 e0       	ldi	r19, 0x00	; 0
    4036:	ae 01       	movw	r20, r28
    4038:	4f 5f       	subi	r20, 0xFF	; 255
    403a:	5f 4f       	sbci	r21, 0xFF	; 255
    403c:	6d 2d       	mov	r22, r13
    403e:	7e 2d       	mov	r23, r14
    4040:	8f 2d       	mov	r24, r15
    4042:	0e 94 2a 27 	call	0x4e54	; 0x4e54 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    4046:	be 01       	movw	r22, r28
    4048:	6f 5f       	subi	r22, 0xFF	; 255
    404a:	7f 4f       	sbci	r23, 0xFF	; 255
    404c:	c8 01       	movw	r24, r16
    404e:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    4052:	c8 01       	movw	r24, r16
    4054:	a1 96       	adiw	r28, 0x21	; 33
    4056:	cd bf       	out	0x3d, r28	; 61
    4058:	de bf       	out	0x3e, r29	; 62
    405a:	df 91       	pop	r29
    405c:	cf 91       	pop	r28
    405e:	1f 91       	pop	r17
    4060:	0f 91       	pop	r16
    4062:	ff 90       	pop	r15
    4064:	ef 90       	pop	r14
    4066:	df 90       	pop	r13
    4068:	08 95       	ret

0000406a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    406a:	cf 92       	push	r12
    406c:	df 92       	push	r13
    406e:	ef 92       	push	r14
    4070:	ff 92       	push	r15
    4072:	0f 93       	push	r16
    4074:	1f 93       	push	r17
    4076:	cf 93       	push	r28
    4078:	df 93       	push	r29
    407a:	cd b7       	in	r28, 0x3d	; 61
    407c:	de b7       	in	r29, 0x3e	; 62
    407e:	29 97       	sbiw	r28, 0x09	; 9
    4080:	cd bf       	out	0x3d, r28	; 61
    4082:	de bf       	out	0x3e, r29	; 62
    4084:	8c 01       	movw	r16, r24
    4086:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    4088:	dc 01       	movw	r26, r24
    408a:	13 96       	adiw	r26, 0x03	; 3
    408c:	8c 91       	ld	r24, X
    408e:	13 97       	sbiw	r26, 0x03	; 3
    4090:	88 23       	and	r24, r24
    4092:	41 f0       	breq	.+16     	; 0x40a4 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    4094:	ed 91       	ld	r30, X+
    4096:	fc 91       	ld	r31, X
    4098:	02 80       	ldd	r0, Z+2	; 0x02
    409a:	f3 81       	ldd	r31, Z+3	; 0x03
    409c:	e0 2d       	mov	r30, r0
    409e:	c8 01       	movw	r24, r16
    40a0:	19 95       	eicall
    40a2:	56 c0       	rjmp	.+172    	; 0x4150 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    40a4:	f8 01       	movw	r30, r16
    40a6:	42 81       	ldd	r20, Z+2	; 0x02
    40a8:	42 30       	cpi	r20, 0x02	; 2
    40aa:	19 f5       	brne	.+70     	; 0x40f2 <_ZN8emstreamlsEh+0x88>
    40ac:	68 94       	set
    40ae:	cc 24       	eor	r12, r12
    40b0:	c3 f8       	bld	r12, 3
    40b2:	d1 2c       	mov	r13, r1
    40b4:	68 94       	set
    40b6:	ff 24       	eor	r15, r15
    40b8:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    40ba:	8e 2d       	mov	r24, r14
    40bc:	8f 21       	and	r24, r15
    40be:	51 f0       	breq	.+20     	; 0x40d4 <_ZN8emstreamlsEh+0x6a>
    40c0:	d8 01       	movw	r26, r16
    40c2:	ed 91       	ld	r30, X+
    40c4:	fc 91       	ld	r31, X
    40c6:	02 80       	ldd	r0, Z+2	; 0x02
    40c8:	f3 81       	ldd	r31, Z+3	; 0x03
    40ca:	e0 2d       	mov	r30, r0
    40cc:	61 e3       	ldi	r22, 0x31	; 49
    40ce:	c8 01       	movw	r24, r16
    40d0:	19 95       	eicall
    40d2:	09 c0       	rjmp	.+18     	; 0x40e6 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    40d4:	d8 01       	movw	r26, r16
    40d6:	ed 91       	ld	r30, X+
    40d8:	fc 91       	ld	r31, X
    40da:	02 80       	ldd	r0, Z+2	; 0x02
    40dc:	f3 81       	ldd	r31, Z+3	; 0x03
    40de:	e0 2d       	mov	r30, r0
    40e0:	60 e3       	ldi	r22, 0x30	; 48
    40e2:	c8 01       	movw	r24, r16
    40e4:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    40e6:	f6 94       	lsr	r15
    40e8:	b1 e0       	ldi	r27, 0x01	; 1
    40ea:	cb 1a       	sub	r12, r27
    40ec:	d1 08       	sbc	r13, r1
    40ee:	29 f7       	brne	.-54     	; 0x40ba <_ZN8emstreamlsEh+0x50>
    40f0:	2f c0       	rjmp	.+94     	; 0x4150 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    40f2:	40 31       	cpi	r20, 0x10	; 16
    40f4:	f9 f4       	brne	.+62     	; 0x4134 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    40f6:	62 95       	swap	r22
    40f8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    40fa:	01 90       	ld	r0, Z+
    40fc:	f0 81       	ld	r31, Z
    40fe:	e0 2d       	mov	r30, r0
    4100:	02 80       	ldd	r0, Z+2	; 0x02
    4102:	f3 81       	ldd	r31, Z+3	; 0x03
    4104:	e0 2d       	mov	r30, r0
    4106:	6a 30       	cpi	r22, 0x0A	; 10
    4108:	10 f0       	brcs	.+4      	; 0x410e <_ZN8emstreamlsEh+0xa4>
    410a:	69 5c       	subi	r22, 0xC9	; 201
    410c:	01 c0       	rjmp	.+2      	; 0x4110 <_ZN8emstreamlsEh+0xa6>
    410e:	60 5d       	subi	r22, 0xD0	; 208
    4110:	c8 01       	movw	r24, r16
    4112:	19 95       	eicall
		temp_char = num & 0x0F;
    4114:	6e 2d       	mov	r22, r14
    4116:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    4118:	d8 01       	movw	r26, r16
    411a:	ed 91       	ld	r30, X+
    411c:	fc 91       	ld	r31, X
    411e:	02 80       	ldd	r0, Z+2	; 0x02
    4120:	f3 81       	ldd	r31, Z+3	; 0x03
    4122:	e0 2d       	mov	r30, r0
    4124:	6a 30       	cpi	r22, 0x0A	; 10
    4126:	10 f0       	brcs	.+4      	; 0x412c <_ZN8emstreamlsEh+0xc2>
    4128:	69 5c       	subi	r22, 0xC9	; 201
    412a:	01 c0       	rjmp	.+2      	; 0x412e <_ZN8emstreamlsEh+0xc4>
    412c:	60 5d       	subi	r22, 0xD0	; 208
    412e:	c8 01       	movw	r24, r16
    4130:	19 95       	eicall
    4132:	0e c0       	rjmp	.+28     	; 0x4150 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4134:	50 e0       	ldi	r21, 0x00	; 0
    4136:	be 01       	movw	r22, r28
    4138:	6f 5f       	subi	r22, 0xFF	; 255
    413a:	7f 4f       	sbci	r23, 0xFF	; 255
    413c:	8e 2d       	mov	r24, r14
    413e:	90 e0       	ldi	r25, 0x00	; 0
    4140:	0e 94 57 27 	call	0x4eae	; 0x4eae <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    4144:	be 01       	movw	r22, r28
    4146:	6f 5f       	subi	r22, 0xFF	; 255
    4148:	7f 4f       	sbci	r23, 0xFF	; 255
    414a:	c8 01       	movw	r24, r16
    414c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    4150:	c8 01       	movw	r24, r16
    4152:	29 96       	adiw	r28, 0x09	; 9
    4154:	cd bf       	out	0x3d, r28	; 61
    4156:	de bf       	out	0x3e, r29	; 62
    4158:	df 91       	pop	r29
    415a:	cf 91       	pop	r28
    415c:	1f 91       	pop	r17
    415e:	0f 91       	pop	r16
    4160:	ff 90       	pop	r15
    4162:	ef 90       	pop	r14
    4164:	df 90       	pop	r13
    4166:	cf 90       	pop	r12
    4168:	08 95       	ret

0000416a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    416a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    416c:	50 96       	adiw	r26, 0x10	; 16
    416e:	ed 91       	ld	r30, X+
    4170:	fc 91       	ld	r31, X
    4172:	51 97       	sbiw	r26, 0x11	; 17
    4174:	80 81       	ld	r24, Z
    4176:	54 96       	adiw	r26, 0x14	; 20
    4178:	4c 91       	ld	r20, X
    417a:	54 97       	sbiw	r26, 0x14	; 20
    417c:	84 23       	and	r24, r20
    417e:	29 f0       	breq	.+10     	; 0x418a <_ZN5rs2327putcharEc+0x20>
    4180:	09 c0       	rjmp	.+18     	; 0x4194 <_ZN5rs2327putcharEc+0x2a>
    4182:	21 50       	subi	r18, 0x01	; 1
    4184:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4186:	19 f4       	brne	.+6      	; 0x418e <_ZN5rs2327putcharEc+0x24>
    4188:	12 c0       	rjmp	.+36     	; 0x41ae <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    418a:	21 e2       	ldi	r18, 0x21	; 33
    418c:	3e e4       	ldi	r19, 0x4E	; 78
    418e:	90 81       	ld	r25, Z
    4190:	94 23       	and	r25, r20
    4192:	b9 f3       	breq	.-18     	; 0x4182 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4194:	90 81       	ld	r25, Z
    4196:	56 96       	adiw	r26, 0x16	; 22
    4198:	8c 91       	ld	r24, X
    419a:	56 97       	sbiw	r26, 0x16	; 22
    419c:	89 2b       	or	r24, r25
    419e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    41a0:	1e 96       	adiw	r26, 0x0e	; 14
    41a2:	ed 91       	ld	r30, X+
    41a4:	fc 91       	ld	r31, X
    41a6:	1f 97       	sbiw	r26, 0x0f	; 15
    41a8:	60 83       	st	Z, r22
	return (true);
    41aa:	81 e0       	ldi	r24, 0x01	; 1
    41ac:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    41ae:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    41b0:	08 95       	ret

000041b2 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    41b2:	cf 93       	push	r28
    41b4:	df 93       	push	r29
    41b6:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    41b8:	c1 8d       	ldd	r28, Z+25	; 0x19
    41ba:	d2 8d       	ldd	r29, Z+26	; 0x1a
    41bc:	28 81       	ld	r18, Y
    41be:	39 81       	ldd	r19, Y+1	; 0x01
    41c0:	a3 8d       	ldd	r26, Z+27	; 0x1b
    41c2:	b4 8d       	ldd	r27, Z+28	; 0x1c
    41c4:	4d 91       	ld	r20, X+
    41c6:	5c 91       	ld	r21, X
    41c8:	24 17       	cp	r18, r20
    41ca:	35 07       	cpc	r19, r21
    41cc:	e9 f3       	breq	.-6      	; 0x41c8 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    41ce:	a7 89       	ldd	r26, Z+23	; 0x17
    41d0:	b0 8d       	ldd	r27, Z+24	; 0x18
    41d2:	0d 90       	ld	r0, X+
    41d4:	bc 91       	ld	r27, X
    41d6:	a0 2d       	mov	r26, r0
    41d8:	a2 0f       	add	r26, r18
    41da:	b3 1f       	adc	r27, r19
    41dc:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    41de:	2f 5f       	subi	r18, 0xFF	; 255
    41e0:	3f 4f       	sbci	r19, 0xFF	; 255
    41e2:	28 83       	st	Y, r18
    41e4:	39 83       	std	Y+1, r19	; 0x01
    41e6:	24 36       	cpi	r18, 0x64	; 100
    41e8:	31 05       	cpc	r19, r1
    41ea:	28 f0       	brcs	.+10     	; 0x41f6 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    41ec:	01 8c       	ldd	r0, Z+25	; 0x19
    41ee:	f2 8d       	ldd	r31, Z+26	; 0x1a
    41f0:	e0 2d       	mov	r30, r0
    41f2:	10 82       	st	Z, r1
    41f4:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    41f6:	90 e0       	ldi	r25, 0x00	; 0
    41f8:	df 91       	pop	r29
    41fa:	cf 91       	pop	r28
    41fc:	08 95       	ret

000041fe <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    41fe:	cf 93       	push	r28
    4200:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    4202:	ec 01       	movw	r28, r24
    4204:	a9 8d       	ldd	r26, Y+25	; 0x19
    4206:	ba 8d       	ldd	r27, Y+26	; 0x1a
    4208:	eb 8d       	ldd	r30, Y+27	; 0x1b
    420a:	fc 8d       	ldd	r31, Y+28	; 0x1c
    420c:	81 e0       	ldi	r24, 0x01	; 1
    420e:	4d 91       	ld	r20, X+
    4210:	5c 91       	ld	r21, X
    4212:	20 81       	ld	r18, Z
    4214:	31 81       	ldd	r19, Z+1	; 0x01
    4216:	42 17       	cp	r20, r18
    4218:	53 07       	cpc	r21, r19
    421a:	09 f4       	brne	.+2      	; 0x421e <_ZN5rs23214check_for_charEv+0x20>
    421c:	80 e0       	ldi	r24, 0x00	; 0
}
    421e:	df 91       	pop	r29
    4220:	cf 91       	pop	r28
    4222:	08 95       	ret

00004224 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    4224:	dc 01       	movw	r26, r24
    4226:	ed 91       	ld	r30, X+
    4228:	fc 91       	ld	r31, X
    422a:	02 80       	ldd	r0, Z+2	; 0x02
    422c:	f3 81       	ldd	r31, Z+3	; 0x03
    422e:	e0 2d       	mov	r30, r0
    4230:	6c e0       	ldi	r22, 0x0C	; 12
    4232:	19 95       	eicall
    4234:	08 95       	ret

00004236 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    4236:	ef 92       	push	r14
    4238:	ff 92       	push	r15
    423a:	0f 93       	push	r16
    423c:	1f 93       	push	r17
    423e:	cf 93       	push	r28
    4240:	df 93       	push	r29
    4242:	ec 01       	movw	r28, r24
    4244:	7b 01       	movw	r14, r22
    4246:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    4248:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <_ZN8emstreamC1Ev>
    424c:	a8 01       	movw	r20, r16
    424e:	b7 01       	movw	r22, r14
    4250:	ce 01       	movw	r24, r28
    4252:	08 96       	adiw	r24, 0x08	; 8
    4254:	0e 94 94 1e 	call	0x3d28	; 0x3d28 <_ZN7base232C1EjP12USART_struct>
    4258:	84 eb       	ldi	r24, 0xB4	; 180
    425a:	91 e2       	ldi	r25, 0x21	; 33
    425c:	88 83       	st	Y, r24
    425e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    4260:	00 3a       	cpi	r16, 0xA0	; 160
    4262:	88 e0       	ldi	r24, 0x08	; 8
    4264:	18 07       	cpc	r17, r24
    4266:	69 f4       	brne	.+26     	; 0x4282 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4268:	8e eb       	ldi	r24, 0xBE	; 190
    426a:	92 e3       	ldi	r25, 0x32	; 50
    426c:	8f 8b       	std	Y+23, r24	; 0x17
    426e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    4270:	84 eb       	ldi	r24, 0xB4	; 180
    4272:	92 e3       	ldi	r25, 0x32	; 50
    4274:	89 8f       	std	Y+25, r24	; 0x19
    4276:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4278:	8a ea       	ldi	r24, 0xAA	; 170
    427a:	92 e3       	ldi	r25, 0x32	; 50
    427c:	8b 8f       	std	Y+27, r24	; 0x1b
    427e:	9c 8f       	std	Y+28, r25	; 0x1c
    4280:	42 c0       	rjmp	.+132    	; 0x4306 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4282:	00 3b       	cpi	r16, 0xB0	; 176
    4284:	e8 e0       	ldi	r30, 0x08	; 8
    4286:	1e 07       	cpc	r17, r30
    4288:	69 f4       	brne	.+26     	; 0x42a4 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    428a:	8c eb       	ldi	r24, 0xBC	; 188
    428c:	92 e3       	ldi	r25, 0x32	; 50
    428e:	8f 8b       	std	Y+23, r24	; 0x17
    4290:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4292:	82 eb       	ldi	r24, 0xB2	; 178
    4294:	92 e3       	ldi	r25, 0x32	; 50
    4296:	89 8f       	std	Y+25, r24	; 0x19
    4298:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    429a:	88 ea       	ldi	r24, 0xA8	; 168
    429c:	92 e3       	ldi	r25, 0x32	; 50
    429e:	8b 8f       	std	Y+27, r24	; 0x1b
    42a0:	9c 8f       	std	Y+28, r25	; 0x1c
    42a2:	31 c0       	rjmp	.+98     	; 0x4306 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    42a4:	00 3a       	cpi	r16, 0xA0	; 160
    42a6:	f9 e0       	ldi	r31, 0x09	; 9
    42a8:	1f 07       	cpc	r17, r31
    42aa:	69 f4       	brne	.+26     	; 0x42c6 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    42ac:	8a eb       	ldi	r24, 0xBA	; 186
    42ae:	92 e3       	ldi	r25, 0x32	; 50
    42b0:	8f 8b       	std	Y+23, r24	; 0x17
    42b2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    42b4:	80 eb       	ldi	r24, 0xB0	; 176
    42b6:	92 e3       	ldi	r25, 0x32	; 50
    42b8:	89 8f       	std	Y+25, r24	; 0x19
    42ba:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    42bc:	86 ea       	ldi	r24, 0xA6	; 166
    42be:	92 e3       	ldi	r25, 0x32	; 50
    42c0:	8b 8f       	std	Y+27, r24	; 0x1b
    42c2:	9c 8f       	std	Y+28, r25	; 0x1c
    42c4:	20 c0       	rjmp	.+64     	; 0x4306 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    42c6:	00 3b       	cpi	r16, 0xB0	; 176
    42c8:	89 e0       	ldi	r24, 0x09	; 9
    42ca:	18 07       	cpc	r17, r24
    42cc:	69 f4       	brne	.+26     	; 0x42e8 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    42ce:	88 eb       	ldi	r24, 0xB8	; 184
    42d0:	92 e3       	ldi	r25, 0x32	; 50
    42d2:	8f 8b       	std	Y+23, r24	; 0x17
    42d4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    42d6:	8e ea       	ldi	r24, 0xAE	; 174
    42d8:	92 e3       	ldi	r25, 0x32	; 50
    42da:	89 8f       	std	Y+25, r24	; 0x19
    42dc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    42de:	84 ea       	ldi	r24, 0xA4	; 164
    42e0:	92 e3       	ldi	r25, 0x32	; 50
    42e2:	8b 8f       	std	Y+27, r24	; 0x1b
    42e4:	9c 8f       	std	Y+28, r25	; 0x1c
    42e6:	0f c0       	rjmp	.+30     	; 0x4306 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    42e8:	00 3a       	cpi	r16, 0xA0	; 160
    42ea:	1a 40       	sbci	r17, 0x0A	; 10
    42ec:	61 f4       	brne	.+24     	; 0x4306 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    42ee:	86 eb       	ldi	r24, 0xB6	; 182
    42f0:	92 e3       	ldi	r25, 0x32	; 50
    42f2:	8f 8b       	std	Y+23, r24	; 0x17
    42f4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    42f6:	8c ea       	ldi	r24, 0xAC	; 172
    42f8:	92 e3       	ldi	r25, 0x32	; 50
    42fa:	89 8f       	std	Y+25, r24	; 0x19
    42fc:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    42fe:	82 ea       	ldi	r24, 0xA2	; 162
    4300:	92 e3       	ldi	r25, 0x32	; 50
    4302:	8b 8f       	std	Y+27, r24	; 0x1b
    4304:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    4306:	0f 89       	ldd	r16, Y+23	; 0x17
    4308:	18 8d       	ldd	r17, Y+24	; 0x18
    430a:	84 e6       	ldi	r24, 0x64	; 100
    430c:	90 e0       	ldi	r25, 0x00	; 0
    430e:	0e 94 90 1e 	call	0x3d20	; 0x3d20 <_Znaj>
    4312:	f8 01       	movw	r30, r16
    4314:	80 83       	st	Z, r24
    4316:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    4318:	e9 8d       	ldd	r30, Y+25	; 0x19
    431a:	fa 8d       	ldd	r31, Y+26	; 0x1a
    431c:	10 82       	st	Z, r1
    431e:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    4320:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4322:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4324:	10 82       	st	Z, r1
    4326:	11 82       	std	Z+1, r1	; 0x01
}
    4328:	df 91       	pop	r29
    432a:	cf 91       	pop	r28
    432c:	1f 91       	pop	r17
    432e:	0f 91       	pop	r16
    4330:	ff 90       	pop	r15
    4332:	ef 90       	pop	r14
    4334:	08 95       	ret

00004336 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    4336:	1f 92       	push	r1
    4338:	0f 92       	push	r0
    433a:	0f b6       	in	r0, 0x3f	; 63
    433c:	0f 92       	push	r0
    433e:	11 24       	eor	r1, r1
    4340:	08 b6       	in	r0, 0x38	; 56
    4342:	0f 92       	push	r0
    4344:	18 be       	out	0x38, r1	; 56
    4346:	0b b6       	in	r0, 0x3b	; 59
    4348:	0f 92       	push	r0
    434a:	1b be       	out	0x3b, r1	; 59
    434c:	2f 93       	push	r18
    434e:	3f 93       	push	r19
    4350:	8f 93       	push	r24
    4352:	9f 93       	push	r25
    4354:	ef 93       	push	r30
    4356:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    4358:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    435c:	e0 91 be 32 	lds	r30, 0x32BE	; 0x8032be <rcvC0_buffer>
    4360:	f0 91 bf 32 	lds	r31, 0x32BF	; 0x8032bf <rcvC0_buffer+0x1>
    4364:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    4368:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    436c:	e8 0f       	add	r30, r24
    436e:	f9 1f       	adc	r31, r25
    4370:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    4372:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    4376:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    437a:	01 96       	adiw	r24, 0x01	; 1
    437c:	84 36       	cpi	r24, 0x64	; 100
    437e:	91 05       	cpc	r25, r1
    4380:	60 f4       	brcc	.+24     	; 0x439a <__vector_25+0x64>
    4382:	80 93 aa 32 	sts	0x32AA, r24	; 0x8032aa <rcvC0_write_index>
    4386:	90 93 ab 32 	sts	0x32AB, r25	; 0x8032ab <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    438a:	20 91 b4 32 	lds	r18, 0x32B4	; 0x8032b4 <rcvC0_read_index>
    438e:	30 91 b5 32 	lds	r19, 0x32B5	; 0x8032b5 <rcvC0_read_index+0x1>
    4392:	82 17       	cp	r24, r18
    4394:	93 07       	cpc	r25, r19
    4396:	f1 f4       	brne	.+60     	; 0x43d4 <__vector_25+0x9e>
    4398:	0c c0       	rjmp	.+24     	; 0x43b2 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    439a:	10 92 aa 32 	sts	0x32AA, r1	; 0x8032aa <rcvC0_write_index>
    439e:	10 92 ab 32 	sts	0x32AB, r1	; 0x8032ab <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    43a2:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <rcvC0_read_index>
    43a6:	90 91 b5 32 	lds	r25, 0x32B5	; 0x8032b5 <rcvC0_read_index+0x1>
    43aa:	18 16       	cp	r1, r24
    43ac:	19 06       	cpc	r1, r25
    43ae:	91 f4       	brne	.+36     	; 0x43d4 <__vector_25+0x9e>
    43b0:	0e c0       	rjmp	.+28     	; 0x43ce <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    43b2:	01 96       	adiw	r24, 0x01	; 1
    43b4:	84 36       	cpi	r24, 0x64	; 100
    43b6:	91 05       	cpc	r25, r1
    43b8:	28 f4       	brcc	.+10     	; 0x43c4 <__vector_25+0x8e>
    43ba:	80 93 b4 32 	sts	0x32B4, r24	; 0x8032b4 <rcvC0_read_index>
    43be:	90 93 b5 32 	sts	0x32B5, r25	; 0x8032b5 <rcvC0_read_index+0x1>
    43c2:	08 c0       	rjmp	.+16     	; 0x43d4 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    43c4:	10 92 b4 32 	sts	0x32B4, r1	; 0x8032b4 <rcvC0_read_index>
    43c8:	10 92 b5 32 	sts	0x32B5, r1	; 0x8032b5 <rcvC0_read_index+0x1>
}
    43cc:	03 c0       	rjmp	.+6      	; 0x43d4 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    43ce:	81 e0       	ldi	r24, 0x01	; 1
    43d0:	90 e0       	ldi	r25, 0x00	; 0
    43d2:	f3 cf       	rjmp	.-26     	; 0x43ba <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    43d4:	ff 91       	pop	r31
    43d6:	ef 91       	pop	r30
    43d8:	9f 91       	pop	r25
    43da:	8f 91       	pop	r24
    43dc:	3f 91       	pop	r19
    43de:	2f 91       	pop	r18
    43e0:	0f 90       	pop	r0
    43e2:	0b be       	out	0x3b, r0	; 59
    43e4:	0f 90       	pop	r0
    43e6:	08 be       	out	0x38, r0	; 56
    43e8:	0f 90       	pop	r0
    43ea:	0f be       	out	0x3f, r0	; 63
    43ec:	0f 90       	pop	r0
    43ee:	1f 90       	pop	r1
    43f0:	18 95       	reti

000043f2 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    43f2:	1f 92       	push	r1
    43f4:	0f 92       	push	r0
    43f6:	0f b6       	in	r0, 0x3f	; 63
    43f8:	0f 92       	push	r0
    43fa:	11 24       	eor	r1, r1
    43fc:	08 b6       	in	r0, 0x38	; 56
    43fe:	0f 92       	push	r0
    4400:	18 be       	out	0x38, r1	; 56
    4402:	0b b6       	in	r0, 0x3b	; 59
    4404:	0f 92       	push	r0
    4406:	1b be       	out	0x3b, r1	; 59
    4408:	2f 93       	push	r18
    440a:	3f 93       	push	r19
    440c:	8f 93       	push	r24
    440e:	9f 93       	push	r25
    4410:	ef 93       	push	r30
    4412:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    4414:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    4418:	e0 91 bc 32 	lds	r30, 0x32BC	; 0x8032bc <rcvC1_buffer>
    441c:	f0 91 bd 32 	lds	r31, 0x32BD	; 0x8032bd <rcvC1_buffer+0x1>
    4420:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC1_write_index>
    4424:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC1_write_index+0x1>
    4428:	e8 0f       	add	r30, r24
    442a:	f9 1f       	adc	r31, r25
    442c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    442e:	80 91 a8 32 	lds	r24, 0x32A8	; 0x8032a8 <rcvC1_write_index>
    4432:	90 91 a9 32 	lds	r25, 0x32A9	; 0x8032a9 <rcvC1_write_index+0x1>
    4436:	01 96       	adiw	r24, 0x01	; 1
    4438:	84 36       	cpi	r24, 0x64	; 100
    443a:	91 05       	cpc	r25, r1
    443c:	60 f4       	brcc	.+24     	; 0x4456 <__vector_28+0x64>
    443e:	80 93 a8 32 	sts	0x32A8, r24	; 0x8032a8 <rcvC1_write_index>
    4442:	90 93 a9 32 	sts	0x32A9, r25	; 0x8032a9 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4446:	20 91 b2 32 	lds	r18, 0x32B2	; 0x8032b2 <rcvC1_read_index>
    444a:	30 91 b3 32 	lds	r19, 0x32B3	; 0x8032b3 <rcvC1_read_index+0x1>
    444e:	82 17       	cp	r24, r18
    4450:	93 07       	cpc	r25, r19
    4452:	f1 f4       	brne	.+60     	; 0x4490 <__vector_28+0x9e>
    4454:	0c c0       	rjmp	.+24     	; 0x446e <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4456:	10 92 a8 32 	sts	0x32A8, r1	; 0x8032a8 <rcvC1_write_index>
    445a:	10 92 a9 32 	sts	0x32A9, r1	; 0x8032a9 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    445e:	80 91 b2 32 	lds	r24, 0x32B2	; 0x8032b2 <rcvC1_read_index>
    4462:	90 91 b3 32 	lds	r25, 0x32B3	; 0x8032b3 <rcvC1_read_index+0x1>
    4466:	18 16       	cp	r1, r24
    4468:	19 06       	cpc	r1, r25
    446a:	91 f4       	brne	.+36     	; 0x4490 <__vector_28+0x9e>
    446c:	0e c0       	rjmp	.+28     	; 0x448a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    446e:	01 96       	adiw	r24, 0x01	; 1
    4470:	84 36       	cpi	r24, 0x64	; 100
    4472:	91 05       	cpc	r25, r1
    4474:	28 f4       	brcc	.+10     	; 0x4480 <__vector_28+0x8e>
    4476:	80 93 b2 32 	sts	0x32B2, r24	; 0x8032b2 <rcvC1_read_index>
    447a:	90 93 b3 32 	sts	0x32B3, r25	; 0x8032b3 <rcvC1_read_index+0x1>
    447e:	08 c0       	rjmp	.+16     	; 0x4490 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    4480:	10 92 b2 32 	sts	0x32B2, r1	; 0x8032b2 <rcvC1_read_index>
    4484:	10 92 b3 32 	sts	0x32B3, r1	; 0x8032b3 <rcvC1_read_index+0x1>
}
    4488:	03 c0       	rjmp	.+6      	; 0x4490 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    448a:	81 e0       	ldi	r24, 0x01	; 1
    448c:	90 e0       	ldi	r25, 0x00	; 0
    448e:	f3 cf       	rjmp	.-26     	; 0x4476 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    4490:	ff 91       	pop	r31
    4492:	ef 91       	pop	r30
    4494:	9f 91       	pop	r25
    4496:	8f 91       	pop	r24
    4498:	3f 91       	pop	r19
    449a:	2f 91       	pop	r18
    449c:	0f 90       	pop	r0
    449e:	0b be       	out	0x3b, r0	; 59
    44a0:	0f 90       	pop	r0
    44a2:	08 be       	out	0x38, r0	; 56
    44a4:	0f 90       	pop	r0
    44a6:	0f be       	out	0x3f, r0	; 63
    44a8:	0f 90       	pop	r0
    44aa:	1f 90       	pop	r1
    44ac:	18 95       	reti

000044ae <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    44ae:	1f 92       	push	r1
    44b0:	0f 92       	push	r0
    44b2:	0f b6       	in	r0, 0x3f	; 63
    44b4:	0f 92       	push	r0
    44b6:	11 24       	eor	r1, r1
    44b8:	08 b6       	in	r0, 0x38	; 56
    44ba:	0f 92       	push	r0
    44bc:	18 be       	out	0x38, r1	; 56
    44be:	0b b6       	in	r0, 0x3b	; 59
    44c0:	0f 92       	push	r0
    44c2:	1b be       	out	0x3b, r1	; 59
    44c4:	2f 93       	push	r18
    44c6:	3f 93       	push	r19
    44c8:	8f 93       	push	r24
    44ca:	9f 93       	push	r25
    44cc:	ef 93       	push	r30
    44ce:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    44d0:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    44d4:	e0 91 ba 32 	lds	r30, 0x32BA	; 0x8032ba <rcvD0_buffer>
    44d8:	f0 91 bb 32 	lds	r31, 0x32BB	; 0x8032bb <rcvD0_buffer+0x1>
    44dc:	80 91 aa 32 	lds	r24, 0x32AA	; 0x8032aa <rcvC0_write_index>
    44e0:	90 91 ab 32 	lds	r25, 0x32AB	; 0x8032ab <rcvC0_write_index+0x1>
    44e4:	e8 0f       	add	r30, r24
    44e6:	f9 1f       	adc	r31, r25
    44e8:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    44ea:	80 91 a6 32 	lds	r24, 0x32A6	; 0x8032a6 <rcvD0_write_index>
    44ee:	90 91 a7 32 	lds	r25, 0x32A7	; 0x8032a7 <rcvD0_write_index+0x1>
    44f2:	01 96       	adiw	r24, 0x01	; 1
    44f4:	84 36       	cpi	r24, 0x64	; 100
    44f6:	91 05       	cpc	r25, r1
    44f8:	60 f4       	brcc	.+24     	; 0x4512 <__vector_88+0x64>
    44fa:	80 93 a6 32 	sts	0x32A6, r24	; 0x8032a6 <rcvD0_write_index>
    44fe:	90 93 a7 32 	sts	0x32A7, r25	; 0x8032a7 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4502:	20 91 b0 32 	lds	r18, 0x32B0	; 0x8032b0 <rcvD0_read_index>
    4506:	30 91 b1 32 	lds	r19, 0x32B1	; 0x8032b1 <rcvD0_read_index+0x1>
    450a:	82 17       	cp	r24, r18
    450c:	93 07       	cpc	r25, r19
    450e:	f1 f4       	brne	.+60     	; 0x454c <__vector_88+0x9e>
    4510:	0c c0       	rjmp	.+24     	; 0x452a <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    4512:	10 92 a6 32 	sts	0x32A6, r1	; 0x8032a6 <rcvD0_write_index>
    4516:	10 92 a7 32 	sts	0x32A7, r1	; 0x8032a7 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    451a:	80 91 b0 32 	lds	r24, 0x32B0	; 0x8032b0 <rcvD0_read_index>
    451e:	90 91 b1 32 	lds	r25, 0x32B1	; 0x8032b1 <rcvD0_read_index+0x1>
    4522:	18 16       	cp	r1, r24
    4524:	19 06       	cpc	r1, r25
    4526:	91 f4       	brne	.+36     	; 0x454c <__vector_88+0x9e>
    4528:	0e c0       	rjmp	.+28     	; 0x4546 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    452a:	01 96       	adiw	r24, 0x01	; 1
    452c:	84 36       	cpi	r24, 0x64	; 100
    452e:	91 05       	cpc	r25, r1
    4530:	28 f4       	brcc	.+10     	; 0x453c <__vector_88+0x8e>
    4532:	80 93 b0 32 	sts	0x32B0, r24	; 0x8032b0 <rcvD0_read_index>
    4536:	90 93 b1 32 	sts	0x32B1, r25	; 0x8032b1 <rcvD0_read_index+0x1>
    453a:	08 c0       	rjmp	.+16     	; 0x454c <__vector_88+0x9e>
	rcvD0_read_index = 0;
    453c:	10 92 b0 32 	sts	0x32B0, r1	; 0x8032b0 <rcvD0_read_index>
    4540:	10 92 b1 32 	sts	0x32B1, r1	; 0x8032b1 <rcvD0_read_index+0x1>
}
    4544:	03 c0       	rjmp	.+6      	; 0x454c <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4546:	81 e0       	ldi	r24, 0x01	; 1
    4548:	90 e0       	ldi	r25, 0x00	; 0
    454a:	f3 cf       	rjmp	.-26     	; 0x4532 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    454c:	ff 91       	pop	r31
    454e:	ef 91       	pop	r30
    4550:	9f 91       	pop	r25
    4552:	8f 91       	pop	r24
    4554:	3f 91       	pop	r19
    4556:	2f 91       	pop	r18
    4558:	0f 90       	pop	r0
    455a:	0b be       	out	0x3b, r0	; 59
    455c:	0f 90       	pop	r0
    455e:	08 be       	out	0x38, r0	; 56
    4560:	0f 90       	pop	r0
    4562:	0f be       	out	0x3f, r0	; 63
    4564:	0f 90       	pop	r0
    4566:	1f 90       	pop	r1
    4568:	18 95       	reti

0000456a <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    456a:	1f 92       	push	r1
    456c:	0f 92       	push	r0
    456e:	0f b6       	in	r0, 0x3f	; 63
    4570:	0f 92       	push	r0
    4572:	11 24       	eor	r1, r1
    4574:	08 b6       	in	r0, 0x38	; 56
    4576:	0f 92       	push	r0
    4578:	18 be       	out	0x38, r1	; 56
    457a:	0b b6       	in	r0, 0x3b	; 59
    457c:	0f 92       	push	r0
    457e:	1b be       	out	0x3b, r1	; 59
    4580:	2f 93       	push	r18
    4582:	3f 93       	push	r19
    4584:	8f 93       	push	r24
    4586:	9f 93       	push	r25
    4588:	ef 93       	push	r30
    458a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    458c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    4590:	e0 91 b8 32 	lds	r30, 0x32B8	; 0x8032b8 <rcvD1_buffer>
    4594:	f0 91 b9 32 	lds	r31, 0x32B9	; 0x8032b9 <rcvD1_buffer+0x1>
    4598:	80 91 a4 32 	lds	r24, 0x32A4	; 0x8032a4 <rcvD1_write_index>
    459c:	90 91 a5 32 	lds	r25, 0x32A5	; 0x8032a5 <rcvD1_write_index+0x1>
    45a0:	e8 0f       	add	r30, r24
    45a2:	f9 1f       	adc	r31, r25
    45a4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    45a6:	80 91 a4 32 	lds	r24, 0x32A4	; 0x8032a4 <rcvD1_write_index>
    45aa:	90 91 a5 32 	lds	r25, 0x32A5	; 0x8032a5 <rcvD1_write_index+0x1>
    45ae:	01 96       	adiw	r24, 0x01	; 1
    45b0:	84 36       	cpi	r24, 0x64	; 100
    45b2:	91 05       	cpc	r25, r1
    45b4:	60 f4       	brcc	.+24     	; 0x45ce <__vector_91+0x64>
    45b6:	80 93 a4 32 	sts	0x32A4, r24	; 0x8032a4 <rcvD1_write_index>
    45ba:	90 93 a5 32 	sts	0x32A5, r25	; 0x8032a5 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    45be:	20 91 ae 32 	lds	r18, 0x32AE	; 0x8032ae <rcvD1_read_index>
    45c2:	30 91 af 32 	lds	r19, 0x32AF	; 0x8032af <rcvD1_read_index+0x1>
    45c6:	82 17       	cp	r24, r18
    45c8:	93 07       	cpc	r25, r19
    45ca:	f1 f4       	brne	.+60     	; 0x4608 <__vector_91+0x9e>
    45cc:	0c c0       	rjmp	.+24     	; 0x45e6 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    45ce:	10 92 a4 32 	sts	0x32A4, r1	; 0x8032a4 <rcvD1_write_index>
    45d2:	10 92 a5 32 	sts	0x32A5, r1	; 0x8032a5 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    45d6:	80 91 ae 32 	lds	r24, 0x32AE	; 0x8032ae <rcvD1_read_index>
    45da:	90 91 af 32 	lds	r25, 0x32AF	; 0x8032af <rcvD1_read_index+0x1>
    45de:	18 16       	cp	r1, r24
    45e0:	19 06       	cpc	r1, r25
    45e2:	91 f4       	brne	.+36     	; 0x4608 <__vector_91+0x9e>
    45e4:	0e c0       	rjmp	.+28     	; 0x4602 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    45e6:	01 96       	adiw	r24, 0x01	; 1
    45e8:	84 36       	cpi	r24, 0x64	; 100
    45ea:	91 05       	cpc	r25, r1
    45ec:	28 f4       	brcc	.+10     	; 0x45f8 <__vector_91+0x8e>
    45ee:	80 93 ae 32 	sts	0x32AE, r24	; 0x8032ae <rcvD1_read_index>
    45f2:	90 93 af 32 	sts	0x32AF, r25	; 0x8032af <rcvD1_read_index+0x1>
    45f6:	08 c0       	rjmp	.+16     	; 0x4608 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    45f8:	10 92 ae 32 	sts	0x32AE, r1	; 0x8032ae <rcvD1_read_index>
    45fc:	10 92 af 32 	sts	0x32AF, r1	; 0x8032af <rcvD1_read_index+0x1>
}
    4600:	03 c0       	rjmp	.+6      	; 0x4608 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    4602:	81 e0       	ldi	r24, 0x01	; 1
    4604:	90 e0       	ldi	r25, 0x00	; 0
    4606:	f3 cf       	rjmp	.-26     	; 0x45ee <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    4608:	ff 91       	pop	r31
    460a:	ef 91       	pop	r30
    460c:	9f 91       	pop	r25
    460e:	8f 91       	pop	r24
    4610:	3f 91       	pop	r19
    4612:	2f 91       	pop	r18
    4614:	0f 90       	pop	r0
    4616:	0b be       	out	0x3b, r0	; 59
    4618:	0f 90       	pop	r0
    461a:	08 be       	out	0x38, r0	; 56
    461c:	0f 90       	pop	r0
    461e:	0f be       	out	0x3f, r0	; 63
    4620:	0f 90       	pop	r0
    4622:	1f 90       	pop	r1
    4624:	18 95       	reti

00004626 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4626:	1f 92       	push	r1
    4628:	0f 92       	push	r0
    462a:	0f b6       	in	r0, 0x3f	; 63
    462c:	0f 92       	push	r0
    462e:	11 24       	eor	r1, r1
    4630:	08 b6       	in	r0, 0x38	; 56
    4632:	0f 92       	push	r0
    4634:	18 be       	out	0x38, r1	; 56
    4636:	0b b6       	in	r0, 0x3b	; 59
    4638:	0f 92       	push	r0
    463a:	1b be       	out	0x3b, r1	; 59
    463c:	2f 93       	push	r18
    463e:	3f 93       	push	r19
    4640:	8f 93       	push	r24
    4642:	9f 93       	push	r25
    4644:	ef 93       	push	r30
    4646:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4648:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    464c:	e0 91 b6 32 	lds	r30, 0x32B6	; 0x8032b6 <rcvE0_buffer>
    4650:	f0 91 b7 32 	lds	r31, 0x32B7	; 0x8032b7 <rcvE0_buffer+0x1>
    4654:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvE0_write_index>
    4658:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvE0_write_index+0x1>
    465c:	e8 0f       	add	r30, r24
    465e:	f9 1f       	adc	r31, r25
    4660:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4662:	80 91 a2 32 	lds	r24, 0x32A2	; 0x8032a2 <rcvE0_write_index>
    4666:	90 91 a3 32 	lds	r25, 0x32A3	; 0x8032a3 <rcvE0_write_index+0x1>
    466a:	01 96       	adiw	r24, 0x01	; 1
    466c:	84 36       	cpi	r24, 0x64	; 100
    466e:	91 05       	cpc	r25, r1
    4670:	60 f4       	brcc	.+24     	; 0x468a <__vector_58+0x64>
    4672:	80 93 a2 32 	sts	0x32A2, r24	; 0x8032a2 <rcvE0_write_index>
    4676:	90 93 a3 32 	sts	0x32A3, r25	; 0x8032a3 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    467a:	20 91 ac 32 	lds	r18, 0x32AC	; 0x8032ac <rcvE0_read_index>
    467e:	30 91 ad 32 	lds	r19, 0x32AD	; 0x8032ad <rcvE0_read_index+0x1>
    4682:	82 17       	cp	r24, r18
    4684:	93 07       	cpc	r25, r19
    4686:	f1 f4       	brne	.+60     	; 0x46c4 <__vector_58+0x9e>
    4688:	0c c0       	rjmp	.+24     	; 0x46a2 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    468a:	10 92 a2 32 	sts	0x32A2, r1	; 0x8032a2 <rcvE0_write_index>
    468e:	10 92 a3 32 	sts	0x32A3, r1	; 0x8032a3 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4692:	80 91 ac 32 	lds	r24, 0x32AC	; 0x8032ac <rcvE0_read_index>
    4696:	90 91 ad 32 	lds	r25, 0x32AD	; 0x8032ad <rcvE0_read_index+0x1>
    469a:	18 16       	cp	r1, r24
    469c:	19 06       	cpc	r1, r25
    469e:	91 f4       	brne	.+36     	; 0x46c4 <__vector_58+0x9e>
    46a0:	0e c0       	rjmp	.+28     	; 0x46be <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    46a2:	01 96       	adiw	r24, 0x01	; 1
    46a4:	84 36       	cpi	r24, 0x64	; 100
    46a6:	91 05       	cpc	r25, r1
    46a8:	28 f4       	brcc	.+10     	; 0x46b4 <__vector_58+0x8e>
    46aa:	80 93 ac 32 	sts	0x32AC, r24	; 0x8032ac <rcvE0_read_index>
    46ae:	90 93 ad 32 	sts	0x32AD, r25	; 0x8032ad <rcvE0_read_index+0x1>
    46b2:	08 c0       	rjmp	.+16     	; 0x46c4 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    46b4:	10 92 ac 32 	sts	0x32AC, r1	; 0x8032ac <rcvE0_read_index>
    46b8:	10 92 ad 32 	sts	0x32AD, r1	; 0x8032ad <rcvE0_read_index+0x1>
}
    46bc:	03 c0       	rjmp	.+6      	; 0x46c4 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    46be:	81 e0       	ldi	r24, 0x01	; 1
    46c0:	90 e0       	ldi	r25, 0x00	; 0
    46c2:	f3 cf       	rjmp	.-26     	; 0x46aa <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    46c4:	ff 91       	pop	r31
    46c6:	ef 91       	pop	r30
    46c8:	9f 91       	pop	r25
    46ca:	8f 91       	pop	r24
    46cc:	3f 91       	pop	r19
    46ce:	2f 91       	pop	r18
    46d0:	0f 90       	pop	r0
    46d2:	0b be       	out	0x3b, r0	; 59
    46d4:	0f 90       	pop	r0
    46d6:	08 be       	out	0x38, r0	; 56
    46d8:	0f 90       	pop	r0
    46da:	0f be       	out	0x3f, r0	; 63
    46dc:	0f 90       	pop	r0
    46de:	1f 90       	pop	r1
    46e0:	18 95       	reti

000046e2 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    46e2:	fc 01       	movw	r30, r24
    46e4:	84 81       	ldd	r24, Z+4	; 0x04
    46e6:	95 81       	ldd	r25, Z+5	; 0x05
    46e8:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
		}
    46ec:	90 e0       	ldi	r25, 0x00	; 0
    46ee:	08 95       	ret

000046f0 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    46f0:	fc 01       	movw	r30, r24
    46f2:	84 81       	ldd	r24, Z+4	; 0x04
    46f4:	95 81       	ldd	r25, Z+5	; 0x05
    46f6:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    46fa:	91 e0       	ldi	r25, 0x01	; 1
    46fc:	81 11       	cpse	r24, r1
    46fe:	01 c0       	rjmp	.+2      	; 0x4702 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    4700:	90 e0       	ldi	r25, 0x00	; 0
		}
    4702:	89 2f       	mov	r24, r25
    4704:	08 95       	ret

00004706 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    4706:	fc 01       	movw	r30, r24
    4708:	84 81       	ldd	r24, Z+4	; 0x04
    470a:	95 81       	ldd	r25, Z+5	; 0x05
    470c:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    4710:	91 e0       	ldi	r25, 0x01	; 1
    4712:	81 11       	cpse	r24, r1
    4714:	90 e0       	ldi	r25, 0x00	; 0
		}
    4716:	89 2f       	mov	r24, r25
    4718:	08 95       	ret

0000471a <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    471a:	fc 01       	movw	r30, r24
    471c:	84 81       	ldd	r24, Z+4	; 0x04
    471e:	95 81       	ldd	r25, Z+5	; 0x05
    4720:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
		}
    4724:	90 e0       	ldi	r25, 0x00	; 0
    4726:	08 95       	ret

00004728 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4728:	fc 01       	movw	r30, r24
    472a:	84 81       	ldd	r24, Z+4	; 0x04
    472c:	95 81       	ldd	r25, Z+5	; 0x05
    472e:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    4732:	91 e0       	ldi	r25, 0x01	; 1
    4734:	81 11       	cpse	r24, r1
    4736:	01 c0       	rjmp	.+2      	; 0x473a <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    4738:	90 e0       	ldi	r25, 0x00	; 0
		}
    473a:	89 2f       	mov	r24, r25
    473c:	08 95       	ret

0000473e <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    473e:	fc 01       	movw	r30, r24
    4740:	84 81       	ldd	r24, Z+4	; 0x04
    4742:	95 81       	ldd	r25, Z+5	; 0x05
    4744:	0e 94 a3 14 	call	0x2946	; 0x2946 <uxQueueMessagesWaitingFromISR>
    4748:	91 e0       	ldi	r25, 0x01	; 1
    474a:	81 11       	cpse	r24, r1
    474c:	90 e0       	ldi	r25, 0x00	; 0
		}
    474e:	89 2f       	mov	r24, r25
    4750:	08 95       	ret

00004752 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4752:	fc 01       	movw	r30, r24
    4754:	84 81       	ldd	r24, Z+4	; 0x04
    4756:	95 81       	ldd	r25, Z+5	; 0x05
    4758:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
		}
    475c:	90 e0       	ldi	r25, 0x00	; 0
    475e:	08 95       	ret

00004760 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4760:	fc 01       	movw	r30, r24
    4762:	84 81       	ldd	r24, Z+4	; 0x04
    4764:	95 81       	ldd	r25, Z+5	; 0x05
    4766:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    476a:	91 e0       	ldi	r25, 0x01	; 1
    476c:	81 11       	cpse	r24, r1
    476e:	01 c0       	rjmp	.+2      	; 0x4772 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4770:	90 e0       	ldi	r25, 0x00	; 0
		}
    4772:	89 2f       	mov	r24, r25
    4774:	08 95       	ret

00004776 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4776:	fc 01       	movw	r30, r24
    4778:	84 81       	ldd	r24, Z+4	; 0x04
    477a:	95 81       	ldd	r25, Z+5	; 0x05
    477c:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    4780:	91 e0       	ldi	r25, 0x01	; 1
    4782:	81 11       	cpse	r24, r1
    4784:	90 e0       	ldi	r25, 0x00	; 0
		}
    4786:	89 2f       	mov	r24, r25
    4788:	08 95       	ret

0000478a <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    478a:	fc 01       	movw	r30, r24
    478c:	84 81       	ldd	r24, Z+4	; 0x04
    478e:	95 81       	ldd	r25, Z+5	; 0x05
    4790:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
		}
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	08 95       	ret

00004798 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4798:	fc 01       	movw	r30, r24
    479a:	84 81       	ldd	r24, Z+4	; 0x04
    479c:	95 81       	ldd	r25, Z+5	; 0x05
    479e:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    47a2:	91 e0       	ldi	r25, 0x01	; 1
    47a4:	81 11       	cpse	r24, r1
    47a6:	01 c0       	rjmp	.+2      	; 0x47aa <_ZN9frt_queueIiE9not_emptyEv+0x12>
    47a8:	90 e0       	ldi	r25, 0x00	; 0
		}
    47aa:	89 2f       	mov	r24, r25
    47ac:	08 95       	ret

000047ae <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    47ae:	fc 01       	movw	r30, r24
    47b0:	84 81       	ldd	r24, Z+4	; 0x04
    47b2:	95 81       	ldd	r25, Z+5	; 0x05
    47b4:	0e 94 9b 14 	call	0x2936	; 0x2936 <uxQueueMessagesWaiting>
    47b8:	91 e0       	ldi	r25, 0x01	; 1
    47ba:	81 11       	cpse	r24, r1
    47bc:	90 e0       	ldi	r25, 0x00	; 0
		}
    47be:	89 2f       	mov	r24, r25
    47c0:	08 95       	ret

000047c2 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    47c2:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    47c4:	01 e0       	ldi	r16, 0x01	; 1
    47c6:	2f ef       	ldi	r18, 0xFF	; 255
    47c8:	3f ef       	ldi	r19, 0xFF	; 255
    47ca:	a9 01       	movw	r20, r18
    47cc:	fc 01       	movw	r30, r24
    47ce:	84 81       	ldd	r24, Z+4	; 0x04
    47d0:	95 81       	ldd	r25, Z+5	; 0x05
    47d2:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    47d6:	0f 91       	pop	r16
    47d8:	08 95       	ret

000047da <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    47da:	0f 93       	push	r16
    47dc:	cf 93       	push	r28
    47de:	df 93       	push	r29
    47e0:	1f 92       	push	r1
    47e2:	1f 92       	push	r1
    47e4:	cd b7       	in	r28, 0x3d	; 61
    47e6:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    47e8:	01 e0       	ldi	r16, 0x01	; 1
    47ea:	2f ef       	ldi	r18, 0xFF	; 255
    47ec:	3f ef       	ldi	r19, 0xFF	; 255
    47ee:	a9 01       	movw	r20, r18
    47f0:	be 01       	movw	r22, r28
    47f2:	6f 5f       	subi	r22, 0xFF	; 255
    47f4:	7f 4f       	sbci	r23, 0xFF	; 255
    47f6:	fc 01       	movw	r30, r24
    47f8:	84 81       	ldd	r24, Z+4	; 0x04
    47fa:	95 81       	ldd	r25, Z+5	; 0x05
    47fc:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    4800:	89 81       	ldd	r24, Y+1	; 0x01
    4802:	9a 81       	ldd	r25, Y+2	; 0x02
    4804:	0f 90       	pop	r0
    4806:	0f 90       	pop	r0
    4808:	df 91       	pop	r29
    480a:	cf 91       	pop	r28
    480c:	0f 91       	pop	r16
    480e:	08 95       	ret

00004810 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    4810:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4812:	00 e0       	ldi	r16, 0x00	; 0
    4814:	2f ef       	ldi	r18, 0xFF	; 255
    4816:	3f ef       	ldi	r19, 0xFF	; 255
    4818:	a9 01       	movw	r20, r18
    481a:	fc 01       	movw	r30, r24
    481c:	84 81       	ldd	r24, Z+4	; 0x04
    481e:	95 81       	ldd	r25, Z+5	; 0x05
    4820:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    4824:	0f 91       	pop	r16
    4826:	08 95       	ret

00004828 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4828:	0f 93       	push	r16
    482a:	cf 93       	push	r28
    482c:	df 93       	push	r29
    482e:	1f 92       	push	r1
    4830:	1f 92       	push	r1
    4832:	cd b7       	in	r28, 0x3d	; 61
    4834:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4836:	00 e0       	ldi	r16, 0x00	; 0
    4838:	2f ef       	ldi	r18, 0xFF	; 255
    483a:	3f ef       	ldi	r19, 0xFF	; 255
    483c:	a9 01       	movw	r20, r18
    483e:	be 01       	movw	r22, r28
    4840:	6f 5f       	subi	r22, 0xFF	; 255
    4842:	7f 4f       	sbci	r23, 0xFF	; 255
    4844:	fc 01       	movw	r30, r24
    4846:	84 81       	ldd	r24, Z+4	; 0x04
    4848:	95 81       	ldd	r25, Z+5	; 0x05
    484a:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    484e:	89 81       	ldd	r24, Y+1	; 0x01
    4850:	9a 81       	ldd	r25, Y+2	; 0x02
    4852:	0f 90       	pop	r0
    4854:	0f 90       	pop	r0
    4856:	df 91       	pop	r29
    4858:	cf 91       	pop	r28
    485a:	0f 91       	pop	r16
    485c:	08 95       	ret

0000485e <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    485e:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4860:	01 e0       	ldi	r16, 0x01	; 1
    4862:	2f ef       	ldi	r18, 0xFF	; 255
    4864:	3f ef       	ldi	r19, 0xFF	; 255
    4866:	a9 01       	movw	r20, r18
    4868:	fc 01       	movw	r30, r24
    486a:	84 81       	ldd	r24, Z+4	; 0x04
    486c:	95 81       	ldd	r25, Z+5	; 0x05
    486e:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    4872:	0f 91       	pop	r16
    4874:	08 95       	ret

00004876 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4876:	0f 93       	push	r16
    4878:	cf 93       	push	r28
    487a:	df 93       	push	r29
    487c:	1f 92       	push	r1
    487e:	1f 92       	push	r1
    4880:	cd b7       	in	r28, 0x3d	; 61
    4882:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4884:	01 e0       	ldi	r16, 0x01	; 1
    4886:	2f ef       	ldi	r18, 0xFF	; 255
    4888:	3f ef       	ldi	r19, 0xFF	; 255
    488a:	a9 01       	movw	r20, r18
    488c:	be 01       	movw	r22, r28
    488e:	6f 5f       	subi	r22, 0xFF	; 255
    4890:	7f 4f       	sbci	r23, 0xFF	; 255
    4892:	fc 01       	movw	r30, r24
    4894:	84 81       	ldd	r24, Z+4	; 0x04
    4896:	95 81       	ldd	r25, Z+5	; 0x05
    4898:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    489c:	89 81       	ldd	r24, Y+1	; 0x01
    489e:	9a 81       	ldd	r25, Y+2	; 0x02
    48a0:	0f 90       	pop	r0
    48a2:	0f 90       	pop	r0
    48a4:	df 91       	pop	r29
    48a6:	cf 91       	pop	r28
    48a8:	0f 91       	pop	r16
    48aa:	08 95       	ret

000048ac <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    48ac:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    48ae:	00 e0       	ldi	r16, 0x00	; 0
    48b0:	2f ef       	ldi	r18, 0xFF	; 255
    48b2:	3f ef       	ldi	r19, 0xFF	; 255
    48b4:	a9 01       	movw	r20, r18
    48b6:	fc 01       	movw	r30, r24
    48b8:	84 81       	ldd	r24, Z+4	; 0x04
    48ba:	95 81       	ldd	r25, Z+5	; 0x05
    48bc:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
}
    48c0:	0f 91       	pop	r16
    48c2:	08 95       	ret

000048c4 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    48c4:	0f 93       	push	r16
    48c6:	cf 93       	push	r28
    48c8:	df 93       	push	r29
    48ca:	1f 92       	push	r1
    48cc:	1f 92       	push	r1
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    48d2:	00 e0       	ldi	r16, 0x00	; 0
    48d4:	2f ef       	ldi	r18, 0xFF	; 255
    48d6:	3f ef       	ldi	r19, 0xFF	; 255
    48d8:	a9 01       	movw	r20, r18
    48da:	be 01       	movw	r22, r28
    48dc:	6f 5f       	subi	r22, 0xFF	; 255
    48de:	7f 4f       	sbci	r23, 0xFF	; 255
    48e0:	fc 01       	movw	r30, r24
    48e2:	84 81       	ldd	r24, Z+4	; 0x04
    48e4:	95 81       	ldd	r25, Z+5	; 0x05
    48e6:	0e 94 aa 13 	call	0x2754	; 0x2754 <xQueueGenericReceive>
	return (recv_item);
}
    48ea:	89 81       	ldd	r24, Y+1	; 0x01
    48ec:	9a 81       	ldd	r25, Y+2	; 0x02
    48ee:	0f 90       	pop	r0
    48f0:	0f 90       	pop	r0
    48f2:	df 91       	pop	r29
    48f4:	cf 91       	pop	r28
    48f6:	0f 91       	pop	r16
    48f8:	08 95       	ret

000048fa <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	1f 92       	push	r1
    4900:	cd b7       	in	r28, 0x3d	; 61
    4902:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4904:	ae 01       	movw	r20, r28
    4906:	4f 5f       	subi	r20, 0xFF	; 255
    4908:	5f 4f       	sbci	r21, 0xFF	; 255
    490a:	fc 01       	movw	r30, r24
    490c:	84 81       	ldd	r24, Z+4	; 0x04
    490e:	95 81       	ldd	r25, Z+5	; 0x05
    4910:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
}
    4914:	0f 90       	pop	r0
    4916:	df 91       	pop	r29
    4918:	cf 91       	pop	r28
    491a:	08 95       	ret

0000491c <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    491c:	cf 93       	push	r28
    491e:	df 93       	push	r29
    4920:	00 d0       	rcall	.+0      	; 0x4922 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4926:	ae 01       	movw	r20, r28
    4928:	4d 5f       	subi	r20, 0xFD	; 253
    492a:	5f 4f       	sbci	r21, 0xFF	; 255
    492c:	be 01       	movw	r22, r28
    492e:	6f 5f       	subi	r22, 0xFF	; 255
    4930:	7f 4f       	sbci	r23, 0xFF	; 255
    4932:	fc 01       	movw	r30, r24
    4934:	84 81       	ldd	r24, Z+4	; 0x04
    4936:	95 81       	ldd	r25, Z+5	; 0x05
    4938:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
	return (recv_item);
}
    493c:	89 81       	ldd	r24, Y+1	; 0x01
    493e:	9a 81       	ldd	r25, Y+2	; 0x02
    4940:	23 96       	adiw	r28, 0x03	; 3
    4942:	cd bf       	out	0x3d, r28	; 61
    4944:	de bf       	out	0x3e, r29	; 62
    4946:	df 91       	pop	r29
    4948:	cf 91       	pop	r28
    494a:	08 95       	ret

0000494c <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    494c:	cf 93       	push	r28
    494e:	df 93       	push	r29
    4950:	1f 92       	push	r1
    4952:	cd b7       	in	r28, 0x3d	; 61
    4954:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4956:	ae 01       	movw	r20, r28
    4958:	4f 5f       	subi	r20, 0xFF	; 255
    495a:	5f 4f       	sbci	r21, 0xFF	; 255
    495c:	fc 01       	movw	r30, r24
    495e:	84 81       	ldd	r24, Z+4	; 0x04
    4960:	95 81       	ldd	r25, Z+5	; 0x05
    4962:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
}
    4966:	0f 90       	pop	r0
    4968:	df 91       	pop	r29
    496a:	cf 91       	pop	r28
    496c:	08 95       	ret

0000496e <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    496e:	cf 93       	push	r28
    4970:	df 93       	push	r29
    4972:	00 d0       	rcall	.+0      	; 0x4974 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4974:	cd b7       	in	r28, 0x3d	; 61
    4976:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4978:	ae 01       	movw	r20, r28
    497a:	4d 5f       	subi	r20, 0xFD	; 253
    497c:	5f 4f       	sbci	r21, 0xFF	; 255
    497e:	be 01       	movw	r22, r28
    4980:	6f 5f       	subi	r22, 0xFF	; 255
    4982:	7f 4f       	sbci	r23, 0xFF	; 255
    4984:	fc 01       	movw	r30, r24
    4986:	84 81       	ldd	r24, Z+4	; 0x04
    4988:	95 81       	ldd	r25, Z+5	; 0x05
    498a:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueReceiveFromISR>
	return (recv_item);
}
    498e:	89 81       	ldd	r24, Y+1	; 0x01
    4990:	9a 81       	ldd	r25, Y+2	; 0x02
    4992:	23 96       	adiw	r28, 0x03	; 3
    4994:	cd bf       	out	0x3d, r28	; 61
    4996:	de bf       	out	0x3e, r29	; 62
    4998:	df 91       	pop	r29
    499a:	cf 91       	pop	r28
    499c:	08 95       	ret

0000499e <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    499e:	cf 93       	push	r28
    49a0:	df 93       	push	r29
    49a2:	1f 92       	push	r1
    49a4:	cd b7       	in	r28, 0x3d	; 61
    49a6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49a8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    49aa:	21 e0       	ldi	r18, 0x01	; 1
    49ac:	ae 01       	movw	r20, r28
    49ae:	4f 5f       	subi	r20, 0xFF	; 255
    49b0:	5f 4f       	sbci	r21, 0xFF	; 255
    49b2:	fc 01       	movw	r30, r24
    49b4:	84 81       	ldd	r24, Z+4	; 0x04
    49b6:	95 81       	ldd	r25, Z+5	; 0x05
    49b8:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49bc:	91 e0       	ldi	r25, 0x01	; 1
    49be:	81 11       	cpse	r24, r1
    49c0:	01 c0       	rjmp	.+2      	; 0x49c4 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    49c2:	90 e0       	ldi	r25, 0x00	; 0
}
    49c4:	89 2f       	mov	r24, r25
    49c6:	0f 90       	pop	r0
    49c8:	df 91       	pop	r29
    49ca:	cf 91       	pop	r28
    49cc:	08 95       	ret

000049ce <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    49ce:	cf 93       	push	r28
    49d0:	df 93       	push	r29
    49d2:	1f 92       	push	r1
    49d4:	cd b7       	in	r28, 0x3d	; 61
    49d6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    49d8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    49da:	20 e0       	ldi	r18, 0x00	; 0
    49dc:	ae 01       	movw	r20, r28
    49de:	4f 5f       	subi	r20, 0xFF	; 255
    49e0:	5f 4f       	sbci	r21, 0xFF	; 255
    49e2:	fc 01       	movw	r30, r24
    49e4:	84 81       	ldd	r24, Z+4	; 0x04
    49e6:	95 81       	ldd	r25, Z+5	; 0x05
    49e8:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    49ec:	91 e0       	ldi	r25, 0x01	; 1
    49ee:	81 11       	cpse	r24, r1
    49f0:	01 c0       	rjmp	.+2      	; 0x49f4 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    49f2:	90 e0       	ldi	r25, 0x00	; 0
}
    49f4:	89 2f       	mov	r24, r25
    49f6:	0f 90       	pop	r0
    49f8:	df 91       	pop	r29
    49fa:	cf 91       	pop	r28
    49fc:	08 95       	ret

000049fe <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    49fe:	cf 93       	push	r28
    4a00:	df 93       	push	r29
    4a02:	1f 92       	push	r1
    4a04:	cd b7       	in	r28, 0x3d	; 61
    4a06:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a08:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4a0a:	21 e0       	ldi	r18, 0x01	; 1
    4a0c:	ae 01       	movw	r20, r28
    4a0e:	4f 5f       	subi	r20, 0xFF	; 255
    4a10:	5f 4f       	sbci	r21, 0xFF	; 255
    4a12:	fc 01       	movw	r30, r24
    4a14:	84 81       	ldd	r24, Z+4	; 0x04
    4a16:	95 81       	ldd	r25, Z+5	; 0x05
    4a18:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a1c:	91 e0       	ldi	r25, 0x01	; 1
    4a1e:	81 11       	cpse	r24, r1
    4a20:	01 c0       	rjmp	.+2      	; 0x4a24 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4a22:	90 e0       	ldi	r25, 0x00	; 0
}
    4a24:	89 2f       	mov	r24, r25
    4a26:	0f 90       	pop	r0
    4a28:	df 91       	pop	r29
    4a2a:	cf 91       	pop	r28
    4a2c:	08 95       	ret

00004a2e <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    4a2e:	cf 93       	push	r28
    4a30:	df 93       	push	r29
    4a32:	1f 92       	push	r1
    4a34:	cd b7       	in	r28, 0x3d	; 61
    4a36:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4a38:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4a3a:	20 e0       	ldi	r18, 0x00	; 0
    4a3c:	ae 01       	movw	r20, r28
    4a3e:	4f 5f       	subi	r20, 0xFF	; 255
    4a40:	5f 4f       	sbci	r21, 0xFF	; 255
    4a42:	fc 01       	movw	r30, r24
    4a44:	84 81       	ldd	r24, Z+4	; 0x04
    4a46:	95 81       	ldd	r25, Z+5	; 0x05
    4a48:	0e 94 7e 13 	call	0x26fc	; 0x26fc <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    4a4c:	91 e0       	ldi	r25, 0x01	; 1
    4a4e:	81 11       	cpse	r24, r1
    4a50:	01 c0       	rjmp	.+2      	; 0x4a54 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4a52:	90 e0       	ldi	r25, 0x00	; 0
}
    4a54:	89 2f       	mov	r24, r25
    4a56:	0f 90       	pop	r0
    4a58:	df 91       	pop	r29
    4a5a:	cf 91       	pop	r28
    4a5c:	08 95       	ret

00004a5e <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4a5e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4a60:	fc 01       	movw	r30, r24
    4a62:	26 81       	ldd	r18, Z+6	; 0x06
    4a64:	37 81       	ldd	r19, Z+7	; 0x07
    4a66:	40 85       	ldd	r20, Z+8	; 0x08
    4a68:	51 85       	ldd	r21, Z+9	; 0x09
    4a6a:	01 e0       	ldi	r16, 0x01	; 1
    4a6c:	84 81       	ldd	r24, Z+4	; 0x04
    4a6e:	95 81       	ldd	r25, Z+5	; 0x05
    4a70:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    4a74:	91 e0       	ldi	r25, 0x01	; 1
    4a76:	81 11       	cpse	r24, r1
    4a78:	01 c0       	rjmp	.+2      	; 0x4a7c <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4a7a:	90 e0       	ldi	r25, 0x00	; 0
		}
    4a7c:	89 2f       	mov	r24, r25
    4a7e:	0f 91       	pop	r16
    4a80:	08 95       	ret

00004a82 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4a82:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4a84:	fc 01       	movw	r30, r24
    4a86:	26 81       	ldd	r18, Z+6	; 0x06
    4a88:	37 81       	ldd	r19, Z+7	; 0x07
    4a8a:	40 85       	ldd	r20, Z+8	; 0x08
    4a8c:	51 85       	ldd	r21, Z+9	; 0x09
    4a8e:	00 e0       	ldi	r16, 0x00	; 0
    4a90:	84 81       	ldd	r24, Z+4	; 0x04
    4a92:	95 81       	ldd	r25, Z+5	; 0x05
    4a94:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    4a98:	91 e0       	ldi	r25, 0x01	; 1
    4a9a:	81 11       	cpse	r24, r1
    4a9c:	01 c0       	rjmp	.+2      	; 0x4aa0 <_ZN9frt_queueIjE3putERKj+0x1e>
    4a9e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4aa0:	89 2f       	mov	r24, r25
    4aa2:	0f 91       	pop	r16
    4aa4:	08 95       	ret

00004aa6 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4aa6:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4aa8:	fc 01       	movw	r30, r24
    4aaa:	26 81       	ldd	r18, Z+6	; 0x06
    4aac:	37 81       	ldd	r19, Z+7	; 0x07
    4aae:	40 85       	ldd	r20, Z+8	; 0x08
    4ab0:	51 85       	ldd	r21, Z+9	; 0x09
    4ab2:	01 e0       	ldi	r16, 0x01	; 1
    4ab4:	84 81       	ldd	r24, Z+4	; 0x04
    4ab6:	95 81       	ldd	r25, Z+5	; 0x05
    4ab8:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    4abc:	91 e0       	ldi	r25, 0x01	; 1
    4abe:	81 11       	cpse	r24, r1
    4ac0:	01 c0       	rjmp	.+2      	; 0x4ac4 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4ac2:	90 e0       	ldi	r25, 0x00	; 0
		}
    4ac4:	89 2f       	mov	r24, r25
    4ac6:	0f 91       	pop	r16
    4ac8:	08 95       	ret

00004aca <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4aca:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4acc:	fc 01       	movw	r30, r24
    4ace:	26 81       	ldd	r18, Z+6	; 0x06
    4ad0:	37 81       	ldd	r19, Z+7	; 0x07
    4ad2:	40 85       	ldd	r20, Z+8	; 0x08
    4ad4:	51 85       	ldd	r21, Z+9	; 0x09
    4ad6:	00 e0       	ldi	r16, 0x00	; 0
    4ad8:	84 81       	ldd	r24, Z+4	; 0x04
    4ada:	95 81       	ldd	r25, Z+5	; 0x05
    4adc:	0e 94 e3 12 	call	0x25c6	; 0x25c6 <xQueueGenericSend>
    4ae0:	91 e0       	ldi	r25, 0x01	; 1
    4ae2:	81 11       	cpse	r24, r1
    4ae4:	01 c0       	rjmp	.+2      	; 0x4ae8 <_ZN9frt_queueIiE3putERKi+0x1e>
    4ae6:	90 e0       	ldi	r25, 0x00	; 0
		}
    4ae8:	89 2f       	mov	r24, r25
    4aea:	0f 91       	pop	r16
    4aec:	08 95       	ret

00004aee <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    4aee:	0f 93       	push	r16
    4af0:	cf 93       	push	r28
    4af2:	df 93       	push	r29
    4af4:	1f 92       	push	r1
    4af6:	cd b7       	in	r28, 0x3d	; 61
    4af8:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    4afa:	2f b7       	in	r18, 0x3f	; 63
    4afc:	29 83       	std	Y+1, r18	; 0x01
	cli();
    4afe:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    4b00:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    4b02:	fc 01       	movw	r30, r24
    4b04:	08 ed       	ldi	r16, 0xD8	; 216
    4b06:	04 bf       	out	0x34, r16	; 52
    4b08:	60 83       	st	Z, r22

	SREG = saved_sreg;
    4b0a:	89 81       	ldd	r24, Y+1	; 0x01
    4b0c:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    4b0e:	0f 90       	pop	r0
    4b10:	df 91       	pop	r29
    4b12:	cf 91       	pop	r28
    4b14:	0f 91       	pop	r16
    4b16:	08 95       	ret

00004b18 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4b18:	ef 92       	push	r14
    4b1a:	ff 92       	push	r15
    4b1c:	0f 93       	push	r16
    4b1e:	1f 93       	push	r17
    4b20:	cf 93       	push	r28
    4b22:	df 93       	push	r29
    4b24:	cd b7       	in	r28, 0x3d	; 61
    4b26:	de b7       	in	r29, 0x3e	; 62
    4b28:	ca 55       	subi	r28, 0x5A	; 90
    4b2a:	d1 09       	sbc	r29, r1
    4b2c:	cd bf       	out	0x3d, r28	; 61
    4b2e:	de bf       	out	0x3e, r29	; 62
	cli();
    4b30:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4b32:	e0 e5       	ldi	r30, 0x50	; 80
    4b34:	f0 e0       	ldi	r31, 0x00	; 0
    4b36:	80 81       	ld	r24, Z
    4b38:	82 60       	ori	r24, 0x02	; 2
    4b3a:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4b3c:	81 81       	ldd	r24, Z+1	; 0x01
    4b3e:	81 ff       	sbrs	r24, 1
    4b40:	fd cf       	rjmp	.-6      	; 0x4b3c <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4b42:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4b46:	68 7f       	andi	r22, 0xF8	; 248
    4b48:	61 60       	ori	r22, 0x01	; 1
    4b4a:	80 e4       	ldi	r24, 0x40	; 64
    4b4c:	90 e0       	ldi	r25, 0x00	; 0
    4b4e:	0e 94 77 25 	call	0x4aee	; 0x4aee <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4b52:	e0 e5       	ldi	r30, 0x50	; 80
    4b54:	f0 e0       	ldi	r31, 0x00	; 0
    4b56:	80 81       	ld	r24, Z
    4b58:	8e 7f       	andi	r24, 0xFE	; 254
    4b5a:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4b5c:	9d ef       	ldi	r25, 0xFD	; 253
    4b5e:	88 ed       	ldi	r24, 0xD8	; 216
    4b60:	08 b6       	in	r0, 0x38	; 56
    4b62:	18 be       	out	0x38, r1	; 56
    4b64:	84 bf       	out	0x34, r24	; 52
    4b66:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4b6a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4b6c:	40 ea       	ldi	r20, 0xA0	; 160
    4b6e:	5a e0       	ldi	r21, 0x0A	; 10
    4b70:	60 e0       	ldi	r22, 0x00	; 0
    4b72:	70 e0       	ldi	r23, 0x00	; 0
    4b74:	ce 01       	movw	r24, r28
    4b76:	01 96       	adiw	r24, 0x01	; 1
    4b78:	0e 94 1b 21 	call	0x4236	; 0x4236 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4b7c:	67 e0       	ldi	r22, 0x07	; 7
    4b7e:	ce 01       	movw	r24, r28
    4b80:	01 96       	adiw	r24, 0x01	; 1
    4b82:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    4b86:	8c 01       	movw	r16, r24
    4b88:	60 ec       	ldi	r22, 0xC0	; 192
    4b8a:	71 e2       	ldi	r23, 0x21	; 33
    4b8c:	0e 94 41 1f 	call	0x3e82	; 0x3e82 <_ZN8emstream4putsEPKc>
    4b90:	66 e0       	ldi	r22, 0x06	; 6
    4b92:	c8 01       	movw	r24, r16
    4b94:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
    4b98:	66 e0       	ldi	r22, 0x06	; 6
    4b9a:	0e 94 78 1f 	call	0x3ef0	; 0x3ef0 <_ZN8emstreamlsE15ser_manipulator>
	
	// Create instance of I2C driver to be used by sensor objects
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4b9e:	8e 01       	movw	r16, r28
    4ba0:	0f 5f       	subi	r16, 0xFF	; 255
    4ba2:	1f 4f       	sbci	r17, 0xFF	; 255
    4ba4:	20 e3       	ldi	r18, 0x30	; 48
    4ba6:	32 ef       	ldi	r19, 0xF2	; 242
    4ba8:	40 e0       	ldi	r20, 0x00	; 0
    4baa:	50 e0       	ldi	r21, 0x00	; 0
    4bac:	60 ea       	ldi	r22, 0xA0	; 160
    4bae:	74 e0       	ldi	r23, 0x04	; 4
    4bb0:	ce 01       	movw	r24, r28
    4bb2:	4e 96       	adiw	r24, 0x1e	; 30
    4bb4:	0e 94 b5 07 	call	0xf6a	; 0xf6a <_ZN9I2CMasterC1EP10TWI_structmP8emstream>
	
	// Create instance of IMU class and pass in a pointer to the I2C driver
	MMA8451 mma8451(&i2c, &ser_dev);
    4bb8:	a8 01       	movw	r20, r16
    4bba:	be 01       	movw	r22, r28
    4bbc:	62 5e       	subi	r22, 0xE2	; 226
    4bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    4bc0:	ce 01       	movw	r24, r28
    4bc2:	c7 96       	adiw	r24, 0x37	; 55
    4bc4:	0e 94 33 0a 	call	0x1466	; 0x1466 <_ZN7MMA8451C1EP9I2CMasterP8emstream>

	//Create instance of Sonar class and pass in a pointer to the I2C driver
	MB1202 mb1202(&i2c, &ser_dev);
    4bc8:	a8 01       	movw	r20, r16
    4bca:	be 01       	movw	r22, r28
    4bcc:	62 5e       	subi	r22, 0xE2	; 226
    4bce:	7f 4f       	sbci	r23, 0xFF	; 255
    4bd0:	ce 01       	movw	r24, r28
    4bd2:	86 5b       	subi	r24, 0xB6	; 182
    4bd4:	9f 4f       	sbci	r25, 0xFF	; 255
    4bd6:	0e 94 4d 09 	call	0x129a	; 0x129a <_ZN6MB1202C1EP9I2CMasterP8emstream>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4bda:	82 e1       	ldi	r24, 0x12	; 18
    4bdc:	90 e0       	ldi	r25, 0x00	; 0
    4bde:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    4be2:	20 e8       	ldi	r18, 0x80	; 128
    4be4:	30 e0       	ldi	r19, 0x00	; 0
    4be6:	40 e0       	ldi	r20, 0x00	; 0
    4be8:	6f ed       	ldi	r22, 0xDF	; 223
    4bea:	71 e2       	ldi	r23, 0x21	; 33
    4bec:	0e 94 5f 0c 	call	0x18be	; 0x18be <_ZN9task_userC1EPKchjP8emstream>
	// new task_sonar( "Sonar", task_priority(2), 128, &ser_dev, &mb1202 );	
	new task_sensor ("Sensor", task_priority (2), 128, &ser_dev, &mma8451);
    4bf0:	88 e1       	ldi	r24, 0x18	; 24
    4bf2:	90 e0       	ldi	r25, 0x00	; 0
    4bf4:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <_Znwj>
    4bf8:	9e 01       	movw	r18, r28
    4bfa:	29 5c       	subi	r18, 0xC9	; 201
    4bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    4bfe:	79 01       	movw	r14, r18
    4c00:	20 e8       	ldi	r18, 0x80	; 128
    4c02:	30 e0       	ldi	r19, 0x00	; 0
    4c04:	42 e0       	ldi	r20, 0x02	; 2
    4c06:	67 ee       	ldi	r22, 0xE7	; 231
    4c08:	71 e2       	ldi	r23, 0x21	; 33
    4c0a:	0e 94 42 0c 	call	0x1884	; 0x1884 <_ZN11task_sensorC1EPKchjP8emstreamP7MMA8451>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4c0e:	87 e0       	ldi	r24, 0x07	; 7
    4c10:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4c14:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4c16:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <vTaskStartScheduler>
}
    4c1a:	80 e0       	ldi	r24, 0x00	; 0
    4c1c:	90 e0       	ldi	r25, 0x00	; 0
    4c1e:	c6 5a       	subi	r28, 0xA6	; 166
    4c20:	df 4f       	sbci	r29, 0xFF	; 255
    4c22:	cd bf       	out	0x3d, r28	; 61
    4c24:	de bf       	out	0x3e, r29	; 62
    4c26:	df 91       	pop	r29
    4c28:	cf 91       	pop	r28
    4c2a:	1f 91       	pop	r17
    4c2c:	0f 91       	pop	r16
    4c2e:	ff 90       	pop	r15
    4c30:	ef 90       	pop	r14
    4c32:	08 95       	ret

00004c34 <_GLOBAL__sub_I_counter>:
    4c34:	cf 92       	push	r12
    4c36:	df 92       	push	r13
    4c38:	ef 92       	push	r14
    4c3a:	ff 92       	push	r15
    4c3c:	0f 93       	push	r16
    4c3e:	1f 93       	push	r17
    4c40:	cf 93       	push	r28
    4c42:	df 93       	push	r29
#include "task_user.h"                      // Header for user interface task
#include "task_sensor.h"
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4c44:	0a e0       	ldi	r16, 0x0A	; 10
    4c46:	10 e0       	ldi	r17, 0x00	; 0
    4c48:	20 e0       	ldi	r18, 0x00	; 0
    4c4a:	30 e0       	ldi	r19, 0x00	; 0
    4c4c:	40 e0       	ldi	r20, 0x00	; 0
    4c4e:	50 e0       	ldi	r21, 0x00	; 0
    4c50:	60 e2       	ldi	r22, 0x20	; 32
    4c52:	70 e0       	ldi	r23, 0x00	; 0
    4c54:	82 ef       	ldi	r24, 0xF2	; 242
    4c56:	92 e3       	ldi	r25, 0x32	; 50
    4c58:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <_ZN14frt_text_queueC1EjP8emstreamm>
    4c5c:	c8 ee       	ldi	r28, 0xE8	; 232
    4c5e:	d2 e3       	ldi	r29, 0x32	; 50
    4c60:	1a 82       	std	Y+2, r1	; 0x02
    4c62:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c64:	82 ef       	ldi	r24, 0xF2	; 242
    4c66:	91 e2       	ldi	r25, 0x21	; 33
    4c68:	88 83       	st	Y, r24
    4c6a:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4c6c:	40 e0       	ldi	r20, 0x00	; 0
    4c6e:	62 e0       	ldi	r22, 0x02	; 2
    4c70:	8f ef       	ldi	r24, 0xFF	; 255
    4c72:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    4c76:	8c 83       	std	Y+4, r24	; 0x04
    4c78:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4c7a:	0f 2e       	mov	r0, r31
    4c7c:	fa e0       	ldi	r31, 0x0A	; 10
    4c7e:	cf 2e       	mov	r12, r31
    4c80:	d1 2c       	mov	r13, r1
    4c82:	e1 2c       	mov	r14, r1
    4c84:	f1 2c       	mov	r15, r1
    4c86:	f0 2d       	mov	r31, r0
    4c88:	ce 82       	std	Y+6, r12	; 0x06
    4c8a:	df 82       	std	Y+7, r13	; 0x07
    4c8c:	e8 86       	std	Y+8, r14	; 0x08
    4c8e:	f9 86       	std	Y+9, r15	; 0x09
    4c90:	ce ed       	ldi	r28, 0xDE	; 222
    4c92:	d2 e3       	ldi	r29, 0x32	; 50
    4c94:	1a 82       	std	Y+2, r1	; 0x02
    4c96:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4c98:	06 e1       	ldi	r16, 0x16	; 22
    4c9a:	12 e2       	ldi	r17, 0x22	; 34
    4c9c:	08 83       	st	Y, r16
    4c9e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ca0:	40 e0       	ldi	r20, 0x00	; 0
    4ca2:	62 e0       	ldi	r22, 0x02	; 2
    4ca4:	8f ef       	ldi	r24, 0xFF	; 255
    4ca6:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    4caa:	8c 83       	std	Y+4, r24	; 0x04
    4cac:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cae:	ce 82       	std	Y+6, r12	; 0x06
    4cb0:	df 82       	std	Y+7, r13	; 0x07
    4cb2:	e8 86       	std	Y+8, r14	; 0x08
    4cb4:	f9 86       	std	Y+9, r15	; 0x09
    4cb6:	c4 ed       	ldi	r28, 0xD4	; 212
    4cb8:	d2 e3       	ldi	r29, 0x32	; 50
    4cba:	1a 82       	std	Y+2, r1	; 0x02
    4cbc:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4cbe:	08 83       	st	Y, r16
    4cc0:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4cc2:	40 e0       	ldi	r20, 0x00	; 0
    4cc4:	62 e0       	ldi	r22, 0x02	; 2
    4cc6:	8f ef       	ldi	r24, 0xFF	; 255
    4cc8:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    4ccc:	8c 83       	std	Y+4, r24	; 0x04
    4cce:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cd0:	ce 82       	std	Y+6, r12	; 0x06
    4cd2:	df 82       	std	Y+7, r13	; 0x07
    4cd4:	e8 86       	std	Y+8, r14	; 0x08
    4cd6:	f9 86       	std	Y+9, r15	; 0x09
    4cd8:	ca ec       	ldi	r28, 0xCA	; 202
    4cda:	d2 e3       	ldi	r29, 0x32	; 50
    4cdc:	1a 82       	std	Y+2, r1	; 0x02
    4cde:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4ce0:	08 83       	st	Y, r16
    4ce2:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4ce4:	40 e0       	ldi	r20, 0x00	; 0
    4ce6:	62 e0       	ldi	r22, 0x02	; 2
    4ce8:	8f ef       	ldi	r24, 0xFF	; 255
    4cea:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    4cee:	8c 83       	std	Y+4, r24	; 0x04
    4cf0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4cf2:	ce 82       	std	Y+6, r12	; 0x06
    4cf4:	df 82       	std	Y+7, r13	; 0x07
    4cf6:	e8 86       	std	Y+8, r14	; 0x08
    4cf8:	f9 86       	std	Y+9, r15	; 0x09
    4cfa:	c0 ec       	ldi	r28, 0xC0	; 192
    4cfc:	d2 e3       	ldi	r29, 0x32	; 50
    4cfe:	1a 82       	std	Y+2, r1	; 0x02
    4d00:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4d02:	08 83       	st	Y, r16
    4d04:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4d06:	40 e0       	ldi	r20, 0x00	; 0
    4d08:	62 e0       	ldi	r22, 0x02	; 2
    4d0a:	8f ef       	ldi	r24, 0xFF	; 255
    4d0c:	0e 94 b5 12 	call	0x256a	; 0x256a <xQueueGenericCreate>
    4d10:	8c 83       	std	Y+4, r24	; 0x04
    4d12:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4d14:	ce 82       	std	Y+6, r12	; 0x06
    4d16:	df 82       	std	Y+7, r13	; 0x07
    4d18:	e8 86       	std	Y+8, r14	; 0x08
    4d1a:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4d1c:	df 91       	pop	r29
    4d1e:	cf 91       	pop	r28
    4d20:	1f 91       	pop	r17
    4d22:	0f 91       	pop	r16
    4d24:	ff 90       	pop	r15
    4d26:	ef 90       	pop	r14
    4d28:	df 90       	pop	r13
    4d2a:	cf 90       	pop	r12
    4d2c:	08 95       	ret

00004d2e <__mulsi3>:
    4d2e:	db 01       	movw	r26, r22
    4d30:	8f 93       	push	r24
    4d32:	9f 93       	push	r25
    4d34:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <__muluhisi3>
    4d38:	bf 91       	pop	r27
    4d3a:	af 91       	pop	r26
    4d3c:	a2 9f       	mul	r26, r18
    4d3e:	80 0d       	add	r24, r0
    4d40:	91 1d       	adc	r25, r1
    4d42:	a3 9f       	mul	r26, r19
    4d44:	90 0d       	add	r25, r0
    4d46:	b2 9f       	mul	r27, r18
    4d48:	90 0d       	add	r25, r0
    4d4a:	11 24       	eor	r1, r1
    4d4c:	08 95       	ret

00004d4e <__udivmodsi4>:
    4d4e:	a1 e2       	ldi	r26, 0x21	; 33
    4d50:	1a 2e       	mov	r1, r26
    4d52:	aa 1b       	sub	r26, r26
    4d54:	bb 1b       	sub	r27, r27
    4d56:	fd 01       	movw	r30, r26
    4d58:	0d c0       	rjmp	.+26     	; 0x4d74 <__udivmodsi4_ep>

00004d5a <__udivmodsi4_loop>:
    4d5a:	aa 1f       	adc	r26, r26
    4d5c:	bb 1f       	adc	r27, r27
    4d5e:	ee 1f       	adc	r30, r30
    4d60:	ff 1f       	adc	r31, r31
    4d62:	a2 17       	cp	r26, r18
    4d64:	b3 07       	cpc	r27, r19
    4d66:	e4 07       	cpc	r30, r20
    4d68:	f5 07       	cpc	r31, r21
    4d6a:	20 f0       	brcs	.+8      	; 0x4d74 <__udivmodsi4_ep>
    4d6c:	a2 1b       	sub	r26, r18
    4d6e:	b3 0b       	sbc	r27, r19
    4d70:	e4 0b       	sbc	r30, r20
    4d72:	f5 0b       	sbc	r31, r21

00004d74 <__udivmodsi4_ep>:
    4d74:	66 1f       	adc	r22, r22
    4d76:	77 1f       	adc	r23, r23
    4d78:	88 1f       	adc	r24, r24
    4d7a:	99 1f       	adc	r25, r25
    4d7c:	1a 94       	dec	r1
    4d7e:	69 f7       	brne	.-38     	; 0x4d5a <__udivmodsi4_loop>
    4d80:	60 95       	com	r22
    4d82:	70 95       	com	r23
    4d84:	80 95       	com	r24
    4d86:	90 95       	com	r25
    4d88:	9b 01       	movw	r18, r22
    4d8a:	ac 01       	movw	r20, r24
    4d8c:	bd 01       	movw	r22, r26
    4d8e:	cf 01       	movw	r24, r30
    4d90:	08 95       	ret

00004d92 <__divmodsi4>:
    4d92:	05 2e       	mov	r0, r21
    4d94:	97 fb       	bst	r25, 7
    4d96:	1e f4       	brtc	.+6      	; 0x4d9e <__divmodsi4+0xc>
    4d98:	00 94       	com	r0
    4d9a:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <__negsi2>
    4d9e:	57 fd       	sbrc	r21, 7
    4da0:	07 d0       	rcall	.+14     	; 0x4db0 <__divmodsi4_neg2>
    4da2:	0e 94 a7 26 	call	0x4d4e	; 0x4d4e <__udivmodsi4>
    4da6:	07 fc       	sbrc	r0, 7
    4da8:	03 d0       	rcall	.+6      	; 0x4db0 <__divmodsi4_neg2>
    4daa:	4e f4       	brtc	.+18     	; 0x4dbe <__divmodsi4_exit>
    4dac:	0c 94 e0 26 	jmp	0x4dc0	; 0x4dc0 <__negsi2>

00004db0 <__divmodsi4_neg2>:
    4db0:	50 95       	com	r21
    4db2:	40 95       	com	r20
    4db4:	30 95       	com	r19
    4db6:	21 95       	neg	r18
    4db8:	3f 4f       	sbci	r19, 0xFF	; 255
    4dba:	4f 4f       	sbci	r20, 0xFF	; 255
    4dbc:	5f 4f       	sbci	r21, 0xFF	; 255

00004dbe <__divmodsi4_exit>:
    4dbe:	08 95       	ret

00004dc0 <__negsi2>:
    4dc0:	90 95       	com	r25
    4dc2:	80 95       	com	r24
    4dc4:	70 95       	com	r23
    4dc6:	61 95       	neg	r22
    4dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    4dca:	8f 4f       	sbci	r24, 0xFF	; 255
    4dcc:	9f 4f       	sbci	r25, 0xFF	; 255
    4dce:	08 95       	ret

00004dd0 <__tablejump2__>:
    4dd0:	ee 0f       	add	r30, r30
    4dd2:	ff 1f       	adc	r31, r31
    4dd4:	88 1f       	adc	r24, r24
    4dd6:	8b bf       	out	0x3b, r24	; 59
    4dd8:	07 90       	elpm	r0, Z+
    4dda:	f6 91       	elpm	r31, Z
    4ddc:	e0 2d       	mov	r30, r0
    4dde:	1b be       	out	0x3b, r1	; 59
    4de0:	19 94       	eijmp

00004de2 <__muluhisi3>:
    4de2:	0e 94 fc 26 	call	0x4df8	; 0x4df8 <__umulhisi3>
    4de6:	a5 9f       	mul	r26, r21
    4de8:	90 0d       	add	r25, r0
    4dea:	b4 9f       	mul	r27, r20
    4dec:	90 0d       	add	r25, r0
    4dee:	a4 9f       	mul	r26, r20
    4df0:	80 0d       	add	r24, r0
    4df2:	91 1d       	adc	r25, r1
    4df4:	11 24       	eor	r1, r1
    4df6:	08 95       	ret

00004df8 <__umulhisi3>:
    4df8:	a2 9f       	mul	r26, r18
    4dfa:	b0 01       	movw	r22, r0
    4dfc:	b3 9f       	mul	r27, r19
    4dfe:	c0 01       	movw	r24, r0
    4e00:	a3 9f       	mul	r26, r19
    4e02:	70 0d       	add	r23, r0
    4e04:	81 1d       	adc	r24, r1
    4e06:	11 24       	eor	r1, r1
    4e08:	91 1d       	adc	r25, r1
    4e0a:	b2 9f       	mul	r27, r18
    4e0c:	70 0d       	add	r23, r0
    4e0e:	81 1d       	adc	r24, r1
    4e10:	11 24       	eor	r1, r1
    4e12:	91 1d       	adc	r25, r1
    4e14:	08 95       	ret

00004e16 <memcpy>:
    4e16:	fb 01       	movw	r30, r22
    4e18:	dc 01       	movw	r26, r24
    4e1a:	02 c0       	rjmp	.+4      	; 0x4e20 <memcpy+0xa>
    4e1c:	01 90       	ld	r0, Z+
    4e1e:	0d 92       	st	X+, r0
    4e20:	41 50       	subi	r20, 0x01	; 1
    4e22:	50 40       	sbci	r21, 0x00	; 0
    4e24:	d8 f7       	brcc	.-10     	; 0x4e1c <memcpy+0x6>
    4e26:	08 95       	ret

00004e28 <memset>:
    4e28:	dc 01       	movw	r26, r24
    4e2a:	01 c0       	rjmp	.+2      	; 0x4e2e <memset+0x6>
    4e2c:	6d 93       	st	X+, r22
    4e2e:	41 50       	subi	r20, 0x01	; 1
    4e30:	50 40       	sbci	r21, 0x00	; 0
    4e32:	e0 f7       	brcc	.-8      	; 0x4e2c <memset+0x4>
    4e34:	08 95       	ret

00004e36 <strncpy>:
    4e36:	fb 01       	movw	r30, r22
    4e38:	dc 01       	movw	r26, r24
    4e3a:	41 50       	subi	r20, 0x01	; 1
    4e3c:	50 40       	sbci	r21, 0x00	; 0
    4e3e:	48 f0       	brcs	.+18     	; 0x4e52 <strncpy+0x1c>
    4e40:	01 90       	ld	r0, Z+
    4e42:	0d 92       	st	X+, r0
    4e44:	00 20       	and	r0, r0
    4e46:	c9 f7       	brne	.-14     	; 0x4e3a <strncpy+0x4>
    4e48:	01 c0       	rjmp	.+2      	; 0x4e4c <strncpy+0x16>
    4e4a:	1d 92       	st	X+, r1
    4e4c:	41 50       	subi	r20, 0x01	; 1
    4e4e:	50 40       	sbci	r21, 0x00	; 0
    4e50:	e0 f7       	brcc	.-8      	; 0x4e4a <strncpy+0x14>
    4e52:	08 95       	ret

00004e54 <ultoa>:
    4e54:	25 32       	cpi	r18, 0x25	; 37
    4e56:	31 05       	cpc	r19, r1
    4e58:	20 f4       	brcc	.+8      	; 0x4e62 <ultoa+0xe>
    4e5a:	22 30       	cpi	r18, 0x02	; 2
    4e5c:	10 f0       	brcs	.+4      	; 0x4e62 <ultoa+0xe>
    4e5e:	0c 94 35 27 	jmp	0x4e6a	; 0x4e6a <__ultoa_ncheck>
    4e62:	fa 01       	movw	r30, r20
    4e64:	10 82       	st	Z, r1
    4e66:	ca 01       	movw	r24, r20
    4e68:	08 95       	ret

00004e6a <__ultoa_ncheck>:
    4e6a:	bb 27       	eor	r27, r27

00004e6c <__ultoa_common>:
    4e6c:	fa 01       	movw	r30, r20
    4e6e:	a6 2f       	mov	r26, r22
    4e70:	62 17       	cp	r22, r18
    4e72:	71 05       	cpc	r23, r1
    4e74:	81 05       	cpc	r24, r1
    4e76:	91 05       	cpc	r25, r1
    4e78:	33 0b       	sbc	r19, r19
    4e7a:	30 fb       	bst	r19, 0
    4e7c:	66 f0       	brts	.+24     	; 0x4e96 <__ultoa_common+0x2a>
    4e7e:	aa 27       	eor	r26, r26
    4e80:	66 0f       	add	r22, r22
    4e82:	77 1f       	adc	r23, r23
    4e84:	88 1f       	adc	r24, r24
    4e86:	99 1f       	adc	r25, r25
    4e88:	aa 1f       	adc	r26, r26
    4e8a:	a2 17       	cp	r26, r18
    4e8c:	10 f0       	brcs	.+4      	; 0x4e92 <__ultoa_common+0x26>
    4e8e:	a2 1b       	sub	r26, r18
    4e90:	63 95       	inc	r22
    4e92:	38 50       	subi	r19, 0x08	; 8
    4e94:	a9 f7       	brne	.-22     	; 0x4e80 <__ultoa_common+0x14>
    4e96:	a0 5d       	subi	r26, 0xD0	; 208
    4e98:	aa 33       	cpi	r26, 0x3A	; 58
    4e9a:	08 f0       	brcs	.+2      	; 0x4e9e <__ultoa_common+0x32>
    4e9c:	a9 5d       	subi	r26, 0xD9	; 217
    4e9e:	a1 93       	st	Z+, r26
    4ea0:	36 f7       	brtc	.-52     	; 0x4e6e <__ultoa_common+0x2>
    4ea2:	b1 11       	cpse	r27, r1
    4ea4:	b1 93       	st	Z+, r27
    4ea6:	10 82       	st	Z, r1
    4ea8:	ca 01       	movw	r24, r20
    4eaa:	0c 94 7c 27 	jmp	0x4ef8	; 0x4ef8 <strrev>

00004eae <utoa>:
    4eae:	45 32       	cpi	r20, 0x25	; 37
    4eb0:	51 05       	cpc	r21, r1
    4eb2:	20 f4       	brcc	.+8      	; 0x4ebc <utoa+0xe>
    4eb4:	42 30       	cpi	r20, 0x02	; 2
    4eb6:	10 f0       	brcs	.+4      	; 0x4ebc <utoa+0xe>
    4eb8:	0c 94 62 27 	jmp	0x4ec4	; 0x4ec4 <__utoa_ncheck>
    4ebc:	fb 01       	movw	r30, r22
    4ebe:	10 82       	st	Z, r1
    4ec0:	cb 01       	movw	r24, r22
    4ec2:	08 95       	ret

00004ec4 <__utoa_ncheck>:
    4ec4:	bb 27       	eor	r27, r27

00004ec6 <__utoa_common>:
    4ec6:	fb 01       	movw	r30, r22
    4ec8:	55 27       	eor	r21, r21
    4eca:	aa 27       	eor	r26, r26
    4ecc:	88 0f       	add	r24, r24
    4ece:	99 1f       	adc	r25, r25
    4ed0:	aa 1f       	adc	r26, r26
    4ed2:	a4 17       	cp	r26, r20
    4ed4:	10 f0       	brcs	.+4      	; 0x4eda <__utoa_common+0x14>
    4ed6:	a4 1b       	sub	r26, r20
    4ed8:	83 95       	inc	r24
    4eda:	50 51       	subi	r21, 0x10	; 16
    4edc:	b9 f7       	brne	.-18     	; 0x4ecc <__utoa_common+0x6>
    4ede:	a0 5d       	subi	r26, 0xD0	; 208
    4ee0:	aa 33       	cpi	r26, 0x3A	; 58
    4ee2:	08 f0       	brcs	.+2      	; 0x4ee6 <__utoa_common+0x20>
    4ee4:	a9 5d       	subi	r26, 0xD9	; 217
    4ee6:	a1 93       	st	Z+, r26
    4ee8:	00 97       	sbiw	r24, 0x00	; 0
    4eea:	79 f7       	brne	.-34     	; 0x4eca <__utoa_common+0x4>
    4eec:	b1 11       	cpse	r27, r1
    4eee:	b1 93       	st	Z+, r27
    4ef0:	11 92       	st	Z+, r1
    4ef2:	cb 01       	movw	r24, r22
    4ef4:	0c 94 7c 27 	jmp	0x4ef8	; 0x4ef8 <strrev>

00004ef8 <strrev>:
    4ef8:	dc 01       	movw	r26, r24
    4efa:	fc 01       	movw	r30, r24
    4efc:	67 2f       	mov	r22, r23
    4efe:	71 91       	ld	r23, Z+
    4f00:	77 23       	and	r23, r23
    4f02:	e1 f7       	brne	.-8      	; 0x4efc <strrev+0x4>
    4f04:	32 97       	sbiw	r30, 0x02	; 2
    4f06:	04 c0       	rjmp	.+8      	; 0x4f10 <strrev+0x18>
    4f08:	7c 91       	ld	r23, X
    4f0a:	6d 93       	st	X+, r22
    4f0c:	70 83       	st	Z, r23
    4f0e:	62 91       	ld	r22, -Z
    4f10:	ae 17       	cp	r26, r30
    4f12:	bf 07       	cpc	r27, r31
    4f14:	c8 f3       	brcs	.-14     	; 0x4f08 <strrev+0x10>
    4f16:	08 95       	ret

00004f18 <_exit>:
    4f18:	f8 94       	cli

00004f1a <__stop_program>:
    4f1a:	ff cf       	rjmp	.-2      	; 0x4f1a <__stop_program>
