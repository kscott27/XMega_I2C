
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003ffe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c8  00802000  00003ffe  00004092  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020c8  008020c8  0000415a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000415a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000418c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007d0  00000000  00000000  000041cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011c2f  00000000  00000000  0000499c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005de9  00000000  00000000  000165cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005169  00000000  00000000  0001c3b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001674  00000000  00000000  00021520  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005942  00000000  00000000  00022b94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006cd3  00000000  00000000  000284d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000710  00000000  00000000  0002f1a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 02 	jmp	0x5ca	; 0x5ca <__ctors_end>
       4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
       8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
       c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      10:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      14:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      18:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      1c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      20:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      24:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      28:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      2c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      30:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      34:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      38:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      3c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      40:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      44:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      48:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      4c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      50:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      54:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      58:	0c 94 43 0a 	jmp	0x1486	; 0x1486 <__vector_22>
      5c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      60:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      64:	0c 94 18 1a 	jmp	0x3430	; 0x3430 <__vector_25>
      68:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      6c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      70:	0c 94 76 1a 	jmp	0x34ec	; 0x34ec <__vector_28>
      74:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      78:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      7c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      80:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      84:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      88:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      8c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      90:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      94:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      98:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      9c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      a0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      a4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      a8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      ac:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      b0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      b4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      b8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      bc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      c0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      c4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      c8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      cc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      d0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      d4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      d8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      dc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      e0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      e4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      e8:	0c 94 90 1b 	jmp	0x3720	; 0x3720 <__vector_58>
      ec:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      f0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      f4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      f8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
      fc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     100:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     104:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     108:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     10c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     110:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     114:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     118:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     11c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     120:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     124:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     128:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     12c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     130:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     134:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     138:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     13c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     140:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     144:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     148:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     14c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     150:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     154:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     158:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     15c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     160:	0c 94 d4 1a 	jmp	0x35a8	; 0x35a8 <__vector_88>
     164:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     168:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     16c:	0c 94 32 1b 	jmp	0x3664	; 0x3664 <__vector_91>
     170:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     174:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     178:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     17c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     180:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     184:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     188:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     18c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     190:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     194:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     198:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     19c:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1a0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1a4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1a8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1ac:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1b0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1b4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1b8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1bc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1c0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1c4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1c8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1cc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1d0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1d4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1d8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1dc:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1e0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1e4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1e8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1ec:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1f0:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1f4:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1f8:	0c 94 1b 03 	jmp	0x636	; 0x636 <__bad_interrupt>
     1fc:	04 18       	sub	r0, r4
     1fe:	07 18       	sub	r0, r7
     200:	0a 18       	sub	r0, r10
     202:	0d 18       	sub	r0, r13
     204:	10 18       	sub	r1, r0
     206:	13 18       	sub	r1, r3
     208:	15 18       	sub	r1, r5
     20a:	26 18       	sub	r2, r6
     20c:	2e 18       	sub	r2, r14
     20e:	38 18       	sub	r3, r8
     210:	36 18       	sub	r3, r6

00000212 <__trampolines_start>:
     212:	0c 94 94 1d 	jmp	0x3b28	; 0x3b28 <_ZN9frt_queueIiE7ISR_putERKi>
     216:	0c 94 fa 1c 	jmp	0x39f4	; 0x39f4 <_ZN9frt_queueIjE7ISR_getEPj>
     21a:	0c 94 2e 18 	jmp	0x305c	; 0x305c <_ZN8emstreamlsE15ser_manipulator+0x72>
     21e:	0c 94 a7 17 	jmp	0x2f4e	; 0x2f4e <_ZN8emstream13ready_to_sendEv>
     222:	0c 94 e5 13 	jmp	0x27ca	; 0x27ca <_ZN8frt_task12print_statusER8emstream>
     226:	0c 94 5e 1c 	jmp	0x38bc	; 0x38bc <_ZN9frt_queueIjE10get_a_copyERj>
     22a:	0c 94 58 15 	jmp	0x2ab0	; 0x2ab0 <_ZN14frt_text_queue7putcharEc>
     22e:	0c 94 64 1d 	jmp	0x3ac8	; 0x3ac8 <_ZN9frt_queueIjE7ISR_putERKj>
     232:	0c 94 04 18 	jmp	0x3008	; 0x3008 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     236:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <_ZN9frt_queueIiE3getEPi>
     23a:	0c 94 00 1c 	jmp	0x3800	; 0x3800 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     23e:	0c 94 07 18 	jmp	0x300e	; 0x300e <_ZN8emstreamlsE15ser_manipulator+0x24>
     242:	0c 94 df 1c 	jmp	0x39be	; 0x39be <_ZN9frt_queueIiE3getEv>
     246:	0c 94 38 1c 	jmp	0x3870	; 0x3870 <_ZN9frt_queueIjE8is_emptyEv>
     24a:	0c 94 91 1c 	jmp	0x3922	; 0x3922 <_ZN9frt_queueIjE3getEv>
     24e:	0c 94 0d 18 	jmp	0x301a	; 0x301a <_ZN8emstreamlsE15ser_manipulator+0x30>
     252:	0c 94 8f 19 	jmp	0x331e	; 0x331e <_ZN5rs23212clear_screenEv>
     256:	0c 94 1c 1c 	jmp	0x3838	; 0x3838 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     25a:	0c 94 85 1c 	jmp	0x390a	; 0x390a <_ZN9frt_queueIjE3getEPj>
     25e:	0c 94 a9 17 	jmp	0x2f52	; 0x2f52 <_ZN8emstream7getcharEv>
     262:	0c 94 32 19 	jmp	0x3264	; 0x3264 <_ZN5rs2327putcharEc>
     266:	0c 94 13 18 	jmp	0x3026	; 0x3026 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     26a:	0c 94 23 1d 	jmp	0x3a46	; 0x3a46 <_ZN9frt_queueIiE7ISR_getEPi>
     26e:	0c 94 f5 1b 	jmp	0x37ea	; 0x37ea <_ZN9frt_queueIjE13ISR_not_emptyEv>
     272:	0c 94 7c 1d 	jmp	0x3af8	; 0x3af8 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     276:	0c 94 7c 19 	jmp	0x32f8	; 0x32f8 <_ZN5rs23214check_for_charEv>
     27a:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <prvIdleTask>
     27e:	0c 94 38 18 	jmp	0x3070	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
     282:	0c 94 11 1c 	jmp	0x3822	; 0x3822 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     286:	0c 94 0a 1c 	jmp	0x3814	; 0x3814 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     28a:	0c 94 e2 02 	jmp	0x5c4	; 0x5c4 <_call_static_run_method>
     28e:	0c 94 e2 1d 	jmp	0x3bc4	; 0x3bc4 <_ZN9frt_queueIiE3putERKi>
     292:	0c 94 d0 1d 	jmp	0x3ba0	; 0x3ba0 <_ZN9frt_queueIiE7butt_inERKi>
     296:	0c 94 6a 1c 	jmp	0x38d4	; 0x38d4 <_ZN9frt_queueIjE10get_a_copyEv>
     29a:	0c 94 81 04 	jmp	0x902	; 0x902 <_ZN10task_sonar3runEv>
     29e:	0c 94 b8 1c 	jmp	0x3970	; 0x3970 <_ZN9frt_queueIiE10get_a_copyEv>
     2a2:	0c 94 0a 18 	jmp	0x3014	; 0x3014 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     2a6:	0c 94 56 19 	jmp	0x32ac	; 0x32ac <_ZN5rs2327getcharEv>
     2aa:	0c 94 ac 17 	jmp	0x2f58	; 0x2f58 <_ZN8emstream14check_for_charEv>
     2ae:	0c 94 2f 15 	jmp	0x2a5e	; 0x2a5e <_ZN14frt_text_queue7getcharEv>
     2b2:	0c 94 26 18 	jmp	0x304c	; 0x304c <_ZN8emstreamlsE15ser_manipulator+0x62>
     2b6:	0c 94 ee 1b 	jmp	0x37dc	; 0x37dc <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2ba:	0c 94 8b 1e 	jmp	0x3d16	; 0x3d16 <_GLOBAL__sub_I_counter>
     2be:	0c 94 4d 15 	jmp	0x2a9a	; 0x2a9a <_ZN14frt_text_queue14check_for_charEv>
     2c2:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <_ZN9frt_queueIiE10get_a_copyERi>
     2c6:	0c 94 34 1d 	jmp	0x3a68	; 0x3a68 <_ZN9frt_queueIiE7ISR_getEv>
     2ca:	0c 94 10 17 	jmp	0x2e20	; 0x2e20 <__cxa_pure_virtual>
     2ce:	0c 94 af 17 	jmp	0x2f5e	; 0x2f5e <_ZN8emstream12clear_screenEv>
     2d2:	0c 94 36 18 	jmp	0x306c	; 0x306c <_ZN8emstreamlsE15ser_manipulator+0x82>
     2d6:	0c 94 42 1c 	jmp	0x3884	; 0x3884 <_ZN9frt_queueIiE12num_items_inEv>
     2da:	0c 94 26 1c 	jmp	0x384c	; 0x384c <_ZN9frt_queueIjE12num_items_inEv>
     2de:	0c 94 49 1c 	jmp	0x3892	; 0x3892 <_ZN9frt_queueIiE9not_emptyEv>
     2e2:	0c 94 0b 1d 	jmp	0x3a16	; 0x3a16 <_ZN9frt_queueIjE7ISR_getEv>
     2e6:	0c 94 4c 1d 	jmp	0x3a98	; 0x3a98 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     2ea:	0c 94 ae 17 	jmp	0x2f5c	; 0x2f5c <_ZN8emstream12transmit_nowEv>
     2ee:	0c 94 10 18 	jmp	0x3020	; 0x3020 <_ZN8emstreamlsE15ser_manipulator+0x36>
     2f2:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <_ZN9frt_queueIjE9not_emptyEv>
     2f6:	0c 94 ac 1d 	jmp	0x3b58	; 0x3b58 <_ZN9frt_queueIjE7butt_inERKj>
     2fa:	0c 94 1f 06 	jmp	0xc3e	; 0xc3e <_ZN9task_user3runEv>
     2fe:	0c 94 15 18 	jmp	0x302a	; 0x302a <_ZN8emstreamlsE15ser_manipulator+0x40>
     302:	0c 94 be 1d 	jmp	0x3b7c	; 0x3b7c <_ZN9frt_queueIjE3putERKj>
     306:	0c 94 54 1c 	jmp	0x38a8	; 0x38a8 <_ZN9frt_queueIiE8is_emptyEv>

0000030a <__trampolines_end>:
     30a:	53 6f       	ori	r21, 0xF3	; 243
     30c:	6e 61       	ori	r22, 0x1E	; 30
     30e:	72 3a       	cpi	r23, 0xA2	; 162
     310:	20 00       	.word	0x0020	; ????

00000312 <_ZZN9task_user11show_statusEvE3__c_4>:
     312:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

0000031d <_ZZN9task_user11show_statusEvE3__c_3>:
     31d:	2f 00                                               /.

0000031f <_ZZN9task_user11show_statusEvE3__c_2>:
     31f:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

0000032d <_ZZN9task_user11show_statusEvE3__c_1>:
     32d:	54 69 6d 65 3a 20 00                                Time: .

00000334 <_ZZN9task_user11show_statusEvE3__c_0>:
     334:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

00000340 <_ZZN9task_user11show_statusEvE3__c>:
     340:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     350:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000035f <_ZZN9task_user18print_help_messageEvE3__c_10>:
     35f:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000036e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     36e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     37e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000389 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     389:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     399:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003a7 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3a7:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3b7:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3c7:	6d 61 74 69 6f 6e 00                                mation.

000003ce <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3ce:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3de:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003ef <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3ef:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     3ff:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000407 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     407:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     417:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000423 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     423:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     433:	68 65 20 41 56 52 00                                he AVR.

0000043a <_ZZN9task_user18print_help_messageEvE3__c_2>:
     43a:	20 68 65 6c 70 00                                    help.

00000440 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     440:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     450:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000045f <_ZZN9task_user18print_help_messageEvE3__c_0>:
     45f:	1b 5b 33 30 6d 00                                   .[30m.

00000465 <_ZZN9task_user18print_help_messageEvE3__c>:
     465:	1b 5b 34 36 6d 00                                   .[46m.

0000046b <_ZZN9task_user3runEvE3__c_3>:
     46b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     47b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000488 <_ZZN9task_user3runEvE3__c_2>:
     488:	3a 57 54 46 3f 00                                   :WTF?.

0000048e <_ZZN9task_user3runEvE3__c_1>:
     48e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     49e:	65 00                                               e.

000004a0 <_ZZN9task_user3runEvE3__c_0>:
     4a0:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004ae <_ZZN9task_user3runEvE3__c>:
     4ae:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4be:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004cc <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4cc:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004d6 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4d6:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004e5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4e5:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     4f5:	61 73 6b 20 00                                      ask .

000004fa <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     4fa:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000508 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     508:	20 63 72 65 61 74 65 64 00                           created.

00000511 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     511:	54 61 73 6b 20 00                                   Task .

00000517 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     517:	1b 5b 32 32 6d 00                                   .[22m.

0000051d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     51d:	54 61 73 6b 3a 20 00                                Task: .

00000524 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     524:	1b 5b 31 6d 00                                      .[1m.

00000529 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     529:	1b 5b 32 32 6d 00                                   .[22m.

0000052f <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     52f:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

0000053a <_ZZ17print_task_stacksP8emstreamE3__c>:
     53a:	1b 5b 31 6d 00                                      .[1m.

0000053f <_ZZ15print_task_listP8emstreamE3__c_9>:
     53f:	09 09 00                                            ...

00000542 <_ZZ15print_task_listP8emstreamE3__c_8>:
     542:	2f 00                                               /.

00000544 <_ZZ15print_task_listP8emstreamE3__c_7>:
     544:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000054f <_ZZ15print_task_listP8emstreamE3__c_6>:
     54f:	09 2d 2d 2d 2d 00                                   .----.

00000555 <_ZZ15print_task_listP8emstreamE3__c_5>:
     555:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000561 <_ZZ15print_task_listP8emstreamE3__c_4>:
     561:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000572 <_ZZ15print_task_listP8emstreamE3__c_3>:
     572:	09 52 75 6e 73 00                                   .Runs.

00000578 <_ZZ15print_task_listP8emstreamE3__c_2>:
     578:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000584 <_ZZ15print_task_listP8emstreamE3__c_1>:
     584:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000595 <_ZZ15print_task_listP8emstreamE3__c_0>:
     595:	09 53 74 61 63 6b 00                                .Stack.

0000059c <_ZZ15print_task_listP8emstreamE3__c>:
     59c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005a7 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5a7:	09 00                                               ..

000005a9 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5a9:	09 00                                               ..

000005ab <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5ab:	2f 00                                               /.

000005ad <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5ad:	09 00                                               ..

000005af <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5af:	09 00                                               ..

000005b1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5b1:	1b 5b 32 32 6d 00                                   .[22m.

000005b7 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5b7:	1b 5b 31 6d 00                                      .[1m.

000005bc <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5bc:	1b 5b 31 6d 00                                      .[1m.

000005c1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5c1:	20 20 00                                              .

000005c4 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5c4:	0e 94 7d 12 	call	0x24fa	; 0x24fa <_ZN8frt_task22_call_users_run_methodEPS_>

000005c8 <__ctors_start>:
     5c8:	8b 1e       	adc	r8, r27

000005ca <__ctors_end>:
     5ca:	11 24       	eor	r1, r1
     5cc:	1f be       	out	0x3f, r1	; 63
     5ce:	cf ef       	ldi	r28, 0xFF	; 255
     5d0:	cd bf       	out	0x3d, r28	; 61
     5d2:	df e3       	ldi	r29, 0x3F	; 63
     5d4:	de bf       	out	0x3e, r29	; 62
     5d6:	00 e0       	ldi	r16, 0x00	; 0
     5d8:	0c bf       	out	0x3c, r16	; 60
     5da:	18 be       	out	0x38, r1	; 56
     5dc:	19 be       	out	0x39, r1	; 57
     5de:	1a be       	out	0x3a, r1	; 58
     5e0:	1b be       	out	0x3b, r1	; 59

000005e2 <__do_copy_data>:
     5e2:	10 e2       	ldi	r17, 0x20	; 32
     5e4:	a0 e0       	ldi	r26, 0x00	; 0
     5e6:	b0 e2       	ldi	r27, 0x20	; 32
     5e8:	ee ef       	ldi	r30, 0xFE	; 254
     5ea:	ff e3       	ldi	r31, 0x3F	; 63
     5ec:	00 e0       	ldi	r16, 0x00	; 0
     5ee:	0b bf       	out	0x3b, r16	; 59
     5f0:	02 c0       	rjmp	.+4      	; 0x5f6 <__do_copy_data+0x14>
     5f2:	07 90       	elpm	r0, Z+
     5f4:	0d 92       	st	X+, r0
     5f6:	a8 3c       	cpi	r26, 0xC8	; 200
     5f8:	b1 07       	cpc	r27, r17
     5fa:	d9 f7       	brne	.-10     	; 0x5f2 <__do_copy_data+0x10>
     5fc:	1b be       	out	0x3b, r1	; 59

000005fe <__do_clear_bss>:
     5fe:	21 e3       	ldi	r18, 0x31	; 49
     600:	a8 ec       	ldi	r26, 0xC8	; 200
     602:	b0 e2       	ldi	r27, 0x20	; 32
     604:	01 c0       	rjmp	.+2      	; 0x608 <.do_clear_bss_start>

00000606 <.do_clear_bss_loop>:
     606:	1d 92       	st	X+, r1

00000608 <.do_clear_bss_start>:
     608:	a6 39       	cpi	r26, 0x96	; 150
     60a:	b2 07       	cpc	r27, r18
     60c:	e1 f7       	brne	.-8      	; 0x606 <.do_clear_bss_loop>

0000060e <__do_global_ctors>:
     60e:	12 e0       	ldi	r17, 0x02	; 2
     610:	c5 ee       	ldi	r28, 0xE5	; 229
     612:	d2 e0       	ldi	r29, 0x02	; 2
     614:	00 e0       	ldi	r16, 0x00	; 0
     616:	06 c0       	rjmp	.+12     	; 0x624 <__do_global_ctors+0x16>
     618:	21 97       	sbiw	r28, 0x01	; 1
     61a:	01 09       	sbc	r16, r1
     61c:	80 2f       	mov	r24, r16
     61e:	fe 01       	movw	r30, r28
     620:	0e 94 59 1f 	call	0x3eb2	; 0x3eb2 <__tablejump2__>
     624:	c4 3e       	cpi	r28, 0xE4	; 228
     626:	d1 07       	cpc	r29, r17
     628:	80 e0       	ldi	r24, 0x00	; 0
     62a:	08 07       	cpc	r16, r24
     62c:	a9 f7       	brne	.-22     	; 0x618 <__do_global_ctors+0xa>
     62e:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <main>
     632:	0c 94 fd 1f 	jmp	0x3ffa	; 0x3ffa <_exit>

00000636 <__bad_interrupt>:
     636:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000063a <_ZN9I2CMaster12set_baudrateEm>:
	}
	else
	{
		return false;
	}
}
     63a:	cf 93       	push	r28
     63c:	df 93       	push	r29
     63e:	ec 01       	movw	r28, r24
     640:	9a 01       	movw	r18, r20
     642:	ab 01       	movw	r20, r22
     644:	22 0f       	add	r18, r18
     646:	33 1f       	adc	r19, r19
     648:	44 1f       	adc	r20, r20
     64a:	55 1f       	adc	r21, r21
     64c:	60 e0       	ldi	r22, 0x00	; 0
     64e:	78 e4       	ldi	r23, 0x48	; 72
     650:	88 ee       	ldi	r24, 0xE8	; 232
     652:	91 e0       	ldi	r25, 0x01	; 1
     654:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
     658:	25 50       	subi	r18, 0x05	; 5
     65a:	2c 83       	std	Y+4, r18	; 0x04
     65c:	e8 81       	ld	r30, Y
     65e:	f9 81       	ldd	r31, Y+1	; 0x01
     660:	25 83       	std	Z+5, r18	; 0x05
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	08 95       	ret

00000668 <_ZN9I2CMasterC1EP10TWI_structm>:
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	fc 01       	movw	r30, r24
     66e:	eb 01       	movw	r28, r22
     670:	ba 01       	movw	r22, r20
     672:	a9 01       	movw	r20, r18
     674:	c0 83       	st	Z, r28
     676:	d1 83       	std	Z+1, r29	; 0x01
     678:	45 83       	std	Z+5, r20	; 0x05
     67a:	56 83       	std	Z+6, r21	; 0x06
     67c:	67 83       	std	Z+7, r22	; 0x07
     67e:	70 87       	std	Z+8, r23	; 0x08
     680:	c0 38       	cpi	r28, 0x80	; 128
     682:	84 e0       	ldi	r24, 0x04	; 4
     684:	d8 07       	cpc	r29, r24
     686:	29 f4       	brne	.+10     	; 0x692 <_ZN9I2CMasterC1EP10TWI_structm+0x2a>
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	96 e0       	ldi	r25, 0x06	; 6
     68c:	82 83       	std	Z+2, r24	; 0x02
     68e:	93 83       	std	Z+3, r25	; 0x03
     690:	08 c0       	rjmp	.+16     	; 0x6a2 <_ZN9I2CMasterC1EP10TWI_structm+0x3a>
     692:	c0 3a       	cpi	r28, 0xA0	; 160
     694:	84 e0       	ldi	r24, 0x04	; 4
     696:	d8 07       	cpc	r29, r24
     698:	21 f4       	brne	.+8      	; 0x6a2 <_ZN9I2CMasterC1EP10TWI_structm+0x3a>
     69a:	80 e8       	ldi	r24, 0x80	; 128
     69c:	96 e0       	ldi	r25, 0x06	; 6
     69e:	82 83       	std	Z+2, r24	; 0x02
     6a0:	93 83       	std	Z+3, r25	; 0x03
     6a2:	a2 81       	ldd	r26, Z+2	; 0x02
     6a4:	b3 81       	ldd	r27, Z+3	; 0x03
     6a6:	83 e0       	ldi	r24, 0x03	; 3
     6a8:	11 96       	adiw	r26, 0x01	; 1
     6aa:	8c 93       	st	X, r24
     6ac:	a2 81       	ldd	r26, Z+2	; 0x02
     6ae:	b3 81       	ldd	r27, Z+3	; 0x03
     6b0:	88 e3       	ldi	r24, 0x38	; 56
     6b2:	50 96       	adiw	r26, 0x10	; 16
     6b4:	8c 93       	st	X, r24
     6b6:	a2 81       	ldd	r26, Z+2	; 0x02
     6b8:	b3 81       	ldd	r27, Z+3	; 0x03
     6ba:	51 96       	adiw	r26, 0x11	; 17
     6bc:	8c 93       	st	X, r24
     6be:	82 e0       	ldi	r24, 0x02	; 2
     6c0:	8a 83       	std	Y+2, r24	; 0x02
     6c2:	cf 01       	movw	r24, r30
     6c4:	0e 94 1d 03 	call	0x63a	; 0x63a <_ZN9I2CMaster12set_baudrateEm>
     6c8:	8c 81       	ldd	r24, Y+4	; 0x04
     6ca:	8d 6c       	ori	r24, 0xCD	; 205
     6cc:	8c 83       	std	Y+4, r24	; 0x04
     6ce:	88 e0       	ldi	r24, 0x08	; 8
     6d0:	89 83       	std	Y+1, r24	; 0x01
     6d2:	df 91       	pop	r29
     6d4:	cf 91       	pop	r28
     6d6:	08 95       	ret

000006d8 <_ZN9I2CMaster5writeEhPhhj>:
     6d8:	0f 93       	push	r16
     6da:	1f 93       	push	r17
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	1f 92       	push	r1
     6e2:	1f 92       	push	r1
     6e4:	cd b7       	in	r28, 0x3d	; 61
     6e6:	de b7       	in	r29, 0x3e	; 62
     6e8:	dc 01       	movw	r26, r24
     6ea:	09 83       	std	Y+1, r16	; 0x01
     6ec:	1a 83       	std	Y+2, r17	; 0x02
     6ee:	ed 91       	ld	r30, X+
     6f0:	fc 91       	ld	r31, X
     6f2:	11 97       	sbiw	r26, 0x01	; 1
     6f4:	66 0f       	add	r22, r22
     6f6:	66 83       	std	Z+6, r22	; 0x06
     6f8:	89 81       	ldd	r24, Y+1	; 0x01
     6fa:	9a 81       	ldd	r25, Y+2	; 0x02
     6fc:	01 97       	sbiw	r24, 0x01	; 1
     6fe:	89 83       	std	Y+1, r24	; 0x01
     700:	9a 83       	std	Y+2, r25	; 0x02
     702:	89 2b       	or	r24, r25
     704:	d1 f1       	breq	.+116    	; 0x77a <_ZN9I2CMaster5writeEhPhhj+0xa2>
     706:	ed 91       	ld	r30, X+
     708:	fc 91       	ld	r31, X
     70a:	11 97       	sbiw	r26, 0x01	; 1
     70c:	84 81       	ldd	r24, Z+4	; 0x04
     70e:	86 ff       	sbrs	r24, 6
     710:	f3 cf       	rjmp	.-26     	; 0x6f8 <_ZN9I2CMaster5writeEhPhhj+0x20>
     712:	33 c0       	rjmp	.+102    	; 0x77a <_ZN9I2CMaster5writeEhPhhj+0xa2>
     714:	22 23       	and	r18, r18
     716:	49 f1       	breq	.+82     	; 0x76a <_ZN9I2CMaster5writeEhPhhj+0x92>
     718:	ba 01       	movw	r22, r20
     71a:	21 50       	subi	r18, 0x01	; 1
     71c:	82 2f       	mov	r24, r18
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	01 96       	adiw	r24, 0x01	; 1
     722:	48 0f       	add	r20, r24
     724:	59 1f       	adc	r21, r25
     726:	09 83       	std	Y+1, r16	; 0x01
     728:	1a 83       	std	Y+2, r17	; 0x02
     72a:	2d 91       	ld	r18, X+
     72c:	3c 91       	ld	r19, X
     72e:	11 97       	sbiw	r26, 0x01	; 1
     730:	fb 01       	movw	r30, r22
     732:	81 91       	ld	r24, Z+
     734:	bf 01       	movw	r22, r30
     736:	f9 01       	movw	r30, r18
     738:	87 83       	std	Z+7, r24	; 0x07
     73a:	29 81       	ldd	r18, Y+1	; 0x01
     73c:	3a 81       	ldd	r19, Y+2	; 0x02
     73e:	21 50       	subi	r18, 0x01	; 1
     740:	31 09       	sbc	r19, r1
     742:	29 83       	std	Y+1, r18	; 0x01
     744:	3a 83       	std	Y+2, r19	; 0x02
     746:	23 2b       	or	r18, r19
     748:	f1 f0       	breq	.+60     	; 0x786 <_ZN9I2CMaster5writeEhPhhj+0xae>
     74a:	ed 91       	ld	r30, X+
     74c:	fc 91       	ld	r31, X
     74e:	11 97       	sbiw	r26, 0x01	; 1
     750:	94 81       	ldd	r25, Z+4	; 0x04
     752:	94 fd       	sbrc	r25, 4
     754:	f2 cf       	rjmp	.-28     	; 0x73a <_ZN9I2CMaster5writeEhPhhj+0x62>
     756:	17 c0       	rjmp	.+46     	; 0x786 <_ZN9I2CMaster5writeEhPhhj+0xae>
     758:	ed 91       	ld	r30, X+
     75a:	fc 91       	ld	r31, X
     75c:	11 97       	sbiw	r26, 0x01	; 1
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	80 64       	ori	r24, 0x40	; 64
     762:	84 83       	std	Z+4, r24	; 0x04
     764:	46 17       	cp	r20, r22
     766:	57 07       	cpc	r21, r23
     768:	f1 f6       	brne	.-68     	; 0x726 <_ZN9I2CMaster5writeEhPhhj+0x4e>
     76a:	ed 91       	ld	r30, X+
     76c:	fc 91       	ld	r31, X
     76e:	83 e0       	ldi	r24, 0x03	; 3
     770:	83 83       	std	Z+3, r24	; 0x03
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	0d c0       	rjmp	.+26     	; 0x790 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     776:	80 e0       	ldi	r24, 0x00	; 0
     778:	0b c0       	rjmp	.+22     	; 0x790 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     77a:	89 81       	ldd	r24, Y+1	; 0x01
     77c:	9a 81       	ldd	r25, Y+2	; 0x02
     77e:	89 2b       	or	r24, r25
     780:	49 f6       	brne	.-110    	; 0x714 <_ZN9I2CMaster5writeEhPhhj+0x3c>
     782:	80 e0       	ldi	r24, 0x00	; 0
     784:	05 c0       	rjmp	.+10     	; 0x790 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     786:	29 81       	ldd	r18, Y+1	; 0x01
     788:	3a 81       	ldd	r19, Y+2	; 0x02
     78a:	23 2b       	or	r18, r19
     78c:	29 f7       	brne	.-54     	; 0x758 <_ZN9I2CMaster5writeEhPhhj+0x80>
     78e:	f3 cf       	rjmp	.-26     	; 0x776 <_ZN9I2CMaster5writeEhPhhj+0x9e>
     790:	0f 90       	pop	r0
     792:	0f 90       	pop	r0
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	1f 91       	pop	r17
     79a:	0f 91       	pop	r16
     79c:	08 95       	ret

0000079e <_ZN9I2CMaster4readEhPhhj>:

bool I2CMaster::read (uint8_t slave_addr, uint8_t* data, uint8_t packet_len, uint16_t timeout)
{
     79e:	0f 93       	push	r16
     7a0:	1f 93       	push	r17
     7a2:	cf 93       	push	r28
     7a4:	df 93       	push	r29
     7a6:	00 d0       	rcall	.+0      	; 0x7a8 <_ZN9I2CMaster4readEhPhhj+0xa>
     7a8:	cd b7       	in	r28, 0x3d	; 61
     7aa:	de b7       	in	r29, 0x3e	; 62
     7ac:	dc 01       	movw	r26, r24
	volatile uint16_t counter;
	volatile uint8_t i;
	counter = timeout;
     7ae:	09 83       	std	Y+1, r16	; 0x01
     7b0:	1a 83       	std	Y+2, r17	; 0x02
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
     7b2:	ed 91       	ld	r30, X+
     7b4:	fc 91       	ld	r31, X
     7b6:	11 97       	sbiw	r26, 0x01	; 1
     7b8:	66 0f       	add	r22, r22
     7ba:	61 60       	ori	r22, 0x01	; 1
     7bc:	66 83       	std	Z+6, r22	; 0x06
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
     7be:	89 81       	ldd	r24, Y+1	; 0x01
     7c0:	9a 81       	ldd	r25, Y+2	; 0x02
     7c2:	01 97       	sbiw	r24, 0x01	; 1
     7c4:	89 83       	std	Y+1, r24	; 0x01
     7c6:	9a 83       	std	Y+2, r25	; 0x02
     7c8:	89 2b       	or	r24, r25
     7ca:	09 f4       	brne	.+2      	; 0x7ce <_ZN9I2CMaster4readEhPhhj+0x30>
     7cc:	47 c0       	rjmp	.+142    	; 0x85c <_ZN9I2CMaster4readEhPhhj+0xbe>
     7ce:	ed 91       	ld	r30, X+
     7d0:	fc 91       	ld	r31, X
     7d2:	11 97       	sbiw	r26, 0x01	; 1
     7d4:	84 81       	ldd	r24, Z+4	; 0x04
     7d6:	88 23       	and	r24, r24
     7d8:	94 f7       	brge	.-28     	; 0x7be <_ZN9I2CMaster4readEhPhhj+0x20>
     7da:	40 c0       	rjmp	.+128    	; 0x85c <_ZN9I2CMaster4readEhPhhj+0xbe>
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     7dc:	1b 82       	std	Y+3, r1	; 0x03
     7de:	8b 81       	ldd	r24, Y+3	; 0x03
     7e0:	82 17       	cp	r24, r18
     7e2:	d8 f5       	brcc	.+118    	; 0x85a <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     7e4:	32 e0       	ldi	r19, 0x02	; 2
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
     7e6:	09 83       	std	Y+1, r16	; 0x01
     7e8:	1a 83       	std	Y+2, r17	; 0x02
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
     7ea:	69 81       	ldd	r22, Y+1	; 0x01
     7ec:	7a 81       	ldd	r23, Y+2	; 0x02
     7ee:	61 50       	subi	r22, 0x01	; 1
     7f0:	71 09       	sbc	r23, r1
     7f2:	69 83       	std	Y+1, r22	; 0x01
     7f4:	7a 83       	std	Y+2, r23	; 0x02
     7f6:	67 2b       	or	r22, r23
     7f8:	c1 f1       	breq	.+112    	; 0x86a <_ZN9I2CMaster4readEhPhhj+0xcc>
     7fa:	ed 91       	ld	r30, X+
     7fc:	fc 91       	ld	r31, X
     7fe:	11 97       	sbiw	r26, 0x01	; 1
     800:	94 81       	ldd	r25, Z+4	; 0x04
     802:	99 23       	and	r25, r25
     804:	94 f7       	brge	.-28     	; 0x7ea <_ZN9I2CMaster4readEhPhhj+0x4c>
     806:	31 c0       	rjmp	.+98     	; 0x86a <_ZN9I2CMaster4readEhPhhj+0xcc>
			if (counter != 0)
			{
				data[i] = interface->MASTER.DATA;
     808:	9b 81       	ldd	r25, Y+3	; 0x03
     80a:	ed 91       	ld	r30, X+
     80c:	fc 91       	ld	r31, X
     80e:	11 97       	sbiw	r26, 0x01	; 1
     810:	87 81       	ldd	r24, Z+7	; 0x07
     812:	fa 01       	movw	r30, r20
     814:	e9 0f       	add	r30, r25
     816:	f1 1d       	adc	r31, r1
     818:	80 83       	st	Z, r24
				if (i < packet_len)
     81a:	8b 81       	ldd	r24, Y+3	; 0x03
     81c:	82 17       	cp	r24, r18
     81e:	88 f4       	brcc	.+34     	; 0x842 <_ZN9I2CMaster4readEhPhhj+0xa4>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     820:	ed 91       	ld	r30, X+
     822:	fc 91       	ld	r31, X
     824:	11 97       	sbiw	r26, 0x01	; 1
     826:	33 83       	std	Z+3, r19	; 0x03
			{
				data[i] = interface->MASTER.DATA;
				if (i < packet_len)
				{
					byte_recv();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     828:	ed 91       	ld	r30, X+
     82a:	fc 91       	ld	r31, X
     82c:	11 97       	sbiw	r26, 0x01	; 1
     82e:	84 81       	ldd	r24, Z+4	; 0x04
     830:	80 68       	ori	r24, 0x80	; 128
     832:	84 83       	std	Z+4, r24	; 0x04
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     834:	8b 81       	ldd	r24, Y+3	; 0x03
     836:	8f 5f       	subi	r24, 0xFF	; 255
     838:	8b 83       	std	Y+3, r24	; 0x03
     83a:	8b 81       	ldd	r24, Y+3	; 0x03
     83c:	82 17       	cp	r24, r18
     83e:	98 f2       	brcs	.-90     	; 0x7e6 <_ZN9I2CMaster4readEhPhhj+0x48>
     840:	0c c0       	rjmp	.+24     	; 0x85a <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
     842:	ed 91       	ld	r30, X+
     844:	fc 91       	ld	r31, X
     846:	11 97       	sbiw	r26, 0x01	; 1
     848:	87 e0       	ldi	r24, 0x07	; 7
     84a:	83 83       	std	Z+3, r24	; 0x03
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
				}
				else
				{
					send_nack_stop();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     84c:	ed 91       	ld	r30, X+
     84e:	fc 91       	ld	r31, X
     850:	84 81       	ldd	r24, Z+4	; 0x04
     852:	80 68       	ori	r24, 0x80	; 128
     854:	84 83       	std	Z+4, r24	; 0x04
					return true;
     856:	81 e0       	ldi	r24, 0x01	; 1
     858:	0d c0       	rjmp	.+26     	; 0x874 <_ZN9I2CMaster4readEhPhhj+0xd6>
	}
	else
	{
		return false;
	}
}
     85a:	0c c0       	rjmp	.+24     	; 0x874 <_ZN9I2CMaster4readEhPhhj+0xd6>
	counter = timeout;
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
     85c:	89 81       	ldd	r24, Y+1	; 0x01
     85e:	9a 81       	ldd	r25, Y+2	; 0x02
     860:	89 2b       	or	r24, r25
     862:	09 f0       	breq	.+2      	; 0x866 <_ZN9I2CMaster4readEhPhhj+0xc8>
     864:	bb cf       	rjmp	.-138    	; 0x7dc <_ZN9I2CMaster4readEhPhhj+0x3e>
			}		
		}
	}
	else
	{
		return false;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	05 c0       	rjmp	.+10     	; 0x874 <_ZN9I2CMaster4readEhPhhj+0xd6>
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
			if (counter != 0)
     86a:	69 81       	ldd	r22, Y+1	; 0x01
     86c:	7a 81       	ldd	r23, Y+2	; 0x02
     86e:	67 2b       	or	r22, r23
     870:	59 f6       	brne	.-106    	; 0x808 <_ZN9I2CMaster4readEhPhhj+0x6a>
					return true;
				}
			}
			else
			{
				return false;
     872:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return false;
	}
}
     874:	23 96       	adiw	r28, 0x03	; 3
     876:	cd bf       	out	0x3d, r28	; 61
     878:	de bf       	out	0x3e, r29	; 62
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	1f 91       	pop	r17
     880:	0f 91       	pop	r16
     882:	08 95       	ret

00000884 <_ZN6MB1202C1EP9I2CMaster>:
};

bool MB1202::is_ready (void)
{
	return i2c->is_ready(slave_addr);
};
     884:	fc 01       	movw	r30, r24
     886:	60 83       	st	Z, r22
     888:	71 83       	std	Z+1, r23	; 0x01
     88a:	14 82       	std	Z+4, r1	; 0x04
     88c:	15 82       	std	Z+5, r1	; 0x05
     88e:	16 82       	std	Z+6, r1	; 0x06
     890:	17 82       	std	Z+7, r1	; 0x07
     892:	10 86       	std	Z+8, r1	; 0x08
     894:	80 e7       	ldi	r24, 0x70	; 112
     896:	82 83       	std	Z+2, r24	; 0x02
     898:	81 e5       	ldi	r24, 0x51	; 81
     89a:	83 83       	std	Z+3, r24	; 0x03
     89c:	8a ea       	ldi	r24, 0xAA	; 170
     89e:	84 83       	std	Z+4, r24	; 0x04
     8a0:	85 ea       	ldi	r24, 0xA5	; 165
     8a2:	85 83       	std	Z+5, r24	; 0x05
     8a4:	08 95       	ret

000008a6 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
     8a6:	0f 93       	push	r16
     8a8:	1f 93       	push	r17
	return i2c->write (slave_addr, range_cmd, 1);
     8aa:	ac 01       	movw	r20, r24
     8ac:	4d 5f       	subi	r20, 0xFD	; 253
     8ae:	5f 4f       	sbci	r21, 0xFF	; 255
     8b0:	08 ee       	ldi	r16, 0xE8	; 232
     8b2:	13 e0       	ldi	r17, 0x03	; 3
     8b4:	21 e0       	ldi	r18, 0x01	; 1
     8b6:	fc 01       	movw	r30, r24
     8b8:	62 81       	ldd	r22, Z+2	; 0x02
     8ba:	80 81       	ld	r24, Z
     8bc:	91 81       	ldd	r25, Z+1	; 0x01
     8be:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN9I2CMaster5writeEhPhhj>
};
     8c2:	1f 91       	pop	r17
     8c4:	0f 91       	pop	r16
     8c6:	08 95       	ret

000008c8 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     8c8:	0f 93       	push	r16
     8ca:	1f 93       	push	r17
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
     8d0:	ec 01       	movw	r28, r24
	i2c->read (slave_addr, bytes_received, 2);
     8d2:	ac 01       	movw	r20, r24
     8d4:	49 5f       	subi	r20, 0xF9	; 249
     8d6:	5f 4f       	sbci	r21, 0xFF	; 255
     8d8:	08 ee       	ldi	r16, 0xE8	; 232
     8da:	13 e0       	ldi	r17, 0x03	; 3
     8dc:	22 e0       	ldi	r18, 0x02	; 2
     8de:	6a 81       	ldd	r22, Y+2	; 0x02
     8e0:	88 81       	ld	r24, Y
     8e2:	99 81       	ldd	r25, Y+1	; 0x01
     8e4:	0e 94 cf 03 	call	0x79e	; 0x79e <_ZN9I2CMaster4readEhPhhj>
	range_reading = ((uint16_t) bytes_received[0] << 8) | ((uint16_t) bytes_received[1]);
     8e8:	8f 81       	ldd	r24, Y+7	; 0x07
     8ea:	90 e0       	ldi	r25, 0x00	; 0
     8ec:	98 2f       	mov	r25, r24
     8ee:	88 27       	eor	r24, r24
     8f0:	28 85       	ldd	r18, Y+8	; 0x08
     8f2:	82 2b       	or	r24, r18
     8f4:	89 87       	std	Y+9, r24	; 0x09
     8f6:	9a 87       	std	Y+10, r25	; 0x0a
	return range_reading;
}
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	1f 91       	pop	r17
     8fe:	0f 91       	pop	r16
     900:	08 95       	ret

00000902 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     902:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     904:	8c 85       	ldd	r24, Y+12	; 0x0c
     906:	88 23       	and	r24, r24
     908:	19 f0       	breq	.+6      	; 0x910 <_ZN10task_sonar3runEv+0xe>
     90a:	81 30       	cpi	r24, 0x01	; 1
     90c:	51 f0       	breq	.+20     	; 0x922 <_ZN10task_sonar3runEv+0x20>
     90e:	25 c0       	rjmp	.+74     	; 0x95a <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     910:	8c 89       	ldd	r24, Y+20	; 0x14
     912:	9d 89       	ldd	r25, Y+21	; 0x15
     914:	0e 94 53 04 	call	0x8a6	; 0x8a6 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     918:	61 e0       	ldi	r22, 0x01	; 1
     91a:	ce 01       	movw	r24, r28
     91c:	0e 94 8c 12 	call	0x2518	; 0x2518 <_ZN8frt_task13transition_toEh>
			
			    break;
     920:	1c c0       	rjmp	.+56     	; 0x95a <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     922:	8c 89       	ldd	r24, Y+20	; 0x14
     924:	9d 89       	ldd	r25, Y+21	; 0x15
     926:	0e 94 64 04 	call	0x8c8	; 0x8c8 <_ZN6MB120211get_readingEv>
     92a:	7c 01       	movw	r14, r24
     92c:	8a 8b       	std	Y+18, r24	; 0x12
     92e:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     930:	6a e0       	ldi	r22, 0x0A	; 10
     932:	8e 81       	ldd	r24, Y+6	; 0x06
     934:	9f 81       	ldd	r25, Y+7	; 0x07
     936:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     93a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     93c:	6a e0       	ldi	r22, 0x0A	; 10
     93e:	73 e0       	ldi	r23, 0x03	; 3
     940:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     944:	b7 01       	movw	r22, r14
     946:	c8 01       	movw	r24, r16
     948:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
     94c:	66 e0       	ldi	r22, 0x06	; 6
     94e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	ce 01       	movw	r24, r28
     956:	0e 94 8c 12 	call	0x2518	; 0x2518 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     95a:	8e 85       	ldd	r24, Y+14	; 0x0e
     95c:	9f 85       	ldd	r25, Y+15	; 0x0f
     95e:	a8 89       	ldd	r26, Y+16	; 0x10
     960:	b9 89       	ldd	r27, Y+17	; 0x11
     962:	01 96       	adiw	r24, 0x01	; 1
     964:	a1 1d       	adc	r26, r1
     966:	b1 1d       	adc	r27, r1
     968:	8e 87       	std	Y+14, r24	; 0x0e
     96a:	9f 87       	std	Y+15, r25	; 0x0f
     96c:	a8 8b       	std	Y+16, r26	; 0x10
     96e:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     970:	64 ef       	ldi	r22, 0xF4	; 244
     972:	71 e0       	ldi	r23, 0x01	; 1
     974:	80 e0       	ldi	r24, 0x00	; 0
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	0e 94 60 10 	call	0x20c0	; 0x20c0 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     97c:	c3 cf       	rjmp	.-122    	; 0x904 <_ZN10task_sonar3runEv+0x2>

0000097e <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     97e:	cf 92       	push	r12
     980:	df 92       	push	r13
     982:	ef 92       	push	r14
     984:	ff 92       	push	r15
     986:	0f 93       	push	r16
     988:	1f 93       	push	r17
     98a:	cf 93       	push	r28
     98c:	df 93       	push	r29
     98e:	ec 01       	movw	r28, r24
     990:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     992:	0e 94 90 12 	call	0x2520	; 0x2520 <_ZN8frt_taskC1EPKchjP8emstream>
     996:	8a e0       	ldi	r24, 0x0A	; 10
     998:	90 e2       	ldi	r25, 0x20	; 32
     99a:	88 83       	st	Y, r24
     99c:	99 83       	std	Y+1, r25	; 0x01
     99e:	ec 8a       	std	Y+20, r14	; 0x14
     9a0:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     9a2:	ce 8a       	std	Y+22, r12	; 0x16
     9a4:	df 8a       	std	Y+23, r13	; 0x17
}
     9a6:	df 91       	pop	r29
     9a8:	cf 91       	pop	r28
     9aa:	1f 91       	pop	r17
     9ac:	0f 91       	pop	r16
     9ae:	ff 90       	pop	r15
     9b0:	ef 90       	pop	r14
     9b2:	df 90       	pop	r13
     9b4:	cf 90       	pop	r12
     9b6:	08 95       	ret

000009b8 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     9b8:	0f 93       	push	r16
     9ba:	1f 93       	push	r17
     9bc:	cf 93       	push	r28
     9be:	df 93       	push	r29
     9c0:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     9c2:	0e 94 90 12 	call	0x2520	; 0x2520 <_ZN8frt_taskC1EPKchjP8emstream>
     9c6:	82 e1       	ldi	r24, 0x12	; 18
     9c8:	90 e2       	ldi	r25, 0x20	; 32
     9ca:	88 83       	st	Y, r24
     9cc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     9ce:	df 91       	pop	r29
     9d0:	cf 91       	pop	r28
     9d2:	1f 91       	pop	r17
     9d4:	0f 91       	pop	r16
     9d6:	08 95       	ret

000009d8 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     9d8:	0f 93       	push	r16
     9da:	1f 93       	push	r17
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
     9e0:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     9e2:	6a e0       	ldi	r22, 0x0A	; 10
     9e4:	8e 81       	ldd	r24, Y+6	; 0x06
     9e6:	9f 81       	ldd	r25, Y+7	; 0x07
     9e8:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     9ec:	8c 01       	movw	r16, r24
     9ee:	65 e6       	ldi	r22, 0x65	; 101
     9f0:	74 e0       	ldi	r23, 0x04	; 4
     9f2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     9f6:	6a e0       	ldi	r22, 0x0A	; 10
     9f8:	c8 01       	movw	r24, r16
     9fa:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     9fe:	8c 01       	movw	r16, r24
     a00:	6f e5       	ldi	r22, 0x5F	; 95
     a02:	74 e0       	ldi	r23, 0x04	; 4
     a04:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a08:	67 e0       	ldi	r22, 0x07	; 7
     a0a:	c8 01       	movw	r24, r16
     a0c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     a10:	6a e0       	ldi	r22, 0x0A	; 10
     a12:	8e 81       	ldd	r24, Y+6	; 0x06
     a14:	9f 81       	ldd	r25, Y+7	; 0x07
     a16:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a1a:	8c 01       	movw	r16, r24
     a1c:	60 e4       	ldi	r22, 0x40	; 64
     a1e:	74 e0       	ldi	r23, 0x04	; 4
     a20:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a24:	6a e0       	ldi	r22, 0x0A	; 10
     a26:	c8 01       	movw	r24, r16
     a28:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a2c:	8c 01       	movw	r16, r24
     a2e:	6a e3       	ldi	r22, 0x3A	; 58
     a30:	74 e0       	ldi	r23, 0x04	; 4
     a32:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a36:	66 e0       	ldi	r22, 0x06	; 6
     a38:	c8 01       	movw	r24, r16
     a3a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     a3e:	6a e0       	ldi	r22, 0x0A	; 10
     a40:	8e 81       	ldd	r24, Y+6	; 0x06
     a42:	9f 81       	ldd	r25, Y+7	; 0x07
     a44:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a48:	8c 01       	movw	r16, r24
     a4a:	63 e2       	ldi	r22, 0x23	; 35
     a4c:	74 e0       	ldi	r23, 0x04	; 4
     a4e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a52:	66 e0       	ldi	r22, 0x06	; 6
     a54:	c8 01       	movw	r24, r16
     a56:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     a5a:	6a e0       	ldi	r22, 0x0A	; 10
     a5c:	8e 81       	ldd	r24, Y+6	; 0x06
     a5e:	9f 81       	ldd	r25, Y+7	; 0x07
     a60:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a64:	8c 01       	movw	r16, r24
     a66:	67 e0       	ldi	r22, 0x07	; 7
     a68:	74 e0       	ldi	r23, 0x04	; 4
     a6a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a6e:	66 e0       	ldi	r22, 0x06	; 6
     a70:	c8 01       	movw	r24, r16
     a72:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     a76:	6a e0       	ldi	r22, 0x0A	; 10
     a78:	8e 81       	ldd	r24, Y+6	; 0x06
     a7a:	9f 81       	ldd	r25, Y+7	; 0x07
     a7c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a80:	8c 01       	movw	r16, r24
     a82:	6f ee       	ldi	r22, 0xEF	; 239
     a84:	73 e0       	ldi	r23, 0x03	; 3
     a86:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     a8a:	66 e0       	ldi	r22, 0x06	; 6
     a8c:	c8 01       	movw	r24, r16
     a8e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     a92:	6a e0       	ldi	r22, 0x0A	; 10
     a94:	8e 81       	ldd	r24, Y+6	; 0x06
     a96:	9f 81       	ldd	r25, Y+7	; 0x07
     a98:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     a9c:	8c 01       	movw	r16, r24
     a9e:	6e ec       	ldi	r22, 0xCE	; 206
     aa0:	73 e0       	ldi	r23, 0x03	; 3
     aa2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     aa6:	66 e0       	ldi	r22, 0x06	; 6
     aa8:	c8 01       	movw	r24, r16
     aaa:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     aae:	6a e0       	ldi	r22, 0x0A	; 10
     ab0:	8e 81       	ldd	r24, Y+6	; 0x06
     ab2:	9f 81       	ldd	r25, Y+7	; 0x07
     ab4:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     ab8:	8c 01       	movw	r16, r24
     aba:	67 ea       	ldi	r22, 0xA7	; 167
     abc:	73 e0       	ldi	r23, 0x03	; 3
     abe:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     ac2:	66 e0       	ldi	r22, 0x06	; 6
     ac4:	c8 01       	movw	r24, r16
     ac6:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     aca:	6a e0       	ldi	r22, 0x0A	; 10
     acc:	8e 81       	ldd	r24, Y+6	; 0x06
     ace:	9f 81       	ldd	r25, Y+7	; 0x07
     ad0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     ad4:	8c 01       	movw	r16, r24
     ad6:	69 e8       	ldi	r22, 0x89	; 137
     ad8:	73 e0       	ldi	r23, 0x03	; 3
     ada:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     ade:	66 e0       	ldi	r22, 0x06	; 6
     ae0:	c8 01       	movw	r24, r16
     ae2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     ae6:	6a e0       	ldi	r22, 0x0A	; 10
     ae8:	8e 81       	ldd	r24, Y+6	; 0x06
     aea:	9f 81       	ldd	r25, Y+7	; 0x07
     aec:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     af0:	8c 01       	movw	r16, r24
     af2:	6e e6       	ldi	r22, 0x6E	; 110
     af4:	73 e0       	ldi	r23, 0x03	; 3
     af6:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     afa:	66 e0       	ldi	r22, 0x06	; 6
     afc:	c8 01       	movw	r24, r16
     afe:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     b02:	6a e0       	ldi	r22, 0x0A	; 10
     b04:	8e 81       	ldd	r24, Y+6	; 0x06
     b06:	9f 81       	ldd	r25, Y+7	; 0x07
     b08:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     b0c:	ec 01       	movw	r28, r24
     b0e:	6f e5       	ldi	r22, 0x5F	; 95
     b10:	73 e0       	ldi	r23, 0x03	; 3
     b12:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     b16:	66 e0       	ldi	r22, 0x06	; 6
     b18:	ce 01       	movw	r24, r28
     b1a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
}
     b1e:	df 91       	pop	r29
     b20:	cf 91       	pop	r28
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	08 95       	ret

00000b28 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     b28:	af 92       	push	r10
     b2a:	bf 92       	push	r11
     b2c:	cf 92       	push	r12
     b2e:	df 92       	push	r13
     b30:	ef 92       	push	r14
     b32:	ff 92       	push	r15
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	00 d0       	rcall	.+0      	; 0xb3e <_ZN9task_user11show_statusEv+0x16>
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <_ZN9task_user11show_statusEv+0x18>
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
     b44:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     b46:	19 82       	std	Y+1, r1	; 0x01
     b48:	1a 82       	std	Y+2, r1	; 0x02
     b4a:	1b 82       	std	Y+3, r1	; 0x03
     b4c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     b4e:	1d 82       	std	Y+5, r1	; 0x05
     b50:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     b52:	0e 94 19 08 	call	0x1032	; 0x1032 <xPortGetFreeHeapSize>
     b56:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     b58:	ce 01       	movw	r24, r28
     b5a:	01 96       	adiw	r24, 0x01	; 1
     b5c:	0e 94 41 16 	call	0x2c82	; 0x2c82 <_ZN10time_stamp10set_to_nowEv>
     b60:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     b62:	66 e0       	ldi	r22, 0x06	; 6
     b64:	f8 01       	movw	r30, r16
     b66:	86 81       	ldd	r24, Z+6	; 0x06
     b68:	97 81       	ldd	r25, Z+7	; 0x07
     b6a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     b6e:	6a e0       	ldi	r22, 0x0A	; 10
     b70:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     b74:	7c 01       	movw	r14, r24
     b76:	60 e4       	ldi	r22, 0x40	; 64
     b78:	73 e0       	ldi	r23, 0x03	; 3
     b7a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     b7e:	6a e0       	ldi	r22, 0x0A	; 10
     b80:	c7 01       	movw	r24, r14
     b82:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     b86:	7c 01       	movw	r14, r24
     b88:	64 e3       	ldi	r22, 0x34	; 52
     b8a:	73 e0       	ldi	r23, 0x03	; 3
     b8c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     b90:	66 e0       	ldi	r22, 0x06	; 6
     b92:	c7 01       	movw	r24, r14
     b94:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     b98:	6a e0       	ldi	r22, 0x0A	; 10
     b9a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     b9e:	7c 01       	movw	r14, r24
     ba0:	6d e2       	ldi	r22, 0x2D	; 45
     ba2:	73 e0       	ldi	r23, 0x03	; 3
     ba4:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     ba8:	b5 01       	movw	r22, r10
     baa:	c7 01       	movw	r24, r14
     bac:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     bb0:	6a e0       	ldi	r22, 0x0A	; 10
     bb2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     bb6:	7c 01       	movw	r14, r24
     bb8:	6f e1       	ldi	r22, 0x1F	; 31
     bba:	73 e0       	ldi	r23, 0x03	; 3
     bbc:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     bc0:	b6 01       	movw	r22, r12
     bc2:	c7 01       	movw	r24, r14
     bc4:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
     bc8:	6a e0       	ldi	r22, 0x0A	; 10
     bca:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     bce:	7c 01       	movw	r14, r24
     bd0:	6d e1       	ldi	r22, 0x1D	; 29
     bd2:	73 e0       	ldi	r23, 0x03	; 3
     bd4:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     bd8:	4f ef       	ldi	r20, 0xFF	; 255
     bda:	5f e0       	ldi	r21, 0x0F	; 15
     bdc:	60 e0       	ldi	r22, 0x00	; 0
     bde:	70 e0       	ldi	r23, 0x00	; 0
     be0:	c7 01       	movw	r24, r14
     be2:	0e 94 70 18 	call	0x30e0	; 0x30e0 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     be6:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     bea:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     bee:	6a e0       	ldi	r22, 0x0A	; 10
     bf0:	f8 01       	movw	r30, r16
     bf2:	86 81       	ldd	r24, Z+6	; 0x06
     bf4:	97 81       	ldd	r25, Z+7	; 0x07
     bf6:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     bfa:	7c 01       	movw	r14, r24
     bfc:	62 e1       	ldi	r22, 0x12	; 18
     bfe:	73 e0       	ldi	r23, 0x03	; 3
     c00:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     c04:	b6 01       	movw	r22, r12
     c06:	c7 01       	movw	r24, r14
     c08:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
     c0c:	66 e0       	ldi	r22, 0x06	; 6
     c0e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     c12:	66 e0       	ldi	r22, 0x06	; 6
     c14:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     c18:	f8 01       	movw	r30, r16
     c1a:	86 81       	ldd	r24, Z+6	; 0x06
     c1c:	97 81       	ldd	r25, Z+7	; 0x07
     c1e:	0e 94 9e 14 	call	0x293c	; 0x293c <_Z15print_task_listP8emstream>
}
     c22:	26 96       	adiw	r28, 0x06	; 6
     c24:	cd bf       	out	0x3d, r28	; 61
     c26:	de bf       	out	0x3e, r29	; 62
     c28:	df 91       	pop	r29
     c2a:	cf 91       	pop	r28
     c2c:	1f 91       	pop	r17
     c2e:	0f 91       	pop	r16
     c30:	ff 90       	pop	r15
     c32:	ef 90       	pop	r14
     c34:	df 90       	pop	r13
     c36:	cf 90       	pop	r12
     c38:	bf 90       	pop	r11
     c3a:	af 90       	pop	r10
     c3c:	08 95       	ret

00000c3e <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     c3e:	cf 93       	push	r28
     c40:	df 93       	push	r29
     c42:	00 d0       	rcall	.+0      	; 0xc44 <_ZN9task_user3runEv+0x6>
     c44:	00 d0       	rcall	.+0      	; 0xc46 <_ZN9task_user3runEv+0x8>
     c46:	cd b7       	in	r28, 0x3d	; 61
     c48:	de b7       	in	r29, 0x3e	; 62
     c4a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     c4c:	19 82       	std	Y+1, r1	; 0x01
     c4e:	1a 82       	std	Y+2, r1	; 0x02
     c50:	1b 82       	std	Y+3, r1	; 0x03
     c52:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     c54:	1d 82       	std	Y+5, r1	; 0x05
     c56:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     c58:	6a e0       	ldi	r22, 0x0A	; 10
     c5a:	dc 01       	movw	r26, r24
     c5c:	16 96       	adiw	r26, 0x06	; 6
     c5e:	8d 91       	ld	r24, X+
     c60:	9c 91       	ld	r25, X
     c62:	17 97       	sbiw	r26, 0x07	; 7
     c64:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     c68:	7c 01       	movw	r14, r24
     c6a:	6e ea       	ldi	r22, 0xAE	; 174
     c6c:	74 e0       	ldi	r23, 0x04	; 4
     c6e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     c72:	66 e0       	ldi	r22, 0x06	; 6
     c74:	c7 01       	movw	r24, r14
     c76:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     c7a:	f8 01       	movw	r30, r16
     c7c:	84 85       	ldd	r24, Z+12	; 0x0c
     c7e:	88 23       	and	r24, r24
     c80:	21 f0       	breq	.+8      	; 0xc8a <_ZN9task_user3runEv+0x4c>
     c82:	81 30       	cpi	r24, 0x01	; 1
     c84:	09 f4       	brne	.+2      	; 0xc88 <_ZN9task_user3runEv+0x4a>
     c86:	5d c0       	rjmp	.+186    	; 0xd42 <_ZN9task_user3runEv+0x104>
     c88:	d8 c0       	rjmp	.+432    	; 0xe3a <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     c8a:	86 81       	ldd	r24, Z+6	; 0x06
     c8c:	97 81       	ldd	r25, Z+7	; 0x07
     c8e:	dc 01       	movw	r26, r24
     c90:	ed 91       	ld	r30, X+
     c92:	fc 91       	ld	r31, X
     c94:	04 80       	ldd	r0, Z+4	; 0x04
     c96:	f5 81       	ldd	r31, Z+5	; 0x05
     c98:	e0 2d       	mov	r30, r0
     c9a:	19 95       	eicall
     c9c:	88 23       	and	r24, r24
     c9e:	a9 f1       	breq	.+106    	; 0xd0a <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     ca0:	f8 01       	movw	r30, r16
     ca2:	86 81       	ldd	r24, Z+6	; 0x06
     ca4:	97 81       	ldd	r25, Z+7	; 0x07
     ca6:	dc 01       	movw	r26, r24
     ca8:	ed 91       	ld	r30, X+
     caa:	fc 91       	ld	r31, X
     cac:	06 80       	ldd	r0, Z+6	; 0x06
     cae:	f7 81       	ldd	r31, Z+7	; 0x07
     cb0:	e0 2d       	mov	r30, r0
     cb2:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     cb4:	99 27       	eor	r25, r25
     cb6:	81 30       	cpi	r24, 0x01	; 1
     cb8:	91 05       	cpc	r25, r1
     cba:	f9 f0       	breq	.+62     	; 0xcfa <_ZN9task_user3runEv+0xbc>
     cbc:	03 97       	sbiw	r24, 0x03	; 3
     cbe:	09 f0       	breq	.+2      	; 0xcc2 <_ZN9task_user3runEv+0x84>
     cc0:	d8 c0       	rjmp	.+432    	; 0xe72 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     cc2:	6a e0       	ldi	r22, 0x0A	; 10
     cc4:	f8 01       	movw	r30, r16
     cc6:	86 81       	ldd	r24, Z+6	; 0x06
     cc8:	97 81       	ldd	r25, Z+7	; 0x07
     cca:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     cce:	8c 01       	movw	r16, r24
     cd0:	60 ea       	ldi	r22, 0xA0	; 160
     cd2:	74 e0       	ldi	r23, 0x04	; 4
     cd4:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     cd8:	66 e0       	ldi	r22, 0x06	; 6
     cda:	c8 01       	movw	r24, r16
     cdc:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     ce0:	93 e0       	ldi	r25, 0x03	; 3
     ce2:	88 ed       	ldi	r24, 0xD8	; 216
     ce4:	08 b6       	in	r0, 0x38	; 56
     ce6:	18 be       	out	0x38, r1	; 56
     ce8:	84 bf       	out	0x34, r24	; 52
     cea:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     cee:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     cf2:	81 fd       	sbrc	r24, 1
     cf4:	fc cf       	rjmp	.-8      	; 0xcee <_ZN9task_user3runEv+0xb0>
     cf6:	08 be       	out	0x38, r0	; 56
     cf8:	ff cf       	rjmp	.-2      	; 0xcf8 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     cfa:	c8 01       	movw	r24, r16
     cfc:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     d00:	61 e0       	ldi	r22, 0x01	; 1
     d02:	c8 01       	movw	r24, r16
     d04:	0e 94 8c 12 	call	0x2518	; 0x2518 <_ZN8frt_task13transition_toEh>
							break;
     d08:	b4 c0       	rjmp	.+360    	; 0xe72 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     d0a:	84 e8       	ldi	r24, 0x84	; 132
     d0c:	91 e3       	ldi	r25, 0x31	; 49
     d0e:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <_ZN14frt_text_queue14check_for_charEv>
     d12:	88 23       	and	r24, r24
     d14:	09 f4       	brne	.+2      	; 0xd18 <_ZN9task_user3runEv+0xda>
     d16:	ad c0       	rjmp	.+346    	; 0xe72 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     d18:	d8 01       	movw	r26, r16
     d1a:	16 96       	adiw	r26, 0x06	; 6
     d1c:	ed 91       	ld	r30, X+
     d1e:	fc 91       	ld	r31, X
     d20:	17 97       	sbiw	r26, 0x07	; 7
     d22:	01 90       	ld	r0, Z+
     d24:	f0 81       	ld	r31, Z
     d26:	e0 2d       	mov	r30, r0
     d28:	e2 80       	ldd	r14, Z+2	; 0x02
     d2a:	f3 80       	ldd	r15, Z+3	; 0x03
     d2c:	84 e8       	ldi	r24, 0x84	; 132
     d2e:	91 e3       	ldi	r25, 0x31	; 49
     d30:	0e 94 2f 15 	call	0x2a5e	; 0x2a5e <_ZN14frt_text_queue7getcharEv>
     d34:	68 2f       	mov	r22, r24
     d36:	f8 01       	movw	r30, r16
     d38:	86 81       	ldd	r24, Z+6	; 0x06
     d3a:	97 81       	ldd	r25, Z+7	; 0x07
     d3c:	f7 01       	movw	r30, r14
     d3e:	19 95       	eicall
     d40:	98 c0       	rjmp	.+304    	; 0xe72 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     d42:	86 81       	ldd	r24, Z+6	; 0x06
     d44:	97 81       	ldd	r25, Z+7	; 0x07
     d46:	dc 01       	movw	r26, r24
     d48:	ed 91       	ld	r30, X+
     d4a:	fc 91       	ld	r31, X
     d4c:	04 80       	ldd	r0, Z+4	; 0x04
     d4e:	f5 81       	ldd	r31, Z+5	; 0x05
     d50:	e0 2d       	mov	r30, r0
     d52:	19 95       	eicall
     d54:	88 23       	and	r24, r24
     d56:	09 f4       	brne	.+2      	; 0xd5a <_ZN9task_user3runEv+0x11c>
     d58:	8c c0       	rjmp	.+280    	; 0xe72 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     d5a:	f8 01       	movw	r30, r16
     d5c:	86 81       	ldd	r24, Z+6	; 0x06
     d5e:	97 81       	ldd	r25, Z+7	; 0x07
     d60:	dc 01       	movw	r26, r24
     d62:	ed 91       	ld	r30, X+
     d64:	fc 91       	ld	r31, X
     d66:	06 80       	ldd	r0, Z+6	; 0x06
     d68:	f7 81       	ldd	r31, Z+7	; 0x07
     d6a:	e0 2d       	mov	r30, r0
     d6c:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     d6e:	9c 01       	movw	r18, r24
     d70:	33 27       	eor	r19, r19
     d72:	28 36       	cpi	r18, 0x68	; 104
     d74:	31 05       	cpc	r19, r1
     d76:	59 f1       	breq	.+86     	; 0xdce <_ZN9task_user3runEv+0x190>
     d78:	3c f4       	brge	.+14     	; 0xd88 <_ZN9task_user3runEv+0x14a>
     d7a:	2b 31       	cpi	r18, 0x1B	; 27
     d7c:	31 05       	cpc	r19, r1
     d7e:	59 f1       	breq	.+86     	; 0xdd6 <_ZN9task_user3runEv+0x198>
     d80:	25 36       	cpi	r18, 0x65	; 101
     d82:	31 05       	cpc	r19, r1
     d84:	41 f1       	breq	.+80     	; 0xdd6 <_ZN9task_user3runEv+0x198>
     d86:	3b c0       	rjmp	.+118    	; 0xdfe <_ZN9task_user3runEv+0x1c0>
     d88:	23 37       	cpi	r18, 0x73	; 115
     d8a:	31 05       	cpc	r19, r1
     d8c:	c1 f0       	breq	.+48     	; 0xdbe <_ZN9task_user3runEv+0x180>
     d8e:	26 37       	cpi	r18, 0x76	; 118
     d90:	31 05       	cpc	r19, r1
     d92:	89 f0       	breq	.+34     	; 0xdb6 <_ZN9task_user3runEv+0x178>
     d94:	2e 36       	cpi	r18, 0x6E	; 110
     d96:	31 05       	cpc	r19, r1
     d98:	91 f5       	brne	.+100    	; 0xdfe <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     d9a:	ce 01       	movw	r24, r28
     d9c:	01 96       	adiw	r24, 0x01	; 1
     d9e:	0e 94 41 16 	call	0x2c82	; 0x2c82 <_ZN10time_stamp10set_to_nowEv>
     da2:	bc 01       	movw	r22, r24
     da4:	f8 01       	movw	r30, r16
     da6:	86 81       	ldd	r24, Z+6	; 0x06
     da8:	97 81       	ldd	r25, Z+7	; 0x07
     daa:	0e 94 e5 15 	call	0x2bca	; 0x2bca <_ZlsR8emstreamR10time_stamp>
     dae:	66 e0       	ldi	r22, 0x06	; 6
     db0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
							break;
     db4:	5e c0       	rjmp	.+188    	; 0xe72 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     db6:	c8 01       	movw	r24, r16
     db8:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN9task_user11show_statusEv>
							break;
     dbc:	5a c0       	rjmp	.+180    	; 0xe72 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     dbe:	d8 01       	movw	r26, r16
     dc0:	16 96       	adiw	r26, 0x06	; 6
     dc2:	8d 91       	ld	r24, X+
     dc4:	9c 91       	ld	r25, X
     dc6:	17 97       	sbiw	r26, 0x07	; 7
     dc8:	0e 94 a5 13 	call	0x274a	; 0x274a <_Z17print_task_stacksP8emstream>
							break;
     dcc:	52 c0       	rjmp	.+164    	; 0xe72 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     dce:	c8 01       	movw	r24, r16
     dd0:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <_ZN9task_user18print_help_messageEv>
							break;
     dd4:	4e c0       	rjmp	.+156    	; 0xe72 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     dd6:	6a e0       	ldi	r22, 0x0A	; 10
     dd8:	f8 01       	movw	r30, r16
     dda:	86 81       	ldd	r24, Z+6	; 0x06
     ddc:	97 81       	ldd	r25, Z+7	; 0x07
     dde:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     de2:	7c 01       	movw	r14, r24
     de4:	6e e8       	ldi	r22, 0x8E	; 142
     de6:	74 e0       	ldi	r23, 0x04	; 4
     de8:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     dec:	66 e0       	ldi	r22, 0x06	; 6
     dee:	c7 01       	movw	r24, r14
     df0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     df4:	60 e0       	ldi	r22, 0x00	; 0
     df6:	c8 01       	movw	r24, r16
     df8:	0e 94 8c 12 	call	0x2518	; 0x2518 <_ZN8frt_task13transition_toEh>
							break;
     dfc:	3a c0       	rjmp	.+116    	; 0xe72 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     dfe:	f8 01       	movw	r30, r16
     e00:	a6 81       	ldd	r26, Z+6	; 0x06
     e02:	b7 81       	ldd	r27, Z+7	; 0x07
     e04:	ed 91       	ld	r30, X+
     e06:	fc 91       	ld	r31, X
     e08:	11 97       	sbiw	r26, 0x01	; 1
     e0a:	02 80       	ldd	r0, Z+2	; 0x02
     e0c:	f3 81       	ldd	r31, Z+3	; 0x03
     e0e:	e0 2d       	mov	r30, r0
     e10:	68 2f       	mov	r22, r24
     e12:	cd 01       	movw	r24, r26
     e14:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     e16:	6a e0       	ldi	r22, 0x0A	; 10
     e18:	d8 01       	movw	r26, r16
     e1a:	16 96       	adiw	r26, 0x06	; 6
     e1c:	8d 91       	ld	r24, X+
     e1e:	9c 91       	ld	r25, X
     e20:	17 97       	sbiw	r26, 0x07	; 7
     e22:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     e26:	7c 01       	movw	r14, r24
     e28:	68 e8       	ldi	r22, 0x88	; 136
     e2a:	74 e0       	ldi	r23, 0x04	; 4
     e2c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     e30:	66 e0       	ldi	r22, 0x06	; 6
     e32:	c7 01       	movw	r24, r14
     e34:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
							break;
     e38:	1c c0       	rjmp	.+56     	; 0xe72 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     e3a:	6a e0       	ldi	r22, 0x0A	; 10
     e3c:	f8 01       	movw	r30, r16
     e3e:	86 81       	ldd	r24, Z+6	; 0x06
     e40:	97 81       	ldd	r25, Z+7	; 0x07
     e42:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
     e46:	8c 01       	movw	r16, r24
     e48:	6b e6       	ldi	r22, 0x6B	; 107
     e4a:	74 e0       	ldi	r23, 0x04	; 4
     e4c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
     e50:	66 e0       	ldi	r22, 0x06	; 6
     e52:	c8 01       	movw	r24, r16
     e54:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     e58:	93 e0       	ldi	r25, 0x03	; 3
     e5a:	88 ed       	ldi	r24, 0xD8	; 216
     e5c:	08 b6       	in	r0, 0x38	; 56
     e5e:	18 be       	out	0x38, r1	; 56
     e60:	84 bf       	out	0x34, r24	; 52
     e62:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e66:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e6a:	81 fd       	sbrc	r24, 1
     e6c:	fc cf       	rjmp	.-8      	; 0xe66 <_ZN9task_user3runEv+0x228>
     e6e:	08 be       	out	0x38, r0	; 56
     e70:	ff cf       	rjmp	.-2      	; 0xe70 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     e72:	f8 01       	movw	r30, r16
     e74:	86 85       	ldd	r24, Z+14	; 0x0e
     e76:	97 85       	ldd	r25, Z+15	; 0x0f
     e78:	a0 89       	ldd	r26, Z+16	; 0x10
     e7a:	b1 89       	ldd	r27, Z+17	; 0x11
     e7c:	01 96       	adiw	r24, 0x01	; 1
     e7e:	a1 1d       	adc	r26, r1
     e80:	b1 1d       	adc	r27, r1
     e82:	86 87       	std	Z+14, r24	; 0x0e
     e84:	97 87       	std	Z+15, r25	; 0x0f
     e86:	a0 8b       	std	Z+16, r26	; 0x10
     e88:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     e8a:	61 e0       	ldi	r22, 0x01	; 1
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 60 10 	call	0x20c0	; 0x20c0 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     e96:	f1 ce       	rjmp	.-542    	; 0xc7a <_ZN9task_user3runEv+0x3c>

00000e98 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e98:	0f 93       	push	r16
     e9a:	1f 93       	push	r17
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
     ea0:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     ea2:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     ea6:	80 91 c8 20 	lds	r24, 0x20C8	; 0x8020c8 <__data_end>
     eaa:	81 11       	cpse	r24, r1
     eac:	1d c0       	rjmp	.+58     	; 0xee8 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     eae:	ad ec       	ldi	r26, 0xCD	; 205
     eb0:	b0 e2       	ldi	r27, 0x20	; 32
     eb2:	e1 ed       	ldi	r30, 0xD1	; 209
     eb4:	f0 e2       	ldi	r31, 0x20	; 32
     eb6:	ed 93       	st	X+, r30
     eb8:	fc 93       	st	X, r31
     eba:	11 97       	sbiw	r26, 0x01	; 1
     ebc:	12 96       	adiw	r26, 0x02	; 2
     ebe:	1d 92       	st	X+, r1
     ec0:	1c 92       	st	X, r1
     ec2:	13 97       	sbiw	r26, 0x03	; 3
     ec4:	a9 ec       	ldi	r26, 0xC9	; 201
     ec6:	b0 e2       	ldi	r27, 0x20	; 32
     ec8:	8f ef       	ldi	r24, 0xFF	; 255
     eca:	9f e0       	ldi	r25, 0x0F	; 15
     ecc:	12 96       	adiw	r26, 0x02	; 2
     ece:	8d 93       	st	X+, r24
     ed0:	9c 93       	st	X, r25
     ed2:	13 97       	sbiw	r26, 0x03	; 3
     ed4:	1d 92       	st	X+, r1
     ed6:	1c 92       	st	X, r1
     ed8:	11 97       	sbiw	r26, 0x01	; 1
     eda:	82 83       	std	Z+2, r24	; 0x02
     edc:	93 83       	std	Z+3, r25	; 0x03
     ede:	a0 83       	st	Z, r26
     ee0:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     ee2:	81 e0       	ldi	r24, 0x01	; 1
     ee4:	80 93 c8 20 	sts	0x20C8, r24	; 0x8020c8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     ee8:	20 97       	sbiw	r28, 0x00	; 0
     eea:	09 f4       	brne	.+2      	; 0xeee <pvPortMalloc+0x56>
     eec:	5f c0       	rjmp	.+190    	; 0xfac <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     eee:	9e 01       	movw	r18, r28
     ef0:	2b 5f       	subi	r18, 0xFB	; 251
     ef2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     ef4:	24 96       	adiw	r28, 0x04	; 4
     ef6:	ce 3f       	cpi	r28, 0xFE	; 254
     ef8:	df 40       	sbci	r29, 0x0F	; 15
     efa:	08 f0       	brcs	.+2      	; 0xefe <pvPortMalloc+0x66>
     efc:	5a c0       	rjmp	.+180    	; 0xfb2 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     efe:	e0 91 cd 20 	lds	r30, 0x20CD	; 0x8020cd <xStart>
     f02:	f0 91 ce 20 	lds	r31, 0x20CE	; 0x8020ce <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     f06:	ad ec       	ldi	r26, 0xCD	; 205
     f08:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <pvPortMalloc+0x78>
     f0c:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     f0e:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     f10:	82 81       	ldd	r24, Z+2	; 0x02
     f12:	93 81       	ldd	r25, Z+3	; 0x03
     f14:	82 17       	cp	r24, r18
     f16:	93 07       	cpc	r25, r19
     f18:	20 f4       	brcc	.+8      	; 0xf22 <pvPortMalloc+0x8a>
     f1a:	80 81       	ld	r24, Z
     f1c:	91 81       	ldd	r25, Z+1	; 0x01
     f1e:	00 97       	sbiw	r24, 0x00	; 0
     f20:	a9 f7       	brne	.-22     	; 0xf0c <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     f22:	c0 e2       	ldi	r28, 0x20	; 32
     f24:	e9 3c       	cpi	r30, 0xC9	; 201
     f26:	fc 07       	cpc	r31, r28
     f28:	09 f4       	brne	.+2      	; 0xf2c <pvPortMalloc+0x94>
     f2a:	46 c0       	rjmp	.+140    	; 0xfb8 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     f2c:	cd 91       	ld	r28, X+
     f2e:	dc 91       	ld	r29, X
     f30:	11 97       	sbiw	r26, 0x01	; 1
     f32:	8e 01       	movw	r16, r28
     f34:	0b 5f       	subi	r16, 0xFB	; 251
     f36:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     f38:	80 81       	ld	r24, Z
     f3a:	91 81       	ldd	r25, Z+1	; 0x01
     f3c:	8d 93       	st	X+, r24
     f3e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     f40:	82 81       	ldd	r24, Z+2	; 0x02
     f42:	93 81       	ldd	r25, Z+3	; 0x03
     f44:	82 1b       	sub	r24, r18
     f46:	93 0b       	sbc	r25, r19
     f48:	8b 30       	cpi	r24, 0x0B	; 11
     f4a:	91 05       	cpc	r25, r1
     f4c:	10 f1       	brcs	.+68     	; 0xf92 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     f4e:	bf 01       	movw	r22, r30
     f50:	62 0f       	add	r22, r18
     f52:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     f54:	db 01       	movw	r26, r22
     f56:	12 96       	adiw	r26, 0x02	; 2
     f58:	8d 93       	st	X+, r24
     f5a:	9c 93       	st	X, r25
     f5c:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     f5e:	22 83       	std	Z+2, r18	; 0x02
     f60:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     f62:	12 96       	adiw	r26, 0x02	; 2
     f64:	4d 91       	ld	r20, X+
     f66:	5c 91       	ld	r21, X
     f68:	13 97       	sbiw	r26, 0x03	; 3
     f6a:	8d ec       	ldi	r24, 0xCD	; 205
     f6c:	90 e2       	ldi	r25, 0x20	; 32
     f6e:	01 c0       	rjmp	.+2      	; 0xf72 <pvPortMalloc+0xda>
     f70:	cd 01       	movw	r24, r26
     f72:	ec 01       	movw	r28, r24
     f74:	a8 81       	ld	r26, Y
     f76:	b9 81       	ldd	r27, Y+1	; 0x01
     f78:	12 96       	adiw	r26, 0x02	; 2
     f7a:	2d 91       	ld	r18, X+
     f7c:	3c 91       	ld	r19, X
     f7e:	13 97       	sbiw	r26, 0x03	; 3
     f80:	24 17       	cp	r18, r20
     f82:	35 07       	cpc	r19, r21
     f84:	a8 f3       	brcs	.-22     	; 0xf70 <pvPortMalloc+0xd8>
     f86:	eb 01       	movw	r28, r22
     f88:	a8 83       	st	Y, r26
     f8a:	b9 83       	std	Y+1, r27	; 0x01
     f8c:	dc 01       	movw	r26, r24
     f8e:	6d 93       	st	X+, r22
     f90:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     f92:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     f96:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     f9a:	22 81       	ldd	r18, Z+2	; 0x02
     f9c:	33 81       	ldd	r19, Z+3	; 0x03
     f9e:	82 1b       	sub	r24, r18
     fa0:	93 0b       	sbc	r25, r19
     fa2:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     fa6:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     faa:	08 c0       	rjmp	.+16     	; 0xfbc <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     fac:	00 e0       	ldi	r16, 0x00	; 0
     fae:	10 e0       	ldi	r17, 0x00	; 0
     fb0:	05 c0       	rjmp	.+10     	; 0xfbc <pvPortMalloc+0x124>
     fb2:	00 e0       	ldi	r16, 0x00	; 0
     fb4:	10 e0       	ldi	r17, 0x00	; 0
     fb6:	02 c0       	rjmp	.+4      	; 0xfbc <pvPortMalloc+0x124>
     fb8:	00 e0       	ldi	r16, 0x00	; 0
     fba:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     fbc:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     fc0:	c8 01       	movw	r24, r16
     fc2:	df 91       	pop	r29
     fc4:	cf 91       	pop	r28
     fc6:	1f 91       	pop	r17
     fc8:	0f 91       	pop	r16
     fca:	08 95       	ret

00000fcc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     fd4:	00 97       	sbiw	r24, 0x00	; 0
     fd6:	41 f1       	breq	.+80     	; 0x1028 <vPortFree+0x5c>
     fd8:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     fda:	8c 01       	movw	r16, r24
     fdc:	05 50       	subi	r16, 0x05	; 5
     fde:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     fe0:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     fe4:	f8 01       	movw	r30, r16
     fe6:	42 81       	ldd	r20, Z+2	; 0x02
     fe8:	53 81       	ldd	r21, Z+3	; 0x03
     fea:	ad ec       	ldi	r26, 0xCD	; 205
     fec:	b0 e2       	ldi	r27, 0x20	; 32
     fee:	01 c0       	rjmp	.+2      	; 0xff2 <vPortFree+0x26>
     ff0:	df 01       	movw	r26, r30
     ff2:	ed 91       	ld	r30, X+
     ff4:	fc 91       	ld	r31, X
     ff6:	11 97       	sbiw	r26, 0x01	; 1
     ff8:	22 81       	ldd	r18, Z+2	; 0x02
     ffa:	33 81       	ldd	r19, Z+3	; 0x03
     ffc:	24 17       	cp	r18, r20
     ffe:	35 07       	cpc	r19, r21
    1000:	b8 f3       	brcs	.-18     	; 0xff0 <vPortFree+0x24>
    1002:	25 97       	sbiw	r28, 0x05	; 5
    1004:	e8 83       	st	Y, r30
    1006:	f9 83       	std	Y+1, r31	; 0x01
    1008:	0d 93       	st	X+, r16
    100a:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    100c:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1010:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	9b 81       	ldd	r25, Y+3	; 0x03
    1018:	82 0f       	add	r24, r18
    101a:	93 1f       	adc	r25, r19
    101c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1020:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1024:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
	}
}
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	08 95       	ret

00001032 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1032:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1036:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    103a:	08 95       	ret

0000103c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    103c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    103e:	03 96       	adiw	r24, 0x03	; 3
    1040:	81 83       	std	Z+1, r24	; 0x01
    1042:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1044:	4f ef       	ldi	r20, 0xFF	; 255
    1046:	5f ef       	ldi	r21, 0xFF	; 255
    1048:	ba 01       	movw	r22, r20
    104a:	43 83       	std	Z+3, r20	; 0x03
    104c:	54 83       	std	Z+4, r21	; 0x04
    104e:	65 83       	std	Z+5, r22	; 0x05
    1050:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1052:	87 83       	std	Z+7, r24	; 0x07
    1054:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1056:	81 87       	std	Z+9, r24	; 0x09
    1058:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    105a:	10 82       	st	Z, r1
    105c:	08 95       	ret

0000105e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    105e:	fc 01       	movw	r30, r24
    1060:	12 86       	std	Z+10, r1	; 0x0a
    1062:	13 86       	std	Z+11, r1	; 0x0b
    1064:	08 95       	ret

00001066 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	fc 01       	movw	r30, r24
    106c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    106e:	21 81       	ldd	r18, Z+1	; 0x01
    1070:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1072:	e9 01       	movw	r28, r18
    1074:	8c 81       	ldd	r24, Y+4	; 0x04
    1076:	9d 81       	ldd	r25, Y+5	; 0x05
    1078:	14 96       	adiw	r26, 0x04	; 4
    107a:	8d 93       	st	X+, r24
    107c:	9c 93       	st	X, r25
    107e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1080:	81 81       	ldd	r24, Z+1	; 0x01
    1082:	92 81       	ldd	r25, Z+2	; 0x02
    1084:	16 96       	adiw	r26, 0x06	; 6
    1086:	8d 93       	st	X+, r24
    1088:	9c 93       	st	X, r25
    108a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    108c:	8c 81       	ldd	r24, Y+4	; 0x04
    108e:	9d 81       	ldd	r25, Y+5	; 0x05
    1090:	ec 01       	movw	r28, r24
    1092:	6e 83       	std	Y+6, r22	; 0x06
    1094:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1096:	e9 01       	movw	r28, r18
    1098:	6c 83       	std	Y+4, r22	; 0x04
    109a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    109c:	61 83       	std	Z+1, r22	; 0x01
    109e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10a0:	1a 96       	adiw	r26, 0x0a	; 10
    10a2:	ed 93       	st	X+, r30
    10a4:	fc 93       	st	X, r31
    10a6:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    10a8:	80 81       	ld	r24, Z
    10aa:	8f 5f       	subi	r24, 0xFF	; 255
    10ac:	80 83       	st	Z, r24
}
    10ae:	df 91       	pop	r29
    10b0:	cf 91       	pop	r28
    10b2:	08 95       	ret

000010b4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    10b4:	0f 93       	push	r16
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    10be:	08 81       	ld	r16, Y
    10c0:	19 81       	ldd	r17, Y+1	; 0x01
    10c2:	2a 81       	ldd	r18, Y+2	; 0x02
    10c4:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    10c6:	0f 3f       	cpi	r16, 0xFF	; 255
    10c8:	4f ef       	ldi	r20, 0xFF	; 255
    10ca:	14 07       	cpc	r17, r20
    10cc:	24 07       	cpc	r18, r20
    10ce:	34 07       	cpc	r19, r20
    10d0:	31 f4       	brne	.+12     	; 0x10de <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    10d2:	dc 01       	movw	r26, r24
    10d4:	19 96       	adiw	r26, 0x09	; 9
    10d6:	ed 91       	ld	r30, X+
    10d8:	fc 91       	ld	r31, X
    10da:	1a 97       	sbiw	r26, 0x0a	; 10
    10dc:	1f c0       	rjmp	.+62     	; 0x111c <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    10de:	fc 01       	movw	r30, r24
    10e0:	33 96       	adiw	r30, 0x03	; 3
    10e2:	dc 01       	movw	r26, r24
    10e4:	17 96       	adiw	r26, 0x07	; 7
    10e6:	4d 91       	ld	r20, X+
    10e8:	5c 91       	ld	r21, X
    10ea:	18 97       	sbiw	r26, 0x08	; 8
    10ec:	da 01       	movw	r26, r20
    10ee:	4d 91       	ld	r20, X+
    10f0:	5d 91       	ld	r21, X+
    10f2:	6d 91       	ld	r22, X+
    10f4:	7c 91       	ld	r23, X
    10f6:	04 17       	cp	r16, r20
    10f8:	15 07       	cpc	r17, r21
    10fa:	26 07       	cpc	r18, r22
    10fc:	37 07       	cpc	r19, r23
    10fe:	70 f0       	brcs	.+28     	; 0x111c <vListInsert+0x68>
    1100:	04 80       	ldd	r0, Z+4	; 0x04
    1102:	f5 81       	ldd	r31, Z+5	; 0x05
    1104:	e0 2d       	mov	r30, r0
    1106:	a4 81       	ldd	r26, Z+4	; 0x04
    1108:	b5 81       	ldd	r27, Z+5	; 0x05
    110a:	4d 91       	ld	r20, X+
    110c:	5d 91       	ld	r21, X+
    110e:	6d 91       	ld	r22, X+
    1110:	7c 91       	ld	r23, X
    1112:	04 17       	cp	r16, r20
    1114:	15 07       	cpc	r17, r21
    1116:	26 07       	cpc	r18, r22
    1118:	37 07       	cpc	r19, r23
    111a:	90 f7       	brcc	.-28     	; 0x1100 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    111c:	a4 81       	ldd	r26, Z+4	; 0x04
    111e:	b5 81       	ldd	r27, Z+5	; 0x05
    1120:	ac 83       	std	Y+4, r26	; 0x04
    1122:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1124:	16 96       	adiw	r26, 0x06	; 6
    1126:	cd 93       	st	X+, r28
    1128:	dc 93       	st	X, r29
    112a:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    112c:	ee 83       	std	Y+6, r30	; 0x06
    112e:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1130:	c4 83       	std	Z+4, r28	; 0x04
    1132:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1134:	8a 87       	std	Y+10, r24	; 0x0a
    1136:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1138:	fc 01       	movw	r30, r24
    113a:	20 81       	ld	r18, Z
    113c:	2f 5f       	subi	r18, 0xFF	; 255
    113e:	20 83       	st	Z, r18
}
    1140:	df 91       	pop	r29
    1142:	cf 91       	pop	r28
    1144:	1f 91       	pop	r17
    1146:	0f 91       	pop	r16
    1148:	08 95       	ret

0000114a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    114a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    114c:	a4 81       	ldd	r26, Z+4	; 0x04
    114e:	b5 81       	ldd	r27, Z+5	; 0x05
    1150:	86 81       	ldd	r24, Z+6	; 0x06
    1152:	97 81       	ldd	r25, Z+7	; 0x07
    1154:	16 96       	adiw	r26, 0x06	; 6
    1156:	8d 93       	st	X+, r24
    1158:	9c 93       	st	X, r25
    115a:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    115c:	a6 81       	ldd	r26, Z+6	; 0x06
    115e:	b7 81       	ldd	r27, Z+7	; 0x07
    1160:	84 81       	ldd	r24, Z+4	; 0x04
    1162:	95 81       	ldd	r25, Z+5	; 0x05
    1164:	14 96       	adiw	r26, 0x04	; 4
    1166:	8d 93       	st	X+, r24
    1168:	9c 93       	st	X, r25
    116a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    116c:	a2 85       	ldd	r26, Z+10	; 0x0a
    116e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1170:	11 96       	adiw	r26, 0x01	; 1
    1172:	8d 91       	ld	r24, X+
    1174:	9c 91       	ld	r25, X
    1176:	12 97       	sbiw	r26, 0x02	; 2
    1178:	e8 17       	cp	r30, r24
    117a:	f9 07       	cpc	r31, r25
    117c:	31 f4       	brne	.+12     	; 0x118a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    117e:	86 81       	ldd	r24, Z+6	; 0x06
    1180:	97 81       	ldd	r25, Z+7	; 0x07
    1182:	11 96       	adiw	r26, 0x01	; 1
    1184:	8d 93       	st	X+, r24
    1186:	9c 93       	st	X, r25
    1188:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    118a:	12 86       	std	Z+10, r1	; 0x0a
    118c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    118e:	8c 91       	ld	r24, X
    1190:	81 50       	subi	r24, 0x01	; 1
    1192:	8c 93       	st	X, r24
    1194:	08 95       	ret

00001196 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1196:	80 93 94 31 	sts	0x3194, r24	; 0x803194 <portStackTopForTask>
    119a:	90 93 95 31 	sts	0x3195, r25	; 0x803195 <portStackTopForTask+0x1>
    119e:	31 e1       	ldi	r19, 0x11	; 17
    11a0:	fc 01       	movw	r30, r24
    11a2:	30 83       	st	Z, r19
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	22 e2       	ldi	r18, 0x22	; 34
    11a8:	20 83       	st	Z, r18
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	a3 e3       	ldi	r26, 0x33	; 51
    11ae:	a0 83       	st	Z, r26
    11b0:	31 97       	sbiw	r30, 0x01	; 1
    11b2:	60 83       	st	Z, r22
    11b4:	31 97       	sbiw	r30, 0x01	; 1
    11b6:	70 83       	st	Z, r23
    11b8:	31 97       	sbiw	r30, 0x01	; 1
    11ba:	10 82       	st	Z, r1
    11bc:	31 97       	sbiw	r30, 0x01	; 1
    11be:	10 82       	st	Z, r1
    11c0:	31 97       	sbiw	r30, 0x01	; 1
    11c2:	60 e8       	ldi	r22, 0x80	; 128
    11c4:	60 83       	st	Z, r22
    11c6:	31 97       	sbiw	r30, 0x01	; 1
    11c8:	10 82       	st	Z, r1
    11ca:	31 97       	sbiw	r30, 0x01	; 1
    11cc:	10 82       	st	Z, r1
    11ce:	31 97       	sbiw	r30, 0x01	; 1
    11d0:	10 82       	st	Z, r1
    11d2:	31 97       	sbiw	r30, 0x01	; 1
    11d4:	62 e0       	ldi	r22, 0x02	; 2
    11d6:	60 83       	st	Z, r22
    11d8:	31 97       	sbiw	r30, 0x01	; 1
    11da:	63 e0       	ldi	r22, 0x03	; 3
    11dc:	60 83       	st	Z, r22
    11de:	31 97       	sbiw	r30, 0x01	; 1
    11e0:	64 e0       	ldi	r22, 0x04	; 4
    11e2:	60 83       	st	Z, r22
    11e4:	31 97       	sbiw	r30, 0x01	; 1
    11e6:	65 e0       	ldi	r22, 0x05	; 5
    11e8:	60 83       	st	Z, r22
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	66 e0       	ldi	r22, 0x06	; 6
    11ee:	60 83       	st	Z, r22
    11f0:	31 97       	sbiw	r30, 0x01	; 1
    11f2:	67 e0       	ldi	r22, 0x07	; 7
    11f4:	60 83       	st	Z, r22
    11f6:	31 97       	sbiw	r30, 0x01	; 1
    11f8:	68 e0       	ldi	r22, 0x08	; 8
    11fa:	60 83       	st	Z, r22
    11fc:	31 97       	sbiw	r30, 0x01	; 1
    11fe:	69 e0       	ldi	r22, 0x09	; 9
    1200:	60 83       	st	Z, r22
    1202:	31 97       	sbiw	r30, 0x01	; 1
    1204:	60 e1       	ldi	r22, 0x10	; 16
    1206:	60 83       	st	Z, r22
    1208:	31 97       	sbiw	r30, 0x01	; 1
    120a:	30 83       	st	Z, r19
    120c:	31 97       	sbiw	r30, 0x01	; 1
    120e:	32 e1       	ldi	r19, 0x12	; 18
    1210:	30 83       	st	Z, r19
    1212:	31 97       	sbiw	r30, 0x01	; 1
    1214:	33 e1       	ldi	r19, 0x13	; 19
    1216:	30 83       	st	Z, r19
    1218:	31 97       	sbiw	r30, 0x01	; 1
    121a:	34 e1       	ldi	r19, 0x14	; 20
    121c:	30 83       	st	Z, r19
    121e:	31 97       	sbiw	r30, 0x01	; 1
    1220:	35 e1       	ldi	r19, 0x15	; 21
    1222:	30 83       	st	Z, r19
    1224:	31 97       	sbiw	r30, 0x01	; 1
    1226:	36 e1       	ldi	r19, 0x16	; 22
    1228:	30 83       	st	Z, r19
    122a:	31 97       	sbiw	r30, 0x01	; 1
    122c:	37 e1       	ldi	r19, 0x17	; 23
    122e:	30 83       	st	Z, r19
    1230:	31 97       	sbiw	r30, 0x01	; 1
    1232:	38 e1       	ldi	r19, 0x18	; 24
    1234:	30 83       	st	Z, r19
    1236:	31 97       	sbiw	r30, 0x01	; 1
    1238:	39 e1       	ldi	r19, 0x19	; 25
    123a:	30 83       	st	Z, r19
    123c:	31 97       	sbiw	r30, 0x01	; 1
    123e:	30 e2       	ldi	r19, 0x20	; 32
    1240:	30 83       	st	Z, r19
    1242:	31 97       	sbiw	r30, 0x01	; 1
    1244:	31 e2       	ldi	r19, 0x21	; 33
    1246:	30 83       	st	Z, r19
    1248:	31 97       	sbiw	r30, 0x01	; 1
    124a:	20 83       	st	Z, r18
    124c:	31 97       	sbiw	r30, 0x01	; 1
    124e:	23 e2       	ldi	r18, 0x23	; 35
    1250:	20 83       	st	Z, r18
    1252:	31 97       	sbiw	r30, 0x01	; 1
    1254:	40 83       	st	Z, r20
    1256:	31 97       	sbiw	r30, 0x01	; 1
    1258:	50 83       	st	Z, r21
    125a:	31 97       	sbiw	r30, 0x01	; 1
    125c:	26 e2       	ldi	r18, 0x26	; 38
    125e:	20 83       	st	Z, r18
    1260:	31 97       	sbiw	r30, 0x01	; 1
    1262:	27 e2       	ldi	r18, 0x27	; 39
    1264:	20 83       	st	Z, r18
    1266:	31 97       	sbiw	r30, 0x01	; 1
    1268:	28 e2       	ldi	r18, 0x28	; 40
    126a:	20 83       	st	Z, r18
    126c:	31 97       	sbiw	r30, 0x01	; 1
    126e:	29 e2       	ldi	r18, 0x29	; 41
    1270:	20 83       	st	Z, r18
    1272:	31 97       	sbiw	r30, 0x01	; 1
    1274:	20 e3       	ldi	r18, 0x30	; 48
    1276:	20 83       	st	Z, r18
    1278:	31 97       	sbiw	r30, 0x01	; 1
    127a:	21 e3       	ldi	r18, 0x31	; 49
    127c:	20 83       	st	Z, r18
    127e:	89 97       	sbiw	r24, 0x29	; 41
    1280:	08 95       	ret

00001282 <xPortStartScheduler>:
    1282:	8c e7       	ldi	r24, 0x7C	; 124
    1284:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1288:	8f ef       	ldi	r24, 0xFF	; 255
    128a:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1294:	91 e1       	ldi	r25, 0x11	; 17
    1296:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    129a:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    129e:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    12a2:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    12a6:	cd 91       	ld	r28, X+
    12a8:	cd bf       	out	0x3d, r28	; 61
    12aa:	dd 91       	ld	r29, X+
    12ac:	de bf       	out	0x3e, r29	; 62
    12ae:	ff 91       	pop	r31
    12b0:	ef 91       	pop	r30
    12b2:	df 91       	pop	r29
    12b4:	cf 91       	pop	r28
    12b6:	bf 91       	pop	r27
    12b8:	af 91       	pop	r26
    12ba:	9f 91       	pop	r25
    12bc:	8f 91       	pop	r24
    12be:	7f 91       	pop	r23
    12c0:	6f 91       	pop	r22
    12c2:	5f 91       	pop	r21
    12c4:	4f 91       	pop	r20
    12c6:	3f 91       	pop	r19
    12c8:	2f 91       	pop	r18
    12ca:	1f 91       	pop	r17
    12cc:	0f 91       	pop	r16
    12ce:	ff 90       	pop	r15
    12d0:	ef 90       	pop	r14
    12d2:	df 90       	pop	r13
    12d4:	cf 90       	pop	r12
    12d6:	bf 90       	pop	r11
    12d8:	af 90       	pop	r10
    12da:	9f 90       	pop	r9
    12dc:	8f 90       	pop	r8
    12de:	7f 90       	pop	r7
    12e0:	6f 90       	pop	r6
    12e2:	5f 90       	pop	r5
    12e4:	4f 90       	pop	r4
    12e6:	3f 90       	pop	r3
    12e8:	2f 90       	pop	r2
    12ea:	1f 90       	pop	r1
    12ec:	0f 90       	pop	r0
    12ee:	0c be       	out	0x3c, r0	; 60
    12f0:	0f 90       	pop	r0
    12f2:	0b be       	out	0x3b, r0	; 59
    12f4:	0f 90       	pop	r0
    12f6:	0f be       	out	0x3f, r0	; 63
    12f8:	0f 90       	pop	r0
    12fa:	08 95       	ret
    12fc:	08 95       	ret

000012fe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12fe:	0f 92       	push	r0
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
    1306:	0b b6       	in	r0, 0x3b	; 59
    1308:	0f 92       	push	r0
    130a:	0c b6       	in	r0, 0x3c	; 60
    130c:	0f 92       	push	r0
    130e:	1f 92       	push	r1
    1310:	11 24       	eor	r1, r1
    1312:	2f 92       	push	r2
    1314:	3f 92       	push	r3
    1316:	4f 92       	push	r4
    1318:	5f 92       	push	r5
    131a:	6f 92       	push	r6
    131c:	7f 92       	push	r7
    131e:	8f 92       	push	r8
    1320:	9f 92       	push	r9
    1322:	af 92       	push	r10
    1324:	bf 92       	push	r11
    1326:	cf 92       	push	r12
    1328:	df 92       	push	r13
    132a:	ef 92       	push	r14
    132c:	ff 92       	push	r15
    132e:	0f 93       	push	r16
    1330:	1f 93       	push	r17
    1332:	2f 93       	push	r18
    1334:	3f 93       	push	r19
    1336:	4f 93       	push	r20
    1338:	5f 93       	push	r21
    133a:	6f 93       	push	r22
    133c:	7f 93       	push	r23
    133e:	8f 93       	push	r24
    1340:	9f 93       	push	r25
    1342:	af 93       	push	r26
    1344:	bf 93       	push	r27
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	ef 93       	push	r30
    134c:	ff 93       	push	r31
    134e:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1352:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1356:	0d b6       	in	r0, 0x3d	; 61
    1358:	0d 92       	st	X+, r0
    135a:	0e b6       	in	r0, 0x3e	; 62
    135c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    135e:	0e 94 8e 10 	call	0x211c	; 0x211c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1362:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1366:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    136a:	cd 91       	ld	r28, X+
    136c:	cd bf       	out	0x3d, r28	; 61
    136e:	dd 91       	ld	r29, X+
    1370:	de bf       	out	0x3e, r29	; 62
    1372:	ff 91       	pop	r31
    1374:	ef 91       	pop	r30
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	bf 91       	pop	r27
    137c:	af 91       	pop	r26
    137e:	9f 91       	pop	r25
    1380:	8f 91       	pop	r24
    1382:	7f 91       	pop	r23
    1384:	6f 91       	pop	r22
    1386:	5f 91       	pop	r21
    1388:	4f 91       	pop	r20
    138a:	3f 91       	pop	r19
    138c:	2f 91       	pop	r18
    138e:	1f 91       	pop	r17
    1390:	0f 91       	pop	r16
    1392:	ff 90       	pop	r15
    1394:	ef 90       	pop	r14
    1396:	df 90       	pop	r13
    1398:	cf 90       	pop	r12
    139a:	bf 90       	pop	r11
    139c:	af 90       	pop	r10
    139e:	9f 90       	pop	r9
    13a0:	8f 90       	pop	r8
    13a2:	7f 90       	pop	r7
    13a4:	6f 90       	pop	r6
    13a6:	5f 90       	pop	r5
    13a8:	4f 90       	pop	r4
    13aa:	3f 90       	pop	r3
    13ac:	2f 90       	pop	r2
    13ae:	1f 90       	pop	r1
    13b0:	0f 90       	pop	r0
    13b2:	0c be       	out	0x3c, r0	; 60
    13b4:	0f 90       	pop	r0
    13b6:	0b be       	out	0x3b, r0	; 59
    13b8:	0f 90       	pop	r0
    13ba:	0f be       	out	0x3f, r0	; 63
    13bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13be:	08 95       	ret

000013c0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    13c0:	0f 92       	push	r0
    13c2:	0f b6       	in	r0, 0x3f	; 63
    13c4:	f8 94       	cli
    13c6:	0f 92       	push	r0
    13c8:	0b b6       	in	r0, 0x3b	; 59
    13ca:	0f 92       	push	r0
    13cc:	0c b6       	in	r0, 0x3c	; 60
    13ce:	0f 92       	push	r0
    13d0:	1f 92       	push	r1
    13d2:	11 24       	eor	r1, r1
    13d4:	2f 92       	push	r2
    13d6:	3f 92       	push	r3
    13d8:	4f 92       	push	r4
    13da:	5f 92       	push	r5
    13dc:	6f 92       	push	r6
    13de:	7f 92       	push	r7
    13e0:	8f 92       	push	r8
    13e2:	9f 92       	push	r9
    13e4:	af 92       	push	r10
    13e6:	bf 92       	push	r11
    13e8:	cf 92       	push	r12
    13ea:	df 92       	push	r13
    13ec:	ef 92       	push	r14
    13ee:	ff 92       	push	r15
    13f0:	0f 93       	push	r16
    13f2:	1f 93       	push	r17
    13f4:	2f 93       	push	r18
    13f6:	3f 93       	push	r19
    13f8:	4f 93       	push	r20
    13fa:	5f 93       	push	r21
    13fc:	6f 93       	push	r22
    13fe:	7f 93       	push	r23
    1400:	8f 93       	push	r24
    1402:	9f 93       	push	r25
    1404:	af 93       	push	r26
    1406:	bf 93       	push	r27
    1408:	cf 93       	push	r28
    140a:	df 93       	push	r29
    140c:	ef 93       	push	r30
    140e:	ff 93       	push	r31
    1410:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    1414:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1418:	0d b6       	in	r0, 0x3d	; 61
    141a:	0d 92       	st	X+, r0
    141c:	0e b6       	in	r0, 0x3e	; 62
    141e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1420:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vTaskIncrementTick>
	vTaskSwitchContext();
    1424:	0e 94 8e 10 	call	0x211c	; 0x211c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1428:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    142c:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1430:	cd 91       	ld	r28, X+
    1432:	cd bf       	out	0x3d, r28	; 61
    1434:	dd 91       	ld	r29, X+
    1436:	de bf       	out	0x3e, r29	; 62
    1438:	ff 91       	pop	r31
    143a:	ef 91       	pop	r30
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	bf 91       	pop	r27
    1442:	af 91       	pop	r26
    1444:	9f 91       	pop	r25
    1446:	8f 91       	pop	r24
    1448:	7f 91       	pop	r23
    144a:	6f 91       	pop	r22
    144c:	5f 91       	pop	r21
    144e:	4f 91       	pop	r20
    1450:	3f 91       	pop	r19
    1452:	2f 91       	pop	r18
    1454:	1f 91       	pop	r17
    1456:	0f 91       	pop	r16
    1458:	ff 90       	pop	r15
    145a:	ef 90       	pop	r14
    145c:	df 90       	pop	r13
    145e:	cf 90       	pop	r12
    1460:	bf 90       	pop	r11
    1462:	af 90       	pop	r10
    1464:	9f 90       	pop	r9
    1466:	8f 90       	pop	r8
    1468:	7f 90       	pop	r7
    146a:	6f 90       	pop	r6
    146c:	5f 90       	pop	r5
    146e:	4f 90       	pop	r4
    1470:	3f 90       	pop	r3
    1472:	2f 90       	pop	r2
    1474:	1f 90       	pop	r1
    1476:	0f 90       	pop	r0
    1478:	0c be       	out	0x3c, r0	; 60
    147a:	0f 90       	pop	r0
    147c:	0b be       	out	0x3b, r0	; 59
    147e:	0f 90       	pop	r0
    1480:	0f be       	out	0x3f, r0	; 63
    1482:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1484:	08 95       	ret

00001486 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1486:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    148a:	18 95       	reti

0000148c <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    148c:	cf 93       	push	r28
    148e:	df 93       	push	r29
    1490:	ec 01       	movw	r28, r24
    1492:	88 a1       	ldd	r24, Y+32	; 0x20
    1494:	81 11       	cpse	r24, r1
    1496:	0b c0       	rjmp	.+22     	; 0x14ae <prvCopyDataToQueue+0x22>
    1498:	88 81       	ld	r24, Y
    149a:	99 81       	ldd	r25, Y+1	; 0x01
    149c:	89 2b       	or	r24, r25
    149e:	e1 f5       	brne	.+120    	; 0x1518 <prvCopyDataToQueue+0x8c>
    14a0:	8a 81       	ldd	r24, Y+2	; 0x02
    14a2:	9b 81       	ldd	r25, Y+3	; 0x03
    14a4:	0e 94 49 12 	call	0x2492	; 0x2492 <vTaskPriorityDisinherit>
    14a8:	1a 82       	std	Y+2, r1	; 0x02
    14aa:	1b 82       	std	Y+3, r1	; 0x03
    14ac:	35 c0       	rjmp	.+106    	; 0x1518 <prvCopyDataToQueue+0x8c>
    14ae:	41 11       	cpse	r20, r1
    14b0:	17 c0       	rjmp	.+46     	; 0x14e0 <prvCopyDataToQueue+0x54>
    14b2:	48 2f       	mov	r20, r24
    14b4:	50 e0       	ldi	r21, 0x00	; 0
    14b6:	8c 81       	ldd	r24, Y+4	; 0x04
    14b8:	9d 81       	ldd	r25, Y+5	; 0x05
    14ba:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <memcpy>
    14be:	28 a1       	ldd	r18, Y+32	; 0x20
    14c0:	8c 81       	ldd	r24, Y+4	; 0x04
    14c2:	9d 81       	ldd	r25, Y+5	; 0x05
    14c4:	82 0f       	add	r24, r18
    14c6:	91 1d       	adc	r25, r1
    14c8:	8c 83       	std	Y+4, r24	; 0x04
    14ca:	9d 83       	std	Y+5, r25	; 0x05
    14cc:	2a 81       	ldd	r18, Y+2	; 0x02
    14ce:	3b 81       	ldd	r19, Y+3	; 0x03
    14d0:	82 17       	cp	r24, r18
    14d2:	93 07       	cpc	r25, r19
    14d4:	08 f1       	brcs	.+66     	; 0x1518 <prvCopyDataToQueue+0x8c>
    14d6:	88 81       	ld	r24, Y
    14d8:	99 81       	ldd	r25, Y+1	; 0x01
    14da:	8c 83       	std	Y+4, r24	; 0x04
    14dc:	9d 83       	std	Y+5, r25	; 0x05
    14de:	1c c0       	rjmp	.+56     	; 0x1518 <prvCopyDataToQueue+0x8c>
    14e0:	48 2f       	mov	r20, r24
    14e2:	50 e0       	ldi	r21, 0x00	; 0
    14e4:	8e 81       	ldd	r24, Y+6	; 0x06
    14e6:	9f 81       	ldd	r25, Y+7	; 0x07
    14e8:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <memcpy>
    14ec:	88 a1       	ldd	r24, Y+32	; 0x20
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	91 95       	neg	r25
    14f2:	81 95       	neg	r24
    14f4:	91 09       	sbc	r25, r1
    14f6:	2e 81       	ldd	r18, Y+6	; 0x06
    14f8:	3f 81       	ldd	r19, Y+7	; 0x07
    14fa:	28 0f       	add	r18, r24
    14fc:	39 1f       	adc	r19, r25
    14fe:	2e 83       	std	Y+6, r18	; 0x06
    1500:	3f 83       	std	Y+7, r19	; 0x07
    1502:	48 81       	ld	r20, Y
    1504:	59 81       	ldd	r21, Y+1	; 0x01
    1506:	24 17       	cp	r18, r20
    1508:	35 07       	cpc	r19, r21
    150a:	30 f4       	brcc	.+12     	; 0x1518 <prvCopyDataToQueue+0x8c>
    150c:	2a 81       	ldd	r18, Y+2	; 0x02
    150e:	3b 81       	ldd	r19, Y+3	; 0x03
    1510:	82 0f       	add	r24, r18
    1512:	93 1f       	adc	r25, r19
    1514:	8e 83       	std	Y+6, r24	; 0x06
    1516:	9f 83       	std	Y+7, r25	; 0x07
    1518:	8e 8d       	ldd	r24, Y+30	; 0x1e
    151a:	8f 5f       	subi	r24, 0xFF	; 255
    151c:	8e 8f       	std	Y+30, r24	; 0x1e
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	08 95       	ret

00001524 <prvCopyDataFromQueue>:
    1524:	fc 01       	movw	r30, r24
    1526:	80 81       	ld	r24, Z
    1528:	91 81       	ldd	r25, Z+1	; 0x01
    152a:	00 97       	sbiw	r24, 0x00	; 0
    152c:	a1 f0       	breq	.+40     	; 0x1556 <prvCopyDataFromQueue+0x32>
    152e:	40 a1       	ldd	r20, Z+32	; 0x20
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	26 81       	ldd	r18, Z+6	; 0x06
    1534:	37 81       	ldd	r19, Z+7	; 0x07
    1536:	24 0f       	add	r18, r20
    1538:	35 1f       	adc	r19, r21
    153a:	26 83       	std	Z+6, r18	; 0x06
    153c:	37 83       	std	Z+7, r19	; 0x07
    153e:	a2 81       	ldd	r26, Z+2	; 0x02
    1540:	b3 81       	ldd	r27, Z+3	; 0x03
    1542:	2a 17       	cp	r18, r26
    1544:	3b 07       	cpc	r19, r27
    1546:	10 f0       	brcs	.+4      	; 0x154c <prvCopyDataFromQueue+0x28>
    1548:	86 83       	std	Z+6, r24	; 0x06
    154a:	97 83       	std	Z+7, r25	; 0x07
    154c:	cb 01       	movw	r24, r22
    154e:	66 81       	ldd	r22, Z+6	; 0x06
    1550:	77 81       	ldd	r23, Z+7	; 0x07
    1552:	0e 94 7c 1f 	call	0x3ef8	; 0x3ef8 <memcpy>
    1556:	08 95       	ret

00001558 <prvUnlockQueue>:
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    1560:	ec 01       	movw	r28, r24
    1562:	0f b6       	in	r0, 0x3f	; 63
    1564:	f8 94       	cli
    1566:	0f 92       	push	r0
    1568:	8a a1       	ldd	r24, Y+34	; 0x22
    156a:	18 16       	cp	r1, r24
    156c:	b4 f4       	brge	.+44     	; 0x159a <prvUnlockQueue+0x42>
    156e:	8b 89       	ldd	r24, Y+19	; 0x13
    1570:	81 11       	cpse	r24, r1
    1572:	05 c0       	rjmp	.+10     	; 0x157e <prvUnlockQueue+0x26>
    1574:	12 c0       	rjmp	.+36     	; 0x159a <prvUnlockQueue+0x42>
    1576:	8b 89       	ldd	r24, Y+19	; 0x13
    1578:	81 11       	cpse	r24, r1
    157a:	04 c0       	rjmp	.+8      	; 0x1584 <prvUnlockQueue+0x2c>
    157c:	0e c0       	rjmp	.+28     	; 0x159a <prvUnlockQueue+0x42>
    157e:	8e 01       	movw	r16, r28
    1580:	0d 5e       	subi	r16, 0xED	; 237
    1582:	1f 4f       	sbci	r17, 0xFF	; 255
    1584:	c8 01       	movw	r24, r16
    1586:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    158a:	81 11       	cpse	r24, r1
    158c:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <vTaskMissedYield>
    1590:	8a a1       	ldd	r24, Y+34	; 0x22
    1592:	81 50       	subi	r24, 0x01	; 1
    1594:	8a a3       	std	Y+34, r24	; 0x22
    1596:	18 16       	cp	r1, r24
    1598:	74 f3       	brlt	.-36     	; 0x1576 <prvUnlockQueue+0x1e>
    159a:	8f ef       	ldi	r24, 0xFF	; 255
    159c:	8a a3       	std	Y+34, r24	; 0x22
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	0f b6       	in	r0, 0x3f	; 63
    15a4:	f8 94       	cli
    15a6:	0f 92       	push	r0
    15a8:	89 a1       	ldd	r24, Y+33	; 0x21
    15aa:	18 16       	cp	r1, r24
    15ac:	b4 f4       	brge	.+44     	; 0x15da <prvUnlockQueue+0x82>
    15ae:	88 85       	ldd	r24, Y+8	; 0x08
    15b0:	81 11       	cpse	r24, r1
    15b2:	05 c0       	rjmp	.+10     	; 0x15be <prvUnlockQueue+0x66>
    15b4:	12 c0       	rjmp	.+36     	; 0x15da <prvUnlockQueue+0x82>
    15b6:	88 85       	ldd	r24, Y+8	; 0x08
    15b8:	81 11       	cpse	r24, r1
    15ba:	04 c0       	rjmp	.+8      	; 0x15c4 <prvUnlockQueue+0x6c>
    15bc:	0e c0       	rjmp	.+28     	; 0x15da <prvUnlockQueue+0x82>
    15be:	8e 01       	movw	r16, r28
    15c0:	08 5f       	subi	r16, 0xF8	; 248
    15c2:	1f 4f       	sbci	r17, 0xFF	; 255
    15c4:	c8 01       	movw	r24, r16
    15c6:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    15ca:	81 11       	cpse	r24, r1
    15cc:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <vTaskMissedYield>
    15d0:	89 a1       	ldd	r24, Y+33	; 0x21
    15d2:	81 50       	subi	r24, 0x01	; 1
    15d4:	89 a3       	std	Y+33, r24	; 0x21
    15d6:	18 16       	cp	r1, r24
    15d8:	74 f3       	brlt	.-36     	; 0x15b6 <prvUnlockQueue+0x5e>
    15da:	8f ef       	ldi	r24, 0xFF	; 255
    15dc:	89 a3       	std	Y+33, r24	; 0x21
    15de:	0f 90       	pop	r0
    15e0:	0f be       	out	0x3f, r0	; 63
    15e2:	df 91       	pop	r29
    15e4:	cf 91       	pop	r28
    15e6:	1f 91       	pop	r17
    15e8:	0f 91       	pop	r16
    15ea:	08 95       	ret

000015ec <xQueueGenericReset>:
    15ec:	1f 93       	push	r17
    15ee:	cf 93       	push	r28
    15f0:	df 93       	push	r29
    15f2:	61 30       	cpi	r22, 0x01	; 1
    15f4:	59 f0       	breq	.+22     	; 0x160c <xQueueGenericReset+0x20>
    15f6:	fc 01       	movw	r30, r24
    15f8:	23 89       	ldd	r18, Z+19	; 0x13
    15fa:	30 85       	ldd	r19, Z+8	; 0x08
    15fc:	31 11       	cpse	r19, r1
    15fe:	2c c0       	rjmp	.+88     	; 0x1658 <xQueueGenericReset+0x6c>
    1600:	11 e0       	ldi	r17, 0x01	; 1
    1602:	21 11       	cpse	r18, r1
    1604:	10 e0       	ldi	r17, 0x00	; 0
    1606:	21 11       	cpse	r18, r1
    1608:	28 c0       	rjmp	.+80     	; 0x165a <xQueueGenericReset+0x6e>
    160a:	01 c0       	rjmp	.+2      	; 0x160e <xQueueGenericReset+0x22>
    160c:	11 e0       	ldi	r17, 0x01	; 1
    160e:	ec 01       	movw	r28, r24
    1610:	48 81       	ld	r20, Y
    1612:	59 81       	ldd	r21, Y+1	; 0x01
    1614:	28 a1       	ldd	r18, Y+32	; 0x20
    1616:	30 e0       	ldi	r19, 0x00	; 0
    1618:	6f 8d       	ldd	r22, Y+31	; 0x1f
    161a:	62 9f       	mul	r22, r18
    161c:	c0 01       	movw	r24, r0
    161e:	63 9f       	mul	r22, r19
    1620:	90 0d       	add	r25, r0
    1622:	11 24       	eor	r1, r1
    1624:	ba 01       	movw	r22, r20
    1626:	68 0f       	add	r22, r24
    1628:	79 1f       	adc	r23, r25
    162a:	6a 83       	std	Y+2, r22	; 0x02
    162c:	7b 83       	std	Y+3, r23	; 0x03
    162e:	1e 8e       	std	Y+30, r1	; 0x1e
    1630:	4c 83       	std	Y+4, r20	; 0x04
    1632:	5d 83       	std	Y+5, r21	; 0x05
    1634:	82 1b       	sub	r24, r18
    1636:	93 0b       	sbc	r25, r19
    1638:	84 0f       	add	r24, r20
    163a:	95 1f       	adc	r25, r21
    163c:	8e 83       	std	Y+6, r24	; 0x06
    163e:	9f 83       	std	Y+7, r25	; 0x07
    1640:	8f ef       	ldi	r24, 0xFF	; 255
    1642:	89 a3       	std	Y+33, r24	; 0x21
    1644:	8a a3       	std	Y+34, r24	; 0x22
    1646:	ce 01       	movw	r24, r28
    1648:	08 96       	adiw	r24, 0x08	; 8
    164a:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    164e:	ce 01       	movw	r24, r28
    1650:	43 96       	adiw	r24, 0x13	; 19
    1652:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1656:	01 c0       	rjmp	.+2      	; 0x165a <xQueueGenericReset+0x6e>
    1658:	10 e0       	ldi	r17, 0x00	; 0
    165a:	81 2f       	mov	r24, r17
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	08 95       	ret

00001664 <xQueueGenericCreate>:
    1664:	0f 93       	push	r16
    1666:	1f 93       	push	r17
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	88 23       	and	r24, r24
    166e:	01 f1       	breq	.+64     	; 0x16b0 <xQueueGenericCreate+0x4c>
    1670:	06 2f       	mov	r16, r22
    1672:	18 2f       	mov	r17, r24
    1674:	83 e2       	ldi	r24, 0x23	; 35
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    167c:	ec 01       	movw	r28, r24
    167e:	89 2b       	or	r24, r25
    1680:	c9 f0       	breq	.+50     	; 0x16b4 <xQueueGenericCreate+0x50>
    1682:	10 9f       	mul	r17, r16
    1684:	c0 01       	movw	r24, r0
    1686:	11 24       	eor	r1, r1
    1688:	01 96       	adiw	r24, 0x01	; 1
    168a:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    168e:	88 83       	st	Y, r24
    1690:	99 83       	std	Y+1, r25	; 0x01
    1692:	89 2b       	or	r24, r25
    1694:	39 f0       	breq	.+14     	; 0x16a4 <xQueueGenericCreate+0x40>
    1696:	1f 8f       	std	Y+31, r17	; 0x1f
    1698:	08 a3       	std	Y+32, r16	; 0x20
    169a:	61 e0       	ldi	r22, 0x01	; 1
    169c:	ce 01       	movw	r24, r28
    169e:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <xQueueGenericReset>
    16a2:	08 c0       	rjmp	.+16     	; 0x16b4 <xQueueGenericCreate+0x50>
    16a4:	ce 01       	movw	r24, r28
    16a6:	0e 94 e6 07 	call	0xfcc	; 0xfcc <vPortFree>
    16aa:	c0 e0       	ldi	r28, 0x00	; 0
    16ac:	d0 e0       	ldi	r29, 0x00	; 0
    16ae:	02 c0       	rjmp	.+4      	; 0x16b4 <xQueueGenericCreate+0x50>
    16b0:	c0 e0       	ldi	r28, 0x00	; 0
    16b2:	d0 e0       	ldi	r29, 0x00	; 0
    16b4:	ce 01       	movw	r24, r28
    16b6:	df 91       	pop	r29
    16b8:	cf 91       	pop	r28
    16ba:	1f 91       	pop	r17
    16bc:	0f 91       	pop	r16
    16be:	08 95       	ret

000016c0 <xQueueGenericSend>:
    16c0:	af 92       	push	r10
    16c2:	bf 92       	push	r11
    16c4:	cf 92       	push	r12
    16c6:	df 92       	push	r13
    16c8:	ef 92       	push	r14
    16ca:	ff 92       	push	r15
    16cc:	0f 93       	push	r16
    16ce:	1f 93       	push	r17
    16d0:	cf 93       	push	r28
    16d2:	df 93       	push	r29
    16d4:	cd b7       	in	r28, 0x3d	; 61
    16d6:	de b7       	in	r29, 0x3e	; 62
    16d8:	29 97       	sbiw	r28, 0x09	; 9
    16da:	cd bf       	out	0x3d, r28	; 61
    16dc:	de bf       	out	0x3e, r29	; 62
    16de:	7c 01       	movw	r14, r24
    16e0:	5b 01       	movw	r10, r22
    16e2:	2e 83       	std	Y+6, r18	; 0x06
    16e4:	3f 83       	std	Y+7, r19	; 0x07
    16e6:	48 87       	std	Y+8, r20	; 0x08
    16e8:	59 87       	std	Y+9, r21	; 0x09
    16ea:	10 e0       	ldi	r17, 0x00	; 0
    16ec:	6c 01       	movw	r12, r24
    16ee:	88 e0       	ldi	r24, 0x08	; 8
    16f0:	c8 0e       	add	r12, r24
    16f2:	d1 1c       	adc	r13, r1
    16f4:	0f b6       	in	r0, 0x3f	; 63
    16f6:	f8 94       	cli
    16f8:	0f 92       	push	r0
    16fa:	f7 01       	movw	r30, r14
    16fc:	96 8d       	ldd	r25, Z+30	; 0x1e
    16fe:	87 8d       	ldd	r24, Z+31	; 0x1f
    1700:	98 17       	cp	r25, r24
    1702:	a8 f4       	brcc	.+42     	; 0x172e <xQueueGenericSend+0x6e>
    1704:	40 2f       	mov	r20, r16
    1706:	b5 01       	movw	r22, r10
    1708:	c7 01       	movw	r24, r14
    170a:	0e 94 46 0a 	call	0x148c	; 0x148c <prvCopyDataToQueue>
    170e:	f7 01       	movw	r30, r14
    1710:	83 89       	ldd	r24, Z+19	; 0x13
    1712:	88 23       	and	r24, r24
    1714:	41 f0       	breq	.+16     	; 0x1726 <xQueueGenericSend+0x66>
    1716:	c7 01       	movw	r24, r14
    1718:	43 96       	adiw	r24, 0x13	; 19
    171a:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    171e:	81 30       	cpi	r24, 0x01	; 1
    1720:	11 f4       	brne	.+4      	; 0x1726 <xQueueGenericSend+0x66>
    1722:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    1726:	0f 90       	pop	r0
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	81 e0       	ldi	r24, 0x01	; 1
    172c:	56 c0       	rjmp	.+172    	; 0x17da <xQueueGenericSend+0x11a>
    172e:	8e 81       	ldd	r24, Y+6	; 0x06
    1730:	9f 81       	ldd	r25, Y+7	; 0x07
    1732:	a8 85       	ldd	r26, Y+8	; 0x08
    1734:	b9 85       	ldd	r27, Y+9	; 0x09
    1736:	89 2b       	or	r24, r25
    1738:	8a 2b       	or	r24, r26
    173a:	8b 2b       	or	r24, r27
    173c:	21 f4       	brne	.+8      	; 0x1746 <xQueueGenericSend+0x86>
    173e:	0f 90       	pop	r0
    1740:	0f be       	out	0x3f, r0	; 63
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	4a c0       	rjmp	.+148    	; 0x17da <xQueueGenericSend+0x11a>
    1746:	11 11       	cpse	r17, r1
    1748:	05 c0       	rjmp	.+10     	; 0x1754 <xQueueGenericSend+0x94>
    174a:	ce 01       	movw	r24, r28
    174c:	01 96       	adiw	r24, 0x01	; 1
    174e:	0e 94 54 11 	call	0x22a8	; 0x22a8 <vTaskSetTimeOutState>
    1752:	11 e0       	ldi	r17, 0x01	; 1
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vTaskSuspendAll>
    175c:	0f b6       	in	r0, 0x3f	; 63
    175e:	f8 94       	cli
    1760:	0f 92       	push	r0
    1762:	f7 01       	movw	r30, r14
    1764:	81 a1       	ldd	r24, Z+33	; 0x21
    1766:	8f 3f       	cpi	r24, 0xFF	; 255
    1768:	09 f4       	brne	.+2      	; 0x176c <xQueueGenericSend+0xac>
    176a:	11 a2       	std	Z+33, r1	; 0x21
    176c:	f7 01       	movw	r30, r14
    176e:	82 a1       	ldd	r24, Z+34	; 0x22
    1770:	8f 3f       	cpi	r24, 0xFF	; 255
    1772:	09 f4       	brne	.+2      	; 0x1776 <xQueueGenericSend+0xb6>
    1774:	12 a2       	std	Z+34, r1	; 0x22
    1776:	0f 90       	pop	r0
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	be 01       	movw	r22, r28
    177c:	6a 5f       	subi	r22, 0xFA	; 250
    177e:	7f 4f       	sbci	r23, 0xFF	; 255
    1780:	ce 01       	movw	r24, r28
    1782:	01 96       	adiw	r24, 0x01	; 1
    1784:	0e 94 65 11 	call	0x22ca	; 0x22ca <xTaskCheckForTimeOut>
    1788:	81 11       	cpse	r24, r1
    178a:	21 c0       	rjmp	.+66     	; 0x17ce <xQueueGenericSend+0x10e>
    178c:	0f b6       	in	r0, 0x3f	; 63
    178e:	f8 94       	cli
    1790:	0f 92       	push	r0
    1792:	f7 01       	movw	r30, r14
    1794:	96 8d       	ldd	r25, Z+30	; 0x1e
    1796:	0f 90       	pop	r0
    1798:	0f be       	out	0x3f, r0	; 63
    179a:	87 8d       	ldd	r24, Z+31	; 0x1f
    179c:	98 13       	cpse	r25, r24
    179e:	11 c0       	rjmp	.+34     	; 0x17c2 <xQueueGenericSend+0x102>
    17a0:	4e 81       	ldd	r20, Y+6	; 0x06
    17a2:	5f 81       	ldd	r21, Y+7	; 0x07
    17a4:	68 85       	ldd	r22, Y+8	; 0x08
    17a6:	79 85       	ldd	r23, Y+9	; 0x09
    17a8:	c6 01       	movw	r24, r12
    17aa:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <vTaskPlaceOnEventList>
    17ae:	c7 01       	movw	r24, r14
    17b0:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
    17b4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
    17b8:	81 11       	cpse	r24, r1
    17ba:	9c cf       	rjmp	.-200    	; 0x16f4 <xQueueGenericSend+0x34>
    17bc:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    17c0:	99 cf       	rjmp	.-206    	; 0x16f4 <xQueueGenericSend+0x34>
    17c2:	c7 01       	movw	r24, r14
    17c4:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
    17c8:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
    17cc:	93 cf       	rjmp	.-218    	; 0x16f4 <xQueueGenericSend+0x34>
    17ce:	c7 01       	movw	r24, r14
    17d0:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
    17d4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
    17d8:	80 e0       	ldi	r24, 0x00	; 0
    17da:	29 96       	adiw	r28, 0x09	; 9
    17dc:	cd bf       	out	0x3d, r28	; 61
    17de:	de bf       	out	0x3e, r29	; 62
    17e0:	df 91       	pop	r29
    17e2:	cf 91       	pop	r28
    17e4:	1f 91       	pop	r17
    17e6:	0f 91       	pop	r16
    17e8:	ff 90       	pop	r15
    17ea:	ef 90       	pop	r14
    17ec:	df 90       	pop	r13
    17ee:	cf 90       	pop	r12
    17f0:	bf 90       	pop	r11
    17f2:	af 90       	pop	r10
    17f4:	08 95       	ret

000017f6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    17f6:	0f 93       	push	r16
    17f8:	1f 93       	push	r17
    17fa:	cf 93       	push	r28
    17fc:	df 93       	push	r29
    17fe:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1800:	fc 01       	movw	r30, r24
    1802:	56 8d       	ldd	r21, Z+30	; 0x1e
    1804:	37 8d       	ldd	r19, Z+31	; 0x1f
    1806:	53 17       	cp	r21, r19
    1808:	c0 f4       	brcc	.+48     	; 0x183a <xQueueGenericSendFromISR+0x44>
    180a:	42 2f       	mov	r20, r18
    180c:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    180e:	0e 94 46 0a 	call	0x148c	; 0x148c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1812:	8a a1       	ldd	r24, Y+34	; 0x22
    1814:	8f 3f       	cpi	r24, 0xFF	; 255
    1816:	69 f4       	brne	.+26     	; 0x1832 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1818:	8b 89       	ldd	r24, Y+19	; 0x13
    181a:	88 23       	and	r24, r24
    181c:	81 f0       	breq	.+32     	; 0x183e <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    181e:	ce 01       	movw	r24, r28
    1820:	43 96       	adiw	r24, 0x13	; 19
    1822:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    1826:	88 23       	and	r24, r24
    1828:	61 f0       	breq	.+24     	; 0x1842 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	f8 01       	movw	r30, r16
    182e:	80 83       	st	Z, r24
    1830:	09 c0       	rjmp	.+18     	; 0x1844 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1832:	8f 5f       	subi	r24, 0xFF	; 255
    1834:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1836:	81 e0       	ldi	r24, 0x01	; 1
    1838:	05 c0       	rjmp	.+10     	; 0x1844 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    183a:	80 e0       	ldi	r24, 0x00	; 0
    183c:	03 c0       	rjmp	.+6      	; 0x1844 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	01 c0       	rjmp	.+2      	; 0x1844 <xQueueGenericSendFromISR+0x4e>
    1842:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	1f 91       	pop	r17
    184a:	0f 91       	pop	r16
    184c:	08 95       	ret

0000184e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    184e:	af 92       	push	r10
    1850:	bf 92       	push	r11
    1852:	cf 92       	push	r12
    1854:	df 92       	push	r13
    1856:	ef 92       	push	r14
    1858:	ff 92       	push	r15
    185a:	0f 93       	push	r16
    185c:	1f 93       	push	r17
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	cd b7       	in	r28, 0x3d	; 61
    1864:	de b7       	in	r29, 0x3e	; 62
    1866:	29 97       	sbiw	r28, 0x09	; 9
    1868:	cd bf       	out	0x3d, r28	; 61
    186a:	de bf       	out	0x3e, r29	; 62
    186c:	7c 01       	movw	r14, r24
    186e:	5b 01       	movw	r10, r22
    1870:	2e 83       	std	Y+6, r18	; 0x06
    1872:	3f 83       	std	Y+7, r19	; 0x07
    1874:	48 87       	std	Y+8, r20	; 0x08
    1876:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1878:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    187a:	6c 01       	movw	r12, r24
    187c:	83 e1       	ldi	r24, 0x13	; 19
    187e:	c8 0e       	add	r12, r24
    1880:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1882:	0f b6       	in	r0, 0x3f	; 63
    1884:	f8 94       	cli
    1886:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1888:	f7 01       	movw	r30, r14
    188a:	86 8d       	ldd	r24, Z+30	; 0x1e
    188c:	88 23       	and	r24, r24
    188e:	99 f1       	breq	.+102    	; 0x18f6 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1890:	c6 80       	ldd	r12, Z+6	; 0x06
    1892:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1894:	b5 01       	movw	r22, r10
    1896:	c7 01       	movw	r24, r14
    1898:	0e 94 92 0a 	call	0x1524	; 0x1524 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    189c:	01 11       	cpse	r16, r1
    189e:	1a c0       	rjmp	.+52     	; 0x18d4 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    18a0:	f7 01       	movw	r30, r14
    18a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    18a4:	81 50       	subi	r24, 0x01	; 1
    18a6:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    18a8:	80 81       	ld	r24, Z
    18aa:	91 81       	ldd	r25, Z+1	; 0x01
    18ac:	89 2b       	or	r24, r25
    18ae:	29 f4       	brne	.+10     	; 0x18ba <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    18b0:	0e 94 ef 11 	call	0x23de	; 0x23de <xTaskGetCurrentTaskHandle>
    18b4:	f7 01       	movw	r30, r14
    18b6:	82 83       	std	Z+2, r24	; 0x02
    18b8:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    18ba:	f7 01       	movw	r30, r14
    18bc:	80 85       	ldd	r24, Z+8	; 0x08
    18be:	88 23       	and	r24, r24
    18c0:	b1 f0       	breq	.+44     	; 0x18ee <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    18c2:	c7 01       	movw	r24, r14
    18c4:	08 96       	adiw	r24, 0x08	; 8
    18c6:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    18ca:	81 30       	cpi	r24, 0x01	; 1
    18cc:	81 f4       	brne	.+32     	; 0x18ee <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    18ce:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    18d2:	0d c0       	rjmp	.+26     	; 0x18ee <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    18d4:	f7 01       	movw	r30, r14
    18d6:	c6 82       	std	Z+6, r12	; 0x06
    18d8:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18da:	83 89       	ldd	r24, Z+19	; 0x13
    18dc:	88 23       	and	r24, r24
    18de:	39 f0       	breq	.+14     	; 0x18ee <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18e0:	c7 01       	movw	r24, r14
    18e2:	43 96       	adiw	r24, 0x13	; 19
    18e4:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    18e8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    18ea:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    18ee:	0f 90       	pop	r0
    18f0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18f2:	81 e0       	ldi	r24, 0x01	; 1
    18f4:	62 c0       	rjmp	.+196    	; 0x19ba <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    18f6:	8e 81       	ldd	r24, Y+6	; 0x06
    18f8:	9f 81       	ldd	r25, Y+7	; 0x07
    18fa:	a8 85       	ldd	r26, Y+8	; 0x08
    18fc:	b9 85       	ldd	r27, Y+9	; 0x09
    18fe:	89 2b       	or	r24, r25
    1900:	8a 2b       	or	r24, r26
    1902:	8b 2b       	or	r24, r27
    1904:	21 f4       	brne	.+8      	; 0x190e <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    190a:	80 e0       	ldi	r24, 0x00	; 0
    190c:	56 c0       	rjmp	.+172    	; 0x19ba <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    190e:	11 11       	cpse	r17, r1
    1910:	05 c0       	rjmp	.+10     	; 0x191c <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1912:	ce 01       	movw	r24, r28
    1914:	01 96       	adiw	r24, 0x01	; 1
    1916:	0e 94 54 11 	call	0x22a8	; 0x22a8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    191a:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    191c:	0f 90       	pop	r0
    191e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1920:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1924:	0f b6       	in	r0, 0x3f	; 63
    1926:	f8 94       	cli
    1928:	0f 92       	push	r0
    192a:	f7 01       	movw	r30, r14
    192c:	81 a1       	ldd	r24, Z+33	; 0x21
    192e:	8f 3f       	cpi	r24, 0xFF	; 255
    1930:	09 f4       	brne	.+2      	; 0x1934 <xQueueGenericReceive+0xe6>
    1932:	11 a2       	std	Z+33, r1	; 0x21
    1934:	f7 01       	movw	r30, r14
    1936:	82 a1       	ldd	r24, Z+34	; 0x22
    1938:	8f 3f       	cpi	r24, 0xFF	; 255
    193a:	09 f4       	brne	.+2      	; 0x193e <xQueueGenericReceive+0xf0>
    193c:	12 a2       	std	Z+34, r1	; 0x22
    193e:	0f 90       	pop	r0
    1940:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1942:	be 01       	movw	r22, r28
    1944:	6a 5f       	subi	r22, 0xFA	; 250
    1946:	7f 4f       	sbci	r23, 0xFF	; 255
    1948:	ce 01       	movw	r24, r28
    194a:	01 96       	adiw	r24, 0x01	; 1
    194c:	0e 94 65 11 	call	0x22ca	; 0x22ca <xTaskCheckForTimeOut>
    1950:	81 11       	cpse	r24, r1
    1952:	2d c0       	rjmp	.+90     	; 0x19ae <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1954:	0f b6       	in	r0, 0x3f	; 63
    1956:	f8 94       	cli
    1958:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    195a:	f7 01       	movw	r30, r14
    195c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    195e:	0f 90       	pop	r0
    1960:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1962:	81 11       	cpse	r24, r1
    1964:	1e c0       	rjmp	.+60     	; 0x19a2 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1966:	80 81       	ld	r24, Z
    1968:	91 81       	ldd	r25, Z+1	; 0x01
    196a:	89 2b       	or	r24, r25
    196c:	49 f4       	brne	.+18     	; 0x1980 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    196e:	0f b6       	in	r0, 0x3f	; 63
    1970:	f8 94       	cli
    1972:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1974:	82 81       	ldd	r24, Z+2	; 0x02
    1976:	93 81       	ldd	r25, Z+3	; 0x03
    1978:	0e 94 f4 11 	call	0x23e8	; 0x23e8 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    197c:	0f 90       	pop	r0
    197e:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1980:	4e 81       	ldd	r20, Y+6	; 0x06
    1982:	5f 81       	ldd	r21, Y+7	; 0x07
    1984:	68 85       	ldd	r22, Y+8	; 0x08
    1986:	79 85       	ldd	r23, Y+9	; 0x09
    1988:	c6 01       	movw	r24, r12
    198a:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    198e:	c7 01       	movw	r24, r14
    1990:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1994:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
    1998:	81 11       	cpse	r24, r1
    199a:	73 cf       	rjmp	.-282    	; 0x1882 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    199c:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    19a0:	70 cf       	rjmp	.-288    	; 0x1882 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    19a2:	c7 01       	movw	r24, r14
    19a4:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19a8:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
    19ac:	6a cf       	rjmp	.-300    	; 0x1882 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    19ae:	c7 01       	movw	r24, r14
    19b0:	0e 94 ac 0a 	call	0x1558	; 0x1558 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19b4:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    19b8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    19ba:	29 96       	adiw	r28, 0x09	; 9
    19bc:	cd bf       	out	0x3d, r28	; 61
    19be:	de bf       	out	0x3e, r29	; 62
    19c0:	df 91       	pop	r29
    19c2:	cf 91       	pop	r28
    19c4:	1f 91       	pop	r17
    19c6:	0f 91       	pop	r16
    19c8:	ff 90       	pop	r15
    19ca:	ef 90       	pop	r14
    19cc:	df 90       	pop	r13
    19ce:	cf 90       	pop	r12
    19d0:	bf 90       	pop	r11
    19d2:	af 90       	pop	r10
    19d4:	08 95       	ret

000019d6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    19d6:	0f 93       	push	r16
    19d8:	1f 93       	push	r17
    19da:	cf 93       	push	r28
    19dc:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19de:	fc 01       	movw	r30, r24
    19e0:	26 8d       	ldd	r18, Z+30	; 0x1e
    19e2:	22 23       	and	r18, r18
    19e4:	d9 f0       	breq	.+54     	; 0x1a1c <xQueueReceiveFromISR+0x46>
    19e6:	8a 01       	movw	r16, r20
    19e8:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19ea:	0e 94 92 0a 	call	0x1524	; 0x1524 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    19ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    19f0:	81 50       	subi	r24, 0x01	; 1
    19f2:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    19f4:	89 a1       	ldd	r24, Y+33	; 0x21
    19f6:	8f 3f       	cpi	r24, 0xFF	; 255
    19f8:	69 f4       	brne	.+26     	; 0x1a14 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19fa:	88 85       	ldd	r24, Y+8	; 0x08
    19fc:	88 23       	and	r24, r24
    19fe:	81 f0       	breq	.+32     	; 0x1a20 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a00:	ce 01       	movw	r24, r28
    1a02:	08 96       	adiw	r24, 0x08	; 8
    1a04:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskRemoveFromEventList>
    1a08:	88 23       	and	r24, r24
    1a0a:	61 f0       	breq	.+24     	; 0x1a24 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	f8 01       	movw	r30, r16
    1a10:	80 83       	st	Z, r24
    1a12:	09 c0       	rjmp	.+18     	; 0x1a26 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1a14:	8f 5f       	subi	r24, 0xFF	; 255
    1a16:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	05 c0       	rjmp	.+10     	; 0x1a26 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
    1a1e:	03 c0       	rjmp	.+6      	; 0x1a26 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	01 c0       	rjmp	.+2      	; 0x1a26 <xQueueReceiveFromISR+0x50>
    1a24:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a26:	df 91       	pop	r29
    1a28:	cf 91       	pop	r28
    1a2a:	1f 91       	pop	r17
    1a2c:	0f 91       	pop	r16
    1a2e:	08 95       	ret

00001a30 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a30:	0f b6       	in	r0, 0x3f	; 63
    1a32:	f8 94       	cli
    1a34:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1a36:	fc 01       	movw	r30, r24
    1a38:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1a3a:	0f 90       	pop	r0
    1a3c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1a3e:	08 95       	ret

00001a40 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1a40:	fc 01       	movw	r30, r24
    1a42:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1a44:	08 95       	ret

00001a46 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1a46:	c4 e0       	ldi	r28, 0x04	; 4
    1a48:	d1 e3       	ldi	r29, 0x31	; 49
    1a4a:	88 81       	ld	r24, Y
    1a4c:	82 30       	cpi	r24, 0x02	; 2
    1a4e:	e8 f3       	brcs	.-6      	; 0x1a4a <prvIdleTask+0x4>
    1a50:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    1a54:	fa cf       	rjmp	.-12     	; 0x1a4a <prvIdleTask+0x4>

00001a56 <prvAddCurrentTaskToDelayedList>:
    1a56:	cf 92       	push	r12
    1a58:	df 92       	push	r13
    1a5a:	ef 92       	push	r14
    1a5c:	ff 92       	push	r15
    1a5e:	6b 01       	movw	r12, r22
    1a60:	7c 01       	movw	r14, r24
    1a62:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1a66:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1a6a:	62 83       	std	Z+2, r22	; 0x02
    1a6c:	73 83       	std	Z+3, r23	; 0x03
    1a6e:	84 83       	std	Z+4, r24	; 0x04
    1a70:	95 83       	std	Z+5, r25	; 0x05
    1a72:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    1a76:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1a7a:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    1a7e:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    1a82:	c8 16       	cp	r12, r24
    1a84:	d9 06       	cpc	r13, r25
    1a86:	ea 06       	cpc	r14, r26
    1a88:	fb 06       	cpc	r15, r27
    1a8a:	68 f4       	brcc	.+26     	; 0x1aa6 <prvAddCurrentTaskToDelayedList+0x50>
    1a8c:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1a90:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1a94:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    1a98:	90 91 eb 30 	lds	r25, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1a9c:	6e 5f       	subi	r22, 0xFE	; 254
    1a9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1aa0:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <vListInsert>
    1aa4:	21 c0       	rjmp	.+66     	; 0x1ae8 <prvAddCurrentTaskToDelayedList+0x92>
    1aa6:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    1aaa:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1aae:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1ab2:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1ab6:	6e 5f       	subi	r22, 0xFE	; 254
    1ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aba:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <vListInsert>
    1abe:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1ac2:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ac6:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1aca:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ace:	c8 16       	cp	r12, r24
    1ad0:	d9 06       	cpc	r13, r25
    1ad2:	ea 06       	cpc	r14, r26
    1ad4:	fb 06       	cpc	r15, r27
    1ad6:	40 f4       	brcc	.+16     	; 0x1ae8 <prvAddCurrentTaskToDelayedList+0x92>
    1ad8:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1adc:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ae0:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ae4:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ae8:	ff 90       	pop	r15
    1aea:	ef 90       	pop	r14
    1aec:	df 90       	pop	r13
    1aee:	cf 90       	pop	r12
    1af0:	08 95       	ret

00001af2 <xTaskGenericCreate>:
    1af2:	4f 92       	push	r4
    1af4:	5f 92       	push	r5
    1af6:	6f 92       	push	r6
    1af8:	7f 92       	push	r7
    1afa:	8f 92       	push	r8
    1afc:	9f 92       	push	r9
    1afe:	af 92       	push	r10
    1b00:	bf 92       	push	r11
    1b02:	cf 92       	push	r12
    1b04:	df 92       	push	r13
    1b06:	ef 92       	push	r14
    1b08:	ff 92       	push	r15
    1b0a:	0f 93       	push	r16
    1b0c:	1f 93       	push	r17
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	5c 01       	movw	r10, r24
    1b14:	4b 01       	movw	r8, r22
    1b16:	3a 01       	movw	r6, r20
    1b18:	29 01       	movw	r4, r18
    1b1a:	88 e2       	ldi	r24, 0x28	; 40
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    1b22:	ec 01       	movw	r28, r24
    1b24:	89 2b       	or	r24, r25
    1b26:	09 f4       	brne	.+2      	; 0x1b2a <xTaskGenericCreate+0x38>
    1b28:	d4 c0       	rjmp	.+424    	; 0x1cd2 <xTaskGenericCreate+0x1e0>
    1b2a:	c1 14       	cp	r12, r1
    1b2c:	d1 04       	cpc	r13, r1
    1b2e:	09 f0       	breq	.+2      	; 0x1b32 <xTaskGenericCreate+0x40>
    1b30:	cc c0       	rjmp	.+408    	; 0x1cca <xTaskGenericCreate+0x1d8>
    1b32:	c3 01       	movw	r24, r6
    1b34:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    1b38:	8b 8f       	std	Y+27, r24	; 0x1b
    1b3a:	9c 8f       	std	Y+28, r25	; 0x1c
    1b3c:	00 97       	sbiw	r24, 0x00	; 0
    1b3e:	21 f4       	brne	.+8      	; 0x1b48 <xTaskGenericCreate+0x56>
    1b40:	ce 01       	movw	r24, r28
    1b42:	0e 94 e6 07 	call	0xfcc	; 0xfcc <vPortFree>
    1b46:	c5 c0       	rjmp	.+394    	; 0x1cd2 <xTaskGenericCreate+0x1e0>
    1b48:	a3 01       	movw	r20, r6
    1b4a:	61 e1       	ldi	r22, 0x11	; 17
    1b4c:	70 e0       	ldi	r23, 0x00	; 0
    1b4e:	0e 94 85 1f 	call	0x3f0a	; 0x3f0a <memset>
    1b52:	93 01       	movw	r18, r6
    1b54:	21 50       	subi	r18, 0x01	; 1
    1b56:	31 09       	sbc	r19, r1
    1b58:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b5a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b5c:	3c 01       	movw	r6, r24
    1b5e:	62 0e       	add	r6, r18
    1b60:	73 1e       	adc	r7, r19
    1b62:	4a e0       	ldi	r20, 0x0A	; 10
    1b64:	50 e0       	ldi	r21, 0x00	; 0
    1b66:	b4 01       	movw	r22, r8
    1b68:	ce 01       	movw	r24, r28
    1b6a:	4d 96       	adiw	r24, 0x1d	; 29
    1b6c:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <strncpy>
    1b70:	1e a2       	std	Y+38, r1	; 0x26
    1b72:	10 2f       	mov	r17, r16
    1b74:	04 30       	cpi	r16, 0x04	; 4
    1b76:	08 f0       	brcs	.+2      	; 0x1b7a <xTaskGenericCreate+0x88>
    1b78:	13 e0       	ldi	r17, 0x03	; 3
    1b7a:	1a 8f       	std	Y+26, r17	; 0x1a
    1b7c:	1f a3       	std	Y+39, r17	; 0x27
    1b7e:	6e 01       	movw	r12, r28
    1b80:	22 e0       	ldi	r18, 0x02	; 2
    1b82:	c2 0e       	add	r12, r18
    1b84:	d1 1c       	adc	r13, r1
    1b86:	c6 01       	movw	r24, r12
    1b88:	0e 94 2f 08 	call	0x105e	; 0x105e <vListInitialiseItem>
    1b8c:	ce 01       	movw	r24, r28
    1b8e:	0e 96       	adiw	r24, 0x0e	; 14
    1b90:	0e 94 2f 08 	call	0x105e	; 0x105e <vListInitialiseItem>
    1b94:	ca 87       	std	Y+10, r28	; 0x0a
    1b96:	db 87       	std	Y+11, r29	; 0x0b
    1b98:	84 e0       	ldi	r24, 0x04	; 4
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	a0 e0       	ldi	r26, 0x00	; 0
    1b9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ba0:	81 1b       	sub	r24, r17
    1ba2:	91 09       	sbc	r25, r1
    1ba4:	a1 09       	sbc	r26, r1
    1ba6:	b1 09       	sbc	r27, r1
    1ba8:	8e 87       	std	Y+14, r24	; 0x0e
    1baa:	9f 87       	std	Y+15, r25	; 0x0f
    1bac:	a8 8b       	std	Y+16, r26	; 0x10
    1bae:	b9 8b       	std	Y+17, r27	; 0x11
    1bb0:	ce 8b       	std	Y+22, r28	; 0x16
    1bb2:	df 8b       	std	Y+23, r29	; 0x17
    1bb4:	a2 01       	movw	r20, r4
    1bb6:	b5 01       	movw	r22, r10
    1bb8:	c3 01       	movw	r24, r6
    1bba:	0e 94 cb 08 	call	0x1196	; 0x1196 <pxPortInitialiseStack>
    1bbe:	88 83       	st	Y, r24
    1bc0:	99 83       	std	Y+1, r25	; 0x01
    1bc2:	e1 14       	cp	r14, r1
    1bc4:	f1 04       	cpc	r15, r1
    1bc6:	19 f0       	breq	.+6      	; 0x1bce <xTaskGenericCreate+0xdc>
    1bc8:	f7 01       	movw	r30, r14
    1bca:	c0 83       	st	Z, r28
    1bcc:	d1 83       	std	Z+1, r29	; 0x01
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	0f 92       	push	r0
    1bd4:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1bd8:	8f 5f       	subi	r24, 0xFF	; 255
    1bda:	80 93 dc 30 	sts	0x30DC, r24	; 0x8030dc <uxCurrentNumberOfTasks>
    1bde:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    1be2:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1be6:	89 2b       	or	r24, r25
    1be8:	89 f5       	brne	.+98     	; 0x1c4c <xTaskGenericCreate+0x15a>
    1bea:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1bee:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1bf2:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1bf6:	81 30       	cpi	r24, 0x01	; 1
    1bf8:	c1 f5       	brne	.+112    	; 0x1c6a <xTaskGenericCreate+0x178>
    1bfa:	84 e0       	ldi	r24, 0x04	; 4
    1bfc:	91 e3       	ldi	r25, 0x31	; 49
    1bfe:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c02:	8f e0       	ldi	r24, 0x0F	; 15
    1c04:	91 e3       	ldi	r25, 0x31	; 49
    1c06:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c0a:	8a e1       	ldi	r24, 0x1A	; 26
    1c0c:	91 e3       	ldi	r25, 0x31	; 49
    1c0e:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c12:	85 e2       	ldi	r24, 0x25	; 37
    1c14:	91 e3       	ldi	r25, 0x31	; 49
    1c16:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c1a:	89 ef       	ldi	r24, 0xF9	; 249
    1c1c:	90 e3       	ldi	r25, 0x30	; 48
    1c1e:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c22:	8e ee       	ldi	r24, 0xEE	; 238
    1c24:	90 e3       	ldi	r25, 0x30	; 48
    1c26:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c2a:	8f ed       	ldi	r24, 0xDF	; 223
    1c2c:	90 e3       	ldi	r25, 0x30	; 48
    1c2e:	0e 94 1e 08 	call	0x103c	; 0x103c <vListInitialise>
    1c32:	89 ef       	ldi	r24, 0xF9	; 249
    1c34:	90 e3       	ldi	r25, 0x30	; 48
    1c36:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <pxDelayedTaskList>
    1c3a:	90 93 ed 30 	sts	0x30ED, r25	; 0x8030ed <pxDelayedTaskList+0x1>
    1c3e:	8e ee       	ldi	r24, 0xEE	; 238
    1c40:	90 e3       	ldi	r25, 0x30	; 48
    1c42:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    1c46:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1c4a:	0f c0       	rjmp	.+30     	; 0x1c6a <xTaskGenericCreate+0x178>
    1c4c:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1c50:	81 11       	cpse	r24, r1
    1c52:	0b c0       	rjmp	.+22     	; 0x1c6a <xTaskGenericCreate+0x178>
    1c54:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1c58:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1c5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c5e:	08 17       	cp	r16, r24
    1c60:	20 f0       	brcs	.+8      	; 0x1c6a <xTaskGenericCreate+0x178>
    1c62:	c0 93 30 31 	sts	0x3130, r28	; 0x803130 <pxCurrentTCB>
    1c66:	d0 93 31 31 	sts	0x3131, r29	; 0x803131 <pxCurrentTCB+0x1>
    1c6a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c6c:	90 91 d7 30 	lds	r25, 0x30D7	; 0x8030d7 <uxTopUsedPriority>
    1c70:	98 17       	cp	r25, r24
    1c72:	10 f4       	brcc	.+4      	; 0x1c78 <xTaskGenericCreate+0x186>
    1c74:	80 93 d7 30 	sts	0x30D7, r24	; 0x8030d7 <uxTopUsedPriority>
    1c78:	90 91 d0 30 	lds	r25, 0x30D0	; 0x8030d0 <uxTaskNumber>
    1c7c:	9f 5f       	subi	r25, 0xFF	; 255
    1c7e:	90 93 d0 30 	sts	0x30D0, r25	; 0x8030d0 <uxTaskNumber>
    1c82:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    1c86:	98 17       	cp	r25, r24
    1c88:	10 f4       	brcc	.+4      	; 0x1c8e <xTaskGenericCreate+0x19c>
    1c8a:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    1c8e:	fb e0       	ldi	r31, 0x0B	; 11
    1c90:	8f 9f       	mul	r24, r31
    1c92:	c0 01       	movw	r24, r0
    1c94:	11 24       	eor	r1, r1
    1c96:	b6 01       	movw	r22, r12
    1c98:	8c 5f       	subi	r24, 0xFC	; 252
    1c9a:	9e 4c       	sbci	r25, 0xCE	; 206
    1c9c:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
    1ca0:	0f 90       	pop	r0
    1ca2:	0f be       	out	0x3f, r0	; 63
    1ca4:	80 91 d5 30 	lds	r24, 0x30D5	; 0x8030d5 <xSchedulerRunning>
    1ca8:	88 23       	and	r24, r24
    1caa:	59 f0       	breq	.+22     	; 0x1cc2 <xTaskGenericCreate+0x1d0>
    1cac:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    1cb0:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1cb4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cb6:	80 17       	cp	r24, r16
    1cb8:	30 f4       	brcc	.+12     	; 0x1cc6 <xTaskGenericCreate+0x1d4>
    1cba:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	09 c0       	rjmp	.+18     	; 0x1cd4 <xTaskGenericCreate+0x1e2>
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	07 c0       	rjmp	.+14     	; 0x1cd4 <xTaskGenericCreate+0x1e2>
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	05 c0       	rjmp	.+10     	; 0x1cd4 <xTaskGenericCreate+0x1e2>
    1cca:	cb 8e       	std	Y+27, r12	; 0x1b
    1ccc:	dc 8e       	std	Y+28, r13	; 0x1c
    1cce:	c6 01       	movw	r24, r12
    1cd0:	3b cf       	rjmp	.-394    	; 0x1b48 <xTaskGenericCreate+0x56>
    1cd2:	8f ef       	ldi	r24, 0xFF	; 255
    1cd4:	df 91       	pop	r29
    1cd6:	cf 91       	pop	r28
    1cd8:	1f 91       	pop	r17
    1cda:	0f 91       	pop	r16
    1cdc:	ff 90       	pop	r15
    1cde:	ef 90       	pop	r14
    1ce0:	df 90       	pop	r13
    1ce2:	cf 90       	pop	r12
    1ce4:	bf 90       	pop	r11
    1ce6:	af 90       	pop	r10
    1ce8:	9f 90       	pop	r9
    1cea:	8f 90       	pop	r8
    1cec:	7f 90       	pop	r7
    1cee:	6f 90       	pop	r6
    1cf0:	5f 90       	pop	r5
    1cf2:	4f 90       	pop	r4
    1cf4:	08 95       	ret

00001cf6 <uxTaskPriorityGet>:
    1cf6:	0f b6       	in	r0, 0x3f	; 63
    1cf8:	f8 94       	cli
    1cfa:	0f 92       	push	r0
    1cfc:	00 97       	sbiw	r24, 0x00	; 0
    1cfe:	21 f4       	brne	.+8      	; 0x1d08 <uxTaskPriorityGet+0x12>
    1d00:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    1d04:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1d08:	0f 90       	pop	r0
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d10:	08 95       	ret

00001d12 <vTaskStartScheduler>:
    1d12:	af 92       	push	r10
    1d14:	bf 92       	push	r11
    1d16:	cf 92       	push	r12
    1d18:	df 92       	push	r13
    1d1a:	ef 92       	push	r14
    1d1c:	ff 92       	push	r15
    1d1e:	0f 93       	push	r16
    1d20:	a1 2c       	mov	r10, r1
    1d22:	b1 2c       	mov	r11, r1
    1d24:	c1 2c       	mov	r12, r1
    1d26:	d1 2c       	mov	r13, r1
    1d28:	0f 2e       	mov	r0, r31
    1d2a:	fd ed       	ldi	r31, 0xDD	; 221
    1d2c:	ef 2e       	mov	r14, r31
    1d2e:	f0 e3       	ldi	r31, 0x30	; 48
    1d30:	ff 2e       	mov	r15, r31
    1d32:	f0 2d       	mov	r31, r0
    1d34:	00 e0       	ldi	r16, 0x00	; 0
    1d36:	20 e0       	ldi	r18, 0x00	; 0
    1d38:	30 e0       	ldi	r19, 0x00	; 0
    1d3a:	44 e6       	ldi	r20, 0x64	; 100
    1d3c:	50 e0       	ldi	r21, 0x00	; 0
    1d3e:	66 e1       	ldi	r22, 0x16	; 22
    1d40:	70 e2       	ldi	r23, 0x20	; 32
    1d42:	83 e2       	ldi	r24, 0x23	; 35
    1d44:	9d e0       	ldi	r25, 0x0D	; 13
    1d46:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <xTaskGenericCreate>
    1d4a:	81 30       	cpi	r24, 0x01	; 1
    1d4c:	69 f4       	brne	.+26     	; 0x1d68 <vTaskStartScheduler+0x56>
    1d4e:	f8 94       	cli
    1d50:	80 93 d5 30 	sts	0x30D5, r24	; 0x8030d5 <xSchedulerRunning>
    1d54:	10 92 d8 30 	sts	0x30D8, r1	; 0x8030d8 <xTickCount>
    1d58:	10 92 d9 30 	sts	0x30D9, r1	; 0x8030d9 <xTickCount+0x1>
    1d5c:	10 92 da 30 	sts	0x30DA, r1	; 0x8030da <xTickCount+0x2>
    1d60:	10 92 db 30 	sts	0x30DB, r1	; 0x8030db <xTickCount+0x3>
    1d64:	0e 94 41 09 	call	0x1282	; 0x1282 <xPortStartScheduler>
    1d68:	0f 91       	pop	r16
    1d6a:	ff 90       	pop	r15
    1d6c:	ef 90       	pop	r14
    1d6e:	df 90       	pop	r13
    1d70:	cf 90       	pop	r12
    1d72:	bf 90       	pop	r11
    1d74:	af 90       	pop	r10
    1d76:	08 95       	ret

00001d78 <vTaskSuspendAll>:
    1d78:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    1d7c:	8f 5f       	subi	r24, 0xFF	; 255
    1d7e:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>
    1d82:	08 95       	ret

00001d84 <xTaskGetTickCount>:
    1d84:	0f b6       	in	r0, 0x3f	; 63
    1d86:	f8 94       	cli
    1d88:	0f 92       	push	r0
    1d8a:	60 91 d8 30 	lds	r22, 0x30D8	; 0x8030d8 <xTickCount>
    1d8e:	70 91 d9 30 	lds	r23, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1d92:	80 91 da 30 	lds	r24, 0x30DA	; 0x8030da <xTickCount+0x2>
    1d96:	90 91 db 30 	lds	r25, 0x30DB	; 0x8030db <xTickCount+0x3>
    1d9a:	0f 90       	pop	r0
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	08 95       	ret

00001da0 <pcTaskGetTaskName>:
    1da0:	00 97       	sbiw	r24, 0x00	; 0
    1da2:	21 f4       	brne	.+8      	; 0x1dac <pcTaskGetTaskName+0xc>
    1da4:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    1da8:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    1dac:	4d 96       	adiw	r24, 0x1d	; 29
    1dae:	08 95       	ret

00001db0 <xTaskGetIdleTaskHandle>:
    1db0:	80 91 dd 30 	lds	r24, 0x30DD	; 0x8030dd <xIdleTaskHandle>
    1db4:	90 91 de 30 	lds	r25, 0x30DE	; 0x8030de <xIdleTaskHandle+0x1>
    1db8:	08 95       	ret

00001dba <vTaskIncrementTick>:
    1dba:	ff 92       	push	r15
    1dbc:	0f 93       	push	r16
    1dbe:	1f 93       	push	r17
    1dc0:	cf 93       	push	r28
    1dc2:	df 93       	push	r29
    1dc4:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    1dc8:	81 11       	cpse	r24, r1
    1dca:	ed c0       	rjmp	.+474    	; 0x1fa6 <vTaskIncrementTick+0x1ec>
    1dcc:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    1dd0:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1dd4:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    1dd8:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    1ddc:	01 96       	adiw	r24, 0x01	; 1
    1dde:	a1 1d       	adc	r26, r1
    1de0:	b1 1d       	adc	r27, r1
    1de2:	80 93 d8 30 	sts	0x30D8, r24	; 0x8030d8 <xTickCount>
    1de6:	90 93 d9 30 	sts	0x30D9, r25	; 0x8030d9 <xTickCount+0x1>
    1dea:	a0 93 da 30 	sts	0x30DA, r26	; 0x8030da <xTickCount+0x2>
    1dee:	b0 93 db 30 	sts	0x30DB, r27	; 0x8030db <xTickCount+0x3>
    1df2:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    1df6:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1dfa:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    1dfe:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    1e02:	89 2b       	or	r24, r25
    1e04:	8a 2b       	or	r24, r26
    1e06:	8b 2b       	or	r24, r27
    1e08:	f1 f5       	brne	.+124    	; 0x1e86 <vTaskIncrementTick+0xcc>
    1e0a:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1e0e:	90 91 ed 30 	lds	r25, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1e12:	20 91 ea 30 	lds	r18, 0x30EA	; 0x8030ea <pxOverflowDelayedTaskList>
    1e16:	30 91 eb 30 	lds	r19, 0x30EB	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1e1a:	20 93 ec 30 	sts	0x30EC, r18	; 0x8030ec <pxDelayedTaskList>
    1e1e:	30 93 ed 30 	sts	0x30ED, r19	; 0x8030ed <pxDelayedTaskList+0x1>
    1e22:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <pxOverflowDelayedTaskList>
    1e26:	90 93 eb 30 	sts	0x30EB, r25	; 0x8030eb <pxOverflowDelayedTaskList+0x1>
    1e2a:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    1e2e:	8f 5f       	subi	r24, 0xFF	; 255
    1e30:	80 93 d1 30 	sts	0x30D1, r24	; 0x8030d1 <xNumOfOverflows>
    1e34:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1e38:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1e3c:	80 81       	ld	r24, Z
    1e3e:	81 11       	cpse	r24, r1
    1e40:	0c c0       	rjmp	.+24     	; 0x1e5a <vTaskIncrementTick+0xa0>
    1e42:	8f ef       	ldi	r24, 0xFF	; 255
    1e44:	9f ef       	ldi	r25, 0xFF	; 255
    1e46:	dc 01       	movw	r26, r24
    1e48:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e4c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e50:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e54:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e58:	16 c0       	rjmp	.+44     	; 0x1e86 <vTaskIncrementTick+0xcc>
    1e5a:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1e5e:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1e62:	07 80       	ldd	r0, Z+7	; 0x07
    1e64:	f0 85       	ldd	r31, Z+8	; 0x08
    1e66:	e0 2d       	mov	r30, r0
    1e68:	00 84       	ldd	r0, Z+8	; 0x08
    1e6a:	f1 85       	ldd	r31, Z+9	; 0x09
    1e6c:	e0 2d       	mov	r30, r0
    1e6e:	82 81       	ldd	r24, Z+2	; 0x02
    1e70:	93 81       	ldd	r25, Z+3	; 0x03
    1e72:	a4 81       	ldd	r26, Z+4	; 0x04
    1e74:	b5 81       	ldd	r27, Z+5	; 0x05
    1e76:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1e7a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e7e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1e82:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1e86:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    1e8a:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1e8e:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    1e92:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    1e96:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1e9a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1e9e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ea2:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1ea6:	48 17       	cp	r20, r24
    1ea8:	59 07       	cpc	r21, r25
    1eaa:	6a 07       	cpc	r22, r26
    1eac:	7b 07       	cpc	r23, r27
    1eae:	08 f4       	brcc	.+2      	; 0x1eb2 <vTaskIncrementTick+0xf8>
    1eb0:	7f c0       	rjmp	.+254    	; 0x1fb0 <vTaskIncrementTick+0x1f6>
    1eb2:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1eb6:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1eba:	80 81       	ld	r24, Z
    1ebc:	88 23       	and	r24, r24
    1ebe:	f9 f0       	breq	.+62     	; 0x1efe <vTaskIncrementTick+0x144>
    1ec0:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1ec4:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1ec8:	07 80       	ldd	r0, Z+7	; 0x07
    1eca:	f0 85       	ldd	r31, Z+8	; 0x08
    1ecc:	e0 2d       	mov	r30, r0
    1ece:	c0 85       	ldd	r28, Z+8	; 0x08
    1ed0:	d1 85       	ldd	r29, Z+9	; 0x09
    1ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ed6:	ac 81       	ldd	r26, Y+4	; 0x04
    1ed8:	bd 81       	ldd	r27, Y+5	; 0x05
    1eda:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    1ede:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1ee2:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    1ee6:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    1eea:	48 17       	cp	r20, r24
    1eec:	59 07       	cpc	r21, r25
    1eee:	6a 07       	cpc	r22, r26
    1ef0:	7b 07       	cpc	r23, r27
    1ef2:	58 f1       	brcs	.+86     	; 0x1f4a <vTaskIncrementTick+0x190>
    1ef4:	0f 2e       	mov	r0, r31
    1ef6:	fb e0       	ldi	r31, 0x0B	; 11
    1ef8:	ff 2e       	mov	r15, r31
    1efa:	f0 2d       	mov	r31, r0
    1efc:	2f c0       	rjmp	.+94     	; 0x1f5c <vTaskIncrementTick+0x1a2>
    1efe:	8f ef       	ldi	r24, 0xFF	; 255
    1f00:	9f ef       	ldi	r25, 0xFF	; 255
    1f02:	dc 01       	movw	r26, r24
    1f04:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1f08:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f0c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f10:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f14:	4d c0       	rjmp	.+154    	; 0x1fb0 <vTaskIncrementTick+0x1f6>
    1f16:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1f1a:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1f1e:	07 80       	ldd	r0, Z+7	; 0x07
    1f20:	f0 85       	ldd	r31, Z+8	; 0x08
    1f22:	e0 2d       	mov	r30, r0
    1f24:	c0 85       	ldd	r28, Z+8	; 0x08
    1f26:	d1 85       	ldd	r29, Z+9	; 0x09
    1f28:	8a 81       	ldd	r24, Y+2	; 0x02
    1f2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1f2c:	ac 81       	ldd	r26, Y+4	; 0x04
    1f2e:	bd 81       	ldd	r27, Y+5	; 0x05
    1f30:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    1f34:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    1f38:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    1f3c:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    1f40:	48 17       	cp	r20, r24
    1f42:	59 07       	cpc	r21, r25
    1f44:	6a 07       	cpc	r22, r26
    1f46:	7b 07       	cpc	r23, r27
    1f48:	48 f4       	brcc	.+18     	; 0x1f5c <vTaskIncrementTick+0x1a2>
    1f4a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1f4e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1f52:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1f56:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1f5a:	2a c0       	rjmp	.+84     	; 0x1fb0 <vTaskIncrementTick+0x1f6>
    1f5c:	8e 01       	movw	r16, r28
    1f5e:	0e 5f       	subi	r16, 0xFE	; 254
    1f60:	1f 4f       	sbci	r17, 0xFF	; 255
    1f62:	c8 01       	movw	r24, r16
    1f64:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
    1f68:	88 8d       	ldd	r24, Y+24	; 0x18
    1f6a:	99 8d       	ldd	r25, Y+25	; 0x19
    1f6c:	89 2b       	or	r24, r25
    1f6e:	21 f0       	breq	.+8      	; 0x1f78 <vTaskIncrementTick+0x1be>
    1f70:	ce 01       	movw	r24, r28
    1f72:	0e 96       	adiw	r24, 0x0e	; 14
    1f74:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
    1f78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f7a:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    1f7e:	98 17       	cp	r25, r24
    1f80:	10 f4       	brcc	.+4      	; 0x1f86 <vTaskIncrementTick+0x1cc>
    1f82:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    1f86:	f8 9e       	mul	r15, r24
    1f88:	c0 01       	movw	r24, r0
    1f8a:	11 24       	eor	r1, r1
    1f8c:	b8 01       	movw	r22, r16
    1f8e:	8c 5f       	subi	r24, 0xFC	; 252
    1f90:	9e 4c       	sbci	r25, 0xCE	; 206
    1f92:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
    1f96:	e0 91 ec 30 	lds	r30, 0x30EC	; 0x8030ec <pxDelayedTaskList>
    1f9a:	f0 91 ed 30 	lds	r31, 0x30ED	; 0x8030ed <pxDelayedTaskList+0x1>
    1f9e:	80 81       	ld	r24, Z
    1fa0:	81 11       	cpse	r24, r1
    1fa2:	b9 cf       	rjmp	.-142    	; 0x1f16 <vTaskIncrementTick+0x15c>
    1fa4:	ac cf       	rjmp	.-168    	; 0x1efe <vTaskIncrementTick+0x144>
    1fa6:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    1faa:	8f 5f       	subi	r24, 0xFF	; 255
    1fac:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	1f 91       	pop	r17
    1fb6:	0f 91       	pop	r16
    1fb8:	ff 90       	pop	r15
    1fba:	08 95       	ret

00001fbc <xTaskResumeAll>:
    1fbc:	cf 92       	push	r12
    1fbe:	df 92       	push	r13
    1fc0:	ef 92       	push	r14
    1fc2:	ff 92       	push	r15
    1fc4:	0f 93       	push	r16
    1fc6:	1f 93       	push	r17
    1fc8:	cf 93       	push	r28
    1fca:	df 93       	push	r29
    1fcc:	0f b6       	in	r0, 0x3f	; 63
    1fce:	f8 94       	cli
    1fd0:	0f 92       	push	r0
    1fd2:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    1fd6:	81 50       	subi	r24, 0x01	; 1
    1fd8:	80 93 d4 30 	sts	0x30D4, r24	; 0x8030d4 <uxSchedulerSuspended>
    1fdc:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    1fe0:	81 11       	cpse	r24, r1
    1fe2:	60 c0       	rjmp	.+192    	; 0x20a4 <xTaskResumeAll+0xe8>
    1fe4:	80 91 dc 30 	lds	r24, 0x30DC	; 0x8030dc <uxCurrentNumberOfTasks>
    1fe8:	81 11       	cpse	r24, r1
    1fea:	2c c0       	rjmp	.+88     	; 0x2044 <xTaskResumeAll+0x88>
    1fec:	5e c0       	rjmp	.+188    	; 0x20aa <xTaskResumeAll+0xee>
    1fee:	d7 01       	movw	r26, r14
    1ff0:	17 96       	adiw	r26, 0x07	; 7
    1ff2:	ed 91       	ld	r30, X+
    1ff4:	fc 91       	ld	r31, X
    1ff6:	18 97       	sbiw	r26, 0x08	; 8
    1ff8:	c0 85       	ldd	r28, Z+8	; 0x08
    1ffa:	d1 85       	ldd	r29, Z+9	; 0x09
    1ffc:	ce 01       	movw	r24, r28
    1ffe:	0e 96       	adiw	r24, 0x0e	; 14
    2000:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
    2004:	8e 01       	movw	r16, r28
    2006:	0e 5f       	subi	r16, 0xFE	; 254
    2008:	1f 4f       	sbci	r17, 0xFF	; 255
    200a:	c8 01       	movw	r24, r16
    200c:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
    2010:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2012:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2016:	98 17       	cp	r25, r24
    2018:	10 f4       	brcc	.+4      	; 0x201e <xTaskResumeAll+0x62>
    201a:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    201e:	d8 9e       	mul	r13, r24
    2020:	c0 01       	movw	r24, r0
    2022:	11 24       	eor	r1, r1
    2024:	b8 01       	movw	r22, r16
    2026:	8c 5f       	subi	r24, 0xFC	; 252
    2028:	9e 4c       	sbci	r25, 0xCE	; 206
    202a:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
    202e:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2032:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2036:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2038:	82 8d       	ldd	r24, Z+26	; 0x1a
    203a:	98 17       	cp	r25, r24
    203c:	70 f0       	brcs	.+28     	; 0x205a <xTaskResumeAll+0x9e>
    203e:	cc 24       	eor	r12, r12
    2040:	c3 94       	inc	r12
    2042:	0b c0       	rjmp	.+22     	; 0x205a <xTaskResumeAll+0x9e>
    2044:	c1 2c       	mov	r12, r1
    2046:	0f 2e       	mov	r0, r31
    2048:	ff ed       	ldi	r31, 0xDF	; 223
    204a:	ef 2e       	mov	r14, r31
    204c:	f0 e3       	ldi	r31, 0x30	; 48
    204e:	ff 2e       	mov	r15, r31
    2050:	f0 2d       	mov	r31, r0
    2052:	0f 2e       	mov	r0, r31
    2054:	fb e0       	ldi	r31, 0x0B	; 11
    2056:	df 2e       	mov	r13, r31
    2058:	f0 2d       	mov	r31, r0
    205a:	f7 01       	movw	r30, r14
    205c:	80 81       	ld	r24, Z
    205e:	81 11       	cpse	r24, r1
    2060:	c6 cf       	rjmp	.-116    	; 0x1fee <xTaskResumeAll+0x32>
    2062:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2066:	88 23       	and	r24, r24
    2068:	81 f0       	breq	.+32     	; 0x208a <xTaskResumeAll+0xce>
    206a:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    206e:	88 23       	and	r24, r24
    2070:	99 f0       	breq	.+38     	; 0x2098 <xTaskResumeAll+0xdc>
    2072:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <vTaskIncrementTick>
    2076:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    207a:	81 50       	subi	r24, 0x01	; 1
    207c:	80 93 d3 30 	sts	0x30D3, r24	; 0x8030d3 <uxMissedTicks>
    2080:	80 91 d3 30 	lds	r24, 0x30D3	; 0x8030d3 <uxMissedTicks>
    2084:	81 11       	cpse	r24, r1
    2086:	f5 cf       	rjmp	.-22     	; 0x2072 <xTaskResumeAll+0xb6>
    2088:	07 c0       	rjmp	.+14     	; 0x2098 <xTaskResumeAll+0xdc>
    208a:	f1 e0       	ldi	r31, 0x01	; 1
    208c:	cf 16       	cp	r12, r31
    208e:	21 f0       	breq	.+8      	; 0x2098 <xTaskResumeAll+0xdc>
    2090:	80 91 d2 30 	lds	r24, 0x30D2	; 0x8030d2 <xMissedYield>
    2094:	81 30       	cpi	r24, 0x01	; 1
    2096:	41 f4       	brne	.+16     	; 0x20a8 <xTaskResumeAll+0xec>
    2098:	10 92 d2 30 	sts	0x30D2, r1	; 0x8030d2 <xMissedYield>
    209c:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
    20a0:	81 e0       	ldi	r24, 0x01	; 1
    20a2:	03 c0       	rjmp	.+6      	; 0x20aa <xTaskResumeAll+0xee>
    20a4:	80 e0       	ldi	r24, 0x00	; 0
    20a6:	01 c0       	rjmp	.+2      	; 0x20aa <xTaskResumeAll+0xee>
    20a8:	80 e0       	ldi	r24, 0x00	; 0
    20aa:	0f 90       	pop	r0
    20ac:	0f be       	out	0x3f, r0	; 63
    20ae:	df 91       	pop	r29
    20b0:	cf 91       	pop	r28
    20b2:	1f 91       	pop	r17
    20b4:	0f 91       	pop	r16
    20b6:	ff 90       	pop	r15
    20b8:	ef 90       	pop	r14
    20ba:	df 90       	pop	r13
    20bc:	cf 90       	pop	r12
    20be:	08 95       	ret

000020c0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    20c0:	cf 92       	push	r12
    20c2:	df 92       	push	r13
    20c4:	ef 92       	push	r14
    20c6:	ff 92       	push	r15
    20c8:	6b 01       	movw	r12, r22
    20ca:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    20cc:	67 2b       	or	r22, r23
    20ce:	68 2b       	or	r22, r24
    20d0:	69 2b       	or	r22, r25
    20d2:	e9 f0       	breq	.+58     	; 0x210e <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    20d4:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    20d8:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    20dc:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    20e0:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    20e4:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    20e8:	c8 0e       	add	r12, r24
    20ea:	d9 1e       	adc	r13, r25
    20ec:	ea 1e       	adc	r14, r26
    20ee:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    20f0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    20f4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    20f8:	02 96       	adiw	r24, 0x02	; 2
    20fa:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    20fe:	c7 01       	movw	r24, r14
    2100:	b6 01       	movw	r22, r12
    2102:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2106:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    210a:	81 11       	cpse	r24, r1
    210c:	02 c0       	rjmp	.+4      	; 0x2112 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    210e:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYield>
		}
	}
    2112:	ff 90       	pop	r15
    2114:	ef 90       	pop	r14
    2116:	df 90       	pop	r13
    2118:	cf 90       	pop	r12
    211a:	08 95       	ret

0000211c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    211c:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2120:	81 11       	cpse	r24, r1
    2122:	0c c0       	rjmp	.+24     	; 0x213c <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2124:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2128:	4b e0       	ldi	r20, 0x0B	; 11
    212a:	e4 9f       	mul	r30, r20
    212c:	f0 01       	movw	r30, r0
    212e:	11 24       	eor	r1, r1
    2130:	ec 5f       	subi	r30, 0xFC	; 252
    2132:	fe 4c       	sbci	r31, 0xCE	; 206
    2134:	80 81       	ld	r24, Z
    2136:	88 23       	and	r24, r24
    2138:	29 f0       	breq	.+10     	; 0x2144 <vTaskSwitchContext+0x28>
    213a:	14 c0       	rjmp	.+40     	; 0x2164 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    2142:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2144:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2146:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    214a:	81 50       	subi	r24, 0x01	; 1
    214c:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2150:	e0 91 d6 30 	lds	r30, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2154:	9e 9f       	mul	r25, r30
    2156:	f0 01       	movw	r30, r0
    2158:	11 24       	eor	r1, r1
    215a:	ec 5f       	subi	r30, 0xFC	; 252
    215c:	fe 4c       	sbci	r31, 0xCE	; 206
    215e:	80 81       	ld	r24, Z
    2160:	88 23       	and	r24, r24
    2162:	89 f3       	breq	.-30     	; 0x2146 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2164:	80 91 d6 30 	lds	r24, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2168:	28 2f       	mov	r18, r24
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	4b e0       	ldi	r20, 0x0B	; 11
    216e:	84 9f       	mul	r24, r20
    2170:	c0 01       	movw	r24, r0
    2172:	11 24       	eor	r1, r1
    2174:	dc 01       	movw	r26, r24
    2176:	ac 5f       	subi	r26, 0xFC	; 252
    2178:	be 4c       	sbci	r27, 0xCE	; 206
    217a:	11 96       	adiw	r26, 0x01	; 1
    217c:	ed 91       	ld	r30, X+
    217e:	fc 91       	ld	r31, X
    2180:	12 97       	sbiw	r26, 0x02	; 2
    2182:	04 80       	ldd	r0, Z+4	; 0x04
    2184:	f5 81       	ldd	r31, Z+5	; 0x05
    2186:	e0 2d       	mov	r30, r0
    2188:	11 96       	adiw	r26, 0x01	; 1
    218a:	ed 93       	st	X+, r30
    218c:	fc 93       	st	X, r31
    218e:	12 97       	sbiw	r26, 0x02	; 2
    2190:	89 5f       	subi	r24, 0xF9	; 249
    2192:	9e 4c       	sbci	r25, 0xCE	; 206
    2194:	e8 17       	cp	r30, r24
    2196:	f9 07       	cpc	r31, r25
    2198:	61 f4       	brne	.+24     	; 0x21b2 <vTaskSwitchContext+0x96>
    219a:	84 81       	ldd	r24, Z+4	; 0x04
    219c:	95 81       	ldd	r25, Z+5	; 0x05
    219e:	4b e0       	ldi	r20, 0x0B	; 11
    21a0:	42 9f       	mul	r20, r18
    21a2:	f0 01       	movw	r30, r0
    21a4:	43 9f       	mul	r20, r19
    21a6:	f0 0d       	add	r31, r0
    21a8:	11 24       	eor	r1, r1
    21aa:	ec 5f       	subi	r30, 0xFC	; 252
    21ac:	fe 4c       	sbci	r31, 0xCE	; 206
    21ae:	81 83       	std	Z+1, r24	; 0x01
    21b0:	92 83       	std	Z+2, r25	; 0x02
    21b2:	8b e0       	ldi	r24, 0x0B	; 11
    21b4:	82 9f       	mul	r24, r18
    21b6:	f0 01       	movw	r30, r0
    21b8:	83 9f       	mul	r24, r19
    21ba:	f0 0d       	add	r31, r0
    21bc:	11 24       	eor	r1, r1
    21be:	ec 5f       	subi	r30, 0xFC	; 252
    21c0:	fe 4c       	sbci	r31, 0xCE	; 206
    21c2:	01 80       	ldd	r0, Z+1	; 0x01
    21c4:	f2 81       	ldd	r31, Z+2	; 0x02
    21c6:	e0 2d       	mov	r30, r0
    21c8:	80 85       	ldd	r24, Z+8	; 0x08
    21ca:	91 85       	ldd	r25, Z+9	; 0x09
    21cc:	80 93 30 31 	sts	0x3130, r24	; 0x803130 <pxCurrentTCB>
    21d0:	90 93 31 31 	sts	0x3131, r25	; 0x803131 <pxCurrentTCB+0x1>
    21d4:	08 95       	ret

000021d6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    21d6:	cf 92       	push	r12
    21d8:	df 92       	push	r13
    21da:	ef 92       	push	r14
    21dc:	ff 92       	push	r15
    21de:	6a 01       	movw	r12, r20
    21e0:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21e2:	60 91 30 31 	lds	r22, 0x3130	; 0x803130 <pxCurrentTCB>
    21e6:	70 91 31 31 	lds	r23, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    21ea:	62 5f       	subi	r22, 0xF2	; 242
    21ec:	7f 4f       	sbci	r23, 0xFF	; 255
    21ee:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    21f2:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    21f6:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    21fa:	02 96       	adiw	r24, 0x02	; 2
    21fc:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2200:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    2204:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2208:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    220c:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2210:	bc 01       	movw	r22, r24
    2212:	cd 01       	movw	r24, r26
    2214:	6c 0d       	add	r22, r12
    2216:	7d 1d       	adc	r23, r13
    2218:	8e 1d       	adc	r24, r14
    221a:	9f 1d       	adc	r25, r15
    221c:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2220:	ff 90       	pop	r15
    2222:	ef 90       	pop	r14
    2224:	df 90       	pop	r13
    2226:	cf 90       	pop	r12
    2228:	08 95       	ret

0000222a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    222a:	0f 93       	push	r16
    222c:	1f 93       	push	r17
    222e:	cf 93       	push	r28
    2230:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2232:	dc 01       	movw	r26, r24
    2234:	17 96       	adiw	r26, 0x07	; 7
    2236:	ed 91       	ld	r30, X+
    2238:	fc 91       	ld	r31, X
    223a:	18 97       	sbiw	r26, 0x08	; 8
    223c:	c0 85       	ldd	r28, Z+8	; 0x08
    223e:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2240:	8e 01       	movw	r16, r28
    2242:	02 5f       	subi	r16, 0xF2	; 242
    2244:	1f 4f       	sbci	r17, 0xFF	; 255
    2246:	c8 01       	movw	r24, r16
    2248:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    224c:	80 91 d4 30 	lds	r24, 0x30D4	; 0x8030d4 <uxSchedulerSuspended>
    2250:	81 11       	cpse	r24, r1
    2252:	16 c0       	rjmp	.+44     	; 0x2280 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2254:	0c 50       	subi	r16, 0x0C	; 12
    2256:	11 09       	sbc	r17, r1
    2258:	c8 01       	movw	r24, r16
    225a:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    225e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2260:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    2264:	98 17       	cp	r25, r24
    2266:	10 f4       	brcc	.+4      	; 0x226c <xTaskRemoveFromEventList+0x42>
    2268:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    226c:	bb e0       	ldi	r27, 0x0B	; 11
    226e:	8b 9f       	mul	r24, r27
    2270:	c0 01       	movw	r24, r0
    2272:	11 24       	eor	r1, r1
    2274:	b8 01       	movw	r22, r16
    2276:	8c 5f       	subi	r24, 0xFC	; 252
    2278:	9e 4c       	sbci	r25, 0xCE	; 206
    227a:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
    227e:	05 c0       	rjmp	.+10     	; 0x228a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2280:	b8 01       	movw	r22, r16
    2282:	8f ed       	ldi	r24, 0xDF	; 223
    2284:	90 e3       	ldi	r25, 0x30	; 48
    2286:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    228a:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    228e:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2292:	81 e0       	ldi	r24, 0x01	; 1
    2294:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2296:	92 8d       	ldd	r25, Z+26	; 0x1a
    2298:	29 17       	cp	r18, r25
    229a:	08 f4       	brcc	.+2      	; 0x229e <xTaskRemoveFromEventList+0x74>
    229c:	80 e0       	ldi	r24, 0x00	; 0
}
    229e:	df 91       	pop	r29
    22a0:	cf 91       	pop	r28
    22a2:	1f 91       	pop	r17
    22a4:	0f 91       	pop	r16
    22a6:	08 95       	ret

000022a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    22a8:	20 91 d1 30 	lds	r18, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    22ac:	fc 01       	movw	r30, r24
    22ae:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    22b0:	40 91 d8 30 	lds	r20, 0x30D8	; 0x8030d8 <xTickCount>
    22b4:	50 91 d9 30 	lds	r21, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    22b8:	60 91 da 30 	lds	r22, 0x30DA	; 0x8030da <xTickCount+0x2>
    22bc:	70 91 db 30 	lds	r23, 0x30DB	; 0x8030db <xTickCount+0x3>
    22c0:	41 83       	std	Z+1, r20	; 0x01
    22c2:	52 83       	std	Z+2, r21	; 0x02
    22c4:	63 83       	std	Z+3, r22	; 0x03
    22c6:	74 83       	std	Z+4, r23	; 0x04
    22c8:	08 95       	ret

000022ca <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    22ca:	8f 92       	push	r8
    22cc:	9f 92       	push	r9
    22ce:	af 92       	push	r10
    22d0:	bf 92       	push	r11
    22d2:	cf 92       	push	r12
    22d4:	df 92       	push	r13
    22d6:	ef 92       	push	r14
    22d8:	ff 92       	push	r15
    22da:	0f 93       	push	r16
    22dc:	1f 93       	push	r17
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    22e4:	0f b6       	in	r0, 0x3f	; 63
    22e6:	f8 94       	cli
    22e8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    22ea:	80 91 d1 30 	lds	r24, 0x30D1	; 0x8030d1 <xNumOfOverflows>
    22ee:	90 81       	ld	r25, Z
    22f0:	98 17       	cp	r25, r24
    22f2:	89 f0       	breq	.+34     	; 0x2316 <xTaskCheckForTimeOut+0x4c>
    22f4:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    22f8:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    22fc:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2300:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2304:	01 81       	ldd	r16, Z+1	; 0x01
    2306:	12 81       	ldd	r17, Z+2	; 0x02
    2308:	23 81       	ldd	r18, Z+3	; 0x03
    230a:	34 81       	ldd	r19, Z+4	; 0x04
    230c:	80 17       	cp	r24, r16
    230e:	91 07       	cpc	r25, r17
    2310:	a2 07       	cpc	r26, r18
    2312:	b3 07       	cpc	r27, r19
    2314:	a8 f5       	brcc	.+106    	; 0x2380 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2316:	80 91 d8 30 	lds	r24, 0x30D8	; 0x8030d8 <xTickCount>
    231a:	90 91 d9 30 	lds	r25, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    231e:	a0 91 da 30 	lds	r26, 0x30DA	; 0x8030da <xTickCount+0x2>
    2322:	b0 91 db 30 	lds	r27, 0x30DB	; 0x8030db <xTickCount+0x3>
    2326:	c1 80       	ldd	r12, Z+1	; 0x01
    2328:	d2 80       	ldd	r13, Z+2	; 0x02
    232a:	e3 80       	ldd	r14, Z+3	; 0x03
    232c:	f4 80       	ldd	r15, Z+4	; 0x04
    232e:	eb 01       	movw	r28, r22
    2330:	08 81       	ld	r16, Y
    2332:	19 81       	ldd	r17, Y+1	; 0x01
    2334:	2a 81       	ldd	r18, Y+2	; 0x02
    2336:	3b 81       	ldd	r19, Y+3	; 0x03
    2338:	8c 19       	sub	r24, r12
    233a:	9d 09       	sbc	r25, r13
    233c:	ae 09       	sbc	r26, r14
    233e:	bf 09       	sbc	r27, r15
    2340:	80 17       	cp	r24, r16
    2342:	91 07       	cpc	r25, r17
    2344:	a2 07       	cpc	r26, r18
    2346:	b3 07       	cpc	r27, r19
    2348:	e8 f4       	brcc	.+58     	; 0x2384 <xTaskCheckForTimeOut+0xba>
    234a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    234c:	80 90 d8 30 	lds	r8, 0x30D8	; 0x8030d8 <xTickCount>
    2350:	90 90 d9 30 	lds	r9, 0x30D9	; 0x8030d9 <xTickCount+0x1>
    2354:	a0 90 da 30 	lds	r10, 0x30DA	; 0x8030da <xTickCount+0x2>
    2358:	b0 90 db 30 	lds	r11, 0x30DB	; 0x8030db <xTickCount+0x3>
    235c:	b5 01       	movw	r22, r10
    235e:	a4 01       	movw	r20, r8
    2360:	4c 19       	sub	r20, r12
    2362:	5d 09       	sbc	r21, r13
    2364:	6e 09       	sbc	r22, r14
    2366:	7f 09       	sbc	r23, r15
    2368:	04 1b       	sub	r16, r20
    236a:	15 0b       	sbc	r17, r21
    236c:	26 0b       	sbc	r18, r22
    236e:	37 0b       	sbc	r19, r23
    2370:	08 83       	st	Y, r16
    2372:	19 83       	std	Y+1, r17	; 0x01
    2374:	2a 83       	std	Y+2, r18	; 0x02
    2376:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2378:	0e 94 54 11 	call	0x22a8	; 0x22a8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    237c:	80 e0       	ldi	r24, 0x00	; 0
    237e:	03 c0       	rjmp	.+6      	; 0x2386 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2380:	81 e0       	ldi	r24, 0x01	; 1
    2382:	01 c0       	rjmp	.+2      	; 0x2386 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2384:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2386:	0f 90       	pop	r0
    2388:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    238a:	df 91       	pop	r29
    238c:	cf 91       	pop	r28
    238e:	1f 91       	pop	r17
    2390:	0f 91       	pop	r16
    2392:	ff 90       	pop	r15
    2394:	ef 90       	pop	r14
    2396:	df 90       	pop	r13
    2398:	cf 90       	pop	r12
    239a:	bf 90       	pop	r11
    239c:	af 90       	pop	r10
    239e:	9f 90       	pop	r9
    23a0:	8f 90       	pop	r8
    23a2:	08 95       	ret

000023a4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	80 93 d2 30 	sts	0x30D2, r24	; 0x8030d2 <xMissedYield>
    23aa:	08 95       	ret

000023ac <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    23ac:	00 97       	sbiw	r24, 0x00	; 0
    23ae:	21 f4       	brne	.+8      	; 0x23b8 <uxTaskGetStackHighWaterMark+0xc>
    23b0:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    23b4:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    23b8:	dc 01       	movw	r26, r24
    23ba:	5b 96       	adiw	r26, 0x1b	; 27
    23bc:	ed 91       	ld	r30, X+
    23be:	fc 91       	ld	r31, X
    23c0:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    23c2:	80 81       	ld	r24, Z
    23c4:	81 31       	cpi	r24, 0x11	; 17
    23c6:	41 f4       	brne	.+16     	; 0x23d8 <uxTaskGetStackHighWaterMark+0x2c>
    23c8:	31 96       	adiw	r30, 0x01	; 1
    23ca:	80 e0       	ldi	r24, 0x00	; 0
    23cc:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    23ce:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    23d0:	21 91       	ld	r18, Z+
    23d2:	21 31       	cpi	r18, 0x11	; 17
    23d4:	e1 f3       	breq	.-8      	; 0x23ce <uxTaskGetStackHighWaterMark+0x22>
    23d6:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    23d8:	80 e0       	ldi	r24, 0x00	; 0
    23da:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    23dc:	08 95       	ret

000023de <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    23de:	80 91 30 31 	lds	r24, 0x3130	; 0x803130 <pxCurrentTCB>
    23e2:	90 91 31 31 	lds	r25, 0x3131	; 0x803131 <pxCurrentTCB+0x1>

		return xReturn;
	}
    23e6:	08 95       	ret

000023e8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    23e8:	0f 93       	push	r16
    23ea:	1f 93       	push	r17
    23ec:	cf 93       	push	r28
    23ee:	df 93       	push	r29
    23f0:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    23f2:	22 8d       	ldd	r18, Z+26	; 0x1a
    23f4:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    23f8:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    23fc:	5a 96       	adiw	r26, 0x1a	; 26
    23fe:	8c 91       	ld	r24, X
    2400:	28 17       	cp	r18, r24
    2402:	08 f0       	brcs	.+2      	; 0x2406 <vTaskPriorityInherit+0x1e>
    2404:	41 c0       	rjmp	.+130    	; 0x2488 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2406:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    240a:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    240e:	5a 96       	adiw	r26, 0x1a	; 26
    2410:	3c 91       	ld	r19, X
    2412:	84 e0       	ldi	r24, 0x04	; 4
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	a0 e0       	ldi	r26, 0x00	; 0
    2418:	b0 e0       	ldi	r27, 0x00	; 0
    241a:	83 1b       	sub	r24, r19
    241c:	91 09       	sbc	r25, r1
    241e:	a1 09       	sbc	r26, r1
    2420:	b1 09       	sbc	r27, r1
    2422:	86 87       	std	Z+14, r24	; 0x0e
    2424:	97 87       	std	Z+15, r25	; 0x0f
    2426:	a0 8b       	std	Z+16, r26	; 0x10
    2428:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    242a:	8b e0       	ldi	r24, 0x0B	; 11
    242c:	28 9f       	mul	r18, r24
    242e:	90 01       	movw	r18, r0
    2430:	11 24       	eor	r1, r1
    2432:	2c 5f       	subi	r18, 0xFC	; 252
    2434:	3e 4c       	sbci	r19, 0xCE	; 206
    2436:	84 85       	ldd	r24, Z+12	; 0x0c
    2438:	95 85       	ldd	r25, Z+13	; 0x0d
    243a:	82 17       	cp	r24, r18
    243c:	93 07       	cpc	r25, r19
    243e:	e9 f4       	brne	.+58     	; 0x247a <vTaskPriorityInherit+0x92>
    2440:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2442:	ef 01       	movw	r28, r30
    2444:	22 96       	adiw	r28, 0x02	; 2
    2446:	ce 01       	movw	r24, r28
    2448:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    244c:	e0 91 30 31 	lds	r30, 0x3130	; 0x803130 <pxCurrentTCB>
    2450:	f0 91 31 31 	lds	r31, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2454:	82 8d       	ldd	r24, Z+26	; 0x1a
    2456:	f8 01       	movw	r30, r16
    2458:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    245a:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    245e:	98 17       	cp	r25, r24
    2460:	10 f4       	brcc	.+4      	; 0x2466 <vTaskPriorityInherit+0x7e>
    2462:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    2466:	fb e0       	ldi	r31, 0x0B	; 11
    2468:	8f 9f       	mul	r24, r31
    246a:	c0 01       	movw	r24, r0
    246c:	11 24       	eor	r1, r1
    246e:	be 01       	movw	r22, r28
    2470:	8c 5f       	subi	r24, 0xFC	; 252
    2472:	9e 4c       	sbci	r25, 0xCE	; 206
    2474:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
    2478:	07 c0       	rjmp	.+14     	; 0x2488 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    247a:	a0 91 30 31 	lds	r26, 0x3130	; 0x803130 <pxCurrentTCB>
    247e:	b0 91 31 31 	lds	r27, 0x3131	; 0x803131 <pxCurrentTCB+0x1>
    2482:	5a 96       	adiw	r26, 0x1a	; 26
    2484:	8c 91       	ld	r24, X
    2486:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2488:	df 91       	pop	r29
    248a:	cf 91       	pop	r28
    248c:	1f 91       	pop	r17
    248e:	0f 91       	pop	r16
    2490:	08 95       	ret

00002492 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2492:	0f 93       	push	r16
    2494:	1f 93       	push	r17
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    249a:	00 97       	sbiw	r24, 0x00	; 0
    249c:	49 f1       	breq	.+82     	; 0x24f0 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    249e:	fc 01       	movw	r30, r24
    24a0:	32 8d       	ldd	r19, Z+26	; 0x1a
    24a2:	27 a1       	ldd	r18, Z+39	; 0x27
    24a4:	32 17       	cp	r19, r18
    24a6:	21 f1       	breq	.+72     	; 0x24f0 <vTaskPriorityDisinherit+0x5e>
    24a8:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    24aa:	8c 01       	movw	r16, r24
    24ac:	0e 5f       	subi	r16, 0xFE	; 254
    24ae:	1f 4f       	sbci	r17, 0xFF	; 255
    24b0:	c8 01       	movw	r24, r16
    24b2:	0e 94 a5 08 	call	0x114a	; 0x114a <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    24b6:	8f a1       	ldd	r24, Y+39	; 0x27
    24b8:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    24ba:	44 e0       	ldi	r20, 0x04	; 4
    24bc:	50 e0       	ldi	r21, 0x00	; 0
    24be:	60 e0       	ldi	r22, 0x00	; 0
    24c0:	70 e0       	ldi	r23, 0x00	; 0
    24c2:	48 1b       	sub	r20, r24
    24c4:	51 09       	sbc	r21, r1
    24c6:	61 09       	sbc	r22, r1
    24c8:	71 09       	sbc	r23, r1
    24ca:	4e 87       	std	Y+14, r20	; 0x0e
    24cc:	5f 87       	std	Y+15, r21	; 0x0f
    24ce:	68 8b       	std	Y+16, r22	; 0x10
    24d0:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    24d2:	90 91 d6 30 	lds	r25, 0x30D6	; 0x8030d6 <uxTopReadyPriority>
    24d6:	98 17       	cp	r25, r24
    24d8:	10 f4       	brcc	.+4      	; 0x24de <vTaskPriorityDisinherit+0x4c>
    24da:	80 93 d6 30 	sts	0x30D6, r24	; 0x8030d6 <uxTopReadyPriority>
    24de:	fb e0       	ldi	r31, 0x0B	; 11
    24e0:	8f 9f       	mul	r24, r31
    24e2:	c0 01       	movw	r24, r0
    24e4:	11 24       	eor	r1, r1
    24e6:	b8 01       	movw	r22, r16
    24e8:	8c 5f       	subi	r24, 0xFC	; 252
    24ea:	9e 4c       	sbci	r25, 0xCE	; 206
    24ec:	0e 94 33 08 	call	0x1066	; 0x1066 <vListInsertEnd>
			}
		}
	}
    24f0:	df 91       	pop	r29
    24f2:	cf 91       	pop	r28
    24f4:	1f 91       	pop	r17
    24f6:	0f 91       	pop	r16
    24f8:	08 95       	ret

000024fa <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    24fa:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    24fc:	e8 81       	ld	r30, Y
    24fe:	f9 81       	ldd	r31, Y+1	; 0x01
    2500:	01 90       	ld	r0, Z+
    2502:	f0 81       	ld	r31, Z
    2504:	e0 2d       	mov	r30, r0
    2506:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2508:	1a 82       	std	Y+2, r1	; 0x02
    250a:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    250c:	6f ef       	ldi	r22, 0xFF	; 255
    250e:	7f ef       	ldi	r23, 0xFF	; 255
    2510:	cb 01       	movw	r24, r22
    2512:	0e 94 60 10 	call	0x20c0	; 0x20c0 <vTaskDelay>
    2516:	fa cf       	rjmp	.-12     	; 0x250c <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002518 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2518:	fc 01       	movw	r30, r24
    251a:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    251c:	65 87       	std	Z+13, r22	; 0x0d
    251e:	08 95       	ret

00002520 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2520:	4f 92       	push	r4
    2522:	5f 92       	push	r5
    2524:	6f 92       	push	r6
    2526:	7f 92       	push	r7
    2528:	8f 92       	push	r8
    252a:	9f 92       	push	r9
    252c:	af 92       	push	r10
    252e:	bf 92       	push	r11
    2530:	cf 92       	push	r12
    2532:	df 92       	push	r13
    2534:	ef 92       	push	r14
    2536:	ff 92       	push	r15
    2538:	0f 93       	push	r16
    253a:	1f 93       	push	r17
    253c:	cf 93       	push	r28
    253e:	df 93       	push	r29
    2540:	cd b7       	in	r28, 0x3d	; 61
    2542:	de b7       	in	r29, 0x3e	; 62
    2544:	2a 97       	sbiw	r28, 0x0a	; 10
    2546:	cd bf       	out	0x3d, r28	; 61
    2548:	de bf       	out	0x3e, r29	; 62
    254a:	4c 01       	movw	r8, r24
    254c:	29 01       	movw	r4, r18
    254e:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2550:	8f e1       	ldi	r24, 0x1F	; 31
    2552:	90 e2       	ldi	r25, 0x20	; 32
    2554:	f4 01       	movw	r30, r8
    2556:	80 83       	st	Z, r24
    2558:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    255a:	fb 01       	movw	r30, r22
    255c:	80 81       	ld	r24, Z
    255e:	88 23       	and	r24, r24
    2560:	69 f0       	breq	.+26     	; 0x257c <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2562:	de 01       	movw	r26, r28
    2564:	11 96       	adiw	r26, 0x01	; 1
    2566:	31 96       	adiw	r30, 0x01	; 1
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	02 c0       	rjmp	.+4      	; 0x2570 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    256c:	99 30       	cpi	r25, 0x09	; 9
    256e:	39 f0       	breq	.+14     	; 0x257e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2570:	9f 5f       	subi	r25, 0xFF	; 255
    2572:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2574:	81 91       	ld	r24, Z+
    2576:	81 11       	cpse	r24, r1
    2578:	f9 cf       	rjmp	.-14     	; 0x256c <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    257a:	01 c0       	rjmp	.+2      	; 0x257e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    257c:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    257e:	e1 e0       	ldi	r30, 0x01	; 1
    2580:	f0 e0       	ldi	r31, 0x00	; 0
    2582:	ec 0f       	add	r30, r28
    2584:	fd 1f       	adc	r31, r29
    2586:	e9 0f       	add	r30, r25
    2588:	f1 1d       	adc	r31, r1
    258a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    258c:	74 01       	movw	r14, r8
    258e:	f2 e0       	ldi	r31, 0x02	; 2
    2590:	ef 0e       	add	r14, r31
    2592:	f1 1c       	adc	r15, r1
    2594:	a1 2c       	mov	r10, r1
    2596:	b1 2c       	mov	r11, r1
    2598:	c1 2c       	mov	r12, r1
    259a:	d1 2c       	mov	r13, r1
    259c:	04 2f       	mov	r16, r20
    259e:	94 01       	movw	r18, r8
    25a0:	a2 01       	movw	r20, r4
    25a2:	be 01       	movw	r22, r28
    25a4:	6f 5f       	subi	r22, 0xFF	; 255
    25a6:	7f 4f       	sbci	r23, 0xFF	; 255
    25a8:	82 ee       	ldi	r24, 0xE2	; 226
    25aa:	92 e0       	ldi	r25, 0x02	; 2
    25ac:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    25b0:	f4 01       	movw	r30, r8
    25b2:	66 82       	std	Z+6, r6	; 0x06
    25b4:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    25b6:	40 86       	std	Z+8, r4	; 0x08
    25b8:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    25ba:	20 91 32 31 	lds	r18, 0x3132	; 0x803132 <last_created_task_pointer>
    25be:	30 91 33 31 	lds	r19, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    25c2:	24 83       	std	Z+4, r18	; 0x04
    25c4:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    25c6:	80 92 32 31 	sts	0x3132, r8	; 0x803132 <last_created_task_pointer>
    25ca:	90 92 33 31 	sts	0x3133, r9	; 0x803133 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    25ce:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    25d0:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    25d2:	40 90 94 31 	lds	r4, 0x3194	; 0x803194 <portStackTopForTask>
    25d6:	50 90 95 31 	lds	r5, 0x3195	; 0x803195 <portStackTopForTask+0x1>
    25da:	ff ef       	ldi	r31, 0xFF	; 255
    25dc:	4f 1a       	sub	r4, r31
    25de:	5f 0a       	sbc	r5, r31
    25e0:	40 92 94 31 	sts	0x3194, r4	; 0x803194 <portStackTopForTask>
    25e4:	50 92 95 31 	sts	0x3195, r5	; 0x803195 <portStackTopForTask+0x1>
    25e8:	f4 01       	movw	r30, r8
    25ea:	42 86       	std	Z+10, r4	; 0x0a
    25ec:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    25ee:	16 86       	std	Z+14, r1	; 0x0e
    25f0:	17 86       	std	Z+15, r1	; 0x0f
    25f2:	10 8a       	std	Z+16, r1	; 0x10
    25f4:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    25f6:	61 14       	cp	r6, r1
    25f8:	71 04       	cpc	r7, r1
    25fa:	09 f4       	brne	.+2      	; 0x25fe <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    25fc:	44 c0       	rjmp	.+136    	; 0x2686 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    25fe:	81 30       	cpi	r24, 0x01	; 1
    2600:	79 f5       	brne	.+94     	; 0x2660 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2602:	6a e0       	ldi	r22, 0x0A	; 10
    2604:	c3 01       	movw	r24, r6
    2606:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    260a:	7c 01       	movw	r14, r24
    260c:	61 e1       	ldi	r22, 0x11	; 17
    260e:	75 e0       	ldi	r23, 0x05	; 5
    2610:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2614:	be 01       	movw	r22, r28
    2616:	6f 5f       	subi	r22, 0xFF	; 255
    2618:	7f 4f       	sbci	r23, 0xFF	; 255
    261a:	c7 01       	movw	r24, r14
    261c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2620:	6a e0       	ldi	r22, 0x0A	; 10
    2622:	c7 01       	movw	r24, r14
    2624:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2628:	7c 01       	movw	r14, r24
    262a:	68 e0       	ldi	r22, 0x08	; 8
    262c:	75 e0       	ldi	r23, 0x05	; 5
    262e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2632:	6a e0       	ldi	r22, 0x0A	; 10
    2634:	c7 01       	movw	r24, r14
    2636:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    263a:	7c 01       	movw	r14, r24
    263c:	6a ef       	ldi	r22, 0xFA	; 250
    263e:	74 e0       	ldi	r23, 0x04	; 4
    2640:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2644:	63 e0       	ldi	r22, 0x03	; 3
    2646:	c7 01       	movw	r24, r14
    2648:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    264c:	b2 01       	movw	r22, r4
    264e:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
    2652:	62 e0       	ldi	r22, 0x02	; 2
    2654:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2658:	66 e0       	ldi	r22, 0x06	; 6
    265a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    265e:	13 c0       	rjmp	.+38     	; 0x2686 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2660:	6a e0       	ldi	r22, 0x0A	; 10
    2662:	c3 01       	movw	r24, r6
    2664:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2668:	4c 01       	movw	r8, r24
    266a:	65 ee       	ldi	r22, 0xE5	; 229
    266c:	74 e0       	ldi	r23, 0x04	; 4
    266e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2672:	be 01       	movw	r22, r28
    2674:	6f 5f       	subi	r22, 0xFF	; 255
    2676:	7f 4f       	sbci	r23, 0xFF	; 255
    2678:	c4 01       	movw	r24, r8
    267a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    267e:	66 e0       	ldi	r22, 0x06	; 6
    2680:	c4 01       	movw	r24, r8
    2682:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2686:	2a 96       	adiw	r28, 0x0a	; 10
    2688:	cd bf       	out	0x3d, r28	; 61
    268a:	de bf       	out	0x3e, r29	; 62
    268c:	df 91       	pop	r29
    268e:	cf 91       	pop	r28
    2690:	1f 91       	pop	r17
    2692:	0f 91       	pop	r16
    2694:	ff 90       	pop	r15
    2696:	ef 90       	pop	r14
    2698:	df 90       	pop	r13
    269a:	cf 90       	pop	r12
    269c:	bf 90       	pop	r11
    269e:	af 90       	pop	r10
    26a0:	9f 90       	pop	r9
    26a2:	8f 90       	pop	r8
    26a4:	7f 90       	pop	r7
    26a6:	6f 90       	pop	r6
    26a8:	5f 90       	pop	r5
    26aa:	4f 90       	pop	r4
    26ac:	08 95       	ret

000026ae <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    26ae:	cf 92       	push	r12
    26b0:	df 92       	push	r13
    26b2:	ef 92       	push	r14
    26b4:	ff 92       	push	r15
    26b6:	0f 93       	push	r16
    26b8:	1f 93       	push	r17
    26ba:	cf 93       	push	r28
    26bc:	df 93       	push	r29
    26be:	ec 01       	movw	r28, r24
    26c0:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    26c2:	8a 81       	ldd	r24, Y+2	; 0x02
    26c4:	9b 81       	ldd	r25, Y+3	; 0x03
    26c6:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <pcTaskGetTaskName>
    26ca:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    26cc:	6a e0       	ldi	r22, 0x0A	; 10
    26ce:	c7 01       	movw	r24, r14
    26d0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    26d4:	8c 01       	movw	r16, r24
    26d6:	64 e2       	ldi	r22, 0x24	; 36
    26d8:	75 e0       	ldi	r23, 0x05	; 5
    26da:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    26de:	6a e0       	ldi	r22, 0x0A	; 10
    26e0:	c8 01       	movw	r24, r16
    26e2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    26e6:	8c 01       	movw	r16, r24
    26e8:	6d e1       	ldi	r22, 0x1D	; 29
    26ea:	75 e0       	ldi	r23, 0x05	; 5
    26ec:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    26f0:	b6 01       	movw	r22, r12
    26f2:	c8 01       	movw	r24, r16
    26f4:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    26f8:	6a e0       	ldi	r22, 0x0A	; 10
    26fa:	c8 01       	movw	r24, r16
    26fc:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2700:	8c 01       	movw	r16, r24
    2702:	67 e1       	ldi	r22, 0x17	; 23
    2704:	75 e0       	ldi	r23, 0x05	; 5
    2706:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    270a:	66 e0       	ldi	r22, 0x06	; 6
    270c:	c8 01       	movw	r24, r16
    270e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2712:	8a 85       	ldd	r24, Y+10	; 0x0a
    2714:	9b 85       	ldd	r25, Y+11	; 0x0b
    2716:	e8 85       	ldd	r30, Y+8	; 0x08
    2718:	f9 85       	ldd	r31, Y+9	; 0x09
    271a:	01 e1       	ldi	r16, 0x11	; 17
    271c:	21 e0       	ldi	r18, 0x01	; 1
    271e:	a7 01       	movw	r20, r14
    2720:	bc 01       	movw	r22, r24
    2722:	8e 1b       	sub	r24, r30
    2724:	9f 0b       	sbc	r25, r31
    2726:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    272a:	8c 81       	ldd	r24, Y+4	; 0x04
    272c:	9d 81       	ldd	r25, Y+5	; 0x05
    272e:	00 97       	sbiw	r24, 0x00	; 0
    2730:	19 f0       	breq	.+6      	; 0x2738 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2732:	b7 01       	movw	r22, r14
    2734:	0e 94 57 13 	call	0x26ae	; 0x26ae <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2738:	df 91       	pop	r29
    273a:	cf 91       	pop	r28
    273c:	1f 91       	pop	r17
    273e:	0f 91       	pop	r16
    2740:	ff 90       	pop	r15
    2742:	ef 90       	pop	r14
    2744:	df 90       	pop	r13
    2746:	cf 90       	pop	r12
    2748:	08 95       	ret

0000274a <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    274a:	0f 93       	push	r16
    274c:	1f 93       	push	r17
    274e:	cf 93       	push	r28
    2750:	df 93       	push	r29
    2752:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2754:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    2758:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    275c:	00 97       	sbiw	r24, 0x00	; 0
    275e:	19 f0       	breq	.+6      	; 0x2766 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2760:	be 01       	movw	r22, r28
    2762:	0e 94 57 13 	call	0x26ae	; 0x26ae <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2766:	6a e0       	ldi	r22, 0x0A	; 10
    2768:	ce 01       	movw	r24, r28
    276a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    276e:	8c 01       	movw	r16, r24
    2770:	6a e3       	ldi	r22, 0x3A	; 58
    2772:	75 e0       	ldi	r23, 0x05	; 5
    2774:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2778:	6a e0       	ldi	r22, 0x0A	; 10
    277a:	c8 01       	movw	r24, r16
    277c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2780:	8c 01       	movw	r16, r24
    2782:	6f e2       	ldi	r22, 0x2F	; 47
    2784:	75 e0       	ldi	r23, 0x05	; 5
    2786:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    278a:	6a e0       	ldi	r22, 0x0A	; 10
    278c:	c8 01       	movw	r24, r16
    278e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2792:	8c 01       	movw	r16, r24
    2794:	69 e2       	ldi	r22, 0x29	; 41
    2796:	75 e0       	ldi	r23, 0x05	; 5
    2798:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    279c:	66 e0       	ldi	r22, 0x06	; 6
    279e:	c8 01       	movw	r24, r16
    27a0:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    27a4:	80 91 94 31 	lds	r24, 0x3194	; 0x803194 <portStackTopForTask>
    27a8:	90 91 95 31 	lds	r25, 0x3195	; 0x803195 <portStackTopForTask+0x1>
    27ac:	bc 01       	movw	r22, r24
    27ae:	6f 5f       	subi	r22, 0xFF	; 255
    27b0:	7f 4f       	sbci	r23, 0xFF	; 255
    27b2:	01 e1       	ldi	r16, 0x11	; 17
    27b4:	21 e0       	ldi	r18, 0x01	; 1
    27b6:	ae 01       	movw	r20, r28
    27b8:	83 56       	subi	r24, 0x63	; 99
    27ba:	91 09       	sbc	r25, r1
    27bc:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	1f 91       	pop	r17
    27c6:	0f 91       	pop	r16
    27c8:	08 95       	ret

000027ca <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    27ca:	8f 92       	push	r8
    27cc:	9f 92       	push	r9
    27ce:	af 92       	push	r10
    27d0:	bf 92       	push	r11
    27d2:	cf 92       	push	r12
    27d4:	df 92       	push	r13
    27d6:	ef 92       	push	r14
    27d8:	ff 92       	push	r15
    27da:	0f 93       	push	r16
    27dc:	1f 93       	push	r17
    27de:	cf 93       	push	r28
    27e0:	df 93       	push	r29
    27e2:	ec 01       	movw	r28, r24
    27e4:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    27e6:	8a 81       	ldd	r24, Y+2	; 0x02
    27e8:	9b 81       	ldd	r25, Y+3	; 0x03
    27ea:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <pcTaskGetTaskName>
    27ee:	bc 01       	movw	r22, r24
    27f0:	c8 01       	movw	r24, r16
    27f2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    27f6:	d8 01       	movw	r26, r16
    27f8:	ed 91       	ld	r30, X+
    27fa:	fc 91       	ld	r31, X
    27fc:	02 80       	ldd	r0, Z+2	; 0x02
    27fe:	f3 81       	ldd	r31, Z+3	; 0x03
    2800:	e0 2d       	mov	r30, r0
    2802:	69 e0       	ldi	r22, 0x09	; 9
    2804:	c8 01       	movw	r24, r16
    2806:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2808:	8a 81       	ldd	r24, Y+2	; 0x02
    280a:	9b 81       	ldd	r25, Y+3	; 0x03
    280c:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <pcTaskGetTaskName>
    2810:	fc 01       	movw	r30, r24
    2812:	01 90       	ld	r0, Z+
    2814:	00 20       	and	r0, r0
    2816:	e9 f7       	brne	.-6      	; 0x2812 <_ZN8frt_task12print_statusER8emstream+0x48>
    2818:	31 97       	sbiw	r30, 0x01	; 1
    281a:	e8 1b       	sub	r30, r24
    281c:	f9 0b       	sbc	r31, r25
    281e:	38 97       	sbiw	r30, 0x08	; 8
    2820:	48 f4       	brcc	.+18     	; 0x2834 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2822:	d8 01       	movw	r26, r16
    2824:	ed 91       	ld	r30, X+
    2826:	fc 91       	ld	r31, X
    2828:	02 80       	ldd	r0, Z+2	; 0x02
    282a:	f3 81       	ldd	r31, Z+3	; 0x03
    282c:	e0 2d       	mov	r30, r0
    282e:	69 e0       	ldi	r22, 0x09	; 9
    2830:	c8 01       	movw	r24, r16
    2832:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2834:	ce 84       	ldd	r12, Y+14	; 0x0e
    2836:	df 84       	ldd	r13, Y+15	; 0x0f
    2838:	e8 88       	ldd	r14, Y+16	; 0x10
    283a:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    283c:	a8 84       	ldd	r10, Y+8	; 0x08
    283e:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2840:	8a 81       	ldd	r24, Y+2	; 0x02
    2842:	9b 81       	ldd	r25, Y+3	; 0x03
    2844:	0e 94 d6 11 	call	0x23ac	; 0x23ac <uxTaskGetStackHighWaterMark>
    2848:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    284a:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    284c:	8a 81       	ldd	r24, Y+2	; 0x02
    284e:	9b 81       	ldd	r25, Y+3	; 0x03
    2850:	0e 94 7b 0e 	call	0x1cf6	; 0x1cf6 <uxTaskPriorityGet>
    2854:	68 2f       	mov	r22, r24
    2856:	c8 01       	movw	r24, r16
    2858:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    285c:	6a e0       	ldi	r22, 0x0A	; 10
    285e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2862:	ec 01       	movw	r28, r24
    2864:	6f ea       	ldi	r22, 0xAF	; 175
    2866:	75 e0       	ldi	r23, 0x05	; 5
    2868:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
			<< get_state ()
    286c:	68 2d       	mov	r22, r8
    286e:	ce 01       	movw	r24, r28
    2870:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2874:	6a e0       	ldi	r22, 0x0A	; 10
    2876:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    287a:	ec 01       	movw	r28, r24
    287c:	6d ea       	ldi	r22, 0xAD	; 173
    287e:	75 e0       	ldi	r23, 0x05	; 5
    2880:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2884:	69 2d       	mov	r22, r9
    2886:	ce 01       	movw	r24, r28
    2888:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    288c:	6a e0       	ldi	r22, 0x0A	; 10
    288e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2892:	ec 01       	movw	r28, r24
    2894:	6b ea       	ldi	r22, 0xAB	; 171
    2896:	75 e0       	ldi	r23, 0x05	; 5
    2898:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    289c:	b5 01       	movw	r22, r10
    289e:	ce 01       	movw	r24, r28
    28a0:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
    28a4:	6a e0       	ldi	r22, 0x0A	; 10
    28a6:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    28aa:	ec 01       	movw	r28, r24
    28ac:	69 ea       	ldi	r22, 0xA9	; 169
    28ae:	75 e0       	ldi	r23, 0x05	; 5
    28b0:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    28b4:	6a e0       	ldi	r22, 0x0A	; 10
    28b6:	ce 01       	movw	r24, r28
    28b8:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    28bc:	ec 01       	movw	r28, r24
    28be:	67 ea       	ldi	r22, 0xA7	; 167
    28c0:	75 e0       	ldi	r23, 0x05	; 5
    28c2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    28c6:	b7 01       	movw	r22, r14
    28c8:	a6 01       	movw	r20, r12
    28ca:	ce 01       	movw	r24, r28
    28cc:	0e 94 70 18 	call	0x30e0	; 0x30e0 <_ZN8emstreamlsEm>
}
    28d0:	df 91       	pop	r29
    28d2:	cf 91       	pop	r28
    28d4:	1f 91       	pop	r17
    28d6:	0f 91       	pop	r16
    28d8:	ff 90       	pop	r15
    28da:	ef 90       	pop	r14
    28dc:	df 90       	pop	r13
    28de:	cf 90       	pop	r12
    28e0:	bf 90       	pop	r11
    28e2:	af 90       	pop	r10
    28e4:	9f 90       	pop	r9
    28e6:	8f 90       	pop	r8
    28e8:	08 95       	ret

000028ea <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    28ea:	cf 93       	push	r28
    28ec:	df 93       	push	r29
    28ee:	ec 01       	movw	r28, r24
    28f0:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    28f2:	db 01       	movw	r26, r22
    28f4:	ed 91       	ld	r30, X+
    28f6:	fc 91       	ld	r31, X
    28f8:	02 80       	ldd	r0, Z+2	; 0x02
    28fa:	f3 81       	ldd	r31, Z+3	; 0x03
    28fc:	e0 2d       	mov	r30, r0
    28fe:	be 01       	movw	r22, r28
    2900:	19 95       	eicall
	return (ser_dev);
}
    2902:	ce 01       	movw	r24, r28
    2904:	df 91       	pop	r29
    2906:	cf 91       	pop	r28
    2908:	08 95       	ret

0000290a <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    290a:	0f 93       	push	r16
    290c:	1f 93       	push	r17
    290e:	cf 93       	push	r28
    2910:	df 93       	push	r29
    2912:	ec 01       	movw	r28, r24
    2914:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2916:	bc 01       	movw	r22, r24
    2918:	c8 01       	movw	r24, r16
    291a:	0e 94 75 14 	call	0x28ea	; 0x28ea <_ZlsR8emstreamR8frt_task>
    291e:	66 e0       	ldi	r22, 0x06	; 6
    2920:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2924:	8c 81       	ldd	r24, Y+4	; 0x04
    2926:	9d 81       	ldd	r25, Y+5	; 0x05
    2928:	00 97       	sbiw	r24, 0x00	; 0
    292a:	19 f0       	breq	.+6      	; 0x2932 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    292c:	b8 01       	movw	r22, r16
    292e:	0e 94 85 14 	call	0x290a	; 0x290a <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2932:	df 91       	pop	r29
    2934:	cf 91       	pop	r28
    2936:	1f 91       	pop	r17
    2938:	0f 91       	pop	r16
    293a:	08 95       	ret

0000293c <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    293c:	0f 93       	push	r16
    293e:	1f 93       	push	r17
    2940:	cf 93       	push	r28
    2942:	df 93       	push	r29
    2944:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2946:	6a e0       	ldi	r22, 0x0A	; 10
    2948:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    294c:	8c 01       	movw	r16, r24
    294e:	6c e9       	ldi	r22, 0x9C	; 156
    2950:	75 e0       	ldi	r23, 0x05	; 5
    2952:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2956:	6a e0       	ldi	r22, 0x0A	; 10
    2958:	c8 01       	movw	r24, r16
    295a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    295e:	8c 01       	movw	r16, r24
    2960:	65 e9       	ldi	r22, 0x95	; 149
    2962:	75 e0       	ldi	r23, 0x05	; 5
    2964:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2968:	66 e0       	ldi	r22, 0x06	; 6
    296a:	c8 01       	movw	r24, r16
    296c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2970:	6a e0       	ldi	r22, 0x0A	; 10
    2972:	ce 01       	movw	r24, r28
    2974:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2978:	8c 01       	movw	r16, r24
    297a:	64 e8       	ldi	r22, 0x84	; 132
    297c:	75 e0       	ldi	r23, 0x05	; 5
    297e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2982:	6a e0       	ldi	r22, 0x0A	; 10
    2984:	c8 01       	movw	r24, r16
    2986:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    298a:	8c 01       	movw	r16, r24
    298c:	68 e7       	ldi	r22, 0x78	; 120
    298e:	75 e0       	ldi	r23, 0x05	; 5
    2990:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2994:	6a e0       	ldi	r22, 0x0A	; 10
    2996:	c8 01       	movw	r24, r16
    2998:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    299c:	8c 01       	movw	r16, r24
    299e:	62 e7       	ldi	r22, 0x72	; 114
    29a0:	75 e0       	ldi	r23, 0x05	; 5
    29a2:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    29a6:	66 e0       	ldi	r22, 0x06	; 6
    29a8:	c8 01       	movw	r24, r16
    29aa:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    29ae:	6a e0       	ldi	r22, 0x0A	; 10
    29b0:	ce 01       	movw	r24, r28
    29b2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    29b6:	8c 01       	movw	r16, r24
    29b8:	61 e6       	ldi	r22, 0x61	; 97
    29ba:	75 e0       	ldi	r23, 0x05	; 5
    29bc:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    29c0:	6a e0       	ldi	r22, 0x0A	; 10
    29c2:	c8 01       	movw	r24, r16
    29c4:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    29c8:	8c 01       	movw	r16, r24
    29ca:	65 e5       	ldi	r22, 0x55	; 85
    29cc:	75 e0       	ldi	r23, 0x05	; 5
    29ce:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    29d2:	6a e0       	ldi	r22, 0x0A	; 10
    29d4:	c8 01       	movw	r24, r16
    29d6:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    29da:	8c 01       	movw	r16, r24
    29dc:	6f e4       	ldi	r22, 0x4F	; 79
    29de:	75 e0       	ldi	r23, 0x05	; 5
    29e0:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    29e4:	66 e0       	ldi	r22, 0x06	; 6
    29e6:	c8 01       	movw	r24, r16
    29e8:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    29ec:	80 91 32 31 	lds	r24, 0x3132	; 0x803132 <last_created_task_pointer>
    29f0:	90 91 33 31 	lds	r25, 0x3133	; 0x803133 <last_created_task_pointer+0x1>
    29f4:	00 97       	sbiw	r24, 0x00	; 0
    29f6:	19 f0       	breq	.+6      	; 0x29fe <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    29f8:	be 01       	movw	r22, r28
    29fa:	0e 94 85 14 	call	0x290a	; 0x290a <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    29fe:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <xTaskGetIdleTaskHandle>
    2a02:	0e 94 d6 11 	call	0x23ac	; 0x23ac <uxTaskGetStackHighWaterMark>
    2a06:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2a08:	6a e0       	ldi	r22, 0x0A	; 10
    2a0a:	ce 01       	movw	r24, r28
    2a0c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2a10:	ec 01       	movw	r28, r24
    2a12:	64 e4       	ldi	r22, 0x44	; 68
    2a14:	75 e0       	ldi	r23, 0x05	; 5
    2a16:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2a1a:	61 2f       	mov	r22, r17
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2a22:	6a e0       	ldi	r22, 0x0A	; 10
    2a24:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2a28:	ec 01       	movw	r28, r24
    2a2a:	62 e4       	ldi	r22, 0x42	; 66
    2a2c:	75 e0       	ldi	r23, 0x05	; 5
    2a2e:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2a32:	64 e6       	ldi	r22, 0x64	; 100
    2a34:	70 e0       	ldi	r23, 0x00	; 0
    2a36:	ce 01       	movw	r24, r28
    2a38:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
    2a3c:	6a e0       	ldi	r22, 0x0A	; 10
    2a3e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2a42:	ec 01       	movw	r28, r24
    2a44:	6f e3       	ldi	r22, 0x3F	; 63
    2a46:	75 e0       	ldi	r23, 0x05	; 5
    2a48:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2a4c:	66 e0       	ldi	r22, 0x06	; 6
    2a4e:	ce 01       	movw	r24, r28
    2a50:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
}
    2a54:	df 91       	pop	r29
    2a56:	cf 91       	pop	r28
    2a58:	1f 91       	pop	r17
    2a5a:	0f 91       	pop	r16
    2a5c:	08 95       	ret

00002a5e <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2a5e:	0f 93       	push	r16
    2a60:	cf 93       	push	r28
    2a62:	df 93       	push	r29
    2a64:	1f 92       	push	r1
    2a66:	cd b7       	in	r28, 0x3d	; 61
    2a68:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2a6a:	00 e0       	ldi	r16, 0x00	; 0
    2a6c:	2f ef       	ldi	r18, 0xFF	; 255
    2a6e:	3f ef       	ldi	r19, 0xFF	; 255
    2a70:	a9 01       	movw	r20, r18
    2a72:	be 01       	movw	r22, r28
    2a74:	6f 5f       	subi	r22, 0xFF	; 255
    2a76:	7f 4f       	sbci	r23, 0xFF	; 255
    2a78:	fc 01       	movw	r30, r24
    2a7a:	80 85       	ldd	r24, Z+8	; 0x08
    2a7c:	91 85       	ldd	r25, Z+9	; 0x09
    2a7e:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
    2a82:	81 30       	cpi	r24, 0x01	; 1
    2a84:	19 f4       	brne	.+6      	; 0x2a8c <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	02 c0       	rjmp	.+4      	; 0x2a90 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2a8c:	8f ef       	ldi	r24, 0xFF	; 255
    2a8e:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2a90:	0f 90       	pop	r0
    2a92:	df 91       	pop	r29
    2a94:	cf 91       	pop	r28
    2a96:	0f 91       	pop	r16
    2a98:	08 95       	ret

00002a9a <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	80 85       	ldd	r24, Z+8	; 0x08
    2a9e:	91 85       	ldd	r25, Z+9	; 0x09
    2aa0:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
    2aa4:	91 e0       	ldi	r25, 0x01	; 1
    2aa6:	81 11       	cpse	r24, r1
    2aa8:	01 c0       	rjmp	.+2      	; 0x2aac <_ZN14frt_text_queue14check_for_charEv+0x12>
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2aac:	89 2f       	mov	r24, r25
    2aae:	08 95       	ret

00002ab0 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2ab0:	0f 93       	push	r16
    2ab2:	cf 93       	push	r28
    2ab4:	df 93       	push	r29
    2ab6:	1f 92       	push	r1
    2ab8:	cd b7       	in	r28, 0x3d	; 61
    2aba:	de b7       	in	r29, 0x3e	; 62
    2abc:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2abe:	fc 01       	movw	r30, r24
    2ac0:	22 85       	ldd	r18, Z+10	; 0x0a
    2ac2:	33 85       	ldd	r19, Z+11	; 0x0b
    2ac4:	44 85       	ldd	r20, Z+12	; 0x0c
    2ac6:	55 85       	ldd	r21, Z+13	; 0x0d
    2ac8:	00 e0       	ldi	r16, 0x00	; 0
    2aca:	be 01       	movw	r22, r28
    2acc:	6f 5f       	subi	r22, 0xFF	; 255
    2ace:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad0:	80 85       	ldd	r24, Z+8	; 0x08
    2ad2:	91 85       	ldd	r25, Z+9	; 0x09
    2ad4:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xQueueGenericSend>
    2ad8:	91 e0       	ldi	r25, 0x01	; 1
    2ada:	81 11       	cpse	r24, r1
    2adc:	01 c0       	rjmp	.+2      	; 0x2ae0 <_ZN14frt_text_queue7putcharEc+0x30>
    2ade:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2ae0:	89 2f       	mov	r24, r25
    2ae2:	0f 90       	pop	r0
    2ae4:	df 91       	pop	r29
    2ae6:	cf 91       	pop	r28
    2ae8:	0f 91       	pop	r16
    2aea:	08 95       	ret

00002aec <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2aec:	8f 92       	push	r8
    2aee:	9f 92       	push	r9
    2af0:	bf 92       	push	r11
    2af2:	cf 92       	push	r12
    2af4:	df 92       	push	r13
    2af6:	ef 92       	push	r14
    2af8:	ff 92       	push	r15
    2afa:	0f 93       	push	r16
    2afc:	1f 93       	push	r17
    2afe:	cf 93       	push	r28
    2b00:	df 93       	push	r29
    2b02:	ec 01       	movw	r28, r24
    2b04:	b6 2e       	mov	r11, r22
    2b06:	4a 01       	movw	r8, r20
    2b08:	68 01       	movw	r12, r16
    2b0a:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2b0c:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <_ZN8emstreamC1Ev>
    2b10:	87 e2       	ldi	r24, 0x27	; 39
    2b12:	90 e2       	ldi	r25, 0x20	; 32
    2b14:	88 83       	st	Y, r24
    2b16:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2b18:	8e 86       	std	Y+14, r8	; 0x0e
    2b1a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2b1c:	40 e0       	ldi	r20, 0x00	; 0
    2b1e:	61 e0       	ldi	r22, 0x01	; 1
    2b20:	8b 2d       	mov	r24, r11
    2b22:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    2b26:	88 87       	std	Y+8, r24	; 0x08
    2b28:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2b2a:	ca 86       	std	Y+10, r12	; 0x0a
    2b2c:	db 86       	std	Y+11, r13	; 0x0b
    2b2e:	ec 86       	std	Y+12, r14	; 0x0c
    2b30:	fd 86       	std	Y+13, r15	; 0x0d
}
    2b32:	df 91       	pop	r29
    2b34:	cf 91       	pop	r28
    2b36:	1f 91       	pop	r17
    2b38:	0f 91       	pop	r16
    2b3a:	ff 90       	pop	r15
    2b3c:	ef 90       	pop	r14
    2b3e:	df 90       	pop	r13
    2b40:	cf 90       	pop	r12
    2b42:	bf 90       	pop	r11
    2b44:	9f 90       	pop	r9
    2b46:	8f 90       	pop	r8
    2b48:	08 95       	ret

00002b4a <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2b4a:	cf 92       	push	r12
    2b4c:	df 92       	push	r13
    2b4e:	ef 92       	push	r14
    2b50:	ff 92       	push	r15
    2b52:	cf 93       	push	r28
    2b54:	df 93       	push	r29
    2b56:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2b58:	68 81       	ld	r22, Y
    2b5a:	79 81       	ldd	r23, Y+1	; 0x01
    2b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b60:	0f 2e       	mov	r0, r31
    2b62:	f8 ee       	ldi	r31, 0xE8	; 232
    2b64:	cf 2e       	mov	r12, r31
    2b66:	f3 e0       	ldi	r31, 0x03	; 3
    2b68:	df 2e       	mov	r13, r31
    2b6a:	e1 2c       	mov	r14, r1
    2b6c:	f1 2c       	mov	r15, r1
    2b6e:	f0 2d       	mov	r31, r0
    2b70:	a7 01       	movw	r20, r14
    2b72:	96 01       	movw	r18, r12
    2b74:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
    2b78:	9b 01       	movw	r18, r22
    2b7a:	ac 01       	movw	r20, r24
    2b7c:	60 e4       	ldi	r22, 0x40	; 64
    2b7e:	72 e4       	ldi	r23, 0x42	; 66
    2b80:	8f e0       	ldi	r24, 0x0F	; 15
    2b82:	90 e0       	ldi	r25, 0x00	; 0
    2b84:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <__mulsi3>
    2b88:	a7 01       	movw	r20, r14
    2b8a:	96 01       	movw	r18, r12
    2b8c:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
    2b90:	69 01       	movw	r12, r18
    2b92:	7a 01       	movw	r14, r20
    2b94:	ac 81       	ldd	r26, Y+4	; 0x04
    2b96:	bd 81       	ldd	r27, Y+5	; 0x05
    2b98:	20 e4       	ldi	r18, 0x40	; 64
    2b9a:	32 e4       	ldi	r19, 0x42	; 66
    2b9c:	4f e0       	ldi	r20, 0x0F	; 15
    2b9e:	50 e0       	ldi	r21, 0x00	; 0
    2ba0:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <__muluhisi3>
    2ba4:	20 e0       	ldi	r18, 0x00	; 0
    2ba6:	38 e4       	ldi	r19, 0x48	; 72
    2ba8:	48 ee       	ldi	r20, 0xE8	; 232
    2baa:	51 e0       	ldi	r21, 0x01	; 1
    2bac:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
    2bb0:	c7 01       	movw	r24, r14
    2bb2:	b6 01       	movw	r22, r12
    2bb4:	62 0f       	add	r22, r18
    2bb6:	73 1f       	adc	r23, r19
    2bb8:	84 1f       	adc	r24, r20
    2bba:	95 1f       	adc	r25, r21
}
    2bbc:	df 91       	pop	r29
    2bbe:	cf 91       	pop	r28
    2bc0:	ff 90       	pop	r15
    2bc2:	ef 90       	pop	r14
    2bc4:	df 90       	pop	r13
    2bc6:	cf 90       	pop	r12
    2bc8:	08 95       	ret

00002bca <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2bca:	cf 92       	push	r12
    2bcc:	df 92       	push	r13
    2bce:	ef 92       	push	r14
    2bd0:	ff 92       	push	r15
    2bd2:	0f 93       	push	r16
    2bd4:	1f 93       	push	r17
    2bd6:	cf 93       	push	r28
    2bd8:	df 93       	push	r29
    2bda:	cd b7       	in	r28, 0x3d	; 61
    2bdc:	de b7       	in	r29, 0x3e	; 62
    2bde:	2f 97       	sbiw	r28, 0x0f	; 15
    2be0:	cd bf       	out	0x3d, r28	; 61
    2be2:	de bf       	out	0x3e, r29	; 62
    2be4:	6c 01       	movw	r12, r24
    2be6:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2be8:	db 01       	movw	r26, r22
    2bea:	6d 91       	ld	r22, X+
    2bec:	7d 91       	ld	r23, X+
    2bee:	8d 91       	ld	r24, X+
    2bf0:	9c 91       	ld	r25, X
    2bf2:	28 ee       	ldi	r18, 0xE8	; 232
    2bf4:	33 e0       	ldi	r19, 0x03	; 3
    2bf6:	40 e0       	ldi	r20, 0x00	; 0
    2bf8:	50 e0       	ldi	r21, 0x00	; 0
    2bfa:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
    2bfe:	ba 01       	movw	r22, r20
    2c00:	a9 01       	movw	r20, r18
    2c02:	c6 01       	movw	r24, r12
    2c04:	0e 94 70 18 	call	0x30e0	; 0x30e0 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2c08:	d6 01       	movw	r26, r12
    2c0a:	ed 91       	ld	r30, X+
    2c0c:	fc 91       	ld	r31, X
    2c0e:	02 80       	ldd	r0, Z+2	; 0x02
    2c10:	f3 81       	ldd	r31, Z+3	; 0x03
    2c12:	e0 2d       	mov	r30, r0
    2c14:	6e e2       	ldi	r22, 0x2E	; 46
    2c16:	c6 01       	movw	r24, r12
    2c18:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2c1a:	c8 01       	movw	r24, r16
    2c1c:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <_ZN10time_stamp12get_microsecEv>
    2c20:	8e 01       	movw	r16, r28
    2c22:	09 5f       	subi	r16, 0xF9	; 249
    2c24:	1f 4f       	sbci	r17, 0xFF	; 255
    2c26:	fe 01       	movw	r30, r28
    2c28:	31 96       	adiw	r30, 0x01	; 1
    2c2a:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2c2c:	2a e0       	ldi	r18, 0x0A	; 10
    2c2e:	30 e0       	ldi	r19, 0x00	; 0
    2c30:	40 e0       	ldi	r20, 0x00	; 0
    2c32:	50 e0       	ldi	r21, 0x00	; 0
    2c34:	0e 94 3a 1f 	call	0x3e74	; 0x3e74 <__divmodsi4>
    2c38:	e6 2f       	mov	r30, r22
    2c3a:	28 87       	std	Y+8, r18	; 0x08
    2c3c:	39 87       	std	Y+9, r19	; 0x09
    2c3e:	4a 87       	std	Y+10, r20	; 0x0a
    2c40:	5b 87       	std	Y+11, r21	; 0x0b
    2c42:	68 85       	ldd	r22, Y+8	; 0x08
    2c44:	79 85       	ldd	r23, Y+9	; 0x09
    2c46:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c48:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2c4a:	20 e3       	ldi	r18, 0x30	; 48
    2c4c:	2e 0f       	add	r18, r30
    2c4e:	d8 01       	movw	r26, r16
    2c50:	2e 93       	st	-X, r18
    2c52:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2c54:	ae 15       	cp	r26, r14
    2c56:	bf 05       	cpc	r27, r15
    2c58:	49 f7       	brne	.-46     	; 0x2c2c <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2c5a:	1f 82       	std	Y+7, r1	; 0x07
    2c5c:	be 01       	movw	r22, r28
    2c5e:	6f 5f       	subi	r22, 0xFF	; 255
    2c60:	7f 4f       	sbci	r23, 0xFF	; 255
    2c62:	c6 01       	movw	r24, r12
    2c64:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2c68:	c6 01       	movw	r24, r12
    2c6a:	2f 96       	adiw	r28, 0x0f	; 15
    2c6c:	cd bf       	out	0x3d, r28	; 61
    2c6e:	de bf       	out	0x3e, r29	; 62
    2c70:	df 91       	pop	r29
    2c72:	cf 91       	pop	r28
    2c74:	1f 91       	pop	r17
    2c76:	0f 91       	pop	r16
    2c78:	ff 90       	pop	r15
    2c7a:	ef 90       	pop	r14
    2c7c:	df 90       	pop	r13
    2c7e:	cf 90       	pop	r12
    2c80:	08 95       	ret

00002c82 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2c88:	0f b6       	in	r0, 0x3f	; 63
    2c8a:	f8 94       	cli
    2c8c:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2c8e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c92:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c96:	8c 83       	std	Y+4, r24	; 0x04
    2c98:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2c9a:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <xTaskGetTickCount>
    2c9e:	68 83       	st	Y, r22
    2ca0:	79 83       	std	Y+1, r23	; 0x01
    2ca2:	8a 83       	std	Y+2, r24	; 0x02
    2ca4:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2ca6:	0f 90       	pop	r0
    2ca8:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2caa:	ce 01       	movw	r24, r28
    2cac:	df 91       	pop	r29
    2cae:	cf 91       	pop	r28
    2cb0:	08 95       	ret

00002cb2 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2cb2:	5f 92       	push	r5
    2cb4:	6f 92       	push	r6
    2cb6:	7f 92       	push	r7
    2cb8:	8f 92       	push	r8
    2cba:	9f 92       	push	r9
    2cbc:	af 92       	push	r10
    2cbe:	bf 92       	push	r11
    2cc0:	cf 92       	push	r12
    2cc2:	df 92       	push	r13
    2cc4:	ef 92       	push	r14
    2cc6:	ff 92       	push	r15
    2cc8:	0f 93       	push	r16
    2cca:	1f 93       	push	r17
    2ccc:	cf 93       	push	r28
    2cce:	df 93       	push	r29
    2cd0:	5c 01       	movw	r10, r24
    2cd2:	4b 01       	movw	r8, r22
    2cd4:	7a 01       	movw	r14, r20
    2cd6:	12 2f       	mov	r17, r18
    2cd8:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2cda:	63 e0       	ldi	r22, 0x03	; 3
    2cdc:	ca 01       	movw	r24, r20
    2cde:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2ce2:	a8 14       	cp	r10, r8
    2ce4:	b9 04       	cpc	r11, r9
    2ce6:	08 f0       	brcs	.+2      	; 0x2cea <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2ce8:	7d c0       	rjmp	.+250    	; 0x2de4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2cea:	65 01       	movw	r12, r10
    2cec:	84 e1       	ldi	r24, 0x14	; 20
    2cee:	c8 0e       	add	r12, r24
    2cf0:	d1 1c       	adc	r13, r1
    2cf2:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2cf4:	6a 2c       	mov	r6, r10
    2cf6:	5b 2c       	mov	r5, r11
    2cf8:	b5 01       	movw	r22, r10
    2cfa:	c7 01       	movw	r24, r14
    2cfc:	0e 94 3c 18 	call	0x3078	; 0x3078 <_ZN8emstreamlsEj>
    2d00:	6a e0       	ldi	r22, 0x0A	; 10
    2d02:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2d06:	61 ec       	ldi	r22, 0xC1	; 193
    2d08:	75 e0       	ldi	r23, 0x05	; 5
    2d0a:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2d0e:	11 23       	and	r17, r17
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2d12:	6d c0       	rjmp	.+218    	; 0x2dee <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2d14:	00 23       	and	r16, r16
    2d16:	09 f4       	brne	.+2      	; 0x2d1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2d18:	6a c0       	rjmp	.+212    	; 0x2dee <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2d1a:	6a e0       	ldi	r22, 0x0A	; 10
    2d1c:	c7 01       	movw	r24, r14
    2d1e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2d22:	6c eb       	ldi	r22, 0xBC	; 188
    2d24:	75 e0       	ldi	r23, 0x05	; 5
    2d26:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    2d2a:	61 c0       	rjmp	.+194    	; 0x2dee <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2d2c:	11 23       	and	r17, r17
    2d2e:	71 f0       	breq	.+28     	; 0x2d4c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2d30:	01 11       	cpse	r16, r1
    2d32:	0c c0       	rjmp	.+24     	; 0x2d4c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2d34:	88 81       	ld	r24, Y
    2d36:	87 15       	cp	r24, r7
    2d38:	49 f0       	breq	.+18     	; 0x2d4c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2d3a:	6a e0       	ldi	r22, 0x0A	; 10
    2d3c:	c7 01       	movw	r24, r14
    2d3e:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2d42:	67 eb       	ldi	r22, 0xB7	; 183
    2d44:	75 e0       	ldi	r23, 0x05	; 5
    2d46:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d4a:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2d4c:	69 91       	ld	r22, Y+
    2d4e:	c7 01       	movw	r24, r14
    2d50:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d54:	dc 01       	movw	r26, r24
    2d56:	ed 91       	ld	r30, X+
    2d58:	fc 91       	ld	r31, X
    2d5a:	02 80       	ldd	r0, Z+2	; 0x02
    2d5c:	f3 81       	ldd	r31, Z+3	; 0x03
    2d5e:	e0 2d       	mov	r30, r0
    2d60:	60 e2       	ldi	r22, 0x20	; 32
    2d62:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2d64:	cc 16       	cp	r12, r28
    2d66:	dd 06       	cpc	r13, r29
    2d68:	09 f7       	brne	.-62     	; 0x2d2c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2d6a:	11 23       	and	r17, r17
    2d6c:	89 f0       	breq	.+34     	; 0x2d90 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2d6e:	6a e0       	ldi	r22, 0x0A	; 10
    2d70:	c7 01       	movw	r24, r14
    2d72:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2d76:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2d78:	61 eb       	ldi	r22, 0xB1	; 177
    2d7a:	75 e0       	ldi	r23, 0x05	; 5
    2d7c:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2d80:	e8 81       	ld	r30, Y
    2d82:	f9 81       	ldd	r31, Y+1	; 0x01
    2d84:	02 80       	ldd	r0, Z+2	; 0x02
    2d86:	f3 81       	ldd	r31, Z+3	; 0x03
    2d88:	e0 2d       	mov	r30, r0
    2d8a:	60 e2       	ldi	r22, 0x20	; 32
    2d8c:	ce 01       	movw	r24, r28
    2d8e:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2d90:	c6 2d       	mov	r28, r6
    2d92:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2d94:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2d96:	80 ee       	ldi	r24, 0xE0	; 224
    2d98:	86 0f       	add	r24, r22
    2d9a:	8f 35       	cpi	r24, 0x5F	; 95
    2d9c:	48 f4       	brcc	.+18     	; 0x2db0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2d9e:	d7 01       	movw	r26, r14
    2da0:	ed 91       	ld	r30, X+
    2da2:	fc 91       	ld	r31, X
    2da4:	02 80       	ldd	r0, Z+2	; 0x02
    2da6:	f3 81       	ldd	r31, Z+3	; 0x03
    2da8:	e0 2d       	mov	r30, r0
    2daa:	c7 01       	movw	r24, r14
    2dac:	19 95       	eicall
    2dae:	09 c0       	rjmp	.+18     	; 0x2dc2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2db0:	d7 01       	movw	r26, r14
    2db2:	ed 91       	ld	r30, X+
    2db4:	fc 91       	ld	r31, X
    2db6:	02 80       	ldd	r0, Z+2	; 0x02
    2db8:	f3 81       	ldd	r31, Z+3	; 0x03
    2dba:	e0 2d       	mov	r30, r0
    2dbc:	6e e2       	ldi	r22, 0x2E	; 46
    2dbe:	c7 01       	movw	r24, r14
    2dc0:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2dc2:	cc 16       	cp	r12, r28
    2dc4:	dd 06       	cpc	r13, r29
    2dc6:	31 f7       	brne	.-52     	; 0x2d94 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2dc8:	b4 e1       	ldi	r27, 0x14	; 20
    2dca:	ab 0e       	add	r10, r27
    2dcc:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2dce:	66 e0       	ldi	r22, 0x06	; 6
    2dd0:	c7 01       	movw	r24, r14
    2dd2:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    2dd6:	84 e1       	ldi	r24, 0x14	; 20
    2dd8:	c8 0e       	add	r12, r24
    2dda:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2ddc:	a8 14       	cp	r10, r8
    2dde:	b9 04       	cpc	r11, r9
    2de0:	08 f4       	brcc	.+2      	; 0x2de4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2de2:	88 cf       	rjmp	.-240    	; 0x2cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2de4:	62 e0       	ldi	r22, 0x02	; 2
    2de6:	c7 01       	movw	r24, r14
    2de8:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
}
    2dec:	03 c0       	rjmp	.+6      	; 0x2df4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2dee:	c6 2d       	mov	r28, r6
    2df0:	d5 2d       	mov	r29, r5
    2df2:	9c cf       	rjmp	.-200    	; 0x2d2c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2df4:	df 91       	pop	r29
    2df6:	cf 91       	pop	r28
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	ff 90       	pop	r15
    2dfe:	ef 90       	pop	r14
    2e00:	df 90       	pop	r13
    2e02:	cf 90       	pop	r12
    2e04:	bf 90       	pop	r11
    2e06:	af 90       	pop	r10
    2e08:	9f 90       	pop	r9
    2e0a:	8f 90       	pop	r8
    2e0c:	7f 90       	pop	r7
    2e0e:	6f 90       	pop	r6
    2e10:	5f 90       	pop	r5
    2e12:	08 95       	ret

00002e14 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2e14:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    2e18:	08 95       	ret

00002e1a <_Znaj>:
    2e1a:	0e 94 4c 07 	call	0xe98	; 0xe98 <pvPortMalloc>
    2e1e:	08 95       	ret

00002e20 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2e20:	08 95       	ret

00002e22 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2e22:	cf 93       	push	r28
    2e24:	df 93       	push	r29
    2e26:	fc 01       	movw	r30, r24
    2e28:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2e2a:	40 3a       	cpi	r20, 0xA0	; 160
    2e2c:	68 e0       	ldi	r22, 0x08	; 8
    2e2e:	56 07       	cpc	r21, r22
    2e30:	49 f4       	brne	.+18     	; 0x2e44 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2e32:	80 e4       	ldi	r24, 0x40	; 64
    2e34:	96 e0       	ldi	r25, 0x06	; 6
    2e36:	82 83       	std	Z+2, r24	; 0x02
    2e38:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e3a:	82 e0       	ldi	r24, 0x02	; 2
    2e3c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e3e:	83 e0       	ldi	r24, 0x03	; 3
    2e40:	85 83       	std	Z+5, r24	; 0x05
    2e42:	32 c0       	rjmp	.+100    	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2e44:	40 3b       	cpi	r20, 0xB0	; 176
    2e46:	78 e0       	ldi	r23, 0x08	; 8
    2e48:	57 07       	cpc	r21, r23
    2e4a:	49 f4       	brne	.+18     	; 0x2e5e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2e4c:	80 e4       	ldi	r24, 0x40	; 64
    2e4e:	96 e0       	ldi	r25, 0x06	; 6
    2e50:	82 83       	std	Z+2, r24	; 0x02
    2e52:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e54:	86 e0       	ldi	r24, 0x06	; 6
    2e56:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e58:	87 e0       	ldi	r24, 0x07	; 7
    2e5a:	85 83       	std	Z+5, r24	; 0x05
    2e5c:	25 c0       	rjmp	.+74     	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2e5e:	40 3a       	cpi	r20, 0xA0	; 160
    2e60:	89 e0       	ldi	r24, 0x09	; 9
    2e62:	58 07       	cpc	r21, r24
    2e64:	49 f4       	brne	.+18     	; 0x2e78 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2e66:	80 e6       	ldi	r24, 0x60	; 96
    2e68:	96 e0       	ldi	r25, 0x06	; 6
    2e6a:	82 83       	std	Z+2, r24	; 0x02
    2e6c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e6e:	82 e0       	ldi	r24, 0x02	; 2
    2e70:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e72:	83 e0       	ldi	r24, 0x03	; 3
    2e74:	85 83       	std	Z+5, r24	; 0x05
    2e76:	18 c0       	rjmp	.+48     	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2e78:	40 3b       	cpi	r20, 0xB0	; 176
    2e7a:	69 e0       	ldi	r22, 0x09	; 9
    2e7c:	56 07       	cpc	r21, r22
    2e7e:	49 f4       	brne	.+18     	; 0x2e92 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2e80:	80 e6       	ldi	r24, 0x60	; 96
    2e82:	96 e0       	ldi	r25, 0x06	; 6
    2e84:	82 83       	std	Z+2, r24	; 0x02
    2e86:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2e88:	86 e0       	ldi	r24, 0x06	; 6
    2e8a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2e8c:	87 e0       	ldi	r24, 0x07	; 7
    2e8e:	85 83       	std	Z+5, r24	; 0x05
    2e90:	0b c0       	rjmp	.+22     	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2e92:	40 3a       	cpi	r20, 0xA0	; 160
    2e94:	5a 40       	sbci	r21, 0x0A	; 10
    2e96:	41 f4       	brne	.+16     	; 0x2ea8 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    2e98:	80 e8       	ldi	r24, 0x80	; 128
    2e9a:	96 e0       	ldi	r25, 0x06	; 6
    2e9c:	82 83       	std	Z+2, r24	; 0x02
    2e9e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2ea0:	82 e0       	ldi	r24, 0x02	; 2
    2ea2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ea4:	83 e0       	ldi	r24, 0x03	; 3
    2ea6:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2ea8:	a6 83       	std	Z+6, r26	; 0x06
    2eaa:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2eac:	cd 01       	movw	r24, r26
    2eae:	01 96       	adiw	r24, 0x01	; 1
    2eb0:	80 87       	std	Z+8, r24	; 0x08
    2eb2:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2eb4:	03 96       	adiw	r24, 0x03	; 3
    2eb6:	82 87       	std	Z+10, r24	; 0x0a
    2eb8:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2eba:	25 81       	ldd	r18, Z+5	; 0x05
    2ebc:	c2 81       	ldd	r28, Z+2	; 0x02
    2ebe:	d3 81       	ldd	r29, Z+3	; 0x03
    2ec0:	4c 81       	ldd	r20, Y+4	; 0x04
    2ec2:	81 e0       	ldi	r24, 0x01	; 1
    2ec4:	90 e0       	ldi	r25, 0x00	; 0
    2ec6:	bc 01       	movw	r22, r24
    2ec8:	02 c0       	rjmp	.+4      	; 0x2ece <_ZN7base232C1EjP12USART_struct+0xac>
    2eca:	66 0f       	add	r22, r22
    2ecc:	77 1f       	adc	r23, r23
    2ece:	2a 95       	dec	r18
    2ed0:	e2 f7       	brpl	.-8      	; 0x2eca <_ZN7base232C1EjP12USART_struct+0xa8>
    2ed2:	9b 01       	movw	r18, r22
    2ed4:	24 2b       	or	r18, r20
    2ed6:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2ed8:	25 81       	ldd	r18, Z+5	; 0x05
    2eda:	c2 81       	ldd	r28, Z+2	; 0x02
    2edc:	d3 81       	ldd	r29, Z+3	; 0x03
    2ede:	48 81       	ld	r20, Y
    2ee0:	bc 01       	movw	r22, r24
    2ee2:	02 c0       	rjmp	.+4      	; 0x2ee8 <_ZN7base232C1EjP12USART_struct+0xc6>
    2ee4:	66 0f       	add	r22, r22
    2ee6:	77 1f       	adc	r23, r23
    2ee8:	2a 95       	dec	r18
    2eea:	e2 f7       	brpl	.-8      	; 0x2ee4 <_ZN7base232C1EjP12USART_struct+0xc2>
    2eec:	9b 01       	movw	r18, r22
    2eee:	24 2b       	or	r18, r20
    2ef0:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2ef2:	34 81       	ldd	r19, Z+4	; 0x04
    2ef4:	c2 81       	ldd	r28, Z+2	; 0x02
    2ef6:	d3 81       	ldd	r29, Z+3	; 0x03
    2ef8:	28 81       	ld	r18, Y
    2efa:	02 c0       	rjmp	.+4      	; 0x2f00 <_ZN7base232C1EjP12USART_struct+0xde>
    2efc:	88 0f       	add	r24, r24
    2efe:	99 1f       	adc	r25, r25
    2f00:	3a 95       	dec	r19
    2f02:	e2 f7       	brpl	.-8      	; 0x2efc <_ZN7base232C1EjP12USART_struct+0xda>
    2f04:	80 95       	com	r24
    2f06:	90 95       	com	r25
    2f08:	82 23       	and	r24, r18
    2f0a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2f0c:	80 e1       	ldi	r24, 0x10	; 16
    2f0e:	13 96       	adiw	r26, 0x03	; 3
    2f10:	8c 93       	st	X, r24
    2f12:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2f14:	83 e0       	ldi	r24, 0x03	; 3
    2f16:	15 96       	adiw	r26, 0x05	; 5
    2f18:	8c 93       	st	X, r24
    2f1a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2f1c:	80 ef       	ldi	r24, 0xF0	; 240
    2f1e:	17 96       	adiw	r26, 0x07	; 7
    2f20:	8c 93       	st	X, r24
    2f22:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2f24:	81 e2       	ldi	r24, 0x21	; 33
    2f26:	16 96       	adiw	r26, 0x06	; 6
    2f28:	8c 93       	st	X, r24
    2f2a:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2f2c:	88 e1       	ldi	r24, 0x18	; 24
    2f2e:	14 96       	adiw	r26, 0x04	; 4
    2f30:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2f32:	80 e8       	ldi	r24, 0x80	; 128
    2f34:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2f36:	80 e4       	ldi	r24, 0x40	; 64
    2f38:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2f3a:	80 e2       	ldi	r24, 0x20	; 32
    2f3c:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2f3e:	06 80       	ldd	r0, Z+6	; 0x06
    2f40:	f7 81       	ldd	r31, Z+7	; 0x07
    2f42:	e0 2d       	mov	r30, r0
    2f44:	80 81       	ld	r24, Z
    2f46:	80 81       	ld	r24, Z
}
    2f48:	df 91       	pop	r29
    2f4a:	cf 91       	pop	r28
    2f4c:	08 95       	ret

00002f4e <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2f4e:	81 e0       	ldi	r24, 0x01	; 1
    2f50:	08 95       	ret

00002f52 <_ZN8emstream7getcharEv>:
    2f52:	80 e0       	ldi	r24, 0x00	; 0
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	08 95       	ret

00002f58 <_ZN8emstream14check_for_charEv>:
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	08 95       	ret

00002f5c <_ZN8emstream12transmit_nowEv>:
    2f5c:	08 95       	ret

00002f5e <_ZN8emstream12clear_screenEv>:
    2f5e:	08 95       	ret

00002f60 <_ZN8emstreamC1Ev>:
    2f60:	fc 01       	movw	r30, r24
    2f62:	87 e3       	ldi	r24, 0x37	; 55
    2f64:	90 e2       	ldi	r25, 0x20	; 32
    2f66:	80 83       	st	Z, r24
    2f68:	91 83       	std	Z+1, r25	; 0x01
    2f6a:	8a e0       	ldi	r24, 0x0A	; 10
    2f6c:	82 83       	std	Z+2, r24	; 0x02
    2f6e:	13 82       	std	Z+3, r1	; 0x03
    2f70:	83 e0       	ldi	r24, 0x03	; 3
    2f72:	85 83       	std	Z+5, r24	; 0x05
    2f74:	14 82       	std	Z+4, r1	; 0x04
    2f76:	16 82       	std	Z+6, r1	; 0x06
    2f78:	17 82       	std	Z+7, r1	; 0x07
    2f7a:	08 95       	ret

00002f7c <_ZN8emstream4putsEPKc>:
    2f7c:	0f 93       	push	r16
    2f7e:	1f 93       	push	r17
    2f80:	cf 93       	push	r28
    2f82:	df 93       	push	r29
    2f84:	8c 01       	movw	r16, r24
    2f86:	fb 01       	movw	r30, r22
    2f88:	dc 01       	movw	r26, r24
    2f8a:	14 96       	adiw	r26, 0x04	; 4
    2f8c:	8c 91       	ld	r24, X
    2f8e:	81 11       	cpse	r24, r1
    2f90:	04 c0       	rjmp	.+8      	; 0x2f9a <_ZN8emstream4putsEPKc+0x1e>
    2f92:	60 81       	ld	r22, Z
    2f94:	61 11       	cpse	r22, r1
    2f96:	17 c0       	rjmp	.+46     	; 0x2fc6 <_ZN8emstream4putsEPKc+0x4a>
    2f98:	23 c0       	rjmp	.+70     	; 0x2fe0 <_ZN8emstream4putsEPKc+0x64>
    2f9a:	d8 01       	movw	r26, r16
    2f9c:	14 96       	adiw	r26, 0x04	; 4
    2f9e:	1c 92       	st	X, r1
    2fa0:	eb 01       	movw	r28, r22
    2fa2:	21 96       	adiw	r28, 0x01	; 1
    2fa4:	64 91       	lpm	r22, Z
    2fa6:	66 23       	and	r22, r22
    2fa8:	d9 f0       	breq	.+54     	; 0x2fe0 <_ZN8emstream4putsEPKc+0x64>
    2faa:	d8 01       	movw	r26, r16
    2fac:	ed 91       	ld	r30, X+
    2fae:	fc 91       	ld	r31, X
    2fb0:	02 80       	ldd	r0, Z+2	; 0x02
    2fb2:	f3 81       	ldd	r31, Z+3	; 0x03
    2fb4:	e0 2d       	mov	r30, r0
    2fb6:	c8 01       	movw	r24, r16
    2fb8:	19 95       	eicall
    2fba:	fe 01       	movw	r30, r28
    2fbc:	64 91       	lpm	r22, Z
    2fbe:	21 96       	adiw	r28, 0x01	; 1
    2fc0:	61 11       	cpse	r22, r1
    2fc2:	f3 cf       	rjmp	.-26     	; 0x2faa <_ZN8emstream4putsEPKc+0x2e>
    2fc4:	0d c0       	rjmp	.+26     	; 0x2fe0 <_ZN8emstream4putsEPKc+0x64>
    2fc6:	ef 01       	movw	r28, r30
    2fc8:	21 96       	adiw	r28, 0x01	; 1
    2fca:	d8 01       	movw	r26, r16
    2fcc:	ed 91       	ld	r30, X+
    2fce:	fc 91       	ld	r31, X
    2fd0:	02 80       	ldd	r0, Z+2	; 0x02
    2fd2:	f3 81       	ldd	r31, Z+3	; 0x03
    2fd4:	e0 2d       	mov	r30, r0
    2fd6:	c8 01       	movw	r24, r16
    2fd8:	19 95       	eicall
    2fda:	69 91       	ld	r22, Y+
    2fdc:	61 11       	cpse	r22, r1
    2fde:	f5 cf       	rjmp	.-22     	; 0x2fca <_ZN8emstream4putsEPKc+0x4e>
    2fe0:	df 91       	pop	r29
    2fe2:	cf 91       	pop	r28
    2fe4:	1f 91       	pop	r17
    2fe6:	0f 91       	pop	r16
    2fe8:	08 95       	ret

00002fea <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2fea:	cf 93       	push	r28
    2fec:	df 93       	push	r29
    2fee:	ec 01       	movw	r28, r24
	switch (new_manip)
    2ff0:	86 2f       	mov	r24, r22
    2ff2:	90 e0       	ldi	r25, 0x00	; 0
    2ff4:	8b 30       	cpi	r24, 0x0B	; 11
    2ff6:	91 05       	cpc	r25, r1
    2ff8:	d8 f5       	brcc	.+118    	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
    2ffa:	fc 01       	movw	r30, r24
    2ffc:	88 27       	eor	r24, r24
    2ffe:	e2 50       	subi	r30, 0x02	; 2
    3000:	ff 4f       	sbci	r31, 0xFF	; 255
    3002:	8f 4f       	sbci	r24, 0xFF	; 255
    3004:	0c 94 59 1f 	jmp	0x3eb2	; 0x3eb2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3008:	82 e0       	ldi	r24, 0x02	; 2
    300a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    300c:	31 c0       	rjmp	.+98     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    300e:	88 e0       	ldi	r24, 0x08	; 8
    3010:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3012:	2e c0       	rjmp	.+92     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3014:	8a e0       	ldi	r24, 0x0A	; 10
    3016:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3018:	2b c0       	rjmp	.+86     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    301a:	80 e1       	ldi	r24, 0x10	; 16
    301c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    301e:	28 c0       	rjmp	.+80     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3020:	81 e0       	ldi	r24, 0x01	; 1
    3022:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3024:	25 c0       	rjmp	.+74     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3026:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3028:	23 c0       	rjmp	.+70     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    302a:	e8 81       	ld	r30, Y
    302c:	f9 81       	ldd	r31, Y+1	; 0x01
    302e:	02 80       	ldd	r0, Z+2	; 0x02
    3030:	f3 81       	ldd	r31, Z+3	; 0x03
    3032:	e0 2d       	mov	r30, r0
    3034:	6d e0       	ldi	r22, 0x0D	; 13
    3036:	ce 01       	movw	r24, r28
    3038:	19 95       	eicall
    303a:	e8 81       	ld	r30, Y
    303c:	f9 81       	ldd	r31, Y+1	; 0x01
    303e:	02 80       	ldd	r0, Z+2	; 0x02
    3040:	f3 81       	ldd	r31, Z+3	; 0x03
    3042:	e0 2d       	mov	r30, r0
    3044:	6a e0       	ldi	r22, 0x0A	; 10
    3046:	ce 01       	movw	r24, r28
    3048:	19 95       	eicall
			break;
    304a:	12 c0       	rjmp	.+36     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    304c:	e8 81       	ld	r30, Y
    304e:	f9 81       	ldd	r31, Y+1	; 0x01
    3050:	02 84       	ldd	r0, Z+10	; 0x0a
    3052:	f3 85       	ldd	r31, Z+11	; 0x0b
    3054:	e0 2d       	mov	r30, r0
    3056:	ce 01       	movw	r24, r28
    3058:	19 95       	eicall
			break;
    305a:	0a c0       	rjmp	.+20     	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    305c:	e8 81       	ld	r30, Y
    305e:	f9 81       	ldd	r31, Y+1	; 0x01
    3060:	00 84       	ldd	r0, Z+8	; 0x08
    3062:	f1 85       	ldd	r31, Z+9	; 0x09
    3064:	e0 2d       	mov	r30, r0
    3066:	ce 01       	movw	r24, r28
    3068:	19 95       	eicall
			break;
    306a:	02 c0       	rjmp	.+4      	; 0x3070 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3070:	ce 01       	movw	r24, r28
    3072:	df 91       	pop	r29
    3074:	cf 91       	pop	r28
    3076:	08 95       	ret

00003078 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3078:	ff 92       	push	r15
    307a:	0f 93       	push	r16
    307c:	1f 93       	push	r17
    307e:	cf 93       	push	r28
    3080:	df 93       	push	r29
    3082:	cd b7       	in	r28, 0x3d	; 61
    3084:	de b7       	in	r29, 0x3e	; 62
    3086:	61 97       	sbiw	r28, 0x11	; 17
    3088:	cd bf       	out	0x3d, r28	; 61
    308a:	de bf       	out	0x3e, r29	; 62
    308c:	8c 01       	movw	r16, r24
    308e:	f6 2e       	mov	r15, r22
    3090:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3092:	f8 01       	movw	r30, r16
    3094:	42 81       	ldd	r20, Z+2	; 0x02
    3096:	40 31       	cpi	r20, 0x10	; 16
    3098:	21 f0       	breq	.+8      	; 0x30a2 <_ZN8emstreamlsEj+0x2a>
    309a:	48 30       	cpi	r20, 0x08	; 8
    309c:	11 f0       	breq	.+4      	; 0x30a2 <_ZN8emstreamlsEj+0x2a>
    309e:	42 30       	cpi	r20, 0x02	; 2
    30a0:	41 f4       	brne	.+16     	; 0x30b2 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    30a2:	69 2f       	mov	r22, r25
    30a4:	c8 01       	movw	r24, r16
    30a6:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    30aa:	6f 2d       	mov	r22, r15
    30ac:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    30b0:	0d c0       	rjmp	.+26     	; 0x30cc <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    30b2:	50 e0       	ldi	r21, 0x00	; 0
    30b4:	be 01       	movw	r22, r28
    30b6:	6f 5f       	subi	r22, 0xFF	; 255
    30b8:	7f 4f       	sbci	r23, 0xFF	; 255
    30ba:	8f 2d       	mov	r24, r15
    30bc:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    30c0:	be 01       	movw	r22, r28
    30c2:	6f 5f       	subi	r22, 0xFF	; 255
    30c4:	7f 4f       	sbci	r23, 0xFF	; 255
    30c6:	c8 01       	movw	r24, r16
    30c8:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30cc:	c8 01       	movw	r24, r16
    30ce:	61 96       	adiw	r28, 0x11	; 17
    30d0:	cd bf       	out	0x3d, r28	; 61
    30d2:	de bf       	out	0x3e, r29	; 62
    30d4:	df 91       	pop	r29
    30d6:	cf 91       	pop	r28
    30d8:	1f 91       	pop	r17
    30da:	0f 91       	pop	r16
    30dc:	ff 90       	pop	r15
    30de:	08 95       	ret

000030e0 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    30e0:	df 92       	push	r13
    30e2:	ef 92       	push	r14
    30e4:	ff 92       	push	r15
    30e6:	0f 93       	push	r16
    30e8:	1f 93       	push	r17
    30ea:	cf 93       	push	r28
    30ec:	df 93       	push	r29
    30ee:	cd b7       	in	r28, 0x3d	; 61
    30f0:	de b7       	in	r29, 0x3e	; 62
    30f2:	a1 97       	sbiw	r28, 0x21	; 33
    30f4:	cd bf       	out	0x3d, r28	; 61
    30f6:	de bf       	out	0x3e, r29	; 62
    30f8:	8c 01       	movw	r16, r24
    30fa:	d4 2e       	mov	r13, r20
    30fc:	e5 2e       	mov	r14, r21
    30fe:	f6 2e       	mov	r15, r22
    3100:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3102:	f8 01       	movw	r30, r16
    3104:	22 81       	ldd	r18, Z+2	; 0x02
    3106:	20 31       	cpi	r18, 0x10	; 16
    3108:	21 f0       	breq	.+8      	; 0x3112 <_ZN8emstreamlsEm+0x32>
    310a:	28 30       	cpi	r18, 0x08	; 8
    310c:	11 f0       	breq	.+4      	; 0x3112 <_ZN8emstreamlsEm+0x32>
    310e:	22 30       	cpi	r18, 0x02	; 2
    3110:	71 f4       	brne	.+28     	; 0x312e <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3112:	69 2f       	mov	r22, r25
    3114:	c8 01       	movw	r24, r16
    3116:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    311a:	6f 2d       	mov	r22, r15
    311c:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    3120:	6e 2d       	mov	r22, r14
    3122:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    3126:	6d 2d       	mov	r22, r13
    3128:	0e 94 b2 18 	call	0x3164	; 0x3164 <_ZN8emstreamlsEh>
    312c:	0f c0       	rjmp	.+30     	; 0x314c <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    312e:	30 e0       	ldi	r19, 0x00	; 0
    3130:	ae 01       	movw	r20, r28
    3132:	4f 5f       	subi	r20, 0xFF	; 255
    3134:	5f 4f       	sbci	r21, 0xFF	; 255
    3136:	6d 2d       	mov	r22, r13
    3138:	7e 2d       	mov	r23, r14
    313a:	8f 2d       	mov	r24, r15
    313c:	0e 94 9b 1f 	call	0x3f36	; 0x3f36 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3140:	be 01       	movw	r22, r28
    3142:	6f 5f       	subi	r22, 0xFF	; 255
    3144:	7f 4f       	sbci	r23, 0xFF	; 255
    3146:	c8 01       	movw	r24, r16
    3148:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    314c:	c8 01       	movw	r24, r16
    314e:	a1 96       	adiw	r28, 0x21	; 33
    3150:	cd bf       	out	0x3d, r28	; 61
    3152:	de bf       	out	0x3e, r29	; 62
    3154:	df 91       	pop	r29
    3156:	cf 91       	pop	r28
    3158:	1f 91       	pop	r17
    315a:	0f 91       	pop	r16
    315c:	ff 90       	pop	r15
    315e:	ef 90       	pop	r14
    3160:	df 90       	pop	r13
    3162:	08 95       	ret

00003164 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3164:	cf 92       	push	r12
    3166:	df 92       	push	r13
    3168:	ef 92       	push	r14
    316a:	ff 92       	push	r15
    316c:	0f 93       	push	r16
    316e:	1f 93       	push	r17
    3170:	cf 93       	push	r28
    3172:	df 93       	push	r29
    3174:	cd b7       	in	r28, 0x3d	; 61
    3176:	de b7       	in	r29, 0x3e	; 62
    3178:	29 97       	sbiw	r28, 0x09	; 9
    317a:	cd bf       	out	0x3d, r28	; 61
    317c:	de bf       	out	0x3e, r29	; 62
    317e:	8c 01       	movw	r16, r24
    3180:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3182:	dc 01       	movw	r26, r24
    3184:	13 96       	adiw	r26, 0x03	; 3
    3186:	8c 91       	ld	r24, X
    3188:	13 97       	sbiw	r26, 0x03	; 3
    318a:	88 23       	and	r24, r24
    318c:	41 f0       	breq	.+16     	; 0x319e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    318e:	ed 91       	ld	r30, X+
    3190:	fc 91       	ld	r31, X
    3192:	02 80       	ldd	r0, Z+2	; 0x02
    3194:	f3 81       	ldd	r31, Z+3	; 0x03
    3196:	e0 2d       	mov	r30, r0
    3198:	c8 01       	movw	r24, r16
    319a:	19 95       	eicall
    319c:	56 c0       	rjmp	.+172    	; 0x324a <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    319e:	f8 01       	movw	r30, r16
    31a0:	42 81       	ldd	r20, Z+2	; 0x02
    31a2:	42 30       	cpi	r20, 0x02	; 2
    31a4:	19 f5       	brne	.+70     	; 0x31ec <_ZN8emstreamlsEh+0x88>
    31a6:	68 94       	set
    31a8:	cc 24       	eor	r12, r12
    31aa:	c3 f8       	bld	r12, 3
    31ac:	d1 2c       	mov	r13, r1
    31ae:	68 94       	set
    31b0:	ff 24       	eor	r15, r15
    31b2:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    31b4:	8e 2d       	mov	r24, r14
    31b6:	8f 21       	and	r24, r15
    31b8:	51 f0       	breq	.+20     	; 0x31ce <_ZN8emstreamlsEh+0x6a>
    31ba:	d8 01       	movw	r26, r16
    31bc:	ed 91       	ld	r30, X+
    31be:	fc 91       	ld	r31, X
    31c0:	02 80       	ldd	r0, Z+2	; 0x02
    31c2:	f3 81       	ldd	r31, Z+3	; 0x03
    31c4:	e0 2d       	mov	r30, r0
    31c6:	61 e3       	ldi	r22, 0x31	; 49
    31c8:	c8 01       	movw	r24, r16
    31ca:	19 95       	eicall
    31cc:	09 c0       	rjmp	.+18     	; 0x31e0 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    31ce:	d8 01       	movw	r26, r16
    31d0:	ed 91       	ld	r30, X+
    31d2:	fc 91       	ld	r31, X
    31d4:	02 80       	ldd	r0, Z+2	; 0x02
    31d6:	f3 81       	ldd	r31, Z+3	; 0x03
    31d8:	e0 2d       	mov	r30, r0
    31da:	60 e3       	ldi	r22, 0x30	; 48
    31dc:	c8 01       	movw	r24, r16
    31de:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    31e0:	f6 94       	lsr	r15
    31e2:	b1 e0       	ldi	r27, 0x01	; 1
    31e4:	cb 1a       	sub	r12, r27
    31e6:	d1 08       	sbc	r13, r1
    31e8:	29 f7       	brne	.-54     	; 0x31b4 <_ZN8emstreamlsEh+0x50>
    31ea:	2f c0       	rjmp	.+94     	; 0x324a <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    31ec:	40 31       	cpi	r20, 0x10	; 16
    31ee:	f9 f4       	brne	.+62     	; 0x322e <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    31f0:	62 95       	swap	r22
    31f2:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    31f4:	01 90       	ld	r0, Z+
    31f6:	f0 81       	ld	r31, Z
    31f8:	e0 2d       	mov	r30, r0
    31fa:	02 80       	ldd	r0, Z+2	; 0x02
    31fc:	f3 81       	ldd	r31, Z+3	; 0x03
    31fe:	e0 2d       	mov	r30, r0
    3200:	6a 30       	cpi	r22, 0x0A	; 10
    3202:	10 f0       	brcs	.+4      	; 0x3208 <_ZN8emstreamlsEh+0xa4>
    3204:	69 5c       	subi	r22, 0xC9	; 201
    3206:	01 c0       	rjmp	.+2      	; 0x320a <_ZN8emstreamlsEh+0xa6>
    3208:	60 5d       	subi	r22, 0xD0	; 208
    320a:	c8 01       	movw	r24, r16
    320c:	19 95       	eicall
		temp_char = num & 0x0F;
    320e:	6e 2d       	mov	r22, r14
    3210:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3212:	d8 01       	movw	r26, r16
    3214:	ed 91       	ld	r30, X+
    3216:	fc 91       	ld	r31, X
    3218:	02 80       	ldd	r0, Z+2	; 0x02
    321a:	f3 81       	ldd	r31, Z+3	; 0x03
    321c:	e0 2d       	mov	r30, r0
    321e:	6a 30       	cpi	r22, 0x0A	; 10
    3220:	10 f0       	brcs	.+4      	; 0x3226 <_ZN8emstreamlsEh+0xc2>
    3222:	69 5c       	subi	r22, 0xC9	; 201
    3224:	01 c0       	rjmp	.+2      	; 0x3228 <_ZN8emstreamlsEh+0xc4>
    3226:	60 5d       	subi	r22, 0xD0	; 208
    3228:	c8 01       	movw	r24, r16
    322a:	19 95       	eicall
    322c:	0e c0       	rjmp	.+28     	; 0x324a <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    322e:	50 e0       	ldi	r21, 0x00	; 0
    3230:	be 01       	movw	r22, r28
    3232:	6f 5f       	subi	r22, 0xFF	; 255
    3234:	7f 4f       	sbci	r23, 0xFF	; 255
    3236:	8e 2d       	mov	r24, r14
    3238:	90 e0       	ldi	r25, 0x00	; 0
    323a:	0e 94 c8 1f 	call	0x3f90	; 0x3f90 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    323e:	be 01       	movw	r22, r28
    3240:	6f 5f       	subi	r22, 0xFF	; 255
    3242:	7f 4f       	sbci	r23, 0xFF	; 255
    3244:	c8 01       	movw	r24, r16
    3246:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    324a:	c8 01       	movw	r24, r16
    324c:	29 96       	adiw	r28, 0x09	; 9
    324e:	cd bf       	out	0x3d, r28	; 61
    3250:	de bf       	out	0x3e, r29	; 62
    3252:	df 91       	pop	r29
    3254:	cf 91       	pop	r28
    3256:	1f 91       	pop	r17
    3258:	0f 91       	pop	r16
    325a:	ff 90       	pop	r15
    325c:	ef 90       	pop	r14
    325e:	df 90       	pop	r13
    3260:	cf 90       	pop	r12
    3262:	08 95       	ret

00003264 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3264:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3266:	50 96       	adiw	r26, 0x10	; 16
    3268:	ed 91       	ld	r30, X+
    326a:	fc 91       	ld	r31, X
    326c:	51 97       	sbiw	r26, 0x11	; 17
    326e:	80 81       	ld	r24, Z
    3270:	54 96       	adiw	r26, 0x14	; 20
    3272:	4c 91       	ld	r20, X
    3274:	54 97       	sbiw	r26, 0x14	; 20
    3276:	84 23       	and	r24, r20
    3278:	29 f0       	breq	.+10     	; 0x3284 <_ZN5rs2327putcharEc+0x20>
    327a:	09 c0       	rjmp	.+18     	; 0x328e <_ZN5rs2327putcharEc+0x2a>
    327c:	21 50       	subi	r18, 0x01	; 1
    327e:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3280:	19 f4       	brne	.+6      	; 0x3288 <_ZN5rs2327putcharEc+0x24>
    3282:	12 c0       	rjmp	.+36     	; 0x32a8 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3284:	21 e2       	ldi	r18, 0x21	; 33
    3286:	3e e4       	ldi	r19, 0x4E	; 78
    3288:	90 81       	ld	r25, Z
    328a:	94 23       	and	r25, r20
    328c:	b9 f3       	breq	.-18     	; 0x327c <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    328e:	90 81       	ld	r25, Z
    3290:	56 96       	adiw	r26, 0x16	; 22
    3292:	8c 91       	ld	r24, X
    3294:	56 97       	sbiw	r26, 0x16	; 22
    3296:	89 2b       	or	r24, r25
    3298:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    329a:	1e 96       	adiw	r26, 0x0e	; 14
    329c:	ed 91       	ld	r30, X+
    329e:	fc 91       	ld	r31, X
    32a0:	1f 97       	sbiw	r26, 0x0f	; 15
    32a2:	60 83       	st	Z, r22
	return (true);
    32a4:	81 e0       	ldi	r24, 0x01	; 1
    32a6:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    32a8:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    32aa:	08 95       	ret

000032ac <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    32b2:	c1 8d       	ldd	r28, Z+25	; 0x19
    32b4:	d2 8d       	ldd	r29, Z+26	; 0x1a
    32b6:	28 81       	ld	r18, Y
    32b8:	39 81       	ldd	r19, Y+1	; 0x01
    32ba:	a3 8d       	ldd	r26, Z+27	; 0x1b
    32bc:	b4 8d       	ldd	r27, Z+28	; 0x1c
    32be:	4d 91       	ld	r20, X+
    32c0:	5c 91       	ld	r21, X
    32c2:	24 17       	cp	r18, r20
    32c4:	35 07       	cpc	r19, r21
    32c6:	e9 f3       	breq	.-6      	; 0x32c2 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    32c8:	a7 89       	ldd	r26, Z+23	; 0x17
    32ca:	b0 8d       	ldd	r27, Z+24	; 0x18
    32cc:	0d 90       	ld	r0, X+
    32ce:	bc 91       	ld	r27, X
    32d0:	a0 2d       	mov	r26, r0
    32d2:	a2 0f       	add	r26, r18
    32d4:	b3 1f       	adc	r27, r19
    32d6:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    32d8:	2f 5f       	subi	r18, 0xFF	; 255
    32da:	3f 4f       	sbci	r19, 0xFF	; 255
    32dc:	28 83       	st	Y, r18
    32de:	39 83       	std	Y+1, r19	; 0x01
    32e0:	24 36       	cpi	r18, 0x64	; 100
    32e2:	31 05       	cpc	r19, r1
    32e4:	28 f0       	brcs	.+10     	; 0x32f0 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    32e6:	01 8c       	ldd	r0, Z+25	; 0x19
    32e8:	f2 8d       	ldd	r31, Z+26	; 0x1a
    32ea:	e0 2d       	mov	r30, r0
    32ec:	10 82       	st	Z, r1
    32ee:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	08 95       	ret

000032f8 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    32f8:	cf 93       	push	r28
    32fa:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    32fc:	ec 01       	movw	r28, r24
    32fe:	a9 8d       	ldd	r26, Y+25	; 0x19
    3300:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3302:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3304:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3306:	81 e0       	ldi	r24, 0x01	; 1
    3308:	4d 91       	ld	r20, X+
    330a:	5c 91       	ld	r21, X
    330c:	20 81       	ld	r18, Z
    330e:	31 81       	ldd	r19, Z+1	; 0x01
    3310:	42 17       	cp	r20, r18
    3312:	53 07       	cpc	r21, r19
    3314:	09 f4       	brne	.+2      	; 0x3318 <_ZN5rs23214check_for_charEv+0x20>
    3316:	80 e0       	ldi	r24, 0x00	; 0
}
    3318:	df 91       	pop	r29
    331a:	cf 91       	pop	r28
    331c:	08 95       	ret

0000331e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    331e:	dc 01       	movw	r26, r24
    3320:	ed 91       	ld	r30, X+
    3322:	fc 91       	ld	r31, X
    3324:	02 80       	ldd	r0, Z+2	; 0x02
    3326:	f3 81       	ldd	r31, Z+3	; 0x03
    3328:	e0 2d       	mov	r30, r0
    332a:	6c e0       	ldi	r22, 0x0C	; 12
    332c:	19 95       	eicall
    332e:	08 95       	ret

00003330 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3330:	ef 92       	push	r14
    3332:	ff 92       	push	r15
    3334:	0f 93       	push	r16
    3336:	1f 93       	push	r17
    3338:	cf 93       	push	r28
    333a:	df 93       	push	r29
    333c:	ec 01       	movw	r28, r24
    333e:	7b 01       	movw	r14, r22
    3340:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3342:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <_ZN8emstreamC1Ev>
    3346:	a8 01       	movw	r20, r16
    3348:	b7 01       	movw	r22, r14
    334a:	ce 01       	movw	r24, r28
    334c:	08 96       	adiw	r24, 0x08	; 8
    334e:	0e 94 11 17 	call	0x2e22	; 0x2e22 <_ZN7base232C1EjP12USART_struct>
    3352:	87 e4       	ldi	r24, 0x47	; 71
    3354:	90 e2       	ldi	r25, 0x20	; 32
    3356:	88 83       	st	Y, r24
    3358:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    335a:	00 3a       	cpi	r16, 0xA0	; 160
    335c:	88 e0       	ldi	r24, 0x08	; 8
    335e:	18 07       	cpc	r17, r24
    3360:	69 f4       	brne	.+26     	; 0x337c <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3362:	80 e5       	ldi	r24, 0x50	; 80
    3364:	91 e3       	ldi	r25, 0x31	; 49
    3366:	8f 8b       	std	Y+23, r24	; 0x17
    3368:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    336a:	86 e4       	ldi	r24, 0x46	; 70
    336c:	91 e3       	ldi	r25, 0x31	; 49
    336e:	89 8f       	std	Y+25, r24	; 0x19
    3370:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3372:	8c e3       	ldi	r24, 0x3C	; 60
    3374:	91 e3       	ldi	r25, 0x31	; 49
    3376:	8b 8f       	std	Y+27, r24	; 0x1b
    3378:	9c 8f       	std	Y+28, r25	; 0x1c
    337a:	42 c0       	rjmp	.+132    	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    337c:	00 3b       	cpi	r16, 0xB0	; 176
    337e:	e8 e0       	ldi	r30, 0x08	; 8
    3380:	1e 07       	cpc	r17, r30
    3382:	69 f4       	brne	.+26     	; 0x339e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3384:	8e e4       	ldi	r24, 0x4E	; 78
    3386:	91 e3       	ldi	r25, 0x31	; 49
    3388:	8f 8b       	std	Y+23, r24	; 0x17
    338a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    338c:	84 e4       	ldi	r24, 0x44	; 68
    338e:	91 e3       	ldi	r25, 0x31	; 49
    3390:	89 8f       	std	Y+25, r24	; 0x19
    3392:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3394:	8a e3       	ldi	r24, 0x3A	; 58
    3396:	91 e3       	ldi	r25, 0x31	; 49
    3398:	8b 8f       	std	Y+27, r24	; 0x1b
    339a:	9c 8f       	std	Y+28, r25	; 0x1c
    339c:	31 c0       	rjmp	.+98     	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    339e:	00 3a       	cpi	r16, 0xA0	; 160
    33a0:	f9 e0       	ldi	r31, 0x09	; 9
    33a2:	1f 07       	cpc	r17, r31
    33a4:	69 f4       	brne	.+26     	; 0x33c0 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    33a6:	8c e4       	ldi	r24, 0x4C	; 76
    33a8:	91 e3       	ldi	r25, 0x31	; 49
    33aa:	8f 8b       	std	Y+23, r24	; 0x17
    33ac:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    33ae:	82 e4       	ldi	r24, 0x42	; 66
    33b0:	91 e3       	ldi	r25, 0x31	; 49
    33b2:	89 8f       	std	Y+25, r24	; 0x19
    33b4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    33b6:	88 e3       	ldi	r24, 0x38	; 56
    33b8:	91 e3       	ldi	r25, 0x31	; 49
    33ba:	8b 8f       	std	Y+27, r24	; 0x1b
    33bc:	9c 8f       	std	Y+28, r25	; 0x1c
    33be:	20 c0       	rjmp	.+64     	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    33c0:	00 3b       	cpi	r16, 0xB0	; 176
    33c2:	89 e0       	ldi	r24, 0x09	; 9
    33c4:	18 07       	cpc	r17, r24
    33c6:	69 f4       	brne	.+26     	; 0x33e2 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    33c8:	8a e4       	ldi	r24, 0x4A	; 74
    33ca:	91 e3       	ldi	r25, 0x31	; 49
    33cc:	8f 8b       	std	Y+23, r24	; 0x17
    33ce:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    33d0:	80 e4       	ldi	r24, 0x40	; 64
    33d2:	91 e3       	ldi	r25, 0x31	; 49
    33d4:	89 8f       	std	Y+25, r24	; 0x19
    33d6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    33d8:	86 e3       	ldi	r24, 0x36	; 54
    33da:	91 e3       	ldi	r25, 0x31	; 49
    33dc:	8b 8f       	std	Y+27, r24	; 0x1b
    33de:	9c 8f       	std	Y+28, r25	; 0x1c
    33e0:	0f c0       	rjmp	.+30     	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    33e2:	00 3a       	cpi	r16, 0xA0	; 160
    33e4:	1a 40       	sbci	r17, 0x0A	; 10
    33e6:	61 f4       	brne	.+24     	; 0x3400 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    33e8:	88 e4       	ldi	r24, 0x48	; 72
    33ea:	91 e3       	ldi	r25, 0x31	; 49
    33ec:	8f 8b       	std	Y+23, r24	; 0x17
    33ee:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    33f0:	8e e3       	ldi	r24, 0x3E	; 62
    33f2:	91 e3       	ldi	r25, 0x31	; 49
    33f4:	89 8f       	std	Y+25, r24	; 0x19
    33f6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    33f8:	84 e3       	ldi	r24, 0x34	; 52
    33fa:	91 e3       	ldi	r25, 0x31	; 49
    33fc:	8b 8f       	std	Y+27, r24	; 0x1b
    33fe:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3400:	0f 89       	ldd	r16, Y+23	; 0x17
    3402:	18 8d       	ldd	r17, Y+24	; 0x18
    3404:	84 e6       	ldi	r24, 0x64	; 100
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	0e 94 0d 17 	call	0x2e1a	; 0x2e1a <_Znaj>
    340c:	f8 01       	movw	r30, r16
    340e:	80 83       	st	Z, r24
    3410:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3412:	e9 8d       	ldd	r30, Y+25	; 0x19
    3414:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3416:	10 82       	st	Z, r1
    3418:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    341a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    341c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    341e:	10 82       	st	Z, r1
    3420:	11 82       	std	Z+1, r1	; 0x01
}
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	1f 91       	pop	r17
    3428:	0f 91       	pop	r16
    342a:	ff 90       	pop	r15
    342c:	ef 90       	pop	r14
    342e:	08 95       	ret

00003430 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3430:	1f 92       	push	r1
    3432:	0f 92       	push	r0
    3434:	0f b6       	in	r0, 0x3f	; 63
    3436:	0f 92       	push	r0
    3438:	11 24       	eor	r1, r1
    343a:	08 b6       	in	r0, 0x38	; 56
    343c:	0f 92       	push	r0
    343e:	18 be       	out	0x38, r1	; 56
    3440:	0b b6       	in	r0, 0x3b	; 59
    3442:	0f 92       	push	r0
    3444:	1b be       	out	0x3b, r1	; 59
    3446:	2f 93       	push	r18
    3448:	3f 93       	push	r19
    344a:	8f 93       	push	r24
    344c:	9f 93       	push	r25
    344e:	ef 93       	push	r30
    3450:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3452:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3456:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <rcvC0_buffer>
    345a:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <rcvC0_buffer+0x1>
    345e:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    3462:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    3466:	e8 0f       	add	r30, r24
    3468:	f9 1f       	adc	r31, r25
    346a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    346c:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    3470:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    3474:	01 96       	adiw	r24, 0x01	; 1
    3476:	84 36       	cpi	r24, 0x64	; 100
    3478:	91 05       	cpc	r25, r1
    347a:	60 f4       	brcc	.+24     	; 0x3494 <__vector_25+0x64>
    347c:	80 93 3c 31 	sts	0x313C, r24	; 0x80313c <rcvC0_write_index>
    3480:	90 93 3d 31 	sts	0x313D, r25	; 0x80313d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3484:	20 91 46 31 	lds	r18, 0x3146	; 0x803146 <rcvC0_read_index>
    3488:	30 91 47 31 	lds	r19, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    348c:	82 17       	cp	r24, r18
    348e:	93 07       	cpc	r25, r19
    3490:	f1 f4       	brne	.+60     	; 0x34ce <__vector_25+0x9e>
    3492:	0c c0       	rjmp	.+24     	; 0x34ac <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3494:	10 92 3c 31 	sts	0x313C, r1	; 0x80313c <rcvC0_write_index>
    3498:	10 92 3d 31 	sts	0x313D, r1	; 0x80313d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    349c:	80 91 46 31 	lds	r24, 0x3146	; 0x803146 <rcvC0_read_index>
    34a0:	90 91 47 31 	lds	r25, 0x3147	; 0x803147 <rcvC0_read_index+0x1>
    34a4:	18 16       	cp	r1, r24
    34a6:	19 06       	cpc	r1, r25
    34a8:	91 f4       	brne	.+36     	; 0x34ce <__vector_25+0x9e>
    34aa:	0e c0       	rjmp	.+28     	; 0x34c8 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    34ac:	01 96       	adiw	r24, 0x01	; 1
    34ae:	84 36       	cpi	r24, 0x64	; 100
    34b0:	91 05       	cpc	r25, r1
    34b2:	28 f4       	brcc	.+10     	; 0x34be <__vector_25+0x8e>
    34b4:	80 93 46 31 	sts	0x3146, r24	; 0x803146 <rcvC0_read_index>
    34b8:	90 93 47 31 	sts	0x3147, r25	; 0x803147 <rcvC0_read_index+0x1>
    34bc:	08 c0       	rjmp	.+16     	; 0x34ce <__vector_25+0x9e>
			rcvC0_read_index = 0;
    34be:	10 92 46 31 	sts	0x3146, r1	; 0x803146 <rcvC0_read_index>
    34c2:	10 92 47 31 	sts	0x3147, r1	; 0x803147 <rcvC0_read_index+0x1>
}
    34c6:	03 c0       	rjmp	.+6      	; 0x34ce <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    34c8:	81 e0       	ldi	r24, 0x01	; 1
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	f3 cf       	rjmp	.-26     	; 0x34b4 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    34ce:	ff 91       	pop	r31
    34d0:	ef 91       	pop	r30
    34d2:	9f 91       	pop	r25
    34d4:	8f 91       	pop	r24
    34d6:	3f 91       	pop	r19
    34d8:	2f 91       	pop	r18
    34da:	0f 90       	pop	r0
    34dc:	0b be       	out	0x3b, r0	; 59
    34de:	0f 90       	pop	r0
    34e0:	08 be       	out	0x38, r0	; 56
    34e2:	0f 90       	pop	r0
    34e4:	0f be       	out	0x3f, r0	; 63
    34e6:	0f 90       	pop	r0
    34e8:	1f 90       	pop	r1
    34ea:	18 95       	reti

000034ec <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    34ec:	1f 92       	push	r1
    34ee:	0f 92       	push	r0
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	0f 92       	push	r0
    34f4:	11 24       	eor	r1, r1
    34f6:	08 b6       	in	r0, 0x38	; 56
    34f8:	0f 92       	push	r0
    34fa:	18 be       	out	0x38, r1	; 56
    34fc:	0b b6       	in	r0, 0x3b	; 59
    34fe:	0f 92       	push	r0
    3500:	1b be       	out	0x3b, r1	; 59
    3502:	2f 93       	push	r18
    3504:	3f 93       	push	r19
    3506:	8f 93       	push	r24
    3508:	9f 93       	push	r25
    350a:	ef 93       	push	r30
    350c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    350e:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3512:	e0 91 4e 31 	lds	r30, 0x314E	; 0x80314e <rcvC1_buffer>
    3516:	f0 91 4f 31 	lds	r31, 0x314F	; 0x80314f <rcvC1_buffer+0x1>
    351a:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    351e:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3522:	e8 0f       	add	r30, r24
    3524:	f9 1f       	adc	r31, r25
    3526:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3528:	80 91 3a 31 	lds	r24, 0x313A	; 0x80313a <rcvC1_write_index>
    352c:	90 91 3b 31 	lds	r25, 0x313B	; 0x80313b <rcvC1_write_index+0x1>
    3530:	01 96       	adiw	r24, 0x01	; 1
    3532:	84 36       	cpi	r24, 0x64	; 100
    3534:	91 05       	cpc	r25, r1
    3536:	60 f4       	brcc	.+24     	; 0x3550 <__vector_28+0x64>
    3538:	80 93 3a 31 	sts	0x313A, r24	; 0x80313a <rcvC1_write_index>
    353c:	90 93 3b 31 	sts	0x313B, r25	; 0x80313b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3540:	20 91 44 31 	lds	r18, 0x3144	; 0x803144 <rcvC1_read_index>
    3544:	30 91 45 31 	lds	r19, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    3548:	82 17       	cp	r24, r18
    354a:	93 07       	cpc	r25, r19
    354c:	f1 f4       	brne	.+60     	; 0x358a <__vector_28+0x9e>
    354e:	0c c0       	rjmp	.+24     	; 0x3568 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3550:	10 92 3a 31 	sts	0x313A, r1	; 0x80313a <rcvC1_write_index>
    3554:	10 92 3b 31 	sts	0x313B, r1	; 0x80313b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3558:	80 91 44 31 	lds	r24, 0x3144	; 0x803144 <rcvC1_read_index>
    355c:	90 91 45 31 	lds	r25, 0x3145	; 0x803145 <rcvC1_read_index+0x1>
    3560:	18 16       	cp	r1, r24
    3562:	19 06       	cpc	r1, r25
    3564:	91 f4       	brne	.+36     	; 0x358a <__vector_28+0x9e>
    3566:	0e c0       	rjmp	.+28     	; 0x3584 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3568:	01 96       	adiw	r24, 0x01	; 1
    356a:	84 36       	cpi	r24, 0x64	; 100
    356c:	91 05       	cpc	r25, r1
    356e:	28 f4       	brcc	.+10     	; 0x357a <__vector_28+0x8e>
    3570:	80 93 44 31 	sts	0x3144, r24	; 0x803144 <rcvC1_read_index>
    3574:	90 93 45 31 	sts	0x3145, r25	; 0x803145 <rcvC1_read_index+0x1>
    3578:	08 c0       	rjmp	.+16     	; 0x358a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    357a:	10 92 44 31 	sts	0x3144, r1	; 0x803144 <rcvC1_read_index>
    357e:	10 92 45 31 	sts	0x3145, r1	; 0x803145 <rcvC1_read_index+0x1>
}
    3582:	03 c0       	rjmp	.+6      	; 0x358a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3584:	81 e0       	ldi	r24, 0x01	; 1
    3586:	90 e0       	ldi	r25, 0x00	; 0
    3588:	f3 cf       	rjmp	.-26     	; 0x3570 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    358a:	ff 91       	pop	r31
    358c:	ef 91       	pop	r30
    358e:	9f 91       	pop	r25
    3590:	8f 91       	pop	r24
    3592:	3f 91       	pop	r19
    3594:	2f 91       	pop	r18
    3596:	0f 90       	pop	r0
    3598:	0b be       	out	0x3b, r0	; 59
    359a:	0f 90       	pop	r0
    359c:	08 be       	out	0x38, r0	; 56
    359e:	0f 90       	pop	r0
    35a0:	0f be       	out	0x3f, r0	; 63
    35a2:	0f 90       	pop	r0
    35a4:	1f 90       	pop	r1
    35a6:	18 95       	reti

000035a8 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    35a8:	1f 92       	push	r1
    35aa:	0f 92       	push	r0
    35ac:	0f b6       	in	r0, 0x3f	; 63
    35ae:	0f 92       	push	r0
    35b0:	11 24       	eor	r1, r1
    35b2:	08 b6       	in	r0, 0x38	; 56
    35b4:	0f 92       	push	r0
    35b6:	18 be       	out	0x38, r1	; 56
    35b8:	0b b6       	in	r0, 0x3b	; 59
    35ba:	0f 92       	push	r0
    35bc:	1b be       	out	0x3b, r1	; 59
    35be:	2f 93       	push	r18
    35c0:	3f 93       	push	r19
    35c2:	8f 93       	push	r24
    35c4:	9f 93       	push	r25
    35c6:	ef 93       	push	r30
    35c8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    35ca:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    35ce:	e0 91 4c 31 	lds	r30, 0x314C	; 0x80314c <rcvD0_buffer>
    35d2:	f0 91 4d 31 	lds	r31, 0x314D	; 0x80314d <rcvD0_buffer+0x1>
    35d6:	80 91 3c 31 	lds	r24, 0x313C	; 0x80313c <rcvC0_write_index>
    35da:	90 91 3d 31 	lds	r25, 0x313D	; 0x80313d <rcvC0_write_index+0x1>
    35de:	e8 0f       	add	r30, r24
    35e0:	f9 1f       	adc	r31, r25
    35e2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    35e4:	80 91 38 31 	lds	r24, 0x3138	; 0x803138 <rcvD0_write_index>
    35e8:	90 91 39 31 	lds	r25, 0x3139	; 0x803139 <rcvD0_write_index+0x1>
    35ec:	01 96       	adiw	r24, 0x01	; 1
    35ee:	84 36       	cpi	r24, 0x64	; 100
    35f0:	91 05       	cpc	r25, r1
    35f2:	60 f4       	brcc	.+24     	; 0x360c <__vector_88+0x64>
    35f4:	80 93 38 31 	sts	0x3138, r24	; 0x803138 <rcvD0_write_index>
    35f8:	90 93 39 31 	sts	0x3139, r25	; 0x803139 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    35fc:	20 91 42 31 	lds	r18, 0x3142	; 0x803142 <rcvD0_read_index>
    3600:	30 91 43 31 	lds	r19, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    3604:	82 17       	cp	r24, r18
    3606:	93 07       	cpc	r25, r19
    3608:	f1 f4       	brne	.+60     	; 0x3646 <__vector_88+0x9e>
    360a:	0c c0       	rjmp	.+24     	; 0x3624 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    360c:	10 92 38 31 	sts	0x3138, r1	; 0x803138 <rcvD0_write_index>
    3610:	10 92 39 31 	sts	0x3139, r1	; 0x803139 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3614:	80 91 42 31 	lds	r24, 0x3142	; 0x803142 <rcvD0_read_index>
    3618:	90 91 43 31 	lds	r25, 0x3143	; 0x803143 <rcvD0_read_index+0x1>
    361c:	18 16       	cp	r1, r24
    361e:	19 06       	cpc	r1, r25
    3620:	91 f4       	brne	.+36     	; 0x3646 <__vector_88+0x9e>
    3622:	0e c0       	rjmp	.+28     	; 0x3640 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3624:	01 96       	adiw	r24, 0x01	; 1
    3626:	84 36       	cpi	r24, 0x64	; 100
    3628:	91 05       	cpc	r25, r1
    362a:	28 f4       	brcc	.+10     	; 0x3636 <__vector_88+0x8e>
    362c:	80 93 42 31 	sts	0x3142, r24	; 0x803142 <rcvD0_read_index>
    3630:	90 93 43 31 	sts	0x3143, r25	; 0x803143 <rcvD0_read_index+0x1>
    3634:	08 c0       	rjmp	.+16     	; 0x3646 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3636:	10 92 42 31 	sts	0x3142, r1	; 0x803142 <rcvD0_read_index>
    363a:	10 92 43 31 	sts	0x3143, r1	; 0x803143 <rcvD0_read_index+0x1>
}
    363e:	03 c0       	rjmp	.+6      	; 0x3646 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3640:	81 e0       	ldi	r24, 0x01	; 1
    3642:	90 e0       	ldi	r25, 0x00	; 0
    3644:	f3 cf       	rjmp	.-26     	; 0x362c <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3646:	ff 91       	pop	r31
    3648:	ef 91       	pop	r30
    364a:	9f 91       	pop	r25
    364c:	8f 91       	pop	r24
    364e:	3f 91       	pop	r19
    3650:	2f 91       	pop	r18
    3652:	0f 90       	pop	r0
    3654:	0b be       	out	0x3b, r0	; 59
    3656:	0f 90       	pop	r0
    3658:	08 be       	out	0x38, r0	; 56
    365a:	0f 90       	pop	r0
    365c:	0f be       	out	0x3f, r0	; 63
    365e:	0f 90       	pop	r0
    3660:	1f 90       	pop	r1
    3662:	18 95       	reti

00003664 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3664:	1f 92       	push	r1
    3666:	0f 92       	push	r0
    3668:	0f b6       	in	r0, 0x3f	; 63
    366a:	0f 92       	push	r0
    366c:	11 24       	eor	r1, r1
    366e:	08 b6       	in	r0, 0x38	; 56
    3670:	0f 92       	push	r0
    3672:	18 be       	out	0x38, r1	; 56
    3674:	0b b6       	in	r0, 0x3b	; 59
    3676:	0f 92       	push	r0
    3678:	1b be       	out	0x3b, r1	; 59
    367a:	2f 93       	push	r18
    367c:	3f 93       	push	r19
    367e:	8f 93       	push	r24
    3680:	9f 93       	push	r25
    3682:	ef 93       	push	r30
    3684:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3686:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    368a:	e0 91 4a 31 	lds	r30, 0x314A	; 0x80314a <rcvD1_buffer>
    368e:	f0 91 4b 31 	lds	r31, 0x314B	; 0x80314b <rcvD1_buffer+0x1>
    3692:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    3696:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    369a:	e8 0f       	add	r30, r24
    369c:	f9 1f       	adc	r31, r25
    369e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    36a0:	80 91 36 31 	lds	r24, 0x3136	; 0x803136 <rcvD1_write_index>
    36a4:	90 91 37 31 	lds	r25, 0x3137	; 0x803137 <rcvD1_write_index+0x1>
    36a8:	01 96       	adiw	r24, 0x01	; 1
    36aa:	84 36       	cpi	r24, 0x64	; 100
    36ac:	91 05       	cpc	r25, r1
    36ae:	60 f4       	brcc	.+24     	; 0x36c8 <__vector_91+0x64>
    36b0:	80 93 36 31 	sts	0x3136, r24	; 0x803136 <rcvD1_write_index>
    36b4:	90 93 37 31 	sts	0x3137, r25	; 0x803137 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    36b8:	20 91 40 31 	lds	r18, 0x3140	; 0x803140 <rcvD1_read_index>
    36bc:	30 91 41 31 	lds	r19, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    36c0:	82 17       	cp	r24, r18
    36c2:	93 07       	cpc	r25, r19
    36c4:	f1 f4       	brne	.+60     	; 0x3702 <__vector_91+0x9e>
    36c6:	0c c0       	rjmp	.+24     	; 0x36e0 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    36c8:	10 92 36 31 	sts	0x3136, r1	; 0x803136 <rcvD1_write_index>
    36cc:	10 92 37 31 	sts	0x3137, r1	; 0x803137 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    36d0:	80 91 40 31 	lds	r24, 0x3140	; 0x803140 <rcvD1_read_index>
    36d4:	90 91 41 31 	lds	r25, 0x3141	; 0x803141 <rcvD1_read_index+0x1>
    36d8:	18 16       	cp	r1, r24
    36da:	19 06       	cpc	r1, r25
    36dc:	91 f4       	brne	.+36     	; 0x3702 <__vector_91+0x9e>
    36de:	0e c0       	rjmp	.+28     	; 0x36fc <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    36e0:	01 96       	adiw	r24, 0x01	; 1
    36e2:	84 36       	cpi	r24, 0x64	; 100
    36e4:	91 05       	cpc	r25, r1
    36e6:	28 f4       	brcc	.+10     	; 0x36f2 <__vector_91+0x8e>
    36e8:	80 93 40 31 	sts	0x3140, r24	; 0x803140 <rcvD1_read_index>
    36ec:	90 93 41 31 	sts	0x3141, r25	; 0x803141 <rcvD1_read_index+0x1>
    36f0:	08 c0       	rjmp	.+16     	; 0x3702 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    36f2:	10 92 40 31 	sts	0x3140, r1	; 0x803140 <rcvD1_read_index>
    36f6:	10 92 41 31 	sts	0x3141, r1	; 0x803141 <rcvD1_read_index+0x1>
}
    36fa:	03 c0       	rjmp	.+6      	; 0x3702 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    36fc:	81 e0       	ldi	r24, 0x01	; 1
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	f3 cf       	rjmp	.-26     	; 0x36e8 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3702:	ff 91       	pop	r31
    3704:	ef 91       	pop	r30
    3706:	9f 91       	pop	r25
    3708:	8f 91       	pop	r24
    370a:	3f 91       	pop	r19
    370c:	2f 91       	pop	r18
    370e:	0f 90       	pop	r0
    3710:	0b be       	out	0x3b, r0	; 59
    3712:	0f 90       	pop	r0
    3714:	08 be       	out	0x38, r0	; 56
    3716:	0f 90       	pop	r0
    3718:	0f be       	out	0x3f, r0	; 63
    371a:	0f 90       	pop	r0
    371c:	1f 90       	pop	r1
    371e:	18 95       	reti

00003720 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3720:	1f 92       	push	r1
    3722:	0f 92       	push	r0
    3724:	0f b6       	in	r0, 0x3f	; 63
    3726:	0f 92       	push	r0
    3728:	11 24       	eor	r1, r1
    372a:	08 b6       	in	r0, 0x38	; 56
    372c:	0f 92       	push	r0
    372e:	18 be       	out	0x38, r1	; 56
    3730:	0b b6       	in	r0, 0x3b	; 59
    3732:	0f 92       	push	r0
    3734:	1b be       	out	0x3b, r1	; 59
    3736:	2f 93       	push	r18
    3738:	3f 93       	push	r19
    373a:	8f 93       	push	r24
    373c:	9f 93       	push	r25
    373e:	ef 93       	push	r30
    3740:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3742:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3746:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <rcvE0_buffer>
    374a:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <rcvE0_buffer+0x1>
    374e:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    3752:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    3756:	e8 0f       	add	r30, r24
    3758:	f9 1f       	adc	r31, r25
    375a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    375c:	80 91 34 31 	lds	r24, 0x3134	; 0x803134 <rcvE0_write_index>
    3760:	90 91 35 31 	lds	r25, 0x3135	; 0x803135 <rcvE0_write_index+0x1>
    3764:	01 96       	adiw	r24, 0x01	; 1
    3766:	84 36       	cpi	r24, 0x64	; 100
    3768:	91 05       	cpc	r25, r1
    376a:	60 f4       	brcc	.+24     	; 0x3784 <__vector_58+0x64>
    376c:	80 93 34 31 	sts	0x3134, r24	; 0x803134 <rcvE0_write_index>
    3770:	90 93 35 31 	sts	0x3135, r25	; 0x803135 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3774:	20 91 3e 31 	lds	r18, 0x313E	; 0x80313e <rcvE0_read_index>
    3778:	30 91 3f 31 	lds	r19, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    377c:	82 17       	cp	r24, r18
    377e:	93 07       	cpc	r25, r19
    3780:	f1 f4       	brne	.+60     	; 0x37be <__vector_58+0x9e>
    3782:	0c c0       	rjmp	.+24     	; 0x379c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3784:	10 92 34 31 	sts	0x3134, r1	; 0x803134 <rcvE0_write_index>
    3788:	10 92 35 31 	sts	0x3135, r1	; 0x803135 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    378c:	80 91 3e 31 	lds	r24, 0x313E	; 0x80313e <rcvE0_read_index>
    3790:	90 91 3f 31 	lds	r25, 0x313F	; 0x80313f <rcvE0_read_index+0x1>
    3794:	18 16       	cp	r1, r24
    3796:	19 06       	cpc	r1, r25
    3798:	91 f4       	brne	.+36     	; 0x37be <__vector_58+0x9e>
    379a:	0e c0       	rjmp	.+28     	; 0x37b8 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    379c:	01 96       	adiw	r24, 0x01	; 1
    379e:	84 36       	cpi	r24, 0x64	; 100
    37a0:	91 05       	cpc	r25, r1
    37a2:	28 f4       	brcc	.+10     	; 0x37ae <__vector_58+0x8e>
    37a4:	80 93 3e 31 	sts	0x313E, r24	; 0x80313e <rcvE0_read_index>
    37a8:	90 93 3f 31 	sts	0x313F, r25	; 0x80313f <rcvE0_read_index+0x1>
    37ac:	08 c0       	rjmp	.+16     	; 0x37be <__vector_58+0x9e>
	rcvE0_read_index = 0;
    37ae:	10 92 3e 31 	sts	0x313E, r1	; 0x80313e <rcvE0_read_index>
    37b2:	10 92 3f 31 	sts	0x313F, r1	; 0x80313f <rcvE0_read_index+0x1>
}
    37b6:	03 c0       	rjmp	.+6      	; 0x37be <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    37b8:	81 e0       	ldi	r24, 0x01	; 1
    37ba:	90 e0       	ldi	r25, 0x00	; 0
    37bc:	f3 cf       	rjmp	.-26     	; 0x37a4 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    37be:	ff 91       	pop	r31
    37c0:	ef 91       	pop	r30
    37c2:	9f 91       	pop	r25
    37c4:	8f 91       	pop	r24
    37c6:	3f 91       	pop	r19
    37c8:	2f 91       	pop	r18
    37ca:	0f 90       	pop	r0
    37cc:	0b be       	out	0x3b, r0	; 59
    37ce:	0f 90       	pop	r0
    37d0:	08 be       	out	0x38, r0	; 56
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63
    37d6:	0f 90       	pop	r0
    37d8:	1f 90       	pop	r1
    37da:	18 95       	reti

000037dc <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    37dc:	fc 01       	movw	r30, r24
    37de:	84 81       	ldd	r24, Z+4	; 0x04
    37e0:	95 81       	ldd	r25, Z+5	; 0x05
    37e2:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
		}
    37e6:	90 e0       	ldi	r25, 0x00	; 0
    37e8:	08 95       	ret

000037ea <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    37ea:	fc 01       	movw	r30, r24
    37ec:	84 81       	ldd	r24, Z+4	; 0x04
    37ee:	95 81       	ldd	r25, Z+5	; 0x05
    37f0:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
    37f4:	91 e0       	ldi	r25, 0x01	; 1
    37f6:	81 11       	cpse	r24, r1
    37f8:	01 c0       	rjmp	.+2      	; 0x37fc <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    37fa:	90 e0       	ldi	r25, 0x00	; 0
		}
    37fc:	89 2f       	mov	r24, r25
    37fe:	08 95       	ret

00003800 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3800:	fc 01       	movw	r30, r24
    3802:	84 81       	ldd	r24, Z+4	; 0x04
    3804:	95 81       	ldd	r25, Z+5	; 0x05
    3806:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
    380a:	91 e0       	ldi	r25, 0x01	; 1
    380c:	81 11       	cpse	r24, r1
    380e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3810:	89 2f       	mov	r24, r25
    3812:	08 95       	ret

00003814 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3814:	fc 01       	movw	r30, r24
    3816:	84 81       	ldd	r24, Z+4	; 0x04
    3818:	95 81       	ldd	r25, Z+5	; 0x05
    381a:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
		}
    381e:	90 e0       	ldi	r25, 0x00	; 0
    3820:	08 95       	ret

00003822 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3822:	fc 01       	movw	r30, r24
    3824:	84 81       	ldd	r24, Z+4	; 0x04
    3826:	95 81       	ldd	r25, Z+5	; 0x05
    3828:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
    382c:	91 e0       	ldi	r25, 0x01	; 1
    382e:	81 11       	cpse	r24, r1
    3830:	01 c0       	rjmp	.+2      	; 0x3834 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    3832:	90 e0       	ldi	r25, 0x00	; 0
		}
    3834:	89 2f       	mov	r24, r25
    3836:	08 95       	ret

00003838 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3838:	fc 01       	movw	r30, r24
    383a:	84 81       	ldd	r24, Z+4	; 0x04
    383c:	95 81       	ldd	r25, Z+5	; 0x05
    383e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxQueueMessagesWaitingFromISR>
    3842:	91 e0       	ldi	r25, 0x01	; 1
    3844:	81 11       	cpse	r24, r1
    3846:	90 e0       	ldi	r25, 0x00	; 0
		}
    3848:	89 2f       	mov	r24, r25
    384a:	08 95       	ret

0000384c <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    384c:	fc 01       	movw	r30, r24
    384e:	84 81       	ldd	r24, Z+4	; 0x04
    3850:	95 81       	ldd	r25, Z+5	; 0x05
    3852:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
		}
    3856:	90 e0       	ldi	r25, 0x00	; 0
    3858:	08 95       	ret

0000385a <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    385a:	fc 01       	movw	r30, r24
    385c:	84 81       	ldd	r24, Z+4	; 0x04
    385e:	95 81       	ldd	r25, Z+5	; 0x05
    3860:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
    3864:	91 e0       	ldi	r25, 0x01	; 1
    3866:	81 11       	cpse	r24, r1
    3868:	01 c0       	rjmp	.+2      	; 0x386c <_ZN9frt_queueIjE9not_emptyEv+0x12>
    386a:	90 e0       	ldi	r25, 0x00	; 0
		}
    386c:	89 2f       	mov	r24, r25
    386e:	08 95       	ret

00003870 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3870:	fc 01       	movw	r30, r24
    3872:	84 81       	ldd	r24, Z+4	; 0x04
    3874:	95 81       	ldd	r25, Z+5	; 0x05
    3876:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
    387a:	91 e0       	ldi	r25, 0x01	; 1
    387c:	81 11       	cpse	r24, r1
    387e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3880:	89 2f       	mov	r24, r25
    3882:	08 95       	ret

00003884 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3884:	fc 01       	movw	r30, r24
    3886:	84 81       	ldd	r24, Z+4	; 0x04
    3888:	95 81       	ldd	r25, Z+5	; 0x05
    388a:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
		}
    388e:	90 e0       	ldi	r25, 0x00	; 0
    3890:	08 95       	ret

00003892 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3892:	fc 01       	movw	r30, r24
    3894:	84 81       	ldd	r24, Z+4	; 0x04
    3896:	95 81       	ldd	r25, Z+5	; 0x05
    3898:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
    389c:	91 e0       	ldi	r25, 0x01	; 1
    389e:	81 11       	cpse	r24, r1
    38a0:	01 c0       	rjmp	.+2      	; 0x38a4 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    38a2:	90 e0       	ldi	r25, 0x00	; 0
		}
    38a4:	89 2f       	mov	r24, r25
    38a6:	08 95       	ret

000038a8 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    38a8:	fc 01       	movw	r30, r24
    38aa:	84 81       	ldd	r24, Z+4	; 0x04
    38ac:	95 81       	ldd	r25, Z+5	; 0x05
    38ae:	0e 94 18 0d 	call	0x1a30	; 0x1a30 <uxQueueMessagesWaiting>
    38b2:	91 e0       	ldi	r25, 0x01	; 1
    38b4:	81 11       	cpse	r24, r1
    38b6:	90 e0       	ldi	r25, 0x00	; 0
		}
    38b8:	89 2f       	mov	r24, r25
    38ba:	08 95       	ret

000038bc <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    38bc:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    38be:	01 e0       	ldi	r16, 0x01	; 1
    38c0:	2f ef       	ldi	r18, 0xFF	; 255
    38c2:	3f ef       	ldi	r19, 0xFF	; 255
    38c4:	a9 01       	movw	r20, r18
    38c6:	fc 01       	movw	r30, r24
    38c8:	84 81       	ldd	r24, Z+4	; 0x04
    38ca:	95 81       	ldd	r25, Z+5	; 0x05
    38cc:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
}
    38d0:	0f 91       	pop	r16
    38d2:	08 95       	ret

000038d4 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    38d4:	0f 93       	push	r16
    38d6:	cf 93       	push	r28
    38d8:	df 93       	push	r29
    38da:	1f 92       	push	r1
    38dc:	1f 92       	push	r1
    38de:	cd b7       	in	r28, 0x3d	; 61
    38e0:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    38e2:	01 e0       	ldi	r16, 0x01	; 1
    38e4:	2f ef       	ldi	r18, 0xFF	; 255
    38e6:	3f ef       	ldi	r19, 0xFF	; 255
    38e8:	a9 01       	movw	r20, r18
    38ea:	be 01       	movw	r22, r28
    38ec:	6f 5f       	subi	r22, 0xFF	; 255
    38ee:	7f 4f       	sbci	r23, 0xFF	; 255
    38f0:	fc 01       	movw	r30, r24
    38f2:	84 81       	ldd	r24, Z+4	; 0x04
    38f4:	95 81       	ldd	r25, Z+5	; 0x05
    38f6:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
	return (recv_item);
}
    38fa:	89 81       	ldd	r24, Y+1	; 0x01
    38fc:	9a 81       	ldd	r25, Y+2	; 0x02
    38fe:	0f 90       	pop	r0
    3900:	0f 90       	pop	r0
    3902:	df 91       	pop	r29
    3904:	cf 91       	pop	r28
    3906:	0f 91       	pop	r16
    3908:	08 95       	ret

0000390a <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    390a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    390c:	00 e0       	ldi	r16, 0x00	; 0
    390e:	2f ef       	ldi	r18, 0xFF	; 255
    3910:	3f ef       	ldi	r19, 0xFF	; 255
    3912:	a9 01       	movw	r20, r18
    3914:	fc 01       	movw	r30, r24
    3916:	84 81       	ldd	r24, Z+4	; 0x04
    3918:	95 81       	ldd	r25, Z+5	; 0x05
    391a:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
}
    391e:	0f 91       	pop	r16
    3920:	08 95       	ret

00003922 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3922:	0f 93       	push	r16
    3924:	cf 93       	push	r28
    3926:	df 93       	push	r29
    3928:	1f 92       	push	r1
    392a:	1f 92       	push	r1
    392c:	cd b7       	in	r28, 0x3d	; 61
    392e:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3930:	00 e0       	ldi	r16, 0x00	; 0
    3932:	2f ef       	ldi	r18, 0xFF	; 255
    3934:	3f ef       	ldi	r19, 0xFF	; 255
    3936:	a9 01       	movw	r20, r18
    3938:	be 01       	movw	r22, r28
    393a:	6f 5f       	subi	r22, 0xFF	; 255
    393c:	7f 4f       	sbci	r23, 0xFF	; 255
    393e:	fc 01       	movw	r30, r24
    3940:	84 81       	ldd	r24, Z+4	; 0x04
    3942:	95 81       	ldd	r25, Z+5	; 0x05
    3944:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
	return (recv_item);
}
    3948:	89 81       	ldd	r24, Y+1	; 0x01
    394a:	9a 81       	ldd	r25, Y+2	; 0x02
    394c:	0f 90       	pop	r0
    394e:	0f 90       	pop	r0
    3950:	df 91       	pop	r29
    3952:	cf 91       	pop	r28
    3954:	0f 91       	pop	r16
    3956:	08 95       	ret

00003958 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3958:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    395a:	01 e0       	ldi	r16, 0x01	; 1
    395c:	2f ef       	ldi	r18, 0xFF	; 255
    395e:	3f ef       	ldi	r19, 0xFF	; 255
    3960:	a9 01       	movw	r20, r18
    3962:	fc 01       	movw	r30, r24
    3964:	84 81       	ldd	r24, Z+4	; 0x04
    3966:	95 81       	ldd	r25, Z+5	; 0x05
    3968:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
}
    396c:	0f 91       	pop	r16
    396e:	08 95       	ret

00003970 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3970:	0f 93       	push	r16
    3972:	cf 93       	push	r28
    3974:	df 93       	push	r29
    3976:	1f 92       	push	r1
    3978:	1f 92       	push	r1
    397a:	cd b7       	in	r28, 0x3d	; 61
    397c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    397e:	01 e0       	ldi	r16, 0x01	; 1
    3980:	2f ef       	ldi	r18, 0xFF	; 255
    3982:	3f ef       	ldi	r19, 0xFF	; 255
    3984:	a9 01       	movw	r20, r18
    3986:	be 01       	movw	r22, r28
    3988:	6f 5f       	subi	r22, 0xFF	; 255
    398a:	7f 4f       	sbci	r23, 0xFF	; 255
    398c:	fc 01       	movw	r30, r24
    398e:	84 81       	ldd	r24, Z+4	; 0x04
    3990:	95 81       	ldd	r25, Z+5	; 0x05
    3992:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
	return (recv_item);
}
    3996:	89 81       	ldd	r24, Y+1	; 0x01
    3998:	9a 81       	ldd	r25, Y+2	; 0x02
    399a:	0f 90       	pop	r0
    399c:	0f 90       	pop	r0
    399e:	df 91       	pop	r29
    39a0:	cf 91       	pop	r28
    39a2:	0f 91       	pop	r16
    39a4:	08 95       	ret

000039a6 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    39a6:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    39a8:	00 e0       	ldi	r16, 0x00	; 0
    39aa:	2f ef       	ldi	r18, 0xFF	; 255
    39ac:	3f ef       	ldi	r19, 0xFF	; 255
    39ae:	a9 01       	movw	r20, r18
    39b0:	fc 01       	movw	r30, r24
    39b2:	84 81       	ldd	r24, Z+4	; 0x04
    39b4:	95 81       	ldd	r25, Z+5	; 0x05
    39b6:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
}
    39ba:	0f 91       	pop	r16
    39bc:	08 95       	ret

000039be <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    39be:	0f 93       	push	r16
    39c0:	cf 93       	push	r28
    39c2:	df 93       	push	r29
    39c4:	1f 92       	push	r1
    39c6:	1f 92       	push	r1
    39c8:	cd b7       	in	r28, 0x3d	; 61
    39ca:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    39cc:	00 e0       	ldi	r16, 0x00	; 0
    39ce:	2f ef       	ldi	r18, 0xFF	; 255
    39d0:	3f ef       	ldi	r19, 0xFF	; 255
    39d2:	a9 01       	movw	r20, r18
    39d4:	be 01       	movw	r22, r28
    39d6:	6f 5f       	subi	r22, 0xFF	; 255
    39d8:	7f 4f       	sbci	r23, 0xFF	; 255
    39da:	fc 01       	movw	r30, r24
    39dc:	84 81       	ldd	r24, Z+4	; 0x04
    39de:	95 81       	ldd	r25, Z+5	; 0x05
    39e0:	0e 94 27 0c 	call	0x184e	; 0x184e <xQueueGenericReceive>
	return (recv_item);
}
    39e4:	89 81       	ldd	r24, Y+1	; 0x01
    39e6:	9a 81       	ldd	r25, Y+2	; 0x02
    39e8:	0f 90       	pop	r0
    39ea:	0f 90       	pop	r0
    39ec:	df 91       	pop	r29
    39ee:	cf 91       	pop	r28
    39f0:	0f 91       	pop	r16
    39f2:	08 95       	ret

000039f4 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    39f4:	cf 93       	push	r28
    39f6:	df 93       	push	r29
    39f8:	1f 92       	push	r1
    39fa:	cd b7       	in	r28, 0x3d	; 61
    39fc:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    39fe:	ae 01       	movw	r20, r28
    3a00:	4f 5f       	subi	r20, 0xFF	; 255
    3a02:	5f 4f       	sbci	r21, 0xFF	; 255
    3a04:	fc 01       	movw	r30, r24
    3a06:	84 81       	ldd	r24, Z+4	; 0x04
    3a08:	95 81       	ldd	r25, Z+5	; 0x05
    3a0a:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <xQueueReceiveFromISR>
}
    3a0e:	0f 90       	pop	r0
    3a10:	df 91       	pop	r29
    3a12:	cf 91       	pop	r28
    3a14:	08 95       	ret

00003a16 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3a16:	cf 93       	push	r28
    3a18:	df 93       	push	r29
    3a1a:	00 d0       	rcall	.+0      	; 0x3a1c <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3a1c:	cd b7       	in	r28, 0x3d	; 61
    3a1e:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3a20:	ae 01       	movw	r20, r28
    3a22:	4d 5f       	subi	r20, 0xFD	; 253
    3a24:	5f 4f       	sbci	r21, 0xFF	; 255
    3a26:	be 01       	movw	r22, r28
    3a28:	6f 5f       	subi	r22, 0xFF	; 255
    3a2a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a2c:	fc 01       	movw	r30, r24
    3a2e:	84 81       	ldd	r24, Z+4	; 0x04
    3a30:	95 81       	ldd	r25, Z+5	; 0x05
    3a32:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <xQueueReceiveFromISR>
	return (recv_item);
}
    3a36:	89 81       	ldd	r24, Y+1	; 0x01
    3a38:	9a 81       	ldd	r25, Y+2	; 0x02
    3a3a:	23 96       	adiw	r28, 0x03	; 3
    3a3c:	cd bf       	out	0x3d, r28	; 61
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	08 95       	ret

00003a46 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3a46:	cf 93       	push	r28
    3a48:	df 93       	push	r29
    3a4a:	1f 92       	push	r1
    3a4c:	cd b7       	in	r28, 0x3d	; 61
    3a4e:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3a50:	ae 01       	movw	r20, r28
    3a52:	4f 5f       	subi	r20, 0xFF	; 255
    3a54:	5f 4f       	sbci	r21, 0xFF	; 255
    3a56:	fc 01       	movw	r30, r24
    3a58:	84 81       	ldd	r24, Z+4	; 0x04
    3a5a:	95 81       	ldd	r25, Z+5	; 0x05
    3a5c:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <xQueueReceiveFromISR>
}
    3a60:	0f 90       	pop	r0
    3a62:	df 91       	pop	r29
    3a64:	cf 91       	pop	r28
    3a66:	08 95       	ret

00003a68 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3a68:	cf 93       	push	r28
    3a6a:	df 93       	push	r29
    3a6c:	00 d0       	rcall	.+0      	; 0x3a6e <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3a6e:	cd b7       	in	r28, 0x3d	; 61
    3a70:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3a72:	ae 01       	movw	r20, r28
    3a74:	4d 5f       	subi	r20, 0xFD	; 253
    3a76:	5f 4f       	sbci	r21, 0xFF	; 255
    3a78:	be 01       	movw	r22, r28
    3a7a:	6f 5f       	subi	r22, 0xFF	; 255
    3a7c:	7f 4f       	sbci	r23, 0xFF	; 255
    3a7e:	fc 01       	movw	r30, r24
    3a80:	84 81       	ldd	r24, Z+4	; 0x04
    3a82:	95 81       	ldd	r25, Z+5	; 0x05
    3a84:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <xQueueReceiveFromISR>
	return (recv_item);
}
    3a88:	89 81       	ldd	r24, Y+1	; 0x01
    3a8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3a8c:	23 96       	adiw	r28, 0x03	; 3
    3a8e:	cd bf       	out	0x3d, r28	; 61
    3a90:	de bf       	out	0x3e, r29	; 62
    3a92:	df 91       	pop	r29
    3a94:	cf 91       	pop	r28
    3a96:	08 95       	ret

00003a98 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3a98:	cf 93       	push	r28
    3a9a:	df 93       	push	r29
    3a9c:	1f 92       	push	r1
    3a9e:	cd b7       	in	r28, 0x3d	; 61
    3aa0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3aa2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3aa4:	21 e0       	ldi	r18, 0x01	; 1
    3aa6:	ae 01       	movw	r20, r28
    3aa8:	4f 5f       	subi	r20, 0xFF	; 255
    3aaa:	5f 4f       	sbci	r21, 0xFF	; 255
    3aac:	fc 01       	movw	r30, r24
    3aae:	84 81       	ldd	r24, Z+4	; 0x04
    3ab0:	95 81       	ldd	r25, Z+5	; 0x05
    3ab2:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ab6:	91 e0       	ldi	r25, 0x01	; 1
    3ab8:	81 11       	cpse	r24, r1
    3aba:	01 c0       	rjmp	.+2      	; 0x3abe <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3abc:	90 e0       	ldi	r25, 0x00	; 0
}
    3abe:	89 2f       	mov	r24, r25
    3ac0:	0f 90       	pop	r0
    3ac2:	df 91       	pop	r29
    3ac4:	cf 91       	pop	r28
    3ac6:	08 95       	ret

00003ac8 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3ac8:	cf 93       	push	r28
    3aca:	df 93       	push	r29
    3acc:	1f 92       	push	r1
    3ace:	cd b7       	in	r28, 0x3d	; 61
    3ad0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3ad2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3ad4:	20 e0       	ldi	r18, 0x00	; 0
    3ad6:	ae 01       	movw	r20, r28
    3ad8:	4f 5f       	subi	r20, 0xFF	; 255
    3ada:	5f 4f       	sbci	r21, 0xFF	; 255
    3adc:	fc 01       	movw	r30, r24
    3ade:	84 81       	ldd	r24, Z+4	; 0x04
    3ae0:	95 81       	ldd	r25, Z+5	; 0x05
    3ae2:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ae6:	91 e0       	ldi	r25, 0x01	; 1
    3ae8:	81 11       	cpse	r24, r1
    3aea:	01 c0       	rjmp	.+2      	; 0x3aee <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3aec:	90 e0       	ldi	r25, 0x00	; 0
}
    3aee:	89 2f       	mov	r24, r25
    3af0:	0f 90       	pop	r0
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	08 95       	ret

00003af8 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3af8:	cf 93       	push	r28
    3afa:	df 93       	push	r29
    3afc:	1f 92       	push	r1
    3afe:	cd b7       	in	r28, 0x3d	; 61
    3b00:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3b02:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3b04:	21 e0       	ldi	r18, 0x01	; 1
    3b06:	ae 01       	movw	r20, r28
    3b08:	4f 5f       	subi	r20, 0xFF	; 255
    3b0a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	84 81       	ldd	r24, Z+4	; 0x04
    3b10:	95 81       	ldd	r25, Z+5	; 0x05
    3b12:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3b16:	91 e0       	ldi	r25, 0x01	; 1
    3b18:	81 11       	cpse	r24, r1
    3b1a:	01 c0       	rjmp	.+2      	; 0x3b1e <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3b1c:	90 e0       	ldi	r25, 0x00	; 0
}
    3b1e:	89 2f       	mov	r24, r25
    3b20:	0f 90       	pop	r0
    3b22:	df 91       	pop	r29
    3b24:	cf 91       	pop	r28
    3b26:	08 95       	ret

00003b28 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3b28:	cf 93       	push	r28
    3b2a:	df 93       	push	r29
    3b2c:	1f 92       	push	r1
    3b2e:	cd b7       	in	r28, 0x3d	; 61
    3b30:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3b32:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3b34:	20 e0       	ldi	r18, 0x00	; 0
    3b36:	ae 01       	movw	r20, r28
    3b38:	4f 5f       	subi	r20, 0xFF	; 255
    3b3a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b3c:	fc 01       	movw	r30, r24
    3b3e:	84 81       	ldd	r24, Z+4	; 0x04
    3b40:	95 81       	ldd	r25, Z+5	; 0x05
    3b42:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3b46:	91 e0       	ldi	r25, 0x01	; 1
    3b48:	81 11       	cpse	r24, r1
    3b4a:	01 c0       	rjmp	.+2      	; 0x3b4e <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
}
    3b4e:	89 2f       	mov	r24, r25
    3b50:	0f 90       	pop	r0
    3b52:	df 91       	pop	r29
    3b54:	cf 91       	pop	r28
    3b56:	08 95       	ret

00003b58 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3b58:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	26 81       	ldd	r18, Z+6	; 0x06
    3b5e:	37 81       	ldd	r19, Z+7	; 0x07
    3b60:	40 85       	ldd	r20, Z+8	; 0x08
    3b62:	51 85       	ldd	r21, Z+9	; 0x09
    3b64:	01 e0       	ldi	r16, 0x01	; 1
    3b66:	84 81       	ldd	r24, Z+4	; 0x04
    3b68:	95 81       	ldd	r25, Z+5	; 0x05
    3b6a:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xQueueGenericSend>
    3b6e:	91 e0       	ldi	r25, 0x01	; 1
    3b70:	81 11       	cpse	r24, r1
    3b72:	01 c0       	rjmp	.+2      	; 0x3b76 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3b74:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b76:	89 2f       	mov	r24, r25
    3b78:	0f 91       	pop	r16
    3b7a:	08 95       	ret

00003b7c <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3b7c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3b7e:	fc 01       	movw	r30, r24
    3b80:	26 81       	ldd	r18, Z+6	; 0x06
    3b82:	37 81       	ldd	r19, Z+7	; 0x07
    3b84:	40 85       	ldd	r20, Z+8	; 0x08
    3b86:	51 85       	ldd	r21, Z+9	; 0x09
    3b88:	00 e0       	ldi	r16, 0x00	; 0
    3b8a:	84 81       	ldd	r24, Z+4	; 0x04
    3b8c:	95 81       	ldd	r25, Z+5	; 0x05
    3b8e:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xQueueGenericSend>
    3b92:	91 e0       	ldi	r25, 0x01	; 1
    3b94:	81 11       	cpse	r24, r1
    3b96:	01 c0       	rjmp	.+2      	; 0x3b9a <_ZN9frt_queueIjE3putERKj+0x1e>
    3b98:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b9a:	89 2f       	mov	r24, r25
    3b9c:	0f 91       	pop	r16
    3b9e:	08 95       	ret

00003ba0 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3ba0:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3ba2:	fc 01       	movw	r30, r24
    3ba4:	26 81       	ldd	r18, Z+6	; 0x06
    3ba6:	37 81       	ldd	r19, Z+7	; 0x07
    3ba8:	40 85       	ldd	r20, Z+8	; 0x08
    3baa:	51 85       	ldd	r21, Z+9	; 0x09
    3bac:	01 e0       	ldi	r16, 0x01	; 1
    3bae:	84 81       	ldd	r24, Z+4	; 0x04
    3bb0:	95 81       	ldd	r25, Z+5	; 0x05
    3bb2:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xQueueGenericSend>
    3bb6:	91 e0       	ldi	r25, 0x01	; 1
    3bb8:	81 11       	cpse	r24, r1
    3bba:	01 c0       	rjmp	.+2      	; 0x3bbe <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
		}
    3bbe:	89 2f       	mov	r24, r25
    3bc0:	0f 91       	pop	r16
    3bc2:	08 95       	ret

00003bc4 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3bc4:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3bc6:	fc 01       	movw	r30, r24
    3bc8:	26 81       	ldd	r18, Z+6	; 0x06
    3bca:	37 81       	ldd	r19, Z+7	; 0x07
    3bcc:	40 85       	ldd	r20, Z+8	; 0x08
    3bce:	51 85       	ldd	r21, Z+9	; 0x09
    3bd0:	00 e0       	ldi	r16, 0x00	; 0
    3bd2:	84 81       	ldd	r24, Z+4	; 0x04
    3bd4:	95 81       	ldd	r25, Z+5	; 0x05
    3bd6:	0e 94 60 0b 	call	0x16c0	; 0x16c0 <xQueueGenericSend>
    3bda:	91 e0       	ldi	r25, 0x01	; 1
    3bdc:	81 11       	cpse	r24, r1
    3bde:	01 c0       	rjmp	.+2      	; 0x3be2 <_ZN9frt_queueIiE3putERKi+0x1e>
    3be0:	90 e0       	ldi	r25, 0x00	; 0
		}
    3be2:	89 2f       	mov	r24, r25
    3be4:	0f 91       	pop	r16
    3be6:	08 95       	ret

00003be8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3be8:	0f 93       	push	r16
    3bea:	cf 93       	push	r28
    3bec:	df 93       	push	r29
    3bee:	1f 92       	push	r1
    3bf0:	cd b7       	in	r28, 0x3d	; 61
    3bf2:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3bf4:	2f b7       	in	r18, 0x3f	; 63
    3bf6:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3bf8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3bfa:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3bfc:	fc 01       	movw	r30, r24
    3bfe:	08 ed       	ldi	r16, 0xD8	; 216
    3c00:	04 bf       	out	0x34, r16	; 52
    3c02:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3c04:	89 81       	ldd	r24, Y+1	; 0x01
    3c06:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3c08:	0f 90       	pop	r0
    3c0a:	df 91       	pop	r29
    3c0c:	cf 91       	pop	r28
    3c0e:	0f 91       	pop	r16
    3c10:	08 95       	ret

00003c12 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3c12:	ef 92       	push	r14
    3c14:	ff 92       	push	r15
    3c16:	0f 93       	push	r16
    3c18:	1f 93       	push	r17
    3c1a:	cf 93       	push	r28
    3c1c:	df 93       	push	r29
    3c1e:	cd b7       	in	r28, 0x3d	; 61
    3c20:	de b7       	in	r29, 0x3e	; 62
    3c22:	eb 97       	sbiw	r28, 0x3b	; 59
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	de bf       	out	0x3e, r29	; 62
	cli();
    3c28:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3c2a:	e0 e5       	ldi	r30, 0x50	; 80
    3c2c:	f0 e0       	ldi	r31, 0x00	; 0
    3c2e:	80 81       	ld	r24, Z
    3c30:	82 60       	ori	r24, 0x02	; 2
    3c32:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3c34:	81 81       	ldd	r24, Z+1	; 0x01
    3c36:	81 ff       	sbrs	r24, 1
    3c38:	fd cf       	rjmp	.-6      	; 0x3c34 <main+0x22>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3c3a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3c3e:	68 7f       	andi	r22, 0xF8	; 248
    3c40:	61 60       	ori	r22, 0x01	; 1
    3c42:	80 e4       	ldi	r24, 0x40	; 64
    3c44:	90 e0       	ldi	r25, 0x00	; 0
    3c46:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3c4a:	e0 e5       	ldi	r30, 0x50	; 80
    3c4c:	f0 e0       	ldi	r31, 0x00	; 0
    3c4e:	80 81       	ld	r24, Z
    3c50:	8e 7f       	andi	r24, 0xFE	; 254
    3c52:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3c54:	9d ef       	ldi	r25, 0xFD	; 253
    3c56:	88 ed       	ldi	r24, 0xD8	; 216
    3c58:	08 b6       	in	r0, 0x38	; 56
    3c5a:	18 be       	out	0x38, r1	; 56
    3c5c:	84 bf       	out	0x34, r24	; 52
    3c5e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3c62:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3c64:	40 ea       	ldi	r20, 0xA0	; 160
    3c66:	5a e0       	ldi	r21, 0x0A	; 10
    3c68:	60 e0       	ldi	r22, 0x00	; 0
    3c6a:	70 e0       	ldi	r23, 0x00	; 0
    3c6c:	ce 01       	movw	r24, r28
    3c6e:	01 96       	adiw	r24, 0x01	; 1
    3c70:	0e 94 98 19 	call	0x3330	; 0x3330 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3c74:	67 e0       	ldi	r22, 0x07	; 7
    3c76:	ce 01       	movw	r24, r28
    3c78:	01 96       	adiw	r24, 0x01	; 1
    3c7a:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    3c7e:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3c80:	63 e5       	ldi	r22, 0x53	; 83
    3c82:	70 e2       	ldi	r23, 0x20	; 32
    3c84:	0e 94 be 17 	call	0x2f7c	; 0x2f7c <_ZN8emstream4putsEPKc>
    3c88:	66 e0       	ldi	r22, 0x06	; 6
    3c8a:	c8 01       	movw	r24, r16
    3c8c:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
    3c90:	66 e0       	ldi	r22, 0x06	; 6
    3c92:	0e 94 f5 17 	call	0x2fea	; 0x2fea <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c (&TWIE, 62000);
    3c96:	20 e3       	ldi	r18, 0x30	; 48
    3c98:	32 ef       	ldi	r19, 0xF2	; 242
    3c9a:	40 e0       	ldi	r20, 0x00	; 0
    3c9c:	50 e0       	ldi	r21, 0x00	; 0
    3c9e:	60 ea       	ldi	r22, 0xA0	; 160
    3ca0:	74 e0       	ldi	r23, 0x04	; 4
    3ca2:	ce 01       	movw	r24, r28
    3ca4:	4e 96       	adiw	r24, 0x1e	; 30
    3ca6:	0e 94 34 03 	call	0x668	; 0x668 <_ZN9I2CMasterC1EP10TWI_structm>
	
	MB1202 mb1202 (&i2c);
    3caa:	be 01       	movw	r22, r28
    3cac:	62 5e       	subi	r22, 0xE2	; 226
    3cae:	7f 4f       	sbci	r23, 0xFF	; 255
    3cb0:	ce 01       	movw	r24, r28
    3cb2:	c1 96       	adiw	r24, 0x31	; 49
    3cb4:	0e 94 42 04 	call	0x884	; 0x884 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3cb8:	82 e1       	ldi	r24, 0x12	; 18
    3cba:	90 e0       	ldi	r25, 0x00	; 0
    3cbc:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <_Znwj>
    3cc0:	8e 01       	movw	r16, r28
    3cc2:	0f 5f       	subi	r16, 0xFF	; 255
    3cc4:	1f 4f       	sbci	r17, 0xFF	; 255
    3cc6:	20 e8       	ldi	r18, 0x80	; 128
    3cc8:	30 e0       	ldi	r19, 0x00	; 0
    3cca:	40 e0       	ldi	r20, 0x00	; 0
    3ccc:	62 e7       	ldi	r22, 0x72	; 114
    3cce:	70 e2       	ldi	r23, 0x20	; 32
    3cd0:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    3cd4:	88 e1       	ldi	r24, 0x18	; 24
    3cd6:	90 e0       	ldi	r25, 0x00	; 0
    3cd8:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <_Znwj>
    3cdc:	9e 01       	movw	r18, r28
    3cde:	2f 5c       	subi	r18, 0xCF	; 207
    3ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ce2:	79 01       	movw	r14, r18
    3ce4:	20 e8       	ldi	r18, 0x80	; 128
    3ce6:	30 e0       	ldi	r19, 0x00	; 0
    3ce8:	42 e0       	ldi	r20, 0x02	; 2
    3cea:	6a e7       	ldi	r22, 0x7A	; 122
    3cec:	70 e2       	ldi	r23, 0x20	; 32
    3cee:	0e 94 bf 04 	call	0x97e	; 0x97e <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3cf2:	87 e0       	ldi	r24, 0x07	; 7
    3cf4:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3cf8:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3cfa:	0e 94 89 0e 	call	0x1d12	; 0x1d12 <vTaskStartScheduler>
}
    3cfe:	80 e0       	ldi	r24, 0x00	; 0
    3d00:	90 e0       	ldi	r25, 0x00	; 0
    3d02:	eb 96       	adiw	r28, 0x3b	; 59
    3d04:	cd bf       	out	0x3d, r28	; 61
    3d06:	de bf       	out	0x3e, r29	; 62
    3d08:	df 91       	pop	r29
    3d0a:	cf 91       	pop	r28
    3d0c:	1f 91       	pop	r17
    3d0e:	0f 91       	pop	r16
    3d10:	ff 90       	pop	r15
    3d12:	ef 90       	pop	r14
    3d14:	08 95       	ret

00003d16 <_GLOBAL__sub_I_counter>:
    3d16:	cf 92       	push	r12
    3d18:	df 92       	push	r13
    3d1a:	ef 92       	push	r14
    3d1c:	ff 92       	push	r15
    3d1e:	0f 93       	push	r16
    3d20:	1f 93       	push	r17
    3d22:	cf 93       	push	r28
    3d24:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3d26:	0a e0       	ldi	r16, 0x0A	; 10
    3d28:	10 e0       	ldi	r17, 0x00	; 0
    3d2a:	20 e0       	ldi	r18, 0x00	; 0
    3d2c:	30 e0       	ldi	r19, 0x00	; 0
    3d2e:	40 e0       	ldi	r20, 0x00	; 0
    3d30:	50 e0       	ldi	r21, 0x00	; 0
    3d32:	60 e2       	ldi	r22, 0x20	; 32
    3d34:	70 e0       	ldi	r23, 0x00	; 0
    3d36:	84 e8       	ldi	r24, 0x84	; 132
    3d38:	91 e3       	ldi	r25, 0x31	; 49
    3d3a:	0e 94 76 15 	call	0x2aec	; 0x2aec <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3d3e:	ca e7       	ldi	r28, 0x7A	; 122
    3d40:	d1 e3       	ldi	r29, 0x31	; 49
    3d42:	1a 82       	std	Y+2, r1	; 0x02
    3d44:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d46:	84 e8       	ldi	r24, 0x84	; 132
    3d48:	90 e2       	ldi	r25, 0x20	; 32
    3d4a:	88 83       	st	Y, r24
    3d4c:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d4e:	40 e0       	ldi	r20, 0x00	; 0
    3d50:	62 e0       	ldi	r22, 0x02	; 2
    3d52:	8f ef       	ldi	r24, 0xFF	; 255
    3d54:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    3d58:	8c 83       	std	Y+4, r24	; 0x04
    3d5a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d5c:	0f 2e       	mov	r0, r31
    3d5e:	fa e0       	ldi	r31, 0x0A	; 10
    3d60:	cf 2e       	mov	r12, r31
    3d62:	d1 2c       	mov	r13, r1
    3d64:	e1 2c       	mov	r14, r1
    3d66:	f1 2c       	mov	r15, r1
    3d68:	f0 2d       	mov	r31, r0
    3d6a:	ce 82       	std	Y+6, r12	; 0x06
    3d6c:	df 82       	std	Y+7, r13	; 0x07
    3d6e:	e8 86       	std	Y+8, r14	; 0x08
    3d70:	f9 86       	std	Y+9, r15	; 0x09
    3d72:	c0 e7       	ldi	r28, 0x70	; 112
    3d74:	d1 e3       	ldi	r29, 0x31	; 49
    3d76:	1a 82       	std	Y+2, r1	; 0x02
    3d78:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3d7a:	08 ea       	ldi	r16, 0xA8	; 168
    3d7c:	10 e2       	ldi	r17, 0x20	; 32
    3d7e:	08 83       	st	Y, r16
    3d80:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3d82:	40 e0       	ldi	r20, 0x00	; 0
    3d84:	62 e0       	ldi	r22, 0x02	; 2
    3d86:	8f ef       	ldi	r24, 0xFF	; 255
    3d88:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    3d8c:	8c 83       	std	Y+4, r24	; 0x04
    3d8e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3d90:	ce 82       	std	Y+6, r12	; 0x06
    3d92:	df 82       	std	Y+7, r13	; 0x07
    3d94:	e8 86       	std	Y+8, r14	; 0x08
    3d96:	f9 86       	std	Y+9, r15	; 0x09
    3d98:	c6 e6       	ldi	r28, 0x66	; 102
    3d9a:	d1 e3       	ldi	r29, 0x31	; 49
    3d9c:	1a 82       	std	Y+2, r1	; 0x02
    3d9e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3da0:	08 83       	st	Y, r16
    3da2:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3da4:	40 e0       	ldi	r20, 0x00	; 0
    3da6:	62 e0       	ldi	r22, 0x02	; 2
    3da8:	8f ef       	ldi	r24, 0xFF	; 255
    3daa:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    3dae:	8c 83       	std	Y+4, r24	; 0x04
    3db0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3db2:	ce 82       	std	Y+6, r12	; 0x06
    3db4:	df 82       	std	Y+7, r13	; 0x07
    3db6:	e8 86       	std	Y+8, r14	; 0x08
    3db8:	f9 86       	std	Y+9, r15	; 0x09
    3dba:	cc e5       	ldi	r28, 0x5C	; 92
    3dbc:	d1 e3       	ldi	r29, 0x31	; 49
    3dbe:	1a 82       	std	Y+2, r1	; 0x02
    3dc0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3dc2:	08 83       	st	Y, r16
    3dc4:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3dc6:	40 e0       	ldi	r20, 0x00	; 0
    3dc8:	62 e0       	ldi	r22, 0x02	; 2
    3dca:	8f ef       	ldi	r24, 0xFF	; 255
    3dcc:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    3dd0:	8c 83       	std	Y+4, r24	; 0x04
    3dd2:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3dd4:	ce 82       	std	Y+6, r12	; 0x06
    3dd6:	df 82       	std	Y+7, r13	; 0x07
    3dd8:	e8 86       	std	Y+8, r14	; 0x08
    3dda:	f9 86       	std	Y+9, r15	; 0x09
    3ddc:	c2 e5       	ldi	r28, 0x52	; 82
    3dde:	d1 e3       	ldi	r29, 0x31	; 49
    3de0:	1a 82       	std	Y+2, r1	; 0x02
    3de2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3de4:	08 83       	st	Y, r16
    3de6:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3de8:	40 e0       	ldi	r20, 0x00	; 0
    3dea:	62 e0       	ldi	r22, 0x02	; 2
    3dec:	8f ef       	ldi	r24, 0xFF	; 255
    3dee:	0e 94 32 0b 	call	0x1664	; 0x1664 <xQueueGenericCreate>
    3df2:	8c 83       	std	Y+4, r24	; 0x04
    3df4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3df6:	ce 82       	std	Y+6, r12	; 0x06
    3df8:	df 82       	std	Y+7, r13	; 0x07
    3dfa:	e8 86       	std	Y+8, r14	; 0x08
    3dfc:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3dfe:	df 91       	pop	r29
    3e00:	cf 91       	pop	r28
    3e02:	1f 91       	pop	r17
    3e04:	0f 91       	pop	r16
    3e06:	ff 90       	pop	r15
    3e08:	ef 90       	pop	r14
    3e0a:	df 90       	pop	r13
    3e0c:	cf 90       	pop	r12
    3e0e:	08 95       	ret

00003e10 <__mulsi3>:
    3e10:	db 01       	movw	r26, r22
    3e12:	8f 93       	push	r24
    3e14:	9f 93       	push	r25
    3e16:	0e 94 62 1f 	call	0x3ec4	; 0x3ec4 <__muluhisi3>
    3e1a:	bf 91       	pop	r27
    3e1c:	af 91       	pop	r26
    3e1e:	a2 9f       	mul	r26, r18
    3e20:	80 0d       	add	r24, r0
    3e22:	91 1d       	adc	r25, r1
    3e24:	a3 9f       	mul	r26, r19
    3e26:	90 0d       	add	r25, r0
    3e28:	b2 9f       	mul	r27, r18
    3e2a:	90 0d       	add	r25, r0
    3e2c:	11 24       	eor	r1, r1
    3e2e:	08 95       	ret

00003e30 <__udivmodsi4>:
    3e30:	a1 e2       	ldi	r26, 0x21	; 33
    3e32:	1a 2e       	mov	r1, r26
    3e34:	aa 1b       	sub	r26, r26
    3e36:	bb 1b       	sub	r27, r27
    3e38:	fd 01       	movw	r30, r26
    3e3a:	0d c0       	rjmp	.+26     	; 0x3e56 <__udivmodsi4_ep>

00003e3c <__udivmodsi4_loop>:
    3e3c:	aa 1f       	adc	r26, r26
    3e3e:	bb 1f       	adc	r27, r27
    3e40:	ee 1f       	adc	r30, r30
    3e42:	ff 1f       	adc	r31, r31
    3e44:	a2 17       	cp	r26, r18
    3e46:	b3 07       	cpc	r27, r19
    3e48:	e4 07       	cpc	r30, r20
    3e4a:	f5 07       	cpc	r31, r21
    3e4c:	20 f0       	brcs	.+8      	; 0x3e56 <__udivmodsi4_ep>
    3e4e:	a2 1b       	sub	r26, r18
    3e50:	b3 0b       	sbc	r27, r19
    3e52:	e4 0b       	sbc	r30, r20
    3e54:	f5 0b       	sbc	r31, r21

00003e56 <__udivmodsi4_ep>:
    3e56:	66 1f       	adc	r22, r22
    3e58:	77 1f       	adc	r23, r23
    3e5a:	88 1f       	adc	r24, r24
    3e5c:	99 1f       	adc	r25, r25
    3e5e:	1a 94       	dec	r1
    3e60:	69 f7       	brne	.-38     	; 0x3e3c <__udivmodsi4_loop>
    3e62:	60 95       	com	r22
    3e64:	70 95       	com	r23
    3e66:	80 95       	com	r24
    3e68:	90 95       	com	r25
    3e6a:	9b 01       	movw	r18, r22
    3e6c:	ac 01       	movw	r20, r24
    3e6e:	bd 01       	movw	r22, r26
    3e70:	cf 01       	movw	r24, r30
    3e72:	08 95       	ret

00003e74 <__divmodsi4>:
    3e74:	05 2e       	mov	r0, r21
    3e76:	97 fb       	bst	r25, 7
    3e78:	1e f4       	brtc	.+6      	; 0x3e80 <__divmodsi4+0xc>
    3e7a:	00 94       	com	r0
    3e7c:	0e 94 51 1f 	call	0x3ea2	; 0x3ea2 <__negsi2>
    3e80:	57 fd       	sbrc	r21, 7
    3e82:	07 d0       	rcall	.+14     	; 0x3e92 <__divmodsi4_neg2>
    3e84:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <__udivmodsi4>
    3e88:	07 fc       	sbrc	r0, 7
    3e8a:	03 d0       	rcall	.+6      	; 0x3e92 <__divmodsi4_neg2>
    3e8c:	4e f4       	brtc	.+18     	; 0x3ea0 <__divmodsi4_exit>
    3e8e:	0c 94 51 1f 	jmp	0x3ea2	; 0x3ea2 <__negsi2>

00003e92 <__divmodsi4_neg2>:
    3e92:	50 95       	com	r21
    3e94:	40 95       	com	r20
    3e96:	30 95       	com	r19
    3e98:	21 95       	neg	r18
    3e9a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e9c:	4f 4f       	sbci	r20, 0xFF	; 255
    3e9e:	5f 4f       	sbci	r21, 0xFF	; 255

00003ea0 <__divmodsi4_exit>:
    3ea0:	08 95       	ret

00003ea2 <__negsi2>:
    3ea2:	90 95       	com	r25
    3ea4:	80 95       	com	r24
    3ea6:	70 95       	com	r23
    3ea8:	61 95       	neg	r22
    3eaa:	7f 4f       	sbci	r23, 0xFF	; 255
    3eac:	8f 4f       	sbci	r24, 0xFF	; 255
    3eae:	9f 4f       	sbci	r25, 0xFF	; 255
    3eb0:	08 95       	ret

00003eb2 <__tablejump2__>:
    3eb2:	ee 0f       	add	r30, r30
    3eb4:	ff 1f       	adc	r31, r31
    3eb6:	88 1f       	adc	r24, r24
    3eb8:	8b bf       	out	0x3b, r24	; 59
    3eba:	07 90       	elpm	r0, Z+
    3ebc:	f6 91       	elpm	r31, Z
    3ebe:	e0 2d       	mov	r30, r0
    3ec0:	1b be       	out	0x3b, r1	; 59
    3ec2:	19 94       	eijmp

00003ec4 <__muluhisi3>:
    3ec4:	0e 94 6d 1f 	call	0x3eda	; 0x3eda <__umulhisi3>
    3ec8:	a5 9f       	mul	r26, r21
    3eca:	90 0d       	add	r25, r0
    3ecc:	b4 9f       	mul	r27, r20
    3ece:	90 0d       	add	r25, r0
    3ed0:	a4 9f       	mul	r26, r20
    3ed2:	80 0d       	add	r24, r0
    3ed4:	91 1d       	adc	r25, r1
    3ed6:	11 24       	eor	r1, r1
    3ed8:	08 95       	ret

00003eda <__umulhisi3>:
    3eda:	a2 9f       	mul	r26, r18
    3edc:	b0 01       	movw	r22, r0
    3ede:	b3 9f       	mul	r27, r19
    3ee0:	c0 01       	movw	r24, r0
    3ee2:	a3 9f       	mul	r26, r19
    3ee4:	70 0d       	add	r23, r0
    3ee6:	81 1d       	adc	r24, r1
    3ee8:	11 24       	eor	r1, r1
    3eea:	91 1d       	adc	r25, r1
    3eec:	b2 9f       	mul	r27, r18
    3eee:	70 0d       	add	r23, r0
    3ef0:	81 1d       	adc	r24, r1
    3ef2:	11 24       	eor	r1, r1
    3ef4:	91 1d       	adc	r25, r1
    3ef6:	08 95       	ret

00003ef8 <memcpy>:
    3ef8:	fb 01       	movw	r30, r22
    3efa:	dc 01       	movw	r26, r24
    3efc:	02 c0       	rjmp	.+4      	; 0x3f02 <memcpy+0xa>
    3efe:	01 90       	ld	r0, Z+
    3f00:	0d 92       	st	X+, r0
    3f02:	41 50       	subi	r20, 0x01	; 1
    3f04:	50 40       	sbci	r21, 0x00	; 0
    3f06:	d8 f7       	brcc	.-10     	; 0x3efe <memcpy+0x6>
    3f08:	08 95       	ret

00003f0a <memset>:
    3f0a:	dc 01       	movw	r26, r24
    3f0c:	01 c0       	rjmp	.+2      	; 0x3f10 <memset+0x6>
    3f0e:	6d 93       	st	X+, r22
    3f10:	41 50       	subi	r20, 0x01	; 1
    3f12:	50 40       	sbci	r21, 0x00	; 0
    3f14:	e0 f7       	brcc	.-8      	; 0x3f0e <memset+0x4>
    3f16:	08 95       	ret

00003f18 <strncpy>:
    3f18:	fb 01       	movw	r30, r22
    3f1a:	dc 01       	movw	r26, r24
    3f1c:	41 50       	subi	r20, 0x01	; 1
    3f1e:	50 40       	sbci	r21, 0x00	; 0
    3f20:	48 f0       	brcs	.+18     	; 0x3f34 <strncpy+0x1c>
    3f22:	01 90       	ld	r0, Z+
    3f24:	0d 92       	st	X+, r0
    3f26:	00 20       	and	r0, r0
    3f28:	c9 f7       	brne	.-14     	; 0x3f1c <strncpy+0x4>
    3f2a:	01 c0       	rjmp	.+2      	; 0x3f2e <strncpy+0x16>
    3f2c:	1d 92       	st	X+, r1
    3f2e:	41 50       	subi	r20, 0x01	; 1
    3f30:	50 40       	sbci	r21, 0x00	; 0
    3f32:	e0 f7       	brcc	.-8      	; 0x3f2c <strncpy+0x14>
    3f34:	08 95       	ret

00003f36 <ultoa>:
    3f36:	25 32       	cpi	r18, 0x25	; 37
    3f38:	31 05       	cpc	r19, r1
    3f3a:	20 f4       	brcc	.+8      	; 0x3f44 <ultoa+0xe>
    3f3c:	22 30       	cpi	r18, 0x02	; 2
    3f3e:	10 f0       	brcs	.+4      	; 0x3f44 <ultoa+0xe>
    3f40:	0c 94 a6 1f 	jmp	0x3f4c	; 0x3f4c <__ultoa_ncheck>
    3f44:	fa 01       	movw	r30, r20
    3f46:	10 82       	st	Z, r1
    3f48:	ca 01       	movw	r24, r20
    3f4a:	08 95       	ret

00003f4c <__ultoa_ncheck>:
    3f4c:	bb 27       	eor	r27, r27

00003f4e <__ultoa_common>:
    3f4e:	fa 01       	movw	r30, r20
    3f50:	a6 2f       	mov	r26, r22
    3f52:	62 17       	cp	r22, r18
    3f54:	71 05       	cpc	r23, r1
    3f56:	81 05       	cpc	r24, r1
    3f58:	91 05       	cpc	r25, r1
    3f5a:	33 0b       	sbc	r19, r19
    3f5c:	30 fb       	bst	r19, 0
    3f5e:	66 f0       	brts	.+24     	; 0x3f78 <__ultoa_common+0x2a>
    3f60:	aa 27       	eor	r26, r26
    3f62:	66 0f       	add	r22, r22
    3f64:	77 1f       	adc	r23, r23
    3f66:	88 1f       	adc	r24, r24
    3f68:	99 1f       	adc	r25, r25
    3f6a:	aa 1f       	adc	r26, r26
    3f6c:	a2 17       	cp	r26, r18
    3f6e:	10 f0       	brcs	.+4      	; 0x3f74 <__ultoa_common+0x26>
    3f70:	a2 1b       	sub	r26, r18
    3f72:	63 95       	inc	r22
    3f74:	38 50       	subi	r19, 0x08	; 8
    3f76:	a9 f7       	brne	.-22     	; 0x3f62 <__ultoa_common+0x14>
    3f78:	a0 5d       	subi	r26, 0xD0	; 208
    3f7a:	aa 33       	cpi	r26, 0x3A	; 58
    3f7c:	08 f0       	brcs	.+2      	; 0x3f80 <__ultoa_common+0x32>
    3f7e:	a9 5d       	subi	r26, 0xD9	; 217
    3f80:	a1 93       	st	Z+, r26
    3f82:	36 f7       	brtc	.-52     	; 0x3f50 <__ultoa_common+0x2>
    3f84:	b1 11       	cpse	r27, r1
    3f86:	b1 93       	st	Z+, r27
    3f88:	10 82       	st	Z, r1
    3f8a:	ca 01       	movw	r24, r20
    3f8c:	0c 94 ed 1f 	jmp	0x3fda	; 0x3fda <strrev>

00003f90 <utoa>:
    3f90:	45 32       	cpi	r20, 0x25	; 37
    3f92:	51 05       	cpc	r21, r1
    3f94:	20 f4       	brcc	.+8      	; 0x3f9e <utoa+0xe>
    3f96:	42 30       	cpi	r20, 0x02	; 2
    3f98:	10 f0       	brcs	.+4      	; 0x3f9e <utoa+0xe>
    3f9a:	0c 94 d3 1f 	jmp	0x3fa6	; 0x3fa6 <__utoa_ncheck>
    3f9e:	fb 01       	movw	r30, r22
    3fa0:	10 82       	st	Z, r1
    3fa2:	cb 01       	movw	r24, r22
    3fa4:	08 95       	ret

00003fa6 <__utoa_ncheck>:
    3fa6:	bb 27       	eor	r27, r27

00003fa8 <__utoa_common>:
    3fa8:	fb 01       	movw	r30, r22
    3faa:	55 27       	eor	r21, r21
    3fac:	aa 27       	eor	r26, r26
    3fae:	88 0f       	add	r24, r24
    3fb0:	99 1f       	adc	r25, r25
    3fb2:	aa 1f       	adc	r26, r26
    3fb4:	a4 17       	cp	r26, r20
    3fb6:	10 f0       	brcs	.+4      	; 0x3fbc <__utoa_common+0x14>
    3fb8:	a4 1b       	sub	r26, r20
    3fba:	83 95       	inc	r24
    3fbc:	50 51       	subi	r21, 0x10	; 16
    3fbe:	b9 f7       	brne	.-18     	; 0x3fae <__utoa_common+0x6>
    3fc0:	a0 5d       	subi	r26, 0xD0	; 208
    3fc2:	aa 33       	cpi	r26, 0x3A	; 58
    3fc4:	08 f0       	brcs	.+2      	; 0x3fc8 <__utoa_common+0x20>
    3fc6:	a9 5d       	subi	r26, 0xD9	; 217
    3fc8:	a1 93       	st	Z+, r26
    3fca:	00 97       	sbiw	r24, 0x00	; 0
    3fcc:	79 f7       	brne	.-34     	; 0x3fac <__utoa_common+0x4>
    3fce:	b1 11       	cpse	r27, r1
    3fd0:	b1 93       	st	Z+, r27
    3fd2:	11 92       	st	Z+, r1
    3fd4:	cb 01       	movw	r24, r22
    3fd6:	0c 94 ed 1f 	jmp	0x3fda	; 0x3fda <strrev>

00003fda <strrev>:
    3fda:	dc 01       	movw	r26, r24
    3fdc:	fc 01       	movw	r30, r24
    3fde:	67 2f       	mov	r22, r23
    3fe0:	71 91       	ld	r23, Z+
    3fe2:	77 23       	and	r23, r23
    3fe4:	e1 f7       	brne	.-8      	; 0x3fde <strrev+0x4>
    3fe6:	32 97       	sbiw	r30, 0x02	; 2
    3fe8:	04 c0       	rjmp	.+8      	; 0x3ff2 <strrev+0x18>
    3fea:	7c 91       	ld	r23, X
    3fec:	6d 93       	st	X+, r22
    3fee:	70 83       	st	Z, r23
    3ff0:	62 91       	ld	r22, -Z
    3ff2:	ae 17       	cp	r26, r30
    3ff4:	bf 07       	cpc	r27, r31
    3ff6:	c8 f3       	brcs	.-14     	; 0x3fea <strrev+0x10>
    3ff8:	08 95       	ret

00003ffa <_exit>:
    3ffa:	f8 94       	cli

00003ffc <__stop_program>:
    3ffc:	ff cf       	rjmp	.-2      	; 0x3ffc <__stop_program>
