
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004df8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000002a8  00802000  00004df8  00004e8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008022a8  008022a8  00005134  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00005134  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005164  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000009b8  00000000  00000000  000051a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001ab30  00000000  00000000  00005b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006f65  00000000  00000000  0002068c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006586  00000000  00000000  000275f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001d68  00000000  00000000  0002db78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006e88  00000000  00000000  0002f8e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000975b  00000000  00000000  00036768  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008f8  00000000  00000000  0003fec3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 03 	jmp	0x66a	; 0x66a <__ctors_end>
       4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
       c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      10:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      14:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      18:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      1c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      20:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      24:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      28:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      2c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      30:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      34:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      38:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      3c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      40:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      44:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      48:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      4c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      50:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      54:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      58:	0c 94 18 11 	jmp	0x2230	; 0x2230 <__vector_22>
      5c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      60:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      64:	0c 94 12 21 	jmp	0x4224	; 0x4224 <__vector_25>
      68:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      6c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      70:	0c 94 70 21 	jmp	0x42e0	; 0x42e0 <__vector_28>
      74:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      78:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      7c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      80:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      84:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      88:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      8c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      90:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      94:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      98:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      9c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      e8:	0c 94 8a 22 	jmp	0x4514	; 0x4514 <__vector_58>
      ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
      fc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     100:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     104:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     108:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     10c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     110:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     114:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     118:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     11c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     120:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     124:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     128:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     12c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     130:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     134:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     138:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     13c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     140:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     144:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     148:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     14c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     150:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     154:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     158:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     15c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     160:	0c 94 ce 21 	jmp	0x439c	; 0x439c <__vector_88>
     164:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     168:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     16c:	0c 94 2c 22 	jmp	0x4458	; 0x4458 <__vector_91>
     170:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     174:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     178:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     17c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     180:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     184:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     188:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     18c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     190:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     194:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     198:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     19c:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1a8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ac:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1b8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1bc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1c8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1cc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1d8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1dc:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1e8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1ec:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f0:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f4:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1f8:	0c 94 6b 03 	jmp	0x6d6	; 0x6d6 <__bad_interrupt>
     1fc:	d9 1e       	adc	r13, r25
     1fe:	dc 1e       	adc	r13, r28
     200:	df 1e       	adc	r13, r31
     202:	e2 1e       	adc	r14, r18
     204:	e5 1e       	adc	r14, r21
     206:	e8 1e       	adc	r14, r24
     208:	ea 1e       	adc	r14, r26
     20a:	fb 1e       	adc	r15, r27
     20c:	03 1f       	adc	r16, r19
     20e:	0d 1f       	adc	r16, r29
     210:	0b 1f       	adc	r16, r27

00000212 <__trampolines_start>:
     212:	0c 94 e8 22 	jmp	0x45d0	; 0x45d0 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     216:	0c 94 04 23 	jmp	0x4608	; 0x4608 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     21a:	0c 94 81 1e 	jmp	0x3d02	; 0x3d02 <_ZN8emstream14check_for_charEv>
     21e:	0c 94 2c 20 	jmp	0x4058	; 0x4058 <_ZN5rs2327putcharEc>
     222:	0c 94 dc 24 	jmp	0x49b8	; 0x49b8 <_ZN9frt_queueIiE3putERKi>
     226:	0c 94 0b 23 	jmp	0x4616	; 0x4616 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     22a:	0c 94 9f 09 	jmp	0x133e	; 0x133e <_ZN9frt_queueIhE3getEPh>
     22e:	0c 94 84 1e 	jmp	0x3d08	; 0x3d08 <_ZN8emstream12clear_screenEv>
     232:	0c 94 20 23 	jmp	0x4640	; 0x4640 <_ZN9frt_queueIjE12num_items_inEv>
     236:	0c 94 8e 24 	jmp	0x491c	; 0x491c <_ZN9frt_queueIiE7ISR_putERKi>
     23a:	0c 94 fe 04 	jmp	0x9fc	; 0x9fc <_ZN9I2CMaster10StartState11serialDebugEv>
     23e:	0c 94 7c 1e 	jmp	0x3cf8	; 0x3cf8 <_ZN8emstream13ready_to_sendEv>
     242:	0c 94 8b 23 	jmp	0x4716	; 0x4716 <_ZN9frt_queueIjE3getEv>
     246:	0c 94 f8 13 	jmp	0x27f0	; 0x27f0 <prvIdleTask>
     24a:	0c 94 ba 1a 	jmp	0x3574	; 0x3574 <_ZN8frt_task12print_statusER8emstream>
     24e:	0c 94 ef 22 	jmp	0x45de	; 0x45de <_ZN9frt_queueIjE13ISR_not_emptyEv>
     252:	0c 94 3c 23 	jmp	0x4678	; 0x4678 <_ZN9frt_queueIiE12num_items_inEv>
     256:	0c 94 ea 1e 	jmp	0x3dd4	; 0x3dd4 <_ZN8emstreamlsE15ser_manipulator+0x40>
     25a:	0c 94 92 05 	jmp	0xb24	; 0xb24 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     25e:	0c 94 d1 05 	jmp	0xba2	; 0xba2 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     262:	0c 94 5f 09 	jmp	0x12be	; 0x12be <_ZN9frt_queueIhE12num_items_inEv>
     266:	0c 94 2d 0a 	jmp	0x145a	; 0x145a <_ZN9frt_queueIhE3putERKh>
     26a:	0c 94 a6 24 	jmp	0x494c	; 0x494c <_ZN9frt_queueIjE7butt_inERKj>
     26e:	0c 94 4a 09 	jmp	0x1294	; 0x1294 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     272:	0c 94 13 05 	jmp	0xa26	; 0xa26 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>
     276:	0c 94 58 23 	jmp	0x46b0	; 0x46b0 <_ZN9frt_queueIjE10get_a_copyERj>
     27a:	0c 94 cd 23 	jmp	0x479a	; 0x479a <_ZN9frt_queueIiE3getEPi>
     27e:	0c 94 b8 24 	jmp	0x4970	; 0x4970 <_ZN9frt_queueIjE3putERKj>
     282:	0c 94 31 05 	jmp	0xa62	; 0xa62 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>
     286:	0c 94 4b 0b 	jmp	0x1696	; 0x1696 <_ZN10task_sonar3runEv>
     28a:	0c 94 1b 0a 	jmp	0x1436	; 0x1436 <_ZN9frt_queueIhE7butt_inERKh>
     28e:	0c 94 39 04 	jmp	0x872	; 0x872 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     292:	0c 94 05 24 	jmp	0x480a	; 0x480a <_ZN9frt_queueIjE7ISR_getEv>
     296:	0c 94 27 23 	jmp	0x464e	; 0x464e <_ZN9frt_queueIjE9not_emptyEv>
     29a:	0c 94 63 04 	jmp	0x8c6	; 0x8c6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     29e:	0c 94 04 1c 	jmp	0x3808	; 0x3808 <_ZN14frt_text_queue7getcharEv>
     2a2:	0c 94 fa 22 	jmp	0x45f4	; 0x45f4 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     2a6:	0c 94 36 09 	jmp	0x126c	; 0x126c <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     2aa:	0c 94 0b 1f 	jmp	0x3e16	; 0x3e16 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2ae:	0c 94 d0 03 	jmp	0x7a0	; 0x7a0 <_ZN8I2CAgent11writePacketER7Command>
     2b2:	0c 94 d4 09 	jmp	0x13a8	; 0x13a8 <_ZN9frt_queueIhE7ISR_getEv>
     2b6:	0c 94 78 03 	jmp	0x6f0	; 0x6f0 <_ZN8I2CAgent8transmitER7Command>
     2ba:	0c 94 89 20 	jmp	0x4112	; 0x4112 <_ZN5rs23212clear_screenEv>
     2be:	0c 94 32 03 	jmp	0x664	; 0x664 <_call_static_run_method>
     2c2:	0c 94 64 23 	jmp	0x46c8	; 0x46c8 <_ZN9frt_queueIjE10get_a_copyEv>
     2c6:	0c 94 55 09 	jmp	0x12aa	; 0x12aa <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2ca:	0c 94 43 23 	jmp	0x4686	; 0x4686 <_ZN9frt_queueIiE9not_emptyEv>
     2ce:	0c 94 43 09 	jmp	0x1286	; 0x1286 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     2d2:	0c 94 b2 23 	jmp	0x4764	; 0x4764 <_ZN9frt_queueIiE10get_a_copyEv>
     2d6:	0c 94 0f 04 	jmp	0x81e	; 0x81e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     2da:	0c 94 aa 04 	jmp	0x954	; 0x954 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>
     2de:	0c 94 22 1c 	jmp	0x3844	; 0x3844 <_ZN14frt_text_queue14check_for_charEv>
     2e2:	0c 94 0d 1f 	jmp	0x3e1a	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
     2e6:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <_ZN14frt_text_queue7putcharEc>
     2ea:	0c 94 f4 23 	jmp	0x47e8	; 0x47e8 <_ZN9frt_queueIjE7ISR_getEPj>
     2ee:	0c 94 78 04 	jmp	0x8f0	; 0x8f0 <_ZN9I2CMaster9DoneState7executeER6Packet>
     2f2:	0c 94 dc 1e 	jmp	0x3db8	; 0x3db8 <_ZN8emstreamlsE15ser_manipulator+0x24>
     2f6:	0c 94 87 09 	jmp	0x130e	; 0x130e <_ZN9frt_queueIhE10get_a_copyEv>
     2fa:	0c 94 a5 03 	jmp	0x74a	; 0x74a <_ZN8I2CAgent7receiveEv>
     2fe:	0c 94 d9 1e 	jmp	0x3db2	; 0x3db2 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     302:	0c 94 83 1e 	jmp	0x3d06	; 0x3d06 <_ZN8emstream12transmit_nowEv>
     306:	0c 94 1d 24 	jmp	0x483a	; 0x483a <_ZN9frt_queueIiE7ISR_getEPi>
     30a:	0c 94 fb 1e 	jmp	0x3df6	; 0x3df6 <_ZN8emstreamlsE15ser_manipulator+0x62>
     30e:	0c 94 e5 1d 	jmp	0x3bca	; 0x3bca <__cxa_pure_virtual>
     312:	0c 94 5e 24 	jmp	0x48bc	; 0x48bc <_ZN9frt_queueIjE7ISR_putERKj>
     316:	0c 94 d4 04 	jmp	0x9a8	; 0x9a8 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>
     31a:	0c 94 e5 1e 	jmp	0x3dca	; 0x3dca <_ZN8emstreamlsE15ser_manipulator+0x36>
     31e:	0c 94 76 20 	jmp	0x40ec	; 0x40ec <_ZN5rs23214check_for_charEv>
     322:	0c 94 f4 0c 	jmp	0x19e8	; 0x19e8 <_ZN9task_user3runEv>
     326:	0c 94 7e 1e 	jmp	0x3cfc	; 0x3cfc <_ZN8emstream7getcharEv>
     32a:	0c 94 7c 04 	jmp	0x8f8	; 0x8f8 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     32e:	0c 94 a6 23 	jmp	0x474c	; 0x474c <_ZN9frt_queueIiE10get_a_copyERi>
     332:	0c 94 71 09 	jmp	0x12e2	; 0x12e2 <_ZN9frt_queueIhE8is_emptyEv>
     336:	0c 94 2e 24 	jmp	0x485c	; 0x485c <_ZN9frt_queueIiE7ISR_getEv>
     33a:	0c 94 32 23 	jmp	0x4664	; 0x4664 <_ZN9frt_queueIjE8is_emptyEv>
     33e:	0c 94 4e 23 	jmp	0x469c	; 0x469c <_ZN9frt_queueIiE8is_emptyEv>
     342:	0c 94 4f 05 	jmp	0xa9e	; 0xa9e <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     346:	0c 94 02 04 	jmp	0x804	; 0x804 <_ZN8I2CAgent11resetPacketER6Packet>
     34a:	0c 94 6d 03 	jmp	0x6da	; 0x6da <_ZN8I2CAgent10readPacketEv>
     34e:	0c 94 46 24 	jmp	0x488c	; 0x488c <_ZN9frt_queueIjE11ISR_butt_inERKj>
     352:	0c 94 bf 04 	jmp	0x97e	; 0x97e <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>
     356:	0c 94 16 23 	jmp	0x462c	; 0x462c <_ZN9frt_queueIiE12ISR_is_emptyEv>
     35a:	0c 94 ca 24 	jmp	0x4994	; 0x4994 <_ZN9frt_queueIiE7butt_inERKi>
     35e:	0c 94 df 1e 	jmp	0x3dbe	; 0x3dbe <_ZN8emstreamlsE15ser_manipulator+0x2a>
     362:	0c 94 e8 1e 	jmp	0x3dd0	; 0x3dd0 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     366:	0c 94 80 04 	jmp	0x900	; 0x900 <_ZN9I2CMaster10ErrorState11serialDebugEv>
     36a:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <_ZN9frt_queueIhE7ISR_getEPh>
     36e:	0c 94 7b 09 	jmp	0x12f6	; 0x12f6 <_ZN9frt_queueIhE10get_a_copyERh>
     372:	0c 94 95 04 	jmp	0x92a	; 0x92a <_ZN9I2CMaster9DoneState11serialDebugEv>
     376:	0c 94 76 24 	jmp	0x48ec	; 0x48ec <_ZN9frt_queueIiE11ISR_butt_inERKi>
     37a:	0c 94 e9 04 	jmp	0x9d2	; 0x9d2 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>
     37e:	0c 94 eb 09 	jmp	0x13d6	; 0x13d6 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     382:	0c 94 50 20 	jmp	0x40a0	; 0x40a0 <_ZN5rs2327getcharEv>
     386:	0c 94 66 09 	jmp	0x12cc	; 0x12cc <_ZN9frt_queueIhE9not_emptyEv>
     38a:	0c 94 7f 23 	jmp	0x46fe	; 0x46fe <_ZN9frt_queueIjE3getEPj>
     38e:	0c 94 88 25 	jmp	0x4b10	; 0x4b10 <_GLOBAL__sub_I_counter>
     392:	0c 94 ab 09 	jmp	0x1356	; 0x1356 <_ZN9frt_queueIhE3getEv>
     396:	0c 94 03 0a 	jmp	0x1406	; 0x1406 <_ZN9frt_queueIhE7ISR_putERKh>
     39a:	0c 94 13 09 	jmp	0x1226	; 0x1226 <_ZN9I2CMaster10StartState7executeER6Packet>
     39e:	0c 94 d9 23 	jmp	0x47b2	; 0x47b2 <_ZN9frt_queueIiE3getEv>
     3a2:	0c 94 03 1f 	jmp	0x3e06	; 0x3e06 <_ZN8emstreamlsE15ser_manipulator+0x72>
     3a6:	0c 94 e2 1e 	jmp	0x3dc4	; 0x3dc4 <_ZN8emstreamlsE15ser_manipulator+0x30>

000003aa <__trampolines_end>:
     3aa:	53 6f       	ori	r21, 0xF3	; 243
     3ac:	6e 61       	ori	r22, 0x1E	; 30
     3ae:	72 3a       	cpi	r23, 0xA2	; 162
     3b0:	20 00       	.word	0x0020	; ????

000003b2 <_ZZN9task_user11show_statusEvE3__c_4>:
     3b2:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

000003bd <_ZZN9task_user11show_statusEvE3__c_3>:
     3bd:	2f 00                                               /.

000003bf <_ZZN9task_user11show_statusEvE3__c_2>:
     3bf:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003cd <_ZZN9task_user11show_statusEvE3__c_1>:
     3cd:	54 69 6d 65 3a 20 00                                Time: .

000003d4 <_ZZN9task_user11show_statusEvE3__c_0>:
     3d4:	4e 6f 76 20 32 33 20 32 30 31 38 00                 Nov 23 2018.

000003e0 <_ZZN9task_user11show_statusEvE3__c>:
     3e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003ff <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3ff:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000040e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     40e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     41e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000429 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     429:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     439:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000447 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     447:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     457:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     467:	6d 61 74 69 6f 6e 00                                mation.

0000046e <_ZZN9task_user18print_help_messageEvE3__c_6>:
     46e:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     47e:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000048f <_ZZN9task_user18print_help_messageEvE3__c_5>:
     48f:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     49f:	65 20 6f 6e 6c 79 3a 00                             e only:.

000004a7 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     4a7:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     4b7:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000004c3 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     4c3:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4d3:	68 65 20 41 56 52 00                                he AVR.

000004da <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4da:	20 68 65 6c 70 00                                    help.

000004e0 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4e0:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4f0:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004ff <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4ff:	1b 5b 33 30 6d 00                                   .[30m.

00000505 <_ZZN9task_user18print_help_messageEvE3__c>:
     505:	1b 5b 34 36 6d 00                                   .[46m.

0000050b <_ZZN9task_user3runEvE3__c_3>:
     50b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     51b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000528 <_ZZN9task_user3runEvE3__c_2>:
     528:	3a 57 54 46 3f 00                                   :WTF?.

0000052e <_ZZN9task_user3runEvE3__c_1>:
     52e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     53e:	65 00                                               e.

00000540 <_ZZN9task_user3runEvE3__c_0>:
     540:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000054e <_ZZN9task_user3runEvE3__c>:
     54e:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     55e:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

0000056c <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     56c:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000576 <_ZZN8frt_task15emergency_resetEvE3__c>:
     576:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000585 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     585:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     595:	61 73 6b 20 00                                      ask .

0000059a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     59a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

000005a8 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     5a8:	20 63 72 65 61 74 65 64 00                           created.

000005b1 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     5b1:	54 61 73 6b 20 00                                   Task .

000005b7 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     5b7:	1b 5b 32 32 6d 00                                   .[22m.

000005bd <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     5bd:	54 61 73 6b 3a 20 00                                Task: .

000005c4 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5c4:	1b 5b 31 6d 00                                      .[1m.

000005c9 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5c9:	1b 5b 32 32 6d 00                                   .[22m.

000005cf <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5cf:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005da <_ZZ17print_task_stacksP8emstreamE3__c>:
     5da:	1b 5b 31 6d 00                                      .[1m.

000005df <_ZZ15print_task_listP8emstreamE3__c_9>:
     5df:	09 09 00                                            ...

000005e2 <_ZZ15print_task_listP8emstreamE3__c_8>:
     5e2:	2f 00                                               /.

000005e4 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5e4:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005ef <_ZZ15print_task_listP8emstreamE3__c_6>:
     5ef:	09 2d 2d 2d 2d 00                                   .----.

000005f5 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5f5:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000601 <_ZZ15print_task_listP8emstreamE3__c_4>:
     601:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000612 <_ZZ15print_task_listP8emstreamE3__c_3>:
     612:	09 52 75 6e 73 00                                   .Runs.

00000618 <_ZZ15print_task_listP8emstreamE3__c_2>:
     618:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000624 <_ZZ15print_task_listP8emstreamE3__c_1>:
     624:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000635 <_ZZ15print_task_listP8emstreamE3__c_0>:
     635:	09 53 74 61 63 6b 00                                .Stack.

0000063c <_ZZ15print_task_listP8emstreamE3__c>:
     63c:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000647 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     647:	09 00                                               ..

00000649 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     649:	09 00                                               ..

0000064b <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     64b:	2f 00                                               /.

0000064d <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     64d:	09 00                                               ..

0000064f <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     64f:	09 00                                               ..

00000651 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     651:	1b 5b 32 32 6d 00                                   .[22m.

00000657 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     657:	1b 5b 31 6d 00                                      .[1m.

0000065c <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     65c:	1b 5b 31 6d 00                                      .[1m.

00000661 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     661:	20 20 00                                              .

00000664 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     664:	0e 94 52 19 	call	0x32a4	; 0x32a4 <_ZN8frt_task22_call_users_run_methodEPS_>

00000668 <__ctors_start>:
     668:	88 25       	eor	r24, r8

0000066a <__ctors_end>:
     66a:	11 24       	eor	r1, r1
     66c:	1f be       	out	0x3f, r1	; 63
     66e:	cf ef       	ldi	r28, 0xFF	; 255
     670:	cd bf       	out	0x3d, r28	; 61
     672:	df e3       	ldi	r29, 0x3F	; 63
     674:	de bf       	out	0x3e, r29	; 62
     676:	00 e0       	ldi	r16, 0x00	; 0
     678:	0c bf       	out	0x3c, r16	; 60
     67a:	18 be       	out	0x38, r1	; 56
     67c:	19 be       	out	0x39, r1	; 57
     67e:	1a be       	out	0x3a, r1	; 58
     680:	1b be       	out	0x3b, r1	; 59

00000682 <__do_copy_data>:
     682:	12 e2       	ldi	r17, 0x22	; 34
     684:	a0 e0       	ldi	r26, 0x00	; 0
     686:	b0 e2       	ldi	r27, 0x20	; 32
     688:	e8 ef       	ldi	r30, 0xF8	; 248
     68a:	fd e4       	ldi	r31, 0x4D	; 77
     68c:	00 e0       	ldi	r16, 0x00	; 0
     68e:	0b bf       	out	0x3b, r16	; 59
     690:	02 c0       	rjmp	.+4      	; 0x696 <__do_copy_data+0x14>
     692:	07 90       	elpm	r0, Z+
     694:	0d 92       	st	X+, r0
     696:	a8 3a       	cpi	r26, 0xA8	; 168
     698:	b1 07       	cpc	r27, r17
     69a:	d9 f7       	brne	.-10     	; 0x692 <__do_copy_data+0x10>
     69c:	1b be       	out	0x3b, r1	; 59

0000069e <__do_clear_bss>:
     69e:	23 e3       	ldi	r18, 0x33	; 51
     6a0:	a8 ea       	ldi	r26, 0xA8	; 168
     6a2:	b2 e2       	ldi	r27, 0x22	; 34
     6a4:	01 c0       	rjmp	.+2      	; 0x6a8 <.do_clear_bss_start>

000006a6 <.do_clear_bss_loop>:
     6a6:	1d 92       	st	X+, r1

000006a8 <.do_clear_bss_start>:
     6a8:	a6 37       	cpi	r26, 0x76	; 118
     6aa:	b2 07       	cpc	r27, r18
     6ac:	e1 f7       	brne	.-8      	; 0x6a6 <.do_clear_bss_loop>

000006ae <__do_global_ctors>:
     6ae:	13 e0       	ldi	r17, 0x03	; 3
     6b0:	c5 e3       	ldi	r28, 0x35	; 53
     6b2:	d3 e0       	ldi	r29, 0x03	; 3
     6b4:	00 e0       	ldi	r16, 0x00	; 0
     6b6:	06 c0       	rjmp	.+12     	; 0x6c4 <__do_global_ctors+0x16>
     6b8:	21 97       	sbiw	r28, 0x01	; 1
     6ba:	01 09       	sbc	r16, r1
     6bc:	80 2f       	mov	r24, r16
     6be:	fe 01       	movw	r30, r28
     6c0:	0e 94 56 26 	call	0x4cac	; 0x4cac <__tablejump2__>
     6c4:	c4 33       	cpi	r28, 0x34	; 52
     6c6:	d1 07       	cpc	r29, r17
     6c8:	80 e0       	ldi	r24, 0x00	; 0
     6ca:	08 07       	cpc	r16, r24
     6cc:	a9 f7       	brne	.-22     	; 0x6b8 <__do_global_ctors+0xa>
     6ce:	0e 94 03 25 	call	0x4a06	; 0x4a06 <main>
     6d2:	0c 94 fa 26 	jmp	0x4df4	; 0x4df4 <_exit>

000006d6 <__bad_interrupt>:
     6d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006da <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6da:	bc 01       	movw	r22, r24
     6dc:	6e 5f       	subi	r22, 0xFE	; 254
     6de:	7f 4f       	sbci	r23, 0xFF	; 255
     6e0:	dc 01       	movw	r26, r24
     6e2:	ed 91       	ld	r30, X+
     6e4:	fc 91       	ld	r31, X
     6e6:	00 84       	ldd	r0, Z+8	; 0x08
     6e8:	f1 85       	ldd	r31, Z+9	; 0x09
     6ea:	e0 2d       	mov	r30, r0
     6ec:	19 95       	eicall
     6ee:	08 95       	ret

000006f0 <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6f0:	ef 92       	push	r14
     6f2:	ff 92       	push	r15
     6f4:	0f 93       	push	r16
     6f6:	1f 93       	push	r17
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	ec 01       	movw	r28, r24
     6fe:	7b 01       	movw	r14, r22
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
  Receiver *    getReceiver()     { return receiver_; }
  TWI_t *       getInterfacePtr() { return interface_; }
  emstream *    getSerial()       { return p_serial; }
     700:	ea 8d       	ldd	r30, Y+26	; 0x1a
     702:	fb 8d       	ldd	r31, Y+27	; 0x1b
     704:	06 81       	ldd	r16, Z+6	; 0x06
     706:	17 81       	ldd	r17, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     708:	66 e0       	ldi	r22, 0x06	; 6
     70a:	70 e2       	ldi	r23, 0x20	; 32
     70c:	c8 01       	movw	r24, r16
     70e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
  *(driver_->getSerial()) << "trans" << endl;
     712:	66 e0       	ldi	r22, 0x06	; 6
     714:	c8 01       	movw	r24, r16
     716:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
  writePacket(cmd);
     71a:	e8 81       	ld	r30, Y
     71c:	f9 81       	ldd	r31, Y+1	; 0x01
     71e:	04 80       	ldd	r0, Z+4	; 0x04
     720:	f5 81       	ldd	r31, Z+5	; 0x05
     722:	e0 2d       	mov	r30, r0
     724:	b7 01       	movw	r22, r14
     726:	ce 01       	movw	r24, r28
     728:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     72a:	be 01       	movw	r22, r28
     72c:	63 5f       	subi	r22, 0xF3	; 243
     72e:	7f 4f       	sbci	r23, 0xFF	; 255
  };

  // I2CMaster(TWI_t * interface, uint32_t i2c_freq);
  I2CMaster(TWI_t * interface, uint32_t i2c_freq, emstream * s);

  Transmitter * getTransmitter()  { return transmitter_; }
     730:	ea 8d       	ldd	r30, Y+26	; 0x1a
     732:	fb 8d       	ldd	r31, Y+27	; 0x1b
     734:	80 81       	ld	r24, Z
     736:	91 81       	ldd	r25, Z+1	; 0x01
     738:	0e 94 a0 07 	call	0xf40	; 0xf40 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     73c:	df 91       	pop	r29
     73e:	cf 91       	pop	r28
     740:	1f 91       	pop	r17
     742:	0f 91       	pop	r16
     744:	ff 90       	pop	r15
     746:	ef 90       	pop	r14
     748:	08 95       	ret

0000074a <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     74a:	ef 92       	push	r14
     74c:	ff 92       	push	r15
     74e:	0f 93       	push	r16
     750:	cf 93       	push	r28
     752:	df 93       	push	r29
     754:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     756:	7c 01       	movw	r14, r24
     758:	82 e0       	ldi	r24, 0x02	; 2
     75a:	e8 0e       	add	r14, r24
     75c:	f1 1c       	adc	r15, r1
     75e:	e8 81       	ld	r30, Y
     760:	f9 81       	ldd	r31, Y+1	; 0x01
     762:	00 84       	ldd	r0, Z+8	; 0x08
     764:	f1 85       	ldd	r31, Z+9	; 0x09
     766:	e0 2d       	mov	r30, r0
     768:	b7 01       	movw	r22, r14
     76a:	ce 01       	movw	r24, r28
     76c:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     76e:	28 85       	ldd	r18, Y+8	; 0x08
     770:	39 85       	ldd	r19, Y+9	; 0x09
     772:	4a 85       	ldd	r20, Y+10	; 0x0a
     774:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     776:	be 01       	movw	r22, r28
     778:	62 5e       	subi	r22, 0xE2	; 226
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	00 e0       	ldi	r16, 0x00	; 0
     77e:	8e 81       	ldd	r24, Y+6	; 0x06
     780:	9f 81       	ldd	r25, Y+7	; 0x07
     782:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     786:	ea 8d       	ldd	r30, Y+26	; 0x1a
     788:	fb 8d       	ldd	r31, Y+27	; 0x1b
  return driver_->getReceiver()->run(inPacket_);
     78a:	b7 01       	movw	r22, r14
     78c:	82 81       	ldd	r24, Z+2	; 0x02
     78e:	93 81       	ldd	r25, Z+3	; 0x03
     790:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	0f 91       	pop	r16
     79a:	ff 90       	pop	r15
     79c:	ef 90       	pop	r14
     79e:	08 95       	ret

000007a0 <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     7a0:	cf 92       	push	r12
     7a2:	df 92       	push	r13
     7a4:	ef 92       	push	r14
     7a6:	ff 92       	push	r15
     7a8:	0f 93       	push	r16
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
     7ae:	ec 01       	movw	r28, r24
     7b0:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     7b2:	6c 01       	movw	r12, r24
     7b4:	8d e0       	ldi	r24, 0x0D	; 13
     7b6:	c8 0e       	add	r12, r24
     7b8:	d1 1c       	adc	r13, r1
     7ba:	e8 81       	ld	r30, Y
     7bc:	f9 81       	ldd	r31, Y+1	; 0x01
     7be:	00 84       	ldd	r0, Z+8	; 0x08
     7c0:	f1 85       	ldd	r31, Z+9	; 0x09
     7c2:	e0 2d       	mov	r30, r0
     7c4:	b6 01       	movw	r22, r12
     7c6:	ce 01       	movw	r24, r28
     7c8:	19 95       	eicall
     7ca:	2b 89       	ldd	r18, Y+19	; 0x13
     7cc:	3c 89       	ldd	r19, Y+20	; 0x14
     7ce:	4d 89       	ldd	r20, Y+21	; 0x15
     7d0:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7d2:	be 01       	movw	r22, r28
     7d4:	63 5e       	subi	r22, 0xE3	; 227
     7d6:	7f 4f       	sbci	r23, 0xFF	; 255
     7d8:	00 e0       	ldi	r16, 0x00	; 0
     7da:	89 89       	ldd	r24, Y+17	; 0x11
     7dc:	9a 89       	ldd	r25, Y+18	; 0x12
     7de:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7e2:	d7 01       	movw	r26, r14
     7e4:	ed 91       	ld	r30, X+
     7e6:	fc 91       	ld	r31, X
     7e8:	01 90       	ld	r0, Z+
     7ea:	f0 81       	ld	r31, Z
     7ec:	e0 2d       	mov	r30, r0
     7ee:	b6 01       	movw	r22, r12
     7f0:	c7 01       	movw	r24, r14
     7f2:	19 95       	eicall
}
     7f4:	df 91       	pop	r29
     7f6:	cf 91       	pop	r28
     7f8:	0f 91       	pop	r16
     7fa:	ff 90       	pop	r15
     7fc:	ef 90       	pop	r14
     7fe:	df 90       	pop	r13
     800:	cf 90       	pop	r12
     802:	08 95       	ret

00000804 <_ZN8I2CAgent11resetPacketER6Packet>:
{
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
     804:	cb 01       	movw	r24, r22
  packet.resetContent();
     806:	0e 94 34 0b 	call	0x1668	; 0x1668 <_ZN6Packet12resetContentEv>
     80a:	08 95       	ret

0000080c <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     80c:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     80e:	64 8f       	std	Z+28, r22	; 0x1c
  writeCommand_ = addr << 1;
     810:	86 2f       	mov	r24, r22
     812:	88 0f       	add	r24, r24
     814:	85 8f       	std	Z+29, r24	; 0x1d
  readCommand_ = addr << 1 | 1 << 0;
     816:	68 2f       	mov	r22, r24
     818:	61 60       	ori	r22, 0x01	; 1
     81a:	66 8f       	std	Z+30, r22	; 0x1e
     81c:	08 95       	ret

0000081e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:
  }
  else
  {
    return false;
  }
}
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	1f 92       	push	r1
     824:	1f 92       	push	r1
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	fc 01       	movw	r30, r24
     82c:	81 85       	ldd	r24, Z+9	; 0x09
     82e:	92 85       	ldd	r25, Z+10	; 0x0a
     830:	89 83       	std	Y+1, r24	; 0x01
     832:	9a 83       	std	Y+2, r25	; 0x02
     834:	29 81       	ldd	r18, Y+1	; 0x01
     836:	3a 81       	ldd	r19, Y+2	; 0x02
     838:	21 50       	subi	r18, 0x01	; 1
     83a:	31 09       	sbc	r19, r1
     83c:	29 83       	std	Y+1, r18	; 0x01
     83e:	3a 83       	std	Y+2, r19	; 0x02
     840:	23 2b       	or	r18, r19
     842:	41 f0       	breq	.+16     	; 0x854 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x36>
     844:	a7 81       	ldd	r26, Z+7	; 0x07
     846:	b0 85       	ldd	r27, Z+8	; 0x08
     848:	14 96       	adiw	r26, 0x04	; 4
     84a:	0d 90       	ld	r0, X+
     84c:	bc 91       	ld	r27, X
     84e:	a0 2d       	mov	r26, r0
     850:	14 96       	adiw	r26, 0x04	; 4
     852:	8c 91       	ld	r24, X
     854:	a7 81       	ldd	r26, Z+7	; 0x07
     856:	b0 85       	ldd	r27, Z+8	; 0x08
     858:	14 96       	adiw	r26, 0x04	; 4
     85a:	0d 90       	ld	r0, X+
     85c:	bc 91       	ld	r27, X
     85e:	a0 2d       	mov	r26, r0
     860:	14 96       	adiw	r26, 0x04	; 4
     862:	8c 91       	ld	r24, X
     864:	84 81       	ldd	r24, Z+4	; 0x04
     866:	95 81       	ldd	r25, Z+5	; 0x05
     868:	0f 90       	pop	r0
     86a:	0f 90       	pop	r0
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	1f 92       	push	r1
     878:	1f 92       	push	r1
     87a:	cd b7       	in	r28, 0x3d	; 61
     87c:	de b7       	in	r29, 0x3e	; 62
     87e:	fc 01       	movw	r30, r24
     880:	81 85       	ldd	r24, Z+9	; 0x09
     882:	92 85       	ldd	r25, Z+10	; 0x0a
     884:	89 83       	std	Y+1, r24	; 0x01
     886:	9a 83       	std	Y+2, r25	; 0x02
     888:	29 81       	ldd	r18, Y+1	; 0x01
     88a:	3a 81       	ldd	r19, Y+2	; 0x02
     88c:	21 50       	subi	r18, 0x01	; 1
     88e:	31 09       	sbc	r19, r1
     890:	29 83       	std	Y+1, r18	; 0x01
     892:	3a 83       	std	Y+2, r19	; 0x02
     894:	23 2b       	or	r18, r19
     896:	41 f0       	breq	.+16     	; 0x8a8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x36>
     898:	a7 81       	ldd	r26, Z+7	; 0x07
     89a:	b0 85       	ldd	r27, Z+8	; 0x08
     89c:	14 96       	adiw	r26, 0x04	; 4
     89e:	0d 90       	ld	r0, X+
     8a0:	bc 91       	ld	r27, X
     8a2:	a0 2d       	mov	r26, r0
     8a4:	14 96       	adiw	r26, 0x04	; 4
     8a6:	8c 91       	ld	r24, X
     8a8:	a7 81       	ldd	r26, Z+7	; 0x07
     8aa:	b0 85       	ldd	r27, Z+8	; 0x08
     8ac:	14 96       	adiw	r26, 0x04	; 4
     8ae:	0d 90       	ld	r0, X+
     8b0:	bc 91       	ld	r27, X
     8b2:	a0 2d       	mov	r26, r0
     8b4:	14 96       	adiw	r26, 0x04	; 4
     8b6:	8c 91       	ld	r24, X
     8b8:	84 81       	ldd	r24, Z+4	; 0x04
     8ba:	95 81       	ldd	r25, Z+5	; 0x05
     8bc:	0f 90       	pop	r0
     8be:	0f 90       	pop	r0
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	08 95       	ret

000008c6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
     8ca:	ec 01       	movw	r28, r24
     8cc:	cb 01       	movw	r24, r22
     8ce:	db 01       	movw	r26, r22
     8d0:	ed 91       	ld	r30, X+
     8d2:	fc 91       	ld	r31, X
     8d4:	04 88       	ldd	r0, Z+20	; 0x14
     8d6:	f5 89       	ldd	r31, Z+21	; 0x15
     8d8:	e0 2d       	mov	r30, r0
     8da:	19 95       	eicall
     8dc:	88 23       	and	r24, r24
     8de:	19 f0       	breq	.+6      	; 0x8e6 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
     8e0:	8a 81       	ldd	r24, Y+2	; 0x02
     8e2:	9b 81       	ldd	r25, Y+3	; 0x03
     8e4:	02 c0       	rjmp	.+4      	; 0x8ea <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
     8e6:	8c 81       	ldd	r24, Y+4	; 0x04
     8e8:	9d 81       	ldd	r25, Y+5	; 0x05
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	08 95       	ret

000008f0 <_ZN9I2CMaster9DoneState7executeER6Packet>:
     8f0:	fc 01       	movw	r30, r24
     8f2:	82 81       	ldd	r24, Z+2	; 0x02
     8f4:	93 81       	ldd	r25, Z+3	; 0x03
     8f6:	08 95       	ret

000008f8 <_ZN9I2CMaster10ErrorState7executeER6Packet>:
     8f8:	fc 01       	movw	r30, r24
     8fa:	82 81       	ldd	r24, Z+2	; 0x02
     8fc:	93 81       	ldd	r25, Z+3	; 0x03
     8fe:	08 95       	ret

00000900 <_ZN9I2CMaster10ErrorState11serialDebugEv>:
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	dc 01       	movw	r26, r24
     906:	17 96       	adiw	r26, 0x07	; 7
     908:	ed 91       	ld	r30, X+
     90a:	fc 91       	ld	r31, X
     90c:	18 97       	sbiw	r26, 0x08	; 8
     90e:	c6 81       	ldd	r28, Z+6	; 0x06
     910:	d7 81       	ldd	r29, Z+7	; 0x07
     912:	6a e1       	ldi	r22, 0x1A	; 26
     914:	70 e2       	ldi	r23, 0x20	; 32
     916:	ce 01       	movw	r24, r28
     918:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     91c:	66 e0       	ldi	r22, 0x06	; 6
     91e:	ce 01       	movw	r24, r28
     920:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     924:	df 91       	pop	r29
     926:	cf 91       	pop	r28
     928:	08 95       	ret

0000092a <_ZN9I2CMaster9DoneState11serialDebugEv>:
     92a:	cf 93       	push	r28
     92c:	df 93       	push	r29
     92e:	dc 01       	movw	r26, r24
     930:	17 96       	adiw	r26, 0x07	; 7
     932:	ed 91       	ld	r30, X+
     934:	fc 91       	ld	r31, X
     936:	18 97       	sbiw	r26, 0x08	; 8
     938:	c6 81       	ldd	r28, Z+6	; 0x06
     93a:	d7 81       	ldd	r29, Z+7	; 0x07
     93c:	60 e2       	ldi	r22, 0x20	; 32
     93e:	70 e2       	ldi	r23, 0x20	; 32
     940:	ce 01       	movw	r24, r28
     942:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     946:	66 e0       	ldi	r22, 0x06	; 6
     948:	ce 01       	movw	r24, r28
     94a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	08 95       	ret

00000954 <_ZN9I2CMaster8Receiver17PacketStatusState11serialDebugEv>:
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	dc 01       	movw	r26, r24
     95a:	17 96       	adiw	r26, 0x07	; 7
     95c:	ed 91       	ld	r30, X+
     95e:	fc 91       	ld	r31, X
     960:	18 97       	sbiw	r26, 0x08	; 8
     962:	c6 81       	ldd	r28, Z+6	; 0x06
     964:	d7 81       	ldd	r29, Z+7	; 0x07
     966:	65 e2       	ldi	r22, 0x25	; 37
     968:	70 e2       	ldi	r23, 0x20	; 32
     96a:	ce 01       	movw	r24, r28
     96c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     970:	66 e0       	ldi	r22, 0x06	; 6
     972:	ce 01       	movw	r24, r28
     974:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	08 95       	ret

0000097e <_ZN9I2CMaster11Transmitter17PacketStatusState11serialDebugEv>:
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	dc 01       	movw	r26, r24
     984:	17 96       	adiw	r26, 0x07	; 7
     986:	ed 91       	ld	r30, X+
     988:	fc 91       	ld	r31, X
     98a:	18 97       	sbiw	r26, 0x08	; 8
     98c:	c6 81       	ldd	r28, Z+6	; 0x06
     98e:	d7 81       	ldd	r29, Z+7	; 0x07
     990:	6e e2       	ldi	r22, 0x2E	; 46
     992:	70 e2       	ldi	r23, 0x20	; 32
     994:	ce 01       	movw	r24, r28
     996:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     99a:	66 e0       	ldi	r22, 0x06	; 6
     99c:	ce 01       	movw	r24, r28
     99e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     9a2:	df 91       	pop	r29
     9a4:	cf 91       	pop	r28
     9a6:	08 95       	ret

000009a8 <_ZN9I2CMaster8Receiver13ExchangeState11serialDebugEv>:
     9a8:	cf 93       	push	r28
     9aa:	df 93       	push	r29
     9ac:	dc 01       	movw	r26, r24
     9ae:	17 96       	adiw	r26, 0x07	; 7
     9b0:	ed 91       	ld	r30, X+
     9b2:	fc 91       	ld	r31, X
     9b4:	18 97       	sbiw	r26, 0x08	; 8
     9b6:	c6 81       	ldd	r28, Z+6	; 0x06
     9b8:	d7 81       	ldd	r29, Z+7	; 0x07
     9ba:	67 e3       	ldi	r22, 0x37	; 55
     9bc:	70 e2       	ldi	r23, 0x20	; 32
     9be:	ce 01       	movw	r24, r28
     9c0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     9c4:	66 e0       	ldi	r22, 0x06	; 6
     9c6:	ce 01       	movw	r24, r28
     9c8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     9cc:	df 91       	pop	r29
     9ce:	cf 91       	pop	r28
     9d0:	08 95       	ret

000009d2 <_ZN9I2CMaster11Transmitter13ExchangeState11serialDebugEv>:
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	dc 01       	movw	r26, r24
     9d8:	17 96       	adiw	r26, 0x07	; 7
     9da:	ed 91       	ld	r30, X+
     9dc:	fc 91       	ld	r31, X
     9de:	18 97       	sbiw	r26, 0x08	; 8
     9e0:	c6 81       	ldd	r28, Z+6	; 0x06
     9e2:	d7 81       	ldd	r29, Z+7	; 0x07
     9e4:	62 e4       	ldi	r22, 0x42	; 66
     9e6:	70 e2       	ldi	r23, 0x20	; 32
     9e8:	ce 01       	movw	r24, r28
     9ea:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     9ee:	66 e0       	ldi	r22, 0x06	; 6
     9f0:	ce 01       	movw	r24, r28
     9f2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     9f6:	df 91       	pop	r29
     9f8:	cf 91       	pop	r28
     9fa:	08 95       	ret

000009fc <_ZN9I2CMaster10StartState11serialDebugEv>:
     9fc:	cf 93       	push	r28
     9fe:	df 93       	push	r29
     a00:	dc 01       	movw	r26, r24
     a02:	17 96       	adiw	r26, 0x07	; 7
     a04:	ed 91       	ld	r30, X+
     a06:	fc 91       	ld	r31, X
     a08:	18 97       	sbiw	r26, 0x08	; 8
     a0a:	c6 81       	ldd	r28, Z+6	; 0x06
     a0c:	d7 81       	ldd	r29, Z+7	; 0x07
     a0e:	6d e4       	ldi	r22, 0x4D	; 77
     a10:	70 e2       	ldi	r23, 0x20	; 32
     a12:	ce 01       	movw	r24, r28
     a14:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     a18:	66 e0       	ldi	r22, 0x06	; 6
     a1a:	ce 01       	movw	r24, r28
     a1c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	08 95       	ret

00000a26 <_ZN9I2CMaster11Transmitter11StatusState11serialDebugEv>:
     a26:	1f 93       	push	r17
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	dc 01       	movw	r26, r24
     a2e:	17 96       	adiw	r26, 0x07	; 7
     a30:	ed 91       	ld	r30, X+
     a32:	fc 91       	ld	r31, X
     a34:	18 97       	sbiw	r26, 0x08	; 8
     a36:	a4 81       	ldd	r26, Z+4	; 0x04
     a38:	b5 81       	ldd	r27, Z+5	; 0x05
     a3a:	14 96       	adiw	r26, 0x04	; 4
     a3c:	1c 91       	ld	r17, X
     a3e:	c6 81       	ldd	r28, Z+6	; 0x06
     a40:	d7 81       	ldd	r29, Z+7	; 0x07
     a42:	63 e5       	ldi	r22, 0x53	; 83
     a44:	70 e2       	ldi	r23, 0x20	; 32
     a46:	ce 01       	movw	r24, r28
     a48:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     a4c:	61 2f       	mov	r22, r17
     a4e:	ce 01       	movw	r24, r28
     a50:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
     a54:	66 e0       	ldi	r22, 0x06	; 6
     a56:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	1f 91       	pop	r17
     a60:	08 95       	ret

00000a62 <_ZN9I2CMaster8Receiver11StatusState11serialDebugEv>:
     a62:	1f 93       	push	r17
     a64:	cf 93       	push	r28
     a66:	df 93       	push	r29
     a68:	dc 01       	movw	r26, r24
     a6a:	17 96       	adiw	r26, 0x07	; 7
     a6c:	ed 91       	ld	r30, X+
     a6e:	fc 91       	ld	r31, X
     a70:	18 97       	sbiw	r26, 0x08	; 8
     a72:	a4 81       	ldd	r26, Z+4	; 0x04
     a74:	b5 81       	ldd	r27, Z+5	; 0x05
     a76:	14 96       	adiw	r26, 0x04	; 4
     a78:	1c 91       	ld	r17, X
     a7a:	c6 81       	ldd	r28, Z+6	; 0x06
     a7c:	d7 81       	ldd	r29, Z+7	; 0x07
     a7e:	6e e5       	ldi	r22, 0x5E	; 94
     a80:	70 e2       	ldi	r23, 0x20	; 32
     a82:	ce 01       	movw	r24, r28
     a84:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     a88:	61 2f       	mov	r22, r17
     a8a:	ce 01       	movw	r24, r28
     a8c:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
     a90:	66 e0       	ldi	r22, 0x06	; 6
     a92:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     a96:	df 91       	pop	r29
     a98:	cf 91       	pop	r28
     a9a:	1f 91       	pop	r17
     a9c:	08 95       	ret

00000a9e <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:
     a9e:	ef 92       	push	r14
     aa0:	ff 92       	push	r15
     aa2:	0f 93       	push	r16
     aa4:	1f 93       	push	r17
     aa6:	cf 93       	push	r28
     aa8:	df 93       	push	r29
     aaa:	8c 01       	movw	r16, r24
     aac:	eb 01       	movw	r28, r22
     aae:	e8 81       	ld	r30, Y
     ab0:	f9 81       	ldd	r31, Y+1	; 0x01
     ab2:	00 8c       	ldd	r0, Z+24	; 0x18
     ab4:	f1 8d       	ldd	r31, Z+25	; 0x19
     ab6:	e0 2d       	mov	r30, r0
     ab8:	cb 01       	movw	r24, r22
     aba:	19 95       	eicall
     abc:	88 23       	and	r24, r24
     abe:	41 f1       	breq	.+80     	; 0xb10 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x72>
     ac0:	e8 81       	ld	r30, Y
     ac2:	f9 81       	ldd	r31, Y+1	; 0x01
     ac4:	02 84       	ldd	r0, Z+10	; 0x0a
     ac6:	f3 85       	ldd	r31, Z+11	; 0x0b
     ac8:	e0 2d       	mov	r30, r0
     aca:	e1 2c       	mov	r14, r1
     acc:	f1 2c       	mov	r15, r1
     ace:	b7 01       	movw	r22, r14
     ad0:	ce 01       	movw	r24, r28
     ad2:	19 95       	eicall
     ad4:	d7 01       	movw	r26, r14
     ad6:	cc 91       	ld	r28, X
     ad8:	d8 01       	movw	r26, r16
     ada:	17 96       	adiw	r26, 0x07	; 7
     adc:	ed 91       	ld	r30, X+
     ade:	fc 91       	ld	r31, X
     ae0:	18 97       	sbiw	r26, 0x08	; 8
     ae2:	e6 80       	ldd	r14, Z+6	; 0x06
     ae4:	f7 80       	ldd	r15, Z+7	; 0x07
     ae6:	69 e6       	ldi	r22, 0x69	; 105
     ae8:	70 e2       	ldi	r23, 0x20	; 32
     aea:	c7 01       	movw	r24, r14
     aec:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     af0:	6c 2f       	mov	r22, r28
     af2:	c7 01       	movw	r24, r14
     af4:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
     af8:	66 e0       	ldi	r22, 0x06	; 6
     afa:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     afe:	d8 01       	movw	r26, r16
     b00:	17 96       	adiw	r26, 0x07	; 7
     b02:	ed 91       	ld	r30, X+
     b04:	fc 91       	ld	r31, X
     b06:	18 97       	sbiw	r26, 0x08	; 8
     b08:	04 80       	ldd	r0, Z+4	; 0x04
     b0a:	f5 81       	ldd	r31, Z+5	; 0x05
     b0c:	e0 2d       	mov	r30, r0
     b0e:	c7 83       	std	Z+7, r28	; 0x07
     b10:	f8 01       	movw	r30, r16
     b12:	82 81       	ldd	r24, Z+2	; 0x02
     b14:	93 81       	ldd	r25, Z+3	; 0x03
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	1f 91       	pop	r17
     b1c:	0f 91       	pop	r16
     b1e:	ff 90       	pop	r15
     b20:	ef 90       	pop	r14
     b22:	08 95       	ret

00000b24 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:
     b24:	bf 92       	push	r11
     b26:	cf 92       	push	r12
     b28:	df 92       	push	r13
     b2a:	ef 92       	push	r14
     b2c:	ff 92       	push	r15
     b2e:	0f 93       	push	r16
     b30:	1f 93       	push	r17
     b32:	cf 93       	push	r28
     b34:	df 93       	push	r29
     b36:	1f 92       	push	r1
     b38:	cd b7       	in	r28, 0x3d	; 61
     b3a:	de b7       	in	r29, 0x3e	; 62
     b3c:	8c 01       	movw	r16, r24
     b3e:	7b 01       	movw	r14, r22
     b40:	dc 01       	movw	r26, r24
     b42:	17 96       	adiw	r26, 0x07	; 7
     b44:	ed 91       	ld	r30, X+
     b46:	fc 91       	ld	r31, X
     b48:	18 97       	sbiw	r26, 0x08	; 8
     b4a:	a4 81       	ldd	r26, Z+4	; 0x04
     b4c:	b5 81       	ldd	r27, Z+5	; 0x05
     b4e:	17 96       	adiw	r26, 0x07	; 7
     b50:	bc 90       	ld	r11, X
     b52:	b9 82       	std	Y+1, r11	; 0x01
     b54:	c6 80       	ldd	r12, Z+6	; 0x06
     b56:	d7 80       	ldd	r13, Z+7	; 0x07
     b58:	6b e7       	ldi	r22, 0x7B	; 123
     b5a:	70 e2       	ldi	r23, 0x20	; 32
     b5c:	c6 01       	movw	r24, r12
     b5e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     b62:	6b 2d       	mov	r22, r11
     b64:	c6 01       	movw	r24, r12
     b66:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
     b6a:	66 e0       	ldi	r22, 0x06	; 6
     b6c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     b70:	d7 01       	movw	r26, r14
     b72:	ed 91       	ld	r30, X+
     b74:	fc 91       	ld	r31, X
     b76:	01 90       	ld	r0, Z+
     b78:	f0 81       	ld	r31, Z
     b7a:	e0 2d       	mov	r30, r0
     b7c:	be 01       	movw	r22, r28
     b7e:	6f 5f       	subi	r22, 0xFF	; 255
     b80:	7f 4f       	sbci	r23, 0xFF	; 255
     b82:	c7 01       	movw	r24, r14
     b84:	19 95       	eicall
     b86:	f8 01       	movw	r30, r16
     b88:	82 81       	ldd	r24, Z+2	; 0x02
     b8a:	93 81       	ldd	r25, Z+3	; 0x03
     b8c:	0f 90       	pop	r0
     b8e:	df 91       	pop	r29
     b90:	cf 91       	pop	r28
     b92:	1f 91       	pop	r17
     b94:	0f 91       	pop	r16
     b96:	ff 90       	pop	r15
     b98:	ef 90       	pop	r14
     b9a:	df 90       	pop	r13
     b9c:	cf 90       	pop	r12
     b9e:	bf 90       	pop	r11
     ba0:	08 95       	ret

00000ba2 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
     ba2:	0f 93       	push	r16
     ba4:	1f 93       	push	r17
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	8c 01       	movw	r16, r24
     bac:	eb 01       	movw	r28, r22
     bae:	e8 81       	ld	r30, Y
     bb0:	f9 81       	ldd	r31, Y+1	; 0x01
     bb2:	04 8c       	ldd	r0, Z+28	; 0x1c
     bb4:	f5 8d       	ldd	r31, Z+29	; 0x1d
     bb6:	e0 2d       	mov	r30, r0
     bb8:	cb 01       	movw	r24, r22
     bba:	19 95       	eicall
     bbc:	2a 85       	ldd	r18, Y+10	; 0x0a
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	82 17       	cp	r24, r18
     bc2:	93 07       	cpc	r25, r19
     bc4:	e9 f4       	brne	.+58     	; 0xc00 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
     bc6:	d8 01       	movw	r26, r16
     bc8:	17 96       	adiw	r26, 0x07	; 7
     bca:	ed 91       	ld	r30, X+
     bcc:	fc 91       	ld	r31, X
     bce:	18 97       	sbiw	r26, 0x08	; 8
     bd0:	04 80       	ldd	r0, Z+4	; 0x04
     bd2:	f5 81       	ldd	r31, Z+5	; 0x05
     bd4:	e0 2d       	mov	r30, r0
     bd6:	87 e0       	ldi	r24, 0x07	; 7
     bd8:	83 83       	std	Z+3, r24	; 0x03
     bda:	17 96       	adiw	r26, 0x07	; 7
     bdc:	ed 91       	ld	r30, X+
     bde:	fc 91       	ld	r31, X
     be0:	18 97       	sbiw	r26, 0x08	; 8
     be2:	c6 81       	ldd	r28, Z+6	; 0x06
     be4:	d7 81       	ldd	r29, Z+7	; 0x07
     be6:	6b e8       	ldi	r22, 0x8B	; 139
     be8:	70 e2       	ldi	r23, 0x20	; 32
     bea:	ce 01       	movw	r24, r28
     bec:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     bf0:	66 e0       	ldi	r22, 0x06	; 6
     bf2:	ce 01       	movw	r24, r28
     bf4:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     bf8:	f8 01       	movw	r30, r16
     bfa:	82 81       	ldd	r24, Z+2	; 0x02
     bfc:	93 81       	ldd	r25, Z+3	; 0x03
     bfe:	1c c0       	rjmp	.+56     	; 0xc38 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x96>
     c00:	d8 01       	movw	r26, r16
     c02:	17 96       	adiw	r26, 0x07	; 7
     c04:	ed 91       	ld	r30, X+
     c06:	fc 91       	ld	r31, X
     c08:	18 97       	sbiw	r26, 0x08	; 8
     c0a:	04 80       	ldd	r0, Z+4	; 0x04
     c0c:	f5 81       	ldd	r31, Z+5	; 0x05
     c0e:	e0 2d       	mov	r30, r0
     c10:	82 e0       	ldi	r24, 0x02	; 2
     c12:	83 83       	std	Z+3, r24	; 0x03
     c14:	17 96       	adiw	r26, 0x07	; 7
     c16:	ed 91       	ld	r30, X+
     c18:	fc 91       	ld	r31, X
     c1a:	18 97       	sbiw	r26, 0x08	; 8
     c1c:	c6 81       	ldd	r28, Z+6	; 0x06
     c1e:	d7 81       	ldd	r29, Z+7	; 0x07
     c20:	60 e9       	ldi	r22, 0x90	; 144
     c22:	70 e2       	ldi	r23, 0x20	; 32
     c24:	ce 01       	movw	r24, r28
     c26:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     c2a:	66 e0       	ldi	r22, 0x06	; 6
     c2c:	ce 01       	movw	r24, r28
     c2e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     c32:	f8 01       	movw	r30, r16
     c34:	84 81       	ldd	r24, Z+4	; 0x04
     c36:	95 81       	ldd	r25, Z+5	; 0x05
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	08 95       	ret

00000c42 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>:
     c42:	af 92       	push	r10
     c44:	bf 92       	push	r11
     c46:	cf 92       	push	r12
     c48:	df 92       	push	r13
     c4a:	ef 92       	push	r14
     c4c:	ff 92       	push	r15
     c4e:	0f 93       	push	r16
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
     c56:	ec 01       	movw	r28, r24
     c58:	8b 01       	movw	r16, r22
     c5a:	7a 01       	movw	r14, r20
     c5c:	68 83       	st	Y, r22
     c5e:	79 83       	std	Y+1, r23	; 0x01
     c60:	4a 83       	std	Y+2, r20	; 0x02
     c62:	5b 83       	std	Y+3, r21	; 0x03
     c64:	8b e0       	ldi	r24, 0x0B	; 11
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     c6c:	6c 01       	movw	r12, r24
     c6e:	fc 01       	movw	r30, r24
     c70:	16 82       	std	Z+6, r1	; 0x06
     c72:	8b e2       	ldi	r24, 0x2B	; 43
     c74:	91 e2       	ldi	r25, 0x21	; 33
     c76:	80 83       	st	Z, r24
     c78:	91 83       	std	Z+1, r25	; 0x01
     c7a:	07 83       	std	Z+7, r16	; 0x07
     c7c:	10 87       	std	Z+8, r17	; 0x08
     c7e:	e1 86       	std	Z+9, r14	; 0x09
     c80:	f2 86       	std	Z+10, r15	; 0x0a
     c82:	f8 01       	movw	r30, r16
     c84:	a6 80       	ldd	r10, Z+6	; 0x06
     c86:	b7 80       	ldd	r11, Z+7	; 0x07
     c88:	69 e9       	ldi	r22, 0x99	; 153
     c8a:	70 e2       	ldi	r23, 0x20	; 32
     c8c:	c5 01       	movw	r24, r10
     c8e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     c92:	b5 01       	movw	r22, r10
     c94:	c5 01       	movw	r24, r10
     c96:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
     c9a:	66 e0       	ldi	r22, 0x06	; 6
     c9c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     ca0:	ce 82       	std	Y+6, r12	; 0x06
     ca2:	df 82       	std	Y+7, r13	; 0x07
     ca4:	8b e0       	ldi	r24, 0x0B	; 11
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     cac:	fc 01       	movw	r30, r24
     cae:	8d 89       	ldd	r24, Y+21	; 0x15
     cb0:	9e 89       	ldd	r25, Y+22	; 0x16
     cb2:	16 82       	std	Z+6, r1	; 0x06
     cb4:	23 e3       	ldi	r18, 0x33	; 51
     cb6:	31 e2       	ldi	r19, 0x21	; 33
     cb8:	20 83       	st	Z, r18
     cba:	31 83       	std	Z+1, r19	; 0x01
     cbc:	07 83       	std	Z+7, r16	; 0x07
     cbe:	10 87       	std	Z+8, r17	; 0x08
     cc0:	81 87       	std	Z+9, r24	; 0x09
     cc2:	92 87       	std	Z+10, r25	; 0x0a
     cc4:	e8 87       	std	Y+8, r30	; 0x08
     cc6:	f9 87       	std	Y+9, r31	; 0x09
     cc8:	89 e0       	ldi	r24, 0x09	; 9
     cca:	90 e0       	ldi	r25, 0x00	; 0
     ccc:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     cd0:	fc 01       	movw	r30, r24
     cd2:	16 82       	std	Z+6, r1	; 0x06
     cd4:	83 e4       	ldi	r24, 0x43	; 67
     cd6:	91 e2       	ldi	r25, 0x21	; 33
     cd8:	80 83       	st	Z, r24
     cda:	91 83       	std	Z+1, r25	; 0x01
     cdc:	07 83       	std	Z+7, r16	; 0x07
     cde:	10 87       	std	Z+8, r17	; 0x08
     ce0:	ea 87       	std	Y+10, r30	; 0x0a
     ce2:	fb 87       	std	Y+11, r31	; 0x0b
     ce4:	89 e0       	ldi	r24, 0x09	; 9
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     cec:	fc 01       	movw	r30, r24
     cee:	16 82       	std	Z+6, r1	; 0x06
     cf0:	83 e5       	ldi	r24, 0x53	; 83
     cf2:	91 e2       	ldi	r25, 0x21	; 33
     cf4:	80 83       	st	Z, r24
     cf6:	91 83       	std	Z+1, r25	; 0x01
     cf8:	07 83       	std	Z+7, r16	; 0x07
     cfa:	10 87       	std	Z+8, r17	; 0x08
     cfc:	ec 87       	std	Y+12, r30	; 0x0c
     cfe:	fd 87       	std	Y+13, r31	; 0x0d
     d00:	89 e0       	ldi	r24, 0x09	; 9
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     d08:	fc 01       	movw	r30, r24
     d0a:	16 82       	std	Z+6, r1	; 0x06
     d0c:	8b e6       	ldi	r24, 0x6B	; 107
     d0e:	91 e2       	ldi	r25, 0x21	; 33
     d10:	80 83       	st	Z, r24
     d12:	91 83       	std	Z+1, r25	; 0x01
     d14:	07 83       	std	Z+7, r16	; 0x07
     d16:	10 87       	std	Z+8, r17	; 0x08
     d18:	ee 87       	std	Y+14, r30	; 0x0e
     d1a:	ff 87       	std	Y+15, r31	; 0x0f
     d1c:	89 e0       	ldi	r24, 0x09	; 9
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     d24:	fc 01       	movw	r30, r24
     d26:	16 82       	std	Z+6, r1	; 0x06
     d28:	83 e6       	ldi	r24, 0x63	; 99
     d2a:	91 e2       	ldi	r25, 0x21	; 33
     d2c:	80 83       	st	Z, r24
     d2e:	91 83       	std	Z+1, r25	; 0x01
     d30:	07 83       	std	Z+7, r16	; 0x07
     d32:	10 87       	std	Z+8, r17	; 0x08
     d34:	e8 8b       	std	Y+16, r30	; 0x10
     d36:	f9 8b       	std	Y+17, r31	; 0x11
     d38:	80 e1       	ldi	r24, 0x10	; 16
     d3a:	97 e2       	ldi	r25, 0x27	; 39
     d3c:	8d 8b       	std	Y+21, r24	; 0x15
     d3e:	9e 8b       	std	Y+22, r25	; 0x16
     d40:	62 eb       	ldi	r22, 0xB2	; 178
     d42:	70 e2       	ldi	r23, 0x20	; 32
     d44:	c7 01       	movw	r24, r14
     d46:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     d4a:	b8 01       	movw	r22, r16
     d4c:	c7 01       	movw	r24, r14
     d4e:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
     d52:	66 e0       	ldi	r22, 0x06	; 6
     d54:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     d58:	f8 01       	movw	r30, r16
     d5a:	06 81       	ldd	r16, Z+6	; 0x06
     d5c:	17 81       	ldd	r17, Z+7	; 0x07
     d5e:	6e ec       	ldi	r22, 0xCE	; 206
     d60:	70 e2       	ldi	r23, 0x20	; 32
     d62:	c7 01       	movw	r24, r14
     d64:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     d68:	b8 01       	movw	r22, r16
     d6a:	c7 01       	movw	r24, r14
     d6c:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
     d70:	66 e0       	ldi	r22, 0x06	; 6
     d72:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     d76:	64 ee       	ldi	r22, 0xE4	; 228
     d78:	70 e2       	ldi	r23, 0x20	; 32
     d7a:	c7 01       	movw	r24, r14
     d7c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     d80:	b7 01       	movw	r22, r14
     d82:	c7 01       	movw	r24, r14
     d84:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
     d88:	66 e0       	ldi	r22, 0x06	; 6
     d8a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     d8e:	88 85       	ldd	r24, Y+8	; 0x08
     d90:	99 85       	ldd	r25, Y+9	; 0x09
     d92:	ee 81       	ldd	r30, Y+6	; 0x06
     d94:	ff 81       	ldd	r31, Y+7	; 0x07
     d96:	82 83       	std	Z+2, r24	; 0x02
     d98:	93 83       	std	Z+3, r25	; 0x03
     d9a:	84 83       	std	Z+4, r24	; 0x04
     d9c:	95 83       	std	Z+5, r25	; 0x05
     d9e:	8e 85       	ldd	r24, Y+14	; 0x0e
     da0:	9f 85       	ldd	r25, Y+15	; 0x0f
     da2:	2a 85       	ldd	r18, Y+10	; 0x0a
     da4:	3b 85       	ldd	r19, Y+11	; 0x0b
     da6:	e8 85       	ldd	r30, Y+8	; 0x08
     da8:	f9 85       	ldd	r31, Y+9	; 0x09
     daa:	22 83       	std	Z+2, r18	; 0x02
     dac:	33 83       	std	Z+3, r19	; 0x03
     dae:	84 83       	std	Z+4, r24	; 0x04
     db0:	95 83       	std	Z+5, r25	; 0x05
     db2:	8c 85       	ldd	r24, Y+12	; 0x0c
     db4:	9d 85       	ldd	r25, Y+13	; 0x0d
     db6:	ea 85       	ldd	r30, Y+10	; 0x0a
     db8:	fb 85       	ldd	r31, Y+11	; 0x0b
     dba:	82 83       	std	Z+2, r24	; 0x02
     dbc:	93 83       	std	Z+3, r25	; 0x03
     dbe:	84 83       	std	Z+4, r24	; 0x04
     dc0:	95 83       	std	Z+5, r25	; 0x05
     dc2:	88 85       	ldd	r24, Y+8	; 0x08
     dc4:	99 85       	ldd	r25, Y+9	; 0x09
     dc6:	28 89       	ldd	r18, Y+16	; 0x10
     dc8:	39 89       	ldd	r19, Y+17	; 0x11
     dca:	ec 85       	ldd	r30, Y+12	; 0x0c
     dcc:	fd 85       	ldd	r31, Y+13	; 0x0d
     dce:	22 83       	std	Z+2, r18	; 0x02
     dd0:	33 83       	std	Z+3, r19	; 0x03
     dd2:	84 83       	std	Z+4, r24	; 0x04
     dd4:	95 83       	std	Z+5, r25	; 0x05
     dd6:	df 91       	pop	r29
     dd8:	cf 91       	pop	r28
     dda:	1f 91       	pop	r17
     ddc:	0f 91       	pop	r16
     dde:	ff 90       	pop	r15
     de0:	ef 90       	pop	r14
     de2:	df 90       	pop	r13
     de4:	cf 90       	pop	r12
     de6:	bf 90       	pop	r11
     de8:	af 90       	pop	r10
     dea:	08 95       	ret

00000dec <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>:
     dec:	cf 92       	push	r12
     dee:	df 92       	push	r13
     df0:	ef 92       	push	r14
     df2:	ff 92       	push	r15
     df4:	0f 93       	push	r16
     df6:	1f 93       	push	r17
     df8:	cf 93       	push	r28
     dfa:	df 93       	push	r29
     dfc:	ec 01       	movw	r28, r24
     dfe:	8b 01       	movw	r16, r22
     e00:	6a 01       	movw	r12, r20
     e02:	68 83       	st	Y, r22
     e04:	79 83       	std	Y+1, r23	; 0x01
     e06:	4a 83       	std	Y+2, r20	; 0x02
     e08:	5b 83       	std	Y+3, r21	; 0x03
     e0a:	8b e0       	ldi	r24, 0x0B	; 11
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     e12:	7c 01       	movw	r14, r24
     e14:	fc 01       	movw	r30, r24
     e16:	16 82       	std	Z+6, r1	; 0x06
     e18:	8b e2       	ldi	r24, 0x2B	; 43
     e1a:	91 e2       	ldi	r25, 0x21	; 33
     e1c:	80 83       	st	Z, r24
     e1e:	91 83       	std	Z+1, r25	; 0x01
     e20:	07 83       	std	Z+7, r16	; 0x07
     e22:	10 87       	std	Z+8, r17	; 0x08
     e24:	c1 86       	std	Z+9, r12	; 0x09
     e26:	d2 86       	std	Z+10, r13	; 0x0a
     e28:	f8 01       	movw	r30, r16
     e2a:	c6 80       	ldd	r12, Z+6	; 0x06
     e2c:	d7 80       	ldd	r13, Z+7	; 0x07
     e2e:	69 e9       	ldi	r22, 0x99	; 153
     e30:	70 e2       	ldi	r23, 0x20	; 32
     e32:	c6 01       	movw	r24, r12
     e34:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
     e38:	b6 01       	movw	r22, r12
     e3a:	c6 01       	movw	r24, r12
     e3c:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
     e40:	66 e0       	ldi	r22, 0x06	; 6
     e42:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
     e46:	ee 82       	std	Y+6, r14	; 0x06
     e48:	ff 82       	std	Y+7, r15	; 0x07
     e4a:	8b e0       	ldi	r24, 0x0B	; 11
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     e52:	fc 01       	movw	r30, r24
     e54:	8d 89       	ldd	r24, Y+21	; 0x15
     e56:	9e 89       	ldd	r25, Y+22	; 0x16
     e58:	16 82       	std	Z+6, r1	; 0x06
     e5a:	2b e3       	ldi	r18, 0x3B	; 59
     e5c:	31 e2       	ldi	r19, 0x21	; 33
     e5e:	20 83       	st	Z, r18
     e60:	31 83       	std	Z+1, r19	; 0x01
     e62:	07 83       	std	Z+7, r16	; 0x07
     e64:	10 87       	std	Z+8, r17	; 0x08
     e66:	81 87       	std	Z+9, r24	; 0x09
     e68:	92 87       	std	Z+10, r25	; 0x0a
     e6a:	e8 87       	std	Y+8, r30	; 0x08
     e6c:	f9 87       	std	Y+9, r31	; 0x09
     e6e:	89 e0       	ldi	r24, 0x09	; 9
     e70:	90 e0       	ldi	r25, 0x00	; 0
     e72:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     e76:	fc 01       	movw	r30, r24
     e78:	16 82       	std	Z+6, r1	; 0x06
     e7a:	8b e4       	ldi	r24, 0x4B	; 75
     e7c:	91 e2       	ldi	r25, 0x21	; 33
     e7e:	80 83       	st	Z, r24
     e80:	91 83       	std	Z+1, r25	; 0x01
     e82:	07 83       	std	Z+7, r16	; 0x07
     e84:	10 87       	std	Z+8, r17	; 0x08
     e86:	ea 87       	std	Y+10, r30	; 0x0a
     e88:	fb 87       	std	Y+11, r31	; 0x0b
     e8a:	89 e0       	ldi	r24, 0x09	; 9
     e8c:	90 e0       	ldi	r25, 0x00	; 0
     e8e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     e92:	fc 01       	movw	r30, r24
     e94:	16 82       	std	Z+6, r1	; 0x06
     e96:	8b e5       	ldi	r24, 0x5B	; 91
     e98:	91 e2       	ldi	r25, 0x21	; 33
     e9a:	80 83       	st	Z, r24
     e9c:	91 83       	std	Z+1, r25	; 0x01
     e9e:	07 83       	std	Z+7, r16	; 0x07
     ea0:	10 87       	std	Z+8, r17	; 0x08
     ea2:	ec 87       	std	Y+12, r30	; 0x0c
     ea4:	fd 87       	std	Y+13, r31	; 0x0d
     ea6:	89 e0       	ldi	r24, 0x09	; 9
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     eae:	fc 01       	movw	r30, r24
     eb0:	16 82       	std	Z+6, r1	; 0x06
     eb2:	8b e6       	ldi	r24, 0x6B	; 107
     eb4:	91 e2       	ldi	r25, 0x21	; 33
     eb6:	80 83       	st	Z, r24
     eb8:	91 83       	std	Z+1, r25	; 0x01
     eba:	07 83       	std	Z+7, r16	; 0x07
     ebc:	10 87       	std	Z+8, r17	; 0x08
     ebe:	ee 87       	std	Y+14, r30	; 0x0e
     ec0:	ff 87       	std	Y+15, r31	; 0x0f
     ec2:	89 e0       	ldi	r24, 0x09	; 9
     ec4:	90 e0       	ldi	r25, 0x00	; 0
     ec6:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
     eca:	fc 01       	movw	r30, r24
     ecc:	16 82       	std	Z+6, r1	; 0x06
     ece:	83 e6       	ldi	r24, 0x63	; 99
     ed0:	91 e2       	ldi	r25, 0x21	; 33
     ed2:	80 83       	st	Z, r24
     ed4:	91 83       	std	Z+1, r25	; 0x01
     ed6:	07 83       	std	Z+7, r16	; 0x07
     ed8:	10 87       	std	Z+8, r17	; 0x08
     eda:	e8 8b       	std	Y+16, r30	; 0x10
     edc:	f9 8b       	std	Y+17, r31	; 0x11
     ede:	80 e1       	ldi	r24, 0x10	; 16
     ee0:	97 e2       	ldi	r25, 0x27	; 39
     ee2:	8d 8b       	std	Y+21, r24	; 0x15
     ee4:	9e 8b       	std	Y+22, r25	; 0x16
     ee6:	88 85       	ldd	r24, Y+8	; 0x08
     ee8:	99 85       	ldd	r25, Y+9	; 0x09
     eea:	ee 81       	ldd	r30, Y+6	; 0x06
     eec:	ff 81       	ldd	r31, Y+7	; 0x07
     eee:	82 83       	std	Z+2, r24	; 0x02
     ef0:	93 83       	std	Z+3, r25	; 0x03
     ef2:	84 83       	std	Z+4, r24	; 0x04
     ef4:	95 83       	std	Z+5, r25	; 0x05
     ef6:	8e 85       	ldd	r24, Y+14	; 0x0e
     ef8:	9f 85       	ldd	r25, Y+15	; 0x0f
     efa:	2a 85       	ldd	r18, Y+10	; 0x0a
     efc:	3b 85       	ldd	r19, Y+11	; 0x0b
     efe:	e8 85       	ldd	r30, Y+8	; 0x08
     f00:	f9 85       	ldd	r31, Y+9	; 0x09
     f02:	22 83       	std	Z+2, r18	; 0x02
     f04:	33 83       	std	Z+3, r19	; 0x03
     f06:	84 83       	std	Z+4, r24	; 0x04
     f08:	95 83       	std	Z+5, r25	; 0x05
     f0a:	8c 85       	ldd	r24, Y+12	; 0x0c
     f0c:	9d 85       	ldd	r25, Y+13	; 0x0d
     f0e:	ea 85       	ldd	r30, Y+10	; 0x0a
     f10:	fb 85       	ldd	r31, Y+11	; 0x0b
     f12:	82 83       	std	Z+2, r24	; 0x02
     f14:	93 83       	std	Z+3, r25	; 0x03
     f16:	84 83       	std	Z+4, r24	; 0x04
     f18:	95 83       	std	Z+5, r25	; 0x05
     f1a:	88 85       	ldd	r24, Y+8	; 0x08
     f1c:	99 85       	ldd	r25, Y+9	; 0x09
     f1e:	28 89       	ldd	r18, Y+16	; 0x10
     f20:	39 89       	ldd	r19, Y+17	; 0x11
     f22:	ec 85       	ldd	r30, Y+12	; 0x0c
     f24:	fd 85       	ldd	r31, Y+13	; 0x0d
     f26:	22 83       	std	Z+2, r18	; 0x02
     f28:	33 83       	std	Z+3, r19	; 0x03
     f2a:	84 83       	std	Z+4, r24	; 0x04
     f2c:	95 83       	std	Z+5, r25	; 0x05
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	1f 91       	pop	r17
     f34:	0f 91       	pop	r16
     f36:	ff 90       	pop	r15
     f38:	ef 90       	pop	r14
     f3a:	df 90       	pop	r13
     f3c:	cf 90       	pop	r12
     f3e:	08 95       	ret

00000f40 <_ZN9I2CMaster11Transmitter3runER6Packet>:
     f40:	0f 93       	push	r16
     f42:	1f 93       	push	r17
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	ec 01       	movw	r28, r24
     f4a:	8b 01       	movw	r16, r22
     f4c:	8e 81       	ldd	r24, Y+6	; 0x06
     f4e:	9f 81       	ldd	r25, Y+7	; 0x07
     f50:	dc 01       	movw	r26, r24
     f52:	ed 91       	ld	r30, X+
     f54:	fc 91       	ld	r31, X
     f56:	01 90       	ld	r0, Z+
     f58:	f0 81       	ld	r31, Z
     f5a:	e0 2d       	mov	r30, r0
     f5c:	19 95       	eicall
     f5e:	8e 81       	ldd	r24, Y+6	; 0x06
     f60:	9f 81       	ldd	r25, Y+7	; 0x07
     f62:	dc 01       	movw	r26, r24
     f64:	ed 91       	ld	r30, X+
     f66:	fc 91       	ld	r31, X
     f68:	02 80       	ldd	r0, Z+2	; 0x02
     f6a:	f3 81       	ldd	r31, Z+3	; 0x03
     f6c:	e0 2d       	mov	r30, r0
     f6e:	19 95       	eicall
     f70:	88 85       	ldd	r24, Y+8	; 0x08
     f72:	99 85       	ldd	r25, Y+9	; 0x09
     f74:	dc 01       	movw	r26, r24
     f76:	ed 91       	ld	r30, X+
     f78:	fc 91       	ld	r31, X
     f7a:	01 90       	ld	r0, Z+
     f7c:	f0 81       	ld	r31, Z
     f7e:	e0 2d       	mov	r30, r0
     f80:	b8 01       	movw	r22, r16
     f82:	19 95       	eicall
     f84:	88 85       	ldd	r24, Y+8	; 0x08
     f86:	99 85       	ldd	r25, Y+9	; 0x09
     f88:	dc 01       	movw	r26, r24
     f8a:	ed 91       	ld	r30, X+
     f8c:	fc 91       	ld	r31, X
     f8e:	02 80       	ldd	r0, Z+2	; 0x02
     f90:	f3 81       	ldd	r31, Z+3	; 0x03
     f92:	e0 2d       	mov	r30, r0
     f94:	19 95       	eicall
     f96:	8a 85       	ldd	r24, Y+10	; 0x0a
     f98:	9b 85       	ldd	r25, Y+11	; 0x0b
     f9a:	dc 01       	movw	r26, r24
     f9c:	ed 91       	ld	r30, X+
     f9e:	fc 91       	ld	r31, X
     fa0:	01 90       	ld	r0, Z+
     fa2:	f0 81       	ld	r31, Z
     fa4:	e0 2d       	mov	r30, r0
     fa6:	b8 01       	movw	r22, r16
     fa8:	19 95       	eicall
     faa:	88 85       	ldd	r24, Y+8	; 0x08
     fac:	99 85       	ldd	r25, Y+9	; 0x09
     fae:	dc 01       	movw	r26, r24
     fb0:	ed 91       	ld	r30, X+
     fb2:	fc 91       	ld	r31, X
     fb4:	02 80       	ldd	r0, Z+2	; 0x02
     fb6:	f3 81       	ldd	r31, Z+3	; 0x03
     fb8:	e0 2d       	mov	r30, r0
     fba:	19 95       	eicall
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	1f 91       	pop	r17
     fc4:	0f 91       	pop	r16
     fc6:	08 95       	ret

00000fc8 <_ZN9I2CMaster8Receiver3runER6Packet>:
     fc8:	0f 93       	push	r16
     fca:	1f 93       	push	r17
     fcc:	cf 93       	push	r28
     fce:	df 93       	push	r29
     fd0:	ec 01       	movw	r28, r24
     fd2:	8b 01       	movw	r16, r22
     fd4:	8e 81       	ldd	r24, Y+6	; 0x06
     fd6:	9f 81       	ldd	r25, Y+7	; 0x07
     fd8:	dc 01       	movw	r26, r24
     fda:	ed 91       	ld	r30, X+
     fdc:	fc 91       	ld	r31, X
     fde:	01 90       	ld	r0, Z+
     fe0:	f0 81       	ld	r31, Z
     fe2:	e0 2d       	mov	r30, r0
     fe4:	19 95       	eicall
     fe6:	8e 81       	ldd	r24, Y+6	; 0x06
     fe8:	9f 81       	ldd	r25, Y+7	; 0x07
     fea:	dc 01       	movw	r26, r24
     fec:	ed 91       	ld	r30, X+
     fee:	fc 91       	ld	r31, X
     ff0:	02 80       	ldd	r0, Z+2	; 0x02
     ff2:	f3 81       	ldd	r31, Z+3	; 0x03
     ff4:	e0 2d       	mov	r30, r0
     ff6:	19 95       	eicall
     ff8:	88 85       	ldd	r24, Y+8	; 0x08
     ffa:	99 85       	ldd	r25, Y+9	; 0x09
     ffc:	dc 01       	movw	r26, r24
     ffe:	ed 91       	ld	r30, X+
    1000:	fc 91       	ld	r31, X
    1002:	01 90       	ld	r0, Z+
    1004:	f0 81       	ld	r31, Z
    1006:	e0 2d       	mov	r30, r0
    1008:	b8 01       	movw	r22, r16
    100a:	19 95       	eicall
    100c:	88 85       	ldd	r24, Y+8	; 0x08
    100e:	99 85       	ldd	r25, Y+9	; 0x09
    1010:	dc 01       	movw	r26, r24
    1012:	ed 91       	ld	r30, X+
    1014:	fc 91       	ld	r31, X
    1016:	02 80       	ldd	r0, Z+2	; 0x02
    1018:	f3 81       	ldd	r31, Z+3	; 0x03
    101a:	e0 2d       	mov	r30, r0
    101c:	19 95       	eicall
    101e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1020:	9b 85       	ldd	r25, Y+11	; 0x0b
    1022:	dc 01       	movw	r26, r24
    1024:	ed 91       	ld	r30, X+
    1026:	fc 91       	ld	r31, X
    1028:	01 90       	ld	r0, Z+
    102a:	f0 81       	ld	r31, Z
    102c:	e0 2d       	mov	r30, r0
    102e:	b8 01       	movw	r22, r16
    1030:	19 95       	eicall
    1032:	88 85       	ldd	r24, Y+8	; 0x08
    1034:	99 85       	ldd	r25, Y+9	; 0x09
    1036:	dc 01       	movw	r26, r24
    1038:	ed 91       	ld	r30, X+
    103a:	fc 91       	ld	r31, X
    103c:	02 80       	ldd	r0, Z+2	; 0x02
    103e:	f3 81       	ldd	r31, Z+3	; 0x03
    1040:	e0 2d       	mov	r30, r0
    1042:	19 95       	eicall
    1044:	8c 85       	ldd	r24, Y+12	; 0x0c
    1046:	9d 85       	ldd	r25, Y+13	; 0x0d
    1048:	dc 01       	movw	r26, r24
    104a:	ed 91       	ld	r30, X+
    104c:	fc 91       	ld	r31, X
    104e:	01 90       	ld	r0, Z+
    1050:	f0 81       	ld	r31, Z
    1052:	e0 2d       	mov	r30, r0
    1054:	b8 01       	movw	r22, r16
    1056:	19 95       	eicall
    1058:	88 85       	ldd	r24, Y+8	; 0x08
    105a:	99 85       	ldd	r25, Y+9	; 0x09
    105c:	dc 01       	movw	r26, r24
    105e:	ed 91       	ld	r30, X+
    1060:	fc 91       	ld	r31, X
    1062:	02 80       	ldd	r0, Z+2	; 0x02
    1064:	f3 81       	ldd	r31, Z+3	; 0x03
    1066:	e0 2d       	mov	r30, r0
    1068:	19 95       	eicall
    106a:	88 85       	ldd	r24, Y+8	; 0x08
    106c:	99 85       	ldd	r25, Y+9	; 0x09
    106e:	dc 01       	movw	r26, r24
    1070:	ed 91       	ld	r30, X+
    1072:	fc 91       	ld	r31, X
    1074:	01 90       	ld	r0, Z+
    1076:	f0 81       	ld	r31, Z
    1078:	e0 2d       	mov	r30, r0
    107a:	b8 01       	movw	r22, r16
    107c:	19 95       	eicall
    107e:	88 85       	ldd	r24, Y+8	; 0x08
    1080:	99 85       	ldd	r25, Y+9	; 0x09
    1082:	dc 01       	movw	r26, r24
    1084:	ed 91       	ld	r30, X+
    1086:	fc 91       	ld	r31, X
    1088:	02 80       	ldd	r0, Z+2	; 0x02
    108a:	f3 81       	ldd	r31, Z+3	; 0x03
    108c:	e0 2d       	mov	r30, r0
    108e:	19 95       	eicall
    1090:	8a 85       	ldd	r24, Y+10	; 0x0a
    1092:	9b 85       	ldd	r25, Y+11	; 0x0b
    1094:	dc 01       	movw	r26, r24
    1096:	ed 91       	ld	r30, X+
    1098:	fc 91       	ld	r31, X
    109a:	01 90       	ld	r0, Z+
    109c:	f0 81       	ld	r31, Z
    109e:	e0 2d       	mov	r30, r0
    10a0:	b8 01       	movw	r22, r16
    10a2:	19 95       	eicall
    10a4:	88 85       	ldd	r24, Y+8	; 0x08
    10a6:	99 85       	ldd	r25, Y+9	; 0x09
    10a8:	dc 01       	movw	r26, r24
    10aa:	ed 91       	ld	r30, X+
    10ac:	fc 91       	ld	r31, X
    10ae:	02 80       	ldd	r0, Z+2	; 0x02
    10b0:	f3 81       	ldd	r31, Z+3	; 0x03
    10b2:	e0 2d       	mov	r30, r0
    10b4:	19 95       	eicall
    10b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    10b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    10ba:	dc 01       	movw	r26, r24
    10bc:	ed 91       	ld	r30, X+
    10be:	fc 91       	ld	r31, X
    10c0:	01 90       	ld	r0, Z+
    10c2:	f0 81       	ld	r31, Z
    10c4:	e0 2d       	mov	r30, r0
    10c6:	b8 01       	movw	r22, r16
    10c8:	19 95       	eicall
    10ca:	88 85       	ldd	r24, Y+8	; 0x08
    10cc:	99 85       	ldd	r25, Y+9	; 0x09
    10ce:	dc 01       	movw	r26, r24
    10d0:	ed 91       	ld	r30, X+
    10d2:	fc 91       	ld	r31, X
    10d4:	02 80       	ldd	r0, Z+2	; 0x02
    10d6:	f3 81       	ldd	r31, Z+3	; 0x03
    10d8:	e0 2d       	mov	r30, r0
    10da:	19 95       	eicall
    10dc:	c8 01       	movw	r24, r16
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	08 95       	ret

000010e8 <_ZN9I2CMaster12set_baudrateEm>:
    10e8:	cf 93       	push	r28
    10ea:	df 93       	push	r29
    10ec:	ec 01       	movw	r28, r24
    10ee:	9a 01       	movw	r18, r20
    10f0:	ab 01       	movw	r20, r22
    10f2:	22 0f       	add	r18, r18
    10f4:	33 1f       	adc	r19, r19
    10f6:	44 1f       	adc	r20, r20
    10f8:	55 1f       	adc	r21, r21
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	78 e4       	ldi	r23, 0x48	; 72
    10fe:	88 ee       	ldi	r24, 0xE8	; 232
    1100:	91 e0       	ldi	r25, 0x01	; 1
    1102:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    1106:	25 50       	subi	r18, 0x05	; 5
    1108:	2a 87       	std	Y+10, r18	; 0x0a
    110a:	ec 81       	ldd	r30, Y+4	; 0x04
    110c:	fd 81       	ldd	r31, Y+5	; 0x05
    110e:	25 83       	std	Z+5, r18	; 0x05
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	08 95       	ret

00001116 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>:
    1116:	ef 92       	push	r14
    1118:	ff 92       	push	r15
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	ec 01       	movw	r28, r24
    1124:	7b 01       	movw	r14, r22
    1126:	ba 01       	movw	r22, r20
    1128:	a9 01       	movw	r20, r18
    112a:	ec 82       	std	Y+4, r14	; 0x04
    112c:	fd 82       	std	Y+5, r15	; 0x05
    112e:	0e 83       	std	Y+6, r16	; 0x06
    1130:	1f 83       	std	Y+7, r17	; 0x07
    1132:	4b 87       	std	Y+11, r20	; 0x0b
    1134:	5c 87       	std	Y+12, r21	; 0x0c
    1136:	6d 87       	std	Y+13, r22	; 0x0d
    1138:	7e 87       	std	Y+14, r23	; 0x0e
    113a:	80 e8       	ldi	r24, 0x80	; 128
    113c:	e8 16       	cp	r14, r24
    113e:	84 e0       	ldi	r24, 0x04	; 4
    1140:	f8 06       	cpc	r15, r24
    1142:	29 f4       	brne	.+10     	; 0x114e <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x38>
    1144:	80 e4       	ldi	r24, 0x40	; 64
    1146:	96 e0       	ldi	r25, 0x06	; 6
    1148:	88 87       	std	Y+8, r24	; 0x08
    114a:	99 87       	std	Y+9, r25	; 0x09
    114c:	09 c0       	rjmp	.+18     	; 0x1160 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
    114e:	e0 ea       	ldi	r30, 0xA0	; 160
    1150:	ee 16       	cp	r14, r30
    1152:	e4 e0       	ldi	r30, 0x04	; 4
    1154:	fe 06       	cpc	r15, r30
    1156:	21 f4       	brne	.+8      	; 0x1160 <_ZN9I2CMasterC1EP10TWI_structmP8emstream+0x4a>
    1158:	80 e8       	ldi	r24, 0x80	; 128
    115a:	96 e0       	ldi	r25, 0x06	; 6
    115c:	88 87       	std	Y+8, r24	; 0x08
    115e:	99 87       	std	Y+9, r25	; 0x09
    1160:	e8 85       	ldd	r30, Y+8	; 0x08
    1162:	f9 85       	ldd	r31, Y+9	; 0x09
    1164:	83 e0       	ldi	r24, 0x03	; 3
    1166:	81 83       	std	Z+1, r24	; 0x01
    1168:	e8 85       	ldd	r30, Y+8	; 0x08
    116a:	f9 85       	ldd	r31, Y+9	; 0x09
    116c:	88 e3       	ldi	r24, 0x38	; 56
    116e:	80 8b       	std	Z+16, r24	; 0x10
    1170:	e8 85       	ldd	r30, Y+8	; 0x08
    1172:	f9 85       	ldd	r31, Y+9	; 0x09
    1174:	81 8b       	std	Z+17, r24	; 0x11
    1176:	82 e0       	ldi	r24, 0x02	; 2
    1178:	f7 01       	movw	r30, r14
    117a:	82 83       	std	Z+2, r24	; 0x02
    117c:	ce 01       	movw	r24, r28
    117e:	0e 94 74 08 	call	0x10e8	; 0x10e8 <_ZN9I2CMaster12set_baudrateEm>
    1182:	f7 01       	movw	r30, r14
    1184:	84 81       	ldd	r24, Z+4	; 0x04
    1186:	8d 6c       	ori	r24, 0xCD	; 205
    1188:	84 83       	std	Z+4, r24	; 0x04
    118a:	88 e0       	ldi	r24, 0x08	; 8
    118c:	81 83       	std	Z+1, r24	; 0x01
    118e:	6d ee       	ldi	r22, 0xED	; 237
    1190:	70 e2       	ldi	r23, 0x20	; 32
    1192:	c8 01       	movw	r24, r16
    1194:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1198:	be 01       	movw	r22, r28
    119a:	c8 01       	movw	r24, r16
    119c:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
    11a0:	66 e0       	ldi	r22, 0x06	; 6
    11a2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    11a6:	ee 80       	ldd	r14, Y+6	; 0x06
    11a8:	ff 80       	ldd	r15, Y+7	; 0x07
    11aa:	64 e0       	ldi	r22, 0x04	; 4
    11ac:	71 e2       	ldi	r23, 0x21	; 33
    11ae:	c8 01       	movw	r24, r16
    11b0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    11b4:	b7 01       	movw	r22, r14
    11b6:	c8 01       	movw	r24, r16
    11b8:	0e 94 11 1f 	call	0x3e22	; 0x3e22 <_ZN8emstreamlsEPv>
    11bc:	66 e0       	ldi	r22, 0x06	; 6
    11be:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    11c2:	87 e1       	ldi	r24, 0x17	; 23
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    11ca:	7c 01       	movw	r14, r24
    11cc:	a8 01       	movw	r20, r16
    11ce:	be 01       	movw	r22, r28
    11d0:	0e 94 21 06 	call	0xc42	; 0xc42 <_ZN9I2CMaster11TransmitterC1EPS_P8emstream>
    11d4:	e8 82       	st	Y, r14
    11d6:	f9 82       	std	Y+1, r15	; 0x01
    11d8:	88 e1       	ldi	r24, 0x18	; 24
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    11e0:	7c 01       	movw	r14, r24
    11e2:	a8 01       	movw	r20, r16
    11e4:	be 01       	movw	r22, r28
    11e6:	0e 94 f6 06 	call	0xdec	; 0xdec <_ZN9I2CMaster8ReceiverC1EPS_P8emstream>
    11ea:	ea 82       	std	Y+2, r14	; 0x02
    11ec:	fb 82       	std	Y+3, r15	; 0x03
    11ee:	0e 80       	ldd	r0, Y+6	; 0x06
    11f0:	df 81       	ldd	r29, Y+7	; 0x07
    11f2:	c0 2d       	mov	r28, r0
    11f4:	65 e1       	ldi	r22, 0x15	; 21
    11f6:	71 e2       	ldi	r23, 0x21	; 33
    11f8:	ce 01       	movw	r24, r28
    11fa:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    11fe:	66 e0       	ldi	r22, 0x06	; 6
    1200:	ce 01       	movw	r24, r28
    1202:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1206:	df 91       	pop	r29
    1208:	cf 91       	pop	r28
    120a:	1f 91       	pop	r17
    120c:	0f 91       	pop	r16
    120e:	ff 90       	pop	r15
    1210:	ef 90       	pop	r14
    1212:	08 95       	ret

00001214 <_ZN9I2CMaster10send_startEv>:


void I2CMaster::send_start(void)
{
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
    1214:	dc 01       	movw	r26, r24
    1216:	14 96       	adiw	r26, 0x04	; 4
    1218:	ed 91       	ld	r30, X+
    121a:	fc 91       	ld	r31, X
    121c:	15 97       	sbiw	r26, 0x05	; 5
    121e:	83 81       	ldd	r24, Z+3	; 0x03
    1220:	81 60       	ori	r24, 0x01	; 1
    1222:	83 83       	std	Z+3, r24	; 0x03
    1224:	08 95       	ret

00001226 <_ZN9I2CMaster10StartState7executeER6Packet>:
  statusState_->serialDebug();
  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
    1226:	0f 93       	push	r16
    1228:	1f 93       	push	r17
    122a:	cf 93       	push	r28
    122c:	df 93       	push	r29
    122e:	ec 01       	movw	r28, r24
    1230:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
    1232:	db 01       	movw	r26, r22
    1234:	ed 91       	ld	r30, X+
    1236:	fc 91       	ld	r31, X
    1238:	02 84       	ldd	r0, Z+10	; 0x0a
    123a:	f3 85       	ldd	r31, Z+11	; 0x0b
    123c:	e0 2d       	mov	r30, r0
    123e:	00 e0       	ldi	r16, 0x00	; 0
    1240:	10 e0       	ldi	r17, 0x00	; 0
    1242:	b8 01       	movw	r22, r16
    1244:	19 95       	eicall
  driver_->send_start();
    1246:	8f 81       	ldd	r24, Y+7	; 0x07
    1248:	98 85       	ldd	r25, Y+8	; 0x08
    124a:	0e 94 0a 09 	call	0x1214	; 0x1214 <_ZN9I2CMaster10send_startEv>
  TWI_t *       getInterfacePtr() { return interface_; }
    124e:	ef 81       	ldd	r30, Y+7	; 0x07
    1250:	f8 85       	ldd	r31, Y+8	; 0x08
    1252:	04 80       	ldd	r0, Z+4	; 0x04
    1254:	f5 81       	ldd	r31, Z+5	; 0x05
    1256:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
    1258:	d8 01       	movw	r26, r16
    125a:	8c 91       	ld	r24, X
    125c:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
    125e:	8a 81       	ldd	r24, Y+2	; 0x02
    1260:	9b 81       	ldd	r25, Y+3	; 0x03
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	1f 91       	pop	r17
    1268:	0f 91       	pop	r16
    126a:	08 95       	ret

0000126c <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready()
{
	return driver_->is_ready(slaveAddr_);
}
    126c:	db 01       	movw	r26, r22
    126e:	bc 01       	movw	r22, r24
    1270:	6e 5f       	subi	r22, 0xFE	; 254
    1272:	7f 4f       	sbci	r23, 0xFF	; 255
    1274:	ed 91       	ld	r30, X+
    1276:	fc 91       	ld	r31, X
    1278:	11 97       	sbiw	r26, 0x01	; 1
    127a:	01 90       	ld	r0, Z+
    127c:	f0 81       	ld	r31, Z
    127e:	e0 2d       	mov	r30, r0
    1280:	cd 01       	movw	r24, r26
    1282:	19 95       	eicall
    1284:	08 95       	ret

00001286 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
    1286:	fc 01       	movw	r30, r24
    1288:	84 81       	ldd	r24, Z+4	; 0x04
    128a:	95 81       	ldd	r25, Z+5	; 0x05
    128c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	08 95       	ret

00001294 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
    1294:	fc 01       	movw	r30, r24
    1296:	84 81       	ldd	r24, Z+4	; 0x04
    1298:	95 81       	ldd	r25, Z+5	; 0x05
    129a:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    129e:	91 e0       	ldi	r25, 0x01	; 1
    12a0:	81 11       	cpse	r24, r1
    12a2:	01 c0       	rjmp	.+2      	; 0x12a6 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
    12a4:	90 e0       	ldi	r25, 0x00	; 0
    12a6:	89 2f       	mov	r24, r25
    12a8:	08 95       	ret

000012aa <_ZN9frt_queueIhE12ISR_is_emptyEv>:
    12aa:	fc 01       	movw	r30, r24
    12ac:	84 81       	ldd	r24, Z+4	; 0x04
    12ae:	95 81       	ldd	r25, Z+5	; 0x05
    12b0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    12b4:	91 e0       	ldi	r25, 0x01	; 1
    12b6:	81 11       	cpse	r24, r1
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	89 2f       	mov	r24, r25
    12bc:	08 95       	ret

000012be <_ZN9frt_queueIhE12num_items_inEv>:
    12be:	fc 01       	movw	r30, r24
    12c0:	84 81       	ldd	r24, Z+4	; 0x04
    12c2:	95 81       	ldd	r25, Z+5	; 0x05
    12c4:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	08 95       	ret

000012cc <_ZN9frt_queueIhE9not_emptyEv>:
    12cc:	fc 01       	movw	r30, r24
    12ce:	84 81       	ldd	r24, Z+4	; 0x04
    12d0:	95 81       	ldd	r25, Z+5	; 0x05
    12d2:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    12d6:	91 e0       	ldi	r25, 0x01	; 1
    12d8:	81 11       	cpse	r24, r1
    12da:	01 c0       	rjmp	.+2      	; 0x12de <_ZN9frt_queueIhE9not_emptyEv+0x12>
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	89 2f       	mov	r24, r25
    12e0:	08 95       	ret

000012e2 <_ZN9frt_queueIhE8is_emptyEv>:
    12e2:	fc 01       	movw	r30, r24
    12e4:	84 81       	ldd	r24, Z+4	; 0x04
    12e6:	95 81       	ldd	r25, Z+5	; 0x05
    12e8:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    12ec:	91 e0       	ldi	r25, 0x01	; 1
    12ee:	81 11       	cpse	r24, r1
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	89 2f       	mov	r24, r25
    12f4:	08 95       	ret

000012f6 <_ZN9frt_queueIhE10get_a_copyERh>:
    12f6:	0f 93       	push	r16
    12f8:	01 e0       	ldi	r16, 0x01	; 1
    12fa:	2f ef       	ldi	r18, 0xFF	; 255
    12fc:	3f ef       	ldi	r19, 0xFF	; 255
    12fe:	a9 01       	movw	r20, r18
    1300:	fc 01       	movw	r30, r24
    1302:	84 81       	ldd	r24, Z+4	; 0x04
    1304:	95 81       	ldd	r25, Z+5	; 0x05
    1306:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
    130a:	0f 91       	pop	r16
    130c:	08 95       	ret

0000130e <_ZN9frt_queueIhE10get_a_copyEv>:
    130e:	0f 93       	push	r16
    1310:	cf 93       	push	r28
    1312:	df 93       	push	r29
    1314:	1f 92       	push	r1
    1316:	cd b7       	in	r28, 0x3d	; 61
    1318:	de b7       	in	r29, 0x3e	; 62
    131a:	01 e0       	ldi	r16, 0x01	; 1
    131c:	2f ef       	ldi	r18, 0xFF	; 255
    131e:	3f ef       	ldi	r19, 0xFF	; 255
    1320:	a9 01       	movw	r20, r18
    1322:	be 01       	movw	r22, r28
    1324:	6f 5f       	subi	r22, 0xFF	; 255
    1326:	7f 4f       	sbci	r23, 0xFF	; 255
    1328:	fc 01       	movw	r30, r24
    132a:	84 81       	ldd	r24, Z+4	; 0x04
    132c:	95 81       	ldd	r25, Z+5	; 0x05
    132e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
    1332:	89 81       	ldd	r24, Y+1	; 0x01
    1334:	0f 90       	pop	r0
    1336:	df 91       	pop	r29
    1338:	cf 91       	pop	r28
    133a:	0f 91       	pop	r16
    133c:	08 95       	ret

0000133e <_ZN9frt_queueIhE3getEPh>:
    133e:	0f 93       	push	r16
    1340:	00 e0       	ldi	r16, 0x00	; 0
    1342:	2f ef       	ldi	r18, 0xFF	; 255
    1344:	3f ef       	ldi	r19, 0xFF	; 255
    1346:	a9 01       	movw	r20, r18
    1348:	fc 01       	movw	r30, r24
    134a:	84 81       	ldd	r24, Z+4	; 0x04
    134c:	95 81       	ldd	r25, Z+5	; 0x05
    134e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
    1352:	0f 91       	pop	r16
    1354:	08 95       	ret

00001356 <_ZN9frt_queueIhE3getEv>:
    1356:	0f 93       	push	r16
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	1f 92       	push	r1
    135e:	cd b7       	in	r28, 0x3d	; 61
    1360:	de b7       	in	r29, 0x3e	; 62
    1362:	00 e0       	ldi	r16, 0x00	; 0
    1364:	2f ef       	ldi	r18, 0xFF	; 255
    1366:	3f ef       	ldi	r19, 0xFF	; 255
    1368:	a9 01       	movw	r20, r18
    136a:	be 01       	movw	r22, r28
    136c:	6f 5f       	subi	r22, 0xFF	; 255
    136e:	7f 4f       	sbci	r23, 0xFF	; 255
    1370:	fc 01       	movw	r30, r24
    1372:	84 81       	ldd	r24, Z+4	; 0x04
    1374:	95 81       	ldd	r25, Z+5	; 0x05
    1376:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	0f 90       	pop	r0
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	0f 91       	pop	r16
    1384:	08 95       	ret

00001386 <_ZN9frt_queueIhE7ISR_getEPh>:
    1386:	cf 93       	push	r28
    1388:	df 93       	push	r29
    138a:	1f 92       	push	r1
    138c:	cd b7       	in	r28, 0x3d	; 61
    138e:	de b7       	in	r29, 0x3e	; 62
    1390:	ae 01       	movw	r20, r28
    1392:	4f 5f       	subi	r20, 0xFF	; 255
    1394:	5f 4f       	sbci	r21, 0xFF	; 255
    1396:	fc 01       	movw	r30, r24
    1398:	84 81       	ldd	r24, Z+4	; 0x04
    139a:	95 81       	ldd	r25, Z+5	; 0x05
    139c:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
    13a0:	0f 90       	pop	r0
    13a2:	df 91       	pop	r29
    13a4:	cf 91       	pop	r28
    13a6:	08 95       	ret

000013a8 <_ZN9frt_queueIhE7ISR_getEv>:
    13a8:	cf 93       	push	r28
    13aa:	df 93       	push	r29
    13ac:	1f 92       	push	r1
    13ae:	1f 92       	push	r1
    13b0:	cd b7       	in	r28, 0x3d	; 61
    13b2:	de b7       	in	r29, 0x3e	; 62
    13b4:	ae 01       	movw	r20, r28
    13b6:	4e 5f       	subi	r20, 0xFE	; 254
    13b8:	5f 4f       	sbci	r21, 0xFF	; 255
    13ba:	be 01       	movw	r22, r28
    13bc:	6f 5f       	subi	r22, 0xFF	; 255
    13be:	7f 4f       	sbci	r23, 0xFF	; 255
    13c0:	fc 01       	movw	r30, r24
    13c2:	84 81       	ldd	r24, Z+4	; 0x04
    13c4:	95 81       	ldd	r25, Z+5	; 0x05
    13c6:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
    13ca:	89 81       	ldd	r24, Y+1	; 0x01
    13cc:	0f 90       	pop	r0
    13ce:	0f 90       	pop	r0
    13d0:	df 91       	pop	r29
    13d2:	cf 91       	pop	r28
    13d4:	08 95       	ret

000013d6 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
    13d6:	cf 93       	push	r28
    13d8:	df 93       	push	r29
    13da:	1f 92       	push	r1
    13dc:	cd b7       	in	r28, 0x3d	; 61
    13de:	de b7       	in	r29, 0x3e	; 62
    13e0:	19 82       	std	Y+1, r1	; 0x01
    13e2:	21 e0       	ldi	r18, 0x01	; 1
    13e4:	ae 01       	movw	r20, r28
    13e6:	4f 5f       	subi	r20, 0xFF	; 255
    13e8:	5f 4f       	sbci	r21, 0xFF	; 255
    13ea:	fc 01       	movw	r30, r24
    13ec:	84 81       	ldd	r24, Z+4	; 0x04
    13ee:	95 81       	ldd	r25, Z+5	; 0x05
    13f0:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
    13f4:	91 e0       	ldi	r25, 0x01	; 1
    13f6:	81 11       	cpse	r24, r1
    13f8:	01 c0       	rjmp	.+2      	; 0x13fc <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	89 2f       	mov	r24, r25
    13fe:	0f 90       	pop	r0
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <_ZN9frt_queueIhE7ISR_putERKh>:
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	1f 92       	push	r1
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	19 82       	std	Y+1, r1	; 0x01
    1412:	20 e0       	ldi	r18, 0x00	; 0
    1414:	ae 01       	movw	r20, r28
    1416:	4f 5f       	subi	r20, 0xFF	; 255
    1418:	5f 4f       	sbci	r21, 0xFF	; 255
    141a:	fc 01       	movw	r30, r24
    141c:	84 81       	ldd	r24, Z+4	; 0x04
    141e:	95 81       	ldd	r25, Z+5	; 0x05
    1420:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
    1424:	91 e0       	ldi	r25, 0x01	; 1
    1426:	81 11       	cpse	r24, r1
    1428:	01 c0       	rjmp	.+2      	; 0x142c <_ZN9frt_queueIhE7ISR_putERKh+0x26>
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	89 2f       	mov	r24, r25
    142e:	0f 90       	pop	r0
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	08 95       	ret

00001436 <_ZN9frt_queueIhE7butt_inERKh>:
    1436:	0f 93       	push	r16
    1438:	fc 01       	movw	r30, r24
    143a:	26 81       	ldd	r18, Z+6	; 0x06
    143c:	37 81       	ldd	r19, Z+7	; 0x07
    143e:	40 85       	ldd	r20, Z+8	; 0x08
    1440:	51 85       	ldd	r21, Z+9	; 0x09
    1442:	01 e0       	ldi	r16, 0x01	; 1
    1444:	84 81       	ldd	r24, Z+4	; 0x04
    1446:	95 81       	ldd	r25, Z+5	; 0x05
    1448:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    144c:	91 e0       	ldi	r25, 0x01	; 1
    144e:	81 11       	cpse	r24, r1
    1450:	01 c0       	rjmp	.+2      	; 0x1454 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	89 2f       	mov	r24, r25
    1456:	0f 91       	pop	r16
    1458:	08 95       	ret

0000145a <_ZN9frt_queueIhE3putERKh>:
    145a:	0f 93       	push	r16
    145c:	fc 01       	movw	r30, r24
    145e:	26 81       	ldd	r18, Z+6	; 0x06
    1460:	37 81       	ldd	r19, Z+7	; 0x07
    1462:	40 85       	ldd	r20, Z+8	; 0x08
    1464:	51 85       	ldd	r21, Z+9	; 0x09
    1466:	00 e0       	ldi	r16, 0x00	; 0
    1468:	84 81       	ldd	r24, Z+4	; 0x04
    146a:	95 81       	ldd	r25, Z+5	; 0x05
    146c:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    1470:	91 e0       	ldi	r25, 0x01	; 1
    1472:	81 11       	cpse	r24, r1
    1474:	01 c0       	rjmp	.+2      	; 0x1478 <_ZN9frt_queueIhE3putERKh+0x1e>
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	89 2f       	mov	r24, r25
    147a:	0f 91       	pop	r16
    147c:	08 95       	ret

0000147e <_ZN6MB1202C1EP9I2CMasterP8emstream>:
    147e:	3f 92       	push	r3
    1480:	4f 92       	push	r4
    1482:	5f 92       	push	r5
    1484:	6f 92       	push	r6
    1486:	7f 92       	push	r7
    1488:	8f 92       	push	r8
    148a:	9f 92       	push	r9
    148c:	af 92       	push	r10
    148e:	bf 92       	push	r11
    1490:	cf 92       	push	r12
    1492:	df 92       	push	r13
    1494:	ef 92       	push	r14
    1496:	ff 92       	push	r15
    1498:	0f 93       	push	r16
    149a:	1f 93       	push	r17
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	8c 01       	movw	r16, r24
    14a2:	7b 01       	movw	r14, r22
    14a4:	6a 01       	movw	r12, r20
    14a6:	dc 01       	movw	r26, r24
    14a8:	6d 93       	st	X+, r22
    14aa:	7c 93       	st	X, r23
    14ac:	11 97       	sbiw	r26, 0x01	; 1
    14ae:	12 96       	adiw	r26, 0x02	; 2
    14b0:	4d 93       	st	X+, r20
    14b2:	5c 93       	st	X, r21
    14b4:	13 97       	sbiw	r26, 0x03	; 3
    14b6:	8f e1       	ldi	r24, 0x1F	; 31
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    14be:	ec 01       	movw	r28, r24
    14c0:	8c ec       	ldi	r24, 0xCC	; 204
    14c2:	91 e2       	ldi	r25, 0x21	; 33
    14c4:	88 83       	st	Y, r24
    14c6:	99 83       	std	Y+1, r25	; 0x01
    14c8:	1c 82       	std	Y+4, r1	; 0x04
    14ca:	1d 82       	std	Y+5, r1	; 0x05
    14cc:	0f 2e       	mov	r0, r31
    14ce:	f4 e8       	ldi	r31, 0x84	; 132
    14d0:	af 2e       	mov	r10, r31
    14d2:	f1 e2       	ldi	r31, 0x21	; 33
    14d4:	bf 2e       	mov	r11, r31
    14d6:	f0 2d       	mov	r31, r0
    14d8:	aa 82       	std	Y+2, r10	; 0x02
    14da:	bb 82       	std	Y+3, r11	; 0x03
    14dc:	40 e0       	ldi	r20, 0x00	; 0
    14de:	61 e0       	ldi	r22, 0x01	; 1
    14e0:	82 e0       	ldi	r24, 0x02	; 2
    14e2:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    14e6:	8e 83       	std	Y+6, r24	; 0x06
    14e8:	9f 83       	std	Y+7, r25	; 0x07
    14ea:	0f 2e       	mov	r0, r31
    14ec:	fa e0       	ldi	r31, 0x0A	; 10
    14ee:	4f 2e       	mov	r4, r31
    14f0:	51 2c       	mov	r5, r1
    14f2:	61 2c       	mov	r6, r1
    14f4:	71 2c       	mov	r7, r1
    14f6:	f0 2d       	mov	r31, r0
    14f8:	48 86       	std	Y+8, r4	; 0x08
    14fa:	59 86       	std	Y+9, r5	; 0x09
    14fc:	6a 86       	std	Y+10, r6	; 0x0a
    14fe:	7b 86       	std	Y+11, r7	; 0x0b
    1500:	0f 2e       	mov	r0, r31
    1502:	f8 ea       	ldi	r31, 0xA8	; 168
    1504:	8f 2e       	mov	r8, r31
    1506:	f1 e2       	ldi	r31, 0x21	; 33
    1508:	9f 2e       	mov	r9, r31
    150a:	f0 2d       	mov	r31, r0
    150c:	8a 82       	std	Y+2, r8	; 0x02
    150e:	9b 82       	std	Y+3, r9	; 0x03
    1510:	68 94       	set
    1512:	33 24       	eor	r3, r3
    1514:	31 f8       	bld	r3, 1
    1516:	3c 86       	std	Y+12, r3	; 0x0c
    1518:	1f 86       	std	Y+15, r1	; 0x0f
    151a:	18 8a       	std	Y+16, r1	; 0x10
    151c:	ad 86       	std	Y+13, r10	; 0x0d
    151e:	be 86       	std	Y+14, r11	; 0x0e
    1520:	40 e0       	ldi	r20, 0x00	; 0
    1522:	61 e0       	ldi	r22, 0x01	; 1
    1524:	82 e0       	ldi	r24, 0x02	; 2
    1526:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    152a:	89 8b       	std	Y+17, r24	; 0x11
    152c:	9a 8b       	std	Y+18, r25	; 0x12
    152e:	4b 8a       	std	Y+19, r4	; 0x13
    1530:	5c 8a       	std	Y+20, r5	; 0x14
    1532:	6d 8a       	std	Y+21, r6	; 0x15
    1534:	7e 8a       	std	Y+22, r7	; 0x16
    1536:	8d 86       	std	Y+13, r8	; 0x0d
    1538:	9e 86       	std	Y+14, r9	; 0x0e
    153a:	3f 8a       	std	Y+23, r3	; 0x17
    153c:	80 e1       	ldi	r24, 0x10	; 16
    153e:	90 e2       	ldi	r25, 0x20	; 32
    1540:	88 83       	st	Y, r24
    1542:	99 83       	std	Y+1, r25	; 0x01
    1544:	c8 8e       	std	Y+24, r12	; 0x18
    1546:	d9 8e       	std	Y+25, r13	; 0x19
    1548:	f8 01       	movw	r30, r16
    154a:	c4 83       	std	Z+4, r28	; 0x04
    154c:	d5 83       	std	Z+5, r29	; 0x05
    154e:	80 e7       	ldi	r24, 0x70	; 112
    1550:	86 83       	std	Z+6, r24	; 0x06
    1552:	10 86       	std	Z+8, r1	; 0x08
    1554:	11 86       	std	Z+9, r1	; 0x09
    1556:	12 86       	std	Z+10, r1	; 0x0a
    1558:	13 86       	std	Z+11, r1	; 0x0b
    155a:	14 86       	std	Z+12, r1	; 0x0c
    155c:	83 e0       	ldi	r24, 0x03	; 3
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    1564:	2a ed       	ldi	r18, 0xDA	; 218
    1566:	31 e2       	ldi	r19, 0x21	; 33
    1568:	fc 01       	movw	r30, r24
    156a:	20 83       	st	Z, r18
    156c:	31 83       	std	Z+1, r19	; 0x01
    156e:	c1 e5       	ldi	r28, 0x51	; 81
    1570:	c2 83       	std	Z+2, r28	; 0x02
    1572:	d8 01       	movw	r26, r16
    1574:	1f 96       	adiw	r26, 0x0f	; 15
    1576:	8d 93       	st	X+, r24
    1578:	9c 93       	st	X, r25
    157a:	50 97       	sbiw	r26, 0x10	; 16
    157c:	14 96       	adiw	r26, 0x04	; 4
    157e:	ed 91       	ld	r30, X+
    1580:	fc 91       	ld	r31, X
    1582:	15 97       	sbiw	r26, 0x05	; 5
    1584:	e2 8e       	std	Z+26, r14	; 0x1a
    1586:	f3 8e       	std	Z+27, r15	; 0x1b
    1588:	16 96       	adiw	r26, 0x06	; 6
    158a:	6c 91       	ld	r22, X
    158c:	16 97       	sbiw	r26, 0x06	; 6
    158e:	14 96       	adiw	r26, 0x04	; 4
    1590:	8d 91       	ld	r24, X+
    1592:	9c 91       	ld	r25, X
    1594:	15 97       	sbiw	r26, 0x05	; 5
    1596:	0e 94 06 04 	call	0x80c	; 0x80c <_ZN8I2CAgent12setSlaveAddrEh>
    159a:	f8 01       	movw	r30, r16
    159c:	c7 83       	std	Z+7, r28	; 0x07
    159e:	8a ea       	ldi	r24, 0xAA	; 170
    15a0:	80 87       	std	Z+8, r24	; 0x08
    15a2:	85 ea       	ldi	r24, 0xA5	; 165
    15a4:	81 87       	std	Z+9, r24	; 0x09
    15a6:	df 91       	pop	r29
    15a8:	cf 91       	pop	r28
    15aa:	1f 91       	pop	r17
    15ac:	0f 91       	pop	r16
    15ae:	ff 90       	pop	r15
    15b0:	ef 90       	pop	r14
    15b2:	df 90       	pop	r13
    15b4:	cf 90       	pop	r12
    15b6:	bf 90       	pop	r11
    15b8:	af 90       	pop	r10
    15ba:	9f 90       	pop	r9
    15bc:	8f 90       	pop	r8
    15be:	7f 90       	pop	r7
    15c0:	6f 90       	pop	r6
    15c2:	5f 90       	pop	r5
    15c4:	4f 90       	pop	r4
    15c6:	3f 90       	pop	r3
    15c8:	08 95       	ret

000015ca <_ZN6MB120211takeReadingEv>:

bool MB1202::takeReading()
{
    15ca:	0f 93       	push	r16
    15cc:	1f 93       	push	r17
    15ce:	cf 93       	push	r28
    15d0:	df 93       	push	r29
    15d2:	ec 01       	movw	r28, r24
	*p_serial << "mb1202 range cmd" << endl;
    15d4:	0a 81       	ldd	r16, Y+2	; 0x02
    15d6:	1b 81       	ldd	r17, Y+3	; 0x03
    15d8:	6f e6       	ldi	r22, 0x6F	; 111
    15da:	71 e2       	ldi	r23, 0x21	; 33
    15dc:	c8 01       	movw	r24, r16
    15de:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    15e2:	66 e0       	ldi	r22, 0x06	; 6
    15e4:	c8 01       	movw	r24, r16
    15e6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	return i2cAgent_->transmit(*rangeCommand_);
    15ea:	8c 81       	ldd	r24, Y+4	; 0x04
    15ec:	9d 81       	ldd	r25, Y+5	; 0x05
    15ee:	6f 85       	ldd	r22, Y+15	; 0x0f
    15f0:	78 89       	ldd	r23, Y+16	; 0x10
    15f2:	dc 01       	movw	r26, r24
    15f4:	ed 91       	ld	r30, X+
    15f6:	fc 91       	ld	r31, X
    15f8:	01 90       	ld	r0, Z+
    15fa:	f0 81       	ld	r31, Z
    15fc:	e0 2d       	mov	r30, r0
    15fe:	19 95       	eicall
}
    1600:	df 91       	pop	r29
    1602:	cf 91       	pop	r28
    1604:	1f 91       	pop	r17
    1606:	0f 91       	pop	r16
    1608:	08 95       	ret

0000160a <_ZN6MB120210getReadingEv>:

uint16_t MB1202::getReading()
{
    160a:	ff 92       	push	r15
    160c:	0f 93       	push	r16
    160e:	1f 93       	push	r17
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
    1616:	8c 81       	ldd	r24, Y+4	; 0x04
    1618:	9d 81       	ldd	r25, Y+5	; 0x05
    161a:	dc 01       	movw	r26, r24
    161c:	ed 91       	ld	r30, X+
    161e:	fc 91       	ld	r31, X
    1620:	02 80       	ldd	r0, Z+2	; 0x02
    1622:	f3 81       	ldd	r31, Z+3	; 0x03
    1624:	e0 2d       	mov	r30, r0
    1626:	19 95       	eicall
    1628:	8c 01       	movw	r16, r24
	rangeReading_ = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
    162a:	dc 01       	movw	r26, r24
    162c:	ed 91       	ld	r30, X+
    162e:	fc 91       	ld	r31, X
    1630:	00 84       	ldd	r0, Z+8	; 0x08
    1632:	f1 85       	ldd	r31, Z+9	; 0x09
    1634:	e0 2d       	mov	r30, r0
    1636:	19 95       	eicall
    1638:	f8 2e       	mov	r15, r24
    163a:	d8 01       	movw	r26, r16
    163c:	ed 91       	ld	r30, X+
    163e:	fc 91       	ld	r31, X
    1640:	00 84       	ldd	r0, Z+8	; 0x08
    1642:	f1 85       	ldd	r31, Z+9	; 0x09
    1644:	e0 2d       	mov	r30, r0
    1646:	c8 01       	movw	r24, r16
    1648:	19 95       	eicall
    164a:	2f 2d       	mov	r18, r15
    164c:	30 e0       	ldi	r19, 0x00	; 0
    164e:	32 2f       	mov	r19, r18
    1650:	22 27       	eor	r18, r18
    1652:	a9 01       	movw	r20, r18
    1654:	48 2b       	or	r20, r24
    1656:	ca 01       	movw	r24, r20
    1658:	8d 87       	std	Y+13, r24	; 0x0d
    165a:	9e 87       	std	Y+14, r25	; 0x0e
	return rangeReading_;
}
    165c:	df 91       	pop	r29
    165e:	cf 91       	pop	r28
    1660:	1f 91       	pop	r17
    1662:	0f 91       	pop	r16
    1664:	ff 90       	pop	r15
    1666:	08 95       	ret

00001668 <_ZN6Packet12resetContentEv>:
#include "Packet.h"

void Packet::resetContent()
{
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	ec 01       	movw	r28, r24
  while( not_empty() )
    166e:	e8 81       	ld	r30, Y
    1670:	f9 81       	ldd	r31, Y+1	; 0x01
    1672:	00 8c       	ldd	r0, Z+24	; 0x18
    1674:	f1 8d       	ldd	r31, Z+25	; 0x19
    1676:	e0 2d       	mov	r30, r0
    1678:	ce 01       	movw	r24, r28
    167a:	19 95       	eicall
    167c:	88 23       	and	r24, r24
    167e:	41 f0       	breq	.+16     	; 0x1690 <_ZN6Packet12resetContentEv+0x28>
  {
    get();
    1680:	e8 81       	ld	r30, Y
    1682:	f9 81       	ldd	r31, Y+1	; 0x01
    1684:	00 84       	ldd	r0, Z+8	; 0x08
    1686:	f1 85       	ldd	r31, Z+9	; 0x09
    1688:	e0 2d       	mov	r30, r0
    168a:	ce 01       	movw	r24, r28
    168c:	19 95       	eicall
#include "Packet.h"

void Packet::resetContent()
{
  while( not_empty() )
    168e:	ef cf       	rjmp	.-34     	; 0x166e <_ZN6Packet12resetContentEv+0x6>
  {
    get();
  }
    1690:	df 91       	pop	r29
    1692:	cf 91       	pop	r28
    1694:	08 95       	ret

00001696 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    1696:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1698:	8c 85       	ldd	r24, Y+12	; 0x0c
    169a:	88 23       	and	r24, r24
    169c:	19 f0       	breq	.+6      	; 0x16a4 <_ZN10task_sonar3runEv+0xe>
    169e:	81 30       	cpi	r24, 0x01	; 1
    16a0:	a9 f0       	breq	.+42     	; 0x16cc <_ZN10task_sonar3runEv+0x36>
    16a2:	30 c0       	rjmp	.+96     	; 0x1704 <_ZN10task_sonar3runEv+0x6e>
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				*p_serial << "Range cmd" << endl;
    16a4:	0e 81       	ldd	r16, Y+6	; 0x06
    16a6:	1f 81       	ldd	r17, Y+7	; 0x07
    16a8:	6c ed       	ldi	r22, 0xDC	; 220
    16aa:	71 e2       	ldi	r23, 0x21	; 33
    16ac:	c8 01       	movw	r24, r16
    16ae:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    16b2:	66 e0       	ldi	r22, 0x06	; 6
    16b4:	c8 01       	movw	r24, r16
    16b6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
				mb1202_->takeReading();	
    16ba:	8c 89       	ldd	r24, Y+20	; 0x14
    16bc:	9d 89       	ldd	r25, Y+21	; 0x15
    16be:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <_ZN6MB120211takeReadingEv>
				
				transition_to(1);			
    16c2:	61 e0       	ldi	r22, 0x01	; 1
    16c4:	ce 01       	movw	r24, r28
    16c6:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN8frt_task13transition_toEh>
			
			  break;
    16ca:	1c c0       	rjmp	.+56     	; 0x1704 <_ZN10task_sonar3runEv+0x6e>
				
			case (1):
			
				rangeReading_ = mb1202_->getReading();
    16cc:	8c 89       	ldd	r24, Y+20	; 0x14
    16ce:	9d 89       	ldd	r25, Y+21	; 0x15
    16d0:	0e 94 05 0b 	call	0x160a	; 0x160a <_ZN6MB120210getReadingEv>
    16d4:	7c 01       	movw	r14, r24
    16d6:	8a 8b       	std	Y+18, r24	; 0x12
    16d8:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << rangeReading_ << endl;
    16da:	6a e0       	ldi	r22, 0x0A	; 10
    16dc:	8e 81       	ldd	r24, Y+6	; 0x06
    16de:	9f 81       	ldd	r25, Y+7	; 0x07
    16e0:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    16e4:	8c 01       	movw	r16, r24
    16e6:	6a ea       	ldi	r22, 0xAA	; 170
    16e8:	73 e0       	ldi	r23, 0x03	; 3
    16ea:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    16ee:	b7 01       	movw	r22, r14
    16f0:	c8 01       	movw	r24, r16
    16f2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    16f6:	66 e0       	ldi	r22, 0x06	; 6
    16f8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    16fc:	60 e0       	ldi	r22, 0x00	; 0
    16fe:	ce 01       	movw	r24, r28
    1700:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1704:	8e 85       	ldd	r24, Y+14	; 0x0e
    1706:	9f 85       	ldd	r25, Y+15	; 0x0f
    1708:	a8 89       	ldd	r26, Y+16	; 0x10
    170a:	b9 89       	ldd	r27, Y+17	; 0x11
    170c:	01 96       	adiw	r24, 0x01	; 1
    170e:	a1 1d       	adc	r26, r1
    1710:	b1 1d       	adc	r27, r1
    1712:	8e 87       	std	Y+14, r24	; 0x0e
    1714:	9f 87       	std	Y+15, r25	; 0x0f
    1716:	a8 8b       	std	Y+16, r26	; 0x10
    1718:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (10000));
    171a:	60 e1       	ldi	r22, 0x10	; 16
    171c:	77 e2       	ldi	r23, 0x27	; 39
    171e:	80 e0       	ldi	r24, 0x00	; 0
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1726:	b8 cf       	rjmp	.-144    	; 0x1698 <_ZN10task_sonar3runEv+0x2>

00001728 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    1728:	cf 92       	push	r12
    172a:	df 92       	push	r13
    172c:	ef 92       	push	r14
    172e:	ff 92       	push	r15
    1730:	0f 93       	push	r16
    1732:	1f 93       	push	r17
    1734:	cf 93       	push	r28
    1736:	df 93       	push	r29
    1738:	ec 01       	movw	r28, r24
    173a:	6b 01       	movw	r12, r22
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), 
		mb1202_(mb1202)
    173c:	0e 94 65 19 	call	0x32ca	; 0x32ca <_ZN8frt_taskC1EPKchjP8emstream>
    1740:	8a ee       	ldi	r24, 0xEA	; 234
    1742:	91 e2       	ldi	r25, 0x21	; 33
    1744:	88 83       	st	Y, r24
    1746:	99 83       	std	Y+1, r25	; 0x01
    1748:	ec 8a       	std	Y+20, r14	; 0x14
    174a:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    174c:	ce 8a       	std	Y+22, r12	; 0x16
    174e:	df 8a       	std	Y+23, r13	; 0x17
}
    1750:	df 91       	pop	r29
    1752:	cf 91       	pop	r28
    1754:	1f 91       	pop	r17
    1756:	0f 91       	pop	r16
    1758:	ff 90       	pop	r15
    175a:	ef 90       	pop	r14
    175c:	df 90       	pop	r13
    175e:	cf 90       	pop	r12
    1760:	08 95       	ret

00001762 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    1762:	0f 93       	push	r16
    1764:	1f 93       	push	r17
    1766:	cf 93       	push	r28
    1768:	df 93       	push	r29
    176a:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    176c:	0e 94 65 19 	call	0x32ca	; 0x32ca <_ZN8frt_taskC1EPKchjP8emstream>
    1770:	82 ef       	ldi	r24, 0xF2	; 242
    1772:	91 e2       	ldi	r25, 0x21	; 33
    1774:	88 83       	st	Y, r24
    1776:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	08 95       	ret

00001782 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    1782:	0f 93       	push	r16
    1784:	1f 93       	push	r17
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    178a:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    178c:	6a e0       	ldi	r22, 0x0A	; 10
    178e:	8e 81       	ldd	r24, Y+6	; 0x06
    1790:	9f 81       	ldd	r25, Y+7	; 0x07
    1792:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1796:	8c 01       	movw	r16, r24
    1798:	65 e0       	ldi	r22, 0x05	; 5
    179a:	75 e0       	ldi	r23, 0x05	; 5
    179c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    17a0:	6a e0       	ldi	r22, 0x0A	; 10
    17a2:	c8 01       	movw	r24, r16
    17a4:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    17a8:	8c 01       	movw	r16, r24
    17aa:	6f ef       	ldi	r22, 0xFF	; 255
    17ac:	74 e0       	ldi	r23, 0x04	; 4
    17ae:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    17b2:	67 e0       	ldi	r22, 0x07	; 7
    17b4:	c8 01       	movw	r24, r16
    17b6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    17ba:	6a e0       	ldi	r22, 0x0A	; 10
    17bc:	8e 81       	ldd	r24, Y+6	; 0x06
    17be:	9f 81       	ldd	r25, Y+7	; 0x07
    17c0:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    17c4:	8c 01       	movw	r16, r24
    17c6:	60 ee       	ldi	r22, 0xE0	; 224
    17c8:	74 e0       	ldi	r23, 0x04	; 4
    17ca:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    17ce:	6a e0       	ldi	r22, 0x0A	; 10
    17d0:	c8 01       	movw	r24, r16
    17d2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    17d6:	8c 01       	movw	r16, r24
    17d8:	6a ed       	ldi	r22, 0xDA	; 218
    17da:	74 e0       	ldi	r23, 0x04	; 4
    17dc:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    17e0:	66 e0       	ldi	r22, 0x06	; 6
    17e2:	c8 01       	movw	r24, r16
    17e4:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    17e8:	6a e0       	ldi	r22, 0x0A	; 10
    17ea:	8e 81       	ldd	r24, Y+6	; 0x06
    17ec:	9f 81       	ldd	r25, Y+7	; 0x07
    17ee:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    17f2:	8c 01       	movw	r16, r24
    17f4:	63 ec       	ldi	r22, 0xC3	; 195
    17f6:	74 e0       	ldi	r23, 0x04	; 4
    17f8:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    17fc:	66 e0       	ldi	r22, 0x06	; 6
    17fe:	c8 01       	movw	r24, r16
    1800:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1804:	6a e0       	ldi	r22, 0x0A	; 10
    1806:	8e 81       	ldd	r24, Y+6	; 0x06
    1808:	9f 81       	ldd	r25, Y+7	; 0x07
    180a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    180e:	8c 01       	movw	r16, r24
    1810:	67 ea       	ldi	r22, 0xA7	; 167
    1812:	74 e0       	ldi	r23, 0x04	; 4
    1814:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1818:	66 e0       	ldi	r22, 0x06	; 6
    181a:	c8 01       	movw	r24, r16
    181c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    1820:	6a e0       	ldi	r22, 0x0A	; 10
    1822:	8e 81       	ldd	r24, Y+6	; 0x06
    1824:	9f 81       	ldd	r25, Y+7	; 0x07
    1826:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    182a:	8c 01       	movw	r16, r24
    182c:	6f e8       	ldi	r22, 0x8F	; 143
    182e:	74 e0       	ldi	r23, 0x04	; 4
    1830:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1834:	66 e0       	ldi	r22, 0x06	; 6
    1836:	c8 01       	movw	r24, r16
    1838:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    183c:	6a e0       	ldi	r22, 0x0A	; 10
    183e:	8e 81       	ldd	r24, Y+6	; 0x06
    1840:	9f 81       	ldd	r25, Y+7	; 0x07
    1842:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1846:	8c 01       	movw	r16, r24
    1848:	6e e6       	ldi	r22, 0x6E	; 110
    184a:	74 e0       	ldi	r23, 0x04	; 4
    184c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1850:	66 e0       	ldi	r22, 0x06	; 6
    1852:	c8 01       	movw	r24, r16
    1854:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1858:	6a e0       	ldi	r22, 0x0A	; 10
    185a:	8e 81       	ldd	r24, Y+6	; 0x06
    185c:	9f 81       	ldd	r25, Y+7	; 0x07
    185e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1862:	8c 01       	movw	r16, r24
    1864:	67 e4       	ldi	r22, 0x47	; 71
    1866:	74 e0       	ldi	r23, 0x04	; 4
    1868:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    186c:	66 e0       	ldi	r22, 0x06	; 6
    186e:	c8 01       	movw	r24, r16
    1870:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1874:	6a e0       	ldi	r22, 0x0A	; 10
    1876:	8e 81       	ldd	r24, Y+6	; 0x06
    1878:	9f 81       	ldd	r25, Y+7	; 0x07
    187a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    187e:	8c 01       	movw	r16, r24
    1880:	69 e2       	ldi	r22, 0x29	; 41
    1882:	74 e0       	ldi	r23, 0x04	; 4
    1884:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1888:	66 e0       	ldi	r22, 0x06	; 6
    188a:	c8 01       	movw	r24, r16
    188c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    1890:	6a e0       	ldi	r22, 0x0A	; 10
    1892:	8e 81       	ldd	r24, Y+6	; 0x06
    1894:	9f 81       	ldd	r25, Y+7	; 0x07
    1896:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    189a:	8c 01       	movw	r16, r24
    189c:	6e e0       	ldi	r22, 0x0E	; 14
    189e:	74 e0       	ldi	r23, 0x04	; 4
    18a0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    18a4:	66 e0       	ldi	r22, 0x06	; 6
    18a6:	c8 01       	movw	r24, r16
    18a8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    18ac:	6a e0       	ldi	r22, 0x0A	; 10
    18ae:	8e 81       	ldd	r24, Y+6	; 0x06
    18b0:	9f 81       	ldd	r25, Y+7	; 0x07
    18b2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    18b6:	ec 01       	movw	r28, r24
    18b8:	6f ef       	ldi	r22, 0xFF	; 255
    18ba:	73 e0       	ldi	r23, 0x03	; 3
    18bc:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    18c0:	66 e0       	ldi	r22, 0x06	; 6
    18c2:	ce 01       	movw	r24, r28
    18c4:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
}
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	1f 91       	pop	r17
    18ce:	0f 91       	pop	r16
    18d0:	08 95       	ret

000018d2 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    18d2:	af 92       	push	r10
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ef 92       	push	r14
    18dc:	ff 92       	push	r15
    18de:	0f 93       	push	r16
    18e0:	1f 93       	push	r17
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <_ZN9task_user11show_statusEv+0x16>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <_ZN9task_user11show_statusEv+0x18>
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    18f0:	19 82       	std	Y+1, r1	; 0x01
    18f2:	1a 82       	std	Y+2, r1	; 0x02
    18f4:	1b 82       	std	Y+3, r1	; 0x03
    18f6:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    18f8:	1d 82       	std	Y+5, r1	; 0x05
    18fa:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    18fc:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <xPortGetFreeHeapSize>
    1900:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    1902:	ce 01       	movw	r24, r28
    1904:	01 96       	adiw	r24, 0x01	; 1
    1906:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <_ZN10time_stamp10set_to_nowEv>
    190a:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    190c:	66 e0       	ldi	r22, 0x06	; 6
    190e:	f8 01       	movw	r30, r16
    1910:	86 81       	ldd	r24, Z+6	; 0x06
    1912:	97 81       	ldd	r25, Z+7	; 0x07
    1914:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1918:	6a e0       	ldi	r22, 0x0A	; 10
    191a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    191e:	7c 01       	movw	r14, r24
    1920:	60 ee       	ldi	r22, 0xE0	; 224
    1922:	73 e0       	ldi	r23, 0x03	; 3
    1924:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1928:	6a e0       	ldi	r22, 0x0A	; 10
    192a:	c7 01       	movw	r24, r14
    192c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1930:	7c 01       	movw	r14, r24
    1932:	64 ed       	ldi	r22, 0xD4	; 212
    1934:	73 e0       	ldi	r23, 0x03	; 3
    1936:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    193a:	66 e0       	ldi	r22, 0x06	; 6
    193c:	c7 01       	movw	r24, r14
    193e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    1942:	6a e0       	ldi	r22, 0x0A	; 10
    1944:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1948:	7c 01       	movw	r14, r24
    194a:	6d ec       	ldi	r22, 0xCD	; 205
    194c:	73 e0       	ldi	r23, 0x03	; 3
    194e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1952:	b5 01       	movw	r22, r10
    1954:	c7 01       	movw	r24, r14
    1956:	0e 94 ba 1c 	call	0x3974	; 0x3974 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    195a:	6a e0       	ldi	r22, 0x0A	; 10
    195c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1960:	7c 01       	movw	r14, r24
    1962:	6f eb       	ldi	r22, 0xBF	; 191
    1964:	73 e0       	ldi	r23, 0x03	; 3
    1966:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    196a:	b6 01       	movw	r22, r12
    196c:	c7 01       	movw	r24, r14
    196e:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    1972:	6a e0       	ldi	r22, 0x0A	; 10
    1974:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1978:	7c 01       	movw	r14, r24
    197a:	6d eb       	ldi	r22, 0xBD	; 189
    197c:	73 e0       	ldi	r23, 0x03	; 3
    197e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    1982:	4f ef       	ldi	r20, 0xFF	; 255
    1984:	5f e0       	ldi	r21, 0x0F	; 15
    1986:	60 e0       	ldi	r22, 0x00	; 0
    1988:	70 e0       	ldi	r23, 0x00	; 0
    198a:	c7 01       	movw	r24, r14
    198c:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    1990:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    1994:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    1998:	6a e0       	ldi	r22, 0x0A	; 10
    199a:	f8 01       	movw	r30, r16
    199c:	86 81       	ldd	r24, Z+6	; 0x06
    199e:	97 81       	ldd	r25, Z+7	; 0x07
    19a0:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    19a4:	7c 01       	movw	r14, r24
    19a6:	62 eb       	ldi	r22, 0xB2	; 178
    19a8:	73 e0       	ldi	r23, 0x03	; 3
    19aa:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    19ae:	b6 01       	movw	r22, r12
    19b0:	c7 01       	movw	r24, r14
    19b2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    19b6:	66 e0       	ldi	r22, 0x06	; 6
    19b8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    19bc:	66 e0       	ldi	r22, 0x06	; 6
    19be:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    19c2:	f8 01       	movw	r30, r16
    19c4:	86 81       	ldd	r24, Z+6	; 0x06
    19c6:	97 81       	ldd	r25, Z+7	; 0x07
    19c8:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <_Z15print_task_listP8emstream>
}
    19cc:	26 96       	adiw	r28, 0x06	; 6
    19ce:	cd bf       	out	0x3d, r28	; 61
    19d0:	de bf       	out	0x3e, r29	; 62
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	1f 91       	pop	r17
    19d8:	0f 91       	pop	r16
    19da:	ff 90       	pop	r15
    19dc:	ef 90       	pop	r14
    19de:	df 90       	pop	r13
    19e0:	cf 90       	pop	r12
    19e2:	bf 90       	pop	r11
    19e4:	af 90       	pop	r10
    19e6:	08 95       	ret

000019e8 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <_ZN9task_user3runEv+0x6>
    19ee:	00 d0       	rcall	.+0      	; 0x19f0 <_ZN9task_user3runEv+0x8>
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    19f6:	19 82       	std	Y+1, r1	; 0x01
    19f8:	1a 82       	std	Y+2, r1	; 0x02
    19fa:	1b 82       	std	Y+3, r1	; 0x03
    19fc:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    19fe:	1d 82       	std	Y+5, r1	; 0x05
    1a00:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    1a02:	6a e0       	ldi	r22, 0x0A	; 10
    1a04:	dc 01       	movw	r26, r24
    1a06:	16 96       	adiw	r26, 0x06	; 6
    1a08:	8d 91       	ld	r24, X+
    1a0a:	9c 91       	ld	r25, X
    1a0c:	17 97       	sbiw	r26, 0x07	; 7
    1a0e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1a12:	7c 01       	movw	r14, r24
    1a14:	6e e4       	ldi	r22, 0x4E	; 78
    1a16:	75 e0       	ldi	r23, 0x05	; 5
    1a18:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1a1c:	66 e0       	ldi	r22, 0x06	; 6
    1a1e:	c7 01       	movw	r24, r14
    1a20:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1a24:	f8 01       	movw	r30, r16
    1a26:	84 85       	ldd	r24, Z+12	; 0x0c
    1a28:	88 23       	and	r24, r24
    1a2a:	21 f0       	breq	.+8      	; 0x1a34 <_ZN9task_user3runEv+0x4c>
    1a2c:	81 30       	cpi	r24, 0x01	; 1
    1a2e:	09 f4       	brne	.+2      	; 0x1a32 <_ZN9task_user3runEv+0x4a>
    1a30:	5d c0       	rjmp	.+186    	; 0x1aec <_ZN9task_user3runEv+0x104>
    1a32:	d8 c0       	rjmp	.+432    	; 0x1be4 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1a34:	86 81       	ldd	r24, Z+6	; 0x06
    1a36:	97 81       	ldd	r25, Z+7	; 0x07
    1a38:	dc 01       	movw	r26, r24
    1a3a:	ed 91       	ld	r30, X+
    1a3c:	fc 91       	ld	r31, X
    1a3e:	04 80       	ldd	r0, Z+4	; 0x04
    1a40:	f5 81       	ldd	r31, Z+5	; 0x05
    1a42:	e0 2d       	mov	r30, r0
    1a44:	19 95       	eicall
    1a46:	88 23       	and	r24, r24
    1a48:	a9 f1       	breq	.+106    	; 0x1ab4 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1a4a:	f8 01       	movw	r30, r16
    1a4c:	86 81       	ldd	r24, Z+6	; 0x06
    1a4e:	97 81       	ldd	r25, Z+7	; 0x07
    1a50:	dc 01       	movw	r26, r24
    1a52:	ed 91       	ld	r30, X+
    1a54:	fc 91       	ld	r31, X
    1a56:	06 80       	ldd	r0, Z+6	; 0x06
    1a58:	f7 81       	ldd	r31, Z+7	; 0x07
    1a5a:	e0 2d       	mov	r30, r0
    1a5c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    1a5e:	99 27       	eor	r25, r25
    1a60:	81 30       	cpi	r24, 0x01	; 1
    1a62:	91 05       	cpc	r25, r1
    1a64:	f9 f0       	breq	.+62     	; 0x1aa4 <_ZN9task_user3runEv+0xbc>
    1a66:	03 97       	sbiw	r24, 0x03	; 3
    1a68:	09 f0       	breq	.+2      	; 0x1a6c <_ZN9task_user3runEv+0x84>
    1a6a:	d8 c0       	rjmp	.+432    	; 0x1c1c <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1a6c:	6a e0       	ldi	r22, 0x0A	; 10
    1a6e:	f8 01       	movw	r30, r16
    1a70:	86 81       	ldd	r24, Z+6	; 0x06
    1a72:	97 81       	ldd	r25, Z+7	; 0x07
    1a74:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1a78:	8c 01       	movw	r16, r24
    1a7a:	60 e4       	ldi	r22, 0x40	; 64
    1a7c:	75 e0       	ldi	r23, 0x05	; 5
    1a7e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1a82:	66 e0       	ldi	r22, 0x06	; 6
    1a84:	c8 01       	movw	r24, r16
    1a86:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1a8a:	93 e0       	ldi	r25, 0x03	; 3
    1a8c:	88 ed       	ldi	r24, 0xD8	; 216
    1a8e:	08 b6       	in	r0, 0x38	; 56
    1a90:	18 be       	out	0x38, r1	; 56
    1a92:	84 bf       	out	0x34, r24	; 52
    1a94:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1a98:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1a9c:	81 fd       	sbrc	r24, 1
    1a9e:	fc cf       	rjmp	.-8      	; 0x1a98 <_ZN9task_user3runEv+0xb0>
    1aa0:	08 be       	out	0x38, r0	; 56
    1aa2:	ff cf       	rjmp	.-2      	; 0x1aa2 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    1aa4:	c8 01       	movw	r24, r16
    1aa6:	0e 94 c1 0b 	call	0x1782	; 0x1782 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    1aaa:	61 e0       	ldi	r22, 0x01	; 1
    1aac:	c8 01       	movw	r24, r16
    1aae:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN8frt_task13transition_toEh>
							break;
    1ab2:	b4 c0       	rjmp	.+360    	; 0x1c1c <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    1ab4:	84 e6       	ldi	r24, 0x64	; 100
    1ab6:	93 e3       	ldi	r25, 0x33	; 51
    1ab8:	0e 94 22 1c 	call	0x3844	; 0x3844 <_ZN14frt_text_queue14check_for_charEv>
    1abc:	88 23       	and	r24, r24
    1abe:	09 f4       	brne	.+2      	; 0x1ac2 <_ZN9task_user3runEv+0xda>
    1ac0:	ad c0       	rjmp	.+346    	; 0x1c1c <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1ac2:	d8 01       	movw	r26, r16
    1ac4:	16 96       	adiw	r26, 0x06	; 6
    1ac6:	ed 91       	ld	r30, X+
    1ac8:	fc 91       	ld	r31, X
    1aca:	17 97       	sbiw	r26, 0x07	; 7
    1acc:	01 90       	ld	r0, Z+
    1ace:	f0 81       	ld	r31, Z
    1ad0:	e0 2d       	mov	r30, r0
    1ad2:	e2 80       	ldd	r14, Z+2	; 0x02
    1ad4:	f3 80       	ldd	r15, Z+3	; 0x03
    1ad6:	84 e6       	ldi	r24, 0x64	; 100
    1ad8:	93 e3       	ldi	r25, 0x33	; 51
    1ada:	0e 94 04 1c 	call	0x3808	; 0x3808 <_ZN14frt_text_queue7getcharEv>
    1ade:	68 2f       	mov	r22, r24
    1ae0:	f8 01       	movw	r30, r16
    1ae2:	86 81       	ldd	r24, Z+6	; 0x06
    1ae4:	97 81       	ldd	r25, Z+7	; 0x07
    1ae6:	f7 01       	movw	r30, r14
    1ae8:	19 95       	eicall
    1aea:	98 c0       	rjmp	.+304    	; 0x1c1c <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1aec:	86 81       	ldd	r24, Z+6	; 0x06
    1aee:	97 81       	ldd	r25, Z+7	; 0x07
    1af0:	dc 01       	movw	r26, r24
    1af2:	ed 91       	ld	r30, X+
    1af4:	fc 91       	ld	r31, X
    1af6:	04 80       	ldd	r0, Z+4	; 0x04
    1af8:	f5 81       	ldd	r31, Z+5	; 0x05
    1afa:	e0 2d       	mov	r30, r0
    1afc:	19 95       	eicall
    1afe:	88 23       	and	r24, r24
    1b00:	09 f4       	brne	.+2      	; 0x1b04 <_ZN9task_user3runEv+0x11c>
    1b02:	8c c0       	rjmp	.+280    	; 0x1c1c <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1b04:	f8 01       	movw	r30, r16
    1b06:	86 81       	ldd	r24, Z+6	; 0x06
    1b08:	97 81       	ldd	r25, Z+7	; 0x07
    1b0a:	dc 01       	movw	r26, r24
    1b0c:	ed 91       	ld	r30, X+
    1b0e:	fc 91       	ld	r31, X
    1b10:	06 80       	ldd	r0, Z+6	; 0x06
    1b12:	f7 81       	ldd	r31, Z+7	; 0x07
    1b14:	e0 2d       	mov	r30, r0
    1b16:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1b18:	9c 01       	movw	r18, r24
    1b1a:	33 27       	eor	r19, r19
    1b1c:	28 36       	cpi	r18, 0x68	; 104
    1b1e:	31 05       	cpc	r19, r1
    1b20:	59 f1       	breq	.+86     	; 0x1b78 <_ZN9task_user3runEv+0x190>
    1b22:	3c f4       	brge	.+14     	; 0x1b32 <_ZN9task_user3runEv+0x14a>
    1b24:	2b 31       	cpi	r18, 0x1B	; 27
    1b26:	31 05       	cpc	r19, r1
    1b28:	59 f1       	breq	.+86     	; 0x1b80 <_ZN9task_user3runEv+0x198>
    1b2a:	25 36       	cpi	r18, 0x65	; 101
    1b2c:	31 05       	cpc	r19, r1
    1b2e:	41 f1       	breq	.+80     	; 0x1b80 <_ZN9task_user3runEv+0x198>
    1b30:	3b c0       	rjmp	.+118    	; 0x1ba8 <_ZN9task_user3runEv+0x1c0>
    1b32:	23 37       	cpi	r18, 0x73	; 115
    1b34:	31 05       	cpc	r19, r1
    1b36:	c1 f0       	breq	.+48     	; 0x1b68 <_ZN9task_user3runEv+0x180>
    1b38:	26 37       	cpi	r18, 0x76	; 118
    1b3a:	31 05       	cpc	r19, r1
    1b3c:	89 f0       	breq	.+34     	; 0x1b60 <_ZN9task_user3runEv+0x178>
    1b3e:	2e 36       	cpi	r18, 0x6E	; 110
    1b40:	31 05       	cpc	r19, r1
    1b42:	91 f5       	brne	.+100    	; 0x1ba8 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1b44:	ce 01       	movw	r24, r28
    1b46:	01 96       	adiw	r24, 0x01	; 1
    1b48:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <_ZN10time_stamp10set_to_nowEv>
    1b4c:	bc 01       	movw	r22, r24
    1b4e:	f8 01       	movw	r30, r16
    1b50:	86 81       	ldd	r24, Z+6	; 0x06
    1b52:	97 81       	ldd	r25, Z+7	; 0x07
    1b54:	0e 94 ba 1c 	call	0x3974	; 0x3974 <_ZlsR8emstreamR10time_stamp>
    1b58:	66 e0       	ldi	r22, 0x06	; 6
    1b5a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1b5e:	5e c0       	rjmp	.+188    	; 0x1c1c <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    1b60:	c8 01       	movw	r24, r16
    1b62:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <_ZN9task_user11show_statusEv>
							break;
    1b66:	5a c0       	rjmp	.+180    	; 0x1c1c <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1b68:	d8 01       	movw	r26, r16
    1b6a:	16 96       	adiw	r26, 0x06	; 6
    1b6c:	8d 91       	ld	r24, X+
    1b6e:	9c 91       	ld	r25, X
    1b70:	17 97       	sbiw	r26, 0x07	; 7
    1b72:	0e 94 7a 1a 	call	0x34f4	; 0x34f4 <_Z17print_task_stacksP8emstream>
							break;
    1b76:	52 c0       	rjmp	.+164    	; 0x1c1c <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1b78:	c8 01       	movw	r24, r16
    1b7a:	0e 94 c1 0b 	call	0x1782	; 0x1782 <_ZN9task_user18print_help_messageEv>
							break;
    1b7e:	4e c0       	rjmp	.+156    	; 0x1c1c <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    1b80:	6a e0       	ldi	r22, 0x0A	; 10
    1b82:	f8 01       	movw	r30, r16
    1b84:	86 81       	ldd	r24, Z+6	; 0x06
    1b86:	97 81       	ldd	r25, Z+7	; 0x07
    1b88:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1b8c:	7c 01       	movw	r14, r24
    1b8e:	6e e2       	ldi	r22, 0x2E	; 46
    1b90:	75 e0       	ldi	r23, 0x05	; 5
    1b92:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1b96:	66 e0       	ldi	r22, 0x06	; 6
    1b98:	c7 01       	movw	r24, r14
    1b9a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    1b9e:	60 e0       	ldi	r22, 0x00	; 0
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	0e 94 61 19 	call	0x32c2	; 0x32c2 <_ZN8frt_task13transition_toEh>
							break;
    1ba6:	3a c0       	rjmp	.+116    	; 0x1c1c <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    1ba8:	f8 01       	movw	r30, r16
    1baa:	a6 81       	ldd	r26, Z+6	; 0x06
    1bac:	b7 81       	ldd	r27, Z+7	; 0x07
    1bae:	ed 91       	ld	r30, X+
    1bb0:	fc 91       	ld	r31, X
    1bb2:	11 97       	sbiw	r26, 0x01	; 1
    1bb4:	02 80       	ldd	r0, Z+2	; 0x02
    1bb6:	f3 81       	ldd	r31, Z+3	; 0x03
    1bb8:	e0 2d       	mov	r30, r0
    1bba:	68 2f       	mov	r22, r24
    1bbc:	cd 01       	movw	r24, r26
    1bbe:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1bc0:	6a e0       	ldi	r22, 0x0A	; 10
    1bc2:	d8 01       	movw	r26, r16
    1bc4:	16 96       	adiw	r26, 0x06	; 6
    1bc6:	8d 91       	ld	r24, X+
    1bc8:	9c 91       	ld	r25, X
    1bca:	17 97       	sbiw	r26, 0x07	; 7
    1bcc:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1bd0:	7c 01       	movw	r14, r24
    1bd2:	68 e2       	ldi	r22, 0x28	; 40
    1bd4:	75 e0       	ldi	r23, 0x05	; 5
    1bd6:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1bda:	66 e0       	ldi	r22, 0x06	; 6
    1bdc:	c7 01       	movw	r24, r14
    1bde:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1be2:	1c c0       	rjmp	.+56     	; 0x1c1c <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1be4:	6a e0       	ldi	r22, 0x0A	; 10
    1be6:	f8 01       	movw	r30, r16
    1be8:	86 81       	ldd	r24, Z+6	; 0x06
    1bea:	97 81       	ldd	r25, Z+7	; 0x07
    1bec:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    1bf0:	8c 01       	movw	r16, r24
    1bf2:	6b e0       	ldi	r22, 0x0B	; 11
    1bf4:	75 e0       	ldi	r23, 0x05	; 5
    1bf6:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    1bfa:	66 e0       	ldi	r22, 0x06	; 6
    1bfc:	c8 01       	movw	r24, r16
    1bfe:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1c02:	93 e0       	ldi	r25, 0x03	; 3
    1c04:	88 ed       	ldi	r24, 0xD8	; 216
    1c06:	08 b6       	in	r0, 0x38	; 56
    1c08:	18 be       	out	0x38, r1	; 56
    1c0a:	84 bf       	out	0x34, r24	; 52
    1c0c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1c10:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1c14:	81 fd       	sbrc	r24, 1
    1c16:	fc cf       	rjmp	.-8      	; 0x1c10 <_ZN9task_user3runEv+0x228>
    1c18:	08 be       	out	0x38, r0	; 56
    1c1a:	ff cf       	rjmp	.-2      	; 0x1c1a <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1c1c:	f8 01       	movw	r30, r16
    1c1e:	86 85       	ldd	r24, Z+14	; 0x0e
    1c20:	97 85       	ldd	r25, Z+15	; 0x0f
    1c22:	a0 89       	ldd	r26, Z+16	; 0x10
    1c24:	b1 89       	ldd	r27, Z+17	; 0x11
    1c26:	01 96       	adiw	r24, 0x01	; 1
    1c28:	a1 1d       	adc	r26, r1
    1c2a:	b1 1d       	adc	r27, r1
    1c2c:	86 87       	std	Z+14, r24	; 0x0e
    1c2e:	97 87       	std	Z+15, r25	; 0x0f
    1c30:	a0 8b       	std	Z+16, r26	; 0x10
    1c32:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1000));
    1c34:	68 ee       	ldi	r22, 0xE8	; 232
    1c36:	73 e0       	ldi	r23, 0x03	; 3
    1c38:	80 e0       	ldi	r24, 0x00	; 0
    1c3a:	90 e0       	ldi	r25, 0x00	; 0
    1c3c:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1c40:	f1 ce       	rjmp	.-542    	; 0x1a24 <_ZN9task_user3runEv+0x3c>

00001c42 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1c42:	0f 93       	push	r16
    1c44:	1f 93       	push	r17
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1c4c:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1c50:	80 91 a8 22 	lds	r24, 0x22A8	; 0x8022a8 <__data_end>
    1c54:	81 11       	cpse	r24, r1
    1c56:	1d c0       	rjmp	.+58     	; 0x1c92 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1c58:	ad ea       	ldi	r26, 0xAD	; 173
    1c5a:	b2 e2       	ldi	r27, 0x22	; 34
    1c5c:	e1 eb       	ldi	r30, 0xB1	; 177
    1c5e:	f2 e2       	ldi	r31, 0x22	; 34
    1c60:	ed 93       	st	X+, r30
    1c62:	fc 93       	st	X, r31
    1c64:	11 97       	sbiw	r26, 0x01	; 1
    1c66:	12 96       	adiw	r26, 0x02	; 2
    1c68:	1d 92       	st	X+, r1
    1c6a:	1c 92       	st	X, r1
    1c6c:	13 97       	sbiw	r26, 0x03	; 3
    1c6e:	a9 ea       	ldi	r26, 0xA9	; 169
    1c70:	b2 e2       	ldi	r27, 0x22	; 34
    1c72:	8f ef       	ldi	r24, 0xFF	; 255
    1c74:	9f e0       	ldi	r25, 0x0F	; 15
    1c76:	12 96       	adiw	r26, 0x02	; 2
    1c78:	8d 93       	st	X+, r24
    1c7a:	9c 93       	st	X, r25
    1c7c:	13 97       	sbiw	r26, 0x03	; 3
    1c7e:	1d 92       	st	X+, r1
    1c80:	1c 92       	st	X, r1
    1c82:	11 97       	sbiw	r26, 0x01	; 1
    1c84:	82 83       	std	Z+2, r24	; 0x02
    1c86:	93 83       	std	Z+3, r25	; 0x03
    1c88:	a0 83       	st	Z, r26
    1c8a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	80 93 a8 22 	sts	0x22A8, r24	; 0x8022a8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1c92:	20 97       	sbiw	r28, 0x00	; 0
    1c94:	09 f4       	brne	.+2      	; 0x1c98 <pvPortMalloc+0x56>
    1c96:	5f c0       	rjmp	.+190    	; 0x1d56 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1c98:	9e 01       	movw	r18, r28
    1c9a:	2b 5f       	subi	r18, 0xFB	; 251
    1c9c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    1c9e:	24 96       	adiw	r28, 0x04	; 4
    1ca0:	ce 3f       	cpi	r28, 0xFE	; 254
    1ca2:	df 40       	sbci	r29, 0x0F	; 15
    1ca4:	08 f0       	brcs	.+2      	; 0x1ca8 <pvPortMalloc+0x66>
    1ca6:	5a c0       	rjmp	.+180    	; 0x1d5c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    1ca8:	e0 91 ad 22 	lds	r30, 0x22AD	; 0x8022ad <xStart>
    1cac:	f0 91 ae 22 	lds	r31, 0x22AE	; 0x8022ae <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    1cb0:	ad ea       	ldi	r26, 0xAD	; 173
    1cb2:	b2 e2       	ldi	r27, 0x22	; 34
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1cb4:	02 c0       	rjmp	.+4      	; 0x1cba <pvPortMalloc+0x78>
    1cb6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    1cb8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1cba:	82 81       	ldd	r24, Z+2	; 0x02
    1cbc:	93 81       	ldd	r25, Z+3	; 0x03
    1cbe:	82 17       	cp	r24, r18
    1cc0:	93 07       	cpc	r25, r19
    1cc2:	20 f4       	brcc	.+8      	; 0x1ccc <pvPortMalloc+0x8a>
    1cc4:	80 81       	ld	r24, Z
    1cc6:	91 81       	ldd	r25, Z+1	; 0x01
    1cc8:	00 97       	sbiw	r24, 0x00	; 0
    1cca:	a9 f7       	brne	.-22     	; 0x1cb6 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1ccc:	c2 e2       	ldi	r28, 0x22	; 34
    1cce:	e9 3a       	cpi	r30, 0xA9	; 169
    1cd0:	fc 07       	cpc	r31, r28
    1cd2:	09 f4       	brne	.+2      	; 0x1cd6 <pvPortMalloc+0x94>
    1cd4:	46 c0       	rjmp	.+140    	; 0x1d62 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1cd6:	cd 91       	ld	r28, X+
    1cd8:	dc 91       	ld	r29, X
    1cda:	11 97       	sbiw	r26, 0x01	; 1
    1cdc:	8e 01       	movw	r16, r28
    1cde:	0b 5f       	subi	r16, 0xFB	; 251
    1ce0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1ce2:	80 81       	ld	r24, Z
    1ce4:	91 81       	ldd	r25, Z+1	; 0x01
    1ce6:	8d 93       	st	X+, r24
    1ce8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1cea:	82 81       	ldd	r24, Z+2	; 0x02
    1cec:	93 81       	ldd	r25, Z+3	; 0x03
    1cee:	82 1b       	sub	r24, r18
    1cf0:	93 0b       	sbc	r25, r19
    1cf2:	8b 30       	cpi	r24, 0x0B	; 11
    1cf4:	91 05       	cpc	r25, r1
    1cf6:	10 f1       	brcs	.+68     	; 0x1d3c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1cf8:	bf 01       	movw	r22, r30
    1cfa:	62 0f       	add	r22, r18
    1cfc:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1cfe:	db 01       	movw	r26, r22
    1d00:	12 96       	adiw	r26, 0x02	; 2
    1d02:	8d 93       	st	X+, r24
    1d04:	9c 93       	st	X, r25
    1d06:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1d08:	22 83       	std	Z+2, r18	; 0x02
    1d0a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1d0c:	12 96       	adiw	r26, 0x02	; 2
    1d0e:	4d 91       	ld	r20, X+
    1d10:	5c 91       	ld	r21, X
    1d12:	13 97       	sbiw	r26, 0x03	; 3
    1d14:	8d ea       	ldi	r24, 0xAD	; 173
    1d16:	92 e2       	ldi	r25, 0x22	; 34
    1d18:	01 c0       	rjmp	.+2      	; 0x1d1c <pvPortMalloc+0xda>
    1d1a:	cd 01       	movw	r24, r26
    1d1c:	ec 01       	movw	r28, r24
    1d1e:	a8 81       	ld	r26, Y
    1d20:	b9 81       	ldd	r27, Y+1	; 0x01
    1d22:	12 96       	adiw	r26, 0x02	; 2
    1d24:	2d 91       	ld	r18, X+
    1d26:	3c 91       	ld	r19, X
    1d28:	13 97       	sbiw	r26, 0x03	; 3
    1d2a:	24 17       	cp	r18, r20
    1d2c:	35 07       	cpc	r19, r21
    1d2e:	a8 f3       	brcs	.-22     	; 0x1d1a <pvPortMalloc+0xd8>
    1d30:	eb 01       	movw	r28, r22
    1d32:	a8 83       	st	Y, r26
    1d34:	b9 83       	std	Y+1, r27	; 0x01
    1d36:	dc 01       	movw	r26, r24
    1d38:	6d 93       	st	X+, r22
    1d3a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d3c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1d40:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1d44:	22 81       	ldd	r18, Z+2	; 0x02
    1d46:	33 81       	ldd	r19, Z+3	; 0x03
    1d48:	82 1b       	sub	r24, r18
    1d4a:	93 0b       	sbc	r25, r19
    1d4c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1d50:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1d54:	08 c0       	rjmp	.+16     	; 0x1d66 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1d56:	00 e0       	ldi	r16, 0x00	; 0
    1d58:	10 e0       	ldi	r17, 0x00	; 0
    1d5a:	05 c0       	rjmp	.+10     	; 0x1d66 <pvPortMalloc+0x124>
    1d5c:	00 e0       	ldi	r16, 0x00	; 0
    1d5e:	10 e0       	ldi	r17, 0x00	; 0
    1d60:	02 c0       	rjmp	.+4      	; 0x1d66 <pvPortMalloc+0x124>
    1d62:	00 e0       	ldi	r16, 0x00	; 0
    1d64:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1d66:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1d6a:	c8 01       	movw	r24, r16
    1d6c:	df 91       	pop	r29
    1d6e:	cf 91       	pop	r28
    1d70:	1f 91       	pop	r17
    1d72:	0f 91       	pop	r16
    1d74:	08 95       	ret

00001d76 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1d7e:	00 97       	sbiw	r24, 0x00	; 0
    1d80:	41 f1       	breq	.+80     	; 0x1dd2 <vPortFree+0x5c>
    1d82:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1d84:	8c 01       	movw	r16, r24
    1d86:	05 50       	subi	r16, 0x05	; 5
    1d88:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1d8a:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1d8e:	f8 01       	movw	r30, r16
    1d90:	42 81       	ldd	r20, Z+2	; 0x02
    1d92:	53 81       	ldd	r21, Z+3	; 0x03
    1d94:	ad ea       	ldi	r26, 0xAD	; 173
    1d96:	b2 e2       	ldi	r27, 0x22	; 34
    1d98:	01 c0       	rjmp	.+2      	; 0x1d9c <vPortFree+0x26>
    1d9a:	df 01       	movw	r26, r30
    1d9c:	ed 91       	ld	r30, X+
    1d9e:	fc 91       	ld	r31, X
    1da0:	11 97       	sbiw	r26, 0x01	; 1
    1da2:	22 81       	ldd	r18, Z+2	; 0x02
    1da4:	33 81       	ldd	r19, Z+3	; 0x03
    1da6:	24 17       	cp	r18, r20
    1da8:	35 07       	cpc	r19, r21
    1daa:	b8 f3       	brcs	.-18     	; 0x1d9a <vPortFree+0x24>
    1dac:	25 97       	sbiw	r28, 0x05	; 5
    1dae:	e8 83       	st	Y, r30
    1db0:	f9 83       	std	Y+1, r31	; 0x01
    1db2:	0d 93       	st	X+, r16
    1db4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1db6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1dba:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc2:	82 0f       	add	r24, r18
    1dc4:	93 1f       	adc	r25, r19
    1dc6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1dca:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1dce:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
	}
}
    1dd2:	df 91       	pop	r29
    1dd4:	cf 91       	pop	r28
    1dd6:	1f 91       	pop	r17
    1dd8:	0f 91       	pop	r16
    1dda:	08 95       	ret

00001ddc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1ddc:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1de0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1de4:	08 95       	ret

00001de6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1de6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1de8:	03 96       	adiw	r24, 0x03	; 3
    1dea:	81 83       	std	Z+1, r24	; 0x01
    1dec:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1dee:	4f ef       	ldi	r20, 0xFF	; 255
    1df0:	5f ef       	ldi	r21, 0xFF	; 255
    1df2:	ba 01       	movw	r22, r20
    1df4:	43 83       	std	Z+3, r20	; 0x03
    1df6:	54 83       	std	Z+4, r21	; 0x04
    1df8:	65 83       	std	Z+5, r22	; 0x05
    1dfa:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1dfc:	87 83       	std	Z+7, r24	; 0x07
    1dfe:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1e00:	81 87       	std	Z+9, r24	; 0x09
    1e02:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1e04:	10 82       	st	Z, r1
    1e06:	08 95       	ret

00001e08 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1e08:	fc 01       	movw	r30, r24
    1e0a:	12 86       	std	Z+10, r1	; 0x0a
    1e0c:	13 86       	std	Z+11, r1	; 0x0b
    1e0e:	08 95       	ret

00001e10 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	fc 01       	movw	r30, r24
    1e16:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1e18:	21 81       	ldd	r18, Z+1	; 0x01
    1e1a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1e1c:	e9 01       	movw	r28, r18
    1e1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1e20:	9d 81       	ldd	r25, Y+5	; 0x05
    1e22:	14 96       	adiw	r26, 0x04	; 4
    1e24:	8d 93       	st	X+, r24
    1e26:	9c 93       	st	X, r25
    1e28:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1e2a:	81 81       	ldd	r24, Z+1	; 0x01
    1e2c:	92 81       	ldd	r25, Z+2	; 0x02
    1e2e:	16 96       	adiw	r26, 0x06	; 6
    1e30:	8d 93       	st	X+, r24
    1e32:	9c 93       	st	X, r25
    1e34:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1e36:	8c 81       	ldd	r24, Y+4	; 0x04
    1e38:	9d 81       	ldd	r25, Y+5	; 0x05
    1e3a:	ec 01       	movw	r28, r24
    1e3c:	6e 83       	std	Y+6, r22	; 0x06
    1e3e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1e40:	e9 01       	movw	r28, r18
    1e42:	6c 83       	std	Y+4, r22	; 0x04
    1e44:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1e46:	61 83       	std	Z+1, r22	; 0x01
    1e48:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1e4a:	1a 96       	adiw	r26, 0x0a	; 10
    1e4c:	ed 93       	st	X+, r30
    1e4e:	fc 93       	st	X, r31
    1e50:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1e52:	80 81       	ld	r24, Z
    1e54:	8f 5f       	subi	r24, 0xFF	; 255
    1e56:	80 83       	st	Z, r24
}
    1e58:	df 91       	pop	r29
    1e5a:	cf 91       	pop	r28
    1e5c:	08 95       	ret

00001e5e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1e68:	08 81       	ld	r16, Y
    1e6a:	19 81       	ldd	r17, Y+1	; 0x01
    1e6c:	2a 81       	ldd	r18, Y+2	; 0x02
    1e6e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1e70:	0f 3f       	cpi	r16, 0xFF	; 255
    1e72:	4f ef       	ldi	r20, 0xFF	; 255
    1e74:	14 07       	cpc	r17, r20
    1e76:	24 07       	cpc	r18, r20
    1e78:	34 07       	cpc	r19, r20
    1e7a:	31 f4       	brne	.+12     	; 0x1e88 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1e7c:	dc 01       	movw	r26, r24
    1e7e:	19 96       	adiw	r26, 0x09	; 9
    1e80:	ed 91       	ld	r30, X+
    1e82:	fc 91       	ld	r31, X
    1e84:	1a 97       	sbiw	r26, 0x0a	; 10
    1e86:	1f c0       	rjmp	.+62     	; 0x1ec6 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1e88:	fc 01       	movw	r30, r24
    1e8a:	33 96       	adiw	r30, 0x03	; 3
    1e8c:	dc 01       	movw	r26, r24
    1e8e:	17 96       	adiw	r26, 0x07	; 7
    1e90:	4d 91       	ld	r20, X+
    1e92:	5c 91       	ld	r21, X
    1e94:	18 97       	sbiw	r26, 0x08	; 8
    1e96:	da 01       	movw	r26, r20
    1e98:	4d 91       	ld	r20, X+
    1e9a:	5d 91       	ld	r21, X+
    1e9c:	6d 91       	ld	r22, X+
    1e9e:	7c 91       	ld	r23, X
    1ea0:	04 17       	cp	r16, r20
    1ea2:	15 07       	cpc	r17, r21
    1ea4:	26 07       	cpc	r18, r22
    1ea6:	37 07       	cpc	r19, r23
    1ea8:	70 f0       	brcs	.+28     	; 0x1ec6 <vListInsert+0x68>
    1eaa:	04 80       	ldd	r0, Z+4	; 0x04
    1eac:	f5 81       	ldd	r31, Z+5	; 0x05
    1eae:	e0 2d       	mov	r30, r0
    1eb0:	a4 81       	ldd	r26, Z+4	; 0x04
    1eb2:	b5 81       	ldd	r27, Z+5	; 0x05
    1eb4:	4d 91       	ld	r20, X+
    1eb6:	5d 91       	ld	r21, X+
    1eb8:	6d 91       	ld	r22, X+
    1eba:	7c 91       	ld	r23, X
    1ebc:	04 17       	cp	r16, r20
    1ebe:	15 07       	cpc	r17, r21
    1ec0:	26 07       	cpc	r18, r22
    1ec2:	37 07       	cpc	r19, r23
    1ec4:	90 f7       	brcc	.-28     	; 0x1eaa <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1ec6:	a4 81       	ldd	r26, Z+4	; 0x04
    1ec8:	b5 81       	ldd	r27, Z+5	; 0x05
    1eca:	ac 83       	std	Y+4, r26	; 0x04
    1ecc:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1ece:	16 96       	adiw	r26, 0x06	; 6
    1ed0:	cd 93       	st	X+, r28
    1ed2:	dc 93       	st	X, r29
    1ed4:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    1ed6:	ee 83       	std	Y+6, r30	; 0x06
    1ed8:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1eda:	c4 83       	std	Z+4, r28	; 0x04
    1edc:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ede:	8a 87       	std	Y+10, r24	; 0x0a
    1ee0:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1ee2:	fc 01       	movw	r30, r24
    1ee4:	20 81       	ld	r18, Z
    1ee6:	2f 5f       	subi	r18, 0xFF	; 255
    1ee8:	20 83       	st	Z, r18
}
    1eea:	df 91       	pop	r29
    1eec:	cf 91       	pop	r28
    1eee:	1f 91       	pop	r17
    1ef0:	0f 91       	pop	r16
    1ef2:	08 95       	ret

00001ef4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1ef4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ef6:	a4 81       	ldd	r26, Z+4	; 0x04
    1ef8:	b5 81       	ldd	r27, Z+5	; 0x05
    1efa:	86 81       	ldd	r24, Z+6	; 0x06
    1efc:	97 81       	ldd	r25, Z+7	; 0x07
    1efe:	16 96       	adiw	r26, 0x06	; 6
    1f00:	8d 93       	st	X+, r24
    1f02:	9c 93       	st	X, r25
    1f04:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1f06:	a6 81       	ldd	r26, Z+6	; 0x06
    1f08:	b7 81       	ldd	r27, Z+7	; 0x07
    1f0a:	84 81       	ldd	r24, Z+4	; 0x04
    1f0c:	95 81       	ldd	r25, Z+5	; 0x05
    1f0e:	14 96       	adiw	r26, 0x04	; 4
    1f10:	8d 93       	st	X+, r24
    1f12:	9c 93       	st	X, r25
    1f14:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1f16:	a2 85       	ldd	r26, Z+10	; 0x0a
    1f18:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1f1a:	11 96       	adiw	r26, 0x01	; 1
    1f1c:	8d 91       	ld	r24, X+
    1f1e:	9c 91       	ld	r25, X
    1f20:	12 97       	sbiw	r26, 0x02	; 2
    1f22:	e8 17       	cp	r30, r24
    1f24:	f9 07       	cpc	r31, r25
    1f26:	31 f4       	brne	.+12     	; 0x1f34 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1f28:	86 81       	ldd	r24, Z+6	; 0x06
    1f2a:	97 81       	ldd	r25, Z+7	; 0x07
    1f2c:	11 96       	adiw	r26, 0x01	; 1
    1f2e:	8d 93       	st	X+, r24
    1f30:	9c 93       	st	X, r25
    1f32:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1f34:	12 86       	std	Z+10, r1	; 0x0a
    1f36:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1f38:	8c 91       	ld	r24, X
    1f3a:	81 50       	subi	r24, 0x01	; 1
    1f3c:	8c 93       	st	X, r24
    1f3e:	08 95       	ret

00001f40 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1f40:	80 93 74 33 	sts	0x3374, r24	; 0x803374 <portStackTopForTask>
    1f44:	90 93 75 33 	sts	0x3375, r25	; 0x803375 <portStackTopForTask+0x1>
    1f48:	31 e1       	ldi	r19, 0x11	; 17
    1f4a:	fc 01       	movw	r30, r24
    1f4c:	30 83       	st	Z, r19
    1f4e:	31 97       	sbiw	r30, 0x01	; 1
    1f50:	22 e2       	ldi	r18, 0x22	; 34
    1f52:	20 83       	st	Z, r18
    1f54:	31 97       	sbiw	r30, 0x01	; 1
    1f56:	a3 e3       	ldi	r26, 0x33	; 51
    1f58:	a0 83       	st	Z, r26
    1f5a:	31 97       	sbiw	r30, 0x01	; 1
    1f5c:	60 83       	st	Z, r22
    1f5e:	31 97       	sbiw	r30, 0x01	; 1
    1f60:	70 83       	st	Z, r23
    1f62:	31 97       	sbiw	r30, 0x01	; 1
    1f64:	10 82       	st	Z, r1
    1f66:	31 97       	sbiw	r30, 0x01	; 1
    1f68:	10 82       	st	Z, r1
    1f6a:	31 97       	sbiw	r30, 0x01	; 1
    1f6c:	60 e8       	ldi	r22, 0x80	; 128
    1f6e:	60 83       	st	Z, r22
    1f70:	31 97       	sbiw	r30, 0x01	; 1
    1f72:	10 82       	st	Z, r1
    1f74:	31 97       	sbiw	r30, 0x01	; 1
    1f76:	10 82       	st	Z, r1
    1f78:	31 97       	sbiw	r30, 0x01	; 1
    1f7a:	10 82       	st	Z, r1
    1f7c:	31 97       	sbiw	r30, 0x01	; 1
    1f7e:	62 e0       	ldi	r22, 0x02	; 2
    1f80:	60 83       	st	Z, r22
    1f82:	31 97       	sbiw	r30, 0x01	; 1
    1f84:	63 e0       	ldi	r22, 0x03	; 3
    1f86:	60 83       	st	Z, r22
    1f88:	31 97       	sbiw	r30, 0x01	; 1
    1f8a:	64 e0       	ldi	r22, 0x04	; 4
    1f8c:	60 83       	st	Z, r22
    1f8e:	31 97       	sbiw	r30, 0x01	; 1
    1f90:	65 e0       	ldi	r22, 0x05	; 5
    1f92:	60 83       	st	Z, r22
    1f94:	31 97       	sbiw	r30, 0x01	; 1
    1f96:	66 e0       	ldi	r22, 0x06	; 6
    1f98:	60 83       	st	Z, r22
    1f9a:	31 97       	sbiw	r30, 0x01	; 1
    1f9c:	67 e0       	ldi	r22, 0x07	; 7
    1f9e:	60 83       	st	Z, r22
    1fa0:	31 97       	sbiw	r30, 0x01	; 1
    1fa2:	68 e0       	ldi	r22, 0x08	; 8
    1fa4:	60 83       	st	Z, r22
    1fa6:	31 97       	sbiw	r30, 0x01	; 1
    1fa8:	69 e0       	ldi	r22, 0x09	; 9
    1faa:	60 83       	st	Z, r22
    1fac:	31 97       	sbiw	r30, 0x01	; 1
    1fae:	60 e1       	ldi	r22, 0x10	; 16
    1fb0:	60 83       	st	Z, r22
    1fb2:	31 97       	sbiw	r30, 0x01	; 1
    1fb4:	30 83       	st	Z, r19
    1fb6:	31 97       	sbiw	r30, 0x01	; 1
    1fb8:	32 e1       	ldi	r19, 0x12	; 18
    1fba:	30 83       	st	Z, r19
    1fbc:	31 97       	sbiw	r30, 0x01	; 1
    1fbe:	33 e1       	ldi	r19, 0x13	; 19
    1fc0:	30 83       	st	Z, r19
    1fc2:	31 97       	sbiw	r30, 0x01	; 1
    1fc4:	34 e1       	ldi	r19, 0x14	; 20
    1fc6:	30 83       	st	Z, r19
    1fc8:	31 97       	sbiw	r30, 0x01	; 1
    1fca:	35 e1       	ldi	r19, 0x15	; 21
    1fcc:	30 83       	st	Z, r19
    1fce:	31 97       	sbiw	r30, 0x01	; 1
    1fd0:	36 e1       	ldi	r19, 0x16	; 22
    1fd2:	30 83       	st	Z, r19
    1fd4:	31 97       	sbiw	r30, 0x01	; 1
    1fd6:	37 e1       	ldi	r19, 0x17	; 23
    1fd8:	30 83       	st	Z, r19
    1fda:	31 97       	sbiw	r30, 0x01	; 1
    1fdc:	38 e1       	ldi	r19, 0x18	; 24
    1fde:	30 83       	st	Z, r19
    1fe0:	31 97       	sbiw	r30, 0x01	; 1
    1fe2:	39 e1       	ldi	r19, 0x19	; 25
    1fe4:	30 83       	st	Z, r19
    1fe6:	31 97       	sbiw	r30, 0x01	; 1
    1fe8:	30 e2       	ldi	r19, 0x20	; 32
    1fea:	30 83       	st	Z, r19
    1fec:	31 97       	sbiw	r30, 0x01	; 1
    1fee:	31 e2       	ldi	r19, 0x21	; 33
    1ff0:	30 83       	st	Z, r19
    1ff2:	31 97       	sbiw	r30, 0x01	; 1
    1ff4:	20 83       	st	Z, r18
    1ff6:	31 97       	sbiw	r30, 0x01	; 1
    1ff8:	23 e2       	ldi	r18, 0x23	; 35
    1ffa:	20 83       	st	Z, r18
    1ffc:	31 97       	sbiw	r30, 0x01	; 1
    1ffe:	40 83       	st	Z, r20
    2000:	31 97       	sbiw	r30, 0x01	; 1
    2002:	50 83       	st	Z, r21
    2004:	31 97       	sbiw	r30, 0x01	; 1
    2006:	26 e2       	ldi	r18, 0x26	; 38
    2008:	20 83       	st	Z, r18
    200a:	31 97       	sbiw	r30, 0x01	; 1
    200c:	27 e2       	ldi	r18, 0x27	; 39
    200e:	20 83       	st	Z, r18
    2010:	31 97       	sbiw	r30, 0x01	; 1
    2012:	28 e2       	ldi	r18, 0x28	; 40
    2014:	20 83       	st	Z, r18
    2016:	31 97       	sbiw	r30, 0x01	; 1
    2018:	29 e2       	ldi	r18, 0x29	; 41
    201a:	20 83       	st	Z, r18
    201c:	31 97       	sbiw	r30, 0x01	; 1
    201e:	20 e3       	ldi	r18, 0x30	; 48
    2020:	20 83       	st	Z, r18
    2022:	31 97       	sbiw	r30, 0x01	; 1
    2024:	21 e3       	ldi	r18, 0x31	; 49
    2026:	20 83       	st	Z, r18
    2028:	89 97       	sbiw	r24, 0x29	; 41
    202a:	08 95       	ret

0000202c <xPortStartScheduler>:
    202c:	8c e7       	ldi	r24, 0x7C	; 124
    202e:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    2032:	8f ef       	ldi	r24, 0xFF	; 255
    2034:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    203e:	91 e1       	ldi	r25, 0x11	; 17
    2040:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    2044:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    2048:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    204c:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2050:	cd 91       	ld	r28, X+
    2052:	cd bf       	out	0x3d, r28	; 61
    2054:	dd 91       	ld	r29, X+
    2056:	de bf       	out	0x3e, r29	; 62
    2058:	ff 91       	pop	r31
    205a:	ef 91       	pop	r30
    205c:	df 91       	pop	r29
    205e:	cf 91       	pop	r28
    2060:	bf 91       	pop	r27
    2062:	af 91       	pop	r26
    2064:	9f 91       	pop	r25
    2066:	8f 91       	pop	r24
    2068:	7f 91       	pop	r23
    206a:	6f 91       	pop	r22
    206c:	5f 91       	pop	r21
    206e:	4f 91       	pop	r20
    2070:	3f 91       	pop	r19
    2072:	2f 91       	pop	r18
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	ff 90       	pop	r15
    207a:	ef 90       	pop	r14
    207c:	df 90       	pop	r13
    207e:	cf 90       	pop	r12
    2080:	bf 90       	pop	r11
    2082:	af 90       	pop	r10
    2084:	9f 90       	pop	r9
    2086:	8f 90       	pop	r8
    2088:	7f 90       	pop	r7
    208a:	6f 90       	pop	r6
    208c:	5f 90       	pop	r5
    208e:	4f 90       	pop	r4
    2090:	3f 90       	pop	r3
    2092:	2f 90       	pop	r2
    2094:	1f 90       	pop	r1
    2096:	0f 90       	pop	r0
    2098:	0c be       	out	0x3c, r0	; 60
    209a:	0f 90       	pop	r0
    209c:	0b be       	out	0x3b, r0	; 59
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	0f 90       	pop	r0
    20a4:	08 95       	ret
    20a6:	08 95       	ret

000020a8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    20a8:	0f 92       	push	r0
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	f8 94       	cli
    20ae:	0f 92       	push	r0
    20b0:	0b b6       	in	r0, 0x3b	; 59
    20b2:	0f 92       	push	r0
    20b4:	0c b6       	in	r0, 0x3c	; 60
    20b6:	0f 92       	push	r0
    20b8:	1f 92       	push	r1
    20ba:	11 24       	eor	r1, r1
    20bc:	2f 92       	push	r2
    20be:	3f 92       	push	r3
    20c0:	4f 92       	push	r4
    20c2:	5f 92       	push	r5
    20c4:	6f 92       	push	r6
    20c6:	7f 92       	push	r7
    20c8:	8f 92       	push	r8
    20ca:	9f 92       	push	r9
    20cc:	af 92       	push	r10
    20ce:	bf 92       	push	r11
    20d0:	cf 92       	push	r12
    20d2:	df 92       	push	r13
    20d4:	ef 92       	push	r14
    20d6:	ff 92       	push	r15
    20d8:	0f 93       	push	r16
    20da:	1f 93       	push	r17
    20dc:	2f 93       	push	r18
    20de:	3f 93       	push	r19
    20e0:	4f 93       	push	r20
    20e2:	5f 93       	push	r21
    20e4:	6f 93       	push	r22
    20e6:	7f 93       	push	r23
    20e8:	8f 93       	push	r24
    20ea:	9f 93       	push	r25
    20ec:	af 93       	push	r26
    20ee:	bf 93       	push	r27
    20f0:	cf 93       	push	r28
    20f2:	df 93       	push	r29
    20f4:	ef 93       	push	r30
    20f6:	ff 93       	push	r31
    20f8:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    20fc:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2100:	0d b6       	in	r0, 0x3d	; 61
    2102:	0d 92       	st	X+, r0
    2104:	0e b6       	in	r0, 0x3e	; 62
    2106:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2108:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    210c:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    2110:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2114:	cd 91       	ld	r28, X+
    2116:	cd bf       	out	0x3d, r28	; 61
    2118:	dd 91       	ld	r29, X+
    211a:	de bf       	out	0x3e, r29	; 62
    211c:	ff 91       	pop	r31
    211e:	ef 91       	pop	r30
    2120:	df 91       	pop	r29
    2122:	cf 91       	pop	r28
    2124:	bf 91       	pop	r27
    2126:	af 91       	pop	r26
    2128:	9f 91       	pop	r25
    212a:	8f 91       	pop	r24
    212c:	7f 91       	pop	r23
    212e:	6f 91       	pop	r22
    2130:	5f 91       	pop	r21
    2132:	4f 91       	pop	r20
    2134:	3f 91       	pop	r19
    2136:	2f 91       	pop	r18
    2138:	1f 91       	pop	r17
    213a:	0f 91       	pop	r16
    213c:	ff 90       	pop	r15
    213e:	ef 90       	pop	r14
    2140:	df 90       	pop	r13
    2142:	cf 90       	pop	r12
    2144:	bf 90       	pop	r11
    2146:	af 90       	pop	r10
    2148:	9f 90       	pop	r9
    214a:	8f 90       	pop	r8
    214c:	7f 90       	pop	r7
    214e:	6f 90       	pop	r6
    2150:	5f 90       	pop	r5
    2152:	4f 90       	pop	r4
    2154:	3f 90       	pop	r3
    2156:	2f 90       	pop	r2
    2158:	1f 90       	pop	r1
    215a:	0f 90       	pop	r0
    215c:	0c be       	out	0x3c, r0	; 60
    215e:	0f 90       	pop	r0
    2160:	0b be       	out	0x3b, r0	; 59
    2162:	0f 90       	pop	r0
    2164:	0f be       	out	0x3f, r0	; 63
    2166:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2168:	08 95       	ret

0000216a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    216a:	0f 92       	push	r0
    216c:	0f b6       	in	r0, 0x3f	; 63
    216e:	f8 94       	cli
    2170:	0f 92       	push	r0
    2172:	0b b6       	in	r0, 0x3b	; 59
    2174:	0f 92       	push	r0
    2176:	0c b6       	in	r0, 0x3c	; 60
    2178:	0f 92       	push	r0
    217a:	1f 92       	push	r1
    217c:	11 24       	eor	r1, r1
    217e:	2f 92       	push	r2
    2180:	3f 92       	push	r3
    2182:	4f 92       	push	r4
    2184:	5f 92       	push	r5
    2186:	6f 92       	push	r6
    2188:	7f 92       	push	r7
    218a:	8f 92       	push	r8
    218c:	9f 92       	push	r9
    218e:	af 92       	push	r10
    2190:	bf 92       	push	r11
    2192:	cf 92       	push	r12
    2194:	df 92       	push	r13
    2196:	ef 92       	push	r14
    2198:	ff 92       	push	r15
    219a:	0f 93       	push	r16
    219c:	1f 93       	push	r17
    219e:	2f 93       	push	r18
    21a0:	3f 93       	push	r19
    21a2:	4f 93       	push	r20
    21a4:	5f 93       	push	r21
    21a6:	6f 93       	push	r22
    21a8:	7f 93       	push	r23
    21aa:	8f 93       	push	r24
    21ac:	9f 93       	push	r25
    21ae:	af 93       	push	r26
    21b0:	bf 93       	push	r27
    21b2:	cf 93       	push	r28
    21b4:	df 93       	push	r29
    21b6:	ef 93       	push	r30
    21b8:	ff 93       	push	r31
    21ba:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    21be:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    21c2:	0d b6       	in	r0, 0x3d	; 61
    21c4:	0d 92       	st	X+, r0
    21c6:	0e b6       	in	r0, 0x3e	; 62
    21c8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    21ca:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vTaskIncrementTick>
	vTaskSwitchContext();
    21ce:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    21d2:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    21d6:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    21da:	cd 91       	ld	r28, X+
    21dc:	cd bf       	out	0x3d, r28	; 61
    21de:	dd 91       	ld	r29, X+
    21e0:	de bf       	out	0x3e, r29	; 62
    21e2:	ff 91       	pop	r31
    21e4:	ef 91       	pop	r30
    21e6:	df 91       	pop	r29
    21e8:	cf 91       	pop	r28
    21ea:	bf 91       	pop	r27
    21ec:	af 91       	pop	r26
    21ee:	9f 91       	pop	r25
    21f0:	8f 91       	pop	r24
    21f2:	7f 91       	pop	r23
    21f4:	6f 91       	pop	r22
    21f6:	5f 91       	pop	r21
    21f8:	4f 91       	pop	r20
    21fa:	3f 91       	pop	r19
    21fc:	2f 91       	pop	r18
    21fe:	1f 91       	pop	r17
    2200:	0f 91       	pop	r16
    2202:	ff 90       	pop	r15
    2204:	ef 90       	pop	r14
    2206:	df 90       	pop	r13
    2208:	cf 90       	pop	r12
    220a:	bf 90       	pop	r11
    220c:	af 90       	pop	r10
    220e:	9f 90       	pop	r9
    2210:	8f 90       	pop	r8
    2212:	7f 90       	pop	r7
    2214:	6f 90       	pop	r6
    2216:	5f 90       	pop	r5
    2218:	4f 90       	pop	r4
    221a:	3f 90       	pop	r3
    221c:	2f 90       	pop	r2
    221e:	1f 90       	pop	r1
    2220:	0f 90       	pop	r0
    2222:	0c be       	out	0x3c, r0	; 60
    2224:	0f 90       	pop	r0
    2226:	0b be       	out	0x3b, r0	; 59
    2228:	0f 90       	pop	r0
    222a:	0f be       	out	0x3f, r0	; 63
    222c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    222e:	08 95       	ret

00002230 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    2230:	0e 94 b5 10 	call	0x216a	; 0x216a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2234:	18 95       	reti

00002236 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    2236:	cf 93       	push	r28
    2238:	df 93       	push	r29
    223a:	ec 01       	movw	r28, r24
    223c:	88 a1       	ldd	r24, Y+32	; 0x20
    223e:	81 11       	cpse	r24, r1
    2240:	0b c0       	rjmp	.+22     	; 0x2258 <prvCopyDataToQueue+0x22>
    2242:	88 81       	ld	r24, Y
    2244:	99 81       	ldd	r25, Y+1	; 0x01
    2246:	89 2b       	or	r24, r25
    2248:	e1 f5       	brne	.+120    	; 0x22c2 <prvCopyDataToQueue+0x8c>
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	9b 81       	ldd	r25, Y+3	; 0x03
    224e:	0e 94 1e 19 	call	0x323c	; 0x323c <vTaskPriorityDisinherit>
    2252:	1a 82       	std	Y+2, r1	; 0x02
    2254:	1b 82       	std	Y+3, r1	; 0x03
    2256:	35 c0       	rjmp	.+106    	; 0x22c2 <prvCopyDataToQueue+0x8c>
    2258:	41 11       	cpse	r20, r1
    225a:	17 c0       	rjmp	.+46     	; 0x228a <prvCopyDataToQueue+0x54>
    225c:	48 2f       	mov	r20, r24
    225e:	50 e0       	ldi	r21, 0x00	; 0
    2260:	8c 81       	ldd	r24, Y+4	; 0x04
    2262:	9d 81       	ldd	r25, Y+5	; 0x05
    2264:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <memcpy>
    2268:	28 a1       	ldd	r18, Y+32	; 0x20
    226a:	8c 81       	ldd	r24, Y+4	; 0x04
    226c:	9d 81       	ldd	r25, Y+5	; 0x05
    226e:	82 0f       	add	r24, r18
    2270:	91 1d       	adc	r25, r1
    2272:	8c 83       	std	Y+4, r24	; 0x04
    2274:	9d 83       	std	Y+5, r25	; 0x05
    2276:	2a 81       	ldd	r18, Y+2	; 0x02
    2278:	3b 81       	ldd	r19, Y+3	; 0x03
    227a:	82 17       	cp	r24, r18
    227c:	93 07       	cpc	r25, r19
    227e:	08 f1       	brcs	.+66     	; 0x22c2 <prvCopyDataToQueue+0x8c>
    2280:	88 81       	ld	r24, Y
    2282:	99 81       	ldd	r25, Y+1	; 0x01
    2284:	8c 83       	std	Y+4, r24	; 0x04
    2286:	9d 83       	std	Y+5, r25	; 0x05
    2288:	1c c0       	rjmp	.+56     	; 0x22c2 <prvCopyDataToQueue+0x8c>
    228a:	48 2f       	mov	r20, r24
    228c:	50 e0       	ldi	r21, 0x00	; 0
    228e:	8e 81       	ldd	r24, Y+6	; 0x06
    2290:	9f 81       	ldd	r25, Y+7	; 0x07
    2292:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <memcpy>
    2296:	88 a1       	ldd	r24, Y+32	; 0x20
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	91 95       	neg	r25
    229c:	81 95       	neg	r24
    229e:	91 09       	sbc	r25, r1
    22a0:	2e 81       	ldd	r18, Y+6	; 0x06
    22a2:	3f 81       	ldd	r19, Y+7	; 0x07
    22a4:	28 0f       	add	r18, r24
    22a6:	39 1f       	adc	r19, r25
    22a8:	2e 83       	std	Y+6, r18	; 0x06
    22aa:	3f 83       	std	Y+7, r19	; 0x07
    22ac:	48 81       	ld	r20, Y
    22ae:	59 81       	ldd	r21, Y+1	; 0x01
    22b0:	24 17       	cp	r18, r20
    22b2:	35 07       	cpc	r19, r21
    22b4:	30 f4       	brcc	.+12     	; 0x22c2 <prvCopyDataToQueue+0x8c>
    22b6:	2a 81       	ldd	r18, Y+2	; 0x02
    22b8:	3b 81       	ldd	r19, Y+3	; 0x03
    22ba:	82 0f       	add	r24, r18
    22bc:	93 1f       	adc	r25, r19
    22be:	8e 83       	std	Y+6, r24	; 0x06
    22c0:	9f 83       	std	Y+7, r25	; 0x07
    22c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22c4:	8f 5f       	subi	r24, 0xFF	; 255
    22c6:	8e 8f       	std	Y+30, r24	; 0x1e
    22c8:	df 91       	pop	r29
    22ca:	cf 91       	pop	r28
    22cc:	08 95       	ret

000022ce <prvCopyDataFromQueue>:
    22ce:	fc 01       	movw	r30, r24
    22d0:	80 81       	ld	r24, Z
    22d2:	91 81       	ldd	r25, Z+1	; 0x01
    22d4:	00 97       	sbiw	r24, 0x00	; 0
    22d6:	a1 f0       	breq	.+40     	; 0x2300 <prvCopyDataFromQueue+0x32>
    22d8:	40 a1       	ldd	r20, Z+32	; 0x20
    22da:	50 e0       	ldi	r21, 0x00	; 0
    22dc:	26 81       	ldd	r18, Z+6	; 0x06
    22de:	37 81       	ldd	r19, Z+7	; 0x07
    22e0:	24 0f       	add	r18, r20
    22e2:	35 1f       	adc	r19, r21
    22e4:	26 83       	std	Z+6, r18	; 0x06
    22e6:	37 83       	std	Z+7, r19	; 0x07
    22e8:	a2 81       	ldd	r26, Z+2	; 0x02
    22ea:	b3 81       	ldd	r27, Z+3	; 0x03
    22ec:	2a 17       	cp	r18, r26
    22ee:	3b 07       	cpc	r19, r27
    22f0:	10 f0       	brcs	.+4      	; 0x22f6 <prvCopyDataFromQueue+0x28>
    22f2:	86 83       	std	Z+6, r24	; 0x06
    22f4:	97 83       	std	Z+7, r25	; 0x07
    22f6:	cb 01       	movw	r24, r22
    22f8:	66 81       	ldd	r22, Z+6	; 0x06
    22fa:	77 81       	ldd	r23, Z+7	; 0x07
    22fc:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <memcpy>
    2300:	08 95       	ret

00002302 <prvUnlockQueue>:
    2302:	0f 93       	push	r16
    2304:	1f 93       	push	r17
    2306:	cf 93       	push	r28
    2308:	df 93       	push	r29
    230a:	ec 01       	movw	r28, r24
    230c:	0f b6       	in	r0, 0x3f	; 63
    230e:	f8 94       	cli
    2310:	0f 92       	push	r0
    2312:	8a a1       	ldd	r24, Y+34	; 0x22
    2314:	18 16       	cp	r1, r24
    2316:	b4 f4       	brge	.+44     	; 0x2344 <prvUnlockQueue+0x42>
    2318:	8b 89       	ldd	r24, Y+19	; 0x13
    231a:	81 11       	cpse	r24, r1
    231c:	05 c0       	rjmp	.+10     	; 0x2328 <prvUnlockQueue+0x26>
    231e:	12 c0       	rjmp	.+36     	; 0x2344 <prvUnlockQueue+0x42>
    2320:	8b 89       	ldd	r24, Y+19	; 0x13
    2322:	81 11       	cpse	r24, r1
    2324:	04 c0       	rjmp	.+8      	; 0x232e <prvUnlockQueue+0x2c>
    2326:	0e c0       	rjmp	.+28     	; 0x2344 <prvUnlockQueue+0x42>
    2328:	8e 01       	movw	r16, r28
    232a:	0d 5e       	subi	r16, 0xED	; 237
    232c:	1f 4f       	sbci	r17, 0xFF	; 255
    232e:	c8 01       	movw	r24, r16
    2330:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    2334:	81 11       	cpse	r24, r1
    2336:	0e 94 a7 18 	call	0x314e	; 0x314e <vTaskMissedYield>
    233a:	8a a1       	ldd	r24, Y+34	; 0x22
    233c:	81 50       	subi	r24, 0x01	; 1
    233e:	8a a3       	std	Y+34, r24	; 0x22
    2340:	18 16       	cp	r1, r24
    2342:	74 f3       	brlt	.-36     	; 0x2320 <prvUnlockQueue+0x1e>
    2344:	8f ef       	ldi	r24, 0xFF	; 255
    2346:	8a a3       	std	Y+34, r24	; 0x22
    2348:	0f 90       	pop	r0
    234a:	0f be       	out	0x3f, r0	; 63
    234c:	0f b6       	in	r0, 0x3f	; 63
    234e:	f8 94       	cli
    2350:	0f 92       	push	r0
    2352:	89 a1       	ldd	r24, Y+33	; 0x21
    2354:	18 16       	cp	r1, r24
    2356:	b4 f4       	brge	.+44     	; 0x2384 <prvUnlockQueue+0x82>
    2358:	88 85       	ldd	r24, Y+8	; 0x08
    235a:	81 11       	cpse	r24, r1
    235c:	05 c0       	rjmp	.+10     	; 0x2368 <prvUnlockQueue+0x66>
    235e:	12 c0       	rjmp	.+36     	; 0x2384 <prvUnlockQueue+0x82>
    2360:	88 85       	ldd	r24, Y+8	; 0x08
    2362:	81 11       	cpse	r24, r1
    2364:	04 c0       	rjmp	.+8      	; 0x236e <prvUnlockQueue+0x6c>
    2366:	0e c0       	rjmp	.+28     	; 0x2384 <prvUnlockQueue+0x82>
    2368:	8e 01       	movw	r16, r28
    236a:	08 5f       	subi	r16, 0xF8	; 248
    236c:	1f 4f       	sbci	r17, 0xFF	; 255
    236e:	c8 01       	movw	r24, r16
    2370:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    2374:	81 11       	cpse	r24, r1
    2376:	0e 94 a7 18 	call	0x314e	; 0x314e <vTaskMissedYield>
    237a:	89 a1       	ldd	r24, Y+33	; 0x21
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	89 a3       	std	Y+33, r24	; 0x21
    2380:	18 16       	cp	r1, r24
    2382:	74 f3       	brlt	.-36     	; 0x2360 <prvUnlockQueue+0x5e>
    2384:	8f ef       	ldi	r24, 0xFF	; 255
    2386:	89 a3       	std	Y+33, r24	; 0x21
    2388:	0f 90       	pop	r0
    238a:	0f be       	out	0x3f, r0	; 63
    238c:	df 91       	pop	r29
    238e:	cf 91       	pop	r28
    2390:	1f 91       	pop	r17
    2392:	0f 91       	pop	r16
    2394:	08 95       	ret

00002396 <xQueueGenericReset>:
    2396:	1f 93       	push	r17
    2398:	cf 93       	push	r28
    239a:	df 93       	push	r29
    239c:	61 30       	cpi	r22, 0x01	; 1
    239e:	59 f0       	breq	.+22     	; 0x23b6 <xQueueGenericReset+0x20>
    23a0:	fc 01       	movw	r30, r24
    23a2:	23 89       	ldd	r18, Z+19	; 0x13
    23a4:	30 85       	ldd	r19, Z+8	; 0x08
    23a6:	31 11       	cpse	r19, r1
    23a8:	2c c0       	rjmp	.+88     	; 0x2402 <xQueueGenericReset+0x6c>
    23aa:	11 e0       	ldi	r17, 0x01	; 1
    23ac:	21 11       	cpse	r18, r1
    23ae:	10 e0       	ldi	r17, 0x00	; 0
    23b0:	21 11       	cpse	r18, r1
    23b2:	28 c0       	rjmp	.+80     	; 0x2404 <xQueueGenericReset+0x6e>
    23b4:	01 c0       	rjmp	.+2      	; 0x23b8 <xQueueGenericReset+0x22>
    23b6:	11 e0       	ldi	r17, 0x01	; 1
    23b8:	ec 01       	movw	r28, r24
    23ba:	48 81       	ld	r20, Y
    23bc:	59 81       	ldd	r21, Y+1	; 0x01
    23be:	28 a1       	ldd	r18, Y+32	; 0x20
    23c0:	30 e0       	ldi	r19, 0x00	; 0
    23c2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    23c4:	62 9f       	mul	r22, r18
    23c6:	c0 01       	movw	r24, r0
    23c8:	63 9f       	mul	r22, r19
    23ca:	90 0d       	add	r25, r0
    23cc:	11 24       	eor	r1, r1
    23ce:	ba 01       	movw	r22, r20
    23d0:	68 0f       	add	r22, r24
    23d2:	79 1f       	adc	r23, r25
    23d4:	6a 83       	std	Y+2, r22	; 0x02
    23d6:	7b 83       	std	Y+3, r23	; 0x03
    23d8:	1e 8e       	std	Y+30, r1	; 0x1e
    23da:	4c 83       	std	Y+4, r20	; 0x04
    23dc:	5d 83       	std	Y+5, r21	; 0x05
    23de:	82 1b       	sub	r24, r18
    23e0:	93 0b       	sbc	r25, r19
    23e2:	84 0f       	add	r24, r20
    23e4:	95 1f       	adc	r25, r21
    23e6:	8e 83       	std	Y+6, r24	; 0x06
    23e8:	9f 83       	std	Y+7, r25	; 0x07
    23ea:	8f ef       	ldi	r24, 0xFF	; 255
    23ec:	89 a3       	std	Y+33, r24	; 0x21
    23ee:	8a a3       	std	Y+34, r24	; 0x22
    23f0:	ce 01       	movw	r24, r28
    23f2:	08 96       	adiw	r24, 0x08	; 8
    23f4:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    23f8:	ce 01       	movw	r24, r28
    23fa:	43 96       	adiw	r24, 0x13	; 19
    23fc:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    2400:	01 c0       	rjmp	.+2      	; 0x2404 <xQueueGenericReset+0x6e>
    2402:	10 e0       	ldi	r17, 0x00	; 0
    2404:	81 2f       	mov	r24, r17
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	1f 91       	pop	r17
    240c:	08 95       	ret

0000240e <xQueueGenericCreate>:
    240e:	0f 93       	push	r16
    2410:	1f 93       	push	r17
    2412:	cf 93       	push	r28
    2414:	df 93       	push	r29
    2416:	88 23       	and	r24, r24
    2418:	01 f1       	breq	.+64     	; 0x245a <xQueueGenericCreate+0x4c>
    241a:	06 2f       	mov	r16, r22
    241c:	18 2f       	mov	r17, r24
    241e:	83 e2       	ldi	r24, 0x23	; 35
    2420:	90 e0       	ldi	r25, 0x00	; 0
    2422:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    2426:	ec 01       	movw	r28, r24
    2428:	89 2b       	or	r24, r25
    242a:	c9 f0       	breq	.+50     	; 0x245e <xQueueGenericCreate+0x50>
    242c:	10 9f       	mul	r17, r16
    242e:	c0 01       	movw	r24, r0
    2430:	11 24       	eor	r1, r1
    2432:	01 96       	adiw	r24, 0x01	; 1
    2434:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    2438:	88 83       	st	Y, r24
    243a:	99 83       	std	Y+1, r25	; 0x01
    243c:	89 2b       	or	r24, r25
    243e:	39 f0       	breq	.+14     	; 0x244e <xQueueGenericCreate+0x40>
    2440:	1f 8f       	std	Y+31, r17	; 0x1f
    2442:	08 a3       	std	Y+32, r16	; 0x20
    2444:	61 e0       	ldi	r22, 0x01	; 1
    2446:	ce 01       	movw	r24, r28
    2448:	0e 94 cb 11 	call	0x2396	; 0x2396 <xQueueGenericReset>
    244c:	08 c0       	rjmp	.+16     	; 0x245e <xQueueGenericCreate+0x50>
    244e:	ce 01       	movw	r24, r28
    2450:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vPortFree>
    2454:	c0 e0       	ldi	r28, 0x00	; 0
    2456:	d0 e0       	ldi	r29, 0x00	; 0
    2458:	02 c0       	rjmp	.+4      	; 0x245e <xQueueGenericCreate+0x50>
    245a:	c0 e0       	ldi	r28, 0x00	; 0
    245c:	d0 e0       	ldi	r29, 0x00	; 0
    245e:	ce 01       	movw	r24, r28
    2460:	df 91       	pop	r29
    2462:	cf 91       	pop	r28
    2464:	1f 91       	pop	r17
    2466:	0f 91       	pop	r16
    2468:	08 95       	ret

0000246a <xQueueGenericSend>:
    246a:	af 92       	push	r10
    246c:	bf 92       	push	r11
    246e:	cf 92       	push	r12
    2470:	df 92       	push	r13
    2472:	ef 92       	push	r14
    2474:	ff 92       	push	r15
    2476:	0f 93       	push	r16
    2478:	1f 93       	push	r17
    247a:	cf 93       	push	r28
    247c:	df 93       	push	r29
    247e:	cd b7       	in	r28, 0x3d	; 61
    2480:	de b7       	in	r29, 0x3e	; 62
    2482:	29 97       	sbiw	r28, 0x09	; 9
    2484:	cd bf       	out	0x3d, r28	; 61
    2486:	de bf       	out	0x3e, r29	; 62
    2488:	7c 01       	movw	r14, r24
    248a:	5b 01       	movw	r10, r22
    248c:	2e 83       	std	Y+6, r18	; 0x06
    248e:	3f 83       	std	Y+7, r19	; 0x07
    2490:	48 87       	std	Y+8, r20	; 0x08
    2492:	59 87       	std	Y+9, r21	; 0x09
    2494:	10 e0       	ldi	r17, 0x00	; 0
    2496:	6c 01       	movw	r12, r24
    2498:	88 e0       	ldi	r24, 0x08	; 8
    249a:	c8 0e       	add	r12, r24
    249c:	d1 1c       	adc	r13, r1
    249e:	0f b6       	in	r0, 0x3f	; 63
    24a0:	f8 94       	cli
    24a2:	0f 92       	push	r0
    24a4:	f7 01       	movw	r30, r14
    24a6:	96 8d       	ldd	r25, Z+30	; 0x1e
    24a8:	87 8d       	ldd	r24, Z+31	; 0x1f
    24aa:	98 17       	cp	r25, r24
    24ac:	a8 f4       	brcc	.+42     	; 0x24d8 <xQueueGenericSend+0x6e>
    24ae:	40 2f       	mov	r20, r16
    24b0:	b5 01       	movw	r22, r10
    24b2:	c7 01       	movw	r24, r14
    24b4:	0e 94 1b 11 	call	0x2236	; 0x2236 <prvCopyDataToQueue>
    24b8:	f7 01       	movw	r30, r14
    24ba:	83 89       	ldd	r24, Z+19	; 0x13
    24bc:	88 23       	and	r24, r24
    24be:	41 f0       	breq	.+16     	; 0x24d0 <xQueueGenericSend+0x66>
    24c0:	c7 01       	movw	r24, r14
    24c2:	43 96       	adiw	r24, 0x13	; 19
    24c4:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    24c8:	81 30       	cpi	r24, 0x01	; 1
    24ca:	11 f4       	brne	.+4      	; 0x24d0 <xQueueGenericSend+0x66>
    24cc:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    24d0:	0f 90       	pop	r0
    24d2:	0f be       	out	0x3f, r0	; 63
    24d4:	81 e0       	ldi	r24, 0x01	; 1
    24d6:	56 c0       	rjmp	.+172    	; 0x2584 <xQueueGenericSend+0x11a>
    24d8:	8e 81       	ldd	r24, Y+6	; 0x06
    24da:	9f 81       	ldd	r25, Y+7	; 0x07
    24dc:	a8 85       	ldd	r26, Y+8	; 0x08
    24de:	b9 85       	ldd	r27, Y+9	; 0x09
    24e0:	89 2b       	or	r24, r25
    24e2:	8a 2b       	or	r24, r26
    24e4:	8b 2b       	or	r24, r27
    24e6:	21 f4       	brne	.+8      	; 0x24f0 <xQueueGenericSend+0x86>
    24e8:	0f 90       	pop	r0
    24ea:	0f be       	out	0x3f, r0	; 63
    24ec:	80 e0       	ldi	r24, 0x00	; 0
    24ee:	4a c0       	rjmp	.+148    	; 0x2584 <xQueueGenericSend+0x11a>
    24f0:	11 11       	cpse	r17, r1
    24f2:	05 c0       	rjmp	.+10     	; 0x24fe <xQueueGenericSend+0x94>
    24f4:	ce 01       	movw	r24, r28
    24f6:	01 96       	adiw	r24, 0x01	; 1
    24f8:	0e 94 29 18 	call	0x3052	; 0x3052 <vTaskSetTimeOutState>
    24fc:	11 e0       	ldi	r17, 0x01	; 1
    24fe:	0f 90       	pop	r0
    2500:	0f be       	out	0x3f, r0	; 63
    2502:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSuspendAll>
    2506:	0f b6       	in	r0, 0x3f	; 63
    2508:	f8 94       	cli
    250a:	0f 92       	push	r0
    250c:	f7 01       	movw	r30, r14
    250e:	81 a1       	ldd	r24, Z+33	; 0x21
    2510:	8f 3f       	cpi	r24, 0xFF	; 255
    2512:	09 f4       	brne	.+2      	; 0x2516 <xQueueGenericSend+0xac>
    2514:	11 a2       	std	Z+33, r1	; 0x21
    2516:	f7 01       	movw	r30, r14
    2518:	82 a1       	ldd	r24, Z+34	; 0x22
    251a:	8f 3f       	cpi	r24, 0xFF	; 255
    251c:	09 f4       	brne	.+2      	; 0x2520 <xQueueGenericSend+0xb6>
    251e:	12 a2       	std	Z+34, r1	; 0x22
    2520:	0f 90       	pop	r0
    2522:	0f be       	out	0x3f, r0	; 63
    2524:	be 01       	movw	r22, r28
    2526:	6a 5f       	subi	r22, 0xFA	; 250
    2528:	7f 4f       	sbci	r23, 0xFF	; 255
    252a:	ce 01       	movw	r24, r28
    252c:	01 96       	adiw	r24, 0x01	; 1
    252e:	0e 94 3a 18 	call	0x3074	; 0x3074 <xTaskCheckForTimeOut>
    2532:	81 11       	cpse	r24, r1
    2534:	21 c0       	rjmp	.+66     	; 0x2578 <xQueueGenericSend+0x10e>
    2536:	0f b6       	in	r0, 0x3f	; 63
    2538:	f8 94       	cli
    253a:	0f 92       	push	r0
    253c:	f7 01       	movw	r30, r14
    253e:	96 8d       	ldd	r25, Z+30	; 0x1e
    2540:	0f 90       	pop	r0
    2542:	0f be       	out	0x3f, r0	; 63
    2544:	87 8d       	ldd	r24, Z+31	; 0x1f
    2546:	98 13       	cpse	r25, r24
    2548:	11 c0       	rjmp	.+34     	; 0x256c <xQueueGenericSend+0x102>
    254a:	4e 81       	ldd	r20, Y+6	; 0x06
    254c:	5f 81       	ldd	r21, Y+7	; 0x07
    254e:	68 85       	ldd	r22, Y+8	; 0x08
    2550:	79 85       	ldd	r23, Y+9	; 0x09
    2552:	c6 01       	movw	r24, r12
    2554:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vTaskPlaceOnEventList>
    2558:	c7 01       	movw	r24, r14
    255a:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
    255e:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
    2562:	81 11       	cpse	r24, r1
    2564:	9c cf       	rjmp	.-200    	; 0x249e <xQueueGenericSend+0x34>
    2566:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    256a:	99 cf       	rjmp	.-206    	; 0x249e <xQueueGenericSend+0x34>
    256c:	c7 01       	movw	r24, r14
    256e:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
    2572:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
    2576:	93 cf       	rjmp	.-218    	; 0x249e <xQueueGenericSend+0x34>
    2578:	c7 01       	movw	r24, r14
    257a:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
    257e:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	29 96       	adiw	r28, 0x09	; 9
    2586:	cd bf       	out	0x3d, r28	; 61
    2588:	de bf       	out	0x3e, r29	; 62
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	ff 90       	pop	r15
    2594:	ef 90       	pop	r14
    2596:	df 90       	pop	r13
    2598:	cf 90       	pop	r12
    259a:	bf 90       	pop	r11
    259c:	af 90       	pop	r10
    259e:	08 95       	ret

000025a0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    25a0:	0f 93       	push	r16
    25a2:	1f 93       	push	r17
    25a4:	cf 93       	push	r28
    25a6:	df 93       	push	r29
    25a8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    25aa:	fc 01       	movw	r30, r24
    25ac:	56 8d       	ldd	r21, Z+30	; 0x1e
    25ae:	37 8d       	ldd	r19, Z+31	; 0x1f
    25b0:	53 17       	cp	r21, r19
    25b2:	c0 f4       	brcc	.+48     	; 0x25e4 <xQueueGenericSendFromISR+0x44>
    25b4:	42 2f       	mov	r20, r18
    25b6:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    25b8:	0e 94 1b 11 	call	0x2236	; 0x2236 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    25bc:	8a a1       	ldd	r24, Y+34	; 0x22
    25be:	8f 3f       	cpi	r24, 0xFF	; 255
    25c0:	69 f4       	brne	.+26     	; 0x25dc <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25c2:	8b 89       	ldd	r24, Y+19	; 0x13
    25c4:	88 23       	and	r24, r24
    25c6:	81 f0       	breq	.+32     	; 0x25e8 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25c8:	ce 01       	movw	r24, r28
    25ca:	43 96       	adiw	r24, 0x13	; 19
    25cc:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    25d0:	88 23       	and	r24, r24
    25d2:	61 f0       	breq	.+24     	; 0x25ec <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    25d4:	81 e0       	ldi	r24, 0x01	; 1
    25d6:	f8 01       	movw	r30, r16
    25d8:	80 83       	st	Z, r24
    25da:	09 c0       	rjmp	.+18     	; 0x25ee <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    25dc:	8f 5f       	subi	r24, 0xFF	; 255
    25de:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    25e0:	81 e0       	ldi	r24, 0x01	; 1
    25e2:	05 c0       	rjmp	.+10     	; 0x25ee <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    25e4:	80 e0       	ldi	r24, 0x00	; 0
    25e6:	03 c0       	rjmp	.+6      	; 0x25ee <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	01 c0       	rjmp	.+2      	; 0x25ee <xQueueGenericSendFromISR+0x4e>
    25ec:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    25ee:	df 91       	pop	r29
    25f0:	cf 91       	pop	r28
    25f2:	1f 91       	pop	r17
    25f4:	0f 91       	pop	r16
    25f6:	08 95       	ret

000025f8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    25f8:	af 92       	push	r10
    25fa:	bf 92       	push	r11
    25fc:	cf 92       	push	r12
    25fe:	df 92       	push	r13
    2600:	ef 92       	push	r14
    2602:	ff 92       	push	r15
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	cf 93       	push	r28
    260a:	df 93       	push	r29
    260c:	cd b7       	in	r28, 0x3d	; 61
    260e:	de b7       	in	r29, 0x3e	; 62
    2610:	29 97       	sbiw	r28, 0x09	; 9
    2612:	cd bf       	out	0x3d, r28	; 61
    2614:	de bf       	out	0x3e, r29	; 62
    2616:	7c 01       	movw	r14, r24
    2618:	5b 01       	movw	r10, r22
    261a:	2e 83       	std	Y+6, r18	; 0x06
    261c:	3f 83       	std	Y+7, r19	; 0x07
    261e:	48 87       	std	Y+8, r20	; 0x08
    2620:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2622:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2624:	6c 01       	movw	r12, r24
    2626:	83 e1       	ldi	r24, 0x13	; 19
    2628:	c8 0e       	add	r12, r24
    262a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    262c:	0f b6       	in	r0, 0x3f	; 63
    262e:	f8 94       	cli
    2630:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2632:	f7 01       	movw	r30, r14
    2634:	86 8d       	ldd	r24, Z+30	; 0x1e
    2636:	88 23       	and	r24, r24
    2638:	99 f1       	breq	.+102    	; 0x26a0 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    263a:	c6 80       	ldd	r12, Z+6	; 0x06
    263c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    263e:	b5 01       	movw	r22, r10
    2640:	c7 01       	movw	r24, r14
    2642:	0e 94 67 11 	call	0x22ce	; 0x22ce <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2646:	01 11       	cpse	r16, r1
    2648:	1a c0       	rjmp	.+52     	; 0x267e <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    264a:	f7 01       	movw	r30, r14
    264c:	86 8d       	ldd	r24, Z+30	; 0x1e
    264e:	81 50       	subi	r24, 0x01	; 1
    2650:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2652:	80 81       	ld	r24, Z
    2654:	91 81       	ldd	r25, Z+1	; 0x01
    2656:	89 2b       	or	r24, r25
    2658:	29 f4       	brne	.+10     	; 0x2664 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    265a:	0e 94 c4 18 	call	0x3188	; 0x3188 <xTaskGetCurrentTaskHandle>
    265e:	f7 01       	movw	r30, r14
    2660:	82 83       	std	Z+2, r24	; 0x02
    2662:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2664:	f7 01       	movw	r30, r14
    2666:	80 85       	ldd	r24, Z+8	; 0x08
    2668:	88 23       	and	r24, r24
    266a:	b1 f0       	breq	.+44     	; 0x2698 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    266c:	c7 01       	movw	r24, r14
    266e:	08 96       	adiw	r24, 0x08	; 8
    2670:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    2674:	81 30       	cpi	r24, 0x01	; 1
    2676:	81 f4       	brne	.+32     	; 0x2698 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    2678:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    267c:	0d c0       	rjmp	.+26     	; 0x2698 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    267e:	f7 01       	movw	r30, r14
    2680:	c6 82       	std	Z+6, r12	; 0x06
    2682:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2684:	83 89       	ldd	r24, Z+19	; 0x13
    2686:	88 23       	and	r24, r24
    2688:	39 f0       	breq	.+14     	; 0x2698 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    268a:	c7 01       	movw	r24, r14
    268c:	43 96       	adiw	r24, 0x13	; 19
    268e:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    2692:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2694:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    2698:	0f 90       	pop	r0
    269a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	62 c0       	rjmp	.+196    	; 0x2764 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    26a0:	8e 81       	ldd	r24, Y+6	; 0x06
    26a2:	9f 81       	ldd	r25, Y+7	; 0x07
    26a4:	a8 85       	ldd	r26, Y+8	; 0x08
    26a6:	b9 85       	ldd	r27, Y+9	; 0x09
    26a8:	89 2b       	or	r24, r25
    26aa:	8a 2b       	or	r24, r26
    26ac:	8b 2b       	or	r24, r27
    26ae:	21 f4       	brne	.+8      	; 0x26b8 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    26b0:	0f 90       	pop	r0
    26b2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    26b4:	80 e0       	ldi	r24, 0x00	; 0
    26b6:	56 c0       	rjmp	.+172    	; 0x2764 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    26b8:	11 11       	cpse	r17, r1
    26ba:	05 c0       	rjmp	.+10     	; 0x26c6 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    26bc:	ce 01       	movw	r24, r28
    26be:	01 96       	adiw	r24, 0x01	; 1
    26c0:	0e 94 29 18 	call	0x3052	; 0x3052 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26c4:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    26c6:	0f 90       	pop	r0
    26c8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ca:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	f8 94       	cli
    26d2:	0f 92       	push	r0
    26d4:	f7 01       	movw	r30, r14
    26d6:	81 a1       	ldd	r24, Z+33	; 0x21
    26d8:	8f 3f       	cpi	r24, 0xFF	; 255
    26da:	09 f4       	brne	.+2      	; 0x26de <xQueueGenericReceive+0xe6>
    26dc:	11 a2       	std	Z+33, r1	; 0x21
    26de:	f7 01       	movw	r30, r14
    26e0:	82 a1       	ldd	r24, Z+34	; 0x22
    26e2:	8f 3f       	cpi	r24, 0xFF	; 255
    26e4:	09 f4       	brne	.+2      	; 0x26e8 <xQueueGenericReceive+0xf0>
    26e6:	12 a2       	std	Z+34, r1	; 0x22
    26e8:	0f 90       	pop	r0
    26ea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26ec:	be 01       	movw	r22, r28
    26ee:	6a 5f       	subi	r22, 0xFA	; 250
    26f0:	7f 4f       	sbci	r23, 0xFF	; 255
    26f2:	ce 01       	movw	r24, r28
    26f4:	01 96       	adiw	r24, 0x01	; 1
    26f6:	0e 94 3a 18 	call	0x3074	; 0x3074 <xTaskCheckForTimeOut>
    26fa:	81 11       	cpse	r24, r1
    26fc:	2d c0       	rjmp	.+90     	; 0x2758 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    26fe:	0f b6       	in	r0, 0x3f	; 63
    2700:	f8 94       	cli
    2702:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2704:	f7 01       	movw	r30, r14
    2706:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    270c:	81 11       	cpse	r24, r1
    270e:	1e c0       	rjmp	.+60     	; 0x274c <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2710:	80 81       	ld	r24, Z
    2712:	91 81       	ldd	r25, Z+1	; 0x01
    2714:	89 2b       	or	r24, r25
    2716:	49 f4       	brne	.+18     	; 0x272a <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    271e:	82 81       	ldd	r24, Z+2	; 0x02
    2720:	93 81       	ldd	r25, Z+3	; 0x03
    2722:	0e 94 c9 18 	call	0x3192	; 0x3192 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2726:	0f 90       	pop	r0
    2728:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    272a:	4e 81       	ldd	r20, Y+6	; 0x06
    272c:	5f 81       	ldd	r21, Y+7	; 0x07
    272e:	68 85       	ldd	r22, Y+8	; 0x08
    2730:	79 85       	ldd	r23, Y+9	; 0x09
    2732:	c6 01       	movw	r24, r12
    2734:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2738:	c7 01       	movw	r24, r14
    273a:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    273e:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
    2742:	81 11       	cpse	r24, r1
    2744:	73 cf       	rjmp	.-282    	; 0x262c <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2746:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    274a:	70 cf       	rjmp	.-288    	; 0x262c <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    274c:	c7 01       	movw	r24, r14
    274e:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2752:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
    2756:	6a cf       	rjmp	.-300    	; 0x262c <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2758:	c7 01       	movw	r24, r14
    275a:	0e 94 81 11 	call	0x2302	; 0x2302 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    275e:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2762:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2764:	29 96       	adiw	r28, 0x09	; 9
    2766:	cd bf       	out	0x3d, r28	; 61
    2768:	de bf       	out	0x3e, r29	; 62
    276a:	df 91       	pop	r29
    276c:	cf 91       	pop	r28
    276e:	1f 91       	pop	r17
    2770:	0f 91       	pop	r16
    2772:	ff 90       	pop	r15
    2774:	ef 90       	pop	r14
    2776:	df 90       	pop	r13
    2778:	cf 90       	pop	r12
    277a:	bf 90       	pop	r11
    277c:	af 90       	pop	r10
    277e:	08 95       	ret

00002780 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    2780:	0f 93       	push	r16
    2782:	1f 93       	push	r17
    2784:	cf 93       	push	r28
    2786:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2788:	fc 01       	movw	r30, r24
    278a:	26 8d       	ldd	r18, Z+30	; 0x1e
    278c:	22 23       	and	r18, r18
    278e:	d9 f0       	breq	.+54     	; 0x27c6 <xQueueReceiveFromISR+0x46>
    2790:	8a 01       	movw	r16, r20
    2792:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2794:	0e 94 67 11 	call	0x22ce	; 0x22ce <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2798:	8e 8d       	ldd	r24, Y+30	; 0x1e
    279a:	81 50       	subi	r24, 0x01	; 1
    279c:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    279e:	89 a1       	ldd	r24, Y+33	; 0x21
    27a0:	8f 3f       	cpi	r24, 0xFF	; 255
    27a2:	69 f4       	brne	.+26     	; 0x27be <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27a4:	88 85       	ldd	r24, Y+8	; 0x08
    27a6:	88 23       	and	r24, r24
    27a8:	81 f0       	breq	.+32     	; 0x27ca <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    27aa:	ce 01       	movw	r24, r28
    27ac:	08 96       	adiw	r24, 0x08	; 8
    27ae:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <xTaskRemoveFromEventList>
    27b2:	88 23       	and	r24, r24
    27b4:	61 f0       	breq	.+24     	; 0x27ce <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	f8 01       	movw	r30, r16
    27ba:	80 83       	st	Z, r24
    27bc:	09 c0       	rjmp	.+18     	; 0x27d0 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    27be:	8f 5f       	subi	r24, 0xFF	; 255
    27c0:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	05 c0       	rjmp	.+10     	; 0x27d0 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    27c6:	80 e0       	ldi	r24, 0x00	; 0
    27c8:	03 c0       	rjmp	.+6      	; 0x27d0 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	01 c0       	rjmp	.+2      	; 0x27d0 <xQueueReceiveFromISR+0x50>
    27ce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    27d0:	df 91       	pop	r29
    27d2:	cf 91       	pop	r28
    27d4:	1f 91       	pop	r17
    27d6:	0f 91       	pop	r16
    27d8:	08 95       	ret

000027da <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    27da:	0f b6       	in	r0, 0x3f	; 63
    27dc:	f8 94       	cli
    27de:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    27e0:	fc 01       	movw	r30, r24
    27e2:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    27e4:	0f 90       	pop	r0
    27e6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    27e8:	08 95       	ret

000027ea <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    27ea:	fc 01       	movw	r30, r24
    27ec:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    27ee:	08 95       	ret

000027f0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    27f0:	c4 ee       	ldi	r28, 0xE4	; 228
    27f2:	d2 e3       	ldi	r29, 0x32	; 50
    27f4:	88 81       	ld	r24, Y
    27f6:	82 30       	cpi	r24, 0x02	; 2
    27f8:	e8 f3       	brcs	.-6      	; 0x27f4 <prvIdleTask+0x4>
    27fa:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    27fe:	fa cf       	rjmp	.-12     	; 0x27f4 <prvIdleTask+0x4>

00002800 <prvAddCurrentTaskToDelayedList>:
    2800:	cf 92       	push	r12
    2802:	df 92       	push	r13
    2804:	ef 92       	push	r14
    2806:	ff 92       	push	r15
    2808:	6b 01       	movw	r12, r22
    280a:	7c 01       	movw	r14, r24
    280c:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    2810:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2814:	62 83       	std	Z+2, r22	; 0x02
    2816:	73 83       	std	Z+3, r23	; 0x03
    2818:	84 83       	std	Z+4, r24	; 0x04
    281a:	95 83       	std	Z+5, r25	; 0x05
    281c:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    2820:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2824:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2828:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    282c:	c8 16       	cp	r12, r24
    282e:	d9 06       	cpc	r13, r25
    2830:	ea 06       	cpc	r14, r26
    2832:	fb 06       	cpc	r15, r27
    2834:	68 f4       	brcc	.+26     	; 0x2850 <prvAddCurrentTaskToDelayedList+0x50>
    2836:	60 91 10 33 	lds	r22, 0x3310	; 0x803310 <pxCurrentTCB>
    283a:	70 91 11 33 	lds	r23, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    283e:	80 91 ca 32 	lds	r24, 0x32CA	; 0x8032ca <pxOverflowDelayedTaskList>
    2842:	90 91 cb 32 	lds	r25, 0x32CB	; 0x8032cb <pxOverflowDelayedTaskList+0x1>
    2846:	6e 5f       	subi	r22, 0xFE	; 254
    2848:	7f 4f       	sbci	r23, 0xFF	; 255
    284a:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vListInsert>
    284e:	21 c0       	rjmp	.+66     	; 0x2892 <prvAddCurrentTaskToDelayedList+0x92>
    2850:	60 91 10 33 	lds	r22, 0x3310	; 0x803310 <pxCurrentTCB>
    2854:	70 91 11 33 	lds	r23, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2858:	80 91 cc 32 	lds	r24, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    285c:	90 91 cd 32 	lds	r25, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2860:	6e 5f       	subi	r22, 0xFE	; 254
    2862:	7f 4f       	sbci	r23, 0xFF	; 255
    2864:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vListInsert>
    2868:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    286c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2870:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2874:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2878:	c8 16       	cp	r12, r24
    287a:	d9 06       	cpc	r13, r25
    287c:	ea 06       	cpc	r14, r26
    287e:	fb 06       	cpc	r15, r27
    2880:	40 f4       	brcc	.+16     	; 0x2892 <prvAddCurrentTaskToDelayedList+0x92>
    2882:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2886:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    288a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    288e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    2892:	ff 90       	pop	r15
    2894:	ef 90       	pop	r14
    2896:	df 90       	pop	r13
    2898:	cf 90       	pop	r12
    289a:	08 95       	ret

0000289c <xTaskGenericCreate>:
    289c:	4f 92       	push	r4
    289e:	5f 92       	push	r5
    28a0:	6f 92       	push	r6
    28a2:	7f 92       	push	r7
    28a4:	8f 92       	push	r8
    28a6:	9f 92       	push	r9
    28a8:	af 92       	push	r10
    28aa:	bf 92       	push	r11
    28ac:	cf 92       	push	r12
    28ae:	df 92       	push	r13
    28b0:	ef 92       	push	r14
    28b2:	ff 92       	push	r15
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	cf 93       	push	r28
    28ba:	df 93       	push	r29
    28bc:	5c 01       	movw	r10, r24
    28be:	4b 01       	movw	r8, r22
    28c0:	3a 01       	movw	r6, r20
    28c2:	29 01       	movw	r4, r18
    28c4:	88 e2       	ldi	r24, 0x28	; 40
    28c6:	90 e0       	ldi	r25, 0x00	; 0
    28c8:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    28cc:	ec 01       	movw	r28, r24
    28ce:	89 2b       	or	r24, r25
    28d0:	09 f4       	brne	.+2      	; 0x28d4 <xTaskGenericCreate+0x38>
    28d2:	d4 c0       	rjmp	.+424    	; 0x2a7c <xTaskGenericCreate+0x1e0>
    28d4:	c1 14       	cp	r12, r1
    28d6:	d1 04       	cpc	r13, r1
    28d8:	09 f0       	breq	.+2      	; 0x28dc <xTaskGenericCreate+0x40>
    28da:	cc c0       	rjmp	.+408    	; 0x2a74 <xTaskGenericCreate+0x1d8>
    28dc:	c3 01       	movw	r24, r6
    28de:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    28e2:	8b 8f       	std	Y+27, r24	; 0x1b
    28e4:	9c 8f       	std	Y+28, r25	; 0x1c
    28e6:	00 97       	sbiw	r24, 0x00	; 0
    28e8:	21 f4       	brne	.+8      	; 0x28f2 <xTaskGenericCreate+0x56>
    28ea:	ce 01       	movw	r24, r28
    28ec:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <vPortFree>
    28f0:	c5 c0       	rjmp	.+394    	; 0x2a7c <xTaskGenericCreate+0x1e0>
    28f2:	a3 01       	movw	r20, r6
    28f4:	61 e1       	ldi	r22, 0x11	; 17
    28f6:	70 e0       	ldi	r23, 0x00	; 0
    28f8:	0e 94 82 26 	call	0x4d04	; 0x4d04 <memset>
    28fc:	93 01       	movw	r18, r6
    28fe:	21 50       	subi	r18, 0x01	; 1
    2900:	31 09       	sbc	r19, r1
    2902:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2904:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2906:	3c 01       	movw	r6, r24
    2908:	62 0e       	add	r6, r18
    290a:	73 1e       	adc	r7, r19
    290c:	4a e0       	ldi	r20, 0x0A	; 10
    290e:	50 e0       	ldi	r21, 0x00	; 0
    2910:	b4 01       	movw	r22, r8
    2912:	ce 01       	movw	r24, r28
    2914:	4d 96       	adiw	r24, 0x1d	; 29
    2916:	0e 94 89 26 	call	0x4d12	; 0x4d12 <strncpy>
    291a:	1e a2       	std	Y+38, r1	; 0x26
    291c:	10 2f       	mov	r17, r16
    291e:	04 30       	cpi	r16, 0x04	; 4
    2920:	08 f0       	brcs	.+2      	; 0x2924 <xTaskGenericCreate+0x88>
    2922:	13 e0       	ldi	r17, 0x03	; 3
    2924:	1a 8f       	std	Y+26, r17	; 0x1a
    2926:	1f a3       	std	Y+39, r17	; 0x27
    2928:	6e 01       	movw	r12, r28
    292a:	22 e0       	ldi	r18, 0x02	; 2
    292c:	c2 0e       	add	r12, r18
    292e:	d1 1c       	adc	r13, r1
    2930:	c6 01       	movw	r24, r12
    2932:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vListInitialiseItem>
    2936:	ce 01       	movw	r24, r28
    2938:	0e 96       	adiw	r24, 0x0e	; 14
    293a:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vListInitialiseItem>
    293e:	ca 87       	std	Y+10, r28	; 0x0a
    2940:	db 87       	std	Y+11, r29	; 0x0b
    2942:	84 e0       	ldi	r24, 0x04	; 4
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	a0 e0       	ldi	r26, 0x00	; 0
    2948:	b0 e0       	ldi	r27, 0x00	; 0
    294a:	81 1b       	sub	r24, r17
    294c:	91 09       	sbc	r25, r1
    294e:	a1 09       	sbc	r26, r1
    2950:	b1 09       	sbc	r27, r1
    2952:	8e 87       	std	Y+14, r24	; 0x0e
    2954:	9f 87       	std	Y+15, r25	; 0x0f
    2956:	a8 8b       	std	Y+16, r26	; 0x10
    2958:	b9 8b       	std	Y+17, r27	; 0x11
    295a:	ce 8b       	std	Y+22, r28	; 0x16
    295c:	df 8b       	std	Y+23, r29	; 0x17
    295e:	a2 01       	movw	r20, r4
    2960:	b5 01       	movw	r22, r10
    2962:	c3 01       	movw	r24, r6
    2964:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <pxPortInitialiseStack>
    2968:	88 83       	st	Y, r24
    296a:	99 83       	std	Y+1, r25	; 0x01
    296c:	e1 14       	cp	r14, r1
    296e:	f1 04       	cpc	r15, r1
    2970:	19 f0       	breq	.+6      	; 0x2978 <xTaskGenericCreate+0xdc>
    2972:	f7 01       	movw	r30, r14
    2974:	c0 83       	st	Z, r28
    2976:	d1 83       	std	Z+1, r29	; 0x01
    2978:	0f b6       	in	r0, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	0f 92       	push	r0
    297e:	80 91 bc 32 	lds	r24, 0x32BC	; 0x8032bc <uxCurrentNumberOfTasks>
    2982:	8f 5f       	subi	r24, 0xFF	; 255
    2984:	80 93 bc 32 	sts	0x32BC, r24	; 0x8032bc <uxCurrentNumberOfTasks>
    2988:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    298c:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2990:	89 2b       	or	r24, r25
    2992:	89 f5       	brne	.+98     	; 0x29f6 <xTaskGenericCreate+0x15a>
    2994:	c0 93 10 33 	sts	0x3310, r28	; 0x803310 <pxCurrentTCB>
    2998:	d0 93 11 33 	sts	0x3311, r29	; 0x803311 <pxCurrentTCB+0x1>
    299c:	80 91 bc 32 	lds	r24, 0x32BC	; 0x8032bc <uxCurrentNumberOfTasks>
    29a0:	81 30       	cpi	r24, 0x01	; 1
    29a2:	c1 f5       	brne	.+112    	; 0x2a14 <xTaskGenericCreate+0x178>
    29a4:	84 ee       	ldi	r24, 0xE4	; 228
    29a6:	92 e3       	ldi	r25, 0x32	; 50
    29a8:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29ac:	8f ee       	ldi	r24, 0xEF	; 239
    29ae:	92 e3       	ldi	r25, 0x32	; 50
    29b0:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29b4:	8a ef       	ldi	r24, 0xFA	; 250
    29b6:	92 e3       	ldi	r25, 0x32	; 50
    29b8:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29bc:	85 e0       	ldi	r24, 0x05	; 5
    29be:	93 e3       	ldi	r25, 0x33	; 51
    29c0:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29c4:	89 ed       	ldi	r24, 0xD9	; 217
    29c6:	92 e3       	ldi	r25, 0x32	; 50
    29c8:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29cc:	8e ec       	ldi	r24, 0xCE	; 206
    29ce:	92 e3       	ldi	r25, 0x32	; 50
    29d0:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29d4:	8f eb       	ldi	r24, 0xBF	; 191
    29d6:	92 e3       	ldi	r25, 0x32	; 50
    29d8:	0e 94 f3 0e 	call	0x1de6	; 0x1de6 <vListInitialise>
    29dc:	89 ed       	ldi	r24, 0xD9	; 217
    29de:	92 e3       	ldi	r25, 0x32	; 50
    29e0:	80 93 cc 32 	sts	0x32CC, r24	; 0x8032cc <pxDelayedTaskList>
    29e4:	90 93 cd 32 	sts	0x32CD, r25	; 0x8032cd <pxDelayedTaskList+0x1>
    29e8:	8e ec       	ldi	r24, 0xCE	; 206
    29ea:	92 e3       	ldi	r25, 0x32	; 50
    29ec:	80 93 ca 32 	sts	0x32CA, r24	; 0x8032ca <pxOverflowDelayedTaskList>
    29f0:	90 93 cb 32 	sts	0x32CB, r25	; 0x8032cb <pxOverflowDelayedTaskList+0x1>
    29f4:	0f c0       	rjmp	.+30     	; 0x2a14 <xTaskGenericCreate+0x178>
    29f6:	80 91 b5 32 	lds	r24, 0x32B5	; 0x8032b5 <xSchedulerRunning>
    29fa:	81 11       	cpse	r24, r1
    29fc:	0b c0       	rjmp	.+22     	; 0x2a14 <xTaskGenericCreate+0x178>
    29fe:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    2a02:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2a06:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a08:	08 17       	cp	r16, r24
    2a0a:	20 f0       	brcs	.+8      	; 0x2a14 <xTaskGenericCreate+0x178>
    2a0c:	c0 93 10 33 	sts	0x3310, r28	; 0x803310 <pxCurrentTCB>
    2a10:	d0 93 11 33 	sts	0x3311, r29	; 0x803311 <pxCurrentTCB+0x1>
    2a14:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2a16:	90 91 b7 32 	lds	r25, 0x32B7	; 0x8032b7 <uxTopUsedPriority>
    2a1a:	98 17       	cp	r25, r24
    2a1c:	10 f4       	brcc	.+4      	; 0x2a22 <xTaskGenericCreate+0x186>
    2a1e:	80 93 b7 32 	sts	0x32B7, r24	; 0x8032b7 <uxTopUsedPriority>
    2a22:	90 91 b0 32 	lds	r25, 0x32B0	; 0x8032b0 <uxTaskNumber>
    2a26:	9f 5f       	subi	r25, 0xFF	; 255
    2a28:	90 93 b0 32 	sts	0x32B0, r25	; 0x8032b0 <uxTaskNumber>
    2a2c:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2a30:	98 17       	cp	r25, r24
    2a32:	10 f4       	brcc	.+4      	; 0x2a38 <xTaskGenericCreate+0x19c>
    2a34:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    2a38:	fb e0       	ldi	r31, 0x0B	; 11
    2a3a:	8f 9f       	mul	r24, r31
    2a3c:	c0 01       	movw	r24, r0
    2a3e:	11 24       	eor	r1, r1
    2a40:	b6 01       	movw	r22, r12
    2a42:	8c 51       	subi	r24, 0x1C	; 28
    2a44:	9d 4c       	sbci	r25, 0xCD	; 205
    2a46:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
    2a4a:	0f 90       	pop	r0
    2a4c:	0f be       	out	0x3f, r0	; 63
    2a4e:	80 91 b5 32 	lds	r24, 0x32B5	; 0x8032b5 <xSchedulerRunning>
    2a52:	88 23       	and	r24, r24
    2a54:	59 f0       	breq	.+22     	; 0x2a6c <xTaskGenericCreate+0x1d0>
    2a56:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    2a5a:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2a5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a60:	80 17       	cp	r24, r16
    2a62:	30 f4       	brcc	.+12     	; 0x2a70 <xTaskGenericCreate+0x1d4>
    2a64:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    2a68:	81 e0       	ldi	r24, 0x01	; 1
    2a6a:	09 c0       	rjmp	.+18     	; 0x2a7e <xTaskGenericCreate+0x1e2>
    2a6c:	81 e0       	ldi	r24, 0x01	; 1
    2a6e:	07 c0       	rjmp	.+14     	; 0x2a7e <xTaskGenericCreate+0x1e2>
    2a70:	81 e0       	ldi	r24, 0x01	; 1
    2a72:	05 c0       	rjmp	.+10     	; 0x2a7e <xTaskGenericCreate+0x1e2>
    2a74:	cb 8e       	std	Y+27, r12	; 0x1b
    2a76:	dc 8e       	std	Y+28, r13	; 0x1c
    2a78:	c6 01       	movw	r24, r12
    2a7a:	3b cf       	rjmp	.-394    	; 0x28f2 <xTaskGenericCreate+0x56>
    2a7c:	8f ef       	ldi	r24, 0xFF	; 255
    2a7e:	df 91       	pop	r29
    2a80:	cf 91       	pop	r28
    2a82:	1f 91       	pop	r17
    2a84:	0f 91       	pop	r16
    2a86:	ff 90       	pop	r15
    2a88:	ef 90       	pop	r14
    2a8a:	df 90       	pop	r13
    2a8c:	cf 90       	pop	r12
    2a8e:	bf 90       	pop	r11
    2a90:	af 90       	pop	r10
    2a92:	9f 90       	pop	r9
    2a94:	8f 90       	pop	r8
    2a96:	7f 90       	pop	r7
    2a98:	6f 90       	pop	r6
    2a9a:	5f 90       	pop	r5
    2a9c:	4f 90       	pop	r4
    2a9e:	08 95       	ret

00002aa0 <uxTaskPriorityGet>:
    2aa0:	0f b6       	in	r0, 0x3f	; 63
    2aa2:	f8 94       	cli
    2aa4:	0f 92       	push	r0
    2aa6:	00 97       	sbiw	r24, 0x00	; 0
    2aa8:	21 f4       	brne	.+8      	; 0x2ab2 <uxTaskPriorityGet+0x12>
    2aaa:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    2aae:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2ab2:	0f 90       	pop	r0
    2ab4:	0f be       	out	0x3f, r0	; 63
    2ab6:	fc 01       	movw	r30, r24
    2ab8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2aba:	08 95       	ret

00002abc <vTaskStartScheduler>:
    2abc:	af 92       	push	r10
    2abe:	bf 92       	push	r11
    2ac0:	cf 92       	push	r12
    2ac2:	df 92       	push	r13
    2ac4:	ef 92       	push	r14
    2ac6:	ff 92       	push	r15
    2ac8:	0f 93       	push	r16
    2aca:	a1 2c       	mov	r10, r1
    2acc:	b1 2c       	mov	r11, r1
    2ace:	c1 2c       	mov	r12, r1
    2ad0:	d1 2c       	mov	r13, r1
    2ad2:	0f 2e       	mov	r0, r31
    2ad4:	fd eb       	ldi	r31, 0xBD	; 189
    2ad6:	ef 2e       	mov	r14, r31
    2ad8:	f2 e3       	ldi	r31, 0x32	; 50
    2ada:	ff 2e       	mov	r15, r31
    2adc:	f0 2d       	mov	r31, r0
    2ade:	00 e0       	ldi	r16, 0x00	; 0
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	44 e6       	ldi	r20, 0x64	; 100
    2ae6:	50 e0       	ldi	r21, 0x00	; 0
    2ae8:	66 ef       	ldi	r22, 0xF6	; 246
    2aea:	71 e2       	ldi	r23, 0x21	; 33
    2aec:	88 ef       	ldi	r24, 0xF8	; 248
    2aee:	93 e1       	ldi	r25, 0x13	; 19
    2af0:	0e 94 4e 14 	call	0x289c	; 0x289c <xTaskGenericCreate>
    2af4:	81 30       	cpi	r24, 0x01	; 1
    2af6:	69 f4       	brne	.+26     	; 0x2b12 <vTaskStartScheduler+0x56>
    2af8:	f8 94       	cli
    2afa:	80 93 b5 32 	sts	0x32B5, r24	; 0x8032b5 <xSchedulerRunning>
    2afe:	10 92 b8 32 	sts	0x32B8, r1	; 0x8032b8 <xTickCount>
    2b02:	10 92 b9 32 	sts	0x32B9, r1	; 0x8032b9 <xTickCount+0x1>
    2b06:	10 92 ba 32 	sts	0x32BA, r1	; 0x8032ba <xTickCount+0x2>
    2b0a:	10 92 bb 32 	sts	0x32BB, r1	; 0x8032bb <xTickCount+0x3>
    2b0e:	0e 94 16 10 	call	0x202c	; 0x202c <xPortStartScheduler>
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	df 90       	pop	r13
    2b1a:	cf 90       	pop	r12
    2b1c:	bf 90       	pop	r11
    2b1e:	af 90       	pop	r10
    2b20:	08 95       	ret

00002b22 <vTaskSuspendAll>:
    2b22:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2b26:	8f 5f       	subi	r24, 0xFF	; 255
    2b28:	80 93 b4 32 	sts	0x32B4, r24	; 0x8032b4 <uxSchedulerSuspended>
    2b2c:	08 95       	ret

00002b2e <xTaskGetTickCount>:
    2b2e:	0f b6       	in	r0, 0x3f	; 63
    2b30:	f8 94       	cli
    2b32:	0f 92       	push	r0
    2b34:	60 91 b8 32 	lds	r22, 0x32B8	; 0x8032b8 <xTickCount>
    2b38:	70 91 b9 32 	lds	r23, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2b3c:	80 91 ba 32 	lds	r24, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2b40:	90 91 bb 32 	lds	r25, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2b44:	0f 90       	pop	r0
    2b46:	0f be       	out	0x3f, r0	; 63
    2b48:	08 95       	ret

00002b4a <pcTaskGetTaskName>:
    2b4a:	00 97       	sbiw	r24, 0x00	; 0
    2b4c:	21 f4       	brne	.+8      	; 0x2b56 <pcTaskGetTaskName+0xc>
    2b4e:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    2b52:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2b56:	4d 96       	adiw	r24, 0x1d	; 29
    2b58:	08 95       	ret

00002b5a <xTaskGetIdleTaskHandle>:
    2b5a:	80 91 bd 32 	lds	r24, 0x32BD	; 0x8032bd <xIdleTaskHandle>
    2b5e:	90 91 be 32 	lds	r25, 0x32BE	; 0x8032be <xIdleTaskHandle+0x1>
    2b62:	08 95       	ret

00002b64 <vTaskIncrementTick>:
    2b64:	ff 92       	push	r15
    2b66:	0f 93       	push	r16
    2b68:	1f 93       	push	r17
    2b6a:	cf 93       	push	r28
    2b6c:	df 93       	push	r29
    2b6e:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2b72:	81 11       	cpse	r24, r1
    2b74:	ed c0       	rjmp	.+474    	; 0x2d50 <vTaskIncrementTick+0x1ec>
    2b76:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    2b7a:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2b7e:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2b82:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2b86:	01 96       	adiw	r24, 0x01	; 1
    2b88:	a1 1d       	adc	r26, r1
    2b8a:	b1 1d       	adc	r27, r1
    2b8c:	80 93 b8 32 	sts	0x32B8, r24	; 0x8032b8 <xTickCount>
    2b90:	90 93 b9 32 	sts	0x32B9, r25	; 0x8032b9 <xTickCount+0x1>
    2b94:	a0 93 ba 32 	sts	0x32BA, r26	; 0x8032ba <xTickCount+0x2>
    2b98:	b0 93 bb 32 	sts	0x32BB, r27	; 0x8032bb <xTickCount+0x3>
    2b9c:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    2ba0:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2ba4:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2ba8:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2bac:	89 2b       	or	r24, r25
    2bae:	8a 2b       	or	r24, r26
    2bb0:	8b 2b       	or	r24, r27
    2bb2:	f1 f5       	brne	.+124    	; 0x2c30 <vTaskIncrementTick+0xcc>
    2bb4:	80 91 cc 32 	lds	r24, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2bb8:	90 91 cd 32 	lds	r25, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2bbc:	20 91 ca 32 	lds	r18, 0x32CA	; 0x8032ca <pxOverflowDelayedTaskList>
    2bc0:	30 91 cb 32 	lds	r19, 0x32CB	; 0x8032cb <pxOverflowDelayedTaskList+0x1>
    2bc4:	20 93 cc 32 	sts	0x32CC, r18	; 0x8032cc <pxDelayedTaskList>
    2bc8:	30 93 cd 32 	sts	0x32CD, r19	; 0x8032cd <pxDelayedTaskList+0x1>
    2bcc:	80 93 ca 32 	sts	0x32CA, r24	; 0x8032ca <pxOverflowDelayedTaskList>
    2bd0:	90 93 cb 32 	sts	0x32CB, r25	; 0x8032cb <pxOverflowDelayedTaskList+0x1>
    2bd4:	80 91 b1 32 	lds	r24, 0x32B1	; 0x8032b1 <xNumOfOverflows>
    2bd8:	8f 5f       	subi	r24, 0xFF	; 255
    2bda:	80 93 b1 32 	sts	0x32B1, r24	; 0x8032b1 <xNumOfOverflows>
    2bde:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2be2:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2be6:	80 81       	ld	r24, Z
    2be8:	81 11       	cpse	r24, r1
    2bea:	0c c0       	rjmp	.+24     	; 0x2c04 <vTaskIncrementTick+0xa0>
    2bec:	8f ef       	ldi	r24, 0xFF	; 255
    2bee:	9f ef       	ldi	r25, 0xFF	; 255
    2bf0:	dc 01       	movw	r26, r24
    2bf2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2bf6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2bfa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2bfe:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2c02:	16 c0       	rjmp	.+44     	; 0x2c30 <vTaskIncrementTick+0xcc>
    2c04:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2c08:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2c0c:	07 80       	ldd	r0, Z+7	; 0x07
    2c0e:	f0 85       	ldd	r31, Z+8	; 0x08
    2c10:	e0 2d       	mov	r30, r0
    2c12:	00 84       	ldd	r0, Z+8	; 0x08
    2c14:	f1 85       	ldd	r31, Z+9	; 0x09
    2c16:	e0 2d       	mov	r30, r0
    2c18:	82 81       	ldd	r24, Z+2	; 0x02
    2c1a:	93 81       	ldd	r25, Z+3	; 0x03
    2c1c:	a4 81       	ldd	r26, Z+4	; 0x04
    2c1e:	b5 81       	ldd	r27, Z+5	; 0x05
    2c20:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2c24:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2c28:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2c2c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2c30:	40 91 b8 32 	lds	r20, 0x32B8	; 0x8032b8 <xTickCount>
    2c34:	50 91 b9 32 	lds	r21, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2c38:	60 91 ba 32 	lds	r22, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2c3c:	70 91 bb 32 	lds	r23, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2c40:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2c44:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2c48:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2c4c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2c50:	48 17       	cp	r20, r24
    2c52:	59 07       	cpc	r21, r25
    2c54:	6a 07       	cpc	r22, r26
    2c56:	7b 07       	cpc	r23, r27
    2c58:	08 f4       	brcc	.+2      	; 0x2c5c <vTaskIncrementTick+0xf8>
    2c5a:	7f c0       	rjmp	.+254    	; 0x2d5a <vTaskIncrementTick+0x1f6>
    2c5c:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2c60:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2c64:	80 81       	ld	r24, Z
    2c66:	88 23       	and	r24, r24
    2c68:	f9 f0       	breq	.+62     	; 0x2ca8 <vTaskIncrementTick+0x144>
    2c6a:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2c6e:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2c72:	07 80       	ldd	r0, Z+7	; 0x07
    2c74:	f0 85       	ldd	r31, Z+8	; 0x08
    2c76:	e0 2d       	mov	r30, r0
    2c78:	c0 85       	ldd	r28, Z+8	; 0x08
    2c7a:	d1 85       	ldd	r29, Z+9	; 0x09
    2c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2c80:	ac 81       	ldd	r26, Y+4	; 0x04
    2c82:	bd 81       	ldd	r27, Y+5	; 0x05
    2c84:	40 91 b8 32 	lds	r20, 0x32B8	; 0x8032b8 <xTickCount>
    2c88:	50 91 b9 32 	lds	r21, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2c8c:	60 91 ba 32 	lds	r22, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2c90:	70 91 bb 32 	lds	r23, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2c94:	48 17       	cp	r20, r24
    2c96:	59 07       	cpc	r21, r25
    2c98:	6a 07       	cpc	r22, r26
    2c9a:	7b 07       	cpc	r23, r27
    2c9c:	58 f1       	brcs	.+86     	; 0x2cf4 <vTaskIncrementTick+0x190>
    2c9e:	0f 2e       	mov	r0, r31
    2ca0:	fb e0       	ldi	r31, 0x0B	; 11
    2ca2:	ff 2e       	mov	r15, r31
    2ca4:	f0 2d       	mov	r31, r0
    2ca6:	2f c0       	rjmp	.+94     	; 0x2d06 <vTaskIncrementTick+0x1a2>
    2ca8:	8f ef       	ldi	r24, 0xFF	; 255
    2caa:	9f ef       	ldi	r25, 0xFF	; 255
    2cac:	dc 01       	movw	r26, r24
    2cae:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2cb2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2cb6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2cba:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2cbe:	4d c0       	rjmp	.+154    	; 0x2d5a <vTaskIncrementTick+0x1f6>
    2cc0:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2cc4:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2cc8:	07 80       	ldd	r0, Z+7	; 0x07
    2cca:	f0 85       	ldd	r31, Z+8	; 0x08
    2ccc:	e0 2d       	mov	r30, r0
    2cce:	c0 85       	ldd	r28, Z+8	; 0x08
    2cd0:	d1 85       	ldd	r29, Z+9	; 0x09
    2cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2cd4:	9b 81       	ldd	r25, Y+3	; 0x03
    2cd6:	ac 81       	ldd	r26, Y+4	; 0x04
    2cd8:	bd 81       	ldd	r27, Y+5	; 0x05
    2cda:	40 91 b8 32 	lds	r20, 0x32B8	; 0x8032b8 <xTickCount>
    2cde:	50 91 b9 32 	lds	r21, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2ce2:	60 91 ba 32 	lds	r22, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2ce6:	70 91 bb 32 	lds	r23, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2cea:	48 17       	cp	r20, r24
    2cec:	59 07       	cpc	r21, r25
    2cee:	6a 07       	cpc	r22, r26
    2cf0:	7b 07       	cpc	r23, r27
    2cf2:	48 f4       	brcc	.+18     	; 0x2d06 <vTaskIncrementTick+0x1a2>
    2cf4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2cf8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2cfc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2d00:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2d04:	2a c0       	rjmp	.+84     	; 0x2d5a <vTaskIncrementTick+0x1f6>
    2d06:	8e 01       	movw	r16, r28
    2d08:	0e 5f       	subi	r16, 0xFE	; 254
    2d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    2d0c:	c8 01       	movw	r24, r16
    2d0e:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
    2d12:	88 8d       	ldd	r24, Y+24	; 0x18
    2d14:	99 8d       	ldd	r25, Y+25	; 0x19
    2d16:	89 2b       	or	r24, r25
    2d18:	21 f0       	breq	.+8      	; 0x2d22 <vTaskIncrementTick+0x1be>
    2d1a:	ce 01       	movw	r24, r28
    2d1c:	0e 96       	adiw	r24, 0x0e	; 14
    2d1e:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
    2d22:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d24:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2d28:	98 17       	cp	r25, r24
    2d2a:	10 f4       	brcc	.+4      	; 0x2d30 <vTaskIncrementTick+0x1cc>
    2d2c:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    2d30:	f8 9e       	mul	r15, r24
    2d32:	c0 01       	movw	r24, r0
    2d34:	11 24       	eor	r1, r1
    2d36:	b8 01       	movw	r22, r16
    2d38:	8c 51       	subi	r24, 0x1C	; 28
    2d3a:	9d 4c       	sbci	r25, 0xCD	; 205
    2d3c:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
    2d40:	e0 91 cc 32 	lds	r30, 0x32CC	; 0x8032cc <pxDelayedTaskList>
    2d44:	f0 91 cd 32 	lds	r31, 0x32CD	; 0x8032cd <pxDelayedTaskList+0x1>
    2d48:	80 81       	ld	r24, Z
    2d4a:	81 11       	cpse	r24, r1
    2d4c:	b9 cf       	rjmp	.-142    	; 0x2cc0 <vTaskIncrementTick+0x15c>
    2d4e:	ac cf       	rjmp	.-168    	; 0x2ca8 <vTaskIncrementTick+0x144>
    2d50:	80 91 b3 32 	lds	r24, 0x32B3	; 0x8032b3 <uxMissedTicks>
    2d54:	8f 5f       	subi	r24, 0xFF	; 255
    2d56:	80 93 b3 32 	sts	0x32B3, r24	; 0x8032b3 <uxMissedTicks>
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	1f 91       	pop	r17
    2d60:	0f 91       	pop	r16
    2d62:	ff 90       	pop	r15
    2d64:	08 95       	ret

00002d66 <xTaskResumeAll>:
    2d66:	cf 92       	push	r12
    2d68:	df 92       	push	r13
    2d6a:	ef 92       	push	r14
    2d6c:	ff 92       	push	r15
    2d6e:	0f 93       	push	r16
    2d70:	1f 93       	push	r17
    2d72:	cf 93       	push	r28
    2d74:	df 93       	push	r29
    2d76:	0f b6       	in	r0, 0x3f	; 63
    2d78:	f8 94       	cli
    2d7a:	0f 92       	push	r0
    2d7c:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2d80:	81 50       	subi	r24, 0x01	; 1
    2d82:	80 93 b4 32 	sts	0x32B4, r24	; 0x8032b4 <uxSchedulerSuspended>
    2d86:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2d8a:	81 11       	cpse	r24, r1
    2d8c:	60 c0       	rjmp	.+192    	; 0x2e4e <xTaskResumeAll+0xe8>
    2d8e:	80 91 bc 32 	lds	r24, 0x32BC	; 0x8032bc <uxCurrentNumberOfTasks>
    2d92:	81 11       	cpse	r24, r1
    2d94:	2c c0       	rjmp	.+88     	; 0x2dee <xTaskResumeAll+0x88>
    2d96:	5e c0       	rjmp	.+188    	; 0x2e54 <xTaskResumeAll+0xee>
    2d98:	d7 01       	movw	r26, r14
    2d9a:	17 96       	adiw	r26, 0x07	; 7
    2d9c:	ed 91       	ld	r30, X+
    2d9e:	fc 91       	ld	r31, X
    2da0:	18 97       	sbiw	r26, 0x08	; 8
    2da2:	c0 85       	ldd	r28, Z+8	; 0x08
    2da4:	d1 85       	ldd	r29, Z+9	; 0x09
    2da6:	ce 01       	movw	r24, r28
    2da8:	0e 96       	adiw	r24, 0x0e	; 14
    2daa:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
    2dae:	8e 01       	movw	r16, r28
    2db0:	0e 5f       	subi	r16, 0xFE	; 254
    2db2:	1f 4f       	sbci	r17, 0xFF	; 255
    2db4:	c8 01       	movw	r24, r16
    2db6:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
    2dba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2dbc:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2dc0:	98 17       	cp	r25, r24
    2dc2:	10 f4       	brcc	.+4      	; 0x2dc8 <xTaskResumeAll+0x62>
    2dc4:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    2dc8:	d8 9e       	mul	r13, r24
    2dca:	c0 01       	movw	r24, r0
    2dcc:	11 24       	eor	r1, r1
    2dce:	b8 01       	movw	r22, r16
    2dd0:	8c 51       	subi	r24, 0x1C	; 28
    2dd2:	9d 4c       	sbci	r25, 0xCD	; 205
    2dd4:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
    2dd8:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    2ddc:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2de0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2de2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2de4:	98 17       	cp	r25, r24
    2de6:	70 f0       	brcs	.+28     	; 0x2e04 <xTaskResumeAll+0x9e>
    2de8:	cc 24       	eor	r12, r12
    2dea:	c3 94       	inc	r12
    2dec:	0b c0       	rjmp	.+22     	; 0x2e04 <xTaskResumeAll+0x9e>
    2dee:	c1 2c       	mov	r12, r1
    2df0:	0f 2e       	mov	r0, r31
    2df2:	ff eb       	ldi	r31, 0xBF	; 191
    2df4:	ef 2e       	mov	r14, r31
    2df6:	f2 e3       	ldi	r31, 0x32	; 50
    2df8:	ff 2e       	mov	r15, r31
    2dfa:	f0 2d       	mov	r31, r0
    2dfc:	0f 2e       	mov	r0, r31
    2dfe:	fb e0       	ldi	r31, 0x0B	; 11
    2e00:	df 2e       	mov	r13, r31
    2e02:	f0 2d       	mov	r31, r0
    2e04:	f7 01       	movw	r30, r14
    2e06:	80 81       	ld	r24, Z
    2e08:	81 11       	cpse	r24, r1
    2e0a:	c6 cf       	rjmp	.-116    	; 0x2d98 <xTaskResumeAll+0x32>
    2e0c:	80 91 b3 32 	lds	r24, 0x32B3	; 0x8032b3 <uxMissedTicks>
    2e10:	88 23       	and	r24, r24
    2e12:	81 f0       	breq	.+32     	; 0x2e34 <xTaskResumeAll+0xce>
    2e14:	80 91 b3 32 	lds	r24, 0x32B3	; 0x8032b3 <uxMissedTicks>
    2e18:	88 23       	and	r24, r24
    2e1a:	99 f0       	breq	.+38     	; 0x2e42 <xTaskResumeAll+0xdc>
    2e1c:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <vTaskIncrementTick>
    2e20:	80 91 b3 32 	lds	r24, 0x32B3	; 0x8032b3 <uxMissedTicks>
    2e24:	81 50       	subi	r24, 0x01	; 1
    2e26:	80 93 b3 32 	sts	0x32B3, r24	; 0x8032b3 <uxMissedTicks>
    2e2a:	80 91 b3 32 	lds	r24, 0x32B3	; 0x8032b3 <uxMissedTicks>
    2e2e:	81 11       	cpse	r24, r1
    2e30:	f5 cf       	rjmp	.-22     	; 0x2e1c <xTaskResumeAll+0xb6>
    2e32:	07 c0       	rjmp	.+14     	; 0x2e42 <xTaskResumeAll+0xdc>
    2e34:	f1 e0       	ldi	r31, 0x01	; 1
    2e36:	cf 16       	cp	r12, r31
    2e38:	21 f0       	breq	.+8      	; 0x2e42 <xTaskResumeAll+0xdc>
    2e3a:	80 91 b2 32 	lds	r24, 0x32B2	; 0x8032b2 <xMissedYield>
    2e3e:	81 30       	cpi	r24, 0x01	; 1
    2e40:	41 f4       	brne	.+16     	; 0x2e52 <xTaskResumeAll+0xec>
    2e42:	10 92 b2 32 	sts	0x32B2, r1	; 0x8032b2 <xMissedYield>
    2e46:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
    2e4a:	81 e0       	ldi	r24, 0x01	; 1
    2e4c:	03 c0       	rjmp	.+6      	; 0x2e54 <xTaskResumeAll+0xee>
    2e4e:	80 e0       	ldi	r24, 0x00	; 0
    2e50:	01 c0       	rjmp	.+2      	; 0x2e54 <xTaskResumeAll+0xee>
    2e52:	80 e0       	ldi	r24, 0x00	; 0
    2e54:	0f 90       	pop	r0
    2e56:	0f be       	out	0x3f, r0	; 63
    2e58:	df 91       	pop	r29
    2e5a:	cf 91       	pop	r28
    2e5c:	1f 91       	pop	r17
    2e5e:	0f 91       	pop	r16
    2e60:	ff 90       	pop	r15
    2e62:	ef 90       	pop	r14
    2e64:	df 90       	pop	r13
    2e66:	cf 90       	pop	r12
    2e68:	08 95       	ret

00002e6a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2e6a:	cf 92       	push	r12
    2e6c:	df 92       	push	r13
    2e6e:	ef 92       	push	r14
    2e70:	ff 92       	push	r15
    2e72:	6b 01       	movw	r12, r22
    2e74:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2e76:	67 2b       	or	r22, r23
    2e78:	68 2b       	or	r22, r24
    2e7a:	69 2b       	or	r22, r25
    2e7c:	e9 f0       	breq	.+58     	; 0x2eb8 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2e7e:	0e 94 91 15 	call	0x2b22	; 0x2b22 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2e82:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    2e86:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2e8a:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2e8e:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    2e92:	c8 0e       	add	r12, r24
    2e94:	d9 1e       	adc	r13, r25
    2e96:	ea 1e       	adc	r14, r26
    2e98:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2e9a:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    2e9e:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2ea2:	02 96       	adiw	r24, 0x02	; 2
    2ea4:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ea8:	c7 01       	movw	r24, r14
    2eaa:	b6 01       	movw	r22, r12
    2eac:	0e 94 00 14 	call	0x2800	; 0x2800 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2eb0:	0e 94 b3 16 	call	0x2d66	; 0x2d66 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2eb4:	81 11       	cpse	r24, r1
    2eb6:	02 c0       	rjmp	.+4      	; 0x2ebc <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    2eb8:	0e 94 54 10 	call	0x20a8	; 0x20a8 <vPortYield>
		}
	}
    2ebc:	ff 90       	pop	r15
    2ebe:	ef 90       	pop	r14
    2ec0:	df 90       	pop	r13
    2ec2:	cf 90       	pop	r12
    2ec4:	08 95       	ret

00002ec6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2ec6:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2eca:	81 11       	cpse	r24, r1
    2ecc:	0c c0       	rjmp	.+24     	; 0x2ee6 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2ece:	e0 91 b6 32 	lds	r30, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2ed2:	4b e0       	ldi	r20, 0x0B	; 11
    2ed4:	e4 9f       	mul	r30, r20
    2ed6:	f0 01       	movw	r30, r0
    2ed8:	11 24       	eor	r1, r1
    2eda:	ec 51       	subi	r30, 0x1C	; 28
    2edc:	fd 4c       	sbci	r31, 0xCD	; 205
    2ede:	80 81       	ld	r24, Z
    2ee0:	88 23       	and	r24, r24
    2ee2:	29 f0       	breq	.+10     	; 0x2eee <vTaskSwitchContext+0x28>
    2ee4:	14 c0       	rjmp	.+40     	; 0x2f0e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2ee6:	81 e0       	ldi	r24, 0x01	; 1
    2ee8:	80 93 b2 32 	sts	0x32B2, r24	; 0x8032b2 <xMissedYield>
    2eec:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2eee:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2ef0:	80 91 b6 32 	lds	r24, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2ef4:	81 50       	subi	r24, 0x01	; 1
    2ef6:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2efa:	e0 91 b6 32 	lds	r30, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2efe:	9e 9f       	mul	r25, r30
    2f00:	f0 01       	movw	r30, r0
    2f02:	11 24       	eor	r1, r1
    2f04:	ec 51       	subi	r30, 0x1C	; 28
    2f06:	fd 4c       	sbci	r31, 0xCD	; 205
    2f08:	80 81       	ld	r24, Z
    2f0a:	88 23       	and	r24, r24
    2f0c:	89 f3       	breq	.-30     	; 0x2ef0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2f0e:	80 91 b6 32 	lds	r24, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    2f12:	28 2f       	mov	r18, r24
    2f14:	30 e0       	ldi	r19, 0x00	; 0
    2f16:	4b e0       	ldi	r20, 0x0B	; 11
    2f18:	84 9f       	mul	r24, r20
    2f1a:	c0 01       	movw	r24, r0
    2f1c:	11 24       	eor	r1, r1
    2f1e:	dc 01       	movw	r26, r24
    2f20:	ac 51       	subi	r26, 0x1C	; 28
    2f22:	bd 4c       	sbci	r27, 0xCD	; 205
    2f24:	11 96       	adiw	r26, 0x01	; 1
    2f26:	ed 91       	ld	r30, X+
    2f28:	fc 91       	ld	r31, X
    2f2a:	12 97       	sbiw	r26, 0x02	; 2
    2f2c:	04 80       	ldd	r0, Z+4	; 0x04
    2f2e:	f5 81       	ldd	r31, Z+5	; 0x05
    2f30:	e0 2d       	mov	r30, r0
    2f32:	11 96       	adiw	r26, 0x01	; 1
    2f34:	ed 93       	st	X+, r30
    2f36:	fc 93       	st	X, r31
    2f38:	12 97       	sbiw	r26, 0x02	; 2
    2f3a:	89 51       	subi	r24, 0x19	; 25
    2f3c:	9d 4c       	sbci	r25, 0xCD	; 205
    2f3e:	e8 17       	cp	r30, r24
    2f40:	f9 07       	cpc	r31, r25
    2f42:	61 f4       	brne	.+24     	; 0x2f5c <vTaskSwitchContext+0x96>
    2f44:	84 81       	ldd	r24, Z+4	; 0x04
    2f46:	95 81       	ldd	r25, Z+5	; 0x05
    2f48:	4b e0       	ldi	r20, 0x0B	; 11
    2f4a:	42 9f       	mul	r20, r18
    2f4c:	f0 01       	movw	r30, r0
    2f4e:	43 9f       	mul	r20, r19
    2f50:	f0 0d       	add	r31, r0
    2f52:	11 24       	eor	r1, r1
    2f54:	ec 51       	subi	r30, 0x1C	; 28
    2f56:	fd 4c       	sbci	r31, 0xCD	; 205
    2f58:	81 83       	std	Z+1, r24	; 0x01
    2f5a:	92 83       	std	Z+2, r25	; 0x02
    2f5c:	8b e0       	ldi	r24, 0x0B	; 11
    2f5e:	82 9f       	mul	r24, r18
    2f60:	f0 01       	movw	r30, r0
    2f62:	83 9f       	mul	r24, r19
    2f64:	f0 0d       	add	r31, r0
    2f66:	11 24       	eor	r1, r1
    2f68:	ec 51       	subi	r30, 0x1C	; 28
    2f6a:	fd 4c       	sbci	r31, 0xCD	; 205
    2f6c:	01 80       	ldd	r0, Z+1	; 0x01
    2f6e:	f2 81       	ldd	r31, Z+2	; 0x02
    2f70:	e0 2d       	mov	r30, r0
    2f72:	80 85       	ldd	r24, Z+8	; 0x08
    2f74:	91 85       	ldd	r25, Z+9	; 0x09
    2f76:	80 93 10 33 	sts	0x3310, r24	; 0x803310 <pxCurrentTCB>
    2f7a:	90 93 11 33 	sts	0x3311, r25	; 0x803311 <pxCurrentTCB+0x1>
    2f7e:	08 95       	ret

00002f80 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2f80:	cf 92       	push	r12
    2f82:	df 92       	push	r13
    2f84:	ef 92       	push	r14
    2f86:	ff 92       	push	r15
    2f88:	6a 01       	movw	r12, r20
    2f8a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2f8c:	60 91 10 33 	lds	r22, 0x3310	; 0x803310 <pxCurrentTCB>
    2f90:	70 91 11 33 	lds	r23, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2f94:	62 5f       	subi	r22, 0xF2	; 242
    2f96:	7f 4f       	sbci	r23, 0xFF	; 255
    2f98:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2f9c:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    2fa0:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    2fa4:	02 96       	adiw	r24, 0x02	; 2
    2fa6:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2faa:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    2fae:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    2fb2:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    2fb6:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2fba:	bc 01       	movw	r22, r24
    2fbc:	cd 01       	movw	r24, r26
    2fbe:	6c 0d       	add	r22, r12
    2fc0:	7d 1d       	adc	r23, r13
    2fc2:	8e 1d       	adc	r24, r14
    2fc4:	9f 1d       	adc	r25, r15
    2fc6:	0e 94 00 14 	call	0x2800	; 0x2800 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2fca:	ff 90       	pop	r15
    2fcc:	ef 90       	pop	r14
    2fce:	df 90       	pop	r13
    2fd0:	cf 90       	pop	r12
    2fd2:	08 95       	ret

00002fd4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2fd4:	0f 93       	push	r16
    2fd6:	1f 93       	push	r17
    2fd8:	cf 93       	push	r28
    2fda:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2fdc:	dc 01       	movw	r26, r24
    2fde:	17 96       	adiw	r26, 0x07	; 7
    2fe0:	ed 91       	ld	r30, X+
    2fe2:	fc 91       	ld	r31, X
    2fe4:	18 97       	sbiw	r26, 0x08	; 8
    2fe6:	c0 85       	ldd	r28, Z+8	; 0x08
    2fe8:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2fea:	8e 01       	movw	r16, r28
    2fec:	02 5f       	subi	r16, 0xF2	; 242
    2fee:	1f 4f       	sbci	r17, 0xFF	; 255
    2ff0:	c8 01       	movw	r24, r16
    2ff2:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2ff6:	80 91 b4 32 	lds	r24, 0x32B4	; 0x8032b4 <uxSchedulerSuspended>
    2ffa:	81 11       	cpse	r24, r1
    2ffc:	16 c0       	rjmp	.+44     	; 0x302a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2ffe:	0c 50       	subi	r16, 0x0C	; 12
    3000:	11 09       	sbc	r17, r1
    3002:	c8 01       	movw	r24, r16
    3004:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    3008:	8a 8d       	ldd	r24, Y+26	; 0x1a
    300a:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    300e:	98 17       	cp	r25, r24
    3010:	10 f4       	brcc	.+4      	; 0x3016 <xTaskRemoveFromEventList+0x42>
    3012:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    3016:	bb e0       	ldi	r27, 0x0B	; 11
    3018:	8b 9f       	mul	r24, r27
    301a:	c0 01       	movw	r24, r0
    301c:	11 24       	eor	r1, r1
    301e:	b8 01       	movw	r22, r16
    3020:	8c 51       	subi	r24, 0x1C	; 28
    3022:	9d 4c       	sbci	r25, 0xCD	; 205
    3024:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
    3028:	05 c0       	rjmp	.+10     	; 0x3034 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    302a:	b8 01       	movw	r22, r16
    302c:	8f eb       	ldi	r24, 0xBF	; 191
    302e:	92 e3       	ldi	r25, 0x32	; 50
    3030:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3034:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    3038:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    303c:	81 e0       	ldi	r24, 0x01	; 1
    303e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    3040:	92 8d       	ldd	r25, Z+26	; 0x1a
    3042:	29 17       	cp	r18, r25
    3044:	08 f4       	brcc	.+2      	; 0x3048 <xTaskRemoveFromEventList+0x74>
    3046:	80 e0       	ldi	r24, 0x00	; 0
}
    3048:	df 91       	pop	r29
    304a:	cf 91       	pop	r28
    304c:	1f 91       	pop	r17
    304e:	0f 91       	pop	r16
    3050:	08 95       	ret

00003052 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3052:	20 91 b1 32 	lds	r18, 0x32B1	; 0x8032b1 <xNumOfOverflows>
    3056:	fc 01       	movw	r30, r24
    3058:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    305a:	40 91 b8 32 	lds	r20, 0x32B8	; 0x8032b8 <xTickCount>
    305e:	50 91 b9 32 	lds	r21, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    3062:	60 91 ba 32 	lds	r22, 0x32BA	; 0x8032ba <xTickCount+0x2>
    3066:	70 91 bb 32 	lds	r23, 0x32BB	; 0x8032bb <xTickCount+0x3>
    306a:	41 83       	std	Z+1, r20	; 0x01
    306c:	52 83       	std	Z+2, r21	; 0x02
    306e:	63 83       	std	Z+3, r22	; 0x03
    3070:	74 83       	std	Z+4, r23	; 0x04
    3072:	08 95       	ret

00003074 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    3074:	8f 92       	push	r8
    3076:	9f 92       	push	r9
    3078:	af 92       	push	r10
    307a:	bf 92       	push	r11
    307c:	cf 92       	push	r12
    307e:	df 92       	push	r13
    3080:	ef 92       	push	r14
    3082:	ff 92       	push	r15
    3084:	0f 93       	push	r16
    3086:	1f 93       	push	r17
    3088:	cf 93       	push	r28
    308a:	df 93       	push	r29
    308c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    308e:	0f b6       	in	r0, 0x3f	; 63
    3090:	f8 94       	cli
    3092:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3094:	80 91 b1 32 	lds	r24, 0x32B1	; 0x8032b1 <xNumOfOverflows>
    3098:	90 81       	ld	r25, Z
    309a:	98 17       	cp	r25, r24
    309c:	89 f0       	breq	.+34     	; 0x30c0 <xTaskCheckForTimeOut+0x4c>
    309e:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    30a2:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    30a6:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    30aa:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    30ae:	01 81       	ldd	r16, Z+1	; 0x01
    30b0:	12 81       	ldd	r17, Z+2	; 0x02
    30b2:	23 81       	ldd	r18, Z+3	; 0x03
    30b4:	34 81       	ldd	r19, Z+4	; 0x04
    30b6:	80 17       	cp	r24, r16
    30b8:	91 07       	cpc	r25, r17
    30ba:	a2 07       	cpc	r26, r18
    30bc:	b3 07       	cpc	r27, r19
    30be:	a8 f5       	brcc	.+106    	; 0x312a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    30c0:	80 91 b8 32 	lds	r24, 0x32B8	; 0x8032b8 <xTickCount>
    30c4:	90 91 b9 32 	lds	r25, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    30c8:	a0 91 ba 32 	lds	r26, 0x32BA	; 0x8032ba <xTickCount+0x2>
    30cc:	b0 91 bb 32 	lds	r27, 0x32BB	; 0x8032bb <xTickCount+0x3>
    30d0:	c1 80       	ldd	r12, Z+1	; 0x01
    30d2:	d2 80       	ldd	r13, Z+2	; 0x02
    30d4:	e3 80       	ldd	r14, Z+3	; 0x03
    30d6:	f4 80       	ldd	r15, Z+4	; 0x04
    30d8:	eb 01       	movw	r28, r22
    30da:	08 81       	ld	r16, Y
    30dc:	19 81       	ldd	r17, Y+1	; 0x01
    30de:	2a 81       	ldd	r18, Y+2	; 0x02
    30e0:	3b 81       	ldd	r19, Y+3	; 0x03
    30e2:	8c 19       	sub	r24, r12
    30e4:	9d 09       	sbc	r25, r13
    30e6:	ae 09       	sbc	r26, r14
    30e8:	bf 09       	sbc	r27, r15
    30ea:	80 17       	cp	r24, r16
    30ec:	91 07       	cpc	r25, r17
    30ee:	a2 07       	cpc	r26, r18
    30f0:	b3 07       	cpc	r27, r19
    30f2:	e8 f4       	brcc	.+58     	; 0x312e <xTaskCheckForTimeOut+0xba>
    30f4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    30f6:	80 90 b8 32 	lds	r8, 0x32B8	; 0x8032b8 <xTickCount>
    30fa:	90 90 b9 32 	lds	r9, 0x32B9	; 0x8032b9 <xTickCount+0x1>
    30fe:	a0 90 ba 32 	lds	r10, 0x32BA	; 0x8032ba <xTickCount+0x2>
    3102:	b0 90 bb 32 	lds	r11, 0x32BB	; 0x8032bb <xTickCount+0x3>
    3106:	b5 01       	movw	r22, r10
    3108:	a4 01       	movw	r20, r8
    310a:	4c 19       	sub	r20, r12
    310c:	5d 09       	sbc	r21, r13
    310e:	6e 09       	sbc	r22, r14
    3110:	7f 09       	sbc	r23, r15
    3112:	04 1b       	sub	r16, r20
    3114:	15 0b       	sbc	r17, r21
    3116:	26 0b       	sbc	r18, r22
    3118:	37 0b       	sbc	r19, r23
    311a:	08 83       	st	Y, r16
    311c:	19 83       	std	Y+1, r17	; 0x01
    311e:	2a 83       	std	Y+2, r18	; 0x02
    3120:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    3122:	0e 94 29 18 	call	0x3052	; 0x3052 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    3126:	80 e0       	ldi	r24, 0x00	; 0
    3128:	03 c0       	rjmp	.+6      	; 0x3130 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	01 c0       	rjmp	.+2      	; 0x3130 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    312e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    3130:	0f 90       	pop	r0
    3132:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3134:	df 91       	pop	r29
    3136:	cf 91       	pop	r28
    3138:	1f 91       	pop	r17
    313a:	0f 91       	pop	r16
    313c:	ff 90       	pop	r15
    313e:	ef 90       	pop	r14
    3140:	df 90       	pop	r13
    3142:	cf 90       	pop	r12
    3144:	bf 90       	pop	r11
    3146:	af 90       	pop	r10
    3148:	9f 90       	pop	r9
    314a:	8f 90       	pop	r8
    314c:	08 95       	ret

0000314e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    314e:	81 e0       	ldi	r24, 0x01	; 1
    3150:	80 93 b2 32 	sts	0x32B2, r24	; 0x8032b2 <xMissedYield>
    3154:	08 95       	ret

00003156 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3156:	00 97       	sbiw	r24, 0x00	; 0
    3158:	21 f4       	brne	.+8      	; 0x3162 <uxTaskGetStackHighWaterMark+0xc>
    315a:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    315e:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    3162:	dc 01       	movw	r26, r24
    3164:	5b 96       	adiw	r26, 0x1b	; 27
    3166:	ed 91       	ld	r30, X+
    3168:	fc 91       	ld	r31, X
    316a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    316c:	80 81       	ld	r24, Z
    316e:	81 31       	cpi	r24, 0x11	; 17
    3170:	41 f4       	brne	.+16     	; 0x3182 <uxTaskGetStackHighWaterMark+0x2c>
    3172:	31 96       	adiw	r30, 0x01	; 1
    3174:	80 e0       	ldi	r24, 0x00	; 0
    3176:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    3178:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    317a:	21 91       	ld	r18, Z+
    317c:	21 31       	cpi	r18, 0x11	; 17
    317e:	e1 f3       	breq	.-8      	; 0x3178 <uxTaskGetStackHighWaterMark+0x22>
    3180:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    3182:	80 e0       	ldi	r24, 0x00	; 0
    3184:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    3186:	08 95       	ret

00003188 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    3188:	80 91 10 33 	lds	r24, 0x3310	; 0x803310 <pxCurrentTCB>
    318c:	90 91 11 33 	lds	r25, 0x3311	; 0x803311 <pxCurrentTCB+0x1>

		return xReturn;
	}
    3190:	08 95       	ret

00003192 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    3192:	0f 93       	push	r16
    3194:	1f 93       	push	r17
    3196:	cf 93       	push	r28
    3198:	df 93       	push	r29
    319a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    319c:	22 8d       	ldd	r18, Z+26	; 0x1a
    319e:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    31a2:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    31a6:	5a 96       	adiw	r26, 0x1a	; 26
    31a8:	8c 91       	ld	r24, X
    31aa:	28 17       	cp	r18, r24
    31ac:	08 f0       	brcs	.+2      	; 0x31b0 <vTaskPriorityInherit+0x1e>
    31ae:	41 c0       	rjmp	.+130    	; 0x3232 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    31b0:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    31b4:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    31b8:	5a 96       	adiw	r26, 0x1a	; 26
    31ba:	3c 91       	ld	r19, X
    31bc:	84 e0       	ldi	r24, 0x04	; 4
    31be:	90 e0       	ldi	r25, 0x00	; 0
    31c0:	a0 e0       	ldi	r26, 0x00	; 0
    31c2:	b0 e0       	ldi	r27, 0x00	; 0
    31c4:	83 1b       	sub	r24, r19
    31c6:	91 09       	sbc	r25, r1
    31c8:	a1 09       	sbc	r26, r1
    31ca:	b1 09       	sbc	r27, r1
    31cc:	86 87       	std	Z+14, r24	; 0x0e
    31ce:	97 87       	std	Z+15, r25	; 0x0f
    31d0:	a0 8b       	std	Z+16, r26	; 0x10
    31d2:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    31d4:	8b e0       	ldi	r24, 0x0B	; 11
    31d6:	28 9f       	mul	r18, r24
    31d8:	90 01       	movw	r18, r0
    31da:	11 24       	eor	r1, r1
    31dc:	2c 51       	subi	r18, 0x1C	; 28
    31de:	3d 4c       	sbci	r19, 0xCD	; 205
    31e0:	84 85       	ldd	r24, Z+12	; 0x0c
    31e2:	95 85       	ldd	r25, Z+13	; 0x0d
    31e4:	82 17       	cp	r24, r18
    31e6:	93 07       	cpc	r25, r19
    31e8:	e9 f4       	brne	.+58     	; 0x3224 <vTaskPriorityInherit+0x92>
    31ea:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    31ec:	ef 01       	movw	r28, r30
    31ee:	22 96       	adiw	r28, 0x02	; 2
    31f0:	ce 01       	movw	r24, r28
    31f2:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    31f6:	e0 91 10 33 	lds	r30, 0x3310	; 0x803310 <pxCurrentTCB>
    31fa:	f0 91 11 33 	lds	r31, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    31fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    3200:	f8 01       	movw	r30, r16
    3202:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    3204:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    3208:	98 17       	cp	r25, r24
    320a:	10 f4       	brcc	.+4      	; 0x3210 <vTaskPriorityInherit+0x7e>
    320c:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    3210:	fb e0       	ldi	r31, 0x0B	; 11
    3212:	8f 9f       	mul	r24, r31
    3214:	c0 01       	movw	r24, r0
    3216:	11 24       	eor	r1, r1
    3218:	be 01       	movw	r22, r28
    321a:	8c 51       	subi	r24, 0x1C	; 28
    321c:	9d 4c       	sbci	r25, 0xCD	; 205
    321e:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
    3222:	07 c0       	rjmp	.+14     	; 0x3232 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3224:	a0 91 10 33 	lds	r26, 0x3310	; 0x803310 <pxCurrentTCB>
    3228:	b0 91 11 33 	lds	r27, 0x3311	; 0x803311 <pxCurrentTCB+0x1>
    322c:	5a 96       	adiw	r26, 0x1a	; 26
    322e:	8c 91       	ld	r24, X
    3230:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    3232:	df 91       	pop	r29
    3234:	cf 91       	pop	r28
    3236:	1f 91       	pop	r17
    3238:	0f 91       	pop	r16
    323a:	08 95       	ret

0000323c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    323c:	0f 93       	push	r16
    323e:	1f 93       	push	r17
    3240:	cf 93       	push	r28
    3242:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3244:	00 97       	sbiw	r24, 0x00	; 0
    3246:	49 f1       	breq	.+82     	; 0x329a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3248:	fc 01       	movw	r30, r24
    324a:	32 8d       	ldd	r19, Z+26	; 0x1a
    324c:	27 a1       	ldd	r18, Z+39	; 0x27
    324e:	32 17       	cp	r19, r18
    3250:	21 f1       	breq	.+72     	; 0x329a <vTaskPriorityDisinherit+0x5e>
    3252:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    3254:	8c 01       	movw	r16, r24
    3256:	0e 5f       	subi	r16, 0xFE	; 254
    3258:	1f 4f       	sbci	r17, 0xFF	; 255
    325a:	c8 01       	movw	r24, r16
    325c:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    3260:	8f a1       	ldd	r24, Y+39	; 0x27
    3262:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    3264:	44 e0       	ldi	r20, 0x04	; 4
    3266:	50 e0       	ldi	r21, 0x00	; 0
    3268:	60 e0       	ldi	r22, 0x00	; 0
    326a:	70 e0       	ldi	r23, 0x00	; 0
    326c:	48 1b       	sub	r20, r24
    326e:	51 09       	sbc	r21, r1
    3270:	61 09       	sbc	r22, r1
    3272:	71 09       	sbc	r23, r1
    3274:	4e 87       	std	Y+14, r20	; 0x0e
    3276:	5f 87       	std	Y+15, r21	; 0x0f
    3278:	68 8b       	std	Y+16, r22	; 0x10
    327a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    327c:	90 91 b6 32 	lds	r25, 0x32B6	; 0x8032b6 <uxTopReadyPriority>
    3280:	98 17       	cp	r25, r24
    3282:	10 f4       	brcc	.+4      	; 0x3288 <vTaskPriorityDisinherit+0x4c>
    3284:	80 93 b6 32 	sts	0x32B6, r24	; 0x8032b6 <uxTopReadyPriority>
    3288:	fb e0       	ldi	r31, 0x0B	; 11
    328a:	8f 9f       	mul	r24, r31
    328c:	c0 01       	movw	r24, r0
    328e:	11 24       	eor	r1, r1
    3290:	b8 01       	movw	r22, r16
    3292:	8c 51       	subi	r24, 0x1C	; 28
    3294:	9d 4c       	sbci	r25, 0xCD	; 205
    3296:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <vListInsertEnd>
			}
		}
	}
    329a:	df 91       	pop	r29
    329c:	cf 91       	pop	r28
    329e:	1f 91       	pop	r17
    32a0:	0f 91       	pop	r16
    32a2:	08 95       	ret

000032a4 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    32a4:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    32a6:	e8 81       	ld	r30, Y
    32a8:	f9 81       	ldd	r31, Y+1	; 0x01
    32aa:	01 90       	ld	r0, Z+
    32ac:	f0 81       	ld	r31, Z
    32ae:	e0 2d       	mov	r30, r0
    32b0:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    32b2:	1a 82       	std	Y+2, r1	; 0x02
    32b4:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    32b6:	6f ef       	ldi	r22, 0xFF	; 255
    32b8:	7f ef       	ldi	r23, 0xFF	; 255
    32ba:	cb 01       	movw	r24, r22
    32bc:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <vTaskDelay>
    32c0:	fa cf       	rjmp	.-12     	; 0x32b6 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000032c2 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    32c2:	fc 01       	movw	r30, r24
    32c4:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    32c6:	65 87       	std	Z+13, r22	; 0x0d
    32c8:	08 95       	ret

000032ca <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    32ca:	4f 92       	push	r4
    32cc:	5f 92       	push	r5
    32ce:	6f 92       	push	r6
    32d0:	7f 92       	push	r7
    32d2:	8f 92       	push	r8
    32d4:	9f 92       	push	r9
    32d6:	af 92       	push	r10
    32d8:	bf 92       	push	r11
    32da:	cf 92       	push	r12
    32dc:	df 92       	push	r13
    32de:	ef 92       	push	r14
    32e0:	ff 92       	push	r15
    32e2:	0f 93       	push	r16
    32e4:	1f 93       	push	r17
    32e6:	cf 93       	push	r28
    32e8:	df 93       	push	r29
    32ea:	cd b7       	in	r28, 0x3d	; 61
    32ec:	de b7       	in	r29, 0x3e	; 62
    32ee:	2a 97       	sbiw	r28, 0x0a	; 10
    32f0:	cd bf       	out	0x3d, r28	; 61
    32f2:	de bf       	out	0x3e, r29	; 62
    32f4:	4c 01       	movw	r8, r24
    32f6:	29 01       	movw	r4, r18
    32f8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    32fa:	8f ef       	ldi	r24, 0xFF	; 255
    32fc:	91 e2       	ldi	r25, 0x21	; 33
    32fe:	f4 01       	movw	r30, r8
    3300:	80 83       	st	Z, r24
    3302:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    3304:	fb 01       	movw	r30, r22
    3306:	80 81       	ld	r24, Z
    3308:	88 23       	and	r24, r24
    330a:	69 f0       	breq	.+26     	; 0x3326 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    330c:	de 01       	movw	r26, r28
    330e:	11 96       	adiw	r26, 0x01	; 1
    3310:	31 96       	adiw	r30, 0x01	; 1
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	02 c0       	rjmp	.+4      	; 0x331a <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    3316:	99 30       	cpi	r25, 0x09	; 9
    3318:	39 f0       	breq	.+14     	; 0x3328 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    331a:	9f 5f       	subi	r25, 0xFF	; 255
    331c:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    331e:	81 91       	ld	r24, Z+
    3320:	81 11       	cpse	r24, r1
    3322:	f9 cf       	rjmp	.-14     	; 0x3316 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    3324:	01 c0       	rjmp	.+2      	; 0x3328 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    3326:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    3328:	e1 e0       	ldi	r30, 0x01	; 1
    332a:	f0 e0       	ldi	r31, 0x00	; 0
    332c:	ec 0f       	add	r30, r28
    332e:	fd 1f       	adc	r31, r29
    3330:	e9 0f       	add	r30, r25
    3332:	f1 1d       	adc	r31, r1
    3334:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    3336:	74 01       	movw	r14, r8
    3338:	f2 e0       	ldi	r31, 0x02	; 2
    333a:	ef 0e       	add	r14, r31
    333c:	f1 1c       	adc	r15, r1
    333e:	a1 2c       	mov	r10, r1
    3340:	b1 2c       	mov	r11, r1
    3342:	c1 2c       	mov	r12, r1
    3344:	d1 2c       	mov	r13, r1
    3346:	04 2f       	mov	r16, r20
    3348:	94 01       	movw	r18, r8
    334a:	a2 01       	movw	r20, r4
    334c:	be 01       	movw	r22, r28
    334e:	6f 5f       	subi	r22, 0xFF	; 255
    3350:	7f 4f       	sbci	r23, 0xFF	; 255
    3352:	82 e3       	ldi	r24, 0x32	; 50
    3354:	93 e0       	ldi	r25, 0x03	; 3
    3356:	0e 94 4e 14 	call	0x289c	; 0x289c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    335a:	f4 01       	movw	r30, r8
    335c:	66 82       	std	Z+6, r6	; 0x06
    335e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    3360:	40 86       	std	Z+8, r4	; 0x08
    3362:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    3364:	20 91 12 33 	lds	r18, 0x3312	; 0x803312 <last_created_task_pointer>
    3368:	30 91 13 33 	lds	r19, 0x3313	; 0x803313 <last_created_task_pointer+0x1>
    336c:	24 83       	std	Z+4, r18	; 0x04
    336e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    3370:	80 92 12 33 	sts	0x3312, r8	; 0x803312 <last_created_task_pointer>
    3374:	90 92 13 33 	sts	0x3313, r9	; 0x803313 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    3378:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    337a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    337c:	40 90 74 33 	lds	r4, 0x3374	; 0x803374 <portStackTopForTask>
    3380:	50 90 75 33 	lds	r5, 0x3375	; 0x803375 <portStackTopForTask+0x1>
    3384:	ff ef       	ldi	r31, 0xFF	; 255
    3386:	4f 1a       	sub	r4, r31
    3388:	5f 0a       	sbc	r5, r31
    338a:	40 92 74 33 	sts	0x3374, r4	; 0x803374 <portStackTopForTask>
    338e:	50 92 75 33 	sts	0x3375, r5	; 0x803375 <portStackTopForTask+0x1>
    3392:	f4 01       	movw	r30, r8
    3394:	42 86       	std	Z+10, r4	; 0x0a
    3396:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    3398:	16 86       	std	Z+14, r1	; 0x0e
    339a:	17 86       	std	Z+15, r1	; 0x0f
    339c:	10 8a       	std	Z+16, r1	; 0x10
    339e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    33a0:	61 14       	cp	r6, r1
    33a2:	71 04       	cpc	r7, r1
    33a4:	09 f4       	brne	.+2      	; 0x33a8 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    33a6:	44 c0       	rjmp	.+136    	; 0x3430 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    33a8:	81 30       	cpi	r24, 0x01	; 1
    33aa:	79 f5       	brne	.+94     	; 0x340a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    33ac:	6a e0       	ldi	r22, 0x0A	; 10
    33ae:	c3 01       	movw	r24, r6
    33b0:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    33b4:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    33b6:	61 eb       	ldi	r22, 0xB1	; 177
    33b8:	75 e0       	ldi	r23, 0x05	; 5
    33ba:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    33be:	be 01       	movw	r22, r28
    33c0:	6f 5f       	subi	r22, 0xFF	; 255
    33c2:	7f 4f       	sbci	r23, 0xFF	; 255
    33c4:	c7 01       	movw	r24, r14
    33c6:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    33ca:	6a e0       	ldi	r22, 0x0A	; 10
    33cc:	c7 01       	movw	r24, r14
    33ce:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    33d2:	7c 01       	movw	r14, r24
    33d4:	68 ea       	ldi	r22, 0xA8	; 168
    33d6:	75 e0       	ldi	r23, 0x05	; 5
    33d8:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    33dc:	6a e0       	ldi	r22, 0x0A	; 10
    33de:	c7 01       	movw	r24, r14
    33e0:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    33e4:	7c 01       	movw	r14, r24
    33e6:	6a e9       	ldi	r22, 0x9A	; 154
    33e8:	75 e0       	ldi	r23, 0x05	; 5
    33ea:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    33ee:	63 e0       	ldi	r22, 0x03	; 3
    33f0:	c7 01       	movw	r24, r14
    33f2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    33f6:	b2 01       	movw	r22, r4
    33f8:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    33fc:	62 e0       	ldi	r22, 0x02	; 2
    33fe:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3402:	66 e0       	ldi	r22, 0x06	; 6
    3404:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3408:	13 c0       	rjmp	.+38     	; 0x3430 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    340a:	6a e0       	ldi	r22, 0x0A	; 10
    340c:	c3 01       	movw	r24, r6
    340e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3412:	4c 01       	movw	r8, r24
    3414:	65 e8       	ldi	r22, 0x85	; 133
    3416:	75 e0       	ldi	r23, 0x05	; 5
    3418:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    341c:	be 01       	movw	r22, r28
    341e:	6f 5f       	subi	r22, 0xFF	; 255
    3420:	7f 4f       	sbci	r23, 0xFF	; 255
    3422:	c4 01       	movw	r24, r8
    3424:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3428:	66 e0       	ldi	r22, 0x06	; 6
    342a:	c4 01       	movw	r24, r8
    342c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    3430:	2a 96       	adiw	r28, 0x0a	; 10
    3432:	cd bf       	out	0x3d, r28	; 61
    3434:	de bf       	out	0x3e, r29	; 62
    3436:	df 91       	pop	r29
    3438:	cf 91       	pop	r28
    343a:	1f 91       	pop	r17
    343c:	0f 91       	pop	r16
    343e:	ff 90       	pop	r15
    3440:	ef 90       	pop	r14
    3442:	df 90       	pop	r13
    3444:	cf 90       	pop	r12
    3446:	bf 90       	pop	r11
    3448:	af 90       	pop	r10
    344a:	9f 90       	pop	r9
    344c:	8f 90       	pop	r8
    344e:	7f 90       	pop	r7
    3450:	6f 90       	pop	r6
    3452:	5f 90       	pop	r5
    3454:	4f 90       	pop	r4
    3456:	08 95       	ret

00003458 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    3458:	cf 92       	push	r12
    345a:	df 92       	push	r13
    345c:	ef 92       	push	r14
    345e:	ff 92       	push	r15
    3460:	0f 93       	push	r16
    3462:	1f 93       	push	r17
    3464:	cf 93       	push	r28
    3466:	df 93       	push	r29
    3468:	ec 01       	movw	r28, r24
    346a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    346c:	8a 81       	ldd	r24, Y+2	; 0x02
    346e:	9b 81       	ldd	r25, Y+3	; 0x03
    3470:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <pcTaskGetTaskName>
    3474:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    3476:	6a e0       	ldi	r22, 0x0A	; 10
    3478:	c7 01       	movw	r24, r14
    347a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    347e:	8c 01       	movw	r16, r24
    3480:	64 ec       	ldi	r22, 0xC4	; 196
    3482:	75 e0       	ldi	r23, 0x05	; 5
    3484:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3488:	6a e0       	ldi	r22, 0x0A	; 10
    348a:	c8 01       	movw	r24, r16
    348c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3490:	8c 01       	movw	r16, r24
    3492:	6d eb       	ldi	r22, 0xBD	; 189
    3494:	75 e0       	ldi	r23, 0x05	; 5
    3496:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    349a:	b6 01       	movw	r22, r12
    349c:	c8 01       	movw	r24, r16
    349e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    34a2:	6a e0       	ldi	r22, 0x0A	; 10
    34a4:	c8 01       	movw	r24, r16
    34a6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    34aa:	8c 01       	movw	r16, r24
    34ac:	67 eb       	ldi	r22, 0xB7	; 183
    34ae:	75 e0       	ldi	r23, 0x05	; 5
    34b0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    34b4:	66 e0       	ldi	r22, 0x06	; 6
    34b6:	c8 01       	movw	r24, r16
    34b8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    34bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    34be:	9b 85       	ldd	r25, Y+11	; 0x0b
    34c0:	e8 85       	ldd	r30, Y+8	; 0x08
    34c2:	f9 85       	ldd	r31, Y+9	; 0x09
    34c4:	01 e1       	ldi	r16, 0x11	; 17
    34c6:	21 e0       	ldi	r18, 0x01	; 1
    34c8:	a7 01       	movw	r20, r14
    34ca:	bc 01       	movw	r22, r24
    34cc:	8e 1b       	sub	r24, r30
    34ce:	9f 0b       	sbc	r25, r31
    34d0:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    34d4:	8c 81       	ldd	r24, Y+4	; 0x04
    34d6:	9d 81       	ldd	r25, Y+5	; 0x05
    34d8:	00 97       	sbiw	r24, 0x00	; 0
    34da:	19 f0       	breq	.+6      	; 0x34e2 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    34dc:	b7 01       	movw	r22, r14
    34de:	0e 94 2c 1a 	call	0x3458	; 0x3458 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    34e2:	df 91       	pop	r29
    34e4:	cf 91       	pop	r28
    34e6:	1f 91       	pop	r17
    34e8:	0f 91       	pop	r16
    34ea:	ff 90       	pop	r15
    34ec:	ef 90       	pop	r14
    34ee:	df 90       	pop	r13
    34f0:	cf 90       	pop	r12
    34f2:	08 95       	ret

000034f4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    34f4:	0f 93       	push	r16
    34f6:	1f 93       	push	r17
    34f8:	cf 93       	push	r28
    34fa:	df 93       	push	r29
    34fc:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    34fe:	80 91 12 33 	lds	r24, 0x3312	; 0x803312 <last_created_task_pointer>
    3502:	90 91 13 33 	lds	r25, 0x3313	; 0x803313 <last_created_task_pointer+0x1>
    3506:	00 97       	sbiw	r24, 0x00	; 0
    3508:	19 f0       	breq	.+6      	; 0x3510 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    350a:	be 01       	movw	r22, r28
    350c:	0e 94 2c 1a 	call	0x3458	; 0x3458 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    3510:	6a e0       	ldi	r22, 0x0A	; 10
    3512:	ce 01       	movw	r24, r28
    3514:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3518:	8c 01       	movw	r16, r24
    351a:	6a ed       	ldi	r22, 0xDA	; 218
    351c:	75 e0       	ldi	r23, 0x05	; 5
    351e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3522:	6a e0       	ldi	r22, 0x0A	; 10
    3524:	c8 01       	movw	r24, r16
    3526:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    352a:	8c 01       	movw	r16, r24
    352c:	6f ec       	ldi	r22, 0xCF	; 207
    352e:	75 e0       	ldi	r23, 0x05	; 5
    3530:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3534:	6a e0       	ldi	r22, 0x0A	; 10
    3536:	c8 01       	movw	r24, r16
    3538:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    353c:	8c 01       	movw	r16, r24
    353e:	69 ec       	ldi	r22, 0xC9	; 201
    3540:	75 e0       	ldi	r23, 0x05	; 5
    3542:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3546:	66 e0       	ldi	r22, 0x06	; 6
    3548:	c8 01       	movw	r24, r16
    354a:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    354e:	80 91 74 33 	lds	r24, 0x3374	; 0x803374 <portStackTopForTask>
    3552:	90 91 75 33 	lds	r25, 0x3375	; 0x803375 <portStackTopForTask+0x1>
    3556:	bc 01       	movw	r22, r24
    3558:	6f 5f       	subi	r22, 0xFF	; 255
    355a:	7f 4f       	sbci	r23, 0xFF	; 255
    355c:	01 e1       	ldi	r16, 0x11	; 17
    355e:	21 e0       	ldi	r18, 0x01	; 1
    3560:	ae 01       	movw	r20, r28
    3562:	83 56       	subi	r24, 0x63	; 99
    3564:	91 09       	sbc	r25, r1
    3566:	0e 94 2e 1d 	call	0x3a5c	; 0x3a5c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    356a:	df 91       	pop	r29
    356c:	cf 91       	pop	r28
    356e:	1f 91       	pop	r17
    3570:	0f 91       	pop	r16
    3572:	08 95       	ret

00003574 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3574:	8f 92       	push	r8
    3576:	9f 92       	push	r9
    3578:	af 92       	push	r10
    357a:	bf 92       	push	r11
    357c:	cf 92       	push	r12
    357e:	df 92       	push	r13
    3580:	ef 92       	push	r14
    3582:	ff 92       	push	r15
    3584:	0f 93       	push	r16
    3586:	1f 93       	push	r17
    3588:	cf 93       	push	r28
    358a:	df 93       	push	r29
    358c:	ec 01       	movw	r28, r24
    358e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    3590:	8a 81       	ldd	r24, Y+2	; 0x02
    3592:	9b 81       	ldd	r25, Y+3	; 0x03
    3594:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <pcTaskGetTaskName>
    3598:	bc 01       	movw	r22, r24
    359a:	c8 01       	movw	r24, r16
    359c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    35a0:	d8 01       	movw	r26, r16
    35a2:	ed 91       	ld	r30, X+
    35a4:	fc 91       	ld	r31, X
    35a6:	02 80       	ldd	r0, Z+2	; 0x02
    35a8:	f3 81       	ldd	r31, Z+3	; 0x03
    35aa:	e0 2d       	mov	r30, r0
    35ac:	69 e0       	ldi	r22, 0x09	; 9
    35ae:	c8 01       	movw	r24, r16
    35b0:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    35b2:	8a 81       	ldd	r24, Y+2	; 0x02
    35b4:	9b 81       	ldd	r25, Y+3	; 0x03
    35b6:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <pcTaskGetTaskName>
    35ba:	fc 01       	movw	r30, r24
    35bc:	01 90       	ld	r0, Z+
    35be:	00 20       	and	r0, r0
    35c0:	e9 f7       	brne	.-6      	; 0x35bc <_ZN8frt_task12print_statusER8emstream+0x48>
    35c2:	31 97       	sbiw	r30, 0x01	; 1
    35c4:	e8 1b       	sub	r30, r24
    35c6:	f9 0b       	sbc	r31, r25
    35c8:	38 97       	sbiw	r30, 0x08	; 8
    35ca:	48 f4       	brcc	.+18     	; 0x35de <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    35cc:	d8 01       	movw	r26, r16
    35ce:	ed 91       	ld	r30, X+
    35d0:	fc 91       	ld	r31, X
    35d2:	02 80       	ldd	r0, Z+2	; 0x02
    35d4:	f3 81       	ldd	r31, Z+3	; 0x03
    35d6:	e0 2d       	mov	r30, r0
    35d8:	69 e0       	ldi	r22, 0x09	; 9
    35da:	c8 01       	movw	r24, r16
    35dc:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    35de:	ce 84       	ldd	r12, Y+14	; 0x0e
    35e0:	df 84       	ldd	r13, Y+15	; 0x0f
    35e2:	e8 88       	ldd	r14, Y+16	; 0x10
    35e4:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    35e6:	a8 84       	ldd	r10, Y+8	; 0x08
    35e8:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    35ea:	8a 81       	ldd	r24, Y+2	; 0x02
    35ec:	9b 81       	ldd	r25, Y+3	; 0x03
    35ee:	0e 94 ab 18 	call	0x3156	; 0x3156 <uxTaskGetStackHighWaterMark>
    35f2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    35f4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    35f6:	8a 81       	ldd	r24, Y+2	; 0x02
    35f8:	9b 81       	ldd	r25, Y+3	; 0x03
    35fa:	0e 94 50 15 	call	0x2aa0	; 0x2aa0 <uxTaskPriorityGet>
    35fe:	68 2f       	mov	r22, r24
    3600:	c8 01       	movw	r24, r16
    3602:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3606:	6a e0       	ldi	r22, 0x0A	; 10
    3608:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    360c:	ec 01       	movw	r28, r24
    360e:	6f e4       	ldi	r22, 0x4F	; 79
    3610:	76 e0       	ldi	r23, 0x06	; 6
    3612:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3616:	68 2d       	mov	r22, r8
    3618:	ce 01       	movw	r24, r28
    361a:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    361e:	6a e0       	ldi	r22, 0x0A	; 10
    3620:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3624:	ec 01       	movw	r28, r24
    3626:	6d e4       	ldi	r22, 0x4D	; 77
    3628:	76 e0       	ldi	r23, 0x06	; 6
    362a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    362e:	69 2d       	mov	r22, r9
    3630:	ce 01       	movw	r24, r28
    3632:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3636:	6a e0       	ldi	r22, 0x0A	; 10
    3638:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    363c:	ec 01       	movw	r28, r24
    363e:	6b e4       	ldi	r22, 0x4B	; 75
    3640:	76 e0       	ldi	r23, 0x06	; 6
    3642:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3646:	b5 01       	movw	r22, r10
    3648:	ce 01       	movw	r24, r28
    364a:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    364e:	6a e0       	ldi	r22, 0x0A	; 10
    3650:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3654:	ec 01       	movw	r28, r24
    3656:	69 e4       	ldi	r22, 0x49	; 73
    3658:	76 e0       	ldi	r23, 0x06	; 6
    365a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    365e:	6a e0       	ldi	r22, 0x0A	; 10
    3660:	ce 01       	movw	r24, r28
    3662:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3666:	ec 01       	movw	r28, r24
    3668:	67 e4       	ldi	r22, 0x47	; 71
    366a:	76 e0       	ldi	r23, 0x06	; 6
    366c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3670:	b7 01       	movw	r22, r14
    3672:	a6 01       	movw	r20, r12
    3674:	ce 01       	movw	r24, r28
    3676:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsEm>
}
    367a:	df 91       	pop	r29
    367c:	cf 91       	pop	r28
    367e:	1f 91       	pop	r17
    3680:	0f 91       	pop	r16
    3682:	ff 90       	pop	r15
    3684:	ef 90       	pop	r14
    3686:	df 90       	pop	r13
    3688:	cf 90       	pop	r12
    368a:	bf 90       	pop	r11
    368c:	af 90       	pop	r10
    368e:	9f 90       	pop	r9
    3690:	8f 90       	pop	r8
    3692:	08 95       	ret

00003694 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    3694:	cf 93       	push	r28
    3696:	df 93       	push	r29
    3698:	ec 01       	movw	r28, r24
    369a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    369c:	db 01       	movw	r26, r22
    369e:	ed 91       	ld	r30, X+
    36a0:	fc 91       	ld	r31, X
    36a2:	02 80       	ldd	r0, Z+2	; 0x02
    36a4:	f3 81       	ldd	r31, Z+3	; 0x03
    36a6:	e0 2d       	mov	r30, r0
    36a8:	be 01       	movw	r22, r28
    36aa:	19 95       	eicall
	return (ser_dev);
}
    36ac:	ce 01       	movw	r24, r28
    36ae:	df 91       	pop	r29
    36b0:	cf 91       	pop	r28
    36b2:	08 95       	ret

000036b4 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    36b4:	0f 93       	push	r16
    36b6:	1f 93       	push	r17
    36b8:	cf 93       	push	r28
    36ba:	df 93       	push	r29
    36bc:	ec 01       	movw	r28, r24
    36be:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    36c0:	bc 01       	movw	r22, r24
    36c2:	c8 01       	movw	r24, r16
    36c4:	0e 94 4a 1b 	call	0x3694	; 0x3694 <_ZlsR8emstreamR8frt_task>
    36c8:	66 e0       	ldi	r22, 0x06	; 6
    36ca:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    36ce:	8c 81       	ldd	r24, Y+4	; 0x04
    36d0:	9d 81       	ldd	r25, Y+5	; 0x05
    36d2:	00 97       	sbiw	r24, 0x00	; 0
    36d4:	19 f0       	breq	.+6      	; 0x36dc <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    36d6:	b8 01       	movw	r22, r16
    36d8:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    36dc:	df 91       	pop	r29
    36de:	cf 91       	pop	r28
    36e0:	1f 91       	pop	r17
    36e2:	0f 91       	pop	r16
    36e4:	08 95       	ret

000036e6 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    36e6:	0f 93       	push	r16
    36e8:	1f 93       	push	r17
    36ea:	cf 93       	push	r28
    36ec:	df 93       	push	r29
    36ee:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    36f0:	6a e0       	ldi	r22, 0x0A	; 10
    36f2:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    36f6:	8c 01       	movw	r16, r24
    36f8:	6c e3       	ldi	r22, 0x3C	; 60
    36fa:	76 e0       	ldi	r23, 0x06	; 6
    36fc:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    3700:	6a e0       	ldi	r22, 0x0A	; 10
    3702:	c8 01       	movw	r24, r16
    3704:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3708:	8c 01       	movw	r16, r24
    370a:	65 e3       	ldi	r22, 0x35	; 53
    370c:	76 e0       	ldi	r23, 0x06	; 6
    370e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    3712:	66 e0       	ldi	r22, 0x06	; 6
    3714:	c8 01       	movw	r24, r16
    3716:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    371a:	6a e0       	ldi	r22, 0x0A	; 10
    371c:	ce 01       	movw	r24, r28
    371e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3722:	8c 01       	movw	r16, r24
    3724:	64 e2       	ldi	r22, 0x24	; 36
    3726:	76 e0       	ldi	r23, 0x06	; 6
    3728:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    372c:	6a e0       	ldi	r22, 0x0A	; 10
    372e:	c8 01       	movw	r24, r16
    3730:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3734:	8c 01       	movw	r16, r24
    3736:	68 e1       	ldi	r22, 0x18	; 24
    3738:	76 e0       	ldi	r23, 0x06	; 6
    373a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    373e:	6a e0       	ldi	r22, 0x0A	; 10
    3740:	c8 01       	movw	r24, r16
    3742:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3746:	8c 01       	movw	r16, r24
    3748:	62 e1       	ldi	r22, 0x12	; 18
    374a:	76 e0       	ldi	r23, 0x06	; 6
    374c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3750:	66 e0       	ldi	r22, 0x06	; 6
    3752:	c8 01       	movw	r24, r16
    3754:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3758:	6a e0       	ldi	r22, 0x0A	; 10
    375a:	ce 01       	movw	r24, r28
    375c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3760:	8c 01       	movw	r16, r24
    3762:	61 e0       	ldi	r22, 0x01	; 1
    3764:	76 e0       	ldi	r23, 0x06	; 6
    3766:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    376a:	6a e0       	ldi	r22, 0x0A	; 10
    376c:	c8 01       	movw	r24, r16
    376e:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3772:	8c 01       	movw	r16, r24
    3774:	65 ef       	ldi	r22, 0xF5	; 245
    3776:	75 e0       	ldi	r23, 0x05	; 5
    3778:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    377c:	6a e0       	ldi	r22, 0x0A	; 10
    377e:	c8 01       	movw	r24, r16
    3780:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3784:	8c 01       	movw	r16, r24
    3786:	6f ee       	ldi	r22, 0xEF	; 239
    3788:	75 e0       	ldi	r23, 0x05	; 5
    378a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    378e:	66 e0       	ldi	r22, 0x06	; 6
    3790:	c8 01       	movw	r24, r16
    3792:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    3796:	80 91 12 33 	lds	r24, 0x3312	; 0x803312 <last_created_task_pointer>
    379a:	90 91 13 33 	lds	r25, 0x3313	; 0x803313 <last_created_task_pointer+0x1>
    379e:	00 97       	sbiw	r24, 0x00	; 0
    37a0:	19 f0       	breq	.+6      	; 0x37a8 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    37a2:	be 01       	movw	r22, r28
    37a4:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    37a8:	0e 94 ad 15 	call	0x2b5a	; 0x2b5a <xTaskGetIdleTaskHandle>
    37ac:	0e 94 ab 18 	call	0x3156	; 0x3156 <uxTaskGetStackHighWaterMark>
    37b0:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    37b2:	6a e0       	ldi	r22, 0x0A	; 10
    37b4:	ce 01       	movw	r24, r28
    37b6:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    37ba:	ec 01       	movw	r28, r24
    37bc:	64 ee       	ldi	r22, 0xE4	; 228
    37be:	75 e0       	ldi	r23, 0x05	; 5
    37c0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    37c4:	61 2f       	mov	r22, r17
    37c6:	ce 01       	movw	r24, r28
    37c8:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    37cc:	6a e0       	ldi	r22, 0x0A	; 10
    37ce:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    37d2:	ec 01       	movw	r28, r24
    37d4:	62 ee       	ldi	r22, 0xE2	; 226
    37d6:	75 e0       	ldi	r23, 0x05	; 5
    37d8:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    37dc:	64 e6       	ldi	r22, 0x64	; 100
    37de:	70 e0       	ldi	r23, 0x00	; 0
    37e0:	ce 01       	movw	r24, r28
    37e2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    37e6:	6a e0       	ldi	r22, 0x0A	; 10
    37e8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    37ec:	ec 01       	movw	r28, r24
    37ee:	6f ed       	ldi	r22, 0xDF	; 223
    37f0:	75 e0       	ldi	r23, 0x05	; 5
    37f2:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    37f6:	66 e0       	ldi	r22, 0x06	; 6
    37f8:	ce 01       	movw	r24, r28
    37fa:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
}
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	1f 91       	pop	r17
    3804:	0f 91       	pop	r16
    3806:	08 95       	ret

00003808 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3808:	0f 93       	push	r16
    380a:	cf 93       	push	r28
    380c:	df 93       	push	r29
    380e:	1f 92       	push	r1
    3810:	cd b7       	in	r28, 0x3d	; 61
    3812:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3814:	00 e0       	ldi	r16, 0x00	; 0
    3816:	2f ef       	ldi	r18, 0xFF	; 255
    3818:	3f ef       	ldi	r19, 0xFF	; 255
    381a:	a9 01       	movw	r20, r18
    381c:	be 01       	movw	r22, r28
    381e:	6f 5f       	subi	r22, 0xFF	; 255
    3820:	7f 4f       	sbci	r23, 0xFF	; 255
    3822:	fc 01       	movw	r30, r24
    3824:	80 85       	ldd	r24, Z+8	; 0x08
    3826:	91 85       	ldd	r25, Z+9	; 0x09
    3828:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
    382c:	81 30       	cpi	r24, 0x01	; 1
    382e:	19 f4       	brne	.+6      	; 0x3836 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    3830:	89 81       	ldd	r24, Y+1	; 0x01
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	02 c0       	rjmp	.+4      	; 0x383a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3836:	8f ef       	ldi	r24, 0xFF	; 255
    3838:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    383a:	0f 90       	pop	r0
    383c:	df 91       	pop	r29
    383e:	cf 91       	pop	r28
    3840:	0f 91       	pop	r16
    3842:	08 95       	ret

00003844 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3844:	fc 01       	movw	r30, r24
    3846:	80 85       	ldd	r24, Z+8	; 0x08
    3848:	91 85       	ldd	r25, Z+9	; 0x09
    384a:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    384e:	91 e0       	ldi	r25, 0x01	; 1
    3850:	81 11       	cpse	r24, r1
    3852:	01 c0       	rjmp	.+2      	; 0x3856 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3854:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3856:	89 2f       	mov	r24, r25
    3858:	08 95       	ret

0000385a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    385a:	0f 93       	push	r16
    385c:	cf 93       	push	r28
    385e:	df 93       	push	r29
    3860:	1f 92       	push	r1
    3862:	cd b7       	in	r28, 0x3d	; 61
    3864:	de b7       	in	r29, 0x3e	; 62
    3866:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3868:	fc 01       	movw	r30, r24
    386a:	22 85       	ldd	r18, Z+10	; 0x0a
    386c:	33 85       	ldd	r19, Z+11	; 0x0b
    386e:	44 85       	ldd	r20, Z+12	; 0x0c
    3870:	55 85       	ldd	r21, Z+13	; 0x0d
    3872:	00 e0       	ldi	r16, 0x00	; 0
    3874:	be 01       	movw	r22, r28
    3876:	6f 5f       	subi	r22, 0xFF	; 255
    3878:	7f 4f       	sbci	r23, 0xFF	; 255
    387a:	80 85       	ldd	r24, Z+8	; 0x08
    387c:	91 85       	ldd	r25, Z+9	; 0x09
    387e:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    3882:	91 e0       	ldi	r25, 0x01	; 1
    3884:	81 11       	cpse	r24, r1
    3886:	01 c0       	rjmp	.+2      	; 0x388a <_ZN14frt_text_queue7putcharEc+0x30>
    3888:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    388a:	89 2f       	mov	r24, r25
    388c:	0f 90       	pop	r0
    388e:	df 91       	pop	r29
    3890:	cf 91       	pop	r28
    3892:	0f 91       	pop	r16
    3894:	08 95       	ret

00003896 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    3896:	8f 92       	push	r8
    3898:	9f 92       	push	r9
    389a:	bf 92       	push	r11
    389c:	cf 92       	push	r12
    389e:	df 92       	push	r13
    38a0:	ef 92       	push	r14
    38a2:	ff 92       	push	r15
    38a4:	0f 93       	push	r16
    38a6:	1f 93       	push	r17
    38a8:	cf 93       	push	r28
    38aa:	df 93       	push	r29
    38ac:	ec 01       	movw	r28, r24
    38ae:	b6 2e       	mov	r11, r22
    38b0:	4a 01       	movw	r8, r20
    38b2:	68 01       	movw	r12, r16
    38b4:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    38b6:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <_ZN8emstreamC1Ev>
    38ba:	87 e0       	ldi	r24, 0x07	; 7
    38bc:	92 e2       	ldi	r25, 0x22	; 34
    38be:	88 83       	st	Y, r24
    38c0:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    38c2:	8e 86       	std	Y+14, r8	; 0x0e
    38c4:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    38c6:	40 e0       	ldi	r20, 0x00	; 0
    38c8:	61 e0       	ldi	r22, 0x01	; 1
    38ca:	8b 2d       	mov	r24, r11
    38cc:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    38d0:	88 87       	std	Y+8, r24	; 0x08
    38d2:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    38d4:	ca 86       	std	Y+10, r12	; 0x0a
    38d6:	db 86       	std	Y+11, r13	; 0x0b
    38d8:	ec 86       	std	Y+12, r14	; 0x0c
    38da:	fd 86       	std	Y+13, r15	; 0x0d
}
    38dc:	df 91       	pop	r29
    38de:	cf 91       	pop	r28
    38e0:	1f 91       	pop	r17
    38e2:	0f 91       	pop	r16
    38e4:	ff 90       	pop	r15
    38e6:	ef 90       	pop	r14
    38e8:	df 90       	pop	r13
    38ea:	cf 90       	pop	r12
    38ec:	bf 90       	pop	r11
    38ee:	9f 90       	pop	r9
    38f0:	8f 90       	pop	r8
    38f2:	08 95       	ret

000038f4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    38f4:	cf 92       	push	r12
    38f6:	df 92       	push	r13
    38f8:	ef 92       	push	r14
    38fa:	ff 92       	push	r15
    38fc:	cf 93       	push	r28
    38fe:	df 93       	push	r29
    3900:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    3902:	68 81       	ld	r22, Y
    3904:	79 81       	ldd	r23, Y+1	; 0x01
    3906:	8a 81       	ldd	r24, Y+2	; 0x02
    3908:	9b 81       	ldd	r25, Y+3	; 0x03
    390a:	0f 2e       	mov	r0, r31
    390c:	f8 ee       	ldi	r31, 0xE8	; 232
    390e:	cf 2e       	mov	r12, r31
    3910:	f3 e0       	ldi	r31, 0x03	; 3
    3912:	df 2e       	mov	r13, r31
    3914:	e1 2c       	mov	r14, r1
    3916:	f1 2c       	mov	r15, r1
    3918:	f0 2d       	mov	r31, r0
    391a:	a7 01       	movw	r20, r14
    391c:	96 01       	movw	r18, r12
    391e:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    3922:	9b 01       	movw	r18, r22
    3924:	ac 01       	movw	r20, r24
    3926:	60 e4       	ldi	r22, 0x40	; 64
    3928:	72 e4       	ldi	r23, 0x42	; 66
    392a:	8f e0       	ldi	r24, 0x0F	; 15
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	0e 94 05 26 	call	0x4c0a	; 0x4c0a <__mulsi3>
    3932:	a7 01       	movw	r20, r14
    3934:	96 01       	movw	r18, r12
    3936:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    393a:	69 01       	movw	r12, r18
    393c:	7a 01       	movw	r14, r20
    393e:	ac 81       	ldd	r26, Y+4	; 0x04
    3940:	bd 81       	ldd	r27, Y+5	; 0x05
    3942:	20 e4       	ldi	r18, 0x40	; 64
    3944:	32 e4       	ldi	r19, 0x42	; 66
    3946:	4f e0       	ldi	r20, 0x0F	; 15
    3948:	50 e0       	ldi	r21, 0x00	; 0
    394a:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <__muluhisi3>
    394e:	20 e0       	ldi	r18, 0x00	; 0
    3950:	38 e4       	ldi	r19, 0x48	; 72
    3952:	48 ee       	ldi	r20, 0xE8	; 232
    3954:	51 e0       	ldi	r21, 0x01	; 1
    3956:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    395a:	c7 01       	movw	r24, r14
    395c:	b6 01       	movw	r22, r12
    395e:	62 0f       	add	r22, r18
    3960:	73 1f       	adc	r23, r19
    3962:	84 1f       	adc	r24, r20
    3964:	95 1f       	adc	r25, r21
}
    3966:	df 91       	pop	r29
    3968:	cf 91       	pop	r28
    396a:	ff 90       	pop	r15
    396c:	ef 90       	pop	r14
    396e:	df 90       	pop	r13
    3970:	cf 90       	pop	r12
    3972:	08 95       	ret

00003974 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3974:	cf 92       	push	r12
    3976:	df 92       	push	r13
    3978:	ef 92       	push	r14
    397a:	ff 92       	push	r15
    397c:	0f 93       	push	r16
    397e:	1f 93       	push	r17
    3980:	cf 93       	push	r28
    3982:	df 93       	push	r29
    3984:	cd b7       	in	r28, 0x3d	; 61
    3986:	de b7       	in	r29, 0x3e	; 62
    3988:	2f 97       	sbiw	r28, 0x0f	; 15
    398a:	cd bf       	out	0x3d, r28	; 61
    398c:	de bf       	out	0x3e, r29	; 62
    398e:	6c 01       	movw	r12, r24
    3990:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    3992:	db 01       	movw	r26, r22
    3994:	6d 91       	ld	r22, X+
    3996:	7d 91       	ld	r23, X+
    3998:	8d 91       	ld	r24, X+
    399a:	9c 91       	ld	r25, X
    399c:	28 ee       	ldi	r18, 0xE8	; 232
    399e:	33 e0       	ldi	r19, 0x03	; 3
    39a0:	40 e0       	ldi	r20, 0x00	; 0
    39a2:	50 e0       	ldi	r21, 0x00	; 0
    39a4:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    39a8:	ba 01       	movw	r22, r20
    39aa:	a9 01       	movw	r20, r18
    39ac:	c6 01       	movw	r24, r12
    39ae:	0e 94 6a 1f 	call	0x3ed4	; 0x3ed4 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    39b2:	d6 01       	movw	r26, r12
    39b4:	ed 91       	ld	r30, X+
    39b6:	fc 91       	ld	r31, X
    39b8:	02 80       	ldd	r0, Z+2	; 0x02
    39ba:	f3 81       	ldd	r31, Z+3	; 0x03
    39bc:	e0 2d       	mov	r30, r0
    39be:	6e e2       	ldi	r22, 0x2E	; 46
    39c0:	c6 01       	movw	r24, r12
    39c2:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    39c4:	c8 01       	movw	r24, r16
    39c6:	0e 94 7a 1c 	call	0x38f4	; 0x38f4 <_ZN10time_stamp12get_microsecEv>
    39ca:	8e 01       	movw	r16, r28
    39cc:	09 5f       	subi	r16, 0xF9	; 249
    39ce:	1f 4f       	sbci	r17, 0xFF	; 255
    39d0:	fe 01       	movw	r30, r28
    39d2:	31 96       	adiw	r30, 0x01	; 1
    39d4:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    39d6:	2a e0       	ldi	r18, 0x0A	; 10
    39d8:	30 e0       	ldi	r19, 0x00	; 0
    39da:	40 e0       	ldi	r20, 0x00	; 0
    39dc:	50 e0       	ldi	r21, 0x00	; 0
    39de:	0e 94 37 26 	call	0x4c6e	; 0x4c6e <__divmodsi4>
    39e2:	e6 2f       	mov	r30, r22
    39e4:	28 87       	std	Y+8, r18	; 0x08
    39e6:	39 87       	std	Y+9, r19	; 0x09
    39e8:	4a 87       	std	Y+10, r20	; 0x0a
    39ea:	5b 87       	std	Y+11, r21	; 0x0b
    39ec:	68 85       	ldd	r22, Y+8	; 0x08
    39ee:	79 85       	ldd	r23, Y+9	; 0x09
    39f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    39f2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    39f4:	20 e3       	ldi	r18, 0x30	; 48
    39f6:	2e 0f       	add	r18, r30
    39f8:	d8 01       	movw	r26, r16
    39fa:	2e 93       	st	-X, r18
    39fc:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    39fe:	ae 15       	cp	r26, r14
    3a00:	bf 05       	cpc	r27, r15
    3a02:	49 f7       	brne	.-46     	; 0x39d6 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3a04:	1f 82       	std	Y+7, r1	; 0x07
    3a06:	be 01       	movw	r22, r28
    3a08:	6f 5f       	subi	r22, 0xFF	; 255
    3a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3a0c:	c6 01       	movw	r24, r12
    3a0e:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    3a12:	c6 01       	movw	r24, r12
    3a14:	2f 96       	adiw	r28, 0x0f	; 15
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	de bf       	out	0x3e, r29	; 62
    3a1a:	df 91       	pop	r29
    3a1c:	cf 91       	pop	r28
    3a1e:	1f 91       	pop	r17
    3a20:	0f 91       	pop	r16
    3a22:	ff 90       	pop	r15
    3a24:	ef 90       	pop	r14
    3a26:	df 90       	pop	r13
    3a28:	cf 90       	pop	r12
    3a2a:	08 95       	ret

00003a2c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3a2c:	cf 93       	push	r28
    3a2e:	df 93       	push	r29
    3a30:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    3a32:	0f b6       	in	r0, 0x3f	; 63
    3a34:	f8 94       	cli
    3a36:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3a38:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3a3c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3a40:	8c 83       	std	Y+4, r24	; 0x04
    3a42:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3a44:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <xTaskGetTickCount>
    3a48:	68 83       	st	Y, r22
    3a4a:	79 83       	std	Y+1, r23	; 0x01
    3a4c:	8a 83       	std	Y+2, r24	; 0x02
    3a4e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    3a50:	0f 90       	pop	r0
    3a52:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3a54:	ce 01       	movw	r24, r28
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	08 95       	ret

00003a5c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3a5c:	5f 92       	push	r5
    3a5e:	6f 92       	push	r6
    3a60:	7f 92       	push	r7
    3a62:	8f 92       	push	r8
    3a64:	9f 92       	push	r9
    3a66:	af 92       	push	r10
    3a68:	bf 92       	push	r11
    3a6a:	cf 92       	push	r12
    3a6c:	df 92       	push	r13
    3a6e:	ef 92       	push	r14
    3a70:	ff 92       	push	r15
    3a72:	0f 93       	push	r16
    3a74:	1f 93       	push	r17
    3a76:	cf 93       	push	r28
    3a78:	df 93       	push	r29
    3a7a:	5c 01       	movw	r10, r24
    3a7c:	4b 01       	movw	r8, r22
    3a7e:	7a 01       	movw	r14, r20
    3a80:	12 2f       	mov	r17, r18
    3a82:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3a84:	63 e0       	ldi	r22, 0x03	; 3
    3a86:	ca 01       	movw	r24, r20
    3a88:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3a8c:	a8 14       	cp	r10, r8
    3a8e:	b9 04       	cpc	r11, r9
    3a90:	08 f0       	brcs	.+2      	; 0x3a94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    3a92:	7d c0       	rjmp	.+250    	; 0x3b8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3a94:	65 01       	movw	r12, r10
    3a96:	84 e1       	ldi	r24, 0x14	; 20
    3a98:	c8 0e       	add	r12, r24
    3a9a:	d1 1c       	adc	r13, r1
    3a9c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    3a9e:	6a 2c       	mov	r6, r10
    3aa0:	5b 2c       	mov	r5, r11
    3aa2:	b5 01       	movw	r22, r10
    3aa4:	c7 01       	movw	r24, r14
    3aa6:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    3aaa:	6a e0       	ldi	r22, 0x0A	; 10
    3aac:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3ab0:	61 e6       	ldi	r22, 0x61	; 97
    3ab2:	76 e0       	ldi	r23, 0x06	; 6
    3ab4:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    3ab8:	11 23       	and	r17, r17
    3aba:	09 f4       	brne	.+2      	; 0x3abe <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3abc:	6d c0       	rjmp	.+218    	; 0x3b98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3abe:	00 23       	and	r16, r16
    3ac0:	09 f4       	brne	.+2      	; 0x3ac4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3ac2:	6a c0       	rjmp	.+212    	; 0x3b98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    3ac4:	6a e0       	ldi	r22, 0x0A	; 10
    3ac6:	c7 01       	movw	r24, r14
    3ac8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3acc:	6c e5       	ldi	r22, 0x5C	; 92
    3ace:	76 e0       	ldi	r23, 0x06	; 6
    3ad0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    3ad4:	61 c0       	rjmp	.+194    	; 0x3b98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    3ad6:	11 23       	and	r17, r17
    3ad8:	71 f0       	breq	.+28     	; 0x3af6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3ada:	01 11       	cpse	r16, r1
    3adc:	0c c0       	rjmp	.+24     	; 0x3af6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3ade:	88 81       	ld	r24, Y
    3ae0:	87 15       	cp	r24, r7
    3ae2:	49 f0       	breq	.+18     	; 0x3af6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    3ae4:	6a e0       	ldi	r22, 0x0A	; 10
    3ae6:	c7 01       	movw	r24, r14
    3ae8:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3aec:	67 e5       	ldi	r22, 0x57	; 87
    3aee:	76 e0       	ldi	r23, 0x06	; 6
    3af0:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3af4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3af6:	69 91       	ld	r22, Y+
    3af8:	c7 01       	movw	r24, r14
    3afa:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3afe:	dc 01       	movw	r26, r24
    3b00:	ed 91       	ld	r30, X+
    3b02:	fc 91       	ld	r31, X
    3b04:	02 80       	ldd	r0, Z+2	; 0x02
    3b06:	f3 81       	ldd	r31, Z+3	; 0x03
    3b08:	e0 2d       	mov	r30, r0
    3b0a:	60 e2       	ldi	r22, 0x20	; 32
    3b0c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3b0e:	cc 16       	cp	r12, r28
    3b10:	dd 06       	cpc	r13, r29
    3b12:	09 f7       	brne	.-62     	; 0x3ad6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3b14:	11 23       	and	r17, r17
    3b16:	89 f0       	breq	.+34     	; 0x3b3a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3b18:	6a e0       	ldi	r22, 0x0A	; 10
    3b1a:	c7 01       	movw	r24, r14
    3b1c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3b20:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3b22:	61 e5       	ldi	r22, 0x51	; 81
    3b24:	76 e0       	ldi	r23, 0x06	; 6
    3b26:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3b2a:	e8 81       	ld	r30, Y
    3b2c:	f9 81       	ldd	r31, Y+1	; 0x01
    3b2e:	02 80       	ldd	r0, Z+2	; 0x02
    3b30:	f3 81       	ldd	r31, Z+3	; 0x03
    3b32:	e0 2d       	mov	r30, r0
    3b34:	60 e2       	ldi	r22, 0x20	; 32
    3b36:	ce 01       	movw	r24, r28
    3b38:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3b3a:	c6 2d       	mov	r28, r6
    3b3c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3b3e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3b40:	80 ee       	ldi	r24, 0xE0	; 224
    3b42:	86 0f       	add	r24, r22
    3b44:	8f 35       	cpi	r24, 0x5F	; 95
    3b46:	48 f4       	brcc	.+18     	; 0x3b5a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3b48:	d7 01       	movw	r26, r14
    3b4a:	ed 91       	ld	r30, X+
    3b4c:	fc 91       	ld	r31, X
    3b4e:	02 80       	ldd	r0, Z+2	; 0x02
    3b50:	f3 81       	ldd	r31, Z+3	; 0x03
    3b52:	e0 2d       	mov	r30, r0
    3b54:	c7 01       	movw	r24, r14
    3b56:	19 95       	eicall
    3b58:	09 c0       	rjmp	.+18     	; 0x3b6c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3b5a:	d7 01       	movw	r26, r14
    3b5c:	ed 91       	ld	r30, X+
    3b5e:	fc 91       	ld	r31, X
    3b60:	02 80       	ldd	r0, Z+2	; 0x02
    3b62:	f3 81       	ldd	r31, Z+3	; 0x03
    3b64:	e0 2d       	mov	r30, r0
    3b66:	6e e2       	ldi	r22, 0x2E	; 46
    3b68:	c7 01       	movw	r24, r14
    3b6a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3b6c:	cc 16       	cp	r12, r28
    3b6e:	dd 06       	cpc	r13, r29
    3b70:	31 f7       	brne	.-52     	; 0x3b3e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    3b72:	b4 e1       	ldi	r27, 0x14	; 20
    3b74:	ab 0e       	add	r10, r27
    3b76:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3b78:	66 e0       	ldi	r22, 0x06	; 6
    3b7a:	c7 01       	movw	r24, r14
    3b7c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3b80:	84 e1       	ldi	r24, 0x14	; 20
    3b82:	c8 0e       	add	r12, r24
    3b84:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3b86:	a8 14       	cp	r10, r8
    3b88:	b9 04       	cpc	r11, r9
    3b8a:	08 f4       	brcc	.+2      	; 0x3b8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3b8c:	88 cf       	rjmp	.-240    	; 0x3a9e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    3b8e:	62 e0       	ldi	r22, 0x02	; 2
    3b90:	c7 01       	movw	r24, r14
    3b92:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
}
    3b96:	03 c0       	rjmp	.+6      	; 0x3b9e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3b98:	c6 2d       	mov	r28, r6
    3b9a:	d5 2d       	mov	r29, r5
    3b9c:	9c cf       	rjmp	.-200    	; 0x3ad6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    3b9e:	df 91       	pop	r29
    3ba0:	cf 91       	pop	r28
    3ba2:	1f 91       	pop	r17
    3ba4:	0f 91       	pop	r16
    3ba6:	ff 90       	pop	r15
    3ba8:	ef 90       	pop	r14
    3baa:	df 90       	pop	r13
    3bac:	cf 90       	pop	r12
    3bae:	bf 90       	pop	r11
    3bb0:	af 90       	pop	r10
    3bb2:	9f 90       	pop	r9
    3bb4:	8f 90       	pop	r8
    3bb6:	7f 90       	pop	r7
    3bb8:	6f 90       	pop	r6
    3bba:	5f 90       	pop	r5
    3bbc:	08 95       	ret

00003bbe <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3bbe:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    3bc2:	08 95       	ret

00003bc4 <_Znaj>:
    3bc4:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <pvPortMalloc>
    3bc8:	08 95       	ret

00003bca <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3bca:	08 95       	ret

00003bcc <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3bcc:	cf 93       	push	r28
    3bce:	df 93       	push	r29
    3bd0:	fc 01       	movw	r30, r24
    3bd2:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    3bd4:	40 3a       	cpi	r20, 0xA0	; 160
    3bd6:	68 e0       	ldi	r22, 0x08	; 8
    3bd8:	56 07       	cpc	r21, r22
    3bda:	49 f4       	brne	.+18     	; 0x3bee <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3bdc:	80 e4       	ldi	r24, 0x40	; 64
    3bde:	96 e0       	ldi	r25, 0x06	; 6
    3be0:	82 83       	std	Z+2, r24	; 0x02
    3be2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3be4:	82 e0       	ldi	r24, 0x02	; 2
    3be6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3be8:	83 e0       	ldi	r24, 0x03	; 3
    3bea:	85 83       	std	Z+5, r24	; 0x05
    3bec:	32 c0       	rjmp	.+100    	; 0x3c52 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3bee:	40 3b       	cpi	r20, 0xB0	; 176
    3bf0:	78 e0       	ldi	r23, 0x08	; 8
    3bf2:	57 07       	cpc	r21, r23
    3bf4:	49 f4       	brne	.+18     	; 0x3c08 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3bf6:	80 e4       	ldi	r24, 0x40	; 64
    3bf8:	96 e0       	ldi	r25, 0x06	; 6
    3bfa:	82 83       	std	Z+2, r24	; 0x02
    3bfc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3bfe:	86 e0       	ldi	r24, 0x06	; 6
    3c00:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3c02:	87 e0       	ldi	r24, 0x07	; 7
    3c04:	85 83       	std	Z+5, r24	; 0x05
    3c06:	25 c0       	rjmp	.+74     	; 0x3c52 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3c08:	40 3a       	cpi	r20, 0xA0	; 160
    3c0a:	89 e0       	ldi	r24, 0x09	; 9
    3c0c:	58 07       	cpc	r21, r24
    3c0e:	49 f4       	brne	.+18     	; 0x3c22 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3c10:	80 e6       	ldi	r24, 0x60	; 96
    3c12:	96 e0       	ldi	r25, 0x06	; 6
    3c14:	82 83       	std	Z+2, r24	; 0x02
    3c16:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3c18:	82 e0       	ldi	r24, 0x02	; 2
    3c1a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3c1c:	83 e0       	ldi	r24, 0x03	; 3
    3c1e:	85 83       	std	Z+5, r24	; 0x05
    3c20:	18 c0       	rjmp	.+48     	; 0x3c52 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3c22:	40 3b       	cpi	r20, 0xB0	; 176
    3c24:	69 e0       	ldi	r22, 0x09	; 9
    3c26:	56 07       	cpc	r21, r22
    3c28:	49 f4       	brne	.+18     	; 0x3c3c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3c2a:	80 e6       	ldi	r24, 0x60	; 96
    3c2c:	96 e0       	ldi	r25, 0x06	; 6
    3c2e:	82 83       	std	Z+2, r24	; 0x02
    3c30:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3c32:	86 e0       	ldi	r24, 0x06	; 6
    3c34:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3c36:	87 e0       	ldi	r24, 0x07	; 7
    3c38:	85 83       	std	Z+5, r24	; 0x05
    3c3a:	0b c0       	rjmp	.+22     	; 0x3c52 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3c3c:	40 3a       	cpi	r20, 0xA0	; 160
    3c3e:	5a 40       	sbci	r21, 0x0A	; 10
    3c40:	41 f4       	brne	.+16     	; 0x3c52 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3c42:	80 e8       	ldi	r24, 0x80	; 128
    3c44:	96 e0       	ldi	r25, 0x06	; 6
    3c46:	82 83       	std	Z+2, r24	; 0x02
    3c48:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3c4a:	82 e0       	ldi	r24, 0x02	; 2
    3c4c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3c4e:	83 e0       	ldi	r24, 0x03	; 3
    3c50:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3c52:	a6 83       	std	Z+6, r26	; 0x06
    3c54:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3c56:	cd 01       	movw	r24, r26
    3c58:	01 96       	adiw	r24, 0x01	; 1
    3c5a:	80 87       	std	Z+8, r24	; 0x08
    3c5c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3c5e:	03 96       	adiw	r24, 0x03	; 3
    3c60:	82 87       	std	Z+10, r24	; 0x0a
    3c62:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3c64:	25 81       	ldd	r18, Z+5	; 0x05
    3c66:	c2 81       	ldd	r28, Z+2	; 0x02
    3c68:	d3 81       	ldd	r29, Z+3	; 0x03
    3c6a:	4c 81       	ldd	r20, Y+4	; 0x04
    3c6c:	81 e0       	ldi	r24, 0x01	; 1
    3c6e:	90 e0       	ldi	r25, 0x00	; 0
    3c70:	bc 01       	movw	r22, r24
    3c72:	02 c0       	rjmp	.+4      	; 0x3c78 <_ZN7base232C1EjP12USART_struct+0xac>
    3c74:	66 0f       	add	r22, r22
    3c76:	77 1f       	adc	r23, r23
    3c78:	2a 95       	dec	r18
    3c7a:	e2 f7       	brpl	.-8      	; 0x3c74 <_ZN7base232C1EjP12USART_struct+0xa8>
    3c7c:	9b 01       	movw	r18, r22
    3c7e:	24 2b       	or	r18, r20
    3c80:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3c82:	25 81       	ldd	r18, Z+5	; 0x05
    3c84:	c2 81       	ldd	r28, Z+2	; 0x02
    3c86:	d3 81       	ldd	r29, Z+3	; 0x03
    3c88:	48 81       	ld	r20, Y
    3c8a:	bc 01       	movw	r22, r24
    3c8c:	02 c0       	rjmp	.+4      	; 0x3c92 <_ZN7base232C1EjP12USART_struct+0xc6>
    3c8e:	66 0f       	add	r22, r22
    3c90:	77 1f       	adc	r23, r23
    3c92:	2a 95       	dec	r18
    3c94:	e2 f7       	brpl	.-8      	; 0x3c8e <_ZN7base232C1EjP12USART_struct+0xc2>
    3c96:	9b 01       	movw	r18, r22
    3c98:	24 2b       	or	r18, r20
    3c9a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    3c9c:	34 81       	ldd	r19, Z+4	; 0x04
    3c9e:	c2 81       	ldd	r28, Z+2	; 0x02
    3ca0:	d3 81       	ldd	r29, Z+3	; 0x03
    3ca2:	28 81       	ld	r18, Y
    3ca4:	02 c0       	rjmp	.+4      	; 0x3caa <_ZN7base232C1EjP12USART_struct+0xde>
    3ca6:	88 0f       	add	r24, r24
    3ca8:	99 1f       	adc	r25, r25
    3caa:	3a 95       	dec	r19
    3cac:	e2 f7       	brpl	.-8      	; 0x3ca6 <_ZN7base232C1EjP12USART_struct+0xda>
    3cae:	80 95       	com	r24
    3cb0:	90 95       	com	r25
    3cb2:	82 23       	and	r24, r18
    3cb4:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    3cb6:	80 e1       	ldi	r24, 0x10	; 16
    3cb8:	13 96       	adiw	r26, 0x03	; 3
    3cba:	8c 93       	st	X, r24
    3cbc:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3cbe:	83 e0       	ldi	r24, 0x03	; 3
    3cc0:	15 96       	adiw	r26, 0x05	; 5
    3cc2:	8c 93       	st	X, r24
    3cc4:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    3cc6:	80 ef       	ldi	r24, 0xF0	; 240
    3cc8:	17 96       	adiw	r26, 0x07	; 7
    3cca:	8c 93       	st	X, r24
    3ccc:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3cce:	81 e2       	ldi	r24, 0x21	; 33
    3cd0:	16 96       	adiw	r26, 0x06	; 6
    3cd2:	8c 93       	st	X, r24
    3cd4:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    3cd6:	88 e1       	ldi	r24, 0x18	; 24
    3cd8:	14 96       	adiw	r26, 0x04	; 4
    3cda:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3cdc:	80 e8       	ldi	r24, 0x80	; 128
    3cde:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3ce0:	80 e4       	ldi	r24, 0x40	; 64
    3ce2:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3ce4:	80 e2       	ldi	r24, 0x20	; 32
    3ce6:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    3ce8:	06 80       	ldd	r0, Z+6	; 0x06
    3cea:	f7 81       	ldd	r31, Z+7	; 0x07
    3cec:	e0 2d       	mov	r30, r0
    3cee:	80 81       	ld	r24, Z
    3cf0:	80 81       	ld	r24, Z
}
    3cf2:	df 91       	pop	r29
    3cf4:	cf 91       	pop	r28
    3cf6:	08 95       	ret

00003cf8 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3cf8:	81 e0       	ldi	r24, 0x01	; 1
    3cfa:	08 95       	ret

00003cfc <_ZN8emstream7getcharEv>:
    3cfc:	80 e0       	ldi	r24, 0x00	; 0
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	08 95       	ret

00003d02 <_ZN8emstream14check_for_charEv>:
    3d02:	80 e0       	ldi	r24, 0x00	; 0
    3d04:	08 95       	ret

00003d06 <_ZN8emstream12transmit_nowEv>:
    3d06:	08 95       	ret

00003d08 <_ZN8emstream12clear_screenEv>:
    3d08:	08 95       	ret

00003d0a <_ZN8emstreamC1Ev>:
    3d0a:	fc 01       	movw	r30, r24
    3d0c:	87 e1       	ldi	r24, 0x17	; 23
    3d0e:	92 e2       	ldi	r25, 0x22	; 34
    3d10:	80 83       	st	Z, r24
    3d12:	91 83       	std	Z+1, r25	; 0x01
    3d14:	8a e0       	ldi	r24, 0x0A	; 10
    3d16:	82 83       	std	Z+2, r24	; 0x02
    3d18:	13 82       	std	Z+3, r1	; 0x03
    3d1a:	83 e0       	ldi	r24, 0x03	; 3
    3d1c:	85 83       	std	Z+5, r24	; 0x05
    3d1e:	14 82       	std	Z+4, r1	; 0x04
    3d20:	16 82       	std	Z+6, r1	; 0x06
    3d22:	17 82       	std	Z+7, r1	; 0x07
    3d24:	08 95       	ret

00003d26 <_ZN8emstream4putsEPKc>:
    3d26:	0f 93       	push	r16
    3d28:	1f 93       	push	r17
    3d2a:	cf 93       	push	r28
    3d2c:	df 93       	push	r29
    3d2e:	8c 01       	movw	r16, r24
    3d30:	fb 01       	movw	r30, r22
    3d32:	dc 01       	movw	r26, r24
    3d34:	14 96       	adiw	r26, 0x04	; 4
    3d36:	8c 91       	ld	r24, X
    3d38:	81 11       	cpse	r24, r1
    3d3a:	04 c0       	rjmp	.+8      	; 0x3d44 <_ZN8emstream4putsEPKc+0x1e>
    3d3c:	60 81       	ld	r22, Z
    3d3e:	61 11       	cpse	r22, r1
    3d40:	17 c0       	rjmp	.+46     	; 0x3d70 <_ZN8emstream4putsEPKc+0x4a>
    3d42:	23 c0       	rjmp	.+70     	; 0x3d8a <_ZN8emstream4putsEPKc+0x64>
    3d44:	d8 01       	movw	r26, r16
    3d46:	14 96       	adiw	r26, 0x04	; 4
    3d48:	1c 92       	st	X, r1
    3d4a:	eb 01       	movw	r28, r22
    3d4c:	21 96       	adiw	r28, 0x01	; 1
    3d4e:	64 91       	lpm	r22, Z
    3d50:	66 23       	and	r22, r22
    3d52:	d9 f0       	breq	.+54     	; 0x3d8a <_ZN8emstream4putsEPKc+0x64>
    3d54:	d8 01       	movw	r26, r16
    3d56:	ed 91       	ld	r30, X+
    3d58:	fc 91       	ld	r31, X
    3d5a:	02 80       	ldd	r0, Z+2	; 0x02
    3d5c:	f3 81       	ldd	r31, Z+3	; 0x03
    3d5e:	e0 2d       	mov	r30, r0
    3d60:	c8 01       	movw	r24, r16
    3d62:	19 95       	eicall
    3d64:	fe 01       	movw	r30, r28
    3d66:	64 91       	lpm	r22, Z
    3d68:	21 96       	adiw	r28, 0x01	; 1
    3d6a:	61 11       	cpse	r22, r1
    3d6c:	f3 cf       	rjmp	.-26     	; 0x3d54 <_ZN8emstream4putsEPKc+0x2e>
    3d6e:	0d c0       	rjmp	.+26     	; 0x3d8a <_ZN8emstream4putsEPKc+0x64>
    3d70:	ef 01       	movw	r28, r30
    3d72:	21 96       	adiw	r28, 0x01	; 1
    3d74:	d8 01       	movw	r26, r16
    3d76:	ed 91       	ld	r30, X+
    3d78:	fc 91       	ld	r31, X
    3d7a:	02 80       	ldd	r0, Z+2	; 0x02
    3d7c:	f3 81       	ldd	r31, Z+3	; 0x03
    3d7e:	e0 2d       	mov	r30, r0
    3d80:	c8 01       	movw	r24, r16
    3d82:	19 95       	eicall
    3d84:	69 91       	ld	r22, Y+
    3d86:	61 11       	cpse	r22, r1
    3d88:	f5 cf       	rjmp	.-22     	; 0x3d74 <_ZN8emstream4putsEPKc+0x4e>
    3d8a:	df 91       	pop	r29
    3d8c:	cf 91       	pop	r28
    3d8e:	1f 91       	pop	r17
    3d90:	0f 91       	pop	r16
    3d92:	08 95       	ret

00003d94 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3d94:	cf 93       	push	r28
    3d96:	df 93       	push	r29
    3d98:	ec 01       	movw	r28, r24
	switch (new_manip)
    3d9a:	86 2f       	mov	r24, r22
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	8b 30       	cpi	r24, 0x0B	; 11
    3da0:	91 05       	cpc	r25, r1
    3da2:	d8 f5       	brcc	.+118    	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
    3da4:	fc 01       	movw	r30, r24
    3da6:	88 27       	eor	r24, r24
    3da8:	e2 50       	subi	r30, 0x02	; 2
    3daa:	ff 4f       	sbci	r31, 0xFF	; 255
    3dac:	8f 4f       	sbci	r24, 0xFF	; 255
    3dae:	0c 94 56 26 	jmp	0x4cac	; 0x4cac <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    3db2:	82 e0       	ldi	r24, 0x02	; 2
    3db4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3db6:	31 c0       	rjmp	.+98     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    3db8:	88 e0       	ldi	r24, 0x08	; 8
    3dba:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3dbc:	2e c0       	rjmp	.+92     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3dbe:	8a e0       	ldi	r24, 0x0A	; 10
    3dc0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3dc2:	2b c0       	rjmp	.+86     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    3dc4:	80 e1       	ldi	r24, 0x10	; 16
    3dc6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3dc8:	28 c0       	rjmp	.+80     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3dca:	81 e0       	ldi	r24, 0x01	; 1
    3dcc:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3dce:	25 c0       	rjmp	.+74     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3dd0:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3dd2:	23 c0       	rjmp	.+70     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    3dd4:	e8 81       	ld	r30, Y
    3dd6:	f9 81       	ldd	r31, Y+1	; 0x01
    3dd8:	02 80       	ldd	r0, Z+2	; 0x02
    3dda:	f3 81       	ldd	r31, Z+3	; 0x03
    3ddc:	e0 2d       	mov	r30, r0
    3dde:	6d e0       	ldi	r22, 0x0D	; 13
    3de0:	ce 01       	movw	r24, r28
    3de2:	19 95       	eicall
    3de4:	e8 81       	ld	r30, Y
    3de6:	f9 81       	ldd	r31, Y+1	; 0x01
    3de8:	02 80       	ldd	r0, Z+2	; 0x02
    3dea:	f3 81       	ldd	r31, Z+3	; 0x03
    3dec:	e0 2d       	mov	r30, r0
    3dee:	6a e0       	ldi	r22, 0x0A	; 10
    3df0:	ce 01       	movw	r24, r28
    3df2:	19 95       	eicall
			break;
    3df4:	12 c0       	rjmp	.+36     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3df6:	e8 81       	ld	r30, Y
    3df8:	f9 81       	ldd	r31, Y+1	; 0x01
    3dfa:	02 84       	ldd	r0, Z+10	; 0x0a
    3dfc:	f3 85       	ldd	r31, Z+11	; 0x0b
    3dfe:	e0 2d       	mov	r30, r0
    3e00:	ce 01       	movw	r24, r28
    3e02:	19 95       	eicall
			break;
    3e04:	0a c0       	rjmp	.+20     	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3e06:	e8 81       	ld	r30, Y
    3e08:	f9 81       	ldd	r31, Y+1	; 0x01
    3e0a:	00 84       	ldd	r0, Z+8	; 0x08
    3e0c:	f1 85       	ldd	r31, Z+9	; 0x09
    3e0e:	e0 2d       	mov	r30, r0
    3e10:	ce 01       	movw	r24, r28
    3e12:	19 95       	eicall
			break;
    3e14:	02 c0       	rjmp	.+4      	; 0x3e1a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3e16:	81 e0       	ldi	r24, 0x01	; 1
    3e18:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3e1a:	ce 01       	movw	r24, r28
    3e1c:	df 91       	pop	r29
    3e1e:	cf 91       	pop	r28
    3e20:	08 95       	ret

00003e22 <_ZN8emstreamlsEPv>:
 *          reference is used to string printable items together with "<<" operators
 *  @param ptr The pointer to be sent out
 */

emstream& emstream::operator<< (void* ptr)
{
    3e22:	0f 93       	push	r16
    3e24:	1f 93       	push	r17
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	ec 01       	movw	r28, r24
    3e2c:	8b 01       	movw	r16, r22
	putchar ('[');
    3e2e:	e8 81       	ld	r30, Y
    3e30:	f9 81       	ldd	r31, Y+1	; 0x01
    3e32:	02 80       	ldd	r0, Z+2	; 0x02
    3e34:	f3 81       	ldd	r31, Z+3	; 0x03
    3e36:	e0 2d       	mov	r30, r0
    3e38:	6b e5       	ldi	r22, 0x5B	; 91
    3e3a:	19 95       	eicall
	*this << hex << (size_t)ptr << dec;
    3e3c:	63 e0       	ldi	r22, 0x03	; 3
    3e3e:	ce 01       	movw	r24, r28
    3e40:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    3e44:	b8 01       	movw	r22, r16
    3e46:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <_ZN8emstreamlsEj>
    3e4a:	62 e0       	ldi	r22, 0x02	; 2
    3e4c:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	putchar (']');
    3e50:	e8 81       	ld	r30, Y
    3e52:	f9 81       	ldd	r31, Y+1	; 0x01
    3e54:	02 80       	ldd	r0, Z+2	; 0x02
    3e56:	f3 81       	ldd	r31, Z+3	; 0x03
    3e58:	e0 2d       	mov	r30, r0
    3e5a:	6d e5       	ldi	r22, 0x5D	; 93
    3e5c:	ce 01       	movw	r24, r28
    3e5e:	19 95       	eicall

	return (*this);
}
    3e60:	ce 01       	movw	r24, r28
    3e62:	df 91       	pop	r29
    3e64:	cf 91       	pop	r28
    3e66:	1f 91       	pop	r17
    3e68:	0f 91       	pop	r16
    3e6a:	08 95       	ret

00003e6c <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3e6c:	ff 92       	push	r15
    3e6e:	0f 93       	push	r16
    3e70:	1f 93       	push	r17
    3e72:	cf 93       	push	r28
    3e74:	df 93       	push	r29
    3e76:	cd b7       	in	r28, 0x3d	; 61
    3e78:	de b7       	in	r29, 0x3e	; 62
    3e7a:	61 97       	sbiw	r28, 0x11	; 17
    3e7c:	cd bf       	out	0x3d, r28	; 61
    3e7e:	de bf       	out	0x3e, r29	; 62
    3e80:	8c 01       	movw	r16, r24
    3e82:	f6 2e       	mov	r15, r22
    3e84:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3e86:	f8 01       	movw	r30, r16
    3e88:	42 81       	ldd	r20, Z+2	; 0x02
    3e8a:	40 31       	cpi	r20, 0x10	; 16
    3e8c:	21 f0       	breq	.+8      	; 0x3e96 <_ZN8emstreamlsEj+0x2a>
    3e8e:	48 30       	cpi	r20, 0x08	; 8
    3e90:	11 f0       	breq	.+4      	; 0x3e96 <_ZN8emstreamlsEj+0x2a>
    3e92:	42 30       	cpi	r20, 0x02	; 2
    3e94:	41 f4       	brne	.+16     	; 0x3ea6 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3e96:	69 2f       	mov	r22, r25
    3e98:	c8 01       	movw	r24, r16
    3e9a:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3e9e:	6f 2d       	mov	r22, r15
    3ea0:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3ea4:	0d c0       	rjmp	.+26     	; 0x3ec0 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3ea6:	50 e0       	ldi	r21, 0x00	; 0
    3ea8:	be 01       	movw	r22, r28
    3eaa:	6f 5f       	subi	r22, 0xFF	; 255
    3eac:	7f 4f       	sbci	r23, 0xFF	; 255
    3eae:	8f 2d       	mov	r24, r15
    3eb0:	0e 94 c5 26 	call	0x4d8a	; 0x4d8a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3eb4:	be 01       	movw	r22, r28
    3eb6:	6f 5f       	subi	r22, 0xFF	; 255
    3eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    3eba:	c8 01       	movw	r24, r16
    3ebc:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3ec0:	c8 01       	movw	r24, r16
    3ec2:	61 96       	adiw	r28, 0x11	; 17
    3ec4:	cd bf       	out	0x3d, r28	; 61
    3ec6:	de bf       	out	0x3e, r29	; 62
    3ec8:	df 91       	pop	r29
    3eca:	cf 91       	pop	r28
    3ecc:	1f 91       	pop	r17
    3ece:	0f 91       	pop	r16
    3ed0:	ff 90       	pop	r15
    3ed2:	08 95       	ret

00003ed4 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3ed4:	df 92       	push	r13
    3ed6:	ef 92       	push	r14
    3ed8:	ff 92       	push	r15
    3eda:	0f 93       	push	r16
    3edc:	1f 93       	push	r17
    3ede:	cf 93       	push	r28
    3ee0:	df 93       	push	r29
    3ee2:	cd b7       	in	r28, 0x3d	; 61
    3ee4:	de b7       	in	r29, 0x3e	; 62
    3ee6:	a1 97       	sbiw	r28, 0x21	; 33
    3ee8:	cd bf       	out	0x3d, r28	; 61
    3eea:	de bf       	out	0x3e, r29	; 62
    3eec:	8c 01       	movw	r16, r24
    3eee:	d4 2e       	mov	r13, r20
    3ef0:	e5 2e       	mov	r14, r21
    3ef2:	f6 2e       	mov	r15, r22
    3ef4:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3ef6:	f8 01       	movw	r30, r16
    3ef8:	22 81       	ldd	r18, Z+2	; 0x02
    3efa:	20 31       	cpi	r18, 0x10	; 16
    3efc:	21 f0       	breq	.+8      	; 0x3f06 <_ZN8emstreamlsEm+0x32>
    3efe:	28 30       	cpi	r18, 0x08	; 8
    3f00:	11 f0       	breq	.+4      	; 0x3f06 <_ZN8emstreamlsEm+0x32>
    3f02:	22 30       	cpi	r18, 0x02	; 2
    3f04:	71 f4       	brne	.+28     	; 0x3f22 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3f06:	69 2f       	mov	r22, r25
    3f08:	c8 01       	movw	r24, r16
    3f0a:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3f0e:	6f 2d       	mov	r22, r15
    3f10:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3f14:	6e 2d       	mov	r22, r14
    3f16:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3f1a:	6d 2d       	mov	r22, r13
    3f1c:	0e 94 ac 1f 	call	0x3f58	; 0x3f58 <_ZN8emstreamlsEh>
    3f20:	0f c0       	rjmp	.+30     	; 0x3f40 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    3f22:	30 e0       	ldi	r19, 0x00	; 0
    3f24:	ae 01       	movw	r20, r28
    3f26:	4f 5f       	subi	r20, 0xFF	; 255
    3f28:	5f 4f       	sbci	r21, 0xFF	; 255
    3f2a:	6d 2d       	mov	r22, r13
    3f2c:	7e 2d       	mov	r23, r14
    3f2e:	8f 2d       	mov	r24, r15
    3f30:	0e 94 98 26 	call	0x4d30	; 0x4d30 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3f34:	be 01       	movw	r22, r28
    3f36:	6f 5f       	subi	r22, 0xFF	; 255
    3f38:	7f 4f       	sbci	r23, 0xFF	; 255
    3f3a:	c8 01       	movw	r24, r16
    3f3c:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3f40:	c8 01       	movw	r24, r16
    3f42:	a1 96       	adiw	r28, 0x21	; 33
    3f44:	cd bf       	out	0x3d, r28	; 61
    3f46:	de bf       	out	0x3e, r29	; 62
    3f48:	df 91       	pop	r29
    3f4a:	cf 91       	pop	r28
    3f4c:	1f 91       	pop	r17
    3f4e:	0f 91       	pop	r16
    3f50:	ff 90       	pop	r15
    3f52:	ef 90       	pop	r14
    3f54:	df 90       	pop	r13
    3f56:	08 95       	ret

00003f58 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3f58:	cf 92       	push	r12
    3f5a:	df 92       	push	r13
    3f5c:	ef 92       	push	r14
    3f5e:	ff 92       	push	r15
    3f60:	0f 93       	push	r16
    3f62:	1f 93       	push	r17
    3f64:	cf 93       	push	r28
    3f66:	df 93       	push	r29
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	29 97       	sbiw	r28, 0x09	; 9
    3f6e:	cd bf       	out	0x3d, r28	; 61
    3f70:	de bf       	out	0x3e, r29	; 62
    3f72:	8c 01       	movw	r16, r24
    3f74:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3f76:	dc 01       	movw	r26, r24
    3f78:	13 96       	adiw	r26, 0x03	; 3
    3f7a:	8c 91       	ld	r24, X
    3f7c:	13 97       	sbiw	r26, 0x03	; 3
    3f7e:	88 23       	and	r24, r24
    3f80:	41 f0       	breq	.+16     	; 0x3f92 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3f82:	ed 91       	ld	r30, X+
    3f84:	fc 91       	ld	r31, X
    3f86:	02 80       	ldd	r0, Z+2	; 0x02
    3f88:	f3 81       	ldd	r31, Z+3	; 0x03
    3f8a:	e0 2d       	mov	r30, r0
    3f8c:	c8 01       	movw	r24, r16
    3f8e:	19 95       	eicall
    3f90:	56 c0       	rjmp	.+172    	; 0x403e <__stack+0x3f>
	}
	else if (base == 2)
    3f92:	f8 01       	movw	r30, r16
    3f94:	42 81       	ldd	r20, Z+2	; 0x02
    3f96:	42 30       	cpi	r20, 0x02	; 2
    3f98:	19 f5       	brne	.+70     	; 0x3fe0 <_ZN8emstreamlsEh+0x88>
    3f9a:	68 94       	set
    3f9c:	cc 24       	eor	r12, r12
    3f9e:	c3 f8       	bld	r12, 3
    3fa0:	d1 2c       	mov	r13, r1
    3fa2:	68 94       	set
    3fa4:	ff 24       	eor	r15, r15
    3fa6:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3fa8:	8e 2d       	mov	r24, r14
    3faa:	8f 21       	and	r24, r15
    3fac:	51 f0       	breq	.+20     	; 0x3fc2 <_ZN8emstreamlsEh+0x6a>
    3fae:	d8 01       	movw	r26, r16
    3fb0:	ed 91       	ld	r30, X+
    3fb2:	fc 91       	ld	r31, X
    3fb4:	02 80       	ldd	r0, Z+2	; 0x02
    3fb6:	f3 81       	ldd	r31, Z+3	; 0x03
    3fb8:	e0 2d       	mov	r30, r0
    3fba:	61 e3       	ldi	r22, 0x31	; 49
    3fbc:	c8 01       	movw	r24, r16
    3fbe:	19 95       	eicall
    3fc0:	09 c0       	rjmp	.+18     	; 0x3fd4 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3fc2:	d8 01       	movw	r26, r16
    3fc4:	ed 91       	ld	r30, X+
    3fc6:	fc 91       	ld	r31, X
    3fc8:	02 80       	ldd	r0, Z+2	; 0x02
    3fca:	f3 81       	ldd	r31, Z+3	; 0x03
    3fcc:	e0 2d       	mov	r30, r0
    3fce:	60 e3       	ldi	r22, 0x30	; 48
    3fd0:	c8 01       	movw	r24, r16
    3fd2:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3fd4:	f6 94       	lsr	r15
    3fd6:	b1 e0       	ldi	r27, 0x01	; 1
    3fd8:	cb 1a       	sub	r12, r27
    3fda:	d1 08       	sbc	r13, r1
    3fdc:	29 f7       	brne	.-54     	; 0x3fa8 <_ZN8emstreamlsEh+0x50>
    3fde:	2f c0       	rjmp	.+94     	; 0x403e <__stack+0x3f>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3fe0:	40 31       	cpi	r20, 0x10	; 16
    3fe2:	f9 f4       	brne	.+62     	; 0x4022 <__stack+0x23>
	{
		temp_char = (num >> 4) & 0x0F;
    3fe4:	62 95       	swap	r22
    3fe6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3fe8:	01 90       	ld	r0, Z+
    3fea:	f0 81       	ld	r31, Z
    3fec:	e0 2d       	mov	r30, r0
    3fee:	02 80       	ldd	r0, Z+2	; 0x02
    3ff0:	f3 81       	ldd	r31, Z+3	; 0x03
    3ff2:	e0 2d       	mov	r30, r0
    3ff4:	6a 30       	cpi	r22, 0x0A	; 10
    3ff6:	10 f0       	brcs	.+4      	; 0x3ffc <_ZN8emstreamlsEh+0xa4>
    3ff8:	69 5c       	subi	r22, 0xC9	; 201
    3ffa:	01 c0       	rjmp	.+2      	; 0x3ffe <_ZN8emstreamlsEh+0xa6>
    3ffc:	60 5d       	subi	r22, 0xD0	; 208
    3ffe:	c8 01       	movw	r24, r16
    4000:	19 95       	eicall
		temp_char = num & 0x0F;
    4002:	6e 2d       	mov	r22, r14
    4004:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    4006:	d8 01       	movw	r26, r16
    4008:	ed 91       	ld	r30, X+
    400a:	fc 91       	ld	r31, X
    400c:	02 80       	ldd	r0, Z+2	; 0x02
    400e:	f3 81       	ldd	r31, Z+3	; 0x03
    4010:	e0 2d       	mov	r30, r0
    4012:	6a 30       	cpi	r22, 0x0A	; 10
    4014:	10 f0       	brcs	.+4      	; 0x401a <__stack+0x1b>
    4016:	69 5c       	subi	r22, 0xC9	; 201
    4018:	01 c0       	rjmp	.+2      	; 0x401c <__stack+0x1d>
    401a:	60 5d       	subi	r22, 0xD0	; 208
    401c:	c8 01       	movw	r24, r16
    401e:	19 95       	eicall
    4020:	0e c0       	rjmp	.+28     	; 0x403e <__stack+0x3f>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    4022:	50 e0       	ldi	r21, 0x00	; 0
    4024:	be 01       	movw	r22, r28
    4026:	6f 5f       	subi	r22, 0xFF	; 255
    4028:	7f 4f       	sbci	r23, 0xFF	; 255
    402a:	8e 2d       	mov	r24, r14
    402c:	90 e0       	ldi	r25, 0x00	; 0
    402e:	0e 94 c5 26 	call	0x4d8a	; 0x4d8a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    4032:	be 01       	movw	r22, r28
    4034:	6f 5f       	subi	r22, 0xFF	; 255
    4036:	7f 4f       	sbci	r23, 0xFF	; 255
    4038:	c8 01       	movw	r24, r16
    403a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    403e:	c8 01       	movw	r24, r16
    4040:	29 96       	adiw	r28, 0x09	; 9
    4042:	cd bf       	out	0x3d, r28	; 61
    4044:	de bf       	out	0x3e, r29	; 62
    4046:	df 91       	pop	r29
    4048:	cf 91       	pop	r28
    404a:	1f 91       	pop	r17
    404c:	0f 91       	pop	r16
    404e:	ff 90       	pop	r15
    4050:	ef 90       	pop	r14
    4052:	df 90       	pop	r13
    4054:	cf 90       	pop	r12
    4056:	08 95       	ret

00004058 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    4058:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    405a:	50 96       	adiw	r26, 0x10	; 16
    405c:	ed 91       	ld	r30, X+
    405e:	fc 91       	ld	r31, X
    4060:	51 97       	sbiw	r26, 0x11	; 17
    4062:	80 81       	ld	r24, Z
    4064:	54 96       	adiw	r26, 0x14	; 20
    4066:	4c 91       	ld	r20, X
    4068:	54 97       	sbiw	r26, 0x14	; 20
    406a:	84 23       	and	r24, r20
    406c:	29 f0       	breq	.+10     	; 0x4078 <_ZN5rs2327putcharEc+0x20>
    406e:	09 c0       	rjmp	.+18     	; 0x4082 <_ZN5rs2327putcharEc+0x2a>
    4070:	21 50       	subi	r18, 0x01	; 1
    4072:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    4074:	19 f4       	brne	.+6      	; 0x407c <_ZN5rs2327putcharEc+0x24>
    4076:	12 c0       	rjmp	.+36     	; 0x409c <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    4078:	21 e2       	ldi	r18, 0x21	; 33
    407a:	3e e4       	ldi	r19, 0x4E	; 78
    407c:	90 81       	ld	r25, Z
    407e:	94 23       	and	r25, r20
    4080:	b9 f3       	breq	.-18     	; 0x4070 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    4082:	90 81       	ld	r25, Z
    4084:	56 96       	adiw	r26, 0x16	; 22
    4086:	8c 91       	ld	r24, X
    4088:	56 97       	sbiw	r26, 0x16	; 22
    408a:	89 2b       	or	r24, r25
    408c:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    408e:	1e 96       	adiw	r26, 0x0e	; 14
    4090:	ed 91       	ld	r30, X+
    4092:	fc 91       	ld	r31, X
    4094:	1f 97       	sbiw	r26, 0x0f	; 15
    4096:	60 83       	st	Z, r22
	return (true);
    4098:	81 e0       	ldi	r24, 0x01	; 1
    409a:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    409c:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    409e:	08 95       	ret

000040a0 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    40a0:	cf 93       	push	r28
    40a2:	df 93       	push	r29
    40a4:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    40a6:	c1 8d       	ldd	r28, Z+25	; 0x19
    40a8:	d2 8d       	ldd	r29, Z+26	; 0x1a
    40aa:	28 81       	ld	r18, Y
    40ac:	39 81       	ldd	r19, Y+1	; 0x01
    40ae:	a3 8d       	ldd	r26, Z+27	; 0x1b
    40b0:	b4 8d       	ldd	r27, Z+28	; 0x1c
    40b2:	4d 91       	ld	r20, X+
    40b4:	5c 91       	ld	r21, X
    40b6:	24 17       	cp	r18, r20
    40b8:	35 07       	cpc	r19, r21
    40ba:	e9 f3       	breq	.-6      	; 0x40b6 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    40bc:	a7 89       	ldd	r26, Z+23	; 0x17
    40be:	b0 8d       	ldd	r27, Z+24	; 0x18
    40c0:	0d 90       	ld	r0, X+
    40c2:	bc 91       	ld	r27, X
    40c4:	a0 2d       	mov	r26, r0
    40c6:	a2 0f       	add	r26, r18
    40c8:	b3 1f       	adc	r27, r19
    40ca:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    40cc:	2f 5f       	subi	r18, 0xFF	; 255
    40ce:	3f 4f       	sbci	r19, 0xFF	; 255
    40d0:	28 83       	st	Y, r18
    40d2:	39 83       	std	Y+1, r19	; 0x01
    40d4:	24 36       	cpi	r18, 0x64	; 100
    40d6:	31 05       	cpc	r19, r1
    40d8:	28 f0       	brcs	.+10     	; 0x40e4 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    40da:	01 8c       	ldd	r0, Z+25	; 0x19
    40dc:	f2 8d       	ldd	r31, Z+26	; 0x1a
    40de:	e0 2d       	mov	r30, r0
    40e0:	10 82       	st	Z, r1
    40e2:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    40e4:	90 e0       	ldi	r25, 0x00	; 0
    40e6:	df 91       	pop	r29
    40e8:	cf 91       	pop	r28
    40ea:	08 95       	ret

000040ec <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    40ec:	cf 93       	push	r28
    40ee:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    40f0:	ec 01       	movw	r28, r24
    40f2:	a9 8d       	ldd	r26, Y+25	; 0x19
    40f4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    40f6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    40f8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    40fa:	81 e0       	ldi	r24, 0x01	; 1
    40fc:	4d 91       	ld	r20, X+
    40fe:	5c 91       	ld	r21, X
    4100:	20 81       	ld	r18, Z
    4102:	31 81       	ldd	r19, Z+1	; 0x01
    4104:	42 17       	cp	r20, r18
    4106:	53 07       	cpc	r21, r19
    4108:	09 f4       	brne	.+2      	; 0x410c <_ZN5rs23214check_for_charEv+0x20>
    410a:	80 e0       	ldi	r24, 0x00	; 0
}
    410c:	df 91       	pop	r29
    410e:	cf 91       	pop	r28
    4110:	08 95       	ret

00004112 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    4112:	dc 01       	movw	r26, r24
    4114:	ed 91       	ld	r30, X+
    4116:	fc 91       	ld	r31, X
    4118:	02 80       	ldd	r0, Z+2	; 0x02
    411a:	f3 81       	ldd	r31, Z+3	; 0x03
    411c:	e0 2d       	mov	r30, r0
    411e:	6c e0       	ldi	r22, 0x0C	; 12
    4120:	19 95       	eicall
    4122:	08 95       	ret

00004124 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    4124:	ef 92       	push	r14
    4126:	ff 92       	push	r15
    4128:	0f 93       	push	r16
    412a:	1f 93       	push	r17
    412c:	cf 93       	push	r28
    412e:	df 93       	push	r29
    4130:	ec 01       	movw	r28, r24
    4132:	7b 01       	movw	r14, r22
    4134:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    4136:	0e 94 85 1e 	call	0x3d0a	; 0x3d0a <_ZN8emstreamC1Ev>
    413a:	a8 01       	movw	r20, r16
    413c:	b7 01       	movw	r22, r14
    413e:	ce 01       	movw	r24, r28
    4140:	08 96       	adiw	r24, 0x08	; 8
    4142:	0e 94 e6 1d 	call	0x3bcc	; 0x3bcc <_ZN7base232C1EjP12USART_struct>
    4146:	87 e2       	ldi	r24, 0x27	; 39
    4148:	92 e2       	ldi	r25, 0x22	; 34
    414a:	88 83       	st	Y, r24
    414c:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    414e:	00 3a       	cpi	r16, 0xA0	; 160
    4150:	88 e0       	ldi	r24, 0x08	; 8
    4152:	18 07       	cpc	r17, r24
    4154:	69 f4       	brne	.+26     	; 0x4170 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    4156:	80 e3       	ldi	r24, 0x30	; 48
    4158:	93 e3       	ldi	r25, 0x33	; 51
    415a:	8f 8b       	std	Y+23, r24	; 0x17
    415c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    415e:	86 e2       	ldi	r24, 0x26	; 38
    4160:	93 e3       	ldi	r25, 0x33	; 51
    4162:	89 8f       	std	Y+25, r24	; 0x19
    4164:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    4166:	8c e1       	ldi	r24, 0x1C	; 28
    4168:	93 e3       	ldi	r25, 0x33	; 51
    416a:	8b 8f       	std	Y+27, r24	; 0x1b
    416c:	9c 8f       	std	Y+28, r25	; 0x1c
    416e:	42 c0       	rjmp	.+132    	; 0x41f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    4170:	00 3b       	cpi	r16, 0xB0	; 176
    4172:	e8 e0       	ldi	r30, 0x08	; 8
    4174:	1e 07       	cpc	r17, r30
    4176:	69 f4       	brne	.+26     	; 0x4192 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    4178:	8e e2       	ldi	r24, 0x2E	; 46
    417a:	93 e3       	ldi	r25, 0x33	; 51
    417c:	8f 8b       	std	Y+23, r24	; 0x17
    417e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    4180:	84 e2       	ldi	r24, 0x24	; 36
    4182:	93 e3       	ldi	r25, 0x33	; 51
    4184:	89 8f       	std	Y+25, r24	; 0x19
    4186:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    4188:	8a e1       	ldi	r24, 0x1A	; 26
    418a:	93 e3       	ldi	r25, 0x33	; 51
    418c:	8b 8f       	std	Y+27, r24	; 0x1b
    418e:	9c 8f       	std	Y+28, r25	; 0x1c
    4190:	31 c0       	rjmp	.+98     	; 0x41f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    4192:	00 3a       	cpi	r16, 0xA0	; 160
    4194:	f9 e0       	ldi	r31, 0x09	; 9
    4196:	1f 07       	cpc	r17, r31
    4198:	69 f4       	brne	.+26     	; 0x41b4 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    419a:	8c e2       	ldi	r24, 0x2C	; 44
    419c:	93 e3       	ldi	r25, 0x33	; 51
    419e:	8f 8b       	std	Y+23, r24	; 0x17
    41a0:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    41a2:	82 e2       	ldi	r24, 0x22	; 34
    41a4:	93 e3       	ldi	r25, 0x33	; 51
    41a6:	89 8f       	std	Y+25, r24	; 0x19
    41a8:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    41aa:	88 e1       	ldi	r24, 0x18	; 24
    41ac:	93 e3       	ldi	r25, 0x33	; 51
    41ae:	8b 8f       	std	Y+27, r24	; 0x1b
    41b0:	9c 8f       	std	Y+28, r25	; 0x1c
    41b2:	20 c0       	rjmp	.+64     	; 0x41f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    41b4:	00 3b       	cpi	r16, 0xB0	; 176
    41b6:	89 e0       	ldi	r24, 0x09	; 9
    41b8:	18 07       	cpc	r17, r24
    41ba:	69 f4       	brne	.+26     	; 0x41d6 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    41bc:	8a e2       	ldi	r24, 0x2A	; 42
    41be:	93 e3       	ldi	r25, 0x33	; 51
    41c0:	8f 8b       	std	Y+23, r24	; 0x17
    41c2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    41c4:	80 e2       	ldi	r24, 0x20	; 32
    41c6:	93 e3       	ldi	r25, 0x33	; 51
    41c8:	89 8f       	std	Y+25, r24	; 0x19
    41ca:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    41cc:	86 e1       	ldi	r24, 0x16	; 22
    41ce:	93 e3       	ldi	r25, 0x33	; 51
    41d0:	8b 8f       	std	Y+27, r24	; 0x1b
    41d2:	9c 8f       	std	Y+28, r25	; 0x1c
    41d4:	0f c0       	rjmp	.+30     	; 0x41f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    41d6:	00 3a       	cpi	r16, 0xA0	; 160
    41d8:	1a 40       	sbci	r17, 0x0A	; 10
    41da:	61 f4       	brne	.+24     	; 0x41f4 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    41dc:	88 e2       	ldi	r24, 0x28	; 40
    41de:	93 e3       	ldi	r25, 0x33	; 51
    41e0:	8f 8b       	std	Y+23, r24	; 0x17
    41e2:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    41e4:	8e e1       	ldi	r24, 0x1E	; 30
    41e6:	93 e3       	ldi	r25, 0x33	; 51
    41e8:	89 8f       	std	Y+25, r24	; 0x19
    41ea:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    41ec:	84 e1       	ldi	r24, 0x14	; 20
    41ee:	93 e3       	ldi	r25, 0x33	; 51
    41f0:	8b 8f       	std	Y+27, r24	; 0x1b
    41f2:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    41f4:	0f 89       	ldd	r16, Y+23	; 0x17
    41f6:	18 8d       	ldd	r17, Y+24	; 0x18
    41f8:	84 e6       	ldi	r24, 0x64	; 100
    41fa:	90 e0       	ldi	r25, 0x00	; 0
    41fc:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <_Znaj>
    4200:	f8 01       	movw	r30, r16
    4202:	80 83       	st	Z, r24
    4204:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    4206:	e9 8d       	ldd	r30, Y+25	; 0x19
    4208:	fa 8d       	ldd	r31, Y+26	; 0x1a
    420a:	10 82       	st	Z, r1
    420c:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    420e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4210:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4212:	10 82       	st	Z, r1
    4214:	11 82       	std	Z+1, r1	; 0x01
}
    4216:	df 91       	pop	r29
    4218:	cf 91       	pop	r28
    421a:	1f 91       	pop	r17
    421c:	0f 91       	pop	r16
    421e:	ff 90       	pop	r15
    4220:	ef 90       	pop	r14
    4222:	08 95       	ret

00004224 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    4224:	1f 92       	push	r1
    4226:	0f 92       	push	r0
    4228:	0f b6       	in	r0, 0x3f	; 63
    422a:	0f 92       	push	r0
    422c:	11 24       	eor	r1, r1
    422e:	08 b6       	in	r0, 0x38	; 56
    4230:	0f 92       	push	r0
    4232:	18 be       	out	0x38, r1	; 56
    4234:	0b b6       	in	r0, 0x3b	; 59
    4236:	0f 92       	push	r0
    4238:	1b be       	out	0x3b, r1	; 59
    423a:	2f 93       	push	r18
    423c:	3f 93       	push	r19
    423e:	8f 93       	push	r24
    4240:	9f 93       	push	r25
    4242:	ef 93       	push	r30
    4244:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    4246:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    424a:	e0 91 30 33 	lds	r30, 0x3330	; 0x803330 <rcvC0_buffer>
    424e:	f0 91 31 33 	lds	r31, 0x3331	; 0x803331 <rcvC0_buffer+0x1>
    4252:	80 91 1c 33 	lds	r24, 0x331C	; 0x80331c <rcvC0_write_index>
    4256:	90 91 1d 33 	lds	r25, 0x331D	; 0x80331d <rcvC0_write_index+0x1>
    425a:	e8 0f       	add	r30, r24
    425c:	f9 1f       	adc	r31, r25
    425e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    4260:	80 91 1c 33 	lds	r24, 0x331C	; 0x80331c <rcvC0_write_index>
    4264:	90 91 1d 33 	lds	r25, 0x331D	; 0x80331d <rcvC0_write_index+0x1>
    4268:	01 96       	adiw	r24, 0x01	; 1
    426a:	84 36       	cpi	r24, 0x64	; 100
    426c:	91 05       	cpc	r25, r1
    426e:	60 f4       	brcc	.+24     	; 0x4288 <__vector_25+0x64>
    4270:	80 93 1c 33 	sts	0x331C, r24	; 0x80331c <rcvC0_write_index>
    4274:	90 93 1d 33 	sts	0x331D, r25	; 0x80331d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4278:	20 91 26 33 	lds	r18, 0x3326	; 0x803326 <rcvC0_read_index>
    427c:	30 91 27 33 	lds	r19, 0x3327	; 0x803327 <rcvC0_read_index+0x1>
    4280:	82 17       	cp	r24, r18
    4282:	93 07       	cpc	r25, r19
    4284:	f1 f4       	brne	.+60     	; 0x42c2 <__vector_25+0x9e>
    4286:	0c c0       	rjmp	.+24     	; 0x42a0 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    4288:	10 92 1c 33 	sts	0x331C, r1	; 0x80331c <rcvC0_write_index>
    428c:	10 92 1d 33 	sts	0x331D, r1	; 0x80331d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    4290:	80 91 26 33 	lds	r24, 0x3326	; 0x803326 <rcvC0_read_index>
    4294:	90 91 27 33 	lds	r25, 0x3327	; 0x803327 <rcvC0_read_index+0x1>
    4298:	18 16       	cp	r1, r24
    429a:	19 06       	cpc	r1, r25
    429c:	91 f4       	brne	.+36     	; 0x42c2 <__vector_25+0x9e>
    429e:	0e c0       	rjmp	.+28     	; 0x42bc <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    42a0:	01 96       	adiw	r24, 0x01	; 1
    42a2:	84 36       	cpi	r24, 0x64	; 100
    42a4:	91 05       	cpc	r25, r1
    42a6:	28 f4       	brcc	.+10     	; 0x42b2 <__vector_25+0x8e>
    42a8:	80 93 26 33 	sts	0x3326, r24	; 0x803326 <rcvC0_read_index>
    42ac:	90 93 27 33 	sts	0x3327, r25	; 0x803327 <rcvC0_read_index+0x1>
    42b0:	08 c0       	rjmp	.+16     	; 0x42c2 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    42b2:	10 92 26 33 	sts	0x3326, r1	; 0x803326 <rcvC0_read_index>
    42b6:	10 92 27 33 	sts	0x3327, r1	; 0x803327 <rcvC0_read_index+0x1>
}
    42ba:	03 c0       	rjmp	.+6      	; 0x42c2 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    42bc:	81 e0       	ldi	r24, 0x01	; 1
    42be:	90 e0       	ldi	r25, 0x00	; 0
    42c0:	f3 cf       	rjmp	.-26     	; 0x42a8 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    42c2:	ff 91       	pop	r31
    42c4:	ef 91       	pop	r30
    42c6:	9f 91       	pop	r25
    42c8:	8f 91       	pop	r24
    42ca:	3f 91       	pop	r19
    42cc:	2f 91       	pop	r18
    42ce:	0f 90       	pop	r0
    42d0:	0b be       	out	0x3b, r0	; 59
    42d2:	0f 90       	pop	r0
    42d4:	08 be       	out	0x38, r0	; 56
    42d6:	0f 90       	pop	r0
    42d8:	0f be       	out	0x3f, r0	; 63
    42da:	0f 90       	pop	r0
    42dc:	1f 90       	pop	r1
    42de:	18 95       	reti

000042e0 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    42e0:	1f 92       	push	r1
    42e2:	0f 92       	push	r0
    42e4:	0f b6       	in	r0, 0x3f	; 63
    42e6:	0f 92       	push	r0
    42e8:	11 24       	eor	r1, r1
    42ea:	08 b6       	in	r0, 0x38	; 56
    42ec:	0f 92       	push	r0
    42ee:	18 be       	out	0x38, r1	; 56
    42f0:	0b b6       	in	r0, 0x3b	; 59
    42f2:	0f 92       	push	r0
    42f4:	1b be       	out	0x3b, r1	; 59
    42f6:	2f 93       	push	r18
    42f8:	3f 93       	push	r19
    42fa:	8f 93       	push	r24
    42fc:	9f 93       	push	r25
    42fe:	ef 93       	push	r30
    4300:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    4302:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    4306:	e0 91 2e 33 	lds	r30, 0x332E	; 0x80332e <rcvC1_buffer>
    430a:	f0 91 2f 33 	lds	r31, 0x332F	; 0x80332f <rcvC1_buffer+0x1>
    430e:	80 91 1a 33 	lds	r24, 0x331A	; 0x80331a <rcvC1_write_index>
    4312:	90 91 1b 33 	lds	r25, 0x331B	; 0x80331b <rcvC1_write_index+0x1>
    4316:	e8 0f       	add	r30, r24
    4318:	f9 1f       	adc	r31, r25
    431a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    431c:	80 91 1a 33 	lds	r24, 0x331A	; 0x80331a <rcvC1_write_index>
    4320:	90 91 1b 33 	lds	r25, 0x331B	; 0x80331b <rcvC1_write_index+0x1>
    4324:	01 96       	adiw	r24, 0x01	; 1
    4326:	84 36       	cpi	r24, 0x64	; 100
    4328:	91 05       	cpc	r25, r1
    432a:	60 f4       	brcc	.+24     	; 0x4344 <__vector_28+0x64>
    432c:	80 93 1a 33 	sts	0x331A, r24	; 0x80331a <rcvC1_write_index>
    4330:	90 93 1b 33 	sts	0x331B, r25	; 0x80331b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    4334:	20 91 24 33 	lds	r18, 0x3324	; 0x803324 <rcvC1_read_index>
    4338:	30 91 25 33 	lds	r19, 0x3325	; 0x803325 <rcvC1_read_index+0x1>
    433c:	82 17       	cp	r24, r18
    433e:	93 07       	cpc	r25, r19
    4340:	f1 f4       	brne	.+60     	; 0x437e <__vector_28+0x9e>
    4342:	0c c0       	rjmp	.+24     	; 0x435c <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    4344:	10 92 1a 33 	sts	0x331A, r1	; 0x80331a <rcvC1_write_index>
    4348:	10 92 1b 33 	sts	0x331B, r1	; 0x80331b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    434c:	80 91 24 33 	lds	r24, 0x3324	; 0x803324 <rcvC1_read_index>
    4350:	90 91 25 33 	lds	r25, 0x3325	; 0x803325 <rcvC1_read_index+0x1>
    4354:	18 16       	cp	r1, r24
    4356:	19 06       	cpc	r1, r25
    4358:	91 f4       	brne	.+36     	; 0x437e <__vector_28+0x9e>
    435a:	0e c0       	rjmp	.+28     	; 0x4378 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    435c:	01 96       	adiw	r24, 0x01	; 1
    435e:	84 36       	cpi	r24, 0x64	; 100
    4360:	91 05       	cpc	r25, r1
    4362:	28 f4       	brcc	.+10     	; 0x436e <__vector_28+0x8e>
    4364:	80 93 24 33 	sts	0x3324, r24	; 0x803324 <rcvC1_read_index>
    4368:	90 93 25 33 	sts	0x3325, r25	; 0x803325 <rcvC1_read_index+0x1>
    436c:	08 c0       	rjmp	.+16     	; 0x437e <__vector_28+0x9e>
	rcvC1_read_index = 0;
    436e:	10 92 24 33 	sts	0x3324, r1	; 0x803324 <rcvC1_read_index>
    4372:	10 92 25 33 	sts	0x3325, r1	; 0x803325 <rcvC1_read_index+0x1>
}
    4376:	03 c0       	rjmp	.+6      	; 0x437e <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    4378:	81 e0       	ldi	r24, 0x01	; 1
    437a:	90 e0       	ldi	r25, 0x00	; 0
    437c:	f3 cf       	rjmp	.-26     	; 0x4364 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    437e:	ff 91       	pop	r31
    4380:	ef 91       	pop	r30
    4382:	9f 91       	pop	r25
    4384:	8f 91       	pop	r24
    4386:	3f 91       	pop	r19
    4388:	2f 91       	pop	r18
    438a:	0f 90       	pop	r0
    438c:	0b be       	out	0x3b, r0	; 59
    438e:	0f 90       	pop	r0
    4390:	08 be       	out	0x38, r0	; 56
    4392:	0f 90       	pop	r0
    4394:	0f be       	out	0x3f, r0	; 63
    4396:	0f 90       	pop	r0
    4398:	1f 90       	pop	r1
    439a:	18 95       	reti

0000439c <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    439c:	1f 92       	push	r1
    439e:	0f 92       	push	r0
    43a0:	0f b6       	in	r0, 0x3f	; 63
    43a2:	0f 92       	push	r0
    43a4:	11 24       	eor	r1, r1
    43a6:	08 b6       	in	r0, 0x38	; 56
    43a8:	0f 92       	push	r0
    43aa:	18 be       	out	0x38, r1	; 56
    43ac:	0b b6       	in	r0, 0x3b	; 59
    43ae:	0f 92       	push	r0
    43b0:	1b be       	out	0x3b, r1	; 59
    43b2:	2f 93       	push	r18
    43b4:	3f 93       	push	r19
    43b6:	8f 93       	push	r24
    43b8:	9f 93       	push	r25
    43ba:	ef 93       	push	r30
    43bc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    43be:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    43c2:	e0 91 2c 33 	lds	r30, 0x332C	; 0x80332c <rcvD0_buffer>
    43c6:	f0 91 2d 33 	lds	r31, 0x332D	; 0x80332d <rcvD0_buffer+0x1>
    43ca:	80 91 1c 33 	lds	r24, 0x331C	; 0x80331c <rcvC0_write_index>
    43ce:	90 91 1d 33 	lds	r25, 0x331D	; 0x80331d <rcvC0_write_index+0x1>
    43d2:	e8 0f       	add	r30, r24
    43d4:	f9 1f       	adc	r31, r25
    43d6:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    43d8:	80 91 18 33 	lds	r24, 0x3318	; 0x803318 <rcvD0_write_index>
    43dc:	90 91 19 33 	lds	r25, 0x3319	; 0x803319 <rcvD0_write_index+0x1>
    43e0:	01 96       	adiw	r24, 0x01	; 1
    43e2:	84 36       	cpi	r24, 0x64	; 100
    43e4:	91 05       	cpc	r25, r1
    43e6:	60 f4       	brcc	.+24     	; 0x4400 <__vector_88+0x64>
    43e8:	80 93 18 33 	sts	0x3318, r24	; 0x803318 <rcvD0_write_index>
    43ec:	90 93 19 33 	sts	0x3319, r25	; 0x803319 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    43f0:	20 91 22 33 	lds	r18, 0x3322	; 0x803322 <rcvD0_read_index>
    43f4:	30 91 23 33 	lds	r19, 0x3323	; 0x803323 <rcvD0_read_index+0x1>
    43f8:	82 17       	cp	r24, r18
    43fa:	93 07       	cpc	r25, r19
    43fc:	f1 f4       	brne	.+60     	; 0x443a <__vector_88+0x9e>
    43fe:	0c c0       	rjmp	.+24     	; 0x4418 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    4400:	10 92 18 33 	sts	0x3318, r1	; 0x803318 <rcvD0_write_index>
    4404:	10 92 19 33 	sts	0x3319, r1	; 0x803319 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    4408:	80 91 22 33 	lds	r24, 0x3322	; 0x803322 <rcvD0_read_index>
    440c:	90 91 23 33 	lds	r25, 0x3323	; 0x803323 <rcvD0_read_index+0x1>
    4410:	18 16       	cp	r1, r24
    4412:	19 06       	cpc	r1, r25
    4414:	91 f4       	brne	.+36     	; 0x443a <__vector_88+0x9e>
    4416:	0e c0       	rjmp	.+28     	; 0x4434 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4418:	01 96       	adiw	r24, 0x01	; 1
    441a:	84 36       	cpi	r24, 0x64	; 100
    441c:	91 05       	cpc	r25, r1
    441e:	28 f4       	brcc	.+10     	; 0x442a <__vector_88+0x8e>
    4420:	80 93 22 33 	sts	0x3322, r24	; 0x803322 <rcvD0_read_index>
    4424:	90 93 23 33 	sts	0x3323, r25	; 0x803323 <rcvD0_read_index+0x1>
    4428:	08 c0       	rjmp	.+16     	; 0x443a <__vector_88+0x9e>
	rcvD0_read_index = 0;
    442a:	10 92 22 33 	sts	0x3322, r1	; 0x803322 <rcvD0_read_index>
    442e:	10 92 23 33 	sts	0x3323, r1	; 0x803323 <rcvD0_read_index+0x1>
}
    4432:	03 c0       	rjmp	.+6      	; 0x443a <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    4434:	81 e0       	ldi	r24, 0x01	; 1
    4436:	90 e0       	ldi	r25, 0x00	; 0
    4438:	f3 cf       	rjmp	.-26     	; 0x4420 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    443a:	ff 91       	pop	r31
    443c:	ef 91       	pop	r30
    443e:	9f 91       	pop	r25
    4440:	8f 91       	pop	r24
    4442:	3f 91       	pop	r19
    4444:	2f 91       	pop	r18
    4446:	0f 90       	pop	r0
    4448:	0b be       	out	0x3b, r0	; 59
    444a:	0f 90       	pop	r0
    444c:	08 be       	out	0x38, r0	; 56
    444e:	0f 90       	pop	r0
    4450:	0f be       	out	0x3f, r0	; 63
    4452:	0f 90       	pop	r0
    4454:	1f 90       	pop	r1
    4456:	18 95       	reti

00004458 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    4458:	1f 92       	push	r1
    445a:	0f 92       	push	r0
    445c:	0f b6       	in	r0, 0x3f	; 63
    445e:	0f 92       	push	r0
    4460:	11 24       	eor	r1, r1
    4462:	08 b6       	in	r0, 0x38	; 56
    4464:	0f 92       	push	r0
    4466:	18 be       	out	0x38, r1	; 56
    4468:	0b b6       	in	r0, 0x3b	; 59
    446a:	0f 92       	push	r0
    446c:	1b be       	out	0x3b, r1	; 59
    446e:	2f 93       	push	r18
    4470:	3f 93       	push	r19
    4472:	8f 93       	push	r24
    4474:	9f 93       	push	r25
    4476:	ef 93       	push	r30
    4478:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    447a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    447e:	e0 91 2a 33 	lds	r30, 0x332A	; 0x80332a <rcvD1_buffer>
    4482:	f0 91 2b 33 	lds	r31, 0x332B	; 0x80332b <rcvD1_buffer+0x1>
    4486:	80 91 16 33 	lds	r24, 0x3316	; 0x803316 <rcvD1_write_index>
    448a:	90 91 17 33 	lds	r25, 0x3317	; 0x803317 <rcvD1_write_index+0x1>
    448e:	e8 0f       	add	r30, r24
    4490:	f9 1f       	adc	r31, r25
    4492:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    4494:	80 91 16 33 	lds	r24, 0x3316	; 0x803316 <rcvD1_write_index>
    4498:	90 91 17 33 	lds	r25, 0x3317	; 0x803317 <rcvD1_write_index+0x1>
    449c:	01 96       	adiw	r24, 0x01	; 1
    449e:	84 36       	cpi	r24, 0x64	; 100
    44a0:	91 05       	cpc	r25, r1
    44a2:	60 f4       	brcc	.+24     	; 0x44bc <__vector_91+0x64>
    44a4:	80 93 16 33 	sts	0x3316, r24	; 0x803316 <rcvD1_write_index>
    44a8:	90 93 17 33 	sts	0x3317, r25	; 0x803317 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    44ac:	20 91 20 33 	lds	r18, 0x3320	; 0x803320 <rcvD1_read_index>
    44b0:	30 91 21 33 	lds	r19, 0x3321	; 0x803321 <rcvD1_read_index+0x1>
    44b4:	82 17       	cp	r24, r18
    44b6:	93 07       	cpc	r25, r19
    44b8:	f1 f4       	brne	.+60     	; 0x44f6 <__vector_91+0x9e>
    44ba:	0c c0       	rjmp	.+24     	; 0x44d4 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    44bc:	10 92 16 33 	sts	0x3316, r1	; 0x803316 <rcvD1_write_index>
    44c0:	10 92 17 33 	sts	0x3317, r1	; 0x803317 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    44c4:	80 91 20 33 	lds	r24, 0x3320	; 0x803320 <rcvD1_read_index>
    44c8:	90 91 21 33 	lds	r25, 0x3321	; 0x803321 <rcvD1_read_index+0x1>
    44cc:	18 16       	cp	r1, r24
    44ce:	19 06       	cpc	r1, r25
    44d0:	91 f4       	brne	.+36     	; 0x44f6 <__vector_91+0x9e>
    44d2:	0e c0       	rjmp	.+28     	; 0x44f0 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    44d4:	01 96       	adiw	r24, 0x01	; 1
    44d6:	84 36       	cpi	r24, 0x64	; 100
    44d8:	91 05       	cpc	r25, r1
    44da:	28 f4       	brcc	.+10     	; 0x44e6 <__vector_91+0x8e>
    44dc:	80 93 20 33 	sts	0x3320, r24	; 0x803320 <rcvD1_read_index>
    44e0:	90 93 21 33 	sts	0x3321, r25	; 0x803321 <rcvD1_read_index+0x1>
    44e4:	08 c0       	rjmp	.+16     	; 0x44f6 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    44e6:	10 92 20 33 	sts	0x3320, r1	; 0x803320 <rcvD1_read_index>
    44ea:	10 92 21 33 	sts	0x3321, r1	; 0x803321 <rcvD1_read_index+0x1>
}
    44ee:	03 c0       	rjmp	.+6      	; 0x44f6 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    44f0:	81 e0       	ldi	r24, 0x01	; 1
    44f2:	90 e0       	ldi	r25, 0x00	; 0
    44f4:	f3 cf       	rjmp	.-26     	; 0x44dc <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    44f6:	ff 91       	pop	r31
    44f8:	ef 91       	pop	r30
    44fa:	9f 91       	pop	r25
    44fc:	8f 91       	pop	r24
    44fe:	3f 91       	pop	r19
    4500:	2f 91       	pop	r18
    4502:	0f 90       	pop	r0
    4504:	0b be       	out	0x3b, r0	; 59
    4506:	0f 90       	pop	r0
    4508:	08 be       	out	0x38, r0	; 56
    450a:	0f 90       	pop	r0
    450c:	0f be       	out	0x3f, r0	; 63
    450e:	0f 90       	pop	r0
    4510:	1f 90       	pop	r1
    4512:	18 95       	reti

00004514 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    4514:	1f 92       	push	r1
    4516:	0f 92       	push	r0
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	0f 92       	push	r0
    451c:	11 24       	eor	r1, r1
    451e:	08 b6       	in	r0, 0x38	; 56
    4520:	0f 92       	push	r0
    4522:	18 be       	out	0x38, r1	; 56
    4524:	0b b6       	in	r0, 0x3b	; 59
    4526:	0f 92       	push	r0
    4528:	1b be       	out	0x3b, r1	; 59
    452a:	2f 93       	push	r18
    452c:	3f 93       	push	r19
    452e:	8f 93       	push	r24
    4530:	9f 93       	push	r25
    4532:	ef 93       	push	r30
    4534:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    4536:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    453a:	e0 91 28 33 	lds	r30, 0x3328	; 0x803328 <rcvE0_buffer>
    453e:	f0 91 29 33 	lds	r31, 0x3329	; 0x803329 <rcvE0_buffer+0x1>
    4542:	80 91 14 33 	lds	r24, 0x3314	; 0x803314 <rcvE0_write_index>
    4546:	90 91 15 33 	lds	r25, 0x3315	; 0x803315 <rcvE0_write_index+0x1>
    454a:	e8 0f       	add	r30, r24
    454c:	f9 1f       	adc	r31, r25
    454e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4550:	80 91 14 33 	lds	r24, 0x3314	; 0x803314 <rcvE0_write_index>
    4554:	90 91 15 33 	lds	r25, 0x3315	; 0x803315 <rcvE0_write_index+0x1>
    4558:	01 96       	adiw	r24, 0x01	; 1
    455a:	84 36       	cpi	r24, 0x64	; 100
    455c:	91 05       	cpc	r25, r1
    455e:	60 f4       	brcc	.+24     	; 0x4578 <__vector_58+0x64>
    4560:	80 93 14 33 	sts	0x3314, r24	; 0x803314 <rcvE0_write_index>
    4564:	90 93 15 33 	sts	0x3315, r25	; 0x803315 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4568:	20 91 1e 33 	lds	r18, 0x331E	; 0x80331e <rcvE0_read_index>
    456c:	30 91 1f 33 	lds	r19, 0x331F	; 0x80331f <rcvE0_read_index+0x1>
    4570:	82 17       	cp	r24, r18
    4572:	93 07       	cpc	r25, r19
    4574:	f1 f4       	brne	.+60     	; 0x45b2 <__vector_58+0x9e>
    4576:	0c c0       	rjmp	.+24     	; 0x4590 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    4578:	10 92 14 33 	sts	0x3314, r1	; 0x803314 <rcvE0_write_index>
    457c:	10 92 15 33 	sts	0x3315, r1	; 0x803315 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4580:	80 91 1e 33 	lds	r24, 0x331E	; 0x80331e <rcvE0_read_index>
    4584:	90 91 1f 33 	lds	r25, 0x331F	; 0x80331f <rcvE0_read_index+0x1>
    4588:	18 16       	cp	r1, r24
    458a:	19 06       	cpc	r1, r25
    458c:	91 f4       	brne	.+36     	; 0x45b2 <__vector_58+0x9e>
    458e:	0e c0       	rjmp	.+28     	; 0x45ac <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4590:	01 96       	adiw	r24, 0x01	; 1
    4592:	84 36       	cpi	r24, 0x64	; 100
    4594:	91 05       	cpc	r25, r1
    4596:	28 f4       	brcc	.+10     	; 0x45a2 <__vector_58+0x8e>
    4598:	80 93 1e 33 	sts	0x331E, r24	; 0x80331e <rcvE0_read_index>
    459c:	90 93 1f 33 	sts	0x331F, r25	; 0x80331f <rcvE0_read_index+0x1>
    45a0:	08 c0       	rjmp	.+16     	; 0x45b2 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    45a2:	10 92 1e 33 	sts	0x331E, r1	; 0x80331e <rcvE0_read_index>
    45a6:	10 92 1f 33 	sts	0x331F, r1	; 0x80331f <rcvE0_read_index+0x1>
}
    45aa:	03 c0       	rjmp	.+6      	; 0x45b2 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    45ac:	81 e0       	ldi	r24, 0x01	; 1
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    45b0:	f3 cf       	rjmp	.-26     	; 0x4598 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    45b2:	ff 91       	pop	r31
    45b4:	ef 91       	pop	r30
    45b6:	9f 91       	pop	r25
    45b8:	8f 91       	pop	r24
    45ba:	3f 91       	pop	r19
    45bc:	2f 91       	pop	r18
    45be:	0f 90       	pop	r0
    45c0:	0b be       	out	0x3b, r0	; 59
    45c2:	0f 90       	pop	r0
    45c4:	08 be       	out	0x38, r0	; 56
    45c6:	0f 90       	pop	r0
    45c8:	0f be       	out	0x3f, r0	; 63
    45ca:	0f 90       	pop	r0
    45cc:	1f 90       	pop	r1
    45ce:	18 95       	reti

000045d0 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    45d0:	fc 01       	movw	r30, r24
    45d2:	84 81       	ldd	r24, Z+4	; 0x04
    45d4:	95 81       	ldd	r25, Z+5	; 0x05
    45d6:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
		}
    45da:	90 e0       	ldi	r25, 0x00	; 0
    45dc:	08 95       	ret

000045de <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    45de:	fc 01       	movw	r30, r24
    45e0:	84 81       	ldd	r24, Z+4	; 0x04
    45e2:	95 81       	ldd	r25, Z+5	; 0x05
    45e4:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    45e8:	91 e0       	ldi	r25, 0x01	; 1
    45ea:	81 11       	cpse	r24, r1
    45ec:	01 c0       	rjmp	.+2      	; 0x45f0 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    45ee:	90 e0       	ldi	r25, 0x00	; 0
		}
    45f0:	89 2f       	mov	r24, r25
    45f2:	08 95       	ret

000045f4 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    45f4:	fc 01       	movw	r30, r24
    45f6:	84 81       	ldd	r24, Z+4	; 0x04
    45f8:	95 81       	ldd	r25, Z+5	; 0x05
    45fa:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    45fe:	91 e0       	ldi	r25, 0x01	; 1
    4600:	81 11       	cpse	r24, r1
    4602:	90 e0       	ldi	r25, 0x00	; 0
		}
    4604:	89 2f       	mov	r24, r25
    4606:	08 95       	ret

00004608 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4608:	fc 01       	movw	r30, r24
    460a:	84 81       	ldd	r24, Z+4	; 0x04
    460c:	95 81       	ldd	r25, Z+5	; 0x05
    460e:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
		}
    4612:	90 e0       	ldi	r25, 0x00	; 0
    4614:	08 95       	ret

00004616 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    4616:	fc 01       	movw	r30, r24
    4618:	84 81       	ldd	r24, Z+4	; 0x04
    461a:	95 81       	ldd	r25, Z+5	; 0x05
    461c:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    4620:	91 e0       	ldi	r25, 0x01	; 1
    4622:	81 11       	cpse	r24, r1
    4624:	01 c0       	rjmp	.+2      	; 0x4628 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    4626:	90 e0       	ldi	r25, 0x00	; 0
		}
    4628:	89 2f       	mov	r24, r25
    462a:	08 95       	ret

0000462c <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    462c:	fc 01       	movw	r30, r24
    462e:	84 81       	ldd	r24, Z+4	; 0x04
    4630:	95 81       	ldd	r25, Z+5	; 0x05
    4632:	0e 94 f5 13 	call	0x27ea	; 0x27ea <uxQueueMessagesWaitingFromISR>
    4636:	91 e0       	ldi	r25, 0x01	; 1
    4638:	81 11       	cpse	r24, r1
    463a:	90 e0       	ldi	r25, 0x00	; 0
		}
    463c:	89 2f       	mov	r24, r25
    463e:	08 95       	ret

00004640 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4640:	fc 01       	movw	r30, r24
    4642:	84 81       	ldd	r24, Z+4	; 0x04
    4644:	95 81       	ldd	r25, Z+5	; 0x05
    4646:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
		}
    464a:	90 e0       	ldi	r25, 0x00	; 0
    464c:	08 95       	ret

0000464e <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    464e:	fc 01       	movw	r30, r24
    4650:	84 81       	ldd	r24, Z+4	; 0x04
    4652:	95 81       	ldd	r25, Z+5	; 0x05
    4654:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    4658:	91 e0       	ldi	r25, 0x01	; 1
    465a:	81 11       	cpse	r24, r1
    465c:	01 c0       	rjmp	.+2      	; 0x4660 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    465e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4660:	89 2f       	mov	r24, r25
    4662:	08 95       	ret

00004664 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4664:	fc 01       	movw	r30, r24
    4666:	84 81       	ldd	r24, Z+4	; 0x04
    4668:	95 81       	ldd	r25, Z+5	; 0x05
    466a:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    466e:	91 e0       	ldi	r25, 0x01	; 1
    4670:	81 11       	cpse	r24, r1
    4672:	90 e0       	ldi	r25, 0x00	; 0
		}
    4674:	89 2f       	mov	r24, r25
    4676:	08 95       	ret

00004678 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4678:	fc 01       	movw	r30, r24
    467a:	84 81       	ldd	r24, Z+4	; 0x04
    467c:	95 81       	ldd	r25, Z+5	; 0x05
    467e:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
		}
    4682:	90 e0       	ldi	r25, 0x00	; 0
    4684:	08 95       	ret

00004686 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4686:	fc 01       	movw	r30, r24
    4688:	84 81       	ldd	r24, Z+4	; 0x04
    468a:	95 81       	ldd	r25, Z+5	; 0x05
    468c:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    4690:	91 e0       	ldi	r25, 0x01	; 1
    4692:	81 11       	cpse	r24, r1
    4694:	01 c0       	rjmp	.+2      	; 0x4698 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4696:	90 e0       	ldi	r25, 0x00	; 0
		}
    4698:	89 2f       	mov	r24, r25
    469a:	08 95       	ret

0000469c <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    469c:	fc 01       	movw	r30, r24
    469e:	84 81       	ldd	r24, Z+4	; 0x04
    46a0:	95 81       	ldd	r25, Z+5	; 0x05
    46a2:	0e 94 ed 13 	call	0x27da	; 0x27da <uxQueueMessagesWaiting>
    46a6:	91 e0       	ldi	r25, 0x01	; 1
    46a8:	81 11       	cpse	r24, r1
    46aa:	90 e0       	ldi	r25, 0x00	; 0
		}
    46ac:	89 2f       	mov	r24, r25
    46ae:	08 95       	ret

000046b0 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    46b0:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    46b2:	01 e0       	ldi	r16, 0x01	; 1
    46b4:	2f ef       	ldi	r18, 0xFF	; 255
    46b6:	3f ef       	ldi	r19, 0xFF	; 255
    46b8:	a9 01       	movw	r20, r18
    46ba:	fc 01       	movw	r30, r24
    46bc:	84 81       	ldd	r24, Z+4	; 0x04
    46be:	95 81       	ldd	r25, Z+5	; 0x05
    46c0:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
}
    46c4:	0f 91       	pop	r16
    46c6:	08 95       	ret

000046c8 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    46c8:	0f 93       	push	r16
    46ca:	cf 93       	push	r28
    46cc:	df 93       	push	r29
    46ce:	1f 92       	push	r1
    46d0:	1f 92       	push	r1
    46d2:	cd b7       	in	r28, 0x3d	; 61
    46d4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    46d6:	01 e0       	ldi	r16, 0x01	; 1
    46d8:	2f ef       	ldi	r18, 0xFF	; 255
    46da:	3f ef       	ldi	r19, 0xFF	; 255
    46dc:	a9 01       	movw	r20, r18
    46de:	be 01       	movw	r22, r28
    46e0:	6f 5f       	subi	r22, 0xFF	; 255
    46e2:	7f 4f       	sbci	r23, 0xFF	; 255
    46e4:	fc 01       	movw	r30, r24
    46e6:	84 81       	ldd	r24, Z+4	; 0x04
    46e8:	95 81       	ldd	r25, Z+5	; 0x05
    46ea:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
	return (recv_item);
}
    46ee:	89 81       	ldd	r24, Y+1	; 0x01
    46f0:	9a 81       	ldd	r25, Y+2	; 0x02
    46f2:	0f 90       	pop	r0
    46f4:	0f 90       	pop	r0
    46f6:	df 91       	pop	r29
    46f8:	cf 91       	pop	r28
    46fa:	0f 91       	pop	r16
    46fc:	08 95       	ret

000046fe <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    46fe:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    4700:	00 e0       	ldi	r16, 0x00	; 0
    4702:	2f ef       	ldi	r18, 0xFF	; 255
    4704:	3f ef       	ldi	r19, 0xFF	; 255
    4706:	a9 01       	movw	r20, r18
    4708:	fc 01       	movw	r30, r24
    470a:	84 81       	ldd	r24, Z+4	; 0x04
    470c:	95 81       	ldd	r25, Z+5	; 0x05
    470e:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
}
    4712:	0f 91       	pop	r16
    4714:	08 95       	ret

00004716 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4716:	0f 93       	push	r16
    4718:	cf 93       	push	r28
    471a:	df 93       	push	r29
    471c:	1f 92       	push	r1
    471e:	1f 92       	push	r1
    4720:	cd b7       	in	r28, 0x3d	; 61
    4722:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4724:	00 e0       	ldi	r16, 0x00	; 0
    4726:	2f ef       	ldi	r18, 0xFF	; 255
    4728:	3f ef       	ldi	r19, 0xFF	; 255
    472a:	a9 01       	movw	r20, r18
    472c:	be 01       	movw	r22, r28
    472e:	6f 5f       	subi	r22, 0xFF	; 255
    4730:	7f 4f       	sbci	r23, 0xFF	; 255
    4732:	fc 01       	movw	r30, r24
    4734:	84 81       	ldd	r24, Z+4	; 0x04
    4736:	95 81       	ldd	r25, Z+5	; 0x05
    4738:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
	return (recv_item);
}
    473c:	89 81       	ldd	r24, Y+1	; 0x01
    473e:	9a 81       	ldd	r25, Y+2	; 0x02
    4740:	0f 90       	pop	r0
    4742:	0f 90       	pop	r0
    4744:	df 91       	pop	r29
    4746:	cf 91       	pop	r28
    4748:	0f 91       	pop	r16
    474a:	08 95       	ret

0000474c <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    474c:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    474e:	01 e0       	ldi	r16, 0x01	; 1
    4750:	2f ef       	ldi	r18, 0xFF	; 255
    4752:	3f ef       	ldi	r19, 0xFF	; 255
    4754:	a9 01       	movw	r20, r18
    4756:	fc 01       	movw	r30, r24
    4758:	84 81       	ldd	r24, Z+4	; 0x04
    475a:	95 81       	ldd	r25, Z+5	; 0x05
    475c:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
}
    4760:	0f 91       	pop	r16
    4762:	08 95       	ret

00004764 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4764:	0f 93       	push	r16
    4766:	cf 93       	push	r28
    4768:	df 93       	push	r29
    476a:	1f 92       	push	r1
    476c:	1f 92       	push	r1
    476e:	cd b7       	in	r28, 0x3d	; 61
    4770:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4772:	01 e0       	ldi	r16, 0x01	; 1
    4774:	2f ef       	ldi	r18, 0xFF	; 255
    4776:	3f ef       	ldi	r19, 0xFF	; 255
    4778:	a9 01       	movw	r20, r18
    477a:	be 01       	movw	r22, r28
    477c:	6f 5f       	subi	r22, 0xFF	; 255
    477e:	7f 4f       	sbci	r23, 0xFF	; 255
    4780:	fc 01       	movw	r30, r24
    4782:	84 81       	ldd	r24, Z+4	; 0x04
    4784:	95 81       	ldd	r25, Z+5	; 0x05
    4786:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
	return (recv_item);
}
    478a:	89 81       	ldd	r24, Y+1	; 0x01
    478c:	9a 81       	ldd	r25, Y+2	; 0x02
    478e:	0f 90       	pop	r0
    4790:	0f 90       	pop	r0
    4792:	df 91       	pop	r29
    4794:	cf 91       	pop	r28
    4796:	0f 91       	pop	r16
    4798:	08 95       	ret

0000479a <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    479a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    479c:	00 e0       	ldi	r16, 0x00	; 0
    479e:	2f ef       	ldi	r18, 0xFF	; 255
    47a0:	3f ef       	ldi	r19, 0xFF	; 255
    47a2:	a9 01       	movw	r20, r18
    47a4:	fc 01       	movw	r30, r24
    47a6:	84 81       	ldd	r24, Z+4	; 0x04
    47a8:	95 81       	ldd	r25, Z+5	; 0x05
    47aa:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
}
    47ae:	0f 91       	pop	r16
    47b0:	08 95       	ret

000047b2 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    47b2:	0f 93       	push	r16
    47b4:	cf 93       	push	r28
    47b6:	df 93       	push	r29
    47b8:	1f 92       	push	r1
    47ba:	1f 92       	push	r1
    47bc:	cd b7       	in	r28, 0x3d	; 61
    47be:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    47c0:	00 e0       	ldi	r16, 0x00	; 0
    47c2:	2f ef       	ldi	r18, 0xFF	; 255
    47c4:	3f ef       	ldi	r19, 0xFF	; 255
    47c6:	a9 01       	movw	r20, r18
    47c8:	be 01       	movw	r22, r28
    47ca:	6f 5f       	subi	r22, 0xFF	; 255
    47cc:	7f 4f       	sbci	r23, 0xFF	; 255
    47ce:	fc 01       	movw	r30, r24
    47d0:	84 81       	ldd	r24, Z+4	; 0x04
    47d2:	95 81       	ldd	r25, Z+5	; 0x05
    47d4:	0e 94 fc 12 	call	0x25f8	; 0x25f8 <xQueueGenericReceive>
	return (recv_item);
}
    47d8:	89 81       	ldd	r24, Y+1	; 0x01
    47da:	9a 81       	ldd	r25, Y+2	; 0x02
    47dc:	0f 90       	pop	r0
    47de:	0f 90       	pop	r0
    47e0:	df 91       	pop	r29
    47e2:	cf 91       	pop	r28
    47e4:	0f 91       	pop	r16
    47e6:	08 95       	ret

000047e8 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    47e8:	cf 93       	push	r28
    47ea:	df 93       	push	r29
    47ec:	1f 92       	push	r1
    47ee:	cd b7       	in	r28, 0x3d	; 61
    47f0:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    47f2:	ae 01       	movw	r20, r28
    47f4:	4f 5f       	subi	r20, 0xFF	; 255
    47f6:	5f 4f       	sbci	r21, 0xFF	; 255
    47f8:	fc 01       	movw	r30, r24
    47fa:	84 81       	ldd	r24, Z+4	; 0x04
    47fc:	95 81       	ldd	r25, Z+5	; 0x05
    47fe:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
}
    4802:	0f 90       	pop	r0
    4804:	df 91       	pop	r29
    4806:	cf 91       	pop	r28
    4808:	08 95       	ret

0000480a <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    480a:	cf 93       	push	r28
    480c:	df 93       	push	r29
    480e:	00 d0       	rcall	.+0      	; 0x4810 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    4810:	cd b7       	in	r28, 0x3d	; 61
    4812:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4814:	ae 01       	movw	r20, r28
    4816:	4d 5f       	subi	r20, 0xFD	; 253
    4818:	5f 4f       	sbci	r21, 0xFF	; 255
    481a:	be 01       	movw	r22, r28
    481c:	6f 5f       	subi	r22, 0xFF	; 255
    481e:	7f 4f       	sbci	r23, 0xFF	; 255
    4820:	fc 01       	movw	r30, r24
    4822:	84 81       	ldd	r24, Z+4	; 0x04
    4824:	95 81       	ldd	r25, Z+5	; 0x05
    4826:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
	return (recv_item);
}
    482a:	89 81       	ldd	r24, Y+1	; 0x01
    482c:	9a 81       	ldd	r25, Y+2	; 0x02
    482e:	23 96       	adiw	r28, 0x03	; 3
    4830:	cd bf       	out	0x3d, r28	; 61
    4832:	de bf       	out	0x3e, r29	; 62
    4834:	df 91       	pop	r29
    4836:	cf 91       	pop	r28
    4838:	08 95       	ret

0000483a <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    483a:	cf 93       	push	r28
    483c:	df 93       	push	r29
    483e:	1f 92       	push	r1
    4840:	cd b7       	in	r28, 0x3d	; 61
    4842:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4844:	ae 01       	movw	r20, r28
    4846:	4f 5f       	subi	r20, 0xFF	; 255
    4848:	5f 4f       	sbci	r21, 0xFF	; 255
    484a:	fc 01       	movw	r30, r24
    484c:	84 81       	ldd	r24, Z+4	; 0x04
    484e:	95 81       	ldd	r25, Z+5	; 0x05
    4850:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
}
    4854:	0f 90       	pop	r0
    4856:	df 91       	pop	r29
    4858:	cf 91       	pop	r28
    485a:	08 95       	ret

0000485c <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    485c:	cf 93       	push	r28
    485e:	df 93       	push	r29
    4860:	00 d0       	rcall	.+0      	; 0x4862 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4862:	cd b7       	in	r28, 0x3d	; 61
    4864:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4866:	ae 01       	movw	r20, r28
    4868:	4d 5f       	subi	r20, 0xFD	; 253
    486a:	5f 4f       	sbci	r21, 0xFF	; 255
    486c:	be 01       	movw	r22, r28
    486e:	6f 5f       	subi	r22, 0xFF	; 255
    4870:	7f 4f       	sbci	r23, 0xFF	; 255
    4872:	fc 01       	movw	r30, r24
    4874:	84 81       	ldd	r24, Z+4	; 0x04
    4876:	95 81       	ldd	r25, Z+5	; 0x05
    4878:	0e 94 c0 13 	call	0x2780	; 0x2780 <xQueueReceiveFromISR>
	return (recv_item);
}
    487c:	89 81       	ldd	r24, Y+1	; 0x01
    487e:	9a 81       	ldd	r25, Y+2	; 0x02
    4880:	23 96       	adiw	r28, 0x03	; 3
    4882:	cd bf       	out	0x3d, r28	; 61
    4884:	de bf       	out	0x3e, r29	; 62
    4886:	df 91       	pop	r29
    4888:	cf 91       	pop	r28
    488a:	08 95       	ret

0000488c <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    488c:	cf 93       	push	r28
    488e:	df 93       	push	r29
    4890:	1f 92       	push	r1
    4892:	cd b7       	in	r28, 0x3d	; 61
    4894:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4896:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    4898:	21 e0       	ldi	r18, 0x01	; 1
    489a:	ae 01       	movw	r20, r28
    489c:	4f 5f       	subi	r20, 0xFF	; 255
    489e:	5f 4f       	sbci	r21, 0xFF	; 255
    48a0:	fc 01       	movw	r30, r24
    48a2:	84 81       	ldd	r24, Z+4	; 0x04
    48a4:	95 81       	ldd	r25, Z+5	; 0x05
    48a6:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    48aa:	91 e0       	ldi	r25, 0x01	; 1
    48ac:	81 11       	cpse	r24, r1
    48ae:	01 c0       	rjmp	.+2      	; 0x48b2 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    48b0:	90 e0       	ldi	r25, 0x00	; 0
}
    48b2:	89 2f       	mov	r24, r25
    48b4:	0f 90       	pop	r0
    48b6:	df 91       	pop	r29
    48b8:	cf 91       	pop	r28
    48ba:	08 95       	ret

000048bc <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    48bc:	cf 93       	push	r28
    48be:	df 93       	push	r29
    48c0:	1f 92       	push	r1
    48c2:	cd b7       	in	r28, 0x3d	; 61
    48c4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    48c6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    48c8:	20 e0       	ldi	r18, 0x00	; 0
    48ca:	ae 01       	movw	r20, r28
    48cc:	4f 5f       	subi	r20, 0xFF	; 255
    48ce:	5f 4f       	sbci	r21, 0xFF	; 255
    48d0:	fc 01       	movw	r30, r24
    48d2:	84 81       	ldd	r24, Z+4	; 0x04
    48d4:	95 81       	ldd	r25, Z+5	; 0x05
    48d6:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    48da:	91 e0       	ldi	r25, 0x01	; 1
    48dc:	81 11       	cpse	r24, r1
    48de:	01 c0       	rjmp	.+2      	; 0x48e2 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    48e0:	90 e0       	ldi	r25, 0x00	; 0
}
    48e2:	89 2f       	mov	r24, r25
    48e4:	0f 90       	pop	r0
    48e6:	df 91       	pop	r29
    48e8:	cf 91       	pop	r28
    48ea:	08 95       	ret

000048ec <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    48ec:	cf 93       	push	r28
    48ee:	df 93       	push	r29
    48f0:	1f 92       	push	r1
    48f2:	cd b7       	in	r28, 0x3d	; 61
    48f4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    48f6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    48f8:	21 e0       	ldi	r18, 0x01	; 1
    48fa:	ae 01       	movw	r20, r28
    48fc:	4f 5f       	subi	r20, 0xFF	; 255
    48fe:	5f 4f       	sbci	r21, 0xFF	; 255
    4900:	fc 01       	movw	r30, r24
    4902:	84 81       	ldd	r24, Z+4	; 0x04
    4904:	95 81       	ldd	r25, Z+5	; 0x05
    4906:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    490a:	91 e0       	ldi	r25, 0x01	; 1
    490c:	81 11       	cpse	r24, r1
    490e:	01 c0       	rjmp	.+2      	; 0x4912 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    4910:	90 e0       	ldi	r25, 0x00	; 0
}
    4912:	89 2f       	mov	r24, r25
    4914:	0f 90       	pop	r0
    4916:	df 91       	pop	r29
    4918:	cf 91       	pop	r28
    491a:	08 95       	ret

0000491c <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    491c:	cf 93       	push	r28
    491e:	df 93       	push	r29
    4920:	1f 92       	push	r1
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4926:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    4928:	20 e0       	ldi	r18, 0x00	; 0
    492a:	ae 01       	movw	r20, r28
    492c:	4f 5f       	subi	r20, 0xFF	; 255
    492e:	5f 4f       	sbci	r21, 0xFF	; 255
    4930:	fc 01       	movw	r30, r24
    4932:	84 81       	ldd	r24, Z+4	; 0x04
    4934:	95 81       	ldd	r25, Z+5	; 0x05
    4936:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    493a:	91 e0       	ldi	r25, 0x01	; 1
    493c:	81 11       	cpse	r24, r1
    493e:	01 c0       	rjmp	.+2      	; 0x4942 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4940:	90 e0       	ldi	r25, 0x00	; 0
}
    4942:	89 2f       	mov	r24, r25
    4944:	0f 90       	pop	r0
    4946:	df 91       	pop	r29
    4948:	cf 91       	pop	r28
    494a:	08 95       	ret

0000494c <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    494c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    494e:	fc 01       	movw	r30, r24
    4950:	26 81       	ldd	r18, Z+6	; 0x06
    4952:	37 81       	ldd	r19, Z+7	; 0x07
    4954:	40 85       	ldd	r20, Z+8	; 0x08
    4956:	51 85       	ldd	r21, Z+9	; 0x09
    4958:	01 e0       	ldi	r16, 0x01	; 1
    495a:	84 81       	ldd	r24, Z+4	; 0x04
    495c:	95 81       	ldd	r25, Z+5	; 0x05
    495e:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    4962:	91 e0       	ldi	r25, 0x01	; 1
    4964:	81 11       	cpse	r24, r1
    4966:	01 c0       	rjmp	.+2      	; 0x496a <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    4968:	90 e0       	ldi	r25, 0x00	; 0
		}
    496a:	89 2f       	mov	r24, r25
    496c:	0f 91       	pop	r16
    496e:	08 95       	ret

00004970 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4970:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4972:	fc 01       	movw	r30, r24
    4974:	26 81       	ldd	r18, Z+6	; 0x06
    4976:	37 81       	ldd	r19, Z+7	; 0x07
    4978:	40 85       	ldd	r20, Z+8	; 0x08
    497a:	51 85       	ldd	r21, Z+9	; 0x09
    497c:	00 e0       	ldi	r16, 0x00	; 0
    497e:	84 81       	ldd	r24, Z+4	; 0x04
    4980:	95 81       	ldd	r25, Z+5	; 0x05
    4982:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    4986:	91 e0       	ldi	r25, 0x01	; 1
    4988:	81 11       	cpse	r24, r1
    498a:	01 c0       	rjmp	.+2      	; 0x498e <_ZN9frt_queueIjE3putERKj+0x1e>
    498c:	90 e0       	ldi	r25, 0x00	; 0
		}
    498e:	89 2f       	mov	r24, r25
    4990:	0f 91       	pop	r16
    4992:	08 95       	ret

00004994 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4994:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4996:	fc 01       	movw	r30, r24
    4998:	26 81       	ldd	r18, Z+6	; 0x06
    499a:	37 81       	ldd	r19, Z+7	; 0x07
    499c:	40 85       	ldd	r20, Z+8	; 0x08
    499e:	51 85       	ldd	r21, Z+9	; 0x09
    49a0:	01 e0       	ldi	r16, 0x01	; 1
    49a2:	84 81       	ldd	r24, Z+4	; 0x04
    49a4:	95 81       	ldd	r25, Z+5	; 0x05
    49a6:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    49aa:	91 e0       	ldi	r25, 0x01	; 1
    49ac:	81 11       	cpse	r24, r1
    49ae:	01 c0       	rjmp	.+2      	; 0x49b2 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    49b0:	90 e0       	ldi	r25, 0x00	; 0
		}
    49b2:	89 2f       	mov	r24, r25
    49b4:	0f 91       	pop	r16
    49b6:	08 95       	ret

000049b8 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    49b8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    49ba:	fc 01       	movw	r30, r24
    49bc:	26 81       	ldd	r18, Z+6	; 0x06
    49be:	37 81       	ldd	r19, Z+7	; 0x07
    49c0:	40 85       	ldd	r20, Z+8	; 0x08
    49c2:	51 85       	ldd	r21, Z+9	; 0x09
    49c4:	00 e0       	ldi	r16, 0x00	; 0
    49c6:	84 81       	ldd	r24, Z+4	; 0x04
    49c8:	95 81       	ldd	r25, Z+5	; 0x05
    49ca:	0e 94 35 12 	call	0x246a	; 0x246a <xQueueGenericSend>
    49ce:	91 e0       	ldi	r25, 0x01	; 1
    49d0:	81 11       	cpse	r24, r1
    49d2:	01 c0       	rjmp	.+2      	; 0x49d6 <_ZN9frt_queueIiE3putERKi+0x1e>
    49d4:	90 e0       	ldi	r25, 0x00	; 0
		}
    49d6:	89 2f       	mov	r24, r25
    49d8:	0f 91       	pop	r16
    49da:	08 95       	ret

000049dc <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    49dc:	0f 93       	push	r16
    49de:	cf 93       	push	r28
    49e0:	df 93       	push	r29
    49e2:	1f 92       	push	r1
    49e4:	cd b7       	in	r28, 0x3d	; 61
    49e6:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    49e8:	2f b7       	in	r18, 0x3f	; 63
    49ea:	29 83       	std	Y+1, r18	; 0x01
	cli();
    49ec:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    49ee:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    49f0:	fc 01       	movw	r30, r24
    49f2:	08 ed       	ldi	r16, 0xD8	; 216
    49f4:	04 bf       	out	0x34, r16	; 52
    49f6:	60 83       	st	Z, r22

	SREG = saved_sreg;
    49f8:	89 81       	ldd	r24, Y+1	; 0x01
    49fa:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    49fc:	0f 90       	pop	r0
    49fe:	df 91       	pop	r29
    4a00:	cf 91       	pop	r28
    4a02:	0f 91       	pop	r16
    4a04:	08 95       	ret

00004a06 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    4a06:	ef 92       	push	r14
    4a08:	ff 92       	push	r15
    4a0a:	0f 93       	push	r16
    4a0c:	1f 93       	push	r17
    4a0e:	cf 93       	push	r28
    4a10:	df 93       	push	r29
    4a12:	cd b7       	in	r28, 0x3d	; 61
    4a14:	de b7       	in	r29, 0x3e	; 62
    4a16:	c7 54       	subi	r28, 0x47	; 71
    4a18:	d1 09       	sbc	r29, r1
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	de bf       	out	0x3e, r29	; 62
	cli();
    4a1e:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    4a20:	e0 e5       	ldi	r30, 0x50	; 80
    4a22:	f0 e0       	ldi	r31, 0x00	; 0
    4a24:	80 81       	ld	r24, Z
    4a26:	82 60       	ori	r24, 0x02	; 2
    4a28:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    4a2a:	81 81       	ldd	r24, Z+1	; 0x01
    4a2c:	81 ff       	sbrs	r24, 1
    4a2e:	fd cf       	rjmp	.-6      	; 0x4a2a <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    4a30:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    4a34:	68 7f       	andi	r22, 0xF8	; 248
    4a36:	61 60       	ori	r22, 0x01	; 1
    4a38:	80 e4       	ldi	r24, 0x40	; 64
    4a3a:	90 e0       	ldi	r25, 0x00	; 0
    4a3c:	0e 94 ee 24 	call	0x49dc	; 0x49dc <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4a40:	e0 e5       	ldi	r30, 0x50	; 80
    4a42:	f0 e0       	ldi	r31, 0x00	; 0
    4a44:	80 81       	ld	r24, Z
    4a46:	8e 7f       	andi	r24, 0xFE	; 254
    4a48:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    4a4a:	9d ef       	ldi	r25, 0xFD	; 253
    4a4c:	88 ed       	ldi	r24, 0xD8	; 216
    4a4e:	08 b6       	in	r0, 0x38	; 56
    4a50:	18 be       	out	0x38, r1	; 56
    4a52:	84 bf       	out	0x34, r24	; 52
    4a54:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    4a58:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    4a5a:	40 ea       	ldi	r20, 0xA0	; 160
    4a5c:	5a e0       	ldi	r21, 0x0A	; 10
    4a5e:	60 e0       	ldi	r22, 0x00	; 0
    4a60:	70 e0       	ldi	r23, 0x00	; 0
    4a62:	ce 01       	movw	r24, r28
    4a64:	01 96       	adiw	r24, 0x01	; 1
    4a66:	0e 94 92 20 	call	0x4124	; 0x4124 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    4a6a:	67 e0       	ldi	r22, 0x07	; 7
    4a6c:	ce 01       	movw	r24, r28
    4a6e:	01 96       	adiw	r24, 0x01	; 1
    4a70:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    4a74:	8c 01       	movw	r16, r24
    4a76:	63 e3       	ldi	r22, 0x33	; 51
    4a78:	72 e2       	ldi	r23, 0x22	; 34
    4a7a:	0e 94 93 1e 	call	0x3d26	; 0x3d26 <_ZN8emstream4putsEPKc>
    4a7e:	66 e0       	ldi	r22, 0x06	; 6
    4a80:	c8 01       	movw	r24, r16
    4a82:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
    4a86:	66 e0       	ldi	r22, 0x06	; 6
    4a88:	0e 94 ca 1e 	call	0x3d94	; 0x3d94 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000, &ser_dev);
    4a8c:	8e 01       	movw	r16, r28
    4a8e:	0f 5f       	subi	r16, 0xFF	; 255
    4a90:	1f 4f       	sbci	r17, 0xFF	; 255
    4a92:	20 e3       	ldi	r18, 0x30	; 48
    4a94:	32 ef       	ldi	r19, 0xF2	; 242
    4a96:	40 e0       	ldi	r20, 0x00	; 0
    4a98:	50 e0       	ldi	r21, 0x00	; 0
    4a9a:	60 ea       	ldi	r22, 0xA0	; 160
    4a9c:	74 e0       	ldi	r23, 0x04	; 4
    4a9e:	ce 01       	movw	r24, r28
    4aa0:	4e 96       	adiw	r24, 0x1e	; 30
    4aa2:	0e 94 8b 08 	call	0x1116	; 0x1116 <_ZN9I2CMasterC1EP10TWI_structmP8emstream>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c, &ser_dev);
    4aa6:	a8 01       	movw	r20, r16
    4aa8:	be 01       	movw	r22, r28
    4aaa:	62 5e       	subi	r22, 0xE2	; 226
    4aac:	7f 4f       	sbci	r23, 0xFF	; 255
    4aae:	ce 01       	movw	r24, r28
    4ab0:	c7 96       	adiw	r24, 0x37	; 55
    4ab2:	0e 94 3f 0a 	call	0x147e	; 0x147e <_ZN6MB1202C1EP9I2CMasterP8emstream>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4ab6:	82 e1       	ldi	r24, 0x12	; 18
    4ab8:	90 e0       	ldi	r25, 0x00	; 0
    4aba:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    4abe:	20 e8       	ldi	r18, 0x80	; 128
    4ac0:	30 e0       	ldi	r19, 0x00	; 0
    4ac2:	40 e0       	ldi	r20, 0x00	; 0
    4ac4:	62 e5       	ldi	r22, 0x52	; 82
    4ac6:	72 e2       	ldi	r23, 0x22	; 34
    4ac8:	0e 94 b1 0b 	call	0x1762	; 0x1762 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    4acc:	88 e1       	ldi	r24, 0x18	; 24
    4ace:	90 e0       	ldi	r25, 0x00	; 0
    4ad0:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <_Znwj>
    4ad4:	9e 01       	movw	r18, r28
    4ad6:	29 5c       	subi	r18, 0xC9	; 201
    4ad8:	3f 4f       	sbci	r19, 0xFF	; 255
    4ada:	79 01       	movw	r14, r18
    4adc:	20 e8       	ldi	r18, 0x80	; 128
    4ade:	30 e0       	ldi	r19, 0x00	; 0
    4ae0:	42 e0       	ldi	r20, 0x02	; 2
    4ae2:	6a e5       	ldi	r22, 0x5A	; 90
    4ae4:	72 e2       	ldi	r23, 0x22	; 34
    4ae6:	0e 94 94 0b 	call	0x1728	; 0x1728 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    4aea:	87 e0       	ldi	r24, 0x07	; 7
    4aec:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    4af0:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    4af2:	0e 94 5e 15 	call	0x2abc	; 0x2abc <vTaskStartScheduler>
}
    4af6:	80 e0       	ldi	r24, 0x00	; 0
    4af8:	90 e0       	ldi	r25, 0x00	; 0
    4afa:	c9 5b       	subi	r28, 0xB9	; 185
    4afc:	df 4f       	sbci	r29, 0xFF	; 255
    4afe:	cd bf       	out	0x3d, r28	; 61
    4b00:	de bf       	out	0x3e, r29	; 62
    4b02:	df 91       	pop	r29
    4b04:	cf 91       	pop	r28
    4b06:	1f 91       	pop	r17
    4b08:	0f 91       	pop	r16
    4b0a:	ff 90       	pop	r15
    4b0c:	ef 90       	pop	r14
    4b0e:	08 95       	ret

00004b10 <_GLOBAL__sub_I_counter>:
    4b10:	cf 92       	push	r12
    4b12:	df 92       	push	r13
    4b14:	ef 92       	push	r14
    4b16:	ff 92       	push	r15
    4b18:	0f 93       	push	r16
    4b1a:	1f 93       	push	r17
    4b1c:	cf 93       	push	r28
    4b1e:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4b20:	0a e0       	ldi	r16, 0x0A	; 10
    4b22:	10 e0       	ldi	r17, 0x00	; 0
    4b24:	20 e0       	ldi	r18, 0x00	; 0
    4b26:	30 e0       	ldi	r19, 0x00	; 0
    4b28:	40 e0       	ldi	r20, 0x00	; 0
    4b2a:	50 e0       	ldi	r21, 0x00	; 0
    4b2c:	60 e2       	ldi	r22, 0x20	; 32
    4b2e:	70 e0       	ldi	r23, 0x00	; 0
    4b30:	84 e6       	ldi	r24, 0x64	; 100
    4b32:	93 e3       	ldi	r25, 0x33	; 51
    4b34:	0e 94 4b 1c 	call	0x3896	; 0x3896 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    4b38:	ca e5       	ldi	r28, 0x5A	; 90
    4b3a:	d3 e3       	ldi	r29, 0x33	; 51
    4b3c:	1a 82       	std	Y+2, r1	; 0x02
    4b3e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b40:	84 e6       	ldi	r24, 0x64	; 100
    4b42:	92 e2       	ldi	r25, 0x22	; 34
    4b44:	88 83       	st	Y, r24
    4b46:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b48:	40 e0       	ldi	r20, 0x00	; 0
    4b4a:	62 e0       	ldi	r22, 0x02	; 2
    4b4c:	8f ef       	ldi	r24, 0xFF	; 255
    4b4e:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    4b52:	8c 83       	std	Y+4, r24	; 0x04
    4b54:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b56:	0f 2e       	mov	r0, r31
    4b58:	fa e0       	ldi	r31, 0x0A	; 10
    4b5a:	cf 2e       	mov	r12, r31
    4b5c:	d1 2c       	mov	r13, r1
    4b5e:	e1 2c       	mov	r14, r1
    4b60:	f1 2c       	mov	r15, r1
    4b62:	f0 2d       	mov	r31, r0
    4b64:	ce 82       	std	Y+6, r12	; 0x06
    4b66:	df 82       	std	Y+7, r13	; 0x07
    4b68:	e8 86       	std	Y+8, r14	; 0x08
    4b6a:	f9 86       	std	Y+9, r15	; 0x09
    4b6c:	c0 e5       	ldi	r28, 0x50	; 80
    4b6e:	d3 e3       	ldi	r29, 0x33	; 51
    4b70:	1a 82       	std	Y+2, r1	; 0x02
    4b72:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b74:	08 e8       	ldi	r16, 0x88	; 136
    4b76:	12 e2       	ldi	r17, 0x22	; 34
    4b78:	08 83       	st	Y, r16
    4b7a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b7c:	40 e0       	ldi	r20, 0x00	; 0
    4b7e:	62 e0       	ldi	r22, 0x02	; 2
    4b80:	8f ef       	ldi	r24, 0xFF	; 255
    4b82:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    4b86:	8c 83       	std	Y+4, r24	; 0x04
    4b88:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4b8a:	ce 82       	std	Y+6, r12	; 0x06
    4b8c:	df 82       	std	Y+7, r13	; 0x07
    4b8e:	e8 86       	std	Y+8, r14	; 0x08
    4b90:	f9 86       	std	Y+9, r15	; 0x09
    4b92:	c6 e4       	ldi	r28, 0x46	; 70
    4b94:	d3 e3       	ldi	r29, 0x33	; 51
    4b96:	1a 82       	std	Y+2, r1	; 0x02
    4b98:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4b9a:	08 83       	st	Y, r16
    4b9c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4b9e:	40 e0       	ldi	r20, 0x00	; 0
    4ba0:	62 e0       	ldi	r22, 0x02	; 2
    4ba2:	8f ef       	ldi	r24, 0xFF	; 255
    4ba4:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    4ba8:	8c 83       	std	Y+4, r24	; 0x04
    4baa:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4bac:	ce 82       	std	Y+6, r12	; 0x06
    4bae:	df 82       	std	Y+7, r13	; 0x07
    4bb0:	e8 86       	std	Y+8, r14	; 0x08
    4bb2:	f9 86       	std	Y+9, r15	; 0x09
    4bb4:	cc e3       	ldi	r28, 0x3C	; 60
    4bb6:	d3 e3       	ldi	r29, 0x33	; 51
    4bb8:	1a 82       	std	Y+2, r1	; 0x02
    4bba:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4bbc:	08 83       	st	Y, r16
    4bbe:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4bc0:	40 e0       	ldi	r20, 0x00	; 0
    4bc2:	62 e0       	ldi	r22, 0x02	; 2
    4bc4:	8f ef       	ldi	r24, 0xFF	; 255
    4bc6:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    4bca:	8c 83       	std	Y+4, r24	; 0x04
    4bcc:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4bce:	ce 82       	std	Y+6, r12	; 0x06
    4bd0:	df 82       	std	Y+7, r13	; 0x07
    4bd2:	e8 86       	std	Y+8, r14	; 0x08
    4bd4:	f9 86       	std	Y+9, r15	; 0x09
    4bd6:	c2 e3       	ldi	r28, 0x32	; 50
    4bd8:	d3 e3       	ldi	r29, 0x33	; 51
    4bda:	1a 82       	std	Y+2, r1	; 0x02
    4bdc:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4bde:	08 83       	st	Y, r16
    4be0:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4be2:	40 e0       	ldi	r20, 0x00	; 0
    4be4:	62 e0       	ldi	r22, 0x02	; 2
    4be6:	8f ef       	ldi	r24, 0xFF	; 255
    4be8:	0e 94 07 12 	call	0x240e	; 0x240e <xQueueGenericCreate>
    4bec:	8c 83       	std	Y+4, r24	; 0x04
    4bee:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4bf0:	ce 82       	std	Y+6, r12	; 0x06
    4bf2:	df 82       	std	Y+7, r13	; 0x07
    4bf4:	e8 86       	std	Y+8, r14	; 0x08
    4bf6:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    4bf8:	df 91       	pop	r29
    4bfa:	cf 91       	pop	r28
    4bfc:	1f 91       	pop	r17
    4bfe:	0f 91       	pop	r16
    4c00:	ff 90       	pop	r15
    4c02:	ef 90       	pop	r14
    4c04:	df 90       	pop	r13
    4c06:	cf 90       	pop	r12
    4c08:	08 95       	ret

00004c0a <__mulsi3>:
    4c0a:	db 01       	movw	r26, r22
    4c0c:	8f 93       	push	r24
    4c0e:	9f 93       	push	r25
    4c10:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <__muluhisi3>
    4c14:	bf 91       	pop	r27
    4c16:	af 91       	pop	r26
    4c18:	a2 9f       	mul	r26, r18
    4c1a:	80 0d       	add	r24, r0
    4c1c:	91 1d       	adc	r25, r1
    4c1e:	a3 9f       	mul	r26, r19
    4c20:	90 0d       	add	r25, r0
    4c22:	b2 9f       	mul	r27, r18
    4c24:	90 0d       	add	r25, r0
    4c26:	11 24       	eor	r1, r1
    4c28:	08 95       	ret

00004c2a <__udivmodsi4>:
    4c2a:	a1 e2       	ldi	r26, 0x21	; 33
    4c2c:	1a 2e       	mov	r1, r26
    4c2e:	aa 1b       	sub	r26, r26
    4c30:	bb 1b       	sub	r27, r27
    4c32:	fd 01       	movw	r30, r26
    4c34:	0d c0       	rjmp	.+26     	; 0x4c50 <__udivmodsi4_ep>

00004c36 <__udivmodsi4_loop>:
    4c36:	aa 1f       	adc	r26, r26
    4c38:	bb 1f       	adc	r27, r27
    4c3a:	ee 1f       	adc	r30, r30
    4c3c:	ff 1f       	adc	r31, r31
    4c3e:	a2 17       	cp	r26, r18
    4c40:	b3 07       	cpc	r27, r19
    4c42:	e4 07       	cpc	r30, r20
    4c44:	f5 07       	cpc	r31, r21
    4c46:	20 f0       	brcs	.+8      	; 0x4c50 <__udivmodsi4_ep>
    4c48:	a2 1b       	sub	r26, r18
    4c4a:	b3 0b       	sbc	r27, r19
    4c4c:	e4 0b       	sbc	r30, r20
    4c4e:	f5 0b       	sbc	r31, r21

00004c50 <__udivmodsi4_ep>:
    4c50:	66 1f       	adc	r22, r22
    4c52:	77 1f       	adc	r23, r23
    4c54:	88 1f       	adc	r24, r24
    4c56:	99 1f       	adc	r25, r25
    4c58:	1a 94       	dec	r1
    4c5a:	69 f7       	brne	.-38     	; 0x4c36 <__udivmodsi4_loop>
    4c5c:	60 95       	com	r22
    4c5e:	70 95       	com	r23
    4c60:	80 95       	com	r24
    4c62:	90 95       	com	r25
    4c64:	9b 01       	movw	r18, r22
    4c66:	ac 01       	movw	r20, r24
    4c68:	bd 01       	movw	r22, r26
    4c6a:	cf 01       	movw	r24, r30
    4c6c:	08 95       	ret

00004c6e <__divmodsi4>:
    4c6e:	05 2e       	mov	r0, r21
    4c70:	97 fb       	bst	r25, 7
    4c72:	1e f4       	brtc	.+6      	; 0x4c7a <__divmodsi4+0xc>
    4c74:	00 94       	com	r0
    4c76:	0e 94 4e 26 	call	0x4c9c	; 0x4c9c <__negsi2>
    4c7a:	57 fd       	sbrc	r21, 7
    4c7c:	07 d0       	rcall	.+14     	; 0x4c8c <__divmodsi4_neg2>
    4c7e:	0e 94 15 26 	call	0x4c2a	; 0x4c2a <__udivmodsi4>
    4c82:	07 fc       	sbrc	r0, 7
    4c84:	03 d0       	rcall	.+6      	; 0x4c8c <__divmodsi4_neg2>
    4c86:	4e f4       	brtc	.+18     	; 0x4c9a <__divmodsi4_exit>
    4c88:	0c 94 4e 26 	jmp	0x4c9c	; 0x4c9c <__negsi2>

00004c8c <__divmodsi4_neg2>:
    4c8c:	50 95       	com	r21
    4c8e:	40 95       	com	r20
    4c90:	30 95       	com	r19
    4c92:	21 95       	neg	r18
    4c94:	3f 4f       	sbci	r19, 0xFF	; 255
    4c96:	4f 4f       	sbci	r20, 0xFF	; 255
    4c98:	5f 4f       	sbci	r21, 0xFF	; 255

00004c9a <__divmodsi4_exit>:
    4c9a:	08 95       	ret

00004c9c <__negsi2>:
    4c9c:	90 95       	com	r25
    4c9e:	80 95       	com	r24
    4ca0:	70 95       	com	r23
    4ca2:	61 95       	neg	r22
    4ca4:	7f 4f       	sbci	r23, 0xFF	; 255
    4ca6:	8f 4f       	sbci	r24, 0xFF	; 255
    4ca8:	9f 4f       	sbci	r25, 0xFF	; 255
    4caa:	08 95       	ret

00004cac <__tablejump2__>:
    4cac:	ee 0f       	add	r30, r30
    4cae:	ff 1f       	adc	r31, r31
    4cb0:	88 1f       	adc	r24, r24
    4cb2:	8b bf       	out	0x3b, r24	; 59
    4cb4:	07 90       	elpm	r0, Z+
    4cb6:	f6 91       	elpm	r31, Z
    4cb8:	e0 2d       	mov	r30, r0
    4cba:	1b be       	out	0x3b, r1	; 59
    4cbc:	19 94       	eijmp

00004cbe <__muluhisi3>:
    4cbe:	0e 94 6a 26 	call	0x4cd4	; 0x4cd4 <__umulhisi3>
    4cc2:	a5 9f       	mul	r26, r21
    4cc4:	90 0d       	add	r25, r0
    4cc6:	b4 9f       	mul	r27, r20
    4cc8:	90 0d       	add	r25, r0
    4cca:	a4 9f       	mul	r26, r20
    4ccc:	80 0d       	add	r24, r0
    4cce:	91 1d       	adc	r25, r1
    4cd0:	11 24       	eor	r1, r1
    4cd2:	08 95       	ret

00004cd4 <__umulhisi3>:
    4cd4:	a2 9f       	mul	r26, r18
    4cd6:	b0 01       	movw	r22, r0
    4cd8:	b3 9f       	mul	r27, r19
    4cda:	c0 01       	movw	r24, r0
    4cdc:	a3 9f       	mul	r26, r19
    4cde:	70 0d       	add	r23, r0
    4ce0:	81 1d       	adc	r24, r1
    4ce2:	11 24       	eor	r1, r1
    4ce4:	91 1d       	adc	r25, r1
    4ce6:	b2 9f       	mul	r27, r18
    4ce8:	70 0d       	add	r23, r0
    4cea:	81 1d       	adc	r24, r1
    4cec:	11 24       	eor	r1, r1
    4cee:	91 1d       	adc	r25, r1
    4cf0:	08 95       	ret

00004cf2 <memcpy>:
    4cf2:	fb 01       	movw	r30, r22
    4cf4:	dc 01       	movw	r26, r24
    4cf6:	02 c0       	rjmp	.+4      	; 0x4cfc <memcpy+0xa>
    4cf8:	01 90       	ld	r0, Z+
    4cfa:	0d 92       	st	X+, r0
    4cfc:	41 50       	subi	r20, 0x01	; 1
    4cfe:	50 40       	sbci	r21, 0x00	; 0
    4d00:	d8 f7       	brcc	.-10     	; 0x4cf8 <memcpy+0x6>
    4d02:	08 95       	ret

00004d04 <memset>:
    4d04:	dc 01       	movw	r26, r24
    4d06:	01 c0       	rjmp	.+2      	; 0x4d0a <memset+0x6>
    4d08:	6d 93       	st	X+, r22
    4d0a:	41 50       	subi	r20, 0x01	; 1
    4d0c:	50 40       	sbci	r21, 0x00	; 0
    4d0e:	e0 f7       	brcc	.-8      	; 0x4d08 <memset+0x4>
    4d10:	08 95       	ret

00004d12 <strncpy>:
    4d12:	fb 01       	movw	r30, r22
    4d14:	dc 01       	movw	r26, r24
    4d16:	41 50       	subi	r20, 0x01	; 1
    4d18:	50 40       	sbci	r21, 0x00	; 0
    4d1a:	48 f0       	brcs	.+18     	; 0x4d2e <strncpy+0x1c>
    4d1c:	01 90       	ld	r0, Z+
    4d1e:	0d 92       	st	X+, r0
    4d20:	00 20       	and	r0, r0
    4d22:	c9 f7       	brne	.-14     	; 0x4d16 <strncpy+0x4>
    4d24:	01 c0       	rjmp	.+2      	; 0x4d28 <strncpy+0x16>
    4d26:	1d 92       	st	X+, r1
    4d28:	41 50       	subi	r20, 0x01	; 1
    4d2a:	50 40       	sbci	r21, 0x00	; 0
    4d2c:	e0 f7       	brcc	.-8      	; 0x4d26 <strncpy+0x14>
    4d2e:	08 95       	ret

00004d30 <ultoa>:
    4d30:	25 32       	cpi	r18, 0x25	; 37
    4d32:	31 05       	cpc	r19, r1
    4d34:	20 f4       	brcc	.+8      	; 0x4d3e <ultoa+0xe>
    4d36:	22 30       	cpi	r18, 0x02	; 2
    4d38:	10 f0       	brcs	.+4      	; 0x4d3e <ultoa+0xe>
    4d3a:	0c 94 a3 26 	jmp	0x4d46	; 0x4d46 <__ultoa_ncheck>
    4d3e:	fa 01       	movw	r30, r20
    4d40:	10 82       	st	Z, r1
    4d42:	ca 01       	movw	r24, r20
    4d44:	08 95       	ret

00004d46 <__ultoa_ncheck>:
    4d46:	bb 27       	eor	r27, r27

00004d48 <__ultoa_common>:
    4d48:	fa 01       	movw	r30, r20
    4d4a:	a6 2f       	mov	r26, r22
    4d4c:	62 17       	cp	r22, r18
    4d4e:	71 05       	cpc	r23, r1
    4d50:	81 05       	cpc	r24, r1
    4d52:	91 05       	cpc	r25, r1
    4d54:	33 0b       	sbc	r19, r19
    4d56:	30 fb       	bst	r19, 0
    4d58:	66 f0       	brts	.+24     	; 0x4d72 <__ultoa_common+0x2a>
    4d5a:	aa 27       	eor	r26, r26
    4d5c:	66 0f       	add	r22, r22
    4d5e:	77 1f       	adc	r23, r23
    4d60:	88 1f       	adc	r24, r24
    4d62:	99 1f       	adc	r25, r25
    4d64:	aa 1f       	adc	r26, r26
    4d66:	a2 17       	cp	r26, r18
    4d68:	10 f0       	brcs	.+4      	; 0x4d6e <__ultoa_common+0x26>
    4d6a:	a2 1b       	sub	r26, r18
    4d6c:	63 95       	inc	r22
    4d6e:	38 50       	subi	r19, 0x08	; 8
    4d70:	a9 f7       	brne	.-22     	; 0x4d5c <__ultoa_common+0x14>
    4d72:	a0 5d       	subi	r26, 0xD0	; 208
    4d74:	aa 33       	cpi	r26, 0x3A	; 58
    4d76:	08 f0       	brcs	.+2      	; 0x4d7a <__ultoa_common+0x32>
    4d78:	a9 5d       	subi	r26, 0xD9	; 217
    4d7a:	a1 93       	st	Z+, r26
    4d7c:	36 f7       	brtc	.-52     	; 0x4d4a <__ultoa_common+0x2>
    4d7e:	b1 11       	cpse	r27, r1
    4d80:	b1 93       	st	Z+, r27
    4d82:	10 82       	st	Z, r1
    4d84:	ca 01       	movw	r24, r20
    4d86:	0c 94 ea 26 	jmp	0x4dd4	; 0x4dd4 <strrev>

00004d8a <utoa>:
    4d8a:	45 32       	cpi	r20, 0x25	; 37
    4d8c:	51 05       	cpc	r21, r1
    4d8e:	20 f4       	brcc	.+8      	; 0x4d98 <utoa+0xe>
    4d90:	42 30       	cpi	r20, 0x02	; 2
    4d92:	10 f0       	brcs	.+4      	; 0x4d98 <utoa+0xe>
    4d94:	0c 94 d0 26 	jmp	0x4da0	; 0x4da0 <__utoa_ncheck>
    4d98:	fb 01       	movw	r30, r22
    4d9a:	10 82       	st	Z, r1
    4d9c:	cb 01       	movw	r24, r22
    4d9e:	08 95       	ret

00004da0 <__utoa_ncheck>:
    4da0:	bb 27       	eor	r27, r27

00004da2 <__utoa_common>:
    4da2:	fb 01       	movw	r30, r22
    4da4:	55 27       	eor	r21, r21
    4da6:	aa 27       	eor	r26, r26
    4da8:	88 0f       	add	r24, r24
    4daa:	99 1f       	adc	r25, r25
    4dac:	aa 1f       	adc	r26, r26
    4dae:	a4 17       	cp	r26, r20
    4db0:	10 f0       	brcs	.+4      	; 0x4db6 <__utoa_common+0x14>
    4db2:	a4 1b       	sub	r26, r20
    4db4:	83 95       	inc	r24
    4db6:	50 51       	subi	r21, 0x10	; 16
    4db8:	b9 f7       	brne	.-18     	; 0x4da8 <__utoa_common+0x6>
    4dba:	a0 5d       	subi	r26, 0xD0	; 208
    4dbc:	aa 33       	cpi	r26, 0x3A	; 58
    4dbe:	08 f0       	brcs	.+2      	; 0x4dc2 <__utoa_common+0x20>
    4dc0:	a9 5d       	subi	r26, 0xD9	; 217
    4dc2:	a1 93       	st	Z+, r26
    4dc4:	00 97       	sbiw	r24, 0x00	; 0
    4dc6:	79 f7       	brne	.-34     	; 0x4da6 <__utoa_common+0x4>
    4dc8:	b1 11       	cpse	r27, r1
    4dca:	b1 93       	st	Z+, r27
    4dcc:	11 92       	st	Z+, r1
    4dce:	cb 01       	movw	r24, r22
    4dd0:	0c 94 ea 26 	jmp	0x4dd4	; 0x4dd4 <strrev>

00004dd4 <strrev>:
    4dd4:	dc 01       	movw	r26, r24
    4dd6:	fc 01       	movw	r30, r24
    4dd8:	67 2f       	mov	r22, r23
    4dda:	71 91       	ld	r23, Z+
    4ddc:	77 23       	and	r23, r23
    4dde:	e1 f7       	brne	.-8      	; 0x4dd8 <strrev+0x4>
    4de0:	32 97       	sbiw	r30, 0x02	; 2
    4de2:	04 c0       	rjmp	.+8      	; 0x4dec <strrev+0x18>
    4de4:	7c 91       	ld	r23, X
    4de6:	6d 93       	st	X+, r22
    4de8:	70 83       	st	Z, r23
    4dea:	62 91       	ld	r22, -Z
    4dec:	ae 17       	cp	r26, r30
    4dee:	bf 07       	cpc	r27, r31
    4df0:	c8 f3       	brcs	.-14     	; 0x4de4 <strrev+0x10>
    4df2:	08 95       	ret

00004df4 <_exit>:
    4df4:	f8 94       	cli

00004df6 <__stop_program>:
    4df6:	ff cf       	rjmp	.-2      	; 0x4df6 <__stop_program>
