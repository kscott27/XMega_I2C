
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000048b8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000168  00802000  000048b8  0000494c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  00802168  00802168  00004ab4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004ab4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004ae4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000918  00000000  00000000  00004b24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001852d  00000000  00000000  0000543c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006a5a  00000000  00000000  0001d969  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005df5  00000000  00000000  000243c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b20  00000000  00000000  0002a1b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006b3b  00000000  00000000  0002bcd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008a23  00000000  00000000  00032813  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000878  00000000  00000000  0003b236  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 23 03 	jmp	0x646	; 0x646 <__ctors_end>
       4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
       8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
       c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      10:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      14:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      18:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      1c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      20:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      24:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      28:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      2c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      30:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      34:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      38:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      3c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      40:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      44:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      48:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      4c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      50:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      54:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      58:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <__vector_22>
      5c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      60:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      64:	0c 94 73 1e 	jmp	0x3ce6	; 0x3ce6 <__vector_25>
      68:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      6c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      70:	0c 94 d1 1e 	jmp	0x3da2	; 0x3da2 <__vector_28>
      74:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      78:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      7c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      80:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      84:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      88:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      8c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      90:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      94:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      98:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      9c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      a8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      ac:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      b8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      bc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      c8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      cc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      d8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      dc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      e8:	0c 94 eb 1f 	jmp	0x3fd6	; 0x3fd6 <__vector_58>
      ec:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      f8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
      fc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     100:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     104:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     108:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     10c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     110:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     114:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     118:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     11c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     120:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     124:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     128:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     12c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     130:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     134:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     138:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     13c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     140:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     144:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     148:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     14c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     150:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     154:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     158:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     15c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     160:	0c 94 2f 1f 	jmp	0x3e5e	; 0x3e5e <__vector_88>
     164:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     168:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     16c:	0c 94 8d 1f 	jmp	0x3f1a	; 0x3f1a <__vector_91>
     170:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     174:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     178:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     17c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     180:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     184:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     188:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     18c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     190:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     194:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     198:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     19c:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1a8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1ac:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1b8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1bc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1c8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1cc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1d8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1dc:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1e8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1ec:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f0:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f4:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1f8:	0c 94 59 03 	jmp	0x6b2	; 0x6b2 <__bad_interrupt>
     1fc:	5f 1c       	adc	r5, r15
     1fe:	62 1c       	adc	r6, r2
     200:	65 1c       	adc	r6, r5
     202:	68 1c       	adc	r6, r8
     204:	6b 1c       	adc	r6, r11
     206:	6e 1c       	adc	r6, r14
     208:	70 1c       	adc	r7, r0
     20a:	81 1c       	adc	r8, r1
     20c:	89 1c       	adc	r8, r9
     20e:	93 1c       	adc	r9, r3
     210:	91 1c       	adc	r9, r1

00000212 <__trampolines_start>:
     212:	0c 94 7a 0a 	jmp	0x14f4	; 0x14f4 <_ZN9task_user3runEv>
     216:	0c 94 3d 22 	jmp	0x447a	; 0x447a <_ZN9frt_queueIiE3putERKi>
     21a:	0c 94 55 21 	jmp	0x42aa	; 0x42aa <_ZN9frt_queueIjE7ISR_getEPj>
     21e:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <_ZN14frt_text_queue14check_for_charEv>
     222:	0c 94 ea 1d 	jmp	0x3bd4	; 0x3bd4 <_ZN5rs23212clear_screenEv>
     226:	0c 94 6b 1c 	jmp	0x38d6	; 0x38d6 <_ZN8emstreamlsE15ser_manipulator+0x36>
     22a:	0c 94 e1 07 	jmp	0xfc2	; 0xfc2 <_ZN9frt_queueIhE7butt_inERKh>
     22e:	0c 94 6e 1c 	jmp	0x38dc	; 0x38dc <_ZN8emstreamlsE15ser_manipulator+0x3c>
     232:	0c 94 a7 21 	jmp	0x434e	; 0x434e <_ZN9frt_queueIjE11ISR_butt_inERKj>
     236:	0c 94 68 1c 	jmp	0x38d0	; 0x38d0 <_ZN8emstreamlsE15ser_manipulator+0x30>
     23a:	0c 94 2c 07 	jmp	0xe58	; 0xe58 <_ZN9frt_queueIhE9not_emptyEv>
     23e:	0c 94 e8 22 	jmp	0x45d0	; 0x45d0 <_GLOBAL__sub_I_counter>
     242:	0c 94 37 07 	jmp	0xe6e	; 0xe6e <_ZN9frt_queueIhE8is_emptyEv>
     246:	0c 94 ec 04 	jmp	0x9d8	; 0x9d8 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>
     24a:	0c 94 8a 19 	jmp	0x3314	; 0x3314 <_ZN14frt_text_queue7getcharEv>
     24e:	0c 94 93 1c 	jmp	0x3926	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
     252:	0c 94 66 21 	jmp	0x42cc	; 0x42cc <_ZN9frt_queueIjE7ISR_getEv>
     256:	0c 94 b1 1d 	jmp	0x3b62	; 0x3b62 <_ZN5rs2327getcharEv>
     25a:	0c 94 89 07 	jmp	0xf12	; 0xf12 <_ZN9frt_queueIhE7ISR_getEPh>
     25e:	0c 94 c9 07 	jmp	0xf92	; 0xf92 <_ZN9frt_queueIhE7ISR_putERKh>
     262:	0c 94 49 20 	jmp	0x4092	; 0x4092 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     266:	0c 94 af 20 	jmp	0x415e	; 0x415e <_ZN9frt_queueIiE8is_emptyEv>
     26a:	0c 94 b3 19 	jmp	0x3366	; 0x3366 <_ZN14frt_text_queue7putcharEc>
     26e:	0c 94 48 04 	jmp	0x890	; 0x890 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>
     272:	0c 94 d7 1d 	jmp	0x3bae	; 0x3bae <_ZN5rs23214check_for_charEv>
     276:	0c 94 b9 20 	jmp	0x4172	; 0x4172 <_ZN9frt_queueIjE10get_a_copyERj>
     27a:	0c 94 88 20 	jmp	0x4110	; 0x4110 <_ZN9frt_queueIjE9not_emptyEv>
     27e:	0c 94 c5 20 	jmp	0x418a	; 0x418a <_ZN9frt_queueIjE10get_a_copyEv>
     282:	0c 94 cf 04 	jmp	0x99e	; 0x99e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>
     286:	0c 94 b1 07 	jmp	0xf62	; 0xf62 <_ZN9frt_queueIhE11ISR_butt_inERKh>
     28a:	0c 94 62 1c 	jmp	0x38c4	; 0x38c4 <_ZN8emstreamlsE15ser_manipulator+0x24>
     28e:	0c 94 2b 22 	jmp	0x4456	; 0x4456 <_ZN9frt_queueIiE7butt_inERKi>
     292:	0c 94 9d 20 	jmp	0x413a	; 0x413a <_ZN9frt_queueIiE12num_items_inEv>
     296:	0c 94 a4 20 	jmp	0x4148	; 0x4148 <_ZN9frt_queueIiE9not_emptyEv>
     29a:	0c 94 07 21 	jmp	0x420e	; 0x420e <_ZN9frt_queueIiE10get_a_copyERi>
     29e:	0c 94 bd 03 	jmp	0x77a	; 0x77a <_ZN8I2CAgent11writePacketER7Command>
     2a2:	0c 94 81 20 	jmp	0x4102	; 0x4102 <_ZN9frt_queueIjE12num_items_inEv>
     2a6:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <_ZN8I2CAgent8transmitER7Command>
     2aa:	0c 94 e4 04 	jmp	0x9c8	; 0x9c8 <_ZN9I2CMaster9DoneState7executeER6Packet>
     2ae:	0c 94 79 04 	jmp	0x8f2	; 0x8f2 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>
     2b2:	0c 94 e0 20 	jmp	0x41c0	; 0x41c0 <_ZN9frt_queueIjE3getEPj>
     2b6:	0c 94 1b 07 	jmp	0xe36	; 0xe36 <_ZN9frt_queueIhE12ISR_is_emptyEv>
     2ba:	0c 94 5f 1c 	jmp	0x38be	; 0x38be <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2be:	0c 94 89 1c 	jmp	0x3912	; 0x3912 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2c2:	0c 94 81 1c 	jmp	0x3902	; 0x3902 <_ZN8emstreamlsE15ser_manipulator+0x62>
     2c6:	0c 94 f8 03 	jmp	0x7f0	; 0x7f0 <_ZN9I2CMaster10StartState7executeER6Packet>
     2ca:	0c 94 40 18 	jmp	0x3080	; 0x3080 <_ZN8frt_task12print_statusER8emstream>
     2ce:	0c 94 ef 21 	jmp	0x43de	; 0x43de <_ZN9frt_queueIiE7ISR_putERKi>
     2d2:	0c 94 20 03 	jmp	0x640	; 0x640 <_call_static_run_method>
     2d6:	0c 94 50 20 	jmp	0x40a0	; 0x40a0 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2da:	0c 94 7e 21 	jmp	0x42fc	; 0x42fc <_ZN9frt_queueIiE7ISR_getEPi>
     2de:	0c 94 4d 07 	jmp	0xe9a	; 0xe9a <_ZN9frt_queueIhE10get_a_copyEv>
     2e2:	0c 94 7e 11 	jmp	0x22fc	; 0x22fc <prvIdleTask>
     2e6:	0c 94 fc 06 	jmp	0xdf8	; 0xdf8 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     2ea:	0c 94 93 20 	jmp	0x4126	; 0x4126 <_ZN9frt_queueIjE8is_emptyEv>
     2ee:	0c 94 8f 21 	jmp	0x431e	; 0x431e <_ZN9frt_queueIiE7ISR_getEv>
     2f2:	0c 94 8d 1d 	jmp	0x3b1a	; 0x3b1a <_ZN5rs2327putcharEc>
     2f6:	0c 94 92 03 	jmp	0x724	; 0x724 <_ZN8I2CAgent7receiveEv>
     2fa:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <_ZN9frt_queueIiE3getEv>
     2fe:	0c 94 07 22 	jmp	0x440e	; 0x440e <_ZN9frt_queueIjE7butt_inERKj>
     302:	0c 94 2e 21 	jmp	0x425c	; 0x425c <_ZN9frt_queueIiE3getEPi>
     306:	0c 94 02 1c 	jmp	0x3804	; 0x3804 <_ZN8emstream13ready_to_sendEv>
     30a:	0c 94 09 1c 	jmp	0x3812	; 0x3812 <_ZN8emstream12transmit_nowEv>
     30e:	0c 94 71 07 	jmp	0xee2	; 0xee2 <_ZN9frt_queueIhE3getEv>
     312:	0c 94 04 1c 	jmp	0x3808	; 0x3808 <_ZN8emstream7getcharEv>
     316:	0c 94 65 20 	jmp	0x40ca	; 0x40ca <_ZN9frt_queueIiE16ISR_num_items_inEv>
     31a:	0c 94 07 1c 	jmp	0x380e	; 0x380e <_ZN8emstream14check_for_charEv>
     31e:	0c 94 0a 1c 	jmp	0x3814	; 0x3814 <_ZN8emstream12clear_screenEv>
     322:	0c 94 bf 21 	jmp	0x437e	; 0x437e <_ZN9frt_queueIjE7ISR_putERKj>
     326:	0c 94 91 1c 	jmp	0x3922	; 0x3922 <_ZN8emstreamlsE15ser_manipulator+0x82>
     32a:	0c 94 09 07 	jmp	0xe12	; 0xe12 <_ZN9frt_queueIhE16ISR_num_items_inEv>
     32e:	0c 94 65 1c 	jmp	0x38ca	; 0x38ca <_ZN8emstreamlsE15ser_manipulator+0x2a>
     332:	0c 94 10 07 	jmp	0xe20	; 0xe20 <_ZN9frt_queueIhE13ISR_not_emptyEv>
     336:	0c 94 d7 21 	jmp	0x43ae	; 0x43ae <_ZN9frt_queueIiE11ISR_butt_inERKi>
     33a:	0c 94 25 07 	jmp	0xe4a	; 0xe4a <_ZN9frt_queueIhE12num_items_inEv>
     33e:	0c 94 41 07 	jmp	0xe82	; 0xe82 <_ZN9frt_queueIhE10get_a_copyERh>
     342:	0c 94 dc 08 	jmp	0x11b8	; 0x11b8 <_ZN10task_sonar3runEv>
     346:	0c 94 9a 07 	jmp	0xf34	; 0xf34 <_ZN9frt_queueIhE7ISR_getEv>
     34a:	0c 94 17 04 	jmp	0x82e	; 0x82e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>
     34e:	0c 94 a9 04 	jmp	0x952	; 0x952 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>
     352:	0c 94 6c 20 	jmp	0x40d8	; 0x40d8 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     356:	0c 94 5b 03 	jmp	0x6b6	; 0x6b6 <_ZN8I2CAgent10readPacketEv>
     35a:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <_ZN9frt_queueIhE3putERKh>
     35e:	0c 94 e8 04 	jmp	0x9d0	; 0x9d0 <_ZN9I2CMaster10ErrorState7executeER6Packet>
     362:	0c 94 ec 20 	jmp	0x41d8	; 0x41d8 <_ZN9frt_queueIjE3getEv>
     366:	0c 94 65 07 	jmp	0xeca	; 0xeca <_ZN9frt_queueIhE3getEPh>
     36a:	0c 94 6b 1b 	jmp	0x36d6	; 0x36d6 <__cxa_pure_virtual>
     36e:	0c 94 13 21 	jmp	0x4226	; 0x4226 <_ZN9frt_queueIiE10get_a_copyEv>
     372:	0c 94 19 22 	jmp	0x4432	; 0x4432 <_ZN9frt_queueIjE3putERKj>
     376:	0c 94 77 20 	jmp	0x40ee	; 0x40ee <_ZN9frt_queueIiE12ISR_is_emptyEv>
     37a:	0c 94 66 03 	jmp	0x6cc	; 0x6cc <_ZN8I2CAgent11resetPacketER6Packet>
     37e:	0c 94 70 1c 	jmp	0x38e0	; 0x38e0 <_ZN8emstreamlsE15ser_manipulator+0x40>
     382:	0c 94 5b 20 	jmp	0x40b6	; 0x40b6 <_ZN9frt_queueIjE12ISR_is_emptyEv>

00000386 <__trampolines_end>:
     386:	53 6f       	ori	r21, 0xF3	; 243
     388:	6e 61       	ori	r22, 0x1E	; 30
     38a:	72 3a       	cpi	r23, 0xA2	; 162
     38c:	20 00       	.word	0x0020	; ????

0000038e <_ZZN9task_user11show_statusEvE3__c_4>:
     38e:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

00000399 <_ZZN9task_user11show_statusEvE3__c_3>:
     399:	2f 00                                               /.

0000039b <_ZZN9task_user11show_statusEvE3__c_2>:
     39b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000003a9 <_ZZN9task_user11show_statusEvE3__c_1>:
     3a9:	54 69 6d 65 3a 20 00                                Time: .

000003b0 <_ZZN9task_user11show_statusEvE3__c_0>:
     3b0:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

000003bc <_ZZN9task_user11show_statusEvE3__c>:
     3bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003db <_ZZN9task_user18print_help_messageEvE3__c_10>:
     3db:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000003ea <_ZZN9task_user18print_help_messageEvE3__c_9>:
     3ea:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     3fa:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000405 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     405:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     415:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

00000423 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     423:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     433:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     443:	6d 61 74 69 6f 6e 00                                mation.

0000044a <_ZZN9task_user18print_help_messageEvE3__c_6>:
     44a:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     45a:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000046b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     46b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     47b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000483 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     483:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     493:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000049f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     49f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     4af:	68 65 20 41 56 52 00                                he AVR.

000004b6 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     4b6:	20 68 65 6c 70 00                                    help.

000004bc <_ZZN9task_user18print_help_messageEvE3__c_1>:
     4bc:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     4cc:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000004db <_ZZN9task_user18print_help_messageEvE3__c_0>:
     4db:	1b 5b 33 30 6d 00                                   .[30m.

000004e1 <_ZZN9task_user18print_help_messageEvE3__c>:
     4e1:	1b 5b 34 36 6d 00                                   .[46m.

000004e7 <_ZZN9task_user3runEvE3__c_3>:
     4e7:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     4f7:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000504 <_ZZN9task_user3runEvE3__c_2>:
     504:	3a 57 54 46 3f 00                                   :WTF?.

0000050a <_ZZN9task_user3runEvE3__c_1>:
     50a:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     51a:	65 00                                               e.

0000051c <_ZZN9task_user3runEvE3__c_0>:
     51c:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

0000052a <_ZZN9task_user3runEvE3__c>:
     52a:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     53a:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000548 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     548:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

00000552 <_ZZN8frt_task15emergency_resetEvE3__c>:
     552:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000561 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     561:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     571:	61 73 6b 20 00                                      ask .

00000576 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     576:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000584 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     584:	20 63 72 65 61 74 65 64 00                           created.

0000058d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     58d:	54 61 73 6b 20 00                                   Task .

00000593 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     593:	1b 5b 32 32 6d 00                                   .[22m.

00000599 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     599:	54 61 73 6b 3a 20 00                                Task: .

000005a0 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     5a0:	1b 5b 31 6d 00                                      .[1m.

000005a5 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     5a5:	1b 5b 32 32 6d 00                                   .[22m.

000005ab <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     5ab:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000005b6 <_ZZ17print_task_stacksP8emstreamE3__c>:
     5b6:	1b 5b 31 6d 00                                      .[1m.

000005bb <_ZZ15print_task_listP8emstreamE3__c_9>:
     5bb:	09 09 00                                            ...

000005be <_ZZ15print_task_listP8emstreamE3__c_8>:
     5be:	2f 00                                               /.

000005c0 <_ZZ15print_task_listP8emstreamE3__c_7>:
     5c0:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000005cb <_ZZ15print_task_listP8emstreamE3__c_6>:
     5cb:	09 2d 2d 2d 2d 00                                   .----.

000005d1 <_ZZ15print_task_listP8emstreamE3__c_5>:
     5d1:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000005dd <_ZZ15print_task_listP8emstreamE3__c_4>:
     5dd:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000005ee <_ZZ15print_task_listP8emstreamE3__c_3>:
     5ee:	09 52 75 6e 73 00                                   .Runs.

000005f4 <_ZZ15print_task_listP8emstreamE3__c_2>:
     5f4:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000600 <_ZZ15print_task_listP8emstreamE3__c_1>:
     600:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

00000611 <_ZZ15print_task_listP8emstreamE3__c_0>:
     611:	09 53 74 61 63 6b 00                                .Stack.

00000618 <_ZZ15print_task_listP8emstreamE3__c>:
     618:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

00000623 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     623:	09 00                                               ..

00000625 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     625:	09 00                                               ..

00000627 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     627:	2f 00                                               /.

00000629 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     629:	09 00                                               ..

0000062b <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     62b:	09 00                                               ..

0000062d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     62d:	1b 5b 32 32 6d 00                                   .[22m.

00000633 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     633:	1b 5b 31 6d 00                                      .[1m.

00000638 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     638:	1b 5b 31 6d 00                                      .[1m.

0000063d <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     63d:	20 20 00                                              .

00000640 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     640:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <_ZN8frt_task22_call_users_run_methodEPS_>

00000644 <__ctors_start>:
     644:	e8 22       	and	r14, r24

00000646 <__ctors_end>:
     646:	11 24       	eor	r1, r1
     648:	1f be       	out	0x3f, r1	; 63
     64a:	cf ef       	ldi	r28, 0xFF	; 255
     64c:	cd bf       	out	0x3d, r28	; 61
     64e:	df e3       	ldi	r29, 0x3F	; 63
     650:	de bf       	out	0x3e, r29	; 62
     652:	00 e0       	ldi	r16, 0x00	; 0
     654:	0c bf       	out	0x3c, r16	; 60
     656:	18 be       	out	0x38, r1	; 56
     658:	19 be       	out	0x39, r1	; 57
     65a:	1a be       	out	0x3a, r1	; 58
     65c:	1b be       	out	0x3b, r1	; 59

0000065e <__do_copy_data>:
     65e:	11 e2       	ldi	r17, 0x21	; 33
     660:	a0 e0       	ldi	r26, 0x00	; 0
     662:	b0 e2       	ldi	r27, 0x20	; 32
     664:	e8 eb       	ldi	r30, 0xB8	; 184
     666:	f8 e4       	ldi	r31, 0x48	; 72
     668:	00 e0       	ldi	r16, 0x00	; 0
     66a:	0b bf       	out	0x3b, r16	; 59
     66c:	02 c0       	rjmp	.+4      	; 0x672 <__do_copy_data+0x14>
     66e:	07 90       	elpm	r0, Z+
     670:	0d 92       	st	X+, r0
     672:	a8 36       	cpi	r26, 0x68	; 104
     674:	b1 07       	cpc	r27, r17
     676:	d9 f7       	brne	.-10     	; 0x66e <__do_copy_data+0x10>
     678:	1b be       	out	0x3b, r1	; 59

0000067a <__do_clear_bss>:
     67a:	22 e3       	ldi	r18, 0x32	; 50
     67c:	a8 e6       	ldi	r26, 0x68	; 104
     67e:	b1 e2       	ldi	r27, 0x21	; 33
     680:	01 c0       	rjmp	.+2      	; 0x684 <.do_clear_bss_start>

00000682 <.do_clear_bss_loop>:
     682:	1d 92       	st	X+, r1

00000684 <.do_clear_bss_start>:
     684:	a6 33       	cpi	r26, 0x36	; 54
     686:	b2 07       	cpc	r27, r18
     688:	e1 f7       	brne	.-8      	; 0x682 <.do_clear_bss_loop>

0000068a <__do_global_ctors>:
     68a:	13 e0       	ldi	r17, 0x03	; 3
     68c:	c3 e2       	ldi	r28, 0x23	; 35
     68e:	d3 e0       	ldi	r29, 0x03	; 3
     690:	00 e0       	ldi	r16, 0x00	; 0
     692:	06 c0       	rjmp	.+12     	; 0x6a0 <__do_global_ctors+0x16>
     694:	21 97       	sbiw	r28, 0x01	; 1
     696:	01 09       	sbc	r16, r1
     698:	80 2f       	mov	r24, r16
     69a:	fe 01       	movw	r30, r28
     69c:	0e 94 b6 23 	call	0x476c	; 0x476c <__tablejump2__>
     6a0:	c2 32       	cpi	r28, 0x22	; 34
     6a2:	d1 07       	cpc	r29, r17
     6a4:	80 e0       	ldi	r24, 0x00	; 0
     6a6:	08 07       	cpc	r16, r24
     6a8:	a9 f7       	brne	.-22     	; 0x694 <__do_global_ctors+0xa>
     6aa:	0e 94 64 22 	call	0x44c8	; 0x44c8 <main>
     6ae:	0c 94 5a 24 	jmp	0x48b4	; 0x48b4 <_exit>

000006b2 <__bad_interrupt>:
     6b2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006b6 <_ZN8I2CAgent10readPacketEv>:
  cmd.writePacket(outPacket_);
}

void I2CAgent::readPacket()
{
  resetPacket(inPacket_);
     6b6:	bc 01       	movw	r22, r24
     6b8:	6e 5f       	subi	r22, 0xFE	; 254
     6ba:	7f 4f       	sbci	r23, 0xFF	; 255
     6bc:	dc 01       	movw	r26, r24
     6be:	ed 91       	ld	r30, X+
     6c0:	fc 91       	ld	r31, X
     6c2:	00 84       	ldd	r0, Z+8	; 0x08
     6c4:	f1 85       	ldd	r31, Z+9	; 0x09
     6c6:	e0 2d       	mov	r30, r0
     6c8:	19 95       	eicall
     6ca:	08 95       	ret

000006cc <_ZN8I2CAgent11resetPacketER6Packet>:
}

void I2CAgent::resetPacket( Packet & packet )
{
     6cc:	cf 93       	push	r28
     6ce:	df 93       	push	r29
     6d0:	eb 01       	movw	r28, r22
  while( packet.not_empty() )
     6d2:	e8 81       	ld	r30, Y
     6d4:	f9 81       	ldd	r31, Y+1	; 0x01
     6d6:	00 8c       	ldd	r0, Z+24	; 0x18
     6d8:	f1 8d       	ldd	r31, Z+25	; 0x19
     6da:	e0 2d       	mov	r30, r0
     6dc:	ce 01       	movw	r24, r28
     6de:	19 95       	eicall
     6e0:	88 23       	and	r24, r24
     6e2:	41 f0       	breq	.+16     	; 0x6f4 <_ZN8I2CAgent11resetPacketER6Packet+0x28>
  {
    packet.get();
     6e4:	e8 81       	ld	r30, Y
     6e6:	f9 81       	ldd	r31, Y+1	; 0x01
     6e8:	00 84       	ldd	r0, Z+8	; 0x08
     6ea:	f1 85       	ldd	r31, Z+9	; 0x09
     6ec:	e0 2d       	mov	r30, r0
     6ee:	ce 01       	movw	r24, r28
     6f0:	19 95       	eicall
  resetPacket(inPacket_);
}

void I2CAgent::resetPacket( Packet & packet )
{
  while( packet.not_empty() )
     6f2:	ef cf       	rjmp	.-34     	; 0x6d2 <_ZN8I2CAgent11resetPacketER6Packet+0x6>
  {
    packet.get();
  }
}
     6f4:	df 91       	pop	r29
     6f6:	cf 91       	pop	r28
     6f8:	08 95       	ret

000006fa <_ZN8I2CAgent8transmitER7Command>:
#include "I2CAgent.h"

bool I2CAgent::transmit( Command & cmd )
{
     6fa:	cf 93       	push	r28
     6fc:	df 93       	push	r29
     6fe:	ec 01       	movw	r28, r24
  writePacket(cmd);
     700:	e8 81       	ld	r30, Y
     702:	f9 81       	ldd	r31, Y+1	; 0x01
     704:	04 80       	ldd	r0, Z+4	; 0x04
     706:	f5 81       	ldd	r31, Z+5	; 0x05
     708:	e0 2d       	mov	r30, r0
     70a:	19 95       	eicall
  bool status = driver_->getTransmitter()->run(outPacket_);
     70c:	be 01       	movw	r22, r28
     70e:	63 5f       	subi	r22, 0xF3	; 243
     710:	7f 4f       	sbci	r23, 0xFF	; 255

  };
  
  I2CMaster(TWI_t * interface, uint32_t i2c_freq);

  Transmitter * getTransmitter()  { return transmitter_; }
     712:	e8 8d       	ldd	r30, Y+24	; 0x18
     714:	f9 8d       	ldd	r31, Y+25	; 0x19
     716:	80 81       	ld	r24, Z
     718:	91 81       	ldd	r25, Z+1	; 0x01
     71a:	0e 94 3a 06 	call	0xc74	; 0xc74 <_ZN9I2CMaster11Transmitter3runER6Packet>
  return status;
}
     71e:	df 91       	pop	r29
     720:	cf 91       	pop	r28
     722:	08 95       	ret

00000724 <_ZN8I2CAgent7receiveEv>:

Packet & I2CAgent::receive()
{
     724:	ef 92       	push	r14
     726:	ff 92       	push	r15
     728:	0f 93       	push	r16
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	ec 01       	movw	r28, r24
  resetPacket(inPacket_);
     730:	7c 01       	movw	r14, r24
     732:	82 e0       	ldi	r24, 0x02	; 2
     734:	e8 0e       	add	r14, r24
     736:	f1 1c       	adc	r15, r1
     738:	e8 81       	ld	r30, Y
     73a:	f9 81       	ldd	r31, Y+1	; 0x01
     73c:	00 84       	ldd	r0, Z+8	; 0x08
     73e:	f1 85       	ldd	r31, Z+9	; 0x09
     740:	e0 2d       	mov	r30, r0
     742:	b7 01       	movw	r22, r14
     744:	ce 01       	movw	r24, r28
     746:	19 95       	eicall
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
     748:	28 85       	ldd	r18, Y+8	; 0x08
     74a:	39 85       	ldd	r19, Y+9	; 0x09
     74c:	4a 85       	ldd	r20, Y+10	; 0x0a
     74e:	5b 85       	ldd	r21, Y+11	; 0x0b
  inPacket_.put(readCommand_);
     750:	be 01       	movw	r22, r28
     752:	64 5e       	subi	r22, 0xE4	; 228
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	00 e0       	ldi	r16, 0x00	; 0
     758:	8e 81       	ldd	r24, Y+6	; 0x06
     75a:	9f 81       	ldd	r25, Y+7	; 0x07
     75c:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
  Receiver *    getReceiver()     { return receiver_; }
     760:	e8 8d       	ldd	r30, Y+24	; 0x18
     762:	f9 8d       	ldd	r31, Y+25	; 0x19
  return driver_->getReceiver()->run(inPacket_);
     764:	b7 01       	movw	r22, r14
     766:	82 81       	ldd	r24, Z+2	; 0x02
     768:	93 81       	ldd	r25, Z+3	; 0x03
     76a:	0e 94 61 06 	call	0xcc2	; 0xcc2 <_ZN9I2CMaster8Receiver3runER6Packet>
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	0f 91       	pop	r16
     774:	ff 90       	pop	r15
     776:	ef 90       	pop	r14
     778:	08 95       	ret

0000077a <_ZN8I2CAgent11writePacketER7Command>:
  writeCommand_ = addr << 1;
  readCommand_ = addr << 1 | 1 << 0;
}

void I2CAgent::writePacket( Command & cmd )
{
     77a:	cf 92       	push	r12
     77c:	df 92       	push	r13
     77e:	ef 92       	push	r14
     780:	ff 92       	push	r15
     782:	0f 93       	push	r16
     784:	cf 93       	push	r28
     786:	df 93       	push	r29
     788:	ec 01       	movw	r28, r24
     78a:	7b 01       	movw	r14, r22
  resetPacket(outPacket_);
     78c:	6c 01       	movw	r12, r24
     78e:	8d e0       	ldi	r24, 0x0D	; 13
     790:	c8 0e       	add	r12, r24
     792:	d1 1c       	adc	r13, r1
     794:	e8 81       	ld	r30, Y
     796:	f9 81       	ldd	r31, Y+1	; 0x01
     798:	00 84       	ldd	r0, Z+8	; 0x08
     79a:	f1 85       	ldd	r31, Z+9	; 0x09
     79c:	e0 2d       	mov	r30, r0
     79e:	b6 01       	movw	r22, r12
     7a0:	ce 01       	movw	r24, r28
     7a2:	19 95       	eicall
     7a4:	2b 89       	ldd	r18, Y+19	; 0x13
     7a6:	3c 89       	ldd	r19, Y+20	; 0x14
     7a8:	4d 89       	ldd	r20, Y+21	; 0x15
     7aa:	5e 89       	ldd	r21, Y+22	; 0x16
  outPacket_.put(writeCommand_);
     7ac:	be 01       	movw	r22, r28
     7ae:	65 5e       	subi	r22, 0xE5	; 229
     7b0:	7f 4f       	sbci	r23, 0xFF	; 255
     7b2:	00 e0       	ldi	r16, 0x00	; 0
     7b4:	89 89       	ldd	r24, Y+17	; 0x11
     7b6:	9a 89       	ldd	r25, Y+18	; 0x12
     7b8:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
  cmd.writePacket(outPacket_);
     7bc:	d7 01       	movw	r26, r14
     7be:	ed 91       	ld	r30, X+
     7c0:	fc 91       	ld	r31, X
     7c2:	01 90       	ld	r0, Z+
     7c4:	f0 81       	ld	r31, Z
     7c6:	e0 2d       	mov	r30, r0
     7c8:	b6 01       	movw	r22, r12
     7ca:	c7 01       	movw	r24, r14
     7cc:	19 95       	eicall
}
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	0f 91       	pop	r16
     7d4:	ff 90       	pop	r15
     7d6:	ef 90       	pop	r14
     7d8:	df 90       	pop	r13
     7da:	cf 90       	pop	r12
     7dc:	08 95       	ret

000007de <_ZN8I2CAgent12setSlaveAddrEh>:
  inPacket_.put(readCommand_);
  return driver_->getReceiver()->run(inPacket_);
}

void I2CAgent::setSlaveAddr( uint8_t addr )
{
     7de:	fc 01       	movw	r30, r24
  slaveAddr_ = addr;
     7e0:	62 8f       	std	Z+26, r22	; 0x1a
  writeCommand_ = addr << 1;
     7e2:	86 2f       	mov	r24, r22
     7e4:	88 0f       	add	r24, r24
     7e6:	83 8f       	std	Z+27, r24	; 0x1b
  readCommand_ = addr << 1 | 1 << 0;
     7e8:	68 2f       	mov	r22, r24
     7ea:	61 60       	ori	r22, 0x01	; 1
     7ec:	64 8f       	std	Z+28, r22	; 0x1c
     7ee:	08 95       	ret

000007f0 <_ZN9I2CMaster10StartState7executeER6Packet>:

  return packet;
}

I2CMaster::State * I2CMaster::StartState::execute( Packet & packet )
{
     7f0:	0f 93       	push	r16
     7f2:	1f 93       	push	r17
     7f4:	cf 93       	push	r28
     7f6:	df 93       	push	r29
     7f8:	ec 01       	movw	r28, r24
     7fa:	cb 01       	movw	r24, r22
  uint8_t * startCommand;
  packet.get(startCommand);
     7fc:	db 01       	movw	r26, r22
     7fe:	ed 91       	ld	r30, X+
     800:	fc 91       	ld	r31, X
     802:	02 84       	ldd	r0, Z+10	; 0x0a
     804:	f3 85       	ldd	r31, Z+11	; 0x0b
     806:	e0 2d       	mov	r30, r0
     808:	00 e0       	ldi	r16, 0x00	; 0
     80a:	10 e0       	ldi	r17, 0x00	; 0
     80c:	b8 01       	movw	r22, r16
     80e:	19 95       	eicall
  TWI_t *       getInterfacePtr() { return interface_; }
     810:	ef 81       	ldd	r30, Y+7	; 0x07
     812:	f8 85       	ldd	r31, Y+8	; 0x08
     814:	04 80       	ldd	r0, Z+4	; 0x04
     816:	f5 81       	ldd	r31, Z+5	; 0x05
     818:	e0 2d       	mov	r30, r0
  driver_->getInterfacePtr()->MASTER.ADDR = *startCommand;
     81a:	d8 01       	movw	r26, r16
     81c:	8c 91       	ld	r24, X
     81e:	86 83       	std	Z+6, r24	; 0x06
  return nextState_;
}
     820:	8a 81       	ldd	r24, Y+2	; 0x02
     822:	9b 81       	ldd	r25, Y+3	; 0x03
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	1f 91       	pop	r17
     82a:	0f 91       	pop	r16
     82c:	08 95       	ret

0000082e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::StatusState::execute( Packet & packet )
{
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	1f 92       	push	r1
     834:	1f 92       	push	r1
     836:	cd b7       	in	r28, 0x3d	; 61
     838:	de b7       	in	r29, 0x3e	; 62
     83a:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     83c:	19 96       	adiw	r26, 0x09	; 9
     83e:	8d 91       	ld	r24, X+
     840:	9c 91       	ld	r25, X
     842:	1a 97       	sbiw	r26, 0x0a	; 10
     844:	89 83       	std	Y+1, r24	; 0x01
     846:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_WIF_bm)) ){ }
     848:	29 81       	ldd	r18, Y+1	; 0x01
     84a:	3a 81       	ldd	r19, Y+2	; 0x02
     84c:	21 50       	subi	r18, 0x01	; 1
     84e:	31 09       	sbc	r19, r1
     850:	29 83       	std	Y+1, r18	; 0x01
     852:	3a 83       	std	Y+2, r19	; 0x02
     854:	23 2b       	or	r18, r19
     856:	51 f0       	breq	.+20     	; 0x86c <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x3e>
     858:	17 96       	adiw	r26, 0x07	; 7
     85a:	ed 91       	ld	r30, X+
     85c:	fc 91       	ld	r31, X
     85e:	18 97       	sbiw	r26, 0x08	; 8
     860:	04 80       	ldd	r0, Z+4	; 0x04
     862:	f5 81       	ldd	r31, Z+5	; 0x05
     864:	e0 2d       	mov	r30, r0
     866:	94 81       	ldd	r25, Z+4	; 0x04
     868:	90 75       	andi	r25, 0x50	; 80
     86a:	71 f7       	brne	.-36     	; 0x848 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x1a>
  if( counter == 0 )
     86c:	89 81       	ldd	r24, Y+1	; 0x01
     86e:	9a 81       	ldd	r25, Y+2	; 0x02
     870:	89 2b       	or	r24, r25
     872:	29 f4       	brne	.+10     	; 0x87e <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x50>
  {
    return returnState_;
     874:	14 96       	adiw	r26, 0x04	; 4
     876:	8d 91       	ld	r24, X+
     878:	9c 91       	ld	r25, X
     87a:	15 97       	sbiw	r26, 0x05	; 5
     87c:	04 c0       	rjmp	.+8      	; 0x886 <_ZN9I2CMaster11Transmitter11StatusState7executeER6Packet+0x58>
  }
  else
  {
    return nextState_;
     87e:	12 96       	adiw	r26, 0x02	; 2
     880:	8d 91       	ld	r24, X+
     882:	9c 91       	ld	r25, X
     884:	13 97       	sbiw	r26, 0x03	; 3
  }
}
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	08 95       	ret

00000890 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::StatusState::execute( Packet & packet )
{
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	1f 92       	push	r1
     896:	1f 92       	push	r1
     898:	cd b7       	in	r28, 0x3d	; 61
     89a:	de b7       	in	r29, 0x3e	; 62
     89c:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  counter = timeout_;
     89e:	19 96       	adiw	r26, 0x09	; 9
     8a0:	8d 91       	ld	r24, X+
     8a2:	9c 91       	ld	r25, X
     8a4:	1a 97       	sbiw	r26, 0x0a	; 10
     8a6:	89 83       	std	Y+1, r24	; 0x01
     8a8:	9a 83       	std	Y+2, r25	; 0x02
  // Need to figure out which status bit to be checking
  while( (--counter != 0) && (driver_->getInterfacePtr()->MASTER.STATUS & (TWI_MASTER_RXACK_bm | TWI_MASTER_RIF_bm)) ){ }
     8aa:	29 81       	ldd	r18, Y+1	; 0x01
     8ac:	3a 81       	ldd	r19, Y+2	; 0x02
     8ae:	21 50       	subi	r18, 0x01	; 1
     8b0:	31 09       	sbc	r19, r1
     8b2:	29 83       	std	Y+1, r18	; 0x01
     8b4:	3a 83       	std	Y+2, r19	; 0x02
     8b6:	23 2b       	or	r18, r19
     8b8:	51 f0       	breq	.+20     	; 0x8ce <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x3e>
     8ba:	17 96       	adiw	r26, 0x07	; 7
     8bc:	ed 91       	ld	r30, X+
     8be:	fc 91       	ld	r31, X
     8c0:	18 97       	sbiw	r26, 0x08	; 8
     8c2:	04 80       	ldd	r0, Z+4	; 0x04
     8c4:	f5 81       	ldd	r31, Z+5	; 0x05
     8c6:	e0 2d       	mov	r30, r0
     8c8:	94 81       	ldd	r25, Z+4	; 0x04
     8ca:	90 79       	andi	r25, 0x90	; 144
     8cc:	71 f7       	brne	.-36     	; 0x8aa <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x1a>
  if( counter == 0 ) {
     8ce:	89 81       	ldd	r24, Y+1	; 0x01
     8d0:	9a 81       	ldd	r25, Y+2	; 0x02
     8d2:	89 2b       	or	r24, r25
     8d4:	29 f4       	brne	.+10     	; 0x8e0 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x50>
    return returnState_; }
     8d6:	14 96       	adiw	r26, 0x04	; 4
     8d8:	8d 91       	ld	r24, X+
     8da:	9c 91       	ld	r25, X
     8dc:	15 97       	sbiw	r26, 0x05	; 5
     8de:	04 c0       	rjmp	.+8      	; 0x8e8 <_ZN9I2CMaster8Receiver11StatusState7executeER6Packet+0x58>
  else {
    return nextState_; }
     8e0:	12 96       	adiw	r26, 0x02	; 2
     8e2:	8d 91       	ld	r24, X+
     8e4:	9c 91       	ld	r25, X
     8e6:	13 97       	sbiw	r26, 0x03	; 3
}
     8e8:	0f 90       	pop	r0
     8ea:	0f 90       	pop	r0
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	08 95       	ret

000008f2 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::ExchangeState::execute( Packet & packet )
{
     8f2:	ef 92       	push	r14
     8f4:	ff 92       	push	r15
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	8c 01       	movw	r16, r24
     900:	eb 01       	movw	r28, r22
  if( packet.not_empty() )
     902:	e8 81       	ld	r30, Y
     904:	f9 81       	ldd	r31, Y+1	; 0x01
     906:	00 8c       	ldd	r0, Z+24	; 0x18
     908:	f1 8d       	ldd	r31, Z+25	; 0x19
     90a:	e0 2d       	mov	r30, r0
     90c:	cb 01       	movw	r24, r22
     90e:	19 95       	eicall
     910:	88 23       	and	r24, r24
     912:	a9 f0       	breq	.+42     	; 0x93e <_ZN9I2CMaster11Transmitter13ExchangeState7executeER6Packet+0x4c>
  {
    uint8_t * data; 
    packet.get(data);
     914:	e8 81       	ld	r30, Y
     916:	f9 81       	ldd	r31, Y+1	; 0x01
     918:	02 84       	ldd	r0, Z+10	; 0x0a
     91a:	f3 85       	ldd	r31, Z+11	; 0x0b
     91c:	e0 2d       	mov	r30, r0
     91e:	e1 2c       	mov	r14, r1
     920:	f1 2c       	mov	r15, r1
     922:	b7 01       	movw	r22, r14
     924:	ce 01       	movw	r24, r28
     926:	19 95       	eicall
     928:	d8 01       	movw	r26, r16
     92a:	17 96       	adiw	r26, 0x07	; 7
     92c:	ed 91       	ld	r30, X+
     92e:	fc 91       	ld	r31, X
     930:	18 97       	sbiw	r26, 0x08	; 8
     932:	04 80       	ldd	r0, Z+4	; 0x04
     934:	f5 81       	ldd	r31, Z+5	; 0x05
     936:	e0 2d       	mov	r30, r0
    driver_->getInterfacePtr()->MASTER.DATA = *data;
     938:	d7 01       	movw	r26, r14
     93a:	8c 91       	ld	r24, X
     93c:	87 83       	std	Z+7, r24	; 0x07
  }
  return nextState_;
}
     93e:	f8 01       	movw	r30, r16
     940:	82 81       	ldd	r24, Z+2	; 0x02
     942:	93 81       	ldd	r25, Z+3	; 0x03
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	1f 91       	pop	r17
     94a:	0f 91       	pop	r16
     94c:	ff 90       	pop	r15
     94e:	ef 90       	pop	r14
     950:	08 95       	ret

00000952 <_ZN9I2CMaster8Receiver13ExchangeState7executeER6Packet>:

I2CMaster::State * I2CMaster::Receiver::ExchangeState::execute( Packet & packet )
{
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	cf 93       	push	r28
     958:	df 93       	push	r29
     95a:	1f 92       	push	r1
     95c:	cd b7       	in	r28, 0x3d	; 61
     95e:	de b7       	in	r29, 0x3e	; 62
     960:	8c 01       	movw	r16, r24
     962:	cb 01       	movw	r24, r22
     964:	d8 01       	movw	r26, r16
     966:	17 96       	adiw	r26, 0x07	; 7
     968:	ed 91       	ld	r30, X+
     96a:	fc 91       	ld	r31, X
     96c:	18 97       	sbiw	r26, 0x08	; 8
     96e:	04 80       	ldd	r0, Z+4	; 0x04
     970:	f5 81       	ldd	r31, Z+5	; 0x05
     972:	e0 2d       	mov	r30, r0
  uint8_t data = driver_->getInterfacePtr()->MASTER.DATA;
     974:	27 81       	ldd	r18, Z+7	; 0x07
     976:	29 83       	std	Y+1, r18	; 0x01
  packet.put(data);
     978:	db 01       	movw	r26, r22
     97a:	ed 91       	ld	r30, X+
     97c:	fc 91       	ld	r31, X
     97e:	01 90       	ld	r0, Z+
     980:	f0 81       	ld	r31, Z
     982:	e0 2d       	mov	r30, r0
     984:	be 01       	movw	r22, r28
     986:	6f 5f       	subi	r22, 0xFF	; 255
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	19 95       	eicall
  return nextState_;
}
     98c:	f8 01       	movw	r30, r16
     98e:	82 81       	ldd	r24, Z+2	; 0x02
     990:	93 81       	ldd	r25, Z+3	; 0x03
     992:	0f 90       	pop	r0
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet>:

I2CMaster::State * I2CMaster::Transmitter::PacketStatusState::execute( Packet & packet )
{
     99e:	cf 93       	push	r28
     9a0:	df 93       	push	r29
     9a2:	ec 01       	movw	r28, r24
     9a4:	cb 01       	movw	r24, r22
  if( packet.is_empty() )
     9a6:	db 01       	movw	r26, r22
     9a8:	ed 91       	ld	r30, X+
     9aa:	fc 91       	ld	r31, X
     9ac:	04 88       	ldd	r0, Z+20	; 0x14
     9ae:	f5 89       	ldd	r31, Z+21	; 0x15
     9b0:	e0 2d       	mov	r30, r0
     9b2:	19 95       	eicall
     9b4:	88 23       	and	r24, r24
     9b6:	19 f0       	breq	.+6      	; 0x9be <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x20>
  {
    return nextState_;
     9b8:	8a 81       	ldd	r24, Y+2	; 0x02
     9ba:	9b 81       	ldd	r25, Y+3	; 0x03
     9bc:	02 c0       	rjmp	.+4      	; 0x9c2 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER6Packet+0x24>
  }
  else
  {
    return returnState_;
     9be:	8c 81       	ldd	r24, Y+4	; 0x04
     9c0:	9d 81       	ldd	r25, Y+5	; 0x05
  }
}
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	08 95       	ret

000009c8 <_ZN9I2CMaster9DoneState7executeER6Packet>:
}

I2CMaster::State * I2CMaster::DoneState::execute( Packet & packet )
{
  return nextState_;
}
     9c8:	fc 01       	movw	r30, r24
     9ca:	82 81       	ldd	r24, Z+2	; 0x02
     9cc:	93 81       	ldd	r25, Z+3	; 0x03
     9ce:	08 95       	ret

000009d0 <_ZN9I2CMaster10ErrorState7executeER6Packet>:

I2CMaster::State * I2CMaster::ErrorState::execute( Packet & packet )
{
  return nextState_;
}
     9d0:	fc 01       	movw	r30, r24
     9d2:	82 81       	ldd	r24, Z+2	; 0x02
     9d4:	93 81       	ldd	r25, Z+3	; 0x03
     9d6:	08 95       	ret

000009d8 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet>:
    return returnState_;
  }
}

I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
     9d8:	0f 93       	push	r16
     9da:	1f 93       	push	r17
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
     9e0:	8c 01       	movw	r16, r24
     9e2:	eb 01       	movw	r28, r22
  if( packet.num_items_in() == packet.getSize() ) {
     9e4:	e8 81       	ld	r30, Y
     9e6:	f9 81       	ldd	r31, Y+1	; 0x01
     9e8:	04 8c       	ldd	r0, Z+28	; 0x1c
     9ea:	f5 8d       	ldd	r31, Z+29	; 0x1d
     9ec:	e0 2d       	mov	r30, r0
     9ee:	cb 01       	movw	r24, r22
     9f0:	19 95       	eicall
     9f2:	2a 85       	ldd	r18, Y+10	; 0x0a
     9f4:	30 e0       	ldi	r19, 0x00	; 0
     9f6:	82 17       	cp	r24, r18
     9f8:	93 07       	cpc	r25, r19
     9fa:	79 f4       	brne	.+30     	; 0xa1a <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x42>
  interface_->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
}

void I2CMaster::send_ack_stop(void)
{
  interface_->MASTER.CTRLC = (1<<TWI_MASTER_CMD1_bp) | (1<<TWI_MASTER_CMD0_bp);
     9fc:	d8 01       	movw	r26, r16
     9fe:	17 96       	adiw	r26, 0x07	; 7
     a00:	ed 91       	ld	r30, X+
     a02:	fc 91       	ld	r31, X
     a04:	18 97       	sbiw	r26, 0x08	; 8
     a06:	04 80       	ldd	r0, Z+4	; 0x04
     a08:	f5 81       	ldd	r31, Z+5	; 0x05
     a0a:	e0 2d       	mov	r30, r0
     a0c:	83 e0       	ldi	r24, 0x03	; 3
     a0e:	83 83       	std	Z+3, r24	; 0x03

I2CMaster::State * I2CMaster::Receiver::PacketStatusState::execute( Packet & packet )
{
  if( packet.num_items_in() == packet.getSize() ) {
    driver_->send_ack_stop();
    return nextState_; }
     a10:	12 96       	adiw	r26, 0x02	; 2
     a12:	8d 91       	ld	r24, X+
     a14:	9c 91       	ld	r25, X
     a16:	13 97       	sbiw	r26, 0x03	; 3
     a18:	0e c0       	rjmp	.+28     	; 0xa36 <_ZN9I2CMaster8Receiver17PacketStatusState7executeER6Packet+0x5e>
  interface_->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
  interface_->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     a1a:	d8 01       	movw	r26, r16
     a1c:	17 96       	adiw	r26, 0x07	; 7
     a1e:	ed 91       	ld	r30, X+
     a20:	fc 91       	ld	r31, X
     a22:	18 97       	sbiw	r26, 0x08	; 8
     a24:	04 80       	ldd	r0, Z+4	; 0x04
     a26:	f5 81       	ldd	r31, Z+5	; 0x05
     a28:	e0 2d       	mov	r30, r0
     a2a:	82 e0       	ldi	r24, 0x02	; 2
     a2c:	83 83       	std	Z+3, r24	; 0x03
  if( packet.num_items_in() == packet.getSize() ) {
    driver_->send_ack_stop();
    return nextState_; }
  else {
    driver_->byte_recv();
    return returnState_; }
     a2e:	14 96       	adiw	r26, 0x04	; 4
     a30:	8d 91       	ld	r24, X+
     a32:	9c 91       	ld	r25, X
     a34:	15 97       	sbiw	r26, 0x05	; 5
}
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	1f 91       	pop	r17
     a3c:	0f 91       	pop	r16
     a3e:	08 95       	ret

00000a40 <_ZN9I2CMaster11TransmitterC1EPS_>:
  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
}

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
     a40:	0f 93       	push	r16
     a42:	1f 93       	push	r17
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	ec 01       	movw	r28, r24
     a4a:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     a4c:	68 83       	st	Y, r22
     a4e:	79 83       	std	Y+1, r23	; 0x01
     a50:	89 e0       	ldi	r24, 0x09	; 9
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     a58:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a5a:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     a5c:	88 e1       	ldi	r24, 0x18	; 24
     a5e:	90 e2       	ldi	r25, 0x20	; 32
     a60:	80 83       	st	Z, r24
     a62:	91 83       	std	Z+1, r25	; 0x01
     a64:	07 83       	std	Z+7, r16	; 0x07
     a66:	10 87       	std	Z+8, r17	; 0x08
     a68:	ec 83       	std	Y+4, r30	; 0x04
     a6a:	fd 83       	std	Y+5, r31	; 0x05
     a6c:	8b e0       	ldi	r24, 0x0B	; 11
     a6e:	90 e0       	ldi	r25, 0x00	; 0
     a70:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     a74:	fc 01       	movw	r30, r24

I2CMaster::Transmitter::Transmitter( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     a76:	8b 89       	ldd	r24, Y+19	; 0x13
     a78:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a7a:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     a7c:	2e e1       	ldi	r18, 0x1E	; 30
     a7e:	30 e2       	ldi	r19, 0x20	; 32
     a80:	20 83       	st	Z, r18
     a82:	31 83       	std	Z+1, r19	; 0x01
     a84:	07 83       	std	Z+7, r16	; 0x07
     a86:	10 87       	std	Z+8, r17	; 0x08
     a88:	81 87       	std	Z+9, r24	; 0x09
     a8a:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     a8c:	ee 83       	std	Y+6, r30	; 0x06
     a8e:	ff 83       	std	Y+7, r31	; 0x07
     a90:	89 e0       	ldi	r24, 0x09	; 9
     a92:	90 e0       	ldi	r25, 0x00	; 0
     a94:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     a98:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     a9a:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     a9c:	8a e2       	ldi	r24, 0x2A	; 42
     a9e:	90 e2       	ldi	r25, 0x20	; 32
     aa0:	80 83       	st	Z, r24
     aa2:	91 83       	std	Z+1, r25	; 0x01
     aa4:	07 83       	std	Z+7, r16	; 0x07
     aa6:	10 87       	std	Z+8, r17	; 0x08
     aa8:	e8 87       	std	Y+8, r30	; 0x08
     aaa:	f9 87       	std	Y+9, r31	; 0x09
     aac:	89 e0       	ldi	r24, 0x09	; 9
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     ab4:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     ab6:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     ab8:	86 e3       	ldi	r24, 0x36	; 54
     aba:	90 e2       	ldi	r25, 0x20	; 32
     abc:	80 83       	st	Z, r24
     abe:	91 83       	std	Z+1, r25	; 0x01
     ac0:	07 83       	std	Z+7, r16	; 0x07
     ac2:	10 87       	std	Z+8, r17	; 0x08
     ac4:	ea 87       	std	Y+10, r30	; 0x0a
     ac6:	fb 87       	std	Y+11, r31	; 0x0b
     ac8:	89 e0       	ldi	r24, 0x09	; 9
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     ad0:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     ad2:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     ad4:	88 e4       	ldi	r24, 0x48	; 72
     ad6:	90 e2       	ldi	r25, 0x20	; 32
     ad8:	80 83       	st	Z, r24
     ada:	91 83       	std	Z+1, r25	; 0x01
     adc:	07 83       	std	Z+7, r16	; 0x07
     ade:	10 87       	std	Z+8, r17	; 0x08
     ae0:	ec 87       	std	Y+12, r30	; 0x0c
     ae2:	fd 87       	std	Y+13, r31	; 0x0d
     ae4:	89 e0       	ldi	r24, 0x09	; 9
     ae6:	90 e0       	ldi	r25, 0x00	; 0
     ae8:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     aec:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     aee:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     af0:	82 e4       	ldi	r24, 0x42	; 66
     af2:	90 e2       	ldi	r25, 0x20	; 32
     af4:	80 83       	st	Z, r24
     af6:	91 83       	std	Z+1, r25	; 0x01
     af8:	07 83       	std	Z+7, r16	; 0x07
     afa:	10 87       	std	Z+8, r17	; 0x08
     afc:	ee 87       	std	Y+14, r30	; 0x0e
     afe:	ff 87       	std	Y+15, r31	; 0x0f
     b00:	80 e1       	ldi	r24, 0x10	; 16
     b02:	97 e2       	ldi	r25, 0x27	; 39
     b04:	8b 8b       	std	Y+19, r24	; 0x13
     b06:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     b08:	8e 81       	ldd	r24, Y+6	; 0x06
     b0a:	9f 81       	ldd	r25, Y+7	; 0x07
     b0c:	ec 81       	ldd	r30, Y+4	; 0x04
     b0e:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b10:	82 83       	std	Z+2, r24	; 0x02
     b12:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     b14:	84 83       	std	Z+4, r24	; 0x04
     b16:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     b18:	8c 85       	ldd	r24, Y+12	; 0x0c
     b1a:	9d 85       	ldd	r25, Y+13	; 0x0d
     b1c:	28 85       	ldd	r18, Y+8	; 0x08
     b1e:	39 85       	ldd	r19, Y+9	; 0x09
     b20:	ee 81       	ldd	r30, Y+6	; 0x06
     b22:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b24:	22 83       	std	Z+2, r18	; 0x02
     b26:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     b28:	84 83       	std	Z+4, r24	; 0x04
     b2a:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     b2c:	8a 85       	ldd	r24, Y+10	; 0x0a
     b2e:	9b 85       	ldd	r25, Y+11	; 0x0b
     b30:	e8 85       	ldd	r30, Y+8	; 0x08
     b32:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b34:	82 83       	std	Z+2, r24	; 0x02
     b36:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     b38:	84 83       	std	Z+4, r24	; 0x04
     b3a:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     b3c:	8e 81       	ldd	r24, Y+6	; 0x06
     b3e:	9f 81       	ldd	r25, Y+7	; 0x07
     b40:	2e 85       	ldd	r18, Y+14	; 0x0e
     b42:	3f 85       	ldd	r19, Y+15	; 0x0f
     b44:	ea 85       	ldd	r30, Y+10	; 0x0a
     b46:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     b48:	22 83       	std	Z+2, r18	; 0x02
     b4a:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     b4c:	84 83       	std	Z+4, r24	; 0x04
     b4e:	95 83       	std	Z+5, r25	; 0x05
}
     b50:	df 91       	pop	r29
     b52:	cf 91       	pop	r28
     b54:	1f 91       	pop	r17
     b56:	0f 91       	pop	r16
     b58:	08 95       	ret

00000b5a <_ZN9I2CMaster8ReceiverC1EPS_>:

I2CMaster::Receiver::Receiver( I2CMaster * d )
     b5a:	0f 93       	push	r16
     b5c:	1f 93       	push	r17
     b5e:	cf 93       	push	r28
     b60:	df 93       	push	r29
     b62:	ec 01       	movw	r28, r24
     b64:	8b 01       	movw	r16, r22
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     b66:	68 83       	st	Y, r22
     b68:	79 83       	std	Y+1, r23	; 0x01
     b6a:	89 e0       	ldi	r24, 0x09	; 9
     b6c:	90 e0       	ldi	r25, 0x00	; 0
     b6e:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     b72:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     b74:	16 82       	std	Z+6, r1	; 0x06
  class StartState
    : public State
  {
  public:
    inline StartState( I2CMaster * d )
      : driver_(d)
     b76:	88 e1       	ldi	r24, 0x18	; 24
     b78:	90 e2       	ldi	r25, 0x20	; 32
     b7a:	80 83       	st	Z, r24
     b7c:	91 83       	std	Z+1, r25	; 0x01
     b7e:	07 83       	std	Z+7, r16	; 0x07
     b80:	10 87       	std	Z+8, r17	; 0x08
     b82:	ec 83       	std	Y+4, r30	; 0x04
     b84:	fd 83       	std	Y+5, r31	; 0x05
     b86:	8b e0       	ldi	r24, 0x0B	; 11
     b88:	90 e0       	ldi	r25, 0x00	; 0
     b8a:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     b8e:	fc 01       	movw	r30, r24

I2CMaster::Receiver::Receiver( I2CMaster * d )
  : driver_(d),
    timeout_(10000),
    startState_(new StartState( d )),
    statusState_(new StatusState( d, timeout_ )),
     b90:	8b 89       	ldd	r24, Y+19	; 0x13
     b92:	9c 89       	ldd	r25, Y+20	; 0x14

  class State
  {
  public:
    inline State() 
      : runs_(0)
     b94:	16 82       	std	Z+6, r1	; 0x06
      : public State
    {
    public:
      inline StatusState( I2CMaster * d, uint16_t timeout )
        : driver_(d),
          timeout_(timeout)
     b96:	24 e2       	ldi	r18, 0x24	; 36
     b98:	30 e2       	ldi	r19, 0x20	; 32
     b9a:	20 83       	st	Z, r18
     b9c:	31 83       	std	Z+1, r19	; 0x01
     b9e:	07 83       	std	Z+7, r16	; 0x07
     ba0:	10 87       	std	Z+8, r17	; 0x08
     ba2:	81 87       	std	Z+9, r24	; 0x09
     ba4:	92 87       	std	Z+10, r25	; 0x0a
    exchangeState_(new ExchangeState( d )),
    packetStatusState_(new PacketStatusState( d )),
    doneState_(new DoneState( d )),
    errorState_(new ErrorState( d ))
     ba6:	ee 83       	std	Y+6, r30	; 0x06
     ba8:	ff 83       	std	Y+7, r31	; 0x07
     baa:	89 e0       	ldi	r24, 0x09	; 9
     bac:	90 e0       	ldi	r25, 0x00	; 0
     bae:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     bb2:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bb4:	16 82       	std	Z+6, r1	; 0x06
    class ExchangeState
      : public State
    {
    public:
      inline ExchangeState( I2CMaster * d )
        : driver_(d)
     bb6:	80 e3       	ldi	r24, 0x30	; 48
     bb8:	90 e2       	ldi	r25, 0x20	; 32
     bba:	80 83       	st	Z, r24
     bbc:	91 83       	std	Z+1, r25	; 0x01
     bbe:	07 83       	std	Z+7, r16	; 0x07
     bc0:	10 87       	std	Z+8, r17	; 0x08
     bc2:	e8 87       	std	Y+8, r30	; 0x08
     bc4:	f9 87       	std	Y+9, r31	; 0x09
     bc6:	89 e0       	ldi	r24, 0x09	; 9
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     bce:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bd0:	16 82       	std	Z+6, r1	; 0x06
    class PacketStatusState
      : public State
    {
    public:
      inline PacketStatusState( I2CMaster * d )
        : driver_(d)
     bd2:	8c e3       	ldi	r24, 0x3C	; 60
     bd4:	90 e2       	ldi	r25, 0x20	; 32
     bd6:	80 83       	st	Z, r24
     bd8:	91 83       	std	Z+1, r25	; 0x01
     bda:	07 83       	std	Z+7, r16	; 0x07
     bdc:	10 87       	std	Z+8, r17	; 0x08
     bde:	ea 87       	std	Y+10, r30	; 0x0a
     be0:	fb 87       	std	Y+11, r31	; 0x0b
     be2:	89 e0       	ldi	r24, 0x09	; 9
     be4:	90 e0       	ldi	r25, 0x00	; 0
     be6:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     bea:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     bec:	16 82       	std	Z+6, r1	; 0x06
  class ErrorState
    : public State
  {
  public:
    inline ErrorState( I2CMaster * d )
      : driver_(d)
     bee:	88 e4       	ldi	r24, 0x48	; 72
     bf0:	90 e2       	ldi	r25, 0x20	; 32
     bf2:	80 83       	st	Z, r24
     bf4:	91 83       	std	Z+1, r25	; 0x01
     bf6:	07 83       	std	Z+7, r16	; 0x07
     bf8:	10 87       	std	Z+8, r17	; 0x08
     bfa:	ec 87       	std	Y+12, r30	; 0x0c
     bfc:	fd 87       	std	Y+13, r31	; 0x0d
     bfe:	89 e0       	ldi	r24, 0x09	; 9
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     c06:	fc 01       	movw	r30, r24

  class State
  {
  public:
    inline State() 
      : runs_(0)
     c08:	16 82       	std	Z+6, r1	; 0x06
  class DoneState
    : public State
  {
  public:
    inline DoneState( I2CMaster * d )
      : driver_(d)
     c0a:	82 e4       	ldi	r24, 0x42	; 66
     c0c:	90 e2       	ldi	r25, 0x20	; 32
     c0e:	80 83       	st	Z, r24
     c10:	91 83       	std	Z+1, r25	; 0x01
     c12:	07 83       	std	Z+7, r16	; 0x07
     c14:	10 87       	std	Z+8, r17	; 0x08
     c16:	ee 87       	std	Y+14, r30	; 0x0e
     c18:	ff 87       	std	Y+15, r31	; 0x0f
     c1a:	80 e1       	ldi	r24, 0x10	; 16
     c1c:	97 e2       	ldi	r25, 0x27	; 39
     c1e:	8b 8b       	std	Y+19, r24	; 0x13
     c20:	9c 8b       	std	Y+20, r25	; 0x14
{
  startState_->setTransition(statusState_, statusState_);
     c22:	8e 81       	ldd	r24, Y+6	; 0x06
     c24:	9f 81       	ldd	r25, Y+7	; 0x07
     c26:	ec 81       	ldd	r30, Y+4	; 0x04
     c28:	fd 81       	ldd	r31, Y+5	; 0x05
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c2a:	82 83       	std	Z+2, r24	; 0x02
     c2c:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     c2e:	84 83       	std	Z+4, r24	; 0x04
     c30:	95 83       	std	Z+5, r25	; 0x05
  statusState_->setTransition(exchangeState_, errorState_);
     c32:	8c 85       	ldd	r24, Y+12	; 0x0c
     c34:	9d 85       	ldd	r25, Y+13	; 0x0d
     c36:	28 85       	ldd	r18, Y+8	; 0x08
     c38:	39 85       	ldd	r19, Y+9	; 0x09
     c3a:	ee 81       	ldd	r30, Y+6	; 0x06
     c3c:	ff 81       	ldd	r31, Y+7	; 0x07
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c3e:	22 83       	std	Z+2, r18	; 0x02
     c40:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     c42:	84 83       	std	Z+4, r24	; 0x04
     c44:	95 83       	std	Z+5, r25	; 0x05
  exchangeState_->setTransition(packetStatusState_, packetStatusState_);
     c46:	8a 85       	ldd	r24, Y+10	; 0x0a
     c48:	9b 85       	ldd	r25, Y+11	; 0x0b
     c4a:	e8 85       	ldd	r30, Y+8	; 0x08
     c4c:	f9 85       	ldd	r31, Y+9	; 0x09
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c4e:	82 83       	std	Z+2, r24	; 0x02
     c50:	93 83       	std	Z+3, r25	; 0x03
      returnState_ = returnState;
     c52:	84 83       	std	Z+4, r24	; 0x04
     c54:	95 83       	std	Z+5, r25	; 0x05
  packetStatusState_->setTransition(doneState_, statusState_);
     c56:	8e 81       	ldd	r24, Y+6	; 0x06
     c58:	9f 81       	ldd	r25, Y+7	; 0x07
     c5a:	2e 85       	ldd	r18, Y+14	; 0x0e
     c5c:	3f 85       	ldd	r19, Y+15	; 0x0f
     c5e:	ea 85       	ldd	r30, Y+10	; 0x0a
     c60:	fb 85       	ldd	r31, Y+11	; 0x0b
    inline State() 
      : runs_(0)
    { }
    void setTransition( State * nextState, State * returnState )
    {
      nextState_ = nextState;
     c62:	22 83       	std	Z+2, r18	; 0x02
     c64:	33 83       	std	Z+3, r19	; 0x03
      returnState_ = returnState;
     c66:	84 83       	std	Z+4, r24	; 0x04
     c68:	95 83       	std	Z+5, r25	; 0x05
}
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	08 95       	ret

00000c74 <_ZN9I2CMaster11Transmitter3runER6Packet>:

bool I2CMaster::Transmitter::run( Packet & packet )
{
     c74:	0f 93       	push	r16
     c76:	1f 93       	push	r17
     c78:	cf 93       	push	r28
     c7a:	df 93       	push	r29
     c7c:	ec 01       	movw	r28, r24
     c7e:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     c80:	8c 81       	ldd	r24, Y+4	; 0x04
     c82:	9d 81       	ldd	r25, Y+5	; 0x05
     c84:	8a 83       	std	Y+2, r24	; 0x02
     c86:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     c88:	8a 81       	ldd	r24, Y+2	; 0x02
     c8a:	9b 81       	ldd	r25, Y+3	; 0x03
     c8c:	2e 85       	ldd	r18, Y+14	; 0x0e
     c8e:	3f 85       	ldd	r19, Y+15	; 0x0f
     c90:	82 17       	cp	r24, r18
     c92:	93 07       	cpc	r25, r19
     c94:	29 f4       	brne	.+10     	; 0xca0 <_ZN9I2CMaster11Transmitter3runER6Packet+0x2c>
     c96:	2c 85       	ldd	r18, Y+12	; 0x0c
     c98:	3d 85       	ldd	r19, Y+13	; 0x0d
     c9a:	82 17       	cp	r24, r18
     c9c:	93 07       	cpc	r25, r19
     c9e:	59 f0       	breq	.+22     	; 0xcb6 <_ZN9I2CMaster11Transmitter3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     ca0:	dc 01       	movw	r26, r24
     ca2:	ed 91       	ld	r30, X+
     ca4:	fc 91       	ld	r31, X
     ca6:	01 90       	ld	r0, Z+
     ca8:	f0 81       	ld	r31, Z
     caa:	e0 2d       	mov	r30, r0
     cac:	b8 01       	movw	r22, r16
     cae:	19 95       	eicall
     cb0:	8a 83       	std	Y+2, r24	; 0x02
     cb2:	9b 83       	std	Y+3, r25	; 0x03

bool I2CMaster::Transmitter::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     cb4:	e9 cf       	rjmp	.-46     	; 0xc88 <_ZN9I2CMaster11Transmitter3runER6Packet+0x14>
  }
  else
  {
    return false;
  }
}
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	1f 91       	pop	r17
     cbe:	0f 91       	pop	r16
     cc0:	08 95       	ret

00000cc2 <_ZN9I2CMaster8Receiver3runER6Packet>:

Packet & I2CMaster::Receiver::run( Packet & packet )
{
     cc2:	0f 93       	push	r16
     cc4:	1f 93       	push	r17
     cc6:	cf 93       	push	r28
     cc8:	df 93       	push	r29
     cca:	ec 01       	movw	r28, r24
     ccc:	8b 01       	movw	r16, r22
  currentState_ = startState_;
     cce:	8c 81       	ldd	r24, Y+4	; 0x04
     cd0:	9d 81       	ldd	r25, Y+5	; 0x05
     cd2:	8a 83       	std	Y+2, r24	; 0x02
     cd4:	9b 83       	std	Y+3, r25	; 0x03
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     cd6:	8a 81       	ldd	r24, Y+2	; 0x02
     cd8:	9b 81       	ldd	r25, Y+3	; 0x03
     cda:	2e 85       	ldd	r18, Y+14	; 0x0e
     cdc:	3f 85       	ldd	r19, Y+15	; 0x0f
     cde:	82 17       	cp	r24, r18
     ce0:	93 07       	cpc	r25, r19
     ce2:	29 f4       	brne	.+10     	; 0xcee <_ZN9I2CMaster8Receiver3runER6Packet+0x2c>
     ce4:	2c 85       	ldd	r18, Y+12	; 0x0c
     ce6:	3d 85       	ldd	r19, Y+13	; 0x0d
     ce8:	82 17       	cp	r24, r18
     cea:	93 07       	cpc	r25, r19
     cec:	59 f0       	breq	.+22     	; 0xd04 <_ZN9I2CMaster8Receiver3runER6Packet+0x42>
  {
    currentState_ = currentState_->execute(packet);
     cee:	dc 01       	movw	r26, r24
     cf0:	ed 91       	ld	r30, X+
     cf2:	fc 91       	ld	r31, X
     cf4:	01 90       	ld	r0, Z+
     cf6:	f0 81       	ld	r31, Z
     cf8:	e0 2d       	mov	r30, r0
     cfa:	b8 01       	movw	r22, r16
     cfc:	19 95       	eicall
     cfe:	8a 83       	std	Y+2, r24	; 0x02
     d00:	9b 83       	std	Y+3, r25	; 0x03

Packet & I2CMaster::Receiver::run( Packet & packet )
{
  currentState_ = startState_;
  
  while( (currentState_ != doneState_) || (currentState_ != errorState_) )
     d02:	e9 cf       	rjmp	.-46     	; 0xcd6 <_ZN9I2CMaster8Receiver3runER6Packet+0x14>
  {
    currentState_ = currentState_->execute(packet);
  }

  return packet;
}
     d04:	c8 01       	movw	r24, r16
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	1f 91       	pop	r17
     d0c:	0f 91       	pop	r16
     d0e:	08 95       	ret

00000d10 <_ZN9I2CMaster12set_baudrateEm>:
{
  return nextState_;
}

void I2CMaster::set_baudrate(uint32_t i2c_freq)
{
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	ec 01       	movw	r28, r24
  baudrate = (F_CPU / (2 * i2c_freq)) - 5;
     d16:	9a 01       	movw	r18, r20
     d18:	ab 01       	movw	r20, r22
     d1a:	22 0f       	add	r18, r18
     d1c:	33 1f       	adc	r19, r19
     d1e:	44 1f       	adc	r20, r20
     d20:	55 1f       	adc	r21, r21
     d22:	60 e0       	ldi	r22, 0x00	; 0
     d24:	78 e4       	ldi	r23, 0x48	; 72
     d26:	88 ee       	ldi	r24, 0xE8	; 232
     d28:	91 e0       	ldi	r25, 0x01	; 1
     d2a:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
     d2e:	25 50       	subi	r18, 0x05	; 5
     d30:	28 87       	std	Y+8, r18	; 0x08
  interface_->MASTER.BAUD = baudrate;
     d32:	ec 81       	ldd	r30, Y+4	; 0x04
     d34:	fd 81       	ldd	r31, Y+5	; 0x05
     d36:	25 83       	std	Z+5, r18	; 0x05
}
     d38:	df 91       	pop	r29
     d3a:	cf 91       	pop	r28
     d3c:	08 95       	ret

00000d3e <_ZN9I2CMasterC1EP10TWI_structm>:
 *  Author: Kevin
 */ 

#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
     d3e:	af 92       	push	r10
     d40:	bf 92       	push	r11
     d42:	cf 92       	push	r12
     d44:	df 92       	push	r13
     d46:	ef 92       	push	r14
     d48:	ff 92       	push	r15
     d4a:	0f 93       	push	r16
     d4c:	1f 93       	push	r17
     d4e:	cf 93       	push	r28
     d50:	df 93       	push	r29
     d52:	ec 01       	movw	r28, r24
     d54:	8b 01       	movw	r16, r22
     d56:	69 01       	movw	r12, r18
     d58:	7a 01       	movw	r14, r20
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
    receiver_(new Receiver(this))
     d5a:	85 e1       	ldi	r24, 0x15	; 21
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     d62:	5c 01       	movw	r10, r24
#include "I2CMaster.h"

I2CMaster::I2CMaster(TWI_t * interface, uint32_t i2c_freq)
  : interface_(interface), 
    i2c_freq(i2c_freq),
    transmitter_(new Transmitter(this)),
     d64:	be 01       	movw	r22, r28
     d66:	0e 94 20 05 	call	0xa40	; 0xa40 <_ZN9I2CMaster11TransmitterC1EPS_>
    receiver_(new Receiver(this))
     d6a:	a8 82       	st	Y, r10
     d6c:	b9 82       	std	Y+1, r11	; 0x01
     d6e:	86 e1       	ldi	r24, 0x16	; 22
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
     d76:	5c 01       	movw	r10, r24
     d78:	be 01       	movw	r22, r28
     d7a:	0e 94 ad 05 	call	0xb5a	; 0xb5a <_ZN9I2CMaster8ReceiverC1EPS_>
     d7e:	aa 82       	std	Y+2, r10	; 0x02
     d80:	bb 82       	std	Y+3, r11	; 0x03
     d82:	0c 83       	std	Y+4, r16	; 0x04
     d84:	1d 83       	std	Y+5, r17	; 0x05
     d86:	c9 86       	std	Y+9, r12	; 0x09
     d88:	da 86       	std	Y+10, r13	; 0x0a
     d8a:	eb 86       	std	Y+11, r14	; 0x0b
     d8c:	fc 86       	std	Y+12, r15	; 0x0c
{ 
  if (interface == &TWIC)
     d8e:	00 38       	cpi	r16, 0x80	; 128
     d90:	84 e0       	ldi	r24, 0x04	; 4
     d92:	18 07       	cpc	r17, r24
     d94:	29 f4       	brne	.+10     	; 0xda0 <_ZN9I2CMasterC1EP10TWI_structm+0x62>
  {
    bus_port = &PORTC;
     d96:	80 e4       	ldi	r24, 0x40	; 64
     d98:	96 e0       	ldi	r25, 0x06	; 6
     d9a:	8e 83       	std	Y+6, r24	; 0x06
     d9c:	9f 83       	std	Y+7, r25	; 0x07
     d9e:	08 c0       	rjmp	.+16     	; 0xdb0 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  }
  if (interface == &TWIE)
     da0:	00 3a       	cpi	r16, 0xA0	; 160
     da2:	e4 e0       	ldi	r30, 0x04	; 4
     da4:	1e 07       	cpc	r17, r30
     da6:	21 f4       	brne	.+8      	; 0xdb0 <_ZN9I2CMasterC1EP10TWI_structm+0x72>
  {
    bus_port = &PORTE;
     da8:	80 e8       	ldi	r24, 0x80	; 128
     daa:	96 e0       	ldi	r25, 0x06	; 6
     dac:	8e 83       	std	Y+6, r24	; 0x06
     dae:	9f 83       	std	Y+7, r25	; 0x07
  }
  
  bus_port->DIRSET = PIN0_bm | PIN1_bm;
     db0:	ee 81       	ldd	r30, Y+6	; 0x06
     db2:	ff 81       	ldd	r31, Y+7	; 0x07
     db4:	83 e0       	ldi	r24, 0x03	; 3
     db6:	81 83       	std	Z+1, r24	; 0x01
  bus_port->PIN0CTRL = PORT_OPC_WIREDANDPULL_gc; //SDA pull up output
     db8:	ee 81       	ldd	r30, Y+6	; 0x06
     dba:	ff 81       	ldd	r31, Y+7	; 0x07
     dbc:	88 e3       	ldi	r24, 0x38	; 56
     dbe:	80 8b       	std	Z+16, r24	; 0x10
  bus_port->PIN1CTRL = PORT_OPC_WIREDANDPULL_gc; //SCL pull up output
     dc0:	ee 81       	ldd	r30, Y+6	; 0x06
     dc2:	ff 81       	ldd	r31, Y+7	; 0x07
     dc4:	81 8b       	std	Z+17, r24	; 0x11
  
  interface->MASTER.CTRLB = 1 << 1;
     dc6:	82 e0       	ldi	r24, 0x02	; 2
     dc8:	f8 01       	movw	r30, r16
     dca:	82 83       	std	Z+2, r24	; 0x02
  
  set_baudrate(i2c_freq); //baud rate is set such that TWI freq=100KHz
     dcc:	b7 01       	movw	r22, r14
     dce:	a6 01       	movw	r20, r12
     dd0:	ce 01       	movw	r24, r28
     dd2:	0e 94 88 06 	call	0xd10	; 0xd10 <_ZN9I2CMaster12set_baudrateEm>
  
//  ptwiport->MASTER.CTRLB = 0x00; //TWI_MASTER_QCEN_bm; //no inactive bus timeout, quick command and smart mode enabled
  
//  ptwiport->MASTER.CTRLC = 0x00; //initially send ACK and no CMD selected

  interface->MASTER.STATUS |= TWI_MASTER_RIF_bm | TWI_MASTER_WIF_bm | TWI_MASTER_ARBLOST_bm | TWI_MASTER_BUSERR_bm | TWI_MASTER_BUSSTATE_IDLE_gc; //clear all flags initially and select bus state IDLE
     dd6:	f8 01       	movw	r30, r16
     dd8:	84 81       	ldd	r24, Z+4	; 0x04
     dda:	8d 6c       	ori	r24, 0xCD	; 205
     ddc:	84 83       	std	Z+4, r24	; 0x04

  interface->MASTER.CTRLA = TWI_MASTER_ENABLE_bm;
     dde:	88 e0       	ldi	r24, 0x08	; 8
     de0:	81 83       	std	Z+1, r24	; 0x01
}
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	1f 91       	pop	r17
     de8:	0f 91       	pop	r16
     dea:	ff 90       	pop	r15
     dec:	ef 90       	pop	r14
     dee:	df 90       	pop	r13
     df0:	cf 90       	pop	r12
     df2:	bf 90       	pop	r11
     df4:	af 90       	pop	r10
     df6:	08 95       	ret

00000df8 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return driver_->is_ready(slaveAddr_);
}
     df8:	db 01       	movw	r26, r22
     dfa:	bc 01       	movw	r22, r24
     dfc:	6e 5f       	subi	r22, 0xFE	; 254
     dfe:	7f 4f       	sbci	r23, 0xFF	; 255
     e00:	ed 91       	ld	r30, X+
     e02:	fc 91       	ld	r31, X
     e04:	11 97       	sbiw	r26, 0x01	; 1
     e06:	01 90       	ld	r0, Z+
     e08:	f0 81       	ld	r31, Z
     e0a:	e0 2d       	mov	r30, r0
     e0c:	cd 01       	movw	r24, r26
     e0e:	19 95       	eicall
     e10:	08 95       	ret

00000e12 <_ZN9frt_queueIhE16ISR_num_items_inEv>:
     e12:	fc 01       	movw	r30, r24
     e14:	84 81       	ldd	r24, Z+4	; 0x04
     e16:	95 81       	ldd	r25, Z+5	; 0x05
     e18:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	08 95       	ret

00000e20 <_ZN9frt_queueIhE13ISR_not_emptyEv>:
     e20:	fc 01       	movw	r30, r24
     e22:	84 81       	ldd	r24, Z+4	; 0x04
     e24:	95 81       	ldd	r25, Z+5	; 0x05
     e26:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
     e2a:	91 e0       	ldi	r25, 0x01	; 1
     e2c:	81 11       	cpse	r24, r1
     e2e:	01 c0       	rjmp	.+2      	; 0xe32 <_ZN9frt_queueIhE13ISR_not_emptyEv+0x12>
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	89 2f       	mov	r24, r25
     e34:	08 95       	ret

00000e36 <_ZN9frt_queueIhE12ISR_is_emptyEv>:
     e36:	fc 01       	movw	r30, r24
     e38:	84 81       	ldd	r24, Z+4	; 0x04
     e3a:	95 81       	ldd	r25, Z+5	; 0x05
     e3c:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
     e40:	91 e0       	ldi	r25, 0x01	; 1
     e42:	81 11       	cpse	r24, r1
     e44:	90 e0       	ldi	r25, 0x00	; 0
     e46:	89 2f       	mov	r24, r25
     e48:	08 95       	ret

00000e4a <_ZN9frt_queueIhE12num_items_inEv>:
     e4a:	fc 01       	movw	r30, r24
     e4c:	84 81       	ldd	r24, Z+4	; 0x04
     e4e:	95 81       	ldd	r25, Z+5	; 0x05
     e50:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
     e54:	90 e0       	ldi	r25, 0x00	; 0
     e56:	08 95       	ret

00000e58 <_ZN9frt_queueIhE9not_emptyEv>:
     e58:	fc 01       	movw	r30, r24
     e5a:	84 81       	ldd	r24, Z+4	; 0x04
     e5c:	95 81       	ldd	r25, Z+5	; 0x05
     e5e:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
     e62:	91 e0       	ldi	r25, 0x01	; 1
     e64:	81 11       	cpse	r24, r1
     e66:	01 c0       	rjmp	.+2      	; 0xe6a <_ZN9frt_queueIhE9not_emptyEv+0x12>
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	89 2f       	mov	r24, r25
     e6c:	08 95       	ret

00000e6e <_ZN9frt_queueIhE8is_emptyEv>:
     e6e:	fc 01       	movw	r30, r24
     e70:	84 81       	ldd	r24, Z+4	; 0x04
     e72:	95 81       	ldd	r25, Z+5	; 0x05
     e74:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
     e78:	91 e0       	ldi	r25, 0x01	; 1
     e7a:	81 11       	cpse	r24, r1
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	89 2f       	mov	r24, r25
     e80:	08 95       	ret

00000e82 <_ZN9frt_queueIhE10get_a_copyERh>:
     e82:	0f 93       	push	r16
     e84:	01 e0       	ldi	r16, 0x01	; 1
     e86:	2f ef       	ldi	r18, 0xFF	; 255
     e88:	3f ef       	ldi	r19, 0xFF	; 255
     e8a:	a9 01       	movw	r20, r18
     e8c:	fc 01       	movw	r30, r24
     e8e:	84 81       	ldd	r24, Z+4	; 0x04
     e90:	95 81       	ldd	r25, Z+5	; 0x05
     e92:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
     e96:	0f 91       	pop	r16
     e98:	08 95       	ret

00000e9a <_ZN9frt_queueIhE10get_a_copyEv>:
     e9a:	0f 93       	push	r16
     e9c:	cf 93       	push	r28
     e9e:	df 93       	push	r29
     ea0:	1f 92       	push	r1
     ea2:	cd b7       	in	r28, 0x3d	; 61
     ea4:	de b7       	in	r29, 0x3e	; 62
     ea6:	01 e0       	ldi	r16, 0x01	; 1
     ea8:	2f ef       	ldi	r18, 0xFF	; 255
     eaa:	3f ef       	ldi	r19, 0xFF	; 255
     eac:	a9 01       	movw	r20, r18
     eae:	be 01       	movw	r22, r28
     eb0:	6f 5f       	subi	r22, 0xFF	; 255
     eb2:	7f 4f       	sbci	r23, 0xFF	; 255
     eb4:	fc 01       	movw	r30, r24
     eb6:	84 81       	ldd	r24, Z+4	; 0x04
     eb8:	95 81       	ldd	r25, Z+5	; 0x05
     eba:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
     ebe:	89 81       	ldd	r24, Y+1	; 0x01
     ec0:	0f 90       	pop	r0
     ec2:	df 91       	pop	r29
     ec4:	cf 91       	pop	r28
     ec6:	0f 91       	pop	r16
     ec8:	08 95       	ret

00000eca <_ZN9frt_queueIhE3getEPh>:
     eca:	0f 93       	push	r16
     ecc:	00 e0       	ldi	r16, 0x00	; 0
     ece:	2f ef       	ldi	r18, 0xFF	; 255
     ed0:	3f ef       	ldi	r19, 0xFF	; 255
     ed2:	a9 01       	movw	r20, r18
     ed4:	fc 01       	movw	r30, r24
     ed6:	84 81       	ldd	r24, Z+4	; 0x04
     ed8:	95 81       	ldd	r25, Z+5	; 0x05
     eda:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
     ede:	0f 91       	pop	r16
     ee0:	08 95       	ret

00000ee2 <_ZN9frt_queueIhE3getEv>:
     ee2:	0f 93       	push	r16
     ee4:	cf 93       	push	r28
     ee6:	df 93       	push	r29
     ee8:	1f 92       	push	r1
     eea:	cd b7       	in	r28, 0x3d	; 61
     eec:	de b7       	in	r29, 0x3e	; 62
     eee:	00 e0       	ldi	r16, 0x00	; 0
     ef0:	2f ef       	ldi	r18, 0xFF	; 255
     ef2:	3f ef       	ldi	r19, 0xFF	; 255
     ef4:	a9 01       	movw	r20, r18
     ef6:	be 01       	movw	r22, r28
     ef8:	6f 5f       	subi	r22, 0xFF	; 255
     efa:	7f 4f       	sbci	r23, 0xFF	; 255
     efc:	fc 01       	movw	r30, r24
     efe:	84 81       	ldd	r24, Z+4	; 0x04
     f00:	95 81       	ldd	r25, Z+5	; 0x05
     f02:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	0f 90       	pop	r0
     f0a:	df 91       	pop	r29
     f0c:	cf 91       	pop	r28
     f0e:	0f 91       	pop	r16
     f10:	08 95       	ret

00000f12 <_ZN9frt_queueIhE7ISR_getEPh>:
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29
     f16:	1f 92       	push	r1
     f18:	cd b7       	in	r28, 0x3d	; 61
     f1a:	de b7       	in	r29, 0x3e	; 62
     f1c:	ae 01       	movw	r20, r28
     f1e:	4f 5f       	subi	r20, 0xFF	; 255
     f20:	5f 4f       	sbci	r21, 0xFF	; 255
     f22:	fc 01       	movw	r30, r24
     f24:	84 81       	ldd	r24, Z+4	; 0x04
     f26:	95 81       	ldd	r25, Z+5	; 0x05
     f28:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
     f2c:	0f 90       	pop	r0
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	08 95       	ret

00000f34 <_ZN9frt_queueIhE7ISR_getEv>:
     f34:	cf 93       	push	r28
     f36:	df 93       	push	r29
     f38:	1f 92       	push	r1
     f3a:	1f 92       	push	r1
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	ae 01       	movw	r20, r28
     f42:	4e 5f       	subi	r20, 0xFE	; 254
     f44:	5f 4f       	sbci	r21, 0xFF	; 255
     f46:	be 01       	movw	r22, r28
     f48:	6f 5f       	subi	r22, 0xFF	; 255
     f4a:	7f 4f       	sbci	r23, 0xFF	; 255
     f4c:	fc 01       	movw	r30, r24
     f4e:	84 81       	ldd	r24, Z+4	; 0x04
     f50:	95 81       	ldd	r25, Z+5	; 0x05
     f52:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
     f56:	89 81       	ldd	r24, Y+1	; 0x01
     f58:	0f 90       	pop	r0
     f5a:	0f 90       	pop	r0
     f5c:	df 91       	pop	r29
     f5e:	cf 91       	pop	r28
     f60:	08 95       	ret

00000f62 <_ZN9frt_queueIhE11ISR_butt_inERKh>:
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	1f 92       	push	r1
     f68:	cd b7       	in	r28, 0x3d	; 61
     f6a:	de b7       	in	r29, 0x3e	; 62
     f6c:	19 82       	std	Y+1, r1	; 0x01
     f6e:	21 e0       	ldi	r18, 0x01	; 1
     f70:	ae 01       	movw	r20, r28
     f72:	4f 5f       	subi	r20, 0xFF	; 255
     f74:	5f 4f       	sbci	r21, 0xFF	; 255
     f76:	fc 01       	movw	r30, r24
     f78:	84 81       	ldd	r24, Z+4	; 0x04
     f7a:	95 81       	ldd	r25, Z+5	; 0x05
     f7c:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
     f80:	91 e0       	ldi	r25, 0x01	; 1
     f82:	81 11       	cpse	r24, r1
     f84:	01 c0       	rjmp	.+2      	; 0xf88 <_ZN9frt_queueIhE11ISR_butt_inERKh+0x26>
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	89 2f       	mov	r24, r25
     f8a:	0f 90       	pop	r0
     f8c:	df 91       	pop	r29
     f8e:	cf 91       	pop	r28
     f90:	08 95       	ret

00000f92 <_ZN9frt_queueIhE7ISR_putERKh>:
     f92:	cf 93       	push	r28
     f94:	df 93       	push	r29
     f96:	1f 92       	push	r1
     f98:	cd b7       	in	r28, 0x3d	; 61
     f9a:	de b7       	in	r29, 0x3e	; 62
     f9c:	19 82       	std	Y+1, r1	; 0x01
     f9e:	20 e0       	ldi	r18, 0x00	; 0
     fa0:	ae 01       	movw	r20, r28
     fa2:	4f 5f       	subi	r20, 0xFF	; 255
     fa4:	5f 4f       	sbci	r21, 0xFF	; 255
     fa6:	fc 01       	movw	r30, r24
     fa8:	84 81       	ldd	r24, Z+4	; 0x04
     faa:	95 81       	ldd	r25, Z+5	; 0x05
     fac:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
     fb0:	91 e0       	ldi	r25, 0x01	; 1
     fb2:	81 11       	cpse	r24, r1
     fb4:	01 c0       	rjmp	.+2      	; 0xfb8 <_ZN9frt_queueIhE7ISR_putERKh+0x26>
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	89 2f       	mov	r24, r25
     fba:	0f 90       	pop	r0
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	08 95       	ret

00000fc2 <_ZN9frt_queueIhE7butt_inERKh>:
     fc2:	0f 93       	push	r16
     fc4:	fc 01       	movw	r30, r24
     fc6:	26 81       	ldd	r18, Z+6	; 0x06
     fc8:	37 81       	ldd	r19, Z+7	; 0x07
     fca:	40 85       	ldd	r20, Z+8	; 0x08
     fcc:	51 85       	ldd	r21, Z+9	; 0x09
     fce:	01 e0       	ldi	r16, 0x01	; 1
     fd0:	84 81       	ldd	r24, Z+4	; 0x04
     fd2:	95 81       	ldd	r25, Z+5	; 0x05
     fd4:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
     fd8:	91 e0       	ldi	r25, 0x01	; 1
     fda:	81 11       	cpse	r24, r1
     fdc:	01 c0       	rjmp	.+2      	; 0xfe0 <_ZN9frt_queueIhE7butt_inERKh+0x1e>
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	89 2f       	mov	r24, r25
     fe2:	0f 91       	pop	r16
     fe4:	08 95       	ret

00000fe6 <_ZN9frt_queueIhE3putERKh>:
     fe6:	0f 93       	push	r16
     fe8:	fc 01       	movw	r30, r24
     fea:	26 81       	ldd	r18, Z+6	; 0x06
     fec:	37 81       	ldd	r19, Z+7	; 0x07
     fee:	40 85       	ldd	r20, Z+8	; 0x08
     ff0:	51 85       	ldd	r21, Z+9	; 0x09
     ff2:	00 e0       	ldi	r16, 0x00	; 0
     ff4:	84 81       	ldd	r24, Z+4	; 0x04
     ff6:	95 81       	ldd	r25, Z+5	; 0x05
     ff8:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
     ffc:	91 e0       	ldi	r25, 0x01	; 1
     ffe:	81 11       	cpse	r24, r1
    1000:	01 c0       	rjmp	.+2      	; 0x1004 <_ZN9frt_queueIhE3putERKh+0x1e>
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	89 2f       	mov	r24, r25
    1006:	0f 91       	pop	r16
    1008:	08 95       	ret

0000100a <_ZN6MB1202C1EP9I2CMaster>:
    100a:	4f 92       	push	r4
    100c:	5f 92       	push	r5
    100e:	6f 92       	push	r6
    1010:	7f 92       	push	r7
    1012:	8f 92       	push	r8
    1014:	9f 92       	push	r9
    1016:	af 92       	push	r10
    1018:	bf 92       	push	r11
    101a:	df 92       	push	r13
    101c:	ef 92       	push	r14
    101e:	ff 92       	push	r15
    1020:	0f 93       	push	r16
    1022:	1f 93       	push	r17
    1024:	cf 93       	push	r28
    1026:	df 93       	push	r29
    1028:	8c 01       	movw	r16, r24
    102a:	7b 01       	movw	r14, r22
    102c:	dc 01       	movw	r26, r24
    102e:	6d 93       	st	X+, r22
    1030:	7c 93       	st	X, r23
    1032:	8d e1       	ldi	r24, 0x1D	; 29
    1034:	90 e0       	ldi	r25, 0x00	; 0
    1036:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
    103a:	ec 01       	movw	r28, r24
    103c:	86 e9       	ldi	r24, 0x96	; 150
    103e:	90 e2       	ldi	r25, 0x20	; 32
    1040:	88 83       	st	Y, r24
    1042:	99 83       	std	Y+1, r25	; 0x01
    1044:	1c 82       	std	Y+4, r1	; 0x04
    1046:	1d 82       	std	Y+5, r1	; 0x05
    1048:	0f 2e       	mov	r0, r31
    104a:	fe e4       	ldi	r31, 0x4E	; 78
    104c:	8f 2e       	mov	r8, r31
    104e:	f0 e2       	ldi	r31, 0x20	; 32
    1050:	9f 2e       	mov	r9, r31
    1052:	f0 2d       	mov	r31, r0
    1054:	8a 82       	std	Y+2, r8	; 0x02
    1056:	9b 82       	std	Y+3, r9	; 0x03
    1058:	40 e0       	ldi	r20, 0x00	; 0
    105a:	61 e0       	ldi	r22, 0x01	; 1
    105c:	82 e0       	ldi	r24, 0x02	; 2
    105e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    1062:	8e 83       	std	Y+6, r24	; 0x06
    1064:	9f 83       	std	Y+7, r25	; 0x07
    1066:	0f 2e       	mov	r0, r31
    1068:	fa e0       	ldi	r31, 0x0A	; 10
    106a:	4f 2e       	mov	r4, r31
    106c:	51 2c       	mov	r5, r1
    106e:	61 2c       	mov	r6, r1
    1070:	71 2c       	mov	r7, r1
    1072:	f0 2d       	mov	r31, r0
    1074:	48 86       	std	Y+8, r4	; 0x08
    1076:	59 86       	std	Y+9, r5	; 0x09
    1078:	6a 86       	std	Y+10, r6	; 0x0a
    107a:	7b 86       	std	Y+11, r7	; 0x0b
    107c:	0f 2e       	mov	r0, r31
    107e:	f2 e7       	ldi	r31, 0x72	; 114
    1080:	af 2e       	mov	r10, r31
    1082:	f0 e2       	ldi	r31, 0x20	; 32
    1084:	bf 2e       	mov	r11, r31
    1086:	f0 2d       	mov	r31, r0
    1088:	aa 82       	std	Y+2, r10	; 0x02
    108a:	bb 82       	std	Y+3, r11	; 0x03
    108c:	68 94       	set
    108e:	dd 24       	eor	r13, r13
    1090:	d1 f8       	bld	r13, 1
    1092:	dc 86       	std	Y+12, r13	; 0x0c
    1094:	1f 86       	std	Y+15, r1	; 0x0f
    1096:	18 8a       	std	Y+16, r1	; 0x10
    1098:	8d 86       	std	Y+13, r8	; 0x0d
    109a:	9e 86       	std	Y+14, r9	; 0x0e
    109c:	40 e0       	ldi	r20, 0x00	; 0
    109e:	61 e0       	ldi	r22, 0x01	; 1
    10a0:	82 e0       	ldi	r24, 0x02	; 2
    10a2:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    10a6:	89 8b       	std	Y+17, r24	; 0x11
    10a8:	9a 8b       	std	Y+18, r25	; 0x12
    10aa:	4b 8a       	std	Y+19, r4	; 0x13
    10ac:	5c 8a       	std	Y+20, r5	; 0x14
    10ae:	6d 8a       	std	Y+21, r6	; 0x15
    10b0:	7e 8a       	std	Y+22, r7	; 0x16
    10b2:	ad 86       	std	Y+13, r10	; 0x0d
    10b4:	be 86       	std	Y+14, r11	; 0x0e
    10b6:	df 8a       	std	Y+23, r13	; 0x17
    10b8:	8a e0       	ldi	r24, 0x0A	; 10
    10ba:	90 e2       	ldi	r25, 0x20	; 32
    10bc:	88 83       	st	Y, r24
    10be:	99 83       	std	Y+1, r25	; 0x01
    10c0:	f8 01       	movw	r30, r16
    10c2:	c2 83       	std	Z+2, r28	; 0x02
    10c4:	d3 83       	std	Z+3, r29	; 0x03
    10c6:	80 e7       	ldi	r24, 0x70	; 112
    10c8:	84 83       	std	Z+4, r24	; 0x04
    10ca:	16 82       	std	Z+6, r1	; 0x06
    10cc:	17 82       	std	Z+7, r1	; 0x07
    10ce:	10 86       	std	Z+8, r1	; 0x08
    10d0:	11 86       	std	Z+9, r1	; 0x09
    10d2:	12 86       	std	Z+10, r1	; 0x0a
    10d4:	83 e0       	ldi	r24, 0x03	; 3
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
    10dc:	24 ea       	ldi	r18, 0xA4	; 164
    10de:	30 e2       	ldi	r19, 0x20	; 32
    10e0:	fc 01       	movw	r30, r24
    10e2:	20 83       	st	Z, r18
    10e4:	31 83       	std	Z+1, r19	; 0x01
    10e6:	c1 e5       	ldi	r28, 0x51	; 81
    10e8:	c2 83       	std	Z+2, r28	; 0x02
    10ea:	d8 01       	movw	r26, r16
    10ec:	1d 96       	adiw	r26, 0x0d	; 13
    10ee:	8d 93       	st	X+, r24
    10f0:	9c 93       	st	X, r25
    10f2:	1e 97       	sbiw	r26, 0x0e	; 14
    10f4:	12 96       	adiw	r26, 0x02	; 2
    10f6:	ed 91       	ld	r30, X+
    10f8:	fc 91       	ld	r31, X
    10fa:	13 97       	sbiw	r26, 0x03	; 3
    10fc:	e0 8e       	std	Z+24, r14	; 0x18
    10fe:	f1 8e       	std	Z+25, r15	; 0x19
    1100:	14 96       	adiw	r26, 0x04	; 4
    1102:	6c 91       	ld	r22, X
    1104:	14 97       	sbiw	r26, 0x04	; 4
    1106:	12 96       	adiw	r26, 0x02	; 2
    1108:	8d 91       	ld	r24, X+
    110a:	9c 91       	ld	r25, X
    110c:	13 97       	sbiw	r26, 0x03	; 3
    110e:	0e 94 ef 03 	call	0x7de	; 0x7de <_ZN8I2CAgent12setSlaveAddrEh>
    1112:	f8 01       	movw	r30, r16
    1114:	c5 83       	std	Z+5, r28	; 0x05
    1116:	8a ea       	ldi	r24, 0xAA	; 170
    1118:	86 83       	std	Z+6, r24	; 0x06
    111a:	85 ea       	ldi	r24, 0xA5	; 165
    111c:	87 83       	std	Z+7, r24	; 0x07
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	ff 90       	pop	r15
    1128:	ef 90       	pop	r14
    112a:	df 90       	pop	r13
    112c:	bf 90       	pop	r11
    112e:	af 90       	pop	r10
    1130:	9f 90       	pop	r9
    1132:	8f 90       	pop	r8
    1134:	7f 90       	pop	r7
    1136:	6f 90       	pop	r6
    1138:	5f 90       	pop	r5
    113a:	4f 90       	pop	r4
    113c:	08 95       	ret

0000113e <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
	return i2cAgent_->transmit(*rangeCommand_);
    113e:	fc 01       	movw	r30, r24
    1140:	a2 81       	ldd	r26, Z+2	; 0x02
    1142:	b3 81       	ldd	r27, Z+3	; 0x03
    1144:	65 85       	ldd	r22, Z+13	; 0x0d
    1146:	76 85       	ldd	r23, Z+14	; 0x0e
    1148:	ed 91       	ld	r30, X+
    114a:	fc 91       	ld	r31, X
    114c:	11 97       	sbiw	r26, 0x01	; 1
    114e:	01 90       	ld	r0, Z+
    1150:	f0 81       	ld	r31, Z
    1152:	e0 2d       	mov	r30, r0
    1154:	cd 01       	movw	r24, r26
    1156:	19 95       	eicall
}
    1158:	08 95       	ret

0000115a <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
    115a:	ff 92       	push	r15
    115c:	0f 93       	push	r16
    115e:	1f 93       	push	r17
    1160:	cf 93       	push	r28
    1162:	df 93       	push	r29
    1164:	ec 01       	movw	r28, r24
	Packet & data = i2cAgent_->receive();
    1166:	8a 81       	ldd	r24, Y+2	; 0x02
    1168:	9b 81       	ldd	r25, Y+3	; 0x03
    116a:	dc 01       	movw	r26, r24
    116c:	ed 91       	ld	r30, X+
    116e:	fc 91       	ld	r31, X
    1170:	02 80       	ldd	r0, Z+2	; 0x02
    1172:	f3 81       	ldd	r31, Z+3	; 0x03
    1174:	e0 2d       	mov	r30, r0
    1176:	19 95       	eicall
    1178:	8c 01       	movw	r16, r24
	range_reading = ((uint16_t) data.get() << 8) | ((uint16_t) data.get());
    117a:	dc 01       	movw	r26, r24
    117c:	ed 91       	ld	r30, X+
    117e:	fc 91       	ld	r31, X
    1180:	00 84       	ldd	r0, Z+8	; 0x08
    1182:	f1 85       	ldd	r31, Z+9	; 0x09
    1184:	e0 2d       	mov	r30, r0
    1186:	19 95       	eicall
    1188:	f8 2e       	mov	r15, r24
    118a:	d8 01       	movw	r26, r16
    118c:	ed 91       	ld	r30, X+
    118e:	fc 91       	ld	r31, X
    1190:	00 84       	ldd	r0, Z+8	; 0x08
    1192:	f1 85       	ldd	r31, Z+9	; 0x09
    1194:	e0 2d       	mov	r30, r0
    1196:	c8 01       	movw	r24, r16
    1198:	19 95       	eicall
    119a:	2f 2d       	mov	r18, r15
    119c:	30 e0       	ldi	r19, 0x00	; 0
    119e:	32 2f       	mov	r19, r18
    11a0:	22 27       	eor	r18, r18
    11a2:	a9 01       	movw	r20, r18
    11a4:	48 2b       	or	r20, r24
    11a6:	ca 01       	movw	r24, r20
    11a8:	8b 87       	std	Y+11, r24	; 0x0b
    11aa:	9c 87       	std	Y+12, r25	; 0x0c
	return range_reading;
}
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	1f 91       	pop	r17
    11b2:	0f 91       	pop	r16
    11b4:	ff 90       	pop	r15
    11b6:	08 95       	ret

000011b8 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
    11b8:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    11ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    11bc:	88 23       	and	r24, r24
    11be:	19 f0       	breq	.+6      	; 0x11c6 <_ZN10task_sonar3runEv+0xe>
    11c0:	81 30       	cpi	r24, 0x01	; 1
    11c2:	51 f0       	breq	.+20     	; 0x11d8 <_ZN10task_sonar3runEv+0x20>
    11c4:	25 c0       	rjmp	.+74     	; 0x1210 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
    11c6:	8c 89       	ldd	r24, Y+20	; 0x14
    11c8:	9d 89       	ldd	r25, Y+21	; 0x15
    11ca:	0e 94 9f 08 	call	0x113e	; 0x113e <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
    11ce:	61 e0       	ldi	r22, 0x01	; 1
    11d0:	ce 01       	movw	r24, r28
    11d2:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_ZN8frt_task13transition_toEh>
			
			    break;
    11d6:	1c c0       	rjmp	.+56     	; 0x1210 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
    11d8:	8c 89       	ldd	r24, Y+20	; 0x14
    11da:	9d 89       	ldd	r25, Y+21	; 0x15
    11dc:	0e 94 ad 08 	call	0x115a	; 0x115a <_ZN6MB120211get_readingEv>
    11e0:	7c 01       	movw	r14, r24
    11e2:	8a 8b       	std	Y+18, r24	; 0x12
    11e4:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
    11e6:	6a e0       	ldi	r22, 0x0A	; 10
    11e8:	8e 81       	ldd	r24, Y+6	; 0x06
    11ea:	9f 81       	ldd	r25, Y+7	; 0x07
    11ec:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    11f0:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    11f2:	66 e8       	ldi	r22, 0x86	; 134
    11f4:	73 e0       	ldi	r23, 0x03	; 3
    11f6:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    11fa:	b7 01       	movw	r22, r14
    11fc:	c8 01       	movw	r24, r16
    11fe:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    1202:	66 e0       	ldi	r22, 0x06	; 6
    1204:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
    1208:	60 e0       	ldi	r22, 0x00	; 0
    120a:	ce 01       	movw	r24, r28
    120c:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
    1210:	8e 85       	ldd	r24, Y+14	; 0x0e
    1212:	9f 85       	ldd	r25, Y+15	; 0x0f
    1214:	a8 89       	ldd	r26, Y+16	; 0x10
    1216:	b9 89       	ldd	r27, Y+17	; 0x11
    1218:	01 96       	adiw	r24, 0x01	; 1
    121a:	a1 1d       	adc	r26, r1
    121c:	b1 1d       	adc	r27, r1
    121e:	8e 87       	std	Y+14, r24	; 0x0e
    1220:	9f 87       	std	Y+15, r25	; 0x0f
    1222:	a8 8b       	std	Y+16, r26	; 0x10
    1224:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
    1226:	64 ef       	ldi	r22, 0xF4	; 244
    1228:	71 e0       	ldi	r23, 0x01	; 1
    122a:	80 e0       	ldi	r24, 0x00	; 0
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	0e 94 bb 14 	call	0x2976	; 0x2976 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1232:	c3 cf       	rjmp	.-122    	; 0x11ba <_ZN10task_sonar3runEv+0x2>

00001234 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
    1234:	cf 92       	push	r12
    1236:	df 92       	push	r13
    1238:	ef 92       	push	r14
    123a:	ff 92       	push	r15
    123c:	0f 93       	push	r16
    123e:	1f 93       	push	r17
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	ec 01       	movw	r28, r24
    1246:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
    1248:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <_ZN8frt_taskC1EPKchjP8emstream>
    124c:	8a ea       	ldi	r24, 0xAA	; 170
    124e:	90 e2       	ldi	r25, 0x20	; 32
    1250:	88 83       	st	Y, r24
    1252:	99 83       	std	Y+1, r25	; 0x01
    1254:	ec 8a       	std	Y+20, r14	; 0x14
    1256:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
    1258:	ce 8a       	std	Y+22, r12	; 0x16
    125a:	df 8a       	std	Y+23, r13	; 0x17
}
    125c:	df 91       	pop	r29
    125e:	cf 91       	pop	r28
    1260:	1f 91       	pop	r17
    1262:	0f 91       	pop	r16
    1264:	ff 90       	pop	r15
    1266:	ef 90       	pop	r14
    1268:	df 90       	pop	r13
    126a:	cf 90       	pop	r12
    126c:	08 95       	ret

0000126e <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	cf 93       	push	r28
    1274:	df 93       	push	r29
    1276:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
    1278:	0e 94 eb 16 	call	0x2dd6	; 0x2dd6 <_ZN8frt_taskC1EPKchjP8emstream>
    127c:	82 eb       	ldi	r24, 0xB2	; 178
    127e:	90 e2       	ldi	r25, 0x20	; 32
    1280:	88 83       	st	Y, r24
    1282:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
    1284:	df 91       	pop	r29
    1286:	cf 91       	pop	r28
    1288:	1f 91       	pop	r17
    128a:	0f 91       	pop	r16
    128c:	08 95       	ret

0000128e <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
    128e:	0f 93       	push	r16
    1290:	1f 93       	push	r17
    1292:	cf 93       	push	r28
    1294:	df 93       	push	r29
    1296:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
    1298:	6a e0       	ldi	r22, 0x0A	; 10
    129a:	8e 81       	ldd	r24, Y+6	; 0x06
    129c:	9f 81       	ldd	r25, Y+7	; 0x07
    129e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    12a2:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    12a4:	61 ee       	ldi	r22, 0xE1	; 225
    12a6:	74 e0       	ldi	r23, 0x04	; 4
    12a8:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    12ac:	6a e0       	ldi	r22, 0x0A	; 10
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    12b4:	8c 01       	movw	r16, r24
    12b6:	6b ed       	ldi	r22, 0xDB	; 219
    12b8:	74 e0       	ldi	r23, 0x04	; 4
    12ba:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    12be:	67 e0       	ldi	r22, 0x07	; 7
    12c0:	c8 01       	movw	r24, r16
    12c2:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
    12c6:	6a e0       	ldi	r22, 0x0A	; 10
    12c8:	8e 81       	ldd	r24, Y+6	; 0x06
    12ca:	9f 81       	ldd	r25, Y+7	; 0x07
    12cc:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    12d0:	8c 01       	movw	r16, r24
    12d2:	6c eb       	ldi	r22, 0xBC	; 188
    12d4:	74 e0       	ldi	r23, 0x04	; 4
    12d6:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    12da:	6a e0       	ldi	r22, 0x0A	; 10
    12dc:	c8 01       	movw	r24, r16
    12de:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    12e2:	8c 01       	movw	r16, r24
    12e4:	66 eb       	ldi	r22, 0xB6	; 182
    12e6:	74 e0       	ldi	r23, 0x04	; 4
    12e8:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    12ec:	66 e0       	ldi	r22, 0x06	; 6
    12ee:	c8 01       	movw	r24, r16
    12f0:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
    12f4:	6a e0       	ldi	r22, 0x0A	; 10
    12f6:	8e 81       	ldd	r24, Y+6	; 0x06
    12f8:	9f 81       	ldd	r25, Y+7	; 0x07
    12fa:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    12fe:	8c 01       	movw	r16, r24
    1300:	6f e9       	ldi	r22, 0x9F	; 159
    1302:	74 e0       	ldi	r23, 0x04	; 4
    1304:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1308:	66 e0       	ldi	r22, 0x06	; 6
    130a:	c8 01       	movw	r24, r16
    130c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
    1310:	6a e0       	ldi	r22, 0x0A	; 10
    1312:	8e 81       	ldd	r24, Y+6	; 0x06
    1314:	9f 81       	ldd	r25, Y+7	; 0x07
    1316:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    131a:	8c 01       	movw	r16, r24
    131c:	63 e8       	ldi	r22, 0x83	; 131
    131e:	74 e0       	ldi	r23, 0x04	; 4
    1320:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1324:	66 e0       	ldi	r22, 0x06	; 6
    1326:	c8 01       	movw	r24, r16
    1328:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
    132c:	6a e0       	ldi	r22, 0x0A	; 10
    132e:	8e 81       	ldd	r24, Y+6	; 0x06
    1330:	9f 81       	ldd	r25, Y+7	; 0x07
    1332:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1336:	8c 01       	movw	r16, r24
    1338:	6b e6       	ldi	r22, 0x6B	; 107
    133a:	74 e0       	ldi	r23, 0x04	; 4
    133c:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1340:	66 e0       	ldi	r22, 0x06	; 6
    1342:	c8 01       	movw	r24, r16
    1344:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
    1348:	6a e0       	ldi	r22, 0x0A	; 10
    134a:	8e 81       	ldd	r24, Y+6	; 0x06
    134c:	9f 81       	ldd	r25, Y+7	; 0x07
    134e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1352:	8c 01       	movw	r16, r24
    1354:	6a e4       	ldi	r22, 0x4A	; 74
    1356:	74 e0       	ldi	r23, 0x04	; 4
    1358:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    135c:	66 e0       	ldi	r22, 0x06	; 6
    135e:	c8 01       	movw	r24, r16
    1360:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
    1364:	6a e0       	ldi	r22, 0x0A	; 10
    1366:	8e 81       	ldd	r24, Y+6	; 0x06
    1368:	9f 81       	ldd	r25, Y+7	; 0x07
    136a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    136e:	8c 01       	movw	r16, r24
    1370:	63 e2       	ldi	r22, 0x23	; 35
    1372:	74 e0       	ldi	r23, 0x04	; 4
    1374:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1378:	66 e0       	ldi	r22, 0x06	; 6
    137a:	c8 01       	movw	r24, r16
    137c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
    1380:	6a e0       	ldi	r22, 0x0A	; 10
    1382:	8e 81       	ldd	r24, Y+6	; 0x06
    1384:	9f 81       	ldd	r25, Y+7	; 0x07
    1386:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    138a:	8c 01       	movw	r16, r24
    138c:	65 e0       	ldi	r22, 0x05	; 5
    138e:	74 e0       	ldi	r23, 0x04	; 4
    1390:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1394:	66 e0       	ldi	r22, 0x06	; 6
    1396:	c8 01       	movw	r24, r16
    1398:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
    139c:	6a e0       	ldi	r22, 0x0A	; 10
    139e:	8e 81       	ldd	r24, Y+6	; 0x06
    13a0:	9f 81       	ldd	r25, Y+7	; 0x07
    13a2:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    13a6:	8c 01       	movw	r16, r24
    13a8:	6a ee       	ldi	r22, 0xEA	; 234
    13aa:	73 e0       	ldi	r23, 0x03	; 3
    13ac:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    13b0:	66 e0       	ldi	r22, 0x06	; 6
    13b2:	c8 01       	movw	r24, r16
    13b4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
    13b8:	6a e0       	ldi	r22, 0x0A	; 10
    13ba:	8e 81       	ldd	r24, Y+6	; 0x06
    13bc:	9f 81       	ldd	r25, Y+7	; 0x07
    13be:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    13c2:	ec 01       	movw	r28, r24
    13c4:	6b ed       	ldi	r22, 0xDB	; 219
    13c6:	73 e0       	ldi	r23, 0x03	; 3
    13c8:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    13cc:	66 e0       	ldi	r22, 0x06	; 6
    13ce:	ce 01       	movw	r24, r28
    13d0:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
}
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	08 95       	ret

000013de <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
    13de:	af 92       	push	r10
    13e0:	bf 92       	push	r11
    13e2:	cf 92       	push	r12
    13e4:	df 92       	push	r13
    13e6:	ef 92       	push	r14
    13e8:	ff 92       	push	r15
    13ea:	0f 93       	push	r16
    13ec:	1f 93       	push	r17
    13ee:	cf 93       	push	r28
    13f0:	df 93       	push	r29
    13f2:	00 d0       	rcall	.+0      	; 0x13f4 <_ZN9task_user11show_statusEv+0x16>
    13f4:	00 d0       	rcall	.+0      	; 0x13f6 <_ZN9task_user11show_statusEv+0x18>
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
    13fa:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    13fc:	19 82       	std	Y+1, r1	; 0x01
    13fe:	1a 82       	std	Y+2, r1	; 0x02
    1400:	1b 82       	std	Y+3, r1	; 0x03
    1402:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    1404:	1d 82       	std	Y+5, r1	; 0x05
    1406:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
    1408:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <xPortGetFreeHeapSize>
    140c:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
    140e:	ce 01       	movw	r24, r28
    1410:	01 96       	adiw	r24, 0x01	; 1
    1412:	0e 94 9c 1a 	call	0x3538	; 0x3538 <_ZN10time_stamp10set_to_nowEv>
    1416:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
    1418:	66 e0       	ldi	r22, 0x06	; 6
    141a:	f8 01       	movw	r30, r16
    141c:	86 81       	ldd	r24, Z+6	; 0x06
    141e:	97 81       	ldd	r25, Z+7	; 0x07
    1420:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1424:	6a e0       	ldi	r22, 0x0A	; 10
    1426:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    142a:	7c 01       	movw	r14, r24
    142c:	6c eb       	ldi	r22, 0xBC	; 188
    142e:	73 e0       	ldi	r23, 0x03	; 3
    1430:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1434:	6a e0       	ldi	r22, 0x0A	; 10
    1436:	c7 01       	movw	r24, r14
    1438:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    143c:	7c 01       	movw	r14, r24
    143e:	60 eb       	ldi	r22, 0xB0	; 176
    1440:	73 e0       	ldi	r23, 0x03	; 3
    1442:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1446:	66 e0       	ldi	r22, 0x06	; 6
    1448:	c7 01       	movw	r24, r14
    144a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
    144e:	6a e0       	ldi	r22, 0x0A	; 10
    1450:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1454:	7c 01       	movw	r14, r24
    1456:	69 ea       	ldi	r22, 0xA9	; 169
    1458:	73 e0       	ldi	r23, 0x03	; 3
    145a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    145e:	b5 01       	movw	r22, r10
    1460:	c7 01       	movw	r24, r14
    1462:	0e 94 40 1a 	call	0x3480	; 0x3480 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
    1466:	6a e0       	ldi	r22, 0x0A	; 10
    1468:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    146c:	7c 01       	movw	r14, r24
    146e:	6b e9       	ldi	r22, 0x9B	; 155
    1470:	73 e0       	ldi	r23, 0x03	; 3
    1472:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1476:	b6 01       	movw	r22, r12
    1478:	c7 01       	movw	r24, r14
    147a:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    147e:	6a e0       	ldi	r22, 0x0A	; 10
    1480:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1484:	7c 01       	movw	r14, r24
    1486:	69 e9       	ldi	r22, 0x99	; 153
    1488:	73 e0       	ldi	r23, 0x03	; 3
    148a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
    148e:	4f ef       	ldi	r20, 0xFF	; 255
    1490:	5f e0       	ldi	r21, 0x0F	; 15
    1492:	60 e0       	ldi	r22, 0x00	; 0
    1494:	70 e0       	ldi	r23, 0x00	; 0
    1496:	c7 01       	movw	r24, r14
    1498:	0e 94 cb 1c 	call	0x3996	; 0x3996 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
    149c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    14a0:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    14a4:	6a e0       	ldi	r22, 0x0A	; 10
    14a6:	f8 01       	movw	r30, r16
    14a8:	86 81       	ldd	r24, Z+6	; 0x06
    14aa:	97 81       	ldd	r25, Z+7	; 0x07
    14ac:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    14b0:	7c 01       	movw	r14, r24
    14b2:	6e e8       	ldi	r22, 0x8E	; 142
    14b4:	73 e0       	ldi	r23, 0x03	; 3
    14b6:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    14ba:	b6 01       	movw	r22, r12
    14bc:	c7 01       	movw	r24, r14
    14be:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    14c2:	66 e0       	ldi	r22, 0x06	; 6
    14c4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    14c8:	66 e0       	ldi	r22, 0x06	; 6
    14ca:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
    14ce:	f8 01       	movw	r30, r16
    14d0:	86 81       	ldd	r24, Z+6	; 0x06
    14d2:	97 81       	ldd	r25, Z+7	; 0x07
    14d4:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <_Z15print_task_listP8emstream>
}
    14d8:	26 96       	adiw	r28, 0x06	; 6
    14da:	cd bf       	out	0x3d, r28	; 61
    14dc:	de bf       	out	0x3e, r29	; 62
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	df 90       	pop	r13
    14ec:	cf 90       	pop	r12
    14ee:	bf 90       	pop	r11
    14f0:	af 90       	pop	r10
    14f2:	08 95       	ret

000014f4 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	00 d0       	rcall	.+0      	; 0x14fa <_ZN9task_user3runEv+0x6>
    14fa:	00 d0       	rcall	.+0      	; 0x14fc <_ZN9task_user3runEv+0x8>
    14fc:	cd b7       	in	r28, 0x3d	; 61
    14fe:	de b7       	in	r29, 0x3e	; 62
    1500:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
    1502:	19 82       	std	Y+1, r1	; 0x01
    1504:	1a 82       	std	Y+2, r1	; 0x02
    1506:	1b 82       	std	Y+3, r1	; 0x03
    1508:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
    150a:	1d 82       	std	Y+5, r1	; 0x05
    150c:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
    150e:	6a e0       	ldi	r22, 0x0A	; 10
    1510:	dc 01       	movw	r26, r24
    1512:	16 96       	adiw	r26, 0x06	; 6
    1514:	8d 91       	ld	r24, X+
    1516:	9c 91       	ld	r25, X
    1518:	17 97       	sbiw	r26, 0x07	; 7
    151a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    151e:	7c 01       	movw	r14, r24
    1520:	6a e2       	ldi	r22, 0x2A	; 42
    1522:	75 e0       	ldi	r23, 0x05	; 5
    1524:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1528:	66 e0       	ldi	r22, 0x06	; 6
    152a:	c7 01       	movw	r24, r14
    152c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
    1530:	f8 01       	movw	r30, r16
    1532:	84 85       	ldd	r24, Z+12	; 0x0c
    1534:	88 23       	and	r24, r24
    1536:	21 f0       	breq	.+8      	; 0x1540 <_ZN9task_user3runEv+0x4c>
    1538:	81 30       	cpi	r24, 0x01	; 1
    153a:	09 f4       	brne	.+2      	; 0x153e <_ZN9task_user3runEv+0x4a>
    153c:	5d c0       	rjmp	.+186    	; 0x15f8 <_ZN9task_user3runEv+0x104>
    153e:	d8 c0       	rjmp	.+432    	; 0x16f0 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
    1540:	86 81       	ldd	r24, Z+6	; 0x06
    1542:	97 81       	ldd	r25, Z+7	; 0x07
    1544:	dc 01       	movw	r26, r24
    1546:	ed 91       	ld	r30, X+
    1548:	fc 91       	ld	r31, X
    154a:	04 80       	ldd	r0, Z+4	; 0x04
    154c:	f5 81       	ldd	r31, Z+5	; 0x05
    154e:	e0 2d       	mov	r30, r0
    1550:	19 95       	eicall
    1552:	88 23       	and	r24, r24
    1554:	a9 f1       	breq	.+106    	; 0x15c0 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
    1556:	f8 01       	movw	r30, r16
    1558:	86 81       	ldd	r24, Z+6	; 0x06
    155a:	97 81       	ldd	r25, Z+7	; 0x07
    155c:	dc 01       	movw	r26, r24
    155e:	ed 91       	ld	r30, X+
    1560:	fc 91       	ld	r31, X
    1562:	06 80       	ldd	r0, Z+6	; 0x06
    1564:	f7 81       	ldd	r31, Z+7	; 0x07
    1566:	e0 2d       	mov	r30, r0
    1568:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
    156a:	99 27       	eor	r25, r25
    156c:	81 30       	cpi	r24, 0x01	; 1
    156e:	91 05       	cpc	r25, r1
    1570:	f9 f0       	breq	.+62     	; 0x15b0 <_ZN9task_user3runEv+0xbc>
    1572:	03 97       	sbiw	r24, 0x03	; 3
    1574:	09 f0       	breq	.+2      	; 0x1578 <_ZN9task_user3runEv+0x84>
    1576:	d8 c0       	rjmp	.+432    	; 0x1728 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
    1578:	6a e0       	ldi	r22, 0x0A	; 10
    157a:	f8 01       	movw	r30, r16
    157c:	86 81       	ldd	r24, Z+6	; 0x06
    157e:	97 81       	ldd	r25, Z+7	; 0x07
    1580:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1584:	8c 01       	movw	r16, r24
    1586:	6c e1       	ldi	r22, 0x1C	; 28
    1588:	75 e0       	ldi	r23, 0x05	; 5
    158a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    158e:	66 e0       	ldi	r22, 0x06	; 6
    1590:	c8 01       	movw	r24, r16
    1592:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
    1596:	93 e0       	ldi	r25, 0x03	; 3
    1598:	88 ed       	ldi	r24, 0xD8	; 216
    159a:	08 b6       	in	r0, 0x38	; 56
    159c:	18 be       	out	0x38, r1	; 56
    159e:	84 bf       	out	0x34, r24	; 52
    15a0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    15a4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    15a8:	81 fd       	sbrc	r24, 1
    15aa:	fc cf       	rjmp	.-8      	; 0x15a4 <_ZN9task_user3runEv+0xb0>
    15ac:	08 be       	out	0x38, r0	; 56
    15ae:	ff cf       	rjmp	.-2      	; 0x15ae <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
    15b0:	c8 01       	movw	r24, r16
    15b2:	0e 94 47 09 	call	0x128e	; 0x128e <_ZN9task_user18print_help_messageEv>
							transition_to (1);
    15b6:	61 e0       	ldi	r22, 0x01	; 1
    15b8:	c8 01       	movw	r24, r16
    15ba:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_ZN8frt_task13transition_toEh>
							break;
    15be:	b4 c0       	rjmp	.+360    	; 0x1728 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
    15c0:	84 e2       	ldi	r24, 0x24	; 36
    15c2:	92 e3       	ldi	r25, 0x32	; 50
    15c4:	0e 94 a8 19 	call	0x3350	; 0x3350 <_ZN14frt_text_queue14check_for_charEv>
    15c8:	88 23       	and	r24, r24
    15ca:	09 f4       	brne	.+2      	; 0x15ce <_ZN9task_user3runEv+0xda>
    15cc:	ad c0       	rjmp	.+346    	; 0x1728 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    15ce:	d8 01       	movw	r26, r16
    15d0:	16 96       	adiw	r26, 0x06	; 6
    15d2:	ed 91       	ld	r30, X+
    15d4:	fc 91       	ld	r31, X
    15d6:	17 97       	sbiw	r26, 0x07	; 7
    15d8:	01 90       	ld	r0, Z+
    15da:	f0 81       	ld	r31, Z
    15dc:	e0 2d       	mov	r30, r0
    15de:	e2 80       	ldd	r14, Z+2	; 0x02
    15e0:	f3 80       	ldd	r15, Z+3	; 0x03
    15e2:	84 e2       	ldi	r24, 0x24	; 36
    15e4:	92 e3       	ldi	r25, 0x32	; 50
    15e6:	0e 94 8a 19 	call	0x3314	; 0x3314 <_ZN14frt_text_queue7getcharEv>
    15ea:	68 2f       	mov	r22, r24
    15ec:	f8 01       	movw	r30, r16
    15ee:	86 81       	ldd	r24, Z+6	; 0x06
    15f0:	97 81       	ldd	r25, Z+7	; 0x07
    15f2:	f7 01       	movw	r30, r14
    15f4:	19 95       	eicall
    15f6:	98 c0       	rjmp	.+304    	; 0x1728 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    15f8:	86 81       	ldd	r24, Z+6	; 0x06
    15fa:	97 81       	ldd	r25, Z+7	; 0x07
    15fc:	dc 01       	movw	r26, r24
    15fe:	ed 91       	ld	r30, X+
    1600:	fc 91       	ld	r31, X
    1602:	04 80       	ldd	r0, Z+4	; 0x04
    1604:	f5 81       	ldd	r31, Z+5	; 0x05
    1606:	e0 2d       	mov	r30, r0
    1608:	19 95       	eicall
    160a:	88 23       	and	r24, r24
    160c:	09 f4       	brne	.+2      	; 0x1610 <_ZN9task_user3runEv+0x11c>
    160e:	8c c0       	rjmp	.+280    	; 0x1728 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    1610:	f8 01       	movw	r30, r16
    1612:	86 81       	ldd	r24, Z+6	; 0x06
    1614:	97 81       	ldd	r25, Z+7	; 0x07
    1616:	dc 01       	movw	r26, r24
    1618:	ed 91       	ld	r30, X+
    161a:	fc 91       	ld	r31, X
    161c:	06 80       	ldd	r0, Z+6	; 0x06
    161e:	f7 81       	ldd	r31, Z+7	; 0x07
    1620:	e0 2d       	mov	r30, r0
    1622:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    1624:	9c 01       	movw	r18, r24
    1626:	33 27       	eor	r19, r19
    1628:	28 36       	cpi	r18, 0x68	; 104
    162a:	31 05       	cpc	r19, r1
    162c:	59 f1       	breq	.+86     	; 0x1684 <_ZN9task_user3runEv+0x190>
    162e:	3c f4       	brge	.+14     	; 0x163e <_ZN9task_user3runEv+0x14a>
    1630:	2b 31       	cpi	r18, 0x1B	; 27
    1632:	31 05       	cpc	r19, r1
    1634:	59 f1       	breq	.+86     	; 0x168c <_ZN9task_user3runEv+0x198>
    1636:	25 36       	cpi	r18, 0x65	; 101
    1638:	31 05       	cpc	r19, r1
    163a:	41 f1       	breq	.+80     	; 0x168c <_ZN9task_user3runEv+0x198>
    163c:	3b c0       	rjmp	.+118    	; 0x16b4 <_ZN9task_user3runEv+0x1c0>
    163e:	23 37       	cpi	r18, 0x73	; 115
    1640:	31 05       	cpc	r19, r1
    1642:	c1 f0       	breq	.+48     	; 0x1674 <_ZN9task_user3runEv+0x180>
    1644:	26 37       	cpi	r18, 0x76	; 118
    1646:	31 05       	cpc	r19, r1
    1648:	89 f0       	breq	.+34     	; 0x166c <_ZN9task_user3runEv+0x178>
    164a:	2e 36       	cpi	r18, 0x6E	; 110
    164c:	31 05       	cpc	r19, r1
    164e:	91 f5       	brne	.+100    	; 0x16b4 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    1650:	ce 01       	movw	r24, r28
    1652:	01 96       	adiw	r24, 0x01	; 1
    1654:	0e 94 9c 1a 	call	0x3538	; 0x3538 <_ZN10time_stamp10set_to_nowEv>
    1658:	bc 01       	movw	r22, r24
    165a:	f8 01       	movw	r30, r16
    165c:	86 81       	ldd	r24, Z+6	; 0x06
    165e:	97 81       	ldd	r25, Z+7	; 0x07
    1660:	0e 94 40 1a 	call	0x3480	; 0x3480 <_ZlsR8emstreamR10time_stamp>
    1664:	66 e0       	ldi	r22, 0x06	; 6
    1666:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    166a:	5e c0       	rjmp	.+188    	; 0x1728 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    166c:	c8 01       	movw	r24, r16
    166e:	0e 94 ef 09 	call	0x13de	; 0x13de <_ZN9task_user11show_statusEv>
							break;
    1672:	5a c0       	rjmp	.+180    	; 0x1728 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    1674:	d8 01       	movw	r26, r16
    1676:	16 96       	adiw	r26, 0x06	; 6
    1678:	8d 91       	ld	r24, X+
    167a:	9c 91       	ld	r25, X
    167c:	17 97       	sbiw	r26, 0x07	; 7
    167e:	0e 94 00 18 	call	0x3000	; 0x3000 <_Z17print_task_stacksP8emstream>
							break;
    1682:	52 c0       	rjmp	.+164    	; 0x1728 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    1684:	c8 01       	movw	r24, r16
    1686:	0e 94 47 09 	call	0x128e	; 0x128e <_ZN9task_user18print_help_messageEv>
							break;
    168a:	4e c0       	rjmp	.+156    	; 0x1728 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    168c:	6a e0       	ldi	r22, 0x0A	; 10
    168e:	f8 01       	movw	r30, r16
    1690:	86 81       	ldd	r24, Z+6	; 0x06
    1692:	97 81       	ldd	r25, Z+7	; 0x07
    1694:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    1698:	7c 01       	movw	r14, r24
    169a:	6a e0       	ldi	r22, 0x0A	; 10
    169c:	75 e0       	ldi	r23, 0x05	; 5
    169e:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    16a2:	66 e0       	ldi	r22, 0x06	; 6
    16a4:	c7 01       	movw	r24, r14
    16a6:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    16aa:	60 e0       	ldi	r22, 0x00	; 0
    16ac:	c8 01       	movw	r24, r16
    16ae:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_ZN8frt_task13transition_toEh>
							break;
    16b2:	3a c0       	rjmp	.+116    	; 0x1728 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    16b4:	f8 01       	movw	r30, r16
    16b6:	a6 81       	ldd	r26, Z+6	; 0x06
    16b8:	b7 81       	ldd	r27, Z+7	; 0x07
    16ba:	ed 91       	ld	r30, X+
    16bc:	fc 91       	ld	r31, X
    16be:	11 97       	sbiw	r26, 0x01	; 1
    16c0:	02 80       	ldd	r0, Z+2	; 0x02
    16c2:	f3 81       	ldd	r31, Z+3	; 0x03
    16c4:	e0 2d       	mov	r30, r0
    16c6:	68 2f       	mov	r22, r24
    16c8:	cd 01       	movw	r24, r26
    16ca:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    16cc:	6a e0       	ldi	r22, 0x0A	; 10
    16ce:	d8 01       	movw	r26, r16
    16d0:	16 96       	adiw	r26, 0x06	; 6
    16d2:	8d 91       	ld	r24, X+
    16d4:	9c 91       	ld	r25, X
    16d6:	17 97       	sbiw	r26, 0x07	; 7
    16d8:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    16dc:	7c 01       	movw	r14, r24
    16de:	64 e0       	ldi	r22, 0x04	; 4
    16e0:	75 e0       	ldi	r23, 0x05	; 5
    16e2:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    16e6:	66 e0       	ldi	r22, 0x06	; 6
    16e8:	c7 01       	movw	r24, r14
    16ea:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
							break;
    16ee:	1c c0       	rjmp	.+56     	; 0x1728 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    16f0:	6a e0       	ldi	r22, 0x0A	; 10
    16f2:	f8 01       	movw	r30, r16
    16f4:	86 81       	ldd	r24, Z+6	; 0x06
    16f6:	97 81       	ldd	r25, Z+7	; 0x07
    16f8:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    16fc:	8c 01       	movw	r16, r24
    16fe:	67 ee       	ldi	r22, 0xE7	; 231
    1700:	74 e0       	ldi	r23, 0x04	; 4
    1702:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    1706:	66 e0       	ldi	r22, 0x06	; 6
    1708:	c8 01       	movw	r24, r16
    170a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    170e:	93 e0       	ldi	r25, 0x03	; 3
    1710:	88 ed       	ldi	r24, 0xD8	; 216
    1712:	08 b6       	in	r0, 0x38	; 56
    1714:	18 be       	out	0x38, r1	; 56
    1716:	84 bf       	out	0x34, r24	; 52
    1718:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    171c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1720:	81 fd       	sbrc	r24, 1
    1722:	fc cf       	rjmp	.-8      	; 0x171c <_ZN9task_user3runEv+0x228>
    1724:	08 be       	out	0x38, r0	; 56
    1726:	ff cf       	rjmp	.-2      	; 0x1726 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1728:	f8 01       	movw	r30, r16
    172a:	86 85       	ldd	r24, Z+14	; 0x0e
    172c:	97 85       	ldd	r25, Z+15	; 0x0f
    172e:	a0 89       	ldd	r26, Z+16	; 0x10
    1730:	b1 89       	ldd	r27, Z+17	; 0x11
    1732:	01 96       	adiw	r24, 0x01	; 1
    1734:	a1 1d       	adc	r26, r1
    1736:	b1 1d       	adc	r27, r1
    1738:	86 87       	std	Z+14, r24	; 0x0e
    173a:	97 87       	std	Z+15, r25	; 0x0f
    173c:	a0 8b       	std	Z+16, r26	; 0x10
    173e:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1740:	61 e0       	ldi	r22, 0x01	; 1
    1742:	70 e0       	ldi	r23, 0x00	; 0
    1744:	80 e0       	ldi	r24, 0x00	; 0
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	0e 94 bb 14 	call	0x2976	; 0x2976 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    174c:	f1 ce       	rjmp	.-542    	; 0x1530 <_ZN9task_user3runEv+0x3c>

0000174e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    174e:	0f 93       	push	r16
    1750:	1f 93       	push	r17
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1758:	0e 94 17 13 	call	0x262e	; 0x262e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    175c:	80 91 68 21 	lds	r24, 0x2168	; 0x802168 <__data_end>
    1760:	81 11       	cpse	r24, r1
    1762:	1d c0       	rjmp	.+58     	; 0x179e <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1764:	ad e6       	ldi	r26, 0x6D	; 109
    1766:	b1 e2       	ldi	r27, 0x21	; 33
    1768:	e1 e7       	ldi	r30, 0x71	; 113
    176a:	f1 e2       	ldi	r31, 0x21	; 33
    176c:	ed 93       	st	X+, r30
    176e:	fc 93       	st	X, r31
    1770:	11 97       	sbiw	r26, 0x01	; 1
    1772:	12 96       	adiw	r26, 0x02	; 2
    1774:	1d 92       	st	X+, r1
    1776:	1c 92       	st	X, r1
    1778:	13 97       	sbiw	r26, 0x03	; 3
    177a:	a9 e6       	ldi	r26, 0x69	; 105
    177c:	b1 e2       	ldi	r27, 0x21	; 33
    177e:	8f ef       	ldi	r24, 0xFF	; 255
    1780:	9f e0       	ldi	r25, 0x0F	; 15
    1782:	12 96       	adiw	r26, 0x02	; 2
    1784:	8d 93       	st	X+, r24
    1786:	9c 93       	st	X, r25
    1788:	13 97       	sbiw	r26, 0x03	; 3
    178a:	1d 92       	st	X+, r1
    178c:	1c 92       	st	X, r1
    178e:	11 97       	sbiw	r26, 0x01	; 1
    1790:	82 83       	std	Z+2, r24	; 0x02
    1792:	93 83       	std	Z+3, r25	; 0x03
    1794:	a0 83       	st	Z, r26
    1796:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    1798:	81 e0       	ldi	r24, 0x01	; 1
    179a:	80 93 68 21 	sts	0x2168, r24	; 0x802168 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    179e:	20 97       	sbiw	r28, 0x00	; 0
    17a0:	09 f4       	brne	.+2      	; 0x17a4 <pvPortMalloc+0x56>
    17a2:	5f c0       	rjmp	.+190    	; 0x1862 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    17a4:	9e 01       	movw	r18, r28
    17a6:	2b 5f       	subi	r18, 0xFB	; 251
    17a8:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    17aa:	24 96       	adiw	r28, 0x04	; 4
    17ac:	ce 3f       	cpi	r28, 0xFE	; 254
    17ae:	df 40       	sbci	r29, 0x0F	; 15
    17b0:	08 f0       	brcs	.+2      	; 0x17b4 <pvPortMalloc+0x66>
    17b2:	5a c0       	rjmp	.+180    	; 0x1868 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    17b4:	e0 91 6d 21 	lds	r30, 0x216D	; 0x80216d <xStart>
    17b8:	f0 91 6e 21 	lds	r31, 0x216E	; 0x80216e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    17bc:	ad e6       	ldi	r26, 0x6D	; 109
    17be:	b1 e2       	ldi	r27, 0x21	; 33
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17c0:	02 c0       	rjmp	.+4      	; 0x17c6 <pvPortMalloc+0x78>
    17c2:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    17c4:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    17c6:	82 81       	ldd	r24, Z+2	; 0x02
    17c8:	93 81       	ldd	r25, Z+3	; 0x03
    17ca:	82 17       	cp	r24, r18
    17cc:	93 07       	cpc	r25, r19
    17ce:	20 f4       	brcc	.+8      	; 0x17d8 <pvPortMalloc+0x8a>
    17d0:	80 81       	ld	r24, Z
    17d2:	91 81       	ldd	r25, Z+1	; 0x01
    17d4:	00 97       	sbiw	r24, 0x00	; 0
    17d6:	a9 f7       	brne	.-22     	; 0x17c2 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    17d8:	c1 e2       	ldi	r28, 0x21	; 33
    17da:	e9 36       	cpi	r30, 0x69	; 105
    17dc:	fc 07       	cpc	r31, r28
    17de:	09 f4       	brne	.+2      	; 0x17e2 <pvPortMalloc+0x94>
    17e0:	46 c0       	rjmp	.+140    	; 0x186e <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    17e2:	cd 91       	ld	r28, X+
    17e4:	dc 91       	ld	r29, X
    17e6:	11 97       	sbiw	r26, 0x01	; 1
    17e8:	8e 01       	movw	r16, r28
    17ea:	0b 5f       	subi	r16, 0xFB	; 251
    17ec:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    17ee:	80 81       	ld	r24, Z
    17f0:	91 81       	ldd	r25, Z+1	; 0x01
    17f2:	8d 93       	st	X+, r24
    17f4:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    17f6:	82 81       	ldd	r24, Z+2	; 0x02
    17f8:	93 81       	ldd	r25, Z+3	; 0x03
    17fa:	82 1b       	sub	r24, r18
    17fc:	93 0b       	sbc	r25, r19
    17fe:	8b 30       	cpi	r24, 0x0B	; 11
    1800:	91 05       	cpc	r25, r1
    1802:	10 f1       	brcs	.+68     	; 0x1848 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1804:	bf 01       	movw	r22, r30
    1806:	62 0f       	add	r22, r18
    1808:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    180a:	db 01       	movw	r26, r22
    180c:	12 96       	adiw	r26, 0x02	; 2
    180e:	8d 93       	st	X+, r24
    1810:	9c 93       	st	X, r25
    1812:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1814:	22 83       	std	Z+2, r18	; 0x02
    1816:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1818:	12 96       	adiw	r26, 0x02	; 2
    181a:	4d 91       	ld	r20, X+
    181c:	5c 91       	ld	r21, X
    181e:	13 97       	sbiw	r26, 0x03	; 3
    1820:	8d e6       	ldi	r24, 0x6D	; 109
    1822:	91 e2       	ldi	r25, 0x21	; 33
    1824:	01 c0       	rjmp	.+2      	; 0x1828 <pvPortMalloc+0xda>
    1826:	cd 01       	movw	r24, r26
    1828:	ec 01       	movw	r28, r24
    182a:	a8 81       	ld	r26, Y
    182c:	b9 81       	ldd	r27, Y+1	; 0x01
    182e:	12 96       	adiw	r26, 0x02	; 2
    1830:	2d 91       	ld	r18, X+
    1832:	3c 91       	ld	r19, X
    1834:	13 97       	sbiw	r26, 0x03	; 3
    1836:	24 17       	cp	r18, r20
    1838:	35 07       	cpc	r19, r21
    183a:	a8 f3       	brcs	.-22     	; 0x1826 <pvPortMalloc+0xd8>
    183c:	eb 01       	movw	r28, r22
    183e:	a8 83       	st	Y, r26
    1840:	b9 83       	std	Y+1, r27	; 0x01
    1842:	dc 01       	movw	r26, r24
    1844:	6d 93       	st	X+, r22
    1846:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1848:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    184c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1850:	22 81       	ldd	r18, Z+2	; 0x02
    1852:	33 81       	ldd	r19, Z+3	; 0x03
    1854:	82 1b       	sub	r24, r18
    1856:	93 0b       	sbc	r25, r19
    1858:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    185c:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1860:	08 c0       	rjmp	.+16     	; 0x1872 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1862:	00 e0       	ldi	r16, 0x00	; 0
    1864:	10 e0       	ldi	r17, 0x00	; 0
    1866:	05 c0       	rjmp	.+10     	; 0x1872 <pvPortMalloc+0x124>
    1868:	00 e0       	ldi	r16, 0x00	; 0
    186a:	10 e0       	ldi	r17, 0x00	; 0
    186c:	02 c0       	rjmp	.+4      	; 0x1872 <pvPortMalloc+0x124>
    186e:	00 e0       	ldi	r16, 0x00	; 0
    1870:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1872:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1876:	c8 01       	movw	r24, r16
    1878:	df 91       	pop	r29
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	0f 91       	pop	r16
    1880:	08 95       	ret

00001882 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1882:	0f 93       	push	r16
    1884:	1f 93       	push	r17
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    188a:	00 97       	sbiw	r24, 0x00	; 0
    188c:	41 f1       	breq	.+80     	; 0x18de <vPortFree+0x5c>
    188e:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1890:	8c 01       	movw	r16, r24
    1892:	05 50       	subi	r16, 0x05	; 5
    1894:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    1896:	0e 94 17 13 	call	0x262e	; 0x262e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    189a:	f8 01       	movw	r30, r16
    189c:	42 81       	ldd	r20, Z+2	; 0x02
    189e:	53 81       	ldd	r21, Z+3	; 0x03
    18a0:	ad e6       	ldi	r26, 0x6D	; 109
    18a2:	b1 e2       	ldi	r27, 0x21	; 33
    18a4:	01 c0       	rjmp	.+2      	; 0x18a8 <vPortFree+0x26>
    18a6:	df 01       	movw	r26, r30
    18a8:	ed 91       	ld	r30, X+
    18aa:	fc 91       	ld	r31, X
    18ac:	11 97       	sbiw	r26, 0x01	; 1
    18ae:	22 81       	ldd	r18, Z+2	; 0x02
    18b0:	33 81       	ldd	r19, Z+3	; 0x03
    18b2:	24 17       	cp	r18, r20
    18b4:	35 07       	cpc	r19, r21
    18b6:	b8 f3       	brcs	.-18     	; 0x18a6 <vPortFree+0x24>
    18b8:	25 97       	sbiw	r28, 0x05	; 5
    18ba:	e8 83       	st	Y, r30
    18bc:	f9 83       	std	Y+1, r31	; 0x01
    18be:	0d 93       	st	X+, r16
    18c0:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    18c2:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    18c6:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    18ca:	8a 81       	ldd	r24, Y+2	; 0x02
    18cc:	9b 81       	ldd	r25, Y+3	; 0x03
    18ce:	82 0f       	add	r24, r18
    18d0:	93 1f       	adc	r25, r19
    18d2:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    18d6:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    18da:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
	}
}
    18de:	df 91       	pop	r29
    18e0:	cf 91       	pop	r28
    18e2:	1f 91       	pop	r17
    18e4:	0f 91       	pop	r16
    18e6:	08 95       	ret

000018e8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    18e8:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    18ec:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    18f0:	08 95       	ret

000018f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    18f2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    18f4:	03 96       	adiw	r24, 0x03	; 3
    18f6:	81 83       	std	Z+1, r24	; 0x01
    18f8:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    18fa:	4f ef       	ldi	r20, 0xFF	; 255
    18fc:	5f ef       	ldi	r21, 0xFF	; 255
    18fe:	ba 01       	movw	r22, r20
    1900:	43 83       	std	Z+3, r20	; 0x03
    1902:	54 83       	std	Z+4, r21	; 0x04
    1904:	65 83       	std	Z+5, r22	; 0x05
    1906:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1908:	87 83       	std	Z+7, r24	; 0x07
    190a:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    190c:	81 87       	std	Z+9, r24	; 0x09
    190e:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1910:	10 82       	st	Z, r1
    1912:	08 95       	ret

00001914 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1914:	fc 01       	movw	r30, r24
    1916:	12 86       	std	Z+10, r1	; 0x0a
    1918:	13 86       	std	Z+11, r1	; 0x0b
    191a:	08 95       	ret

0000191c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    191c:	cf 93       	push	r28
    191e:	df 93       	push	r29
    1920:	fc 01       	movw	r30, r24
    1922:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1924:	21 81       	ldd	r18, Z+1	; 0x01
    1926:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1928:	e9 01       	movw	r28, r18
    192a:	8c 81       	ldd	r24, Y+4	; 0x04
    192c:	9d 81       	ldd	r25, Y+5	; 0x05
    192e:	14 96       	adiw	r26, 0x04	; 4
    1930:	8d 93       	st	X+, r24
    1932:	9c 93       	st	X, r25
    1934:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1936:	81 81       	ldd	r24, Z+1	; 0x01
    1938:	92 81       	ldd	r25, Z+2	; 0x02
    193a:	16 96       	adiw	r26, 0x06	; 6
    193c:	8d 93       	st	X+, r24
    193e:	9c 93       	st	X, r25
    1940:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1942:	8c 81       	ldd	r24, Y+4	; 0x04
    1944:	9d 81       	ldd	r25, Y+5	; 0x05
    1946:	ec 01       	movw	r28, r24
    1948:	6e 83       	std	Y+6, r22	; 0x06
    194a:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    194c:	e9 01       	movw	r28, r18
    194e:	6c 83       	std	Y+4, r22	; 0x04
    1950:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1952:	61 83       	std	Z+1, r22	; 0x01
    1954:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1956:	1a 96       	adiw	r26, 0x0a	; 10
    1958:	ed 93       	st	X+, r30
    195a:	fc 93       	st	X, r31
    195c:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    195e:	80 81       	ld	r24, Z
    1960:	8f 5f       	subi	r24, 0xFF	; 255
    1962:	80 83       	st	Z, r24
}
    1964:	df 91       	pop	r29
    1966:	cf 91       	pop	r28
    1968:	08 95       	ret

0000196a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    196a:	0f 93       	push	r16
    196c:	1f 93       	push	r17
    196e:	cf 93       	push	r28
    1970:	df 93       	push	r29
    1972:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1974:	08 81       	ld	r16, Y
    1976:	19 81       	ldd	r17, Y+1	; 0x01
    1978:	2a 81       	ldd	r18, Y+2	; 0x02
    197a:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    197c:	0f 3f       	cpi	r16, 0xFF	; 255
    197e:	4f ef       	ldi	r20, 0xFF	; 255
    1980:	14 07       	cpc	r17, r20
    1982:	24 07       	cpc	r18, r20
    1984:	34 07       	cpc	r19, r20
    1986:	31 f4       	brne	.+12     	; 0x1994 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1988:	dc 01       	movw	r26, r24
    198a:	19 96       	adiw	r26, 0x09	; 9
    198c:	ed 91       	ld	r30, X+
    198e:	fc 91       	ld	r31, X
    1990:	1a 97       	sbiw	r26, 0x0a	; 10
    1992:	1f c0       	rjmp	.+62     	; 0x19d2 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1994:	fc 01       	movw	r30, r24
    1996:	33 96       	adiw	r30, 0x03	; 3
    1998:	dc 01       	movw	r26, r24
    199a:	17 96       	adiw	r26, 0x07	; 7
    199c:	4d 91       	ld	r20, X+
    199e:	5c 91       	ld	r21, X
    19a0:	18 97       	sbiw	r26, 0x08	; 8
    19a2:	da 01       	movw	r26, r20
    19a4:	4d 91       	ld	r20, X+
    19a6:	5d 91       	ld	r21, X+
    19a8:	6d 91       	ld	r22, X+
    19aa:	7c 91       	ld	r23, X
    19ac:	04 17       	cp	r16, r20
    19ae:	15 07       	cpc	r17, r21
    19b0:	26 07       	cpc	r18, r22
    19b2:	37 07       	cpc	r19, r23
    19b4:	70 f0       	brcs	.+28     	; 0x19d2 <vListInsert+0x68>
    19b6:	04 80       	ldd	r0, Z+4	; 0x04
    19b8:	f5 81       	ldd	r31, Z+5	; 0x05
    19ba:	e0 2d       	mov	r30, r0
    19bc:	a4 81       	ldd	r26, Z+4	; 0x04
    19be:	b5 81       	ldd	r27, Z+5	; 0x05
    19c0:	4d 91       	ld	r20, X+
    19c2:	5d 91       	ld	r21, X+
    19c4:	6d 91       	ld	r22, X+
    19c6:	7c 91       	ld	r23, X
    19c8:	04 17       	cp	r16, r20
    19ca:	15 07       	cpc	r17, r21
    19cc:	26 07       	cpc	r18, r22
    19ce:	37 07       	cpc	r19, r23
    19d0:	90 f7       	brcc	.-28     	; 0x19b6 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19d2:	a4 81       	ldd	r26, Z+4	; 0x04
    19d4:	b5 81       	ldd	r27, Z+5	; 0x05
    19d6:	ac 83       	std	Y+4, r26	; 0x04
    19d8:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19da:	16 96       	adiw	r26, 0x06	; 6
    19dc:	cd 93       	st	X+, r28
    19de:	dc 93       	st	X, r29
    19e0:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    19e2:	ee 83       	std	Y+6, r30	; 0x06
    19e4:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    19e6:	c4 83       	std	Z+4, r28	; 0x04
    19e8:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19ea:	8a 87       	std	Y+10, r24	; 0x0a
    19ec:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    19ee:	fc 01       	movw	r30, r24
    19f0:	20 81       	ld	r18, Z
    19f2:	2f 5f       	subi	r18, 0xFF	; 255
    19f4:	20 83       	st	Z, r18
}
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	08 95       	ret

00001a00 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1a00:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a02:	a4 81       	ldd	r26, Z+4	; 0x04
    1a04:	b5 81       	ldd	r27, Z+5	; 0x05
    1a06:	86 81       	ldd	r24, Z+6	; 0x06
    1a08:	97 81       	ldd	r25, Z+7	; 0x07
    1a0a:	16 96       	adiw	r26, 0x06	; 6
    1a0c:	8d 93       	st	X+, r24
    1a0e:	9c 93       	st	X, r25
    1a10:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a12:	a6 81       	ldd	r26, Z+6	; 0x06
    1a14:	b7 81       	ldd	r27, Z+7	; 0x07
    1a16:	84 81       	ldd	r24, Z+4	; 0x04
    1a18:	95 81       	ldd	r25, Z+5	; 0x05
    1a1a:	14 96       	adiw	r26, 0x04	; 4
    1a1c:	8d 93       	st	X+, r24
    1a1e:	9c 93       	st	X, r25
    1a20:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1a22:	a2 85       	ldd	r26, Z+10	; 0x0a
    1a24:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a26:	11 96       	adiw	r26, 0x01	; 1
    1a28:	8d 91       	ld	r24, X+
    1a2a:	9c 91       	ld	r25, X
    1a2c:	12 97       	sbiw	r26, 0x02	; 2
    1a2e:	e8 17       	cp	r30, r24
    1a30:	f9 07       	cpc	r31, r25
    1a32:	31 f4       	brne	.+12     	; 0x1a40 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a34:	86 81       	ldd	r24, Z+6	; 0x06
    1a36:	97 81       	ldd	r25, Z+7	; 0x07
    1a38:	11 96       	adiw	r26, 0x01	; 1
    1a3a:	8d 93       	st	X+, r24
    1a3c:	9c 93       	st	X, r25
    1a3e:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1a40:	12 86       	std	Z+10, r1	; 0x0a
    1a42:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1a44:	8c 91       	ld	r24, X
    1a46:	81 50       	subi	r24, 0x01	; 1
    1a48:	8c 93       	st	X, r24
    1a4a:	08 95       	ret

00001a4c <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a4c:	80 93 34 32 	sts	0x3234, r24	; 0x803234 <portStackTopForTask>
    1a50:	90 93 35 32 	sts	0x3235, r25	; 0x803235 <portStackTopForTask+0x1>
    1a54:	31 e1       	ldi	r19, 0x11	; 17
    1a56:	fc 01       	movw	r30, r24
    1a58:	30 83       	st	Z, r19
    1a5a:	31 97       	sbiw	r30, 0x01	; 1
    1a5c:	22 e2       	ldi	r18, 0x22	; 34
    1a5e:	20 83       	st	Z, r18
    1a60:	31 97       	sbiw	r30, 0x01	; 1
    1a62:	a3 e3       	ldi	r26, 0x33	; 51
    1a64:	a0 83       	st	Z, r26
    1a66:	31 97       	sbiw	r30, 0x01	; 1
    1a68:	60 83       	st	Z, r22
    1a6a:	31 97       	sbiw	r30, 0x01	; 1
    1a6c:	70 83       	st	Z, r23
    1a6e:	31 97       	sbiw	r30, 0x01	; 1
    1a70:	10 82       	st	Z, r1
    1a72:	31 97       	sbiw	r30, 0x01	; 1
    1a74:	10 82       	st	Z, r1
    1a76:	31 97       	sbiw	r30, 0x01	; 1
    1a78:	60 e8       	ldi	r22, 0x80	; 128
    1a7a:	60 83       	st	Z, r22
    1a7c:	31 97       	sbiw	r30, 0x01	; 1
    1a7e:	10 82       	st	Z, r1
    1a80:	31 97       	sbiw	r30, 0x01	; 1
    1a82:	10 82       	st	Z, r1
    1a84:	31 97       	sbiw	r30, 0x01	; 1
    1a86:	10 82       	st	Z, r1
    1a88:	31 97       	sbiw	r30, 0x01	; 1
    1a8a:	62 e0       	ldi	r22, 0x02	; 2
    1a8c:	60 83       	st	Z, r22
    1a8e:	31 97       	sbiw	r30, 0x01	; 1
    1a90:	63 e0       	ldi	r22, 0x03	; 3
    1a92:	60 83       	st	Z, r22
    1a94:	31 97       	sbiw	r30, 0x01	; 1
    1a96:	64 e0       	ldi	r22, 0x04	; 4
    1a98:	60 83       	st	Z, r22
    1a9a:	31 97       	sbiw	r30, 0x01	; 1
    1a9c:	65 e0       	ldi	r22, 0x05	; 5
    1a9e:	60 83       	st	Z, r22
    1aa0:	31 97       	sbiw	r30, 0x01	; 1
    1aa2:	66 e0       	ldi	r22, 0x06	; 6
    1aa4:	60 83       	st	Z, r22
    1aa6:	31 97       	sbiw	r30, 0x01	; 1
    1aa8:	67 e0       	ldi	r22, 0x07	; 7
    1aaa:	60 83       	st	Z, r22
    1aac:	31 97       	sbiw	r30, 0x01	; 1
    1aae:	68 e0       	ldi	r22, 0x08	; 8
    1ab0:	60 83       	st	Z, r22
    1ab2:	31 97       	sbiw	r30, 0x01	; 1
    1ab4:	69 e0       	ldi	r22, 0x09	; 9
    1ab6:	60 83       	st	Z, r22
    1ab8:	31 97       	sbiw	r30, 0x01	; 1
    1aba:	60 e1       	ldi	r22, 0x10	; 16
    1abc:	60 83       	st	Z, r22
    1abe:	31 97       	sbiw	r30, 0x01	; 1
    1ac0:	30 83       	st	Z, r19
    1ac2:	31 97       	sbiw	r30, 0x01	; 1
    1ac4:	32 e1       	ldi	r19, 0x12	; 18
    1ac6:	30 83       	st	Z, r19
    1ac8:	31 97       	sbiw	r30, 0x01	; 1
    1aca:	33 e1       	ldi	r19, 0x13	; 19
    1acc:	30 83       	st	Z, r19
    1ace:	31 97       	sbiw	r30, 0x01	; 1
    1ad0:	34 e1       	ldi	r19, 0x14	; 20
    1ad2:	30 83       	st	Z, r19
    1ad4:	31 97       	sbiw	r30, 0x01	; 1
    1ad6:	35 e1       	ldi	r19, 0x15	; 21
    1ad8:	30 83       	st	Z, r19
    1ada:	31 97       	sbiw	r30, 0x01	; 1
    1adc:	36 e1       	ldi	r19, 0x16	; 22
    1ade:	30 83       	st	Z, r19
    1ae0:	31 97       	sbiw	r30, 0x01	; 1
    1ae2:	37 e1       	ldi	r19, 0x17	; 23
    1ae4:	30 83       	st	Z, r19
    1ae6:	31 97       	sbiw	r30, 0x01	; 1
    1ae8:	38 e1       	ldi	r19, 0x18	; 24
    1aea:	30 83       	st	Z, r19
    1aec:	31 97       	sbiw	r30, 0x01	; 1
    1aee:	39 e1       	ldi	r19, 0x19	; 25
    1af0:	30 83       	st	Z, r19
    1af2:	31 97       	sbiw	r30, 0x01	; 1
    1af4:	30 e2       	ldi	r19, 0x20	; 32
    1af6:	30 83       	st	Z, r19
    1af8:	31 97       	sbiw	r30, 0x01	; 1
    1afa:	31 e2       	ldi	r19, 0x21	; 33
    1afc:	30 83       	st	Z, r19
    1afe:	31 97       	sbiw	r30, 0x01	; 1
    1b00:	20 83       	st	Z, r18
    1b02:	31 97       	sbiw	r30, 0x01	; 1
    1b04:	23 e2       	ldi	r18, 0x23	; 35
    1b06:	20 83       	st	Z, r18
    1b08:	31 97       	sbiw	r30, 0x01	; 1
    1b0a:	40 83       	st	Z, r20
    1b0c:	31 97       	sbiw	r30, 0x01	; 1
    1b0e:	50 83       	st	Z, r21
    1b10:	31 97       	sbiw	r30, 0x01	; 1
    1b12:	26 e2       	ldi	r18, 0x26	; 38
    1b14:	20 83       	st	Z, r18
    1b16:	31 97       	sbiw	r30, 0x01	; 1
    1b18:	27 e2       	ldi	r18, 0x27	; 39
    1b1a:	20 83       	st	Z, r18
    1b1c:	31 97       	sbiw	r30, 0x01	; 1
    1b1e:	28 e2       	ldi	r18, 0x28	; 40
    1b20:	20 83       	st	Z, r18
    1b22:	31 97       	sbiw	r30, 0x01	; 1
    1b24:	29 e2       	ldi	r18, 0x29	; 41
    1b26:	20 83       	st	Z, r18
    1b28:	31 97       	sbiw	r30, 0x01	; 1
    1b2a:	20 e3       	ldi	r18, 0x30	; 48
    1b2c:	20 83       	st	Z, r18
    1b2e:	31 97       	sbiw	r30, 0x01	; 1
    1b30:	21 e3       	ldi	r18, 0x31	; 49
    1b32:	20 83       	st	Z, r18
    1b34:	89 97       	sbiw	r24, 0x29	; 41
    1b36:	08 95       	ret

00001b38 <xPortStartScheduler>:
    1b38:	8c e7       	ldi	r24, 0x7C	; 124
    1b3a:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1b3e:	8f ef       	ldi	r24, 0xFF	; 255
    1b40:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    1b44:	81 e0       	ldi	r24, 0x01	; 1
    1b46:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1b4a:	91 e1       	ldi	r25, 0x11	; 17
    1b4c:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1b50:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    1b54:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1b58:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1b5c:	cd 91       	ld	r28, X+
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	dd 91       	ld	r29, X+
    1b62:	de bf       	out	0x3e, r29	; 62
    1b64:	ff 91       	pop	r31
    1b66:	ef 91       	pop	r30
    1b68:	df 91       	pop	r29
    1b6a:	cf 91       	pop	r28
    1b6c:	bf 91       	pop	r27
    1b6e:	af 91       	pop	r26
    1b70:	9f 91       	pop	r25
    1b72:	8f 91       	pop	r24
    1b74:	7f 91       	pop	r23
    1b76:	6f 91       	pop	r22
    1b78:	5f 91       	pop	r21
    1b7a:	4f 91       	pop	r20
    1b7c:	3f 91       	pop	r19
    1b7e:	2f 91       	pop	r18
    1b80:	1f 91       	pop	r17
    1b82:	0f 91       	pop	r16
    1b84:	ff 90       	pop	r15
    1b86:	ef 90       	pop	r14
    1b88:	df 90       	pop	r13
    1b8a:	cf 90       	pop	r12
    1b8c:	bf 90       	pop	r11
    1b8e:	af 90       	pop	r10
    1b90:	9f 90       	pop	r9
    1b92:	8f 90       	pop	r8
    1b94:	7f 90       	pop	r7
    1b96:	6f 90       	pop	r6
    1b98:	5f 90       	pop	r5
    1b9a:	4f 90       	pop	r4
    1b9c:	3f 90       	pop	r3
    1b9e:	2f 90       	pop	r2
    1ba0:	1f 90       	pop	r1
    1ba2:	0f 90       	pop	r0
    1ba4:	0c be       	out	0x3c, r0	; 60
    1ba6:	0f 90       	pop	r0
    1ba8:	0b be       	out	0x3b, r0	; 59
    1baa:	0f 90       	pop	r0
    1bac:	0f be       	out	0x3f, r0	; 63
    1bae:	0f 90       	pop	r0
    1bb0:	08 95       	ret
    1bb2:	08 95       	ret

00001bb4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1bb4:	0f 92       	push	r0
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	f8 94       	cli
    1bba:	0f 92       	push	r0
    1bbc:	0b b6       	in	r0, 0x3b	; 59
    1bbe:	0f 92       	push	r0
    1bc0:	0c b6       	in	r0, 0x3c	; 60
    1bc2:	0f 92       	push	r0
    1bc4:	1f 92       	push	r1
    1bc6:	11 24       	eor	r1, r1
    1bc8:	2f 92       	push	r2
    1bca:	3f 92       	push	r3
    1bcc:	4f 92       	push	r4
    1bce:	5f 92       	push	r5
    1bd0:	6f 92       	push	r6
    1bd2:	7f 92       	push	r7
    1bd4:	8f 92       	push	r8
    1bd6:	9f 92       	push	r9
    1bd8:	af 92       	push	r10
    1bda:	bf 92       	push	r11
    1bdc:	cf 92       	push	r12
    1bde:	df 92       	push	r13
    1be0:	ef 92       	push	r14
    1be2:	ff 92       	push	r15
    1be4:	0f 93       	push	r16
    1be6:	1f 93       	push	r17
    1be8:	2f 93       	push	r18
    1bea:	3f 93       	push	r19
    1bec:	4f 93       	push	r20
    1bee:	5f 93       	push	r21
    1bf0:	6f 93       	push	r22
    1bf2:	7f 93       	push	r23
    1bf4:	8f 93       	push	r24
    1bf6:	9f 93       	push	r25
    1bf8:	af 93       	push	r26
    1bfa:	bf 93       	push	r27
    1bfc:	cf 93       	push	r28
    1bfe:	df 93       	push	r29
    1c00:	ef 93       	push	r30
    1c02:	ff 93       	push	r31
    1c04:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1c08:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1c0c:	0d b6       	in	r0, 0x3d	; 61
    1c0e:	0d 92       	st	X+, r0
    1c10:	0e b6       	in	r0, 0x3e	; 62
    1c12:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1c14:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1c18:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1c1c:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1c20:	cd 91       	ld	r28, X+
    1c22:	cd bf       	out	0x3d, r28	; 61
    1c24:	dd 91       	ld	r29, X+
    1c26:	de bf       	out	0x3e, r29	; 62
    1c28:	ff 91       	pop	r31
    1c2a:	ef 91       	pop	r30
    1c2c:	df 91       	pop	r29
    1c2e:	cf 91       	pop	r28
    1c30:	bf 91       	pop	r27
    1c32:	af 91       	pop	r26
    1c34:	9f 91       	pop	r25
    1c36:	8f 91       	pop	r24
    1c38:	7f 91       	pop	r23
    1c3a:	6f 91       	pop	r22
    1c3c:	5f 91       	pop	r21
    1c3e:	4f 91       	pop	r20
    1c40:	3f 91       	pop	r19
    1c42:	2f 91       	pop	r18
    1c44:	1f 91       	pop	r17
    1c46:	0f 91       	pop	r16
    1c48:	ff 90       	pop	r15
    1c4a:	ef 90       	pop	r14
    1c4c:	df 90       	pop	r13
    1c4e:	cf 90       	pop	r12
    1c50:	bf 90       	pop	r11
    1c52:	af 90       	pop	r10
    1c54:	9f 90       	pop	r9
    1c56:	8f 90       	pop	r8
    1c58:	7f 90       	pop	r7
    1c5a:	6f 90       	pop	r6
    1c5c:	5f 90       	pop	r5
    1c5e:	4f 90       	pop	r4
    1c60:	3f 90       	pop	r3
    1c62:	2f 90       	pop	r2
    1c64:	1f 90       	pop	r1
    1c66:	0f 90       	pop	r0
    1c68:	0c be       	out	0x3c, r0	; 60
    1c6a:	0f 90       	pop	r0
    1c6c:	0b be       	out	0x3b, r0	; 59
    1c6e:	0f 90       	pop	r0
    1c70:	0f be       	out	0x3f, r0	; 63
    1c72:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c74:	08 95       	ret

00001c76 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c76:	0f 92       	push	r0
    1c78:	0f b6       	in	r0, 0x3f	; 63
    1c7a:	f8 94       	cli
    1c7c:	0f 92       	push	r0
    1c7e:	0b b6       	in	r0, 0x3b	; 59
    1c80:	0f 92       	push	r0
    1c82:	0c b6       	in	r0, 0x3c	; 60
    1c84:	0f 92       	push	r0
    1c86:	1f 92       	push	r1
    1c88:	11 24       	eor	r1, r1
    1c8a:	2f 92       	push	r2
    1c8c:	3f 92       	push	r3
    1c8e:	4f 92       	push	r4
    1c90:	5f 92       	push	r5
    1c92:	6f 92       	push	r6
    1c94:	7f 92       	push	r7
    1c96:	8f 92       	push	r8
    1c98:	9f 92       	push	r9
    1c9a:	af 92       	push	r10
    1c9c:	bf 92       	push	r11
    1c9e:	cf 92       	push	r12
    1ca0:	df 92       	push	r13
    1ca2:	ef 92       	push	r14
    1ca4:	ff 92       	push	r15
    1ca6:	0f 93       	push	r16
    1ca8:	1f 93       	push	r17
    1caa:	2f 93       	push	r18
    1cac:	3f 93       	push	r19
    1cae:	4f 93       	push	r20
    1cb0:	5f 93       	push	r21
    1cb2:	6f 93       	push	r22
    1cb4:	7f 93       	push	r23
    1cb6:	8f 93       	push	r24
    1cb8:	9f 93       	push	r25
    1cba:	af 93       	push	r26
    1cbc:	bf 93       	push	r27
    1cbe:	cf 93       	push	r28
    1cc0:	df 93       	push	r29
    1cc2:	ef 93       	push	r30
    1cc4:	ff 93       	push	r31
    1cc6:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1cca:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1cce:	0d b6       	in	r0, 0x3d	; 61
    1cd0:	0d 92       	st	X+, r0
    1cd2:	0e b6       	in	r0, 0x3e	; 62
    1cd4:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1cd6:	0e 94 38 13 	call	0x2670	; 0x2670 <vTaskIncrementTick>
	vTaskSwitchContext();
    1cda:	0e 94 e9 14 	call	0x29d2	; 0x29d2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1cde:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    1ce2:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    1ce6:	cd 91       	ld	r28, X+
    1ce8:	cd bf       	out	0x3d, r28	; 61
    1cea:	dd 91       	ld	r29, X+
    1cec:	de bf       	out	0x3e, r29	; 62
    1cee:	ff 91       	pop	r31
    1cf0:	ef 91       	pop	r30
    1cf2:	df 91       	pop	r29
    1cf4:	cf 91       	pop	r28
    1cf6:	bf 91       	pop	r27
    1cf8:	af 91       	pop	r26
    1cfa:	9f 91       	pop	r25
    1cfc:	8f 91       	pop	r24
    1cfe:	7f 91       	pop	r23
    1d00:	6f 91       	pop	r22
    1d02:	5f 91       	pop	r21
    1d04:	4f 91       	pop	r20
    1d06:	3f 91       	pop	r19
    1d08:	2f 91       	pop	r18
    1d0a:	1f 91       	pop	r17
    1d0c:	0f 91       	pop	r16
    1d0e:	ff 90       	pop	r15
    1d10:	ef 90       	pop	r14
    1d12:	df 90       	pop	r13
    1d14:	cf 90       	pop	r12
    1d16:	bf 90       	pop	r11
    1d18:	af 90       	pop	r10
    1d1a:	9f 90       	pop	r9
    1d1c:	8f 90       	pop	r8
    1d1e:	7f 90       	pop	r7
    1d20:	6f 90       	pop	r6
    1d22:	5f 90       	pop	r5
    1d24:	4f 90       	pop	r4
    1d26:	3f 90       	pop	r3
    1d28:	2f 90       	pop	r2
    1d2a:	1f 90       	pop	r1
    1d2c:	0f 90       	pop	r0
    1d2e:	0c be       	out	0x3c, r0	; 60
    1d30:	0f 90       	pop	r0
    1d32:	0b be       	out	0x3b, r0	; 59
    1d34:	0f 90       	pop	r0
    1d36:	0f be       	out	0x3f, r0	; 63
    1d38:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1d3a:	08 95       	ret

00001d3c <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1d3c:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1d40:	18 95       	reti

00001d42 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	ec 01       	movw	r28, r24
    1d48:	88 a1       	ldd	r24, Y+32	; 0x20
    1d4a:	81 11       	cpse	r24, r1
    1d4c:	0b c0       	rjmp	.+22     	; 0x1d64 <prvCopyDataToQueue+0x22>
    1d4e:	88 81       	ld	r24, Y
    1d50:	99 81       	ldd	r25, Y+1	; 0x01
    1d52:	89 2b       	or	r24, r25
    1d54:	e1 f5       	brne	.+120    	; 0x1dce <prvCopyDataToQueue+0x8c>
    1d56:	8a 81       	ldd	r24, Y+2	; 0x02
    1d58:	9b 81       	ldd	r25, Y+3	; 0x03
    1d5a:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <vTaskPriorityDisinherit>
    1d5e:	1a 82       	std	Y+2, r1	; 0x02
    1d60:	1b 82       	std	Y+3, r1	; 0x03
    1d62:	35 c0       	rjmp	.+106    	; 0x1dce <prvCopyDataToQueue+0x8c>
    1d64:	41 11       	cpse	r20, r1
    1d66:	17 c0       	rjmp	.+46     	; 0x1d96 <prvCopyDataToQueue+0x54>
    1d68:	48 2f       	mov	r20, r24
    1d6a:	50 e0       	ldi	r21, 0x00	; 0
    1d6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d6e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d70:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <memcpy>
    1d74:	28 a1       	ldd	r18, Y+32	; 0x20
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7a:	82 0f       	add	r24, r18
    1d7c:	91 1d       	adc	r25, r1
    1d7e:	8c 83       	std	Y+4, r24	; 0x04
    1d80:	9d 83       	std	Y+5, r25	; 0x05
    1d82:	2a 81       	ldd	r18, Y+2	; 0x02
    1d84:	3b 81       	ldd	r19, Y+3	; 0x03
    1d86:	82 17       	cp	r24, r18
    1d88:	93 07       	cpc	r25, r19
    1d8a:	08 f1       	brcs	.+66     	; 0x1dce <prvCopyDataToQueue+0x8c>
    1d8c:	88 81       	ld	r24, Y
    1d8e:	99 81       	ldd	r25, Y+1	; 0x01
    1d90:	8c 83       	std	Y+4, r24	; 0x04
    1d92:	9d 83       	std	Y+5, r25	; 0x05
    1d94:	1c c0       	rjmp	.+56     	; 0x1dce <prvCopyDataToQueue+0x8c>
    1d96:	48 2f       	mov	r20, r24
    1d98:	50 e0       	ldi	r21, 0x00	; 0
    1d9a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d9c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d9e:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <memcpy>
    1da2:	88 a1       	ldd	r24, Y+32	; 0x20
    1da4:	90 e0       	ldi	r25, 0x00	; 0
    1da6:	91 95       	neg	r25
    1da8:	81 95       	neg	r24
    1daa:	91 09       	sbc	r25, r1
    1dac:	2e 81       	ldd	r18, Y+6	; 0x06
    1dae:	3f 81       	ldd	r19, Y+7	; 0x07
    1db0:	28 0f       	add	r18, r24
    1db2:	39 1f       	adc	r19, r25
    1db4:	2e 83       	std	Y+6, r18	; 0x06
    1db6:	3f 83       	std	Y+7, r19	; 0x07
    1db8:	48 81       	ld	r20, Y
    1dba:	59 81       	ldd	r21, Y+1	; 0x01
    1dbc:	24 17       	cp	r18, r20
    1dbe:	35 07       	cpc	r19, r21
    1dc0:	30 f4       	brcc	.+12     	; 0x1dce <prvCopyDataToQueue+0x8c>
    1dc2:	2a 81       	ldd	r18, Y+2	; 0x02
    1dc4:	3b 81       	ldd	r19, Y+3	; 0x03
    1dc6:	82 0f       	add	r24, r18
    1dc8:	93 1f       	adc	r25, r19
    1dca:	8e 83       	std	Y+6, r24	; 0x06
    1dcc:	9f 83       	std	Y+7, r25	; 0x07
    1dce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1dd0:	8f 5f       	subi	r24, 0xFF	; 255
    1dd2:	8e 8f       	std	Y+30, r24	; 0x1e
    1dd4:	df 91       	pop	r29
    1dd6:	cf 91       	pop	r28
    1dd8:	08 95       	ret

00001dda <prvCopyDataFromQueue>:
    1dda:	fc 01       	movw	r30, r24
    1ddc:	80 81       	ld	r24, Z
    1dde:	91 81       	ldd	r25, Z+1	; 0x01
    1de0:	00 97       	sbiw	r24, 0x00	; 0
    1de2:	a1 f0       	breq	.+40     	; 0x1e0c <prvCopyDataFromQueue+0x32>
    1de4:	40 a1       	ldd	r20, Z+32	; 0x20
    1de6:	50 e0       	ldi	r21, 0x00	; 0
    1de8:	26 81       	ldd	r18, Z+6	; 0x06
    1dea:	37 81       	ldd	r19, Z+7	; 0x07
    1dec:	24 0f       	add	r18, r20
    1dee:	35 1f       	adc	r19, r21
    1df0:	26 83       	std	Z+6, r18	; 0x06
    1df2:	37 83       	std	Z+7, r19	; 0x07
    1df4:	a2 81       	ldd	r26, Z+2	; 0x02
    1df6:	b3 81       	ldd	r27, Z+3	; 0x03
    1df8:	2a 17       	cp	r18, r26
    1dfa:	3b 07       	cpc	r19, r27
    1dfc:	10 f0       	brcs	.+4      	; 0x1e02 <prvCopyDataFromQueue+0x28>
    1dfe:	86 83       	std	Z+6, r24	; 0x06
    1e00:	97 83       	std	Z+7, r25	; 0x07
    1e02:	cb 01       	movw	r24, r22
    1e04:	66 81       	ldd	r22, Z+6	; 0x06
    1e06:	77 81       	ldd	r23, Z+7	; 0x07
    1e08:	0e 94 d9 23 	call	0x47b2	; 0x47b2 <memcpy>
    1e0c:	08 95       	ret

00001e0e <prvUnlockQueue>:
    1e0e:	0f 93       	push	r16
    1e10:	1f 93       	push	r17
    1e12:	cf 93       	push	r28
    1e14:	df 93       	push	r29
    1e16:	ec 01       	movw	r28, r24
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	f8 94       	cli
    1e1c:	0f 92       	push	r0
    1e1e:	8a a1       	ldd	r24, Y+34	; 0x22
    1e20:	18 16       	cp	r1, r24
    1e22:	b4 f4       	brge	.+44     	; 0x1e50 <prvUnlockQueue+0x42>
    1e24:	8b 89       	ldd	r24, Y+19	; 0x13
    1e26:	81 11       	cpse	r24, r1
    1e28:	05 c0       	rjmp	.+10     	; 0x1e34 <prvUnlockQueue+0x26>
    1e2a:	12 c0       	rjmp	.+36     	; 0x1e50 <prvUnlockQueue+0x42>
    1e2c:	8b 89       	ldd	r24, Y+19	; 0x13
    1e2e:	81 11       	cpse	r24, r1
    1e30:	04 c0       	rjmp	.+8      	; 0x1e3a <prvUnlockQueue+0x2c>
    1e32:	0e c0       	rjmp	.+28     	; 0x1e50 <prvUnlockQueue+0x42>
    1e34:	8e 01       	movw	r16, r28
    1e36:	0d 5e       	subi	r16, 0xED	; 237
    1e38:	1f 4f       	sbci	r17, 0xFF	; 255
    1e3a:	c8 01       	movw	r24, r16
    1e3c:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    1e40:	81 11       	cpse	r24, r1
    1e42:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <vTaskMissedYield>
    1e46:	8a a1       	ldd	r24, Y+34	; 0x22
    1e48:	81 50       	subi	r24, 0x01	; 1
    1e4a:	8a a3       	std	Y+34, r24	; 0x22
    1e4c:	18 16       	cp	r1, r24
    1e4e:	74 f3       	brlt	.-36     	; 0x1e2c <prvUnlockQueue+0x1e>
    1e50:	8f ef       	ldi	r24, 0xFF	; 255
    1e52:	8a a3       	std	Y+34, r24	; 0x22
    1e54:	0f 90       	pop	r0
    1e56:	0f be       	out	0x3f, r0	; 63
    1e58:	0f b6       	in	r0, 0x3f	; 63
    1e5a:	f8 94       	cli
    1e5c:	0f 92       	push	r0
    1e5e:	89 a1       	ldd	r24, Y+33	; 0x21
    1e60:	18 16       	cp	r1, r24
    1e62:	b4 f4       	brge	.+44     	; 0x1e90 <prvUnlockQueue+0x82>
    1e64:	88 85       	ldd	r24, Y+8	; 0x08
    1e66:	81 11       	cpse	r24, r1
    1e68:	05 c0       	rjmp	.+10     	; 0x1e74 <prvUnlockQueue+0x66>
    1e6a:	12 c0       	rjmp	.+36     	; 0x1e90 <prvUnlockQueue+0x82>
    1e6c:	88 85       	ldd	r24, Y+8	; 0x08
    1e6e:	81 11       	cpse	r24, r1
    1e70:	04 c0       	rjmp	.+8      	; 0x1e7a <prvUnlockQueue+0x6c>
    1e72:	0e c0       	rjmp	.+28     	; 0x1e90 <prvUnlockQueue+0x82>
    1e74:	8e 01       	movw	r16, r28
    1e76:	08 5f       	subi	r16, 0xF8	; 248
    1e78:	1f 4f       	sbci	r17, 0xFF	; 255
    1e7a:	c8 01       	movw	r24, r16
    1e7c:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    1e80:	81 11       	cpse	r24, r1
    1e82:	0e 94 2d 16 	call	0x2c5a	; 0x2c5a <vTaskMissedYield>
    1e86:	89 a1       	ldd	r24, Y+33	; 0x21
    1e88:	81 50       	subi	r24, 0x01	; 1
    1e8a:	89 a3       	std	Y+33, r24	; 0x21
    1e8c:	18 16       	cp	r1, r24
    1e8e:	74 f3       	brlt	.-36     	; 0x1e6c <prvUnlockQueue+0x5e>
    1e90:	8f ef       	ldi	r24, 0xFF	; 255
    1e92:	89 a3       	std	Y+33, r24	; 0x21
    1e94:	0f 90       	pop	r0
    1e96:	0f be       	out	0x3f, r0	; 63
    1e98:	df 91       	pop	r29
    1e9a:	cf 91       	pop	r28
    1e9c:	1f 91       	pop	r17
    1e9e:	0f 91       	pop	r16
    1ea0:	08 95       	ret

00001ea2 <xQueueGenericReset>:
    1ea2:	1f 93       	push	r17
    1ea4:	cf 93       	push	r28
    1ea6:	df 93       	push	r29
    1ea8:	61 30       	cpi	r22, 0x01	; 1
    1eaa:	59 f0       	breq	.+22     	; 0x1ec2 <xQueueGenericReset+0x20>
    1eac:	fc 01       	movw	r30, r24
    1eae:	23 89       	ldd	r18, Z+19	; 0x13
    1eb0:	30 85       	ldd	r19, Z+8	; 0x08
    1eb2:	31 11       	cpse	r19, r1
    1eb4:	2c c0       	rjmp	.+88     	; 0x1f0e <xQueueGenericReset+0x6c>
    1eb6:	11 e0       	ldi	r17, 0x01	; 1
    1eb8:	21 11       	cpse	r18, r1
    1eba:	10 e0       	ldi	r17, 0x00	; 0
    1ebc:	21 11       	cpse	r18, r1
    1ebe:	28 c0       	rjmp	.+80     	; 0x1f10 <xQueueGenericReset+0x6e>
    1ec0:	01 c0       	rjmp	.+2      	; 0x1ec4 <xQueueGenericReset+0x22>
    1ec2:	11 e0       	ldi	r17, 0x01	; 1
    1ec4:	ec 01       	movw	r28, r24
    1ec6:	48 81       	ld	r20, Y
    1ec8:	59 81       	ldd	r21, Y+1	; 0x01
    1eca:	28 a1       	ldd	r18, Y+32	; 0x20
    1ecc:	30 e0       	ldi	r19, 0x00	; 0
    1ece:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1ed0:	62 9f       	mul	r22, r18
    1ed2:	c0 01       	movw	r24, r0
    1ed4:	63 9f       	mul	r22, r19
    1ed6:	90 0d       	add	r25, r0
    1ed8:	11 24       	eor	r1, r1
    1eda:	ba 01       	movw	r22, r20
    1edc:	68 0f       	add	r22, r24
    1ede:	79 1f       	adc	r23, r25
    1ee0:	6a 83       	std	Y+2, r22	; 0x02
    1ee2:	7b 83       	std	Y+3, r23	; 0x03
    1ee4:	1e 8e       	std	Y+30, r1	; 0x1e
    1ee6:	4c 83       	std	Y+4, r20	; 0x04
    1ee8:	5d 83       	std	Y+5, r21	; 0x05
    1eea:	82 1b       	sub	r24, r18
    1eec:	93 0b       	sbc	r25, r19
    1eee:	84 0f       	add	r24, r20
    1ef0:	95 1f       	adc	r25, r21
    1ef2:	8e 83       	std	Y+6, r24	; 0x06
    1ef4:	9f 83       	std	Y+7, r25	; 0x07
    1ef6:	8f ef       	ldi	r24, 0xFF	; 255
    1ef8:	89 a3       	std	Y+33, r24	; 0x21
    1efa:	8a a3       	std	Y+34, r24	; 0x22
    1efc:	ce 01       	movw	r24, r28
    1efe:	08 96       	adiw	r24, 0x08	; 8
    1f00:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    1f04:	ce 01       	movw	r24, r28
    1f06:	43 96       	adiw	r24, 0x13	; 19
    1f08:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    1f0c:	01 c0       	rjmp	.+2      	; 0x1f10 <xQueueGenericReset+0x6e>
    1f0e:	10 e0       	ldi	r17, 0x00	; 0
    1f10:	81 2f       	mov	r24, r17
    1f12:	df 91       	pop	r29
    1f14:	cf 91       	pop	r28
    1f16:	1f 91       	pop	r17
    1f18:	08 95       	ret

00001f1a <xQueueGenericCreate>:
    1f1a:	0f 93       	push	r16
    1f1c:	1f 93       	push	r17
    1f1e:	cf 93       	push	r28
    1f20:	df 93       	push	r29
    1f22:	88 23       	and	r24, r24
    1f24:	01 f1       	breq	.+64     	; 0x1f66 <xQueueGenericCreate+0x4c>
    1f26:	06 2f       	mov	r16, r22
    1f28:	18 2f       	mov	r17, r24
    1f2a:	83 e2       	ldi	r24, 0x23	; 35
    1f2c:	90 e0       	ldi	r25, 0x00	; 0
    1f2e:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    1f32:	ec 01       	movw	r28, r24
    1f34:	89 2b       	or	r24, r25
    1f36:	c9 f0       	breq	.+50     	; 0x1f6a <xQueueGenericCreate+0x50>
    1f38:	10 9f       	mul	r17, r16
    1f3a:	c0 01       	movw	r24, r0
    1f3c:	11 24       	eor	r1, r1
    1f3e:	01 96       	adiw	r24, 0x01	; 1
    1f40:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    1f44:	88 83       	st	Y, r24
    1f46:	99 83       	std	Y+1, r25	; 0x01
    1f48:	89 2b       	or	r24, r25
    1f4a:	39 f0       	breq	.+14     	; 0x1f5a <xQueueGenericCreate+0x40>
    1f4c:	1f 8f       	std	Y+31, r17	; 0x1f
    1f4e:	08 a3       	std	Y+32, r16	; 0x20
    1f50:	61 e0       	ldi	r22, 0x01	; 1
    1f52:	ce 01       	movw	r24, r28
    1f54:	0e 94 51 0f 	call	0x1ea2	; 0x1ea2 <xQueueGenericReset>
    1f58:	08 c0       	rjmp	.+16     	; 0x1f6a <xQueueGenericCreate+0x50>
    1f5a:	ce 01       	movw	r24, r28
    1f5c:	0e 94 41 0c 	call	0x1882	; 0x1882 <vPortFree>
    1f60:	c0 e0       	ldi	r28, 0x00	; 0
    1f62:	d0 e0       	ldi	r29, 0x00	; 0
    1f64:	02 c0       	rjmp	.+4      	; 0x1f6a <xQueueGenericCreate+0x50>
    1f66:	c0 e0       	ldi	r28, 0x00	; 0
    1f68:	d0 e0       	ldi	r29, 0x00	; 0
    1f6a:	ce 01       	movw	r24, r28
    1f6c:	df 91       	pop	r29
    1f6e:	cf 91       	pop	r28
    1f70:	1f 91       	pop	r17
    1f72:	0f 91       	pop	r16
    1f74:	08 95       	ret

00001f76 <xQueueGenericSend>:
    1f76:	af 92       	push	r10
    1f78:	bf 92       	push	r11
    1f7a:	cf 92       	push	r12
    1f7c:	df 92       	push	r13
    1f7e:	ef 92       	push	r14
    1f80:	ff 92       	push	r15
    1f82:	0f 93       	push	r16
    1f84:	1f 93       	push	r17
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	cd b7       	in	r28, 0x3d	; 61
    1f8c:	de b7       	in	r29, 0x3e	; 62
    1f8e:	29 97       	sbiw	r28, 0x09	; 9
    1f90:	cd bf       	out	0x3d, r28	; 61
    1f92:	de bf       	out	0x3e, r29	; 62
    1f94:	7c 01       	movw	r14, r24
    1f96:	5b 01       	movw	r10, r22
    1f98:	2e 83       	std	Y+6, r18	; 0x06
    1f9a:	3f 83       	std	Y+7, r19	; 0x07
    1f9c:	48 87       	std	Y+8, r20	; 0x08
    1f9e:	59 87       	std	Y+9, r21	; 0x09
    1fa0:	10 e0       	ldi	r17, 0x00	; 0
    1fa2:	6c 01       	movw	r12, r24
    1fa4:	88 e0       	ldi	r24, 0x08	; 8
    1fa6:	c8 0e       	add	r12, r24
    1fa8:	d1 1c       	adc	r13, r1
    1faa:	0f b6       	in	r0, 0x3f	; 63
    1fac:	f8 94       	cli
    1fae:	0f 92       	push	r0
    1fb0:	f7 01       	movw	r30, r14
    1fb2:	96 8d       	ldd	r25, Z+30	; 0x1e
    1fb4:	87 8d       	ldd	r24, Z+31	; 0x1f
    1fb6:	98 17       	cp	r25, r24
    1fb8:	a8 f4       	brcc	.+42     	; 0x1fe4 <xQueueGenericSend+0x6e>
    1fba:	40 2f       	mov	r20, r16
    1fbc:	b5 01       	movw	r22, r10
    1fbe:	c7 01       	movw	r24, r14
    1fc0:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <prvCopyDataToQueue>
    1fc4:	f7 01       	movw	r30, r14
    1fc6:	83 89       	ldd	r24, Z+19	; 0x13
    1fc8:	88 23       	and	r24, r24
    1fca:	41 f0       	breq	.+16     	; 0x1fdc <xQueueGenericSend+0x66>
    1fcc:	c7 01       	movw	r24, r14
    1fce:	43 96       	adiw	r24, 0x13	; 19
    1fd0:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    1fd4:	81 30       	cpi	r24, 0x01	; 1
    1fd6:	11 f4       	brne	.+4      	; 0x1fdc <xQueueGenericSend+0x66>
    1fd8:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	56 c0       	rjmp	.+172    	; 0x2090 <xQueueGenericSend+0x11a>
    1fe4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fe6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fe8:	a8 85       	ldd	r26, Y+8	; 0x08
    1fea:	b9 85       	ldd	r27, Y+9	; 0x09
    1fec:	89 2b       	or	r24, r25
    1fee:	8a 2b       	or	r24, r26
    1ff0:	8b 2b       	or	r24, r27
    1ff2:	21 f4       	brne	.+8      	; 0x1ffc <xQueueGenericSend+0x86>
    1ff4:	0f 90       	pop	r0
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	80 e0       	ldi	r24, 0x00	; 0
    1ffa:	4a c0       	rjmp	.+148    	; 0x2090 <xQueueGenericSend+0x11a>
    1ffc:	11 11       	cpse	r17, r1
    1ffe:	05 c0       	rjmp	.+10     	; 0x200a <xQueueGenericSend+0x94>
    2000:	ce 01       	movw	r24, r28
    2002:	01 96       	adiw	r24, 0x01	; 1
    2004:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <vTaskSetTimeOutState>
    2008:	11 e0       	ldi	r17, 0x01	; 1
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	0e 94 17 13 	call	0x262e	; 0x262e <vTaskSuspendAll>
    2012:	0f b6       	in	r0, 0x3f	; 63
    2014:	f8 94       	cli
    2016:	0f 92       	push	r0
    2018:	f7 01       	movw	r30, r14
    201a:	81 a1       	ldd	r24, Z+33	; 0x21
    201c:	8f 3f       	cpi	r24, 0xFF	; 255
    201e:	09 f4       	brne	.+2      	; 0x2022 <xQueueGenericSend+0xac>
    2020:	11 a2       	std	Z+33, r1	; 0x21
    2022:	f7 01       	movw	r30, r14
    2024:	82 a1       	ldd	r24, Z+34	; 0x22
    2026:	8f 3f       	cpi	r24, 0xFF	; 255
    2028:	09 f4       	brne	.+2      	; 0x202c <xQueueGenericSend+0xb6>
    202a:	12 a2       	std	Z+34, r1	; 0x22
    202c:	0f 90       	pop	r0
    202e:	0f be       	out	0x3f, r0	; 63
    2030:	be 01       	movw	r22, r28
    2032:	6a 5f       	subi	r22, 0xFA	; 250
    2034:	7f 4f       	sbci	r23, 0xFF	; 255
    2036:	ce 01       	movw	r24, r28
    2038:	01 96       	adiw	r24, 0x01	; 1
    203a:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskCheckForTimeOut>
    203e:	81 11       	cpse	r24, r1
    2040:	21 c0       	rjmp	.+66     	; 0x2084 <xQueueGenericSend+0x10e>
    2042:	0f b6       	in	r0, 0x3f	; 63
    2044:	f8 94       	cli
    2046:	0f 92       	push	r0
    2048:	f7 01       	movw	r30, r14
    204a:	96 8d       	ldd	r25, Z+30	; 0x1e
    204c:	0f 90       	pop	r0
    204e:	0f be       	out	0x3f, r0	; 63
    2050:	87 8d       	ldd	r24, Z+31	; 0x1f
    2052:	98 13       	cpse	r25, r24
    2054:	11 c0       	rjmp	.+34     	; 0x2078 <xQueueGenericSend+0x102>
    2056:	4e 81       	ldd	r20, Y+6	; 0x06
    2058:	5f 81       	ldd	r21, Y+7	; 0x07
    205a:	68 85       	ldd	r22, Y+8	; 0x08
    205c:	79 85       	ldd	r23, Y+9	; 0x09
    205e:	c6 01       	movw	r24, r12
    2060:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <vTaskPlaceOnEventList>
    2064:	c7 01       	movw	r24, r14
    2066:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
    206a:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
    206e:	81 11       	cpse	r24, r1
    2070:	9c cf       	rjmp	.-200    	; 0x1faa <xQueueGenericSend+0x34>
    2072:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    2076:	99 cf       	rjmp	.-206    	; 0x1faa <xQueueGenericSend+0x34>
    2078:	c7 01       	movw	r24, r14
    207a:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
    207e:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
    2082:	93 cf       	rjmp	.-218    	; 0x1faa <xQueueGenericSend+0x34>
    2084:	c7 01       	movw	r24, r14
    2086:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
    208a:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
    208e:	80 e0       	ldi	r24, 0x00	; 0
    2090:	29 96       	adiw	r28, 0x09	; 9
    2092:	cd bf       	out	0x3d, r28	; 61
    2094:	de bf       	out	0x3e, r29	; 62
    2096:	df 91       	pop	r29
    2098:	cf 91       	pop	r28
    209a:	1f 91       	pop	r17
    209c:	0f 91       	pop	r16
    209e:	ff 90       	pop	r15
    20a0:	ef 90       	pop	r14
    20a2:	df 90       	pop	r13
    20a4:	cf 90       	pop	r12
    20a6:	bf 90       	pop	r11
    20a8:	af 90       	pop	r10
    20aa:	08 95       	ret

000020ac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    20ac:	0f 93       	push	r16
    20ae:	1f 93       	push	r17
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    20b6:	fc 01       	movw	r30, r24
    20b8:	56 8d       	ldd	r21, Z+30	; 0x1e
    20ba:	37 8d       	ldd	r19, Z+31	; 0x1f
    20bc:	53 17       	cp	r21, r19
    20be:	c0 f4       	brcc	.+48     	; 0x20f0 <xQueueGenericSendFromISR+0x44>
    20c0:	42 2f       	mov	r20, r18
    20c2:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20c4:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    20c8:	8a a1       	ldd	r24, Y+34	; 0x22
    20ca:	8f 3f       	cpi	r24, 0xFF	; 255
    20cc:	69 f4       	brne	.+26     	; 0x20e8 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20ce:	8b 89       	ldd	r24, Y+19	; 0x13
    20d0:	88 23       	and	r24, r24
    20d2:	81 f0       	breq	.+32     	; 0x20f4 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20d4:	ce 01       	movw	r24, r28
    20d6:	43 96       	adiw	r24, 0x13	; 19
    20d8:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    20dc:	88 23       	and	r24, r24
    20de:	61 f0       	breq	.+24     	; 0x20f8 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    20e0:	81 e0       	ldi	r24, 0x01	; 1
    20e2:	f8 01       	movw	r30, r16
    20e4:	80 83       	st	Z, r24
    20e6:	09 c0       	rjmp	.+18     	; 0x20fa <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    20e8:	8f 5f       	subi	r24, 0xFF	; 255
    20ea:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	05 c0       	rjmp	.+10     	; 0x20fa <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20f0:	80 e0       	ldi	r24, 0x00	; 0
    20f2:	03 c0       	rjmp	.+6      	; 0x20fa <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	01 c0       	rjmp	.+2      	; 0x20fa <xQueueGenericSendFromISR+0x4e>
    20f8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20fa:	df 91       	pop	r29
    20fc:	cf 91       	pop	r28
    20fe:	1f 91       	pop	r17
    2100:	0f 91       	pop	r16
    2102:	08 95       	ret

00002104 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2104:	af 92       	push	r10
    2106:	bf 92       	push	r11
    2108:	cf 92       	push	r12
    210a:	df 92       	push	r13
    210c:	ef 92       	push	r14
    210e:	ff 92       	push	r15
    2110:	0f 93       	push	r16
    2112:	1f 93       	push	r17
    2114:	cf 93       	push	r28
    2116:	df 93       	push	r29
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
    211c:	29 97       	sbiw	r28, 0x09	; 9
    211e:	cd bf       	out	0x3d, r28	; 61
    2120:	de bf       	out	0x3e, r29	; 62
    2122:	7c 01       	movw	r14, r24
    2124:	5b 01       	movw	r10, r22
    2126:	2e 83       	std	Y+6, r18	; 0x06
    2128:	3f 83       	std	Y+7, r19	; 0x07
    212a:	48 87       	std	Y+8, r20	; 0x08
    212c:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    212e:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2130:	6c 01       	movw	r12, r24
    2132:	83 e1       	ldi	r24, 0x13	; 19
    2134:	c8 0e       	add	r12, r24
    2136:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    213e:	f7 01       	movw	r30, r14
    2140:	86 8d       	ldd	r24, Z+30	; 0x1e
    2142:	88 23       	and	r24, r24
    2144:	99 f1       	breq	.+102    	; 0x21ac <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2146:	c6 80       	ldd	r12, Z+6	; 0x06
    2148:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    214a:	b5 01       	movw	r22, r10
    214c:	c7 01       	movw	r24, r14
    214e:	0e 94 ed 0e 	call	0x1dda	; 0x1dda <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2152:	01 11       	cpse	r16, r1
    2154:	1a c0       	rjmp	.+52     	; 0x218a <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    2156:	f7 01       	movw	r30, r14
    2158:	86 8d       	ldd	r24, Z+30	; 0x1e
    215a:	81 50       	subi	r24, 0x01	; 1
    215c:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    215e:	80 81       	ld	r24, Z
    2160:	91 81       	ldd	r25, Z+1	; 0x01
    2162:	89 2b       	or	r24, r25
    2164:	29 f4       	brne	.+10     	; 0x2170 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    2166:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <xTaskGetCurrentTaskHandle>
    216a:	f7 01       	movw	r30, r14
    216c:	82 83       	std	Z+2, r24	; 0x02
    216e:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2170:	f7 01       	movw	r30, r14
    2172:	80 85       	ldd	r24, Z+8	; 0x08
    2174:	88 23       	and	r24, r24
    2176:	b1 f0       	breq	.+44     	; 0x21a4 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2178:	c7 01       	movw	r24, r14
    217a:	08 96       	adiw	r24, 0x08	; 8
    217c:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    2180:	81 30       	cpi	r24, 0x01	; 1
    2182:	81 f4       	brne	.+32     	; 0x21a4 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    2184:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    2188:	0d c0       	rjmp	.+26     	; 0x21a4 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    218a:	f7 01       	movw	r30, r14
    218c:	c6 82       	std	Z+6, r12	; 0x06
    218e:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2190:	83 89       	ldd	r24, Z+19	; 0x13
    2192:	88 23       	and	r24, r24
    2194:	39 f0       	breq	.+14     	; 0x21a4 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2196:	c7 01       	movw	r24, r14
    2198:	43 96       	adiw	r24, 0x13	; 19
    219a:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    219e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    21a0:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    21a4:	0f 90       	pop	r0
    21a6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    21a8:	81 e0       	ldi	r24, 0x01	; 1
    21aa:	62 c0       	rjmp	.+196    	; 0x2270 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    21ac:	8e 81       	ldd	r24, Y+6	; 0x06
    21ae:	9f 81       	ldd	r25, Y+7	; 0x07
    21b0:	a8 85       	ldd	r26, Y+8	; 0x08
    21b2:	b9 85       	ldd	r27, Y+9	; 0x09
    21b4:	89 2b       	or	r24, r25
    21b6:	8a 2b       	or	r24, r26
    21b8:	8b 2b       	or	r24, r27
    21ba:	21 f4       	brne	.+8      	; 0x21c4 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    21bc:	0f 90       	pop	r0
    21be:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    21c0:	80 e0       	ldi	r24, 0x00	; 0
    21c2:	56 c0       	rjmp	.+172    	; 0x2270 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    21c4:	11 11       	cpse	r17, r1
    21c6:	05 c0       	rjmp	.+10     	; 0x21d2 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    21c8:	ce 01       	movw	r24, r28
    21ca:	01 96       	adiw	r24, 0x01	; 1
    21cc:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    21d0:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    21d2:	0f 90       	pop	r0
    21d4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    21d6:	0e 94 17 13 	call	0x262e	; 0x262e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    21da:	0f b6       	in	r0, 0x3f	; 63
    21dc:	f8 94       	cli
    21de:	0f 92       	push	r0
    21e0:	f7 01       	movw	r30, r14
    21e2:	81 a1       	ldd	r24, Z+33	; 0x21
    21e4:	8f 3f       	cpi	r24, 0xFF	; 255
    21e6:	09 f4       	brne	.+2      	; 0x21ea <xQueueGenericReceive+0xe6>
    21e8:	11 a2       	std	Z+33, r1	; 0x21
    21ea:	f7 01       	movw	r30, r14
    21ec:	82 a1       	ldd	r24, Z+34	; 0x22
    21ee:	8f 3f       	cpi	r24, 0xFF	; 255
    21f0:	09 f4       	brne	.+2      	; 0x21f4 <xQueueGenericReceive+0xf0>
    21f2:	12 a2       	std	Z+34, r1	; 0x22
    21f4:	0f 90       	pop	r0
    21f6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    21f8:	be 01       	movw	r22, r28
    21fa:	6a 5f       	subi	r22, 0xFA	; 250
    21fc:	7f 4f       	sbci	r23, 0xFF	; 255
    21fe:	ce 01       	movw	r24, r28
    2200:	01 96       	adiw	r24, 0x01	; 1
    2202:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <xTaskCheckForTimeOut>
    2206:	81 11       	cpse	r24, r1
    2208:	2d c0       	rjmp	.+90     	; 0x2264 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    220a:	0f b6       	in	r0, 0x3f	; 63
    220c:	f8 94       	cli
    220e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2210:	f7 01       	movw	r30, r14
    2212:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    2214:	0f 90       	pop	r0
    2216:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2218:	81 11       	cpse	r24, r1
    221a:	1e c0       	rjmp	.+60     	; 0x2258 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    221c:	80 81       	ld	r24, Z
    221e:	91 81       	ldd	r25, Z+1	; 0x01
    2220:	89 2b       	or	r24, r25
    2222:	49 f4       	brne	.+18     	; 0x2236 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    222a:	82 81       	ldd	r24, Z+2	; 0x02
    222c:	93 81       	ldd	r25, Z+3	; 0x03
    222e:	0e 94 4f 16 	call	0x2c9e	; 0x2c9e <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2236:	4e 81       	ldd	r20, Y+6	; 0x06
    2238:	5f 81       	ldd	r21, Y+7	; 0x07
    223a:	68 85       	ldd	r22, Y+8	; 0x08
    223c:	79 85       	ldd	r23, Y+9	; 0x09
    223e:	c6 01       	movw	r24, r12
    2240:	0e 94 46 15 	call	0x2a8c	; 0x2a8c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2244:	c7 01       	movw	r24, r14
    2246:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    224a:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
    224e:	81 11       	cpse	r24, r1
    2250:	73 cf       	rjmp	.-282    	; 0x2138 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    2252:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    2256:	70 cf       	rjmp	.-288    	; 0x2138 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2258:	c7 01       	movw	r24, r14
    225a:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    225e:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
    2262:	6a cf       	rjmp	.-300    	; 0x2138 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2264:	c7 01       	movw	r24, r14
    2266:	0e 94 07 0f 	call	0x1e0e	; 0x1e0e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    226a:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    226e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2270:	29 96       	adiw	r28, 0x09	; 9
    2272:	cd bf       	out	0x3d, r28	; 61
    2274:	de bf       	out	0x3e, r29	; 62
    2276:	df 91       	pop	r29
    2278:	cf 91       	pop	r28
    227a:	1f 91       	pop	r17
    227c:	0f 91       	pop	r16
    227e:	ff 90       	pop	r15
    2280:	ef 90       	pop	r14
    2282:	df 90       	pop	r13
    2284:	cf 90       	pop	r12
    2286:	bf 90       	pop	r11
    2288:	af 90       	pop	r10
    228a:	08 95       	ret

0000228c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    228c:	0f 93       	push	r16
    228e:	1f 93       	push	r17
    2290:	cf 93       	push	r28
    2292:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2294:	fc 01       	movw	r30, r24
    2296:	26 8d       	ldd	r18, Z+30	; 0x1e
    2298:	22 23       	and	r18, r18
    229a:	d9 f0       	breq	.+54     	; 0x22d2 <xQueueReceiveFromISR+0x46>
    229c:	8a 01       	movw	r16, r20
    229e:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    22a0:	0e 94 ed 0e 	call	0x1dda	; 0x1dda <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    22a4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22a6:	81 50       	subi	r24, 0x01	; 1
    22a8:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    22aa:	89 a1       	ldd	r24, Y+33	; 0x21
    22ac:	8f 3f       	cpi	r24, 0xFF	; 255
    22ae:	69 f4       	brne	.+26     	; 0x22ca <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22b0:	88 85       	ldd	r24, Y+8	; 0x08
    22b2:	88 23       	and	r24, r24
    22b4:	81 f0       	breq	.+32     	; 0x22d6 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22b6:	ce 01       	movw	r24, r28
    22b8:	08 96       	adiw	r24, 0x08	; 8
    22ba:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <xTaskRemoveFromEventList>
    22be:	88 23       	and	r24, r24
    22c0:	61 f0       	breq	.+24     	; 0x22da <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	f8 01       	movw	r30, r16
    22c6:	80 83       	st	Z, r24
    22c8:	09 c0       	rjmp	.+18     	; 0x22dc <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    22ca:	8f 5f       	subi	r24, 0xFF	; 255
    22cc:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    22ce:	81 e0       	ldi	r24, 0x01	; 1
    22d0:	05 c0       	rjmp	.+10     	; 0x22dc <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    22d2:	80 e0       	ldi	r24, 0x00	; 0
    22d4:	03 c0       	rjmp	.+6      	; 0x22dc <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	01 c0       	rjmp	.+2      	; 0x22dc <xQueueReceiveFromISR+0x50>
    22da:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    22dc:	df 91       	pop	r29
    22de:	cf 91       	pop	r28
    22e0:	1f 91       	pop	r17
    22e2:	0f 91       	pop	r16
    22e4:	08 95       	ret

000022e6 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    22e6:	0f b6       	in	r0, 0x3f	; 63
    22e8:	f8 94       	cli
    22ea:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    22ec:	fc 01       	movw	r30, r24
    22ee:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    22f0:	0f 90       	pop	r0
    22f2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    22f4:	08 95       	ret

000022f6 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    22f6:	fc 01       	movw	r30, r24
    22f8:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    22fa:	08 95       	ret

000022fc <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    22fc:	c4 ea       	ldi	r28, 0xA4	; 164
    22fe:	d1 e3       	ldi	r29, 0x31	; 49
    2300:	88 81       	ld	r24, Y
    2302:	82 30       	cpi	r24, 0x02	; 2
    2304:	e8 f3       	brcs	.-6      	; 0x2300 <prvIdleTask+0x4>
    2306:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    230a:	fa cf       	rjmp	.-12     	; 0x2300 <prvIdleTask+0x4>

0000230c <prvAddCurrentTaskToDelayedList>:
    230c:	cf 92       	push	r12
    230e:	df 92       	push	r13
    2310:	ef 92       	push	r14
    2312:	ff 92       	push	r15
    2314:	6b 01       	movw	r12, r22
    2316:	7c 01       	movw	r14, r24
    2318:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    231c:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2320:	62 83       	std	Z+2, r22	; 0x02
    2322:	73 83       	std	Z+3, r23	; 0x03
    2324:	84 83       	std	Z+4, r24	; 0x04
    2326:	95 83       	std	Z+5, r25	; 0x05
    2328:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    232c:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2330:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2334:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2338:	c8 16       	cp	r12, r24
    233a:	d9 06       	cpc	r13, r25
    233c:	ea 06       	cpc	r14, r26
    233e:	fb 06       	cpc	r15, r27
    2340:	68 f4       	brcc	.+26     	; 0x235c <prvAddCurrentTaskToDelayedList+0x50>
    2342:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2346:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    234a:	80 91 8a 31 	lds	r24, 0x318A	; 0x80318a <pxOverflowDelayedTaskList>
    234e:	90 91 8b 31 	lds	r25, 0x318B	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    2352:	6e 5f       	subi	r22, 0xFE	; 254
    2354:	7f 4f       	sbci	r23, 0xFF	; 255
    2356:	0e 94 b5 0c 	call	0x196a	; 0x196a <vListInsert>
    235a:	21 c0       	rjmp	.+66     	; 0x239e <prvAddCurrentTaskToDelayedList+0x92>
    235c:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2360:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2364:	80 91 8c 31 	lds	r24, 0x318C	; 0x80318c <pxDelayedTaskList>
    2368:	90 91 8d 31 	lds	r25, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    236c:	6e 5f       	subi	r22, 0xFE	; 254
    236e:	7f 4f       	sbci	r23, 0xFF	; 255
    2370:	0e 94 b5 0c 	call	0x196a	; 0x196a <vListInsert>
    2374:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2378:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    237c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2380:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2384:	c8 16       	cp	r12, r24
    2386:	d9 06       	cpc	r13, r25
    2388:	ea 06       	cpc	r14, r26
    238a:	fb 06       	cpc	r15, r27
    238c:	40 f4       	brcc	.+16     	; 0x239e <prvAddCurrentTaskToDelayedList+0x92>
    238e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    2392:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    2396:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    239a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    239e:	ff 90       	pop	r15
    23a0:	ef 90       	pop	r14
    23a2:	df 90       	pop	r13
    23a4:	cf 90       	pop	r12
    23a6:	08 95       	ret

000023a8 <xTaskGenericCreate>:
    23a8:	4f 92       	push	r4
    23aa:	5f 92       	push	r5
    23ac:	6f 92       	push	r6
    23ae:	7f 92       	push	r7
    23b0:	8f 92       	push	r8
    23b2:	9f 92       	push	r9
    23b4:	af 92       	push	r10
    23b6:	bf 92       	push	r11
    23b8:	cf 92       	push	r12
    23ba:	df 92       	push	r13
    23bc:	ef 92       	push	r14
    23be:	ff 92       	push	r15
    23c0:	0f 93       	push	r16
    23c2:	1f 93       	push	r17
    23c4:	cf 93       	push	r28
    23c6:	df 93       	push	r29
    23c8:	5c 01       	movw	r10, r24
    23ca:	4b 01       	movw	r8, r22
    23cc:	3a 01       	movw	r6, r20
    23ce:	29 01       	movw	r4, r18
    23d0:	88 e2       	ldi	r24, 0x28	; 40
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    23d8:	ec 01       	movw	r28, r24
    23da:	89 2b       	or	r24, r25
    23dc:	09 f4       	brne	.+2      	; 0x23e0 <xTaskGenericCreate+0x38>
    23de:	d4 c0       	rjmp	.+424    	; 0x2588 <xTaskGenericCreate+0x1e0>
    23e0:	c1 14       	cp	r12, r1
    23e2:	d1 04       	cpc	r13, r1
    23e4:	09 f0       	breq	.+2      	; 0x23e8 <xTaskGenericCreate+0x40>
    23e6:	cc c0       	rjmp	.+408    	; 0x2580 <xTaskGenericCreate+0x1d8>
    23e8:	c3 01       	movw	r24, r6
    23ea:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    23ee:	8b 8f       	std	Y+27, r24	; 0x1b
    23f0:	9c 8f       	std	Y+28, r25	; 0x1c
    23f2:	00 97       	sbiw	r24, 0x00	; 0
    23f4:	21 f4       	brne	.+8      	; 0x23fe <xTaskGenericCreate+0x56>
    23f6:	ce 01       	movw	r24, r28
    23f8:	0e 94 41 0c 	call	0x1882	; 0x1882 <vPortFree>
    23fc:	c5 c0       	rjmp	.+394    	; 0x2588 <xTaskGenericCreate+0x1e0>
    23fe:	a3 01       	movw	r20, r6
    2400:	61 e1       	ldi	r22, 0x11	; 17
    2402:	70 e0       	ldi	r23, 0x00	; 0
    2404:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <memset>
    2408:	93 01       	movw	r18, r6
    240a:	21 50       	subi	r18, 0x01	; 1
    240c:	31 09       	sbc	r19, r1
    240e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2410:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2412:	3c 01       	movw	r6, r24
    2414:	62 0e       	add	r6, r18
    2416:	73 1e       	adc	r7, r19
    2418:	4a e0       	ldi	r20, 0x0A	; 10
    241a:	50 e0       	ldi	r21, 0x00	; 0
    241c:	b4 01       	movw	r22, r8
    241e:	ce 01       	movw	r24, r28
    2420:	4d 96       	adiw	r24, 0x1d	; 29
    2422:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <strncpy>
    2426:	1e a2       	std	Y+38, r1	; 0x26
    2428:	10 2f       	mov	r17, r16
    242a:	04 30       	cpi	r16, 0x04	; 4
    242c:	08 f0       	brcs	.+2      	; 0x2430 <xTaskGenericCreate+0x88>
    242e:	13 e0       	ldi	r17, 0x03	; 3
    2430:	1a 8f       	std	Y+26, r17	; 0x1a
    2432:	1f a3       	std	Y+39, r17	; 0x27
    2434:	6e 01       	movw	r12, r28
    2436:	22 e0       	ldi	r18, 0x02	; 2
    2438:	c2 0e       	add	r12, r18
    243a:	d1 1c       	adc	r13, r1
    243c:	c6 01       	movw	r24, r12
    243e:	0e 94 8a 0c 	call	0x1914	; 0x1914 <vListInitialiseItem>
    2442:	ce 01       	movw	r24, r28
    2444:	0e 96       	adiw	r24, 0x0e	; 14
    2446:	0e 94 8a 0c 	call	0x1914	; 0x1914 <vListInitialiseItem>
    244a:	ca 87       	std	Y+10, r28	; 0x0a
    244c:	db 87       	std	Y+11, r29	; 0x0b
    244e:	84 e0       	ldi	r24, 0x04	; 4
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	a0 e0       	ldi	r26, 0x00	; 0
    2454:	b0 e0       	ldi	r27, 0x00	; 0
    2456:	81 1b       	sub	r24, r17
    2458:	91 09       	sbc	r25, r1
    245a:	a1 09       	sbc	r26, r1
    245c:	b1 09       	sbc	r27, r1
    245e:	8e 87       	std	Y+14, r24	; 0x0e
    2460:	9f 87       	std	Y+15, r25	; 0x0f
    2462:	a8 8b       	std	Y+16, r26	; 0x10
    2464:	b9 8b       	std	Y+17, r27	; 0x11
    2466:	ce 8b       	std	Y+22, r28	; 0x16
    2468:	df 8b       	std	Y+23, r29	; 0x17
    246a:	a2 01       	movw	r20, r4
    246c:	b5 01       	movw	r22, r10
    246e:	c3 01       	movw	r24, r6
    2470:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <pxPortInitialiseStack>
    2474:	88 83       	st	Y, r24
    2476:	99 83       	std	Y+1, r25	; 0x01
    2478:	e1 14       	cp	r14, r1
    247a:	f1 04       	cpc	r15, r1
    247c:	19 f0       	breq	.+6      	; 0x2484 <xTaskGenericCreate+0xdc>
    247e:	f7 01       	movw	r30, r14
    2480:	c0 83       	st	Z, r28
    2482:	d1 83       	std	Z+1, r29	; 0x01
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	0f 92       	push	r0
    248a:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    248e:	8f 5f       	subi	r24, 0xFF	; 255
    2490:	80 93 7c 31 	sts	0x317C, r24	; 0x80317c <uxCurrentNumberOfTasks>
    2494:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2498:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    249c:	89 2b       	or	r24, r25
    249e:	89 f5       	brne	.+98     	; 0x2502 <xTaskGenericCreate+0x15a>
    24a0:	c0 93 d0 31 	sts	0x31D0, r28	; 0x8031d0 <pxCurrentTCB>
    24a4:	d0 93 d1 31 	sts	0x31D1, r29	; 0x8031d1 <pxCurrentTCB+0x1>
    24a8:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    24ac:	81 30       	cpi	r24, 0x01	; 1
    24ae:	c1 f5       	brne	.+112    	; 0x2520 <xTaskGenericCreate+0x178>
    24b0:	84 ea       	ldi	r24, 0xA4	; 164
    24b2:	91 e3       	ldi	r25, 0x31	; 49
    24b4:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24b8:	8f ea       	ldi	r24, 0xAF	; 175
    24ba:	91 e3       	ldi	r25, 0x31	; 49
    24bc:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24c0:	8a eb       	ldi	r24, 0xBA	; 186
    24c2:	91 e3       	ldi	r25, 0x31	; 49
    24c4:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24c8:	85 ec       	ldi	r24, 0xC5	; 197
    24ca:	91 e3       	ldi	r25, 0x31	; 49
    24cc:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24d0:	89 e9       	ldi	r24, 0x99	; 153
    24d2:	91 e3       	ldi	r25, 0x31	; 49
    24d4:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24d8:	8e e8       	ldi	r24, 0x8E	; 142
    24da:	91 e3       	ldi	r25, 0x31	; 49
    24dc:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24e0:	8f e7       	ldi	r24, 0x7F	; 127
    24e2:	91 e3       	ldi	r25, 0x31	; 49
    24e4:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInitialise>
    24e8:	89 e9       	ldi	r24, 0x99	; 153
    24ea:	91 e3       	ldi	r25, 0x31	; 49
    24ec:	80 93 8c 31 	sts	0x318C, r24	; 0x80318c <pxDelayedTaskList>
    24f0:	90 93 8d 31 	sts	0x318D, r25	; 0x80318d <pxDelayedTaskList+0x1>
    24f4:	8e e8       	ldi	r24, 0x8E	; 142
    24f6:	91 e3       	ldi	r25, 0x31	; 49
    24f8:	80 93 8a 31 	sts	0x318A, r24	; 0x80318a <pxOverflowDelayedTaskList>
    24fc:	90 93 8b 31 	sts	0x318B, r25	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    2500:	0f c0       	rjmp	.+30     	; 0x2520 <xTaskGenericCreate+0x178>
    2502:	80 91 75 31 	lds	r24, 0x3175	; 0x803175 <xSchedulerRunning>
    2506:	81 11       	cpse	r24, r1
    2508:	0b c0       	rjmp	.+22     	; 0x2520 <xTaskGenericCreate+0x178>
    250a:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    250e:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2512:	82 8d       	ldd	r24, Z+26	; 0x1a
    2514:	08 17       	cp	r16, r24
    2516:	20 f0       	brcs	.+8      	; 0x2520 <xTaskGenericCreate+0x178>
    2518:	c0 93 d0 31 	sts	0x31D0, r28	; 0x8031d0 <pxCurrentTCB>
    251c:	d0 93 d1 31 	sts	0x31D1, r29	; 0x8031d1 <pxCurrentTCB+0x1>
    2520:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2522:	90 91 77 31 	lds	r25, 0x3177	; 0x803177 <uxTopUsedPriority>
    2526:	98 17       	cp	r25, r24
    2528:	10 f4       	brcc	.+4      	; 0x252e <xTaskGenericCreate+0x186>
    252a:	80 93 77 31 	sts	0x3177, r24	; 0x803177 <uxTopUsedPriority>
    252e:	90 91 70 31 	lds	r25, 0x3170	; 0x803170 <uxTaskNumber>
    2532:	9f 5f       	subi	r25, 0xFF	; 255
    2534:	90 93 70 31 	sts	0x3170, r25	; 0x803170 <uxTaskNumber>
    2538:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    253c:	98 17       	cp	r25, r24
    253e:	10 f4       	brcc	.+4      	; 0x2544 <xTaskGenericCreate+0x19c>
    2540:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2544:	fb e0       	ldi	r31, 0x0B	; 11
    2546:	8f 9f       	mul	r24, r31
    2548:	c0 01       	movw	r24, r0
    254a:	11 24       	eor	r1, r1
    254c:	b6 01       	movw	r22, r12
    254e:	8c 55       	subi	r24, 0x5C	; 92
    2550:	9e 4c       	sbci	r25, 0xCE	; 206
    2552:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
    2556:	0f 90       	pop	r0
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	80 91 75 31 	lds	r24, 0x3175	; 0x803175 <xSchedulerRunning>
    255e:	88 23       	and	r24, r24
    2560:	59 f0       	breq	.+22     	; 0x2578 <xTaskGenericCreate+0x1d0>
    2562:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2566:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    256a:	82 8d       	ldd	r24, Z+26	; 0x1a
    256c:	80 17       	cp	r24, r16
    256e:	30 f4       	brcc	.+12     	; 0x257c <xTaskGenericCreate+0x1d4>
    2570:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    2574:	81 e0       	ldi	r24, 0x01	; 1
    2576:	09 c0       	rjmp	.+18     	; 0x258a <xTaskGenericCreate+0x1e2>
    2578:	81 e0       	ldi	r24, 0x01	; 1
    257a:	07 c0       	rjmp	.+14     	; 0x258a <xTaskGenericCreate+0x1e2>
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	05 c0       	rjmp	.+10     	; 0x258a <xTaskGenericCreate+0x1e2>
    2580:	cb 8e       	std	Y+27, r12	; 0x1b
    2582:	dc 8e       	std	Y+28, r13	; 0x1c
    2584:	c6 01       	movw	r24, r12
    2586:	3b cf       	rjmp	.-394    	; 0x23fe <xTaskGenericCreate+0x56>
    2588:	8f ef       	ldi	r24, 0xFF	; 255
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	ff 90       	pop	r15
    2594:	ef 90       	pop	r14
    2596:	df 90       	pop	r13
    2598:	cf 90       	pop	r12
    259a:	bf 90       	pop	r11
    259c:	af 90       	pop	r10
    259e:	9f 90       	pop	r9
    25a0:	8f 90       	pop	r8
    25a2:	7f 90       	pop	r7
    25a4:	6f 90       	pop	r6
    25a6:	5f 90       	pop	r5
    25a8:	4f 90       	pop	r4
    25aa:	08 95       	ret

000025ac <uxTaskPriorityGet>:
    25ac:	0f b6       	in	r0, 0x3f	; 63
    25ae:	f8 94       	cli
    25b0:	0f 92       	push	r0
    25b2:	00 97       	sbiw	r24, 0x00	; 0
    25b4:	21 f4       	brne	.+8      	; 0x25be <uxTaskPriorityGet+0x12>
    25b6:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    25ba:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    25be:	0f 90       	pop	r0
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	fc 01       	movw	r30, r24
    25c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    25c6:	08 95       	ret

000025c8 <vTaskStartScheduler>:
    25c8:	af 92       	push	r10
    25ca:	bf 92       	push	r11
    25cc:	cf 92       	push	r12
    25ce:	df 92       	push	r13
    25d0:	ef 92       	push	r14
    25d2:	ff 92       	push	r15
    25d4:	0f 93       	push	r16
    25d6:	a1 2c       	mov	r10, r1
    25d8:	b1 2c       	mov	r11, r1
    25da:	c1 2c       	mov	r12, r1
    25dc:	d1 2c       	mov	r13, r1
    25de:	0f 2e       	mov	r0, r31
    25e0:	fd e7       	ldi	r31, 0x7D	; 125
    25e2:	ef 2e       	mov	r14, r31
    25e4:	f1 e3       	ldi	r31, 0x31	; 49
    25e6:	ff 2e       	mov	r15, r31
    25e8:	f0 2d       	mov	r31, r0
    25ea:	00 e0       	ldi	r16, 0x00	; 0
    25ec:	20 e0       	ldi	r18, 0x00	; 0
    25ee:	30 e0       	ldi	r19, 0x00	; 0
    25f0:	44 e6       	ldi	r20, 0x64	; 100
    25f2:	50 e0       	ldi	r21, 0x00	; 0
    25f4:	66 eb       	ldi	r22, 0xB6	; 182
    25f6:	70 e2       	ldi	r23, 0x20	; 32
    25f8:	8e e7       	ldi	r24, 0x7E	; 126
    25fa:	91 e1       	ldi	r25, 0x11	; 17
    25fc:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <xTaskGenericCreate>
    2600:	81 30       	cpi	r24, 0x01	; 1
    2602:	69 f4       	brne	.+26     	; 0x261e <vTaskStartScheduler+0x56>
    2604:	f8 94       	cli
    2606:	80 93 75 31 	sts	0x3175, r24	; 0x803175 <xSchedulerRunning>
    260a:	10 92 78 31 	sts	0x3178, r1	; 0x803178 <xTickCount>
    260e:	10 92 79 31 	sts	0x3179, r1	; 0x803179 <xTickCount+0x1>
    2612:	10 92 7a 31 	sts	0x317A, r1	; 0x80317a <xTickCount+0x2>
    2616:	10 92 7b 31 	sts	0x317B, r1	; 0x80317b <xTickCount+0x3>
    261a:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <xPortStartScheduler>
    261e:	0f 91       	pop	r16
    2620:	ff 90       	pop	r15
    2622:	ef 90       	pop	r14
    2624:	df 90       	pop	r13
    2626:	cf 90       	pop	r12
    2628:	bf 90       	pop	r11
    262a:	af 90       	pop	r10
    262c:	08 95       	ret

0000262e <vTaskSuspendAll>:
    262e:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2632:	8f 5f       	subi	r24, 0xFF	; 255
    2634:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <uxSchedulerSuspended>
    2638:	08 95       	ret

0000263a <xTaskGetTickCount>:
    263a:	0f b6       	in	r0, 0x3f	; 63
    263c:	f8 94       	cli
    263e:	0f 92       	push	r0
    2640:	60 91 78 31 	lds	r22, 0x3178	; 0x803178 <xTickCount>
    2644:	70 91 79 31 	lds	r23, 0x3179	; 0x803179 <xTickCount+0x1>
    2648:	80 91 7a 31 	lds	r24, 0x317A	; 0x80317a <xTickCount+0x2>
    264c:	90 91 7b 31 	lds	r25, 0x317B	; 0x80317b <xTickCount+0x3>
    2650:	0f 90       	pop	r0
    2652:	0f be       	out	0x3f, r0	; 63
    2654:	08 95       	ret

00002656 <pcTaskGetTaskName>:
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	21 f4       	brne	.+8      	; 0x2662 <pcTaskGetTaskName+0xc>
    265a:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    265e:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2662:	4d 96       	adiw	r24, 0x1d	; 29
    2664:	08 95       	ret

00002666 <xTaskGetIdleTaskHandle>:
    2666:	80 91 7d 31 	lds	r24, 0x317D	; 0x80317d <xIdleTaskHandle>
    266a:	90 91 7e 31 	lds	r25, 0x317E	; 0x80317e <xIdleTaskHandle+0x1>
    266e:	08 95       	ret

00002670 <vTaskIncrementTick>:
    2670:	ff 92       	push	r15
    2672:	0f 93       	push	r16
    2674:	1f 93       	push	r17
    2676:	cf 93       	push	r28
    2678:	df 93       	push	r29
    267a:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    267e:	81 11       	cpse	r24, r1
    2680:	ed c0       	rjmp	.+474    	; 0x285c <vTaskIncrementTick+0x1ec>
    2682:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2686:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    268a:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    268e:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2692:	01 96       	adiw	r24, 0x01	; 1
    2694:	a1 1d       	adc	r26, r1
    2696:	b1 1d       	adc	r27, r1
    2698:	80 93 78 31 	sts	0x3178, r24	; 0x803178 <xTickCount>
    269c:	90 93 79 31 	sts	0x3179, r25	; 0x803179 <xTickCount+0x1>
    26a0:	a0 93 7a 31 	sts	0x317A, r26	; 0x80317a <xTickCount+0x2>
    26a4:	b0 93 7b 31 	sts	0x317B, r27	; 0x80317b <xTickCount+0x3>
    26a8:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    26ac:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    26b0:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    26b4:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    26b8:	89 2b       	or	r24, r25
    26ba:	8a 2b       	or	r24, r26
    26bc:	8b 2b       	or	r24, r27
    26be:	f1 f5       	brne	.+124    	; 0x273c <vTaskIncrementTick+0xcc>
    26c0:	80 91 8c 31 	lds	r24, 0x318C	; 0x80318c <pxDelayedTaskList>
    26c4:	90 91 8d 31 	lds	r25, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    26c8:	20 91 8a 31 	lds	r18, 0x318A	; 0x80318a <pxOverflowDelayedTaskList>
    26cc:	30 91 8b 31 	lds	r19, 0x318B	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    26d0:	20 93 8c 31 	sts	0x318C, r18	; 0x80318c <pxDelayedTaskList>
    26d4:	30 93 8d 31 	sts	0x318D, r19	; 0x80318d <pxDelayedTaskList+0x1>
    26d8:	80 93 8a 31 	sts	0x318A, r24	; 0x80318a <pxOverflowDelayedTaskList>
    26dc:	90 93 8b 31 	sts	0x318B, r25	; 0x80318b <pxOverflowDelayedTaskList+0x1>
    26e0:	80 91 71 31 	lds	r24, 0x3171	; 0x803171 <xNumOfOverflows>
    26e4:	8f 5f       	subi	r24, 0xFF	; 255
    26e6:	80 93 71 31 	sts	0x3171, r24	; 0x803171 <xNumOfOverflows>
    26ea:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    26ee:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    26f2:	80 81       	ld	r24, Z
    26f4:	81 11       	cpse	r24, r1
    26f6:	0c c0       	rjmp	.+24     	; 0x2710 <vTaskIncrementTick+0xa0>
    26f8:	8f ef       	ldi	r24, 0xFF	; 255
    26fa:	9f ef       	ldi	r25, 0xFF	; 255
    26fc:	dc 01       	movw	r26, r24
    26fe:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2702:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2706:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    270a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    270e:	16 c0       	rjmp	.+44     	; 0x273c <vTaskIncrementTick+0xcc>
    2710:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    2714:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2718:	07 80       	ldd	r0, Z+7	; 0x07
    271a:	f0 85       	ldd	r31, Z+8	; 0x08
    271c:	e0 2d       	mov	r30, r0
    271e:	00 84       	ldd	r0, Z+8	; 0x08
    2720:	f1 85       	ldd	r31, Z+9	; 0x09
    2722:	e0 2d       	mov	r30, r0
    2724:	82 81       	ldd	r24, Z+2	; 0x02
    2726:	93 81       	ldd	r25, Z+3	; 0x03
    2728:	a4 81       	ldd	r26, Z+4	; 0x04
    272a:	b5 81       	ldd	r27, Z+5	; 0x05
    272c:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2730:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2734:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2738:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    273c:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2740:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2744:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    2748:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    274c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2750:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2754:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2758:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    275c:	48 17       	cp	r20, r24
    275e:	59 07       	cpc	r21, r25
    2760:	6a 07       	cpc	r22, r26
    2762:	7b 07       	cpc	r23, r27
    2764:	08 f4       	brcc	.+2      	; 0x2768 <vTaskIncrementTick+0xf8>
    2766:	7f c0       	rjmp	.+254    	; 0x2866 <vTaskIncrementTick+0x1f6>
    2768:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    276c:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2770:	80 81       	ld	r24, Z
    2772:	88 23       	and	r24, r24
    2774:	f9 f0       	breq	.+62     	; 0x27b4 <vTaskIncrementTick+0x144>
    2776:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    277a:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    277e:	07 80       	ldd	r0, Z+7	; 0x07
    2780:	f0 85       	ldd	r31, Z+8	; 0x08
    2782:	e0 2d       	mov	r30, r0
    2784:	c0 85       	ldd	r28, Z+8	; 0x08
    2786:	d1 85       	ldd	r29, Z+9	; 0x09
    2788:	8a 81       	ldd	r24, Y+2	; 0x02
    278a:	9b 81       	ldd	r25, Y+3	; 0x03
    278c:	ac 81       	ldd	r26, Y+4	; 0x04
    278e:	bd 81       	ldd	r27, Y+5	; 0x05
    2790:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2794:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2798:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    279c:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    27a0:	48 17       	cp	r20, r24
    27a2:	59 07       	cpc	r21, r25
    27a4:	6a 07       	cpc	r22, r26
    27a6:	7b 07       	cpc	r23, r27
    27a8:	58 f1       	brcs	.+86     	; 0x2800 <vTaskIncrementTick+0x190>
    27aa:	0f 2e       	mov	r0, r31
    27ac:	fb e0       	ldi	r31, 0x0B	; 11
    27ae:	ff 2e       	mov	r15, r31
    27b0:	f0 2d       	mov	r31, r0
    27b2:	2f c0       	rjmp	.+94     	; 0x2812 <vTaskIncrementTick+0x1a2>
    27b4:	8f ef       	ldi	r24, 0xFF	; 255
    27b6:	9f ef       	ldi	r25, 0xFF	; 255
    27b8:	dc 01       	movw	r26, r24
    27ba:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    27be:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    27c2:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    27c6:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    27ca:	4d c0       	rjmp	.+154    	; 0x2866 <vTaskIncrementTick+0x1f6>
    27cc:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    27d0:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    27d4:	07 80       	ldd	r0, Z+7	; 0x07
    27d6:	f0 85       	ldd	r31, Z+8	; 0x08
    27d8:	e0 2d       	mov	r30, r0
    27da:	c0 85       	ldd	r28, Z+8	; 0x08
    27dc:	d1 85       	ldd	r29, Z+9	; 0x09
    27de:	8a 81       	ldd	r24, Y+2	; 0x02
    27e0:	9b 81       	ldd	r25, Y+3	; 0x03
    27e2:	ac 81       	ldd	r26, Y+4	; 0x04
    27e4:	bd 81       	ldd	r27, Y+5	; 0x05
    27e6:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    27ea:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    27ee:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    27f2:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    27f6:	48 17       	cp	r20, r24
    27f8:	59 07       	cpc	r21, r25
    27fa:	6a 07       	cpc	r22, r26
    27fc:	7b 07       	cpc	r23, r27
    27fe:	48 f4       	brcc	.+18     	; 0x2812 <vTaskIncrementTick+0x1a2>
    2800:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2804:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2808:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    280c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2810:	2a c0       	rjmp	.+84     	; 0x2866 <vTaskIncrementTick+0x1f6>
    2812:	8e 01       	movw	r16, r28
    2814:	0e 5f       	subi	r16, 0xFE	; 254
    2816:	1f 4f       	sbci	r17, 0xFF	; 255
    2818:	c8 01       	movw	r24, r16
    281a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
    281e:	88 8d       	ldd	r24, Y+24	; 0x18
    2820:	99 8d       	ldd	r25, Y+25	; 0x19
    2822:	89 2b       	or	r24, r25
    2824:	21 f0       	breq	.+8      	; 0x282e <vTaskIncrementTick+0x1be>
    2826:	ce 01       	movw	r24, r28
    2828:	0e 96       	adiw	r24, 0x0e	; 14
    282a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
    282e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2830:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2834:	98 17       	cp	r25, r24
    2836:	10 f4       	brcc	.+4      	; 0x283c <vTaskIncrementTick+0x1cc>
    2838:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    283c:	f8 9e       	mul	r15, r24
    283e:	c0 01       	movw	r24, r0
    2840:	11 24       	eor	r1, r1
    2842:	b8 01       	movw	r22, r16
    2844:	8c 55       	subi	r24, 0x5C	; 92
    2846:	9e 4c       	sbci	r25, 0xCE	; 206
    2848:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
    284c:	e0 91 8c 31 	lds	r30, 0x318C	; 0x80318c <pxDelayedTaskList>
    2850:	f0 91 8d 31 	lds	r31, 0x318D	; 0x80318d <pxDelayedTaskList+0x1>
    2854:	80 81       	ld	r24, Z
    2856:	81 11       	cpse	r24, r1
    2858:	b9 cf       	rjmp	.-142    	; 0x27cc <vTaskIncrementTick+0x15c>
    285a:	ac cf       	rjmp	.-168    	; 0x27b4 <vTaskIncrementTick+0x144>
    285c:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2860:	8f 5f       	subi	r24, 0xFF	; 255
    2862:	80 93 73 31 	sts	0x3173, r24	; 0x803173 <uxMissedTicks>
    2866:	df 91       	pop	r29
    2868:	cf 91       	pop	r28
    286a:	1f 91       	pop	r17
    286c:	0f 91       	pop	r16
    286e:	ff 90       	pop	r15
    2870:	08 95       	ret

00002872 <xTaskResumeAll>:
    2872:	cf 92       	push	r12
    2874:	df 92       	push	r13
    2876:	ef 92       	push	r14
    2878:	ff 92       	push	r15
    287a:	0f 93       	push	r16
    287c:	1f 93       	push	r17
    287e:	cf 93       	push	r28
    2880:	df 93       	push	r29
    2882:	0f b6       	in	r0, 0x3f	; 63
    2884:	f8 94       	cli
    2886:	0f 92       	push	r0
    2888:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    288c:	81 50       	subi	r24, 0x01	; 1
    288e:	80 93 74 31 	sts	0x3174, r24	; 0x803174 <uxSchedulerSuspended>
    2892:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2896:	81 11       	cpse	r24, r1
    2898:	60 c0       	rjmp	.+192    	; 0x295a <xTaskResumeAll+0xe8>
    289a:	80 91 7c 31 	lds	r24, 0x317C	; 0x80317c <uxCurrentNumberOfTasks>
    289e:	81 11       	cpse	r24, r1
    28a0:	2c c0       	rjmp	.+88     	; 0x28fa <xTaskResumeAll+0x88>
    28a2:	5e c0       	rjmp	.+188    	; 0x2960 <xTaskResumeAll+0xee>
    28a4:	d7 01       	movw	r26, r14
    28a6:	17 96       	adiw	r26, 0x07	; 7
    28a8:	ed 91       	ld	r30, X+
    28aa:	fc 91       	ld	r31, X
    28ac:	18 97       	sbiw	r26, 0x08	; 8
    28ae:	c0 85       	ldd	r28, Z+8	; 0x08
    28b0:	d1 85       	ldd	r29, Z+9	; 0x09
    28b2:	ce 01       	movw	r24, r28
    28b4:	0e 96       	adiw	r24, 0x0e	; 14
    28b6:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
    28ba:	8e 01       	movw	r16, r28
    28bc:	0e 5f       	subi	r16, 0xFE	; 254
    28be:	1f 4f       	sbci	r17, 0xFF	; 255
    28c0:	c8 01       	movw	r24, r16
    28c2:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
    28c6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28c8:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    28cc:	98 17       	cp	r25, r24
    28ce:	10 f4       	brcc	.+4      	; 0x28d4 <xTaskResumeAll+0x62>
    28d0:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    28d4:	d8 9e       	mul	r13, r24
    28d6:	c0 01       	movw	r24, r0
    28d8:	11 24       	eor	r1, r1
    28da:	b8 01       	movw	r22, r16
    28dc:	8c 55       	subi	r24, 0x5C	; 92
    28de:	9e 4c       	sbci	r25, 0xCE	; 206
    28e0:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
    28e4:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    28e8:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    28ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28ee:	82 8d       	ldd	r24, Z+26	; 0x1a
    28f0:	98 17       	cp	r25, r24
    28f2:	70 f0       	brcs	.+28     	; 0x2910 <xTaskResumeAll+0x9e>
    28f4:	cc 24       	eor	r12, r12
    28f6:	c3 94       	inc	r12
    28f8:	0b c0       	rjmp	.+22     	; 0x2910 <xTaskResumeAll+0x9e>
    28fa:	c1 2c       	mov	r12, r1
    28fc:	0f 2e       	mov	r0, r31
    28fe:	ff e7       	ldi	r31, 0x7F	; 127
    2900:	ef 2e       	mov	r14, r31
    2902:	f1 e3       	ldi	r31, 0x31	; 49
    2904:	ff 2e       	mov	r15, r31
    2906:	f0 2d       	mov	r31, r0
    2908:	0f 2e       	mov	r0, r31
    290a:	fb e0       	ldi	r31, 0x0B	; 11
    290c:	df 2e       	mov	r13, r31
    290e:	f0 2d       	mov	r31, r0
    2910:	f7 01       	movw	r30, r14
    2912:	80 81       	ld	r24, Z
    2914:	81 11       	cpse	r24, r1
    2916:	c6 cf       	rjmp	.-116    	; 0x28a4 <xTaskResumeAll+0x32>
    2918:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    291c:	88 23       	and	r24, r24
    291e:	81 f0       	breq	.+32     	; 0x2940 <xTaskResumeAll+0xce>
    2920:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2924:	88 23       	and	r24, r24
    2926:	99 f0       	breq	.+38     	; 0x294e <xTaskResumeAll+0xdc>
    2928:	0e 94 38 13 	call	0x2670	; 0x2670 <vTaskIncrementTick>
    292c:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    2930:	81 50       	subi	r24, 0x01	; 1
    2932:	80 93 73 31 	sts	0x3173, r24	; 0x803173 <uxMissedTicks>
    2936:	80 91 73 31 	lds	r24, 0x3173	; 0x803173 <uxMissedTicks>
    293a:	81 11       	cpse	r24, r1
    293c:	f5 cf       	rjmp	.-22     	; 0x2928 <xTaskResumeAll+0xb6>
    293e:	07 c0       	rjmp	.+14     	; 0x294e <xTaskResumeAll+0xdc>
    2940:	f1 e0       	ldi	r31, 0x01	; 1
    2942:	cf 16       	cp	r12, r31
    2944:	21 f0       	breq	.+8      	; 0x294e <xTaskResumeAll+0xdc>
    2946:	80 91 72 31 	lds	r24, 0x3172	; 0x803172 <xMissedYield>
    294a:	81 30       	cpi	r24, 0x01	; 1
    294c:	41 f4       	brne	.+16     	; 0x295e <xTaskResumeAll+0xec>
    294e:	10 92 72 31 	sts	0x3172, r1	; 0x803172 <xMissedYield>
    2952:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	03 c0       	rjmp	.+6      	; 0x2960 <xTaskResumeAll+0xee>
    295a:	80 e0       	ldi	r24, 0x00	; 0
    295c:	01 c0       	rjmp	.+2      	; 0x2960 <xTaskResumeAll+0xee>
    295e:	80 e0       	ldi	r24, 0x00	; 0
    2960:	0f 90       	pop	r0
    2962:	0f be       	out	0x3f, r0	; 63
    2964:	df 91       	pop	r29
    2966:	cf 91       	pop	r28
    2968:	1f 91       	pop	r17
    296a:	0f 91       	pop	r16
    296c:	ff 90       	pop	r15
    296e:	ef 90       	pop	r14
    2970:	df 90       	pop	r13
    2972:	cf 90       	pop	r12
    2974:	08 95       	ret

00002976 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2976:	cf 92       	push	r12
    2978:	df 92       	push	r13
    297a:	ef 92       	push	r14
    297c:	ff 92       	push	r15
    297e:	6b 01       	movw	r12, r22
    2980:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2982:	67 2b       	or	r22, r23
    2984:	68 2b       	or	r22, r24
    2986:	69 2b       	or	r22, r25
    2988:	e9 f0       	breq	.+58     	; 0x29c4 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    298a:	0e 94 17 13 	call	0x262e	; 0x262e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    298e:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2992:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2996:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    299a:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    299e:	c8 0e       	add	r12, r24
    29a0:	d9 1e       	adc	r13, r25
    29a2:	ea 1e       	adc	r14, r26
    29a4:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    29a6:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    29aa:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    29ae:	02 96       	adiw	r24, 0x02	; 2
    29b0:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    29b4:	c7 01       	movw	r24, r14
    29b6:	b6 01       	movw	r22, r12
    29b8:	0e 94 86 11 	call	0x230c	; 0x230c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    29bc:	0e 94 39 14 	call	0x2872	; 0x2872 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29c0:	81 11       	cpse	r24, r1
    29c2:	02 c0       	rjmp	.+4      	; 0x29c8 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    29c4:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <vPortYield>
		}
	}
    29c8:	ff 90       	pop	r15
    29ca:	ef 90       	pop	r14
    29cc:	df 90       	pop	r13
    29ce:	cf 90       	pop	r12
    29d0:	08 95       	ret

000029d2 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    29d2:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    29d6:	81 11       	cpse	r24, r1
    29d8:	0c c0       	rjmp	.+24     	; 0x29f2 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29da:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <uxTopReadyPriority>
    29de:	4b e0       	ldi	r20, 0x0B	; 11
    29e0:	e4 9f       	mul	r30, r20
    29e2:	f0 01       	movw	r30, r0
    29e4:	11 24       	eor	r1, r1
    29e6:	ec 55       	subi	r30, 0x5C	; 92
    29e8:	fe 4c       	sbci	r31, 0xCE	; 206
    29ea:	80 81       	ld	r24, Z
    29ec:	88 23       	and	r24, r24
    29ee:	29 f0       	breq	.+10     	; 0x29fa <vTaskSwitchContext+0x28>
    29f0:	14 c0       	rjmp	.+40     	; 0x2a1a <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    29f2:	81 e0       	ldi	r24, 0x01	; 1
    29f4:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <xMissedYield>
    29f8:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    29fa:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    29fc:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <uxTopReadyPriority>
    2a00:	81 50       	subi	r24, 0x01	; 1
    2a02:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2a06:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <uxTopReadyPriority>
    2a0a:	9e 9f       	mul	r25, r30
    2a0c:	f0 01       	movw	r30, r0
    2a0e:	11 24       	eor	r1, r1
    2a10:	ec 55       	subi	r30, 0x5C	; 92
    2a12:	fe 4c       	sbci	r31, 0xCE	; 206
    2a14:	80 81       	ld	r24, Z
    2a16:	88 23       	and	r24, r24
    2a18:	89 f3       	breq	.-30     	; 0x29fc <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2a1a:	80 91 76 31 	lds	r24, 0x3176	; 0x803176 <uxTopReadyPriority>
    2a1e:	28 2f       	mov	r18, r24
    2a20:	30 e0       	ldi	r19, 0x00	; 0
    2a22:	4b e0       	ldi	r20, 0x0B	; 11
    2a24:	84 9f       	mul	r24, r20
    2a26:	c0 01       	movw	r24, r0
    2a28:	11 24       	eor	r1, r1
    2a2a:	dc 01       	movw	r26, r24
    2a2c:	ac 55       	subi	r26, 0x5C	; 92
    2a2e:	be 4c       	sbci	r27, 0xCE	; 206
    2a30:	11 96       	adiw	r26, 0x01	; 1
    2a32:	ed 91       	ld	r30, X+
    2a34:	fc 91       	ld	r31, X
    2a36:	12 97       	sbiw	r26, 0x02	; 2
    2a38:	04 80       	ldd	r0, Z+4	; 0x04
    2a3a:	f5 81       	ldd	r31, Z+5	; 0x05
    2a3c:	e0 2d       	mov	r30, r0
    2a3e:	11 96       	adiw	r26, 0x01	; 1
    2a40:	ed 93       	st	X+, r30
    2a42:	fc 93       	st	X, r31
    2a44:	12 97       	sbiw	r26, 0x02	; 2
    2a46:	89 55       	subi	r24, 0x59	; 89
    2a48:	9e 4c       	sbci	r25, 0xCE	; 206
    2a4a:	e8 17       	cp	r30, r24
    2a4c:	f9 07       	cpc	r31, r25
    2a4e:	61 f4       	brne	.+24     	; 0x2a68 <vTaskSwitchContext+0x96>
    2a50:	84 81       	ldd	r24, Z+4	; 0x04
    2a52:	95 81       	ldd	r25, Z+5	; 0x05
    2a54:	4b e0       	ldi	r20, 0x0B	; 11
    2a56:	42 9f       	mul	r20, r18
    2a58:	f0 01       	movw	r30, r0
    2a5a:	43 9f       	mul	r20, r19
    2a5c:	f0 0d       	add	r31, r0
    2a5e:	11 24       	eor	r1, r1
    2a60:	ec 55       	subi	r30, 0x5C	; 92
    2a62:	fe 4c       	sbci	r31, 0xCE	; 206
    2a64:	81 83       	std	Z+1, r24	; 0x01
    2a66:	92 83       	std	Z+2, r25	; 0x02
    2a68:	8b e0       	ldi	r24, 0x0B	; 11
    2a6a:	82 9f       	mul	r24, r18
    2a6c:	f0 01       	movw	r30, r0
    2a6e:	83 9f       	mul	r24, r19
    2a70:	f0 0d       	add	r31, r0
    2a72:	11 24       	eor	r1, r1
    2a74:	ec 55       	subi	r30, 0x5C	; 92
    2a76:	fe 4c       	sbci	r31, 0xCE	; 206
    2a78:	01 80       	ldd	r0, Z+1	; 0x01
    2a7a:	f2 81       	ldd	r31, Z+2	; 0x02
    2a7c:	e0 2d       	mov	r30, r0
    2a7e:	80 85       	ldd	r24, Z+8	; 0x08
    2a80:	91 85       	ldd	r25, Z+9	; 0x09
    2a82:	80 93 d0 31 	sts	0x31D0, r24	; 0x8031d0 <pxCurrentTCB>
    2a86:	90 93 d1 31 	sts	0x31D1, r25	; 0x8031d1 <pxCurrentTCB+0x1>
    2a8a:	08 95       	ret

00002a8c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2a8c:	cf 92       	push	r12
    2a8e:	df 92       	push	r13
    2a90:	ef 92       	push	r14
    2a92:	ff 92       	push	r15
    2a94:	6a 01       	movw	r12, r20
    2a96:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2a98:	60 91 d0 31 	lds	r22, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2a9c:	70 91 d1 31 	lds	r23, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2aa0:	62 5f       	subi	r22, 0xF2	; 242
    2aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa4:	0e 94 b5 0c 	call	0x196a	; 0x196a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2aa8:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2aac:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2ab0:	02 96       	adiw	r24, 0x02	; 2
    2ab2:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2ab6:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2aba:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2abe:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2ac2:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2ac6:	bc 01       	movw	r22, r24
    2ac8:	cd 01       	movw	r24, r26
    2aca:	6c 0d       	add	r22, r12
    2acc:	7d 1d       	adc	r23, r13
    2ace:	8e 1d       	adc	r24, r14
    2ad0:	9f 1d       	adc	r25, r15
    2ad2:	0e 94 86 11 	call	0x230c	; 0x230c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2ad6:	ff 90       	pop	r15
    2ad8:	ef 90       	pop	r14
    2ada:	df 90       	pop	r13
    2adc:	cf 90       	pop	r12
    2ade:	08 95       	ret

00002ae0 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2ae0:	0f 93       	push	r16
    2ae2:	1f 93       	push	r17
    2ae4:	cf 93       	push	r28
    2ae6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2ae8:	dc 01       	movw	r26, r24
    2aea:	17 96       	adiw	r26, 0x07	; 7
    2aec:	ed 91       	ld	r30, X+
    2aee:	fc 91       	ld	r31, X
    2af0:	18 97       	sbiw	r26, 0x08	; 8
    2af2:	c0 85       	ldd	r28, Z+8	; 0x08
    2af4:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2af6:	8e 01       	movw	r16, r28
    2af8:	02 5f       	subi	r16, 0xF2	; 242
    2afa:	1f 4f       	sbci	r17, 0xFF	; 255
    2afc:	c8 01       	movw	r24, r16
    2afe:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2b02:	80 91 74 31 	lds	r24, 0x3174	; 0x803174 <uxSchedulerSuspended>
    2b06:	81 11       	cpse	r24, r1
    2b08:	16 c0       	rjmp	.+44     	; 0x2b36 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2b0a:	0c 50       	subi	r16, 0x0C	; 12
    2b0c:	11 09       	sbc	r17, r1
    2b0e:	c8 01       	movw	r24, r16
    2b10:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2b14:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b16:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2b1a:	98 17       	cp	r25, r24
    2b1c:	10 f4       	brcc	.+4      	; 0x2b22 <xTaskRemoveFromEventList+0x42>
    2b1e:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2b22:	bb e0       	ldi	r27, 0x0B	; 11
    2b24:	8b 9f       	mul	r24, r27
    2b26:	c0 01       	movw	r24, r0
    2b28:	11 24       	eor	r1, r1
    2b2a:	b8 01       	movw	r22, r16
    2b2c:	8c 55       	subi	r24, 0x5C	; 92
    2b2e:	9e 4c       	sbci	r25, 0xCE	; 206
    2b30:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
    2b34:	05 c0       	rjmp	.+10     	; 0x2b40 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2b36:	b8 01       	movw	r22, r16
    2b38:	8f e7       	ldi	r24, 0x7F	; 127
    2b3a:	91 e3       	ldi	r25, 0x31	; 49
    2b3c:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b40:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2b44:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2b48:	81 e0       	ldi	r24, 0x01	; 1
    2b4a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2b4c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b4e:	29 17       	cp	r18, r25
    2b50:	08 f4       	brcc	.+2      	; 0x2b54 <xTaskRemoveFromEventList+0x74>
    2b52:	80 e0       	ldi	r24, 0x00	; 0
}
    2b54:	df 91       	pop	r29
    2b56:	cf 91       	pop	r28
    2b58:	1f 91       	pop	r17
    2b5a:	0f 91       	pop	r16
    2b5c:	08 95       	ret

00002b5e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2b5e:	20 91 71 31 	lds	r18, 0x3171	; 0x803171 <xNumOfOverflows>
    2b62:	fc 01       	movw	r30, r24
    2b64:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2b66:	40 91 78 31 	lds	r20, 0x3178	; 0x803178 <xTickCount>
    2b6a:	50 91 79 31 	lds	r21, 0x3179	; 0x803179 <xTickCount+0x1>
    2b6e:	60 91 7a 31 	lds	r22, 0x317A	; 0x80317a <xTickCount+0x2>
    2b72:	70 91 7b 31 	lds	r23, 0x317B	; 0x80317b <xTickCount+0x3>
    2b76:	41 83       	std	Z+1, r20	; 0x01
    2b78:	52 83       	std	Z+2, r21	; 0x02
    2b7a:	63 83       	std	Z+3, r22	; 0x03
    2b7c:	74 83       	std	Z+4, r23	; 0x04
    2b7e:	08 95       	ret

00002b80 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2b80:	8f 92       	push	r8
    2b82:	9f 92       	push	r9
    2b84:	af 92       	push	r10
    2b86:	bf 92       	push	r11
    2b88:	cf 92       	push	r12
    2b8a:	df 92       	push	r13
    2b8c:	ef 92       	push	r14
    2b8e:	ff 92       	push	r15
    2b90:	0f 93       	push	r16
    2b92:	1f 93       	push	r17
    2b94:	cf 93       	push	r28
    2b96:	df 93       	push	r29
    2b98:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2b9a:	0f b6       	in	r0, 0x3f	; 63
    2b9c:	f8 94       	cli
    2b9e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2ba0:	80 91 71 31 	lds	r24, 0x3171	; 0x803171 <xNumOfOverflows>
    2ba4:	90 81       	ld	r25, Z
    2ba6:	98 17       	cp	r25, r24
    2ba8:	89 f0       	breq	.+34     	; 0x2bcc <xTaskCheckForTimeOut+0x4c>
    2baa:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2bae:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2bb2:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2bb6:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2bba:	01 81       	ldd	r16, Z+1	; 0x01
    2bbc:	12 81       	ldd	r17, Z+2	; 0x02
    2bbe:	23 81       	ldd	r18, Z+3	; 0x03
    2bc0:	34 81       	ldd	r19, Z+4	; 0x04
    2bc2:	80 17       	cp	r24, r16
    2bc4:	91 07       	cpc	r25, r17
    2bc6:	a2 07       	cpc	r26, r18
    2bc8:	b3 07       	cpc	r27, r19
    2bca:	a8 f5       	brcc	.+106    	; 0x2c36 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2bcc:	80 91 78 31 	lds	r24, 0x3178	; 0x803178 <xTickCount>
    2bd0:	90 91 79 31 	lds	r25, 0x3179	; 0x803179 <xTickCount+0x1>
    2bd4:	a0 91 7a 31 	lds	r26, 0x317A	; 0x80317a <xTickCount+0x2>
    2bd8:	b0 91 7b 31 	lds	r27, 0x317B	; 0x80317b <xTickCount+0x3>
    2bdc:	c1 80       	ldd	r12, Z+1	; 0x01
    2bde:	d2 80       	ldd	r13, Z+2	; 0x02
    2be0:	e3 80       	ldd	r14, Z+3	; 0x03
    2be2:	f4 80       	ldd	r15, Z+4	; 0x04
    2be4:	eb 01       	movw	r28, r22
    2be6:	08 81       	ld	r16, Y
    2be8:	19 81       	ldd	r17, Y+1	; 0x01
    2bea:	2a 81       	ldd	r18, Y+2	; 0x02
    2bec:	3b 81       	ldd	r19, Y+3	; 0x03
    2bee:	8c 19       	sub	r24, r12
    2bf0:	9d 09       	sbc	r25, r13
    2bf2:	ae 09       	sbc	r26, r14
    2bf4:	bf 09       	sbc	r27, r15
    2bf6:	80 17       	cp	r24, r16
    2bf8:	91 07       	cpc	r25, r17
    2bfa:	a2 07       	cpc	r26, r18
    2bfc:	b3 07       	cpc	r27, r19
    2bfe:	e8 f4       	brcc	.+58     	; 0x2c3a <xTaskCheckForTimeOut+0xba>
    2c00:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2c02:	80 90 78 31 	lds	r8, 0x3178	; 0x803178 <xTickCount>
    2c06:	90 90 79 31 	lds	r9, 0x3179	; 0x803179 <xTickCount+0x1>
    2c0a:	a0 90 7a 31 	lds	r10, 0x317A	; 0x80317a <xTickCount+0x2>
    2c0e:	b0 90 7b 31 	lds	r11, 0x317B	; 0x80317b <xTickCount+0x3>
    2c12:	b5 01       	movw	r22, r10
    2c14:	a4 01       	movw	r20, r8
    2c16:	4c 19       	sub	r20, r12
    2c18:	5d 09       	sbc	r21, r13
    2c1a:	6e 09       	sbc	r22, r14
    2c1c:	7f 09       	sbc	r23, r15
    2c1e:	04 1b       	sub	r16, r20
    2c20:	15 0b       	sbc	r17, r21
    2c22:	26 0b       	sbc	r18, r22
    2c24:	37 0b       	sbc	r19, r23
    2c26:	08 83       	st	Y, r16
    2c28:	19 83       	std	Y+1, r17	; 0x01
    2c2a:	2a 83       	std	Y+2, r18	; 0x02
    2c2c:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2c2e:	0e 94 af 15 	call	0x2b5e	; 0x2b5e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2c32:	80 e0       	ldi	r24, 0x00	; 0
    2c34:	03 c0       	rjmp	.+6      	; 0x2c3c <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2c36:	81 e0       	ldi	r24, 0x01	; 1
    2c38:	01 c0       	rjmp	.+2      	; 0x2c3c <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2c3a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2c3c:	0f 90       	pop	r0
    2c3e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	ff 90       	pop	r15
    2c4a:	ef 90       	pop	r14
    2c4c:	df 90       	pop	r13
    2c4e:	cf 90       	pop	r12
    2c50:	bf 90       	pop	r11
    2c52:	af 90       	pop	r10
    2c54:	9f 90       	pop	r9
    2c56:	8f 90       	pop	r8
    2c58:	08 95       	ret

00002c5a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	80 93 72 31 	sts	0x3172, r24	; 0x803172 <xMissedYield>
    2c60:	08 95       	ret

00002c62 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2c62:	00 97       	sbiw	r24, 0x00	; 0
    2c64:	21 f4       	brne	.+8      	; 0x2c6e <uxTaskGetStackHighWaterMark+0xc>
    2c66:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2c6a:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2c6e:	dc 01       	movw	r26, r24
    2c70:	5b 96       	adiw	r26, 0x1b	; 27
    2c72:	ed 91       	ld	r30, X+
    2c74:	fc 91       	ld	r31, X
    2c76:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2c78:	80 81       	ld	r24, Z
    2c7a:	81 31       	cpi	r24, 0x11	; 17
    2c7c:	41 f4       	brne	.+16     	; 0x2c8e <uxTaskGetStackHighWaterMark+0x2c>
    2c7e:	31 96       	adiw	r30, 0x01	; 1
    2c80:	80 e0       	ldi	r24, 0x00	; 0
    2c82:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2c84:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2c86:	21 91       	ld	r18, Z+
    2c88:	21 31       	cpi	r18, 0x11	; 17
    2c8a:	e1 f3       	breq	.-8      	; 0x2c84 <uxTaskGetStackHighWaterMark+0x22>
    2c8c:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2c8e:	80 e0       	ldi	r24, 0x00	; 0
    2c90:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2c92:	08 95       	ret

00002c94 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2c94:	80 91 d0 31 	lds	r24, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2c98:	90 91 d1 31 	lds	r25, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2c9c:	08 95       	ret

00002c9e <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2c9e:	0f 93       	push	r16
    2ca0:	1f 93       	push	r17
    2ca2:	cf 93       	push	r28
    2ca4:	df 93       	push	r29
    2ca6:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2ca8:	22 8d       	ldd	r18, Z+26	; 0x1a
    2caa:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2cae:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2cb2:	5a 96       	adiw	r26, 0x1a	; 26
    2cb4:	8c 91       	ld	r24, X
    2cb6:	28 17       	cp	r18, r24
    2cb8:	08 f0       	brcs	.+2      	; 0x2cbc <vTaskPriorityInherit+0x1e>
    2cba:	41 c0       	rjmp	.+130    	; 0x2d3e <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2cbc:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2cc0:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2cc4:	5a 96       	adiw	r26, 0x1a	; 26
    2cc6:	3c 91       	ld	r19, X
    2cc8:	84 e0       	ldi	r24, 0x04	; 4
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	a0 e0       	ldi	r26, 0x00	; 0
    2cce:	b0 e0       	ldi	r27, 0x00	; 0
    2cd0:	83 1b       	sub	r24, r19
    2cd2:	91 09       	sbc	r25, r1
    2cd4:	a1 09       	sbc	r26, r1
    2cd6:	b1 09       	sbc	r27, r1
    2cd8:	86 87       	std	Z+14, r24	; 0x0e
    2cda:	97 87       	std	Z+15, r25	; 0x0f
    2cdc:	a0 8b       	std	Z+16, r26	; 0x10
    2cde:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2ce0:	8b e0       	ldi	r24, 0x0B	; 11
    2ce2:	28 9f       	mul	r18, r24
    2ce4:	90 01       	movw	r18, r0
    2ce6:	11 24       	eor	r1, r1
    2ce8:	2c 55       	subi	r18, 0x5C	; 92
    2cea:	3e 4c       	sbci	r19, 0xCE	; 206
    2cec:	84 85       	ldd	r24, Z+12	; 0x0c
    2cee:	95 85       	ldd	r25, Z+13	; 0x0d
    2cf0:	82 17       	cp	r24, r18
    2cf2:	93 07       	cpc	r25, r19
    2cf4:	e9 f4       	brne	.+58     	; 0x2d30 <vTaskPriorityInherit+0x92>
    2cf6:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2cf8:	ef 01       	movw	r28, r30
    2cfa:	22 96       	adiw	r28, 0x02	; 2
    2cfc:	ce 01       	movw	r24, r28
    2cfe:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d02:	e0 91 d0 31 	lds	r30, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2d06:	f0 91 d1 31 	lds	r31, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2d0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d0c:	f8 01       	movw	r30, r16
    2d0e:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2d10:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2d14:	98 17       	cp	r25, r24
    2d16:	10 f4       	brcc	.+4      	; 0x2d1c <vTaskPriorityInherit+0x7e>
    2d18:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2d1c:	fb e0       	ldi	r31, 0x0B	; 11
    2d1e:	8f 9f       	mul	r24, r31
    2d20:	c0 01       	movw	r24, r0
    2d22:	11 24       	eor	r1, r1
    2d24:	be 01       	movw	r22, r28
    2d26:	8c 55       	subi	r24, 0x5C	; 92
    2d28:	9e 4c       	sbci	r25, 0xCE	; 206
    2d2a:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
    2d2e:	07 c0       	rjmp	.+14     	; 0x2d3e <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2d30:	a0 91 d0 31 	lds	r26, 0x31D0	; 0x8031d0 <pxCurrentTCB>
    2d34:	b0 91 d1 31 	lds	r27, 0x31D1	; 0x8031d1 <pxCurrentTCB+0x1>
    2d38:	5a 96       	adiw	r26, 0x1a	; 26
    2d3a:	8c 91       	ld	r24, X
    2d3c:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2d3e:	df 91       	pop	r29
    2d40:	cf 91       	pop	r28
    2d42:	1f 91       	pop	r17
    2d44:	0f 91       	pop	r16
    2d46:	08 95       	ret

00002d48 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2d48:	0f 93       	push	r16
    2d4a:	1f 93       	push	r17
    2d4c:	cf 93       	push	r28
    2d4e:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2d50:	00 97       	sbiw	r24, 0x00	; 0
    2d52:	49 f1       	breq	.+82     	; 0x2da6 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2d54:	fc 01       	movw	r30, r24
    2d56:	32 8d       	ldd	r19, Z+26	; 0x1a
    2d58:	27 a1       	ldd	r18, Z+39	; 0x27
    2d5a:	32 17       	cp	r19, r18
    2d5c:	21 f1       	breq	.+72     	; 0x2da6 <vTaskPriorityDisinherit+0x5e>
    2d5e:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2d60:	8c 01       	movw	r16, r24
    2d62:	0e 5f       	subi	r16, 0xFE	; 254
    2d64:	1f 4f       	sbci	r17, 0xFF	; 255
    2d66:	c8 01       	movw	r24, r16
    2d68:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2d6c:	8f a1       	ldd	r24, Y+39	; 0x27
    2d6e:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2d70:	44 e0       	ldi	r20, 0x04	; 4
    2d72:	50 e0       	ldi	r21, 0x00	; 0
    2d74:	60 e0       	ldi	r22, 0x00	; 0
    2d76:	70 e0       	ldi	r23, 0x00	; 0
    2d78:	48 1b       	sub	r20, r24
    2d7a:	51 09       	sbc	r21, r1
    2d7c:	61 09       	sbc	r22, r1
    2d7e:	71 09       	sbc	r23, r1
    2d80:	4e 87       	std	Y+14, r20	; 0x0e
    2d82:	5f 87       	std	Y+15, r21	; 0x0f
    2d84:	68 8b       	std	Y+16, r22	; 0x10
    2d86:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2d88:	90 91 76 31 	lds	r25, 0x3176	; 0x803176 <uxTopReadyPriority>
    2d8c:	98 17       	cp	r25, r24
    2d8e:	10 f4       	brcc	.+4      	; 0x2d94 <vTaskPriorityDisinherit+0x4c>
    2d90:	80 93 76 31 	sts	0x3176, r24	; 0x803176 <uxTopReadyPriority>
    2d94:	fb e0       	ldi	r31, 0x0B	; 11
    2d96:	8f 9f       	mul	r24, r31
    2d98:	c0 01       	movw	r24, r0
    2d9a:	11 24       	eor	r1, r1
    2d9c:	b8 01       	movw	r22, r16
    2d9e:	8c 55       	subi	r24, 0x5C	; 92
    2da0:	9e 4c       	sbci	r25, 0xCE	; 206
    2da2:	0e 94 8e 0c 	call	0x191c	; 0x191c <vListInsertEnd>
			}
		}
	}
    2da6:	df 91       	pop	r29
    2da8:	cf 91       	pop	r28
    2daa:	1f 91       	pop	r17
    2dac:	0f 91       	pop	r16
    2dae:	08 95       	ret

00002db0 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    2db0:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2db2:	e8 81       	ld	r30, Y
    2db4:	f9 81       	ldd	r31, Y+1	; 0x01
    2db6:	01 90       	ld	r0, Z+
    2db8:	f0 81       	ld	r31, Z
    2dba:	e0 2d       	mov	r30, r0
    2dbc:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2dbe:	1a 82       	std	Y+2, r1	; 0x02
    2dc0:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2dc2:	6f ef       	ldi	r22, 0xFF	; 255
    2dc4:	7f ef       	ldi	r23, 0xFF	; 255
    2dc6:	cb 01       	movw	r24, r22
    2dc8:	0e 94 bb 14 	call	0x2976	; 0x2976 <vTaskDelay>
    2dcc:	fa cf       	rjmp	.-12     	; 0x2dc2 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002dce <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2dce:	fc 01       	movw	r30, r24
    2dd0:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2dd2:	65 87       	std	Z+13, r22	; 0x0d
    2dd4:	08 95       	ret

00002dd6 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2dd6:	4f 92       	push	r4
    2dd8:	5f 92       	push	r5
    2dda:	6f 92       	push	r6
    2ddc:	7f 92       	push	r7
    2dde:	8f 92       	push	r8
    2de0:	9f 92       	push	r9
    2de2:	af 92       	push	r10
    2de4:	bf 92       	push	r11
    2de6:	cf 92       	push	r12
    2de8:	df 92       	push	r13
    2dea:	ef 92       	push	r14
    2dec:	ff 92       	push	r15
    2dee:	0f 93       	push	r16
    2df0:	1f 93       	push	r17
    2df2:	cf 93       	push	r28
    2df4:	df 93       	push	r29
    2df6:	cd b7       	in	r28, 0x3d	; 61
    2df8:	de b7       	in	r29, 0x3e	; 62
    2dfa:	2a 97       	sbiw	r28, 0x0a	; 10
    2dfc:	cd bf       	out	0x3d, r28	; 61
    2dfe:	de bf       	out	0x3e, r29	; 62
    2e00:	4c 01       	movw	r8, r24
    2e02:	29 01       	movw	r4, r18
    2e04:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2e06:	8f eb       	ldi	r24, 0xBF	; 191
    2e08:	90 e2       	ldi	r25, 0x20	; 32
    2e0a:	f4 01       	movw	r30, r8
    2e0c:	80 83       	st	Z, r24
    2e0e:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e10:	fb 01       	movw	r30, r22
    2e12:	80 81       	ld	r24, Z
    2e14:	88 23       	and	r24, r24
    2e16:	69 f0       	breq	.+26     	; 0x2e32 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2e18:	de 01       	movw	r26, r28
    2e1a:	11 96       	adiw	r26, 0x01	; 1
    2e1c:	31 96       	adiw	r30, 0x01	; 1
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	02 c0       	rjmp	.+4      	; 0x2e26 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2e22:	99 30       	cpi	r25, 0x09	; 9
    2e24:	39 f0       	breq	.+14     	; 0x2e34 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2e26:	9f 5f       	subi	r25, 0xFF	; 255
    2e28:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2e2a:	81 91       	ld	r24, Z+
    2e2c:	81 11       	cpse	r24, r1
    2e2e:	f9 cf       	rjmp	.-14     	; 0x2e22 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2e30:	01 c0       	rjmp	.+2      	; 0x2e34 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2e32:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2e34:	e1 e0       	ldi	r30, 0x01	; 1
    2e36:	f0 e0       	ldi	r31, 0x00	; 0
    2e38:	ec 0f       	add	r30, r28
    2e3a:	fd 1f       	adc	r31, r29
    2e3c:	e9 0f       	add	r30, r25
    2e3e:	f1 1d       	adc	r31, r1
    2e40:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2e42:	74 01       	movw	r14, r8
    2e44:	f2 e0       	ldi	r31, 0x02	; 2
    2e46:	ef 0e       	add	r14, r31
    2e48:	f1 1c       	adc	r15, r1
    2e4a:	a1 2c       	mov	r10, r1
    2e4c:	b1 2c       	mov	r11, r1
    2e4e:	c1 2c       	mov	r12, r1
    2e50:	d1 2c       	mov	r13, r1
    2e52:	04 2f       	mov	r16, r20
    2e54:	94 01       	movw	r18, r8
    2e56:	a2 01       	movw	r20, r4
    2e58:	be 01       	movw	r22, r28
    2e5a:	6f 5f       	subi	r22, 0xFF	; 255
    2e5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e5e:	80 e2       	ldi	r24, 0x20	; 32
    2e60:	93 e0       	ldi	r25, 0x03	; 3
    2e62:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2e66:	f4 01       	movw	r30, r8
    2e68:	66 82       	std	Z+6, r6	; 0x06
    2e6a:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2e6c:	40 86       	std	Z+8, r4	; 0x08
    2e6e:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2e70:	20 91 d2 31 	lds	r18, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    2e74:	30 91 d3 31 	lds	r19, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    2e78:	24 83       	std	Z+4, r18	; 0x04
    2e7a:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2e7c:	80 92 d2 31 	sts	0x31D2, r8	; 0x8031d2 <last_created_task_pointer>
    2e80:	90 92 d3 31 	sts	0x31D3, r9	; 0x8031d3 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2e84:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2e86:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2e88:	40 90 34 32 	lds	r4, 0x3234	; 0x803234 <portStackTopForTask>
    2e8c:	50 90 35 32 	lds	r5, 0x3235	; 0x803235 <portStackTopForTask+0x1>
    2e90:	ff ef       	ldi	r31, 0xFF	; 255
    2e92:	4f 1a       	sub	r4, r31
    2e94:	5f 0a       	sbc	r5, r31
    2e96:	40 92 34 32 	sts	0x3234, r4	; 0x803234 <portStackTopForTask>
    2e9a:	50 92 35 32 	sts	0x3235, r5	; 0x803235 <portStackTopForTask+0x1>
    2e9e:	f4 01       	movw	r30, r8
    2ea0:	42 86       	std	Z+10, r4	; 0x0a
    2ea2:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2ea4:	16 86       	std	Z+14, r1	; 0x0e
    2ea6:	17 86       	std	Z+15, r1	; 0x0f
    2ea8:	10 8a       	std	Z+16, r1	; 0x10
    2eaa:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2eac:	61 14       	cp	r6, r1
    2eae:	71 04       	cpc	r7, r1
    2eb0:	09 f4       	brne	.+2      	; 0x2eb4 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2eb2:	44 c0       	rjmp	.+136    	; 0x2f3c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2eb4:	81 30       	cpi	r24, 0x01	; 1
    2eb6:	79 f5       	brne	.+94     	; 0x2f16 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2eb8:	6a e0       	ldi	r22, 0x0A	; 10
    2eba:	c3 01       	movw	r24, r6
    2ebc:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2ec0:	7c 01       	movw	r14, r24
    2ec2:	6d e8       	ldi	r22, 0x8D	; 141
    2ec4:	75 e0       	ldi	r23, 0x05	; 5
    2ec6:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2eca:	be 01       	movw	r22, r28
    2ecc:	6f 5f       	subi	r22, 0xFF	; 255
    2ece:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed0:	c7 01       	movw	r24, r14
    2ed2:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2ed6:	6a e0       	ldi	r22, 0x0A	; 10
    2ed8:	c7 01       	movw	r24, r14
    2eda:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2ede:	7c 01       	movw	r14, r24
    2ee0:	64 e8       	ldi	r22, 0x84	; 132
    2ee2:	75 e0       	ldi	r23, 0x05	; 5
    2ee4:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2ee8:	6a e0       	ldi	r22, 0x0A	; 10
    2eea:	c7 01       	movw	r24, r14
    2eec:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2ef0:	7c 01       	movw	r14, r24
    2ef2:	66 e7       	ldi	r22, 0x76	; 118
    2ef4:	75 e0       	ldi	r23, 0x05	; 5
    2ef6:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2efa:	63 e0       	ldi	r22, 0x03	; 3
    2efc:	c7 01       	movw	r24, r14
    2efe:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f02:	b2 01       	movw	r22, r4
    2f04:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    2f08:	62 e0       	ldi	r22, 0x02	; 2
    2f0a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f0e:	66 e0       	ldi	r22, 0x06	; 6
    2f10:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f14:	13 c0       	rjmp	.+38     	; 0x2f3c <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2f16:	6a e0       	ldi	r22, 0x0A	; 10
    2f18:	c3 01       	movw	r24, r6
    2f1a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f1e:	4c 01       	movw	r8, r24
    2f20:	61 e6       	ldi	r22, 0x61	; 97
    2f22:	75 e0       	ldi	r23, 0x05	; 5
    2f24:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2f28:	be 01       	movw	r22, r28
    2f2a:	6f 5f       	subi	r22, 0xFF	; 255
    2f2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2e:	c4 01       	movw	r24, r8
    2f30:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2f34:	66 e0       	ldi	r22, 0x06	; 6
    2f36:	c4 01       	movw	r24, r8
    2f38:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2f3c:	2a 96       	adiw	r28, 0x0a	; 10
    2f3e:	cd bf       	out	0x3d, r28	; 61
    2f40:	de bf       	out	0x3e, r29	; 62
    2f42:	df 91       	pop	r29
    2f44:	cf 91       	pop	r28
    2f46:	1f 91       	pop	r17
    2f48:	0f 91       	pop	r16
    2f4a:	ff 90       	pop	r15
    2f4c:	ef 90       	pop	r14
    2f4e:	df 90       	pop	r13
    2f50:	cf 90       	pop	r12
    2f52:	bf 90       	pop	r11
    2f54:	af 90       	pop	r10
    2f56:	9f 90       	pop	r9
    2f58:	8f 90       	pop	r8
    2f5a:	7f 90       	pop	r7
    2f5c:	6f 90       	pop	r6
    2f5e:	5f 90       	pop	r5
    2f60:	4f 90       	pop	r4
    2f62:	08 95       	ret

00002f64 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2f64:	cf 92       	push	r12
    2f66:	df 92       	push	r13
    2f68:	ef 92       	push	r14
    2f6a:	ff 92       	push	r15
    2f6c:	0f 93       	push	r16
    2f6e:	1f 93       	push	r17
    2f70:	cf 93       	push	r28
    2f72:	df 93       	push	r29
    2f74:	ec 01       	movw	r28, r24
    2f76:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2f78:	8a 81       	ldd	r24, Y+2	; 0x02
    2f7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7c:	0e 94 2b 13 	call	0x2656	; 0x2656 <pcTaskGetTaskName>
    2f80:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2f82:	6a e0       	ldi	r22, 0x0A	; 10
    2f84:	c7 01       	movw	r24, r14
    2f86:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f8a:	8c 01       	movw	r16, r24
    2f8c:	60 ea       	ldi	r22, 0xA0	; 160
    2f8e:	75 e0       	ldi	r23, 0x05	; 5
    2f90:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2f94:	6a e0       	ldi	r22, 0x0A	; 10
    2f96:	c8 01       	movw	r24, r16
    2f98:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2f9c:	8c 01       	movw	r16, r24
    2f9e:	69 e9       	ldi	r22, 0x99	; 153
    2fa0:	75 e0       	ldi	r23, 0x05	; 5
    2fa2:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2fa6:	b6 01       	movw	r22, r12
    2fa8:	c8 01       	movw	r24, r16
    2faa:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2fae:	6a e0       	ldi	r22, 0x0A	; 10
    2fb0:	c8 01       	movw	r24, r16
    2fb2:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    2fb6:	8c 01       	movw	r16, r24
    2fb8:	63 e9       	ldi	r22, 0x93	; 147
    2fba:	75 e0       	ldi	r23, 0x05	; 5
    2fbc:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    2fc0:	66 e0       	ldi	r22, 0x06	; 6
    2fc2:	c8 01       	movw	r24, r16
    2fc4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2fc8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fca:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fcc:	e8 85       	ldd	r30, Y+8	; 0x08
    2fce:	f9 85       	ldd	r31, Y+9	; 0x09
    2fd0:	01 e1       	ldi	r16, 0x11	; 17
    2fd2:	21 e0       	ldi	r18, 0x01	; 1
    2fd4:	a7 01       	movw	r20, r14
    2fd6:	bc 01       	movw	r22, r24
    2fd8:	8e 1b       	sub	r24, r30
    2fda:	9f 0b       	sbc	r25, r31
    2fdc:	0e 94 b4 1a 	call	0x3568	; 0x3568 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2fe0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fe2:	9d 81       	ldd	r25, Y+5	; 0x05
    2fe4:	00 97       	sbiw	r24, 0x00	; 0
    2fe6:	19 f0       	breq	.+6      	; 0x2fee <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2fe8:	b7 01       	movw	r22, r14
    2fea:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2fee:	df 91       	pop	r29
    2ff0:	cf 91       	pop	r28
    2ff2:	1f 91       	pop	r17
    2ff4:	0f 91       	pop	r16
    2ff6:	ff 90       	pop	r15
    2ff8:	ef 90       	pop	r14
    2ffa:	df 90       	pop	r13
    2ffc:	cf 90       	pop	r12
    2ffe:	08 95       	ret

00003000 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    3000:	0f 93       	push	r16
    3002:	1f 93       	push	r17
    3004:	cf 93       	push	r28
    3006:	df 93       	push	r29
    3008:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    300a:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    300e:	90 91 d3 31 	lds	r25, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    3012:	00 97       	sbiw	r24, 0x00	; 0
    3014:	19 f0       	breq	.+6      	; 0x301c <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    3016:	be 01       	movw	r22, r28
    3018:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    301c:	6a e0       	ldi	r22, 0x0A	; 10
    301e:	ce 01       	movw	r24, r28
    3020:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3024:	8c 01       	movw	r16, r24
    3026:	66 eb       	ldi	r22, 0xB6	; 182
    3028:	75 e0       	ldi	r23, 0x05	; 5
    302a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    302e:	6a e0       	ldi	r22, 0x0A	; 10
    3030:	c8 01       	movw	r24, r16
    3032:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3036:	8c 01       	movw	r16, r24
    3038:	6b ea       	ldi	r22, 0xAB	; 171
    303a:	75 e0       	ldi	r23, 0x05	; 5
    303c:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    3040:	6a e0       	ldi	r22, 0x0A	; 10
    3042:	c8 01       	movw	r24, r16
    3044:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3048:	8c 01       	movw	r16, r24
    304a:	65 ea       	ldi	r22, 0xA5	; 165
    304c:	75 e0       	ldi	r23, 0x05	; 5
    304e:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    3052:	66 e0       	ldi	r22, 0x06	; 6
    3054:	c8 01       	movw	r24, r16
    3056:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    305a:	80 91 34 32 	lds	r24, 0x3234	; 0x803234 <portStackTopForTask>
    305e:	90 91 35 32 	lds	r25, 0x3235	; 0x803235 <portStackTopForTask+0x1>
    3062:	bc 01       	movw	r22, r24
    3064:	6f 5f       	subi	r22, 0xFF	; 255
    3066:	7f 4f       	sbci	r23, 0xFF	; 255
    3068:	01 e1       	ldi	r16, 0x11	; 17
    306a:	21 e0       	ldi	r18, 0x01	; 1
    306c:	ae 01       	movw	r20, r28
    306e:	83 56       	subi	r24, 0x63	; 99
    3070:	91 09       	sbc	r25, r1
    3072:	0e 94 b4 1a 	call	0x3568	; 0x3568 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    3076:	df 91       	pop	r29
    3078:	cf 91       	pop	r28
    307a:	1f 91       	pop	r17
    307c:	0f 91       	pop	r16
    307e:	08 95       	ret

00003080 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    3080:	8f 92       	push	r8
    3082:	9f 92       	push	r9
    3084:	af 92       	push	r10
    3086:	bf 92       	push	r11
    3088:	cf 92       	push	r12
    308a:	df 92       	push	r13
    308c:	ef 92       	push	r14
    308e:	ff 92       	push	r15
    3090:	0f 93       	push	r16
    3092:	1f 93       	push	r17
    3094:	cf 93       	push	r28
    3096:	df 93       	push	r29
    3098:	ec 01       	movw	r28, r24
    309a:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    309c:	8a 81       	ldd	r24, Y+2	; 0x02
    309e:	9b 81       	ldd	r25, Y+3	; 0x03
    30a0:	0e 94 2b 13 	call	0x2656	; 0x2656 <pcTaskGetTaskName>
    30a4:	bc 01       	movw	r22, r24
    30a6:	c8 01       	movw	r24, r16
    30a8:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    30ac:	d8 01       	movw	r26, r16
    30ae:	ed 91       	ld	r30, X+
    30b0:	fc 91       	ld	r31, X
    30b2:	02 80       	ldd	r0, Z+2	; 0x02
    30b4:	f3 81       	ldd	r31, Z+3	; 0x03
    30b6:	e0 2d       	mov	r30, r0
    30b8:	69 e0       	ldi	r22, 0x09	; 9
    30ba:	c8 01       	movw	r24, r16
    30bc:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    30be:	8a 81       	ldd	r24, Y+2	; 0x02
    30c0:	9b 81       	ldd	r25, Y+3	; 0x03
    30c2:	0e 94 2b 13 	call	0x2656	; 0x2656 <pcTaskGetTaskName>
    30c6:	fc 01       	movw	r30, r24
    30c8:	01 90       	ld	r0, Z+
    30ca:	00 20       	and	r0, r0
    30cc:	e9 f7       	brne	.-6      	; 0x30c8 <_ZN8frt_task12print_statusER8emstream+0x48>
    30ce:	31 97       	sbiw	r30, 0x01	; 1
    30d0:	e8 1b       	sub	r30, r24
    30d2:	f9 0b       	sbc	r31, r25
    30d4:	38 97       	sbiw	r30, 0x08	; 8
    30d6:	48 f4       	brcc	.+18     	; 0x30ea <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    30d8:	d8 01       	movw	r26, r16
    30da:	ed 91       	ld	r30, X+
    30dc:	fc 91       	ld	r31, X
    30de:	02 80       	ldd	r0, Z+2	; 0x02
    30e0:	f3 81       	ldd	r31, Z+3	; 0x03
    30e2:	e0 2d       	mov	r30, r0
    30e4:	69 e0       	ldi	r22, 0x09	; 9
    30e6:	c8 01       	movw	r24, r16
    30e8:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    30ea:	ce 84       	ldd	r12, Y+14	; 0x0e
    30ec:	df 84       	ldd	r13, Y+15	; 0x0f
    30ee:	e8 88       	ldd	r14, Y+16	; 0x10
    30f0:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    30f2:	a8 84       	ldd	r10, Y+8	; 0x08
    30f4:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    30f6:	8a 81       	ldd	r24, Y+2	; 0x02
    30f8:	9b 81       	ldd	r25, Y+3	; 0x03
    30fa:	0e 94 31 16 	call	0x2c62	; 0x2c62 <uxTaskGetStackHighWaterMark>
    30fe:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    3100:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    3102:	8a 81       	ldd	r24, Y+2	; 0x02
    3104:	9b 81       	ldd	r25, Y+3	; 0x03
    3106:	0e 94 d6 12 	call	0x25ac	; 0x25ac <uxTaskPriorityGet>
    310a:	68 2f       	mov	r22, r24
    310c:	c8 01       	movw	r24, r16
    310e:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    3112:	6a e0       	ldi	r22, 0x0A	; 10
    3114:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3118:	ec 01       	movw	r28, r24
    311a:	6b e2       	ldi	r22, 0x2B	; 43
    311c:	76 e0       	ldi	r23, 0x06	; 6
    311e:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
			<< get_state ()
    3122:	68 2d       	mov	r22, r8
    3124:	ce 01       	movw	r24, r28
    3126:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    312a:	6a e0       	ldi	r22, 0x0A	; 10
    312c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3130:	ec 01       	movw	r28, r24
    3132:	69 e2       	ldi	r22, 0x29	; 41
    3134:	76 e0       	ldi	r23, 0x06	; 6
    3136:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    313a:	69 2d       	mov	r22, r9
    313c:	ce 01       	movw	r24, r28
    313e:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    3142:	6a e0       	ldi	r22, 0x0A	; 10
    3144:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3148:	ec 01       	movw	r28, r24
    314a:	67 e2       	ldi	r22, 0x27	; 39
    314c:	76 e0       	ldi	r23, 0x06	; 6
    314e:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    3152:	b5 01       	movw	r22, r10
    3154:	ce 01       	movw	r24, r28
    3156:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    315a:	6a e0       	ldi	r22, 0x0A	; 10
    315c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3160:	ec 01       	movw	r28, r24
    3162:	65 e2       	ldi	r22, 0x25	; 37
    3164:	76 e0       	ldi	r23, 0x06	; 6
    3166:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    316a:	6a e0       	ldi	r22, 0x0A	; 10
    316c:	ce 01       	movw	r24, r28
    316e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3172:	ec 01       	movw	r28, r24
    3174:	63 e2       	ldi	r22, 0x23	; 35
    3176:	76 e0       	ldi	r23, 0x06	; 6
    3178:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    317c:	b7 01       	movw	r22, r14
    317e:	a6 01       	movw	r20, r12
    3180:	ce 01       	movw	r24, r28
    3182:	0e 94 cb 1c 	call	0x3996	; 0x3996 <_ZN8emstreamlsEm>
}
    3186:	df 91       	pop	r29
    3188:	cf 91       	pop	r28
    318a:	1f 91       	pop	r17
    318c:	0f 91       	pop	r16
    318e:	ff 90       	pop	r15
    3190:	ef 90       	pop	r14
    3192:	df 90       	pop	r13
    3194:	cf 90       	pop	r12
    3196:	bf 90       	pop	r11
    3198:	af 90       	pop	r10
    319a:	9f 90       	pop	r9
    319c:	8f 90       	pop	r8
    319e:	08 95       	ret

000031a0 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    31a0:	cf 93       	push	r28
    31a2:	df 93       	push	r29
    31a4:	ec 01       	movw	r28, r24
    31a6:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    31a8:	db 01       	movw	r26, r22
    31aa:	ed 91       	ld	r30, X+
    31ac:	fc 91       	ld	r31, X
    31ae:	02 80       	ldd	r0, Z+2	; 0x02
    31b0:	f3 81       	ldd	r31, Z+3	; 0x03
    31b2:	e0 2d       	mov	r30, r0
    31b4:	be 01       	movw	r22, r28
    31b6:	19 95       	eicall
	return (ser_dev);
}
    31b8:	ce 01       	movw	r24, r28
    31ba:	df 91       	pop	r29
    31bc:	cf 91       	pop	r28
    31be:	08 95       	ret

000031c0 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    31c0:	0f 93       	push	r16
    31c2:	1f 93       	push	r17
    31c4:	cf 93       	push	r28
    31c6:	df 93       	push	r29
    31c8:	ec 01       	movw	r28, r24
    31ca:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    31cc:	bc 01       	movw	r22, r24
    31ce:	c8 01       	movw	r24, r16
    31d0:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <_ZlsR8emstreamR8frt_task>
    31d4:	66 e0       	ldi	r22, 0x06	; 6
    31d6:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    31da:	8c 81       	ldd	r24, Y+4	; 0x04
    31dc:	9d 81       	ldd	r25, Y+5	; 0x05
    31de:	00 97       	sbiw	r24, 0x00	; 0
    31e0:	19 f0       	breq	.+6      	; 0x31e8 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    31e2:	b8 01       	movw	r22, r16
    31e4:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	1f 91       	pop	r17
    31ee:	0f 91       	pop	r16
    31f0:	08 95       	ret

000031f2 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    31f2:	0f 93       	push	r16
    31f4:	1f 93       	push	r17
    31f6:	cf 93       	push	r28
    31f8:	df 93       	push	r29
    31fa:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    31fc:	6a e0       	ldi	r22, 0x0A	; 10
    31fe:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3202:	8c 01       	movw	r16, r24
    3204:	68 e1       	ldi	r22, 0x18	; 24
    3206:	76 e0       	ldi	r23, 0x06	; 6
    3208:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    320c:	6a e0       	ldi	r22, 0x0A	; 10
    320e:	c8 01       	movw	r24, r16
    3210:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3214:	8c 01       	movw	r16, r24
    3216:	61 e1       	ldi	r22, 0x11	; 17
    3218:	76 e0       	ldi	r23, 0x06	; 6
    321a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    321e:	66 e0       	ldi	r22, 0x06	; 6
    3220:	c8 01       	movw	r24, r16
    3222:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    3226:	6a e0       	ldi	r22, 0x0A	; 10
    3228:	ce 01       	movw	r24, r28
    322a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    322e:	8c 01       	movw	r16, r24
    3230:	60 e0       	ldi	r22, 0x00	; 0
    3232:	76 e0       	ldi	r23, 0x06	; 6
    3234:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    3238:	6a e0       	ldi	r22, 0x0A	; 10
    323a:	c8 01       	movw	r24, r16
    323c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3240:	8c 01       	movw	r16, r24
    3242:	64 ef       	ldi	r22, 0xF4	; 244
    3244:	75 e0       	ldi	r23, 0x05	; 5
    3246:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    324a:	6a e0       	ldi	r22, 0x0A	; 10
    324c:	c8 01       	movw	r24, r16
    324e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3252:	8c 01       	movw	r16, r24
    3254:	6e ee       	ldi	r22, 0xEE	; 238
    3256:	75 e0       	ldi	r23, 0x05	; 5
    3258:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    325c:	66 e0       	ldi	r22, 0x06	; 6
    325e:	c8 01       	movw	r24, r16
    3260:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    3264:	6a e0       	ldi	r22, 0x0A	; 10
    3266:	ce 01       	movw	r24, r28
    3268:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    326c:	8c 01       	movw	r16, r24
    326e:	6d ed       	ldi	r22, 0xDD	; 221
    3270:	75 e0       	ldi	r23, 0x05	; 5
    3272:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    3276:	6a e0       	ldi	r22, 0x0A	; 10
    3278:	c8 01       	movw	r24, r16
    327a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    327e:	8c 01       	movw	r16, r24
    3280:	61 ed       	ldi	r22, 0xD1	; 209
    3282:	75 e0       	ldi	r23, 0x05	; 5
    3284:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    3288:	6a e0       	ldi	r22, 0x0A	; 10
    328a:	c8 01       	movw	r24, r16
    328c:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    3290:	8c 01       	movw	r16, r24
    3292:	6b ec       	ldi	r22, 0xCB	; 203
    3294:	75 e0       	ldi	r23, 0x05	; 5
    3296:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    329a:	66 e0       	ldi	r22, 0x06	; 6
    329c:	c8 01       	movw	r24, r16
    329e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    32a2:	80 91 d2 31 	lds	r24, 0x31D2	; 0x8031d2 <last_created_task_pointer>
    32a6:	90 91 d3 31 	lds	r25, 0x31D3	; 0x8031d3 <last_created_task_pointer+0x1>
    32aa:	00 97       	sbiw	r24, 0x00	; 0
    32ac:	19 f0       	breq	.+6      	; 0x32b4 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    32ae:	be 01       	movw	r22, r28
    32b0:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32b4:	0e 94 33 13 	call	0x2666	; 0x2666 <xTaskGetIdleTaskHandle>
    32b8:	0e 94 31 16 	call	0x2c62	; 0x2c62 <uxTaskGetStackHighWaterMark>
    32bc:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    32be:	6a e0       	ldi	r22, 0x0A	; 10
    32c0:	ce 01       	movw	r24, r28
    32c2:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    32c6:	ec 01       	movw	r28, r24
    32c8:	60 ec       	ldi	r22, 0xC0	; 192
    32ca:	75 e0       	ldi	r23, 0x05	; 5
    32cc:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    32d0:	61 2f       	mov	r22, r17
    32d2:	ce 01       	movw	r24, r28
    32d4:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    32d8:	6a e0       	ldi	r22, 0x0A	; 10
    32da:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    32de:	ec 01       	movw	r28, r24
    32e0:	6e eb       	ldi	r22, 0xBE	; 190
    32e2:	75 e0       	ldi	r23, 0x05	; 5
    32e4:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    32e8:	64 e6       	ldi	r22, 0x64	; 100
    32ea:	70 e0       	ldi	r23, 0x00	; 0
    32ec:	ce 01       	movw	r24, r28
    32ee:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    32f2:	6a e0       	ldi	r22, 0x0A	; 10
    32f4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    32f8:	ec 01       	movw	r28, r24
    32fa:	6b eb       	ldi	r22, 0xBB	; 187
    32fc:	75 e0       	ldi	r23, 0x05	; 5
    32fe:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    3302:	66 e0       	ldi	r22, 0x06	; 6
    3304:	ce 01       	movw	r24, r28
    3306:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
}
    330a:	df 91       	pop	r29
    330c:	cf 91       	pop	r28
    330e:	1f 91       	pop	r17
    3310:	0f 91       	pop	r16
    3312:	08 95       	ret

00003314 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    3314:	0f 93       	push	r16
    3316:	cf 93       	push	r28
    3318:	df 93       	push	r29
    331a:	1f 92       	push	r1
    331c:	cd b7       	in	r28, 0x3d	; 61
    331e:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    3320:	00 e0       	ldi	r16, 0x00	; 0
    3322:	2f ef       	ldi	r18, 0xFF	; 255
    3324:	3f ef       	ldi	r19, 0xFF	; 255
    3326:	a9 01       	movw	r20, r18
    3328:	be 01       	movw	r22, r28
    332a:	6f 5f       	subi	r22, 0xFF	; 255
    332c:	7f 4f       	sbci	r23, 0xFF	; 255
    332e:	fc 01       	movw	r30, r24
    3330:	80 85       	ldd	r24, Z+8	; 0x08
    3332:	91 85       	ldd	r25, Z+9	; 0x09
    3334:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
    3338:	81 30       	cpi	r24, 0x01	; 1
    333a:	19 f4       	brne	.+6      	; 0x3342 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    333c:	89 81       	ldd	r24, Y+1	; 0x01
    333e:	90 e0       	ldi	r25, 0x00	; 0
    3340:	02 c0       	rjmp	.+4      	; 0x3346 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    3342:	8f ef       	ldi	r24, 0xFF	; 255
    3344:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    3346:	0f 90       	pop	r0
    3348:	df 91       	pop	r29
    334a:	cf 91       	pop	r28
    334c:	0f 91       	pop	r16
    334e:	08 95       	ret

00003350 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    3350:	fc 01       	movw	r30, r24
    3352:	80 85       	ldd	r24, Z+8	; 0x08
    3354:	91 85       	ldd	r25, Z+9	; 0x09
    3356:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
    335a:	91 e0       	ldi	r25, 0x01	; 1
    335c:	81 11       	cpse	r24, r1
    335e:	01 c0       	rjmp	.+2      	; 0x3362 <_ZN14frt_text_queue14check_for_charEv+0x12>
    3360:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    3362:	89 2f       	mov	r24, r25
    3364:	08 95       	ret

00003366 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    3366:	0f 93       	push	r16
    3368:	cf 93       	push	r28
    336a:	df 93       	push	r29
    336c:	1f 92       	push	r1
    336e:	cd b7       	in	r28, 0x3d	; 61
    3370:	de b7       	in	r29, 0x3e	; 62
    3372:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    3374:	fc 01       	movw	r30, r24
    3376:	22 85       	ldd	r18, Z+10	; 0x0a
    3378:	33 85       	ldd	r19, Z+11	; 0x0b
    337a:	44 85       	ldd	r20, Z+12	; 0x0c
    337c:	55 85       	ldd	r21, Z+13	; 0x0d
    337e:	00 e0       	ldi	r16, 0x00	; 0
    3380:	be 01       	movw	r22, r28
    3382:	6f 5f       	subi	r22, 0xFF	; 255
    3384:	7f 4f       	sbci	r23, 0xFF	; 255
    3386:	80 85       	ldd	r24, Z+8	; 0x08
    3388:	91 85       	ldd	r25, Z+9	; 0x09
    338a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
    338e:	91 e0       	ldi	r25, 0x01	; 1
    3390:	81 11       	cpse	r24, r1
    3392:	01 c0       	rjmp	.+2      	; 0x3396 <_ZN14frt_text_queue7putcharEc+0x30>
    3394:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    3396:	89 2f       	mov	r24, r25
    3398:	0f 90       	pop	r0
    339a:	df 91       	pop	r29
    339c:	cf 91       	pop	r28
    339e:	0f 91       	pop	r16
    33a0:	08 95       	ret

000033a2 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    33a2:	8f 92       	push	r8
    33a4:	9f 92       	push	r9
    33a6:	bf 92       	push	r11
    33a8:	cf 92       	push	r12
    33aa:	df 92       	push	r13
    33ac:	ef 92       	push	r14
    33ae:	ff 92       	push	r15
    33b0:	0f 93       	push	r16
    33b2:	1f 93       	push	r17
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	ec 01       	movw	r28, r24
    33ba:	b6 2e       	mov	r11, r22
    33bc:	4a 01       	movw	r8, r20
    33be:	68 01       	movw	r12, r16
    33c0:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    33c2:	0e 94 0b 1c 	call	0x3816	; 0x3816 <_ZN8emstreamC1Ev>
    33c6:	87 ec       	ldi	r24, 0xC7	; 199
    33c8:	90 e2       	ldi	r25, 0x20	; 32
    33ca:	88 83       	st	Y, r24
    33cc:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    33ce:	8e 86       	std	Y+14, r8	; 0x0e
    33d0:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    33d2:	40 e0       	ldi	r20, 0x00	; 0
    33d4:	61 e0       	ldi	r22, 0x01	; 1
    33d6:	8b 2d       	mov	r24, r11
    33d8:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    33dc:	88 87       	std	Y+8, r24	; 0x08
    33de:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    33e0:	ca 86       	std	Y+10, r12	; 0x0a
    33e2:	db 86       	std	Y+11, r13	; 0x0b
    33e4:	ec 86       	std	Y+12, r14	; 0x0c
    33e6:	fd 86       	std	Y+13, r15	; 0x0d
}
    33e8:	df 91       	pop	r29
    33ea:	cf 91       	pop	r28
    33ec:	1f 91       	pop	r17
    33ee:	0f 91       	pop	r16
    33f0:	ff 90       	pop	r15
    33f2:	ef 90       	pop	r14
    33f4:	df 90       	pop	r13
    33f6:	cf 90       	pop	r12
    33f8:	bf 90       	pop	r11
    33fa:	9f 90       	pop	r9
    33fc:	8f 90       	pop	r8
    33fe:	08 95       	ret

00003400 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    3400:	cf 92       	push	r12
    3402:	df 92       	push	r13
    3404:	ef 92       	push	r14
    3406:	ff 92       	push	r15
    3408:	cf 93       	push	r28
    340a:	df 93       	push	r29
    340c:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    340e:	68 81       	ld	r22, Y
    3410:	79 81       	ldd	r23, Y+1	; 0x01
    3412:	8a 81       	ldd	r24, Y+2	; 0x02
    3414:	9b 81       	ldd	r25, Y+3	; 0x03
    3416:	0f 2e       	mov	r0, r31
    3418:	f8 ee       	ldi	r31, 0xE8	; 232
    341a:	cf 2e       	mov	r12, r31
    341c:	f3 e0       	ldi	r31, 0x03	; 3
    341e:	df 2e       	mov	r13, r31
    3420:	e1 2c       	mov	r14, r1
    3422:	f1 2c       	mov	r15, r1
    3424:	f0 2d       	mov	r31, r0
    3426:	a7 01       	movw	r20, r14
    3428:	96 01       	movw	r18, r12
    342a:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
    342e:	9b 01       	movw	r18, r22
    3430:	ac 01       	movw	r20, r24
    3432:	60 e4       	ldi	r22, 0x40	; 64
    3434:	72 e4       	ldi	r23, 0x42	; 66
    3436:	8f e0       	ldi	r24, 0x0F	; 15
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	0e 94 65 23 	call	0x46ca	; 0x46ca <__mulsi3>
    343e:	a7 01       	movw	r20, r14
    3440:	96 01       	movw	r18, r12
    3442:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
    3446:	69 01       	movw	r12, r18
    3448:	7a 01       	movw	r14, r20
    344a:	ac 81       	ldd	r26, Y+4	; 0x04
    344c:	bd 81       	ldd	r27, Y+5	; 0x05
    344e:	20 e4       	ldi	r18, 0x40	; 64
    3450:	32 e4       	ldi	r19, 0x42	; 66
    3452:	4f e0       	ldi	r20, 0x0F	; 15
    3454:	50 e0       	ldi	r21, 0x00	; 0
    3456:	0e 94 bf 23 	call	0x477e	; 0x477e <__muluhisi3>
    345a:	20 e0       	ldi	r18, 0x00	; 0
    345c:	38 e4       	ldi	r19, 0x48	; 72
    345e:	48 ee       	ldi	r20, 0xE8	; 232
    3460:	51 e0       	ldi	r21, 0x01	; 1
    3462:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
    3466:	c7 01       	movw	r24, r14
    3468:	b6 01       	movw	r22, r12
    346a:	62 0f       	add	r22, r18
    346c:	73 1f       	adc	r23, r19
    346e:	84 1f       	adc	r24, r20
    3470:	95 1f       	adc	r25, r21
}
    3472:	df 91       	pop	r29
    3474:	cf 91       	pop	r28
    3476:	ff 90       	pop	r15
    3478:	ef 90       	pop	r14
    347a:	df 90       	pop	r13
    347c:	cf 90       	pop	r12
    347e:	08 95       	ret

00003480 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    3480:	cf 92       	push	r12
    3482:	df 92       	push	r13
    3484:	ef 92       	push	r14
    3486:	ff 92       	push	r15
    3488:	0f 93       	push	r16
    348a:	1f 93       	push	r17
    348c:	cf 93       	push	r28
    348e:	df 93       	push	r29
    3490:	cd b7       	in	r28, 0x3d	; 61
    3492:	de b7       	in	r29, 0x3e	; 62
    3494:	2f 97       	sbiw	r28, 0x0f	; 15
    3496:	cd bf       	out	0x3d, r28	; 61
    3498:	de bf       	out	0x3e, r29	; 62
    349a:	6c 01       	movw	r12, r24
    349c:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    349e:	db 01       	movw	r26, r22
    34a0:	6d 91       	ld	r22, X+
    34a2:	7d 91       	ld	r23, X+
    34a4:	8d 91       	ld	r24, X+
    34a6:	9c 91       	ld	r25, X
    34a8:	28 ee       	ldi	r18, 0xE8	; 232
    34aa:	33 e0       	ldi	r19, 0x03	; 3
    34ac:	40 e0       	ldi	r20, 0x00	; 0
    34ae:	50 e0       	ldi	r21, 0x00	; 0
    34b0:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
    34b4:	ba 01       	movw	r22, r20
    34b6:	a9 01       	movw	r20, r18
    34b8:	c6 01       	movw	r24, r12
    34ba:	0e 94 cb 1c 	call	0x3996	; 0x3996 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    34be:	d6 01       	movw	r26, r12
    34c0:	ed 91       	ld	r30, X+
    34c2:	fc 91       	ld	r31, X
    34c4:	02 80       	ldd	r0, Z+2	; 0x02
    34c6:	f3 81       	ldd	r31, Z+3	; 0x03
    34c8:	e0 2d       	mov	r30, r0
    34ca:	6e e2       	ldi	r22, 0x2E	; 46
    34cc:	c6 01       	movw	r24, r12
    34ce:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    34d0:	c8 01       	movw	r24, r16
    34d2:	0e 94 00 1a 	call	0x3400	; 0x3400 <_ZN10time_stamp12get_microsecEv>
    34d6:	8e 01       	movw	r16, r28
    34d8:	09 5f       	subi	r16, 0xF9	; 249
    34da:	1f 4f       	sbci	r17, 0xFF	; 255
    34dc:	fe 01       	movw	r30, r28
    34de:	31 96       	adiw	r30, 0x01	; 1
    34e0:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    34e2:	2a e0       	ldi	r18, 0x0A	; 10
    34e4:	30 e0       	ldi	r19, 0x00	; 0
    34e6:	40 e0       	ldi	r20, 0x00	; 0
    34e8:	50 e0       	ldi	r21, 0x00	; 0
    34ea:	0e 94 97 23 	call	0x472e	; 0x472e <__divmodsi4>
    34ee:	e6 2f       	mov	r30, r22
    34f0:	28 87       	std	Y+8, r18	; 0x08
    34f2:	39 87       	std	Y+9, r19	; 0x09
    34f4:	4a 87       	std	Y+10, r20	; 0x0a
    34f6:	5b 87       	std	Y+11, r21	; 0x0b
    34f8:	68 85       	ldd	r22, Y+8	; 0x08
    34fa:	79 85       	ldd	r23, Y+9	; 0x09
    34fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    34fe:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    3500:	20 e3       	ldi	r18, 0x30	; 48
    3502:	2e 0f       	add	r18, r30
    3504:	d8 01       	movw	r26, r16
    3506:	2e 93       	st	-X, r18
    3508:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    350a:	ae 15       	cp	r26, r14
    350c:	bf 05       	cpc	r27, r15
    350e:	49 f7       	brne	.-46     	; 0x34e2 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    3510:	1f 82       	std	Y+7, r1	; 0x07
    3512:	be 01       	movw	r22, r28
    3514:	6f 5f       	subi	r22, 0xFF	; 255
    3516:	7f 4f       	sbci	r23, 0xFF	; 255
    3518:	c6 01       	movw	r24, r12
    351a:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    351e:	c6 01       	movw	r24, r12
    3520:	2f 96       	adiw	r28, 0x0f	; 15
    3522:	cd bf       	out	0x3d, r28	; 61
    3524:	de bf       	out	0x3e, r29	; 62
    3526:	df 91       	pop	r29
    3528:	cf 91       	pop	r28
    352a:	1f 91       	pop	r17
    352c:	0f 91       	pop	r16
    352e:	ff 90       	pop	r15
    3530:	ef 90       	pop	r14
    3532:	df 90       	pop	r13
    3534:	cf 90       	pop	r12
    3536:	08 95       	ret

00003538 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    3538:	cf 93       	push	r28
    353a:	df 93       	push	r29
    353c:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    353e:	0f b6       	in	r0, 0x3f	; 63
    3540:	f8 94       	cli
    3542:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    3544:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3548:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    354c:	8c 83       	std	Y+4, r24	; 0x04
    354e:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    3550:	0e 94 1d 13 	call	0x263a	; 0x263a <xTaskGetTickCount>
    3554:	68 83       	st	Y, r22
    3556:	79 83       	std	Y+1, r23	; 0x01
    3558:	8a 83       	std	Y+2, r24	; 0x02
    355a:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    355c:	0f 90       	pop	r0
    355e:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    3560:	ce 01       	movw	r24, r28
    3562:	df 91       	pop	r29
    3564:	cf 91       	pop	r28
    3566:	08 95       	ret

00003568 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    3568:	5f 92       	push	r5
    356a:	6f 92       	push	r6
    356c:	7f 92       	push	r7
    356e:	8f 92       	push	r8
    3570:	9f 92       	push	r9
    3572:	af 92       	push	r10
    3574:	bf 92       	push	r11
    3576:	cf 92       	push	r12
    3578:	df 92       	push	r13
    357a:	ef 92       	push	r14
    357c:	ff 92       	push	r15
    357e:	0f 93       	push	r16
    3580:	1f 93       	push	r17
    3582:	cf 93       	push	r28
    3584:	df 93       	push	r29
    3586:	5c 01       	movw	r10, r24
    3588:	4b 01       	movw	r8, r22
    358a:	7a 01       	movw	r14, r20
    358c:	12 2f       	mov	r17, r18
    358e:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    3590:	63 e0       	ldi	r22, 0x03	; 3
    3592:	ca 01       	movw	r24, r20
    3594:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    3598:	a8 14       	cp	r10, r8
    359a:	b9 04       	cpc	r11, r9
    359c:	08 f0       	brcs	.+2      	; 0x35a0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    359e:	7d c0       	rjmp	.+250    	; 0x369a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    35a0:	65 01       	movw	r12, r10
    35a2:	84 e1       	ldi	r24, 0x14	; 20
    35a4:	c8 0e       	add	r12, r24
    35a6:	d1 1c       	adc	r13, r1
    35a8:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    35aa:	6a 2c       	mov	r6, r10
    35ac:	5b 2c       	mov	r5, r11
    35ae:	b5 01       	movw	r22, r10
    35b0:	c7 01       	movw	r24, r14
    35b2:	0e 94 97 1c 	call	0x392e	; 0x392e <_ZN8emstreamlsEj>
    35b6:	6a e0       	ldi	r22, 0x0A	; 10
    35b8:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    35bc:	6d e3       	ldi	r22, 0x3D	; 61
    35be:	76 e0       	ldi	r23, 0x06	; 6
    35c0:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    35c4:	11 23       	and	r17, r17
    35c6:	09 f4       	brne	.+2      	; 0x35ca <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    35c8:	6d c0       	rjmp	.+218    	; 0x36a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    35ca:	00 23       	and	r16, r16
    35cc:	09 f4       	brne	.+2      	; 0x35d0 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    35ce:	6a c0       	rjmp	.+212    	; 0x36a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    35d0:	6a e0       	ldi	r22, 0x0A	; 10
    35d2:	c7 01       	movw	r24, r14
    35d4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    35d8:	68 e3       	ldi	r22, 0x38	; 56
    35da:	76 e0       	ldi	r23, 0x06	; 6
    35dc:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    35e0:	61 c0       	rjmp	.+194    	; 0x36a4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    35e2:	11 23       	and	r17, r17
    35e4:	71 f0       	breq	.+28     	; 0x3602 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    35e6:	01 11       	cpse	r16, r1
    35e8:	0c c0       	rjmp	.+24     	; 0x3602 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    35ea:	88 81       	ld	r24, Y
    35ec:	87 15       	cp	r24, r7
    35ee:	49 f0       	breq	.+18     	; 0x3602 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    35f0:	6a e0       	ldi	r22, 0x0A	; 10
    35f2:	c7 01       	movw	r24, r14
    35f4:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    35f8:	63 e3       	ldi	r22, 0x33	; 51
    35fa:	76 e0       	ldi	r23, 0x06	; 6
    35fc:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3600:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    3602:	69 91       	ld	r22, Y+
    3604:	c7 01       	movw	r24, r14
    3606:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    360a:	dc 01       	movw	r26, r24
    360c:	ed 91       	ld	r30, X+
    360e:	fc 91       	ld	r31, X
    3610:	02 80       	ldd	r0, Z+2	; 0x02
    3612:	f3 81       	ldd	r31, Z+3	; 0x03
    3614:	e0 2d       	mov	r30, r0
    3616:	60 e2       	ldi	r22, 0x20	; 32
    3618:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    361a:	cc 16       	cp	r12, r28
    361c:	dd 06       	cpc	r13, r29
    361e:	09 f7       	brne	.-62     	; 0x35e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    3620:	11 23       	and	r17, r17
    3622:	89 f0       	breq	.+34     	; 0x3646 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    3624:	6a e0       	ldi	r22, 0x0A	; 10
    3626:	c7 01       	movw	r24, r14
    3628:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    362c:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    362e:	6d e2       	ldi	r22, 0x2D	; 45
    3630:	76 e0       	ldi	r23, 0x06	; 6
    3632:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3636:	e8 81       	ld	r30, Y
    3638:	f9 81       	ldd	r31, Y+1	; 0x01
    363a:	02 80       	ldd	r0, Z+2	; 0x02
    363c:	f3 81       	ldd	r31, Z+3	; 0x03
    363e:	e0 2d       	mov	r30, r0
    3640:	60 e2       	ldi	r22, 0x20	; 32
    3642:	ce 01       	movw	r24, r28
    3644:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3646:	c6 2d       	mov	r28, r6
    3648:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    364a:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    364c:	80 ee       	ldi	r24, 0xE0	; 224
    364e:	86 0f       	add	r24, r22
    3650:	8f 35       	cpi	r24, 0x5F	; 95
    3652:	48 f4       	brcc	.+18     	; 0x3666 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    3654:	d7 01       	movw	r26, r14
    3656:	ed 91       	ld	r30, X+
    3658:	fc 91       	ld	r31, X
    365a:	02 80       	ldd	r0, Z+2	; 0x02
    365c:	f3 81       	ldd	r31, Z+3	; 0x03
    365e:	e0 2d       	mov	r30, r0
    3660:	c7 01       	movw	r24, r14
    3662:	19 95       	eicall
    3664:	09 c0       	rjmp	.+18     	; 0x3678 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    3666:	d7 01       	movw	r26, r14
    3668:	ed 91       	ld	r30, X+
    366a:	fc 91       	ld	r31, X
    366c:	02 80       	ldd	r0, Z+2	; 0x02
    366e:	f3 81       	ldd	r31, Z+3	; 0x03
    3670:	e0 2d       	mov	r30, r0
    3672:	6e e2       	ldi	r22, 0x2E	; 46
    3674:	c7 01       	movw	r24, r14
    3676:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    3678:	cc 16       	cp	r12, r28
    367a:	dd 06       	cpc	r13, r29
    367c:	31 f7       	brne	.-52     	; 0x364a <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    367e:	b4 e1       	ldi	r27, 0x14	; 20
    3680:	ab 0e       	add	r10, r27
    3682:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    3684:	66 e0       	ldi	r22, 0x06	; 6
    3686:	c7 01       	movw	r24, r14
    3688:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    368c:	84 e1       	ldi	r24, 0x14	; 20
    368e:	c8 0e       	add	r12, r24
    3690:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    3692:	a8 14       	cp	r10, r8
    3694:	b9 04       	cpc	r11, r9
    3696:	08 f4       	brcc	.+2      	; 0x369a <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    3698:	88 cf       	rjmp	.-240    	; 0x35aa <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    369a:	62 e0       	ldi	r22, 0x02	; 2
    369c:	c7 01       	movw	r24, r14
    369e:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
}
    36a2:	03 c0       	rjmp	.+6      	; 0x36aa <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    36a4:	c6 2d       	mov	r28, r6
    36a6:	d5 2d       	mov	r29, r5
    36a8:	9c cf       	rjmp	.-200    	; 0x35e2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    36aa:	df 91       	pop	r29
    36ac:	cf 91       	pop	r28
    36ae:	1f 91       	pop	r17
    36b0:	0f 91       	pop	r16
    36b2:	ff 90       	pop	r15
    36b4:	ef 90       	pop	r14
    36b6:	df 90       	pop	r13
    36b8:	cf 90       	pop	r12
    36ba:	bf 90       	pop	r11
    36bc:	af 90       	pop	r10
    36be:	9f 90       	pop	r9
    36c0:	8f 90       	pop	r8
    36c2:	7f 90       	pop	r7
    36c4:	6f 90       	pop	r6
    36c6:	5f 90       	pop	r5
    36c8:	08 95       	ret

000036ca <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    36ca:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    36ce:	08 95       	ret

000036d0 <_Znaj>:
    36d0:	0e 94 a7 0b 	call	0x174e	; 0x174e <pvPortMalloc>
    36d4:	08 95       	ret

000036d6 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    36d6:	08 95       	ret

000036d8 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    36d8:	cf 93       	push	r28
    36da:	df 93       	push	r29
    36dc:	fc 01       	movw	r30, r24
    36de:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    36e0:	40 3a       	cpi	r20, 0xA0	; 160
    36e2:	68 e0       	ldi	r22, 0x08	; 8
    36e4:	56 07       	cpc	r21, r22
    36e6:	49 f4       	brne	.+18     	; 0x36fa <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    36e8:	80 e4       	ldi	r24, 0x40	; 64
    36ea:	96 e0       	ldi	r25, 0x06	; 6
    36ec:	82 83       	std	Z+2, r24	; 0x02
    36ee:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    36f0:	82 e0       	ldi	r24, 0x02	; 2
    36f2:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    36f4:	83 e0       	ldi	r24, 0x03	; 3
    36f6:	85 83       	std	Z+5, r24	; 0x05
    36f8:	32 c0       	rjmp	.+100    	; 0x375e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    36fa:	40 3b       	cpi	r20, 0xB0	; 176
    36fc:	78 e0       	ldi	r23, 0x08	; 8
    36fe:	57 07       	cpc	r21, r23
    3700:	49 f4       	brne	.+18     	; 0x3714 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    3702:	80 e4       	ldi	r24, 0x40	; 64
    3704:	96 e0       	ldi	r25, 0x06	; 6
    3706:	82 83       	std	Z+2, r24	; 0x02
    3708:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    370a:	86 e0       	ldi	r24, 0x06	; 6
    370c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    370e:	87 e0       	ldi	r24, 0x07	; 7
    3710:	85 83       	std	Z+5, r24	; 0x05
    3712:	25 c0       	rjmp	.+74     	; 0x375e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3714:	40 3a       	cpi	r20, 0xA0	; 160
    3716:	89 e0       	ldi	r24, 0x09	; 9
    3718:	58 07       	cpc	r21, r24
    371a:	49 f4       	brne	.+18     	; 0x372e <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    371c:	80 e6       	ldi	r24, 0x60	; 96
    371e:	96 e0       	ldi	r25, 0x06	; 6
    3720:	82 83       	std	Z+2, r24	; 0x02
    3722:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3724:	82 e0       	ldi	r24, 0x02	; 2
    3726:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3728:	83 e0       	ldi	r24, 0x03	; 3
    372a:	85 83       	std	Z+5, r24	; 0x05
    372c:	18 c0       	rjmp	.+48     	; 0x375e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    372e:	40 3b       	cpi	r20, 0xB0	; 176
    3730:	69 e0       	ldi	r22, 0x09	; 9
    3732:	56 07       	cpc	r21, r22
    3734:	49 f4       	brne	.+18     	; 0x3748 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3736:	80 e6       	ldi	r24, 0x60	; 96
    3738:	96 e0       	ldi	r25, 0x06	; 6
    373a:	82 83       	std	Z+2, r24	; 0x02
    373c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    373e:	86 e0       	ldi	r24, 0x06	; 6
    3740:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3742:	87 e0       	ldi	r24, 0x07	; 7
    3744:	85 83       	std	Z+5, r24	; 0x05
    3746:	0b c0       	rjmp	.+22     	; 0x375e <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3748:	40 3a       	cpi	r20, 0xA0	; 160
    374a:	5a 40       	sbci	r21, 0x0A	; 10
    374c:	41 f4       	brne	.+16     	; 0x375e <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    374e:	80 e8       	ldi	r24, 0x80	; 128
    3750:	96 e0       	ldi	r25, 0x06	; 6
    3752:	82 83       	std	Z+2, r24	; 0x02
    3754:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3756:	82 e0       	ldi	r24, 0x02	; 2
    3758:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    375a:	83 e0       	ldi	r24, 0x03	; 3
    375c:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    375e:	a6 83       	std	Z+6, r26	; 0x06
    3760:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3762:	cd 01       	movw	r24, r26
    3764:	01 96       	adiw	r24, 0x01	; 1
    3766:	80 87       	std	Z+8, r24	; 0x08
    3768:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    376a:	03 96       	adiw	r24, 0x03	; 3
    376c:	82 87       	std	Z+10, r24	; 0x0a
    376e:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3770:	25 81       	ldd	r18, Z+5	; 0x05
    3772:	c2 81       	ldd	r28, Z+2	; 0x02
    3774:	d3 81       	ldd	r29, Z+3	; 0x03
    3776:	4c 81       	ldd	r20, Y+4	; 0x04
    3778:	81 e0       	ldi	r24, 0x01	; 1
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	bc 01       	movw	r22, r24
    377e:	02 c0       	rjmp	.+4      	; 0x3784 <_ZN7base232C1EjP12USART_struct+0xac>
    3780:	66 0f       	add	r22, r22
    3782:	77 1f       	adc	r23, r23
    3784:	2a 95       	dec	r18
    3786:	e2 f7       	brpl	.-8      	; 0x3780 <_ZN7base232C1EjP12USART_struct+0xa8>
    3788:	9b 01       	movw	r18, r22
    378a:	24 2b       	or	r18, r20
    378c:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    378e:	25 81       	ldd	r18, Z+5	; 0x05
    3790:	c2 81       	ldd	r28, Z+2	; 0x02
    3792:	d3 81       	ldd	r29, Z+3	; 0x03
    3794:	48 81       	ld	r20, Y
    3796:	bc 01       	movw	r22, r24
    3798:	02 c0       	rjmp	.+4      	; 0x379e <_ZN7base232C1EjP12USART_struct+0xc6>
    379a:	66 0f       	add	r22, r22
    379c:	77 1f       	adc	r23, r23
    379e:	2a 95       	dec	r18
    37a0:	e2 f7       	brpl	.-8      	; 0x379a <_ZN7base232C1EjP12USART_struct+0xc2>
    37a2:	9b 01       	movw	r18, r22
    37a4:	24 2b       	or	r18, r20
    37a6:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    37a8:	34 81       	ldd	r19, Z+4	; 0x04
    37aa:	c2 81       	ldd	r28, Z+2	; 0x02
    37ac:	d3 81       	ldd	r29, Z+3	; 0x03
    37ae:	28 81       	ld	r18, Y
    37b0:	02 c0       	rjmp	.+4      	; 0x37b6 <_ZN7base232C1EjP12USART_struct+0xde>
    37b2:	88 0f       	add	r24, r24
    37b4:	99 1f       	adc	r25, r25
    37b6:	3a 95       	dec	r19
    37b8:	e2 f7       	brpl	.-8      	; 0x37b2 <_ZN7base232C1EjP12USART_struct+0xda>
    37ba:	80 95       	com	r24
    37bc:	90 95       	com	r25
    37be:	82 23       	and	r24, r18
    37c0:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    37c2:	80 e1       	ldi	r24, 0x10	; 16
    37c4:	13 96       	adiw	r26, 0x03	; 3
    37c6:	8c 93       	st	X, r24
    37c8:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    37ca:	83 e0       	ldi	r24, 0x03	; 3
    37cc:	15 96       	adiw	r26, 0x05	; 5
    37ce:	8c 93       	st	X, r24
    37d0:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    37d2:	80 ef       	ldi	r24, 0xF0	; 240
    37d4:	17 96       	adiw	r26, 0x07	; 7
    37d6:	8c 93       	st	X, r24
    37d8:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    37da:	81 e2       	ldi	r24, 0x21	; 33
    37dc:	16 96       	adiw	r26, 0x06	; 6
    37de:	8c 93       	st	X, r24
    37e0:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    37e2:	88 e1       	ldi	r24, 0x18	; 24
    37e4:	14 96       	adiw	r26, 0x04	; 4
    37e6:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    37e8:	80 e8       	ldi	r24, 0x80	; 128
    37ea:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    37ec:	80 e4       	ldi	r24, 0x40	; 64
    37ee:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    37f0:	80 e2       	ldi	r24, 0x20	; 32
    37f2:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    37f4:	06 80       	ldd	r0, Z+6	; 0x06
    37f6:	f7 81       	ldd	r31, Z+7	; 0x07
    37f8:	e0 2d       	mov	r30, r0
    37fa:	80 81       	ld	r24, Z
    37fc:	80 81       	ld	r24, Z
}
    37fe:	df 91       	pop	r29
    3800:	cf 91       	pop	r28
    3802:	08 95       	ret

00003804 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    3804:	81 e0       	ldi	r24, 0x01	; 1
    3806:	08 95       	ret

00003808 <_ZN8emstream7getcharEv>:
    3808:	80 e0       	ldi	r24, 0x00	; 0
    380a:	90 e0       	ldi	r25, 0x00	; 0
    380c:	08 95       	ret

0000380e <_ZN8emstream14check_for_charEv>:
    380e:	80 e0       	ldi	r24, 0x00	; 0
    3810:	08 95       	ret

00003812 <_ZN8emstream12transmit_nowEv>:
    3812:	08 95       	ret

00003814 <_ZN8emstream12clear_screenEv>:
    3814:	08 95       	ret

00003816 <_ZN8emstreamC1Ev>:
    3816:	fc 01       	movw	r30, r24
    3818:	87 ed       	ldi	r24, 0xD7	; 215
    381a:	90 e2       	ldi	r25, 0x20	; 32
    381c:	80 83       	st	Z, r24
    381e:	91 83       	std	Z+1, r25	; 0x01
    3820:	8a e0       	ldi	r24, 0x0A	; 10
    3822:	82 83       	std	Z+2, r24	; 0x02
    3824:	13 82       	std	Z+3, r1	; 0x03
    3826:	83 e0       	ldi	r24, 0x03	; 3
    3828:	85 83       	std	Z+5, r24	; 0x05
    382a:	14 82       	std	Z+4, r1	; 0x04
    382c:	16 82       	std	Z+6, r1	; 0x06
    382e:	17 82       	std	Z+7, r1	; 0x07
    3830:	08 95       	ret

00003832 <_ZN8emstream4putsEPKc>:
    3832:	0f 93       	push	r16
    3834:	1f 93       	push	r17
    3836:	cf 93       	push	r28
    3838:	df 93       	push	r29
    383a:	8c 01       	movw	r16, r24
    383c:	fb 01       	movw	r30, r22
    383e:	dc 01       	movw	r26, r24
    3840:	14 96       	adiw	r26, 0x04	; 4
    3842:	8c 91       	ld	r24, X
    3844:	81 11       	cpse	r24, r1
    3846:	04 c0       	rjmp	.+8      	; 0x3850 <_ZN8emstream4putsEPKc+0x1e>
    3848:	60 81       	ld	r22, Z
    384a:	61 11       	cpse	r22, r1
    384c:	17 c0       	rjmp	.+46     	; 0x387c <_ZN8emstream4putsEPKc+0x4a>
    384e:	23 c0       	rjmp	.+70     	; 0x3896 <_ZN8emstream4putsEPKc+0x64>
    3850:	d8 01       	movw	r26, r16
    3852:	14 96       	adiw	r26, 0x04	; 4
    3854:	1c 92       	st	X, r1
    3856:	eb 01       	movw	r28, r22
    3858:	21 96       	adiw	r28, 0x01	; 1
    385a:	64 91       	lpm	r22, Z
    385c:	66 23       	and	r22, r22
    385e:	d9 f0       	breq	.+54     	; 0x3896 <_ZN8emstream4putsEPKc+0x64>
    3860:	d8 01       	movw	r26, r16
    3862:	ed 91       	ld	r30, X+
    3864:	fc 91       	ld	r31, X
    3866:	02 80       	ldd	r0, Z+2	; 0x02
    3868:	f3 81       	ldd	r31, Z+3	; 0x03
    386a:	e0 2d       	mov	r30, r0
    386c:	c8 01       	movw	r24, r16
    386e:	19 95       	eicall
    3870:	fe 01       	movw	r30, r28
    3872:	64 91       	lpm	r22, Z
    3874:	21 96       	adiw	r28, 0x01	; 1
    3876:	61 11       	cpse	r22, r1
    3878:	f3 cf       	rjmp	.-26     	; 0x3860 <_ZN8emstream4putsEPKc+0x2e>
    387a:	0d c0       	rjmp	.+26     	; 0x3896 <_ZN8emstream4putsEPKc+0x64>
    387c:	ef 01       	movw	r28, r30
    387e:	21 96       	adiw	r28, 0x01	; 1
    3880:	d8 01       	movw	r26, r16
    3882:	ed 91       	ld	r30, X+
    3884:	fc 91       	ld	r31, X
    3886:	02 80       	ldd	r0, Z+2	; 0x02
    3888:	f3 81       	ldd	r31, Z+3	; 0x03
    388a:	e0 2d       	mov	r30, r0
    388c:	c8 01       	movw	r24, r16
    388e:	19 95       	eicall
    3890:	69 91       	ld	r22, Y+
    3892:	61 11       	cpse	r22, r1
    3894:	f5 cf       	rjmp	.-22     	; 0x3880 <_ZN8emstream4putsEPKc+0x4e>
    3896:	df 91       	pop	r29
    3898:	cf 91       	pop	r28
    389a:	1f 91       	pop	r17
    389c:	0f 91       	pop	r16
    389e:	08 95       	ret

000038a0 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    38a0:	cf 93       	push	r28
    38a2:	df 93       	push	r29
    38a4:	ec 01       	movw	r28, r24
	switch (new_manip)
    38a6:	86 2f       	mov	r24, r22
    38a8:	90 e0       	ldi	r25, 0x00	; 0
    38aa:	8b 30       	cpi	r24, 0x0B	; 11
    38ac:	91 05       	cpc	r25, r1
    38ae:	d8 f5       	brcc	.+118    	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
    38b0:	fc 01       	movw	r30, r24
    38b2:	88 27       	eor	r24, r24
    38b4:	e2 50       	subi	r30, 0x02	; 2
    38b6:	ff 4f       	sbci	r31, 0xFF	; 255
    38b8:	8f 4f       	sbci	r24, 0xFF	; 255
    38ba:	0c 94 b6 23 	jmp	0x476c	; 0x476c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    38be:	82 e0       	ldi	r24, 0x02	; 2
    38c0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38c2:	31 c0       	rjmp	.+98     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    38c4:	88 e0       	ldi	r24, 0x08	; 8
    38c6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38c8:	2e c0       	rjmp	.+92     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    38ca:	8a e0       	ldi	r24, 0x0A	; 10
    38cc:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38ce:	2b c0       	rjmp	.+86     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    38d0:	80 e1       	ldi	r24, 0x10	; 16
    38d2:	8a 83       	std	Y+2, r24	; 0x02
			break;
    38d4:	28 c0       	rjmp	.+80     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    38d6:	81 e0       	ldi	r24, 0x01	; 1
    38d8:	8b 83       	std	Y+3, r24	; 0x03
			break;
    38da:	25 c0       	rjmp	.+74     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    38dc:	1b 82       	std	Y+3, r1	; 0x03
			break;
    38de:	23 c0       	rjmp	.+70     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    38e0:	e8 81       	ld	r30, Y
    38e2:	f9 81       	ldd	r31, Y+1	; 0x01
    38e4:	02 80       	ldd	r0, Z+2	; 0x02
    38e6:	f3 81       	ldd	r31, Z+3	; 0x03
    38e8:	e0 2d       	mov	r30, r0
    38ea:	6d e0       	ldi	r22, 0x0D	; 13
    38ec:	ce 01       	movw	r24, r28
    38ee:	19 95       	eicall
    38f0:	e8 81       	ld	r30, Y
    38f2:	f9 81       	ldd	r31, Y+1	; 0x01
    38f4:	02 80       	ldd	r0, Z+2	; 0x02
    38f6:	f3 81       	ldd	r31, Z+3	; 0x03
    38f8:	e0 2d       	mov	r30, r0
    38fa:	6a e0       	ldi	r22, 0x0A	; 10
    38fc:	ce 01       	movw	r24, r28
    38fe:	19 95       	eicall
			break;
    3900:	12 c0       	rjmp	.+36     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    3902:	e8 81       	ld	r30, Y
    3904:	f9 81       	ldd	r31, Y+1	; 0x01
    3906:	02 84       	ldd	r0, Z+10	; 0x0a
    3908:	f3 85       	ldd	r31, Z+11	; 0x0b
    390a:	e0 2d       	mov	r30, r0
    390c:	ce 01       	movw	r24, r28
    390e:	19 95       	eicall
			break;
    3910:	0a c0       	rjmp	.+20     	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3912:	e8 81       	ld	r30, Y
    3914:	f9 81       	ldd	r31, Y+1	; 0x01
    3916:	00 84       	ldd	r0, Z+8	; 0x08
    3918:	f1 85       	ldd	r31, Z+9	; 0x09
    391a:	e0 2d       	mov	r30, r0
    391c:	ce 01       	movw	r24, r28
    391e:	19 95       	eicall
			break;
    3920:	02 c0       	rjmp	.+4      	; 0x3926 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3922:	81 e0       	ldi	r24, 0x01	; 1
    3924:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3926:	ce 01       	movw	r24, r28
    3928:	df 91       	pop	r29
    392a:	cf 91       	pop	r28
    392c:	08 95       	ret

0000392e <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    392e:	ff 92       	push	r15
    3930:	0f 93       	push	r16
    3932:	1f 93       	push	r17
    3934:	cf 93       	push	r28
    3936:	df 93       	push	r29
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
    393c:	61 97       	sbiw	r28, 0x11	; 17
    393e:	cd bf       	out	0x3d, r28	; 61
    3940:	de bf       	out	0x3e, r29	; 62
    3942:	8c 01       	movw	r16, r24
    3944:	f6 2e       	mov	r15, r22
    3946:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3948:	f8 01       	movw	r30, r16
    394a:	42 81       	ldd	r20, Z+2	; 0x02
    394c:	40 31       	cpi	r20, 0x10	; 16
    394e:	21 f0       	breq	.+8      	; 0x3958 <_ZN8emstreamlsEj+0x2a>
    3950:	48 30       	cpi	r20, 0x08	; 8
    3952:	11 f0       	breq	.+4      	; 0x3958 <_ZN8emstreamlsEj+0x2a>
    3954:	42 30       	cpi	r20, 0x02	; 2
    3956:	41 f4       	brne	.+16     	; 0x3968 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3958:	69 2f       	mov	r22, r25
    395a:	c8 01       	movw	r24, r16
    395c:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    3960:	6f 2d       	mov	r22, r15
    3962:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    3966:	0d c0       	rjmp	.+26     	; 0x3982 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3968:	50 e0       	ldi	r21, 0x00	; 0
    396a:	be 01       	movw	r22, r28
    396c:	6f 5f       	subi	r22, 0xFF	; 255
    396e:	7f 4f       	sbci	r23, 0xFF	; 255
    3970:	8f 2d       	mov	r24, r15
    3972:	0e 94 25 24 	call	0x484a	; 0x484a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3976:	be 01       	movw	r22, r28
    3978:	6f 5f       	subi	r22, 0xFF	; 255
    397a:	7f 4f       	sbci	r23, 0xFF	; 255
    397c:	c8 01       	movw	r24, r16
    397e:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3982:	c8 01       	movw	r24, r16
    3984:	61 96       	adiw	r28, 0x11	; 17
    3986:	cd bf       	out	0x3d, r28	; 61
    3988:	de bf       	out	0x3e, r29	; 62
    398a:	df 91       	pop	r29
    398c:	cf 91       	pop	r28
    398e:	1f 91       	pop	r17
    3990:	0f 91       	pop	r16
    3992:	ff 90       	pop	r15
    3994:	08 95       	ret

00003996 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3996:	df 92       	push	r13
    3998:	ef 92       	push	r14
    399a:	ff 92       	push	r15
    399c:	0f 93       	push	r16
    399e:	1f 93       	push	r17
    39a0:	cf 93       	push	r28
    39a2:	df 93       	push	r29
    39a4:	cd b7       	in	r28, 0x3d	; 61
    39a6:	de b7       	in	r29, 0x3e	; 62
    39a8:	a1 97       	sbiw	r28, 0x21	; 33
    39aa:	cd bf       	out	0x3d, r28	; 61
    39ac:	de bf       	out	0x3e, r29	; 62
    39ae:	8c 01       	movw	r16, r24
    39b0:	d4 2e       	mov	r13, r20
    39b2:	e5 2e       	mov	r14, r21
    39b4:	f6 2e       	mov	r15, r22
    39b6:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    39b8:	f8 01       	movw	r30, r16
    39ba:	22 81       	ldd	r18, Z+2	; 0x02
    39bc:	20 31       	cpi	r18, 0x10	; 16
    39be:	21 f0       	breq	.+8      	; 0x39c8 <_ZN8emstreamlsEm+0x32>
    39c0:	28 30       	cpi	r18, 0x08	; 8
    39c2:	11 f0       	breq	.+4      	; 0x39c8 <_ZN8emstreamlsEm+0x32>
    39c4:	22 30       	cpi	r18, 0x02	; 2
    39c6:	71 f4       	brne	.+28     	; 0x39e4 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    39c8:	69 2f       	mov	r22, r25
    39ca:	c8 01       	movw	r24, r16
    39cc:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    39d0:	6f 2d       	mov	r22, r15
    39d2:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    39d6:	6e 2d       	mov	r22, r14
    39d8:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    39dc:	6d 2d       	mov	r22, r13
    39de:	0e 94 0d 1d 	call	0x3a1a	; 0x3a1a <_ZN8emstreamlsEh>
    39e2:	0f c0       	rjmp	.+30     	; 0x3a02 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    39e4:	30 e0       	ldi	r19, 0x00	; 0
    39e6:	ae 01       	movw	r20, r28
    39e8:	4f 5f       	subi	r20, 0xFF	; 255
    39ea:	5f 4f       	sbci	r21, 0xFF	; 255
    39ec:	6d 2d       	mov	r22, r13
    39ee:	7e 2d       	mov	r23, r14
    39f0:	8f 2d       	mov	r24, r15
    39f2:	0e 94 f8 23 	call	0x47f0	; 0x47f0 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    39f6:	be 01       	movw	r22, r28
    39f8:	6f 5f       	subi	r22, 0xFF	; 255
    39fa:	7f 4f       	sbci	r23, 0xFF	; 255
    39fc:	c8 01       	movw	r24, r16
    39fe:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3a02:	c8 01       	movw	r24, r16
    3a04:	a1 96       	adiw	r28, 0x21	; 33
    3a06:	cd bf       	out	0x3d, r28	; 61
    3a08:	de bf       	out	0x3e, r29	; 62
    3a0a:	df 91       	pop	r29
    3a0c:	cf 91       	pop	r28
    3a0e:	1f 91       	pop	r17
    3a10:	0f 91       	pop	r16
    3a12:	ff 90       	pop	r15
    3a14:	ef 90       	pop	r14
    3a16:	df 90       	pop	r13
    3a18:	08 95       	ret

00003a1a <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3a1a:	cf 92       	push	r12
    3a1c:	df 92       	push	r13
    3a1e:	ef 92       	push	r14
    3a20:	ff 92       	push	r15
    3a22:	0f 93       	push	r16
    3a24:	1f 93       	push	r17
    3a26:	cf 93       	push	r28
    3a28:	df 93       	push	r29
    3a2a:	cd b7       	in	r28, 0x3d	; 61
    3a2c:	de b7       	in	r29, 0x3e	; 62
    3a2e:	29 97       	sbiw	r28, 0x09	; 9
    3a30:	cd bf       	out	0x3d, r28	; 61
    3a32:	de bf       	out	0x3e, r29	; 62
    3a34:	8c 01       	movw	r16, r24
    3a36:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3a38:	dc 01       	movw	r26, r24
    3a3a:	13 96       	adiw	r26, 0x03	; 3
    3a3c:	8c 91       	ld	r24, X
    3a3e:	13 97       	sbiw	r26, 0x03	; 3
    3a40:	88 23       	and	r24, r24
    3a42:	41 f0       	breq	.+16     	; 0x3a54 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3a44:	ed 91       	ld	r30, X+
    3a46:	fc 91       	ld	r31, X
    3a48:	02 80       	ldd	r0, Z+2	; 0x02
    3a4a:	f3 81       	ldd	r31, Z+3	; 0x03
    3a4c:	e0 2d       	mov	r30, r0
    3a4e:	c8 01       	movw	r24, r16
    3a50:	19 95       	eicall
    3a52:	56 c0       	rjmp	.+172    	; 0x3b00 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3a54:	f8 01       	movw	r30, r16
    3a56:	42 81       	ldd	r20, Z+2	; 0x02
    3a58:	42 30       	cpi	r20, 0x02	; 2
    3a5a:	19 f5       	brne	.+70     	; 0x3aa2 <_ZN8emstreamlsEh+0x88>
    3a5c:	68 94       	set
    3a5e:	cc 24       	eor	r12, r12
    3a60:	c3 f8       	bld	r12, 3
    3a62:	d1 2c       	mov	r13, r1
    3a64:	68 94       	set
    3a66:	ff 24       	eor	r15, r15
    3a68:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3a6a:	8e 2d       	mov	r24, r14
    3a6c:	8f 21       	and	r24, r15
    3a6e:	51 f0       	breq	.+20     	; 0x3a84 <_ZN8emstreamlsEh+0x6a>
    3a70:	d8 01       	movw	r26, r16
    3a72:	ed 91       	ld	r30, X+
    3a74:	fc 91       	ld	r31, X
    3a76:	02 80       	ldd	r0, Z+2	; 0x02
    3a78:	f3 81       	ldd	r31, Z+3	; 0x03
    3a7a:	e0 2d       	mov	r30, r0
    3a7c:	61 e3       	ldi	r22, 0x31	; 49
    3a7e:	c8 01       	movw	r24, r16
    3a80:	19 95       	eicall
    3a82:	09 c0       	rjmp	.+18     	; 0x3a96 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3a84:	d8 01       	movw	r26, r16
    3a86:	ed 91       	ld	r30, X+
    3a88:	fc 91       	ld	r31, X
    3a8a:	02 80       	ldd	r0, Z+2	; 0x02
    3a8c:	f3 81       	ldd	r31, Z+3	; 0x03
    3a8e:	e0 2d       	mov	r30, r0
    3a90:	60 e3       	ldi	r22, 0x30	; 48
    3a92:	c8 01       	movw	r24, r16
    3a94:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3a96:	f6 94       	lsr	r15
    3a98:	b1 e0       	ldi	r27, 0x01	; 1
    3a9a:	cb 1a       	sub	r12, r27
    3a9c:	d1 08       	sbc	r13, r1
    3a9e:	29 f7       	brne	.-54     	; 0x3a6a <_ZN8emstreamlsEh+0x50>
    3aa0:	2f c0       	rjmp	.+94     	; 0x3b00 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3aa2:	40 31       	cpi	r20, 0x10	; 16
    3aa4:	f9 f4       	brne	.+62     	; 0x3ae4 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3aa6:	62 95       	swap	r22
    3aa8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3aaa:	01 90       	ld	r0, Z+
    3aac:	f0 81       	ld	r31, Z
    3aae:	e0 2d       	mov	r30, r0
    3ab0:	02 80       	ldd	r0, Z+2	; 0x02
    3ab2:	f3 81       	ldd	r31, Z+3	; 0x03
    3ab4:	e0 2d       	mov	r30, r0
    3ab6:	6a 30       	cpi	r22, 0x0A	; 10
    3ab8:	10 f0       	brcs	.+4      	; 0x3abe <_ZN8emstreamlsEh+0xa4>
    3aba:	69 5c       	subi	r22, 0xC9	; 201
    3abc:	01 c0       	rjmp	.+2      	; 0x3ac0 <_ZN8emstreamlsEh+0xa6>
    3abe:	60 5d       	subi	r22, 0xD0	; 208
    3ac0:	c8 01       	movw	r24, r16
    3ac2:	19 95       	eicall
		temp_char = num & 0x0F;
    3ac4:	6e 2d       	mov	r22, r14
    3ac6:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3ac8:	d8 01       	movw	r26, r16
    3aca:	ed 91       	ld	r30, X+
    3acc:	fc 91       	ld	r31, X
    3ace:	02 80       	ldd	r0, Z+2	; 0x02
    3ad0:	f3 81       	ldd	r31, Z+3	; 0x03
    3ad2:	e0 2d       	mov	r30, r0
    3ad4:	6a 30       	cpi	r22, 0x0A	; 10
    3ad6:	10 f0       	brcs	.+4      	; 0x3adc <_ZN8emstreamlsEh+0xc2>
    3ad8:	69 5c       	subi	r22, 0xC9	; 201
    3ada:	01 c0       	rjmp	.+2      	; 0x3ade <_ZN8emstreamlsEh+0xc4>
    3adc:	60 5d       	subi	r22, 0xD0	; 208
    3ade:	c8 01       	movw	r24, r16
    3ae0:	19 95       	eicall
    3ae2:	0e c0       	rjmp	.+28     	; 0x3b00 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3ae4:	50 e0       	ldi	r21, 0x00	; 0
    3ae6:	be 01       	movw	r22, r28
    3ae8:	6f 5f       	subi	r22, 0xFF	; 255
    3aea:	7f 4f       	sbci	r23, 0xFF	; 255
    3aec:	8e 2d       	mov	r24, r14
    3aee:	90 e0       	ldi	r25, 0x00	; 0
    3af0:	0e 94 25 24 	call	0x484a	; 0x484a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    3af4:	be 01       	movw	r22, r28
    3af6:	6f 5f       	subi	r22, 0xFF	; 255
    3af8:	7f 4f       	sbci	r23, 0xFF	; 255
    3afa:	c8 01       	movw	r24, r16
    3afc:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3b00:	c8 01       	movw	r24, r16
    3b02:	29 96       	adiw	r28, 0x09	; 9
    3b04:	cd bf       	out	0x3d, r28	; 61
    3b06:	de bf       	out	0x3e, r29	; 62
    3b08:	df 91       	pop	r29
    3b0a:	cf 91       	pop	r28
    3b0c:	1f 91       	pop	r17
    3b0e:	0f 91       	pop	r16
    3b10:	ff 90       	pop	r15
    3b12:	ef 90       	pop	r14
    3b14:	df 90       	pop	r13
    3b16:	cf 90       	pop	r12
    3b18:	08 95       	ret

00003b1a <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3b1a:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b1c:	50 96       	adiw	r26, 0x10	; 16
    3b1e:	ed 91       	ld	r30, X+
    3b20:	fc 91       	ld	r31, X
    3b22:	51 97       	sbiw	r26, 0x11	; 17
    3b24:	80 81       	ld	r24, Z
    3b26:	54 96       	adiw	r26, 0x14	; 20
    3b28:	4c 91       	ld	r20, X
    3b2a:	54 97       	sbiw	r26, 0x14	; 20
    3b2c:	84 23       	and	r24, r20
    3b2e:	29 f0       	breq	.+10     	; 0x3b3a <_ZN5rs2327putcharEc+0x20>
    3b30:	09 c0       	rjmp	.+18     	; 0x3b44 <_ZN5rs2327putcharEc+0x2a>
    3b32:	21 50       	subi	r18, 0x01	; 1
    3b34:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3b36:	19 f4       	brne	.+6      	; 0x3b3e <_ZN5rs2327putcharEc+0x24>
    3b38:	12 c0       	rjmp	.+36     	; 0x3b5e <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3b3a:	21 e2       	ldi	r18, 0x21	; 33
    3b3c:	3e e4       	ldi	r19, 0x4E	; 78
    3b3e:	90 81       	ld	r25, Z
    3b40:	94 23       	and	r25, r20
    3b42:	b9 f3       	breq	.-18     	; 0x3b32 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3b44:	90 81       	ld	r25, Z
    3b46:	56 96       	adiw	r26, 0x16	; 22
    3b48:	8c 91       	ld	r24, X
    3b4a:	56 97       	sbiw	r26, 0x16	; 22
    3b4c:	89 2b       	or	r24, r25
    3b4e:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3b50:	1e 96       	adiw	r26, 0x0e	; 14
    3b52:	ed 91       	ld	r30, X+
    3b54:	fc 91       	ld	r31, X
    3b56:	1f 97       	sbiw	r26, 0x0f	; 15
    3b58:	60 83       	st	Z, r22
	return (true);
    3b5a:	81 e0       	ldi	r24, 0x01	; 1
    3b5c:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3b5e:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3b60:	08 95       	ret

00003b62 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3b68:	c1 8d       	ldd	r28, Z+25	; 0x19
    3b6a:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3b6c:	28 81       	ld	r18, Y
    3b6e:	39 81       	ldd	r19, Y+1	; 0x01
    3b70:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3b72:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3b74:	4d 91       	ld	r20, X+
    3b76:	5c 91       	ld	r21, X
    3b78:	24 17       	cp	r18, r20
    3b7a:	35 07       	cpc	r19, r21
    3b7c:	e9 f3       	breq	.-6      	; 0x3b78 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3b7e:	a7 89       	ldd	r26, Z+23	; 0x17
    3b80:	b0 8d       	ldd	r27, Z+24	; 0x18
    3b82:	0d 90       	ld	r0, X+
    3b84:	bc 91       	ld	r27, X
    3b86:	a0 2d       	mov	r26, r0
    3b88:	a2 0f       	add	r26, r18
    3b8a:	b3 1f       	adc	r27, r19
    3b8c:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3b8e:	2f 5f       	subi	r18, 0xFF	; 255
    3b90:	3f 4f       	sbci	r19, 0xFF	; 255
    3b92:	28 83       	st	Y, r18
    3b94:	39 83       	std	Y+1, r19	; 0x01
    3b96:	24 36       	cpi	r18, 0x64	; 100
    3b98:	31 05       	cpc	r19, r1
    3b9a:	28 f0       	brcs	.+10     	; 0x3ba6 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3b9c:	01 8c       	ldd	r0, Z+25	; 0x19
    3b9e:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3ba0:	e0 2d       	mov	r30, r0
    3ba2:	10 82       	st	Z, r1
    3ba4:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3ba6:	90 e0       	ldi	r25, 0x00	; 0
    3ba8:	df 91       	pop	r29
    3baa:	cf 91       	pop	r28
    3bac:	08 95       	ret

00003bae <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3bae:	cf 93       	push	r28
    3bb0:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    3bb2:	ec 01       	movw	r28, r24
    3bb4:	a9 8d       	ldd	r26, Y+25	; 0x19
    3bb6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3bb8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3bba:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3bbc:	81 e0       	ldi	r24, 0x01	; 1
    3bbe:	4d 91       	ld	r20, X+
    3bc0:	5c 91       	ld	r21, X
    3bc2:	20 81       	ld	r18, Z
    3bc4:	31 81       	ldd	r19, Z+1	; 0x01
    3bc6:	42 17       	cp	r20, r18
    3bc8:	53 07       	cpc	r21, r19
    3bca:	09 f4       	brne	.+2      	; 0x3bce <_ZN5rs23214check_for_charEv+0x20>
    3bcc:	80 e0       	ldi	r24, 0x00	; 0
}
    3bce:	df 91       	pop	r29
    3bd0:	cf 91       	pop	r28
    3bd2:	08 95       	ret

00003bd4 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    3bd4:	dc 01       	movw	r26, r24
    3bd6:	ed 91       	ld	r30, X+
    3bd8:	fc 91       	ld	r31, X
    3bda:	02 80       	ldd	r0, Z+2	; 0x02
    3bdc:	f3 81       	ldd	r31, Z+3	; 0x03
    3bde:	e0 2d       	mov	r30, r0
    3be0:	6c e0       	ldi	r22, 0x0C	; 12
    3be2:	19 95       	eicall
    3be4:	08 95       	ret

00003be6 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3be6:	ef 92       	push	r14
    3be8:	ff 92       	push	r15
    3bea:	0f 93       	push	r16
    3bec:	1f 93       	push	r17
    3bee:	cf 93       	push	r28
    3bf0:	df 93       	push	r29
    3bf2:	ec 01       	movw	r28, r24
    3bf4:	7b 01       	movw	r14, r22
    3bf6:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3bf8:	0e 94 0b 1c 	call	0x3816	; 0x3816 <_ZN8emstreamC1Ev>
    3bfc:	a8 01       	movw	r20, r16
    3bfe:	b7 01       	movw	r22, r14
    3c00:	ce 01       	movw	r24, r28
    3c02:	08 96       	adiw	r24, 0x08	; 8
    3c04:	0e 94 6c 1b 	call	0x36d8	; 0x36d8 <_ZN7base232C1EjP12USART_struct>
    3c08:	87 ee       	ldi	r24, 0xE7	; 231
    3c0a:	90 e2       	ldi	r25, 0x20	; 32
    3c0c:	88 83       	st	Y, r24
    3c0e:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3c10:	00 3a       	cpi	r16, 0xA0	; 160
    3c12:	88 e0       	ldi	r24, 0x08	; 8
    3c14:	18 07       	cpc	r17, r24
    3c16:	69 f4       	brne	.+26     	; 0x3c32 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3c18:	80 ef       	ldi	r24, 0xF0	; 240
    3c1a:	91 e3       	ldi	r25, 0x31	; 49
    3c1c:	8f 8b       	std	Y+23, r24	; 0x17
    3c1e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3c20:	86 ee       	ldi	r24, 0xE6	; 230
    3c22:	91 e3       	ldi	r25, 0x31	; 49
    3c24:	89 8f       	std	Y+25, r24	; 0x19
    3c26:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3c28:	8c ed       	ldi	r24, 0xDC	; 220
    3c2a:	91 e3       	ldi	r25, 0x31	; 49
    3c2c:	8b 8f       	std	Y+27, r24	; 0x1b
    3c2e:	9c 8f       	std	Y+28, r25	; 0x1c
    3c30:	42 c0       	rjmp	.+132    	; 0x3cb6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3c32:	00 3b       	cpi	r16, 0xB0	; 176
    3c34:	e8 e0       	ldi	r30, 0x08	; 8
    3c36:	1e 07       	cpc	r17, r30
    3c38:	69 f4       	brne	.+26     	; 0x3c54 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3c3a:	8e ee       	ldi	r24, 0xEE	; 238
    3c3c:	91 e3       	ldi	r25, 0x31	; 49
    3c3e:	8f 8b       	std	Y+23, r24	; 0x17
    3c40:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3c42:	84 ee       	ldi	r24, 0xE4	; 228
    3c44:	91 e3       	ldi	r25, 0x31	; 49
    3c46:	89 8f       	std	Y+25, r24	; 0x19
    3c48:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3c4a:	8a ed       	ldi	r24, 0xDA	; 218
    3c4c:	91 e3       	ldi	r25, 0x31	; 49
    3c4e:	8b 8f       	std	Y+27, r24	; 0x1b
    3c50:	9c 8f       	std	Y+28, r25	; 0x1c
    3c52:	31 c0       	rjmp	.+98     	; 0x3cb6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3c54:	00 3a       	cpi	r16, 0xA0	; 160
    3c56:	f9 e0       	ldi	r31, 0x09	; 9
    3c58:	1f 07       	cpc	r17, r31
    3c5a:	69 f4       	brne	.+26     	; 0x3c76 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3c5c:	8c ee       	ldi	r24, 0xEC	; 236
    3c5e:	91 e3       	ldi	r25, 0x31	; 49
    3c60:	8f 8b       	std	Y+23, r24	; 0x17
    3c62:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3c64:	82 ee       	ldi	r24, 0xE2	; 226
    3c66:	91 e3       	ldi	r25, 0x31	; 49
    3c68:	89 8f       	std	Y+25, r24	; 0x19
    3c6a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3c6c:	88 ed       	ldi	r24, 0xD8	; 216
    3c6e:	91 e3       	ldi	r25, 0x31	; 49
    3c70:	8b 8f       	std	Y+27, r24	; 0x1b
    3c72:	9c 8f       	std	Y+28, r25	; 0x1c
    3c74:	20 c0       	rjmp	.+64     	; 0x3cb6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3c76:	00 3b       	cpi	r16, 0xB0	; 176
    3c78:	89 e0       	ldi	r24, 0x09	; 9
    3c7a:	18 07       	cpc	r17, r24
    3c7c:	69 f4       	brne	.+26     	; 0x3c98 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3c7e:	8a ee       	ldi	r24, 0xEA	; 234
    3c80:	91 e3       	ldi	r25, 0x31	; 49
    3c82:	8f 8b       	std	Y+23, r24	; 0x17
    3c84:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3c86:	80 ee       	ldi	r24, 0xE0	; 224
    3c88:	91 e3       	ldi	r25, 0x31	; 49
    3c8a:	89 8f       	std	Y+25, r24	; 0x19
    3c8c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3c8e:	86 ed       	ldi	r24, 0xD6	; 214
    3c90:	91 e3       	ldi	r25, 0x31	; 49
    3c92:	8b 8f       	std	Y+27, r24	; 0x1b
    3c94:	9c 8f       	std	Y+28, r25	; 0x1c
    3c96:	0f c0       	rjmp	.+30     	; 0x3cb6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3c98:	00 3a       	cpi	r16, 0xA0	; 160
    3c9a:	1a 40       	sbci	r17, 0x0A	; 10
    3c9c:	61 f4       	brne	.+24     	; 0x3cb6 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3c9e:	88 ee       	ldi	r24, 0xE8	; 232
    3ca0:	91 e3       	ldi	r25, 0x31	; 49
    3ca2:	8f 8b       	std	Y+23, r24	; 0x17
    3ca4:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3ca6:	8e ed       	ldi	r24, 0xDE	; 222
    3ca8:	91 e3       	ldi	r25, 0x31	; 49
    3caa:	89 8f       	std	Y+25, r24	; 0x19
    3cac:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3cae:	84 ed       	ldi	r24, 0xD4	; 212
    3cb0:	91 e3       	ldi	r25, 0x31	; 49
    3cb2:	8b 8f       	std	Y+27, r24	; 0x1b
    3cb4:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3cb6:	0f 89       	ldd	r16, Y+23	; 0x17
    3cb8:	18 8d       	ldd	r17, Y+24	; 0x18
    3cba:	84 e6       	ldi	r24, 0x64	; 100
    3cbc:	90 e0       	ldi	r25, 0x00	; 0
    3cbe:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <_Znaj>
    3cc2:	f8 01       	movw	r30, r16
    3cc4:	80 83       	st	Z, r24
    3cc6:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3cc8:	e9 8d       	ldd	r30, Y+25	; 0x19
    3cca:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3ccc:	10 82       	st	Z, r1
    3cce:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    3cd0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3cd2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3cd4:	10 82       	st	Z, r1
    3cd6:	11 82       	std	Z+1, r1	; 0x01
}
    3cd8:	df 91       	pop	r29
    3cda:	cf 91       	pop	r28
    3cdc:	1f 91       	pop	r17
    3cde:	0f 91       	pop	r16
    3ce0:	ff 90       	pop	r15
    3ce2:	ef 90       	pop	r14
    3ce4:	08 95       	ret

00003ce6 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3ce6:	1f 92       	push	r1
    3ce8:	0f 92       	push	r0
    3cea:	0f b6       	in	r0, 0x3f	; 63
    3cec:	0f 92       	push	r0
    3cee:	11 24       	eor	r1, r1
    3cf0:	08 b6       	in	r0, 0x38	; 56
    3cf2:	0f 92       	push	r0
    3cf4:	18 be       	out	0x38, r1	; 56
    3cf6:	0b b6       	in	r0, 0x3b	; 59
    3cf8:	0f 92       	push	r0
    3cfa:	1b be       	out	0x3b, r1	; 59
    3cfc:	2f 93       	push	r18
    3cfe:	3f 93       	push	r19
    3d00:	8f 93       	push	r24
    3d02:	9f 93       	push	r25
    3d04:	ef 93       	push	r30
    3d06:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3d08:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3d0c:	e0 91 f0 31 	lds	r30, 0x31F0	; 0x8031f0 <rcvC0_buffer>
    3d10:	f0 91 f1 31 	lds	r31, 0x31F1	; 0x8031f1 <rcvC0_buffer+0x1>
    3d14:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3d18:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3d1c:	e8 0f       	add	r30, r24
    3d1e:	f9 1f       	adc	r31, r25
    3d20:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3d22:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3d26:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3d2a:	01 96       	adiw	r24, 0x01	; 1
    3d2c:	84 36       	cpi	r24, 0x64	; 100
    3d2e:	91 05       	cpc	r25, r1
    3d30:	60 f4       	brcc	.+24     	; 0x3d4a <__vector_25+0x64>
    3d32:	80 93 dc 31 	sts	0x31DC, r24	; 0x8031dc <rcvC0_write_index>
    3d36:	90 93 dd 31 	sts	0x31DD, r25	; 0x8031dd <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d3a:	20 91 e6 31 	lds	r18, 0x31E6	; 0x8031e6 <rcvC0_read_index>
    3d3e:	30 91 e7 31 	lds	r19, 0x31E7	; 0x8031e7 <rcvC0_read_index+0x1>
    3d42:	82 17       	cp	r24, r18
    3d44:	93 07       	cpc	r25, r19
    3d46:	f1 f4       	brne	.+60     	; 0x3d84 <__vector_25+0x9e>
    3d48:	0c c0       	rjmp	.+24     	; 0x3d62 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3d4a:	10 92 dc 31 	sts	0x31DC, r1	; 0x8031dc <rcvC0_write_index>
    3d4e:	10 92 dd 31 	sts	0x31DD, r1	; 0x8031dd <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3d52:	80 91 e6 31 	lds	r24, 0x31E6	; 0x8031e6 <rcvC0_read_index>
    3d56:	90 91 e7 31 	lds	r25, 0x31E7	; 0x8031e7 <rcvC0_read_index+0x1>
    3d5a:	18 16       	cp	r1, r24
    3d5c:	19 06       	cpc	r1, r25
    3d5e:	91 f4       	brne	.+36     	; 0x3d84 <__vector_25+0x9e>
    3d60:	0e c0       	rjmp	.+28     	; 0x3d7e <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d62:	01 96       	adiw	r24, 0x01	; 1
    3d64:	84 36       	cpi	r24, 0x64	; 100
    3d66:	91 05       	cpc	r25, r1
    3d68:	28 f4       	brcc	.+10     	; 0x3d74 <__vector_25+0x8e>
    3d6a:	80 93 e6 31 	sts	0x31E6, r24	; 0x8031e6 <rcvC0_read_index>
    3d6e:	90 93 e7 31 	sts	0x31E7, r25	; 0x8031e7 <rcvC0_read_index+0x1>
    3d72:	08 c0       	rjmp	.+16     	; 0x3d84 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3d74:	10 92 e6 31 	sts	0x31E6, r1	; 0x8031e6 <rcvC0_read_index>
    3d78:	10 92 e7 31 	sts	0x31E7, r1	; 0x8031e7 <rcvC0_read_index+0x1>
}
    3d7c:	03 c0       	rjmp	.+6      	; 0x3d84 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3d7e:	81 e0       	ldi	r24, 0x01	; 1
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	f3 cf       	rjmp	.-26     	; 0x3d6a <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3d84:	ff 91       	pop	r31
    3d86:	ef 91       	pop	r30
    3d88:	9f 91       	pop	r25
    3d8a:	8f 91       	pop	r24
    3d8c:	3f 91       	pop	r19
    3d8e:	2f 91       	pop	r18
    3d90:	0f 90       	pop	r0
    3d92:	0b be       	out	0x3b, r0	; 59
    3d94:	0f 90       	pop	r0
    3d96:	08 be       	out	0x38, r0	; 56
    3d98:	0f 90       	pop	r0
    3d9a:	0f be       	out	0x3f, r0	; 63
    3d9c:	0f 90       	pop	r0
    3d9e:	1f 90       	pop	r1
    3da0:	18 95       	reti

00003da2 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3da2:	1f 92       	push	r1
    3da4:	0f 92       	push	r0
    3da6:	0f b6       	in	r0, 0x3f	; 63
    3da8:	0f 92       	push	r0
    3daa:	11 24       	eor	r1, r1
    3dac:	08 b6       	in	r0, 0x38	; 56
    3dae:	0f 92       	push	r0
    3db0:	18 be       	out	0x38, r1	; 56
    3db2:	0b b6       	in	r0, 0x3b	; 59
    3db4:	0f 92       	push	r0
    3db6:	1b be       	out	0x3b, r1	; 59
    3db8:	2f 93       	push	r18
    3dba:	3f 93       	push	r19
    3dbc:	8f 93       	push	r24
    3dbe:	9f 93       	push	r25
    3dc0:	ef 93       	push	r30
    3dc2:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    3dc4:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3dc8:	e0 91 ee 31 	lds	r30, 0x31EE	; 0x8031ee <rcvC1_buffer>
    3dcc:	f0 91 ef 31 	lds	r31, 0x31EF	; 0x8031ef <rcvC1_buffer+0x1>
    3dd0:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <rcvC1_write_index>
    3dd4:	90 91 db 31 	lds	r25, 0x31DB	; 0x8031db <rcvC1_write_index+0x1>
    3dd8:	e8 0f       	add	r30, r24
    3dda:	f9 1f       	adc	r31, r25
    3ddc:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3dde:	80 91 da 31 	lds	r24, 0x31DA	; 0x8031da <rcvC1_write_index>
    3de2:	90 91 db 31 	lds	r25, 0x31DB	; 0x8031db <rcvC1_write_index+0x1>
    3de6:	01 96       	adiw	r24, 0x01	; 1
    3de8:	84 36       	cpi	r24, 0x64	; 100
    3dea:	91 05       	cpc	r25, r1
    3dec:	60 f4       	brcc	.+24     	; 0x3e06 <__vector_28+0x64>
    3dee:	80 93 da 31 	sts	0x31DA, r24	; 0x8031da <rcvC1_write_index>
    3df2:	90 93 db 31 	sts	0x31DB, r25	; 0x8031db <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3df6:	20 91 e4 31 	lds	r18, 0x31E4	; 0x8031e4 <rcvC1_read_index>
    3dfa:	30 91 e5 31 	lds	r19, 0x31E5	; 0x8031e5 <rcvC1_read_index+0x1>
    3dfe:	82 17       	cp	r24, r18
    3e00:	93 07       	cpc	r25, r19
    3e02:	f1 f4       	brne	.+60     	; 0x3e40 <__vector_28+0x9e>
    3e04:	0c c0       	rjmp	.+24     	; 0x3e1e <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3e06:	10 92 da 31 	sts	0x31DA, r1	; 0x8031da <rcvC1_write_index>
    3e0a:	10 92 db 31 	sts	0x31DB, r1	; 0x8031db <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3e0e:	80 91 e4 31 	lds	r24, 0x31E4	; 0x8031e4 <rcvC1_read_index>
    3e12:	90 91 e5 31 	lds	r25, 0x31E5	; 0x8031e5 <rcvC1_read_index+0x1>
    3e16:	18 16       	cp	r1, r24
    3e18:	19 06       	cpc	r1, r25
    3e1a:	91 f4       	brne	.+36     	; 0x3e40 <__vector_28+0x9e>
    3e1c:	0e c0       	rjmp	.+28     	; 0x3e3a <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e1e:	01 96       	adiw	r24, 0x01	; 1
    3e20:	84 36       	cpi	r24, 0x64	; 100
    3e22:	91 05       	cpc	r25, r1
    3e24:	28 f4       	brcc	.+10     	; 0x3e30 <__vector_28+0x8e>
    3e26:	80 93 e4 31 	sts	0x31E4, r24	; 0x8031e4 <rcvC1_read_index>
    3e2a:	90 93 e5 31 	sts	0x31E5, r25	; 0x8031e5 <rcvC1_read_index+0x1>
    3e2e:	08 c0       	rjmp	.+16     	; 0x3e40 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3e30:	10 92 e4 31 	sts	0x31E4, r1	; 0x8031e4 <rcvC1_read_index>
    3e34:	10 92 e5 31 	sts	0x31E5, r1	; 0x8031e5 <rcvC1_read_index+0x1>
}
    3e38:	03 c0       	rjmp	.+6      	; 0x3e40 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3e3a:	81 e0       	ldi	r24, 0x01	; 1
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
    3e3e:	f3 cf       	rjmp	.-26     	; 0x3e26 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3e40:	ff 91       	pop	r31
    3e42:	ef 91       	pop	r30
    3e44:	9f 91       	pop	r25
    3e46:	8f 91       	pop	r24
    3e48:	3f 91       	pop	r19
    3e4a:	2f 91       	pop	r18
    3e4c:	0f 90       	pop	r0
    3e4e:	0b be       	out	0x3b, r0	; 59
    3e50:	0f 90       	pop	r0
    3e52:	08 be       	out	0x38, r0	; 56
    3e54:	0f 90       	pop	r0
    3e56:	0f be       	out	0x3f, r0	; 63
    3e58:	0f 90       	pop	r0
    3e5a:	1f 90       	pop	r1
    3e5c:	18 95       	reti

00003e5e <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3e5e:	1f 92       	push	r1
    3e60:	0f 92       	push	r0
    3e62:	0f b6       	in	r0, 0x3f	; 63
    3e64:	0f 92       	push	r0
    3e66:	11 24       	eor	r1, r1
    3e68:	08 b6       	in	r0, 0x38	; 56
    3e6a:	0f 92       	push	r0
    3e6c:	18 be       	out	0x38, r1	; 56
    3e6e:	0b b6       	in	r0, 0x3b	; 59
    3e70:	0f 92       	push	r0
    3e72:	1b be       	out	0x3b, r1	; 59
    3e74:	2f 93       	push	r18
    3e76:	3f 93       	push	r19
    3e78:	8f 93       	push	r24
    3e7a:	9f 93       	push	r25
    3e7c:	ef 93       	push	r30
    3e7e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3e80:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3e84:	e0 91 ec 31 	lds	r30, 0x31EC	; 0x8031ec <rcvD0_buffer>
    3e88:	f0 91 ed 31 	lds	r31, 0x31ED	; 0x8031ed <rcvD0_buffer+0x1>
    3e8c:	80 91 dc 31 	lds	r24, 0x31DC	; 0x8031dc <rcvC0_write_index>
    3e90:	90 91 dd 31 	lds	r25, 0x31DD	; 0x8031dd <rcvC0_write_index+0x1>
    3e94:	e8 0f       	add	r30, r24
    3e96:	f9 1f       	adc	r31, r25
    3e98:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3e9a:	80 91 d8 31 	lds	r24, 0x31D8	; 0x8031d8 <rcvD0_write_index>
    3e9e:	90 91 d9 31 	lds	r25, 0x31D9	; 0x8031d9 <rcvD0_write_index+0x1>
    3ea2:	01 96       	adiw	r24, 0x01	; 1
    3ea4:	84 36       	cpi	r24, 0x64	; 100
    3ea6:	91 05       	cpc	r25, r1
    3ea8:	60 f4       	brcc	.+24     	; 0x3ec2 <__vector_88+0x64>
    3eaa:	80 93 d8 31 	sts	0x31D8, r24	; 0x8031d8 <rcvD0_write_index>
    3eae:	90 93 d9 31 	sts	0x31D9, r25	; 0x8031d9 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3eb2:	20 91 e2 31 	lds	r18, 0x31E2	; 0x8031e2 <rcvD0_read_index>
    3eb6:	30 91 e3 31 	lds	r19, 0x31E3	; 0x8031e3 <rcvD0_read_index+0x1>
    3eba:	82 17       	cp	r24, r18
    3ebc:	93 07       	cpc	r25, r19
    3ebe:	f1 f4       	brne	.+60     	; 0x3efc <__vector_88+0x9e>
    3ec0:	0c c0       	rjmp	.+24     	; 0x3eda <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    3ec2:	10 92 d8 31 	sts	0x31D8, r1	; 0x8031d8 <rcvD0_write_index>
    3ec6:	10 92 d9 31 	sts	0x31D9, r1	; 0x8031d9 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3eca:	80 91 e2 31 	lds	r24, 0x31E2	; 0x8031e2 <rcvD0_read_index>
    3ece:	90 91 e3 31 	lds	r25, 0x31E3	; 0x8031e3 <rcvD0_read_index+0x1>
    3ed2:	18 16       	cp	r1, r24
    3ed4:	19 06       	cpc	r1, r25
    3ed6:	91 f4       	brne	.+36     	; 0x3efc <__vector_88+0x9e>
    3ed8:	0e c0       	rjmp	.+28     	; 0x3ef6 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3eda:	01 96       	adiw	r24, 0x01	; 1
    3edc:	84 36       	cpi	r24, 0x64	; 100
    3ede:	91 05       	cpc	r25, r1
    3ee0:	28 f4       	brcc	.+10     	; 0x3eec <__vector_88+0x8e>
    3ee2:	80 93 e2 31 	sts	0x31E2, r24	; 0x8031e2 <rcvD0_read_index>
    3ee6:	90 93 e3 31 	sts	0x31E3, r25	; 0x8031e3 <rcvD0_read_index+0x1>
    3eea:	08 c0       	rjmp	.+16     	; 0x3efc <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3eec:	10 92 e2 31 	sts	0x31E2, r1	; 0x8031e2 <rcvD0_read_index>
    3ef0:	10 92 e3 31 	sts	0x31E3, r1	; 0x8031e3 <rcvD0_read_index+0x1>
}
    3ef4:	03 c0       	rjmp	.+6      	; 0x3efc <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3ef6:	81 e0       	ldi	r24, 0x01	; 1
    3ef8:	90 e0       	ldi	r25, 0x00	; 0
    3efa:	f3 cf       	rjmp	.-26     	; 0x3ee2 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3efc:	ff 91       	pop	r31
    3efe:	ef 91       	pop	r30
    3f00:	9f 91       	pop	r25
    3f02:	8f 91       	pop	r24
    3f04:	3f 91       	pop	r19
    3f06:	2f 91       	pop	r18
    3f08:	0f 90       	pop	r0
    3f0a:	0b be       	out	0x3b, r0	; 59
    3f0c:	0f 90       	pop	r0
    3f0e:	08 be       	out	0x38, r0	; 56
    3f10:	0f 90       	pop	r0
    3f12:	0f be       	out	0x3f, r0	; 63
    3f14:	0f 90       	pop	r0
    3f16:	1f 90       	pop	r1
    3f18:	18 95       	reti

00003f1a <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3f1a:	1f 92       	push	r1
    3f1c:	0f 92       	push	r0
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	0f 92       	push	r0
    3f22:	11 24       	eor	r1, r1
    3f24:	08 b6       	in	r0, 0x38	; 56
    3f26:	0f 92       	push	r0
    3f28:	18 be       	out	0x38, r1	; 56
    3f2a:	0b b6       	in	r0, 0x3b	; 59
    3f2c:	0f 92       	push	r0
    3f2e:	1b be       	out	0x3b, r1	; 59
    3f30:	2f 93       	push	r18
    3f32:	3f 93       	push	r19
    3f34:	8f 93       	push	r24
    3f36:	9f 93       	push	r25
    3f38:	ef 93       	push	r30
    3f3a:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3f3c:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3f40:	e0 91 ea 31 	lds	r30, 0x31EA	; 0x8031ea <rcvD1_buffer>
    3f44:	f0 91 eb 31 	lds	r31, 0x31EB	; 0x8031eb <rcvD1_buffer+0x1>
    3f48:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <rcvD1_write_index>
    3f4c:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <rcvD1_write_index+0x1>
    3f50:	e8 0f       	add	r30, r24
    3f52:	f9 1f       	adc	r31, r25
    3f54:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3f56:	80 91 d6 31 	lds	r24, 0x31D6	; 0x8031d6 <rcvD1_write_index>
    3f5a:	90 91 d7 31 	lds	r25, 0x31D7	; 0x8031d7 <rcvD1_write_index+0x1>
    3f5e:	01 96       	adiw	r24, 0x01	; 1
    3f60:	84 36       	cpi	r24, 0x64	; 100
    3f62:	91 05       	cpc	r25, r1
    3f64:	60 f4       	brcc	.+24     	; 0x3f7e <__vector_91+0x64>
    3f66:	80 93 d6 31 	sts	0x31D6, r24	; 0x8031d6 <rcvD1_write_index>
    3f6a:	90 93 d7 31 	sts	0x31D7, r25	; 0x8031d7 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3f6e:	20 91 e0 31 	lds	r18, 0x31E0	; 0x8031e0 <rcvD1_read_index>
    3f72:	30 91 e1 31 	lds	r19, 0x31E1	; 0x8031e1 <rcvD1_read_index+0x1>
    3f76:	82 17       	cp	r24, r18
    3f78:	93 07       	cpc	r25, r19
    3f7a:	f1 f4       	brne	.+60     	; 0x3fb8 <__vector_91+0x9e>
    3f7c:	0c c0       	rjmp	.+24     	; 0x3f96 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3f7e:	10 92 d6 31 	sts	0x31D6, r1	; 0x8031d6 <rcvD1_write_index>
    3f82:	10 92 d7 31 	sts	0x31D7, r1	; 0x8031d7 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3f86:	80 91 e0 31 	lds	r24, 0x31E0	; 0x8031e0 <rcvD1_read_index>
    3f8a:	90 91 e1 31 	lds	r25, 0x31E1	; 0x8031e1 <rcvD1_read_index+0x1>
    3f8e:	18 16       	cp	r1, r24
    3f90:	19 06       	cpc	r1, r25
    3f92:	91 f4       	brne	.+36     	; 0x3fb8 <__vector_91+0x9e>
    3f94:	0e c0       	rjmp	.+28     	; 0x3fb2 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3f96:	01 96       	adiw	r24, 0x01	; 1
    3f98:	84 36       	cpi	r24, 0x64	; 100
    3f9a:	91 05       	cpc	r25, r1
    3f9c:	28 f4       	brcc	.+10     	; 0x3fa8 <__vector_91+0x8e>
    3f9e:	80 93 e0 31 	sts	0x31E0, r24	; 0x8031e0 <rcvD1_read_index>
    3fa2:	90 93 e1 31 	sts	0x31E1, r25	; 0x8031e1 <rcvD1_read_index+0x1>
    3fa6:	08 c0       	rjmp	.+16     	; 0x3fb8 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3fa8:	10 92 e0 31 	sts	0x31E0, r1	; 0x8031e0 <rcvD1_read_index>
    3fac:	10 92 e1 31 	sts	0x31E1, r1	; 0x8031e1 <rcvD1_read_index+0x1>
}
    3fb0:	03 c0       	rjmp	.+6      	; 0x3fb8 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3fb2:	81 e0       	ldi	r24, 0x01	; 1
    3fb4:	90 e0       	ldi	r25, 0x00	; 0
    3fb6:	f3 cf       	rjmp	.-26     	; 0x3f9e <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3fb8:	ff 91       	pop	r31
    3fba:	ef 91       	pop	r30
    3fbc:	9f 91       	pop	r25
    3fbe:	8f 91       	pop	r24
    3fc0:	3f 91       	pop	r19
    3fc2:	2f 91       	pop	r18
    3fc4:	0f 90       	pop	r0
    3fc6:	0b be       	out	0x3b, r0	; 59
    3fc8:	0f 90       	pop	r0
    3fca:	08 be       	out	0x38, r0	; 56
    3fcc:	0f 90       	pop	r0
    3fce:	0f be       	out	0x3f, r0	; 63
    3fd0:	0f 90       	pop	r0
    3fd2:	1f 90       	pop	r1
    3fd4:	18 95       	reti

00003fd6 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3fd6:	1f 92       	push	r1
    3fd8:	0f 92       	push	r0
    3fda:	0f b6       	in	r0, 0x3f	; 63
    3fdc:	0f 92       	push	r0
    3fde:	11 24       	eor	r1, r1
    3fe0:	08 b6       	in	r0, 0x38	; 56
    3fe2:	0f 92       	push	r0
    3fe4:	18 be       	out	0x38, r1	; 56
    3fe6:	0b b6       	in	r0, 0x3b	; 59
    3fe8:	0f 92       	push	r0
    3fea:	1b be       	out	0x3b, r1	; 59
    3fec:	2f 93       	push	r18
    3fee:	3f 93       	push	r19
    3ff0:	8f 93       	push	r24
    3ff2:	9f 93       	push	r25
    3ff4:	ef 93       	push	r30
    3ff6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3ff8:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3ffc:	e0 91 e8 31 	lds	r30, 0x31E8	; 0x8031e8 <rcvE0_buffer>
    4000:	f0 91 e9 31 	lds	r31, 0x31E9	; 0x8031e9 <rcvE0_buffer+0x1>
    4004:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <rcvE0_write_index>
    4008:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <rcvE0_write_index+0x1>
    400c:	e8 0f       	add	r30, r24
    400e:	f9 1f       	adc	r31, r25
    4010:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    4012:	80 91 d4 31 	lds	r24, 0x31D4	; 0x8031d4 <rcvE0_write_index>
    4016:	90 91 d5 31 	lds	r25, 0x31D5	; 0x8031d5 <rcvE0_write_index+0x1>
    401a:	01 96       	adiw	r24, 0x01	; 1
    401c:	84 36       	cpi	r24, 0x64	; 100
    401e:	91 05       	cpc	r25, r1
    4020:	60 f4       	brcc	.+24     	; 0x403a <__stack+0x3b>
    4022:	80 93 d4 31 	sts	0x31D4, r24	; 0x8031d4 <rcvE0_write_index>
    4026:	90 93 d5 31 	sts	0x31D5, r25	; 0x8031d5 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    402a:	20 91 de 31 	lds	r18, 0x31DE	; 0x8031de <rcvE0_read_index>
    402e:	30 91 df 31 	lds	r19, 0x31DF	; 0x8031df <rcvE0_read_index+0x1>
    4032:	82 17       	cp	r24, r18
    4034:	93 07       	cpc	r25, r19
    4036:	f1 f4       	brne	.+60     	; 0x4074 <__stack+0x75>
    4038:	0c c0       	rjmp	.+24     	; 0x4052 <__stack+0x53>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    403a:	10 92 d4 31 	sts	0x31D4, r1	; 0x8031d4 <rcvE0_write_index>
    403e:	10 92 d5 31 	sts	0x31D5, r1	; 0x8031d5 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    4042:	80 91 de 31 	lds	r24, 0x31DE	; 0x8031de <rcvE0_read_index>
    4046:	90 91 df 31 	lds	r25, 0x31DF	; 0x8031df <rcvE0_read_index+0x1>
    404a:	18 16       	cp	r1, r24
    404c:	19 06       	cpc	r1, r25
    404e:	91 f4       	brne	.+36     	; 0x4074 <__stack+0x75>
    4050:	0e c0       	rjmp	.+28     	; 0x406e <__stack+0x6f>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    4052:	01 96       	adiw	r24, 0x01	; 1
    4054:	84 36       	cpi	r24, 0x64	; 100
    4056:	91 05       	cpc	r25, r1
    4058:	28 f4       	brcc	.+10     	; 0x4064 <__stack+0x65>
    405a:	80 93 de 31 	sts	0x31DE, r24	; 0x8031de <rcvE0_read_index>
    405e:	90 93 df 31 	sts	0x31DF, r25	; 0x8031df <rcvE0_read_index+0x1>
    4062:	08 c0       	rjmp	.+16     	; 0x4074 <__stack+0x75>
	rcvE0_read_index = 0;
    4064:	10 92 de 31 	sts	0x31DE, r1	; 0x8031de <rcvE0_read_index>
    4068:	10 92 df 31 	sts	0x31DF, r1	; 0x8031df <rcvE0_read_index+0x1>
}
    406c:	03 c0       	rjmp	.+6      	; 0x4074 <__stack+0x75>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    406e:	81 e0       	ldi	r24, 0x01	; 1
    4070:	90 e0       	ldi	r25, 0x00	; 0
    4072:	f3 cf       	rjmp	.-26     	; 0x405a <__stack+0x5b>
	rcvE0_read_index = 0;
}
    4074:	ff 91       	pop	r31
    4076:	ef 91       	pop	r30
    4078:	9f 91       	pop	r25
    407a:	8f 91       	pop	r24
    407c:	3f 91       	pop	r19
    407e:	2f 91       	pop	r18
    4080:	0f 90       	pop	r0
    4082:	0b be       	out	0x3b, r0	; 59
    4084:	0f 90       	pop	r0
    4086:	08 be       	out	0x38, r0	; 56
    4088:	0f 90       	pop	r0
    408a:	0f be       	out	0x3f, r0	; 63
    408c:	0f 90       	pop	r0
    408e:	1f 90       	pop	r1
    4090:	18 95       	reti

00004092 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    4092:	fc 01       	movw	r30, r24
    4094:	84 81       	ldd	r24, Z+4	; 0x04
    4096:	95 81       	ldd	r25, Z+5	; 0x05
    4098:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
		}
    409c:	90 e0       	ldi	r25, 0x00	; 0
    409e:	08 95       	ret

000040a0 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    40a0:	fc 01       	movw	r30, r24
    40a2:	84 81       	ldd	r24, Z+4	; 0x04
    40a4:	95 81       	ldd	r25, Z+5	; 0x05
    40a6:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
    40aa:	91 e0       	ldi	r25, 0x01	; 1
    40ac:	81 11       	cpse	r24, r1
    40ae:	01 c0       	rjmp	.+2      	; 0x40b2 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    40b0:	90 e0       	ldi	r25, 0x00	; 0
		}
    40b2:	89 2f       	mov	r24, r25
    40b4:	08 95       	ret

000040b6 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    40b6:	fc 01       	movw	r30, r24
    40b8:	84 81       	ldd	r24, Z+4	; 0x04
    40ba:	95 81       	ldd	r25, Z+5	; 0x05
    40bc:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
    40c0:	91 e0       	ldi	r25, 0x01	; 1
    40c2:	81 11       	cpse	r24, r1
    40c4:	90 e0       	ldi	r25, 0x00	; 0
		}
    40c6:	89 2f       	mov	r24, r25
    40c8:	08 95       	ret

000040ca <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    40ca:	fc 01       	movw	r30, r24
    40cc:	84 81       	ldd	r24, Z+4	; 0x04
    40ce:	95 81       	ldd	r25, Z+5	; 0x05
    40d0:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
		}
    40d4:	90 e0       	ldi	r25, 0x00	; 0
    40d6:	08 95       	ret

000040d8 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    40d8:	fc 01       	movw	r30, r24
    40da:	84 81       	ldd	r24, Z+4	; 0x04
    40dc:	95 81       	ldd	r25, Z+5	; 0x05
    40de:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
    40e2:	91 e0       	ldi	r25, 0x01	; 1
    40e4:	81 11       	cpse	r24, r1
    40e6:	01 c0       	rjmp	.+2      	; 0x40ea <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    40e8:	90 e0       	ldi	r25, 0x00	; 0
		}
    40ea:	89 2f       	mov	r24, r25
    40ec:	08 95       	ret

000040ee <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    40ee:	fc 01       	movw	r30, r24
    40f0:	84 81       	ldd	r24, Z+4	; 0x04
    40f2:	95 81       	ldd	r25, Z+5	; 0x05
    40f4:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <uxQueueMessagesWaitingFromISR>
    40f8:	91 e0       	ldi	r25, 0x01	; 1
    40fa:	81 11       	cpse	r24, r1
    40fc:	90 e0       	ldi	r25, 0x00	; 0
		}
    40fe:	89 2f       	mov	r24, r25
    4100:	08 95       	ret

00004102 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    4102:	fc 01       	movw	r30, r24
    4104:	84 81       	ldd	r24, Z+4	; 0x04
    4106:	95 81       	ldd	r25, Z+5	; 0x05
    4108:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
		}
    410c:	90 e0       	ldi	r25, 0x00	; 0
    410e:	08 95       	ret

00004110 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4110:	fc 01       	movw	r30, r24
    4112:	84 81       	ldd	r24, Z+4	; 0x04
    4114:	95 81       	ldd	r25, Z+5	; 0x05
    4116:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
    411a:	91 e0       	ldi	r25, 0x01	; 1
    411c:	81 11       	cpse	r24, r1
    411e:	01 c0       	rjmp	.+2      	; 0x4122 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    4120:	90 e0       	ldi	r25, 0x00	; 0
		}
    4122:	89 2f       	mov	r24, r25
    4124:	08 95       	ret

00004126 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    4126:	fc 01       	movw	r30, r24
    4128:	84 81       	ldd	r24, Z+4	; 0x04
    412a:	95 81       	ldd	r25, Z+5	; 0x05
    412c:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
    4130:	91 e0       	ldi	r25, 0x01	; 1
    4132:	81 11       	cpse	r24, r1
    4134:	90 e0       	ldi	r25, 0x00	; 0
		}
    4136:	89 2f       	mov	r24, r25
    4138:	08 95       	ret

0000413a <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    413a:	fc 01       	movw	r30, r24
    413c:	84 81       	ldd	r24, Z+4	; 0x04
    413e:	95 81       	ldd	r25, Z+5	; 0x05
    4140:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
		}
    4144:	90 e0       	ldi	r25, 0x00	; 0
    4146:	08 95       	ret

00004148 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    4148:	fc 01       	movw	r30, r24
    414a:	84 81       	ldd	r24, Z+4	; 0x04
    414c:	95 81       	ldd	r25, Z+5	; 0x05
    414e:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
    4152:	91 e0       	ldi	r25, 0x01	; 1
    4154:	81 11       	cpse	r24, r1
    4156:	01 c0       	rjmp	.+2      	; 0x415a <_ZN9frt_queueIiE9not_emptyEv+0x12>
    4158:	90 e0       	ldi	r25, 0x00	; 0
		}
    415a:	89 2f       	mov	r24, r25
    415c:	08 95       	ret

0000415e <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    415e:	fc 01       	movw	r30, r24
    4160:	84 81       	ldd	r24, Z+4	; 0x04
    4162:	95 81       	ldd	r25, Z+5	; 0x05
    4164:	0e 94 73 11 	call	0x22e6	; 0x22e6 <uxQueueMessagesWaiting>
    4168:	91 e0       	ldi	r25, 0x01	; 1
    416a:	81 11       	cpse	r24, r1
    416c:	90 e0       	ldi	r25, 0x00	; 0
		}
    416e:	89 2f       	mov	r24, r25
    4170:	08 95       	ret

00004172 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    4172:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4174:	01 e0       	ldi	r16, 0x01	; 1
    4176:	2f ef       	ldi	r18, 0xFF	; 255
    4178:	3f ef       	ldi	r19, 0xFF	; 255
    417a:	a9 01       	movw	r20, r18
    417c:	fc 01       	movw	r30, r24
    417e:	84 81       	ldd	r24, Z+4	; 0x04
    4180:	95 81       	ldd	r25, Z+5	; 0x05
    4182:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
}
    4186:	0f 91       	pop	r16
    4188:	08 95       	ret

0000418a <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    418a:	0f 93       	push	r16
    418c:	cf 93       	push	r28
    418e:	df 93       	push	r29
    4190:	1f 92       	push	r1
    4192:	1f 92       	push	r1
    4194:	cd b7       	in	r28, 0x3d	; 61
    4196:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4198:	01 e0       	ldi	r16, 0x01	; 1
    419a:	2f ef       	ldi	r18, 0xFF	; 255
    419c:	3f ef       	ldi	r19, 0xFF	; 255
    419e:	a9 01       	movw	r20, r18
    41a0:	be 01       	movw	r22, r28
    41a2:	6f 5f       	subi	r22, 0xFF	; 255
    41a4:	7f 4f       	sbci	r23, 0xFF	; 255
    41a6:	fc 01       	movw	r30, r24
    41a8:	84 81       	ldd	r24, Z+4	; 0x04
    41aa:	95 81       	ldd	r25, Z+5	; 0x05
    41ac:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
	return (recv_item);
}
    41b0:	89 81       	ldd	r24, Y+1	; 0x01
    41b2:	9a 81       	ldd	r25, Y+2	; 0x02
    41b4:	0f 90       	pop	r0
    41b6:	0f 90       	pop	r0
    41b8:	df 91       	pop	r29
    41ba:	cf 91       	pop	r28
    41bc:	0f 91       	pop	r16
    41be:	08 95       	ret

000041c0 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    41c0:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    41c2:	00 e0       	ldi	r16, 0x00	; 0
    41c4:	2f ef       	ldi	r18, 0xFF	; 255
    41c6:	3f ef       	ldi	r19, 0xFF	; 255
    41c8:	a9 01       	movw	r20, r18
    41ca:	fc 01       	movw	r30, r24
    41cc:	84 81       	ldd	r24, Z+4	; 0x04
    41ce:	95 81       	ldd	r25, Z+5	; 0x05
    41d0:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
}
    41d4:	0f 91       	pop	r16
    41d6:	08 95       	ret

000041d8 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    41d8:	0f 93       	push	r16
    41da:	cf 93       	push	r28
    41dc:	df 93       	push	r29
    41de:	1f 92       	push	r1
    41e0:	1f 92       	push	r1
    41e2:	cd b7       	in	r28, 0x3d	; 61
    41e4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    41e6:	00 e0       	ldi	r16, 0x00	; 0
    41e8:	2f ef       	ldi	r18, 0xFF	; 255
    41ea:	3f ef       	ldi	r19, 0xFF	; 255
    41ec:	a9 01       	movw	r20, r18
    41ee:	be 01       	movw	r22, r28
    41f0:	6f 5f       	subi	r22, 0xFF	; 255
    41f2:	7f 4f       	sbci	r23, 0xFF	; 255
    41f4:	fc 01       	movw	r30, r24
    41f6:	84 81       	ldd	r24, Z+4	; 0x04
    41f8:	95 81       	ldd	r25, Z+5	; 0x05
    41fa:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
	return (recv_item);
}
    41fe:	89 81       	ldd	r24, Y+1	; 0x01
    4200:	9a 81       	ldd	r25, Y+2	; 0x02
    4202:	0f 90       	pop	r0
    4204:	0f 90       	pop	r0
    4206:	df 91       	pop	r29
    4208:	cf 91       	pop	r28
    420a:	0f 91       	pop	r16
    420c:	08 95       	ret

0000420e <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    420e:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    4210:	01 e0       	ldi	r16, 0x01	; 1
    4212:	2f ef       	ldi	r18, 0xFF	; 255
    4214:	3f ef       	ldi	r19, 0xFF	; 255
    4216:	a9 01       	movw	r20, r18
    4218:	fc 01       	movw	r30, r24
    421a:	84 81       	ldd	r24, Z+4	; 0x04
    421c:	95 81       	ldd	r25, Z+5	; 0x05
    421e:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
}
    4222:	0f 91       	pop	r16
    4224:	08 95       	ret

00004226 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    4226:	0f 93       	push	r16
    4228:	cf 93       	push	r28
    422a:	df 93       	push	r29
    422c:	1f 92       	push	r1
    422e:	1f 92       	push	r1
    4230:	cd b7       	in	r28, 0x3d	; 61
    4232:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    4234:	01 e0       	ldi	r16, 0x01	; 1
    4236:	2f ef       	ldi	r18, 0xFF	; 255
    4238:	3f ef       	ldi	r19, 0xFF	; 255
    423a:	a9 01       	movw	r20, r18
    423c:	be 01       	movw	r22, r28
    423e:	6f 5f       	subi	r22, 0xFF	; 255
    4240:	7f 4f       	sbci	r23, 0xFF	; 255
    4242:	fc 01       	movw	r30, r24
    4244:	84 81       	ldd	r24, Z+4	; 0x04
    4246:	95 81       	ldd	r25, Z+5	; 0x05
    4248:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
	return (recv_item);
}
    424c:	89 81       	ldd	r24, Y+1	; 0x01
    424e:	9a 81       	ldd	r25, Y+2	; 0x02
    4250:	0f 90       	pop	r0
    4252:	0f 90       	pop	r0
    4254:	df 91       	pop	r29
    4256:	cf 91       	pop	r28
    4258:	0f 91       	pop	r16
    425a:	08 95       	ret

0000425c <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    425c:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    425e:	00 e0       	ldi	r16, 0x00	; 0
    4260:	2f ef       	ldi	r18, 0xFF	; 255
    4262:	3f ef       	ldi	r19, 0xFF	; 255
    4264:	a9 01       	movw	r20, r18
    4266:	fc 01       	movw	r30, r24
    4268:	84 81       	ldd	r24, Z+4	; 0x04
    426a:	95 81       	ldd	r25, Z+5	; 0x05
    426c:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
}
    4270:	0f 91       	pop	r16
    4272:	08 95       	ret

00004274 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    4274:	0f 93       	push	r16
    4276:	cf 93       	push	r28
    4278:	df 93       	push	r29
    427a:	1f 92       	push	r1
    427c:	1f 92       	push	r1
    427e:	cd b7       	in	r28, 0x3d	; 61
    4280:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    4282:	00 e0       	ldi	r16, 0x00	; 0
    4284:	2f ef       	ldi	r18, 0xFF	; 255
    4286:	3f ef       	ldi	r19, 0xFF	; 255
    4288:	a9 01       	movw	r20, r18
    428a:	be 01       	movw	r22, r28
    428c:	6f 5f       	subi	r22, 0xFF	; 255
    428e:	7f 4f       	sbci	r23, 0xFF	; 255
    4290:	fc 01       	movw	r30, r24
    4292:	84 81       	ldd	r24, Z+4	; 0x04
    4294:	95 81       	ldd	r25, Z+5	; 0x05
    4296:	0e 94 82 10 	call	0x2104	; 0x2104 <xQueueGenericReceive>
	return (recv_item);
}
    429a:	89 81       	ldd	r24, Y+1	; 0x01
    429c:	9a 81       	ldd	r25, Y+2	; 0x02
    429e:	0f 90       	pop	r0
    42a0:	0f 90       	pop	r0
    42a2:	df 91       	pop	r29
    42a4:	cf 91       	pop	r28
    42a6:	0f 91       	pop	r16
    42a8:	08 95       	ret

000042aa <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    42aa:	cf 93       	push	r28
    42ac:	df 93       	push	r29
    42ae:	1f 92       	push	r1
    42b0:	cd b7       	in	r28, 0x3d	; 61
    42b2:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    42b4:	ae 01       	movw	r20, r28
    42b6:	4f 5f       	subi	r20, 0xFF	; 255
    42b8:	5f 4f       	sbci	r21, 0xFF	; 255
    42ba:	fc 01       	movw	r30, r24
    42bc:	84 81       	ldd	r24, Z+4	; 0x04
    42be:	95 81       	ldd	r25, Z+5	; 0x05
    42c0:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
}
    42c4:	0f 90       	pop	r0
    42c6:	df 91       	pop	r29
    42c8:	cf 91       	pop	r28
    42ca:	08 95       	ret

000042cc <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    42cc:	cf 93       	push	r28
    42ce:	df 93       	push	r29
    42d0:	00 d0       	rcall	.+0      	; 0x42d2 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    42d2:	cd b7       	in	r28, 0x3d	; 61
    42d4:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    42d6:	ae 01       	movw	r20, r28
    42d8:	4d 5f       	subi	r20, 0xFD	; 253
    42da:	5f 4f       	sbci	r21, 0xFF	; 255
    42dc:	be 01       	movw	r22, r28
    42de:	6f 5f       	subi	r22, 0xFF	; 255
    42e0:	7f 4f       	sbci	r23, 0xFF	; 255
    42e2:	fc 01       	movw	r30, r24
    42e4:	84 81       	ldd	r24, Z+4	; 0x04
    42e6:	95 81       	ldd	r25, Z+5	; 0x05
    42e8:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
	return (recv_item);
}
    42ec:	89 81       	ldd	r24, Y+1	; 0x01
    42ee:	9a 81       	ldd	r25, Y+2	; 0x02
    42f0:	23 96       	adiw	r28, 0x03	; 3
    42f2:	cd bf       	out	0x3d, r28	; 61
    42f4:	de bf       	out	0x3e, r29	; 62
    42f6:	df 91       	pop	r29
    42f8:	cf 91       	pop	r28
    42fa:	08 95       	ret

000042fc <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    42fc:	cf 93       	push	r28
    42fe:	df 93       	push	r29
    4300:	1f 92       	push	r1
    4302:	cd b7       	in	r28, 0x3d	; 61
    4304:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    4306:	ae 01       	movw	r20, r28
    4308:	4f 5f       	subi	r20, 0xFF	; 255
    430a:	5f 4f       	sbci	r21, 0xFF	; 255
    430c:	fc 01       	movw	r30, r24
    430e:	84 81       	ldd	r24, Z+4	; 0x04
    4310:	95 81       	ldd	r25, Z+5	; 0x05
    4312:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
}
    4316:	0f 90       	pop	r0
    4318:	df 91       	pop	r29
    431a:	cf 91       	pop	r28
    431c:	08 95       	ret

0000431e <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    431e:	cf 93       	push	r28
    4320:	df 93       	push	r29
    4322:	00 d0       	rcall	.+0      	; 0x4324 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    4324:	cd b7       	in	r28, 0x3d	; 61
    4326:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    4328:	ae 01       	movw	r20, r28
    432a:	4d 5f       	subi	r20, 0xFD	; 253
    432c:	5f 4f       	sbci	r21, 0xFF	; 255
    432e:	be 01       	movw	r22, r28
    4330:	6f 5f       	subi	r22, 0xFF	; 255
    4332:	7f 4f       	sbci	r23, 0xFF	; 255
    4334:	fc 01       	movw	r30, r24
    4336:	84 81       	ldd	r24, Z+4	; 0x04
    4338:	95 81       	ldd	r25, Z+5	; 0x05
    433a:	0e 94 46 11 	call	0x228c	; 0x228c <xQueueReceiveFromISR>
	return (recv_item);
}
    433e:	89 81       	ldd	r24, Y+1	; 0x01
    4340:	9a 81       	ldd	r25, Y+2	; 0x02
    4342:	23 96       	adiw	r28, 0x03	; 3
    4344:	cd bf       	out	0x3d, r28	; 61
    4346:	de bf       	out	0x3e, r29	; 62
    4348:	df 91       	pop	r29
    434a:	cf 91       	pop	r28
    434c:	08 95       	ret

0000434e <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    434e:	cf 93       	push	r28
    4350:	df 93       	push	r29
    4352:	1f 92       	push	r1
    4354:	cd b7       	in	r28, 0x3d	; 61
    4356:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4358:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    435a:	21 e0       	ldi	r18, 0x01	; 1
    435c:	ae 01       	movw	r20, r28
    435e:	4f 5f       	subi	r20, 0xFF	; 255
    4360:	5f 4f       	sbci	r21, 0xFF	; 255
    4362:	fc 01       	movw	r30, r24
    4364:	84 81       	ldd	r24, Z+4	; 0x04
    4366:	95 81       	ldd	r25, Z+5	; 0x05
    4368:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    436c:	91 e0       	ldi	r25, 0x01	; 1
    436e:	81 11       	cpse	r24, r1
    4370:	01 c0       	rjmp	.+2      	; 0x4374 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    4372:	90 e0       	ldi	r25, 0x00	; 0
}
    4374:	89 2f       	mov	r24, r25
    4376:	0f 90       	pop	r0
    4378:	df 91       	pop	r29
    437a:	cf 91       	pop	r28
    437c:	08 95       	ret

0000437e <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    437e:	cf 93       	push	r28
    4380:	df 93       	push	r29
    4382:	1f 92       	push	r1
    4384:	cd b7       	in	r28, 0x3d	; 61
    4386:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    4388:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    438a:	20 e0       	ldi	r18, 0x00	; 0
    438c:	ae 01       	movw	r20, r28
    438e:	4f 5f       	subi	r20, 0xFF	; 255
    4390:	5f 4f       	sbci	r21, 0xFF	; 255
    4392:	fc 01       	movw	r30, r24
    4394:	84 81       	ldd	r24, Z+4	; 0x04
    4396:	95 81       	ldd	r25, Z+5	; 0x05
    4398:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    439c:	91 e0       	ldi	r25, 0x01	; 1
    439e:	81 11       	cpse	r24, r1
    43a0:	01 c0       	rjmp	.+2      	; 0x43a4 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    43a2:	90 e0       	ldi	r25, 0x00	; 0
}
    43a4:	89 2f       	mov	r24, r25
    43a6:	0f 90       	pop	r0
    43a8:	df 91       	pop	r29
    43aa:	cf 91       	pop	r28
    43ac:	08 95       	ret

000043ae <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    43ae:	cf 93       	push	r28
    43b0:	df 93       	push	r29
    43b2:	1f 92       	push	r1
    43b4:	cd b7       	in	r28, 0x3d	; 61
    43b6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    43b8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    43ba:	21 e0       	ldi	r18, 0x01	; 1
    43bc:	ae 01       	movw	r20, r28
    43be:	4f 5f       	subi	r20, 0xFF	; 255
    43c0:	5f 4f       	sbci	r21, 0xFF	; 255
    43c2:	fc 01       	movw	r30, r24
    43c4:	84 81       	ldd	r24, Z+4	; 0x04
    43c6:	95 81       	ldd	r25, Z+5	; 0x05
    43c8:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    43cc:	91 e0       	ldi	r25, 0x01	; 1
    43ce:	81 11       	cpse	r24, r1
    43d0:	01 c0       	rjmp	.+2      	; 0x43d4 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    43d2:	90 e0       	ldi	r25, 0x00	; 0
}
    43d4:	89 2f       	mov	r24, r25
    43d6:	0f 90       	pop	r0
    43d8:	df 91       	pop	r29
    43da:	cf 91       	pop	r28
    43dc:	08 95       	ret

000043de <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    43de:	cf 93       	push	r28
    43e0:	df 93       	push	r29
    43e2:	1f 92       	push	r1
    43e4:	cd b7       	in	r28, 0x3d	; 61
    43e6:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    43e8:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    43ea:	20 e0       	ldi	r18, 0x00	; 0
    43ec:	ae 01       	movw	r20, r28
    43ee:	4f 5f       	subi	r20, 0xFF	; 255
    43f0:	5f 4f       	sbci	r21, 0xFF	; 255
    43f2:	fc 01       	movw	r30, r24
    43f4:	84 81       	ldd	r24, Z+4	; 0x04
    43f6:	95 81       	ldd	r25, Z+5	; 0x05
    43f8:	0e 94 56 10 	call	0x20ac	; 0x20ac <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    43fc:	91 e0       	ldi	r25, 0x01	; 1
    43fe:	81 11       	cpse	r24, r1
    4400:	01 c0       	rjmp	.+2      	; 0x4404 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    4402:	90 e0       	ldi	r25, 0x00	; 0
}
    4404:	89 2f       	mov	r24, r25
    4406:	0f 90       	pop	r0
    4408:	df 91       	pop	r29
    440a:	cf 91       	pop	r28
    440c:	08 95       	ret

0000440e <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    440e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4410:	fc 01       	movw	r30, r24
    4412:	26 81       	ldd	r18, Z+6	; 0x06
    4414:	37 81       	ldd	r19, Z+7	; 0x07
    4416:	40 85       	ldd	r20, Z+8	; 0x08
    4418:	51 85       	ldd	r21, Z+9	; 0x09
    441a:	01 e0       	ldi	r16, 0x01	; 1
    441c:	84 81       	ldd	r24, Z+4	; 0x04
    441e:	95 81       	ldd	r25, Z+5	; 0x05
    4420:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
    4424:	91 e0       	ldi	r25, 0x01	; 1
    4426:	81 11       	cpse	r24, r1
    4428:	01 c0       	rjmp	.+2      	; 0x442c <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    442a:	90 e0       	ldi	r25, 0x00	; 0
		}
    442c:	89 2f       	mov	r24, r25
    442e:	0f 91       	pop	r16
    4430:	08 95       	ret

00004432 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    4432:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    4434:	fc 01       	movw	r30, r24
    4436:	26 81       	ldd	r18, Z+6	; 0x06
    4438:	37 81       	ldd	r19, Z+7	; 0x07
    443a:	40 85       	ldd	r20, Z+8	; 0x08
    443c:	51 85       	ldd	r21, Z+9	; 0x09
    443e:	00 e0       	ldi	r16, 0x00	; 0
    4440:	84 81       	ldd	r24, Z+4	; 0x04
    4442:	95 81       	ldd	r25, Z+5	; 0x05
    4444:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
    4448:	91 e0       	ldi	r25, 0x01	; 1
    444a:	81 11       	cpse	r24, r1
    444c:	01 c0       	rjmp	.+2      	; 0x4450 <_ZN9frt_queueIjE3putERKj+0x1e>
    444e:	90 e0       	ldi	r25, 0x00	; 0
		}
    4450:	89 2f       	mov	r24, r25
    4452:	0f 91       	pop	r16
    4454:	08 95       	ret

00004456 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    4456:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    4458:	fc 01       	movw	r30, r24
    445a:	26 81       	ldd	r18, Z+6	; 0x06
    445c:	37 81       	ldd	r19, Z+7	; 0x07
    445e:	40 85       	ldd	r20, Z+8	; 0x08
    4460:	51 85       	ldd	r21, Z+9	; 0x09
    4462:	01 e0       	ldi	r16, 0x01	; 1
    4464:	84 81       	ldd	r24, Z+4	; 0x04
    4466:	95 81       	ldd	r25, Z+5	; 0x05
    4468:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
    446c:	91 e0       	ldi	r25, 0x01	; 1
    446e:	81 11       	cpse	r24, r1
    4470:	01 c0       	rjmp	.+2      	; 0x4474 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    4472:	90 e0       	ldi	r25, 0x00	; 0
		}
    4474:	89 2f       	mov	r24, r25
    4476:	0f 91       	pop	r16
    4478:	08 95       	ret

0000447a <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    447a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    447c:	fc 01       	movw	r30, r24
    447e:	26 81       	ldd	r18, Z+6	; 0x06
    4480:	37 81       	ldd	r19, Z+7	; 0x07
    4482:	40 85       	ldd	r20, Z+8	; 0x08
    4484:	51 85       	ldd	r21, Z+9	; 0x09
    4486:	00 e0       	ldi	r16, 0x00	; 0
    4488:	84 81       	ldd	r24, Z+4	; 0x04
    448a:	95 81       	ldd	r25, Z+5	; 0x05
    448c:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <xQueueGenericSend>
    4490:	91 e0       	ldi	r25, 0x01	; 1
    4492:	81 11       	cpse	r24, r1
    4494:	01 c0       	rjmp	.+2      	; 0x4498 <_ZN9frt_queueIiE3putERKi+0x1e>
    4496:	90 e0       	ldi	r25, 0x00	; 0
		}
    4498:	89 2f       	mov	r24, r25
    449a:	0f 91       	pop	r16
    449c:	08 95       	ret

0000449e <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    449e:	0f 93       	push	r16
    44a0:	cf 93       	push	r28
    44a2:	df 93       	push	r29
    44a4:	1f 92       	push	r1
    44a6:	cd b7       	in	r28, 0x3d	; 61
    44a8:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    44aa:	2f b7       	in	r18, 0x3f	; 63
    44ac:	29 83       	std	Y+1, r18	; 0x01
	cli();
    44ae:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    44b0:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    44b2:	fc 01       	movw	r30, r24
    44b4:	08 ed       	ldi	r16, 0xD8	; 216
    44b6:	04 bf       	out	0x34, r16	; 52
    44b8:	60 83       	st	Z, r22

	SREG = saved_sreg;
    44ba:	89 81       	ldd	r24, Y+1	; 0x01
    44bc:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    44be:	0f 90       	pop	r0
    44c0:	df 91       	pop	r29
    44c2:	cf 91       	pop	r28
    44c4:	0f 91       	pop	r16
    44c6:	08 95       	ret

000044c8 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    44c8:	ef 92       	push	r14
    44ca:	ff 92       	push	r15
    44cc:	0f 93       	push	r16
    44ce:	1f 93       	push	r17
    44d0:	cf 93       	push	r28
    44d2:	df 93       	push	r29
    44d4:	cd b7       	in	r28, 0x3d	; 61
    44d6:	de b7       	in	r29, 0x3e	; 62
    44d8:	c3 54       	subi	r28, 0x43	; 67
    44da:	d1 09       	sbc	r29, r1
    44dc:	cd bf       	out	0x3d, r28	; 61
    44de:	de bf       	out	0x3e, r29	; 62
	cli();
    44e0:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    44e2:	e0 e5       	ldi	r30, 0x50	; 80
    44e4:	f0 e0       	ldi	r31, 0x00	; 0
    44e6:	80 81       	ld	r24, Z
    44e8:	82 60       	ori	r24, 0x02	; 2
    44ea:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    44ec:	81 81       	ldd	r24, Z+1	; 0x01
    44ee:	81 ff       	sbrs	r24, 1
    44f0:	fd cf       	rjmp	.-6      	; 0x44ec <main+0x24>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    44f2:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    44f6:	68 7f       	andi	r22, 0xF8	; 248
    44f8:	61 60       	ori	r22, 0x01	; 1
    44fa:	80 e4       	ldi	r24, 0x40	; 64
    44fc:	90 e0       	ldi	r25, 0x00	; 0
    44fe:	0e 94 4f 22 	call	0x449e	; 0x449e <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    4502:	e0 e5       	ldi	r30, 0x50	; 80
    4504:	f0 e0       	ldi	r31, 0x00	; 0
    4506:	80 81       	ld	r24, Z
    4508:	8e 7f       	andi	r24, 0xFE	; 254
    450a:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    450c:	9d ef       	ldi	r25, 0xFD	; 253
    450e:	88 ed       	ldi	r24, 0xD8	; 216
    4510:	08 b6       	in	r0, 0x38	; 56
    4512:	18 be       	out	0x38, r1	; 56
    4514:	84 bf       	out	0x34, r24	; 52
    4516:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    451a:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    451c:	40 ea       	ldi	r20, 0xA0	; 160
    451e:	5a e0       	ldi	r21, 0x0A	; 10
    4520:	60 e0       	ldi	r22, 0x00	; 0
    4522:	70 e0       	ldi	r23, 0x00	; 0
    4524:	ce 01       	movw	r24, r28
    4526:	01 96       	adiw	r24, 0x01	; 1
    4528:	0e 94 f3 1d 	call	0x3be6	; 0x3be6 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    452c:	67 e0       	ldi	r22, 0x07	; 7
    452e:	ce 01       	movw	r24, r28
    4530:	01 96       	adiw	r24, 0x01	; 1
    4532:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    4536:	8c 01       	movw	r16, r24
    4538:	63 ef       	ldi	r22, 0xF3	; 243
    453a:	70 e2       	ldi	r23, 0x20	; 32
    453c:	0e 94 19 1c 	call	0x3832	; 0x3832 <_ZN8emstream4putsEPKc>
    4540:	66 e0       	ldi	r22, 0x06	; 6
    4542:	c8 01       	movw	r24, r16
    4544:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
    4548:	66 e0       	ldi	r22, 0x06	; 6
    454a:	0e 94 50 1c 	call	0x38a0	; 0x38a0 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c(&TWIE, 62000);
    454e:	20 e3       	ldi	r18, 0x30	; 48
    4550:	32 ef       	ldi	r19, 0xF2	; 242
    4552:	40 e0       	ldi	r20, 0x00	; 0
    4554:	50 e0       	ldi	r21, 0x00	; 0
    4556:	60 ea       	ldi	r22, 0xA0	; 160
    4558:	74 e0       	ldi	r23, 0x04	; 4
    455a:	ce 01       	movw	r24, r28
    455c:	4e 96       	adiw	r24, 0x1e	; 30
    455e:	0e 94 9f 06 	call	0xd3e	; 0xd3e <_ZN9I2CMasterC1EP10TWI_structm>

	// I2CAgent i2cAgent();
	
	MB1202 mb1202(&i2c);
    4562:	be 01       	movw	r22, r28
    4564:	62 5e       	subi	r22, 0xE2	; 226
    4566:	7f 4f       	sbci	r23, 0xFF	; 255
    4568:	ce 01       	movw	r24, r28
    456a:	c5 96       	adiw	r24, 0x35	; 53
    456c:	0e 94 05 08 	call	0x100a	; 0x100a <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    4570:	82 e1       	ldi	r24, 0x12	; 18
    4572:	90 e0       	ldi	r25, 0x00	; 0
    4574:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
    4578:	8e 01       	movw	r16, r28
    457a:	0f 5f       	subi	r16, 0xFF	; 255
    457c:	1f 4f       	sbci	r17, 0xFF	; 255
    457e:	20 e8       	ldi	r18, 0x80	; 128
    4580:	30 e0       	ldi	r19, 0x00	; 0
    4582:	40 e0       	ldi	r20, 0x00	; 0
    4584:	62 e1       	ldi	r22, 0x12	; 18
    4586:	71 e2       	ldi	r23, 0x21	; 33
    4588:	0e 94 37 09 	call	0x126e	; 0x126e <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    458c:	88 e1       	ldi	r24, 0x18	; 24
    458e:	90 e0       	ldi	r25, 0x00	; 0
    4590:	0e 94 65 1b 	call	0x36ca	; 0x36ca <_Znwj>
    4594:	9e 01       	movw	r18, r28
    4596:	2b 5c       	subi	r18, 0xCB	; 203
    4598:	3f 4f       	sbci	r19, 0xFF	; 255
    459a:	79 01       	movw	r14, r18
    459c:	20 e8       	ldi	r18, 0x80	; 128
    459e:	30 e0       	ldi	r19, 0x00	; 0
    45a0:	42 e0       	ldi	r20, 0x02	; 2
    45a2:	6a e1       	ldi	r22, 0x1A	; 26
    45a4:	71 e2       	ldi	r23, 0x21	; 33
    45a6:	0e 94 1a 09 	call	0x1234	; 0x1234 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    45aa:	87 e0       	ldi	r24, 0x07	; 7
    45ac:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    45b0:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    45b2:	0e 94 e4 12 	call	0x25c8	; 0x25c8 <vTaskStartScheduler>
}
    45b6:	80 e0       	ldi	r24, 0x00	; 0
    45b8:	90 e0       	ldi	r25, 0x00	; 0
    45ba:	cd 5b       	subi	r28, 0xBD	; 189
    45bc:	df 4f       	sbci	r29, 0xFF	; 255
    45be:	cd bf       	out	0x3d, r28	; 61
    45c0:	de bf       	out	0x3e, r29	; 62
    45c2:	df 91       	pop	r29
    45c4:	cf 91       	pop	r28
    45c6:	1f 91       	pop	r17
    45c8:	0f 91       	pop	r16
    45ca:	ff 90       	pop	r15
    45cc:	ef 90       	pop	r14
    45ce:	08 95       	ret

000045d0 <_GLOBAL__sub_I_counter>:
    45d0:	cf 92       	push	r12
    45d2:	df 92       	push	r13
    45d4:	ef 92       	push	r14
    45d6:	ff 92       	push	r15
    45d8:	0f 93       	push	r16
    45da:	1f 93       	push	r17
    45dc:	cf 93       	push	r28
    45de:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    45e0:	0a e0       	ldi	r16, 0x0A	; 10
    45e2:	10 e0       	ldi	r17, 0x00	; 0
    45e4:	20 e0       	ldi	r18, 0x00	; 0
    45e6:	30 e0       	ldi	r19, 0x00	; 0
    45e8:	40 e0       	ldi	r20, 0x00	; 0
    45ea:	50 e0       	ldi	r21, 0x00	; 0
    45ec:	60 e2       	ldi	r22, 0x20	; 32
    45ee:	70 e0       	ldi	r23, 0x00	; 0
    45f0:	84 e2       	ldi	r24, 0x24	; 36
    45f2:	92 e3       	ldi	r25, 0x32	; 50
    45f4:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    45f8:	ca e1       	ldi	r28, 0x1A	; 26
    45fa:	d2 e3       	ldi	r29, 0x32	; 50
    45fc:	1a 82       	std	Y+2, r1	; 0x02
    45fe:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4600:	84 e2       	ldi	r24, 0x24	; 36
    4602:	91 e2       	ldi	r25, 0x21	; 33
    4604:	88 83       	st	Y, r24
    4606:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4608:	40 e0       	ldi	r20, 0x00	; 0
    460a:	62 e0       	ldi	r22, 0x02	; 2
    460c:	8f ef       	ldi	r24, 0xFF	; 255
    460e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    4612:	8c 83       	std	Y+4, r24	; 0x04
    4614:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4616:	0f 2e       	mov	r0, r31
    4618:	fa e0       	ldi	r31, 0x0A	; 10
    461a:	cf 2e       	mov	r12, r31
    461c:	d1 2c       	mov	r13, r1
    461e:	e1 2c       	mov	r14, r1
    4620:	f1 2c       	mov	r15, r1
    4622:	f0 2d       	mov	r31, r0
    4624:	ce 82       	std	Y+6, r12	; 0x06
    4626:	df 82       	std	Y+7, r13	; 0x07
    4628:	e8 86       	std	Y+8, r14	; 0x08
    462a:	f9 86       	std	Y+9, r15	; 0x09
    462c:	c0 e1       	ldi	r28, 0x10	; 16
    462e:	d2 e3       	ldi	r29, 0x32	; 50
    4630:	1a 82       	std	Y+2, r1	; 0x02
    4632:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4634:	08 e4       	ldi	r16, 0x48	; 72
    4636:	11 e2       	ldi	r17, 0x21	; 33
    4638:	08 83       	st	Y, r16
    463a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    463c:	40 e0       	ldi	r20, 0x00	; 0
    463e:	62 e0       	ldi	r22, 0x02	; 2
    4640:	8f ef       	ldi	r24, 0xFF	; 255
    4642:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    4646:	8c 83       	std	Y+4, r24	; 0x04
    4648:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    464a:	ce 82       	std	Y+6, r12	; 0x06
    464c:	df 82       	std	Y+7, r13	; 0x07
    464e:	e8 86       	std	Y+8, r14	; 0x08
    4650:	f9 86       	std	Y+9, r15	; 0x09
    4652:	c6 e0       	ldi	r28, 0x06	; 6
    4654:	d2 e3       	ldi	r29, 0x32	; 50
    4656:	1a 82       	std	Y+2, r1	; 0x02
    4658:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    465a:	08 83       	st	Y, r16
    465c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    465e:	40 e0       	ldi	r20, 0x00	; 0
    4660:	62 e0       	ldi	r22, 0x02	; 2
    4662:	8f ef       	ldi	r24, 0xFF	; 255
    4664:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    4668:	8c 83       	std	Y+4, r24	; 0x04
    466a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    466c:	ce 82       	std	Y+6, r12	; 0x06
    466e:	df 82       	std	Y+7, r13	; 0x07
    4670:	e8 86       	std	Y+8, r14	; 0x08
    4672:	f9 86       	std	Y+9, r15	; 0x09
    4674:	cc ef       	ldi	r28, 0xFC	; 252
    4676:	d1 e3       	ldi	r29, 0x31	; 49
    4678:	1a 82       	std	Y+2, r1	; 0x02
    467a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    467c:	08 83       	st	Y, r16
    467e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4680:	40 e0       	ldi	r20, 0x00	; 0
    4682:	62 e0       	ldi	r22, 0x02	; 2
    4684:	8f ef       	ldi	r24, 0xFF	; 255
    4686:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    468a:	8c 83       	std	Y+4, r24	; 0x04
    468c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    468e:	ce 82       	std	Y+6, r12	; 0x06
    4690:	df 82       	std	Y+7, r13	; 0x07
    4692:	e8 86       	std	Y+8, r14	; 0x08
    4694:	f9 86       	std	Y+9, r15	; 0x09
    4696:	c2 ef       	ldi	r28, 0xF2	; 242
    4698:	d1 e3       	ldi	r29, 0x31	; 49
    469a:	1a 82       	std	Y+2, r1	; 0x02
    469c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    469e:	08 83       	st	Y, r16
    46a0:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    46a2:	40 e0       	ldi	r20, 0x00	; 0
    46a4:	62 e0       	ldi	r22, 0x02	; 2
    46a6:	8f ef       	ldi	r24, 0xFF	; 255
    46a8:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    46ac:	8c 83       	std	Y+4, r24	; 0x04
    46ae:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    46b0:	ce 82       	std	Y+6, r12	; 0x06
    46b2:	df 82       	std	Y+7, r13	; 0x07
    46b4:	e8 86       	std	Y+8, r14	; 0x08
    46b6:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    46b8:	df 91       	pop	r29
    46ba:	cf 91       	pop	r28
    46bc:	1f 91       	pop	r17
    46be:	0f 91       	pop	r16
    46c0:	ff 90       	pop	r15
    46c2:	ef 90       	pop	r14
    46c4:	df 90       	pop	r13
    46c6:	cf 90       	pop	r12
    46c8:	08 95       	ret

000046ca <__mulsi3>:
    46ca:	db 01       	movw	r26, r22
    46cc:	8f 93       	push	r24
    46ce:	9f 93       	push	r25
    46d0:	0e 94 bf 23 	call	0x477e	; 0x477e <__muluhisi3>
    46d4:	bf 91       	pop	r27
    46d6:	af 91       	pop	r26
    46d8:	a2 9f       	mul	r26, r18
    46da:	80 0d       	add	r24, r0
    46dc:	91 1d       	adc	r25, r1
    46de:	a3 9f       	mul	r26, r19
    46e0:	90 0d       	add	r25, r0
    46e2:	b2 9f       	mul	r27, r18
    46e4:	90 0d       	add	r25, r0
    46e6:	11 24       	eor	r1, r1
    46e8:	08 95       	ret

000046ea <__udivmodsi4>:
    46ea:	a1 e2       	ldi	r26, 0x21	; 33
    46ec:	1a 2e       	mov	r1, r26
    46ee:	aa 1b       	sub	r26, r26
    46f0:	bb 1b       	sub	r27, r27
    46f2:	fd 01       	movw	r30, r26
    46f4:	0d c0       	rjmp	.+26     	; 0x4710 <__udivmodsi4_ep>

000046f6 <__udivmodsi4_loop>:
    46f6:	aa 1f       	adc	r26, r26
    46f8:	bb 1f       	adc	r27, r27
    46fa:	ee 1f       	adc	r30, r30
    46fc:	ff 1f       	adc	r31, r31
    46fe:	a2 17       	cp	r26, r18
    4700:	b3 07       	cpc	r27, r19
    4702:	e4 07       	cpc	r30, r20
    4704:	f5 07       	cpc	r31, r21
    4706:	20 f0       	brcs	.+8      	; 0x4710 <__udivmodsi4_ep>
    4708:	a2 1b       	sub	r26, r18
    470a:	b3 0b       	sbc	r27, r19
    470c:	e4 0b       	sbc	r30, r20
    470e:	f5 0b       	sbc	r31, r21

00004710 <__udivmodsi4_ep>:
    4710:	66 1f       	adc	r22, r22
    4712:	77 1f       	adc	r23, r23
    4714:	88 1f       	adc	r24, r24
    4716:	99 1f       	adc	r25, r25
    4718:	1a 94       	dec	r1
    471a:	69 f7       	brne	.-38     	; 0x46f6 <__udivmodsi4_loop>
    471c:	60 95       	com	r22
    471e:	70 95       	com	r23
    4720:	80 95       	com	r24
    4722:	90 95       	com	r25
    4724:	9b 01       	movw	r18, r22
    4726:	ac 01       	movw	r20, r24
    4728:	bd 01       	movw	r22, r26
    472a:	cf 01       	movw	r24, r30
    472c:	08 95       	ret

0000472e <__divmodsi4>:
    472e:	05 2e       	mov	r0, r21
    4730:	97 fb       	bst	r25, 7
    4732:	1e f4       	brtc	.+6      	; 0x473a <__divmodsi4+0xc>
    4734:	00 94       	com	r0
    4736:	0e 94 ae 23 	call	0x475c	; 0x475c <__negsi2>
    473a:	57 fd       	sbrc	r21, 7
    473c:	07 d0       	rcall	.+14     	; 0x474c <__divmodsi4_neg2>
    473e:	0e 94 75 23 	call	0x46ea	; 0x46ea <__udivmodsi4>
    4742:	07 fc       	sbrc	r0, 7
    4744:	03 d0       	rcall	.+6      	; 0x474c <__divmodsi4_neg2>
    4746:	4e f4       	brtc	.+18     	; 0x475a <__divmodsi4_exit>
    4748:	0c 94 ae 23 	jmp	0x475c	; 0x475c <__negsi2>

0000474c <__divmodsi4_neg2>:
    474c:	50 95       	com	r21
    474e:	40 95       	com	r20
    4750:	30 95       	com	r19
    4752:	21 95       	neg	r18
    4754:	3f 4f       	sbci	r19, 0xFF	; 255
    4756:	4f 4f       	sbci	r20, 0xFF	; 255
    4758:	5f 4f       	sbci	r21, 0xFF	; 255

0000475a <__divmodsi4_exit>:
    475a:	08 95       	ret

0000475c <__negsi2>:
    475c:	90 95       	com	r25
    475e:	80 95       	com	r24
    4760:	70 95       	com	r23
    4762:	61 95       	neg	r22
    4764:	7f 4f       	sbci	r23, 0xFF	; 255
    4766:	8f 4f       	sbci	r24, 0xFF	; 255
    4768:	9f 4f       	sbci	r25, 0xFF	; 255
    476a:	08 95       	ret

0000476c <__tablejump2__>:
    476c:	ee 0f       	add	r30, r30
    476e:	ff 1f       	adc	r31, r31
    4770:	88 1f       	adc	r24, r24
    4772:	8b bf       	out	0x3b, r24	; 59
    4774:	07 90       	elpm	r0, Z+
    4776:	f6 91       	elpm	r31, Z
    4778:	e0 2d       	mov	r30, r0
    477a:	1b be       	out	0x3b, r1	; 59
    477c:	19 94       	eijmp

0000477e <__muluhisi3>:
    477e:	0e 94 ca 23 	call	0x4794	; 0x4794 <__umulhisi3>
    4782:	a5 9f       	mul	r26, r21
    4784:	90 0d       	add	r25, r0
    4786:	b4 9f       	mul	r27, r20
    4788:	90 0d       	add	r25, r0
    478a:	a4 9f       	mul	r26, r20
    478c:	80 0d       	add	r24, r0
    478e:	91 1d       	adc	r25, r1
    4790:	11 24       	eor	r1, r1
    4792:	08 95       	ret

00004794 <__umulhisi3>:
    4794:	a2 9f       	mul	r26, r18
    4796:	b0 01       	movw	r22, r0
    4798:	b3 9f       	mul	r27, r19
    479a:	c0 01       	movw	r24, r0
    479c:	a3 9f       	mul	r26, r19
    479e:	70 0d       	add	r23, r0
    47a0:	81 1d       	adc	r24, r1
    47a2:	11 24       	eor	r1, r1
    47a4:	91 1d       	adc	r25, r1
    47a6:	b2 9f       	mul	r27, r18
    47a8:	70 0d       	add	r23, r0
    47aa:	81 1d       	adc	r24, r1
    47ac:	11 24       	eor	r1, r1
    47ae:	91 1d       	adc	r25, r1
    47b0:	08 95       	ret

000047b2 <memcpy>:
    47b2:	fb 01       	movw	r30, r22
    47b4:	dc 01       	movw	r26, r24
    47b6:	02 c0       	rjmp	.+4      	; 0x47bc <memcpy+0xa>
    47b8:	01 90       	ld	r0, Z+
    47ba:	0d 92       	st	X+, r0
    47bc:	41 50       	subi	r20, 0x01	; 1
    47be:	50 40       	sbci	r21, 0x00	; 0
    47c0:	d8 f7       	brcc	.-10     	; 0x47b8 <memcpy+0x6>
    47c2:	08 95       	ret

000047c4 <memset>:
    47c4:	dc 01       	movw	r26, r24
    47c6:	01 c0       	rjmp	.+2      	; 0x47ca <memset+0x6>
    47c8:	6d 93       	st	X+, r22
    47ca:	41 50       	subi	r20, 0x01	; 1
    47cc:	50 40       	sbci	r21, 0x00	; 0
    47ce:	e0 f7       	brcc	.-8      	; 0x47c8 <memset+0x4>
    47d0:	08 95       	ret

000047d2 <strncpy>:
    47d2:	fb 01       	movw	r30, r22
    47d4:	dc 01       	movw	r26, r24
    47d6:	41 50       	subi	r20, 0x01	; 1
    47d8:	50 40       	sbci	r21, 0x00	; 0
    47da:	48 f0       	brcs	.+18     	; 0x47ee <strncpy+0x1c>
    47dc:	01 90       	ld	r0, Z+
    47de:	0d 92       	st	X+, r0
    47e0:	00 20       	and	r0, r0
    47e2:	c9 f7       	brne	.-14     	; 0x47d6 <strncpy+0x4>
    47e4:	01 c0       	rjmp	.+2      	; 0x47e8 <strncpy+0x16>
    47e6:	1d 92       	st	X+, r1
    47e8:	41 50       	subi	r20, 0x01	; 1
    47ea:	50 40       	sbci	r21, 0x00	; 0
    47ec:	e0 f7       	brcc	.-8      	; 0x47e6 <strncpy+0x14>
    47ee:	08 95       	ret

000047f0 <ultoa>:
    47f0:	25 32       	cpi	r18, 0x25	; 37
    47f2:	31 05       	cpc	r19, r1
    47f4:	20 f4       	brcc	.+8      	; 0x47fe <ultoa+0xe>
    47f6:	22 30       	cpi	r18, 0x02	; 2
    47f8:	10 f0       	brcs	.+4      	; 0x47fe <ultoa+0xe>
    47fa:	0c 94 03 24 	jmp	0x4806	; 0x4806 <__ultoa_ncheck>
    47fe:	fa 01       	movw	r30, r20
    4800:	10 82       	st	Z, r1
    4802:	ca 01       	movw	r24, r20
    4804:	08 95       	ret

00004806 <__ultoa_ncheck>:
    4806:	bb 27       	eor	r27, r27

00004808 <__ultoa_common>:
    4808:	fa 01       	movw	r30, r20
    480a:	a6 2f       	mov	r26, r22
    480c:	62 17       	cp	r22, r18
    480e:	71 05       	cpc	r23, r1
    4810:	81 05       	cpc	r24, r1
    4812:	91 05       	cpc	r25, r1
    4814:	33 0b       	sbc	r19, r19
    4816:	30 fb       	bst	r19, 0
    4818:	66 f0       	brts	.+24     	; 0x4832 <__ultoa_common+0x2a>
    481a:	aa 27       	eor	r26, r26
    481c:	66 0f       	add	r22, r22
    481e:	77 1f       	adc	r23, r23
    4820:	88 1f       	adc	r24, r24
    4822:	99 1f       	adc	r25, r25
    4824:	aa 1f       	adc	r26, r26
    4826:	a2 17       	cp	r26, r18
    4828:	10 f0       	brcs	.+4      	; 0x482e <__ultoa_common+0x26>
    482a:	a2 1b       	sub	r26, r18
    482c:	63 95       	inc	r22
    482e:	38 50       	subi	r19, 0x08	; 8
    4830:	a9 f7       	brne	.-22     	; 0x481c <__ultoa_common+0x14>
    4832:	a0 5d       	subi	r26, 0xD0	; 208
    4834:	aa 33       	cpi	r26, 0x3A	; 58
    4836:	08 f0       	brcs	.+2      	; 0x483a <__ultoa_common+0x32>
    4838:	a9 5d       	subi	r26, 0xD9	; 217
    483a:	a1 93       	st	Z+, r26
    483c:	36 f7       	brtc	.-52     	; 0x480a <__ultoa_common+0x2>
    483e:	b1 11       	cpse	r27, r1
    4840:	b1 93       	st	Z+, r27
    4842:	10 82       	st	Z, r1
    4844:	ca 01       	movw	r24, r20
    4846:	0c 94 4a 24 	jmp	0x4894	; 0x4894 <strrev>

0000484a <utoa>:
    484a:	45 32       	cpi	r20, 0x25	; 37
    484c:	51 05       	cpc	r21, r1
    484e:	20 f4       	brcc	.+8      	; 0x4858 <utoa+0xe>
    4850:	42 30       	cpi	r20, 0x02	; 2
    4852:	10 f0       	brcs	.+4      	; 0x4858 <utoa+0xe>
    4854:	0c 94 30 24 	jmp	0x4860	; 0x4860 <__utoa_ncheck>
    4858:	fb 01       	movw	r30, r22
    485a:	10 82       	st	Z, r1
    485c:	cb 01       	movw	r24, r22
    485e:	08 95       	ret

00004860 <__utoa_ncheck>:
    4860:	bb 27       	eor	r27, r27

00004862 <__utoa_common>:
    4862:	fb 01       	movw	r30, r22
    4864:	55 27       	eor	r21, r21
    4866:	aa 27       	eor	r26, r26
    4868:	88 0f       	add	r24, r24
    486a:	99 1f       	adc	r25, r25
    486c:	aa 1f       	adc	r26, r26
    486e:	a4 17       	cp	r26, r20
    4870:	10 f0       	brcs	.+4      	; 0x4876 <__utoa_common+0x14>
    4872:	a4 1b       	sub	r26, r20
    4874:	83 95       	inc	r24
    4876:	50 51       	subi	r21, 0x10	; 16
    4878:	b9 f7       	brne	.-18     	; 0x4868 <__utoa_common+0x6>
    487a:	a0 5d       	subi	r26, 0xD0	; 208
    487c:	aa 33       	cpi	r26, 0x3A	; 58
    487e:	08 f0       	brcs	.+2      	; 0x4882 <__utoa_common+0x20>
    4880:	a9 5d       	subi	r26, 0xD9	; 217
    4882:	a1 93       	st	Z+, r26
    4884:	00 97       	sbiw	r24, 0x00	; 0
    4886:	79 f7       	brne	.-34     	; 0x4866 <__utoa_common+0x4>
    4888:	b1 11       	cpse	r27, r1
    488a:	b1 93       	st	Z+, r27
    488c:	11 92       	st	Z+, r1
    488e:	cb 01       	movw	r24, r22
    4890:	0c 94 4a 24 	jmp	0x4894	; 0x4894 <strrev>

00004894 <strrev>:
    4894:	dc 01       	movw	r26, r24
    4896:	fc 01       	movw	r30, r24
    4898:	67 2f       	mov	r22, r23
    489a:	71 91       	ld	r23, Z+
    489c:	77 23       	and	r23, r23
    489e:	e1 f7       	brne	.-8      	; 0x4898 <strrev+0x4>
    48a0:	32 97       	sbiw	r30, 0x02	; 2
    48a2:	04 c0       	rjmp	.+8      	; 0x48ac <strrev+0x18>
    48a4:	7c 91       	ld	r23, X
    48a6:	6d 93       	st	X+, r22
    48a8:	70 83       	st	Z, r23
    48aa:	62 91       	ld	r22, -Z
    48ac:	ae 17       	cp	r26, r30
    48ae:	bf 07       	cpc	r27, r31
    48b0:	c8 f3       	brcs	.-14     	; 0x48a4 <strrev+0x10>
    48b2:	08 95       	ret

000048b4 <_exit>:
    48b4:	f8 94       	cli

000048b6 <__stop_program>:
    48b6:	ff cf       	rjmp	.-2      	; 0x48b6 <__stop_program>
