
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000041cc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e0  00802000  000041cc  00004260  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020e0  008020e0  00004340  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004340  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004370  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000808  00000000  00000000  000043b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012d60  00000000  00000000  00004bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006066  00000000  00000000  00017918  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000052bb  00000000  00000000  0001d97e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001764  00000000  00000000  00022c3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005f29  00000000  00000000  000243a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000071aa  00000000  00000000  0002a2c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000748  00000000  00000000  00031473  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ed 02 	jmp	0x5da	; 0x5da <__ctors_end>
       4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
       8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
       c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      10:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      14:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      18:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      1c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      20:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      24:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      28:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      2c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      30:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      34:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      38:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      3c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      40:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      44:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      48:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      4c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      50:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      54:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      58:	0c 94 2a 0b 	jmp	0x1654	; 0x1654 <__vector_22>
      5c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      60:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      64:	0c 94 ff 1a 	jmp	0x35fe	; 0x35fe <__vector_25>
      68:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      6c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      70:	0c 94 5d 1b 	jmp	0x36ba	; 0x36ba <__vector_28>
      74:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      78:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      7c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      80:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      84:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      88:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      8c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      90:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      94:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      98:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      9c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      ac:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      bc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      cc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      dc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e8:	0c 94 77 1c 	jmp	0x38ee	; 0x38ee <__vector_58>
      ec:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      fc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     100:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     104:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     108:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     10c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     110:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     114:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     118:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     11c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     120:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     124:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     128:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     12c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     130:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     134:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     138:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     13c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     140:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     144:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     148:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     14c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     150:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     154:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     158:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     15c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     160:	0c 94 bb 1b 	jmp	0x3776	; 0x3776 <__vector_88>
     164:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     168:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     16c:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <__vector_91>
     170:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     174:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     178:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     17c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     180:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     184:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     188:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     18c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     190:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     194:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     198:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     19c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1ac:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1bc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1cc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1dc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1ec:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1fc:	eb 18       	sub	r14, r11
     1fe:	ee 18       	sub	r14, r14
     200:	f1 18       	sub	r15, r1
     202:	f4 18       	sub	r15, r4
     204:	f7 18       	sub	r15, r7
     206:	fa 18       	sub	r15, r10
     208:	fc 18       	sub	r15, r12
     20a:	0d 19       	sub	r16, r13
     20c:	15 19       	sub	r17, r5
     20e:	1f 19       	sub	r17, r15
     210:	1d 19       	sub	r17, r13

00000212 <__trampolines_start>:
     212:	0c 94 14 1d 	jmp	0x3a28	; 0x3a28 <_ZN9frt_queueIjE9not_emptyEv>
     216:	0c 94 1f 19 	jmp	0x323e	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
     21a:	0c 94 06 07 	jmp	0xe0c	; 0xe0c <_ZN9task_user3runEv>
     21e:	0c 94 9f 1d 	jmp	0x3b3e	; 0x3b3e <_ZN9frt_queueIiE10get_a_copyEv>
     222:	0c 94 72 1f 	jmp	0x3ee4	; 0x3ee4 <_GLOBAL__sub_I_counter>
     226:	0c 94 96 18 	jmp	0x312c	; 0x312c <_ZN8emstream12clear_screenEv>
     22a:	0c 94 0d 1d 	jmp	0x3a1a	; 0x3a1a <_ZN9frt_queueIjE12num_items_inEv>
     22e:	0c 94 93 18 	jmp	0x3126	; 0x3126 <_ZN8emstream14check_for_charEv>
     232:	0c 94 0c 05 	jmp	0xa18	; 0xa18 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     236:	0c 94 3b 1d 	jmp	0x3a76	; 0x3a76 <_ZN9frt_queueIiE8is_emptyEv>
     23a:	0c 94 33 1e 	jmp	0x3c66	; 0x3c66 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     23e:	0c 94 a5 1e 	jmp	0x3d4a	; 0x3d4a <_ZN9frt_queueIjE3putERKj>
     242:	0c 94 0d 19 	jmp	0x321a	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x62>
     246:	0c 94 fc 18 	jmp	0x31f8	; 0x31f8 <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 68 05 	jmp	0xad0	; 0xad0 <_ZN10task_sonar3runEv>
     24e:	0c 94 8e 18 	jmp	0x311c	; 0x311c <_ZN8emstream13ready_to_sendEv>
     252:	0c 94 ea 02 	jmp	0x5d4	; 0x5d4 <_call_static_run_method>
     256:	0c 94 30 1d 	jmp	0x3a60	; 0x3a60 <_ZN9frt_queueIiE9not_emptyEv>
     25a:	0c 94 4b 1e 	jmp	0x3c96	; 0x3c96 <_ZN9frt_queueIjE7ISR_putERKj>
     25e:	0c 94 ee 18 	jmp	0x31dc	; 0x31dc <_ZN8emstreamlsE15ser_manipulator+0x24>
     262:	0c 94 b7 1e 	jmp	0x3d6e	; 0x3d6e <_ZN9frt_queueIiE7butt_inERKi>
     266:	0c 94 dc 1c 	jmp	0x39b8	; 0x39b8 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     26a:	0c 94 f7 18 	jmp	0x31ee	; 0x31ee <_ZN8emstreamlsE15ser_manipulator+0x36>
     26e:	0c 94 7b 1e 	jmp	0x3cf6	; 0x3cf6 <_ZN9frt_queueIiE7ISR_putERKi>
     272:	0c 94 03 1d 	jmp	0x3a06	; 0x3a06 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     276:	0c 94 f2 1d 	jmp	0x3be4	; 0x3be4 <_ZN9frt_queueIjE7ISR_getEv>
     27a:	0c 94 63 1e 	jmp	0x3cc6	; 0x3cc6 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     27e:	0c 94 6c 1d 	jmp	0x3ad8	; 0x3ad8 <_ZN9frt_queueIjE3getEPj>
     282:	0c 94 f7 17 	jmp	0x2fee	; 0x2fee <__cxa_pure_virtual>
     286:	0c 94 fa 18 	jmp	0x31f4	; 0x31f4 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     28a:	0c 94 34 16 	jmp	0x2c68	; 0x2c68 <_ZN14frt_text_queue14check_for_charEv>
     28e:	0c 94 eb 18 	jmp	0x31d6	; 0x31d6 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     292:	0c 94 cc 14 	jmp	0x2998	; 0x2998 <_ZN8frt_task12print_statusER8emstream>
     296:	0c 94 76 1a 	jmp	0x34ec	; 0x34ec <_ZN5rs23212clear_screenEv>
     29a:	0c 94 78 1d 	jmp	0x3af0	; 0x3af0 <_ZN9frt_queueIjE3getEv>
     29e:	0c 94 1d 19 	jmp	0x323a	; 0x323a <_ZN8emstreamlsE15ser_manipulator+0x82>
     2a2:	0c 94 c6 1d 	jmp	0x3b8c	; 0x3b8c <_ZN9frt_queueIiE3getEv>
     2a6:	0c 94 3d 03 	jmp	0x67a	; 0x67a <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>
     2aa:	0c 94 29 1d 	jmp	0x3a52	; 0x3a52 <_ZN9frt_queueIiE12num_items_inEv>
     2ae:	0c 94 f1 1c 	jmp	0x39e2	; 0x39e2 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2b2:	0c 94 45 1d 	jmp	0x3a8a	; 0x3a8a <_ZN9frt_queueIjE10get_a_copyERj>
     2b6:	0c 94 15 19 	jmp	0x322a	; 0x322a <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ba:	0c 94 19 1a 	jmp	0x3432	; 0x3432 <_ZN5rs2327putcharEc>
     2be:	0c 94 1b 1e 	jmp	0x3c36	; 0x3c36 <_ZN9frt_queueIiE7ISR_getEv>
     2c2:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <_ZN9frt_queueIjE12ISR_is_emptyEv>
     2c6:	0c 94 ba 1d 	jmp	0x3b74	; 0x3b74 <_ZN9frt_queueIiE3getEPi>
     2ca:	0c 94 25 03 	jmp	0x64a	; 0x64a <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>
     2ce:	0c 94 3f 16 	jmp	0x2c7e	; 0x2c7e <_ZN14frt_text_queue7putcharEc>
     2d2:	0c 94 0a 0e 	jmp	0x1c14	; 0x1c14 <prvIdleTask>
     2d6:	0c 94 51 1d 	jmp	0x3aa2	; 0x3aa2 <_ZN9frt_queueIjE10get_a_copyEv>
     2da:	0c 94 d5 1c 	jmp	0x39aa	; 0x39aa <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2de:	0c 94 16 16 	jmp	0x2c2c	; 0x2c2c <_ZN14frt_text_queue7getcharEv>
     2e2:	0c 94 93 1e 	jmp	0x3d26	; 0x3d26 <_ZN9frt_queueIjE7butt_inERKj>
     2e6:	0c 94 c9 1e 	jmp	0x3d92	; 0x3d92 <_ZN9frt_queueIiE3putERKi>
     2ea:	0c 94 93 1d 	jmp	0x3b26	; 0x3b26 <_ZN9frt_queueIiE10get_a_copyERi>
     2ee:	0c 94 95 18 	jmp	0x312a	; 0x312a <_ZN8emstream12transmit_nowEv>
     2f2:	0c 94 3d 1a 	jmp	0x347a	; 0x347a <_ZN5rs2327getcharEv>
     2f6:	0c 94 90 18 	jmp	0x3120	; 0x3120 <_ZN8emstream7getcharEv>
     2fa:	0c 94 0a 1e 	jmp	0x3c14	; 0x3c14 <_ZN9frt_queueIiE7ISR_getEPi>
     2fe:	0c 94 1f 1d 	jmp	0x3a3e	; 0x3a3e <_ZN9frt_queueIjE8is_emptyEv>
     302:	0c 94 f1 18 	jmp	0x31e2	; 0x31e2 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 e1 1d 	jmp	0x3bc2	; 0x3bc2 <_ZN9frt_queueIjE7ISR_getEPj>
     30a:	0c 94 6e 03 	jmp	0x6dc	; 0x6dc <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>
     30e:	0c 94 f8 1c 	jmp	0x39f0	; 0x39f0 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     312:	0c 94 f4 18 	jmp	0x31e8	; 0x31e8 <_ZN8emstreamlsE15ser_manipulator+0x30>
     316:	0c 94 63 1a 	jmp	0x34c6	; 0x34c6 <_ZN5rs23214check_for_charEv>

0000031a <__trampolines_end>:
     31a:	53 6f       	ori	r21, 0xF3	; 243
     31c:	6e 61       	ori	r22, 0x1E	; 30
     31e:	72 3a       	cpi	r23, 0xA2	; 162
     320:	20 00       	.word	0x0020	; ????

00000322 <_ZZN9task_user11show_statusEvE3__c_4>:
     322:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

0000032d <_ZZN9task_user11show_statusEvE3__c_3>:
     32d:	2f 00                                               /.

0000032f <_ZZN9task_user11show_statusEvE3__c_2>:
     32f:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

0000033d <_ZZN9task_user11show_statusEvE3__c_1>:
     33d:	54 69 6d 65 3a 20 00                                Time: .

00000344 <_ZZN9task_user11show_statusEvE3__c_0>:
     344:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

00000350 <_ZZN9task_user11show_statusEvE3__c>:
     350:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     360:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000036f <_ZZN9task_user18print_help_messageEvE3__c_10>:
     36f:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000037e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     37e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     38e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000399 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     399:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3a9:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003b7 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3b7:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3c7:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3d7:	6d 61 74 69 6f 6e 00                                mation.

000003de <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3de:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3ee:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003ff <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3ff:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     40f:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000417 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     417:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     427:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000433 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     433:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     443:	68 65 20 41 56 52 00                                he AVR.

0000044a <_ZZN9task_user18print_help_messageEvE3__c_2>:
     44a:	20 68 65 6c 70 00                                    help.

00000450 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     450:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     460:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000046f <_ZZN9task_user18print_help_messageEvE3__c_0>:
     46f:	1b 5b 33 30 6d 00                                   .[30m.

00000475 <_ZZN9task_user18print_help_messageEvE3__c>:
     475:	1b 5b 34 36 6d 00                                   .[46m.

0000047b <_ZZN9task_user3runEvE3__c_3>:
     47b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     48b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000498 <_ZZN9task_user3runEvE3__c_2>:
     498:	3a 57 54 46 3f 00                                   :WTF?.

0000049e <_ZZN9task_user3runEvE3__c_1>:
     49e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4ae:	65 00                                               e.

000004b0 <_ZZN9task_user3runEvE3__c_0>:
     4b0:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004be <_ZZN9task_user3runEvE3__c>:
     4be:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4ce:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004dc <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4dc:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004e6 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4e6:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004f5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4f5:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     505:	61 73 6b 20 00                                      ask .

0000050a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     50a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000518 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     518:	20 63 72 65 61 74 65 64 00                           created.

00000521 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     521:	54 61 73 6b 20 00                                   Task .

00000527 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     527:	1b 5b 32 32 6d 00                                   .[22m.

0000052d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     52d:	54 61 73 6b 3a 20 00                                Task: .

00000534 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     534:	1b 5b 31 6d 00                                      .[1m.

00000539 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     53f:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

0000054a <_ZZ17print_task_stacksP8emstreamE3__c>:
     54a:	1b 5b 31 6d 00                                      .[1m.

0000054f <_ZZ15print_task_listP8emstreamE3__c_9>:
     54f:	09 09 00                                            ...

00000552 <_ZZ15print_task_listP8emstreamE3__c_8>:
     552:	2f 00                                               /.

00000554 <_ZZ15print_task_listP8emstreamE3__c_7>:
     554:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000055f <_ZZ15print_task_listP8emstreamE3__c_6>:
     55f:	09 2d 2d 2d 2d 00                                   .----.

00000565 <_ZZ15print_task_listP8emstreamE3__c_5>:
     565:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000571 <_ZZ15print_task_listP8emstreamE3__c_4>:
     571:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000582 <_ZZ15print_task_listP8emstreamE3__c_3>:
     582:	09 52 75 6e 73 00                                   .Runs.

00000588 <_ZZ15print_task_listP8emstreamE3__c_2>:
     588:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000594 <_ZZ15print_task_listP8emstreamE3__c_1>:
     594:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005a5 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5a5:	09 53 74 61 63 6b 00                                .Stack.

000005ac <_ZZ15print_task_listP8emstreamE3__c>:
     5ac:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005b7 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5b7:	09 00                                               ..

000005b9 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5b9:	09 00                                               ..

000005bb <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5bb:	2f 00                                               /.

000005bd <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5bd:	09 00                                               ..

000005bf <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5bf:	09 00                                               ..

000005c1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5c1:	1b 5b 32 32 6d 00                                   .[22m.

000005c7 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5c7:	1b 5b 31 6d 00                                      .[1m.

000005cc <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5cc:	1b 5b 31 6d 00                                      .[1m.

000005d1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5d1:	20 20 00                                              .

000005d4 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5d4:	0e 94 64 13 	call	0x26c8	; 0x26c8 <_ZN8frt_task22_call_users_run_methodEPS_>

000005d8 <__ctors_start>:
     5d8:	72 1f       	adc	r23, r18

000005da <__ctors_end>:
     5da:	11 24       	eor	r1, r1
     5dc:	1f be       	out	0x3f, r1	; 63
     5de:	cf ef       	ldi	r28, 0xFF	; 255
     5e0:	cd bf       	out	0x3d, r28	; 61
     5e2:	df e3       	ldi	r29, 0x3F	; 63
     5e4:	de bf       	out	0x3e, r29	; 62
     5e6:	00 e0       	ldi	r16, 0x00	; 0
     5e8:	0c bf       	out	0x3c, r16	; 60
     5ea:	18 be       	out	0x38, r1	; 56
     5ec:	19 be       	out	0x39, r1	; 57
     5ee:	1a be       	out	0x3a, r1	; 58
     5f0:	1b be       	out	0x3b, r1	; 59

000005f2 <__do_copy_data>:
     5f2:	10 e2       	ldi	r17, 0x20	; 32
     5f4:	a0 e0       	ldi	r26, 0x00	; 0
     5f6:	b0 e2       	ldi	r27, 0x20	; 32
     5f8:	ec ec       	ldi	r30, 0xCC	; 204
     5fa:	f1 e4       	ldi	r31, 0x41	; 65
     5fc:	00 e0       	ldi	r16, 0x00	; 0
     5fe:	0b bf       	out	0x3b, r16	; 59
     600:	02 c0       	rjmp	.+4      	; 0x606 <__do_copy_data+0x14>
     602:	07 90       	elpm	r0, Z+
     604:	0d 92       	st	X+, r0
     606:	a0 3e       	cpi	r26, 0xE0	; 224
     608:	b1 07       	cpc	r27, r17
     60a:	d9 f7       	brne	.-10     	; 0x602 <__do_copy_data+0x10>
     60c:	1b be       	out	0x3b, r1	; 59

0000060e <__do_clear_bss>:
     60e:	21 e3       	ldi	r18, 0x31	; 49
     610:	a0 ee       	ldi	r26, 0xE0	; 224
     612:	b0 e2       	ldi	r27, 0x20	; 32
     614:	01 c0       	rjmp	.+2      	; 0x618 <.do_clear_bss_start>

00000616 <.do_clear_bss_loop>:
     616:	1d 92       	st	X+, r1

00000618 <.do_clear_bss_start>:
     618:	ae 3a       	cpi	r26, 0xAE	; 174
     61a:	b2 07       	cpc	r27, r18
     61c:	e1 f7       	brne	.-8      	; 0x616 <.do_clear_bss_loop>

0000061e <__do_global_ctors>:
     61e:	12 e0       	ldi	r17, 0x02	; 2
     620:	cd ee       	ldi	r28, 0xED	; 237
     622:	d2 e0       	ldi	r29, 0x02	; 2
     624:	00 e0       	ldi	r16, 0x00	; 0
     626:	06 c0       	rjmp	.+12     	; 0x634 <__do_global_ctors+0x16>
     628:	21 97       	sbiw	r28, 0x01	; 1
     62a:	01 09       	sbc	r16, r1
     62c:	80 2f       	mov	r24, r16
     62e:	fe 01       	movw	r30, r28
     630:	0e 94 40 20 	call	0x4080	; 0x4080 <__tablejump2__>
     634:	cc 3e       	cpi	r28, 0xEC	; 236
     636:	d1 07       	cpc	r29, r17
     638:	80 e0       	ldi	r24, 0x00	; 0
     63a:	08 07       	cpc	r16, r24
     63c:	a9 f7       	brne	.-22     	; 0x628 <__do_global_ctors+0xa>
     63e:	0e 94 f0 1e 	call	0x3de0	; 0x3de0 <main>
     642:	0c 94 e4 20 	jmp	0x41c8	; 0x41c8 <_exit>

00000646 <__bad_interrupt>:
     646:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000064a <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>:
	}
	else
	{
		return false;
	}
}
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	ec 01       	movw	r28, r24
     654:	cb 01       	movw	r24, r22
     656:	0e 81       	ldd	r16, Y+6	; 0x06
     658:	1f 81       	ldd	r17, Y+7	; 0x07
     65a:	db 01       	movw	r26, r22
     65c:	ed 91       	ld	r30, X+
     65e:	fc 91       	ld	r31, X
     660:	00 84       	ldd	r0, Z+8	; 0x08
     662:	f1 85       	ldd	r31, Z+9	; 0x09
     664:	e0 2d       	mov	r30, r0
     666:	19 95       	eicall
     668:	f8 01       	movw	r30, r16
     66a:	86 83       	std	Z+6, r24	; 0x06
     66c:	8a 81       	ldd	r24, Y+2	; 0x02
     66e:	9b 81       	ldd	r25, Y+3	; 0x03
     670:	df 91       	pop	r29
     672:	cf 91       	pop	r28
     674:	1f 91       	pop	r17
     676:	0f 91       	pop	r16
     678:	08 95       	ret

0000067a <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>:
     67a:	cf 93       	push	r28
     67c:	df 93       	push	r29
     67e:	1f 92       	push	r1
     680:	1f 92       	push	r1
     682:	cd b7       	in	r28, 0x3d	; 61
     684:	de b7       	in	r29, 0x3e	; 62
     686:	dc 01       	movw	r26, r24
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	8d 91       	ld	r24, X+
     68c:	9c 91       	ld	r25, X
     68e:	19 97       	sbiw	r26, 0x09	; 9
     690:	89 83       	std	Y+1, r24	; 0x01
     692:	9a 83       	std	Y+2, r25	; 0x02
     694:	29 81       	ldd	r18, Y+1	; 0x01
     696:	3a 81       	ldd	r19, Y+2	; 0x02
     698:	21 50       	subi	r18, 0x01	; 1
     69a:	31 09       	sbc	r19, r1
     69c:	29 83       	std	Y+1, r18	; 0x01
     69e:	3a 83       	std	Y+2, r19	; 0x02
     6a0:	23 2b       	or	r18, r19
     6a2:	91 f0       	breq	.+36     	; 0x6c8 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6a4:	16 96       	adiw	r26, 0x06	; 6
     6a6:	ed 91       	ld	r30, X+
     6a8:	fc 91       	ld	r31, X
     6aa:	17 97       	sbiw	r26, 0x07	; 7
     6ac:	94 81       	ldd	r25, Z+4	; 0x04
     6ae:	94 fd       	sbrc	r25, 4
     6b0:	f1 cf       	rjmp	.-30     	; 0x694 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x1a>
     6b2:	0a c0       	rjmp	.+20     	; 0x6c8 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6b4:	14 96       	adiw	r26, 0x04	; 4
     6b6:	8d 91       	ld	r24, X+
     6b8:	9c 91       	ld	r25, X
     6ba:	15 97       	sbiw	r26, 0x05	; 5
     6bc:	0a c0       	rjmp	.+20     	; 0x6d2 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6be:	12 96       	adiw	r26, 0x02	; 2
     6c0:	8d 91       	ld	r24, X+
     6c2:	9c 91       	ld	r25, X
     6c4:	13 97       	sbiw	r26, 0x03	; 3
     6c6:	05 c0       	rjmp	.+10     	; 0x6d2 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6c8:	29 81       	ldd	r18, Y+1	; 0x01
     6ca:	3a 81       	ldd	r19, Y+2	; 0x02
     6cc:	23 2b       	or	r18, r19
     6ce:	b9 f7       	brne	.-18     	; 0x6be <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x44>
     6d0:	f1 cf       	rjmp	.-30     	; 0x6b4 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x3a>
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>:
     6dc:	fc 01       	movw	r30, r24
     6de:	82 81       	ldd	r24, Z+2	; 0x02
     6e0:	93 81       	ldd	r25, Z+3	; 0x03
     6e2:	08 95       	ret

000006e4 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     6e4:	0f 93       	push	r16
     6e6:	1f 93       	push	r17
     6e8:	cf 93       	push	r28
     6ea:	df 93       	push	r29
     6ec:	ec 01       	movw	r28, r24
     6ee:	8b 01       	movw	r16, r22
     6f0:	88 e0       	ldi	r24, 0x08	; 8
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
     6f8:	2a e0       	ldi	r18, 0x0A	; 10
     6fa:	30 e2       	ldi	r19, 0x20	; 32
     6fc:	fc 01       	movw	r30, r24
     6fe:	20 83       	st	Z, r18
     700:	31 83       	std	Z+1, r19	; 0x01
     702:	06 83       	std	Z+6, r16	; 0x06
     704:	17 83       	std	Z+7, r17	; 0x07
     706:	8a 83       	std	Y+2, r24	; 0x02
     708:	9b 83       	std	Y+3, r25	; 0x03
     70a:	8a e0       	ldi	r24, 0x0A	; 10
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
     712:	fc 01       	movw	r30, r24
     714:	8d 85       	ldd	r24, Y+13	; 0x0d
     716:	9e 85       	ldd	r25, Y+14	; 0x0e
     718:	20 e1       	ldi	r18, 0x10	; 16
     71a:	30 e2       	ldi	r19, 0x20	; 32
     71c:	20 83       	st	Z, r18
     71e:	31 83       	std	Z+1, r19	; 0x01
     720:	06 83       	std	Z+6, r16	; 0x06
     722:	17 83       	std	Z+7, r17	; 0x07
     724:	80 87       	std	Z+8, r24	; 0x08
     726:	91 87       	std	Z+9, r25	; 0x09
     728:	ec 83       	std	Y+4, r30	; 0x04
     72a:	fd 83       	std	Y+5, r31	; 0x05
     72c:	88 e0       	ldi	r24, 0x08	; 8
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
     734:	26 e1       	ldi	r18, 0x16	; 22
     736:	30 e2       	ldi	r19, 0x20	; 32
     738:	fc 01       	movw	r30, r24
     73a:	20 83       	st	Z, r18
     73c:	31 83       	std	Z+1, r19	; 0x01
     73e:	06 83       	std	Z+6, r16	; 0x06
     740:	17 83       	std	Z+7, r17	; 0x07
     742:	88 87       	std	Y+8, r24	; 0x08
     744:	99 87       	std	Y+9, r25	; 0x09
     746:	80 e1       	ldi	r24, 0x10	; 16
     748:	97 e2       	ldi	r25, 0x27	; 39
     74a:	8d 87       	std	Y+13, r24	; 0x0d
     74c:	9e 87       	std	Y+14, r25	; 0x0e
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	1f 91       	pop	r17
     754:	0f 91       	pop	r16
     756:	08 95       	ret

00000758 <_ZN9I2CMaster12set_baudrateEm>:
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	9a 01       	movw	r18, r20
     760:	ab 01       	movw	r20, r22
     762:	22 0f       	add	r18, r18
     764:	33 1f       	adc	r19, r19
     766:	44 1f       	adc	r20, r20
     768:	55 1f       	adc	r21, r21
     76a:	60 e0       	ldi	r22, 0x00	; 0
     76c:	78 e4       	ldi	r23, 0x48	; 72
     76e:	88 ee       	ldi	r24, 0xE8	; 232
     770:	91 e0       	ldi	r25, 0x01	; 1
     772:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
     776:	25 50       	subi	r18, 0x05	; 5
     778:	2e 83       	std	Y+6, r18	; 0x06
     77a:	ea 81       	ldd	r30, Y+2	; 0x02
     77c:	fb 81       	ldd	r31, Y+3	; 0x03
     77e:	25 83       	std	Z+5, r18	; 0x05
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <_ZN9I2CMasterC1EP10TWI_structm>:
     786:	af 92       	push	r10
     788:	bf 92       	push	r11
     78a:	cf 92       	push	r12
     78c:	df 92       	push	r13
     78e:	ef 92       	push	r14
     790:	ff 92       	push	r15
     792:	0f 93       	push	r16
     794:	1f 93       	push	r17
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	8c 01       	movw	r16, r24
     79c:	eb 01       	movw	r28, r22
     79e:	69 01       	movw	r12, r18
     7a0:	7a 01       	movw	r14, r20
     7a2:	8f e0       	ldi	r24, 0x0F	; 15
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
     7aa:	5c 01       	movw	r10, r24
     7ac:	be 01       	movw	r22, r28
     7ae:	0e 94 72 03 	call	0x6e4	; 0x6e4 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     7b2:	d8 01       	movw	r26, r16
     7b4:	ad 92       	st	X+, r10
     7b6:	bc 92       	st	X, r11
     7b8:	11 97       	sbiw	r26, 0x01	; 1
     7ba:	12 96       	adiw	r26, 0x02	; 2
     7bc:	cd 93       	st	X+, r28
     7be:	dc 93       	st	X, r29
     7c0:	13 97       	sbiw	r26, 0x03	; 3
     7c2:	f8 01       	movw	r30, r16
     7c4:	c7 82       	std	Z+7, r12	; 0x07
     7c6:	d0 86       	std	Z+8, r13	; 0x08
     7c8:	e1 86       	std	Z+9, r14	; 0x09
     7ca:	f2 86       	std	Z+10, r15	; 0x0a
     7cc:	c0 38       	cpi	r28, 0x80	; 128
     7ce:	f4 e0       	ldi	r31, 0x04	; 4
     7d0:	df 07       	cpc	r29, r31
     7d2:	39 f4       	brne	.+14     	; 0x7e2 <_ZN9I2CMasterC1EP10TWI_structm+0x5c>
     7d4:	80 e4       	ldi	r24, 0x40	; 64
     7d6:	96 e0       	ldi	r25, 0x06	; 6
     7d8:	14 96       	adiw	r26, 0x04	; 4
     7da:	8d 93       	st	X+, r24
     7dc:	9c 93       	st	X, r25
     7de:	15 97       	sbiw	r26, 0x05	; 5
     7e0:	09 c0       	rjmp	.+18     	; 0x7f4 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
     7e2:	c0 3a       	cpi	r28, 0xA0	; 160
     7e4:	b4 e0       	ldi	r27, 0x04	; 4
     7e6:	db 07       	cpc	r29, r27
     7e8:	29 f4       	brne	.+10     	; 0x7f4 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
     7ea:	80 e8       	ldi	r24, 0x80	; 128
     7ec:	96 e0       	ldi	r25, 0x06	; 6
     7ee:	f8 01       	movw	r30, r16
     7f0:	84 83       	std	Z+4, r24	; 0x04
     7f2:	95 83       	std	Z+5, r25	; 0x05
     7f4:	d8 01       	movw	r26, r16
     7f6:	14 96       	adiw	r26, 0x04	; 4
     7f8:	ed 91       	ld	r30, X+
     7fa:	fc 91       	ld	r31, X
     7fc:	15 97       	sbiw	r26, 0x05	; 5
     7fe:	83 e0       	ldi	r24, 0x03	; 3
     800:	81 83       	std	Z+1, r24	; 0x01
     802:	14 96       	adiw	r26, 0x04	; 4
     804:	ed 91       	ld	r30, X+
     806:	fc 91       	ld	r31, X
     808:	15 97       	sbiw	r26, 0x05	; 5
     80a:	88 e3       	ldi	r24, 0x38	; 56
     80c:	80 8b       	std	Z+16, r24	; 0x10
     80e:	14 96       	adiw	r26, 0x04	; 4
     810:	ed 91       	ld	r30, X+
     812:	fc 91       	ld	r31, X
     814:	15 97       	sbiw	r26, 0x05	; 5
     816:	81 8b       	std	Z+17, r24	; 0x11
     818:	82 e0       	ldi	r24, 0x02	; 2
     81a:	8a 83       	std	Y+2, r24	; 0x02
     81c:	b7 01       	movw	r22, r14
     81e:	a6 01       	movw	r20, r12
     820:	c8 01       	movw	r24, r16
     822:	0e 94 ac 03 	call	0x758	; 0x758 <_ZN9I2CMaster12set_baudrateEm>
     826:	8c 81       	ldd	r24, Y+4	; 0x04
     828:	8d 6c       	ori	r24, 0xCD	; 205
     82a:	8c 83       	std	Y+4, r24	; 0x04
     82c:	88 e0       	ldi	r24, 0x08	; 8
     82e:	89 83       	std	Y+1, r24	; 0x01
     830:	df 91       	pop	r29
     832:	cf 91       	pop	r28
     834:	1f 91       	pop	r17
     836:	0f 91       	pop	r16
     838:	ff 90       	pop	r15
     83a:	ef 90       	pop	r14
     83c:	df 90       	pop	r13
     83e:	cf 90       	pop	r12
     840:	bf 90       	pop	r11
     842:	af 90       	pop	r10
     844:	08 95       	ret

00000846 <_ZN9I2CMaster5writeEhPhhj>:
     846:	0f 93       	push	r16
     848:	1f 93       	push	r17
     84a:	cf 93       	push	r28
     84c:	df 93       	push	r29
     84e:	1f 92       	push	r1
     850:	1f 92       	push	r1
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
     856:	dc 01       	movw	r26, r24
     858:	09 83       	std	Y+1, r16	; 0x01
     85a:	1a 83       	std	Y+2, r17	; 0x02
     85c:	12 96       	adiw	r26, 0x02	; 2
     85e:	ed 91       	ld	r30, X+
     860:	fc 91       	ld	r31, X
     862:	13 97       	sbiw	r26, 0x03	; 3
     864:	66 0f       	add	r22, r22
     866:	66 83       	std	Z+6, r22	; 0x06
     868:	89 81       	ldd	r24, Y+1	; 0x01
     86a:	9a 81       	ldd	r25, Y+2	; 0x02
     86c:	01 97       	sbiw	r24, 0x01	; 1
     86e:	89 83       	std	Y+1, r24	; 0x01
     870:	9a 83       	std	Y+2, r25	; 0x02
     872:	89 2b       	or	r24, r25
     874:	09 f4       	brne	.+2      	; 0x878 <_ZN9I2CMaster5writeEhPhhj+0x32>
     876:	40 c0       	rjmp	.+128    	; 0x8f8 <_ZN9I2CMaster5writeEhPhhj+0xb2>
     878:	12 96       	adiw	r26, 0x02	; 2
     87a:	ed 91       	ld	r30, X+
     87c:	fc 91       	ld	r31, X
     87e:	13 97       	sbiw	r26, 0x03	; 3
     880:	84 81       	ldd	r24, Z+4	; 0x04
     882:	86 ff       	sbrs	r24, 6
     884:	f1 cf       	rjmp	.-30     	; 0x868 <_ZN9I2CMaster5writeEhPhhj+0x22>
     886:	38 c0       	rjmp	.+112    	; 0x8f8 <_ZN9I2CMaster5writeEhPhhj+0xb2>
     888:	22 23       	and	r18, r18
     88a:	61 f1       	breq	.+88     	; 0x8e4 <_ZN9I2CMaster5writeEhPhhj+0x9e>
     88c:	ba 01       	movw	r22, r20
     88e:	21 50       	subi	r18, 0x01	; 1
     890:	82 2f       	mov	r24, r18
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	01 96       	adiw	r24, 0x01	; 1
     896:	48 0f       	add	r20, r24
     898:	59 1f       	adc	r21, r25
     89a:	09 83       	std	Y+1, r16	; 0x01
     89c:	1a 83       	std	Y+2, r17	; 0x02
     89e:	12 96       	adiw	r26, 0x02	; 2
     8a0:	2d 91       	ld	r18, X+
     8a2:	3c 91       	ld	r19, X
     8a4:	13 97       	sbiw	r26, 0x03	; 3
     8a6:	fb 01       	movw	r30, r22
     8a8:	81 91       	ld	r24, Z+
     8aa:	bf 01       	movw	r22, r30
     8ac:	f9 01       	movw	r30, r18
     8ae:	87 83       	std	Z+7, r24	; 0x07
     8b0:	29 81       	ldd	r18, Y+1	; 0x01
     8b2:	3a 81       	ldd	r19, Y+2	; 0x02
     8b4:	21 50       	subi	r18, 0x01	; 1
     8b6:	31 09       	sbc	r19, r1
     8b8:	29 83       	std	Y+1, r18	; 0x01
     8ba:	3a 83       	std	Y+2, r19	; 0x02
     8bc:	23 2b       	or	r18, r19
     8be:	11 f1       	breq	.+68     	; 0x904 <_ZN9I2CMaster5writeEhPhhj+0xbe>
     8c0:	12 96       	adiw	r26, 0x02	; 2
     8c2:	ed 91       	ld	r30, X+
     8c4:	fc 91       	ld	r31, X
     8c6:	13 97       	sbiw	r26, 0x03	; 3
     8c8:	94 81       	ldd	r25, Z+4	; 0x04
     8ca:	94 fd       	sbrc	r25, 4
     8cc:	f1 cf       	rjmp	.-30     	; 0x8b0 <_ZN9I2CMaster5writeEhPhhj+0x6a>
     8ce:	1a c0       	rjmp	.+52     	; 0x904 <_ZN9I2CMaster5writeEhPhhj+0xbe>
     8d0:	12 96       	adiw	r26, 0x02	; 2
     8d2:	ed 91       	ld	r30, X+
     8d4:	fc 91       	ld	r31, X
     8d6:	13 97       	sbiw	r26, 0x03	; 3
     8d8:	84 81       	ldd	r24, Z+4	; 0x04
     8da:	80 64       	ori	r24, 0x40	; 64
     8dc:	84 83       	std	Z+4, r24	; 0x04
     8de:	46 17       	cp	r20, r22
     8e0:	57 07       	cpc	r21, r23
     8e2:	d9 f6       	brne	.-74     	; 0x89a <_ZN9I2CMaster5writeEhPhhj+0x54>
     8e4:	12 96       	adiw	r26, 0x02	; 2
     8e6:	ed 91       	ld	r30, X+
     8e8:	fc 91       	ld	r31, X
     8ea:	13 97       	sbiw	r26, 0x03	; 3
     8ec:	83 e0       	ldi	r24, 0x03	; 3
     8ee:	83 83       	std	Z+3, r24	; 0x03
     8f0:	81 e0       	ldi	r24, 0x01	; 1
     8f2:	0d c0       	rjmp	.+26     	; 0x90e <_ZN9I2CMaster5writeEhPhhj+0xc8>
     8f4:	80 e0       	ldi	r24, 0x00	; 0
     8f6:	0b c0       	rjmp	.+22     	; 0x90e <_ZN9I2CMaster5writeEhPhhj+0xc8>
     8f8:	89 81       	ldd	r24, Y+1	; 0x01
     8fa:	9a 81       	ldd	r25, Y+2	; 0x02
     8fc:	89 2b       	or	r24, r25
     8fe:	21 f6       	brne	.-120    	; 0x888 <_ZN9I2CMaster5writeEhPhhj+0x42>
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	05 c0       	rjmp	.+10     	; 0x90e <_ZN9I2CMaster5writeEhPhhj+0xc8>
     904:	29 81       	ldd	r18, Y+1	; 0x01
     906:	3a 81       	ldd	r19, Y+2	; 0x02
     908:	23 2b       	or	r18, r19
     90a:	11 f7       	brne	.-60     	; 0x8d0 <_ZN9I2CMaster5writeEhPhhj+0x8a>
     90c:	f3 cf       	rjmp	.-26     	; 0x8f4 <_ZN9I2CMaster5writeEhPhhj+0xae>
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	df 91       	pop	r29
     914:	cf 91       	pop	r28
     916:	1f 91       	pop	r17
     918:	0f 91       	pop	r16
     91a:	08 95       	ret

0000091c <_ZN9I2CMaster4readEhPhhj>:

bool I2CMaster::read (uint8_t slave_addr, uint8_t* data, uint8_t packet_len, uint16_t timeout)
{
     91c:	0f 93       	push	r16
     91e:	1f 93       	push	r17
     920:	cf 93       	push	r28
     922:	df 93       	push	r29
     924:	00 d0       	rcall	.+0      	; 0x926 <_ZN9I2CMaster4readEhPhhj+0xa>
     926:	cd b7       	in	r28, 0x3d	; 61
     928:	de b7       	in	r29, 0x3e	; 62
     92a:	dc 01       	movw	r26, r24
	volatile uint16_t counter;
	volatile uint8_t i;
	counter = timeout;
     92c:	09 83       	std	Y+1, r16	; 0x01
     92e:	1a 83       	std	Y+2, r17	; 0x02
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
     930:	12 96       	adiw	r26, 0x02	; 2
     932:	ed 91       	ld	r30, X+
     934:	fc 91       	ld	r31, X
     936:	13 97       	sbiw	r26, 0x03	; 3
     938:	66 0f       	add	r22, r22
     93a:	61 60       	ori	r22, 0x01	; 1
     93c:	66 83       	std	Z+6, r22	; 0x06
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
     93e:	89 81       	ldd	r24, Y+1	; 0x01
     940:	9a 81       	ldd	r25, Y+2	; 0x02
     942:	01 97       	sbiw	r24, 0x01	; 1
     944:	89 83       	std	Y+1, r24	; 0x01
     946:	9a 83       	std	Y+2, r25	; 0x02
     948:	89 2b       	or	r24, r25
     94a:	09 f4       	brne	.+2      	; 0x94e <_ZN9I2CMaster4readEhPhhj+0x32>
     94c:	51 c0       	rjmp	.+162    	; 0x9f0 <_ZN9I2CMaster4readEhPhhj+0xd4>
     94e:	12 96       	adiw	r26, 0x02	; 2
     950:	ed 91       	ld	r30, X+
     952:	fc 91       	ld	r31, X
     954:	13 97       	sbiw	r26, 0x03	; 3
     956:	84 81       	ldd	r24, Z+4	; 0x04
     958:	88 23       	and	r24, r24
     95a:	8c f7       	brge	.-30     	; 0x93e <_ZN9I2CMaster4readEhPhhj+0x22>
     95c:	49 c0       	rjmp	.+146    	; 0x9f0 <_ZN9I2CMaster4readEhPhhj+0xd4>
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     95e:	1b 82       	std	Y+3, r1	; 0x03
     960:	8b 81       	ldd	r24, Y+3	; 0x03
     962:	82 17       	cp	r24, r18
     964:	08 f0       	brcs	.+2      	; 0x968 <_ZN9I2CMaster4readEhPhhj+0x4c>
     966:	43 c0       	rjmp	.+134    	; 0x9ee <_ZN9I2CMaster4readEhPhhj+0xd2>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     968:	32 e0       	ldi	r19, 0x02	; 2
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
     96a:	09 83       	std	Y+1, r16	; 0x01
     96c:	1a 83       	std	Y+2, r17	; 0x02
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
     96e:	69 81       	ldd	r22, Y+1	; 0x01
     970:	7a 81       	ldd	r23, Y+2	; 0x02
     972:	61 50       	subi	r22, 0x01	; 1
     974:	71 09       	sbc	r23, r1
     976:	69 83       	std	Y+1, r22	; 0x01
     978:	7a 83       	std	Y+2, r23	; 0x02
     97a:	67 2b       	or	r22, r23
     97c:	09 f4       	brne	.+2      	; 0x980 <_ZN9I2CMaster4readEhPhhj+0x64>
     97e:	3f c0       	rjmp	.+126    	; 0x9fe <_ZN9I2CMaster4readEhPhhj+0xe2>
     980:	12 96       	adiw	r26, 0x02	; 2
     982:	ed 91       	ld	r30, X+
     984:	fc 91       	ld	r31, X
     986:	13 97       	sbiw	r26, 0x03	; 3
     988:	94 81       	ldd	r25, Z+4	; 0x04
     98a:	99 23       	and	r25, r25
     98c:	84 f7       	brge	.-32     	; 0x96e <_ZN9I2CMaster4readEhPhhj+0x52>
     98e:	37 c0       	rjmp	.+110    	; 0x9fe <_ZN9I2CMaster4readEhPhhj+0xe2>
			if (counter != 0)
			{
				data[i] = interface->MASTER.DATA;
     990:	9b 81       	ldd	r25, Y+3	; 0x03
     992:	12 96       	adiw	r26, 0x02	; 2
     994:	ed 91       	ld	r30, X+
     996:	fc 91       	ld	r31, X
     998:	13 97       	sbiw	r26, 0x03	; 3
     99a:	87 81       	ldd	r24, Z+7	; 0x07
     99c:	fa 01       	movw	r30, r20
     99e:	e9 0f       	add	r30, r25
     9a0:	f1 1d       	adc	r31, r1
     9a2:	80 83       	st	Z, r24
				if (i < packet_len)
     9a4:	8b 81       	ldd	r24, Y+3	; 0x03
     9a6:	82 17       	cp	r24, r18
     9a8:	98 f4       	brcc	.+38     	; 0x9d0 <_ZN9I2CMaster4readEhPhhj+0xb4>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     9aa:	12 96       	adiw	r26, 0x02	; 2
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
     9b0:	13 97       	sbiw	r26, 0x03	; 3
     9b2:	33 83       	std	Z+3, r19	; 0x03
			{
				data[i] = interface->MASTER.DATA;
				if (i < packet_len)
				{
					byte_recv();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     9b4:	12 96       	adiw	r26, 0x02	; 2
     9b6:	ed 91       	ld	r30, X+
     9b8:	fc 91       	ld	r31, X
     9ba:	13 97       	sbiw	r26, 0x03	; 3
     9bc:	84 81       	ldd	r24, Z+4	; 0x04
     9be:	80 68       	ori	r24, 0x80	; 128
     9c0:	84 83       	std	Z+4, r24	; 0x04
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     9c2:	8b 81       	ldd	r24, Y+3	; 0x03
     9c4:	8f 5f       	subi	r24, 0xFF	; 255
     9c6:	8b 83       	std	Y+3, r24	; 0x03
     9c8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ca:	82 17       	cp	r24, r18
     9cc:	70 f2       	brcs	.-100    	; 0x96a <_ZN9I2CMaster4readEhPhhj+0x4e>
     9ce:	0f c0       	rjmp	.+30     	; 0x9ee <_ZN9I2CMaster4readEhPhhj+0xd2>
	interface->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
     9d0:	12 96       	adiw	r26, 0x02	; 2
     9d2:	ed 91       	ld	r30, X+
     9d4:	fc 91       	ld	r31, X
     9d6:	13 97       	sbiw	r26, 0x03	; 3
     9d8:	87 e0       	ldi	r24, 0x07	; 7
     9da:	83 83       	std	Z+3, r24	; 0x03
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
				}
				else
				{
					send_nack_stop();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     9dc:	12 96       	adiw	r26, 0x02	; 2
     9de:	ed 91       	ld	r30, X+
     9e0:	fc 91       	ld	r31, X
     9e2:	13 97       	sbiw	r26, 0x03	; 3
     9e4:	84 81       	ldd	r24, Z+4	; 0x04
     9e6:	80 68       	ori	r24, 0x80	; 128
     9e8:	84 83       	std	Z+4, r24	; 0x04
					return true;
     9ea:	81 e0       	ldi	r24, 0x01	; 1
     9ec:	0d c0       	rjmp	.+26     	; 0xa08 <_ZN9I2CMaster4readEhPhhj+0xec>
	}
	else
	{
		return false;
	}
}
     9ee:	0c c0       	rjmp	.+24     	; 0xa08 <_ZN9I2CMaster4readEhPhhj+0xec>
	counter = timeout;
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
     9f0:	89 81       	ldd	r24, Y+1	; 0x01
     9f2:	9a 81       	ldd	r25, Y+2	; 0x02
     9f4:	89 2b       	or	r24, r25
     9f6:	09 f0       	breq	.+2      	; 0x9fa <_ZN9I2CMaster4readEhPhhj+0xde>
     9f8:	b2 cf       	rjmp	.-156    	; 0x95e <_ZN9I2CMaster4readEhPhhj+0x42>
			}		
		}
	}
	else
	{
		return false;
     9fa:	80 e0       	ldi	r24, 0x00	; 0
     9fc:	05 c0       	rjmp	.+10     	; 0xa08 <_ZN9I2CMaster4readEhPhhj+0xec>
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
			if (counter != 0)
     9fe:	69 81       	ldd	r22, Y+1	; 0x01
     a00:	7a 81       	ldd	r23, Y+2	; 0x02
     a02:	67 2b       	or	r22, r23
     a04:	29 f6       	brne	.-118    	; 0x990 <_ZN9I2CMaster4readEhPhhj+0x74>
					return true;
				}
			}
			else
			{
				return false;
     a06:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return false;
	}
}
     a08:	23 96       	adiw	r28, 0x03	; 3
     a0a:	cd bf       	out	0x3d, r28	; 61
     a0c:	de bf       	out	0x3e, r29	; 62
     a0e:	df 91       	pop	r29
     a10:	cf 91       	pop	r28
     a12:	1f 91       	pop	r17
     a14:	0f 91       	pop	r16
     a16:	08 95       	ret

00000a18 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return i2c->is_ready(slave_addr);
};
     a18:	db 01       	movw	r26, r22
     a1a:	bc 01       	movw	r22, r24
     a1c:	6e 5f       	subi	r22, 0xFE	; 254
     a1e:	7f 4f       	sbci	r23, 0xFF	; 255
     a20:	ed 91       	ld	r30, X+
     a22:	fc 91       	ld	r31, X
     a24:	11 97       	sbiw	r26, 0x01	; 1
     a26:	01 90       	ld	r0, Z+
     a28:	f0 81       	ld	r31, Z
     a2a:	e0 2d       	mov	r30, r0
     a2c:	cd 01       	movw	r24, r26
     a2e:	19 95       	eicall
     a30:	08 95       	ret

00000a32 <_ZN6MB1202C1EP9I2CMaster>:
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	ec 01       	movw	r28, r24
     a38:	68 83       	st	Y, r22
     a3a:	79 83       	std	Y+1, r23	; 0x01
     a3c:	1c 82       	std	Y+4, r1	; 0x04
     a3e:	1d 82       	std	Y+5, r1	; 0x05
     a40:	1e 82       	std	Y+6, r1	; 0x06
     a42:	1f 82       	std	Y+7, r1	; 0x07
     a44:	18 86       	std	Y+8, r1	; 0x08
     a46:	83 e0       	ldi	r24, 0x03	; 3
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
     a4e:	2c e1       	ldi	r18, 0x1C	; 28
     a50:	30 e2       	ldi	r19, 0x20	; 32
     a52:	fc 01       	movw	r30, r24
     a54:	20 83       	st	Z, r18
     a56:	31 83       	std	Z+1, r19	; 0x01
     a58:	21 e5       	ldi	r18, 0x51	; 81
     a5a:	22 83       	std	Z+2, r18	; 0x02
     a5c:	8b 87       	std	Y+11, r24	; 0x0b
     a5e:	9c 87       	std	Y+12, r25	; 0x0c
     a60:	80 e7       	ldi	r24, 0x70	; 112
     a62:	8a 83       	std	Y+2, r24	; 0x02
     a64:	2b 83       	std	Y+3, r18	; 0x03
     a66:	8a ea       	ldi	r24, 0xAA	; 170
     a68:	8c 83       	std	Y+4, r24	; 0x04
     a6a:	85 ea       	ldi	r24, 0xA5	; 165
     a6c:	8d 83       	std	Y+5, r24	; 0x05
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	08 95       	ret

00000a74 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
     a74:	0f 93       	push	r16
     a76:	1f 93       	push	r17
	return i2c->write (slave_addr, range_cmd, 1);
     a78:	ac 01       	movw	r20, r24
     a7a:	4d 5f       	subi	r20, 0xFD	; 253
     a7c:	5f 4f       	sbci	r21, 0xFF	; 255
     a7e:	08 ee       	ldi	r16, 0xE8	; 232
     a80:	13 e0       	ldi	r17, 0x03	; 3
     a82:	21 e0       	ldi	r18, 0x01	; 1
     a84:	fc 01       	movw	r30, r24
     a86:	62 81       	ldd	r22, Z+2	; 0x02
     a88:	80 81       	ld	r24, Z
     a8a:	91 81       	ldd	r25, Z+1	; 0x01
     a8c:	0e 94 23 04 	call	0x846	; 0x846 <_ZN9I2CMaster5writeEhPhhj>
};
     a90:	1f 91       	pop	r17
     a92:	0f 91       	pop	r16
     a94:	08 95       	ret

00000a96 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	ec 01       	movw	r28, r24
	i2c->read (slave_addr, bytes_received, 2);
     aa0:	ac 01       	movw	r20, r24
     aa2:	49 5f       	subi	r20, 0xF9	; 249
     aa4:	5f 4f       	sbci	r21, 0xFF	; 255
     aa6:	08 ee       	ldi	r16, 0xE8	; 232
     aa8:	13 e0       	ldi	r17, 0x03	; 3
     aaa:	22 e0       	ldi	r18, 0x02	; 2
     aac:	6a 81       	ldd	r22, Y+2	; 0x02
     aae:	88 81       	ld	r24, Y
     ab0:	99 81       	ldd	r25, Y+1	; 0x01
     ab2:	0e 94 8e 04 	call	0x91c	; 0x91c <_ZN9I2CMaster4readEhPhhj>
	range_reading = ((uint16_t) bytes_received[0] << 8) | ((uint16_t) bytes_received[1]);
     ab6:	8f 81       	ldd	r24, Y+7	; 0x07
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	98 2f       	mov	r25, r24
     abc:	88 27       	eor	r24, r24
     abe:	28 85       	ldd	r18, Y+8	; 0x08
     ac0:	82 2b       	or	r24, r18
     ac2:	89 87       	std	Y+9, r24	; 0x09
     ac4:	9a 87       	std	Y+10, r25	; 0x0a
	return range_reading;
}
     ac6:	df 91       	pop	r29
     ac8:	cf 91       	pop	r28
     aca:	1f 91       	pop	r17
     acc:	0f 91       	pop	r16
     ace:	08 95       	ret

00000ad0 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     ad0:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     ad2:	8c 85       	ldd	r24, Y+12	; 0x0c
     ad4:	88 23       	and	r24, r24
     ad6:	19 f0       	breq	.+6      	; 0xade <_ZN10task_sonar3runEv+0xe>
     ad8:	81 30       	cpi	r24, 0x01	; 1
     ada:	51 f0       	breq	.+20     	; 0xaf0 <_ZN10task_sonar3runEv+0x20>
     adc:	25 c0       	rjmp	.+74     	; 0xb28 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     ade:	8c 89       	ldd	r24, Y+20	; 0x14
     ae0:	9d 89       	ldd	r25, Y+21	; 0x15
     ae2:	0e 94 3a 05 	call	0xa74	; 0xa74 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     ae6:	61 e0       	ldi	r22, 0x01	; 1
     ae8:	ce 01       	movw	r24, r28
     aea:	0e 94 73 13 	call	0x26e6	; 0x26e6 <_ZN8frt_task13transition_toEh>
			
			    break;
     aee:	1c c0       	rjmp	.+56     	; 0xb28 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     af0:	8c 89       	ldd	r24, Y+20	; 0x14
     af2:	9d 89       	ldd	r25, Y+21	; 0x15
     af4:	0e 94 4b 05 	call	0xa96	; 0xa96 <_ZN6MB120211get_readingEv>
     af8:	7c 01       	movw	r14, r24
     afa:	8a 8b       	std	Y+18, r24	; 0x12
     afc:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     afe:	6a e0       	ldi	r22, 0x0A	; 10
     b00:	8e 81       	ldd	r24, Y+6	; 0x06
     b02:	9f 81       	ldd	r25, Y+7	; 0x07
     b04:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     b08:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     b0a:	6a e1       	ldi	r22, 0x1A	; 26
     b0c:	73 e0       	ldi	r23, 0x03	; 3
     b0e:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     b12:	b7 01       	movw	r22, r14
     b14:	c8 01       	movw	r24, r16
     b16:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
     b1a:	66 e0       	ldi	r22, 0x06	; 6
     b1c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     b20:	60 e0       	ldi	r22, 0x00	; 0
     b22:	ce 01       	movw	r24, r28
     b24:	0e 94 73 13 	call	0x26e6	; 0x26e6 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     b28:	8e 85       	ldd	r24, Y+14	; 0x0e
     b2a:	9f 85       	ldd	r25, Y+15	; 0x0f
     b2c:	a8 89       	ldd	r26, Y+16	; 0x10
     b2e:	b9 89       	ldd	r27, Y+17	; 0x11
     b30:	01 96       	adiw	r24, 0x01	; 1
     b32:	a1 1d       	adc	r26, r1
     b34:	b1 1d       	adc	r27, r1
     b36:	8e 87       	std	Y+14, r24	; 0x0e
     b38:	9f 87       	std	Y+15, r25	; 0x0f
     b3a:	a8 8b       	std	Y+16, r26	; 0x10
     b3c:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     b3e:	64 ef       	ldi	r22, 0xF4	; 244
     b40:	71 e0       	ldi	r23, 0x01	; 1
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	0e 94 47 11 	call	0x228e	; 0x228e <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     b4a:	c3 cf       	rjmp	.-122    	; 0xad2 <_ZN10task_sonar3runEv+0x2>

00000b4c <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     b4c:	cf 92       	push	r12
     b4e:	df 92       	push	r13
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	ec 01       	movw	r28, r24
     b5e:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     b60:	0e 94 77 13 	call	0x26ee	; 0x26ee <_ZN8frt_taskC1EPKchjP8emstream>
     b64:	82 e2       	ldi	r24, 0x22	; 34
     b66:	90 e2       	ldi	r25, 0x20	; 32
     b68:	88 83       	st	Y, r24
     b6a:	99 83       	std	Y+1, r25	; 0x01
     b6c:	ec 8a       	std	Y+20, r14	; 0x14
     b6e:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     b70:	ce 8a       	std	Y+22, r12	; 0x16
     b72:	df 8a       	std	Y+23, r13	; 0x17
}
     b74:	df 91       	pop	r29
     b76:	cf 91       	pop	r28
     b78:	1f 91       	pop	r17
     b7a:	0f 91       	pop	r16
     b7c:	ff 90       	pop	r15
     b7e:	ef 90       	pop	r14
     b80:	df 90       	pop	r13
     b82:	cf 90       	pop	r12
     b84:	08 95       	ret

00000b86 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     b86:	0f 93       	push	r16
     b88:	1f 93       	push	r17
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
     b8e:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b90:	0e 94 77 13 	call	0x26ee	; 0x26ee <_ZN8frt_taskC1EPKchjP8emstream>
     b94:	8a e2       	ldi	r24, 0x2A	; 42
     b96:	90 e2       	ldi	r25, 0x20	; 32
     b98:	88 83       	st	Y, r24
     b9a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     b9c:	df 91       	pop	r29
     b9e:	cf 91       	pop	r28
     ba0:	1f 91       	pop	r17
     ba2:	0f 91       	pop	r16
     ba4:	08 95       	ret

00000ba6 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     ba6:	0f 93       	push	r16
     ba8:	1f 93       	push	r17
     baa:	cf 93       	push	r28
     bac:	df 93       	push	r29
     bae:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     bb0:	6a e0       	ldi	r22, 0x0A	; 10
     bb2:	8e 81       	ldd	r24, Y+6	; 0x06
     bb4:	9f 81       	ldd	r25, Y+7	; 0x07
     bb6:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     bba:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     bbc:	65 e7       	ldi	r22, 0x75	; 117
     bbe:	74 e0       	ldi	r23, 0x04	; 4
     bc0:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     bc4:	6a e0       	ldi	r22, 0x0A	; 10
     bc6:	c8 01       	movw	r24, r16
     bc8:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     bcc:	8c 01       	movw	r16, r24
     bce:	6f e6       	ldi	r22, 0x6F	; 111
     bd0:	74 e0       	ldi	r23, 0x04	; 4
     bd2:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     bd6:	67 e0       	ldi	r22, 0x07	; 7
     bd8:	c8 01       	movw	r24, r16
     bda:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     bde:	6a e0       	ldi	r22, 0x0A	; 10
     be0:	8e 81       	ldd	r24, Y+6	; 0x06
     be2:	9f 81       	ldd	r25, Y+7	; 0x07
     be4:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     be8:	8c 01       	movw	r16, r24
     bea:	60 e5       	ldi	r22, 0x50	; 80
     bec:	74 e0       	ldi	r23, 0x04	; 4
     bee:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     bf2:	6a e0       	ldi	r22, 0x0A	; 10
     bf4:	c8 01       	movw	r24, r16
     bf6:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     bfa:	8c 01       	movw	r16, r24
     bfc:	6a e4       	ldi	r22, 0x4A	; 74
     bfe:	74 e0       	ldi	r23, 0x04	; 4
     c00:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c04:	66 e0       	ldi	r22, 0x06	; 6
     c06:	c8 01       	movw	r24, r16
     c08:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     c0c:	6a e0       	ldi	r22, 0x0A	; 10
     c0e:	8e 81       	ldd	r24, Y+6	; 0x06
     c10:	9f 81       	ldd	r25, Y+7	; 0x07
     c12:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     c16:	8c 01       	movw	r16, r24
     c18:	63 e3       	ldi	r22, 0x33	; 51
     c1a:	74 e0       	ldi	r23, 0x04	; 4
     c1c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c20:	66 e0       	ldi	r22, 0x06	; 6
     c22:	c8 01       	movw	r24, r16
     c24:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     c28:	6a e0       	ldi	r22, 0x0A	; 10
     c2a:	8e 81       	ldd	r24, Y+6	; 0x06
     c2c:	9f 81       	ldd	r25, Y+7	; 0x07
     c2e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     c32:	8c 01       	movw	r16, r24
     c34:	67 e1       	ldi	r22, 0x17	; 23
     c36:	74 e0       	ldi	r23, 0x04	; 4
     c38:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c3c:	66 e0       	ldi	r22, 0x06	; 6
     c3e:	c8 01       	movw	r24, r16
     c40:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     c44:	6a e0       	ldi	r22, 0x0A	; 10
     c46:	8e 81       	ldd	r24, Y+6	; 0x06
     c48:	9f 81       	ldd	r25, Y+7	; 0x07
     c4a:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     c4e:	8c 01       	movw	r16, r24
     c50:	6f ef       	ldi	r22, 0xFF	; 255
     c52:	73 e0       	ldi	r23, 0x03	; 3
     c54:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c58:	66 e0       	ldi	r22, 0x06	; 6
     c5a:	c8 01       	movw	r24, r16
     c5c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     c60:	6a e0       	ldi	r22, 0x0A	; 10
     c62:	8e 81       	ldd	r24, Y+6	; 0x06
     c64:	9f 81       	ldd	r25, Y+7	; 0x07
     c66:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     c6a:	8c 01       	movw	r16, r24
     c6c:	6e ed       	ldi	r22, 0xDE	; 222
     c6e:	73 e0       	ldi	r23, 0x03	; 3
     c70:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c74:	66 e0       	ldi	r22, 0x06	; 6
     c76:	c8 01       	movw	r24, r16
     c78:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     c7c:	6a e0       	ldi	r22, 0x0A	; 10
     c7e:	8e 81       	ldd	r24, Y+6	; 0x06
     c80:	9f 81       	ldd	r25, Y+7	; 0x07
     c82:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     c86:	8c 01       	movw	r16, r24
     c88:	67 eb       	ldi	r22, 0xB7	; 183
     c8a:	73 e0       	ldi	r23, 0x03	; 3
     c8c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     c90:	66 e0       	ldi	r22, 0x06	; 6
     c92:	c8 01       	movw	r24, r16
     c94:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     c98:	6a e0       	ldi	r22, 0x0A	; 10
     c9a:	8e 81       	ldd	r24, Y+6	; 0x06
     c9c:	9f 81       	ldd	r25, Y+7	; 0x07
     c9e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     ca2:	8c 01       	movw	r16, r24
     ca4:	69 e9       	ldi	r22, 0x99	; 153
     ca6:	73 e0       	ldi	r23, 0x03	; 3
     ca8:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     cac:	66 e0       	ldi	r22, 0x06	; 6
     cae:	c8 01       	movw	r24, r16
     cb0:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     cb4:	6a e0       	ldi	r22, 0x0A	; 10
     cb6:	8e 81       	ldd	r24, Y+6	; 0x06
     cb8:	9f 81       	ldd	r25, Y+7	; 0x07
     cba:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     cbe:	8c 01       	movw	r16, r24
     cc0:	6e e7       	ldi	r22, 0x7E	; 126
     cc2:	73 e0       	ldi	r23, 0x03	; 3
     cc4:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     cc8:	66 e0       	ldi	r22, 0x06	; 6
     cca:	c8 01       	movw	r24, r16
     ccc:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     cd0:	6a e0       	ldi	r22, 0x0A	; 10
     cd2:	8e 81       	ldd	r24, Y+6	; 0x06
     cd4:	9f 81       	ldd	r25, Y+7	; 0x07
     cd6:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     cda:	ec 01       	movw	r28, r24
     cdc:	6f e6       	ldi	r22, 0x6F	; 111
     cde:	73 e0       	ldi	r23, 0x03	; 3
     ce0:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     ce4:	66 e0       	ldi	r22, 0x06	; 6
     ce6:	ce 01       	movw	r24, r28
     ce8:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
}
     cec:	df 91       	pop	r29
     cee:	cf 91       	pop	r28
     cf0:	1f 91       	pop	r17
     cf2:	0f 91       	pop	r16
     cf4:	08 95       	ret

00000cf6 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     cf6:	af 92       	push	r10
     cf8:	bf 92       	push	r11
     cfa:	cf 92       	push	r12
     cfc:	df 92       	push	r13
     cfe:	ef 92       	push	r14
     d00:	ff 92       	push	r15
     d02:	0f 93       	push	r16
     d04:	1f 93       	push	r17
     d06:	cf 93       	push	r28
     d08:	df 93       	push	r29
     d0a:	00 d0       	rcall	.+0      	; 0xd0c <_ZN9task_user11show_statusEv+0x16>
     d0c:	00 d0       	rcall	.+0      	; 0xd0e <_ZN9task_user11show_statusEv+0x18>
     d0e:	cd b7       	in	r28, 0x3d	; 61
     d10:	de b7       	in	r29, 0x3e	; 62
     d12:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     d14:	19 82       	std	Y+1, r1	; 0x01
     d16:	1a 82       	std	Y+2, r1	; 0x02
     d18:	1b 82       	std	Y+3, r1	; 0x03
     d1a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     d1c:	1d 82       	std	Y+5, r1	; 0x05
     d1e:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     d20:	0e 94 00 09 	call	0x1200	; 0x1200 <xPortGetFreeHeapSize>
     d24:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     d26:	ce 01       	movw	r24, r28
     d28:	01 96       	adiw	r24, 0x01	; 1
     d2a:	0e 94 28 17 	call	0x2e50	; 0x2e50 <_ZN10time_stamp10set_to_nowEv>
     d2e:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     d30:	66 e0       	ldi	r22, 0x06	; 6
     d32:	f8 01       	movw	r30, r16
     d34:	86 81       	ldd	r24, Z+6	; 0x06
     d36:	97 81       	ldd	r25, Z+7	; 0x07
     d38:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d3c:	6a e0       	ldi	r22, 0x0A	; 10
     d3e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d42:	7c 01       	movw	r14, r24
     d44:	60 e5       	ldi	r22, 0x50	; 80
     d46:	73 e0       	ldi	r23, 0x03	; 3
     d48:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     d4c:	6a e0       	ldi	r22, 0x0A	; 10
     d4e:	c7 01       	movw	r24, r14
     d50:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d54:	7c 01       	movw	r14, r24
     d56:	64 e4       	ldi	r22, 0x44	; 68
     d58:	73 e0       	ldi	r23, 0x03	; 3
     d5a:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     d5e:	66 e0       	ldi	r22, 0x06	; 6
     d60:	c7 01       	movw	r24, r14
     d62:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     d66:	6a e0       	ldi	r22, 0x0A	; 10
     d68:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d6c:	7c 01       	movw	r14, r24
     d6e:	6d e3       	ldi	r22, 0x3D	; 61
     d70:	73 e0       	ldi	r23, 0x03	; 3
     d72:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     d76:	b5 01       	movw	r22, r10
     d78:	c7 01       	movw	r24, r14
     d7a:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     d7e:	6a e0       	ldi	r22, 0x0A	; 10
     d80:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d84:	7c 01       	movw	r14, r24
     d86:	6f e2       	ldi	r22, 0x2F	; 47
     d88:	73 e0       	ldi	r23, 0x03	; 3
     d8a:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     d8e:	b6 01       	movw	r22, r12
     d90:	c7 01       	movw	r24, r14
     d92:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
     d96:	6a e0       	ldi	r22, 0x0A	; 10
     d98:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     d9c:	7c 01       	movw	r14, r24
     d9e:	6d e2       	ldi	r22, 0x2D	; 45
     da0:	73 e0       	ldi	r23, 0x03	; 3
     da2:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     da6:	4f ef       	ldi	r20, 0xFF	; 255
     da8:	5f e0       	ldi	r21, 0x0F	; 15
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	70 e0       	ldi	r23, 0x00	; 0
     dae:	c7 01       	movw	r24, r14
     db0:	0e 94 57 19 	call	0x32ae	; 0x32ae <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     db4:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     db8:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     dbc:	6a e0       	ldi	r22, 0x0A	; 10
     dbe:	f8 01       	movw	r30, r16
     dc0:	86 81       	ldd	r24, Z+6	; 0x06
     dc2:	97 81       	ldd	r25, Z+7	; 0x07
     dc4:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     dc8:	7c 01       	movw	r14, r24
     dca:	62 e2       	ldi	r22, 0x22	; 34
     dcc:	73 e0       	ldi	r23, 0x03	; 3
     dce:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     dd2:	b6 01       	movw	r22, r12
     dd4:	c7 01       	movw	r24, r14
     dd6:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
     dda:	66 e0       	ldi	r22, 0x06	; 6
     ddc:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     de0:	66 e0       	ldi	r22, 0x06	; 6
     de2:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     de6:	f8 01       	movw	r30, r16
     de8:	86 81       	ldd	r24, Z+6	; 0x06
     dea:	97 81       	ldd	r25, Z+7	; 0x07
     dec:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <_Z15print_task_listP8emstream>
}
     df0:	26 96       	adiw	r28, 0x06	; 6
     df2:	cd bf       	out	0x3d, r28	; 61
     df4:	de bf       	out	0x3e, r29	; 62
     df6:	df 91       	pop	r29
     df8:	cf 91       	pop	r28
     dfa:	1f 91       	pop	r17
     dfc:	0f 91       	pop	r16
     dfe:	ff 90       	pop	r15
     e00:	ef 90       	pop	r14
     e02:	df 90       	pop	r13
     e04:	cf 90       	pop	r12
     e06:	bf 90       	pop	r11
     e08:	af 90       	pop	r10
     e0a:	08 95       	ret

00000e0c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     e0c:	cf 93       	push	r28
     e0e:	df 93       	push	r29
     e10:	00 d0       	rcall	.+0      	; 0xe12 <_ZN9task_user3runEv+0x6>
     e12:	00 d0       	rcall	.+0      	; 0xe14 <_ZN9task_user3runEv+0x8>
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
     e18:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     e1a:	19 82       	std	Y+1, r1	; 0x01
     e1c:	1a 82       	std	Y+2, r1	; 0x02
     e1e:	1b 82       	std	Y+3, r1	; 0x03
     e20:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     e22:	1d 82       	std	Y+5, r1	; 0x05
     e24:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     e26:	6a e0       	ldi	r22, 0x0A	; 10
     e28:	dc 01       	movw	r26, r24
     e2a:	16 96       	adiw	r26, 0x06	; 6
     e2c:	8d 91       	ld	r24, X+
     e2e:	9c 91       	ld	r25, X
     e30:	17 97       	sbiw	r26, 0x07	; 7
     e32:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     e36:	7c 01       	movw	r14, r24
     e38:	6e eb       	ldi	r22, 0xBE	; 190
     e3a:	74 e0       	ldi	r23, 0x04	; 4
     e3c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     e40:	66 e0       	ldi	r22, 0x06	; 6
     e42:	c7 01       	movw	r24, r14
     e44:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     e48:	f8 01       	movw	r30, r16
     e4a:	84 85       	ldd	r24, Z+12	; 0x0c
     e4c:	88 23       	and	r24, r24
     e4e:	21 f0       	breq	.+8      	; 0xe58 <_ZN9task_user3runEv+0x4c>
     e50:	81 30       	cpi	r24, 0x01	; 1
     e52:	09 f4       	brne	.+2      	; 0xe56 <_ZN9task_user3runEv+0x4a>
     e54:	5d c0       	rjmp	.+186    	; 0xf10 <_ZN9task_user3runEv+0x104>
     e56:	d8 c0       	rjmp	.+432    	; 0x1008 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     e58:	86 81       	ldd	r24, Z+6	; 0x06
     e5a:	97 81       	ldd	r25, Z+7	; 0x07
     e5c:	dc 01       	movw	r26, r24
     e5e:	ed 91       	ld	r30, X+
     e60:	fc 91       	ld	r31, X
     e62:	04 80       	ldd	r0, Z+4	; 0x04
     e64:	f5 81       	ldd	r31, Z+5	; 0x05
     e66:	e0 2d       	mov	r30, r0
     e68:	19 95       	eicall
     e6a:	88 23       	and	r24, r24
     e6c:	a9 f1       	breq	.+106    	; 0xed8 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     e6e:	f8 01       	movw	r30, r16
     e70:	86 81       	ldd	r24, Z+6	; 0x06
     e72:	97 81       	ldd	r25, Z+7	; 0x07
     e74:	dc 01       	movw	r26, r24
     e76:	ed 91       	ld	r30, X+
     e78:	fc 91       	ld	r31, X
     e7a:	06 80       	ldd	r0, Z+6	; 0x06
     e7c:	f7 81       	ldd	r31, Z+7	; 0x07
     e7e:	e0 2d       	mov	r30, r0
     e80:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     e82:	99 27       	eor	r25, r25
     e84:	81 30       	cpi	r24, 0x01	; 1
     e86:	91 05       	cpc	r25, r1
     e88:	f9 f0       	breq	.+62     	; 0xec8 <_ZN9task_user3runEv+0xbc>
     e8a:	03 97       	sbiw	r24, 0x03	; 3
     e8c:	09 f0       	breq	.+2      	; 0xe90 <_ZN9task_user3runEv+0x84>
     e8e:	d8 c0       	rjmp	.+432    	; 0x1040 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     e90:	6a e0       	ldi	r22, 0x0A	; 10
     e92:	f8 01       	movw	r30, r16
     e94:	86 81       	ldd	r24, Z+6	; 0x06
     e96:	97 81       	ldd	r25, Z+7	; 0x07
     e98:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     e9c:	8c 01       	movw	r16, r24
     e9e:	60 eb       	ldi	r22, 0xB0	; 176
     ea0:	74 e0       	ldi	r23, 0x04	; 4
     ea2:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     ea6:	66 e0       	ldi	r22, 0x06	; 6
     ea8:	c8 01       	movw	r24, r16
     eaa:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     eae:	93 e0       	ldi	r25, 0x03	; 3
     eb0:	88 ed       	ldi	r24, 0xD8	; 216
     eb2:	08 b6       	in	r0, 0x38	; 56
     eb4:	18 be       	out	0x38, r1	; 56
     eb6:	84 bf       	out	0x34, r24	; 52
     eb8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     ebc:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     ec0:	81 fd       	sbrc	r24, 1
     ec2:	fc cf       	rjmp	.-8      	; 0xebc <_ZN9task_user3runEv+0xb0>
     ec4:	08 be       	out	0x38, r0	; 56
     ec6:	ff cf       	rjmp	.-2      	; 0xec6 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     ec8:	c8 01       	movw	r24, r16
     eca:	0e 94 d3 05 	call	0xba6	; 0xba6 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     ece:	61 e0       	ldi	r22, 0x01	; 1
     ed0:	c8 01       	movw	r24, r16
     ed2:	0e 94 73 13 	call	0x26e6	; 0x26e6 <_ZN8frt_task13transition_toEh>
							break;
     ed6:	b4 c0       	rjmp	.+360    	; 0x1040 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     ed8:	8c e9       	ldi	r24, 0x9C	; 156
     eda:	91 e3       	ldi	r25, 0x31	; 49
     edc:	0e 94 34 16 	call	0x2c68	; 0x2c68 <_ZN14frt_text_queue14check_for_charEv>
     ee0:	88 23       	and	r24, r24
     ee2:	09 f4       	brne	.+2      	; 0xee6 <_ZN9task_user3runEv+0xda>
     ee4:	ad c0       	rjmp	.+346    	; 0x1040 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     ee6:	d8 01       	movw	r26, r16
     ee8:	16 96       	adiw	r26, 0x06	; 6
     eea:	ed 91       	ld	r30, X+
     eec:	fc 91       	ld	r31, X
     eee:	17 97       	sbiw	r26, 0x07	; 7
     ef0:	01 90       	ld	r0, Z+
     ef2:	f0 81       	ld	r31, Z
     ef4:	e0 2d       	mov	r30, r0
     ef6:	e2 80       	ldd	r14, Z+2	; 0x02
     ef8:	f3 80       	ldd	r15, Z+3	; 0x03
     efa:	8c e9       	ldi	r24, 0x9C	; 156
     efc:	91 e3       	ldi	r25, 0x31	; 49
     efe:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <_ZN14frt_text_queue7getcharEv>
     f02:	68 2f       	mov	r22, r24
     f04:	f8 01       	movw	r30, r16
     f06:	86 81       	ldd	r24, Z+6	; 0x06
     f08:	97 81       	ldd	r25, Z+7	; 0x07
     f0a:	f7 01       	movw	r30, r14
     f0c:	19 95       	eicall
     f0e:	98 c0       	rjmp	.+304    	; 0x1040 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     f10:	86 81       	ldd	r24, Z+6	; 0x06
     f12:	97 81       	ldd	r25, Z+7	; 0x07
     f14:	dc 01       	movw	r26, r24
     f16:	ed 91       	ld	r30, X+
     f18:	fc 91       	ld	r31, X
     f1a:	04 80       	ldd	r0, Z+4	; 0x04
     f1c:	f5 81       	ldd	r31, Z+5	; 0x05
     f1e:	e0 2d       	mov	r30, r0
     f20:	19 95       	eicall
     f22:	88 23       	and	r24, r24
     f24:	09 f4       	brne	.+2      	; 0xf28 <_ZN9task_user3runEv+0x11c>
     f26:	8c c0       	rjmp	.+280    	; 0x1040 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     f28:	f8 01       	movw	r30, r16
     f2a:	86 81       	ldd	r24, Z+6	; 0x06
     f2c:	97 81       	ldd	r25, Z+7	; 0x07
     f2e:	dc 01       	movw	r26, r24
     f30:	ed 91       	ld	r30, X+
     f32:	fc 91       	ld	r31, X
     f34:	06 80       	ldd	r0, Z+6	; 0x06
     f36:	f7 81       	ldd	r31, Z+7	; 0x07
     f38:	e0 2d       	mov	r30, r0
     f3a:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     f3c:	9c 01       	movw	r18, r24
     f3e:	33 27       	eor	r19, r19
     f40:	28 36       	cpi	r18, 0x68	; 104
     f42:	31 05       	cpc	r19, r1
     f44:	59 f1       	breq	.+86     	; 0xf9c <_ZN9task_user3runEv+0x190>
     f46:	3c f4       	brge	.+14     	; 0xf56 <_ZN9task_user3runEv+0x14a>
     f48:	2b 31       	cpi	r18, 0x1B	; 27
     f4a:	31 05       	cpc	r19, r1
     f4c:	59 f1       	breq	.+86     	; 0xfa4 <_ZN9task_user3runEv+0x198>
     f4e:	25 36       	cpi	r18, 0x65	; 101
     f50:	31 05       	cpc	r19, r1
     f52:	41 f1       	breq	.+80     	; 0xfa4 <_ZN9task_user3runEv+0x198>
     f54:	3b c0       	rjmp	.+118    	; 0xfcc <_ZN9task_user3runEv+0x1c0>
     f56:	23 37       	cpi	r18, 0x73	; 115
     f58:	31 05       	cpc	r19, r1
     f5a:	c1 f0       	breq	.+48     	; 0xf8c <_ZN9task_user3runEv+0x180>
     f5c:	26 37       	cpi	r18, 0x76	; 118
     f5e:	31 05       	cpc	r19, r1
     f60:	89 f0       	breq	.+34     	; 0xf84 <_ZN9task_user3runEv+0x178>
     f62:	2e 36       	cpi	r18, 0x6E	; 110
     f64:	31 05       	cpc	r19, r1
     f66:	91 f5       	brne	.+100    	; 0xfcc <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     f68:	ce 01       	movw	r24, r28
     f6a:	01 96       	adiw	r24, 0x01	; 1
     f6c:	0e 94 28 17 	call	0x2e50	; 0x2e50 <_ZN10time_stamp10set_to_nowEv>
     f70:	bc 01       	movw	r22, r24
     f72:	f8 01       	movw	r30, r16
     f74:	86 81       	ldd	r24, Z+6	; 0x06
     f76:	97 81       	ldd	r25, Z+7	; 0x07
     f78:	0e 94 cc 16 	call	0x2d98	; 0x2d98 <_ZlsR8emstreamR10time_stamp>
     f7c:	66 e0       	ldi	r22, 0x06	; 6
     f7e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
							break;
     f82:	5e c0       	rjmp	.+188    	; 0x1040 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     f84:	c8 01       	movw	r24, r16
     f86:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <_ZN9task_user11show_statusEv>
							break;
     f8a:	5a c0       	rjmp	.+180    	; 0x1040 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     f8c:	d8 01       	movw	r26, r16
     f8e:	16 96       	adiw	r26, 0x06	; 6
     f90:	8d 91       	ld	r24, X+
     f92:	9c 91       	ld	r25, X
     f94:	17 97       	sbiw	r26, 0x07	; 7
     f96:	0e 94 8c 14 	call	0x2918	; 0x2918 <_Z17print_task_stacksP8emstream>
							break;
     f9a:	52 c0       	rjmp	.+164    	; 0x1040 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     f9c:	c8 01       	movw	r24, r16
     f9e:	0e 94 d3 05 	call	0xba6	; 0xba6 <_ZN9task_user18print_help_messageEv>
							break;
     fa2:	4e c0       	rjmp	.+156    	; 0x1040 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     fa4:	6a e0       	ldi	r22, 0x0A	; 10
     fa6:	f8 01       	movw	r30, r16
     fa8:	86 81       	ldd	r24, Z+6	; 0x06
     faa:	97 81       	ldd	r25, Z+7	; 0x07
     fac:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     fb0:	7c 01       	movw	r14, r24
     fb2:	6e e9       	ldi	r22, 0x9E	; 158
     fb4:	74 e0       	ldi	r23, 0x04	; 4
     fb6:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     fba:	66 e0       	ldi	r22, 0x06	; 6
     fbc:	c7 01       	movw	r24, r14
     fbe:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     fc2:	60 e0       	ldi	r22, 0x00	; 0
     fc4:	c8 01       	movw	r24, r16
     fc6:	0e 94 73 13 	call	0x26e6	; 0x26e6 <_ZN8frt_task13transition_toEh>
							break;
     fca:	3a c0       	rjmp	.+116    	; 0x1040 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     fcc:	f8 01       	movw	r30, r16
     fce:	a6 81       	ldd	r26, Z+6	; 0x06
     fd0:	b7 81       	ldd	r27, Z+7	; 0x07
     fd2:	ed 91       	ld	r30, X+
     fd4:	fc 91       	ld	r31, X
     fd6:	11 97       	sbiw	r26, 0x01	; 1
     fd8:	02 80       	ldd	r0, Z+2	; 0x02
     fda:	f3 81       	ldd	r31, Z+3	; 0x03
     fdc:	e0 2d       	mov	r30, r0
     fde:	68 2f       	mov	r22, r24
     fe0:	cd 01       	movw	r24, r26
     fe2:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     fe4:	6a e0       	ldi	r22, 0x0A	; 10
     fe6:	d8 01       	movw	r26, r16
     fe8:	16 96       	adiw	r26, 0x06	; 6
     fea:	8d 91       	ld	r24, X+
     fec:	9c 91       	ld	r25, X
     fee:	17 97       	sbiw	r26, 0x07	; 7
     ff0:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
     ff4:	7c 01       	movw	r14, r24
     ff6:	68 e9       	ldi	r22, 0x98	; 152
     ff8:	74 e0       	ldi	r23, 0x04	; 4
     ffa:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
     ffe:	66 e0       	ldi	r22, 0x06	; 6
    1000:	c7 01       	movw	r24, r14
    1002:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
							break;
    1006:	1c c0       	rjmp	.+56     	; 0x1040 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    1008:	6a e0       	ldi	r22, 0x0A	; 10
    100a:	f8 01       	movw	r30, r16
    100c:	86 81       	ldd	r24, Z+6	; 0x06
    100e:	97 81       	ldd	r25, Z+7	; 0x07
    1010:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    1014:	8c 01       	movw	r16, r24
    1016:	6b e7       	ldi	r22, 0x7B	; 123
    1018:	74 e0       	ldi	r23, 0x04	; 4
    101a:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    101e:	66 e0       	ldi	r22, 0x06	; 6
    1020:	c8 01       	movw	r24, r16
    1022:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1026:	93 e0       	ldi	r25, 0x03	; 3
    1028:	88 ed       	ldi	r24, 0xD8	; 216
    102a:	08 b6       	in	r0, 0x38	; 56
    102c:	18 be       	out	0x38, r1	; 56
    102e:	84 bf       	out	0x34, r24	; 52
    1030:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1034:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1038:	81 fd       	sbrc	r24, 1
    103a:	fc cf       	rjmp	.-8      	; 0x1034 <_ZN9task_user3runEv+0x228>
    103c:	08 be       	out	0x38, r0	; 56
    103e:	ff cf       	rjmp	.-2      	; 0x103e <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1040:	f8 01       	movw	r30, r16
    1042:	86 85       	ldd	r24, Z+14	; 0x0e
    1044:	97 85       	ldd	r25, Z+15	; 0x0f
    1046:	a0 89       	ldd	r26, Z+16	; 0x10
    1048:	b1 89       	ldd	r27, Z+17	; 0x11
    104a:	01 96       	adiw	r24, 0x01	; 1
    104c:	a1 1d       	adc	r26, r1
    104e:	b1 1d       	adc	r27, r1
    1050:	86 87       	std	Z+14, r24	; 0x0e
    1052:	97 87       	std	Z+15, r25	; 0x0f
    1054:	a0 8b       	std	Z+16, r26	; 0x10
    1056:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1058:	61 e0       	ldi	r22, 0x01	; 1
    105a:	70 e0       	ldi	r23, 0x00	; 0
    105c:	80 e0       	ldi	r24, 0x00	; 0
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	0e 94 47 11 	call	0x228e	; 0x228e <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1064:	f1 ce       	rjmp	.-542    	; 0xe48 <_ZN9task_user3runEv+0x3c>

00001066 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1066:	0f 93       	push	r16
    1068:	1f 93       	push	r17
    106a:	cf 93       	push	r28
    106c:	df 93       	push	r29
    106e:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1070:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1074:	80 91 e0 20 	lds	r24, 0x20E0	; 0x8020e0 <__data_end>
    1078:	81 11       	cpse	r24, r1
    107a:	1d c0       	rjmp	.+58     	; 0x10b6 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    107c:	a5 ee       	ldi	r26, 0xE5	; 229
    107e:	b0 e2       	ldi	r27, 0x20	; 32
    1080:	e9 ee       	ldi	r30, 0xE9	; 233
    1082:	f0 e2       	ldi	r31, 0x20	; 32
    1084:	ed 93       	st	X+, r30
    1086:	fc 93       	st	X, r31
    1088:	11 97       	sbiw	r26, 0x01	; 1
    108a:	12 96       	adiw	r26, 0x02	; 2
    108c:	1d 92       	st	X+, r1
    108e:	1c 92       	st	X, r1
    1090:	13 97       	sbiw	r26, 0x03	; 3
    1092:	a1 ee       	ldi	r26, 0xE1	; 225
    1094:	b0 e2       	ldi	r27, 0x20	; 32
    1096:	8f ef       	ldi	r24, 0xFF	; 255
    1098:	9f e0       	ldi	r25, 0x0F	; 15
    109a:	12 96       	adiw	r26, 0x02	; 2
    109c:	8d 93       	st	X+, r24
    109e:	9c 93       	st	X, r25
    10a0:	13 97       	sbiw	r26, 0x03	; 3
    10a2:	1d 92       	st	X+, r1
    10a4:	1c 92       	st	X, r1
    10a6:	11 97       	sbiw	r26, 0x01	; 1
    10a8:	82 83       	std	Z+2, r24	; 0x02
    10aa:	93 83       	std	Z+3, r25	; 0x03
    10ac:	a0 83       	st	Z, r26
    10ae:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    10b0:	81 e0       	ldi	r24, 0x01	; 1
    10b2:	80 93 e0 20 	sts	0x20E0, r24	; 0x8020e0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    10b6:	20 97       	sbiw	r28, 0x00	; 0
    10b8:	09 f4       	brne	.+2      	; 0x10bc <pvPortMalloc+0x56>
    10ba:	5f c0       	rjmp	.+190    	; 0x117a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    10bc:	9e 01       	movw	r18, r28
    10be:	2b 5f       	subi	r18, 0xFB	; 251
    10c0:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    10c2:	24 96       	adiw	r28, 0x04	; 4
    10c4:	ce 3f       	cpi	r28, 0xFE	; 254
    10c6:	df 40       	sbci	r29, 0x0F	; 15
    10c8:	08 f0       	brcs	.+2      	; 0x10cc <pvPortMalloc+0x66>
    10ca:	5a c0       	rjmp	.+180    	; 0x1180 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    10cc:	e0 91 e5 20 	lds	r30, 0x20E5	; 0x8020e5 <xStart>
    10d0:	f0 91 e6 20 	lds	r31, 0x20E6	; 0x8020e6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    10d4:	a5 ee       	ldi	r26, 0xE5	; 229
    10d6:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    10d8:	02 c0       	rjmp	.+4      	; 0x10de <pvPortMalloc+0x78>
    10da:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    10dc:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    10de:	82 81       	ldd	r24, Z+2	; 0x02
    10e0:	93 81       	ldd	r25, Z+3	; 0x03
    10e2:	82 17       	cp	r24, r18
    10e4:	93 07       	cpc	r25, r19
    10e6:	20 f4       	brcc	.+8      	; 0x10f0 <pvPortMalloc+0x8a>
    10e8:	80 81       	ld	r24, Z
    10ea:	91 81       	ldd	r25, Z+1	; 0x01
    10ec:	00 97       	sbiw	r24, 0x00	; 0
    10ee:	a9 f7       	brne	.-22     	; 0x10da <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    10f0:	c0 e2       	ldi	r28, 0x20	; 32
    10f2:	e1 3e       	cpi	r30, 0xE1	; 225
    10f4:	fc 07       	cpc	r31, r28
    10f6:	09 f4       	brne	.+2      	; 0x10fa <pvPortMalloc+0x94>
    10f8:	46 c0       	rjmp	.+140    	; 0x1186 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    10fa:	cd 91       	ld	r28, X+
    10fc:	dc 91       	ld	r29, X
    10fe:	11 97       	sbiw	r26, 0x01	; 1
    1100:	8e 01       	movw	r16, r28
    1102:	0b 5f       	subi	r16, 0xFB	; 251
    1104:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1106:	80 81       	ld	r24, Z
    1108:	91 81       	ldd	r25, Z+1	; 0x01
    110a:	8d 93       	st	X+, r24
    110c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    110e:	82 81       	ldd	r24, Z+2	; 0x02
    1110:	93 81       	ldd	r25, Z+3	; 0x03
    1112:	82 1b       	sub	r24, r18
    1114:	93 0b       	sbc	r25, r19
    1116:	8b 30       	cpi	r24, 0x0B	; 11
    1118:	91 05       	cpc	r25, r1
    111a:	10 f1       	brcs	.+68     	; 0x1160 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    111c:	bf 01       	movw	r22, r30
    111e:	62 0f       	add	r22, r18
    1120:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1122:	db 01       	movw	r26, r22
    1124:	12 96       	adiw	r26, 0x02	; 2
    1126:	8d 93       	st	X+, r24
    1128:	9c 93       	st	X, r25
    112a:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    112c:	22 83       	std	Z+2, r18	; 0x02
    112e:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1130:	12 96       	adiw	r26, 0x02	; 2
    1132:	4d 91       	ld	r20, X+
    1134:	5c 91       	ld	r21, X
    1136:	13 97       	sbiw	r26, 0x03	; 3
    1138:	85 ee       	ldi	r24, 0xE5	; 229
    113a:	90 e2       	ldi	r25, 0x20	; 32
    113c:	01 c0       	rjmp	.+2      	; 0x1140 <pvPortMalloc+0xda>
    113e:	cd 01       	movw	r24, r26
    1140:	ec 01       	movw	r28, r24
    1142:	a8 81       	ld	r26, Y
    1144:	b9 81       	ldd	r27, Y+1	; 0x01
    1146:	12 96       	adiw	r26, 0x02	; 2
    1148:	2d 91       	ld	r18, X+
    114a:	3c 91       	ld	r19, X
    114c:	13 97       	sbiw	r26, 0x03	; 3
    114e:	24 17       	cp	r18, r20
    1150:	35 07       	cpc	r19, r21
    1152:	a8 f3       	brcs	.-22     	; 0x113e <pvPortMalloc+0xd8>
    1154:	eb 01       	movw	r28, r22
    1156:	a8 83       	st	Y, r26
    1158:	b9 83       	std	Y+1, r27	; 0x01
    115a:	dc 01       	movw	r26, r24
    115c:	6d 93       	st	X+, r22
    115e:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1160:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1164:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1168:	22 81       	ldd	r18, Z+2	; 0x02
    116a:	33 81       	ldd	r19, Z+3	; 0x03
    116c:	82 1b       	sub	r24, r18
    116e:	93 0b       	sbc	r25, r19
    1170:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1174:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1178:	08 c0       	rjmp	.+16     	; 0x118a <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    117a:	00 e0       	ldi	r16, 0x00	; 0
    117c:	10 e0       	ldi	r17, 0x00	; 0
    117e:	05 c0       	rjmp	.+10     	; 0x118a <pvPortMalloc+0x124>
    1180:	00 e0       	ldi	r16, 0x00	; 0
    1182:	10 e0       	ldi	r17, 0x00	; 0
    1184:	02 c0       	rjmp	.+4      	; 0x118a <pvPortMalloc+0x124>
    1186:	00 e0       	ldi	r16, 0x00	; 0
    1188:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    118a:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    118e:	c8 01       	movw	r24, r16
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	1f 91       	pop	r17
    1196:	0f 91       	pop	r16
    1198:	08 95       	ret

0000119a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    119a:	0f 93       	push	r16
    119c:	1f 93       	push	r17
    119e:	cf 93       	push	r28
    11a0:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    11a2:	00 97       	sbiw	r24, 0x00	; 0
    11a4:	41 f1       	breq	.+80     	; 0x11f6 <vPortFree+0x5c>
    11a6:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    11a8:	8c 01       	movw	r16, r24
    11aa:	05 50       	subi	r16, 0x05	; 5
    11ac:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    11ae:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    11b2:	f8 01       	movw	r30, r16
    11b4:	42 81       	ldd	r20, Z+2	; 0x02
    11b6:	53 81       	ldd	r21, Z+3	; 0x03
    11b8:	a5 ee       	ldi	r26, 0xE5	; 229
    11ba:	b0 e2       	ldi	r27, 0x20	; 32
    11bc:	01 c0       	rjmp	.+2      	; 0x11c0 <vPortFree+0x26>
    11be:	df 01       	movw	r26, r30
    11c0:	ed 91       	ld	r30, X+
    11c2:	fc 91       	ld	r31, X
    11c4:	11 97       	sbiw	r26, 0x01	; 1
    11c6:	22 81       	ldd	r18, Z+2	; 0x02
    11c8:	33 81       	ldd	r19, Z+3	; 0x03
    11ca:	24 17       	cp	r18, r20
    11cc:	35 07       	cpc	r19, r21
    11ce:	b8 f3       	brcs	.-18     	; 0x11be <vPortFree+0x24>
    11d0:	25 97       	sbiw	r28, 0x05	; 5
    11d2:	e8 83       	st	Y, r30
    11d4:	f9 83       	std	Y+1, r31	; 0x01
    11d6:	0d 93       	st	X+, r16
    11d8:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    11da:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    11de:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    11e2:	8a 81       	ldd	r24, Y+2	; 0x02
    11e4:	9b 81       	ldd	r25, Y+3	; 0x03
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    11ee:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    11f2:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
	}
}
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	08 95       	ret

00001200 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1200:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1204:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1208:	08 95       	ret

0000120a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    120a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    120c:	03 96       	adiw	r24, 0x03	; 3
    120e:	81 83       	std	Z+1, r24	; 0x01
    1210:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1212:	4f ef       	ldi	r20, 0xFF	; 255
    1214:	5f ef       	ldi	r21, 0xFF	; 255
    1216:	ba 01       	movw	r22, r20
    1218:	43 83       	std	Z+3, r20	; 0x03
    121a:	54 83       	std	Z+4, r21	; 0x04
    121c:	65 83       	std	Z+5, r22	; 0x05
    121e:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1220:	87 83       	std	Z+7, r24	; 0x07
    1222:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1224:	81 87       	std	Z+9, r24	; 0x09
    1226:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1228:	10 82       	st	Z, r1
    122a:	08 95       	ret

0000122c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    122c:	fc 01       	movw	r30, r24
    122e:	12 86       	std	Z+10, r1	; 0x0a
    1230:	13 86       	std	Z+11, r1	; 0x0b
    1232:	08 95       	ret

00001234 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
    1238:	fc 01       	movw	r30, r24
    123a:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    123c:	21 81       	ldd	r18, Z+1	; 0x01
    123e:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1240:	e9 01       	movw	r28, r18
    1242:	8c 81       	ldd	r24, Y+4	; 0x04
    1244:	9d 81       	ldd	r25, Y+5	; 0x05
    1246:	14 96       	adiw	r26, 0x04	; 4
    1248:	8d 93       	st	X+, r24
    124a:	9c 93       	st	X, r25
    124c:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    124e:	81 81       	ldd	r24, Z+1	; 0x01
    1250:	92 81       	ldd	r25, Z+2	; 0x02
    1252:	16 96       	adiw	r26, 0x06	; 6
    1254:	8d 93       	st	X+, r24
    1256:	9c 93       	st	X, r25
    1258:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    125a:	8c 81       	ldd	r24, Y+4	; 0x04
    125c:	9d 81       	ldd	r25, Y+5	; 0x05
    125e:	ec 01       	movw	r28, r24
    1260:	6e 83       	std	Y+6, r22	; 0x06
    1262:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1264:	e9 01       	movw	r28, r18
    1266:	6c 83       	std	Y+4, r22	; 0x04
    1268:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    126a:	61 83       	std	Z+1, r22	; 0x01
    126c:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    126e:	1a 96       	adiw	r26, 0x0a	; 10
    1270:	ed 93       	st	X+, r30
    1272:	fc 93       	st	X, r31
    1274:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1276:	80 81       	ld	r24, Z
    1278:	8f 5f       	subi	r24, 0xFF	; 255
    127a:	80 83       	st	Z, r24
}
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	08 95       	ret

00001282 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1282:	0f 93       	push	r16
    1284:	1f 93       	push	r17
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    128c:	08 81       	ld	r16, Y
    128e:	19 81       	ldd	r17, Y+1	; 0x01
    1290:	2a 81       	ldd	r18, Y+2	; 0x02
    1292:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1294:	0f 3f       	cpi	r16, 0xFF	; 255
    1296:	4f ef       	ldi	r20, 0xFF	; 255
    1298:	14 07       	cpc	r17, r20
    129a:	24 07       	cpc	r18, r20
    129c:	34 07       	cpc	r19, r20
    129e:	31 f4       	brne	.+12     	; 0x12ac <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    12a0:	dc 01       	movw	r26, r24
    12a2:	19 96       	adiw	r26, 0x09	; 9
    12a4:	ed 91       	ld	r30, X+
    12a6:	fc 91       	ld	r31, X
    12a8:	1a 97       	sbiw	r26, 0x0a	; 10
    12aa:	1f c0       	rjmp	.+62     	; 0x12ea <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    12ac:	fc 01       	movw	r30, r24
    12ae:	33 96       	adiw	r30, 0x03	; 3
    12b0:	dc 01       	movw	r26, r24
    12b2:	17 96       	adiw	r26, 0x07	; 7
    12b4:	4d 91       	ld	r20, X+
    12b6:	5c 91       	ld	r21, X
    12b8:	18 97       	sbiw	r26, 0x08	; 8
    12ba:	da 01       	movw	r26, r20
    12bc:	4d 91       	ld	r20, X+
    12be:	5d 91       	ld	r21, X+
    12c0:	6d 91       	ld	r22, X+
    12c2:	7c 91       	ld	r23, X
    12c4:	04 17       	cp	r16, r20
    12c6:	15 07       	cpc	r17, r21
    12c8:	26 07       	cpc	r18, r22
    12ca:	37 07       	cpc	r19, r23
    12cc:	70 f0       	brcs	.+28     	; 0x12ea <vListInsert+0x68>
    12ce:	04 80       	ldd	r0, Z+4	; 0x04
    12d0:	f5 81       	ldd	r31, Z+5	; 0x05
    12d2:	e0 2d       	mov	r30, r0
    12d4:	a4 81       	ldd	r26, Z+4	; 0x04
    12d6:	b5 81       	ldd	r27, Z+5	; 0x05
    12d8:	4d 91       	ld	r20, X+
    12da:	5d 91       	ld	r21, X+
    12dc:	6d 91       	ld	r22, X+
    12de:	7c 91       	ld	r23, X
    12e0:	04 17       	cp	r16, r20
    12e2:	15 07       	cpc	r17, r21
    12e4:	26 07       	cpc	r18, r22
    12e6:	37 07       	cpc	r19, r23
    12e8:	90 f7       	brcc	.-28     	; 0x12ce <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    12ea:	a4 81       	ldd	r26, Z+4	; 0x04
    12ec:	b5 81       	ldd	r27, Z+5	; 0x05
    12ee:	ac 83       	std	Y+4, r26	; 0x04
    12f0:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    12f2:	16 96       	adiw	r26, 0x06	; 6
    12f4:	cd 93       	st	X+, r28
    12f6:	dc 93       	st	X, r29
    12f8:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    12fa:	ee 83       	std	Y+6, r30	; 0x06
    12fc:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    12fe:	c4 83       	std	Z+4, r28	; 0x04
    1300:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1302:	8a 87       	std	Y+10, r24	; 0x0a
    1304:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1306:	fc 01       	movw	r30, r24
    1308:	20 81       	ld	r18, Z
    130a:	2f 5f       	subi	r18, 0xFF	; 255
    130c:	20 83       	st	Z, r18
}
    130e:	df 91       	pop	r29
    1310:	cf 91       	pop	r28
    1312:	1f 91       	pop	r17
    1314:	0f 91       	pop	r16
    1316:	08 95       	ret

00001318 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1318:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    131a:	a4 81       	ldd	r26, Z+4	; 0x04
    131c:	b5 81       	ldd	r27, Z+5	; 0x05
    131e:	86 81       	ldd	r24, Z+6	; 0x06
    1320:	97 81       	ldd	r25, Z+7	; 0x07
    1322:	16 96       	adiw	r26, 0x06	; 6
    1324:	8d 93       	st	X+, r24
    1326:	9c 93       	st	X, r25
    1328:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    132a:	a6 81       	ldd	r26, Z+6	; 0x06
    132c:	b7 81       	ldd	r27, Z+7	; 0x07
    132e:	84 81       	ldd	r24, Z+4	; 0x04
    1330:	95 81       	ldd	r25, Z+5	; 0x05
    1332:	14 96       	adiw	r26, 0x04	; 4
    1334:	8d 93       	st	X+, r24
    1336:	9c 93       	st	X, r25
    1338:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    133a:	a2 85       	ldd	r26, Z+10	; 0x0a
    133c:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    133e:	11 96       	adiw	r26, 0x01	; 1
    1340:	8d 91       	ld	r24, X+
    1342:	9c 91       	ld	r25, X
    1344:	12 97       	sbiw	r26, 0x02	; 2
    1346:	e8 17       	cp	r30, r24
    1348:	f9 07       	cpc	r31, r25
    134a:	31 f4       	brne	.+12     	; 0x1358 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    134c:	86 81       	ldd	r24, Z+6	; 0x06
    134e:	97 81       	ldd	r25, Z+7	; 0x07
    1350:	11 96       	adiw	r26, 0x01	; 1
    1352:	8d 93       	st	X+, r24
    1354:	9c 93       	st	X, r25
    1356:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1358:	12 86       	std	Z+10, r1	; 0x0a
    135a:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    135c:	8c 91       	ld	r24, X
    135e:	81 50       	subi	r24, 0x01	; 1
    1360:	8c 93       	st	X, r24
    1362:	08 95       	ret

00001364 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1364:	80 93 ac 31 	sts	0x31AC, r24	; 0x8031ac <portStackTopForTask>
    1368:	90 93 ad 31 	sts	0x31AD, r25	; 0x8031ad <portStackTopForTask+0x1>
    136c:	31 e1       	ldi	r19, 0x11	; 17
    136e:	fc 01       	movw	r30, r24
    1370:	30 83       	st	Z, r19
    1372:	31 97       	sbiw	r30, 0x01	; 1
    1374:	22 e2       	ldi	r18, 0x22	; 34
    1376:	20 83       	st	Z, r18
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	a3 e3       	ldi	r26, 0x33	; 51
    137c:	a0 83       	st	Z, r26
    137e:	31 97       	sbiw	r30, 0x01	; 1
    1380:	60 83       	st	Z, r22
    1382:	31 97       	sbiw	r30, 0x01	; 1
    1384:	70 83       	st	Z, r23
    1386:	31 97       	sbiw	r30, 0x01	; 1
    1388:	10 82       	st	Z, r1
    138a:	31 97       	sbiw	r30, 0x01	; 1
    138c:	10 82       	st	Z, r1
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	60 e8       	ldi	r22, 0x80	; 128
    1392:	60 83       	st	Z, r22
    1394:	31 97       	sbiw	r30, 0x01	; 1
    1396:	10 82       	st	Z, r1
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	10 82       	st	Z, r1
    139c:	31 97       	sbiw	r30, 0x01	; 1
    139e:	10 82       	st	Z, r1
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	62 e0       	ldi	r22, 0x02	; 2
    13a4:	60 83       	st	Z, r22
    13a6:	31 97       	sbiw	r30, 0x01	; 1
    13a8:	63 e0       	ldi	r22, 0x03	; 3
    13aa:	60 83       	st	Z, r22
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	64 e0       	ldi	r22, 0x04	; 4
    13b0:	60 83       	st	Z, r22
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	65 e0       	ldi	r22, 0x05	; 5
    13b6:	60 83       	st	Z, r22
    13b8:	31 97       	sbiw	r30, 0x01	; 1
    13ba:	66 e0       	ldi	r22, 0x06	; 6
    13bc:	60 83       	st	Z, r22
    13be:	31 97       	sbiw	r30, 0x01	; 1
    13c0:	67 e0       	ldi	r22, 0x07	; 7
    13c2:	60 83       	st	Z, r22
    13c4:	31 97       	sbiw	r30, 0x01	; 1
    13c6:	68 e0       	ldi	r22, 0x08	; 8
    13c8:	60 83       	st	Z, r22
    13ca:	31 97       	sbiw	r30, 0x01	; 1
    13cc:	69 e0       	ldi	r22, 0x09	; 9
    13ce:	60 83       	st	Z, r22
    13d0:	31 97       	sbiw	r30, 0x01	; 1
    13d2:	60 e1       	ldi	r22, 0x10	; 16
    13d4:	60 83       	st	Z, r22
    13d6:	31 97       	sbiw	r30, 0x01	; 1
    13d8:	30 83       	st	Z, r19
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	32 e1       	ldi	r19, 0x12	; 18
    13de:	30 83       	st	Z, r19
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	33 e1       	ldi	r19, 0x13	; 19
    13e4:	30 83       	st	Z, r19
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	34 e1       	ldi	r19, 0x14	; 20
    13ea:	30 83       	st	Z, r19
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	35 e1       	ldi	r19, 0x15	; 21
    13f0:	30 83       	st	Z, r19
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	36 e1       	ldi	r19, 0x16	; 22
    13f6:	30 83       	st	Z, r19
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	37 e1       	ldi	r19, 0x17	; 23
    13fc:	30 83       	st	Z, r19
    13fe:	31 97       	sbiw	r30, 0x01	; 1
    1400:	38 e1       	ldi	r19, 0x18	; 24
    1402:	30 83       	st	Z, r19
    1404:	31 97       	sbiw	r30, 0x01	; 1
    1406:	39 e1       	ldi	r19, 0x19	; 25
    1408:	30 83       	st	Z, r19
    140a:	31 97       	sbiw	r30, 0x01	; 1
    140c:	30 e2       	ldi	r19, 0x20	; 32
    140e:	30 83       	st	Z, r19
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	31 e2       	ldi	r19, 0x21	; 33
    1414:	30 83       	st	Z, r19
    1416:	31 97       	sbiw	r30, 0x01	; 1
    1418:	20 83       	st	Z, r18
    141a:	31 97       	sbiw	r30, 0x01	; 1
    141c:	23 e2       	ldi	r18, 0x23	; 35
    141e:	20 83       	st	Z, r18
    1420:	31 97       	sbiw	r30, 0x01	; 1
    1422:	40 83       	st	Z, r20
    1424:	31 97       	sbiw	r30, 0x01	; 1
    1426:	50 83       	st	Z, r21
    1428:	31 97       	sbiw	r30, 0x01	; 1
    142a:	26 e2       	ldi	r18, 0x26	; 38
    142c:	20 83       	st	Z, r18
    142e:	31 97       	sbiw	r30, 0x01	; 1
    1430:	27 e2       	ldi	r18, 0x27	; 39
    1432:	20 83       	st	Z, r18
    1434:	31 97       	sbiw	r30, 0x01	; 1
    1436:	28 e2       	ldi	r18, 0x28	; 40
    1438:	20 83       	st	Z, r18
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	29 e2       	ldi	r18, 0x29	; 41
    143e:	20 83       	st	Z, r18
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	20 e3       	ldi	r18, 0x30	; 48
    1444:	20 83       	st	Z, r18
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	21 e3       	ldi	r18, 0x31	; 49
    144a:	20 83       	st	Z, r18
    144c:	89 97       	sbiw	r24, 0x29	; 41
    144e:	08 95       	ret

00001450 <xPortStartScheduler>:
    1450:	8c e7       	ldi	r24, 0x7C	; 124
    1452:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1456:	8f ef       	ldi	r24, 0xFF	; 255
    1458:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1462:	91 e1       	ldi	r25, 0x11	; 17
    1464:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1468:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    146c:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    1470:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1474:	cd 91       	ld	r28, X+
    1476:	cd bf       	out	0x3d, r28	; 61
    1478:	dd 91       	ld	r29, X+
    147a:	de bf       	out	0x3e, r29	; 62
    147c:	ff 91       	pop	r31
    147e:	ef 91       	pop	r30
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	bf 91       	pop	r27
    1486:	af 91       	pop	r26
    1488:	9f 91       	pop	r25
    148a:	8f 91       	pop	r24
    148c:	7f 91       	pop	r23
    148e:	6f 91       	pop	r22
    1490:	5f 91       	pop	r21
    1492:	4f 91       	pop	r20
    1494:	3f 91       	pop	r19
    1496:	2f 91       	pop	r18
    1498:	1f 91       	pop	r17
    149a:	0f 91       	pop	r16
    149c:	ff 90       	pop	r15
    149e:	ef 90       	pop	r14
    14a0:	df 90       	pop	r13
    14a2:	cf 90       	pop	r12
    14a4:	bf 90       	pop	r11
    14a6:	af 90       	pop	r10
    14a8:	9f 90       	pop	r9
    14aa:	8f 90       	pop	r8
    14ac:	7f 90       	pop	r7
    14ae:	6f 90       	pop	r6
    14b0:	5f 90       	pop	r5
    14b2:	4f 90       	pop	r4
    14b4:	3f 90       	pop	r3
    14b6:	2f 90       	pop	r2
    14b8:	1f 90       	pop	r1
    14ba:	0f 90       	pop	r0
    14bc:	0c be       	out	0x3c, r0	; 60
    14be:	0f 90       	pop	r0
    14c0:	0b be       	out	0x3b, r0	; 59
    14c2:	0f 90       	pop	r0
    14c4:	0f be       	out	0x3f, r0	; 63
    14c6:	0f 90       	pop	r0
    14c8:	08 95       	ret
    14ca:	08 95       	ret

000014cc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14cc:	0f 92       	push	r0
    14ce:	0f b6       	in	r0, 0x3f	; 63
    14d0:	f8 94       	cli
    14d2:	0f 92       	push	r0
    14d4:	0b b6       	in	r0, 0x3b	; 59
    14d6:	0f 92       	push	r0
    14d8:	0c b6       	in	r0, 0x3c	; 60
    14da:	0f 92       	push	r0
    14dc:	1f 92       	push	r1
    14de:	11 24       	eor	r1, r1
    14e0:	2f 92       	push	r2
    14e2:	3f 92       	push	r3
    14e4:	4f 92       	push	r4
    14e6:	5f 92       	push	r5
    14e8:	6f 92       	push	r6
    14ea:	7f 92       	push	r7
    14ec:	8f 92       	push	r8
    14ee:	9f 92       	push	r9
    14f0:	af 92       	push	r10
    14f2:	bf 92       	push	r11
    14f4:	cf 92       	push	r12
    14f6:	df 92       	push	r13
    14f8:	ef 92       	push	r14
    14fa:	ff 92       	push	r15
    14fc:	0f 93       	push	r16
    14fe:	1f 93       	push	r17
    1500:	2f 93       	push	r18
    1502:	3f 93       	push	r19
    1504:	4f 93       	push	r20
    1506:	5f 93       	push	r21
    1508:	6f 93       	push	r22
    150a:	7f 93       	push	r23
    150c:	8f 93       	push	r24
    150e:	9f 93       	push	r25
    1510:	af 93       	push	r26
    1512:	bf 93       	push	r27
    1514:	cf 93       	push	r28
    1516:	df 93       	push	r29
    1518:	ef 93       	push	r30
    151a:	ff 93       	push	r31
    151c:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    1520:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1524:	0d b6       	in	r0, 0x3d	; 61
    1526:	0d 92       	st	X+, r0
    1528:	0e b6       	in	r0, 0x3e	; 62
    152a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    152c:	0e 94 75 11 	call	0x22ea	; 0x22ea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1530:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    1534:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1538:	cd 91       	ld	r28, X+
    153a:	cd bf       	out	0x3d, r28	; 61
    153c:	dd 91       	ld	r29, X+
    153e:	de bf       	out	0x3e, r29	; 62
    1540:	ff 91       	pop	r31
    1542:	ef 91       	pop	r30
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	bf 91       	pop	r27
    154a:	af 91       	pop	r26
    154c:	9f 91       	pop	r25
    154e:	8f 91       	pop	r24
    1550:	7f 91       	pop	r23
    1552:	6f 91       	pop	r22
    1554:	5f 91       	pop	r21
    1556:	4f 91       	pop	r20
    1558:	3f 91       	pop	r19
    155a:	2f 91       	pop	r18
    155c:	1f 91       	pop	r17
    155e:	0f 91       	pop	r16
    1560:	ff 90       	pop	r15
    1562:	ef 90       	pop	r14
    1564:	df 90       	pop	r13
    1566:	cf 90       	pop	r12
    1568:	bf 90       	pop	r11
    156a:	af 90       	pop	r10
    156c:	9f 90       	pop	r9
    156e:	8f 90       	pop	r8
    1570:	7f 90       	pop	r7
    1572:	6f 90       	pop	r6
    1574:	5f 90       	pop	r5
    1576:	4f 90       	pop	r4
    1578:	3f 90       	pop	r3
    157a:	2f 90       	pop	r2
    157c:	1f 90       	pop	r1
    157e:	0f 90       	pop	r0
    1580:	0c be       	out	0x3c, r0	; 60
    1582:	0f 90       	pop	r0
    1584:	0b be       	out	0x3b, r0	; 59
    1586:	0f 90       	pop	r0
    1588:	0f be       	out	0x3f, r0	; 63
    158a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    158c:	08 95       	ret

0000158e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    158e:	0f 92       	push	r0
    1590:	0f b6       	in	r0, 0x3f	; 63
    1592:	f8 94       	cli
    1594:	0f 92       	push	r0
    1596:	0b b6       	in	r0, 0x3b	; 59
    1598:	0f 92       	push	r0
    159a:	0c b6       	in	r0, 0x3c	; 60
    159c:	0f 92       	push	r0
    159e:	1f 92       	push	r1
    15a0:	11 24       	eor	r1, r1
    15a2:	2f 92       	push	r2
    15a4:	3f 92       	push	r3
    15a6:	4f 92       	push	r4
    15a8:	5f 92       	push	r5
    15aa:	6f 92       	push	r6
    15ac:	7f 92       	push	r7
    15ae:	8f 92       	push	r8
    15b0:	9f 92       	push	r9
    15b2:	af 92       	push	r10
    15b4:	bf 92       	push	r11
    15b6:	cf 92       	push	r12
    15b8:	df 92       	push	r13
    15ba:	ef 92       	push	r14
    15bc:	ff 92       	push	r15
    15be:	0f 93       	push	r16
    15c0:	1f 93       	push	r17
    15c2:	2f 93       	push	r18
    15c4:	3f 93       	push	r19
    15c6:	4f 93       	push	r20
    15c8:	5f 93       	push	r21
    15ca:	6f 93       	push	r22
    15cc:	7f 93       	push	r23
    15ce:	8f 93       	push	r24
    15d0:	9f 93       	push	r25
    15d2:	af 93       	push	r26
    15d4:	bf 93       	push	r27
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	ef 93       	push	r30
    15dc:	ff 93       	push	r31
    15de:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    15e2:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    15e6:	0d b6       	in	r0, 0x3d	; 61
    15e8:	0d 92       	st	X+, r0
    15ea:	0e b6       	in	r0, 0x3e	; 62
    15ec:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    15ee:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <vTaskIncrementTick>
	vTaskSwitchContext();
    15f2:	0e 94 75 11 	call	0x22ea	; 0x22ea <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15f6:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    15fa:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    15fe:	cd 91       	ld	r28, X+
    1600:	cd bf       	out	0x3d, r28	; 61
    1602:	dd 91       	ld	r29, X+
    1604:	de bf       	out	0x3e, r29	; 62
    1606:	ff 91       	pop	r31
    1608:	ef 91       	pop	r30
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	bf 91       	pop	r27
    1610:	af 91       	pop	r26
    1612:	9f 91       	pop	r25
    1614:	8f 91       	pop	r24
    1616:	7f 91       	pop	r23
    1618:	6f 91       	pop	r22
    161a:	5f 91       	pop	r21
    161c:	4f 91       	pop	r20
    161e:	3f 91       	pop	r19
    1620:	2f 91       	pop	r18
    1622:	1f 91       	pop	r17
    1624:	0f 91       	pop	r16
    1626:	ff 90       	pop	r15
    1628:	ef 90       	pop	r14
    162a:	df 90       	pop	r13
    162c:	cf 90       	pop	r12
    162e:	bf 90       	pop	r11
    1630:	af 90       	pop	r10
    1632:	9f 90       	pop	r9
    1634:	8f 90       	pop	r8
    1636:	7f 90       	pop	r7
    1638:	6f 90       	pop	r6
    163a:	5f 90       	pop	r5
    163c:	4f 90       	pop	r4
    163e:	3f 90       	pop	r3
    1640:	2f 90       	pop	r2
    1642:	1f 90       	pop	r1
    1644:	0f 90       	pop	r0
    1646:	0c be       	out	0x3c, r0	; 60
    1648:	0f 90       	pop	r0
    164a:	0b be       	out	0x3b, r0	; 59
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
    1650:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1652:	08 95       	ret

00001654 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1654:	0e 94 c7 0a 	call	0x158e	; 0x158e <vPortYieldFromTick>
		asm volatile ( "reti" );
    1658:	18 95       	reti

0000165a <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    165a:	cf 93       	push	r28
    165c:	df 93       	push	r29
    165e:	ec 01       	movw	r28, r24
    1660:	88 a1       	ldd	r24, Y+32	; 0x20
    1662:	81 11       	cpse	r24, r1
    1664:	0b c0       	rjmp	.+22     	; 0x167c <prvCopyDataToQueue+0x22>
    1666:	88 81       	ld	r24, Y
    1668:	99 81       	ldd	r25, Y+1	; 0x01
    166a:	89 2b       	or	r24, r25
    166c:	e1 f5       	brne	.+120    	; 0x16e6 <prvCopyDataToQueue+0x8c>
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	9b 81       	ldd	r25, Y+3	; 0x03
    1672:	0e 94 30 13 	call	0x2660	; 0x2660 <vTaskPriorityDisinherit>
    1676:	1a 82       	std	Y+2, r1	; 0x02
    1678:	1b 82       	std	Y+3, r1	; 0x03
    167a:	35 c0       	rjmp	.+106    	; 0x16e6 <prvCopyDataToQueue+0x8c>
    167c:	41 11       	cpse	r20, r1
    167e:	17 c0       	rjmp	.+46     	; 0x16ae <prvCopyDataToQueue+0x54>
    1680:	48 2f       	mov	r20, r24
    1682:	50 e0       	ldi	r21, 0x00	; 0
    1684:	8c 81       	ldd	r24, Y+4	; 0x04
    1686:	9d 81       	ldd	r25, Y+5	; 0x05
    1688:	0e 94 63 20 	call	0x40c6	; 0x40c6 <memcpy>
    168c:	28 a1       	ldd	r18, Y+32	; 0x20
    168e:	8c 81       	ldd	r24, Y+4	; 0x04
    1690:	9d 81       	ldd	r25, Y+5	; 0x05
    1692:	82 0f       	add	r24, r18
    1694:	91 1d       	adc	r25, r1
    1696:	8c 83       	std	Y+4, r24	; 0x04
    1698:	9d 83       	std	Y+5, r25	; 0x05
    169a:	2a 81       	ldd	r18, Y+2	; 0x02
    169c:	3b 81       	ldd	r19, Y+3	; 0x03
    169e:	82 17       	cp	r24, r18
    16a0:	93 07       	cpc	r25, r19
    16a2:	08 f1       	brcs	.+66     	; 0x16e6 <prvCopyDataToQueue+0x8c>
    16a4:	88 81       	ld	r24, Y
    16a6:	99 81       	ldd	r25, Y+1	; 0x01
    16a8:	8c 83       	std	Y+4, r24	; 0x04
    16aa:	9d 83       	std	Y+5, r25	; 0x05
    16ac:	1c c0       	rjmp	.+56     	; 0x16e6 <prvCopyDataToQueue+0x8c>
    16ae:	48 2f       	mov	r20, r24
    16b0:	50 e0       	ldi	r21, 0x00	; 0
    16b2:	8e 81       	ldd	r24, Y+6	; 0x06
    16b4:	9f 81       	ldd	r25, Y+7	; 0x07
    16b6:	0e 94 63 20 	call	0x40c6	; 0x40c6 <memcpy>
    16ba:	88 a1       	ldd	r24, Y+32	; 0x20
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	91 95       	neg	r25
    16c0:	81 95       	neg	r24
    16c2:	91 09       	sbc	r25, r1
    16c4:	2e 81       	ldd	r18, Y+6	; 0x06
    16c6:	3f 81       	ldd	r19, Y+7	; 0x07
    16c8:	28 0f       	add	r18, r24
    16ca:	39 1f       	adc	r19, r25
    16cc:	2e 83       	std	Y+6, r18	; 0x06
    16ce:	3f 83       	std	Y+7, r19	; 0x07
    16d0:	48 81       	ld	r20, Y
    16d2:	59 81       	ldd	r21, Y+1	; 0x01
    16d4:	24 17       	cp	r18, r20
    16d6:	35 07       	cpc	r19, r21
    16d8:	30 f4       	brcc	.+12     	; 0x16e6 <prvCopyDataToQueue+0x8c>
    16da:	2a 81       	ldd	r18, Y+2	; 0x02
    16dc:	3b 81       	ldd	r19, Y+3	; 0x03
    16de:	82 0f       	add	r24, r18
    16e0:	93 1f       	adc	r25, r19
    16e2:	8e 83       	std	Y+6, r24	; 0x06
    16e4:	9f 83       	std	Y+7, r25	; 0x07
    16e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16e8:	8f 5f       	subi	r24, 0xFF	; 255
    16ea:	8e 8f       	std	Y+30, r24	; 0x1e
    16ec:	df 91       	pop	r29
    16ee:	cf 91       	pop	r28
    16f0:	08 95       	ret

000016f2 <prvCopyDataFromQueue>:
    16f2:	fc 01       	movw	r30, r24
    16f4:	80 81       	ld	r24, Z
    16f6:	91 81       	ldd	r25, Z+1	; 0x01
    16f8:	00 97       	sbiw	r24, 0x00	; 0
    16fa:	a1 f0       	breq	.+40     	; 0x1724 <prvCopyDataFromQueue+0x32>
    16fc:	40 a1       	ldd	r20, Z+32	; 0x20
    16fe:	50 e0       	ldi	r21, 0x00	; 0
    1700:	26 81       	ldd	r18, Z+6	; 0x06
    1702:	37 81       	ldd	r19, Z+7	; 0x07
    1704:	24 0f       	add	r18, r20
    1706:	35 1f       	adc	r19, r21
    1708:	26 83       	std	Z+6, r18	; 0x06
    170a:	37 83       	std	Z+7, r19	; 0x07
    170c:	a2 81       	ldd	r26, Z+2	; 0x02
    170e:	b3 81       	ldd	r27, Z+3	; 0x03
    1710:	2a 17       	cp	r18, r26
    1712:	3b 07       	cpc	r19, r27
    1714:	10 f0       	brcs	.+4      	; 0x171a <prvCopyDataFromQueue+0x28>
    1716:	86 83       	std	Z+6, r24	; 0x06
    1718:	97 83       	std	Z+7, r25	; 0x07
    171a:	cb 01       	movw	r24, r22
    171c:	66 81       	ldd	r22, Z+6	; 0x06
    171e:	77 81       	ldd	r23, Z+7	; 0x07
    1720:	0e 94 63 20 	call	0x40c6	; 0x40c6 <memcpy>
    1724:	08 95       	ret

00001726 <prvUnlockQueue>:
    1726:	0f 93       	push	r16
    1728:	1f 93       	push	r17
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	ec 01       	movw	r28, r24
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	0f 92       	push	r0
    1736:	8a a1       	ldd	r24, Y+34	; 0x22
    1738:	18 16       	cp	r1, r24
    173a:	b4 f4       	brge	.+44     	; 0x1768 <prvUnlockQueue+0x42>
    173c:	8b 89       	ldd	r24, Y+19	; 0x13
    173e:	81 11       	cpse	r24, r1
    1740:	05 c0       	rjmp	.+10     	; 0x174c <prvUnlockQueue+0x26>
    1742:	12 c0       	rjmp	.+36     	; 0x1768 <prvUnlockQueue+0x42>
    1744:	8b 89       	ldd	r24, Y+19	; 0x13
    1746:	81 11       	cpse	r24, r1
    1748:	04 c0       	rjmp	.+8      	; 0x1752 <prvUnlockQueue+0x2c>
    174a:	0e c0       	rjmp	.+28     	; 0x1768 <prvUnlockQueue+0x42>
    174c:	8e 01       	movw	r16, r28
    174e:	0d 5e       	subi	r16, 0xED	; 237
    1750:	1f 4f       	sbci	r17, 0xFF	; 255
    1752:	c8 01       	movw	r24, r16
    1754:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    1758:	81 11       	cpse	r24, r1
    175a:	0e 94 b9 12 	call	0x2572	; 0x2572 <vTaskMissedYield>
    175e:	8a a1       	ldd	r24, Y+34	; 0x22
    1760:	81 50       	subi	r24, 0x01	; 1
    1762:	8a a3       	std	Y+34, r24	; 0x22
    1764:	18 16       	cp	r1, r24
    1766:	74 f3       	brlt	.-36     	; 0x1744 <prvUnlockQueue+0x1e>
    1768:	8f ef       	ldi	r24, 0xFF	; 255
    176a:	8a a3       	std	Y+34, r24	; 0x22
    176c:	0f 90       	pop	r0
    176e:	0f be       	out	0x3f, r0	; 63
    1770:	0f b6       	in	r0, 0x3f	; 63
    1772:	f8 94       	cli
    1774:	0f 92       	push	r0
    1776:	89 a1       	ldd	r24, Y+33	; 0x21
    1778:	18 16       	cp	r1, r24
    177a:	b4 f4       	brge	.+44     	; 0x17a8 <prvUnlockQueue+0x82>
    177c:	88 85       	ldd	r24, Y+8	; 0x08
    177e:	81 11       	cpse	r24, r1
    1780:	05 c0       	rjmp	.+10     	; 0x178c <prvUnlockQueue+0x66>
    1782:	12 c0       	rjmp	.+36     	; 0x17a8 <prvUnlockQueue+0x82>
    1784:	88 85       	ldd	r24, Y+8	; 0x08
    1786:	81 11       	cpse	r24, r1
    1788:	04 c0       	rjmp	.+8      	; 0x1792 <prvUnlockQueue+0x6c>
    178a:	0e c0       	rjmp	.+28     	; 0x17a8 <prvUnlockQueue+0x82>
    178c:	8e 01       	movw	r16, r28
    178e:	08 5f       	subi	r16, 0xF8	; 248
    1790:	1f 4f       	sbci	r17, 0xFF	; 255
    1792:	c8 01       	movw	r24, r16
    1794:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    1798:	81 11       	cpse	r24, r1
    179a:	0e 94 b9 12 	call	0x2572	; 0x2572 <vTaskMissedYield>
    179e:	89 a1       	ldd	r24, Y+33	; 0x21
    17a0:	81 50       	subi	r24, 0x01	; 1
    17a2:	89 a3       	std	Y+33, r24	; 0x21
    17a4:	18 16       	cp	r1, r24
    17a6:	74 f3       	brlt	.-36     	; 0x1784 <prvUnlockQueue+0x5e>
    17a8:	8f ef       	ldi	r24, 0xFF	; 255
    17aa:	89 a3       	std	Y+33, r24	; 0x21
    17ac:	0f 90       	pop	r0
    17ae:	0f be       	out	0x3f, r0	; 63
    17b0:	df 91       	pop	r29
    17b2:	cf 91       	pop	r28
    17b4:	1f 91       	pop	r17
    17b6:	0f 91       	pop	r16
    17b8:	08 95       	ret

000017ba <xQueueGenericReset>:
    17ba:	1f 93       	push	r17
    17bc:	cf 93       	push	r28
    17be:	df 93       	push	r29
    17c0:	61 30       	cpi	r22, 0x01	; 1
    17c2:	59 f0       	breq	.+22     	; 0x17da <xQueueGenericReset+0x20>
    17c4:	fc 01       	movw	r30, r24
    17c6:	23 89       	ldd	r18, Z+19	; 0x13
    17c8:	30 85       	ldd	r19, Z+8	; 0x08
    17ca:	31 11       	cpse	r19, r1
    17cc:	2c c0       	rjmp	.+88     	; 0x1826 <xQueueGenericReset+0x6c>
    17ce:	11 e0       	ldi	r17, 0x01	; 1
    17d0:	21 11       	cpse	r18, r1
    17d2:	10 e0       	ldi	r17, 0x00	; 0
    17d4:	21 11       	cpse	r18, r1
    17d6:	28 c0       	rjmp	.+80     	; 0x1828 <xQueueGenericReset+0x6e>
    17d8:	01 c0       	rjmp	.+2      	; 0x17dc <xQueueGenericReset+0x22>
    17da:	11 e0       	ldi	r17, 0x01	; 1
    17dc:	ec 01       	movw	r28, r24
    17de:	48 81       	ld	r20, Y
    17e0:	59 81       	ldd	r21, Y+1	; 0x01
    17e2:	28 a1       	ldd	r18, Y+32	; 0x20
    17e4:	30 e0       	ldi	r19, 0x00	; 0
    17e6:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17e8:	62 9f       	mul	r22, r18
    17ea:	c0 01       	movw	r24, r0
    17ec:	63 9f       	mul	r22, r19
    17ee:	90 0d       	add	r25, r0
    17f0:	11 24       	eor	r1, r1
    17f2:	ba 01       	movw	r22, r20
    17f4:	68 0f       	add	r22, r24
    17f6:	79 1f       	adc	r23, r25
    17f8:	6a 83       	std	Y+2, r22	; 0x02
    17fa:	7b 83       	std	Y+3, r23	; 0x03
    17fc:	1e 8e       	std	Y+30, r1	; 0x1e
    17fe:	4c 83       	std	Y+4, r20	; 0x04
    1800:	5d 83       	std	Y+5, r21	; 0x05
    1802:	82 1b       	sub	r24, r18
    1804:	93 0b       	sbc	r25, r19
    1806:	84 0f       	add	r24, r20
    1808:	95 1f       	adc	r25, r21
    180a:	8e 83       	std	Y+6, r24	; 0x06
    180c:	9f 83       	std	Y+7, r25	; 0x07
    180e:	8f ef       	ldi	r24, 0xFF	; 255
    1810:	89 a3       	std	Y+33, r24	; 0x21
    1812:	8a a3       	std	Y+34, r24	; 0x22
    1814:	ce 01       	movw	r24, r28
    1816:	08 96       	adiw	r24, 0x08	; 8
    1818:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    181c:	ce 01       	movw	r24, r28
    181e:	43 96       	adiw	r24, 0x13	; 19
    1820:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1824:	01 c0       	rjmp	.+2      	; 0x1828 <xQueueGenericReset+0x6e>
    1826:	10 e0       	ldi	r17, 0x00	; 0
    1828:	81 2f       	mov	r24, r17
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	1f 91       	pop	r17
    1830:	08 95       	ret

00001832 <xQueueGenericCreate>:
    1832:	0f 93       	push	r16
    1834:	1f 93       	push	r17
    1836:	cf 93       	push	r28
    1838:	df 93       	push	r29
    183a:	88 23       	and	r24, r24
    183c:	01 f1       	breq	.+64     	; 0x187e <xQueueGenericCreate+0x4c>
    183e:	06 2f       	mov	r16, r22
    1840:	18 2f       	mov	r17, r24
    1842:	83 e2       	ldi	r24, 0x23	; 35
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    184a:	ec 01       	movw	r28, r24
    184c:	89 2b       	or	r24, r25
    184e:	c9 f0       	breq	.+50     	; 0x1882 <xQueueGenericCreate+0x50>
    1850:	10 9f       	mul	r17, r16
    1852:	c0 01       	movw	r24, r0
    1854:	11 24       	eor	r1, r1
    1856:	01 96       	adiw	r24, 0x01	; 1
    1858:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    185c:	88 83       	st	Y, r24
    185e:	99 83       	std	Y+1, r25	; 0x01
    1860:	89 2b       	or	r24, r25
    1862:	39 f0       	breq	.+14     	; 0x1872 <xQueueGenericCreate+0x40>
    1864:	1f 8f       	std	Y+31, r17	; 0x1f
    1866:	08 a3       	std	Y+32, r16	; 0x20
    1868:	61 e0       	ldi	r22, 0x01	; 1
    186a:	ce 01       	movw	r24, r28
    186c:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <xQueueGenericReset>
    1870:	08 c0       	rjmp	.+16     	; 0x1882 <xQueueGenericCreate+0x50>
    1872:	ce 01       	movw	r24, r28
    1874:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
    1878:	c0 e0       	ldi	r28, 0x00	; 0
    187a:	d0 e0       	ldi	r29, 0x00	; 0
    187c:	02 c0       	rjmp	.+4      	; 0x1882 <xQueueGenericCreate+0x50>
    187e:	c0 e0       	ldi	r28, 0x00	; 0
    1880:	d0 e0       	ldi	r29, 0x00	; 0
    1882:	ce 01       	movw	r24, r28
    1884:	df 91       	pop	r29
    1886:	cf 91       	pop	r28
    1888:	1f 91       	pop	r17
    188a:	0f 91       	pop	r16
    188c:	08 95       	ret

0000188e <xQueueGenericSend>:
    188e:	af 92       	push	r10
    1890:	bf 92       	push	r11
    1892:	cf 92       	push	r12
    1894:	df 92       	push	r13
    1896:	ef 92       	push	r14
    1898:	ff 92       	push	r15
    189a:	0f 93       	push	r16
    189c:	1f 93       	push	r17
    189e:	cf 93       	push	r28
    18a0:	df 93       	push	r29
    18a2:	cd b7       	in	r28, 0x3d	; 61
    18a4:	de b7       	in	r29, 0x3e	; 62
    18a6:	29 97       	sbiw	r28, 0x09	; 9
    18a8:	cd bf       	out	0x3d, r28	; 61
    18aa:	de bf       	out	0x3e, r29	; 62
    18ac:	7c 01       	movw	r14, r24
    18ae:	5b 01       	movw	r10, r22
    18b0:	2e 83       	std	Y+6, r18	; 0x06
    18b2:	3f 83       	std	Y+7, r19	; 0x07
    18b4:	48 87       	std	Y+8, r20	; 0x08
    18b6:	59 87       	std	Y+9, r21	; 0x09
    18b8:	10 e0       	ldi	r17, 0x00	; 0
    18ba:	6c 01       	movw	r12, r24
    18bc:	88 e0       	ldi	r24, 0x08	; 8
    18be:	c8 0e       	add	r12, r24
    18c0:	d1 1c       	adc	r13, r1
    18c2:	0f b6       	in	r0, 0x3f	; 63
    18c4:	f8 94       	cli
    18c6:	0f 92       	push	r0
    18c8:	f7 01       	movw	r30, r14
    18ca:	96 8d       	ldd	r25, Z+30	; 0x1e
    18cc:	87 8d       	ldd	r24, Z+31	; 0x1f
    18ce:	98 17       	cp	r25, r24
    18d0:	a8 f4       	brcc	.+42     	; 0x18fc <xQueueGenericSend+0x6e>
    18d2:	40 2f       	mov	r20, r16
    18d4:	b5 01       	movw	r22, r10
    18d6:	c7 01       	movw	r24, r14
    18d8:	0e 94 2d 0b 	call	0x165a	; 0x165a <prvCopyDataToQueue>
    18dc:	f7 01       	movw	r30, r14
    18de:	83 89       	ldd	r24, Z+19	; 0x13
    18e0:	88 23       	and	r24, r24
    18e2:	41 f0       	breq	.+16     	; 0x18f4 <xQueueGenericSend+0x66>
    18e4:	c7 01       	movw	r24, r14
    18e6:	43 96       	adiw	r24, 0x13	; 19
    18e8:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    18ec:	81 30       	cpi	r24, 0x01	; 1
    18ee:	11 f4       	brne	.+4      	; 0x18f4 <xQueueGenericSend+0x66>
    18f0:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    18f4:	0f 90       	pop	r0
    18f6:	0f be       	out	0x3f, r0	; 63
    18f8:	81 e0       	ldi	r24, 0x01	; 1
    18fa:	56 c0       	rjmp	.+172    	; 0x19a8 <xQueueGenericSend+0x11a>
    18fc:	8e 81       	ldd	r24, Y+6	; 0x06
    18fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1900:	a8 85       	ldd	r26, Y+8	; 0x08
    1902:	b9 85       	ldd	r27, Y+9	; 0x09
    1904:	89 2b       	or	r24, r25
    1906:	8a 2b       	or	r24, r26
    1908:	8b 2b       	or	r24, r27
    190a:	21 f4       	brne	.+8      	; 0x1914 <xQueueGenericSend+0x86>
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	4a c0       	rjmp	.+148    	; 0x19a8 <xQueueGenericSend+0x11a>
    1914:	11 11       	cpse	r17, r1
    1916:	05 c0       	rjmp	.+10     	; 0x1922 <xQueueGenericSend+0x94>
    1918:	ce 01       	movw	r24, r28
    191a:	01 96       	adiw	r24, 0x01	; 1
    191c:	0e 94 3b 12 	call	0x2476	; 0x2476 <vTaskSetTimeOutState>
    1920:	11 e0       	ldi	r17, 0x01	; 1
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskSuspendAll>
    192a:	0f b6       	in	r0, 0x3f	; 63
    192c:	f8 94       	cli
    192e:	0f 92       	push	r0
    1930:	f7 01       	movw	r30, r14
    1932:	81 a1       	ldd	r24, Z+33	; 0x21
    1934:	8f 3f       	cpi	r24, 0xFF	; 255
    1936:	09 f4       	brne	.+2      	; 0x193a <xQueueGenericSend+0xac>
    1938:	11 a2       	std	Z+33, r1	; 0x21
    193a:	f7 01       	movw	r30, r14
    193c:	82 a1       	ldd	r24, Z+34	; 0x22
    193e:	8f 3f       	cpi	r24, 0xFF	; 255
    1940:	09 f4       	brne	.+2      	; 0x1944 <xQueueGenericSend+0xb6>
    1942:	12 a2       	std	Z+34, r1	; 0x22
    1944:	0f 90       	pop	r0
    1946:	0f be       	out	0x3f, r0	; 63
    1948:	be 01       	movw	r22, r28
    194a:	6a 5f       	subi	r22, 0xFA	; 250
    194c:	7f 4f       	sbci	r23, 0xFF	; 255
    194e:	ce 01       	movw	r24, r28
    1950:	01 96       	adiw	r24, 0x01	; 1
    1952:	0e 94 4c 12 	call	0x2498	; 0x2498 <xTaskCheckForTimeOut>
    1956:	81 11       	cpse	r24, r1
    1958:	21 c0       	rjmp	.+66     	; 0x199c <xQueueGenericSend+0x10e>
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	0f 92       	push	r0
    1960:	f7 01       	movw	r30, r14
    1962:	96 8d       	ldd	r25, Z+30	; 0x1e
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	87 8d       	ldd	r24, Z+31	; 0x1f
    196a:	98 13       	cpse	r25, r24
    196c:	11 c0       	rjmp	.+34     	; 0x1990 <xQueueGenericSend+0x102>
    196e:	4e 81       	ldd	r20, Y+6	; 0x06
    1970:	5f 81       	ldd	r21, Y+7	; 0x07
    1972:	68 85       	ldd	r22, Y+8	; 0x08
    1974:	79 85       	ldd	r23, Y+9	; 0x09
    1976:	c6 01       	movw	r24, r12
    1978:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <vTaskPlaceOnEventList>
    197c:	c7 01       	movw	r24, r14
    197e:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
    1982:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
    1986:	81 11       	cpse	r24, r1
    1988:	9c cf       	rjmp	.-200    	; 0x18c2 <xQueueGenericSend+0x34>
    198a:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    198e:	99 cf       	rjmp	.-206    	; 0x18c2 <xQueueGenericSend+0x34>
    1990:	c7 01       	movw	r24, r14
    1992:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
    1996:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
    199a:	93 cf       	rjmp	.-218    	; 0x18c2 <xQueueGenericSend+0x34>
    199c:	c7 01       	movw	r24, r14
    199e:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
    19a2:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
    19a6:	80 e0       	ldi	r24, 0x00	; 0
    19a8:	29 96       	adiw	r28, 0x09	; 9
    19aa:	cd bf       	out	0x3d, r28	; 61
    19ac:	de bf       	out	0x3e, r29	; 62
    19ae:	df 91       	pop	r29
    19b0:	cf 91       	pop	r28
    19b2:	1f 91       	pop	r17
    19b4:	0f 91       	pop	r16
    19b6:	ff 90       	pop	r15
    19b8:	ef 90       	pop	r14
    19ba:	df 90       	pop	r13
    19bc:	cf 90       	pop	r12
    19be:	bf 90       	pop	r11
    19c0:	af 90       	pop	r10
    19c2:	08 95       	ret

000019c4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    19c4:	0f 93       	push	r16
    19c6:	1f 93       	push	r17
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
    19cc:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19ce:	fc 01       	movw	r30, r24
    19d0:	56 8d       	ldd	r21, Z+30	; 0x1e
    19d2:	37 8d       	ldd	r19, Z+31	; 0x1f
    19d4:	53 17       	cp	r21, r19
    19d6:	c0 f4       	brcc	.+48     	; 0x1a08 <xQueueGenericSendFromISR+0x44>
    19d8:	42 2f       	mov	r20, r18
    19da:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19dc:	0e 94 2d 0b 	call	0x165a	; 0x165a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    19e0:	8a a1       	ldd	r24, Y+34	; 0x22
    19e2:	8f 3f       	cpi	r24, 0xFF	; 255
    19e4:	69 f4       	brne	.+26     	; 0x1a00 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19e6:	8b 89       	ldd	r24, Y+19	; 0x13
    19e8:	88 23       	and	r24, r24
    19ea:	81 f0       	breq	.+32     	; 0x1a0c <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19ec:	ce 01       	movw	r24, r28
    19ee:	43 96       	adiw	r24, 0x13	; 19
    19f0:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    19f4:	88 23       	and	r24, r24
    19f6:	61 f0       	breq	.+24     	; 0x1a10 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    19f8:	81 e0       	ldi	r24, 0x01	; 1
    19fa:	f8 01       	movw	r30, r16
    19fc:	80 83       	st	Z, r24
    19fe:	09 c0       	rjmp	.+18     	; 0x1a12 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1a00:	8f 5f       	subi	r24, 0xFF	; 255
    1a02:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1a04:	81 e0       	ldi	r24, 0x01	; 1
    1a06:	05 c0       	rjmp	.+10     	; 0x1a12 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1a08:	80 e0       	ldi	r24, 0x00	; 0
    1a0a:	03 c0       	rjmp	.+6      	; 0x1a12 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	01 c0       	rjmp	.+2      	; 0x1a12 <xQueueGenericSendFromISR+0x4e>
    1a10:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a12:	df 91       	pop	r29
    1a14:	cf 91       	pop	r28
    1a16:	1f 91       	pop	r17
    1a18:	0f 91       	pop	r16
    1a1a:	08 95       	ret

00001a1c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1a1c:	af 92       	push	r10
    1a1e:	bf 92       	push	r11
    1a20:	cf 92       	push	r12
    1a22:	df 92       	push	r13
    1a24:	ef 92       	push	r14
    1a26:	ff 92       	push	r15
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
    1a30:	cd b7       	in	r28, 0x3d	; 61
    1a32:	de b7       	in	r29, 0x3e	; 62
    1a34:	29 97       	sbiw	r28, 0x09	; 9
    1a36:	cd bf       	out	0x3d, r28	; 61
    1a38:	de bf       	out	0x3e, r29	; 62
    1a3a:	7c 01       	movw	r14, r24
    1a3c:	5b 01       	movw	r10, r22
    1a3e:	2e 83       	std	Y+6, r18	; 0x06
    1a40:	3f 83       	std	Y+7, r19	; 0x07
    1a42:	48 87       	std	Y+8, r20	; 0x08
    1a44:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1a46:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a48:	6c 01       	movw	r12, r24
    1a4a:	83 e1       	ldi	r24, 0x13	; 19
    1a4c:	c8 0e       	add	r12, r24
    1a4e:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1a56:	f7 01       	movw	r30, r14
    1a58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a5a:	88 23       	and	r24, r24
    1a5c:	99 f1       	breq	.+102    	; 0x1ac4 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1a5e:	c6 80       	ldd	r12, Z+6	; 0x06
    1a60:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a62:	b5 01       	movw	r22, r10
    1a64:	c7 01       	movw	r24, r14
    1a66:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a6a:	01 11       	cpse	r16, r1
    1a6c:	1a c0       	rjmp	.+52     	; 0x1aa2 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a6e:	f7 01       	movw	r30, r14
    1a70:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a72:	81 50       	subi	r24, 0x01	; 1
    1a74:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a76:	80 81       	ld	r24, Z
    1a78:	91 81       	ldd	r25, Z+1	; 0x01
    1a7a:	89 2b       	or	r24, r25
    1a7c:	29 f4       	brne	.+10     	; 0x1a88 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1a7e:	0e 94 d6 12 	call	0x25ac	; 0x25ac <xTaskGetCurrentTaskHandle>
    1a82:	f7 01       	movw	r30, r14
    1a84:	82 83       	std	Z+2, r24	; 0x02
    1a86:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a88:	f7 01       	movw	r30, r14
    1a8a:	80 85       	ldd	r24, Z+8	; 0x08
    1a8c:	88 23       	and	r24, r24
    1a8e:	b1 f0       	breq	.+44     	; 0x1abc <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a90:	c7 01       	movw	r24, r14
    1a92:	08 96       	adiw	r24, 0x08	; 8
    1a94:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    1a98:	81 30       	cpi	r24, 0x01	; 1
    1a9a:	81 f4       	brne	.+32     	; 0x1abc <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1a9c:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    1aa0:	0d c0       	rjmp	.+26     	; 0x1abc <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1aa2:	f7 01       	movw	r30, r14
    1aa4:	c6 82       	std	Z+6, r12	; 0x06
    1aa6:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aa8:	83 89       	ldd	r24, Z+19	; 0x13
    1aaa:	88 23       	and	r24, r24
    1aac:	39 f0       	breq	.+14     	; 0x1abc <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aae:	c7 01       	movw	r24, r14
    1ab0:	43 96       	adiw	r24, 0x13	; 19
    1ab2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    1ab6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1ab8:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1abc:	0f 90       	pop	r0
    1abe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1ac0:	81 e0       	ldi	r24, 0x01	; 1
    1ac2:	62 c0       	rjmp	.+196    	; 0x1b88 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ac4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ac6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ac8:	a8 85       	ldd	r26, Y+8	; 0x08
    1aca:	b9 85       	ldd	r27, Y+9	; 0x09
    1acc:	89 2b       	or	r24, r25
    1ace:	8a 2b       	or	r24, r26
    1ad0:	8b 2b       	or	r24, r27
    1ad2:	21 f4       	brne	.+8      	; 0x1adc <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ad4:	0f 90       	pop	r0
    1ad6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ad8:	80 e0       	ldi	r24, 0x00	; 0
    1ada:	56 c0       	rjmp	.+172    	; 0x1b88 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1adc:	11 11       	cpse	r17, r1
    1ade:	05 c0       	rjmp	.+10     	; 0x1aea <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ae0:	ce 01       	movw	r24, r28
    1ae2:	01 96       	adiw	r24, 0x01	; 1
    1ae4:	0e 94 3b 12 	call	0x2476	; 0x2476 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ae8:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1aea:	0f 90       	pop	r0
    1aec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1aee:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	0f 92       	push	r0
    1af8:	f7 01       	movw	r30, r14
    1afa:	81 a1       	ldd	r24, Z+33	; 0x21
    1afc:	8f 3f       	cpi	r24, 0xFF	; 255
    1afe:	09 f4       	brne	.+2      	; 0x1b02 <xQueueGenericReceive+0xe6>
    1b00:	11 a2       	std	Z+33, r1	; 0x21
    1b02:	f7 01       	movw	r30, r14
    1b04:	82 a1       	ldd	r24, Z+34	; 0x22
    1b06:	8f 3f       	cpi	r24, 0xFF	; 255
    1b08:	09 f4       	brne	.+2      	; 0x1b0c <xQueueGenericReceive+0xf0>
    1b0a:	12 a2       	std	Z+34, r1	; 0x22
    1b0c:	0f 90       	pop	r0
    1b0e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b10:	be 01       	movw	r22, r28
    1b12:	6a 5f       	subi	r22, 0xFA	; 250
    1b14:	7f 4f       	sbci	r23, 0xFF	; 255
    1b16:	ce 01       	movw	r24, r28
    1b18:	01 96       	adiw	r24, 0x01	; 1
    1b1a:	0e 94 4c 12 	call	0x2498	; 0x2498 <xTaskCheckForTimeOut>
    1b1e:	81 11       	cpse	r24, r1
    1b20:	2d c0       	rjmp	.+90     	; 0x1b7c <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	f8 94       	cli
    1b26:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1b28:	f7 01       	movw	r30, r14
    1b2a:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b2c:	0f 90       	pop	r0
    1b2e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b30:	81 11       	cpse	r24, r1
    1b32:	1e c0       	rjmp	.+60     	; 0x1b70 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b34:	80 81       	ld	r24, Z
    1b36:	91 81       	ldd	r25, Z+1	; 0x01
    1b38:	89 2b       	or	r24, r25
    1b3a:	49 f4       	brne	.+18     	; 0x1b4e <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    1b3c:	0f b6       	in	r0, 0x3f	; 63
    1b3e:	f8 94       	cli
    1b40:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b42:	82 81       	ldd	r24, Z+2	; 0x02
    1b44:	93 81       	ldd	r25, Z+3	; 0x03
    1b46:	0e 94 db 12 	call	0x25b6	; 0x25b6 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b4e:	4e 81       	ldd	r20, Y+6	; 0x06
    1b50:	5f 81       	ldd	r21, Y+7	; 0x07
    1b52:	68 85       	ldd	r22, Y+8	; 0x08
    1b54:	79 85       	ldd	r23, Y+9	; 0x09
    1b56:	c6 01       	movw	r24, r12
    1b58:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b5c:	c7 01       	movw	r24, r14
    1b5e:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b62:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
    1b66:	81 11       	cpse	r24, r1
    1b68:	73 cf       	rjmp	.-282    	; 0x1a50 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1b6a:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    1b6e:	70 cf       	rjmp	.-288    	; 0x1a50 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b70:	c7 01       	movw	r24, r14
    1b72:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b76:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
    1b7a:	6a cf       	rjmp	.-300    	; 0x1a50 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b7c:	c7 01       	movw	r24, r14
    1b7e:	0e 94 93 0b 	call	0x1726	; 0x1726 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b82:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b86:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b88:	29 96       	adiw	r28, 0x09	; 9
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	de bf       	out	0x3e, r29	; 62
    1b8e:	df 91       	pop	r29
    1b90:	cf 91       	pop	r28
    1b92:	1f 91       	pop	r17
    1b94:	0f 91       	pop	r16
    1b96:	ff 90       	pop	r15
    1b98:	ef 90       	pop	r14
    1b9a:	df 90       	pop	r13
    1b9c:	cf 90       	pop	r12
    1b9e:	bf 90       	pop	r11
    1ba0:	af 90       	pop	r10
    1ba2:	08 95       	ret

00001ba4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1ba4:	0f 93       	push	r16
    1ba6:	1f 93       	push	r17
    1ba8:	cf 93       	push	r28
    1baa:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1bac:	fc 01       	movw	r30, r24
    1bae:	26 8d       	ldd	r18, Z+30	; 0x1e
    1bb0:	22 23       	and	r18, r18
    1bb2:	d9 f0       	breq	.+54     	; 0x1bea <xQueueReceiveFromISR+0x46>
    1bb4:	8a 01       	movw	r16, r20
    1bb6:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1bb8:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1bbc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1bbe:	81 50       	subi	r24, 0x01	; 1
    1bc0:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1bc2:	89 a1       	ldd	r24, Y+33	; 0x21
    1bc4:	8f 3f       	cpi	r24, 0xFF	; 255
    1bc6:	69 f4       	brne	.+26     	; 0x1be2 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1bc8:	88 85       	ldd	r24, Y+8	; 0x08
    1bca:	88 23       	and	r24, r24
    1bcc:	81 f0       	breq	.+32     	; 0x1bee <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bce:	ce 01       	movw	r24, r28
    1bd0:	08 96       	adiw	r24, 0x08	; 8
    1bd2:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <xTaskRemoveFromEventList>
    1bd6:	88 23       	and	r24, r24
    1bd8:	61 f0       	breq	.+24     	; 0x1bf2 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	f8 01       	movw	r30, r16
    1bde:	80 83       	st	Z, r24
    1be0:	09 c0       	rjmp	.+18     	; 0x1bf4 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1be2:	8f 5f       	subi	r24, 0xFF	; 255
    1be4:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1be6:	81 e0       	ldi	r24, 0x01	; 1
    1be8:	05 c0       	rjmp	.+10     	; 0x1bf4 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1bea:	80 e0       	ldi	r24, 0x00	; 0
    1bec:	03 c0       	rjmp	.+6      	; 0x1bf4 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	01 c0       	rjmp	.+2      	; 0x1bf4 <xQueueReceiveFromISR+0x50>
    1bf2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1bf4:	df 91       	pop	r29
    1bf6:	cf 91       	pop	r28
    1bf8:	1f 91       	pop	r17
    1bfa:	0f 91       	pop	r16
    1bfc:	08 95       	ret

00001bfe <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1bfe:	0f b6       	in	r0, 0x3f	; 63
    1c00:	f8 94       	cli
    1c02:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1c04:	fc 01       	movw	r30, r24
    1c06:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1c0c:	08 95       	ret

00001c0e <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1c0e:	fc 01       	movw	r30, r24
    1c10:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1c12:	08 95       	ret

00001c14 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1c14:	cc e1       	ldi	r28, 0x1C	; 28
    1c16:	d1 e3       	ldi	r29, 0x31	; 49
    1c18:	88 81       	ld	r24, Y
    1c1a:	82 30       	cpi	r24, 0x02	; 2
    1c1c:	e8 f3       	brcs	.-6      	; 0x1c18 <prvIdleTask+0x4>
    1c1e:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    1c22:	fa cf       	rjmp	.-12     	; 0x1c18 <prvIdleTask+0x4>

00001c24 <prvAddCurrentTaskToDelayedList>:
    1c24:	cf 92       	push	r12
    1c26:	df 92       	push	r13
    1c28:	ef 92       	push	r14
    1c2a:	ff 92       	push	r15
    1c2c:	6b 01       	movw	r12, r22
    1c2e:	7c 01       	movw	r14, r24
    1c30:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1c34:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c38:	62 83       	std	Z+2, r22	; 0x02
    1c3a:	73 83       	std	Z+3, r23	; 0x03
    1c3c:	84 83       	std	Z+4, r24	; 0x04
    1c3e:	95 83       	std	Z+5, r25	; 0x05
    1c40:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1c44:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1c48:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1c4c:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1c50:	c8 16       	cp	r12, r24
    1c52:	d9 06       	cpc	r13, r25
    1c54:	ea 06       	cpc	r14, r26
    1c56:	fb 06       	cpc	r15, r27
    1c58:	68 f4       	brcc	.+26     	; 0x1c74 <prvAddCurrentTaskToDelayedList+0x50>
    1c5a:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    1c5e:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c62:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxOverflowDelayedTaskList>
    1c66:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1c6a:	6e 5f       	subi	r22, 0xFE	; 254
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	0e 94 41 09 	call	0x1282	; 0x1282 <vListInsert>
    1c72:	21 c0       	rjmp	.+66     	; 0x1cb6 <prvAddCurrentTaskToDelayedList+0x92>
    1c74:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    1c78:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c7c:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxDelayedTaskList>
    1c80:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    1c84:	6e 5f       	subi	r22, 0xFE	; 254
    1c86:	7f 4f       	sbci	r23, 0xFF	; 255
    1c88:	0e 94 41 09 	call	0x1282	; 0x1282 <vListInsert>
    1c8c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1c90:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c94:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c98:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c9c:	c8 16       	cp	r12, r24
    1c9e:	d9 06       	cpc	r13, r25
    1ca0:	ea 06       	cpc	r14, r26
    1ca2:	fb 06       	cpc	r15, r27
    1ca4:	40 f4       	brcc	.+16     	; 0x1cb6 <prvAddCurrentTaskToDelayedList+0x92>
    1ca6:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1caa:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cae:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cb2:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1cb6:	ff 90       	pop	r15
    1cb8:	ef 90       	pop	r14
    1cba:	df 90       	pop	r13
    1cbc:	cf 90       	pop	r12
    1cbe:	08 95       	ret

00001cc0 <xTaskGenericCreate>:
    1cc0:	4f 92       	push	r4
    1cc2:	5f 92       	push	r5
    1cc4:	6f 92       	push	r6
    1cc6:	7f 92       	push	r7
    1cc8:	8f 92       	push	r8
    1cca:	9f 92       	push	r9
    1ccc:	af 92       	push	r10
    1cce:	bf 92       	push	r11
    1cd0:	cf 92       	push	r12
    1cd2:	df 92       	push	r13
    1cd4:	ef 92       	push	r14
    1cd6:	ff 92       	push	r15
    1cd8:	0f 93       	push	r16
    1cda:	1f 93       	push	r17
    1cdc:	cf 93       	push	r28
    1cde:	df 93       	push	r29
    1ce0:	5c 01       	movw	r10, r24
    1ce2:	4b 01       	movw	r8, r22
    1ce4:	3a 01       	movw	r6, r20
    1ce6:	29 01       	movw	r4, r18
    1ce8:	88 e2       	ldi	r24, 0x28	; 40
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    1cf0:	ec 01       	movw	r28, r24
    1cf2:	89 2b       	or	r24, r25
    1cf4:	09 f4       	brne	.+2      	; 0x1cf8 <xTaskGenericCreate+0x38>
    1cf6:	d4 c0       	rjmp	.+424    	; 0x1ea0 <xTaskGenericCreate+0x1e0>
    1cf8:	c1 14       	cp	r12, r1
    1cfa:	d1 04       	cpc	r13, r1
    1cfc:	09 f0       	breq	.+2      	; 0x1d00 <xTaskGenericCreate+0x40>
    1cfe:	cc c0       	rjmp	.+408    	; 0x1e98 <xTaskGenericCreate+0x1d8>
    1d00:	c3 01       	movw	r24, r6
    1d02:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    1d06:	8b 8f       	std	Y+27, r24	; 0x1b
    1d08:	9c 8f       	std	Y+28, r25	; 0x1c
    1d0a:	00 97       	sbiw	r24, 0x00	; 0
    1d0c:	21 f4       	brne	.+8      	; 0x1d16 <xTaskGenericCreate+0x56>
    1d0e:	ce 01       	movw	r24, r28
    1d10:	0e 94 cd 08 	call	0x119a	; 0x119a <vPortFree>
    1d14:	c5 c0       	rjmp	.+394    	; 0x1ea0 <xTaskGenericCreate+0x1e0>
    1d16:	a3 01       	movw	r20, r6
    1d18:	61 e1       	ldi	r22, 0x11	; 17
    1d1a:	70 e0       	ldi	r23, 0x00	; 0
    1d1c:	0e 94 6c 20 	call	0x40d8	; 0x40d8 <memset>
    1d20:	93 01       	movw	r18, r6
    1d22:	21 50       	subi	r18, 0x01	; 1
    1d24:	31 09       	sbc	r19, r1
    1d26:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d28:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d2a:	3c 01       	movw	r6, r24
    1d2c:	62 0e       	add	r6, r18
    1d2e:	73 1e       	adc	r7, r19
    1d30:	4a e0       	ldi	r20, 0x0A	; 10
    1d32:	50 e0       	ldi	r21, 0x00	; 0
    1d34:	b4 01       	movw	r22, r8
    1d36:	ce 01       	movw	r24, r28
    1d38:	4d 96       	adiw	r24, 0x1d	; 29
    1d3a:	0e 94 73 20 	call	0x40e6	; 0x40e6 <strncpy>
    1d3e:	1e a2       	std	Y+38, r1	; 0x26
    1d40:	10 2f       	mov	r17, r16
    1d42:	04 30       	cpi	r16, 0x04	; 4
    1d44:	08 f0       	brcs	.+2      	; 0x1d48 <xTaskGenericCreate+0x88>
    1d46:	13 e0       	ldi	r17, 0x03	; 3
    1d48:	1a 8f       	std	Y+26, r17	; 0x1a
    1d4a:	1f a3       	std	Y+39, r17	; 0x27
    1d4c:	6e 01       	movw	r12, r28
    1d4e:	22 e0       	ldi	r18, 0x02	; 2
    1d50:	c2 0e       	add	r12, r18
    1d52:	d1 1c       	adc	r13, r1
    1d54:	c6 01       	movw	r24, r12
    1d56:	0e 94 16 09 	call	0x122c	; 0x122c <vListInitialiseItem>
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	0e 96       	adiw	r24, 0x0e	; 14
    1d5e:	0e 94 16 09 	call	0x122c	; 0x122c <vListInitialiseItem>
    1d62:	ca 87       	std	Y+10, r28	; 0x0a
    1d64:	db 87       	std	Y+11, r29	; 0x0b
    1d66:	84 e0       	ldi	r24, 0x04	; 4
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	a0 e0       	ldi	r26, 0x00	; 0
    1d6c:	b0 e0       	ldi	r27, 0x00	; 0
    1d6e:	81 1b       	sub	r24, r17
    1d70:	91 09       	sbc	r25, r1
    1d72:	a1 09       	sbc	r26, r1
    1d74:	b1 09       	sbc	r27, r1
    1d76:	8e 87       	std	Y+14, r24	; 0x0e
    1d78:	9f 87       	std	Y+15, r25	; 0x0f
    1d7a:	a8 8b       	std	Y+16, r26	; 0x10
    1d7c:	b9 8b       	std	Y+17, r27	; 0x11
    1d7e:	ce 8b       	std	Y+22, r28	; 0x16
    1d80:	df 8b       	std	Y+23, r29	; 0x17
    1d82:	a2 01       	movw	r20, r4
    1d84:	b5 01       	movw	r22, r10
    1d86:	c3 01       	movw	r24, r6
    1d88:	0e 94 b2 09 	call	0x1364	; 0x1364 <pxPortInitialiseStack>
    1d8c:	88 83       	st	Y, r24
    1d8e:	99 83       	std	Y+1, r25	; 0x01
    1d90:	e1 14       	cp	r14, r1
    1d92:	f1 04       	cpc	r15, r1
    1d94:	19 f0       	breq	.+6      	; 0x1d9c <xTaskGenericCreate+0xdc>
    1d96:	f7 01       	movw	r30, r14
    1d98:	c0 83       	st	Z, r28
    1d9a:	d1 83       	std	Z+1, r29	; 0x01
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	0f 92       	push	r0
    1da2:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    1da6:	8f 5f       	subi	r24, 0xFF	; 255
    1da8:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <uxCurrentNumberOfTasks>
    1dac:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1db0:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1db4:	89 2b       	or	r24, r25
    1db6:	89 f5       	brne	.+98     	; 0x1e1a <xTaskGenericCreate+0x15a>
    1db8:	c0 93 48 31 	sts	0x3148, r28	; 0x803148 <pxCurrentTCB>
    1dbc:	d0 93 49 31 	sts	0x3149, r29	; 0x803149 <pxCurrentTCB+0x1>
    1dc0:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    1dc4:	81 30       	cpi	r24, 0x01	; 1
    1dc6:	c1 f5       	brne	.+112    	; 0x1e38 <xTaskGenericCreate+0x178>
    1dc8:	8c e1       	ldi	r24, 0x1C	; 28
    1dca:	91 e3       	ldi	r25, 0x31	; 49
    1dcc:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1dd0:	87 e2       	ldi	r24, 0x27	; 39
    1dd2:	91 e3       	ldi	r25, 0x31	; 49
    1dd4:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1dd8:	82 e3       	ldi	r24, 0x32	; 50
    1dda:	91 e3       	ldi	r25, 0x31	; 49
    1ddc:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1de0:	8d e3       	ldi	r24, 0x3D	; 61
    1de2:	91 e3       	ldi	r25, 0x31	; 49
    1de4:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1de8:	81 e1       	ldi	r24, 0x11	; 17
    1dea:	91 e3       	ldi	r25, 0x31	; 49
    1dec:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1df0:	86 e0       	ldi	r24, 0x06	; 6
    1df2:	91 e3       	ldi	r25, 0x31	; 49
    1df4:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1df8:	87 ef       	ldi	r24, 0xF7	; 247
    1dfa:	90 e3       	ldi	r25, 0x30	; 48
    1dfc:	0e 94 05 09 	call	0x120a	; 0x120a <vListInitialise>
    1e00:	81 e1       	ldi	r24, 0x11	; 17
    1e02:	91 e3       	ldi	r25, 0x31	; 49
    1e04:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxDelayedTaskList>
    1e08:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxDelayedTaskList+0x1>
    1e0c:	86 e0       	ldi	r24, 0x06	; 6
    1e0e:	91 e3       	ldi	r25, 0x31	; 49
    1e10:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxOverflowDelayedTaskList>
    1e14:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1e18:	0f c0       	rjmp	.+30     	; 0x1e38 <xTaskGenericCreate+0x178>
    1e1a:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <xSchedulerRunning>
    1e1e:	81 11       	cpse	r24, r1
    1e20:	0b c0       	rjmp	.+22     	; 0x1e38 <xTaskGenericCreate+0x178>
    1e22:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1e26:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1e2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e2c:	08 17       	cp	r16, r24
    1e2e:	20 f0       	brcs	.+8      	; 0x1e38 <xTaskGenericCreate+0x178>
    1e30:	c0 93 48 31 	sts	0x3148, r28	; 0x803148 <pxCurrentTCB>
    1e34:	d0 93 49 31 	sts	0x3149, r29	; 0x803149 <pxCurrentTCB+0x1>
    1e38:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e3a:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <uxTopUsedPriority>
    1e3e:	98 17       	cp	r25, r24
    1e40:	10 f4       	brcc	.+4      	; 0x1e46 <xTaskGenericCreate+0x186>
    1e42:	80 93 ef 30 	sts	0x30EF, r24	; 0x8030ef <uxTopUsedPriority>
    1e46:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTaskNumber>
    1e4a:	9f 5f       	subi	r25, 0xFF	; 255
    1e4c:	90 93 e8 30 	sts	0x30E8, r25	; 0x8030e8 <uxTaskNumber>
    1e50:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    1e54:	98 17       	cp	r25, r24
    1e56:	10 f4       	brcc	.+4      	; 0x1e5c <xTaskGenericCreate+0x19c>
    1e58:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    1e5c:	fb e0       	ldi	r31, 0x0B	; 11
    1e5e:	8f 9f       	mul	r24, r31
    1e60:	c0 01       	movw	r24, r0
    1e62:	11 24       	eor	r1, r1
    1e64:	b6 01       	movw	r22, r12
    1e66:	84 5e       	subi	r24, 0xE4	; 228
    1e68:	9e 4c       	sbci	r25, 0xCE	; 206
    1e6a:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63
    1e72:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <xSchedulerRunning>
    1e76:	88 23       	and	r24, r24
    1e78:	59 f0       	breq	.+22     	; 0x1e90 <xTaskGenericCreate+0x1d0>
    1e7a:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1e7e:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1e82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e84:	80 17       	cp	r24, r16
    1e86:	30 f4       	brcc	.+12     	; 0x1e94 <xTaskGenericCreate+0x1d4>
    1e88:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	09 c0       	rjmp	.+18     	; 0x1ea2 <xTaskGenericCreate+0x1e2>
    1e90:	81 e0       	ldi	r24, 0x01	; 1
    1e92:	07 c0       	rjmp	.+14     	; 0x1ea2 <xTaskGenericCreate+0x1e2>
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	05 c0       	rjmp	.+10     	; 0x1ea2 <xTaskGenericCreate+0x1e2>
    1e98:	cb 8e       	std	Y+27, r12	; 0x1b
    1e9a:	dc 8e       	std	Y+28, r13	; 0x1c
    1e9c:	c6 01       	movw	r24, r12
    1e9e:	3b cf       	rjmp	.-394    	; 0x1d16 <xTaskGenericCreate+0x56>
    1ea0:	8f ef       	ldi	r24, 0xFF	; 255
    1ea2:	df 91       	pop	r29
    1ea4:	cf 91       	pop	r28
    1ea6:	1f 91       	pop	r17
    1ea8:	0f 91       	pop	r16
    1eaa:	ff 90       	pop	r15
    1eac:	ef 90       	pop	r14
    1eae:	df 90       	pop	r13
    1eb0:	cf 90       	pop	r12
    1eb2:	bf 90       	pop	r11
    1eb4:	af 90       	pop	r10
    1eb6:	9f 90       	pop	r9
    1eb8:	8f 90       	pop	r8
    1eba:	7f 90       	pop	r7
    1ebc:	6f 90       	pop	r6
    1ebe:	5f 90       	pop	r5
    1ec0:	4f 90       	pop	r4
    1ec2:	08 95       	ret

00001ec4 <uxTaskPriorityGet>:
    1ec4:	0f b6       	in	r0, 0x3f	; 63
    1ec6:	f8 94       	cli
    1ec8:	0f 92       	push	r0
    1eca:	00 97       	sbiw	r24, 0x00	; 0
    1ecc:	21 f4       	brne	.+8      	; 0x1ed6 <uxTaskPriorityGet+0x12>
    1ece:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1ed2:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63
    1eda:	fc 01       	movw	r30, r24
    1edc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ede:	08 95       	ret

00001ee0 <vTaskStartScheduler>:
    1ee0:	af 92       	push	r10
    1ee2:	bf 92       	push	r11
    1ee4:	cf 92       	push	r12
    1ee6:	df 92       	push	r13
    1ee8:	ef 92       	push	r14
    1eea:	ff 92       	push	r15
    1eec:	0f 93       	push	r16
    1eee:	a1 2c       	mov	r10, r1
    1ef0:	b1 2c       	mov	r11, r1
    1ef2:	c1 2c       	mov	r12, r1
    1ef4:	d1 2c       	mov	r13, r1
    1ef6:	0f 2e       	mov	r0, r31
    1ef8:	f5 ef       	ldi	r31, 0xF5	; 245
    1efa:	ef 2e       	mov	r14, r31
    1efc:	f0 e3       	ldi	r31, 0x30	; 48
    1efe:	ff 2e       	mov	r15, r31
    1f00:	f0 2d       	mov	r31, r0
    1f02:	00 e0       	ldi	r16, 0x00	; 0
    1f04:	20 e0       	ldi	r18, 0x00	; 0
    1f06:	30 e0       	ldi	r19, 0x00	; 0
    1f08:	44 e6       	ldi	r20, 0x64	; 100
    1f0a:	50 e0       	ldi	r21, 0x00	; 0
    1f0c:	6e e2       	ldi	r22, 0x2E	; 46
    1f0e:	70 e2       	ldi	r23, 0x20	; 32
    1f10:	8a e0       	ldi	r24, 0x0A	; 10
    1f12:	9e e0       	ldi	r25, 0x0E	; 14
    1f14:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xTaskGenericCreate>
    1f18:	81 30       	cpi	r24, 0x01	; 1
    1f1a:	69 f4       	brne	.+26     	; 0x1f36 <vTaskStartScheduler+0x56>
    1f1c:	f8 94       	cli
    1f1e:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <xSchedulerRunning>
    1f22:	10 92 f0 30 	sts	0x30F0, r1	; 0x8030f0 <xTickCount>
    1f26:	10 92 f1 30 	sts	0x30F1, r1	; 0x8030f1 <xTickCount+0x1>
    1f2a:	10 92 f2 30 	sts	0x30F2, r1	; 0x8030f2 <xTickCount+0x2>
    1f2e:	10 92 f3 30 	sts	0x30F3, r1	; 0x8030f3 <xTickCount+0x3>
    1f32:	0e 94 28 0a 	call	0x1450	; 0x1450 <xPortStartScheduler>
    1f36:	0f 91       	pop	r16
    1f38:	ff 90       	pop	r15
    1f3a:	ef 90       	pop	r14
    1f3c:	df 90       	pop	r13
    1f3e:	cf 90       	pop	r12
    1f40:	bf 90       	pop	r11
    1f42:	af 90       	pop	r10
    1f44:	08 95       	ret

00001f46 <vTaskSuspendAll>:
    1f46:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    1f4a:	8f 5f       	subi	r24, 0xFF	; 255
    1f4c:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxSchedulerSuspended>
    1f50:	08 95       	ret

00001f52 <xTaskGetTickCount>:
    1f52:	0f b6       	in	r0, 0x3f	; 63
    1f54:	f8 94       	cli
    1f56:	0f 92       	push	r0
    1f58:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount>
    1f5c:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1f60:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1f64:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63
    1f6c:	08 95       	ret

00001f6e <pcTaskGetTaskName>:
    1f6e:	00 97       	sbiw	r24, 0x00	; 0
    1f70:	21 f4       	brne	.+8      	; 0x1f7a <pcTaskGetTaskName+0xc>
    1f72:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1f76:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1f7a:	4d 96       	adiw	r24, 0x1d	; 29
    1f7c:	08 95       	ret

00001f7e <xTaskGetIdleTaskHandle>:
    1f7e:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <xIdleTaskHandle>
    1f82:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <xIdleTaskHandle+0x1>
    1f86:	08 95       	ret

00001f88 <vTaskIncrementTick>:
    1f88:	ff 92       	push	r15
    1f8a:	0f 93       	push	r16
    1f8c:	1f 93       	push	r17
    1f8e:	cf 93       	push	r28
    1f90:	df 93       	push	r29
    1f92:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    1f96:	81 11       	cpse	r24, r1
    1f98:	ed c0       	rjmp	.+474    	; 0x2174 <vTaskIncrementTick+0x1ec>
    1f9a:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1f9e:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1fa2:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1fa6:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1faa:	01 96       	adiw	r24, 0x01	; 1
    1fac:	a1 1d       	adc	r26, r1
    1fae:	b1 1d       	adc	r27, r1
    1fb0:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <xTickCount>
    1fb4:	90 93 f1 30 	sts	0x30F1, r25	; 0x8030f1 <xTickCount+0x1>
    1fb8:	a0 93 f2 30 	sts	0x30F2, r26	; 0x8030f2 <xTickCount+0x2>
    1fbc:	b0 93 f3 30 	sts	0x30F3, r27	; 0x8030f3 <xTickCount+0x3>
    1fc0:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1fc4:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1fc8:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1fcc:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1fd0:	89 2b       	or	r24, r25
    1fd2:	8a 2b       	or	r24, r26
    1fd4:	8b 2b       	or	r24, r27
    1fd6:	f1 f5       	brne	.+124    	; 0x2054 <vTaskIncrementTick+0xcc>
    1fd8:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxDelayedTaskList>
    1fdc:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    1fe0:	20 91 02 31 	lds	r18, 0x3102	; 0x803102 <pxOverflowDelayedTaskList>
    1fe4:	30 91 03 31 	lds	r19, 0x3103	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1fe8:	20 93 04 31 	sts	0x3104, r18	; 0x803104 <pxDelayedTaskList>
    1fec:	30 93 05 31 	sts	0x3105, r19	; 0x803105 <pxDelayedTaskList+0x1>
    1ff0:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxOverflowDelayedTaskList>
    1ff4:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1ff8:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    1ffc:	8f 5f       	subi	r24, 0xFF	; 255
    1ffe:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <xNumOfOverflows>
    2002:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2006:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    200a:	80 81       	ld	r24, Z
    200c:	81 11       	cpse	r24, r1
    200e:	0c c0       	rjmp	.+24     	; 0x2028 <vTaskIncrementTick+0xa0>
    2010:	8f ef       	ldi	r24, 0xFF	; 255
    2012:	9f ef       	ldi	r25, 0xFF	; 255
    2014:	dc 01       	movw	r26, r24
    2016:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    201a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    201e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2022:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2026:	16 c0       	rjmp	.+44     	; 0x2054 <vTaskIncrementTick+0xcc>
    2028:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    202c:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2030:	07 80       	ldd	r0, Z+7	; 0x07
    2032:	f0 85       	ldd	r31, Z+8	; 0x08
    2034:	e0 2d       	mov	r30, r0
    2036:	00 84       	ldd	r0, Z+8	; 0x08
    2038:	f1 85       	ldd	r31, Z+9	; 0x09
    203a:	e0 2d       	mov	r30, r0
    203c:	82 81       	ldd	r24, Z+2	; 0x02
    203e:	93 81       	ldd	r25, Z+3	; 0x03
    2040:	a4 81       	ldd	r26, Z+4	; 0x04
    2042:	b5 81       	ldd	r27, Z+5	; 0x05
    2044:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2048:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    204c:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2050:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2054:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    2058:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    205c:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    2060:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    2064:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2068:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    206c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2070:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2074:	48 17       	cp	r20, r24
    2076:	59 07       	cpc	r21, r25
    2078:	6a 07       	cpc	r22, r26
    207a:	7b 07       	cpc	r23, r27
    207c:	08 f4       	brcc	.+2      	; 0x2080 <vTaskIncrementTick+0xf8>
    207e:	7f c0       	rjmp	.+254    	; 0x217e <vTaskIncrementTick+0x1f6>
    2080:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2084:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2088:	80 81       	ld	r24, Z
    208a:	88 23       	and	r24, r24
    208c:	f9 f0       	breq	.+62     	; 0x20cc <vTaskIncrementTick+0x144>
    208e:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2092:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2096:	07 80       	ldd	r0, Z+7	; 0x07
    2098:	f0 85       	ldd	r31, Z+8	; 0x08
    209a:	e0 2d       	mov	r30, r0
    209c:	c0 85       	ldd	r28, Z+8	; 0x08
    209e:	d1 85       	ldd	r29, Z+9	; 0x09
    20a0:	8a 81       	ldd	r24, Y+2	; 0x02
    20a2:	9b 81       	ldd	r25, Y+3	; 0x03
    20a4:	ac 81       	ldd	r26, Y+4	; 0x04
    20a6:	bd 81       	ldd	r27, Y+5	; 0x05
    20a8:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    20ac:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    20b0:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    20b4:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    20b8:	48 17       	cp	r20, r24
    20ba:	59 07       	cpc	r21, r25
    20bc:	6a 07       	cpc	r22, r26
    20be:	7b 07       	cpc	r23, r27
    20c0:	58 f1       	brcs	.+86     	; 0x2118 <vTaskIncrementTick+0x190>
    20c2:	0f 2e       	mov	r0, r31
    20c4:	fb e0       	ldi	r31, 0x0B	; 11
    20c6:	ff 2e       	mov	r15, r31
    20c8:	f0 2d       	mov	r31, r0
    20ca:	2f c0       	rjmp	.+94     	; 0x212a <vTaskIncrementTick+0x1a2>
    20cc:	8f ef       	ldi	r24, 0xFF	; 255
    20ce:	9f ef       	ldi	r25, 0xFF	; 255
    20d0:	dc 01       	movw	r26, r24
    20d2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20d6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20da:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20de:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    20e2:	4d c0       	rjmp	.+154    	; 0x217e <vTaskIncrementTick+0x1f6>
    20e4:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    20e8:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    20ec:	07 80       	ldd	r0, Z+7	; 0x07
    20ee:	f0 85       	ldd	r31, Z+8	; 0x08
    20f0:	e0 2d       	mov	r30, r0
    20f2:	c0 85       	ldd	r28, Z+8	; 0x08
    20f4:	d1 85       	ldd	r29, Z+9	; 0x09
    20f6:	8a 81       	ldd	r24, Y+2	; 0x02
    20f8:	9b 81       	ldd	r25, Y+3	; 0x03
    20fa:	ac 81       	ldd	r26, Y+4	; 0x04
    20fc:	bd 81       	ldd	r27, Y+5	; 0x05
    20fe:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    2102:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    2106:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    210a:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    210e:	48 17       	cp	r20, r24
    2110:	59 07       	cpc	r21, r25
    2112:	6a 07       	cpc	r22, r26
    2114:	7b 07       	cpc	r23, r27
    2116:	48 f4       	brcc	.+18     	; 0x212a <vTaskIncrementTick+0x1a2>
    2118:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    211c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2120:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2124:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2128:	2a c0       	rjmp	.+84     	; 0x217e <vTaskIncrementTick+0x1f6>
    212a:	8e 01       	movw	r16, r28
    212c:	0e 5f       	subi	r16, 0xFE	; 254
    212e:	1f 4f       	sbci	r17, 0xFF	; 255
    2130:	c8 01       	movw	r24, r16
    2132:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
    2136:	88 8d       	ldd	r24, Y+24	; 0x18
    2138:	99 8d       	ldd	r25, Y+25	; 0x19
    213a:	89 2b       	or	r24, r25
    213c:	21 f0       	breq	.+8      	; 0x2146 <vTaskIncrementTick+0x1be>
    213e:	ce 01       	movw	r24, r28
    2140:	0e 96       	adiw	r24, 0x0e	; 14
    2142:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
    2146:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2148:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    214c:	98 17       	cp	r25, r24
    214e:	10 f4       	brcc	.+4      	; 0x2154 <vTaskIncrementTick+0x1cc>
    2150:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2154:	f8 9e       	mul	r15, r24
    2156:	c0 01       	movw	r24, r0
    2158:	11 24       	eor	r1, r1
    215a:	b8 01       	movw	r22, r16
    215c:	84 5e       	subi	r24, 0xE4	; 228
    215e:	9e 4c       	sbci	r25, 0xCE	; 206
    2160:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
    2164:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2168:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    216c:	80 81       	ld	r24, Z
    216e:	81 11       	cpse	r24, r1
    2170:	b9 cf       	rjmp	.-142    	; 0x20e4 <vTaskIncrementTick+0x15c>
    2172:	ac cf       	rjmp	.-168    	; 0x20cc <vTaskIncrementTick+0x144>
    2174:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2178:	8f 5f       	subi	r24, 0xFF	; 255
    217a:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <uxMissedTicks>
    217e:	df 91       	pop	r29
    2180:	cf 91       	pop	r28
    2182:	1f 91       	pop	r17
    2184:	0f 91       	pop	r16
    2186:	ff 90       	pop	r15
    2188:	08 95       	ret

0000218a <xTaskResumeAll>:
    218a:	cf 92       	push	r12
    218c:	df 92       	push	r13
    218e:	ef 92       	push	r14
    2190:	ff 92       	push	r15
    2192:	0f 93       	push	r16
    2194:	1f 93       	push	r17
    2196:	cf 93       	push	r28
    2198:	df 93       	push	r29
    219a:	0f b6       	in	r0, 0x3f	; 63
    219c:	f8 94       	cli
    219e:	0f 92       	push	r0
    21a0:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    21a4:	81 50       	subi	r24, 0x01	; 1
    21a6:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxSchedulerSuspended>
    21aa:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    21ae:	81 11       	cpse	r24, r1
    21b0:	60 c0       	rjmp	.+192    	; 0x2272 <xTaskResumeAll+0xe8>
    21b2:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    21b6:	81 11       	cpse	r24, r1
    21b8:	2c c0       	rjmp	.+88     	; 0x2212 <xTaskResumeAll+0x88>
    21ba:	5e c0       	rjmp	.+188    	; 0x2278 <xTaskResumeAll+0xee>
    21bc:	d7 01       	movw	r26, r14
    21be:	17 96       	adiw	r26, 0x07	; 7
    21c0:	ed 91       	ld	r30, X+
    21c2:	fc 91       	ld	r31, X
    21c4:	18 97       	sbiw	r26, 0x08	; 8
    21c6:	c0 85       	ldd	r28, Z+8	; 0x08
    21c8:	d1 85       	ldd	r29, Z+9	; 0x09
    21ca:	ce 01       	movw	r24, r28
    21cc:	0e 96       	adiw	r24, 0x0e	; 14
    21ce:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
    21d2:	8e 01       	movw	r16, r28
    21d4:	0e 5f       	subi	r16, 0xFE	; 254
    21d6:	1f 4f       	sbci	r17, 0xFF	; 255
    21d8:	c8 01       	movw	r24, r16
    21da:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
    21de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    21e0:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    21e4:	98 17       	cp	r25, r24
    21e6:	10 f4       	brcc	.+4      	; 0x21ec <xTaskResumeAll+0x62>
    21e8:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    21ec:	d8 9e       	mul	r13, r24
    21ee:	c0 01       	movw	r24, r0
    21f0:	11 24       	eor	r1, r1
    21f2:	b8 01       	movw	r22, r16
    21f4:	84 5e       	subi	r24, 0xE4	; 228
    21f6:	9e 4c       	sbci	r25, 0xCE	; 206
    21f8:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
    21fc:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    2200:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    2204:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2206:	82 8d       	ldd	r24, Z+26	; 0x1a
    2208:	98 17       	cp	r25, r24
    220a:	70 f0       	brcs	.+28     	; 0x2228 <xTaskResumeAll+0x9e>
    220c:	cc 24       	eor	r12, r12
    220e:	c3 94       	inc	r12
    2210:	0b c0       	rjmp	.+22     	; 0x2228 <xTaskResumeAll+0x9e>
    2212:	c1 2c       	mov	r12, r1
    2214:	0f 2e       	mov	r0, r31
    2216:	f7 ef       	ldi	r31, 0xF7	; 247
    2218:	ef 2e       	mov	r14, r31
    221a:	f0 e3       	ldi	r31, 0x30	; 48
    221c:	ff 2e       	mov	r15, r31
    221e:	f0 2d       	mov	r31, r0
    2220:	0f 2e       	mov	r0, r31
    2222:	fb e0       	ldi	r31, 0x0B	; 11
    2224:	df 2e       	mov	r13, r31
    2226:	f0 2d       	mov	r31, r0
    2228:	f7 01       	movw	r30, r14
    222a:	80 81       	ld	r24, Z
    222c:	81 11       	cpse	r24, r1
    222e:	c6 cf       	rjmp	.-116    	; 0x21bc <xTaskResumeAll+0x32>
    2230:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2234:	88 23       	and	r24, r24
    2236:	81 f0       	breq	.+32     	; 0x2258 <xTaskResumeAll+0xce>
    2238:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    223c:	88 23       	and	r24, r24
    223e:	99 f0       	breq	.+38     	; 0x2266 <xTaskResumeAll+0xdc>
    2240:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <vTaskIncrementTick>
    2244:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2248:	81 50       	subi	r24, 0x01	; 1
    224a:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <uxMissedTicks>
    224e:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2252:	81 11       	cpse	r24, r1
    2254:	f5 cf       	rjmp	.-22     	; 0x2240 <xTaskResumeAll+0xb6>
    2256:	07 c0       	rjmp	.+14     	; 0x2266 <xTaskResumeAll+0xdc>
    2258:	f1 e0       	ldi	r31, 0x01	; 1
    225a:	cf 16       	cp	r12, r31
    225c:	21 f0       	breq	.+8      	; 0x2266 <xTaskResumeAll+0xdc>
    225e:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xMissedYield>
    2262:	81 30       	cpi	r24, 0x01	; 1
    2264:	41 f4       	brne	.+16     	; 0x2276 <xTaskResumeAll+0xec>
    2266:	10 92 ea 30 	sts	0x30EA, r1	; 0x8030ea <xMissedYield>
    226a:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
    226e:	81 e0       	ldi	r24, 0x01	; 1
    2270:	03 c0       	rjmp	.+6      	; 0x2278 <xTaskResumeAll+0xee>
    2272:	80 e0       	ldi	r24, 0x00	; 0
    2274:	01 c0       	rjmp	.+2      	; 0x2278 <xTaskResumeAll+0xee>
    2276:	80 e0       	ldi	r24, 0x00	; 0
    2278:	0f 90       	pop	r0
    227a:	0f be       	out	0x3f, r0	; 63
    227c:	df 91       	pop	r29
    227e:	cf 91       	pop	r28
    2280:	1f 91       	pop	r17
    2282:	0f 91       	pop	r16
    2284:	ff 90       	pop	r15
    2286:	ef 90       	pop	r14
    2288:	df 90       	pop	r13
    228a:	cf 90       	pop	r12
    228c:	08 95       	ret

0000228e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    228e:	cf 92       	push	r12
    2290:	df 92       	push	r13
    2292:	ef 92       	push	r14
    2294:	ff 92       	push	r15
    2296:	6b 01       	movw	r12, r22
    2298:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    229a:	67 2b       	or	r22, r23
    229c:	68 2b       	or	r22, r24
    229e:	69 2b       	or	r22, r25
    22a0:	e9 f0       	breq	.+58     	; 0x22dc <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    22a2:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    22a6:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    22aa:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    22ae:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    22b2:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    22b6:	c8 0e       	add	r12, r24
    22b8:	d9 1e       	adc	r13, r25
    22ba:	ea 1e       	adc	r14, r26
    22bc:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    22be:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    22c2:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    22c6:	02 96       	adiw	r24, 0x02	; 2
    22c8:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22cc:	c7 01       	movw	r24, r14
    22ce:	b6 01       	movw	r22, r12
    22d0:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    22d4:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22d8:	81 11       	cpse	r24, r1
    22da:	02 c0       	rjmp	.+4      	; 0x22e0 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    22dc:	0e 94 66 0a 	call	0x14cc	; 0x14cc <vPortYield>
		}
	}
    22e0:	ff 90       	pop	r15
    22e2:	ef 90       	pop	r14
    22e4:	df 90       	pop	r13
    22e6:	cf 90       	pop	r12
    22e8:	08 95       	ret

000022ea <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22ea:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    22ee:	81 11       	cpse	r24, r1
    22f0:	0c c0       	rjmp	.+24     	; 0x230a <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22f2:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    22f6:	4b e0       	ldi	r20, 0x0B	; 11
    22f8:	e4 9f       	mul	r30, r20
    22fa:	f0 01       	movw	r30, r0
    22fc:	11 24       	eor	r1, r1
    22fe:	e4 5e       	subi	r30, 0xE4	; 228
    2300:	fe 4c       	sbci	r31, 0xCE	; 206
    2302:	80 81       	ld	r24, Z
    2304:	88 23       	and	r24, r24
    2306:	29 f0       	breq	.+10     	; 0x2312 <vTaskSwitchContext+0x28>
    2308:	14 c0       	rjmp	.+40     	; 0x2332 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xMissedYield>
    2310:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2312:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2314:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2318:	81 50       	subi	r24, 0x01	; 1
    231a:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    231e:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2322:	9e 9f       	mul	r25, r30
    2324:	f0 01       	movw	r30, r0
    2326:	11 24       	eor	r1, r1
    2328:	e4 5e       	subi	r30, 0xE4	; 228
    232a:	fe 4c       	sbci	r31, 0xCE	; 206
    232c:	80 81       	ld	r24, Z
    232e:	88 23       	and	r24, r24
    2330:	89 f3       	breq	.-30     	; 0x2314 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2332:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2336:	28 2f       	mov	r18, r24
    2338:	30 e0       	ldi	r19, 0x00	; 0
    233a:	4b e0       	ldi	r20, 0x0B	; 11
    233c:	84 9f       	mul	r24, r20
    233e:	c0 01       	movw	r24, r0
    2340:	11 24       	eor	r1, r1
    2342:	dc 01       	movw	r26, r24
    2344:	a4 5e       	subi	r26, 0xE4	; 228
    2346:	be 4c       	sbci	r27, 0xCE	; 206
    2348:	11 96       	adiw	r26, 0x01	; 1
    234a:	ed 91       	ld	r30, X+
    234c:	fc 91       	ld	r31, X
    234e:	12 97       	sbiw	r26, 0x02	; 2
    2350:	04 80       	ldd	r0, Z+4	; 0x04
    2352:	f5 81       	ldd	r31, Z+5	; 0x05
    2354:	e0 2d       	mov	r30, r0
    2356:	11 96       	adiw	r26, 0x01	; 1
    2358:	ed 93       	st	X+, r30
    235a:	fc 93       	st	X, r31
    235c:	12 97       	sbiw	r26, 0x02	; 2
    235e:	81 5e       	subi	r24, 0xE1	; 225
    2360:	9e 4c       	sbci	r25, 0xCE	; 206
    2362:	e8 17       	cp	r30, r24
    2364:	f9 07       	cpc	r31, r25
    2366:	61 f4       	brne	.+24     	; 0x2380 <vTaskSwitchContext+0x96>
    2368:	84 81       	ldd	r24, Z+4	; 0x04
    236a:	95 81       	ldd	r25, Z+5	; 0x05
    236c:	4b e0       	ldi	r20, 0x0B	; 11
    236e:	42 9f       	mul	r20, r18
    2370:	f0 01       	movw	r30, r0
    2372:	43 9f       	mul	r20, r19
    2374:	f0 0d       	add	r31, r0
    2376:	11 24       	eor	r1, r1
    2378:	e4 5e       	subi	r30, 0xE4	; 228
    237a:	fe 4c       	sbci	r31, 0xCE	; 206
    237c:	81 83       	std	Z+1, r24	; 0x01
    237e:	92 83       	std	Z+2, r25	; 0x02
    2380:	8b e0       	ldi	r24, 0x0B	; 11
    2382:	82 9f       	mul	r24, r18
    2384:	f0 01       	movw	r30, r0
    2386:	83 9f       	mul	r24, r19
    2388:	f0 0d       	add	r31, r0
    238a:	11 24       	eor	r1, r1
    238c:	e4 5e       	subi	r30, 0xE4	; 228
    238e:	fe 4c       	sbci	r31, 0xCE	; 206
    2390:	01 80       	ldd	r0, Z+1	; 0x01
    2392:	f2 81       	ldd	r31, Z+2	; 0x02
    2394:	e0 2d       	mov	r30, r0
    2396:	80 85       	ldd	r24, Z+8	; 0x08
    2398:	91 85       	ldd	r25, Z+9	; 0x09
    239a:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <pxCurrentTCB>
    239e:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <pxCurrentTCB+0x1>
    23a2:	08 95       	ret

000023a4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    23a4:	cf 92       	push	r12
    23a6:	df 92       	push	r13
    23a8:	ef 92       	push	r14
    23aa:	ff 92       	push	r15
    23ac:	6a 01       	movw	r12, r20
    23ae:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    23b0:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    23b4:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    23b8:	62 5f       	subi	r22, 0xF2	; 242
    23ba:	7f 4f       	sbci	r23, 0xFF	; 255
    23bc:	0e 94 41 09 	call	0x1282	; 0x1282 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23c0:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    23c4:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    23c8:	02 96       	adiw	r24, 0x02	; 2
    23ca:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    23ce:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    23d2:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    23d6:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    23da:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    23de:	bc 01       	movw	r22, r24
    23e0:	cd 01       	movw	r24, r26
    23e2:	6c 0d       	add	r22, r12
    23e4:	7d 1d       	adc	r23, r13
    23e6:	8e 1d       	adc	r24, r14
    23e8:	9f 1d       	adc	r25, r15
    23ea:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	df 90       	pop	r13
    23f4:	cf 90       	pop	r12
    23f6:	08 95       	ret

000023f8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    23f8:	0f 93       	push	r16
    23fa:	1f 93       	push	r17
    23fc:	cf 93       	push	r28
    23fe:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2400:	dc 01       	movw	r26, r24
    2402:	17 96       	adiw	r26, 0x07	; 7
    2404:	ed 91       	ld	r30, X+
    2406:	fc 91       	ld	r31, X
    2408:	18 97       	sbiw	r26, 0x08	; 8
    240a:	c0 85       	ldd	r28, Z+8	; 0x08
    240c:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    240e:	8e 01       	movw	r16, r28
    2410:	02 5f       	subi	r16, 0xF2	; 242
    2412:	1f 4f       	sbci	r17, 0xFF	; 255
    2414:	c8 01       	movw	r24, r16
    2416:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    241a:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    241e:	81 11       	cpse	r24, r1
    2420:	16 c0       	rjmp	.+44     	; 0x244e <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2422:	0c 50       	subi	r16, 0x0C	; 12
    2424:	11 09       	sbc	r17, r1
    2426:	c8 01       	movw	r24, r16
    2428:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    242c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    242e:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2432:	98 17       	cp	r25, r24
    2434:	10 f4       	brcc	.+4      	; 0x243a <xTaskRemoveFromEventList+0x42>
    2436:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    243a:	bb e0       	ldi	r27, 0x0B	; 11
    243c:	8b 9f       	mul	r24, r27
    243e:	c0 01       	movw	r24, r0
    2440:	11 24       	eor	r1, r1
    2442:	b8 01       	movw	r22, r16
    2444:	84 5e       	subi	r24, 0xE4	; 228
    2446:	9e 4c       	sbci	r25, 0xCE	; 206
    2448:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
    244c:	05 c0       	rjmp	.+10     	; 0x2458 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    244e:	b8 01       	movw	r22, r16
    2450:	87 ef       	ldi	r24, 0xF7	; 247
    2452:	90 e3       	ldi	r25, 0x30	; 48
    2454:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2458:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    245c:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2460:	81 e0       	ldi	r24, 0x01	; 1
    2462:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2464:	92 8d       	ldd	r25, Z+26	; 0x1a
    2466:	29 17       	cp	r18, r25
    2468:	08 f4       	brcc	.+2      	; 0x246c <xTaskRemoveFromEventList+0x74>
    246a:	80 e0       	ldi	r24, 0x00	; 0
}
    246c:	df 91       	pop	r29
    246e:	cf 91       	pop	r28
    2470:	1f 91       	pop	r17
    2472:	0f 91       	pop	r16
    2474:	08 95       	ret

00002476 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2476:	20 91 e9 30 	lds	r18, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    247a:	fc 01       	movw	r30, r24
    247c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    247e:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    2482:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    2486:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    248a:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    248e:	41 83       	std	Z+1, r20	; 0x01
    2490:	52 83       	std	Z+2, r21	; 0x02
    2492:	63 83       	std	Z+3, r22	; 0x03
    2494:	74 83       	std	Z+4, r23	; 0x04
    2496:	08 95       	ret

00002498 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2498:	8f 92       	push	r8
    249a:	9f 92       	push	r9
    249c:	af 92       	push	r10
    249e:	bf 92       	push	r11
    24a0:	cf 92       	push	r12
    24a2:	df 92       	push	r13
    24a4:	ef 92       	push	r14
    24a6:	ff 92       	push	r15
    24a8:	0f 93       	push	r16
    24aa:	1f 93       	push	r17
    24ac:	cf 93       	push	r28
    24ae:	df 93       	push	r29
    24b0:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24b2:	0f b6       	in	r0, 0x3f	; 63
    24b4:	f8 94       	cli
    24b6:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    24b8:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    24bc:	90 81       	ld	r25, Z
    24be:	98 17       	cp	r25, r24
    24c0:	89 f0       	breq	.+34     	; 0x24e4 <xTaskCheckForTimeOut+0x4c>
    24c2:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    24c6:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    24ca:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    24ce:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    24d2:	01 81       	ldd	r16, Z+1	; 0x01
    24d4:	12 81       	ldd	r17, Z+2	; 0x02
    24d6:	23 81       	ldd	r18, Z+3	; 0x03
    24d8:	34 81       	ldd	r19, Z+4	; 0x04
    24da:	80 17       	cp	r24, r16
    24dc:	91 07       	cpc	r25, r17
    24de:	a2 07       	cpc	r26, r18
    24e0:	b3 07       	cpc	r27, r19
    24e2:	a8 f5       	brcc	.+106    	; 0x254e <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    24e4:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    24e8:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    24ec:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    24f0:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    24f4:	c1 80       	ldd	r12, Z+1	; 0x01
    24f6:	d2 80       	ldd	r13, Z+2	; 0x02
    24f8:	e3 80       	ldd	r14, Z+3	; 0x03
    24fa:	f4 80       	ldd	r15, Z+4	; 0x04
    24fc:	eb 01       	movw	r28, r22
    24fe:	08 81       	ld	r16, Y
    2500:	19 81       	ldd	r17, Y+1	; 0x01
    2502:	2a 81       	ldd	r18, Y+2	; 0x02
    2504:	3b 81       	ldd	r19, Y+3	; 0x03
    2506:	8c 19       	sub	r24, r12
    2508:	9d 09       	sbc	r25, r13
    250a:	ae 09       	sbc	r26, r14
    250c:	bf 09       	sbc	r27, r15
    250e:	80 17       	cp	r24, r16
    2510:	91 07       	cpc	r25, r17
    2512:	a2 07       	cpc	r26, r18
    2514:	b3 07       	cpc	r27, r19
    2516:	e8 f4       	brcc	.+58     	; 0x2552 <xTaskCheckForTimeOut+0xba>
    2518:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    251a:	80 90 f0 30 	lds	r8, 0x30F0	; 0x8030f0 <xTickCount>
    251e:	90 90 f1 30 	lds	r9, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    2522:	a0 90 f2 30 	lds	r10, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    2526:	b0 90 f3 30 	lds	r11, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    252a:	b5 01       	movw	r22, r10
    252c:	a4 01       	movw	r20, r8
    252e:	4c 19       	sub	r20, r12
    2530:	5d 09       	sbc	r21, r13
    2532:	6e 09       	sbc	r22, r14
    2534:	7f 09       	sbc	r23, r15
    2536:	04 1b       	sub	r16, r20
    2538:	15 0b       	sbc	r17, r21
    253a:	26 0b       	sbc	r18, r22
    253c:	37 0b       	sbc	r19, r23
    253e:	08 83       	st	Y, r16
    2540:	19 83       	std	Y+1, r17	; 0x01
    2542:	2a 83       	std	Y+2, r18	; 0x02
    2544:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2546:	0e 94 3b 12 	call	0x2476	; 0x2476 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    254a:	80 e0       	ldi	r24, 0x00	; 0
    254c:	03 c0       	rjmp	.+6      	; 0x2554 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	01 c0       	rjmp	.+2      	; 0x2554 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2552:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2554:	0f 90       	pop	r0
    2556:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2558:	df 91       	pop	r29
    255a:	cf 91       	pop	r28
    255c:	1f 91       	pop	r17
    255e:	0f 91       	pop	r16
    2560:	ff 90       	pop	r15
    2562:	ef 90       	pop	r14
    2564:	df 90       	pop	r13
    2566:	cf 90       	pop	r12
    2568:	bf 90       	pop	r11
    256a:	af 90       	pop	r10
    256c:	9f 90       	pop	r9
    256e:	8f 90       	pop	r8
    2570:	08 95       	ret

00002572 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xMissedYield>
    2578:	08 95       	ret

0000257a <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    257a:	00 97       	sbiw	r24, 0x00	; 0
    257c:	21 f4       	brne	.+8      	; 0x2586 <uxTaskGetStackHighWaterMark+0xc>
    257e:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    2582:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2586:	dc 01       	movw	r26, r24
    2588:	5b 96       	adiw	r26, 0x1b	; 27
    258a:	ed 91       	ld	r30, X+
    258c:	fc 91       	ld	r31, X
    258e:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2590:	80 81       	ld	r24, Z
    2592:	81 31       	cpi	r24, 0x11	; 17
    2594:	41 f4       	brne	.+16     	; 0x25a6 <uxTaskGetStackHighWaterMark+0x2c>
    2596:	31 96       	adiw	r30, 0x01	; 1
    2598:	80 e0       	ldi	r24, 0x00	; 0
    259a:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    259c:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    259e:	21 91       	ld	r18, Z+
    25a0:	21 31       	cpi	r18, 0x11	; 17
    25a2:	e1 f3       	breq	.-8      	; 0x259c <uxTaskGetStackHighWaterMark+0x22>
    25a4:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    25a6:	80 e0       	ldi	r24, 0x00	; 0
    25a8:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    25aa:	08 95       	ret

000025ac <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    25ac:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    25b0:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>

		return xReturn;
	}
    25b4:	08 95       	ret

000025b6 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    25b6:	0f 93       	push	r16
    25b8:	1f 93       	push	r17
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
    25be:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    25c0:	22 8d       	ldd	r18, Z+26	; 0x1a
    25c2:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    25c6:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    25ca:	5a 96       	adiw	r26, 0x1a	; 26
    25cc:	8c 91       	ld	r24, X
    25ce:	28 17       	cp	r18, r24
    25d0:	08 f0       	brcs	.+2      	; 0x25d4 <vTaskPriorityInherit+0x1e>
    25d2:	41 c0       	rjmp	.+130    	; 0x2656 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    25d4:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    25d8:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    25dc:	5a 96       	adiw	r26, 0x1a	; 26
    25de:	3c 91       	ld	r19, X
    25e0:	84 e0       	ldi	r24, 0x04	; 4
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	a0 e0       	ldi	r26, 0x00	; 0
    25e6:	b0 e0       	ldi	r27, 0x00	; 0
    25e8:	83 1b       	sub	r24, r19
    25ea:	91 09       	sbc	r25, r1
    25ec:	a1 09       	sbc	r26, r1
    25ee:	b1 09       	sbc	r27, r1
    25f0:	86 87       	std	Z+14, r24	; 0x0e
    25f2:	97 87       	std	Z+15, r25	; 0x0f
    25f4:	a0 8b       	std	Z+16, r26	; 0x10
    25f6:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    25f8:	8b e0       	ldi	r24, 0x0B	; 11
    25fa:	28 9f       	mul	r18, r24
    25fc:	90 01       	movw	r18, r0
    25fe:	11 24       	eor	r1, r1
    2600:	24 5e       	subi	r18, 0xE4	; 228
    2602:	3e 4c       	sbci	r19, 0xCE	; 206
    2604:	84 85       	ldd	r24, Z+12	; 0x0c
    2606:	95 85       	ldd	r25, Z+13	; 0x0d
    2608:	82 17       	cp	r24, r18
    260a:	93 07       	cpc	r25, r19
    260c:	e9 f4       	brne	.+58     	; 0x2648 <vTaskPriorityInherit+0x92>
    260e:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2610:	ef 01       	movw	r28, r30
    2612:	22 96       	adiw	r28, 0x02	; 2
    2614:	ce 01       	movw	r24, r28
    2616:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    261a:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    261e:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    2622:	82 8d       	ldd	r24, Z+26	; 0x1a
    2624:	f8 01       	movw	r30, r16
    2626:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2628:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    262c:	98 17       	cp	r25, r24
    262e:	10 f4       	brcc	.+4      	; 0x2634 <vTaskPriorityInherit+0x7e>
    2630:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2634:	fb e0       	ldi	r31, 0x0B	; 11
    2636:	8f 9f       	mul	r24, r31
    2638:	c0 01       	movw	r24, r0
    263a:	11 24       	eor	r1, r1
    263c:	be 01       	movw	r22, r28
    263e:	84 5e       	subi	r24, 0xE4	; 228
    2640:	9e 4c       	sbci	r25, 0xCE	; 206
    2642:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
    2646:	07 c0       	rjmp	.+14     	; 0x2656 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2648:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    264c:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    2650:	5a 96       	adiw	r26, 0x1a	; 26
    2652:	8c 91       	ld	r24, X
    2654:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2656:	df 91       	pop	r29
    2658:	cf 91       	pop	r28
    265a:	1f 91       	pop	r17
    265c:	0f 91       	pop	r16
    265e:	08 95       	ret

00002660 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2660:	0f 93       	push	r16
    2662:	1f 93       	push	r17
    2664:	cf 93       	push	r28
    2666:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2668:	00 97       	sbiw	r24, 0x00	; 0
    266a:	49 f1       	breq	.+82     	; 0x26be <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    266c:	fc 01       	movw	r30, r24
    266e:	32 8d       	ldd	r19, Z+26	; 0x1a
    2670:	27 a1       	ldd	r18, Z+39	; 0x27
    2672:	32 17       	cp	r19, r18
    2674:	21 f1       	breq	.+72     	; 0x26be <vTaskPriorityDisinherit+0x5e>
    2676:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2678:	8c 01       	movw	r16, r24
    267a:	0e 5f       	subi	r16, 0xFE	; 254
    267c:	1f 4f       	sbci	r17, 0xFF	; 255
    267e:	c8 01       	movw	r24, r16
    2680:	0e 94 8c 09 	call	0x1318	; 0x1318 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2684:	8f a1       	ldd	r24, Y+39	; 0x27
    2686:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2688:	44 e0       	ldi	r20, 0x04	; 4
    268a:	50 e0       	ldi	r21, 0x00	; 0
    268c:	60 e0       	ldi	r22, 0x00	; 0
    268e:	70 e0       	ldi	r23, 0x00	; 0
    2690:	48 1b       	sub	r20, r24
    2692:	51 09       	sbc	r21, r1
    2694:	61 09       	sbc	r22, r1
    2696:	71 09       	sbc	r23, r1
    2698:	4e 87       	std	Y+14, r20	; 0x0e
    269a:	5f 87       	std	Y+15, r21	; 0x0f
    269c:	68 8b       	std	Y+16, r22	; 0x10
    269e:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    26a0:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    26a4:	98 17       	cp	r25, r24
    26a6:	10 f4       	brcc	.+4      	; 0x26ac <vTaskPriorityDisinherit+0x4c>
    26a8:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    26ac:	fb e0       	ldi	r31, 0x0B	; 11
    26ae:	8f 9f       	mul	r24, r31
    26b0:	c0 01       	movw	r24, r0
    26b2:	11 24       	eor	r1, r1
    26b4:	b8 01       	movw	r22, r16
    26b6:	84 5e       	subi	r24, 0xE4	; 228
    26b8:	9e 4c       	sbci	r25, 0xCE	; 206
    26ba:	0e 94 1a 09 	call	0x1234	; 0x1234 <vListInsertEnd>
			}
		}
	}
    26be:	df 91       	pop	r29
    26c0:	cf 91       	pop	r28
    26c2:	1f 91       	pop	r17
    26c4:	0f 91       	pop	r16
    26c6:	08 95       	ret

000026c8 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    26c8:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    26ca:	e8 81       	ld	r30, Y
    26cc:	f9 81       	ldd	r31, Y+1	; 0x01
    26ce:	01 90       	ld	r0, Z+
    26d0:	f0 81       	ld	r31, Z
    26d2:	e0 2d       	mov	r30, r0
    26d4:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    26d6:	1a 82       	std	Y+2, r1	; 0x02
    26d8:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    26da:	6f ef       	ldi	r22, 0xFF	; 255
    26dc:	7f ef       	ldi	r23, 0xFF	; 255
    26de:	cb 01       	movw	r24, r22
    26e0:	0e 94 47 11 	call	0x228e	; 0x228e <vTaskDelay>
    26e4:	fa cf       	rjmp	.-12     	; 0x26da <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000026e6 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    26e6:	fc 01       	movw	r30, r24
    26e8:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    26ea:	65 87       	std	Z+13, r22	; 0x0d
    26ec:	08 95       	ret

000026ee <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    26ee:	4f 92       	push	r4
    26f0:	5f 92       	push	r5
    26f2:	6f 92       	push	r6
    26f4:	7f 92       	push	r7
    26f6:	8f 92       	push	r8
    26f8:	9f 92       	push	r9
    26fa:	af 92       	push	r10
    26fc:	bf 92       	push	r11
    26fe:	cf 92       	push	r12
    2700:	df 92       	push	r13
    2702:	ef 92       	push	r14
    2704:	ff 92       	push	r15
    2706:	0f 93       	push	r16
    2708:	1f 93       	push	r17
    270a:	cf 93       	push	r28
    270c:	df 93       	push	r29
    270e:	cd b7       	in	r28, 0x3d	; 61
    2710:	de b7       	in	r29, 0x3e	; 62
    2712:	2a 97       	sbiw	r28, 0x0a	; 10
    2714:	cd bf       	out	0x3d, r28	; 61
    2716:	de bf       	out	0x3e, r29	; 62
    2718:	4c 01       	movw	r8, r24
    271a:	29 01       	movw	r4, r18
    271c:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    271e:	87 e3       	ldi	r24, 0x37	; 55
    2720:	90 e2       	ldi	r25, 0x20	; 32
    2722:	f4 01       	movw	r30, r8
    2724:	80 83       	st	Z, r24
    2726:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2728:	fb 01       	movw	r30, r22
    272a:	80 81       	ld	r24, Z
    272c:	88 23       	and	r24, r24
    272e:	69 f0       	breq	.+26     	; 0x274a <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2730:	de 01       	movw	r26, r28
    2732:	11 96       	adiw	r26, 0x01	; 1
    2734:	31 96       	adiw	r30, 0x01	; 1
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	02 c0       	rjmp	.+4      	; 0x273e <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    273a:	99 30       	cpi	r25, 0x09	; 9
    273c:	39 f0       	breq	.+14     	; 0x274c <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    273e:	9f 5f       	subi	r25, 0xFF	; 255
    2740:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2742:	81 91       	ld	r24, Z+
    2744:	81 11       	cpse	r24, r1
    2746:	f9 cf       	rjmp	.-14     	; 0x273a <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2748:	01 c0       	rjmp	.+2      	; 0x274c <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    274a:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    274c:	e1 e0       	ldi	r30, 0x01	; 1
    274e:	f0 e0       	ldi	r31, 0x00	; 0
    2750:	ec 0f       	add	r30, r28
    2752:	fd 1f       	adc	r31, r29
    2754:	e9 0f       	add	r30, r25
    2756:	f1 1d       	adc	r31, r1
    2758:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    275a:	74 01       	movw	r14, r8
    275c:	f2 e0       	ldi	r31, 0x02	; 2
    275e:	ef 0e       	add	r14, r31
    2760:	f1 1c       	adc	r15, r1
    2762:	a1 2c       	mov	r10, r1
    2764:	b1 2c       	mov	r11, r1
    2766:	c1 2c       	mov	r12, r1
    2768:	d1 2c       	mov	r13, r1
    276a:	04 2f       	mov	r16, r20
    276c:	94 01       	movw	r18, r8
    276e:	a2 01       	movw	r20, r4
    2770:	be 01       	movw	r22, r28
    2772:	6f 5f       	subi	r22, 0xFF	; 255
    2774:	7f 4f       	sbci	r23, 0xFF	; 255
    2776:	8a ee       	ldi	r24, 0xEA	; 234
    2778:	92 e0       	ldi	r25, 0x02	; 2
    277a:	0e 94 60 0e 	call	0x1cc0	; 0x1cc0 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    277e:	f4 01       	movw	r30, r8
    2780:	66 82       	std	Z+6, r6	; 0x06
    2782:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2784:	40 86       	std	Z+8, r4	; 0x08
    2786:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2788:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <last_created_task_pointer>
    278c:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    2790:	24 83       	std	Z+4, r18	; 0x04
    2792:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2794:	80 92 4a 31 	sts	0x314A, r8	; 0x80314a <last_created_task_pointer>
    2798:	90 92 4b 31 	sts	0x314B, r9	; 0x80314b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    279c:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    279e:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    27a0:	40 90 ac 31 	lds	r4, 0x31AC	; 0x8031ac <portStackTopForTask>
    27a4:	50 90 ad 31 	lds	r5, 0x31AD	; 0x8031ad <portStackTopForTask+0x1>
    27a8:	ff ef       	ldi	r31, 0xFF	; 255
    27aa:	4f 1a       	sub	r4, r31
    27ac:	5f 0a       	sbc	r5, r31
    27ae:	40 92 ac 31 	sts	0x31AC, r4	; 0x8031ac <portStackTopForTask>
    27b2:	50 92 ad 31 	sts	0x31AD, r5	; 0x8031ad <portStackTopForTask+0x1>
    27b6:	f4 01       	movw	r30, r8
    27b8:	42 86       	std	Z+10, r4	; 0x0a
    27ba:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    27bc:	16 86       	std	Z+14, r1	; 0x0e
    27be:	17 86       	std	Z+15, r1	; 0x0f
    27c0:	10 8a       	std	Z+16, r1	; 0x10
    27c2:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    27c4:	61 14       	cp	r6, r1
    27c6:	71 04       	cpc	r7, r1
    27c8:	09 f4       	brne	.+2      	; 0x27cc <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    27ca:	44 c0       	rjmp	.+136    	; 0x2854 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    27cc:	81 30       	cpi	r24, 0x01	; 1
    27ce:	79 f5       	brne	.+94     	; 0x282e <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    27d0:	6a e0       	ldi	r22, 0x0A	; 10
    27d2:	c3 01       	movw	r24, r6
    27d4:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    27d8:	7c 01       	movw	r14, r24
    27da:	61 e2       	ldi	r22, 0x21	; 33
    27dc:	75 e0       	ldi	r23, 0x05	; 5
    27de:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    27e2:	be 01       	movw	r22, r28
    27e4:	6f 5f       	subi	r22, 0xFF	; 255
    27e6:	7f 4f       	sbci	r23, 0xFF	; 255
    27e8:	c7 01       	movw	r24, r14
    27ea:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    27ee:	6a e0       	ldi	r22, 0x0A	; 10
    27f0:	c7 01       	movw	r24, r14
    27f2:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    27f6:	7c 01       	movw	r14, r24
    27f8:	68 e1       	ldi	r22, 0x18	; 24
    27fa:	75 e0       	ldi	r23, 0x05	; 5
    27fc:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2800:	6a e0       	ldi	r22, 0x0A	; 10
    2802:	c7 01       	movw	r24, r14
    2804:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2808:	7c 01       	movw	r14, r24
    280a:	6a e0       	ldi	r22, 0x0A	; 10
    280c:	75 e0       	ldi	r23, 0x05	; 5
    280e:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2812:	63 e0       	ldi	r22, 0x03	; 3
    2814:	c7 01       	movw	r24, r14
    2816:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    281a:	b2 01       	movw	r22, r4
    281c:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
    2820:	62 e0       	ldi	r22, 0x02	; 2
    2822:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2826:	66 e0       	ldi	r22, 0x06	; 6
    2828:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    282c:	13 c0       	rjmp	.+38     	; 0x2854 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    282e:	6a e0       	ldi	r22, 0x0A	; 10
    2830:	c3 01       	movw	r24, r6
    2832:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2836:	4c 01       	movw	r8, r24
    2838:	65 ef       	ldi	r22, 0xF5	; 245
    283a:	74 e0       	ldi	r23, 0x04	; 4
    283c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2840:	be 01       	movw	r22, r28
    2842:	6f 5f       	subi	r22, 0xFF	; 255
    2844:	7f 4f       	sbci	r23, 0xFF	; 255
    2846:	c4 01       	movw	r24, r8
    2848:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    284c:	66 e0       	ldi	r22, 0x06	; 6
    284e:	c4 01       	movw	r24, r8
    2850:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2854:	2a 96       	adiw	r28, 0x0a	; 10
    2856:	cd bf       	out	0x3d, r28	; 61
    2858:	de bf       	out	0x3e, r29	; 62
    285a:	df 91       	pop	r29
    285c:	cf 91       	pop	r28
    285e:	1f 91       	pop	r17
    2860:	0f 91       	pop	r16
    2862:	ff 90       	pop	r15
    2864:	ef 90       	pop	r14
    2866:	df 90       	pop	r13
    2868:	cf 90       	pop	r12
    286a:	bf 90       	pop	r11
    286c:	af 90       	pop	r10
    286e:	9f 90       	pop	r9
    2870:	8f 90       	pop	r8
    2872:	7f 90       	pop	r7
    2874:	6f 90       	pop	r6
    2876:	5f 90       	pop	r5
    2878:	4f 90       	pop	r4
    287a:	08 95       	ret

0000287c <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    287c:	cf 92       	push	r12
    287e:	df 92       	push	r13
    2880:	ef 92       	push	r14
    2882:	ff 92       	push	r15
    2884:	0f 93       	push	r16
    2886:	1f 93       	push	r17
    2888:	cf 93       	push	r28
    288a:	df 93       	push	r29
    288c:	ec 01       	movw	r28, r24
    288e:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2890:	8a 81       	ldd	r24, Y+2	; 0x02
    2892:	9b 81       	ldd	r25, Y+3	; 0x03
    2894:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <pcTaskGetTaskName>
    2898:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    289a:	6a e0       	ldi	r22, 0x0A	; 10
    289c:	c7 01       	movw	r24, r14
    289e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    28a2:	8c 01       	movw	r16, r24
    28a4:	64 e3       	ldi	r22, 0x34	; 52
    28a6:	75 e0       	ldi	r23, 0x05	; 5
    28a8:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    28ac:	6a e0       	ldi	r22, 0x0A	; 10
    28ae:	c8 01       	movw	r24, r16
    28b0:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    28b4:	8c 01       	movw	r16, r24
    28b6:	6d e2       	ldi	r22, 0x2D	; 45
    28b8:	75 e0       	ldi	r23, 0x05	; 5
    28ba:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    28be:	b6 01       	movw	r22, r12
    28c0:	c8 01       	movw	r24, r16
    28c2:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    28c6:	6a e0       	ldi	r22, 0x0A	; 10
    28c8:	c8 01       	movw	r24, r16
    28ca:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    28ce:	8c 01       	movw	r16, r24
    28d0:	67 e2       	ldi	r22, 0x27	; 39
    28d2:	75 e0       	ldi	r23, 0x05	; 5
    28d4:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    28d8:	66 e0       	ldi	r22, 0x06	; 6
    28da:	c8 01       	movw	r24, r16
    28dc:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    28e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    28e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    28e4:	e8 85       	ldd	r30, Y+8	; 0x08
    28e6:	f9 85       	ldd	r31, Y+9	; 0x09
    28e8:	01 e1       	ldi	r16, 0x11	; 17
    28ea:	21 e0       	ldi	r18, 0x01	; 1
    28ec:	a7 01       	movw	r20, r14
    28ee:	bc 01       	movw	r22, r24
    28f0:	8e 1b       	sub	r24, r30
    28f2:	9f 0b       	sbc	r25, r31
    28f4:	0e 94 40 17 	call	0x2e80	; 0x2e80 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    28f8:	8c 81       	ldd	r24, Y+4	; 0x04
    28fa:	9d 81       	ldd	r25, Y+5	; 0x05
    28fc:	00 97       	sbiw	r24, 0x00	; 0
    28fe:	19 f0       	breq	.+6      	; 0x2906 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2900:	b7 01       	movw	r22, r14
    2902:	0e 94 3e 14 	call	0x287c	; 0x287c <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2906:	df 91       	pop	r29
    2908:	cf 91       	pop	r28
    290a:	1f 91       	pop	r17
    290c:	0f 91       	pop	r16
    290e:	ff 90       	pop	r15
    2910:	ef 90       	pop	r14
    2912:	df 90       	pop	r13
    2914:	cf 90       	pop	r12
    2916:	08 95       	ret

00002918 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2918:	0f 93       	push	r16
    291a:	1f 93       	push	r17
    291c:	cf 93       	push	r28
    291e:	df 93       	push	r29
    2920:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2922:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <last_created_task_pointer>
    2926:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    292a:	00 97       	sbiw	r24, 0x00	; 0
    292c:	19 f0       	breq	.+6      	; 0x2934 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    292e:	be 01       	movw	r22, r28
    2930:	0e 94 3e 14 	call	0x287c	; 0x287c <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2934:	6a e0       	ldi	r22, 0x0A	; 10
    2936:	ce 01       	movw	r24, r28
    2938:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    293c:	8c 01       	movw	r16, r24
    293e:	6a e4       	ldi	r22, 0x4A	; 74
    2940:	75 e0       	ldi	r23, 0x05	; 5
    2942:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2946:	6a e0       	ldi	r22, 0x0A	; 10
    2948:	c8 01       	movw	r24, r16
    294a:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    294e:	8c 01       	movw	r16, r24
    2950:	6f e3       	ldi	r22, 0x3F	; 63
    2952:	75 e0       	ldi	r23, 0x05	; 5
    2954:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2958:	6a e0       	ldi	r22, 0x0A	; 10
    295a:	c8 01       	movw	r24, r16
    295c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2960:	8c 01       	movw	r16, r24
    2962:	69 e3       	ldi	r22, 0x39	; 57
    2964:	75 e0       	ldi	r23, 0x05	; 5
    2966:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    296a:	66 e0       	ldi	r22, 0x06	; 6
    296c:	c8 01       	movw	r24, r16
    296e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2972:	80 91 ac 31 	lds	r24, 0x31AC	; 0x8031ac <portStackTopForTask>
    2976:	90 91 ad 31 	lds	r25, 0x31AD	; 0x8031ad <portStackTopForTask+0x1>
    297a:	bc 01       	movw	r22, r24
    297c:	6f 5f       	subi	r22, 0xFF	; 255
    297e:	7f 4f       	sbci	r23, 0xFF	; 255
    2980:	01 e1       	ldi	r16, 0x11	; 17
    2982:	21 e0       	ldi	r18, 0x01	; 1
    2984:	ae 01       	movw	r20, r28
    2986:	83 56       	subi	r24, 0x63	; 99
    2988:	91 09       	sbc	r25, r1
    298a:	0e 94 40 17 	call	0x2e80	; 0x2e80 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    298e:	df 91       	pop	r29
    2990:	cf 91       	pop	r28
    2992:	1f 91       	pop	r17
    2994:	0f 91       	pop	r16
    2996:	08 95       	ret

00002998 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2998:	8f 92       	push	r8
    299a:	9f 92       	push	r9
    299c:	af 92       	push	r10
    299e:	bf 92       	push	r11
    29a0:	cf 92       	push	r12
    29a2:	df 92       	push	r13
    29a4:	ef 92       	push	r14
    29a6:	ff 92       	push	r15
    29a8:	0f 93       	push	r16
    29aa:	1f 93       	push	r17
    29ac:	cf 93       	push	r28
    29ae:	df 93       	push	r29
    29b0:	ec 01       	movw	r28, r24
    29b2:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    29b4:	8a 81       	ldd	r24, Y+2	; 0x02
    29b6:	9b 81       	ldd	r25, Y+3	; 0x03
    29b8:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <pcTaskGetTaskName>
    29bc:	bc 01       	movw	r22, r24
    29be:	c8 01       	movw	r24, r16
    29c0:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    29c4:	d8 01       	movw	r26, r16
    29c6:	ed 91       	ld	r30, X+
    29c8:	fc 91       	ld	r31, X
    29ca:	02 80       	ldd	r0, Z+2	; 0x02
    29cc:	f3 81       	ldd	r31, Z+3	; 0x03
    29ce:	e0 2d       	mov	r30, r0
    29d0:	69 e0       	ldi	r22, 0x09	; 9
    29d2:	c8 01       	movw	r24, r16
    29d4:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    29d6:	8a 81       	ldd	r24, Y+2	; 0x02
    29d8:	9b 81       	ldd	r25, Y+3	; 0x03
    29da:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <pcTaskGetTaskName>
    29de:	fc 01       	movw	r30, r24
    29e0:	01 90       	ld	r0, Z+
    29e2:	00 20       	and	r0, r0
    29e4:	e9 f7       	brne	.-6      	; 0x29e0 <_ZN8frt_task12print_statusER8emstream+0x48>
    29e6:	31 97       	sbiw	r30, 0x01	; 1
    29e8:	e8 1b       	sub	r30, r24
    29ea:	f9 0b       	sbc	r31, r25
    29ec:	38 97       	sbiw	r30, 0x08	; 8
    29ee:	48 f4       	brcc	.+18     	; 0x2a02 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    29f0:	d8 01       	movw	r26, r16
    29f2:	ed 91       	ld	r30, X+
    29f4:	fc 91       	ld	r31, X
    29f6:	02 80       	ldd	r0, Z+2	; 0x02
    29f8:	f3 81       	ldd	r31, Z+3	; 0x03
    29fa:	e0 2d       	mov	r30, r0
    29fc:	69 e0       	ldi	r22, 0x09	; 9
    29fe:	c8 01       	movw	r24, r16
    2a00:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2a02:	ce 84       	ldd	r12, Y+14	; 0x0e
    2a04:	df 84       	ldd	r13, Y+15	; 0x0f
    2a06:	e8 88       	ldd	r14, Y+16	; 0x10
    2a08:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2a0a:	a8 84       	ldd	r10, Y+8	; 0x08
    2a0c:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a10:	9b 81       	ldd	r25, Y+3	; 0x03
    2a12:	0e 94 bd 12 	call	0x257a	; 0x257a <uxTaskGetStackHighWaterMark>
    2a16:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2a18:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a1c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a1e:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <uxTaskPriorityGet>
    2a22:	68 2f       	mov	r22, r24
    2a24:	c8 01       	movw	r24, r16
    2a26:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    2a2a:	6a e0       	ldi	r22, 0x0A	; 10
    2a2c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2a30:	ec 01       	movw	r28, r24
    2a32:	6f eb       	ldi	r22, 0xBF	; 191
    2a34:	75 e0       	ldi	r23, 0x05	; 5
    2a36:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
			<< get_state ()
    2a3a:	68 2d       	mov	r22, r8
    2a3c:	ce 01       	movw	r24, r28
    2a3e:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2a42:	6a e0       	ldi	r22, 0x0A	; 10
    2a44:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2a48:	ec 01       	movw	r28, r24
    2a4a:	6d eb       	ldi	r22, 0xBD	; 189
    2a4c:	75 e0       	ldi	r23, 0x05	; 5
    2a4e:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2a52:	69 2d       	mov	r22, r9
    2a54:	ce 01       	movw	r24, r28
    2a56:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    2a5a:	6a e0       	ldi	r22, 0x0A	; 10
    2a5c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2a60:	ec 01       	movw	r28, r24
    2a62:	6b eb       	ldi	r22, 0xBB	; 187
    2a64:	75 e0       	ldi	r23, 0x05	; 5
    2a66:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2a6a:	b5 01       	movw	r22, r10
    2a6c:	ce 01       	movw	r24, r28
    2a6e:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
    2a72:	6a e0       	ldi	r22, 0x0A	; 10
    2a74:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2a78:	ec 01       	movw	r28, r24
    2a7a:	69 eb       	ldi	r22, 0xB9	; 185
    2a7c:	75 e0       	ldi	r23, 0x05	; 5
    2a7e:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2a82:	6a e0       	ldi	r22, 0x0A	; 10
    2a84:	ce 01       	movw	r24, r28
    2a86:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2a8a:	ec 01       	movw	r28, r24
    2a8c:	67 eb       	ldi	r22, 0xB7	; 183
    2a8e:	75 e0       	ldi	r23, 0x05	; 5
    2a90:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2a94:	b7 01       	movw	r22, r14
    2a96:	a6 01       	movw	r20, r12
    2a98:	ce 01       	movw	r24, r28
    2a9a:	0e 94 57 19 	call	0x32ae	; 0x32ae <_ZN8emstreamlsEm>
}
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	1f 91       	pop	r17
    2aa4:	0f 91       	pop	r16
    2aa6:	ff 90       	pop	r15
    2aa8:	ef 90       	pop	r14
    2aaa:	df 90       	pop	r13
    2aac:	cf 90       	pop	r12
    2aae:	bf 90       	pop	r11
    2ab0:	af 90       	pop	r10
    2ab2:	9f 90       	pop	r9
    2ab4:	8f 90       	pop	r8
    2ab6:	08 95       	ret

00002ab8 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2ab8:	cf 93       	push	r28
    2aba:	df 93       	push	r29
    2abc:	ec 01       	movw	r28, r24
    2abe:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2ac0:	db 01       	movw	r26, r22
    2ac2:	ed 91       	ld	r30, X+
    2ac4:	fc 91       	ld	r31, X
    2ac6:	02 80       	ldd	r0, Z+2	; 0x02
    2ac8:	f3 81       	ldd	r31, Z+3	; 0x03
    2aca:	e0 2d       	mov	r30, r0
    2acc:	be 01       	movw	r22, r28
    2ace:	19 95       	eicall
	return (ser_dev);
}
    2ad0:	ce 01       	movw	r24, r28
    2ad2:	df 91       	pop	r29
    2ad4:	cf 91       	pop	r28
    2ad6:	08 95       	ret

00002ad8 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2ad8:	0f 93       	push	r16
    2ada:	1f 93       	push	r17
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	ec 01       	movw	r28, r24
    2ae2:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2ae4:	bc 01       	movw	r22, r24
    2ae6:	c8 01       	movw	r24, r16
    2ae8:	0e 94 5c 15 	call	0x2ab8	; 0x2ab8 <_ZlsR8emstreamR8frt_task>
    2aec:	66 e0       	ldi	r22, 0x06	; 6
    2aee:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2af2:	8c 81       	ldd	r24, Y+4	; 0x04
    2af4:	9d 81       	ldd	r25, Y+5	; 0x05
    2af6:	00 97       	sbiw	r24, 0x00	; 0
    2af8:	19 f0       	breq	.+6      	; 0x2b00 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2afa:	b8 01       	movw	r22, r16
    2afc:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2b00:	df 91       	pop	r29
    2b02:	cf 91       	pop	r28
    2b04:	1f 91       	pop	r17
    2b06:	0f 91       	pop	r16
    2b08:	08 95       	ret

00002b0a <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2b0a:	0f 93       	push	r16
    2b0c:	1f 93       	push	r17
    2b0e:	cf 93       	push	r28
    2b10:	df 93       	push	r29
    2b12:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2b14:	6a e0       	ldi	r22, 0x0A	; 10
    2b16:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b1a:	8c 01       	movw	r16, r24
    2b1c:	6c ea       	ldi	r22, 0xAC	; 172
    2b1e:	75 e0       	ldi	r23, 0x05	; 5
    2b20:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2b24:	6a e0       	ldi	r22, 0x0A	; 10
    2b26:	c8 01       	movw	r24, r16
    2b28:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b2c:	8c 01       	movw	r16, r24
    2b2e:	65 ea       	ldi	r22, 0xA5	; 165
    2b30:	75 e0       	ldi	r23, 0x05	; 5
    2b32:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2b36:	66 e0       	ldi	r22, 0x06	; 6
    2b38:	c8 01       	movw	r24, r16
    2b3a:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2b3e:	6a e0       	ldi	r22, 0x0A	; 10
    2b40:	ce 01       	movw	r24, r28
    2b42:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b46:	8c 01       	movw	r16, r24
    2b48:	64 e9       	ldi	r22, 0x94	; 148
    2b4a:	75 e0       	ldi	r23, 0x05	; 5
    2b4c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2b50:	6a e0       	ldi	r22, 0x0A	; 10
    2b52:	c8 01       	movw	r24, r16
    2b54:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b58:	8c 01       	movw	r16, r24
    2b5a:	68 e8       	ldi	r22, 0x88	; 136
    2b5c:	75 e0       	ldi	r23, 0x05	; 5
    2b5e:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2b62:	6a e0       	ldi	r22, 0x0A	; 10
    2b64:	c8 01       	movw	r24, r16
    2b66:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b6a:	8c 01       	movw	r16, r24
    2b6c:	62 e8       	ldi	r22, 0x82	; 130
    2b6e:	75 e0       	ldi	r23, 0x05	; 5
    2b70:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2b74:	66 e0       	ldi	r22, 0x06	; 6
    2b76:	c8 01       	movw	r24, r16
    2b78:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2b7c:	6a e0       	ldi	r22, 0x0A	; 10
    2b7e:	ce 01       	movw	r24, r28
    2b80:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b84:	8c 01       	movw	r16, r24
    2b86:	61 e7       	ldi	r22, 0x71	; 113
    2b88:	75 e0       	ldi	r23, 0x05	; 5
    2b8a:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2b8e:	6a e0       	ldi	r22, 0x0A	; 10
    2b90:	c8 01       	movw	r24, r16
    2b92:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2b96:	8c 01       	movw	r16, r24
    2b98:	65 e6       	ldi	r22, 0x65	; 101
    2b9a:	75 e0       	ldi	r23, 0x05	; 5
    2b9c:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2ba0:	6a e0       	ldi	r22, 0x0A	; 10
    2ba2:	c8 01       	movw	r24, r16
    2ba4:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2ba8:	8c 01       	movw	r16, r24
    2baa:	6f e5       	ldi	r22, 0x5F	; 95
    2bac:	75 e0       	ldi	r23, 0x05	; 5
    2bae:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2bb2:	66 e0       	ldi	r22, 0x06	; 6
    2bb4:	c8 01       	movw	r24, r16
    2bb6:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2bba:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <last_created_task_pointer>
    2bbe:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    2bc2:	00 97       	sbiw	r24, 0x00	; 0
    2bc4:	19 f0       	breq	.+6      	; 0x2bcc <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2bc6:	be 01       	movw	r22, r28
    2bc8:	0e 94 6c 15 	call	0x2ad8	; 0x2ad8 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2bcc:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <xTaskGetIdleTaskHandle>
    2bd0:	0e 94 bd 12 	call	0x257a	; 0x257a <uxTaskGetStackHighWaterMark>
    2bd4:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2bd6:	6a e0       	ldi	r22, 0x0A	; 10
    2bd8:	ce 01       	movw	r24, r28
    2bda:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2bde:	ec 01       	movw	r28, r24
    2be0:	64 e5       	ldi	r22, 0x54	; 84
    2be2:	75 e0       	ldi	r23, 0x05	; 5
    2be4:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2be8:	61 2f       	mov	r22, r17
    2bea:	ce 01       	movw	r24, r28
    2bec:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2bf0:	6a e0       	ldi	r22, 0x0A	; 10
    2bf2:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2bf6:	ec 01       	movw	r28, r24
    2bf8:	62 e5       	ldi	r22, 0x52	; 82
    2bfa:	75 e0       	ldi	r23, 0x05	; 5
    2bfc:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2c00:	64 e6       	ldi	r22, 0x64	; 100
    2c02:	70 e0       	ldi	r23, 0x00	; 0
    2c04:	ce 01       	movw	r24, r28
    2c06:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
    2c0a:	6a e0       	ldi	r22, 0x0A	; 10
    2c0c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2c10:	ec 01       	movw	r28, r24
    2c12:	6f e4       	ldi	r22, 0x4F	; 79
    2c14:	75 e0       	ldi	r23, 0x05	; 5
    2c16:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2c1a:	66 e0       	ldi	r22, 0x06	; 6
    2c1c:	ce 01       	movw	r24, r28
    2c1e:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
}
    2c22:	df 91       	pop	r29
    2c24:	cf 91       	pop	r28
    2c26:	1f 91       	pop	r17
    2c28:	0f 91       	pop	r16
    2c2a:	08 95       	ret

00002c2c <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2c2c:	0f 93       	push	r16
    2c2e:	cf 93       	push	r28
    2c30:	df 93       	push	r29
    2c32:	1f 92       	push	r1
    2c34:	cd b7       	in	r28, 0x3d	; 61
    2c36:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2c38:	00 e0       	ldi	r16, 0x00	; 0
    2c3a:	2f ef       	ldi	r18, 0xFF	; 255
    2c3c:	3f ef       	ldi	r19, 0xFF	; 255
    2c3e:	a9 01       	movw	r20, r18
    2c40:	be 01       	movw	r22, r28
    2c42:	6f 5f       	subi	r22, 0xFF	; 255
    2c44:	7f 4f       	sbci	r23, 0xFF	; 255
    2c46:	fc 01       	movw	r30, r24
    2c48:	80 85       	ldd	r24, Z+8	; 0x08
    2c4a:	91 85       	ldd	r25, Z+9	; 0x09
    2c4c:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
    2c50:	81 30       	cpi	r24, 0x01	; 1
    2c52:	19 f4       	brne	.+6      	; 0x2c5a <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2c54:	89 81       	ldd	r24, Y+1	; 0x01
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	02 c0       	rjmp	.+4      	; 0x2c5e <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2c5a:	8f ef       	ldi	r24, 0xFF	; 255
    2c5c:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2c5e:	0f 90       	pop	r0
    2c60:	df 91       	pop	r29
    2c62:	cf 91       	pop	r28
    2c64:	0f 91       	pop	r16
    2c66:	08 95       	ret

00002c68 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2c68:	fc 01       	movw	r30, r24
    2c6a:	80 85       	ldd	r24, Z+8	; 0x08
    2c6c:	91 85       	ldd	r25, Z+9	; 0x09
    2c6e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
    2c72:	91 e0       	ldi	r25, 0x01	; 1
    2c74:	81 11       	cpse	r24, r1
    2c76:	01 c0       	rjmp	.+2      	; 0x2c7a <_ZN14frt_text_queue14check_for_charEv+0x12>
    2c78:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2c7a:	89 2f       	mov	r24, r25
    2c7c:	08 95       	ret

00002c7e <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2c7e:	0f 93       	push	r16
    2c80:	cf 93       	push	r28
    2c82:	df 93       	push	r29
    2c84:	1f 92       	push	r1
    2c86:	cd b7       	in	r28, 0x3d	; 61
    2c88:	de b7       	in	r29, 0x3e	; 62
    2c8a:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2c8c:	fc 01       	movw	r30, r24
    2c8e:	22 85       	ldd	r18, Z+10	; 0x0a
    2c90:	33 85       	ldd	r19, Z+11	; 0x0b
    2c92:	44 85       	ldd	r20, Z+12	; 0x0c
    2c94:	55 85       	ldd	r21, Z+13	; 0x0d
    2c96:	00 e0       	ldi	r16, 0x00	; 0
    2c98:	be 01       	movw	r22, r28
    2c9a:	6f 5f       	subi	r22, 0xFF	; 255
    2c9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9e:	80 85       	ldd	r24, Z+8	; 0x08
    2ca0:	91 85       	ldd	r25, Z+9	; 0x09
    2ca2:	0e 94 47 0c 	call	0x188e	; 0x188e <xQueueGenericSend>
    2ca6:	91 e0       	ldi	r25, 0x01	; 1
    2ca8:	81 11       	cpse	r24, r1
    2caa:	01 c0       	rjmp	.+2      	; 0x2cae <_ZN14frt_text_queue7putcharEc+0x30>
    2cac:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2cae:	89 2f       	mov	r24, r25
    2cb0:	0f 90       	pop	r0
    2cb2:	df 91       	pop	r29
    2cb4:	cf 91       	pop	r28
    2cb6:	0f 91       	pop	r16
    2cb8:	08 95       	ret

00002cba <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2cba:	8f 92       	push	r8
    2cbc:	9f 92       	push	r9
    2cbe:	bf 92       	push	r11
    2cc0:	cf 92       	push	r12
    2cc2:	df 92       	push	r13
    2cc4:	ef 92       	push	r14
    2cc6:	ff 92       	push	r15
    2cc8:	0f 93       	push	r16
    2cca:	1f 93       	push	r17
    2ccc:	cf 93       	push	r28
    2cce:	df 93       	push	r29
    2cd0:	ec 01       	movw	r28, r24
    2cd2:	b6 2e       	mov	r11, r22
    2cd4:	4a 01       	movw	r8, r20
    2cd6:	68 01       	movw	r12, r16
    2cd8:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2cda:	0e 94 97 18 	call	0x312e	; 0x312e <_ZN8emstreamC1Ev>
    2cde:	8f e3       	ldi	r24, 0x3F	; 63
    2ce0:	90 e2       	ldi	r25, 0x20	; 32
    2ce2:	88 83       	st	Y, r24
    2ce4:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2ce6:	8e 86       	std	Y+14, r8	; 0x0e
    2ce8:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2cea:	40 e0       	ldi	r20, 0x00	; 0
    2cec:	61 e0       	ldi	r22, 0x01	; 1
    2cee:	8b 2d       	mov	r24, r11
    2cf0:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    2cf4:	88 87       	std	Y+8, r24	; 0x08
    2cf6:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2cf8:	ca 86       	std	Y+10, r12	; 0x0a
    2cfa:	db 86       	std	Y+11, r13	; 0x0b
    2cfc:	ec 86       	std	Y+12, r14	; 0x0c
    2cfe:	fd 86       	std	Y+13, r15	; 0x0d
}
    2d00:	df 91       	pop	r29
    2d02:	cf 91       	pop	r28
    2d04:	1f 91       	pop	r17
    2d06:	0f 91       	pop	r16
    2d08:	ff 90       	pop	r15
    2d0a:	ef 90       	pop	r14
    2d0c:	df 90       	pop	r13
    2d0e:	cf 90       	pop	r12
    2d10:	bf 90       	pop	r11
    2d12:	9f 90       	pop	r9
    2d14:	8f 90       	pop	r8
    2d16:	08 95       	ret

00002d18 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2d18:	cf 92       	push	r12
    2d1a:	df 92       	push	r13
    2d1c:	ef 92       	push	r14
    2d1e:	ff 92       	push	r15
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2d26:	68 81       	ld	r22, Y
    2d28:	79 81       	ldd	r23, Y+1	; 0x01
    2d2a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d2c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d2e:	0f 2e       	mov	r0, r31
    2d30:	f8 ee       	ldi	r31, 0xE8	; 232
    2d32:	cf 2e       	mov	r12, r31
    2d34:	f3 e0       	ldi	r31, 0x03	; 3
    2d36:	df 2e       	mov	r13, r31
    2d38:	e1 2c       	mov	r14, r1
    2d3a:	f1 2c       	mov	r15, r1
    2d3c:	f0 2d       	mov	r31, r0
    2d3e:	a7 01       	movw	r20, r14
    2d40:	96 01       	movw	r18, r12
    2d42:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
    2d46:	9b 01       	movw	r18, r22
    2d48:	ac 01       	movw	r20, r24
    2d4a:	60 e4       	ldi	r22, 0x40	; 64
    2d4c:	72 e4       	ldi	r23, 0x42	; 66
    2d4e:	8f e0       	ldi	r24, 0x0F	; 15
    2d50:	90 e0       	ldi	r25, 0x00	; 0
    2d52:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <__mulsi3>
    2d56:	a7 01       	movw	r20, r14
    2d58:	96 01       	movw	r18, r12
    2d5a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
    2d5e:	69 01       	movw	r12, r18
    2d60:	7a 01       	movw	r14, r20
    2d62:	ac 81       	ldd	r26, Y+4	; 0x04
    2d64:	bd 81       	ldd	r27, Y+5	; 0x05
    2d66:	20 e4       	ldi	r18, 0x40	; 64
    2d68:	32 e4       	ldi	r19, 0x42	; 66
    2d6a:	4f e0       	ldi	r20, 0x0F	; 15
    2d6c:	50 e0       	ldi	r21, 0x00	; 0
    2d6e:	0e 94 49 20 	call	0x4092	; 0x4092 <__muluhisi3>
    2d72:	20 e0       	ldi	r18, 0x00	; 0
    2d74:	38 e4       	ldi	r19, 0x48	; 72
    2d76:	48 ee       	ldi	r20, 0xE8	; 232
    2d78:	51 e0       	ldi	r21, 0x01	; 1
    2d7a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
    2d7e:	c7 01       	movw	r24, r14
    2d80:	b6 01       	movw	r22, r12
    2d82:	62 0f       	add	r22, r18
    2d84:	73 1f       	adc	r23, r19
    2d86:	84 1f       	adc	r24, r20
    2d88:	95 1f       	adc	r25, r21
}
    2d8a:	df 91       	pop	r29
    2d8c:	cf 91       	pop	r28
    2d8e:	ff 90       	pop	r15
    2d90:	ef 90       	pop	r14
    2d92:	df 90       	pop	r13
    2d94:	cf 90       	pop	r12
    2d96:	08 95       	ret

00002d98 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2d98:	cf 92       	push	r12
    2d9a:	df 92       	push	r13
    2d9c:	ef 92       	push	r14
    2d9e:	ff 92       	push	r15
    2da0:	0f 93       	push	r16
    2da2:	1f 93       	push	r17
    2da4:	cf 93       	push	r28
    2da6:	df 93       	push	r29
    2da8:	cd b7       	in	r28, 0x3d	; 61
    2daa:	de b7       	in	r29, 0x3e	; 62
    2dac:	2f 97       	sbiw	r28, 0x0f	; 15
    2dae:	cd bf       	out	0x3d, r28	; 61
    2db0:	de bf       	out	0x3e, r29	; 62
    2db2:	6c 01       	movw	r12, r24
    2db4:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2db6:	db 01       	movw	r26, r22
    2db8:	6d 91       	ld	r22, X+
    2dba:	7d 91       	ld	r23, X+
    2dbc:	8d 91       	ld	r24, X+
    2dbe:	9c 91       	ld	r25, X
    2dc0:	28 ee       	ldi	r18, 0xE8	; 232
    2dc2:	33 e0       	ldi	r19, 0x03	; 3
    2dc4:	40 e0       	ldi	r20, 0x00	; 0
    2dc6:	50 e0       	ldi	r21, 0x00	; 0
    2dc8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
    2dcc:	ba 01       	movw	r22, r20
    2dce:	a9 01       	movw	r20, r18
    2dd0:	c6 01       	movw	r24, r12
    2dd2:	0e 94 57 19 	call	0x32ae	; 0x32ae <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2dd6:	d6 01       	movw	r26, r12
    2dd8:	ed 91       	ld	r30, X+
    2dda:	fc 91       	ld	r31, X
    2ddc:	02 80       	ldd	r0, Z+2	; 0x02
    2dde:	f3 81       	ldd	r31, Z+3	; 0x03
    2de0:	e0 2d       	mov	r30, r0
    2de2:	6e e2       	ldi	r22, 0x2E	; 46
    2de4:	c6 01       	movw	r24, r12
    2de6:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2de8:	c8 01       	movw	r24, r16
    2dea:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <_ZN10time_stamp12get_microsecEv>
    2dee:	8e 01       	movw	r16, r28
    2df0:	09 5f       	subi	r16, 0xF9	; 249
    2df2:	1f 4f       	sbci	r17, 0xFF	; 255
    2df4:	fe 01       	movw	r30, r28
    2df6:	31 96       	adiw	r30, 0x01	; 1
    2df8:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2dfa:	2a e0       	ldi	r18, 0x0A	; 10
    2dfc:	30 e0       	ldi	r19, 0x00	; 0
    2dfe:	40 e0       	ldi	r20, 0x00	; 0
    2e00:	50 e0       	ldi	r21, 0x00	; 0
    2e02:	0e 94 21 20 	call	0x4042	; 0x4042 <__divmodsi4>
    2e06:	e6 2f       	mov	r30, r22
    2e08:	28 87       	std	Y+8, r18	; 0x08
    2e0a:	39 87       	std	Y+9, r19	; 0x09
    2e0c:	4a 87       	std	Y+10, r20	; 0x0a
    2e0e:	5b 87       	std	Y+11, r21	; 0x0b
    2e10:	68 85       	ldd	r22, Y+8	; 0x08
    2e12:	79 85       	ldd	r23, Y+9	; 0x09
    2e14:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e16:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2e18:	20 e3       	ldi	r18, 0x30	; 48
    2e1a:	2e 0f       	add	r18, r30
    2e1c:	d8 01       	movw	r26, r16
    2e1e:	2e 93       	st	-X, r18
    2e20:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2e22:	ae 15       	cp	r26, r14
    2e24:	bf 05       	cpc	r27, r15
    2e26:	49 f7       	brne	.-46     	; 0x2dfa <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2e28:	1f 82       	std	Y+7, r1	; 0x07
    2e2a:	be 01       	movw	r22, r28
    2e2c:	6f 5f       	subi	r22, 0xFF	; 255
    2e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e30:	c6 01       	movw	r24, r12
    2e32:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2e36:	c6 01       	movw	r24, r12
    2e38:	2f 96       	adiw	r28, 0x0f	; 15
    2e3a:	cd bf       	out	0x3d, r28	; 61
    2e3c:	de bf       	out	0x3e, r29	; 62
    2e3e:	df 91       	pop	r29
    2e40:	cf 91       	pop	r28
    2e42:	1f 91       	pop	r17
    2e44:	0f 91       	pop	r16
    2e46:	ff 90       	pop	r15
    2e48:	ef 90       	pop	r14
    2e4a:	df 90       	pop	r13
    2e4c:	cf 90       	pop	r12
    2e4e:	08 95       	ret

00002e50 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2e50:	cf 93       	push	r28
    2e52:	df 93       	push	r29
    2e54:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2e56:	0f b6       	in	r0, 0x3f	; 63
    2e58:	f8 94       	cli
    2e5a:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2e5c:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2e60:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2e64:	8c 83       	std	Y+4, r24	; 0x04
    2e66:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2e68:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <xTaskGetTickCount>
    2e6c:	68 83       	st	Y, r22
    2e6e:	79 83       	std	Y+1, r23	; 0x01
    2e70:	8a 83       	std	Y+2, r24	; 0x02
    2e72:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2e74:	0f 90       	pop	r0
    2e76:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2e78:	ce 01       	movw	r24, r28
    2e7a:	df 91       	pop	r29
    2e7c:	cf 91       	pop	r28
    2e7e:	08 95       	ret

00002e80 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2e80:	5f 92       	push	r5
    2e82:	6f 92       	push	r6
    2e84:	7f 92       	push	r7
    2e86:	8f 92       	push	r8
    2e88:	9f 92       	push	r9
    2e8a:	af 92       	push	r10
    2e8c:	bf 92       	push	r11
    2e8e:	cf 92       	push	r12
    2e90:	df 92       	push	r13
    2e92:	ef 92       	push	r14
    2e94:	ff 92       	push	r15
    2e96:	0f 93       	push	r16
    2e98:	1f 93       	push	r17
    2e9a:	cf 93       	push	r28
    2e9c:	df 93       	push	r29
    2e9e:	5c 01       	movw	r10, r24
    2ea0:	4b 01       	movw	r8, r22
    2ea2:	7a 01       	movw	r14, r20
    2ea4:	12 2f       	mov	r17, r18
    2ea6:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2ea8:	63 e0       	ldi	r22, 0x03	; 3
    2eaa:	ca 01       	movw	r24, r20
    2eac:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2eb0:	a8 14       	cp	r10, r8
    2eb2:	b9 04       	cpc	r11, r9
    2eb4:	08 f0       	brcs	.+2      	; 0x2eb8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2eb6:	7d c0       	rjmp	.+250    	; 0x2fb2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2eb8:	65 01       	movw	r12, r10
    2eba:	84 e1       	ldi	r24, 0x14	; 20
    2ebc:	c8 0e       	add	r12, r24
    2ebe:	d1 1c       	adc	r13, r1
    2ec0:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2ec2:	6a 2c       	mov	r6, r10
    2ec4:	5b 2c       	mov	r5, r11
    2ec6:	b5 01       	movw	r22, r10
    2ec8:	c7 01       	movw	r24, r14
    2eca:	0e 94 23 19 	call	0x3246	; 0x3246 <_ZN8emstreamlsEj>
    2ece:	6a e0       	ldi	r22, 0x0A	; 10
    2ed0:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2ed4:	61 ed       	ldi	r22, 0xD1	; 209
    2ed6:	75 e0       	ldi	r23, 0x05	; 5
    2ed8:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2edc:	11 23       	and	r17, r17
    2ede:	09 f4       	brne	.+2      	; 0x2ee2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2ee0:	6d c0       	rjmp	.+218    	; 0x2fbc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2ee2:	00 23       	and	r16, r16
    2ee4:	09 f4       	brne	.+2      	; 0x2ee8 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2ee6:	6a c0       	rjmp	.+212    	; 0x2fbc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2ee8:	6a e0       	ldi	r22, 0x0A	; 10
    2eea:	c7 01       	movw	r24, r14
    2eec:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2ef0:	6c ec       	ldi	r22, 0xCC	; 204
    2ef2:	75 e0       	ldi	r23, 0x05	; 5
    2ef4:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    2ef8:	61 c0       	rjmp	.+194    	; 0x2fbc <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2efa:	11 23       	and	r17, r17
    2efc:	71 f0       	breq	.+28     	; 0x2f1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2efe:	01 11       	cpse	r16, r1
    2f00:	0c c0       	rjmp	.+24     	; 0x2f1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2f02:	88 81       	ld	r24, Y
    2f04:	87 15       	cp	r24, r7
    2f06:	49 f0       	breq	.+18     	; 0x2f1a <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2f08:	6a e0       	ldi	r22, 0x0A	; 10
    2f0a:	c7 01       	movw	r24, r14
    2f0c:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2f10:	67 ec       	ldi	r22, 0xC7	; 199
    2f12:	75 e0       	ldi	r23, 0x05	; 5
    2f14:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2f18:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2f1a:	69 91       	ld	r22, Y+
    2f1c:	c7 01       	movw	r24, r14
    2f1e:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2f22:	dc 01       	movw	r26, r24
    2f24:	ed 91       	ld	r30, X+
    2f26:	fc 91       	ld	r31, X
    2f28:	02 80       	ldd	r0, Z+2	; 0x02
    2f2a:	f3 81       	ldd	r31, Z+3	; 0x03
    2f2c:	e0 2d       	mov	r30, r0
    2f2e:	60 e2       	ldi	r22, 0x20	; 32
    2f30:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2f32:	cc 16       	cp	r12, r28
    2f34:	dd 06       	cpc	r13, r29
    2f36:	09 f7       	brne	.-62     	; 0x2efa <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2f38:	11 23       	and	r17, r17
    2f3a:	89 f0       	breq	.+34     	; 0x2f5e <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2f3c:	6a e0       	ldi	r22, 0x0A	; 10
    2f3e:	c7 01       	movw	r24, r14
    2f40:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2f44:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2f46:	61 ec       	ldi	r22, 0xC1	; 193
    2f48:	75 e0       	ldi	r23, 0x05	; 5
    2f4a:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2f4e:	e8 81       	ld	r30, Y
    2f50:	f9 81       	ldd	r31, Y+1	; 0x01
    2f52:	02 80       	ldd	r0, Z+2	; 0x02
    2f54:	f3 81       	ldd	r31, Z+3	; 0x03
    2f56:	e0 2d       	mov	r30, r0
    2f58:	60 e2       	ldi	r22, 0x20	; 32
    2f5a:	ce 01       	movw	r24, r28
    2f5c:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2f5e:	c6 2d       	mov	r28, r6
    2f60:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2f62:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2f64:	80 ee       	ldi	r24, 0xE0	; 224
    2f66:	86 0f       	add	r24, r22
    2f68:	8f 35       	cpi	r24, 0x5F	; 95
    2f6a:	48 f4       	brcc	.+18     	; 0x2f7e <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2f6c:	d7 01       	movw	r26, r14
    2f6e:	ed 91       	ld	r30, X+
    2f70:	fc 91       	ld	r31, X
    2f72:	02 80       	ldd	r0, Z+2	; 0x02
    2f74:	f3 81       	ldd	r31, Z+3	; 0x03
    2f76:	e0 2d       	mov	r30, r0
    2f78:	c7 01       	movw	r24, r14
    2f7a:	19 95       	eicall
    2f7c:	09 c0       	rjmp	.+18     	; 0x2f90 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2f7e:	d7 01       	movw	r26, r14
    2f80:	ed 91       	ld	r30, X+
    2f82:	fc 91       	ld	r31, X
    2f84:	02 80       	ldd	r0, Z+2	; 0x02
    2f86:	f3 81       	ldd	r31, Z+3	; 0x03
    2f88:	e0 2d       	mov	r30, r0
    2f8a:	6e e2       	ldi	r22, 0x2E	; 46
    2f8c:	c7 01       	movw	r24, r14
    2f8e:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2f90:	cc 16       	cp	r12, r28
    2f92:	dd 06       	cpc	r13, r29
    2f94:	31 f7       	brne	.-52     	; 0x2f62 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2f96:	b4 e1       	ldi	r27, 0x14	; 20
    2f98:	ab 0e       	add	r10, r27
    2f9a:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2f9c:	66 e0       	ldi	r22, 0x06	; 6
    2f9e:	c7 01       	movw	r24, r14
    2fa0:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    2fa4:	84 e1       	ldi	r24, 0x14	; 20
    2fa6:	c8 0e       	add	r12, r24
    2fa8:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2faa:	a8 14       	cp	r10, r8
    2fac:	b9 04       	cpc	r11, r9
    2fae:	08 f4       	brcc	.+2      	; 0x2fb2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2fb0:	88 cf       	rjmp	.-240    	; 0x2ec2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2fb2:	62 e0       	ldi	r22, 0x02	; 2
    2fb4:	c7 01       	movw	r24, r14
    2fb6:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
}
    2fba:	03 c0       	rjmp	.+6      	; 0x2fc2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2fbc:	c6 2d       	mov	r28, r6
    2fbe:	d5 2d       	mov	r29, r5
    2fc0:	9c cf       	rjmp	.-200    	; 0x2efa <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2fc2:	df 91       	pop	r29
    2fc4:	cf 91       	pop	r28
    2fc6:	1f 91       	pop	r17
    2fc8:	0f 91       	pop	r16
    2fca:	ff 90       	pop	r15
    2fcc:	ef 90       	pop	r14
    2fce:	df 90       	pop	r13
    2fd0:	cf 90       	pop	r12
    2fd2:	bf 90       	pop	r11
    2fd4:	af 90       	pop	r10
    2fd6:	9f 90       	pop	r9
    2fd8:	8f 90       	pop	r8
    2fda:	7f 90       	pop	r7
    2fdc:	6f 90       	pop	r6
    2fde:	5f 90       	pop	r5
    2fe0:	08 95       	ret

00002fe2 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2fe2:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    2fe6:	08 95       	ret

00002fe8 <_Znaj>:
    2fe8:	0e 94 33 08 	call	0x1066	; 0x1066 <pvPortMalloc>
    2fec:	08 95       	ret

00002fee <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2fee:	08 95       	ret

00002ff0 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2ff0:	cf 93       	push	r28
    2ff2:	df 93       	push	r29
    2ff4:	fc 01       	movw	r30, r24
    2ff6:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2ff8:	40 3a       	cpi	r20, 0xA0	; 160
    2ffa:	68 e0       	ldi	r22, 0x08	; 8
    2ffc:	56 07       	cpc	r21, r22
    2ffe:	49 f4       	brne	.+18     	; 0x3012 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3000:	80 e4       	ldi	r24, 0x40	; 64
    3002:	96 e0       	ldi	r25, 0x06	; 6
    3004:	82 83       	std	Z+2, r24	; 0x02
    3006:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3008:	82 e0       	ldi	r24, 0x02	; 2
    300a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    300c:	83 e0       	ldi	r24, 0x03	; 3
    300e:	85 83       	std	Z+5, r24	; 0x05
    3010:	32 c0       	rjmp	.+100    	; 0x3076 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3012:	40 3b       	cpi	r20, 0xB0	; 176
    3014:	78 e0       	ldi	r23, 0x08	; 8
    3016:	57 07       	cpc	r21, r23
    3018:	49 f4       	brne	.+18     	; 0x302c <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    301a:	80 e4       	ldi	r24, 0x40	; 64
    301c:	96 e0       	ldi	r25, 0x06	; 6
    301e:	82 83       	std	Z+2, r24	; 0x02
    3020:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3022:	86 e0       	ldi	r24, 0x06	; 6
    3024:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3026:	87 e0       	ldi	r24, 0x07	; 7
    3028:	85 83       	std	Z+5, r24	; 0x05
    302a:	25 c0       	rjmp	.+74     	; 0x3076 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    302c:	40 3a       	cpi	r20, 0xA0	; 160
    302e:	89 e0       	ldi	r24, 0x09	; 9
    3030:	58 07       	cpc	r21, r24
    3032:	49 f4       	brne	.+18     	; 0x3046 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3034:	80 e6       	ldi	r24, 0x60	; 96
    3036:	96 e0       	ldi	r25, 0x06	; 6
    3038:	82 83       	std	Z+2, r24	; 0x02
    303a:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    303c:	82 e0       	ldi	r24, 0x02	; 2
    303e:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3040:	83 e0       	ldi	r24, 0x03	; 3
    3042:	85 83       	std	Z+5, r24	; 0x05
    3044:	18 c0       	rjmp	.+48     	; 0x3076 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3046:	40 3b       	cpi	r20, 0xB0	; 176
    3048:	69 e0       	ldi	r22, 0x09	; 9
    304a:	56 07       	cpc	r21, r22
    304c:	49 f4       	brne	.+18     	; 0x3060 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    304e:	80 e6       	ldi	r24, 0x60	; 96
    3050:	96 e0       	ldi	r25, 0x06	; 6
    3052:	82 83       	std	Z+2, r24	; 0x02
    3054:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3056:	86 e0       	ldi	r24, 0x06	; 6
    3058:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    305a:	87 e0       	ldi	r24, 0x07	; 7
    305c:	85 83       	std	Z+5, r24	; 0x05
    305e:	0b c0       	rjmp	.+22     	; 0x3076 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3060:	40 3a       	cpi	r20, 0xA0	; 160
    3062:	5a 40       	sbci	r21, 0x0A	; 10
    3064:	41 f4       	brne	.+16     	; 0x3076 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3066:	80 e8       	ldi	r24, 0x80	; 128
    3068:	96 e0       	ldi	r25, 0x06	; 6
    306a:	82 83       	std	Z+2, r24	; 0x02
    306c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    306e:	82 e0       	ldi	r24, 0x02	; 2
    3070:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3072:	83 e0       	ldi	r24, 0x03	; 3
    3074:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3076:	a6 83       	std	Z+6, r26	; 0x06
    3078:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    307a:	cd 01       	movw	r24, r26
    307c:	01 96       	adiw	r24, 0x01	; 1
    307e:	80 87       	std	Z+8, r24	; 0x08
    3080:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    3082:	03 96       	adiw	r24, 0x03	; 3
    3084:	82 87       	std	Z+10, r24	; 0x0a
    3086:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3088:	25 81       	ldd	r18, Z+5	; 0x05
    308a:	c2 81       	ldd	r28, Z+2	; 0x02
    308c:	d3 81       	ldd	r29, Z+3	; 0x03
    308e:	4c 81       	ldd	r20, Y+4	; 0x04
    3090:	81 e0       	ldi	r24, 0x01	; 1
    3092:	90 e0       	ldi	r25, 0x00	; 0
    3094:	bc 01       	movw	r22, r24
    3096:	02 c0       	rjmp	.+4      	; 0x309c <_ZN7base232C1EjP12USART_struct+0xac>
    3098:	66 0f       	add	r22, r22
    309a:	77 1f       	adc	r23, r23
    309c:	2a 95       	dec	r18
    309e:	e2 f7       	brpl	.-8      	; 0x3098 <_ZN7base232C1EjP12USART_struct+0xa8>
    30a0:	9b 01       	movw	r18, r22
    30a2:	24 2b       	or	r18, r20
    30a4:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    30a6:	25 81       	ldd	r18, Z+5	; 0x05
    30a8:	c2 81       	ldd	r28, Z+2	; 0x02
    30aa:	d3 81       	ldd	r29, Z+3	; 0x03
    30ac:	48 81       	ld	r20, Y
    30ae:	bc 01       	movw	r22, r24
    30b0:	02 c0       	rjmp	.+4      	; 0x30b6 <_ZN7base232C1EjP12USART_struct+0xc6>
    30b2:	66 0f       	add	r22, r22
    30b4:	77 1f       	adc	r23, r23
    30b6:	2a 95       	dec	r18
    30b8:	e2 f7       	brpl	.-8      	; 0x30b2 <_ZN7base232C1EjP12USART_struct+0xc2>
    30ba:	9b 01       	movw	r18, r22
    30bc:	24 2b       	or	r18, r20
    30be:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    30c0:	34 81       	ldd	r19, Z+4	; 0x04
    30c2:	c2 81       	ldd	r28, Z+2	; 0x02
    30c4:	d3 81       	ldd	r29, Z+3	; 0x03
    30c6:	28 81       	ld	r18, Y
    30c8:	02 c0       	rjmp	.+4      	; 0x30ce <_ZN7base232C1EjP12USART_struct+0xde>
    30ca:	88 0f       	add	r24, r24
    30cc:	99 1f       	adc	r25, r25
    30ce:	3a 95       	dec	r19
    30d0:	e2 f7       	brpl	.-8      	; 0x30ca <_ZN7base232C1EjP12USART_struct+0xda>
    30d2:	80 95       	com	r24
    30d4:	90 95       	com	r25
    30d6:	82 23       	and	r24, r18
    30d8:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    30da:	80 e1       	ldi	r24, 0x10	; 16
    30dc:	13 96       	adiw	r26, 0x03	; 3
    30de:	8c 93       	st	X, r24
    30e0:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    30e2:	83 e0       	ldi	r24, 0x03	; 3
    30e4:	15 96       	adiw	r26, 0x05	; 5
    30e6:	8c 93       	st	X, r24
    30e8:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    30ea:	80 ef       	ldi	r24, 0xF0	; 240
    30ec:	17 96       	adiw	r26, 0x07	; 7
    30ee:	8c 93       	st	X, r24
    30f0:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    30f2:	81 e2       	ldi	r24, 0x21	; 33
    30f4:	16 96       	adiw	r26, 0x06	; 6
    30f6:	8c 93       	st	X, r24
    30f8:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    30fa:	88 e1       	ldi	r24, 0x18	; 24
    30fc:	14 96       	adiw	r26, 0x04	; 4
    30fe:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3100:	80 e8       	ldi	r24, 0x80	; 128
    3102:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3104:	80 e4       	ldi	r24, 0x40	; 64
    3106:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    3108:	80 e2       	ldi	r24, 0x20	; 32
    310a:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    310c:	06 80       	ldd	r0, Z+6	; 0x06
    310e:	f7 81       	ldd	r31, Z+7	; 0x07
    3110:	e0 2d       	mov	r30, r0
    3112:	80 81       	ld	r24, Z
    3114:	80 81       	ld	r24, Z
}
    3116:	df 91       	pop	r29
    3118:	cf 91       	pop	r28
    311a:	08 95       	ret

0000311c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    311c:	81 e0       	ldi	r24, 0x01	; 1
    311e:	08 95       	ret

00003120 <_ZN8emstream7getcharEv>:
    3120:	80 e0       	ldi	r24, 0x00	; 0
    3122:	90 e0       	ldi	r25, 0x00	; 0
    3124:	08 95       	ret

00003126 <_ZN8emstream14check_for_charEv>:
    3126:	80 e0       	ldi	r24, 0x00	; 0
    3128:	08 95       	ret

0000312a <_ZN8emstream12transmit_nowEv>:
    312a:	08 95       	ret

0000312c <_ZN8emstream12clear_screenEv>:
    312c:	08 95       	ret

0000312e <_ZN8emstreamC1Ev>:
    312e:	fc 01       	movw	r30, r24
    3130:	8f e4       	ldi	r24, 0x4F	; 79
    3132:	90 e2       	ldi	r25, 0x20	; 32
    3134:	80 83       	st	Z, r24
    3136:	91 83       	std	Z+1, r25	; 0x01
    3138:	8a e0       	ldi	r24, 0x0A	; 10
    313a:	82 83       	std	Z+2, r24	; 0x02
    313c:	13 82       	std	Z+3, r1	; 0x03
    313e:	83 e0       	ldi	r24, 0x03	; 3
    3140:	85 83       	std	Z+5, r24	; 0x05
    3142:	14 82       	std	Z+4, r1	; 0x04
    3144:	16 82       	std	Z+6, r1	; 0x06
    3146:	17 82       	std	Z+7, r1	; 0x07
    3148:	08 95       	ret

0000314a <_ZN8emstream4putsEPKc>:
    314a:	0f 93       	push	r16
    314c:	1f 93       	push	r17
    314e:	cf 93       	push	r28
    3150:	df 93       	push	r29
    3152:	8c 01       	movw	r16, r24
    3154:	fb 01       	movw	r30, r22
    3156:	dc 01       	movw	r26, r24
    3158:	14 96       	adiw	r26, 0x04	; 4
    315a:	8c 91       	ld	r24, X
    315c:	81 11       	cpse	r24, r1
    315e:	04 c0       	rjmp	.+8      	; 0x3168 <_ZN8emstream4putsEPKc+0x1e>
    3160:	60 81       	ld	r22, Z
    3162:	61 11       	cpse	r22, r1
    3164:	17 c0       	rjmp	.+46     	; 0x3194 <_ZN8emstream4putsEPKc+0x4a>
    3166:	23 c0       	rjmp	.+70     	; 0x31ae <_ZN8emstream4putsEPKc+0x64>
    3168:	d8 01       	movw	r26, r16
    316a:	14 96       	adiw	r26, 0x04	; 4
    316c:	1c 92       	st	X, r1
    316e:	eb 01       	movw	r28, r22
    3170:	21 96       	adiw	r28, 0x01	; 1
    3172:	64 91       	lpm	r22, Z
    3174:	66 23       	and	r22, r22
    3176:	d9 f0       	breq	.+54     	; 0x31ae <_ZN8emstream4putsEPKc+0x64>
    3178:	d8 01       	movw	r26, r16
    317a:	ed 91       	ld	r30, X+
    317c:	fc 91       	ld	r31, X
    317e:	02 80       	ldd	r0, Z+2	; 0x02
    3180:	f3 81       	ldd	r31, Z+3	; 0x03
    3182:	e0 2d       	mov	r30, r0
    3184:	c8 01       	movw	r24, r16
    3186:	19 95       	eicall
    3188:	fe 01       	movw	r30, r28
    318a:	64 91       	lpm	r22, Z
    318c:	21 96       	adiw	r28, 0x01	; 1
    318e:	61 11       	cpse	r22, r1
    3190:	f3 cf       	rjmp	.-26     	; 0x3178 <_ZN8emstream4putsEPKc+0x2e>
    3192:	0d c0       	rjmp	.+26     	; 0x31ae <_ZN8emstream4putsEPKc+0x64>
    3194:	ef 01       	movw	r28, r30
    3196:	21 96       	adiw	r28, 0x01	; 1
    3198:	d8 01       	movw	r26, r16
    319a:	ed 91       	ld	r30, X+
    319c:	fc 91       	ld	r31, X
    319e:	02 80       	ldd	r0, Z+2	; 0x02
    31a0:	f3 81       	ldd	r31, Z+3	; 0x03
    31a2:	e0 2d       	mov	r30, r0
    31a4:	c8 01       	movw	r24, r16
    31a6:	19 95       	eicall
    31a8:	69 91       	ld	r22, Y+
    31aa:	61 11       	cpse	r22, r1
    31ac:	f5 cf       	rjmp	.-22     	; 0x3198 <_ZN8emstream4putsEPKc+0x4e>
    31ae:	df 91       	pop	r29
    31b0:	cf 91       	pop	r28
    31b2:	1f 91       	pop	r17
    31b4:	0f 91       	pop	r16
    31b6:	08 95       	ret

000031b8 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    31b8:	cf 93       	push	r28
    31ba:	df 93       	push	r29
    31bc:	ec 01       	movw	r28, r24
	switch (new_manip)
    31be:	86 2f       	mov	r24, r22
    31c0:	90 e0       	ldi	r25, 0x00	; 0
    31c2:	8b 30       	cpi	r24, 0x0B	; 11
    31c4:	91 05       	cpc	r25, r1
    31c6:	d8 f5       	brcc	.+118    	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
    31c8:	fc 01       	movw	r30, r24
    31ca:	88 27       	eor	r24, r24
    31cc:	e2 50       	subi	r30, 0x02	; 2
    31ce:	ff 4f       	sbci	r31, 0xFF	; 255
    31d0:	8f 4f       	sbci	r24, 0xFF	; 255
    31d2:	0c 94 40 20 	jmp	0x4080	; 0x4080 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    31d6:	82 e0       	ldi	r24, 0x02	; 2
    31d8:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31da:	31 c0       	rjmp	.+98     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    31dc:	88 e0       	ldi	r24, 0x08	; 8
    31de:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31e0:	2e c0       	rjmp	.+92     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    31e2:	8a e0       	ldi	r24, 0x0A	; 10
    31e4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31e6:	2b c0       	rjmp	.+86     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    31e8:	80 e1       	ldi	r24, 0x10	; 16
    31ea:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31ec:	28 c0       	rjmp	.+80     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    31ee:	81 e0       	ldi	r24, 0x01	; 1
    31f0:	8b 83       	std	Y+3, r24	; 0x03
			break;
    31f2:	25 c0       	rjmp	.+74     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    31f4:	1b 82       	std	Y+3, r1	; 0x03
			break;
    31f6:	23 c0       	rjmp	.+70     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    31f8:	e8 81       	ld	r30, Y
    31fa:	f9 81       	ldd	r31, Y+1	; 0x01
    31fc:	02 80       	ldd	r0, Z+2	; 0x02
    31fe:	f3 81       	ldd	r31, Z+3	; 0x03
    3200:	e0 2d       	mov	r30, r0
    3202:	6d e0       	ldi	r22, 0x0D	; 13
    3204:	ce 01       	movw	r24, r28
    3206:	19 95       	eicall
    3208:	e8 81       	ld	r30, Y
    320a:	f9 81       	ldd	r31, Y+1	; 0x01
    320c:	02 80       	ldd	r0, Z+2	; 0x02
    320e:	f3 81       	ldd	r31, Z+3	; 0x03
    3210:	e0 2d       	mov	r30, r0
    3212:	6a e0       	ldi	r22, 0x0A	; 10
    3214:	ce 01       	movw	r24, r28
    3216:	19 95       	eicall
			break;
    3218:	12 c0       	rjmp	.+36     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    321a:	e8 81       	ld	r30, Y
    321c:	f9 81       	ldd	r31, Y+1	; 0x01
    321e:	02 84       	ldd	r0, Z+10	; 0x0a
    3220:	f3 85       	ldd	r31, Z+11	; 0x0b
    3222:	e0 2d       	mov	r30, r0
    3224:	ce 01       	movw	r24, r28
    3226:	19 95       	eicall
			break;
    3228:	0a c0       	rjmp	.+20     	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    322a:	e8 81       	ld	r30, Y
    322c:	f9 81       	ldd	r31, Y+1	; 0x01
    322e:	00 84       	ldd	r0, Z+8	; 0x08
    3230:	f1 85       	ldd	r31, Z+9	; 0x09
    3232:	e0 2d       	mov	r30, r0
    3234:	ce 01       	movw	r24, r28
    3236:	19 95       	eicall
			break;
    3238:	02 c0       	rjmp	.+4      	; 0x323e <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    323a:	81 e0       	ldi	r24, 0x01	; 1
    323c:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    323e:	ce 01       	movw	r24, r28
    3240:	df 91       	pop	r29
    3242:	cf 91       	pop	r28
    3244:	08 95       	ret

00003246 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3246:	ff 92       	push	r15
    3248:	0f 93       	push	r16
    324a:	1f 93       	push	r17
    324c:	cf 93       	push	r28
    324e:	df 93       	push	r29
    3250:	cd b7       	in	r28, 0x3d	; 61
    3252:	de b7       	in	r29, 0x3e	; 62
    3254:	61 97       	sbiw	r28, 0x11	; 17
    3256:	cd bf       	out	0x3d, r28	; 61
    3258:	de bf       	out	0x3e, r29	; 62
    325a:	8c 01       	movw	r16, r24
    325c:	f6 2e       	mov	r15, r22
    325e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3260:	f8 01       	movw	r30, r16
    3262:	42 81       	ldd	r20, Z+2	; 0x02
    3264:	40 31       	cpi	r20, 0x10	; 16
    3266:	21 f0       	breq	.+8      	; 0x3270 <_ZN8emstreamlsEj+0x2a>
    3268:	48 30       	cpi	r20, 0x08	; 8
    326a:	11 f0       	breq	.+4      	; 0x3270 <_ZN8emstreamlsEj+0x2a>
    326c:	42 30       	cpi	r20, 0x02	; 2
    326e:	41 f4       	brne	.+16     	; 0x3280 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3270:	69 2f       	mov	r22, r25
    3272:	c8 01       	movw	r24, r16
    3274:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    3278:	6f 2d       	mov	r22, r15
    327a:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    327e:	0d c0       	rjmp	.+26     	; 0x329a <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3280:	50 e0       	ldi	r21, 0x00	; 0
    3282:	be 01       	movw	r22, r28
    3284:	6f 5f       	subi	r22, 0xFF	; 255
    3286:	7f 4f       	sbci	r23, 0xFF	; 255
    3288:	8f 2d       	mov	r24, r15
    328a:	0e 94 af 20 	call	0x415e	; 0x415e <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    328e:	be 01       	movw	r22, r28
    3290:	6f 5f       	subi	r22, 0xFF	; 255
    3292:	7f 4f       	sbci	r23, 0xFF	; 255
    3294:	c8 01       	movw	r24, r16
    3296:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    329a:	c8 01       	movw	r24, r16
    329c:	61 96       	adiw	r28, 0x11	; 17
    329e:	cd bf       	out	0x3d, r28	; 61
    32a0:	de bf       	out	0x3e, r29	; 62
    32a2:	df 91       	pop	r29
    32a4:	cf 91       	pop	r28
    32a6:	1f 91       	pop	r17
    32a8:	0f 91       	pop	r16
    32aa:	ff 90       	pop	r15
    32ac:	08 95       	ret

000032ae <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    32ae:	df 92       	push	r13
    32b0:	ef 92       	push	r14
    32b2:	ff 92       	push	r15
    32b4:	0f 93       	push	r16
    32b6:	1f 93       	push	r17
    32b8:	cf 93       	push	r28
    32ba:	df 93       	push	r29
    32bc:	cd b7       	in	r28, 0x3d	; 61
    32be:	de b7       	in	r29, 0x3e	; 62
    32c0:	a1 97       	sbiw	r28, 0x21	; 33
    32c2:	cd bf       	out	0x3d, r28	; 61
    32c4:	de bf       	out	0x3e, r29	; 62
    32c6:	8c 01       	movw	r16, r24
    32c8:	d4 2e       	mov	r13, r20
    32ca:	e5 2e       	mov	r14, r21
    32cc:	f6 2e       	mov	r15, r22
    32ce:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    32d0:	f8 01       	movw	r30, r16
    32d2:	22 81       	ldd	r18, Z+2	; 0x02
    32d4:	20 31       	cpi	r18, 0x10	; 16
    32d6:	21 f0       	breq	.+8      	; 0x32e0 <_ZN8emstreamlsEm+0x32>
    32d8:	28 30       	cpi	r18, 0x08	; 8
    32da:	11 f0       	breq	.+4      	; 0x32e0 <_ZN8emstreamlsEm+0x32>
    32dc:	22 30       	cpi	r18, 0x02	; 2
    32de:	71 f4       	brne	.+28     	; 0x32fc <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    32e0:	69 2f       	mov	r22, r25
    32e2:	c8 01       	movw	r24, r16
    32e4:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    32e8:	6f 2d       	mov	r22, r15
    32ea:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    32ee:	6e 2d       	mov	r22, r14
    32f0:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    32f4:	6d 2d       	mov	r22, r13
    32f6:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN8emstreamlsEh>
    32fa:	0f c0       	rjmp	.+30     	; 0x331a <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    32fc:	30 e0       	ldi	r19, 0x00	; 0
    32fe:	ae 01       	movw	r20, r28
    3300:	4f 5f       	subi	r20, 0xFF	; 255
    3302:	5f 4f       	sbci	r21, 0xFF	; 255
    3304:	6d 2d       	mov	r22, r13
    3306:	7e 2d       	mov	r23, r14
    3308:	8f 2d       	mov	r24, r15
    330a:	0e 94 82 20 	call	0x4104	; 0x4104 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    330e:	be 01       	movw	r22, r28
    3310:	6f 5f       	subi	r22, 0xFF	; 255
    3312:	7f 4f       	sbci	r23, 0xFF	; 255
    3314:	c8 01       	movw	r24, r16
    3316:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    331a:	c8 01       	movw	r24, r16
    331c:	a1 96       	adiw	r28, 0x21	; 33
    331e:	cd bf       	out	0x3d, r28	; 61
    3320:	de bf       	out	0x3e, r29	; 62
    3322:	df 91       	pop	r29
    3324:	cf 91       	pop	r28
    3326:	1f 91       	pop	r17
    3328:	0f 91       	pop	r16
    332a:	ff 90       	pop	r15
    332c:	ef 90       	pop	r14
    332e:	df 90       	pop	r13
    3330:	08 95       	ret

00003332 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3332:	cf 92       	push	r12
    3334:	df 92       	push	r13
    3336:	ef 92       	push	r14
    3338:	ff 92       	push	r15
    333a:	0f 93       	push	r16
    333c:	1f 93       	push	r17
    333e:	cf 93       	push	r28
    3340:	df 93       	push	r29
    3342:	cd b7       	in	r28, 0x3d	; 61
    3344:	de b7       	in	r29, 0x3e	; 62
    3346:	29 97       	sbiw	r28, 0x09	; 9
    3348:	cd bf       	out	0x3d, r28	; 61
    334a:	de bf       	out	0x3e, r29	; 62
    334c:	8c 01       	movw	r16, r24
    334e:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3350:	dc 01       	movw	r26, r24
    3352:	13 96       	adiw	r26, 0x03	; 3
    3354:	8c 91       	ld	r24, X
    3356:	13 97       	sbiw	r26, 0x03	; 3
    3358:	88 23       	and	r24, r24
    335a:	41 f0       	breq	.+16     	; 0x336c <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    335c:	ed 91       	ld	r30, X+
    335e:	fc 91       	ld	r31, X
    3360:	02 80       	ldd	r0, Z+2	; 0x02
    3362:	f3 81       	ldd	r31, Z+3	; 0x03
    3364:	e0 2d       	mov	r30, r0
    3366:	c8 01       	movw	r24, r16
    3368:	19 95       	eicall
    336a:	56 c0       	rjmp	.+172    	; 0x3418 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    336c:	f8 01       	movw	r30, r16
    336e:	42 81       	ldd	r20, Z+2	; 0x02
    3370:	42 30       	cpi	r20, 0x02	; 2
    3372:	19 f5       	brne	.+70     	; 0x33ba <_ZN8emstreamlsEh+0x88>
    3374:	68 94       	set
    3376:	cc 24       	eor	r12, r12
    3378:	c3 f8       	bld	r12, 3
    337a:	d1 2c       	mov	r13, r1
    337c:	68 94       	set
    337e:	ff 24       	eor	r15, r15
    3380:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3382:	8e 2d       	mov	r24, r14
    3384:	8f 21       	and	r24, r15
    3386:	51 f0       	breq	.+20     	; 0x339c <_ZN8emstreamlsEh+0x6a>
    3388:	d8 01       	movw	r26, r16
    338a:	ed 91       	ld	r30, X+
    338c:	fc 91       	ld	r31, X
    338e:	02 80       	ldd	r0, Z+2	; 0x02
    3390:	f3 81       	ldd	r31, Z+3	; 0x03
    3392:	e0 2d       	mov	r30, r0
    3394:	61 e3       	ldi	r22, 0x31	; 49
    3396:	c8 01       	movw	r24, r16
    3398:	19 95       	eicall
    339a:	09 c0       	rjmp	.+18     	; 0x33ae <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    339c:	d8 01       	movw	r26, r16
    339e:	ed 91       	ld	r30, X+
    33a0:	fc 91       	ld	r31, X
    33a2:	02 80       	ldd	r0, Z+2	; 0x02
    33a4:	f3 81       	ldd	r31, Z+3	; 0x03
    33a6:	e0 2d       	mov	r30, r0
    33a8:	60 e3       	ldi	r22, 0x30	; 48
    33aa:	c8 01       	movw	r24, r16
    33ac:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    33ae:	f6 94       	lsr	r15
    33b0:	b1 e0       	ldi	r27, 0x01	; 1
    33b2:	cb 1a       	sub	r12, r27
    33b4:	d1 08       	sbc	r13, r1
    33b6:	29 f7       	brne	.-54     	; 0x3382 <_ZN8emstreamlsEh+0x50>
    33b8:	2f c0       	rjmp	.+94     	; 0x3418 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    33ba:	40 31       	cpi	r20, 0x10	; 16
    33bc:	f9 f4       	brne	.+62     	; 0x33fc <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    33be:	62 95       	swap	r22
    33c0:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    33c2:	01 90       	ld	r0, Z+
    33c4:	f0 81       	ld	r31, Z
    33c6:	e0 2d       	mov	r30, r0
    33c8:	02 80       	ldd	r0, Z+2	; 0x02
    33ca:	f3 81       	ldd	r31, Z+3	; 0x03
    33cc:	e0 2d       	mov	r30, r0
    33ce:	6a 30       	cpi	r22, 0x0A	; 10
    33d0:	10 f0       	brcs	.+4      	; 0x33d6 <_ZN8emstreamlsEh+0xa4>
    33d2:	69 5c       	subi	r22, 0xC9	; 201
    33d4:	01 c0       	rjmp	.+2      	; 0x33d8 <_ZN8emstreamlsEh+0xa6>
    33d6:	60 5d       	subi	r22, 0xD0	; 208
    33d8:	c8 01       	movw	r24, r16
    33da:	19 95       	eicall
		temp_char = num & 0x0F;
    33dc:	6e 2d       	mov	r22, r14
    33de:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    33e0:	d8 01       	movw	r26, r16
    33e2:	ed 91       	ld	r30, X+
    33e4:	fc 91       	ld	r31, X
    33e6:	02 80       	ldd	r0, Z+2	; 0x02
    33e8:	f3 81       	ldd	r31, Z+3	; 0x03
    33ea:	e0 2d       	mov	r30, r0
    33ec:	6a 30       	cpi	r22, 0x0A	; 10
    33ee:	10 f0       	brcs	.+4      	; 0x33f4 <_ZN8emstreamlsEh+0xc2>
    33f0:	69 5c       	subi	r22, 0xC9	; 201
    33f2:	01 c0       	rjmp	.+2      	; 0x33f6 <_ZN8emstreamlsEh+0xc4>
    33f4:	60 5d       	subi	r22, 0xD0	; 208
    33f6:	c8 01       	movw	r24, r16
    33f8:	19 95       	eicall
    33fa:	0e c0       	rjmp	.+28     	; 0x3418 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    33fc:	50 e0       	ldi	r21, 0x00	; 0
    33fe:	be 01       	movw	r22, r28
    3400:	6f 5f       	subi	r22, 0xFF	; 255
    3402:	7f 4f       	sbci	r23, 0xFF	; 255
    3404:	8e 2d       	mov	r24, r14
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	0e 94 af 20 	call	0x415e	; 0x415e <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    340c:	be 01       	movw	r22, r28
    340e:	6f 5f       	subi	r22, 0xFF	; 255
    3410:	7f 4f       	sbci	r23, 0xFF	; 255
    3412:	c8 01       	movw	r24, r16
    3414:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3418:	c8 01       	movw	r24, r16
    341a:	29 96       	adiw	r28, 0x09	; 9
    341c:	cd bf       	out	0x3d, r28	; 61
    341e:	de bf       	out	0x3e, r29	; 62
    3420:	df 91       	pop	r29
    3422:	cf 91       	pop	r28
    3424:	1f 91       	pop	r17
    3426:	0f 91       	pop	r16
    3428:	ff 90       	pop	r15
    342a:	ef 90       	pop	r14
    342c:	df 90       	pop	r13
    342e:	cf 90       	pop	r12
    3430:	08 95       	ret

00003432 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3432:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3434:	50 96       	adiw	r26, 0x10	; 16
    3436:	ed 91       	ld	r30, X+
    3438:	fc 91       	ld	r31, X
    343a:	51 97       	sbiw	r26, 0x11	; 17
    343c:	80 81       	ld	r24, Z
    343e:	54 96       	adiw	r26, 0x14	; 20
    3440:	4c 91       	ld	r20, X
    3442:	54 97       	sbiw	r26, 0x14	; 20
    3444:	84 23       	and	r24, r20
    3446:	29 f0       	breq	.+10     	; 0x3452 <_ZN5rs2327putcharEc+0x20>
    3448:	09 c0       	rjmp	.+18     	; 0x345c <_ZN5rs2327putcharEc+0x2a>
    344a:	21 50       	subi	r18, 0x01	; 1
    344c:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    344e:	19 f4       	brne	.+6      	; 0x3456 <_ZN5rs2327putcharEc+0x24>
    3450:	12 c0       	rjmp	.+36     	; 0x3476 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3452:	21 e2       	ldi	r18, 0x21	; 33
    3454:	3e e4       	ldi	r19, 0x4E	; 78
    3456:	90 81       	ld	r25, Z
    3458:	94 23       	and	r25, r20
    345a:	b9 f3       	breq	.-18     	; 0x344a <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    345c:	90 81       	ld	r25, Z
    345e:	56 96       	adiw	r26, 0x16	; 22
    3460:	8c 91       	ld	r24, X
    3462:	56 97       	sbiw	r26, 0x16	; 22
    3464:	89 2b       	or	r24, r25
    3466:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3468:	1e 96       	adiw	r26, 0x0e	; 14
    346a:	ed 91       	ld	r30, X+
    346c:	fc 91       	ld	r31, X
    346e:	1f 97       	sbiw	r26, 0x0f	; 15
    3470:	60 83       	st	Z, r22
	return (true);
    3472:	81 e0       	ldi	r24, 0x01	; 1
    3474:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3476:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3478:	08 95       	ret

0000347a <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    347a:	cf 93       	push	r28
    347c:	df 93       	push	r29
    347e:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3480:	c1 8d       	ldd	r28, Z+25	; 0x19
    3482:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3484:	28 81       	ld	r18, Y
    3486:	39 81       	ldd	r19, Y+1	; 0x01
    3488:	a3 8d       	ldd	r26, Z+27	; 0x1b
    348a:	b4 8d       	ldd	r27, Z+28	; 0x1c
    348c:	4d 91       	ld	r20, X+
    348e:	5c 91       	ld	r21, X
    3490:	24 17       	cp	r18, r20
    3492:	35 07       	cpc	r19, r21
    3494:	e9 f3       	breq	.-6      	; 0x3490 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3496:	a7 89       	ldd	r26, Z+23	; 0x17
    3498:	b0 8d       	ldd	r27, Z+24	; 0x18
    349a:	0d 90       	ld	r0, X+
    349c:	bc 91       	ld	r27, X
    349e:	a0 2d       	mov	r26, r0
    34a0:	a2 0f       	add	r26, r18
    34a2:	b3 1f       	adc	r27, r19
    34a4:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    34a6:	2f 5f       	subi	r18, 0xFF	; 255
    34a8:	3f 4f       	sbci	r19, 0xFF	; 255
    34aa:	28 83       	st	Y, r18
    34ac:	39 83       	std	Y+1, r19	; 0x01
    34ae:	24 36       	cpi	r18, 0x64	; 100
    34b0:	31 05       	cpc	r19, r1
    34b2:	28 f0       	brcs	.+10     	; 0x34be <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    34b4:	01 8c       	ldd	r0, Z+25	; 0x19
    34b6:	f2 8d       	ldd	r31, Z+26	; 0x1a
    34b8:	e0 2d       	mov	r30, r0
    34ba:	10 82       	st	Z, r1
    34bc:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	df 91       	pop	r29
    34c2:	cf 91       	pop	r28
    34c4:	08 95       	ret

000034c6 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    34c6:	cf 93       	push	r28
    34c8:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    34ca:	ec 01       	movw	r28, r24
    34cc:	a9 8d       	ldd	r26, Y+25	; 0x19
    34ce:	ba 8d       	ldd	r27, Y+26	; 0x1a
    34d0:	eb 8d       	ldd	r30, Y+27	; 0x1b
    34d2:	fc 8d       	ldd	r31, Y+28	; 0x1c
    34d4:	81 e0       	ldi	r24, 0x01	; 1
    34d6:	4d 91       	ld	r20, X+
    34d8:	5c 91       	ld	r21, X
    34da:	20 81       	ld	r18, Z
    34dc:	31 81       	ldd	r19, Z+1	; 0x01
    34de:	42 17       	cp	r20, r18
    34e0:	53 07       	cpc	r21, r19
    34e2:	09 f4       	brne	.+2      	; 0x34e6 <_ZN5rs23214check_for_charEv+0x20>
    34e4:	80 e0       	ldi	r24, 0x00	; 0
}
    34e6:	df 91       	pop	r29
    34e8:	cf 91       	pop	r28
    34ea:	08 95       	ret

000034ec <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    34ec:	dc 01       	movw	r26, r24
    34ee:	ed 91       	ld	r30, X+
    34f0:	fc 91       	ld	r31, X
    34f2:	02 80       	ldd	r0, Z+2	; 0x02
    34f4:	f3 81       	ldd	r31, Z+3	; 0x03
    34f6:	e0 2d       	mov	r30, r0
    34f8:	6c e0       	ldi	r22, 0x0C	; 12
    34fa:	19 95       	eicall
    34fc:	08 95       	ret

000034fe <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    34fe:	ef 92       	push	r14
    3500:	ff 92       	push	r15
    3502:	0f 93       	push	r16
    3504:	1f 93       	push	r17
    3506:	cf 93       	push	r28
    3508:	df 93       	push	r29
    350a:	ec 01       	movw	r28, r24
    350c:	7b 01       	movw	r14, r22
    350e:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3510:	0e 94 97 18 	call	0x312e	; 0x312e <_ZN8emstreamC1Ev>
    3514:	a8 01       	movw	r20, r16
    3516:	b7 01       	movw	r22, r14
    3518:	ce 01       	movw	r24, r28
    351a:	08 96       	adiw	r24, 0x08	; 8
    351c:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <_ZN7base232C1EjP12USART_struct>
    3520:	8f e5       	ldi	r24, 0x5F	; 95
    3522:	90 e2       	ldi	r25, 0x20	; 32
    3524:	88 83       	st	Y, r24
    3526:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3528:	00 3a       	cpi	r16, 0xA0	; 160
    352a:	88 e0       	ldi	r24, 0x08	; 8
    352c:	18 07       	cpc	r17, r24
    352e:	69 f4       	brne	.+26     	; 0x354a <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3530:	88 e6       	ldi	r24, 0x68	; 104
    3532:	91 e3       	ldi	r25, 0x31	; 49
    3534:	8f 8b       	std	Y+23, r24	; 0x17
    3536:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3538:	8e e5       	ldi	r24, 0x5E	; 94
    353a:	91 e3       	ldi	r25, 0x31	; 49
    353c:	89 8f       	std	Y+25, r24	; 0x19
    353e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3540:	84 e5       	ldi	r24, 0x54	; 84
    3542:	91 e3       	ldi	r25, 0x31	; 49
    3544:	8b 8f       	std	Y+27, r24	; 0x1b
    3546:	9c 8f       	std	Y+28, r25	; 0x1c
    3548:	42 c0       	rjmp	.+132    	; 0x35ce <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    354a:	00 3b       	cpi	r16, 0xB0	; 176
    354c:	e8 e0       	ldi	r30, 0x08	; 8
    354e:	1e 07       	cpc	r17, r30
    3550:	69 f4       	brne	.+26     	; 0x356c <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3552:	86 e6       	ldi	r24, 0x66	; 102
    3554:	91 e3       	ldi	r25, 0x31	; 49
    3556:	8f 8b       	std	Y+23, r24	; 0x17
    3558:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    355a:	8c e5       	ldi	r24, 0x5C	; 92
    355c:	91 e3       	ldi	r25, 0x31	; 49
    355e:	89 8f       	std	Y+25, r24	; 0x19
    3560:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3562:	82 e5       	ldi	r24, 0x52	; 82
    3564:	91 e3       	ldi	r25, 0x31	; 49
    3566:	8b 8f       	std	Y+27, r24	; 0x1b
    3568:	9c 8f       	std	Y+28, r25	; 0x1c
    356a:	31 c0       	rjmp	.+98     	; 0x35ce <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    356c:	00 3a       	cpi	r16, 0xA0	; 160
    356e:	f9 e0       	ldi	r31, 0x09	; 9
    3570:	1f 07       	cpc	r17, r31
    3572:	69 f4       	brne	.+26     	; 0x358e <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3574:	84 e6       	ldi	r24, 0x64	; 100
    3576:	91 e3       	ldi	r25, 0x31	; 49
    3578:	8f 8b       	std	Y+23, r24	; 0x17
    357a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    357c:	8a e5       	ldi	r24, 0x5A	; 90
    357e:	91 e3       	ldi	r25, 0x31	; 49
    3580:	89 8f       	std	Y+25, r24	; 0x19
    3582:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3584:	80 e5       	ldi	r24, 0x50	; 80
    3586:	91 e3       	ldi	r25, 0x31	; 49
    3588:	8b 8f       	std	Y+27, r24	; 0x1b
    358a:	9c 8f       	std	Y+28, r25	; 0x1c
    358c:	20 c0       	rjmp	.+64     	; 0x35ce <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    358e:	00 3b       	cpi	r16, 0xB0	; 176
    3590:	89 e0       	ldi	r24, 0x09	; 9
    3592:	18 07       	cpc	r17, r24
    3594:	69 f4       	brne	.+26     	; 0x35b0 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3596:	82 e6       	ldi	r24, 0x62	; 98
    3598:	91 e3       	ldi	r25, 0x31	; 49
    359a:	8f 8b       	std	Y+23, r24	; 0x17
    359c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    359e:	88 e5       	ldi	r24, 0x58	; 88
    35a0:	91 e3       	ldi	r25, 0x31	; 49
    35a2:	89 8f       	std	Y+25, r24	; 0x19
    35a4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    35a6:	8e e4       	ldi	r24, 0x4E	; 78
    35a8:	91 e3       	ldi	r25, 0x31	; 49
    35aa:	8b 8f       	std	Y+27, r24	; 0x1b
    35ac:	9c 8f       	std	Y+28, r25	; 0x1c
    35ae:	0f c0       	rjmp	.+30     	; 0x35ce <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    35b0:	00 3a       	cpi	r16, 0xA0	; 160
    35b2:	1a 40       	sbci	r17, 0x0A	; 10
    35b4:	61 f4       	brne	.+24     	; 0x35ce <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    35b6:	80 e6       	ldi	r24, 0x60	; 96
    35b8:	91 e3       	ldi	r25, 0x31	; 49
    35ba:	8f 8b       	std	Y+23, r24	; 0x17
    35bc:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    35be:	86 e5       	ldi	r24, 0x56	; 86
    35c0:	91 e3       	ldi	r25, 0x31	; 49
    35c2:	89 8f       	std	Y+25, r24	; 0x19
    35c4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    35c6:	8c e4       	ldi	r24, 0x4C	; 76
    35c8:	91 e3       	ldi	r25, 0x31	; 49
    35ca:	8b 8f       	std	Y+27, r24	; 0x1b
    35cc:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    35ce:	0f 89       	ldd	r16, Y+23	; 0x17
    35d0:	18 8d       	ldd	r17, Y+24	; 0x18
    35d2:	84 e6       	ldi	r24, 0x64	; 100
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	0e 94 f4 17 	call	0x2fe8	; 0x2fe8 <_Znaj>
    35da:	f8 01       	movw	r30, r16
    35dc:	80 83       	st	Z, r24
    35de:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    35e0:	e9 8d       	ldd	r30, Y+25	; 0x19
    35e2:	fa 8d       	ldd	r31, Y+26	; 0x1a
    35e4:	10 82       	st	Z, r1
    35e6:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    35e8:	eb 8d       	ldd	r30, Y+27	; 0x1b
    35ea:	fc 8d       	ldd	r31, Y+28	; 0x1c
    35ec:	10 82       	st	Z, r1
    35ee:	11 82       	std	Z+1, r1	; 0x01
}
    35f0:	df 91       	pop	r29
    35f2:	cf 91       	pop	r28
    35f4:	1f 91       	pop	r17
    35f6:	0f 91       	pop	r16
    35f8:	ff 90       	pop	r15
    35fa:	ef 90       	pop	r14
    35fc:	08 95       	ret

000035fe <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    35fe:	1f 92       	push	r1
    3600:	0f 92       	push	r0
    3602:	0f b6       	in	r0, 0x3f	; 63
    3604:	0f 92       	push	r0
    3606:	11 24       	eor	r1, r1
    3608:	08 b6       	in	r0, 0x38	; 56
    360a:	0f 92       	push	r0
    360c:	18 be       	out	0x38, r1	; 56
    360e:	0b b6       	in	r0, 0x3b	; 59
    3610:	0f 92       	push	r0
    3612:	1b be       	out	0x3b, r1	; 59
    3614:	2f 93       	push	r18
    3616:	3f 93       	push	r19
    3618:	8f 93       	push	r24
    361a:	9f 93       	push	r25
    361c:	ef 93       	push	r30
    361e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3620:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3624:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvC0_buffer>
    3628:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvC0_buffer+0x1>
    362c:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    3630:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    3634:	e8 0f       	add	r30, r24
    3636:	f9 1f       	adc	r31, r25
    3638:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    363a:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    363e:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    3642:	01 96       	adiw	r24, 0x01	; 1
    3644:	84 36       	cpi	r24, 0x64	; 100
    3646:	91 05       	cpc	r25, r1
    3648:	60 f4       	brcc	.+24     	; 0x3662 <__vector_25+0x64>
    364a:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvC0_write_index>
    364e:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3652:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvC0_read_index>
    3656:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvC0_read_index+0x1>
    365a:	82 17       	cp	r24, r18
    365c:	93 07       	cpc	r25, r19
    365e:	f1 f4       	brne	.+60     	; 0x369c <__vector_25+0x9e>
    3660:	0c c0       	rjmp	.+24     	; 0x367a <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3662:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvC0_write_index>
    3666:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    366a:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC0_read_index>
    366e:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC0_read_index+0x1>
    3672:	18 16       	cp	r1, r24
    3674:	19 06       	cpc	r1, r25
    3676:	91 f4       	brne	.+36     	; 0x369c <__vector_25+0x9e>
    3678:	0e c0       	rjmp	.+28     	; 0x3696 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    367a:	01 96       	adiw	r24, 0x01	; 1
    367c:	84 36       	cpi	r24, 0x64	; 100
    367e:	91 05       	cpc	r25, r1
    3680:	28 f4       	brcc	.+10     	; 0x368c <__vector_25+0x8e>
    3682:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC0_read_index>
    3686:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC0_read_index+0x1>
    368a:	08 c0       	rjmp	.+16     	; 0x369c <__vector_25+0x9e>
			rcvC0_read_index = 0;
    368c:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC0_read_index>
    3690:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC0_read_index+0x1>
}
    3694:	03 c0       	rjmp	.+6      	; 0x369c <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3696:	81 e0       	ldi	r24, 0x01	; 1
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	f3 cf       	rjmp	.-26     	; 0x3682 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    369c:	ff 91       	pop	r31
    369e:	ef 91       	pop	r30
    36a0:	9f 91       	pop	r25
    36a2:	8f 91       	pop	r24
    36a4:	3f 91       	pop	r19
    36a6:	2f 91       	pop	r18
    36a8:	0f 90       	pop	r0
    36aa:	0b be       	out	0x3b, r0	; 59
    36ac:	0f 90       	pop	r0
    36ae:	08 be       	out	0x38, r0	; 56
    36b0:	0f 90       	pop	r0
    36b2:	0f be       	out	0x3f, r0	; 63
    36b4:	0f 90       	pop	r0
    36b6:	1f 90       	pop	r1
    36b8:	18 95       	reti

000036ba <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    36ba:	1f 92       	push	r1
    36bc:	0f 92       	push	r0
    36be:	0f b6       	in	r0, 0x3f	; 63
    36c0:	0f 92       	push	r0
    36c2:	11 24       	eor	r1, r1
    36c4:	08 b6       	in	r0, 0x38	; 56
    36c6:	0f 92       	push	r0
    36c8:	18 be       	out	0x38, r1	; 56
    36ca:	0b b6       	in	r0, 0x3b	; 59
    36cc:	0f 92       	push	r0
    36ce:	1b be       	out	0x3b, r1	; 59
    36d0:	2f 93       	push	r18
    36d2:	3f 93       	push	r19
    36d4:	8f 93       	push	r24
    36d6:	9f 93       	push	r25
    36d8:	ef 93       	push	r30
    36da:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    36dc:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    36e0:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvC1_buffer>
    36e4:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvC1_buffer+0x1>
    36e8:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC1_write_index>
    36ec:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC1_write_index+0x1>
    36f0:	e8 0f       	add	r30, r24
    36f2:	f9 1f       	adc	r31, r25
    36f4:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    36f6:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC1_write_index>
    36fa:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC1_write_index+0x1>
    36fe:	01 96       	adiw	r24, 0x01	; 1
    3700:	84 36       	cpi	r24, 0x64	; 100
    3702:	91 05       	cpc	r25, r1
    3704:	60 f4       	brcc	.+24     	; 0x371e <__vector_28+0x64>
    3706:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvC1_write_index>
    370a:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    370e:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvC1_read_index>
    3712:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvC1_read_index+0x1>
    3716:	82 17       	cp	r24, r18
    3718:	93 07       	cpc	r25, r19
    371a:	f1 f4       	brne	.+60     	; 0x3758 <__vector_28+0x9e>
    371c:	0c c0       	rjmp	.+24     	; 0x3736 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    371e:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvC1_write_index>
    3722:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3726:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC1_read_index>
    372a:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC1_read_index+0x1>
    372e:	18 16       	cp	r1, r24
    3730:	19 06       	cpc	r1, r25
    3732:	91 f4       	brne	.+36     	; 0x3758 <__vector_28+0x9e>
    3734:	0e c0       	rjmp	.+28     	; 0x3752 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3736:	01 96       	adiw	r24, 0x01	; 1
    3738:	84 36       	cpi	r24, 0x64	; 100
    373a:	91 05       	cpc	r25, r1
    373c:	28 f4       	brcc	.+10     	; 0x3748 <__vector_28+0x8e>
    373e:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC1_read_index>
    3742:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC1_read_index+0x1>
    3746:	08 c0       	rjmp	.+16     	; 0x3758 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3748:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC1_read_index>
    374c:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC1_read_index+0x1>
}
    3750:	03 c0       	rjmp	.+6      	; 0x3758 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3752:	81 e0       	ldi	r24, 0x01	; 1
    3754:	90 e0       	ldi	r25, 0x00	; 0
    3756:	f3 cf       	rjmp	.-26     	; 0x373e <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3758:	ff 91       	pop	r31
    375a:	ef 91       	pop	r30
    375c:	9f 91       	pop	r25
    375e:	8f 91       	pop	r24
    3760:	3f 91       	pop	r19
    3762:	2f 91       	pop	r18
    3764:	0f 90       	pop	r0
    3766:	0b be       	out	0x3b, r0	; 59
    3768:	0f 90       	pop	r0
    376a:	08 be       	out	0x38, r0	; 56
    376c:	0f 90       	pop	r0
    376e:	0f be       	out	0x3f, r0	; 63
    3770:	0f 90       	pop	r0
    3772:	1f 90       	pop	r1
    3774:	18 95       	reti

00003776 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3776:	1f 92       	push	r1
    3778:	0f 92       	push	r0
    377a:	0f b6       	in	r0, 0x3f	; 63
    377c:	0f 92       	push	r0
    377e:	11 24       	eor	r1, r1
    3780:	08 b6       	in	r0, 0x38	; 56
    3782:	0f 92       	push	r0
    3784:	18 be       	out	0x38, r1	; 56
    3786:	0b b6       	in	r0, 0x3b	; 59
    3788:	0f 92       	push	r0
    378a:	1b be       	out	0x3b, r1	; 59
    378c:	2f 93       	push	r18
    378e:	3f 93       	push	r19
    3790:	8f 93       	push	r24
    3792:	9f 93       	push	r25
    3794:	ef 93       	push	r30
    3796:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3798:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    379c:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvD0_buffer>
    37a0:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvD0_buffer+0x1>
    37a4:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    37a8:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    37ac:	e8 0f       	add	r30, r24
    37ae:	f9 1f       	adc	r31, r25
    37b0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    37b2:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD0_write_index>
    37b6:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD0_write_index+0x1>
    37ba:	01 96       	adiw	r24, 0x01	; 1
    37bc:	84 36       	cpi	r24, 0x64	; 100
    37be:	91 05       	cpc	r25, r1
    37c0:	60 f4       	brcc	.+24     	; 0x37da <__vector_88+0x64>
    37c2:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvD0_write_index>
    37c6:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    37ca:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvD0_read_index>
    37ce:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvD0_read_index+0x1>
    37d2:	82 17       	cp	r24, r18
    37d4:	93 07       	cpc	r25, r19
    37d6:	f1 f4       	brne	.+60     	; 0x3814 <__vector_88+0x9e>
    37d8:	0c c0       	rjmp	.+24     	; 0x37f2 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    37da:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvD0_write_index>
    37de:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    37e2:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD0_read_index>
    37e6:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD0_read_index+0x1>
    37ea:	18 16       	cp	r1, r24
    37ec:	19 06       	cpc	r1, r25
    37ee:	91 f4       	brne	.+36     	; 0x3814 <__vector_88+0x9e>
    37f0:	0e c0       	rjmp	.+28     	; 0x380e <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    37f2:	01 96       	adiw	r24, 0x01	; 1
    37f4:	84 36       	cpi	r24, 0x64	; 100
    37f6:	91 05       	cpc	r25, r1
    37f8:	28 f4       	brcc	.+10     	; 0x3804 <__vector_88+0x8e>
    37fa:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD0_read_index>
    37fe:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD0_read_index+0x1>
    3802:	08 c0       	rjmp	.+16     	; 0x3814 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3804:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD0_read_index>
    3808:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD0_read_index+0x1>
}
    380c:	03 c0       	rjmp	.+6      	; 0x3814 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    380e:	81 e0       	ldi	r24, 0x01	; 1
    3810:	90 e0       	ldi	r25, 0x00	; 0
    3812:	f3 cf       	rjmp	.-26     	; 0x37fa <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3814:	ff 91       	pop	r31
    3816:	ef 91       	pop	r30
    3818:	9f 91       	pop	r25
    381a:	8f 91       	pop	r24
    381c:	3f 91       	pop	r19
    381e:	2f 91       	pop	r18
    3820:	0f 90       	pop	r0
    3822:	0b be       	out	0x3b, r0	; 59
    3824:	0f 90       	pop	r0
    3826:	08 be       	out	0x38, r0	; 56
    3828:	0f 90       	pop	r0
    382a:	0f be       	out	0x3f, r0	; 63
    382c:	0f 90       	pop	r0
    382e:	1f 90       	pop	r1
    3830:	18 95       	reti

00003832 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3832:	1f 92       	push	r1
    3834:	0f 92       	push	r0
    3836:	0f b6       	in	r0, 0x3f	; 63
    3838:	0f 92       	push	r0
    383a:	11 24       	eor	r1, r1
    383c:	08 b6       	in	r0, 0x38	; 56
    383e:	0f 92       	push	r0
    3840:	18 be       	out	0x38, r1	; 56
    3842:	0b b6       	in	r0, 0x3b	; 59
    3844:	0f 92       	push	r0
    3846:	1b be       	out	0x3b, r1	; 59
    3848:	2f 93       	push	r18
    384a:	3f 93       	push	r19
    384c:	8f 93       	push	r24
    384e:	9f 93       	push	r25
    3850:	ef 93       	push	r30
    3852:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3854:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3858:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvD1_buffer>
    385c:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvD1_buffer+0x1>
    3860:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD1_write_index>
    3864:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD1_write_index+0x1>
    3868:	e8 0f       	add	r30, r24
    386a:	f9 1f       	adc	r31, r25
    386c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    386e:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD1_write_index>
    3872:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD1_write_index+0x1>
    3876:	01 96       	adiw	r24, 0x01	; 1
    3878:	84 36       	cpi	r24, 0x64	; 100
    387a:	91 05       	cpc	r25, r1
    387c:	60 f4       	brcc	.+24     	; 0x3896 <__vector_91+0x64>
    387e:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvD1_write_index>
    3882:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3886:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvD1_read_index>
    388a:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvD1_read_index+0x1>
    388e:	82 17       	cp	r24, r18
    3890:	93 07       	cpc	r25, r19
    3892:	f1 f4       	brne	.+60     	; 0x38d0 <__vector_91+0x9e>
    3894:	0c c0       	rjmp	.+24     	; 0x38ae <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3896:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvD1_write_index>
    389a:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    389e:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD1_read_index>
    38a2:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD1_read_index+0x1>
    38a6:	18 16       	cp	r1, r24
    38a8:	19 06       	cpc	r1, r25
    38aa:	91 f4       	brne	.+36     	; 0x38d0 <__vector_91+0x9e>
    38ac:	0e c0       	rjmp	.+28     	; 0x38ca <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    38ae:	01 96       	adiw	r24, 0x01	; 1
    38b0:	84 36       	cpi	r24, 0x64	; 100
    38b2:	91 05       	cpc	r25, r1
    38b4:	28 f4       	brcc	.+10     	; 0x38c0 <__vector_91+0x8e>
    38b6:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD1_read_index>
    38ba:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD1_read_index+0x1>
    38be:	08 c0       	rjmp	.+16     	; 0x38d0 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    38c0:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD1_read_index>
    38c4:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD1_read_index+0x1>
}
    38c8:	03 c0       	rjmp	.+6      	; 0x38d0 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    38ca:	81 e0       	ldi	r24, 0x01	; 1
    38cc:	90 e0       	ldi	r25, 0x00	; 0
    38ce:	f3 cf       	rjmp	.-26     	; 0x38b6 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    38d0:	ff 91       	pop	r31
    38d2:	ef 91       	pop	r30
    38d4:	9f 91       	pop	r25
    38d6:	8f 91       	pop	r24
    38d8:	3f 91       	pop	r19
    38da:	2f 91       	pop	r18
    38dc:	0f 90       	pop	r0
    38de:	0b be       	out	0x3b, r0	; 59
    38e0:	0f 90       	pop	r0
    38e2:	08 be       	out	0x38, r0	; 56
    38e4:	0f 90       	pop	r0
    38e6:	0f be       	out	0x3f, r0	; 63
    38e8:	0f 90       	pop	r0
    38ea:	1f 90       	pop	r1
    38ec:	18 95       	reti

000038ee <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    38ee:	1f 92       	push	r1
    38f0:	0f 92       	push	r0
    38f2:	0f b6       	in	r0, 0x3f	; 63
    38f4:	0f 92       	push	r0
    38f6:	11 24       	eor	r1, r1
    38f8:	08 b6       	in	r0, 0x38	; 56
    38fa:	0f 92       	push	r0
    38fc:	18 be       	out	0x38, r1	; 56
    38fe:	0b b6       	in	r0, 0x3b	; 59
    3900:	0f 92       	push	r0
    3902:	1b be       	out	0x3b, r1	; 59
    3904:	2f 93       	push	r18
    3906:	3f 93       	push	r19
    3908:	8f 93       	push	r24
    390a:	9f 93       	push	r25
    390c:	ef 93       	push	r30
    390e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3910:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3914:	e0 91 60 31 	lds	r30, 0x3160	; 0x803160 <rcvE0_buffer>
    3918:	f0 91 61 31 	lds	r31, 0x3161	; 0x803161 <rcvE0_buffer+0x1>
    391c:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvE0_write_index>
    3920:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvE0_write_index+0x1>
    3924:	e8 0f       	add	r30, r24
    3926:	f9 1f       	adc	r31, r25
    3928:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    392a:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvE0_write_index>
    392e:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvE0_write_index+0x1>
    3932:	01 96       	adiw	r24, 0x01	; 1
    3934:	84 36       	cpi	r24, 0x64	; 100
    3936:	91 05       	cpc	r25, r1
    3938:	60 f4       	brcc	.+24     	; 0x3952 <__vector_58+0x64>
    393a:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvE0_write_index>
    393e:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3942:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvE0_read_index>
    3946:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvE0_read_index+0x1>
    394a:	82 17       	cp	r24, r18
    394c:	93 07       	cpc	r25, r19
    394e:	f1 f4       	brne	.+60     	; 0x398c <__vector_58+0x9e>
    3950:	0c c0       	rjmp	.+24     	; 0x396a <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3952:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvE0_write_index>
    3956:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    395a:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvE0_read_index>
    395e:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvE0_read_index+0x1>
    3962:	18 16       	cp	r1, r24
    3964:	19 06       	cpc	r1, r25
    3966:	91 f4       	brne	.+36     	; 0x398c <__vector_58+0x9e>
    3968:	0e c0       	rjmp	.+28     	; 0x3986 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    396a:	01 96       	adiw	r24, 0x01	; 1
    396c:	84 36       	cpi	r24, 0x64	; 100
    396e:	91 05       	cpc	r25, r1
    3970:	28 f4       	brcc	.+10     	; 0x397c <__vector_58+0x8e>
    3972:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvE0_read_index>
    3976:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvE0_read_index+0x1>
    397a:	08 c0       	rjmp	.+16     	; 0x398c <__vector_58+0x9e>
	rcvE0_read_index = 0;
    397c:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvE0_read_index>
    3980:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvE0_read_index+0x1>
}
    3984:	03 c0       	rjmp	.+6      	; 0x398c <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3986:	81 e0       	ldi	r24, 0x01	; 1
    3988:	90 e0       	ldi	r25, 0x00	; 0
    398a:	f3 cf       	rjmp	.-26     	; 0x3972 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    398c:	ff 91       	pop	r31
    398e:	ef 91       	pop	r30
    3990:	9f 91       	pop	r25
    3992:	8f 91       	pop	r24
    3994:	3f 91       	pop	r19
    3996:	2f 91       	pop	r18
    3998:	0f 90       	pop	r0
    399a:	0b be       	out	0x3b, r0	; 59
    399c:	0f 90       	pop	r0
    399e:	08 be       	out	0x38, r0	; 56
    39a0:	0f 90       	pop	r0
    39a2:	0f be       	out	0x3f, r0	; 63
    39a4:	0f 90       	pop	r0
    39a6:	1f 90       	pop	r1
    39a8:	18 95       	reti

000039aa <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    39aa:	fc 01       	movw	r30, r24
    39ac:	84 81       	ldd	r24, Z+4	; 0x04
    39ae:	95 81       	ldd	r25, Z+5	; 0x05
    39b0:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
		}
    39b4:	90 e0       	ldi	r25, 0x00	; 0
    39b6:	08 95       	ret

000039b8 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    39b8:	fc 01       	movw	r30, r24
    39ba:	84 81       	ldd	r24, Z+4	; 0x04
    39bc:	95 81       	ldd	r25, Z+5	; 0x05
    39be:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
    39c2:	91 e0       	ldi	r25, 0x01	; 1
    39c4:	81 11       	cpse	r24, r1
    39c6:	01 c0       	rjmp	.+2      	; 0x39ca <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    39c8:	90 e0       	ldi	r25, 0x00	; 0
		}
    39ca:	89 2f       	mov	r24, r25
    39cc:	08 95       	ret

000039ce <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    39ce:	fc 01       	movw	r30, r24
    39d0:	84 81       	ldd	r24, Z+4	; 0x04
    39d2:	95 81       	ldd	r25, Z+5	; 0x05
    39d4:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
    39d8:	91 e0       	ldi	r25, 0x01	; 1
    39da:	81 11       	cpse	r24, r1
    39dc:	90 e0       	ldi	r25, 0x00	; 0
		}
    39de:	89 2f       	mov	r24, r25
    39e0:	08 95       	ret

000039e2 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    39e2:	fc 01       	movw	r30, r24
    39e4:	84 81       	ldd	r24, Z+4	; 0x04
    39e6:	95 81       	ldd	r25, Z+5	; 0x05
    39e8:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
		}
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	08 95       	ret

000039f0 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    39f0:	fc 01       	movw	r30, r24
    39f2:	84 81       	ldd	r24, Z+4	; 0x04
    39f4:	95 81       	ldd	r25, Z+5	; 0x05
    39f6:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
    39fa:	91 e0       	ldi	r25, 0x01	; 1
    39fc:	81 11       	cpse	r24, r1
    39fe:	01 c0       	rjmp	.+2      	; 0x3a02 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    3a00:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a02:	89 2f       	mov	r24, r25
    3a04:	08 95       	ret

00003a06 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3a06:	fc 01       	movw	r30, r24
    3a08:	84 81       	ldd	r24, Z+4	; 0x04
    3a0a:	95 81       	ldd	r25, Z+5	; 0x05
    3a0c:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <uxQueueMessagesWaitingFromISR>
    3a10:	91 e0       	ldi	r25, 0x01	; 1
    3a12:	81 11       	cpse	r24, r1
    3a14:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a16:	89 2f       	mov	r24, r25
    3a18:	08 95       	ret

00003a1a <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3a1a:	fc 01       	movw	r30, r24
    3a1c:	84 81       	ldd	r24, Z+4	; 0x04
    3a1e:	95 81       	ldd	r25, Z+5	; 0x05
    3a20:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
		}
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	08 95       	ret

00003a28 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3a28:	fc 01       	movw	r30, r24
    3a2a:	84 81       	ldd	r24, Z+4	; 0x04
    3a2c:	95 81       	ldd	r25, Z+5	; 0x05
    3a2e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
    3a32:	91 e0       	ldi	r25, 0x01	; 1
    3a34:	81 11       	cpse	r24, r1
    3a36:	01 c0       	rjmp	.+2      	; 0x3a3a <_ZN9frt_queueIjE9not_emptyEv+0x12>
    3a38:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a3a:	89 2f       	mov	r24, r25
    3a3c:	08 95       	ret

00003a3e <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3a3e:	fc 01       	movw	r30, r24
    3a40:	84 81       	ldd	r24, Z+4	; 0x04
    3a42:	95 81       	ldd	r25, Z+5	; 0x05
    3a44:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
    3a48:	91 e0       	ldi	r25, 0x01	; 1
    3a4a:	81 11       	cpse	r24, r1
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a4e:	89 2f       	mov	r24, r25
    3a50:	08 95       	ret

00003a52 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3a52:	fc 01       	movw	r30, r24
    3a54:	84 81       	ldd	r24, Z+4	; 0x04
    3a56:	95 81       	ldd	r25, Z+5	; 0x05
    3a58:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
		}
    3a5c:	90 e0       	ldi	r25, 0x00	; 0
    3a5e:	08 95       	ret

00003a60 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3a60:	fc 01       	movw	r30, r24
    3a62:	84 81       	ldd	r24, Z+4	; 0x04
    3a64:	95 81       	ldd	r25, Z+5	; 0x05
    3a66:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
    3a6a:	91 e0       	ldi	r25, 0x01	; 1
    3a6c:	81 11       	cpse	r24, r1
    3a6e:	01 c0       	rjmp	.+2      	; 0x3a72 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3a70:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a72:	89 2f       	mov	r24, r25
    3a74:	08 95       	ret

00003a76 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3a76:	fc 01       	movw	r30, r24
    3a78:	84 81       	ldd	r24, Z+4	; 0x04
    3a7a:	95 81       	ldd	r25, Z+5	; 0x05
    3a7c:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <uxQueueMessagesWaiting>
    3a80:	91 e0       	ldi	r25, 0x01	; 1
    3a82:	81 11       	cpse	r24, r1
    3a84:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a86:	89 2f       	mov	r24, r25
    3a88:	08 95       	ret

00003a8a <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3a8a:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3a8c:	01 e0       	ldi	r16, 0x01	; 1
    3a8e:	2f ef       	ldi	r18, 0xFF	; 255
    3a90:	3f ef       	ldi	r19, 0xFF	; 255
    3a92:	a9 01       	movw	r20, r18
    3a94:	fc 01       	movw	r30, r24
    3a96:	84 81       	ldd	r24, Z+4	; 0x04
    3a98:	95 81       	ldd	r25, Z+5	; 0x05
    3a9a:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
}
    3a9e:	0f 91       	pop	r16
    3aa0:	08 95       	ret

00003aa2 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3aa2:	0f 93       	push	r16
    3aa4:	cf 93       	push	r28
    3aa6:	df 93       	push	r29
    3aa8:	1f 92       	push	r1
    3aaa:	1f 92       	push	r1
    3aac:	cd b7       	in	r28, 0x3d	; 61
    3aae:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3ab0:	01 e0       	ldi	r16, 0x01	; 1
    3ab2:	2f ef       	ldi	r18, 0xFF	; 255
    3ab4:	3f ef       	ldi	r19, 0xFF	; 255
    3ab6:	a9 01       	movw	r20, r18
    3ab8:	be 01       	movw	r22, r28
    3aba:	6f 5f       	subi	r22, 0xFF	; 255
    3abc:	7f 4f       	sbci	r23, 0xFF	; 255
    3abe:	fc 01       	movw	r30, r24
    3ac0:	84 81       	ldd	r24, Z+4	; 0x04
    3ac2:	95 81       	ldd	r25, Z+5	; 0x05
    3ac4:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
	return (recv_item);
}
    3ac8:	89 81       	ldd	r24, Y+1	; 0x01
    3aca:	9a 81       	ldd	r25, Y+2	; 0x02
    3acc:	0f 90       	pop	r0
    3ace:	0f 90       	pop	r0
    3ad0:	df 91       	pop	r29
    3ad2:	cf 91       	pop	r28
    3ad4:	0f 91       	pop	r16
    3ad6:	08 95       	ret

00003ad8 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3ad8:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3ada:	00 e0       	ldi	r16, 0x00	; 0
    3adc:	2f ef       	ldi	r18, 0xFF	; 255
    3ade:	3f ef       	ldi	r19, 0xFF	; 255
    3ae0:	a9 01       	movw	r20, r18
    3ae2:	fc 01       	movw	r30, r24
    3ae4:	84 81       	ldd	r24, Z+4	; 0x04
    3ae6:	95 81       	ldd	r25, Z+5	; 0x05
    3ae8:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
}
    3aec:	0f 91       	pop	r16
    3aee:	08 95       	ret

00003af0 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3af0:	0f 93       	push	r16
    3af2:	cf 93       	push	r28
    3af4:	df 93       	push	r29
    3af6:	1f 92       	push	r1
    3af8:	1f 92       	push	r1
    3afa:	cd b7       	in	r28, 0x3d	; 61
    3afc:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3afe:	00 e0       	ldi	r16, 0x00	; 0
    3b00:	2f ef       	ldi	r18, 0xFF	; 255
    3b02:	3f ef       	ldi	r19, 0xFF	; 255
    3b04:	a9 01       	movw	r20, r18
    3b06:	be 01       	movw	r22, r28
    3b08:	6f 5f       	subi	r22, 0xFF	; 255
    3b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	84 81       	ldd	r24, Z+4	; 0x04
    3b10:	95 81       	ldd	r25, Z+5	; 0x05
    3b12:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
	return (recv_item);
}
    3b16:	89 81       	ldd	r24, Y+1	; 0x01
    3b18:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1a:	0f 90       	pop	r0
    3b1c:	0f 90       	pop	r0
    3b1e:	df 91       	pop	r29
    3b20:	cf 91       	pop	r28
    3b22:	0f 91       	pop	r16
    3b24:	08 95       	ret

00003b26 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3b26:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3b28:	01 e0       	ldi	r16, 0x01	; 1
    3b2a:	2f ef       	ldi	r18, 0xFF	; 255
    3b2c:	3f ef       	ldi	r19, 0xFF	; 255
    3b2e:	a9 01       	movw	r20, r18
    3b30:	fc 01       	movw	r30, r24
    3b32:	84 81       	ldd	r24, Z+4	; 0x04
    3b34:	95 81       	ldd	r25, Z+5	; 0x05
    3b36:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
}
    3b3a:	0f 91       	pop	r16
    3b3c:	08 95       	ret

00003b3e <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3b3e:	0f 93       	push	r16
    3b40:	cf 93       	push	r28
    3b42:	df 93       	push	r29
    3b44:	1f 92       	push	r1
    3b46:	1f 92       	push	r1
    3b48:	cd b7       	in	r28, 0x3d	; 61
    3b4a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3b4c:	01 e0       	ldi	r16, 0x01	; 1
    3b4e:	2f ef       	ldi	r18, 0xFF	; 255
    3b50:	3f ef       	ldi	r19, 0xFF	; 255
    3b52:	a9 01       	movw	r20, r18
    3b54:	be 01       	movw	r22, r28
    3b56:	6f 5f       	subi	r22, 0xFF	; 255
    3b58:	7f 4f       	sbci	r23, 0xFF	; 255
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	84 81       	ldd	r24, Z+4	; 0x04
    3b5e:	95 81       	ldd	r25, Z+5	; 0x05
    3b60:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
	return (recv_item);
}
    3b64:	89 81       	ldd	r24, Y+1	; 0x01
    3b66:	9a 81       	ldd	r25, Y+2	; 0x02
    3b68:	0f 90       	pop	r0
    3b6a:	0f 90       	pop	r0
    3b6c:	df 91       	pop	r29
    3b6e:	cf 91       	pop	r28
    3b70:	0f 91       	pop	r16
    3b72:	08 95       	ret

00003b74 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3b74:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3b76:	00 e0       	ldi	r16, 0x00	; 0
    3b78:	2f ef       	ldi	r18, 0xFF	; 255
    3b7a:	3f ef       	ldi	r19, 0xFF	; 255
    3b7c:	a9 01       	movw	r20, r18
    3b7e:	fc 01       	movw	r30, r24
    3b80:	84 81       	ldd	r24, Z+4	; 0x04
    3b82:	95 81       	ldd	r25, Z+5	; 0x05
    3b84:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
}
    3b88:	0f 91       	pop	r16
    3b8a:	08 95       	ret

00003b8c <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3b8c:	0f 93       	push	r16
    3b8e:	cf 93       	push	r28
    3b90:	df 93       	push	r29
    3b92:	1f 92       	push	r1
    3b94:	1f 92       	push	r1
    3b96:	cd b7       	in	r28, 0x3d	; 61
    3b98:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3b9a:	00 e0       	ldi	r16, 0x00	; 0
    3b9c:	2f ef       	ldi	r18, 0xFF	; 255
    3b9e:	3f ef       	ldi	r19, 0xFF	; 255
    3ba0:	a9 01       	movw	r20, r18
    3ba2:	be 01       	movw	r22, r28
    3ba4:	6f 5f       	subi	r22, 0xFF	; 255
    3ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ba8:	fc 01       	movw	r30, r24
    3baa:	84 81       	ldd	r24, Z+4	; 0x04
    3bac:	95 81       	ldd	r25, Z+5	; 0x05
    3bae:	0e 94 0e 0d 	call	0x1a1c	; 0x1a1c <xQueueGenericReceive>
	return (recv_item);
}
    3bb2:	89 81       	ldd	r24, Y+1	; 0x01
    3bb4:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	df 91       	pop	r29
    3bbc:	cf 91       	pop	r28
    3bbe:	0f 91       	pop	r16
    3bc0:	08 95       	ret

00003bc2 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3bc2:	cf 93       	push	r28
    3bc4:	df 93       	push	r29
    3bc6:	1f 92       	push	r1
    3bc8:	cd b7       	in	r28, 0x3d	; 61
    3bca:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3bcc:	ae 01       	movw	r20, r28
    3bce:	4f 5f       	subi	r20, 0xFF	; 255
    3bd0:	5f 4f       	sbci	r21, 0xFF	; 255
    3bd2:	fc 01       	movw	r30, r24
    3bd4:	84 81       	ldd	r24, Z+4	; 0x04
    3bd6:	95 81       	ldd	r25, Z+5	; 0x05
    3bd8:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <xQueueReceiveFromISR>
}
    3bdc:	0f 90       	pop	r0
    3bde:	df 91       	pop	r29
    3be0:	cf 91       	pop	r28
    3be2:	08 95       	ret

00003be4 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3be4:	cf 93       	push	r28
    3be6:	df 93       	push	r29
    3be8:	00 d0       	rcall	.+0      	; 0x3bea <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3bea:	cd b7       	in	r28, 0x3d	; 61
    3bec:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3bee:	ae 01       	movw	r20, r28
    3bf0:	4d 5f       	subi	r20, 0xFD	; 253
    3bf2:	5f 4f       	sbci	r21, 0xFF	; 255
    3bf4:	be 01       	movw	r22, r28
    3bf6:	6f 5f       	subi	r22, 0xFF	; 255
    3bf8:	7f 4f       	sbci	r23, 0xFF	; 255
    3bfa:	fc 01       	movw	r30, r24
    3bfc:	84 81       	ldd	r24, Z+4	; 0x04
    3bfe:	95 81       	ldd	r25, Z+5	; 0x05
    3c00:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <xQueueReceiveFromISR>
	return (recv_item);
}
    3c04:	89 81       	ldd	r24, Y+1	; 0x01
    3c06:	9a 81       	ldd	r25, Y+2	; 0x02
    3c08:	23 96       	adiw	r28, 0x03	; 3
    3c0a:	cd bf       	out	0x3d, r28	; 61
    3c0c:	de bf       	out	0x3e, r29	; 62
    3c0e:	df 91       	pop	r29
    3c10:	cf 91       	pop	r28
    3c12:	08 95       	ret

00003c14 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	1f 92       	push	r1
    3c1a:	cd b7       	in	r28, 0x3d	; 61
    3c1c:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3c1e:	ae 01       	movw	r20, r28
    3c20:	4f 5f       	subi	r20, 0xFF	; 255
    3c22:	5f 4f       	sbci	r21, 0xFF	; 255
    3c24:	fc 01       	movw	r30, r24
    3c26:	84 81       	ldd	r24, Z+4	; 0x04
    3c28:	95 81       	ldd	r25, Z+5	; 0x05
    3c2a:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <xQueueReceiveFromISR>
}
    3c2e:	0f 90       	pop	r0
    3c30:	df 91       	pop	r29
    3c32:	cf 91       	pop	r28
    3c34:	08 95       	ret

00003c36 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3c36:	cf 93       	push	r28
    3c38:	df 93       	push	r29
    3c3a:	00 d0       	rcall	.+0      	; 0x3c3c <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3c3c:	cd b7       	in	r28, 0x3d	; 61
    3c3e:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3c40:	ae 01       	movw	r20, r28
    3c42:	4d 5f       	subi	r20, 0xFD	; 253
    3c44:	5f 4f       	sbci	r21, 0xFF	; 255
    3c46:	be 01       	movw	r22, r28
    3c48:	6f 5f       	subi	r22, 0xFF	; 255
    3c4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c4c:	fc 01       	movw	r30, r24
    3c4e:	84 81       	ldd	r24, Z+4	; 0x04
    3c50:	95 81       	ldd	r25, Z+5	; 0x05
    3c52:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <xQueueReceiveFromISR>
	return (recv_item);
}
    3c56:	89 81       	ldd	r24, Y+1	; 0x01
    3c58:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5a:	23 96       	adiw	r28, 0x03	; 3
    3c5c:	cd bf       	out	0x3d, r28	; 61
    3c5e:	de bf       	out	0x3e, r29	; 62
    3c60:	df 91       	pop	r29
    3c62:	cf 91       	pop	r28
    3c64:	08 95       	ret

00003c66 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3c66:	cf 93       	push	r28
    3c68:	df 93       	push	r29
    3c6a:	1f 92       	push	r1
    3c6c:	cd b7       	in	r28, 0x3d	; 61
    3c6e:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c70:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3c72:	21 e0       	ldi	r18, 0x01	; 1
    3c74:	ae 01       	movw	r20, r28
    3c76:	4f 5f       	subi	r20, 0xFF	; 255
    3c78:	5f 4f       	sbci	r21, 0xFF	; 255
    3c7a:	fc 01       	movw	r30, r24
    3c7c:	84 81       	ldd	r24, Z+4	; 0x04
    3c7e:	95 81       	ldd	r25, Z+5	; 0x05
    3c80:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c84:	91 e0       	ldi	r25, 0x01	; 1
    3c86:	81 11       	cpse	r24, r1
    3c88:	01 c0       	rjmp	.+2      	; 0x3c8c <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3c8a:	90 e0       	ldi	r25, 0x00	; 0
}
    3c8c:	89 2f       	mov	r24, r25
    3c8e:	0f 90       	pop	r0
    3c90:	df 91       	pop	r29
    3c92:	cf 91       	pop	r28
    3c94:	08 95       	ret

00003c96 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3c96:	cf 93       	push	r28
    3c98:	df 93       	push	r29
    3c9a:	1f 92       	push	r1
    3c9c:	cd b7       	in	r28, 0x3d	; 61
    3c9e:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3ca0:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3ca2:	20 e0       	ldi	r18, 0x00	; 0
    3ca4:	ae 01       	movw	r20, r28
    3ca6:	4f 5f       	subi	r20, 0xFF	; 255
    3ca8:	5f 4f       	sbci	r21, 0xFF	; 255
    3caa:	fc 01       	movw	r30, r24
    3cac:	84 81       	ldd	r24, Z+4	; 0x04
    3cae:	95 81       	ldd	r25, Z+5	; 0x05
    3cb0:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3cb4:	91 e0       	ldi	r25, 0x01	; 1
    3cb6:	81 11       	cpse	r24, r1
    3cb8:	01 c0       	rjmp	.+2      	; 0x3cbc <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3cba:	90 e0       	ldi	r25, 0x00	; 0
}
    3cbc:	89 2f       	mov	r24, r25
    3cbe:	0f 90       	pop	r0
    3cc0:	df 91       	pop	r29
    3cc2:	cf 91       	pop	r28
    3cc4:	08 95       	ret

00003cc6 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3cc6:	cf 93       	push	r28
    3cc8:	df 93       	push	r29
    3cca:	1f 92       	push	r1
    3ccc:	cd b7       	in	r28, 0x3d	; 61
    3cce:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3cd0:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3cd2:	21 e0       	ldi	r18, 0x01	; 1
    3cd4:	ae 01       	movw	r20, r28
    3cd6:	4f 5f       	subi	r20, 0xFF	; 255
    3cd8:	5f 4f       	sbci	r21, 0xFF	; 255
    3cda:	fc 01       	movw	r30, r24
    3cdc:	84 81       	ldd	r24, Z+4	; 0x04
    3cde:	95 81       	ldd	r25, Z+5	; 0x05
    3ce0:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3ce4:	91 e0       	ldi	r25, 0x01	; 1
    3ce6:	81 11       	cpse	r24, r1
    3ce8:	01 c0       	rjmp	.+2      	; 0x3cec <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3cea:	90 e0       	ldi	r25, 0x00	; 0
}
    3cec:	89 2f       	mov	r24, r25
    3cee:	0f 90       	pop	r0
    3cf0:	df 91       	pop	r29
    3cf2:	cf 91       	pop	r28
    3cf4:	08 95       	ret

00003cf6 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3cf6:	cf 93       	push	r28
    3cf8:	df 93       	push	r29
    3cfa:	1f 92       	push	r1
    3cfc:	cd b7       	in	r28, 0x3d	; 61
    3cfe:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3d00:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3d02:	20 e0       	ldi	r18, 0x00	; 0
    3d04:	ae 01       	movw	r20, r28
    3d06:	4f 5f       	subi	r20, 0xFF	; 255
    3d08:	5f 4f       	sbci	r21, 0xFF	; 255
    3d0a:	fc 01       	movw	r30, r24
    3d0c:	84 81       	ldd	r24, Z+4	; 0x04
    3d0e:	95 81       	ldd	r25, Z+5	; 0x05
    3d10:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3d14:	91 e0       	ldi	r25, 0x01	; 1
    3d16:	81 11       	cpse	r24, r1
    3d18:	01 c0       	rjmp	.+2      	; 0x3d1c <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
}
    3d1c:	89 2f       	mov	r24, r25
    3d1e:	0f 90       	pop	r0
    3d20:	df 91       	pop	r29
    3d22:	cf 91       	pop	r28
    3d24:	08 95       	ret

00003d26 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3d26:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3d28:	fc 01       	movw	r30, r24
    3d2a:	26 81       	ldd	r18, Z+6	; 0x06
    3d2c:	37 81       	ldd	r19, Z+7	; 0x07
    3d2e:	40 85       	ldd	r20, Z+8	; 0x08
    3d30:	51 85       	ldd	r21, Z+9	; 0x09
    3d32:	01 e0       	ldi	r16, 0x01	; 1
    3d34:	84 81       	ldd	r24, Z+4	; 0x04
    3d36:	95 81       	ldd	r25, Z+5	; 0x05
    3d38:	0e 94 47 0c 	call	0x188e	; 0x188e <xQueueGenericSend>
    3d3c:	91 e0       	ldi	r25, 0x01	; 1
    3d3e:	81 11       	cpse	r24, r1
    3d40:	01 c0       	rjmp	.+2      	; 0x3d44 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3d42:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d44:	89 2f       	mov	r24, r25
    3d46:	0f 91       	pop	r16
    3d48:	08 95       	ret

00003d4a <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3d4a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3d4c:	fc 01       	movw	r30, r24
    3d4e:	26 81       	ldd	r18, Z+6	; 0x06
    3d50:	37 81       	ldd	r19, Z+7	; 0x07
    3d52:	40 85       	ldd	r20, Z+8	; 0x08
    3d54:	51 85       	ldd	r21, Z+9	; 0x09
    3d56:	00 e0       	ldi	r16, 0x00	; 0
    3d58:	84 81       	ldd	r24, Z+4	; 0x04
    3d5a:	95 81       	ldd	r25, Z+5	; 0x05
    3d5c:	0e 94 47 0c 	call	0x188e	; 0x188e <xQueueGenericSend>
    3d60:	91 e0       	ldi	r25, 0x01	; 1
    3d62:	81 11       	cpse	r24, r1
    3d64:	01 c0       	rjmp	.+2      	; 0x3d68 <_ZN9frt_queueIjE3putERKj+0x1e>
    3d66:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d68:	89 2f       	mov	r24, r25
    3d6a:	0f 91       	pop	r16
    3d6c:	08 95       	ret

00003d6e <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3d6e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3d70:	fc 01       	movw	r30, r24
    3d72:	26 81       	ldd	r18, Z+6	; 0x06
    3d74:	37 81       	ldd	r19, Z+7	; 0x07
    3d76:	40 85       	ldd	r20, Z+8	; 0x08
    3d78:	51 85       	ldd	r21, Z+9	; 0x09
    3d7a:	01 e0       	ldi	r16, 0x01	; 1
    3d7c:	84 81       	ldd	r24, Z+4	; 0x04
    3d7e:	95 81       	ldd	r25, Z+5	; 0x05
    3d80:	0e 94 47 0c 	call	0x188e	; 0x188e <xQueueGenericSend>
    3d84:	91 e0       	ldi	r25, 0x01	; 1
    3d86:	81 11       	cpse	r24, r1
    3d88:	01 c0       	rjmp	.+2      	; 0x3d8c <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d8c:	89 2f       	mov	r24, r25
    3d8e:	0f 91       	pop	r16
    3d90:	08 95       	ret

00003d92 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3d92:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3d94:	fc 01       	movw	r30, r24
    3d96:	26 81       	ldd	r18, Z+6	; 0x06
    3d98:	37 81       	ldd	r19, Z+7	; 0x07
    3d9a:	40 85       	ldd	r20, Z+8	; 0x08
    3d9c:	51 85       	ldd	r21, Z+9	; 0x09
    3d9e:	00 e0       	ldi	r16, 0x00	; 0
    3da0:	84 81       	ldd	r24, Z+4	; 0x04
    3da2:	95 81       	ldd	r25, Z+5	; 0x05
    3da4:	0e 94 47 0c 	call	0x188e	; 0x188e <xQueueGenericSend>
    3da8:	91 e0       	ldi	r25, 0x01	; 1
    3daa:	81 11       	cpse	r24, r1
    3dac:	01 c0       	rjmp	.+2      	; 0x3db0 <_ZN9frt_queueIiE3putERKi+0x1e>
    3dae:	90 e0       	ldi	r25, 0x00	; 0
		}
    3db0:	89 2f       	mov	r24, r25
    3db2:	0f 91       	pop	r16
    3db4:	08 95       	ret

00003db6 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3db6:	0f 93       	push	r16
    3db8:	cf 93       	push	r28
    3dba:	df 93       	push	r29
    3dbc:	1f 92       	push	r1
    3dbe:	cd b7       	in	r28, 0x3d	; 61
    3dc0:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3dc2:	2f b7       	in	r18, 0x3f	; 63
    3dc4:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3dc6:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3dc8:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3dca:	fc 01       	movw	r30, r24
    3dcc:	08 ed       	ldi	r16, 0xD8	; 216
    3dce:	04 bf       	out	0x34, r16	; 52
    3dd0:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3dd2:	89 81       	ldd	r24, Y+1	; 0x01
    3dd4:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3dd6:	0f 90       	pop	r0
    3dd8:	df 91       	pop	r29
    3dda:	cf 91       	pop	r28
    3ddc:	0f 91       	pop	r16
    3dde:	08 95       	ret

00003de0 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3de0:	ef 92       	push	r14
    3de2:	ff 92       	push	r15
    3de4:	0f 93       	push	r16
    3de6:	1f 93       	push	r17
    3de8:	cf 93       	push	r28
    3dea:	df 93       	push	r29
    3dec:	cd b7       	in	r28, 0x3d	; 61
    3dee:	de b7       	in	r29, 0x3e	; 62
    3df0:	ef 97       	sbiw	r28, 0x3f	; 63
    3df2:	cd bf       	out	0x3d, r28	; 61
    3df4:	de bf       	out	0x3e, r29	; 62
	cli();
    3df6:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3df8:	e0 e5       	ldi	r30, 0x50	; 80
    3dfa:	f0 e0       	ldi	r31, 0x00	; 0
    3dfc:	80 81       	ld	r24, Z
    3dfe:	82 60       	ori	r24, 0x02	; 2
    3e00:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3e02:	81 81       	ldd	r24, Z+1	; 0x01
    3e04:	81 ff       	sbrs	r24, 1
    3e06:	fd cf       	rjmp	.-6      	; 0x3e02 <main+0x22>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3e08:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3e0c:	68 7f       	andi	r22, 0xF8	; 248
    3e0e:	61 60       	ori	r22, 0x01	; 1
    3e10:	80 e4       	ldi	r24, 0x40	; 64
    3e12:	90 e0       	ldi	r25, 0x00	; 0
    3e14:	0e 94 db 1e 	call	0x3db6	; 0x3db6 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3e18:	e0 e5       	ldi	r30, 0x50	; 80
    3e1a:	f0 e0       	ldi	r31, 0x00	; 0
    3e1c:	80 81       	ld	r24, Z
    3e1e:	8e 7f       	andi	r24, 0xFE	; 254
    3e20:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3e22:	9d ef       	ldi	r25, 0xFD	; 253
    3e24:	88 ed       	ldi	r24, 0xD8	; 216
    3e26:	08 b6       	in	r0, 0x38	; 56
    3e28:	18 be       	out	0x38, r1	; 56
    3e2a:	84 bf       	out	0x34, r24	; 52
    3e2c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3e30:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3e32:	40 ea       	ldi	r20, 0xA0	; 160
    3e34:	5a e0       	ldi	r21, 0x0A	; 10
    3e36:	60 e0       	ldi	r22, 0x00	; 0
    3e38:	70 e0       	ldi	r23, 0x00	; 0
    3e3a:	ce 01       	movw	r24, r28
    3e3c:	01 96       	adiw	r24, 0x01	; 1
    3e3e:	0e 94 7f 1a 	call	0x34fe	; 0x34fe <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3e42:	67 e0       	ldi	r22, 0x07	; 7
    3e44:	ce 01       	movw	r24, r28
    3e46:	01 96       	adiw	r24, 0x01	; 1
    3e48:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    3e4c:	8c 01       	movw	r16, r24
    3e4e:	6b e6       	ldi	r22, 0x6B	; 107
    3e50:	70 e2       	ldi	r23, 0x20	; 32
    3e52:	0e 94 a5 18 	call	0x314a	; 0x314a <_ZN8emstream4putsEPKc>
    3e56:	66 e0       	ldi	r22, 0x06	; 6
    3e58:	c8 01       	movw	r24, r16
    3e5a:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
    3e5e:	66 e0       	ldi	r22, 0x06	; 6
    3e60:	0e 94 dc 18 	call	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c (&TWIE, 62000);
    3e64:	20 e3       	ldi	r18, 0x30	; 48
    3e66:	32 ef       	ldi	r19, 0xF2	; 242
    3e68:	40 e0       	ldi	r20, 0x00	; 0
    3e6a:	50 e0       	ldi	r21, 0x00	; 0
    3e6c:	60 ea       	ldi	r22, 0xA0	; 160
    3e6e:	74 e0       	ldi	r23, 0x04	; 4
    3e70:	ce 01       	movw	r24, r28
    3e72:	4e 96       	adiw	r24, 0x1e	; 30
    3e74:	0e 94 c3 03 	call	0x786	; 0x786 <_ZN9I2CMasterC1EP10TWI_structm>
	
	MB1202 mb1202 (&i2c);
    3e78:	be 01       	movw	r22, r28
    3e7a:	62 5e       	subi	r22, 0xE2	; 226
    3e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    3e7e:	ce 01       	movw	r24, r28
    3e80:	c3 96       	adiw	r24, 0x33	; 51
    3e82:	0e 94 19 05 	call	0xa32	; 0xa32 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3e86:	82 e1       	ldi	r24, 0x12	; 18
    3e88:	90 e0       	ldi	r25, 0x00	; 0
    3e8a:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
    3e8e:	8e 01       	movw	r16, r28
    3e90:	0f 5f       	subi	r16, 0xFF	; 255
    3e92:	1f 4f       	sbci	r17, 0xFF	; 255
    3e94:	20 e8       	ldi	r18, 0x80	; 128
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	40 e0       	ldi	r20, 0x00	; 0
    3e9a:	6a e8       	ldi	r22, 0x8A	; 138
    3e9c:	70 e2       	ldi	r23, 0x20	; 32
    3e9e:	0e 94 c3 05 	call	0xb86	; 0xb86 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    3ea2:	88 e1       	ldi	r24, 0x18	; 24
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	0e 94 f1 17 	call	0x2fe2	; 0x2fe2 <_Znwj>
    3eaa:	9e 01       	movw	r18, r28
    3eac:	2d 5c       	subi	r18, 0xCD	; 205
    3eae:	3f 4f       	sbci	r19, 0xFF	; 255
    3eb0:	79 01       	movw	r14, r18
    3eb2:	20 e8       	ldi	r18, 0x80	; 128
    3eb4:	30 e0       	ldi	r19, 0x00	; 0
    3eb6:	42 e0       	ldi	r20, 0x02	; 2
    3eb8:	62 e9       	ldi	r22, 0x92	; 146
    3eba:	70 e2       	ldi	r23, 0x20	; 32
    3ebc:	0e 94 a6 05 	call	0xb4c	; 0xb4c <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3ec0:	87 e0       	ldi	r24, 0x07	; 7
    3ec2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3ec6:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3ec8:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <vTaskStartScheduler>
}
    3ecc:	80 e0       	ldi	r24, 0x00	; 0
    3ece:	90 e0       	ldi	r25, 0x00	; 0
    3ed0:	ef 96       	adiw	r28, 0x3f	; 63
    3ed2:	cd bf       	out	0x3d, r28	; 61
    3ed4:	de bf       	out	0x3e, r29	; 62
    3ed6:	df 91       	pop	r29
    3ed8:	cf 91       	pop	r28
    3eda:	1f 91       	pop	r17
    3edc:	0f 91       	pop	r16
    3ede:	ff 90       	pop	r15
    3ee0:	ef 90       	pop	r14
    3ee2:	08 95       	ret

00003ee4 <_GLOBAL__sub_I_counter>:
    3ee4:	cf 92       	push	r12
    3ee6:	df 92       	push	r13
    3ee8:	ef 92       	push	r14
    3eea:	ff 92       	push	r15
    3eec:	0f 93       	push	r16
    3eee:	1f 93       	push	r17
    3ef0:	cf 93       	push	r28
    3ef2:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3ef4:	0a e0       	ldi	r16, 0x0A	; 10
    3ef6:	10 e0       	ldi	r17, 0x00	; 0
    3ef8:	20 e0       	ldi	r18, 0x00	; 0
    3efa:	30 e0       	ldi	r19, 0x00	; 0
    3efc:	40 e0       	ldi	r20, 0x00	; 0
    3efe:	50 e0       	ldi	r21, 0x00	; 0
    3f00:	60 e2       	ldi	r22, 0x20	; 32
    3f02:	70 e0       	ldi	r23, 0x00	; 0
    3f04:	8c e9       	ldi	r24, 0x9C	; 156
    3f06:	91 e3       	ldi	r25, 0x31	; 49
    3f08:	0e 94 5d 16 	call	0x2cba	; 0x2cba <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3f0c:	c2 e9       	ldi	r28, 0x92	; 146
    3f0e:	d1 e3       	ldi	r29, 0x31	; 49
    3f10:	1a 82       	std	Y+2, r1	; 0x02
    3f12:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f14:	8c e9       	ldi	r24, 0x9C	; 156
    3f16:	90 e2       	ldi	r25, 0x20	; 32
    3f18:	88 83       	st	Y, r24
    3f1a:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f1c:	40 e0       	ldi	r20, 0x00	; 0
    3f1e:	62 e0       	ldi	r22, 0x02	; 2
    3f20:	8f ef       	ldi	r24, 0xFF	; 255
    3f22:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    3f26:	8c 83       	std	Y+4, r24	; 0x04
    3f28:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f2a:	0f 2e       	mov	r0, r31
    3f2c:	fa e0       	ldi	r31, 0x0A	; 10
    3f2e:	cf 2e       	mov	r12, r31
    3f30:	d1 2c       	mov	r13, r1
    3f32:	e1 2c       	mov	r14, r1
    3f34:	f1 2c       	mov	r15, r1
    3f36:	f0 2d       	mov	r31, r0
    3f38:	ce 82       	std	Y+6, r12	; 0x06
    3f3a:	df 82       	std	Y+7, r13	; 0x07
    3f3c:	e8 86       	std	Y+8, r14	; 0x08
    3f3e:	f9 86       	std	Y+9, r15	; 0x09
    3f40:	c8 e8       	ldi	r28, 0x88	; 136
    3f42:	d1 e3       	ldi	r29, 0x31	; 49
    3f44:	1a 82       	std	Y+2, r1	; 0x02
    3f46:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f48:	00 ec       	ldi	r16, 0xC0	; 192
    3f4a:	10 e2       	ldi	r17, 0x20	; 32
    3f4c:	08 83       	st	Y, r16
    3f4e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f50:	40 e0       	ldi	r20, 0x00	; 0
    3f52:	62 e0       	ldi	r22, 0x02	; 2
    3f54:	8f ef       	ldi	r24, 0xFF	; 255
    3f56:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    3f5a:	8c 83       	std	Y+4, r24	; 0x04
    3f5c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f5e:	ce 82       	std	Y+6, r12	; 0x06
    3f60:	df 82       	std	Y+7, r13	; 0x07
    3f62:	e8 86       	std	Y+8, r14	; 0x08
    3f64:	f9 86       	std	Y+9, r15	; 0x09
    3f66:	ce e7       	ldi	r28, 0x7E	; 126
    3f68:	d1 e3       	ldi	r29, 0x31	; 49
    3f6a:	1a 82       	std	Y+2, r1	; 0x02
    3f6c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f6e:	08 83       	st	Y, r16
    3f70:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f72:	40 e0       	ldi	r20, 0x00	; 0
    3f74:	62 e0       	ldi	r22, 0x02	; 2
    3f76:	8f ef       	ldi	r24, 0xFF	; 255
    3f78:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    3f7c:	8c 83       	std	Y+4, r24	; 0x04
    3f7e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f80:	ce 82       	std	Y+6, r12	; 0x06
    3f82:	df 82       	std	Y+7, r13	; 0x07
    3f84:	e8 86       	std	Y+8, r14	; 0x08
    3f86:	f9 86       	std	Y+9, r15	; 0x09
    3f88:	c4 e7       	ldi	r28, 0x74	; 116
    3f8a:	d1 e3       	ldi	r29, 0x31	; 49
    3f8c:	1a 82       	std	Y+2, r1	; 0x02
    3f8e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f90:	08 83       	st	Y, r16
    3f92:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f94:	40 e0       	ldi	r20, 0x00	; 0
    3f96:	62 e0       	ldi	r22, 0x02	; 2
    3f98:	8f ef       	ldi	r24, 0xFF	; 255
    3f9a:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    3f9e:	8c 83       	std	Y+4, r24	; 0x04
    3fa0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3fa2:	ce 82       	std	Y+6, r12	; 0x06
    3fa4:	df 82       	std	Y+7, r13	; 0x07
    3fa6:	e8 86       	std	Y+8, r14	; 0x08
    3fa8:	f9 86       	std	Y+9, r15	; 0x09
    3faa:	ca e6       	ldi	r28, 0x6A	; 106
    3fac:	d1 e3       	ldi	r29, 0x31	; 49
    3fae:	1a 82       	std	Y+2, r1	; 0x02
    3fb0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3fb2:	08 83       	st	Y, r16
    3fb4:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3fb6:	40 e0       	ldi	r20, 0x00	; 0
    3fb8:	62 e0       	ldi	r22, 0x02	; 2
    3fba:	8f ef       	ldi	r24, 0xFF	; 255
    3fbc:	0e 94 19 0c 	call	0x1832	; 0x1832 <xQueueGenericCreate>
    3fc0:	8c 83       	std	Y+4, r24	; 0x04
    3fc2:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3fc4:	ce 82       	std	Y+6, r12	; 0x06
    3fc6:	df 82       	std	Y+7, r13	; 0x07
    3fc8:	e8 86       	std	Y+8, r14	; 0x08
    3fca:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3fcc:	df 91       	pop	r29
    3fce:	cf 91       	pop	r28
    3fd0:	1f 91       	pop	r17
    3fd2:	0f 91       	pop	r16
    3fd4:	ff 90       	pop	r15
    3fd6:	ef 90       	pop	r14
    3fd8:	df 90       	pop	r13
    3fda:	cf 90       	pop	r12
    3fdc:	08 95       	ret

00003fde <__mulsi3>:
    3fde:	db 01       	movw	r26, r22
    3fe0:	8f 93       	push	r24
    3fe2:	9f 93       	push	r25
    3fe4:	0e 94 49 20 	call	0x4092	; 0x4092 <__muluhisi3>
    3fe8:	bf 91       	pop	r27
    3fea:	af 91       	pop	r26
    3fec:	a2 9f       	mul	r26, r18
    3fee:	80 0d       	add	r24, r0
    3ff0:	91 1d       	adc	r25, r1
    3ff2:	a3 9f       	mul	r26, r19
    3ff4:	90 0d       	add	r25, r0
    3ff6:	b2 9f       	mul	r27, r18
    3ff8:	90 0d       	add	r25, r0
    3ffa:	11 24       	eor	r1, r1
    3ffc:	08 95       	ret

00003ffe <__udivmodsi4>:
    3ffe:	a1 e2       	ldi	r26, 0x21	; 33
    4000:	1a 2e       	mov	r1, r26
    4002:	aa 1b       	sub	r26, r26
    4004:	bb 1b       	sub	r27, r27
    4006:	fd 01       	movw	r30, r26
    4008:	0d c0       	rjmp	.+26     	; 0x4024 <__udivmodsi4_ep>

0000400a <__udivmodsi4_loop>:
    400a:	aa 1f       	adc	r26, r26
    400c:	bb 1f       	adc	r27, r27
    400e:	ee 1f       	adc	r30, r30
    4010:	ff 1f       	adc	r31, r31
    4012:	a2 17       	cp	r26, r18
    4014:	b3 07       	cpc	r27, r19
    4016:	e4 07       	cpc	r30, r20
    4018:	f5 07       	cpc	r31, r21
    401a:	20 f0       	brcs	.+8      	; 0x4024 <__udivmodsi4_ep>
    401c:	a2 1b       	sub	r26, r18
    401e:	b3 0b       	sbc	r27, r19
    4020:	e4 0b       	sbc	r30, r20
    4022:	f5 0b       	sbc	r31, r21

00004024 <__udivmodsi4_ep>:
    4024:	66 1f       	adc	r22, r22
    4026:	77 1f       	adc	r23, r23
    4028:	88 1f       	adc	r24, r24
    402a:	99 1f       	adc	r25, r25
    402c:	1a 94       	dec	r1
    402e:	69 f7       	brne	.-38     	; 0x400a <__udivmodsi4_loop>
    4030:	60 95       	com	r22
    4032:	70 95       	com	r23
    4034:	80 95       	com	r24
    4036:	90 95       	com	r25
    4038:	9b 01       	movw	r18, r22
    403a:	ac 01       	movw	r20, r24
    403c:	bd 01       	movw	r22, r26
    403e:	cf 01       	movw	r24, r30
    4040:	08 95       	ret

00004042 <__divmodsi4>:
    4042:	05 2e       	mov	r0, r21
    4044:	97 fb       	bst	r25, 7
    4046:	1e f4       	brtc	.+6      	; 0x404e <__divmodsi4+0xc>
    4048:	00 94       	com	r0
    404a:	0e 94 38 20 	call	0x4070	; 0x4070 <__negsi2>
    404e:	57 fd       	sbrc	r21, 7
    4050:	07 d0       	rcall	.+14     	; 0x4060 <__divmodsi4_neg2>
    4052:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__udivmodsi4>
    4056:	07 fc       	sbrc	r0, 7
    4058:	03 d0       	rcall	.+6      	; 0x4060 <__divmodsi4_neg2>
    405a:	4e f4       	brtc	.+18     	; 0x406e <__divmodsi4_exit>
    405c:	0c 94 38 20 	jmp	0x4070	; 0x4070 <__negsi2>

00004060 <__divmodsi4_neg2>:
    4060:	50 95       	com	r21
    4062:	40 95       	com	r20
    4064:	30 95       	com	r19
    4066:	21 95       	neg	r18
    4068:	3f 4f       	sbci	r19, 0xFF	; 255
    406a:	4f 4f       	sbci	r20, 0xFF	; 255
    406c:	5f 4f       	sbci	r21, 0xFF	; 255

0000406e <__divmodsi4_exit>:
    406e:	08 95       	ret

00004070 <__negsi2>:
    4070:	90 95       	com	r25
    4072:	80 95       	com	r24
    4074:	70 95       	com	r23
    4076:	61 95       	neg	r22
    4078:	7f 4f       	sbci	r23, 0xFF	; 255
    407a:	8f 4f       	sbci	r24, 0xFF	; 255
    407c:	9f 4f       	sbci	r25, 0xFF	; 255
    407e:	08 95       	ret

00004080 <__tablejump2__>:
    4080:	ee 0f       	add	r30, r30
    4082:	ff 1f       	adc	r31, r31
    4084:	88 1f       	adc	r24, r24
    4086:	8b bf       	out	0x3b, r24	; 59
    4088:	07 90       	elpm	r0, Z+
    408a:	f6 91       	elpm	r31, Z
    408c:	e0 2d       	mov	r30, r0
    408e:	1b be       	out	0x3b, r1	; 59
    4090:	19 94       	eijmp

00004092 <__muluhisi3>:
    4092:	0e 94 54 20 	call	0x40a8	; 0x40a8 <__umulhisi3>
    4096:	a5 9f       	mul	r26, r21
    4098:	90 0d       	add	r25, r0
    409a:	b4 9f       	mul	r27, r20
    409c:	90 0d       	add	r25, r0
    409e:	a4 9f       	mul	r26, r20
    40a0:	80 0d       	add	r24, r0
    40a2:	91 1d       	adc	r25, r1
    40a4:	11 24       	eor	r1, r1
    40a6:	08 95       	ret

000040a8 <__umulhisi3>:
    40a8:	a2 9f       	mul	r26, r18
    40aa:	b0 01       	movw	r22, r0
    40ac:	b3 9f       	mul	r27, r19
    40ae:	c0 01       	movw	r24, r0
    40b0:	a3 9f       	mul	r26, r19
    40b2:	70 0d       	add	r23, r0
    40b4:	81 1d       	adc	r24, r1
    40b6:	11 24       	eor	r1, r1
    40b8:	91 1d       	adc	r25, r1
    40ba:	b2 9f       	mul	r27, r18
    40bc:	70 0d       	add	r23, r0
    40be:	81 1d       	adc	r24, r1
    40c0:	11 24       	eor	r1, r1
    40c2:	91 1d       	adc	r25, r1
    40c4:	08 95       	ret

000040c6 <memcpy>:
    40c6:	fb 01       	movw	r30, r22
    40c8:	dc 01       	movw	r26, r24
    40ca:	02 c0       	rjmp	.+4      	; 0x40d0 <memcpy+0xa>
    40cc:	01 90       	ld	r0, Z+
    40ce:	0d 92       	st	X+, r0
    40d0:	41 50       	subi	r20, 0x01	; 1
    40d2:	50 40       	sbci	r21, 0x00	; 0
    40d4:	d8 f7       	brcc	.-10     	; 0x40cc <memcpy+0x6>
    40d6:	08 95       	ret

000040d8 <memset>:
    40d8:	dc 01       	movw	r26, r24
    40da:	01 c0       	rjmp	.+2      	; 0x40de <memset+0x6>
    40dc:	6d 93       	st	X+, r22
    40de:	41 50       	subi	r20, 0x01	; 1
    40e0:	50 40       	sbci	r21, 0x00	; 0
    40e2:	e0 f7       	brcc	.-8      	; 0x40dc <memset+0x4>
    40e4:	08 95       	ret

000040e6 <strncpy>:
    40e6:	fb 01       	movw	r30, r22
    40e8:	dc 01       	movw	r26, r24
    40ea:	41 50       	subi	r20, 0x01	; 1
    40ec:	50 40       	sbci	r21, 0x00	; 0
    40ee:	48 f0       	brcs	.+18     	; 0x4102 <strncpy+0x1c>
    40f0:	01 90       	ld	r0, Z+
    40f2:	0d 92       	st	X+, r0
    40f4:	00 20       	and	r0, r0
    40f6:	c9 f7       	brne	.-14     	; 0x40ea <strncpy+0x4>
    40f8:	01 c0       	rjmp	.+2      	; 0x40fc <strncpy+0x16>
    40fa:	1d 92       	st	X+, r1
    40fc:	41 50       	subi	r20, 0x01	; 1
    40fe:	50 40       	sbci	r21, 0x00	; 0
    4100:	e0 f7       	brcc	.-8      	; 0x40fa <strncpy+0x14>
    4102:	08 95       	ret

00004104 <ultoa>:
    4104:	25 32       	cpi	r18, 0x25	; 37
    4106:	31 05       	cpc	r19, r1
    4108:	20 f4       	brcc	.+8      	; 0x4112 <ultoa+0xe>
    410a:	22 30       	cpi	r18, 0x02	; 2
    410c:	10 f0       	brcs	.+4      	; 0x4112 <ultoa+0xe>
    410e:	0c 94 8d 20 	jmp	0x411a	; 0x411a <__ultoa_ncheck>
    4112:	fa 01       	movw	r30, r20
    4114:	10 82       	st	Z, r1
    4116:	ca 01       	movw	r24, r20
    4118:	08 95       	ret

0000411a <__ultoa_ncheck>:
    411a:	bb 27       	eor	r27, r27

0000411c <__ultoa_common>:
    411c:	fa 01       	movw	r30, r20
    411e:	a6 2f       	mov	r26, r22
    4120:	62 17       	cp	r22, r18
    4122:	71 05       	cpc	r23, r1
    4124:	81 05       	cpc	r24, r1
    4126:	91 05       	cpc	r25, r1
    4128:	33 0b       	sbc	r19, r19
    412a:	30 fb       	bst	r19, 0
    412c:	66 f0       	brts	.+24     	; 0x4146 <__ultoa_common+0x2a>
    412e:	aa 27       	eor	r26, r26
    4130:	66 0f       	add	r22, r22
    4132:	77 1f       	adc	r23, r23
    4134:	88 1f       	adc	r24, r24
    4136:	99 1f       	adc	r25, r25
    4138:	aa 1f       	adc	r26, r26
    413a:	a2 17       	cp	r26, r18
    413c:	10 f0       	brcs	.+4      	; 0x4142 <__ultoa_common+0x26>
    413e:	a2 1b       	sub	r26, r18
    4140:	63 95       	inc	r22
    4142:	38 50       	subi	r19, 0x08	; 8
    4144:	a9 f7       	brne	.-22     	; 0x4130 <__ultoa_common+0x14>
    4146:	a0 5d       	subi	r26, 0xD0	; 208
    4148:	aa 33       	cpi	r26, 0x3A	; 58
    414a:	08 f0       	brcs	.+2      	; 0x414e <__ultoa_common+0x32>
    414c:	a9 5d       	subi	r26, 0xD9	; 217
    414e:	a1 93       	st	Z+, r26
    4150:	36 f7       	brtc	.-52     	; 0x411e <__ultoa_common+0x2>
    4152:	b1 11       	cpse	r27, r1
    4154:	b1 93       	st	Z+, r27
    4156:	10 82       	st	Z, r1
    4158:	ca 01       	movw	r24, r20
    415a:	0c 94 d4 20 	jmp	0x41a8	; 0x41a8 <strrev>

0000415e <utoa>:
    415e:	45 32       	cpi	r20, 0x25	; 37
    4160:	51 05       	cpc	r21, r1
    4162:	20 f4       	brcc	.+8      	; 0x416c <utoa+0xe>
    4164:	42 30       	cpi	r20, 0x02	; 2
    4166:	10 f0       	brcs	.+4      	; 0x416c <utoa+0xe>
    4168:	0c 94 ba 20 	jmp	0x4174	; 0x4174 <__utoa_ncheck>
    416c:	fb 01       	movw	r30, r22
    416e:	10 82       	st	Z, r1
    4170:	cb 01       	movw	r24, r22
    4172:	08 95       	ret

00004174 <__utoa_ncheck>:
    4174:	bb 27       	eor	r27, r27

00004176 <__utoa_common>:
    4176:	fb 01       	movw	r30, r22
    4178:	55 27       	eor	r21, r21
    417a:	aa 27       	eor	r26, r26
    417c:	88 0f       	add	r24, r24
    417e:	99 1f       	adc	r25, r25
    4180:	aa 1f       	adc	r26, r26
    4182:	a4 17       	cp	r26, r20
    4184:	10 f0       	brcs	.+4      	; 0x418a <__utoa_common+0x14>
    4186:	a4 1b       	sub	r26, r20
    4188:	83 95       	inc	r24
    418a:	50 51       	subi	r21, 0x10	; 16
    418c:	b9 f7       	brne	.-18     	; 0x417c <__utoa_common+0x6>
    418e:	a0 5d       	subi	r26, 0xD0	; 208
    4190:	aa 33       	cpi	r26, 0x3A	; 58
    4192:	08 f0       	brcs	.+2      	; 0x4196 <__utoa_common+0x20>
    4194:	a9 5d       	subi	r26, 0xD9	; 217
    4196:	a1 93       	st	Z+, r26
    4198:	00 97       	sbiw	r24, 0x00	; 0
    419a:	79 f7       	brne	.-34     	; 0x417a <__utoa_common+0x4>
    419c:	b1 11       	cpse	r27, r1
    419e:	b1 93       	st	Z+, r27
    41a0:	11 92       	st	Z+, r1
    41a2:	cb 01       	movw	r24, r22
    41a4:	0c 94 d4 20 	jmp	0x41a8	; 0x41a8 <strrev>

000041a8 <strrev>:
    41a8:	dc 01       	movw	r26, r24
    41aa:	fc 01       	movw	r30, r24
    41ac:	67 2f       	mov	r22, r23
    41ae:	71 91       	ld	r23, Z+
    41b0:	77 23       	and	r23, r23
    41b2:	e1 f7       	brne	.-8      	; 0x41ac <strrev+0x4>
    41b4:	32 97       	sbiw	r30, 0x02	; 2
    41b6:	04 c0       	rjmp	.+8      	; 0x41c0 <strrev+0x18>
    41b8:	7c 91       	ld	r23, X
    41ba:	6d 93       	st	X+, r22
    41bc:	70 83       	st	Z, r23
    41be:	62 91       	ld	r22, -Z
    41c0:	ae 17       	cp	r26, r30
    41c2:	bf 07       	cpc	r27, r31
    41c4:	c8 f3       	brcs	.-14     	; 0x41b8 <strrev+0x10>
    41c6:	08 95       	ret

000041c8 <_exit>:
    41c8:	f8 94       	cli

000041ca <__stop_program>:
    41ca:	ff cf       	rjmp	.-2      	; 0x41ca <__stop_program>
