
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000042ee  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000f2  00802000  000042ee  00004382  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020f2  008020f2  00004474  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004474  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000044a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000818  00000000  00000000  000044e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001322e  00000000  00000000  00004cfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000608c  00000000  00000000  00017f2a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005392  00000000  00000000  0001dfb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000017b0  00000000  00000000  00023348  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006117  00000000  00000000  00024af8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007488  00000000  00000000  0002ac0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000758  00000000  00000000  00032097  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f3 02 	jmp	0x5e6	; 0x5e6 <__ctors_end>
       4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
       8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
       c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      10:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      14:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      18:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      1c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      20:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      24:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      28:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      2c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      30:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      34:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      38:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      3c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      40:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      44:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      48:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      4c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      50:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      54:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      58:	0c 94 bb 0b 	jmp	0x1776	; 0x1776 <__vector_22>
      5c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      60:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      64:	0c 94 90 1b 	jmp	0x3720	; 0x3720 <__vector_25>
      68:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      6c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      70:	0c 94 ee 1b 	jmp	0x37dc	; 0x37dc <__vector_28>
      74:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      78:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      7c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      80:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      84:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      88:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      8c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      90:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      94:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      98:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      9c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      a0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      a4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      a8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      ac:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      b0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      b4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      b8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      bc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      c0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      c4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      c8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      cc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      d0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      d4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      d8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      dc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      e0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      e4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      e8:	0c 94 08 1d 	jmp	0x3a10	; 0x3a10 <__vector_58>
      ec:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      f0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      f4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      f8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
      fc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     100:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     104:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     108:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     10c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     110:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     114:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     118:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     11c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     120:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     124:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     128:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     12c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     130:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     134:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     138:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     13c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     140:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     144:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     148:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     14c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     150:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     154:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     158:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     15c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     160:	0c 94 4c 1c 	jmp	0x3898	; 0x3898 <__vector_88>
     164:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     168:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     16c:	0c 94 aa 1c 	jmp	0x3954	; 0x3954 <__vector_91>
     170:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     174:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     178:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     17c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     180:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     184:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     188:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     18c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     190:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     194:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     198:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     19c:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1a0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1a4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1a8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1ac:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1b0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1b4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1b8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1bc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1c0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1c4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1c8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1cc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1d0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1d4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1d8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1dc:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1e0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1e4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1e8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1ec:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1f0:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1f4:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1f8:	0c 94 29 03 	jmp	0x652	; 0x652 <__bad_interrupt>
     1fc:	7c 19       	sub	r23, r12
     1fe:	7f 19       	sub	r23, r15
     200:	82 19       	sub	r24, r2
     202:	85 19       	sub	r24, r5
     204:	88 19       	sub	r24, r8
     206:	8b 19       	sub	r24, r11
     208:	8d 19       	sub	r24, r13
     20a:	9e 19       	sub	r25, r14
     20c:	a6 19       	sub	r26, r6
     20e:	b0 19       	sub	r27, r0
     210:	ae 19       	sub	r26, r14

00000212 <__trampolines_start>:
     212:	0c 94 9b 0e 	jmp	0x1d36	; 0x1d36 <prvIdleTask>
     216:	0c 94 6d 1d 	jmp	0x3ada	; 0x3ada <_ZN9frt_queueIjE13ISR_not_emptyEv>
     21a:	0c 94 24 19 	jmp	0x3248	; 0x3248 <_ZN8emstream14check_for_charEv>
     21e:	0c 94 ce 1a 	jmp	0x359c	; 0x359c <_ZN5rs2327getcharEv>
     222:	0c 94 cc 1d 	jmp	0x3b98	; 0x3b98 <_ZN9frt_queueIiE8is_emptyEv>
     226:	0c 94 36 1f 	jmp	0x3e6c	; 0x3e6c <_ZN9frt_queueIjE3putERKj>
     22a:	0c 94 66 1d 	jmp	0x3acc	; 0x3acc <_ZN9frt_queueIjE16ISR_num_items_inEv>
     22e:	0c 94 8d 19 	jmp	0x331a	; 0x331a <_ZN8emstreamlsE15ser_manipulator+0x40>
     232:	0c 94 85 19 	jmp	0x330a	; 0x330a <_ZN8emstreamlsE15ser_manipulator+0x30>
     236:	0c 94 94 1d 	jmp	0x3b28	; 0x3b28 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     23a:	0c 94 4b 1e 	jmp	0x3c96	; 0x3c96 <_ZN9frt_queueIiE3getEPi>
     23e:	0c 94 b0 03 	jmp	0x760	; 0x760 <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>
     242:	0c 94 88 19 	jmp	0x3310	; 0x3310 <_ZN8emstreamlsE15ser_manipulator+0x36>
     246:	0c 94 97 07 	jmp	0xf2e	; 0xf2e <_ZN9task_user3runEv>
     24a:	0c 94 82 19 	jmp	0x3304	; 0x3304 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     24e:	0c 94 ac 1e 	jmp	0x3d58	; 0x3d58 <_ZN9frt_queueIiE7ISR_getEv>
     252:	0c 94 f4 1e 	jmp	0x3de8	; 0x3de8 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     256:	0c 94 7f 19 	jmp	0x32fe	; 0x32fe <_ZN8emstreamlsE15ser_manipulator+0x24>
     25a:	0c 94 f4 1a 	jmp	0x35e8	; 0x35e8 <_ZN5rs23214check_for_charEv>
     25e:	0c 94 a7 16 	jmp	0x2d4e	; 0x2d4e <_ZN14frt_text_queue7getcharEv>
     262:	0c 94 07 1b 	jmp	0x360e	; 0x360e <_ZN5rs23212clear_screenEv>
     266:	0c 94 89 1d 	jmp	0x3b12	; 0x3b12 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     26a:	0c 94 57 1e 	jmp	0x3cae	; 0x3cae <_ZN9frt_queueIiE3getEv>
     26e:	0c 94 0c 1f 	jmp	0x3e18	; 0x3e18 <_ZN9frt_queueIiE7ISR_putERKi>
     272:	0c 94 b4 03 	jmp	0x768	; 0x768 <_ZN9I2CMaster11Transmitter10ErrorState7executeER9frt_queueIhE>
     276:	0c 94 c4 1e 	jmp	0x3d88	; 0x3d88 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     27a:	0c 94 9e 19 	jmp	0x333c	; 0x333c <_ZN8emstreamlsE15ser_manipulator+0x62>
     27e:	0c 94 f0 02 	jmp	0x5e0	; 0x5e0 <_call_static_run_method>
     282:	0c 94 8b 19 	jmp	0x3316	; 0x3316 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     286:	0c 94 b0 19 	jmp	0x3360	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
     28a:	0c 94 27 19 	jmp	0x324e	; 0x324e <_ZN8emstream12clear_screenEv>
     28e:	0c 94 5a 1f 	jmp	0x3eb4	; 0x3eb4 <_ZN9frt_queueIiE3putERKi>
     292:	0c 94 83 1e 	jmp	0x3d06	; 0x3d06 <_ZN9frt_queueIjE7ISR_getEv>
     296:	0c 94 09 1e 	jmp	0x3c12	; 0x3c12 <_ZN9frt_queueIjE3getEv>
     29a:	0c 94 43 03 	jmp	0x686	; 0x686 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>
     29e:	0c 94 72 1e 	jmp	0x3ce4	; 0x3ce4 <_ZN9frt_queueIjE7ISR_getEPj>
     2a2:	0c 94 b0 1d 	jmp	0x3b60	; 0x3b60 <_ZN9frt_queueIjE8is_emptyEv>
     2a6:	0c 94 9d 05 	jmp	0xb3a	; 0xb3a <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     2aa:	0c 94 c5 16 	jmp	0x2d8a	; 0x2d8a <_ZN14frt_text_queue14check_for_charEv>
     2ae:	0c 94 a6 19 	jmp	0x334c	; 0x334c <_ZN8emstreamlsE15ser_manipulator+0x72>
     2b2:	0c 94 ba 1d 	jmp	0x3b74	; 0x3b74 <_ZN9frt_queueIiE12num_items_inEv>
     2b6:	0c 94 ae 19 	jmp	0x335c	; 0x335c <_ZN8emstreamlsE15ser_manipulator+0x82>
     2ba:	0c 94 e2 1d 	jmp	0x3bc4	; 0x3bc4 <_ZN9frt_queueIjE10get_a_copyEv>
     2be:	0c 94 5d 15 	jmp	0x2aba	; 0x2aba <_ZN8frt_task12print_statusER8emstream>
     2c2:	0c 94 82 1d 	jmp	0x3b04	; 0x3b04 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2c6:	0c 94 9e 1d 	jmp	0x3b3c	; 0x3b3c <_ZN9frt_queueIjE12num_items_inEv>
     2ca:	0c 94 7c 19 	jmp	0x32f8	; 0x32f8 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2ce:	0c 94 30 1e 	jmp	0x3c60	; 0x3c60 <_ZN9frt_queueIiE10get_a_copyEv>
     2d2:	0c 94 9b 03 	jmp	0x736	; 0x736 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER9frt_queueIhE>
     2d6:	0c 94 aa 1a 	jmp	0x3554	; 0x3554 <_ZN5rs2327putcharEc>
     2da:	0c 94 48 1f 	jmp	0x3e90	; 0x3e90 <_ZN9frt_queueIiE7butt_inERKi>
     2de:	0c 94 03 20 	jmp	0x4006	; 0x4006 <_GLOBAL__sub_I_counter>
     2e2:	0c 94 21 19 	jmp	0x3242	; 0x3242 <_ZN8emstream7getcharEv>
     2e6:	0c 94 d6 1d 	jmp	0x3bac	; 0x3bac <_ZN9frt_queueIjE10get_a_copyERj>
     2ea:	0c 94 a5 1d 	jmp	0x3b4a	; 0x3b4a <_ZN9frt_queueIjE9not_emptyEv>
     2ee:	0c 94 88 18 	jmp	0x3110	; 0x3110 <__cxa_pure_virtual>
     2f2:	0c 94 9b 1e 	jmp	0x3d36	; 0x3d36 <_ZN9frt_queueIiE7ISR_getEPi>
     2f6:	0c 94 dc 1e 	jmp	0x3db8	; 0x3db8 <_ZN9frt_queueIjE7ISR_putERKj>
     2fa:	0c 94 26 19 	jmp	0x324c	; 0x324c <_ZN8emstream12transmit_nowEv>
     2fe:	0c 94 f9 05 	jmp	0xbf2	; 0xbf2 <_ZN10task_sonar3runEv>
     302:	0c 94 d0 16 	jmp	0x2da0	; 0x2da0 <_ZN14frt_text_queue7putcharEc>
     306:	0c 94 c1 1d 	jmp	0x3b82	; 0x3b82 <_ZN9frt_queueIiE9not_emptyEv>
     30a:	0c 94 24 1f 	jmp	0x3e48	; 0x3e48 <_ZN9frt_queueIjE7butt_inERKj>
     30e:	0c 94 24 1e 	jmp	0x3c48	; 0x3c48 <_ZN9frt_queueIiE10get_a_copyERi>
     312:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER9frt_queueIhE>
     316:	0c 94 78 1d 	jmp	0x3af0	; 0x3af0 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     31a:	0c 94 fd 1d 	jmp	0x3bfa	; 0x3bfa <_ZN9frt_queueIjE3getEPj>
     31e:	0c 94 2b 03 	jmp	0x656	; 0x656 <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>
     322:	0c 94 1f 19 	jmp	0x323e	; 0x323e <_ZN8emstream13ready_to_sendEv>

00000326 <__trampolines_end>:
     326:	53 6f       	ori	r21, 0xF3	; 243
     328:	6e 61       	ori	r22, 0x1E	; 30
     32a:	72 3a       	cpi	r23, 0xA2	; 162
     32c:	20 00       	.word	0x0020	; ????

0000032e <_ZZN9task_user11show_statusEvE3__c_4>:
     32e:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

00000339 <_ZZN9task_user11show_statusEvE3__c_3>:
     339:	2f 00                                               /.

0000033b <_ZZN9task_user11show_statusEvE3__c_2>:
     33b:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000349 <_ZZN9task_user11show_statusEvE3__c_1>:
     349:	54 69 6d 65 3a 20 00                                Time: .

00000350 <_ZZN9task_user11show_statusEvE3__c_0>:
     350:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

0000035c <_ZZN9task_user11show_statusEvE3__c>:
     35c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     36c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000037b <_ZZN9task_user18print_help_messageEvE3__c_10>:
     37b:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000038a <_ZZN9task_user18print_help_messageEvE3__c_9>:
     38a:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     39a:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

000003a5 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     3a5:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3b5:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003c3 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3c3:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3d3:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3e3:	6d 61 74 69 6f 6e 00                                mation.

000003ea <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3ea:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3fa:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

0000040b <_ZZN9task_user18print_help_messageEvE3__c_5>:
     40b:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     41b:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000423 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     423:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     433:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

0000043f <_ZZN9task_user18print_help_messageEvE3__c_3>:
     43f:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     44f:	68 65 20 41 56 52 00                                he AVR.

00000456 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     456:	20 68 65 6c 70 00                                    help.

0000045c <_ZZN9task_user18print_help_messageEvE3__c_1>:
     45c:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     46c:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000047b <_ZZN9task_user18print_help_messageEvE3__c_0>:
     47b:	1b 5b 33 30 6d 00                                   .[30m.

00000481 <_ZZN9task_user18print_help_messageEvE3__c>:
     481:	1b 5b 34 36 6d 00                                   .[46m.

00000487 <_ZZN9task_user3runEvE3__c_3>:
     487:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     497:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

000004a4 <_ZZN9task_user3runEvE3__c_2>:
     4a4:	3a 57 54 46 3f 00                                   :WTF?.

000004aa <_ZZN9task_user3runEvE3__c_1>:
     4aa:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4ba:	65 00                                               e.

000004bc <_ZZN9task_user3runEvE3__c_0>:
     4bc:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004ca <_ZZN9task_user3runEvE3__c>:
     4ca:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4da:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004e8 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4e8:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004f2 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4f2:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

00000501 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     501:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     511:	61 73 6b 20 00                                      ask .

00000516 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     516:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000524 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     524:	20 63 72 65 61 74 65 64 00                           created.

0000052d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     52d:	54 61 73 6b 20 00                                   Task .

00000533 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     533:	1b 5b 32 32 6d 00                                   .[22m.

00000539 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     539:	54 61 73 6b 3a 20 00                                Task: .

00000540 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     540:	1b 5b 31 6d 00                                      .[1m.

00000545 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     545:	1b 5b 32 32 6d 00                                   .[22m.

0000054b <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     54b:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000556 <_ZZ17print_task_stacksP8emstreamE3__c>:
     556:	1b 5b 31 6d 00                                      .[1m.

0000055b <_ZZ15print_task_listP8emstreamE3__c_9>:
     55b:	09 09 00                                            ...

0000055e <_ZZ15print_task_listP8emstreamE3__c_8>:
     55e:	2f 00                                               /.

00000560 <_ZZ15print_task_listP8emstreamE3__c_7>:
     560:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000056b <_ZZ15print_task_listP8emstreamE3__c_6>:
     56b:	09 2d 2d 2d 2d 00                                   .----.

00000571 <_ZZ15print_task_listP8emstreamE3__c_5>:
     571:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

0000057d <_ZZ15print_task_listP8emstreamE3__c_4>:
     57d:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

0000058e <_ZZ15print_task_listP8emstreamE3__c_3>:
     58e:	09 52 75 6e 73 00                                   .Runs.

00000594 <_ZZ15print_task_listP8emstreamE3__c_2>:
     594:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

000005a0 <_ZZ15print_task_listP8emstreamE3__c_1>:
     5a0:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005b1 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5b1:	09 53 74 61 63 6b 00                                .Stack.

000005b8 <_ZZ15print_task_listP8emstreamE3__c>:
     5b8:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005c3 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5c3:	09 00                                               ..

000005c5 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5c5:	09 00                                               ..

000005c7 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5c7:	2f 00                                               /.

000005c9 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5c9:	09 00                                               ..

000005cb <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5cb:	09 00                                               ..

000005cd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5cd:	1b 5b 32 32 6d 00                                   .[22m.

000005d3 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5d3:	1b 5b 31 6d 00                                      .[1m.

000005d8 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5d8:	1b 5b 31 6d 00                                      .[1m.

000005dd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5dd:	20 20 00                                              .

000005e0 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5e0:	0e 94 f5 13 	call	0x27ea	; 0x27ea <_ZN8frt_task22_call_users_run_methodEPS_>

000005e4 <__ctors_start>:
     5e4:	03 20       	and	r0, r3

000005e6 <__ctors_end>:
     5e6:	11 24       	eor	r1, r1
     5e8:	1f be       	out	0x3f, r1	; 63
     5ea:	cf ef       	ldi	r28, 0xFF	; 255
     5ec:	cd bf       	out	0x3d, r28	; 61
     5ee:	df e3       	ldi	r29, 0x3F	; 63
     5f0:	de bf       	out	0x3e, r29	; 62
     5f2:	00 e0       	ldi	r16, 0x00	; 0
     5f4:	0c bf       	out	0x3c, r16	; 60
     5f6:	18 be       	out	0x38, r1	; 56
     5f8:	19 be       	out	0x39, r1	; 57
     5fa:	1a be       	out	0x3a, r1	; 58
     5fc:	1b be       	out	0x3b, r1	; 59

000005fe <__do_copy_data>:
     5fe:	10 e2       	ldi	r17, 0x20	; 32
     600:	a0 e0       	ldi	r26, 0x00	; 0
     602:	b0 e2       	ldi	r27, 0x20	; 32
     604:	ee ee       	ldi	r30, 0xEE	; 238
     606:	f2 e4       	ldi	r31, 0x42	; 66
     608:	00 e0       	ldi	r16, 0x00	; 0
     60a:	0b bf       	out	0x3b, r16	; 59
     60c:	02 c0       	rjmp	.+4      	; 0x612 <__do_copy_data+0x14>
     60e:	07 90       	elpm	r0, Z+
     610:	0d 92       	st	X+, r0
     612:	a2 3f       	cpi	r26, 0xF2	; 242
     614:	b1 07       	cpc	r27, r17
     616:	d9 f7       	brne	.-10     	; 0x60e <__do_copy_data+0x10>
     618:	1b be       	out	0x3b, r1	; 59

0000061a <__do_clear_bss>:
     61a:	21 e3       	ldi	r18, 0x31	; 49
     61c:	a2 ef       	ldi	r26, 0xF2	; 242
     61e:	b0 e2       	ldi	r27, 0x20	; 32
     620:	01 c0       	rjmp	.+2      	; 0x624 <.do_clear_bss_start>

00000622 <.do_clear_bss_loop>:
     622:	1d 92       	st	X+, r1

00000624 <.do_clear_bss_start>:
     624:	a0 3c       	cpi	r26, 0xC0	; 192
     626:	b2 07       	cpc	r27, r18
     628:	e1 f7       	brne	.-8      	; 0x622 <.do_clear_bss_loop>

0000062a <__do_global_ctors>:
     62a:	12 e0       	ldi	r17, 0x02	; 2
     62c:	c3 ef       	ldi	r28, 0xF3	; 243
     62e:	d2 e0       	ldi	r29, 0x02	; 2
     630:	00 e0       	ldi	r16, 0x00	; 0
     632:	06 c0       	rjmp	.+12     	; 0x640 <__do_global_ctors+0x16>
     634:	21 97       	sbiw	r28, 0x01	; 1
     636:	01 09       	sbc	r16, r1
     638:	80 2f       	mov	r24, r16
     63a:	fe 01       	movw	r30, r28
     63c:	0e 94 d1 20 	call	0x41a2	; 0x41a2 <__tablejump2__>
     640:	c2 3f       	cpi	r28, 0xF2	; 242
     642:	d1 07       	cpc	r29, r17
     644:	80 e0       	ldi	r24, 0x00	; 0
     646:	08 07       	cpc	r16, r24
     648:	a9 f7       	brne	.-22     	; 0x634 <__do_global_ctors+0xa>
     64a:	0e 94 81 1f 	call	0x3f02	; 0x3f02 <main>
     64e:	0c 94 75 21 	jmp	0x42ea	; 0x42ea <_exit>

00000652 <__bad_interrupt>:
     652:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000656 <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>:
  }
  else
  {
    return false;
  }
}
     656:	0f 93       	push	r16
     658:	1f 93       	push	r17
     65a:	cf 93       	push	r28
     65c:	df 93       	push	r29
     65e:	ec 01       	movw	r28, r24
     660:	cb 01       	movw	r24, r22
     662:	0e 81       	ldd	r16, Y+6	; 0x06
     664:	1f 81       	ldd	r17, Y+7	; 0x07
     666:	db 01       	movw	r26, r22
     668:	ed 91       	ld	r30, X+
     66a:	fc 91       	ld	r31, X
     66c:	00 84       	ldd	r0, Z+8	; 0x08
     66e:	f1 85       	ldd	r31, Z+9	; 0x09
     670:	e0 2d       	mov	r30, r0
     672:	19 95       	eicall
     674:	f8 01       	movw	r30, r16
     676:	86 83       	std	Z+6, r24	; 0x06
     678:	8a 81       	ldd	r24, Y+2	; 0x02
     67a:	9b 81       	ldd	r25, Y+3	; 0x03
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
     680:	1f 91       	pop	r17
     682:	0f 91       	pop	r16
     684:	08 95       	ret

00000686 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>:
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	1f 92       	push	r1
     68c:	1f 92       	push	r1
     68e:	cd b7       	in	r28, 0x3d	; 61
     690:	de b7       	in	r29, 0x3e	; 62
     692:	dc 01       	movw	r26, r24
     694:	18 96       	adiw	r26, 0x08	; 8
     696:	8d 91       	ld	r24, X+
     698:	9c 91       	ld	r25, X
     69a:	19 97       	sbiw	r26, 0x09	; 9
     69c:	89 83       	std	Y+1, r24	; 0x01
     69e:	9a 83       	std	Y+2, r25	; 0x02
     6a0:	29 81       	ldd	r18, Y+1	; 0x01
     6a2:	3a 81       	ldd	r19, Y+2	; 0x02
     6a4:	21 50       	subi	r18, 0x01	; 1
     6a6:	31 09       	sbc	r19, r1
     6a8:	29 83       	std	Y+1, r18	; 0x01
     6aa:	3a 83       	std	Y+2, r19	; 0x02
     6ac:	23 2b       	or	r18, r19
     6ae:	91 f0       	breq	.+36     	; 0x6d4 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6b0:	16 96       	adiw	r26, 0x06	; 6
     6b2:	ed 91       	ld	r30, X+
     6b4:	fc 91       	ld	r31, X
     6b6:	17 97       	sbiw	r26, 0x07	; 7
     6b8:	94 81       	ldd	r25, Z+4	; 0x04
     6ba:	94 fd       	sbrc	r25, 4
     6bc:	f1 cf       	rjmp	.-30     	; 0x6a0 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x1a>
     6be:	0a c0       	rjmp	.+20     	; 0x6d4 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6c0:	14 96       	adiw	r26, 0x04	; 4
     6c2:	8d 91       	ld	r24, X+
     6c4:	9c 91       	ld	r25, X
     6c6:	15 97       	sbiw	r26, 0x05	; 5
     6c8:	0a c0       	rjmp	.+20     	; 0x6de <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6ca:	12 96       	adiw	r26, 0x02	; 2
     6cc:	8d 91       	ld	r24, X+
     6ce:	9c 91       	ld	r25, X
     6d0:	13 97       	sbiw	r26, 0x03	; 3
     6d2:	05 c0       	rjmp	.+10     	; 0x6de <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6d4:	29 81       	ldd	r18, Y+1	; 0x01
     6d6:	3a 81       	ldd	r19, Y+2	; 0x02
     6d8:	23 2b       	or	r18, r19
     6da:	b9 f7       	brne	.-18     	; 0x6ca <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x44>
     6dc:	f1 cf       	rjmp	.-30     	; 0x6c0 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x3a>
     6de:	0f 90       	pop	r0
     6e0:	0f 90       	pop	r0
     6e2:	df 91       	pop	r29
     6e4:	cf 91       	pop	r28
     6e6:	08 95       	ret

000006e8 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER9frt_queueIhE>:
     6e8:	ef 92       	push	r14
     6ea:	ff 92       	push	r15
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	cf 93       	push	r28
     6f2:	df 93       	push	r29
     6f4:	8c 01       	movw	r16, r24
     6f6:	eb 01       	movw	r28, r22
     6f8:	e8 81       	ld	r30, Y
     6fa:	f9 81       	ldd	r31, Y+1	; 0x01
     6fc:	00 8c       	ldd	r0, Z+24	; 0x18
     6fe:	f1 8d       	ldd	r31, Z+25	; 0x19
     700:	e0 2d       	mov	r30, r0
     702:	cb 01       	movw	r24, r22
     704:	19 95       	eicall
     706:	88 23       	and	r24, r24
     708:	61 f0       	breq	.+24     	; 0x722 <_ZN9I2CMaster11Transmitter13ExchangeState7executeER9frt_queueIhE+0x3a>
     70a:	f8 01       	movw	r30, r16
     70c:	e6 80       	ldd	r14, Z+6	; 0x06
     70e:	f7 80       	ldd	r15, Z+7	; 0x07
     710:	e8 81       	ld	r30, Y
     712:	f9 81       	ldd	r31, Y+1	; 0x01
     714:	00 84       	ldd	r0, Z+8	; 0x08
     716:	f1 85       	ldd	r31, Z+9	; 0x09
     718:	e0 2d       	mov	r30, r0
     71a:	ce 01       	movw	r24, r28
     71c:	19 95       	eicall
     71e:	f7 01       	movw	r30, r14
     720:	87 83       	std	Z+7, r24	; 0x07
     722:	f8 01       	movw	r30, r16
     724:	82 81       	ldd	r24, Z+2	; 0x02
     726:	93 81       	ldd	r25, Z+3	; 0x03
     728:	df 91       	pop	r29
     72a:	cf 91       	pop	r28
     72c:	1f 91       	pop	r17
     72e:	0f 91       	pop	r16
     730:	ff 90       	pop	r15
     732:	ef 90       	pop	r14
     734:	08 95       	ret

00000736 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER9frt_queueIhE>:
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	ec 01       	movw	r28, r24
     73c:	cb 01       	movw	r24, r22
     73e:	db 01       	movw	r26, r22
     740:	ed 91       	ld	r30, X+
     742:	fc 91       	ld	r31, X
     744:	04 88       	ldd	r0, Z+20	; 0x14
     746:	f5 89       	ldd	r31, Z+21	; 0x15
     748:	e0 2d       	mov	r30, r0
     74a:	19 95       	eicall
     74c:	88 23       	and	r24, r24
     74e:	19 f0       	breq	.+6      	; 0x756 <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER9frt_queueIhE+0x20>
     750:	8a 81       	ldd	r24, Y+2	; 0x02
     752:	9b 81       	ldd	r25, Y+3	; 0x03
     754:	02 c0       	rjmp	.+4      	; 0x75a <_ZN9I2CMaster11Transmitter17PacketStatusState7executeER9frt_queueIhE+0x24>
     756:	8c 81       	ldd	r24, Y+4	; 0x04
     758:	9d 81       	ldd	r25, Y+5	; 0x05
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>:
     760:	fc 01       	movw	r30, r24
     762:	82 81       	ldd	r24, Z+2	; 0x02
     764:	93 81       	ldd	r25, Z+3	; 0x03
     766:	08 95       	ret

00000768 <_ZN9I2CMaster11Transmitter10ErrorState7executeER9frt_queueIhE>:
     768:	fc 01       	movw	r30, r24
     76a:	82 81       	ldd	r24, Z+2	; 0x02
     76c:	93 81       	ldd	r25, Z+3	; 0x03
     76e:	08 95       	ret

00000770 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     770:	0f 93       	push	r16
     772:	1f 93       	push	r17
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	ec 01       	movw	r28, r24
     77a:	8b 01       	movw	r16, r22
     77c:	88 e0       	ldi	r24, 0x08	; 8
     77e:	90 e0       	ldi	r25, 0x00	; 0
     780:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     784:	2a e0       	ldi	r18, 0x0A	; 10
     786:	30 e2       	ldi	r19, 0x20	; 32
     788:	fc 01       	movw	r30, r24
     78a:	20 83       	st	Z, r18
     78c:	31 83       	std	Z+1, r19	; 0x01
     78e:	06 83       	std	Z+6, r16	; 0x06
     790:	17 83       	std	Z+7, r17	; 0x07
     792:	8a 83       	std	Y+2, r24	; 0x02
     794:	9b 83       	std	Y+3, r25	; 0x03
     796:	8a e0       	ldi	r24, 0x0A	; 10
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     79e:	fc 01       	movw	r30, r24
     7a0:	89 89       	ldd	r24, Y+17	; 0x11
     7a2:	9a 89       	ldd	r25, Y+18	; 0x12
     7a4:	20 e1       	ldi	r18, 0x10	; 16
     7a6:	30 e2       	ldi	r19, 0x20	; 32
     7a8:	20 83       	st	Z, r18
     7aa:	31 83       	std	Z+1, r19	; 0x01
     7ac:	06 83       	std	Z+6, r16	; 0x06
     7ae:	17 83       	std	Z+7, r17	; 0x07
     7b0:	80 87       	std	Z+8, r24	; 0x08
     7b2:	91 87       	std	Z+9, r25	; 0x09
     7b4:	ec 83       	std	Y+4, r30	; 0x04
     7b6:	fd 83       	std	Y+5, r31	; 0x05
     7b8:	88 e0       	ldi	r24, 0x08	; 8
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     7c0:	26 e1       	ldi	r18, 0x16	; 22
     7c2:	30 e2       	ldi	r19, 0x20	; 32
     7c4:	fc 01       	movw	r30, r24
     7c6:	20 83       	st	Z, r18
     7c8:	31 83       	std	Z+1, r19	; 0x01
     7ca:	06 83       	std	Z+6, r16	; 0x06
     7cc:	17 83       	std	Z+7, r17	; 0x07
     7ce:	8e 83       	std	Y+6, r24	; 0x06
     7d0:	9f 83       	std	Y+7, r25	; 0x07
     7d2:	88 e0       	ldi	r24, 0x08	; 8
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     7da:	2c e1       	ldi	r18, 0x1C	; 28
     7dc:	30 e2       	ldi	r19, 0x20	; 32
     7de:	fc 01       	movw	r30, r24
     7e0:	20 83       	st	Z, r18
     7e2:	31 83       	std	Z+1, r19	; 0x01
     7e4:	06 83       	std	Z+6, r16	; 0x06
     7e6:	17 83       	std	Z+7, r17	; 0x07
     7e8:	88 87       	std	Y+8, r24	; 0x08
     7ea:	99 87       	std	Y+9, r25	; 0x09
     7ec:	88 e0       	ldi	r24, 0x08	; 8
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     7f4:	28 e2       	ldi	r18, 0x28	; 40
     7f6:	30 e2       	ldi	r19, 0x20	; 32
     7f8:	fc 01       	movw	r30, r24
     7fa:	20 83       	st	Z, r18
     7fc:	31 83       	std	Z+1, r19	; 0x01
     7fe:	06 83       	std	Z+6, r16	; 0x06
     800:	17 83       	std	Z+7, r17	; 0x07
     802:	8a 87       	std	Y+10, r24	; 0x0a
     804:	9b 87       	std	Y+11, r25	; 0x0b
     806:	88 e0       	ldi	r24, 0x08	; 8
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     80e:	22 e2       	ldi	r18, 0x22	; 34
     810:	30 e2       	ldi	r19, 0x20	; 32
     812:	fc 01       	movw	r30, r24
     814:	20 83       	st	Z, r18
     816:	31 83       	std	Z+1, r19	; 0x01
     818:	06 83       	std	Z+6, r16	; 0x06
     81a:	17 83       	std	Z+7, r17	; 0x07
     81c:	8c 87       	std	Y+12, r24	; 0x0c
     81e:	9d 87       	std	Y+13, r25	; 0x0d
     820:	80 e1       	ldi	r24, 0x10	; 16
     822:	97 e2       	ldi	r25, 0x27	; 39
     824:	89 8b       	std	Y+17, r24	; 0x11
     826:	9a 8b       	std	Y+18, r25	; 0x12
     828:	8c 81       	ldd	r24, Y+4	; 0x04
     82a:	9d 81       	ldd	r25, Y+5	; 0x05
     82c:	ea 81       	ldd	r30, Y+2	; 0x02
     82e:	fb 81       	ldd	r31, Y+3	; 0x03
     830:	82 83       	std	Z+2, r24	; 0x02
     832:	93 83       	std	Z+3, r25	; 0x03
     834:	84 83       	std	Z+4, r24	; 0x04
     836:	95 83       	std	Z+5, r25	; 0x05
     838:	8a 85       	ldd	r24, Y+10	; 0x0a
     83a:	9b 85       	ldd	r25, Y+11	; 0x0b
     83c:	2e 81       	ldd	r18, Y+6	; 0x06
     83e:	3f 81       	ldd	r19, Y+7	; 0x07
     840:	ec 81       	ldd	r30, Y+4	; 0x04
     842:	fd 81       	ldd	r31, Y+5	; 0x05
     844:	22 83       	std	Z+2, r18	; 0x02
     846:	33 83       	std	Z+3, r19	; 0x03
     848:	84 83       	std	Z+4, r24	; 0x04
     84a:	95 83       	std	Z+5, r25	; 0x05
     84c:	88 85       	ldd	r24, Y+8	; 0x08
     84e:	99 85       	ldd	r25, Y+9	; 0x09
     850:	ee 81       	ldd	r30, Y+6	; 0x06
     852:	ff 81       	ldd	r31, Y+7	; 0x07
     854:	82 83       	std	Z+2, r24	; 0x02
     856:	93 83       	std	Z+3, r25	; 0x03
     858:	84 83       	std	Z+4, r24	; 0x04
     85a:	95 83       	std	Z+5, r25	; 0x05
     85c:	8c 81       	ldd	r24, Y+4	; 0x04
     85e:	9d 81       	ldd	r25, Y+5	; 0x05
     860:	2c 85       	ldd	r18, Y+12	; 0x0c
     862:	3d 85       	ldd	r19, Y+13	; 0x0d
     864:	e8 85       	ldd	r30, Y+8	; 0x08
     866:	f9 85       	ldd	r31, Y+9	; 0x09
     868:	22 83       	std	Z+2, r18	; 0x02
     86a:	33 83       	std	Z+3, r19	; 0x03
     86c:	84 83       	std	Z+4, r24	; 0x04
     86e:	95 83       	std	Z+5, r25	; 0x05
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	08 95       	ret

0000087a <_ZN9I2CMaster12set_baudrateEm>:
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	ec 01       	movw	r28, r24
     880:	9a 01       	movw	r18, r20
     882:	ab 01       	movw	r20, r22
     884:	22 0f       	add	r18, r18
     886:	33 1f       	adc	r19, r19
     888:	44 1f       	adc	r20, r20
     88a:	55 1f       	adc	r21, r21
     88c:	60 e0       	ldi	r22, 0x00	; 0
     88e:	78 e4       	ldi	r23, 0x48	; 72
     890:	88 ee       	ldi	r24, 0xE8	; 232
     892:	91 e0       	ldi	r25, 0x01	; 1
     894:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
     898:	25 50       	subi	r18, 0x05	; 5
     89a:	2e 83       	std	Y+6, r18	; 0x06
     89c:	ea 81       	ldd	r30, Y+2	; 0x02
     89e:	fb 81       	ldd	r31, Y+3	; 0x03
     8a0:	25 83       	std	Z+5, r18	; 0x05
     8a2:	df 91       	pop	r29
     8a4:	cf 91       	pop	r28
     8a6:	08 95       	ret

000008a8 <_ZN9I2CMasterC1EP10TWI_structm>:
     8a8:	af 92       	push	r10
     8aa:	bf 92       	push	r11
     8ac:	cf 92       	push	r12
     8ae:	df 92       	push	r13
     8b0:	ef 92       	push	r14
     8b2:	ff 92       	push	r15
     8b4:	0f 93       	push	r16
     8b6:	1f 93       	push	r17
     8b8:	cf 93       	push	r28
     8ba:	df 93       	push	r29
     8bc:	8c 01       	movw	r16, r24
     8be:	eb 01       	movw	r28, r22
     8c0:	69 01       	movw	r12, r18
     8c2:	7a 01       	movw	r14, r20
     8c4:	83 e1       	ldi	r24, 0x13	; 19
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     8cc:	5c 01       	movw	r10, r24
     8ce:	be 01       	movw	r22, r28
     8d0:	0e 94 b8 03 	call	0x770	; 0x770 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     8d4:	d8 01       	movw	r26, r16
     8d6:	ad 92       	st	X+, r10
     8d8:	bc 92       	st	X, r11
     8da:	11 97       	sbiw	r26, 0x01	; 1
     8dc:	12 96       	adiw	r26, 0x02	; 2
     8de:	cd 93       	st	X+, r28
     8e0:	dc 93       	st	X, r29
     8e2:	13 97       	sbiw	r26, 0x03	; 3
     8e4:	f8 01       	movw	r30, r16
     8e6:	c7 82       	std	Z+7, r12	; 0x07
     8e8:	d0 86       	std	Z+8, r13	; 0x08
     8ea:	e1 86       	std	Z+9, r14	; 0x09
     8ec:	f2 86       	std	Z+10, r15	; 0x0a
     8ee:	c0 38       	cpi	r28, 0x80	; 128
     8f0:	f4 e0       	ldi	r31, 0x04	; 4
     8f2:	df 07       	cpc	r29, r31
     8f4:	39 f4       	brne	.+14     	; 0x904 <_ZN9I2CMasterC1EP10TWI_structm+0x5c>
     8f6:	80 e4       	ldi	r24, 0x40	; 64
     8f8:	96 e0       	ldi	r25, 0x06	; 6
     8fa:	14 96       	adiw	r26, 0x04	; 4
     8fc:	8d 93       	st	X+, r24
     8fe:	9c 93       	st	X, r25
     900:	15 97       	sbiw	r26, 0x05	; 5
     902:	09 c0       	rjmp	.+18     	; 0x916 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
     904:	c0 3a       	cpi	r28, 0xA0	; 160
     906:	b4 e0       	ldi	r27, 0x04	; 4
     908:	db 07       	cpc	r29, r27
     90a:	29 f4       	brne	.+10     	; 0x916 <_ZN9I2CMasterC1EP10TWI_structm+0x6e>
     90c:	80 e8       	ldi	r24, 0x80	; 128
     90e:	96 e0       	ldi	r25, 0x06	; 6
     910:	f8 01       	movw	r30, r16
     912:	84 83       	std	Z+4, r24	; 0x04
     914:	95 83       	std	Z+5, r25	; 0x05
     916:	d8 01       	movw	r26, r16
     918:	14 96       	adiw	r26, 0x04	; 4
     91a:	ed 91       	ld	r30, X+
     91c:	fc 91       	ld	r31, X
     91e:	15 97       	sbiw	r26, 0x05	; 5
     920:	83 e0       	ldi	r24, 0x03	; 3
     922:	81 83       	std	Z+1, r24	; 0x01
     924:	14 96       	adiw	r26, 0x04	; 4
     926:	ed 91       	ld	r30, X+
     928:	fc 91       	ld	r31, X
     92a:	15 97       	sbiw	r26, 0x05	; 5
     92c:	88 e3       	ldi	r24, 0x38	; 56
     92e:	80 8b       	std	Z+16, r24	; 0x10
     930:	14 96       	adiw	r26, 0x04	; 4
     932:	ed 91       	ld	r30, X+
     934:	fc 91       	ld	r31, X
     936:	15 97       	sbiw	r26, 0x05	; 5
     938:	81 8b       	std	Z+17, r24	; 0x11
     93a:	82 e0       	ldi	r24, 0x02	; 2
     93c:	8a 83       	std	Y+2, r24	; 0x02
     93e:	b7 01       	movw	r22, r14
     940:	a6 01       	movw	r20, r12
     942:	c8 01       	movw	r24, r16
     944:	0e 94 3d 04 	call	0x87a	; 0x87a <_ZN9I2CMaster12set_baudrateEm>
     948:	8c 81       	ldd	r24, Y+4	; 0x04
     94a:	8d 6c       	ori	r24, 0xCD	; 205
     94c:	8c 83       	std	Y+4, r24	; 0x04
     94e:	88 e0       	ldi	r24, 0x08	; 8
     950:	89 83       	std	Y+1, r24	; 0x01
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	1f 91       	pop	r17
     958:	0f 91       	pop	r16
     95a:	ff 90       	pop	r15
     95c:	ef 90       	pop	r14
     95e:	df 90       	pop	r13
     960:	cf 90       	pop	r12
     962:	bf 90       	pop	r11
     964:	af 90       	pop	r10
     966:	08 95       	ret

00000968 <_ZN9I2CMaster5writeEhPhhj>:
     968:	0f 93       	push	r16
     96a:	1f 93       	push	r17
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	1f 92       	push	r1
     972:	1f 92       	push	r1
     974:	cd b7       	in	r28, 0x3d	; 61
     976:	de b7       	in	r29, 0x3e	; 62
     978:	dc 01       	movw	r26, r24
     97a:	09 83       	std	Y+1, r16	; 0x01
     97c:	1a 83       	std	Y+2, r17	; 0x02
     97e:	12 96       	adiw	r26, 0x02	; 2
     980:	ed 91       	ld	r30, X+
     982:	fc 91       	ld	r31, X
     984:	13 97       	sbiw	r26, 0x03	; 3
     986:	66 0f       	add	r22, r22
     988:	66 83       	std	Z+6, r22	; 0x06
     98a:	89 81       	ldd	r24, Y+1	; 0x01
     98c:	9a 81       	ldd	r25, Y+2	; 0x02
     98e:	01 97       	sbiw	r24, 0x01	; 1
     990:	89 83       	std	Y+1, r24	; 0x01
     992:	9a 83       	std	Y+2, r25	; 0x02
     994:	89 2b       	or	r24, r25
     996:	09 f4       	brne	.+2      	; 0x99a <_ZN9I2CMaster5writeEhPhhj+0x32>
     998:	40 c0       	rjmp	.+128    	; 0xa1a <_ZN9I2CMaster5writeEhPhhj+0xb2>
     99a:	12 96       	adiw	r26, 0x02	; 2
     99c:	ed 91       	ld	r30, X+
     99e:	fc 91       	ld	r31, X
     9a0:	13 97       	sbiw	r26, 0x03	; 3
     9a2:	84 81       	ldd	r24, Z+4	; 0x04
     9a4:	86 ff       	sbrs	r24, 6
     9a6:	f1 cf       	rjmp	.-30     	; 0x98a <_ZN9I2CMaster5writeEhPhhj+0x22>
     9a8:	38 c0       	rjmp	.+112    	; 0xa1a <_ZN9I2CMaster5writeEhPhhj+0xb2>
     9aa:	22 23       	and	r18, r18
     9ac:	61 f1       	breq	.+88     	; 0xa06 <_ZN9I2CMaster5writeEhPhhj+0x9e>
     9ae:	ba 01       	movw	r22, r20
     9b0:	21 50       	subi	r18, 0x01	; 1
     9b2:	82 2f       	mov	r24, r18
     9b4:	90 e0       	ldi	r25, 0x00	; 0
     9b6:	01 96       	adiw	r24, 0x01	; 1
     9b8:	48 0f       	add	r20, r24
     9ba:	59 1f       	adc	r21, r25
     9bc:	09 83       	std	Y+1, r16	; 0x01
     9be:	1a 83       	std	Y+2, r17	; 0x02
     9c0:	12 96       	adiw	r26, 0x02	; 2
     9c2:	2d 91       	ld	r18, X+
     9c4:	3c 91       	ld	r19, X
     9c6:	13 97       	sbiw	r26, 0x03	; 3
     9c8:	fb 01       	movw	r30, r22
     9ca:	81 91       	ld	r24, Z+
     9cc:	bf 01       	movw	r22, r30
     9ce:	f9 01       	movw	r30, r18
     9d0:	87 83       	std	Z+7, r24	; 0x07
     9d2:	29 81       	ldd	r18, Y+1	; 0x01
     9d4:	3a 81       	ldd	r19, Y+2	; 0x02
     9d6:	21 50       	subi	r18, 0x01	; 1
     9d8:	31 09       	sbc	r19, r1
     9da:	29 83       	std	Y+1, r18	; 0x01
     9dc:	3a 83       	std	Y+2, r19	; 0x02
     9de:	23 2b       	or	r18, r19
     9e0:	11 f1       	breq	.+68     	; 0xa26 <_ZN9I2CMaster5writeEhPhhj+0xbe>
     9e2:	12 96       	adiw	r26, 0x02	; 2
     9e4:	ed 91       	ld	r30, X+
     9e6:	fc 91       	ld	r31, X
     9e8:	13 97       	sbiw	r26, 0x03	; 3
     9ea:	94 81       	ldd	r25, Z+4	; 0x04
     9ec:	94 fd       	sbrc	r25, 4
     9ee:	f1 cf       	rjmp	.-30     	; 0x9d2 <_ZN9I2CMaster5writeEhPhhj+0x6a>
     9f0:	1a c0       	rjmp	.+52     	; 0xa26 <_ZN9I2CMaster5writeEhPhhj+0xbe>
     9f2:	12 96       	adiw	r26, 0x02	; 2
     9f4:	ed 91       	ld	r30, X+
     9f6:	fc 91       	ld	r31, X
     9f8:	13 97       	sbiw	r26, 0x03	; 3
     9fa:	84 81       	ldd	r24, Z+4	; 0x04
     9fc:	80 64       	ori	r24, 0x40	; 64
     9fe:	84 83       	std	Z+4, r24	; 0x04
     a00:	46 17       	cp	r20, r22
     a02:	57 07       	cpc	r21, r23
     a04:	d9 f6       	brne	.-74     	; 0x9bc <_ZN9I2CMaster5writeEhPhhj+0x54>
     a06:	12 96       	adiw	r26, 0x02	; 2
     a08:	ed 91       	ld	r30, X+
     a0a:	fc 91       	ld	r31, X
     a0c:	13 97       	sbiw	r26, 0x03	; 3
     a0e:	83 e0       	ldi	r24, 0x03	; 3
     a10:	83 83       	std	Z+3, r24	; 0x03
     a12:	81 e0       	ldi	r24, 0x01	; 1
     a14:	0d c0       	rjmp	.+26     	; 0xa30 <_ZN9I2CMaster5writeEhPhhj+0xc8>
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	0b c0       	rjmp	.+22     	; 0xa30 <_ZN9I2CMaster5writeEhPhhj+0xc8>
     a1a:	89 81       	ldd	r24, Y+1	; 0x01
     a1c:	9a 81       	ldd	r25, Y+2	; 0x02
     a1e:	89 2b       	or	r24, r25
     a20:	21 f6       	brne	.-120    	; 0x9aa <_ZN9I2CMaster5writeEhPhhj+0x42>
     a22:	80 e0       	ldi	r24, 0x00	; 0
     a24:	05 c0       	rjmp	.+10     	; 0xa30 <_ZN9I2CMaster5writeEhPhhj+0xc8>
     a26:	29 81       	ldd	r18, Y+1	; 0x01
     a28:	3a 81       	ldd	r19, Y+2	; 0x02
     a2a:	23 2b       	or	r18, r19
     a2c:	11 f7       	brne	.-60     	; 0x9f2 <_ZN9I2CMaster5writeEhPhhj+0x8a>
     a2e:	f3 cf       	rjmp	.-26     	; 0xa16 <_ZN9I2CMaster5writeEhPhhj+0xae>
     a30:	0f 90       	pop	r0
     a32:	0f 90       	pop	r0
     a34:	df 91       	pop	r29
     a36:	cf 91       	pop	r28
     a38:	1f 91       	pop	r17
     a3a:	0f 91       	pop	r16
     a3c:	08 95       	ret

00000a3e <_ZN9I2CMaster4readEhPhhj>:

bool I2CMaster::read (uint8_t slave_addr, uint8_t* data, uint8_t packet_len, uint16_t timeout)
{
     a3e:	0f 93       	push	r16
     a40:	1f 93       	push	r17
     a42:	cf 93       	push	r28
     a44:	df 93       	push	r29
     a46:	00 d0       	rcall	.+0      	; 0xa48 <_ZN9I2CMaster4readEhPhhj+0xa>
     a48:	cd b7       	in	r28, 0x3d	; 61
     a4a:	de b7       	in	r29, 0x3e	; 62
     a4c:	dc 01       	movw	r26, r24
  volatile uint16_t counter;
  volatile uint8_t i;
  counter = timeout;
     a4e:	09 83       	std	Y+1, r16	; 0x01
     a50:	1a 83       	std	Y+2, r17	; 0x02
  
  interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
     a52:	12 96       	adiw	r26, 0x02	; 2
     a54:	ed 91       	ld	r30, X+
     a56:	fc 91       	ld	r31, X
     a58:	13 97       	sbiw	r26, 0x03	; 3
     a5a:	66 0f       	add	r22, r22
     a5c:	61 60       	ori	r22, 0x01	; 1
     a5e:	66 83       	std	Z+6, r22	; 0x06
  
  while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
     a60:	89 81       	ldd	r24, Y+1	; 0x01
     a62:	9a 81       	ldd	r25, Y+2	; 0x02
     a64:	01 97       	sbiw	r24, 0x01	; 1
     a66:	89 83       	std	Y+1, r24	; 0x01
     a68:	9a 83       	std	Y+2, r25	; 0x02
     a6a:	89 2b       	or	r24, r25
     a6c:	09 f4       	brne	.+2      	; 0xa70 <_ZN9I2CMaster4readEhPhhj+0x32>
     a6e:	51 c0       	rjmp	.+162    	; 0xb12 <_ZN9I2CMaster4readEhPhhj+0xd4>
     a70:	12 96       	adiw	r26, 0x02	; 2
     a72:	ed 91       	ld	r30, X+
     a74:	fc 91       	ld	r31, X
     a76:	13 97       	sbiw	r26, 0x03	; 3
     a78:	84 81       	ldd	r24, Z+4	; 0x04
     a7a:	88 23       	and	r24, r24
     a7c:	8c f7       	brge	.-30     	; 0xa60 <_ZN9I2CMaster4readEhPhhj+0x22>
     a7e:	49 c0       	rjmp	.+146    	; 0xb12 <_ZN9I2CMaster4readEhPhhj+0xd4>
  if (counter != 0)
  {
    for (i = 0; i < packet_len; ++i)
     a80:	1b 82       	std	Y+3, r1	; 0x03
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	82 17       	cp	r24, r18
     a86:	08 f0       	brcs	.+2      	; 0xa8a <_ZN9I2CMaster4readEhPhhj+0x4c>
     a88:	43 c0       	rjmp	.+134    	; 0xb10 <_ZN9I2CMaster4readEhPhhj+0xd2>
  interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
  interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     a8a:	32 e0       	ldi	r19, 0x02	; 2
  while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
  if (counter != 0)
  {
    for (i = 0; i < packet_len; ++i)
    {
      counter = timeout;
     a8c:	09 83       	std	Y+1, r16	; 0x01
     a8e:	1a 83       	std	Y+2, r17	; 0x02
      while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }      
     a90:	69 81       	ldd	r22, Y+1	; 0x01
     a92:	7a 81       	ldd	r23, Y+2	; 0x02
     a94:	61 50       	subi	r22, 0x01	; 1
     a96:	71 09       	sbc	r23, r1
     a98:	69 83       	std	Y+1, r22	; 0x01
     a9a:	7a 83       	std	Y+2, r23	; 0x02
     a9c:	67 2b       	or	r22, r23
     a9e:	09 f4       	brne	.+2      	; 0xaa2 <_ZN9I2CMaster4readEhPhhj+0x64>
     aa0:	3f c0       	rjmp	.+126    	; 0xb20 <_ZN9I2CMaster4readEhPhhj+0xe2>
     aa2:	12 96       	adiw	r26, 0x02	; 2
     aa4:	ed 91       	ld	r30, X+
     aa6:	fc 91       	ld	r31, X
     aa8:	13 97       	sbiw	r26, 0x03	; 3
     aaa:	94 81       	ldd	r25, Z+4	; 0x04
     aac:	99 23       	and	r25, r25
     aae:	84 f7       	brge	.-32     	; 0xa90 <_ZN9I2CMaster4readEhPhhj+0x52>
     ab0:	37 c0       	rjmp	.+110    	; 0xb20 <_ZN9I2CMaster4readEhPhhj+0xe2>
      if (counter != 0)
      {
        data[i] = interface->MASTER.DATA;
     ab2:	9b 81       	ldd	r25, Y+3	; 0x03
     ab4:	12 96       	adiw	r26, 0x02	; 2
     ab6:	ed 91       	ld	r30, X+
     ab8:	fc 91       	ld	r31, X
     aba:	13 97       	sbiw	r26, 0x03	; 3
     abc:	87 81       	ldd	r24, Z+7	; 0x07
     abe:	fa 01       	movw	r30, r20
     ac0:	e9 0f       	add	r30, r25
     ac2:	f1 1d       	adc	r31, r1
     ac4:	80 83       	st	Z, r24
        if (i < packet_len)
     ac6:	8b 81       	ldd	r24, Y+3	; 0x03
     ac8:	82 17       	cp	r24, r18
     aca:	98 f4       	brcc	.+38     	; 0xaf2 <_ZN9I2CMaster4readEhPhhj+0xb4>
  interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
  interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     acc:	12 96       	adiw	r26, 0x02	; 2
     ace:	ed 91       	ld	r30, X+
     ad0:	fc 91       	ld	r31, X
     ad2:	13 97       	sbiw	r26, 0x03	; 3
     ad4:	33 83       	std	Z+3, r19	; 0x03
      {
        data[i] = interface->MASTER.DATA;
        if (i < packet_len)
        {
          byte_recv();
          interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     ad6:	12 96       	adiw	r26, 0x02	; 2
     ad8:	ed 91       	ld	r30, X+
     ada:	fc 91       	ld	r31, X
     adc:	13 97       	sbiw	r26, 0x03	; 3
     ade:	84 81       	ldd	r24, Z+4	; 0x04
     ae0:	80 68       	ori	r24, 0x80	; 128
     ae2:	84 83       	std	Z+4, r24	; 0x04
  interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
  
  while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
  if (counter != 0)
  {
    for (i = 0; i < packet_len; ++i)
     ae4:	8b 81       	ldd	r24, Y+3	; 0x03
     ae6:	8f 5f       	subi	r24, 0xFF	; 255
     ae8:	8b 83       	std	Y+3, r24	; 0x03
     aea:	8b 81       	ldd	r24, Y+3	; 0x03
     aec:	82 17       	cp	r24, r18
     aee:	70 f2       	brcs	.-100    	; 0xa8c <_ZN9I2CMaster4readEhPhhj+0x4e>
     af0:	0f c0       	rjmp	.+30     	; 0xb10 <_ZN9I2CMaster4readEhPhhj+0xd2>
  interface->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
  interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
     af2:	12 96       	adiw	r26, 0x02	; 2
     af4:	ed 91       	ld	r30, X+
     af6:	fc 91       	ld	r31, X
     af8:	13 97       	sbiw	r26, 0x03	; 3
     afa:	87 e0       	ldi	r24, 0x07	; 7
     afc:	83 83       	std	Z+3, r24	; 0x03
          interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
        }
        else
        {
          send_nack_stop();
          interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     afe:	12 96       	adiw	r26, 0x02	; 2
     b00:	ed 91       	ld	r30, X+
     b02:	fc 91       	ld	r31, X
     b04:	13 97       	sbiw	r26, 0x03	; 3
     b06:	84 81       	ldd	r24, Z+4	; 0x04
     b08:	80 68       	ori	r24, 0x80	; 128
     b0a:	84 83       	std	Z+4, r24	; 0x04
          return true;
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	0d c0       	rjmp	.+26     	; 0xb2a <_ZN9I2CMaster4readEhPhhj+0xec>
  }
  else
  {
    return false;
  }
}
     b10:	0c c0       	rjmp	.+24     	; 0xb2a <_ZN9I2CMaster4readEhPhhj+0xec>
  counter = timeout;
  
  interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
  
  while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
  if (counter != 0)
     b12:	89 81       	ldd	r24, Y+1	; 0x01
     b14:	9a 81       	ldd	r25, Y+2	; 0x02
     b16:	89 2b       	or	r24, r25
     b18:	09 f0       	breq	.+2      	; 0xb1c <_ZN9I2CMaster4readEhPhhj+0xde>
     b1a:	b2 cf       	rjmp	.-156    	; 0xa80 <_ZN9I2CMaster4readEhPhhj+0x42>
      }   
    }
  }
  else
  {
    return false;
     b1c:	80 e0       	ldi	r24, 0x00	; 0
     b1e:	05 c0       	rjmp	.+10     	; 0xb2a <_ZN9I2CMaster4readEhPhhj+0xec>
  {
    for (i = 0; i < packet_len; ++i)
    {
      counter = timeout;
      while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }      
      if (counter != 0)
     b20:	69 81       	ldd	r22, Y+1	; 0x01
     b22:	7a 81       	ldd	r23, Y+2	; 0x02
     b24:	67 2b       	or	r22, r23
     b26:	29 f6       	brne	.-118    	; 0xab2 <_ZN9I2CMaster4readEhPhhj+0x74>
          return true;
        }
      }
      else
      {
        return false;
     b28:	80 e0       	ldi	r24, 0x00	; 0
  }
  else
  {
    return false;
  }
}
     b2a:	23 96       	adiw	r28, 0x03	; 3
     b2c:	cd bf       	out	0x3d, r28	; 61
     b2e:	de bf       	out	0x3e, r29	; 62
     b30:	df 91       	pop	r29
     b32:	cf 91       	pop	r28
     b34:	1f 91       	pop	r17
     b36:	0f 91       	pop	r16
     b38:	08 95       	ret

00000b3a <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return i2c->is_ready(slave_addr);
};
     b3a:	db 01       	movw	r26, r22
     b3c:	bc 01       	movw	r22, r24
     b3e:	6e 5f       	subi	r22, 0xFE	; 254
     b40:	7f 4f       	sbci	r23, 0xFF	; 255
     b42:	ed 91       	ld	r30, X+
     b44:	fc 91       	ld	r31, X
     b46:	11 97       	sbiw	r26, 0x01	; 1
     b48:	01 90       	ld	r0, Z+
     b4a:	f0 81       	ld	r31, Z
     b4c:	e0 2d       	mov	r30, r0
     b4e:	cd 01       	movw	r24, r26
     b50:	19 95       	eicall
     b52:	08 95       	ret

00000b54 <_ZN6MB1202C1EP9I2CMaster>:
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	ec 01       	movw	r28, r24
     b5a:	68 83       	st	Y, r22
     b5c:	79 83       	std	Y+1, r23	; 0x01
     b5e:	1c 82       	std	Y+4, r1	; 0x04
     b60:	1d 82       	std	Y+5, r1	; 0x05
     b62:	1e 82       	std	Y+6, r1	; 0x06
     b64:	1f 82       	std	Y+7, r1	; 0x07
     b66:	18 86       	std	Y+8, r1	; 0x08
     b68:	83 e0       	ldi	r24, 0x03	; 3
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
     b70:	2e e2       	ldi	r18, 0x2E	; 46
     b72:	30 e2       	ldi	r19, 0x20	; 32
     b74:	fc 01       	movw	r30, r24
     b76:	20 83       	st	Z, r18
     b78:	31 83       	std	Z+1, r19	; 0x01
     b7a:	21 e5       	ldi	r18, 0x51	; 81
     b7c:	22 83       	std	Z+2, r18	; 0x02
     b7e:	8b 87       	std	Y+11, r24	; 0x0b
     b80:	9c 87       	std	Y+12, r25	; 0x0c
     b82:	80 e7       	ldi	r24, 0x70	; 112
     b84:	8a 83       	std	Y+2, r24	; 0x02
     b86:	2b 83       	std	Y+3, r18	; 0x03
     b88:	8a ea       	ldi	r24, 0xAA	; 170
     b8a:	8c 83       	std	Y+4, r24	; 0x04
     b8c:	85 ea       	ldi	r24, 0xA5	; 165
     b8e:	8d 83       	std	Y+5, r24	; 0x05
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	08 95       	ret

00000b96 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
     b96:	0f 93       	push	r16
     b98:	1f 93       	push	r17
	return i2c->write (slave_addr, range_cmd, 1);
     b9a:	ac 01       	movw	r20, r24
     b9c:	4d 5f       	subi	r20, 0xFD	; 253
     b9e:	5f 4f       	sbci	r21, 0xFF	; 255
     ba0:	08 ee       	ldi	r16, 0xE8	; 232
     ba2:	13 e0       	ldi	r17, 0x03	; 3
     ba4:	21 e0       	ldi	r18, 0x01	; 1
     ba6:	fc 01       	movw	r30, r24
     ba8:	62 81       	ldd	r22, Z+2	; 0x02
     baa:	80 81       	ld	r24, Z
     bac:	91 81       	ldd	r25, Z+1	; 0x01
     bae:	0e 94 b4 04 	call	0x968	; 0x968 <_ZN9I2CMaster5writeEhPhhj>
};
     bb2:	1f 91       	pop	r17
     bb4:	0f 91       	pop	r16
     bb6:	08 95       	ret

00000bb8 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     bb8:	0f 93       	push	r16
     bba:	1f 93       	push	r17
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ec 01       	movw	r28, r24
	i2c->read (slave_addr, bytes_received, 2);
     bc2:	ac 01       	movw	r20, r24
     bc4:	49 5f       	subi	r20, 0xF9	; 249
     bc6:	5f 4f       	sbci	r21, 0xFF	; 255
     bc8:	08 ee       	ldi	r16, 0xE8	; 232
     bca:	13 e0       	ldi	r17, 0x03	; 3
     bcc:	22 e0       	ldi	r18, 0x02	; 2
     bce:	6a 81       	ldd	r22, Y+2	; 0x02
     bd0:	88 81       	ld	r24, Y
     bd2:	99 81       	ldd	r25, Y+1	; 0x01
     bd4:	0e 94 1f 05 	call	0xa3e	; 0xa3e <_ZN9I2CMaster4readEhPhhj>
	range_reading = ((uint16_t) bytes_received[0] << 8) | ((uint16_t) bytes_received[1]);
     bd8:	8f 81       	ldd	r24, Y+7	; 0x07
     bda:	90 e0       	ldi	r25, 0x00	; 0
     bdc:	98 2f       	mov	r25, r24
     bde:	88 27       	eor	r24, r24
     be0:	28 85       	ldd	r18, Y+8	; 0x08
     be2:	82 2b       	or	r24, r18
     be4:	89 87       	std	Y+9, r24	; 0x09
     be6:	9a 87       	std	Y+10, r25	; 0x0a
	return range_reading;
}
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	1f 91       	pop	r17
     bee:	0f 91       	pop	r16
     bf0:	08 95       	ret

00000bf2 <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     bf2:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     bf4:	8c 85       	ldd	r24, Y+12	; 0x0c
     bf6:	88 23       	and	r24, r24
     bf8:	19 f0       	breq	.+6      	; 0xc00 <_ZN10task_sonar3runEv+0xe>
     bfa:	81 30       	cpi	r24, 0x01	; 1
     bfc:	51 f0       	breq	.+20     	; 0xc12 <_ZN10task_sonar3runEv+0x20>
     bfe:	25 c0       	rjmp	.+74     	; 0xc4a <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     c00:	8c 89       	ldd	r24, Y+20	; 0x14
     c02:	9d 89       	ldd	r25, Y+21	; 0x15
     c04:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     c08:	61 e0       	ldi	r22, 0x01	; 1
     c0a:	ce 01       	movw	r24, r28
     c0c:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task13transition_toEh>
			
			    break;
     c10:	1c c0       	rjmp	.+56     	; 0xc4a <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     c12:	8c 89       	ldd	r24, Y+20	; 0x14
     c14:	9d 89       	ldd	r25, Y+21	; 0x15
     c16:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <_ZN6MB120211get_readingEv>
     c1a:	7c 01       	movw	r14, r24
     c1c:	8a 8b       	std	Y+18, r24	; 0x12
     c1e:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     c20:	6a e0       	ldi	r22, 0x0A	; 10
     c22:	8e 81       	ldd	r24, Y+6	; 0x06
     c24:	9f 81       	ldd	r25, Y+7	; 0x07
     c26:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     c2a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     c2c:	66 e2       	ldi	r22, 0x26	; 38
     c2e:	73 e0       	ldi	r23, 0x03	; 3
     c30:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     c34:	b7 01       	movw	r22, r14
     c36:	c8 01       	movw	r24, r16
     c38:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
     c3c:	66 e0       	ldi	r22, 0x06	; 6
     c3e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     c42:	60 e0       	ldi	r22, 0x00	; 0
     c44:	ce 01       	movw	r24, r28
     c46:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     c4a:	8e 85       	ldd	r24, Y+14	; 0x0e
     c4c:	9f 85       	ldd	r25, Y+15	; 0x0f
     c4e:	a8 89       	ldd	r26, Y+16	; 0x10
     c50:	b9 89       	ldd	r27, Y+17	; 0x11
     c52:	01 96       	adiw	r24, 0x01	; 1
     c54:	a1 1d       	adc	r26, r1
     c56:	b1 1d       	adc	r27, r1
     c58:	8e 87       	std	Y+14, r24	; 0x0e
     c5a:	9f 87       	std	Y+15, r25	; 0x0f
     c5c:	a8 8b       	std	Y+16, r26	; 0x10
     c5e:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     c60:	64 ef       	ldi	r22, 0xF4	; 244
     c62:	71 e0       	ldi	r23, 0x01	; 1
     c64:	80 e0       	ldi	r24, 0x00	; 0
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     c6c:	c3 cf       	rjmp	.-122    	; 0xbf4 <_ZN10task_sonar3runEv+0x2>

00000c6e <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     c6e:	cf 92       	push	r12
     c70:	df 92       	push	r13
     c72:	ef 92       	push	r14
     c74:	ff 92       	push	r15
     c76:	0f 93       	push	r16
     c78:	1f 93       	push	r17
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	ec 01       	movw	r28, r24
     c80:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     c82:	0e 94 08 14 	call	0x2810	; 0x2810 <_ZN8frt_taskC1EPKchjP8emstream>
     c86:	84 e3       	ldi	r24, 0x34	; 52
     c88:	90 e2       	ldi	r25, 0x20	; 32
     c8a:	88 83       	st	Y, r24
     c8c:	99 83       	std	Y+1, r25	; 0x01
     c8e:	ec 8a       	std	Y+20, r14	; 0x14
     c90:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     c92:	ce 8a       	std	Y+22, r12	; 0x16
     c94:	df 8a       	std	Y+23, r13	; 0x17
}
     c96:	df 91       	pop	r29
     c98:	cf 91       	pop	r28
     c9a:	1f 91       	pop	r17
     c9c:	0f 91       	pop	r16
     c9e:	ff 90       	pop	r15
     ca0:	ef 90       	pop	r14
     ca2:	df 90       	pop	r13
     ca4:	cf 90       	pop	r12
     ca6:	08 95       	ret

00000ca8 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     ca8:	0f 93       	push	r16
     caa:	1f 93       	push	r17
     cac:	cf 93       	push	r28
     cae:	df 93       	push	r29
     cb0:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     cb2:	0e 94 08 14 	call	0x2810	; 0x2810 <_ZN8frt_taskC1EPKchjP8emstream>
     cb6:	8c e3       	ldi	r24, 0x3C	; 60
     cb8:	90 e2       	ldi	r25, 0x20	; 32
     cba:	88 83       	st	Y, r24
     cbc:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     cbe:	df 91       	pop	r29
     cc0:	cf 91       	pop	r28
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	08 95       	ret

00000cc8 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     cc8:	0f 93       	push	r16
     cca:	1f 93       	push	r17
     ccc:	cf 93       	push	r28
     cce:	df 93       	push	r29
     cd0:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     cd2:	6a e0       	ldi	r22, 0x0A	; 10
     cd4:	8e 81       	ldd	r24, Y+6	; 0x06
     cd6:	9f 81       	ldd	r25, Y+7	; 0x07
     cd8:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     cdc:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     cde:	61 e8       	ldi	r22, 0x81	; 129
     ce0:	74 e0       	ldi	r23, 0x04	; 4
     ce2:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     ce6:	6a e0       	ldi	r22, 0x0A	; 10
     ce8:	c8 01       	movw	r24, r16
     cea:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     cee:	8c 01       	movw	r16, r24
     cf0:	6b e7       	ldi	r22, 0x7B	; 123
     cf2:	74 e0       	ldi	r23, 0x04	; 4
     cf4:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     cf8:	67 e0       	ldi	r22, 0x07	; 7
     cfa:	c8 01       	movw	r24, r16
     cfc:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     d00:	6a e0       	ldi	r22, 0x0A	; 10
     d02:	8e 81       	ldd	r24, Y+6	; 0x06
     d04:	9f 81       	ldd	r25, Y+7	; 0x07
     d06:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d0a:	8c 01       	movw	r16, r24
     d0c:	6c e5       	ldi	r22, 0x5C	; 92
     d0e:	74 e0       	ldi	r23, 0x04	; 4
     d10:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d14:	6a e0       	ldi	r22, 0x0A	; 10
     d16:	c8 01       	movw	r24, r16
     d18:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d1c:	8c 01       	movw	r16, r24
     d1e:	66 e5       	ldi	r22, 0x56	; 86
     d20:	74 e0       	ldi	r23, 0x04	; 4
     d22:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d26:	66 e0       	ldi	r22, 0x06	; 6
     d28:	c8 01       	movw	r24, r16
     d2a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     d2e:	6a e0       	ldi	r22, 0x0A	; 10
     d30:	8e 81       	ldd	r24, Y+6	; 0x06
     d32:	9f 81       	ldd	r25, Y+7	; 0x07
     d34:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d38:	8c 01       	movw	r16, r24
     d3a:	6f e3       	ldi	r22, 0x3F	; 63
     d3c:	74 e0       	ldi	r23, 0x04	; 4
     d3e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d42:	66 e0       	ldi	r22, 0x06	; 6
     d44:	c8 01       	movw	r24, r16
     d46:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     d4a:	6a e0       	ldi	r22, 0x0A	; 10
     d4c:	8e 81       	ldd	r24, Y+6	; 0x06
     d4e:	9f 81       	ldd	r25, Y+7	; 0x07
     d50:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d54:	8c 01       	movw	r16, r24
     d56:	63 e2       	ldi	r22, 0x23	; 35
     d58:	74 e0       	ldi	r23, 0x04	; 4
     d5a:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d5e:	66 e0       	ldi	r22, 0x06	; 6
     d60:	c8 01       	movw	r24, r16
     d62:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     d66:	6a e0       	ldi	r22, 0x0A	; 10
     d68:	8e 81       	ldd	r24, Y+6	; 0x06
     d6a:	9f 81       	ldd	r25, Y+7	; 0x07
     d6c:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d70:	8c 01       	movw	r16, r24
     d72:	6b e0       	ldi	r22, 0x0B	; 11
     d74:	74 e0       	ldi	r23, 0x04	; 4
     d76:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d7a:	66 e0       	ldi	r22, 0x06	; 6
     d7c:	c8 01       	movw	r24, r16
     d7e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     d82:	6a e0       	ldi	r22, 0x0A	; 10
     d84:	8e 81       	ldd	r24, Y+6	; 0x06
     d86:	9f 81       	ldd	r25, Y+7	; 0x07
     d88:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     d8c:	8c 01       	movw	r16, r24
     d8e:	6a ee       	ldi	r22, 0xEA	; 234
     d90:	73 e0       	ldi	r23, 0x03	; 3
     d92:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     d96:	66 e0       	ldi	r22, 0x06	; 6
     d98:	c8 01       	movw	r24, r16
     d9a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     d9e:	6a e0       	ldi	r22, 0x0A	; 10
     da0:	8e 81       	ldd	r24, Y+6	; 0x06
     da2:	9f 81       	ldd	r25, Y+7	; 0x07
     da4:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     da8:	8c 01       	movw	r16, r24
     daa:	63 ec       	ldi	r22, 0xC3	; 195
     dac:	73 e0       	ldi	r23, 0x03	; 3
     dae:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     db2:	66 e0       	ldi	r22, 0x06	; 6
     db4:	c8 01       	movw	r24, r16
     db6:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     dba:	6a e0       	ldi	r22, 0x0A	; 10
     dbc:	8e 81       	ldd	r24, Y+6	; 0x06
     dbe:	9f 81       	ldd	r25, Y+7	; 0x07
     dc0:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     dc4:	8c 01       	movw	r16, r24
     dc6:	65 ea       	ldi	r22, 0xA5	; 165
     dc8:	73 e0       	ldi	r23, 0x03	; 3
     dca:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     dce:	66 e0       	ldi	r22, 0x06	; 6
     dd0:	c8 01       	movw	r24, r16
     dd2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     dd6:	6a e0       	ldi	r22, 0x0A	; 10
     dd8:	8e 81       	ldd	r24, Y+6	; 0x06
     dda:	9f 81       	ldd	r25, Y+7	; 0x07
     ddc:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     de0:	8c 01       	movw	r16, r24
     de2:	6a e8       	ldi	r22, 0x8A	; 138
     de4:	73 e0       	ldi	r23, 0x03	; 3
     de6:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     dea:	66 e0       	ldi	r22, 0x06	; 6
     dec:	c8 01       	movw	r24, r16
     dee:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     df2:	6a e0       	ldi	r22, 0x0A	; 10
     df4:	8e 81       	ldd	r24, Y+6	; 0x06
     df6:	9f 81       	ldd	r25, Y+7	; 0x07
     df8:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     dfc:	ec 01       	movw	r28, r24
     dfe:	6b e7       	ldi	r22, 0x7B	; 123
     e00:	73 e0       	ldi	r23, 0x03	; 3
     e02:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     e06:	66 e0       	ldi	r22, 0x06	; 6
     e08:	ce 01       	movw	r24, r28
     e0a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
}
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	08 95       	ret

00000e18 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     e18:	af 92       	push	r10
     e1a:	bf 92       	push	r11
     e1c:	cf 92       	push	r12
     e1e:	df 92       	push	r13
     e20:	ef 92       	push	r14
     e22:	ff 92       	push	r15
     e24:	0f 93       	push	r16
     e26:	1f 93       	push	r17
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	00 d0       	rcall	.+0      	; 0xe2e <_ZN9task_user11show_statusEv+0x16>
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <_ZN9task_user11show_statusEv+0x18>
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     e36:	19 82       	std	Y+1, r1	; 0x01
     e38:	1a 82       	std	Y+2, r1	; 0x02
     e3a:	1b 82       	std	Y+3, r1	; 0x03
     e3c:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     e3e:	1d 82       	std	Y+5, r1	; 0x05
     e40:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     e42:	0e 94 91 09 	call	0x1322	; 0x1322 <xPortGetFreeHeapSize>
     e46:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     e48:	ce 01       	movw	r24, r28
     e4a:	01 96       	adiw	r24, 0x01	; 1
     e4c:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <_ZN10time_stamp10set_to_nowEv>
     e50:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     e52:	66 e0       	ldi	r22, 0x06	; 6
     e54:	f8 01       	movw	r30, r16
     e56:	86 81       	ldd	r24, Z+6	; 0x06
     e58:	97 81       	ldd	r25, Z+7	; 0x07
     e5a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     e5e:	6a e0       	ldi	r22, 0x0A	; 10
     e60:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     e64:	7c 01       	movw	r14, r24
     e66:	6c e5       	ldi	r22, 0x5C	; 92
     e68:	73 e0       	ldi	r23, 0x03	; 3
     e6a:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     e6e:	6a e0       	ldi	r22, 0x0A	; 10
     e70:	c7 01       	movw	r24, r14
     e72:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     e76:	7c 01       	movw	r14, r24
     e78:	60 e5       	ldi	r22, 0x50	; 80
     e7a:	73 e0       	ldi	r23, 0x03	; 3
     e7c:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     e80:	66 e0       	ldi	r22, 0x06	; 6
     e82:	c7 01       	movw	r24, r14
     e84:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     e88:	6a e0       	ldi	r22, 0x0A	; 10
     e8a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     e8e:	7c 01       	movw	r14, r24
     e90:	69 e4       	ldi	r22, 0x49	; 73
     e92:	73 e0       	ldi	r23, 0x03	; 3
     e94:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     e98:	b5 01       	movw	r22, r10
     e9a:	c7 01       	movw	r24, r14
     e9c:	0e 94 5d 17 	call	0x2eba	; 0x2eba <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     ea0:	6a e0       	ldi	r22, 0x0A	; 10
     ea2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     ea6:	7c 01       	movw	r14, r24
     ea8:	6b e3       	ldi	r22, 0x3B	; 59
     eaa:	73 e0       	ldi	r23, 0x03	; 3
     eac:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     eb0:	b6 01       	movw	r22, r12
     eb2:	c7 01       	movw	r24, r14
     eb4:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
     eb8:	6a e0       	ldi	r22, 0x0A	; 10
     eba:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     ebe:	7c 01       	movw	r14, r24
     ec0:	69 e3       	ldi	r22, 0x39	; 57
     ec2:	73 e0       	ldi	r23, 0x03	; 3
     ec4:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     ec8:	4f ef       	ldi	r20, 0xFF	; 255
     eca:	5f e0       	ldi	r21, 0x0F	; 15
     ecc:	60 e0       	ldi	r22, 0x00	; 0
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	c7 01       	movw	r24, r14
     ed2:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     ed6:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     eda:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     ede:	6a e0       	ldi	r22, 0x0A	; 10
     ee0:	f8 01       	movw	r30, r16
     ee2:	86 81       	ldd	r24, Z+6	; 0x06
     ee4:	97 81       	ldd	r25, Z+7	; 0x07
     ee6:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     eea:	7c 01       	movw	r14, r24
     eec:	6e e2       	ldi	r22, 0x2E	; 46
     eee:	73 e0       	ldi	r23, 0x03	; 3
     ef0:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     ef4:	b6 01       	movw	r22, r12
     ef6:	c7 01       	movw	r24, r14
     ef8:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
     efc:	66 e0       	ldi	r22, 0x06	; 6
     efe:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     f02:	66 e0       	ldi	r22, 0x06	; 6
     f04:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     f08:	f8 01       	movw	r30, r16
     f0a:	86 81       	ldd	r24, Z+6	; 0x06
     f0c:	97 81       	ldd	r25, Z+7	; 0x07
     f0e:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <_Z15print_task_listP8emstream>
}
     f12:	26 96       	adiw	r28, 0x06	; 6
     f14:	cd bf       	out	0x3d, r28	; 61
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	1f 91       	pop	r17
     f1e:	0f 91       	pop	r16
     f20:	ff 90       	pop	r15
     f22:	ef 90       	pop	r14
     f24:	df 90       	pop	r13
     f26:	cf 90       	pop	r12
     f28:	bf 90       	pop	r11
     f2a:	af 90       	pop	r10
     f2c:	08 95       	ret

00000f2e <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     f2e:	cf 93       	push	r28
     f30:	df 93       	push	r29
     f32:	00 d0       	rcall	.+0      	; 0xf34 <_ZN9task_user3runEv+0x6>
     f34:	00 d0       	rcall	.+0      	; 0xf36 <_ZN9task_user3runEv+0x8>
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
     f3a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     f3c:	19 82       	std	Y+1, r1	; 0x01
     f3e:	1a 82       	std	Y+2, r1	; 0x02
     f40:	1b 82       	std	Y+3, r1	; 0x03
     f42:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     f44:	1d 82       	std	Y+5, r1	; 0x05
     f46:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     f48:	6a e0       	ldi	r22, 0x0A	; 10
     f4a:	dc 01       	movw	r26, r24
     f4c:	16 96       	adiw	r26, 0x06	; 6
     f4e:	8d 91       	ld	r24, X+
     f50:	9c 91       	ld	r25, X
     f52:	17 97       	sbiw	r26, 0x07	; 7
     f54:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     f58:	7c 01       	movw	r14, r24
     f5a:	6a ec       	ldi	r22, 0xCA	; 202
     f5c:	74 e0       	ldi	r23, 0x04	; 4
     f5e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     f62:	66 e0       	ldi	r22, 0x06	; 6
     f64:	c7 01       	movw	r24, r14
     f66:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     f6a:	f8 01       	movw	r30, r16
     f6c:	84 85       	ldd	r24, Z+12	; 0x0c
     f6e:	88 23       	and	r24, r24
     f70:	21 f0       	breq	.+8      	; 0xf7a <_ZN9task_user3runEv+0x4c>
     f72:	81 30       	cpi	r24, 0x01	; 1
     f74:	09 f4       	brne	.+2      	; 0xf78 <_ZN9task_user3runEv+0x4a>
     f76:	5d c0       	rjmp	.+186    	; 0x1032 <_ZN9task_user3runEv+0x104>
     f78:	d8 c0       	rjmp	.+432    	; 0x112a <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     f7a:	86 81       	ldd	r24, Z+6	; 0x06
     f7c:	97 81       	ldd	r25, Z+7	; 0x07
     f7e:	dc 01       	movw	r26, r24
     f80:	ed 91       	ld	r30, X+
     f82:	fc 91       	ld	r31, X
     f84:	04 80       	ldd	r0, Z+4	; 0x04
     f86:	f5 81       	ldd	r31, Z+5	; 0x05
     f88:	e0 2d       	mov	r30, r0
     f8a:	19 95       	eicall
     f8c:	88 23       	and	r24, r24
     f8e:	a9 f1       	breq	.+106    	; 0xffa <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     f90:	f8 01       	movw	r30, r16
     f92:	86 81       	ldd	r24, Z+6	; 0x06
     f94:	97 81       	ldd	r25, Z+7	; 0x07
     f96:	dc 01       	movw	r26, r24
     f98:	ed 91       	ld	r30, X+
     f9a:	fc 91       	ld	r31, X
     f9c:	06 80       	ldd	r0, Z+6	; 0x06
     f9e:	f7 81       	ldd	r31, Z+7	; 0x07
     fa0:	e0 2d       	mov	r30, r0
     fa2:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     fa4:	99 27       	eor	r25, r25
     fa6:	81 30       	cpi	r24, 0x01	; 1
     fa8:	91 05       	cpc	r25, r1
     faa:	f9 f0       	breq	.+62     	; 0xfea <_ZN9task_user3runEv+0xbc>
     fac:	03 97       	sbiw	r24, 0x03	; 3
     fae:	09 f0       	breq	.+2      	; 0xfb2 <_ZN9task_user3runEv+0x84>
     fb0:	d8 c0       	rjmp	.+432    	; 0x1162 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     fb2:	6a e0       	ldi	r22, 0x0A	; 10
     fb4:	f8 01       	movw	r30, r16
     fb6:	86 81       	ldd	r24, Z+6	; 0x06
     fb8:	97 81       	ldd	r25, Z+7	; 0x07
     fba:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
     fbe:	8c 01       	movw	r16, r24
     fc0:	6c eb       	ldi	r22, 0xBC	; 188
     fc2:	74 e0       	ldi	r23, 0x04	; 4
     fc4:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
     fc8:	66 e0       	ldi	r22, 0x06	; 6
     fca:	c8 01       	movw	r24, r16
     fcc:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     fd0:	93 e0       	ldi	r25, 0x03	; 3
     fd2:	88 ed       	ldi	r24, 0xD8	; 216
     fd4:	08 b6       	in	r0, 0x38	; 56
     fd6:	18 be       	out	0x38, r1	; 56
     fd8:	84 bf       	out	0x34, r24	; 52
     fda:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     fde:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     fe2:	81 fd       	sbrc	r24, 1
     fe4:	fc cf       	rjmp	.-8      	; 0xfde <_ZN9task_user3runEv+0xb0>
     fe6:	08 be       	out	0x38, r0	; 56
     fe8:	ff cf       	rjmp	.-2      	; 0xfe8 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     fea:	c8 01       	movw	r24, r16
     fec:	0e 94 64 06 	call	0xcc8	; 0xcc8 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     ff0:	61 e0       	ldi	r22, 0x01	; 1
     ff2:	c8 01       	movw	r24, r16
     ff4:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task13transition_toEh>
							break;
     ff8:	b4 c0       	rjmp	.+360    	; 0x1162 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     ffa:	8e ea       	ldi	r24, 0xAE	; 174
     ffc:	91 e3       	ldi	r25, 0x31	; 49
     ffe:	0e 94 c5 16 	call	0x2d8a	; 0x2d8a <_ZN14frt_text_queue14check_for_charEv>
    1002:	88 23       	and	r24, r24
    1004:	09 f4       	brne	.+2      	; 0x1008 <_ZN9task_user3runEv+0xda>
    1006:	ad c0       	rjmp	.+346    	; 0x1162 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
    1008:	d8 01       	movw	r26, r16
    100a:	16 96       	adiw	r26, 0x06	; 6
    100c:	ed 91       	ld	r30, X+
    100e:	fc 91       	ld	r31, X
    1010:	17 97       	sbiw	r26, 0x07	; 7
    1012:	01 90       	ld	r0, Z+
    1014:	f0 81       	ld	r31, Z
    1016:	e0 2d       	mov	r30, r0
    1018:	e2 80       	ldd	r14, Z+2	; 0x02
    101a:	f3 80       	ldd	r15, Z+3	; 0x03
    101c:	8e ea       	ldi	r24, 0xAE	; 174
    101e:	91 e3       	ldi	r25, 0x31	; 49
    1020:	0e 94 a7 16 	call	0x2d4e	; 0x2d4e <_ZN14frt_text_queue7getcharEv>
    1024:	68 2f       	mov	r22, r24
    1026:	f8 01       	movw	r30, r16
    1028:	86 81       	ldd	r24, Z+6	; 0x06
    102a:	97 81       	ldd	r25, Z+7	; 0x07
    102c:	f7 01       	movw	r30, r14
    102e:	19 95       	eicall
    1030:	98 c0       	rjmp	.+304    	; 0x1162 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
    1032:	86 81       	ldd	r24, Z+6	; 0x06
    1034:	97 81       	ldd	r25, Z+7	; 0x07
    1036:	dc 01       	movw	r26, r24
    1038:	ed 91       	ld	r30, X+
    103a:	fc 91       	ld	r31, X
    103c:	04 80       	ldd	r0, Z+4	; 0x04
    103e:	f5 81       	ldd	r31, Z+5	; 0x05
    1040:	e0 2d       	mov	r30, r0
    1042:	19 95       	eicall
    1044:	88 23       	and	r24, r24
    1046:	09 f4       	brne	.+2      	; 0x104a <_ZN9task_user3runEv+0x11c>
    1048:	8c c0       	rjmp	.+280    	; 0x1162 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
    104a:	f8 01       	movw	r30, r16
    104c:	86 81       	ldd	r24, Z+6	; 0x06
    104e:	97 81       	ldd	r25, Z+7	; 0x07
    1050:	dc 01       	movw	r26, r24
    1052:	ed 91       	ld	r30, X+
    1054:	fc 91       	ld	r31, X
    1056:	06 80       	ldd	r0, Z+6	; 0x06
    1058:	f7 81       	ldd	r31, Z+7	; 0x07
    105a:	e0 2d       	mov	r30, r0
    105c:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
    105e:	9c 01       	movw	r18, r24
    1060:	33 27       	eor	r19, r19
    1062:	28 36       	cpi	r18, 0x68	; 104
    1064:	31 05       	cpc	r19, r1
    1066:	59 f1       	breq	.+86     	; 0x10be <_ZN9task_user3runEv+0x190>
    1068:	3c f4       	brge	.+14     	; 0x1078 <_ZN9task_user3runEv+0x14a>
    106a:	2b 31       	cpi	r18, 0x1B	; 27
    106c:	31 05       	cpc	r19, r1
    106e:	59 f1       	breq	.+86     	; 0x10c6 <_ZN9task_user3runEv+0x198>
    1070:	25 36       	cpi	r18, 0x65	; 101
    1072:	31 05       	cpc	r19, r1
    1074:	41 f1       	breq	.+80     	; 0x10c6 <_ZN9task_user3runEv+0x198>
    1076:	3b c0       	rjmp	.+118    	; 0x10ee <_ZN9task_user3runEv+0x1c0>
    1078:	23 37       	cpi	r18, 0x73	; 115
    107a:	31 05       	cpc	r19, r1
    107c:	c1 f0       	breq	.+48     	; 0x10ae <_ZN9task_user3runEv+0x180>
    107e:	26 37       	cpi	r18, 0x76	; 118
    1080:	31 05       	cpc	r19, r1
    1082:	89 f0       	breq	.+34     	; 0x10a6 <_ZN9task_user3runEv+0x178>
    1084:	2e 36       	cpi	r18, 0x6E	; 110
    1086:	31 05       	cpc	r19, r1
    1088:	91 f5       	brne	.+100    	; 0x10ee <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
    108a:	ce 01       	movw	r24, r28
    108c:	01 96       	adiw	r24, 0x01	; 1
    108e:	0e 94 b9 17 	call	0x2f72	; 0x2f72 <_ZN10time_stamp10set_to_nowEv>
    1092:	bc 01       	movw	r22, r24
    1094:	f8 01       	movw	r30, r16
    1096:	86 81       	ldd	r24, Z+6	; 0x06
    1098:	97 81       	ldd	r25, Z+7	; 0x07
    109a:	0e 94 5d 17 	call	0x2eba	; 0x2eba <_ZlsR8emstreamR10time_stamp>
    109e:	66 e0       	ldi	r22, 0x06	; 6
    10a0:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
							break;
    10a4:	5e c0       	rjmp	.+188    	; 0x1162 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
    10a6:	c8 01       	movw	r24, r16
    10a8:	0e 94 0c 07 	call	0xe18	; 0xe18 <_ZN9task_user11show_statusEv>
							break;
    10ac:	5a c0       	rjmp	.+180    	; 0x1162 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
    10ae:	d8 01       	movw	r26, r16
    10b0:	16 96       	adiw	r26, 0x06	; 6
    10b2:	8d 91       	ld	r24, X+
    10b4:	9c 91       	ld	r25, X
    10b6:	17 97       	sbiw	r26, 0x07	; 7
    10b8:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <_Z17print_task_stacksP8emstream>
							break;
    10bc:	52 c0       	rjmp	.+164    	; 0x1162 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
    10be:	c8 01       	movw	r24, r16
    10c0:	0e 94 64 06 	call	0xcc8	; 0xcc8 <_ZN9task_user18print_help_messageEv>
							break;
    10c4:	4e c0       	rjmp	.+156    	; 0x1162 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
    10c6:	6a e0       	ldi	r22, 0x0A	; 10
    10c8:	f8 01       	movw	r30, r16
    10ca:	86 81       	ldd	r24, Z+6	; 0x06
    10cc:	97 81       	ldd	r25, Z+7	; 0x07
    10ce:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    10d2:	7c 01       	movw	r14, r24
    10d4:	6a ea       	ldi	r22, 0xAA	; 170
    10d6:	74 e0       	ldi	r23, 0x04	; 4
    10d8:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    10dc:	66 e0       	ldi	r22, 0x06	; 6
    10de:	c7 01       	movw	r24, r14
    10e0:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	c8 01       	movw	r24, r16
    10e8:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN8frt_task13transition_toEh>
							break;
    10ec:	3a c0       	rjmp	.+116    	; 0x1162 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
    10ee:	f8 01       	movw	r30, r16
    10f0:	a6 81       	ldd	r26, Z+6	; 0x06
    10f2:	b7 81       	ldd	r27, Z+7	; 0x07
    10f4:	ed 91       	ld	r30, X+
    10f6:	fc 91       	ld	r31, X
    10f8:	11 97       	sbiw	r26, 0x01	; 1
    10fa:	02 80       	ldd	r0, Z+2	; 0x02
    10fc:	f3 81       	ldd	r31, Z+3	; 0x03
    10fe:	e0 2d       	mov	r30, r0
    1100:	68 2f       	mov	r22, r24
    1102:	cd 01       	movw	r24, r26
    1104:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
    1106:	6a e0       	ldi	r22, 0x0A	; 10
    1108:	d8 01       	movw	r26, r16
    110a:	16 96       	adiw	r26, 0x06	; 6
    110c:	8d 91       	ld	r24, X+
    110e:	9c 91       	ld	r25, X
    1110:	17 97       	sbiw	r26, 0x07	; 7
    1112:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    1116:	7c 01       	movw	r14, r24
    1118:	64 ea       	ldi	r22, 0xA4	; 164
    111a:	74 e0       	ldi	r23, 0x04	; 4
    111c:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    1120:	66 e0       	ldi	r22, 0x06	; 6
    1122:	c7 01       	movw	r24, r14
    1124:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
							break;
    1128:	1c c0       	rjmp	.+56     	; 0x1162 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
    112a:	6a e0       	ldi	r22, 0x0A	; 10
    112c:	f8 01       	movw	r30, r16
    112e:	86 81       	ldd	r24, Z+6	; 0x06
    1130:	97 81       	ldd	r25, Z+7	; 0x07
    1132:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    1136:	8c 01       	movw	r16, r24
    1138:	67 e8       	ldi	r22, 0x87	; 135
    113a:	74 e0       	ldi	r23, 0x04	; 4
    113c:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    1140:	66 e0       	ldi	r22, 0x06	; 6
    1142:	c8 01       	movw	r24, r16
    1144:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1148:	93 e0       	ldi	r25, 0x03	; 3
    114a:	88 ed       	ldi	r24, 0xD8	; 216
    114c:	08 b6       	in	r0, 0x38	; 56
    114e:	18 be       	out	0x38, r1	; 56
    1150:	84 bf       	out	0x34, r24	; 52
    1152:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1156:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    115a:	81 fd       	sbrc	r24, 1
    115c:	fc cf       	rjmp	.-8      	; 0x1156 <_ZN9task_user3runEv+0x228>
    115e:	08 be       	out	0x38, r0	; 56
    1160:	ff cf       	rjmp	.-2      	; 0x1160 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    1162:	f8 01       	movw	r30, r16
    1164:	86 85       	ldd	r24, Z+14	; 0x0e
    1166:	97 85       	ldd	r25, Z+15	; 0x0f
    1168:	a0 89       	ldd	r26, Z+16	; 0x10
    116a:	b1 89       	ldd	r27, Z+17	; 0x11
    116c:	01 96       	adiw	r24, 0x01	; 1
    116e:	a1 1d       	adc	r26, r1
    1170:	b1 1d       	adc	r27, r1
    1172:	86 87       	std	Z+14, r24	; 0x0e
    1174:	97 87       	std	Z+15, r25	; 0x0f
    1176:	a0 8b       	std	Z+16, r26	; 0x10
    1178:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    117a:	61 e0       	ldi	r22, 0x01	; 1
    117c:	70 e0       	ldi	r23, 0x00	; 0
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1186:	f1 ce       	rjmp	.-542    	; 0xf6a <_ZN9task_user3runEv+0x3c>

00001188 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1188:	0f 93       	push	r16
    118a:	1f 93       	push	r17
    118c:	cf 93       	push	r28
    118e:	df 93       	push	r29
    1190:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1192:	0e 94 34 10 	call	0x2068	; 0x2068 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1196:	80 91 f2 20 	lds	r24, 0x20F2	; 0x8020f2 <__data_end>
    119a:	81 11       	cpse	r24, r1
    119c:	1d c0       	rjmp	.+58     	; 0x11d8 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    119e:	a7 ef       	ldi	r26, 0xF7	; 247
    11a0:	b0 e2       	ldi	r27, 0x20	; 32
    11a2:	eb ef       	ldi	r30, 0xFB	; 251
    11a4:	f0 e2       	ldi	r31, 0x20	; 32
    11a6:	ed 93       	st	X+, r30
    11a8:	fc 93       	st	X, r31
    11aa:	11 97       	sbiw	r26, 0x01	; 1
    11ac:	12 96       	adiw	r26, 0x02	; 2
    11ae:	1d 92       	st	X+, r1
    11b0:	1c 92       	st	X, r1
    11b2:	13 97       	sbiw	r26, 0x03	; 3
    11b4:	a3 ef       	ldi	r26, 0xF3	; 243
    11b6:	b0 e2       	ldi	r27, 0x20	; 32
    11b8:	8f ef       	ldi	r24, 0xFF	; 255
    11ba:	9f e0       	ldi	r25, 0x0F	; 15
    11bc:	12 96       	adiw	r26, 0x02	; 2
    11be:	8d 93       	st	X+, r24
    11c0:	9c 93       	st	X, r25
    11c2:	13 97       	sbiw	r26, 0x03	; 3
    11c4:	1d 92       	st	X+, r1
    11c6:	1c 92       	st	X, r1
    11c8:	11 97       	sbiw	r26, 0x01	; 1
    11ca:	82 83       	std	Z+2, r24	; 0x02
    11cc:	93 83       	std	Z+3, r25	; 0x03
    11ce:	a0 83       	st	Z, r26
    11d0:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	80 93 f2 20 	sts	0x20F2, r24	; 0x8020f2 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    11d8:	20 97       	sbiw	r28, 0x00	; 0
    11da:	09 f4       	brne	.+2      	; 0x11de <pvPortMalloc+0x56>
    11dc:	5f c0       	rjmp	.+190    	; 0x129c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    11de:	9e 01       	movw	r18, r28
    11e0:	2b 5f       	subi	r18, 0xFB	; 251
    11e2:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    11e4:	24 96       	adiw	r28, 0x04	; 4
    11e6:	ce 3f       	cpi	r28, 0xFE	; 254
    11e8:	df 40       	sbci	r29, 0x0F	; 15
    11ea:	08 f0       	brcs	.+2      	; 0x11ee <pvPortMalloc+0x66>
    11ec:	5a c0       	rjmp	.+180    	; 0x12a2 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    11ee:	e0 91 f7 20 	lds	r30, 0x20F7	; 0x8020f7 <xStart>
    11f2:	f0 91 f8 20 	lds	r31, 0x20F8	; 0x8020f8 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    11f6:	a7 ef       	ldi	r26, 0xF7	; 247
    11f8:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    11fa:	02 c0       	rjmp	.+4      	; 0x1200 <pvPortMalloc+0x78>
    11fc:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    11fe:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    1200:	82 81       	ldd	r24, Z+2	; 0x02
    1202:	93 81       	ldd	r25, Z+3	; 0x03
    1204:	82 17       	cp	r24, r18
    1206:	93 07       	cpc	r25, r19
    1208:	20 f4       	brcc	.+8      	; 0x1212 <pvPortMalloc+0x8a>
    120a:	80 81       	ld	r24, Z
    120c:	91 81       	ldd	r25, Z+1	; 0x01
    120e:	00 97       	sbiw	r24, 0x00	; 0
    1210:	a9 f7       	brne	.-22     	; 0x11fc <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    1212:	c0 e2       	ldi	r28, 0x20	; 32
    1214:	e3 3f       	cpi	r30, 0xF3	; 243
    1216:	fc 07       	cpc	r31, r28
    1218:	09 f4       	brne	.+2      	; 0x121c <pvPortMalloc+0x94>
    121a:	46 c0       	rjmp	.+140    	; 0x12a8 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    121c:	cd 91       	ld	r28, X+
    121e:	dc 91       	ld	r29, X
    1220:	11 97       	sbiw	r26, 0x01	; 1
    1222:	8e 01       	movw	r16, r28
    1224:	0b 5f       	subi	r16, 0xFB	; 251
    1226:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1228:	80 81       	ld	r24, Z
    122a:	91 81       	ldd	r25, Z+1	; 0x01
    122c:	8d 93       	st	X+, r24
    122e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1230:	82 81       	ldd	r24, Z+2	; 0x02
    1232:	93 81       	ldd	r25, Z+3	; 0x03
    1234:	82 1b       	sub	r24, r18
    1236:	93 0b       	sbc	r25, r19
    1238:	8b 30       	cpi	r24, 0x0B	; 11
    123a:	91 05       	cpc	r25, r1
    123c:	10 f1       	brcs	.+68     	; 0x1282 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    123e:	bf 01       	movw	r22, r30
    1240:	62 0f       	add	r22, r18
    1242:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1244:	db 01       	movw	r26, r22
    1246:	12 96       	adiw	r26, 0x02	; 2
    1248:	8d 93       	st	X+, r24
    124a:	9c 93       	st	X, r25
    124c:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    124e:	22 83       	std	Z+2, r18	; 0x02
    1250:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1252:	12 96       	adiw	r26, 0x02	; 2
    1254:	4d 91       	ld	r20, X+
    1256:	5c 91       	ld	r21, X
    1258:	13 97       	sbiw	r26, 0x03	; 3
    125a:	87 ef       	ldi	r24, 0xF7	; 247
    125c:	90 e2       	ldi	r25, 0x20	; 32
    125e:	01 c0       	rjmp	.+2      	; 0x1262 <pvPortMalloc+0xda>
    1260:	cd 01       	movw	r24, r26
    1262:	ec 01       	movw	r28, r24
    1264:	a8 81       	ld	r26, Y
    1266:	b9 81       	ldd	r27, Y+1	; 0x01
    1268:	12 96       	adiw	r26, 0x02	; 2
    126a:	2d 91       	ld	r18, X+
    126c:	3c 91       	ld	r19, X
    126e:	13 97       	sbiw	r26, 0x03	; 3
    1270:	24 17       	cp	r18, r20
    1272:	35 07       	cpc	r19, r21
    1274:	a8 f3       	brcs	.-22     	; 0x1260 <pvPortMalloc+0xd8>
    1276:	eb 01       	movw	r28, r22
    1278:	a8 83       	st	Y, r26
    127a:	b9 83       	std	Y+1, r27	; 0x01
    127c:	dc 01       	movw	r26, r24
    127e:	6d 93       	st	X+, r22
    1280:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1282:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1286:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    128a:	22 81       	ldd	r18, Z+2	; 0x02
    128c:	33 81       	ldd	r19, Z+3	; 0x03
    128e:	82 1b       	sub	r24, r18
    1290:	93 0b       	sbc	r25, r19
    1292:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1296:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    129a:	08 c0       	rjmp	.+16     	; 0x12ac <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    129c:	00 e0       	ldi	r16, 0x00	; 0
    129e:	10 e0       	ldi	r17, 0x00	; 0
    12a0:	05 c0       	rjmp	.+10     	; 0x12ac <pvPortMalloc+0x124>
    12a2:	00 e0       	ldi	r16, 0x00	; 0
    12a4:	10 e0       	ldi	r17, 0x00	; 0
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <pvPortMalloc+0x124>
    12a8:	00 e0       	ldi	r16, 0x00	; 0
    12aa:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    12ac:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    12b0:	c8 01       	movw	r24, r16
    12b2:	df 91       	pop	r29
    12b4:	cf 91       	pop	r28
    12b6:	1f 91       	pop	r17
    12b8:	0f 91       	pop	r16
    12ba:	08 95       	ret

000012bc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    12bc:	0f 93       	push	r16
    12be:	1f 93       	push	r17
    12c0:	cf 93       	push	r28
    12c2:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    12c4:	00 97       	sbiw	r24, 0x00	; 0
    12c6:	41 f1       	breq	.+80     	; 0x1318 <vPortFree+0x5c>
    12c8:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    12ca:	8c 01       	movw	r16, r24
    12cc:	05 50       	subi	r16, 0x05	; 5
    12ce:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    12d0:	0e 94 34 10 	call	0x2068	; 0x2068 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    12d4:	f8 01       	movw	r30, r16
    12d6:	42 81       	ldd	r20, Z+2	; 0x02
    12d8:	53 81       	ldd	r21, Z+3	; 0x03
    12da:	a7 ef       	ldi	r26, 0xF7	; 247
    12dc:	b0 e2       	ldi	r27, 0x20	; 32
    12de:	01 c0       	rjmp	.+2      	; 0x12e2 <vPortFree+0x26>
    12e0:	df 01       	movw	r26, r30
    12e2:	ed 91       	ld	r30, X+
    12e4:	fc 91       	ld	r31, X
    12e6:	11 97       	sbiw	r26, 0x01	; 1
    12e8:	22 81       	ldd	r18, Z+2	; 0x02
    12ea:	33 81       	ldd	r19, Z+3	; 0x03
    12ec:	24 17       	cp	r18, r20
    12ee:	35 07       	cpc	r19, r21
    12f0:	b8 f3       	brcs	.-18     	; 0x12e0 <vPortFree+0x24>
    12f2:	25 97       	sbiw	r28, 0x05	; 5
    12f4:	e8 83       	st	Y, r30
    12f6:	f9 83       	std	Y+1, r31	; 0x01
    12f8:	0d 93       	st	X+, r16
    12fa:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    12fc:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    1300:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    1304:	8a 81       	ldd	r24, Y+2	; 0x02
    1306:	9b 81       	ldd	r25, Y+3	; 0x03
    1308:	82 0f       	add	r24, r18
    130a:	93 1f       	adc	r25, r19
    130c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1310:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    1314:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
	}
}
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	08 95       	ret

00001322 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1322:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1326:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    132a:	08 95       	ret

0000132c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    132c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    132e:	03 96       	adiw	r24, 0x03	; 3
    1330:	81 83       	std	Z+1, r24	; 0x01
    1332:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1334:	4f ef       	ldi	r20, 0xFF	; 255
    1336:	5f ef       	ldi	r21, 0xFF	; 255
    1338:	ba 01       	movw	r22, r20
    133a:	43 83       	std	Z+3, r20	; 0x03
    133c:	54 83       	std	Z+4, r21	; 0x04
    133e:	65 83       	std	Z+5, r22	; 0x05
    1340:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1342:	87 83       	std	Z+7, r24	; 0x07
    1344:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1346:	81 87       	std	Z+9, r24	; 0x09
    1348:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    134a:	10 82       	st	Z, r1
    134c:	08 95       	ret

0000134e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    134e:	fc 01       	movw	r30, r24
    1350:	12 86       	std	Z+10, r1	; 0x0a
    1352:	13 86       	std	Z+11, r1	; 0x0b
    1354:	08 95       	ret

00001356 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1356:	cf 93       	push	r28
    1358:	df 93       	push	r29
    135a:	fc 01       	movw	r30, r24
    135c:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    135e:	21 81       	ldd	r18, Z+1	; 0x01
    1360:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1362:	e9 01       	movw	r28, r18
    1364:	8c 81       	ldd	r24, Y+4	; 0x04
    1366:	9d 81       	ldd	r25, Y+5	; 0x05
    1368:	14 96       	adiw	r26, 0x04	; 4
    136a:	8d 93       	st	X+, r24
    136c:	9c 93       	st	X, r25
    136e:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1370:	81 81       	ldd	r24, Z+1	; 0x01
    1372:	92 81       	ldd	r25, Z+2	; 0x02
    1374:	16 96       	adiw	r26, 0x06	; 6
    1376:	8d 93       	st	X+, r24
    1378:	9c 93       	st	X, r25
    137a:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    137c:	8c 81       	ldd	r24, Y+4	; 0x04
    137e:	9d 81       	ldd	r25, Y+5	; 0x05
    1380:	ec 01       	movw	r28, r24
    1382:	6e 83       	std	Y+6, r22	; 0x06
    1384:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1386:	e9 01       	movw	r28, r18
    1388:	6c 83       	std	Y+4, r22	; 0x04
    138a:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    138c:	61 83       	std	Z+1, r22	; 0x01
    138e:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1390:	1a 96       	adiw	r26, 0x0a	; 10
    1392:	ed 93       	st	X+, r30
    1394:	fc 93       	st	X, r31
    1396:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1398:	80 81       	ld	r24, Z
    139a:	8f 5f       	subi	r24, 0xFF	; 255
    139c:	80 83       	st	Z, r24
}
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	08 95       	ret

000013a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    13a4:	0f 93       	push	r16
    13a6:	1f 93       	push	r17
    13a8:	cf 93       	push	r28
    13aa:	df 93       	push	r29
    13ac:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    13ae:	08 81       	ld	r16, Y
    13b0:	19 81       	ldd	r17, Y+1	; 0x01
    13b2:	2a 81       	ldd	r18, Y+2	; 0x02
    13b4:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    13b6:	0f 3f       	cpi	r16, 0xFF	; 255
    13b8:	4f ef       	ldi	r20, 0xFF	; 255
    13ba:	14 07       	cpc	r17, r20
    13bc:	24 07       	cpc	r18, r20
    13be:	34 07       	cpc	r19, r20
    13c0:	31 f4       	brne	.+12     	; 0x13ce <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    13c2:	dc 01       	movw	r26, r24
    13c4:	19 96       	adiw	r26, 0x09	; 9
    13c6:	ed 91       	ld	r30, X+
    13c8:	fc 91       	ld	r31, X
    13ca:	1a 97       	sbiw	r26, 0x0a	; 10
    13cc:	1f c0       	rjmp	.+62     	; 0x140c <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    13ce:	fc 01       	movw	r30, r24
    13d0:	33 96       	adiw	r30, 0x03	; 3
    13d2:	dc 01       	movw	r26, r24
    13d4:	17 96       	adiw	r26, 0x07	; 7
    13d6:	4d 91       	ld	r20, X+
    13d8:	5c 91       	ld	r21, X
    13da:	18 97       	sbiw	r26, 0x08	; 8
    13dc:	da 01       	movw	r26, r20
    13de:	4d 91       	ld	r20, X+
    13e0:	5d 91       	ld	r21, X+
    13e2:	6d 91       	ld	r22, X+
    13e4:	7c 91       	ld	r23, X
    13e6:	04 17       	cp	r16, r20
    13e8:	15 07       	cpc	r17, r21
    13ea:	26 07       	cpc	r18, r22
    13ec:	37 07       	cpc	r19, r23
    13ee:	70 f0       	brcs	.+28     	; 0x140c <vListInsert+0x68>
    13f0:	04 80       	ldd	r0, Z+4	; 0x04
    13f2:	f5 81       	ldd	r31, Z+5	; 0x05
    13f4:	e0 2d       	mov	r30, r0
    13f6:	a4 81       	ldd	r26, Z+4	; 0x04
    13f8:	b5 81       	ldd	r27, Z+5	; 0x05
    13fa:	4d 91       	ld	r20, X+
    13fc:	5d 91       	ld	r21, X+
    13fe:	6d 91       	ld	r22, X+
    1400:	7c 91       	ld	r23, X
    1402:	04 17       	cp	r16, r20
    1404:	15 07       	cpc	r17, r21
    1406:	26 07       	cpc	r18, r22
    1408:	37 07       	cpc	r19, r23
    140a:	90 f7       	brcc	.-28     	; 0x13f0 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    140c:	a4 81       	ldd	r26, Z+4	; 0x04
    140e:	b5 81       	ldd	r27, Z+5	; 0x05
    1410:	ac 83       	std	Y+4, r26	; 0x04
    1412:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1414:	16 96       	adiw	r26, 0x06	; 6
    1416:	cd 93       	st	X+, r28
    1418:	dc 93       	st	X, r29
    141a:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    141c:	ee 83       	std	Y+6, r30	; 0x06
    141e:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1420:	c4 83       	std	Z+4, r28	; 0x04
    1422:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1424:	8a 87       	std	Y+10, r24	; 0x0a
    1426:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1428:	fc 01       	movw	r30, r24
    142a:	20 81       	ld	r18, Z
    142c:	2f 5f       	subi	r18, 0xFF	; 255
    142e:	20 83       	st	Z, r18
}
    1430:	df 91       	pop	r29
    1432:	cf 91       	pop	r28
    1434:	1f 91       	pop	r17
    1436:	0f 91       	pop	r16
    1438:	08 95       	ret

0000143a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    143a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    143c:	a4 81       	ldd	r26, Z+4	; 0x04
    143e:	b5 81       	ldd	r27, Z+5	; 0x05
    1440:	86 81       	ldd	r24, Z+6	; 0x06
    1442:	97 81       	ldd	r25, Z+7	; 0x07
    1444:	16 96       	adiw	r26, 0x06	; 6
    1446:	8d 93       	st	X+, r24
    1448:	9c 93       	st	X, r25
    144a:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    144c:	a6 81       	ldd	r26, Z+6	; 0x06
    144e:	b7 81       	ldd	r27, Z+7	; 0x07
    1450:	84 81       	ldd	r24, Z+4	; 0x04
    1452:	95 81       	ldd	r25, Z+5	; 0x05
    1454:	14 96       	adiw	r26, 0x04	; 4
    1456:	8d 93       	st	X+, r24
    1458:	9c 93       	st	X, r25
    145a:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    145c:	a2 85       	ldd	r26, Z+10	; 0x0a
    145e:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1460:	11 96       	adiw	r26, 0x01	; 1
    1462:	8d 91       	ld	r24, X+
    1464:	9c 91       	ld	r25, X
    1466:	12 97       	sbiw	r26, 0x02	; 2
    1468:	e8 17       	cp	r30, r24
    146a:	f9 07       	cpc	r31, r25
    146c:	31 f4       	brne	.+12     	; 0x147a <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    146e:	86 81       	ldd	r24, Z+6	; 0x06
    1470:	97 81       	ldd	r25, Z+7	; 0x07
    1472:	11 96       	adiw	r26, 0x01	; 1
    1474:	8d 93       	st	X+, r24
    1476:	9c 93       	st	X, r25
    1478:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    147a:	12 86       	std	Z+10, r1	; 0x0a
    147c:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    147e:	8c 91       	ld	r24, X
    1480:	81 50       	subi	r24, 0x01	; 1
    1482:	8c 93       	st	X, r24
    1484:	08 95       	ret

00001486 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1486:	80 93 be 31 	sts	0x31BE, r24	; 0x8031be <portStackTopForTask>
    148a:	90 93 bf 31 	sts	0x31BF, r25	; 0x8031bf <portStackTopForTask+0x1>
    148e:	31 e1       	ldi	r19, 0x11	; 17
    1490:	fc 01       	movw	r30, r24
    1492:	30 83       	st	Z, r19
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	22 e2       	ldi	r18, 0x22	; 34
    1498:	20 83       	st	Z, r18
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	a3 e3       	ldi	r26, 0x33	; 51
    149e:	a0 83       	st	Z, r26
    14a0:	31 97       	sbiw	r30, 0x01	; 1
    14a2:	60 83       	st	Z, r22
    14a4:	31 97       	sbiw	r30, 0x01	; 1
    14a6:	70 83       	st	Z, r23
    14a8:	31 97       	sbiw	r30, 0x01	; 1
    14aa:	10 82       	st	Z, r1
    14ac:	31 97       	sbiw	r30, 0x01	; 1
    14ae:	10 82       	st	Z, r1
    14b0:	31 97       	sbiw	r30, 0x01	; 1
    14b2:	60 e8       	ldi	r22, 0x80	; 128
    14b4:	60 83       	st	Z, r22
    14b6:	31 97       	sbiw	r30, 0x01	; 1
    14b8:	10 82       	st	Z, r1
    14ba:	31 97       	sbiw	r30, 0x01	; 1
    14bc:	10 82       	st	Z, r1
    14be:	31 97       	sbiw	r30, 0x01	; 1
    14c0:	10 82       	st	Z, r1
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	62 e0       	ldi	r22, 0x02	; 2
    14c6:	60 83       	st	Z, r22
    14c8:	31 97       	sbiw	r30, 0x01	; 1
    14ca:	63 e0       	ldi	r22, 0x03	; 3
    14cc:	60 83       	st	Z, r22
    14ce:	31 97       	sbiw	r30, 0x01	; 1
    14d0:	64 e0       	ldi	r22, 0x04	; 4
    14d2:	60 83       	st	Z, r22
    14d4:	31 97       	sbiw	r30, 0x01	; 1
    14d6:	65 e0       	ldi	r22, 0x05	; 5
    14d8:	60 83       	st	Z, r22
    14da:	31 97       	sbiw	r30, 0x01	; 1
    14dc:	66 e0       	ldi	r22, 0x06	; 6
    14de:	60 83       	st	Z, r22
    14e0:	31 97       	sbiw	r30, 0x01	; 1
    14e2:	67 e0       	ldi	r22, 0x07	; 7
    14e4:	60 83       	st	Z, r22
    14e6:	31 97       	sbiw	r30, 0x01	; 1
    14e8:	68 e0       	ldi	r22, 0x08	; 8
    14ea:	60 83       	st	Z, r22
    14ec:	31 97       	sbiw	r30, 0x01	; 1
    14ee:	69 e0       	ldi	r22, 0x09	; 9
    14f0:	60 83       	st	Z, r22
    14f2:	31 97       	sbiw	r30, 0x01	; 1
    14f4:	60 e1       	ldi	r22, 0x10	; 16
    14f6:	60 83       	st	Z, r22
    14f8:	31 97       	sbiw	r30, 0x01	; 1
    14fa:	30 83       	st	Z, r19
    14fc:	31 97       	sbiw	r30, 0x01	; 1
    14fe:	32 e1       	ldi	r19, 0x12	; 18
    1500:	30 83       	st	Z, r19
    1502:	31 97       	sbiw	r30, 0x01	; 1
    1504:	33 e1       	ldi	r19, 0x13	; 19
    1506:	30 83       	st	Z, r19
    1508:	31 97       	sbiw	r30, 0x01	; 1
    150a:	34 e1       	ldi	r19, 0x14	; 20
    150c:	30 83       	st	Z, r19
    150e:	31 97       	sbiw	r30, 0x01	; 1
    1510:	35 e1       	ldi	r19, 0x15	; 21
    1512:	30 83       	st	Z, r19
    1514:	31 97       	sbiw	r30, 0x01	; 1
    1516:	36 e1       	ldi	r19, 0x16	; 22
    1518:	30 83       	st	Z, r19
    151a:	31 97       	sbiw	r30, 0x01	; 1
    151c:	37 e1       	ldi	r19, 0x17	; 23
    151e:	30 83       	st	Z, r19
    1520:	31 97       	sbiw	r30, 0x01	; 1
    1522:	38 e1       	ldi	r19, 0x18	; 24
    1524:	30 83       	st	Z, r19
    1526:	31 97       	sbiw	r30, 0x01	; 1
    1528:	39 e1       	ldi	r19, 0x19	; 25
    152a:	30 83       	st	Z, r19
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	30 e2       	ldi	r19, 0x20	; 32
    1530:	30 83       	st	Z, r19
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	31 e2       	ldi	r19, 0x21	; 33
    1536:	30 83       	st	Z, r19
    1538:	31 97       	sbiw	r30, 0x01	; 1
    153a:	20 83       	st	Z, r18
    153c:	31 97       	sbiw	r30, 0x01	; 1
    153e:	23 e2       	ldi	r18, 0x23	; 35
    1540:	20 83       	st	Z, r18
    1542:	31 97       	sbiw	r30, 0x01	; 1
    1544:	40 83       	st	Z, r20
    1546:	31 97       	sbiw	r30, 0x01	; 1
    1548:	50 83       	st	Z, r21
    154a:	31 97       	sbiw	r30, 0x01	; 1
    154c:	26 e2       	ldi	r18, 0x26	; 38
    154e:	20 83       	st	Z, r18
    1550:	31 97       	sbiw	r30, 0x01	; 1
    1552:	27 e2       	ldi	r18, 0x27	; 39
    1554:	20 83       	st	Z, r18
    1556:	31 97       	sbiw	r30, 0x01	; 1
    1558:	28 e2       	ldi	r18, 0x28	; 40
    155a:	20 83       	st	Z, r18
    155c:	31 97       	sbiw	r30, 0x01	; 1
    155e:	29 e2       	ldi	r18, 0x29	; 41
    1560:	20 83       	st	Z, r18
    1562:	31 97       	sbiw	r30, 0x01	; 1
    1564:	20 e3       	ldi	r18, 0x30	; 48
    1566:	20 83       	st	Z, r18
    1568:	31 97       	sbiw	r30, 0x01	; 1
    156a:	21 e3       	ldi	r18, 0x31	; 49
    156c:	20 83       	st	Z, r18
    156e:	89 97       	sbiw	r24, 0x29	; 41
    1570:	08 95       	ret

00001572 <xPortStartScheduler>:
    1572:	8c e7       	ldi	r24, 0x7C	; 124
    1574:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1578:	8f ef       	ldi	r24, 0xFF	; 255
    157a:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    157e:	81 e0       	ldi	r24, 0x01	; 1
    1580:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    1584:	91 e1       	ldi	r25, 0x11	; 17
    1586:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    158a:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    158e:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    1592:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1596:	cd 91       	ld	r28, X+
    1598:	cd bf       	out	0x3d, r28	; 61
    159a:	dd 91       	ld	r29, X+
    159c:	de bf       	out	0x3e, r29	; 62
    159e:	ff 91       	pop	r31
    15a0:	ef 91       	pop	r30
    15a2:	df 91       	pop	r29
    15a4:	cf 91       	pop	r28
    15a6:	bf 91       	pop	r27
    15a8:	af 91       	pop	r26
    15aa:	9f 91       	pop	r25
    15ac:	8f 91       	pop	r24
    15ae:	7f 91       	pop	r23
    15b0:	6f 91       	pop	r22
    15b2:	5f 91       	pop	r21
    15b4:	4f 91       	pop	r20
    15b6:	3f 91       	pop	r19
    15b8:	2f 91       	pop	r18
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	ff 90       	pop	r15
    15c0:	ef 90       	pop	r14
    15c2:	df 90       	pop	r13
    15c4:	cf 90       	pop	r12
    15c6:	bf 90       	pop	r11
    15c8:	af 90       	pop	r10
    15ca:	9f 90       	pop	r9
    15cc:	8f 90       	pop	r8
    15ce:	7f 90       	pop	r7
    15d0:	6f 90       	pop	r6
    15d2:	5f 90       	pop	r5
    15d4:	4f 90       	pop	r4
    15d6:	3f 90       	pop	r3
    15d8:	2f 90       	pop	r2
    15da:	1f 90       	pop	r1
    15dc:	0f 90       	pop	r0
    15de:	0c be       	out	0x3c, r0	; 60
    15e0:	0f 90       	pop	r0
    15e2:	0b be       	out	0x3b, r0	; 59
    15e4:	0f 90       	pop	r0
    15e6:	0f be       	out	0x3f, r0	; 63
    15e8:	0f 90       	pop	r0
    15ea:	08 95       	ret
    15ec:	08 95       	ret

000015ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    15ee:	0f 92       	push	r0
    15f0:	0f b6       	in	r0, 0x3f	; 63
    15f2:	f8 94       	cli
    15f4:	0f 92       	push	r0
    15f6:	0b b6       	in	r0, 0x3b	; 59
    15f8:	0f 92       	push	r0
    15fa:	0c b6       	in	r0, 0x3c	; 60
    15fc:	0f 92       	push	r0
    15fe:	1f 92       	push	r1
    1600:	11 24       	eor	r1, r1
    1602:	2f 92       	push	r2
    1604:	3f 92       	push	r3
    1606:	4f 92       	push	r4
    1608:	5f 92       	push	r5
    160a:	6f 92       	push	r6
    160c:	7f 92       	push	r7
    160e:	8f 92       	push	r8
    1610:	9f 92       	push	r9
    1612:	af 92       	push	r10
    1614:	bf 92       	push	r11
    1616:	cf 92       	push	r12
    1618:	df 92       	push	r13
    161a:	ef 92       	push	r14
    161c:	ff 92       	push	r15
    161e:	0f 93       	push	r16
    1620:	1f 93       	push	r17
    1622:	2f 93       	push	r18
    1624:	3f 93       	push	r19
    1626:	4f 93       	push	r20
    1628:	5f 93       	push	r21
    162a:	6f 93       	push	r22
    162c:	7f 93       	push	r23
    162e:	8f 93       	push	r24
    1630:	9f 93       	push	r25
    1632:	af 93       	push	r26
    1634:	bf 93       	push	r27
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	ef 93       	push	r30
    163c:	ff 93       	push	r31
    163e:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    1642:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1646:	0d b6       	in	r0, 0x3d	; 61
    1648:	0d 92       	st	X+, r0
    164a:	0e b6       	in	r0, 0x3e	; 62
    164c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    164e:	0e 94 06 12 	call	0x240c	; 0x240c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1652:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    1656:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    165a:	cd 91       	ld	r28, X+
    165c:	cd bf       	out	0x3d, r28	; 61
    165e:	dd 91       	ld	r29, X+
    1660:	de bf       	out	0x3e, r29	; 62
    1662:	ff 91       	pop	r31
    1664:	ef 91       	pop	r30
    1666:	df 91       	pop	r29
    1668:	cf 91       	pop	r28
    166a:	bf 91       	pop	r27
    166c:	af 91       	pop	r26
    166e:	9f 91       	pop	r25
    1670:	8f 91       	pop	r24
    1672:	7f 91       	pop	r23
    1674:	6f 91       	pop	r22
    1676:	5f 91       	pop	r21
    1678:	4f 91       	pop	r20
    167a:	3f 91       	pop	r19
    167c:	2f 91       	pop	r18
    167e:	1f 91       	pop	r17
    1680:	0f 91       	pop	r16
    1682:	ff 90       	pop	r15
    1684:	ef 90       	pop	r14
    1686:	df 90       	pop	r13
    1688:	cf 90       	pop	r12
    168a:	bf 90       	pop	r11
    168c:	af 90       	pop	r10
    168e:	9f 90       	pop	r9
    1690:	8f 90       	pop	r8
    1692:	7f 90       	pop	r7
    1694:	6f 90       	pop	r6
    1696:	5f 90       	pop	r5
    1698:	4f 90       	pop	r4
    169a:	3f 90       	pop	r3
    169c:	2f 90       	pop	r2
    169e:	1f 90       	pop	r1
    16a0:	0f 90       	pop	r0
    16a2:	0c be       	out	0x3c, r0	; 60
    16a4:	0f 90       	pop	r0
    16a6:	0b be       	out	0x3b, r0	; 59
    16a8:	0f 90       	pop	r0
    16aa:	0f be       	out	0x3f, r0	; 63
    16ac:	0f 90       	pop	r0

	asm volatile ( "ret" );
    16ae:	08 95       	ret

000016b0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    16b0:	0f 92       	push	r0
    16b2:	0f b6       	in	r0, 0x3f	; 63
    16b4:	f8 94       	cli
    16b6:	0f 92       	push	r0
    16b8:	0b b6       	in	r0, 0x3b	; 59
    16ba:	0f 92       	push	r0
    16bc:	0c b6       	in	r0, 0x3c	; 60
    16be:	0f 92       	push	r0
    16c0:	1f 92       	push	r1
    16c2:	11 24       	eor	r1, r1
    16c4:	2f 92       	push	r2
    16c6:	3f 92       	push	r3
    16c8:	4f 92       	push	r4
    16ca:	5f 92       	push	r5
    16cc:	6f 92       	push	r6
    16ce:	7f 92       	push	r7
    16d0:	8f 92       	push	r8
    16d2:	9f 92       	push	r9
    16d4:	af 92       	push	r10
    16d6:	bf 92       	push	r11
    16d8:	cf 92       	push	r12
    16da:	df 92       	push	r13
    16dc:	ef 92       	push	r14
    16de:	ff 92       	push	r15
    16e0:	0f 93       	push	r16
    16e2:	1f 93       	push	r17
    16e4:	2f 93       	push	r18
    16e6:	3f 93       	push	r19
    16e8:	4f 93       	push	r20
    16ea:	5f 93       	push	r21
    16ec:	6f 93       	push	r22
    16ee:	7f 93       	push	r23
    16f0:	8f 93       	push	r24
    16f2:	9f 93       	push	r25
    16f4:	af 93       	push	r26
    16f6:	bf 93       	push	r27
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	ef 93       	push	r30
    16fe:	ff 93       	push	r31
    1700:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    1704:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1708:	0d b6       	in	r0, 0x3d	; 61
    170a:	0d 92       	st	X+, r0
    170c:	0e b6       	in	r0, 0x3e	; 62
    170e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1710:	0e 94 55 10 	call	0x20aa	; 0x20aa <vTaskIncrementTick>
	vTaskSwitchContext();
    1714:	0e 94 06 12 	call	0x240c	; 0x240c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1718:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    171c:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1720:	cd 91       	ld	r28, X+
    1722:	cd bf       	out	0x3d, r28	; 61
    1724:	dd 91       	ld	r29, X+
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	ff 91       	pop	r31
    172a:	ef 91       	pop	r30
    172c:	df 91       	pop	r29
    172e:	cf 91       	pop	r28
    1730:	bf 91       	pop	r27
    1732:	af 91       	pop	r26
    1734:	9f 91       	pop	r25
    1736:	8f 91       	pop	r24
    1738:	7f 91       	pop	r23
    173a:	6f 91       	pop	r22
    173c:	5f 91       	pop	r21
    173e:	4f 91       	pop	r20
    1740:	3f 91       	pop	r19
    1742:	2f 91       	pop	r18
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	ff 90       	pop	r15
    174a:	ef 90       	pop	r14
    174c:	df 90       	pop	r13
    174e:	cf 90       	pop	r12
    1750:	bf 90       	pop	r11
    1752:	af 90       	pop	r10
    1754:	9f 90       	pop	r9
    1756:	8f 90       	pop	r8
    1758:	7f 90       	pop	r7
    175a:	6f 90       	pop	r6
    175c:	5f 90       	pop	r5
    175e:	4f 90       	pop	r4
    1760:	3f 90       	pop	r3
    1762:	2f 90       	pop	r2
    1764:	1f 90       	pop	r1
    1766:	0f 90       	pop	r0
    1768:	0c be       	out	0x3c, r0	; 60
    176a:	0f 90       	pop	r0
    176c:	0b be       	out	0x3b, r0	; 59
    176e:	0f 90       	pop	r0
    1770:	0f be       	out	0x3f, r0	; 63
    1772:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1774:	08 95       	ret

00001776 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1776:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    177a:	18 95       	reti

0000177c <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
    1780:	ec 01       	movw	r28, r24
    1782:	88 a1       	ldd	r24, Y+32	; 0x20
    1784:	81 11       	cpse	r24, r1
    1786:	0b c0       	rjmp	.+22     	; 0x179e <prvCopyDataToQueue+0x22>
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	89 2b       	or	r24, r25
    178e:	e1 f5       	brne	.+120    	; 0x1808 <prvCopyDataToQueue+0x8c>
    1790:	8a 81       	ldd	r24, Y+2	; 0x02
    1792:	9b 81       	ldd	r25, Y+3	; 0x03
    1794:	0e 94 c1 13 	call	0x2782	; 0x2782 <vTaskPriorityDisinherit>
    1798:	1a 82       	std	Y+2, r1	; 0x02
    179a:	1b 82       	std	Y+3, r1	; 0x03
    179c:	35 c0       	rjmp	.+106    	; 0x1808 <prvCopyDataToQueue+0x8c>
    179e:	41 11       	cpse	r20, r1
    17a0:	17 c0       	rjmp	.+46     	; 0x17d0 <prvCopyDataToQueue+0x54>
    17a2:	48 2f       	mov	r20, r24
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	8c 81       	ldd	r24, Y+4	; 0x04
    17a8:	9d 81       	ldd	r25, Y+5	; 0x05
    17aa:	0e 94 f4 20 	call	0x41e8	; 0x41e8 <memcpy>
    17ae:	28 a1       	ldd	r18, Y+32	; 0x20
    17b0:	8c 81       	ldd	r24, Y+4	; 0x04
    17b2:	9d 81       	ldd	r25, Y+5	; 0x05
    17b4:	82 0f       	add	r24, r18
    17b6:	91 1d       	adc	r25, r1
    17b8:	8c 83       	std	Y+4, r24	; 0x04
    17ba:	9d 83       	std	Y+5, r25	; 0x05
    17bc:	2a 81       	ldd	r18, Y+2	; 0x02
    17be:	3b 81       	ldd	r19, Y+3	; 0x03
    17c0:	82 17       	cp	r24, r18
    17c2:	93 07       	cpc	r25, r19
    17c4:	08 f1       	brcs	.+66     	; 0x1808 <prvCopyDataToQueue+0x8c>
    17c6:	88 81       	ld	r24, Y
    17c8:	99 81       	ldd	r25, Y+1	; 0x01
    17ca:	8c 83       	std	Y+4, r24	; 0x04
    17cc:	9d 83       	std	Y+5, r25	; 0x05
    17ce:	1c c0       	rjmp	.+56     	; 0x1808 <prvCopyDataToQueue+0x8c>
    17d0:	48 2f       	mov	r20, r24
    17d2:	50 e0       	ldi	r21, 0x00	; 0
    17d4:	8e 81       	ldd	r24, Y+6	; 0x06
    17d6:	9f 81       	ldd	r25, Y+7	; 0x07
    17d8:	0e 94 f4 20 	call	0x41e8	; 0x41e8 <memcpy>
    17dc:	88 a1       	ldd	r24, Y+32	; 0x20
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	91 95       	neg	r25
    17e2:	81 95       	neg	r24
    17e4:	91 09       	sbc	r25, r1
    17e6:	2e 81       	ldd	r18, Y+6	; 0x06
    17e8:	3f 81       	ldd	r19, Y+7	; 0x07
    17ea:	28 0f       	add	r18, r24
    17ec:	39 1f       	adc	r19, r25
    17ee:	2e 83       	std	Y+6, r18	; 0x06
    17f0:	3f 83       	std	Y+7, r19	; 0x07
    17f2:	48 81       	ld	r20, Y
    17f4:	59 81       	ldd	r21, Y+1	; 0x01
    17f6:	24 17       	cp	r18, r20
    17f8:	35 07       	cpc	r19, r21
    17fa:	30 f4       	brcc	.+12     	; 0x1808 <prvCopyDataToQueue+0x8c>
    17fc:	2a 81       	ldd	r18, Y+2	; 0x02
    17fe:	3b 81       	ldd	r19, Y+3	; 0x03
    1800:	82 0f       	add	r24, r18
    1802:	93 1f       	adc	r25, r19
    1804:	8e 83       	std	Y+6, r24	; 0x06
    1806:	9f 83       	std	Y+7, r25	; 0x07
    1808:	8e 8d       	ldd	r24, Y+30	; 0x1e
    180a:	8f 5f       	subi	r24, 0xFF	; 255
    180c:	8e 8f       	std	Y+30, r24	; 0x1e
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	08 95       	ret

00001814 <prvCopyDataFromQueue>:
    1814:	fc 01       	movw	r30, r24
    1816:	80 81       	ld	r24, Z
    1818:	91 81       	ldd	r25, Z+1	; 0x01
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	a1 f0       	breq	.+40     	; 0x1846 <prvCopyDataFromQueue+0x32>
    181e:	40 a1       	ldd	r20, Z+32	; 0x20
    1820:	50 e0       	ldi	r21, 0x00	; 0
    1822:	26 81       	ldd	r18, Z+6	; 0x06
    1824:	37 81       	ldd	r19, Z+7	; 0x07
    1826:	24 0f       	add	r18, r20
    1828:	35 1f       	adc	r19, r21
    182a:	26 83       	std	Z+6, r18	; 0x06
    182c:	37 83       	std	Z+7, r19	; 0x07
    182e:	a2 81       	ldd	r26, Z+2	; 0x02
    1830:	b3 81       	ldd	r27, Z+3	; 0x03
    1832:	2a 17       	cp	r18, r26
    1834:	3b 07       	cpc	r19, r27
    1836:	10 f0       	brcs	.+4      	; 0x183c <prvCopyDataFromQueue+0x28>
    1838:	86 83       	std	Z+6, r24	; 0x06
    183a:	97 83       	std	Z+7, r25	; 0x07
    183c:	cb 01       	movw	r24, r22
    183e:	66 81       	ldd	r22, Z+6	; 0x06
    1840:	77 81       	ldd	r23, Z+7	; 0x07
    1842:	0e 94 f4 20 	call	0x41e8	; 0x41e8 <memcpy>
    1846:	08 95       	ret

00001848 <prvUnlockQueue>:
    1848:	0f 93       	push	r16
    184a:	1f 93       	push	r17
    184c:	cf 93       	push	r28
    184e:	df 93       	push	r29
    1850:	ec 01       	movw	r28, r24
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	f8 94       	cli
    1856:	0f 92       	push	r0
    1858:	8a a1       	ldd	r24, Y+34	; 0x22
    185a:	18 16       	cp	r1, r24
    185c:	b4 f4       	brge	.+44     	; 0x188a <prvUnlockQueue+0x42>
    185e:	8b 89       	ldd	r24, Y+19	; 0x13
    1860:	81 11       	cpse	r24, r1
    1862:	05 c0       	rjmp	.+10     	; 0x186e <prvUnlockQueue+0x26>
    1864:	12 c0       	rjmp	.+36     	; 0x188a <prvUnlockQueue+0x42>
    1866:	8b 89       	ldd	r24, Y+19	; 0x13
    1868:	81 11       	cpse	r24, r1
    186a:	04 c0       	rjmp	.+8      	; 0x1874 <prvUnlockQueue+0x2c>
    186c:	0e c0       	rjmp	.+28     	; 0x188a <prvUnlockQueue+0x42>
    186e:	8e 01       	movw	r16, r28
    1870:	0d 5e       	subi	r16, 0xED	; 237
    1872:	1f 4f       	sbci	r17, 0xFF	; 255
    1874:	c8 01       	movw	r24, r16
    1876:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    187a:	81 11       	cpse	r24, r1
    187c:	0e 94 4a 13 	call	0x2694	; 0x2694 <vTaskMissedYield>
    1880:	8a a1       	ldd	r24, Y+34	; 0x22
    1882:	81 50       	subi	r24, 0x01	; 1
    1884:	8a a3       	std	Y+34, r24	; 0x22
    1886:	18 16       	cp	r1, r24
    1888:	74 f3       	brlt	.-36     	; 0x1866 <prvUnlockQueue+0x1e>
    188a:	8f ef       	ldi	r24, 0xFF	; 255
    188c:	8a a3       	std	Y+34, r24	; 0x22
    188e:	0f 90       	pop	r0
    1890:	0f be       	out	0x3f, r0	; 63
    1892:	0f b6       	in	r0, 0x3f	; 63
    1894:	f8 94       	cli
    1896:	0f 92       	push	r0
    1898:	89 a1       	ldd	r24, Y+33	; 0x21
    189a:	18 16       	cp	r1, r24
    189c:	b4 f4       	brge	.+44     	; 0x18ca <prvUnlockQueue+0x82>
    189e:	88 85       	ldd	r24, Y+8	; 0x08
    18a0:	81 11       	cpse	r24, r1
    18a2:	05 c0       	rjmp	.+10     	; 0x18ae <prvUnlockQueue+0x66>
    18a4:	12 c0       	rjmp	.+36     	; 0x18ca <prvUnlockQueue+0x82>
    18a6:	88 85       	ldd	r24, Y+8	; 0x08
    18a8:	81 11       	cpse	r24, r1
    18aa:	04 c0       	rjmp	.+8      	; 0x18b4 <prvUnlockQueue+0x6c>
    18ac:	0e c0       	rjmp	.+28     	; 0x18ca <prvUnlockQueue+0x82>
    18ae:	8e 01       	movw	r16, r28
    18b0:	08 5f       	subi	r16, 0xF8	; 248
    18b2:	1f 4f       	sbci	r17, 0xFF	; 255
    18b4:	c8 01       	movw	r24, r16
    18b6:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    18ba:	81 11       	cpse	r24, r1
    18bc:	0e 94 4a 13 	call	0x2694	; 0x2694 <vTaskMissedYield>
    18c0:	89 a1       	ldd	r24, Y+33	; 0x21
    18c2:	81 50       	subi	r24, 0x01	; 1
    18c4:	89 a3       	std	Y+33, r24	; 0x21
    18c6:	18 16       	cp	r1, r24
    18c8:	74 f3       	brlt	.-36     	; 0x18a6 <prvUnlockQueue+0x5e>
    18ca:	8f ef       	ldi	r24, 0xFF	; 255
    18cc:	89 a3       	std	Y+33, r24	; 0x21
    18ce:	0f 90       	pop	r0
    18d0:	0f be       	out	0x3f, r0	; 63
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	1f 91       	pop	r17
    18d8:	0f 91       	pop	r16
    18da:	08 95       	ret

000018dc <xQueueGenericReset>:
    18dc:	1f 93       	push	r17
    18de:	cf 93       	push	r28
    18e0:	df 93       	push	r29
    18e2:	61 30       	cpi	r22, 0x01	; 1
    18e4:	59 f0       	breq	.+22     	; 0x18fc <xQueueGenericReset+0x20>
    18e6:	fc 01       	movw	r30, r24
    18e8:	23 89       	ldd	r18, Z+19	; 0x13
    18ea:	30 85       	ldd	r19, Z+8	; 0x08
    18ec:	31 11       	cpse	r19, r1
    18ee:	2c c0       	rjmp	.+88     	; 0x1948 <xQueueGenericReset+0x6c>
    18f0:	11 e0       	ldi	r17, 0x01	; 1
    18f2:	21 11       	cpse	r18, r1
    18f4:	10 e0       	ldi	r17, 0x00	; 0
    18f6:	21 11       	cpse	r18, r1
    18f8:	28 c0       	rjmp	.+80     	; 0x194a <xQueueGenericReset+0x6e>
    18fa:	01 c0       	rjmp	.+2      	; 0x18fe <xQueueGenericReset+0x22>
    18fc:	11 e0       	ldi	r17, 0x01	; 1
    18fe:	ec 01       	movw	r28, r24
    1900:	48 81       	ld	r20, Y
    1902:	59 81       	ldd	r21, Y+1	; 0x01
    1904:	28 a1       	ldd	r18, Y+32	; 0x20
    1906:	30 e0       	ldi	r19, 0x00	; 0
    1908:	6f 8d       	ldd	r22, Y+31	; 0x1f
    190a:	62 9f       	mul	r22, r18
    190c:	c0 01       	movw	r24, r0
    190e:	63 9f       	mul	r22, r19
    1910:	90 0d       	add	r25, r0
    1912:	11 24       	eor	r1, r1
    1914:	ba 01       	movw	r22, r20
    1916:	68 0f       	add	r22, r24
    1918:	79 1f       	adc	r23, r25
    191a:	6a 83       	std	Y+2, r22	; 0x02
    191c:	7b 83       	std	Y+3, r23	; 0x03
    191e:	1e 8e       	std	Y+30, r1	; 0x1e
    1920:	4c 83       	std	Y+4, r20	; 0x04
    1922:	5d 83       	std	Y+5, r21	; 0x05
    1924:	82 1b       	sub	r24, r18
    1926:	93 0b       	sbc	r25, r19
    1928:	84 0f       	add	r24, r20
    192a:	95 1f       	adc	r25, r21
    192c:	8e 83       	std	Y+6, r24	; 0x06
    192e:	9f 83       	std	Y+7, r25	; 0x07
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	89 a3       	std	Y+33, r24	; 0x21
    1934:	8a a3       	std	Y+34, r24	; 0x22
    1936:	ce 01       	movw	r24, r28
    1938:	08 96       	adiw	r24, 0x08	; 8
    193a:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    193e:	ce 01       	movw	r24, r28
    1940:	43 96       	adiw	r24, 0x13	; 19
    1942:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1946:	01 c0       	rjmp	.+2      	; 0x194a <xQueueGenericReset+0x6e>
    1948:	10 e0       	ldi	r17, 0x00	; 0
    194a:	81 2f       	mov	r24, r17
    194c:	df 91       	pop	r29
    194e:	cf 91       	pop	r28
    1950:	1f 91       	pop	r17
    1952:	08 95       	ret

00001954 <xQueueGenericCreate>:
    1954:	0f 93       	push	r16
    1956:	1f 93       	push	r17
    1958:	cf 93       	push	r28
    195a:	df 93       	push	r29
    195c:	88 23       	and	r24, r24
    195e:	01 f1       	breq	.+64     	; 0x19a0 <xQueueGenericCreate+0x4c>
    1960:	06 2f       	mov	r16, r22
    1962:	18 2f       	mov	r17, r24
    1964:	83 e2       	ldi	r24, 0x23	; 35
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    196c:	ec 01       	movw	r28, r24
    196e:	89 2b       	or	r24, r25
    1970:	c9 f0       	breq	.+50     	; 0x19a4 <xQueueGenericCreate+0x50>
    1972:	10 9f       	mul	r17, r16
    1974:	c0 01       	movw	r24, r0
    1976:	11 24       	eor	r1, r1
    1978:	01 96       	adiw	r24, 0x01	; 1
    197a:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    197e:	88 83       	st	Y, r24
    1980:	99 83       	std	Y+1, r25	; 0x01
    1982:	89 2b       	or	r24, r25
    1984:	39 f0       	breq	.+14     	; 0x1994 <xQueueGenericCreate+0x40>
    1986:	1f 8f       	std	Y+31, r17	; 0x1f
    1988:	08 a3       	std	Y+32, r16	; 0x20
    198a:	61 e0       	ldi	r22, 0x01	; 1
    198c:	ce 01       	movw	r24, r28
    198e:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <xQueueGenericReset>
    1992:	08 c0       	rjmp	.+16     	; 0x19a4 <xQueueGenericCreate+0x50>
    1994:	ce 01       	movw	r24, r28
    1996:	0e 94 5e 09 	call	0x12bc	; 0x12bc <vPortFree>
    199a:	c0 e0       	ldi	r28, 0x00	; 0
    199c:	d0 e0       	ldi	r29, 0x00	; 0
    199e:	02 c0       	rjmp	.+4      	; 0x19a4 <xQueueGenericCreate+0x50>
    19a0:	c0 e0       	ldi	r28, 0x00	; 0
    19a2:	d0 e0       	ldi	r29, 0x00	; 0
    19a4:	ce 01       	movw	r24, r28
    19a6:	df 91       	pop	r29
    19a8:	cf 91       	pop	r28
    19aa:	1f 91       	pop	r17
    19ac:	0f 91       	pop	r16
    19ae:	08 95       	ret

000019b0 <xQueueGenericSend>:
    19b0:	af 92       	push	r10
    19b2:	bf 92       	push	r11
    19b4:	cf 92       	push	r12
    19b6:	df 92       	push	r13
    19b8:	ef 92       	push	r14
    19ba:	ff 92       	push	r15
    19bc:	0f 93       	push	r16
    19be:	1f 93       	push	r17
    19c0:	cf 93       	push	r28
    19c2:	df 93       	push	r29
    19c4:	cd b7       	in	r28, 0x3d	; 61
    19c6:	de b7       	in	r29, 0x3e	; 62
    19c8:	29 97       	sbiw	r28, 0x09	; 9
    19ca:	cd bf       	out	0x3d, r28	; 61
    19cc:	de bf       	out	0x3e, r29	; 62
    19ce:	7c 01       	movw	r14, r24
    19d0:	5b 01       	movw	r10, r22
    19d2:	2e 83       	std	Y+6, r18	; 0x06
    19d4:	3f 83       	std	Y+7, r19	; 0x07
    19d6:	48 87       	std	Y+8, r20	; 0x08
    19d8:	59 87       	std	Y+9, r21	; 0x09
    19da:	10 e0       	ldi	r17, 0x00	; 0
    19dc:	6c 01       	movw	r12, r24
    19de:	88 e0       	ldi	r24, 0x08	; 8
    19e0:	c8 0e       	add	r12, r24
    19e2:	d1 1c       	adc	r13, r1
    19e4:	0f b6       	in	r0, 0x3f	; 63
    19e6:	f8 94       	cli
    19e8:	0f 92       	push	r0
    19ea:	f7 01       	movw	r30, r14
    19ec:	96 8d       	ldd	r25, Z+30	; 0x1e
    19ee:	87 8d       	ldd	r24, Z+31	; 0x1f
    19f0:	98 17       	cp	r25, r24
    19f2:	a8 f4       	brcc	.+42     	; 0x1a1e <xQueueGenericSend+0x6e>
    19f4:	40 2f       	mov	r20, r16
    19f6:	b5 01       	movw	r22, r10
    19f8:	c7 01       	movw	r24, r14
    19fa:	0e 94 be 0b 	call	0x177c	; 0x177c <prvCopyDataToQueue>
    19fe:	f7 01       	movw	r30, r14
    1a00:	83 89       	ldd	r24, Z+19	; 0x13
    1a02:	88 23       	and	r24, r24
    1a04:	41 f0       	breq	.+16     	; 0x1a16 <xQueueGenericSend+0x66>
    1a06:	c7 01       	movw	r24, r14
    1a08:	43 96       	adiw	r24, 0x13	; 19
    1a0a:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    1a0e:	81 30       	cpi	r24, 0x01	; 1
    1a10:	11 f4       	brne	.+4      	; 0x1a16 <xQueueGenericSend+0x66>
    1a12:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1a16:	0f 90       	pop	r0
    1a18:	0f be       	out	0x3f, r0	; 63
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
    1a1c:	56 c0       	rjmp	.+172    	; 0x1aca <xQueueGenericSend+0x11a>
    1a1e:	8e 81       	ldd	r24, Y+6	; 0x06
    1a20:	9f 81       	ldd	r25, Y+7	; 0x07
    1a22:	a8 85       	ldd	r26, Y+8	; 0x08
    1a24:	b9 85       	ldd	r27, Y+9	; 0x09
    1a26:	89 2b       	or	r24, r25
    1a28:	8a 2b       	or	r24, r26
    1a2a:	8b 2b       	or	r24, r27
    1a2c:	21 f4       	brne	.+8      	; 0x1a36 <xQueueGenericSend+0x86>
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63
    1a32:	80 e0       	ldi	r24, 0x00	; 0
    1a34:	4a c0       	rjmp	.+148    	; 0x1aca <xQueueGenericSend+0x11a>
    1a36:	11 11       	cpse	r17, r1
    1a38:	05 c0       	rjmp	.+10     	; 0x1a44 <xQueueGenericSend+0x94>
    1a3a:	ce 01       	movw	r24, r28
    1a3c:	01 96       	adiw	r24, 0x01	; 1
    1a3e:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
    1a42:	11 e0       	ldi	r17, 0x01	; 1
    1a44:	0f 90       	pop	r0
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	0e 94 34 10 	call	0x2068	; 0x2068 <vTaskSuspendAll>
    1a4c:	0f b6       	in	r0, 0x3f	; 63
    1a4e:	f8 94       	cli
    1a50:	0f 92       	push	r0
    1a52:	f7 01       	movw	r30, r14
    1a54:	81 a1       	ldd	r24, Z+33	; 0x21
    1a56:	8f 3f       	cpi	r24, 0xFF	; 255
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <xQueueGenericSend+0xac>
    1a5a:	11 a2       	std	Z+33, r1	; 0x21
    1a5c:	f7 01       	movw	r30, r14
    1a5e:	82 a1       	ldd	r24, Z+34	; 0x22
    1a60:	8f 3f       	cpi	r24, 0xFF	; 255
    1a62:	09 f4       	brne	.+2      	; 0x1a66 <xQueueGenericSend+0xb6>
    1a64:	12 a2       	std	Z+34, r1	; 0x22
    1a66:	0f 90       	pop	r0
    1a68:	0f be       	out	0x3f, r0	; 63
    1a6a:	be 01       	movw	r22, r28
    1a6c:	6a 5f       	subi	r22, 0xFA	; 250
    1a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a70:	ce 01       	movw	r24, r28
    1a72:	01 96       	adiw	r24, 0x01	; 1
    1a74:	0e 94 dd 12 	call	0x25ba	; 0x25ba <xTaskCheckForTimeOut>
    1a78:	81 11       	cpse	r24, r1
    1a7a:	21 c0       	rjmp	.+66     	; 0x1abe <xQueueGenericSend+0x10e>
    1a7c:	0f b6       	in	r0, 0x3f	; 63
    1a7e:	f8 94       	cli
    1a80:	0f 92       	push	r0
    1a82:	f7 01       	movw	r30, r14
    1a84:	96 8d       	ldd	r25, Z+30	; 0x1e
    1a86:	0f 90       	pop	r0
    1a88:	0f be       	out	0x3f, r0	; 63
    1a8a:	87 8d       	ldd	r24, Z+31	; 0x1f
    1a8c:	98 13       	cpse	r25, r24
    1a8e:	11 c0       	rjmp	.+34     	; 0x1ab2 <xQueueGenericSend+0x102>
    1a90:	4e 81       	ldd	r20, Y+6	; 0x06
    1a92:	5f 81       	ldd	r21, Y+7	; 0x07
    1a94:	68 85       	ldd	r22, Y+8	; 0x08
    1a96:	79 85       	ldd	r23, Y+9	; 0x09
    1a98:	c6 01       	movw	r24, r12
    1a9a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vTaskPlaceOnEventList>
    1a9e:	c7 01       	movw	r24, r14
    1aa0:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
    1aa4:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
    1aa8:	81 11       	cpse	r24, r1
    1aaa:	9c cf       	rjmp	.-200    	; 0x19e4 <xQueueGenericSend+0x34>
    1aac:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1ab0:	99 cf       	rjmp	.-206    	; 0x19e4 <xQueueGenericSend+0x34>
    1ab2:	c7 01       	movw	r24, r14
    1ab4:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
    1ab8:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
    1abc:	93 cf       	rjmp	.-218    	; 0x19e4 <xQueueGenericSend+0x34>
    1abe:	c7 01       	movw	r24, r14
    1ac0:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
    1ac4:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
    1ac8:	80 e0       	ldi	r24, 0x00	; 0
    1aca:	29 96       	adiw	r28, 0x09	; 9
    1acc:	cd bf       	out	0x3d, r28	; 61
    1ace:	de bf       	out	0x3e, r29	; 62
    1ad0:	df 91       	pop	r29
    1ad2:	cf 91       	pop	r28
    1ad4:	1f 91       	pop	r17
    1ad6:	0f 91       	pop	r16
    1ad8:	ff 90       	pop	r15
    1ada:	ef 90       	pop	r14
    1adc:	df 90       	pop	r13
    1ade:	cf 90       	pop	r12
    1ae0:	bf 90       	pop	r11
    1ae2:	af 90       	pop	r10
    1ae4:	08 95       	ret

00001ae6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1ae6:	0f 93       	push	r16
    1ae8:	1f 93       	push	r17
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1af0:	fc 01       	movw	r30, r24
    1af2:	56 8d       	ldd	r21, Z+30	; 0x1e
    1af4:	37 8d       	ldd	r19, Z+31	; 0x1f
    1af6:	53 17       	cp	r21, r19
    1af8:	c0 f4       	brcc	.+48     	; 0x1b2a <xQueueGenericSendFromISR+0x44>
    1afa:	42 2f       	mov	r20, r18
    1afc:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1afe:	0e 94 be 0b 	call	0x177c	; 0x177c <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1b02:	8a a1       	ldd	r24, Y+34	; 0x22
    1b04:	8f 3f       	cpi	r24, 0xFF	; 255
    1b06:	69 f4       	brne	.+26     	; 0x1b22 <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b08:	8b 89       	ldd	r24, Y+19	; 0x13
    1b0a:	88 23       	and	r24, r24
    1b0c:	81 f0       	breq	.+32     	; 0x1b2e <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b0e:	ce 01       	movw	r24, r28
    1b10:	43 96       	adiw	r24, 0x13	; 19
    1b12:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    1b16:	88 23       	and	r24, r24
    1b18:	61 f0       	breq	.+24     	; 0x1b32 <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	80 83       	st	Z, r24
    1b20:	09 c0       	rjmp	.+18     	; 0x1b34 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1b22:	8f 5f       	subi	r24, 0xFF	; 255
    1b24:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	05 c0       	rjmp	.+10     	; 0x1b34 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	03 c0       	rjmp	.+6      	; 0x1b34 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	01 c0       	rjmp	.+2      	; 0x1b34 <xQueueGenericSendFromISR+0x4e>
    1b32:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1b34:	df 91       	pop	r29
    1b36:	cf 91       	pop	r28
    1b38:	1f 91       	pop	r17
    1b3a:	0f 91       	pop	r16
    1b3c:	08 95       	ret

00001b3e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1b3e:	af 92       	push	r10
    1b40:	bf 92       	push	r11
    1b42:	cf 92       	push	r12
    1b44:	df 92       	push	r13
    1b46:	ef 92       	push	r14
    1b48:	ff 92       	push	r15
    1b4a:	0f 93       	push	r16
    1b4c:	1f 93       	push	r17
    1b4e:	cf 93       	push	r28
    1b50:	df 93       	push	r29
    1b52:	cd b7       	in	r28, 0x3d	; 61
    1b54:	de b7       	in	r29, 0x3e	; 62
    1b56:	29 97       	sbiw	r28, 0x09	; 9
    1b58:	cd bf       	out	0x3d, r28	; 61
    1b5a:	de bf       	out	0x3e, r29	; 62
    1b5c:	7c 01       	movw	r14, r24
    1b5e:	5b 01       	movw	r10, r22
    1b60:	2e 83       	std	Y+6, r18	; 0x06
    1b62:	3f 83       	std	Y+7, r19	; 0x07
    1b64:	48 87       	std	Y+8, r20	; 0x08
    1b66:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1b68:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b6a:	6c 01       	movw	r12, r24
    1b6c:	83 e1       	ldi	r24, 0x13	; 19
    1b6e:	c8 0e       	add	r12, r24
    1b70:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b78:	f7 01       	movw	r30, r14
    1b7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b7c:	88 23       	and	r24, r24
    1b7e:	99 f1       	breq	.+102    	; 0x1be6 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1b80:	c6 80       	ldd	r12, Z+6	; 0x06
    1b82:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b84:	b5 01       	movw	r22, r10
    1b86:	c7 01       	movw	r24, r14
    1b88:	0e 94 0a 0c 	call	0x1814	; 0x1814 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1b8c:	01 11       	cpse	r16, r1
    1b8e:	1a c0       	rjmp	.+52     	; 0x1bc4 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1b90:	f7 01       	movw	r30, r14
    1b92:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b94:	81 50       	subi	r24, 0x01	; 1
    1b96:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b98:	80 81       	ld	r24, Z
    1b9a:	91 81       	ldd	r25, Z+1	; 0x01
    1b9c:	89 2b       	or	r24, r25
    1b9e:	29 f4       	brne	.+10     	; 0x1baa <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1ba0:	0e 94 67 13 	call	0x26ce	; 0x26ce <xTaskGetCurrentTaskHandle>
    1ba4:	f7 01       	movw	r30, r14
    1ba6:	82 83       	std	Z+2, r24	; 0x02
    1ba8:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1baa:	f7 01       	movw	r30, r14
    1bac:	80 85       	ldd	r24, Z+8	; 0x08
    1bae:	88 23       	and	r24, r24
    1bb0:	b1 f0       	breq	.+44     	; 0x1bde <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1bb2:	c7 01       	movw	r24, r14
    1bb4:	08 96       	adiw	r24, 0x08	; 8
    1bb6:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    1bba:	81 30       	cpi	r24, 0x01	; 1
    1bbc:	81 f4       	brne	.+32     	; 0x1bde <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1bbe:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1bc2:	0d c0       	rjmp	.+26     	; 0x1bde <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1bc4:	f7 01       	movw	r30, r14
    1bc6:	c6 82       	std	Z+6, r12	; 0x06
    1bc8:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bca:	83 89       	ldd	r24, Z+19	; 0x13
    1bcc:	88 23       	and	r24, r24
    1bce:	39 f0       	breq	.+14     	; 0x1bde <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bd0:	c7 01       	movw	r24, r14
    1bd2:	43 96       	adiw	r24, 0x13	; 19
    1bd4:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    1bd8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1bda:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1be2:	81 e0       	ldi	r24, 0x01	; 1
    1be4:	62 c0       	rjmp	.+196    	; 0x1caa <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1be6:	8e 81       	ldd	r24, Y+6	; 0x06
    1be8:	9f 81       	ldd	r25, Y+7	; 0x07
    1bea:	a8 85       	ldd	r26, Y+8	; 0x08
    1bec:	b9 85       	ldd	r27, Y+9	; 0x09
    1bee:	89 2b       	or	r24, r25
    1bf0:	8a 2b       	or	r24, r26
    1bf2:	8b 2b       	or	r24, r27
    1bf4:	21 f4       	brne	.+8      	; 0x1bfe <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1bf6:	0f 90       	pop	r0
    1bf8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1bfa:	80 e0       	ldi	r24, 0x00	; 0
    1bfc:	56 c0       	rjmp	.+172    	; 0x1caa <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1bfe:	11 11       	cpse	r17, r1
    1c00:	05 c0       	rjmp	.+10     	; 0x1c0c <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1c02:	ce 01       	movw	r24, r28
    1c04:	01 96       	adiw	r24, 0x01	; 1
    1c06:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1c0a:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1c0c:	0f 90       	pop	r0
    1c0e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1c10:	0e 94 34 10 	call	0x2068	; 0x2068 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1c14:	0f b6       	in	r0, 0x3f	; 63
    1c16:	f8 94       	cli
    1c18:	0f 92       	push	r0
    1c1a:	f7 01       	movw	r30, r14
    1c1c:	81 a1       	ldd	r24, Z+33	; 0x21
    1c1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c20:	09 f4       	brne	.+2      	; 0x1c24 <xQueueGenericReceive+0xe6>
    1c22:	11 a2       	std	Z+33, r1	; 0x21
    1c24:	f7 01       	movw	r30, r14
    1c26:	82 a1       	ldd	r24, Z+34	; 0x22
    1c28:	8f 3f       	cpi	r24, 0xFF	; 255
    1c2a:	09 f4       	brne	.+2      	; 0x1c2e <xQueueGenericReceive+0xf0>
    1c2c:	12 a2       	std	Z+34, r1	; 0x22
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c32:	be 01       	movw	r22, r28
    1c34:	6a 5f       	subi	r22, 0xFA	; 250
    1c36:	7f 4f       	sbci	r23, 0xFF	; 255
    1c38:	ce 01       	movw	r24, r28
    1c3a:	01 96       	adiw	r24, 0x01	; 1
    1c3c:	0e 94 dd 12 	call	0x25ba	; 0x25ba <xTaskCheckForTimeOut>
    1c40:	81 11       	cpse	r24, r1
    1c42:	2d c0       	rjmp	.+90     	; 0x1c9e <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1c4a:	f7 01       	movw	r30, r14
    1c4c:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c52:	81 11       	cpse	r24, r1
    1c54:	1e c0       	rjmp	.+60     	; 0x1c92 <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c56:	80 81       	ld	r24, Z
    1c58:	91 81       	ldd	r25, Z+1	; 0x01
    1c5a:	89 2b       	or	r24, r25
    1c5c:	49 f4       	brne	.+18     	; 0x1c70 <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1c64:	82 81       	ldd	r24, Z+2	; 0x02
    1c66:	93 81       	ldd	r25, Z+3	; 0x03
    1c68:	0e 94 6c 13 	call	0x26d8	; 0x26d8 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c70:	4e 81       	ldd	r20, Y+6	; 0x06
    1c72:	5f 81       	ldd	r21, Y+7	; 0x07
    1c74:	68 85       	ldd	r22, Y+8	; 0x08
    1c76:	79 85       	ldd	r23, Y+9	; 0x09
    1c78:	c6 01       	movw	r24, r12
    1c7a:	0e 94 63 12 	call	0x24c6	; 0x24c6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1c7e:	c7 01       	movw	r24, r14
    1c80:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1c84:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
    1c88:	81 11       	cpse	r24, r1
    1c8a:	73 cf       	rjmp	.-282    	; 0x1b72 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1c8c:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1c90:	70 cf       	rjmp	.-288    	; 0x1b72 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1c92:	c7 01       	movw	r24, r14
    1c94:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1c98:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
    1c9c:	6a cf       	rjmp	.-300    	; 0x1b72 <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1c9e:	c7 01       	movw	r24, r14
    1ca0:	0e 94 24 0c 	call	0x1848	; 0x1848 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1ca4:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1ca8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1caa:	29 96       	adiw	r28, 0x09	; 9
    1cac:	cd bf       	out	0x3d, r28	; 61
    1cae:	de bf       	out	0x3e, r29	; 62
    1cb0:	df 91       	pop	r29
    1cb2:	cf 91       	pop	r28
    1cb4:	1f 91       	pop	r17
    1cb6:	0f 91       	pop	r16
    1cb8:	ff 90       	pop	r15
    1cba:	ef 90       	pop	r14
    1cbc:	df 90       	pop	r13
    1cbe:	cf 90       	pop	r12
    1cc0:	bf 90       	pop	r11
    1cc2:	af 90       	pop	r10
    1cc4:	08 95       	ret

00001cc6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	cf 93       	push	r28
    1ccc:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1cce:	fc 01       	movw	r30, r24
    1cd0:	26 8d       	ldd	r18, Z+30	; 0x1e
    1cd2:	22 23       	and	r18, r18
    1cd4:	d9 f0       	breq	.+54     	; 0x1d0c <xQueueReceiveFromISR+0x46>
    1cd6:	8a 01       	movw	r16, r20
    1cd8:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1cda:	0e 94 0a 0c 	call	0x1814	; 0x1814 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1cde:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ce0:	81 50       	subi	r24, 0x01	; 1
    1ce2:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1ce4:	89 a1       	ldd	r24, Y+33	; 0x21
    1ce6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce8:	69 f4       	brne	.+26     	; 0x1d04 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cea:	88 85       	ldd	r24, Y+8	; 0x08
    1cec:	88 23       	and	r24, r24
    1cee:	81 f0       	breq	.+32     	; 0x1d10 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cf0:	ce 01       	movw	r24, r28
    1cf2:	08 96       	adiw	r24, 0x08	; 8
    1cf4:	0e 94 8d 12 	call	0x251a	; 0x251a <xTaskRemoveFromEventList>
    1cf8:	88 23       	and	r24, r24
    1cfa:	61 f0       	breq	.+24     	; 0x1d14 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1cfc:	81 e0       	ldi	r24, 0x01	; 1
    1cfe:	f8 01       	movw	r30, r16
    1d00:	80 83       	st	Z, r24
    1d02:	09 c0       	rjmp	.+18     	; 0x1d16 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1d04:	8f 5f       	subi	r24, 0xFF	; 255
    1d06:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1d08:	81 e0       	ldi	r24, 0x01	; 1
    1d0a:	05 c0       	rjmp	.+10     	; 0x1d16 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	03 c0       	rjmp	.+6      	; 0x1d16 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1d10:	81 e0       	ldi	r24, 0x01	; 1
    1d12:	01 c0       	rjmp	.+2      	; 0x1d16 <xQueueReceiveFromISR+0x50>
    1d14:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1d16:	df 91       	pop	r29
    1d18:	cf 91       	pop	r28
    1d1a:	1f 91       	pop	r17
    1d1c:	0f 91       	pop	r16
    1d1e:	08 95       	ret

00001d20 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d20:	0f b6       	in	r0, 0x3f	; 63
    1d22:	f8 94       	cli
    1d24:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1d26:	fc 01       	movw	r30, r24
    1d28:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1d2a:	0f 90       	pop	r0
    1d2c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1d2e:	08 95       	ret

00001d30 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1d30:	fc 01       	movw	r30, r24
    1d32:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1d34:	08 95       	ret

00001d36 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1d36:	ce e2       	ldi	r28, 0x2E	; 46
    1d38:	d1 e3       	ldi	r29, 0x31	; 49
    1d3a:	88 81       	ld	r24, Y
    1d3c:	82 30       	cpi	r24, 0x02	; 2
    1d3e:	e8 f3       	brcs	.-6      	; 0x1d3a <prvIdleTask+0x4>
    1d40:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1d44:	fa cf       	rjmp	.-12     	; 0x1d3a <prvIdleTask+0x4>

00001d46 <prvAddCurrentTaskToDelayedList>:
    1d46:	cf 92       	push	r12
    1d48:	df 92       	push	r13
    1d4a:	ef 92       	push	r14
    1d4c:	ff 92       	push	r15
    1d4e:	6b 01       	movw	r12, r22
    1d50:	7c 01       	movw	r14, r24
    1d52:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    1d56:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1d5a:	62 83       	std	Z+2, r22	; 0x02
    1d5c:	73 83       	std	Z+3, r23	; 0x03
    1d5e:	84 83       	std	Z+4, r24	; 0x04
    1d60:	95 83       	std	Z+5, r25	; 0x05
    1d62:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    1d66:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    1d6a:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    1d6e:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    1d72:	c8 16       	cp	r12, r24
    1d74:	d9 06       	cpc	r13, r25
    1d76:	ea 06       	cpc	r14, r26
    1d78:	fb 06       	cpc	r15, r27
    1d7a:	68 f4       	brcc	.+26     	; 0x1d96 <prvAddCurrentTaskToDelayedList+0x50>
    1d7c:	60 91 5a 31 	lds	r22, 0x315A	; 0x80315a <pxCurrentTCB>
    1d80:	70 91 5b 31 	lds	r23, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1d84:	80 91 14 31 	lds	r24, 0x3114	; 0x803114 <pxOverflowDelayedTaskList>
    1d88:	90 91 15 31 	lds	r25, 0x3115	; 0x803115 <pxOverflowDelayedTaskList+0x1>
    1d8c:	6e 5f       	subi	r22, 0xFE	; 254
    1d8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d90:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <vListInsert>
    1d94:	21 c0       	rjmp	.+66     	; 0x1dd8 <prvAddCurrentTaskToDelayedList+0x92>
    1d96:	60 91 5a 31 	lds	r22, 0x315A	; 0x80315a <pxCurrentTCB>
    1d9a:	70 91 5b 31 	lds	r23, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1d9e:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <pxDelayedTaskList>
    1da2:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    1da6:	6e 5f       	subi	r22, 0xFE	; 254
    1da8:	7f 4f       	sbci	r23, 0xFF	; 255
    1daa:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <vListInsert>
    1dae:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1db2:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1db6:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dba:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dbe:	c8 16       	cp	r12, r24
    1dc0:	d9 06       	cpc	r13, r25
    1dc2:	ea 06       	cpc	r14, r26
    1dc4:	fb 06       	cpc	r15, r27
    1dc6:	40 f4       	brcc	.+16     	; 0x1dd8 <prvAddCurrentTaskToDelayedList+0x92>
    1dc8:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1dcc:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dd0:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1dd4:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1dd8:	ff 90       	pop	r15
    1dda:	ef 90       	pop	r14
    1ddc:	df 90       	pop	r13
    1dde:	cf 90       	pop	r12
    1de0:	08 95       	ret

00001de2 <xTaskGenericCreate>:
    1de2:	4f 92       	push	r4
    1de4:	5f 92       	push	r5
    1de6:	6f 92       	push	r6
    1de8:	7f 92       	push	r7
    1dea:	8f 92       	push	r8
    1dec:	9f 92       	push	r9
    1dee:	af 92       	push	r10
    1df0:	bf 92       	push	r11
    1df2:	cf 92       	push	r12
    1df4:	df 92       	push	r13
    1df6:	ef 92       	push	r14
    1df8:	ff 92       	push	r15
    1dfa:	0f 93       	push	r16
    1dfc:	1f 93       	push	r17
    1dfe:	cf 93       	push	r28
    1e00:	df 93       	push	r29
    1e02:	5c 01       	movw	r10, r24
    1e04:	4b 01       	movw	r8, r22
    1e06:	3a 01       	movw	r6, r20
    1e08:	29 01       	movw	r4, r18
    1e0a:	88 e2       	ldi	r24, 0x28	; 40
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    1e12:	ec 01       	movw	r28, r24
    1e14:	89 2b       	or	r24, r25
    1e16:	09 f4       	brne	.+2      	; 0x1e1a <xTaskGenericCreate+0x38>
    1e18:	d4 c0       	rjmp	.+424    	; 0x1fc2 <xTaskGenericCreate+0x1e0>
    1e1a:	c1 14       	cp	r12, r1
    1e1c:	d1 04       	cpc	r13, r1
    1e1e:	09 f0       	breq	.+2      	; 0x1e22 <xTaskGenericCreate+0x40>
    1e20:	cc c0       	rjmp	.+408    	; 0x1fba <xTaskGenericCreate+0x1d8>
    1e22:	c3 01       	movw	r24, r6
    1e24:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    1e28:	8b 8f       	std	Y+27, r24	; 0x1b
    1e2a:	9c 8f       	std	Y+28, r25	; 0x1c
    1e2c:	00 97       	sbiw	r24, 0x00	; 0
    1e2e:	21 f4       	brne	.+8      	; 0x1e38 <xTaskGenericCreate+0x56>
    1e30:	ce 01       	movw	r24, r28
    1e32:	0e 94 5e 09 	call	0x12bc	; 0x12bc <vPortFree>
    1e36:	c5 c0       	rjmp	.+394    	; 0x1fc2 <xTaskGenericCreate+0x1e0>
    1e38:	a3 01       	movw	r20, r6
    1e3a:	61 e1       	ldi	r22, 0x11	; 17
    1e3c:	70 e0       	ldi	r23, 0x00	; 0
    1e3e:	0e 94 fd 20 	call	0x41fa	; 0x41fa <memset>
    1e42:	93 01       	movw	r18, r6
    1e44:	21 50       	subi	r18, 0x01	; 1
    1e46:	31 09       	sbc	r19, r1
    1e48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e4a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e4c:	3c 01       	movw	r6, r24
    1e4e:	62 0e       	add	r6, r18
    1e50:	73 1e       	adc	r7, r19
    1e52:	4a e0       	ldi	r20, 0x0A	; 10
    1e54:	50 e0       	ldi	r21, 0x00	; 0
    1e56:	b4 01       	movw	r22, r8
    1e58:	ce 01       	movw	r24, r28
    1e5a:	4d 96       	adiw	r24, 0x1d	; 29
    1e5c:	0e 94 04 21 	call	0x4208	; 0x4208 <strncpy>
    1e60:	1e a2       	std	Y+38, r1	; 0x26
    1e62:	10 2f       	mov	r17, r16
    1e64:	04 30       	cpi	r16, 0x04	; 4
    1e66:	08 f0       	brcs	.+2      	; 0x1e6a <xTaskGenericCreate+0x88>
    1e68:	13 e0       	ldi	r17, 0x03	; 3
    1e6a:	1a 8f       	std	Y+26, r17	; 0x1a
    1e6c:	1f a3       	std	Y+39, r17	; 0x27
    1e6e:	6e 01       	movw	r12, r28
    1e70:	22 e0       	ldi	r18, 0x02	; 2
    1e72:	c2 0e       	add	r12, r18
    1e74:	d1 1c       	adc	r13, r1
    1e76:	c6 01       	movw	r24, r12
    1e78:	0e 94 a7 09 	call	0x134e	; 0x134e <vListInitialiseItem>
    1e7c:	ce 01       	movw	r24, r28
    1e7e:	0e 96       	adiw	r24, 0x0e	; 14
    1e80:	0e 94 a7 09 	call	0x134e	; 0x134e <vListInitialiseItem>
    1e84:	ca 87       	std	Y+10, r28	; 0x0a
    1e86:	db 87       	std	Y+11, r29	; 0x0b
    1e88:	84 e0       	ldi	r24, 0x04	; 4
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	a0 e0       	ldi	r26, 0x00	; 0
    1e8e:	b0 e0       	ldi	r27, 0x00	; 0
    1e90:	81 1b       	sub	r24, r17
    1e92:	91 09       	sbc	r25, r1
    1e94:	a1 09       	sbc	r26, r1
    1e96:	b1 09       	sbc	r27, r1
    1e98:	8e 87       	std	Y+14, r24	; 0x0e
    1e9a:	9f 87       	std	Y+15, r25	; 0x0f
    1e9c:	a8 8b       	std	Y+16, r26	; 0x10
    1e9e:	b9 8b       	std	Y+17, r27	; 0x11
    1ea0:	ce 8b       	std	Y+22, r28	; 0x16
    1ea2:	df 8b       	std	Y+23, r29	; 0x17
    1ea4:	a2 01       	movw	r20, r4
    1ea6:	b5 01       	movw	r22, r10
    1ea8:	c3 01       	movw	r24, r6
    1eaa:	0e 94 43 0a 	call	0x1486	; 0x1486 <pxPortInitialiseStack>
    1eae:	88 83       	st	Y, r24
    1eb0:	99 83       	std	Y+1, r25	; 0x01
    1eb2:	e1 14       	cp	r14, r1
    1eb4:	f1 04       	cpc	r15, r1
    1eb6:	19 f0       	breq	.+6      	; 0x1ebe <xTaskGenericCreate+0xdc>
    1eb8:	f7 01       	movw	r30, r14
    1eba:	c0 83       	st	Z, r28
    1ebc:	d1 83       	std	Z+1, r29	; 0x01
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
    1ec4:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <uxCurrentNumberOfTasks>
    1ec8:	8f 5f       	subi	r24, 0xFF	; 255
    1eca:	80 93 06 31 	sts	0x3106, r24	; 0x803106 <uxCurrentNumberOfTasks>
    1ece:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    1ed2:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1ed6:	89 2b       	or	r24, r25
    1ed8:	89 f5       	brne	.+98     	; 0x1f3c <xTaskGenericCreate+0x15a>
    1eda:	c0 93 5a 31 	sts	0x315A, r28	; 0x80315a <pxCurrentTCB>
    1ede:	d0 93 5b 31 	sts	0x315B, r29	; 0x80315b <pxCurrentTCB+0x1>
    1ee2:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <uxCurrentNumberOfTasks>
    1ee6:	81 30       	cpi	r24, 0x01	; 1
    1ee8:	c1 f5       	brne	.+112    	; 0x1f5a <xTaskGenericCreate+0x178>
    1eea:	8e e2       	ldi	r24, 0x2E	; 46
    1eec:	91 e3       	ldi	r25, 0x31	; 49
    1eee:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1ef2:	89 e3       	ldi	r24, 0x39	; 57
    1ef4:	91 e3       	ldi	r25, 0x31	; 49
    1ef6:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1efa:	84 e4       	ldi	r24, 0x44	; 68
    1efc:	91 e3       	ldi	r25, 0x31	; 49
    1efe:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1f02:	8f e4       	ldi	r24, 0x4F	; 79
    1f04:	91 e3       	ldi	r25, 0x31	; 49
    1f06:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1f0a:	83 e2       	ldi	r24, 0x23	; 35
    1f0c:	91 e3       	ldi	r25, 0x31	; 49
    1f0e:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1f12:	88 e1       	ldi	r24, 0x18	; 24
    1f14:	91 e3       	ldi	r25, 0x31	; 49
    1f16:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1f1a:	89 e0       	ldi	r24, 0x09	; 9
    1f1c:	91 e3       	ldi	r25, 0x31	; 49
    1f1e:	0e 94 96 09 	call	0x132c	; 0x132c <vListInitialise>
    1f22:	83 e2       	ldi	r24, 0x23	; 35
    1f24:	91 e3       	ldi	r25, 0x31	; 49
    1f26:	80 93 16 31 	sts	0x3116, r24	; 0x803116 <pxDelayedTaskList>
    1f2a:	90 93 17 31 	sts	0x3117, r25	; 0x803117 <pxDelayedTaskList+0x1>
    1f2e:	88 e1       	ldi	r24, 0x18	; 24
    1f30:	91 e3       	ldi	r25, 0x31	; 49
    1f32:	80 93 14 31 	sts	0x3114, r24	; 0x803114 <pxOverflowDelayedTaskList>
    1f36:	90 93 15 31 	sts	0x3115, r25	; 0x803115 <pxOverflowDelayedTaskList+0x1>
    1f3a:	0f c0       	rjmp	.+30     	; 0x1f5a <xTaskGenericCreate+0x178>
    1f3c:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <xSchedulerRunning>
    1f40:	81 11       	cpse	r24, r1
    1f42:	0b c0       	rjmp	.+22     	; 0x1f5a <xTaskGenericCreate+0x178>
    1f44:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    1f48:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1f4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f4e:	08 17       	cp	r16, r24
    1f50:	20 f0       	brcs	.+8      	; 0x1f5a <xTaskGenericCreate+0x178>
    1f52:	c0 93 5a 31 	sts	0x315A, r28	; 0x80315a <pxCurrentTCB>
    1f56:	d0 93 5b 31 	sts	0x315B, r29	; 0x80315b <pxCurrentTCB+0x1>
    1f5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f5c:	90 91 01 31 	lds	r25, 0x3101	; 0x803101 <uxTopUsedPriority>
    1f60:	98 17       	cp	r25, r24
    1f62:	10 f4       	brcc	.+4      	; 0x1f68 <xTaskGenericCreate+0x186>
    1f64:	80 93 01 31 	sts	0x3101, r24	; 0x803101 <uxTopUsedPriority>
    1f68:	90 91 fa 30 	lds	r25, 0x30FA	; 0x8030fa <uxTaskNumber>
    1f6c:	9f 5f       	subi	r25, 0xFF	; 255
    1f6e:	90 93 fa 30 	sts	0x30FA, r25	; 0x8030fa <uxTaskNumber>
    1f72:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    1f76:	98 17       	cp	r25, r24
    1f78:	10 f4       	brcc	.+4      	; 0x1f7e <xTaskGenericCreate+0x19c>
    1f7a:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    1f7e:	fb e0       	ldi	r31, 0x0B	; 11
    1f80:	8f 9f       	mul	r24, r31
    1f82:	c0 01       	movw	r24, r0
    1f84:	11 24       	eor	r1, r1
    1f86:	b6 01       	movw	r22, r12
    1f88:	82 5d       	subi	r24, 0xD2	; 210
    1f8a:	9e 4c       	sbci	r25, 0xCE	; 206
    1f8c:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
    1f90:	0f 90       	pop	r0
    1f92:	0f be       	out	0x3f, r0	; 63
    1f94:	80 91 ff 30 	lds	r24, 0x30FF	; 0x8030ff <xSchedulerRunning>
    1f98:	88 23       	and	r24, r24
    1f9a:	59 f0       	breq	.+22     	; 0x1fb2 <xTaskGenericCreate+0x1d0>
    1f9c:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    1fa0:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1fa4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fa6:	80 17       	cp	r24, r16
    1fa8:	30 f4       	brcc	.+12     	; 0x1fb6 <xTaskGenericCreate+0x1d4>
    1faa:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    1fae:	81 e0       	ldi	r24, 0x01	; 1
    1fb0:	09 c0       	rjmp	.+18     	; 0x1fc4 <xTaskGenericCreate+0x1e2>
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	07 c0       	rjmp	.+14     	; 0x1fc4 <xTaskGenericCreate+0x1e2>
    1fb6:	81 e0       	ldi	r24, 0x01	; 1
    1fb8:	05 c0       	rjmp	.+10     	; 0x1fc4 <xTaskGenericCreate+0x1e2>
    1fba:	cb 8e       	std	Y+27, r12	; 0x1b
    1fbc:	dc 8e       	std	Y+28, r13	; 0x1c
    1fbe:	c6 01       	movw	r24, r12
    1fc0:	3b cf       	rjmp	.-394    	; 0x1e38 <xTaskGenericCreate+0x56>
    1fc2:	8f ef       	ldi	r24, 0xFF	; 255
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28
    1fc8:	1f 91       	pop	r17
    1fca:	0f 91       	pop	r16
    1fcc:	ff 90       	pop	r15
    1fce:	ef 90       	pop	r14
    1fd0:	df 90       	pop	r13
    1fd2:	cf 90       	pop	r12
    1fd4:	bf 90       	pop	r11
    1fd6:	af 90       	pop	r10
    1fd8:	9f 90       	pop	r9
    1fda:	8f 90       	pop	r8
    1fdc:	7f 90       	pop	r7
    1fde:	6f 90       	pop	r6
    1fe0:	5f 90       	pop	r5
    1fe2:	4f 90       	pop	r4
    1fe4:	08 95       	ret

00001fe6 <uxTaskPriorityGet>:
    1fe6:	0f b6       	in	r0, 0x3f	; 63
    1fe8:	f8 94       	cli
    1fea:	0f 92       	push	r0
    1fec:	00 97       	sbiw	r24, 0x00	; 0
    1fee:	21 f4       	brne	.+8      	; 0x1ff8 <uxTaskPriorityGet+0x12>
    1ff0:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    1ff4:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    1ff8:	0f 90       	pop	r0
    1ffa:	0f be       	out	0x3f, r0	; 63
    1ffc:	fc 01       	movw	r30, r24
    1ffe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2000:	08 95       	ret

00002002 <vTaskStartScheduler>:
    2002:	af 92       	push	r10
    2004:	bf 92       	push	r11
    2006:	cf 92       	push	r12
    2008:	df 92       	push	r13
    200a:	ef 92       	push	r14
    200c:	ff 92       	push	r15
    200e:	0f 93       	push	r16
    2010:	a1 2c       	mov	r10, r1
    2012:	b1 2c       	mov	r11, r1
    2014:	c1 2c       	mov	r12, r1
    2016:	d1 2c       	mov	r13, r1
    2018:	0f 2e       	mov	r0, r31
    201a:	f7 e0       	ldi	r31, 0x07	; 7
    201c:	ef 2e       	mov	r14, r31
    201e:	f1 e3       	ldi	r31, 0x31	; 49
    2020:	ff 2e       	mov	r15, r31
    2022:	f0 2d       	mov	r31, r0
    2024:	00 e0       	ldi	r16, 0x00	; 0
    2026:	20 e0       	ldi	r18, 0x00	; 0
    2028:	30 e0       	ldi	r19, 0x00	; 0
    202a:	44 e6       	ldi	r20, 0x64	; 100
    202c:	50 e0       	ldi	r21, 0x00	; 0
    202e:	60 e4       	ldi	r22, 0x40	; 64
    2030:	70 e2       	ldi	r23, 0x20	; 32
    2032:	8b e9       	ldi	r24, 0x9B	; 155
    2034:	9e e0       	ldi	r25, 0x0E	; 14
    2036:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <xTaskGenericCreate>
    203a:	81 30       	cpi	r24, 0x01	; 1
    203c:	69 f4       	brne	.+26     	; 0x2058 <vTaskStartScheduler+0x56>
    203e:	f8 94       	cli
    2040:	80 93 ff 30 	sts	0x30FF, r24	; 0x8030ff <xSchedulerRunning>
    2044:	10 92 02 31 	sts	0x3102, r1	; 0x803102 <xTickCount>
    2048:	10 92 03 31 	sts	0x3103, r1	; 0x803103 <xTickCount+0x1>
    204c:	10 92 04 31 	sts	0x3104, r1	; 0x803104 <xTickCount+0x2>
    2050:	10 92 05 31 	sts	0x3105, r1	; 0x803105 <xTickCount+0x3>
    2054:	0e 94 b9 0a 	call	0x1572	; 0x1572 <xPortStartScheduler>
    2058:	0f 91       	pop	r16
    205a:	ff 90       	pop	r15
    205c:	ef 90       	pop	r14
    205e:	df 90       	pop	r13
    2060:	cf 90       	pop	r12
    2062:	bf 90       	pop	r11
    2064:	af 90       	pop	r10
    2066:	08 95       	ret

00002068 <vTaskSuspendAll>:
    2068:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    206c:	8f 5f       	subi	r24, 0xFF	; 255
    206e:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <uxSchedulerSuspended>
    2072:	08 95       	ret

00002074 <xTaskGetTickCount>:
    2074:	0f b6       	in	r0, 0x3f	; 63
    2076:	f8 94       	cli
    2078:	0f 92       	push	r0
    207a:	60 91 02 31 	lds	r22, 0x3102	; 0x803102 <xTickCount>
    207e:	70 91 03 31 	lds	r23, 0x3103	; 0x803103 <xTickCount+0x1>
    2082:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <xTickCount+0x2>
    2086:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <xTickCount+0x3>
    208a:	0f 90       	pop	r0
    208c:	0f be       	out	0x3f, r0	; 63
    208e:	08 95       	ret

00002090 <pcTaskGetTaskName>:
    2090:	00 97       	sbiw	r24, 0x00	; 0
    2092:	21 f4       	brne	.+8      	; 0x209c <pcTaskGetTaskName+0xc>
    2094:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    2098:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    209c:	4d 96       	adiw	r24, 0x1d	; 29
    209e:	08 95       	ret

000020a0 <xTaskGetIdleTaskHandle>:
    20a0:	80 91 07 31 	lds	r24, 0x3107	; 0x803107 <xIdleTaskHandle>
    20a4:	90 91 08 31 	lds	r25, 0x3108	; 0x803108 <xIdleTaskHandle+0x1>
    20a8:	08 95       	ret

000020aa <vTaskIncrementTick>:
    20aa:	ff 92       	push	r15
    20ac:	0f 93       	push	r16
    20ae:	1f 93       	push	r17
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    20b8:	81 11       	cpse	r24, r1
    20ba:	ed c0       	rjmp	.+474    	; 0x2296 <vTaskIncrementTick+0x1ec>
    20bc:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    20c0:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    20c4:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    20c8:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    20cc:	01 96       	adiw	r24, 0x01	; 1
    20ce:	a1 1d       	adc	r26, r1
    20d0:	b1 1d       	adc	r27, r1
    20d2:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <xTickCount>
    20d6:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <xTickCount+0x1>
    20da:	a0 93 04 31 	sts	0x3104, r26	; 0x803104 <xTickCount+0x2>
    20de:	b0 93 05 31 	sts	0x3105, r27	; 0x803105 <xTickCount+0x3>
    20e2:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    20e6:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    20ea:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    20ee:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    20f2:	89 2b       	or	r24, r25
    20f4:	8a 2b       	or	r24, r26
    20f6:	8b 2b       	or	r24, r27
    20f8:	f1 f5       	brne	.+124    	; 0x2176 <vTaskIncrementTick+0xcc>
    20fa:	80 91 16 31 	lds	r24, 0x3116	; 0x803116 <pxDelayedTaskList>
    20fe:	90 91 17 31 	lds	r25, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    2102:	20 91 14 31 	lds	r18, 0x3114	; 0x803114 <pxOverflowDelayedTaskList>
    2106:	30 91 15 31 	lds	r19, 0x3115	; 0x803115 <pxOverflowDelayedTaskList+0x1>
    210a:	20 93 16 31 	sts	0x3116, r18	; 0x803116 <pxDelayedTaskList>
    210e:	30 93 17 31 	sts	0x3117, r19	; 0x803117 <pxDelayedTaskList+0x1>
    2112:	80 93 14 31 	sts	0x3114, r24	; 0x803114 <pxOverflowDelayedTaskList>
    2116:	90 93 15 31 	sts	0x3115, r25	; 0x803115 <pxOverflowDelayedTaskList+0x1>
    211a:	80 91 fb 30 	lds	r24, 0x30FB	; 0x8030fb <xNumOfOverflows>
    211e:	8f 5f       	subi	r24, 0xFF	; 255
    2120:	80 93 fb 30 	sts	0x30FB, r24	; 0x8030fb <xNumOfOverflows>
    2124:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    2128:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    212c:	80 81       	ld	r24, Z
    212e:	81 11       	cpse	r24, r1
    2130:	0c c0       	rjmp	.+24     	; 0x214a <vTaskIncrementTick+0xa0>
    2132:	8f ef       	ldi	r24, 0xFF	; 255
    2134:	9f ef       	ldi	r25, 0xFF	; 255
    2136:	dc 01       	movw	r26, r24
    2138:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    213c:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2140:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2144:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2148:	16 c0       	rjmp	.+44     	; 0x2176 <vTaskIncrementTick+0xcc>
    214a:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    214e:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    2152:	07 80       	ldd	r0, Z+7	; 0x07
    2154:	f0 85       	ldd	r31, Z+8	; 0x08
    2156:	e0 2d       	mov	r30, r0
    2158:	00 84       	ldd	r0, Z+8	; 0x08
    215a:	f1 85       	ldd	r31, Z+9	; 0x09
    215c:	e0 2d       	mov	r30, r0
    215e:	82 81       	ldd	r24, Z+2	; 0x02
    2160:	93 81       	ldd	r25, Z+3	; 0x03
    2162:	a4 81       	ldd	r26, Z+4	; 0x04
    2164:	b5 81       	ldd	r27, Z+5	; 0x05
    2166:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    216a:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    216e:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2172:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2176:	40 91 02 31 	lds	r20, 0x3102	; 0x803102 <xTickCount>
    217a:	50 91 03 31 	lds	r21, 0x3103	; 0x803103 <xTickCount+0x1>
    217e:	60 91 04 31 	lds	r22, 0x3104	; 0x803104 <xTickCount+0x2>
    2182:	70 91 05 31 	lds	r23, 0x3105	; 0x803105 <xTickCount+0x3>
    2186:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    218a:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    218e:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    2192:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2196:	48 17       	cp	r20, r24
    2198:	59 07       	cpc	r21, r25
    219a:	6a 07       	cpc	r22, r26
    219c:	7b 07       	cpc	r23, r27
    219e:	08 f4       	brcc	.+2      	; 0x21a2 <vTaskIncrementTick+0xf8>
    21a0:	7f c0       	rjmp	.+254    	; 0x22a0 <vTaskIncrementTick+0x1f6>
    21a2:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    21a6:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    21aa:	80 81       	ld	r24, Z
    21ac:	88 23       	and	r24, r24
    21ae:	f9 f0       	breq	.+62     	; 0x21ee <vTaskIncrementTick+0x144>
    21b0:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    21b4:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    21b8:	07 80       	ldd	r0, Z+7	; 0x07
    21ba:	f0 85       	ldd	r31, Z+8	; 0x08
    21bc:	e0 2d       	mov	r30, r0
    21be:	c0 85       	ldd	r28, Z+8	; 0x08
    21c0:	d1 85       	ldd	r29, Z+9	; 0x09
    21c2:	8a 81       	ldd	r24, Y+2	; 0x02
    21c4:	9b 81       	ldd	r25, Y+3	; 0x03
    21c6:	ac 81       	ldd	r26, Y+4	; 0x04
    21c8:	bd 81       	ldd	r27, Y+5	; 0x05
    21ca:	40 91 02 31 	lds	r20, 0x3102	; 0x803102 <xTickCount>
    21ce:	50 91 03 31 	lds	r21, 0x3103	; 0x803103 <xTickCount+0x1>
    21d2:	60 91 04 31 	lds	r22, 0x3104	; 0x803104 <xTickCount+0x2>
    21d6:	70 91 05 31 	lds	r23, 0x3105	; 0x803105 <xTickCount+0x3>
    21da:	48 17       	cp	r20, r24
    21dc:	59 07       	cpc	r21, r25
    21de:	6a 07       	cpc	r22, r26
    21e0:	7b 07       	cpc	r23, r27
    21e2:	58 f1       	brcs	.+86     	; 0x223a <vTaskIncrementTick+0x190>
    21e4:	0f 2e       	mov	r0, r31
    21e6:	fb e0       	ldi	r31, 0x0B	; 11
    21e8:	ff 2e       	mov	r15, r31
    21ea:	f0 2d       	mov	r31, r0
    21ec:	2f c0       	rjmp	.+94     	; 0x224c <vTaskIncrementTick+0x1a2>
    21ee:	8f ef       	ldi	r24, 0xFF	; 255
    21f0:	9f ef       	ldi	r25, 0xFF	; 255
    21f2:	dc 01       	movw	r26, r24
    21f4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    21f8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    21fc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2200:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2204:	4d c0       	rjmp	.+154    	; 0x22a0 <vTaskIncrementTick+0x1f6>
    2206:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    220a:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    220e:	07 80       	ldd	r0, Z+7	; 0x07
    2210:	f0 85       	ldd	r31, Z+8	; 0x08
    2212:	e0 2d       	mov	r30, r0
    2214:	c0 85       	ldd	r28, Z+8	; 0x08
    2216:	d1 85       	ldd	r29, Z+9	; 0x09
    2218:	8a 81       	ldd	r24, Y+2	; 0x02
    221a:	9b 81       	ldd	r25, Y+3	; 0x03
    221c:	ac 81       	ldd	r26, Y+4	; 0x04
    221e:	bd 81       	ldd	r27, Y+5	; 0x05
    2220:	40 91 02 31 	lds	r20, 0x3102	; 0x803102 <xTickCount>
    2224:	50 91 03 31 	lds	r21, 0x3103	; 0x803103 <xTickCount+0x1>
    2228:	60 91 04 31 	lds	r22, 0x3104	; 0x803104 <xTickCount+0x2>
    222c:	70 91 05 31 	lds	r23, 0x3105	; 0x803105 <xTickCount+0x3>
    2230:	48 17       	cp	r20, r24
    2232:	59 07       	cpc	r21, r25
    2234:	6a 07       	cpc	r22, r26
    2236:	7b 07       	cpc	r23, r27
    2238:	48 f4       	brcc	.+18     	; 0x224c <vTaskIncrementTick+0x1a2>
    223a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    223e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2242:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2246:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    224a:	2a c0       	rjmp	.+84     	; 0x22a0 <vTaskIncrementTick+0x1f6>
    224c:	8e 01       	movw	r16, r28
    224e:	0e 5f       	subi	r16, 0xFE	; 254
    2250:	1f 4f       	sbci	r17, 0xFF	; 255
    2252:	c8 01       	movw	r24, r16
    2254:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
    2258:	88 8d       	ldd	r24, Y+24	; 0x18
    225a:	99 8d       	ldd	r25, Y+25	; 0x19
    225c:	89 2b       	or	r24, r25
    225e:	21 f0       	breq	.+8      	; 0x2268 <vTaskIncrementTick+0x1be>
    2260:	ce 01       	movw	r24, r28
    2262:	0e 96       	adiw	r24, 0x0e	; 14
    2264:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
    2268:	8a 8d       	ldd	r24, Y+26	; 0x1a
    226a:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    226e:	98 17       	cp	r25, r24
    2270:	10 f4       	brcc	.+4      	; 0x2276 <vTaskIncrementTick+0x1cc>
    2272:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    2276:	f8 9e       	mul	r15, r24
    2278:	c0 01       	movw	r24, r0
    227a:	11 24       	eor	r1, r1
    227c:	b8 01       	movw	r22, r16
    227e:	82 5d       	subi	r24, 0xD2	; 210
    2280:	9e 4c       	sbci	r25, 0xCE	; 206
    2282:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
    2286:	e0 91 16 31 	lds	r30, 0x3116	; 0x803116 <pxDelayedTaskList>
    228a:	f0 91 17 31 	lds	r31, 0x3117	; 0x803117 <pxDelayedTaskList+0x1>
    228e:	80 81       	ld	r24, Z
    2290:	81 11       	cpse	r24, r1
    2292:	b9 cf       	rjmp	.-142    	; 0x2206 <vTaskIncrementTick+0x15c>
    2294:	ac cf       	rjmp	.-168    	; 0x21ee <vTaskIncrementTick+0x144>
    2296:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <uxMissedTicks>
    229a:	8f 5f       	subi	r24, 0xFF	; 255
    229c:	80 93 fd 30 	sts	0x30FD, r24	; 0x8030fd <uxMissedTicks>
    22a0:	df 91       	pop	r29
    22a2:	cf 91       	pop	r28
    22a4:	1f 91       	pop	r17
    22a6:	0f 91       	pop	r16
    22a8:	ff 90       	pop	r15
    22aa:	08 95       	ret

000022ac <xTaskResumeAll>:
    22ac:	cf 92       	push	r12
    22ae:	df 92       	push	r13
    22b0:	ef 92       	push	r14
    22b2:	ff 92       	push	r15
    22b4:	0f 93       	push	r16
    22b6:	1f 93       	push	r17
    22b8:	cf 93       	push	r28
    22ba:	df 93       	push	r29
    22bc:	0f b6       	in	r0, 0x3f	; 63
    22be:	f8 94       	cli
    22c0:	0f 92       	push	r0
    22c2:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    22c6:	81 50       	subi	r24, 0x01	; 1
    22c8:	80 93 fe 30 	sts	0x30FE, r24	; 0x8030fe <uxSchedulerSuspended>
    22cc:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    22d0:	81 11       	cpse	r24, r1
    22d2:	60 c0       	rjmp	.+192    	; 0x2394 <xTaskResumeAll+0xe8>
    22d4:	80 91 06 31 	lds	r24, 0x3106	; 0x803106 <uxCurrentNumberOfTasks>
    22d8:	81 11       	cpse	r24, r1
    22da:	2c c0       	rjmp	.+88     	; 0x2334 <xTaskResumeAll+0x88>
    22dc:	5e c0       	rjmp	.+188    	; 0x239a <xTaskResumeAll+0xee>
    22de:	d7 01       	movw	r26, r14
    22e0:	17 96       	adiw	r26, 0x07	; 7
    22e2:	ed 91       	ld	r30, X+
    22e4:	fc 91       	ld	r31, X
    22e6:	18 97       	sbiw	r26, 0x08	; 8
    22e8:	c0 85       	ldd	r28, Z+8	; 0x08
    22ea:	d1 85       	ldd	r29, Z+9	; 0x09
    22ec:	ce 01       	movw	r24, r28
    22ee:	0e 96       	adiw	r24, 0x0e	; 14
    22f0:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
    22f4:	8e 01       	movw	r16, r28
    22f6:	0e 5f       	subi	r16, 0xFE	; 254
    22f8:	1f 4f       	sbci	r17, 0xFF	; 255
    22fa:	c8 01       	movw	r24, r16
    22fc:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
    2300:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2302:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    2306:	98 17       	cp	r25, r24
    2308:	10 f4       	brcc	.+4      	; 0x230e <xTaskResumeAll+0x62>
    230a:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    230e:	d8 9e       	mul	r13, r24
    2310:	c0 01       	movw	r24, r0
    2312:	11 24       	eor	r1, r1
    2314:	b8 01       	movw	r22, r16
    2316:	82 5d       	subi	r24, 0xD2	; 210
    2318:	9e 4c       	sbci	r25, 0xCE	; 206
    231a:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
    231e:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    2322:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    2326:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2328:	82 8d       	ldd	r24, Z+26	; 0x1a
    232a:	98 17       	cp	r25, r24
    232c:	70 f0       	brcs	.+28     	; 0x234a <xTaskResumeAll+0x9e>
    232e:	cc 24       	eor	r12, r12
    2330:	c3 94       	inc	r12
    2332:	0b c0       	rjmp	.+22     	; 0x234a <xTaskResumeAll+0x9e>
    2334:	c1 2c       	mov	r12, r1
    2336:	0f 2e       	mov	r0, r31
    2338:	f9 e0       	ldi	r31, 0x09	; 9
    233a:	ef 2e       	mov	r14, r31
    233c:	f1 e3       	ldi	r31, 0x31	; 49
    233e:	ff 2e       	mov	r15, r31
    2340:	f0 2d       	mov	r31, r0
    2342:	0f 2e       	mov	r0, r31
    2344:	fb e0       	ldi	r31, 0x0B	; 11
    2346:	df 2e       	mov	r13, r31
    2348:	f0 2d       	mov	r31, r0
    234a:	f7 01       	movw	r30, r14
    234c:	80 81       	ld	r24, Z
    234e:	81 11       	cpse	r24, r1
    2350:	c6 cf       	rjmp	.-116    	; 0x22de <xTaskResumeAll+0x32>
    2352:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <uxMissedTicks>
    2356:	88 23       	and	r24, r24
    2358:	81 f0       	breq	.+32     	; 0x237a <xTaskResumeAll+0xce>
    235a:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <uxMissedTicks>
    235e:	88 23       	and	r24, r24
    2360:	99 f0       	breq	.+38     	; 0x2388 <xTaskResumeAll+0xdc>
    2362:	0e 94 55 10 	call	0x20aa	; 0x20aa <vTaskIncrementTick>
    2366:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <uxMissedTicks>
    236a:	81 50       	subi	r24, 0x01	; 1
    236c:	80 93 fd 30 	sts	0x30FD, r24	; 0x8030fd <uxMissedTicks>
    2370:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <uxMissedTicks>
    2374:	81 11       	cpse	r24, r1
    2376:	f5 cf       	rjmp	.-22     	; 0x2362 <xTaskResumeAll+0xb6>
    2378:	07 c0       	rjmp	.+14     	; 0x2388 <xTaskResumeAll+0xdc>
    237a:	f1 e0       	ldi	r31, 0x01	; 1
    237c:	cf 16       	cp	r12, r31
    237e:	21 f0       	breq	.+8      	; 0x2388 <xTaskResumeAll+0xdc>
    2380:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <xMissedYield>
    2384:	81 30       	cpi	r24, 0x01	; 1
    2386:	41 f4       	brne	.+16     	; 0x2398 <xTaskResumeAll+0xec>
    2388:	10 92 fc 30 	sts	0x30FC, r1	; 0x8030fc <xMissedYield>
    238c:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
    2390:	81 e0       	ldi	r24, 0x01	; 1
    2392:	03 c0       	rjmp	.+6      	; 0x239a <xTaskResumeAll+0xee>
    2394:	80 e0       	ldi	r24, 0x00	; 0
    2396:	01 c0       	rjmp	.+2      	; 0x239a <xTaskResumeAll+0xee>
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	0f 90       	pop	r0
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	df 91       	pop	r29
    23a0:	cf 91       	pop	r28
    23a2:	1f 91       	pop	r17
    23a4:	0f 91       	pop	r16
    23a6:	ff 90       	pop	r15
    23a8:	ef 90       	pop	r14
    23aa:	df 90       	pop	r13
    23ac:	cf 90       	pop	r12
    23ae:	08 95       	ret

000023b0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    23b0:	cf 92       	push	r12
    23b2:	df 92       	push	r13
    23b4:	ef 92       	push	r14
    23b6:	ff 92       	push	r15
    23b8:	6b 01       	movw	r12, r22
    23ba:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    23bc:	67 2b       	or	r22, r23
    23be:	68 2b       	or	r22, r24
    23c0:	69 2b       	or	r22, r25
    23c2:	e9 f0       	breq	.+58     	; 0x23fe <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    23c4:	0e 94 34 10 	call	0x2068	; 0x2068 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    23c8:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    23cc:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    23d0:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    23d4:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    23d8:	c8 0e       	add	r12, r24
    23da:	d9 1e       	adc	r13, r25
    23dc:	ea 1e       	adc	r14, r26
    23de:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23e0:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    23e4:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    23e8:	02 96       	adiw	r24, 0x02	; 2
    23ea:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    23ee:	c7 01       	movw	r24, r14
    23f0:	b6 01       	movw	r22, r12
    23f2:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    23f6:	0e 94 56 11 	call	0x22ac	; 0x22ac <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    23fa:	81 11       	cpse	r24, r1
    23fc:	02 c0       	rjmp	.+4      	; 0x2402 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    23fe:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <vPortYield>
		}
	}
    2402:	ff 90       	pop	r15
    2404:	ef 90       	pop	r14
    2406:	df 90       	pop	r13
    2408:	cf 90       	pop	r12
    240a:	08 95       	ret

0000240c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    240c:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    2410:	81 11       	cpse	r24, r1
    2412:	0c c0       	rjmp	.+24     	; 0x242c <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2414:	e0 91 00 31 	lds	r30, 0x3100	; 0x803100 <uxTopReadyPriority>
    2418:	4b e0       	ldi	r20, 0x0B	; 11
    241a:	e4 9f       	mul	r30, r20
    241c:	f0 01       	movw	r30, r0
    241e:	11 24       	eor	r1, r1
    2420:	e2 5d       	subi	r30, 0xD2	; 210
    2422:	fe 4c       	sbci	r31, 0xCE	; 206
    2424:	80 81       	ld	r24, Z
    2426:	88 23       	and	r24, r24
    2428:	29 f0       	breq	.+10     	; 0x2434 <vTaskSwitchContext+0x28>
    242a:	14 c0       	rjmp	.+40     	; 0x2454 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <xMissedYield>
    2432:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2434:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2436:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxTopReadyPriority>
    243a:	81 50       	subi	r24, 0x01	; 1
    243c:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2440:	e0 91 00 31 	lds	r30, 0x3100	; 0x803100 <uxTopReadyPriority>
    2444:	9e 9f       	mul	r25, r30
    2446:	f0 01       	movw	r30, r0
    2448:	11 24       	eor	r1, r1
    244a:	e2 5d       	subi	r30, 0xD2	; 210
    244c:	fe 4c       	sbci	r31, 0xCE	; 206
    244e:	80 81       	ld	r24, Z
    2450:	88 23       	and	r24, r24
    2452:	89 f3       	breq	.-30     	; 0x2436 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2454:	80 91 00 31 	lds	r24, 0x3100	; 0x803100 <uxTopReadyPriority>
    2458:	28 2f       	mov	r18, r24
    245a:	30 e0       	ldi	r19, 0x00	; 0
    245c:	4b e0       	ldi	r20, 0x0B	; 11
    245e:	84 9f       	mul	r24, r20
    2460:	c0 01       	movw	r24, r0
    2462:	11 24       	eor	r1, r1
    2464:	dc 01       	movw	r26, r24
    2466:	a2 5d       	subi	r26, 0xD2	; 210
    2468:	be 4c       	sbci	r27, 0xCE	; 206
    246a:	11 96       	adiw	r26, 0x01	; 1
    246c:	ed 91       	ld	r30, X+
    246e:	fc 91       	ld	r31, X
    2470:	12 97       	sbiw	r26, 0x02	; 2
    2472:	04 80       	ldd	r0, Z+4	; 0x04
    2474:	f5 81       	ldd	r31, Z+5	; 0x05
    2476:	e0 2d       	mov	r30, r0
    2478:	11 96       	adiw	r26, 0x01	; 1
    247a:	ed 93       	st	X+, r30
    247c:	fc 93       	st	X, r31
    247e:	12 97       	sbiw	r26, 0x02	; 2
    2480:	8f 5c       	subi	r24, 0xCF	; 207
    2482:	9e 4c       	sbci	r25, 0xCE	; 206
    2484:	e8 17       	cp	r30, r24
    2486:	f9 07       	cpc	r31, r25
    2488:	61 f4       	brne	.+24     	; 0x24a2 <vTaskSwitchContext+0x96>
    248a:	84 81       	ldd	r24, Z+4	; 0x04
    248c:	95 81       	ldd	r25, Z+5	; 0x05
    248e:	4b e0       	ldi	r20, 0x0B	; 11
    2490:	42 9f       	mul	r20, r18
    2492:	f0 01       	movw	r30, r0
    2494:	43 9f       	mul	r20, r19
    2496:	f0 0d       	add	r31, r0
    2498:	11 24       	eor	r1, r1
    249a:	e2 5d       	subi	r30, 0xD2	; 210
    249c:	fe 4c       	sbci	r31, 0xCE	; 206
    249e:	81 83       	std	Z+1, r24	; 0x01
    24a0:	92 83       	std	Z+2, r25	; 0x02
    24a2:	8b e0       	ldi	r24, 0x0B	; 11
    24a4:	82 9f       	mul	r24, r18
    24a6:	f0 01       	movw	r30, r0
    24a8:	83 9f       	mul	r24, r19
    24aa:	f0 0d       	add	r31, r0
    24ac:	11 24       	eor	r1, r1
    24ae:	e2 5d       	subi	r30, 0xD2	; 210
    24b0:	fe 4c       	sbci	r31, 0xCE	; 206
    24b2:	01 80       	ldd	r0, Z+1	; 0x01
    24b4:	f2 81       	ldd	r31, Z+2	; 0x02
    24b6:	e0 2d       	mov	r30, r0
    24b8:	80 85       	ldd	r24, Z+8	; 0x08
    24ba:	91 85       	ldd	r25, Z+9	; 0x09
    24bc:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <pxCurrentTCB>
    24c0:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <pxCurrentTCB+0x1>
    24c4:	08 95       	ret

000024c6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    24c6:	cf 92       	push	r12
    24c8:	df 92       	push	r13
    24ca:	ef 92       	push	r14
    24cc:	ff 92       	push	r15
    24ce:	6a 01       	movw	r12, r20
    24d0:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    24d2:	60 91 5a 31 	lds	r22, 0x315A	; 0x80315a <pxCurrentTCB>
    24d6:	70 91 5b 31 	lds	r23, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    24da:	62 5f       	subi	r22, 0xF2	; 242
    24dc:	7f 4f       	sbci	r23, 0xFF	; 255
    24de:	0e 94 d2 09 	call	0x13a4	; 0x13a4 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24e2:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    24e6:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    24ea:	02 96       	adiw	r24, 0x02	; 2
    24ec:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    24f0:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    24f4:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    24f8:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    24fc:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2500:	bc 01       	movw	r22, r24
    2502:	cd 01       	movw	r24, r26
    2504:	6c 0d       	add	r22, r12
    2506:	7d 1d       	adc	r23, r13
    2508:	8e 1d       	adc	r24, r14
    250a:	9f 1d       	adc	r25, r15
    250c:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2510:	ff 90       	pop	r15
    2512:	ef 90       	pop	r14
    2514:	df 90       	pop	r13
    2516:	cf 90       	pop	r12
    2518:	08 95       	ret

0000251a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    251a:	0f 93       	push	r16
    251c:	1f 93       	push	r17
    251e:	cf 93       	push	r28
    2520:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2522:	dc 01       	movw	r26, r24
    2524:	17 96       	adiw	r26, 0x07	; 7
    2526:	ed 91       	ld	r30, X+
    2528:	fc 91       	ld	r31, X
    252a:	18 97       	sbiw	r26, 0x08	; 8
    252c:	c0 85       	ldd	r28, Z+8	; 0x08
    252e:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2530:	8e 01       	movw	r16, r28
    2532:	02 5f       	subi	r16, 0xF2	; 242
    2534:	1f 4f       	sbci	r17, 0xFF	; 255
    2536:	c8 01       	movw	r24, r16
    2538:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    253c:	80 91 fe 30 	lds	r24, 0x30FE	; 0x8030fe <uxSchedulerSuspended>
    2540:	81 11       	cpse	r24, r1
    2542:	16 c0       	rjmp	.+44     	; 0x2570 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2544:	0c 50       	subi	r16, 0x0C	; 12
    2546:	11 09       	sbc	r17, r1
    2548:	c8 01       	movw	r24, r16
    254a:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    254e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2550:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    2554:	98 17       	cp	r25, r24
    2556:	10 f4       	brcc	.+4      	; 0x255c <xTaskRemoveFromEventList+0x42>
    2558:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    255c:	bb e0       	ldi	r27, 0x0B	; 11
    255e:	8b 9f       	mul	r24, r27
    2560:	c0 01       	movw	r24, r0
    2562:	11 24       	eor	r1, r1
    2564:	b8 01       	movw	r22, r16
    2566:	82 5d       	subi	r24, 0xD2	; 210
    2568:	9e 4c       	sbci	r25, 0xCE	; 206
    256a:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
    256e:	05 c0       	rjmp	.+10     	; 0x257a <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2570:	b8 01       	movw	r22, r16
    2572:	89 e0       	ldi	r24, 0x09	; 9
    2574:	91 e3       	ldi	r25, 0x31	; 49
    2576:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    257a:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    257e:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2586:	92 8d       	ldd	r25, Z+26	; 0x1a
    2588:	29 17       	cp	r18, r25
    258a:	08 f4       	brcc	.+2      	; 0x258e <xTaskRemoveFromEventList+0x74>
    258c:	80 e0       	ldi	r24, 0x00	; 0
}
    258e:	df 91       	pop	r29
    2590:	cf 91       	pop	r28
    2592:	1f 91       	pop	r17
    2594:	0f 91       	pop	r16
    2596:	08 95       	ret

00002598 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2598:	20 91 fb 30 	lds	r18, 0x30FB	; 0x8030fb <xNumOfOverflows>
    259c:	fc 01       	movw	r30, r24
    259e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    25a0:	40 91 02 31 	lds	r20, 0x3102	; 0x803102 <xTickCount>
    25a4:	50 91 03 31 	lds	r21, 0x3103	; 0x803103 <xTickCount+0x1>
    25a8:	60 91 04 31 	lds	r22, 0x3104	; 0x803104 <xTickCount+0x2>
    25ac:	70 91 05 31 	lds	r23, 0x3105	; 0x803105 <xTickCount+0x3>
    25b0:	41 83       	std	Z+1, r20	; 0x01
    25b2:	52 83       	std	Z+2, r21	; 0x02
    25b4:	63 83       	std	Z+3, r22	; 0x03
    25b6:	74 83       	std	Z+4, r23	; 0x04
    25b8:	08 95       	ret

000025ba <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    25ba:	8f 92       	push	r8
    25bc:	9f 92       	push	r9
    25be:	af 92       	push	r10
    25c0:	bf 92       	push	r11
    25c2:	cf 92       	push	r12
    25c4:	df 92       	push	r13
    25c6:	ef 92       	push	r14
    25c8:	ff 92       	push	r15
    25ca:	0f 93       	push	r16
    25cc:	1f 93       	push	r17
    25ce:	cf 93       	push	r28
    25d0:	df 93       	push	r29
    25d2:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25d4:	0f b6       	in	r0, 0x3f	; 63
    25d6:	f8 94       	cli
    25d8:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    25da:	80 91 fb 30 	lds	r24, 0x30FB	; 0x8030fb <xNumOfOverflows>
    25de:	90 81       	ld	r25, Z
    25e0:	98 17       	cp	r25, r24
    25e2:	89 f0       	breq	.+34     	; 0x2606 <xTaskCheckForTimeOut+0x4c>
    25e4:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    25e8:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    25ec:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    25f0:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    25f4:	01 81       	ldd	r16, Z+1	; 0x01
    25f6:	12 81       	ldd	r17, Z+2	; 0x02
    25f8:	23 81       	ldd	r18, Z+3	; 0x03
    25fa:	34 81       	ldd	r19, Z+4	; 0x04
    25fc:	80 17       	cp	r24, r16
    25fe:	91 07       	cpc	r25, r17
    2600:	a2 07       	cpc	r26, r18
    2602:	b3 07       	cpc	r27, r19
    2604:	a8 f5       	brcc	.+106    	; 0x2670 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2606:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <xTickCount>
    260a:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <xTickCount+0x1>
    260e:	a0 91 04 31 	lds	r26, 0x3104	; 0x803104 <xTickCount+0x2>
    2612:	b0 91 05 31 	lds	r27, 0x3105	; 0x803105 <xTickCount+0x3>
    2616:	c1 80       	ldd	r12, Z+1	; 0x01
    2618:	d2 80       	ldd	r13, Z+2	; 0x02
    261a:	e3 80       	ldd	r14, Z+3	; 0x03
    261c:	f4 80       	ldd	r15, Z+4	; 0x04
    261e:	eb 01       	movw	r28, r22
    2620:	08 81       	ld	r16, Y
    2622:	19 81       	ldd	r17, Y+1	; 0x01
    2624:	2a 81       	ldd	r18, Y+2	; 0x02
    2626:	3b 81       	ldd	r19, Y+3	; 0x03
    2628:	8c 19       	sub	r24, r12
    262a:	9d 09       	sbc	r25, r13
    262c:	ae 09       	sbc	r26, r14
    262e:	bf 09       	sbc	r27, r15
    2630:	80 17       	cp	r24, r16
    2632:	91 07       	cpc	r25, r17
    2634:	a2 07       	cpc	r26, r18
    2636:	b3 07       	cpc	r27, r19
    2638:	e8 f4       	brcc	.+58     	; 0x2674 <xTaskCheckForTimeOut+0xba>
    263a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    263c:	80 90 02 31 	lds	r8, 0x3102	; 0x803102 <xTickCount>
    2640:	90 90 03 31 	lds	r9, 0x3103	; 0x803103 <xTickCount+0x1>
    2644:	a0 90 04 31 	lds	r10, 0x3104	; 0x803104 <xTickCount+0x2>
    2648:	b0 90 05 31 	lds	r11, 0x3105	; 0x803105 <xTickCount+0x3>
    264c:	b5 01       	movw	r22, r10
    264e:	a4 01       	movw	r20, r8
    2650:	4c 19       	sub	r20, r12
    2652:	5d 09       	sbc	r21, r13
    2654:	6e 09       	sbc	r22, r14
    2656:	7f 09       	sbc	r23, r15
    2658:	04 1b       	sub	r16, r20
    265a:	15 0b       	sbc	r17, r21
    265c:	26 0b       	sbc	r18, r22
    265e:	37 0b       	sbc	r19, r23
    2660:	08 83       	st	Y, r16
    2662:	19 83       	std	Y+1, r17	; 0x01
    2664:	2a 83       	std	Y+2, r18	; 0x02
    2666:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2668:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    266c:	80 e0       	ldi	r24, 0x00	; 0
    266e:	03 c0       	rjmp	.+6      	; 0x2676 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	01 c0       	rjmp	.+2      	; 0x2676 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2674:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2676:	0f 90       	pop	r0
    2678:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    267a:	df 91       	pop	r29
    267c:	cf 91       	pop	r28
    267e:	1f 91       	pop	r17
    2680:	0f 91       	pop	r16
    2682:	ff 90       	pop	r15
    2684:	ef 90       	pop	r14
    2686:	df 90       	pop	r13
    2688:	cf 90       	pop	r12
    268a:	bf 90       	pop	r11
    268c:	af 90       	pop	r10
    268e:	9f 90       	pop	r9
    2690:	8f 90       	pop	r8
    2692:	08 95       	ret

00002694 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <xMissedYield>
    269a:	08 95       	ret

0000269c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	21 f4       	brne	.+8      	; 0x26a8 <uxTaskGetStackHighWaterMark+0xc>
    26a0:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    26a4:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    26a8:	dc 01       	movw	r26, r24
    26aa:	5b 96       	adiw	r26, 0x1b	; 27
    26ac:	ed 91       	ld	r30, X+
    26ae:	fc 91       	ld	r31, X
    26b0:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    26b2:	80 81       	ld	r24, Z
    26b4:	81 31       	cpi	r24, 0x11	; 17
    26b6:	41 f4       	brne	.+16     	; 0x26c8 <uxTaskGetStackHighWaterMark+0x2c>
    26b8:	31 96       	adiw	r30, 0x01	; 1
    26ba:	80 e0       	ldi	r24, 0x00	; 0
    26bc:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    26be:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    26c0:	21 91       	ld	r18, Z+
    26c2:	21 31       	cpi	r18, 0x11	; 17
    26c4:	e1 f3       	breq	.-8      	; 0x26be <uxTaskGetStackHighWaterMark+0x22>
    26c6:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    26c8:	80 e0       	ldi	r24, 0x00	; 0
    26ca:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    26cc:	08 95       	ret

000026ce <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    26ce:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <pxCurrentTCB>
    26d2:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <pxCurrentTCB+0x1>

		return xReturn;
	}
    26d6:	08 95       	ret

000026d8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    26d8:	0f 93       	push	r16
    26da:	1f 93       	push	r17
    26dc:	cf 93       	push	r28
    26de:	df 93       	push	r29
    26e0:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    26e2:	22 8d       	ldd	r18, Z+26	; 0x1a
    26e4:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    26e8:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    26ec:	5a 96       	adiw	r26, 0x1a	; 26
    26ee:	8c 91       	ld	r24, X
    26f0:	28 17       	cp	r18, r24
    26f2:	08 f0       	brcs	.+2      	; 0x26f6 <vTaskPriorityInherit+0x1e>
    26f4:	41 c0       	rjmp	.+130    	; 0x2778 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    26f6:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    26fa:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    26fe:	5a 96       	adiw	r26, 0x1a	; 26
    2700:	3c 91       	ld	r19, X
    2702:	84 e0       	ldi	r24, 0x04	; 4
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	a0 e0       	ldi	r26, 0x00	; 0
    2708:	b0 e0       	ldi	r27, 0x00	; 0
    270a:	83 1b       	sub	r24, r19
    270c:	91 09       	sbc	r25, r1
    270e:	a1 09       	sbc	r26, r1
    2710:	b1 09       	sbc	r27, r1
    2712:	86 87       	std	Z+14, r24	; 0x0e
    2714:	97 87       	std	Z+15, r25	; 0x0f
    2716:	a0 8b       	std	Z+16, r26	; 0x10
    2718:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    271a:	8b e0       	ldi	r24, 0x0B	; 11
    271c:	28 9f       	mul	r18, r24
    271e:	90 01       	movw	r18, r0
    2720:	11 24       	eor	r1, r1
    2722:	22 5d       	subi	r18, 0xD2	; 210
    2724:	3e 4c       	sbci	r19, 0xCE	; 206
    2726:	84 85       	ldd	r24, Z+12	; 0x0c
    2728:	95 85       	ldd	r25, Z+13	; 0x0d
    272a:	82 17       	cp	r24, r18
    272c:	93 07       	cpc	r25, r19
    272e:	e9 f4       	brne	.+58     	; 0x276a <vTaskPriorityInherit+0x92>
    2730:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2732:	ef 01       	movw	r28, r30
    2734:	22 96       	adiw	r28, 0x02	; 2
    2736:	ce 01       	movw	r24, r28
    2738:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    273c:	e0 91 5a 31 	lds	r30, 0x315A	; 0x80315a <pxCurrentTCB>
    2740:	f0 91 5b 31 	lds	r31, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    2744:	82 8d       	ldd	r24, Z+26	; 0x1a
    2746:	f8 01       	movw	r30, r16
    2748:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    274a:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    274e:	98 17       	cp	r25, r24
    2750:	10 f4       	brcc	.+4      	; 0x2756 <vTaskPriorityInherit+0x7e>
    2752:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    2756:	fb e0       	ldi	r31, 0x0B	; 11
    2758:	8f 9f       	mul	r24, r31
    275a:	c0 01       	movw	r24, r0
    275c:	11 24       	eor	r1, r1
    275e:	be 01       	movw	r22, r28
    2760:	82 5d       	subi	r24, 0xD2	; 210
    2762:	9e 4c       	sbci	r25, 0xCE	; 206
    2764:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
    2768:	07 c0       	rjmp	.+14     	; 0x2778 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    276a:	a0 91 5a 31 	lds	r26, 0x315A	; 0x80315a <pxCurrentTCB>
    276e:	b0 91 5b 31 	lds	r27, 0x315B	; 0x80315b <pxCurrentTCB+0x1>
    2772:	5a 96       	adiw	r26, 0x1a	; 26
    2774:	8c 91       	ld	r24, X
    2776:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2778:	df 91       	pop	r29
    277a:	cf 91       	pop	r28
    277c:	1f 91       	pop	r17
    277e:	0f 91       	pop	r16
    2780:	08 95       	ret

00002782 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    2782:	0f 93       	push	r16
    2784:	1f 93       	push	r17
    2786:	cf 93       	push	r28
    2788:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    278a:	00 97       	sbiw	r24, 0x00	; 0
    278c:	49 f1       	breq	.+82     	; 0x27e0 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    278e:	fc 01       	movw	r30, r24
    2790:	32 8d       	ldd	r19, Z+26	; 0x1a
    2792:	27 a1       	ldd	r18, Z+39	; 0x27
    2794:	32 17       	cp	r19, r18
    2796:	21 f1       	breq	.+72     	; 0x27e0 <vTaskPriorityDisinherit+0x5e>
    2798:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    279a:	8c 01       	movw	r16, r24
    279c:	0e 5f       	subi	r16, 0xFE	; 254
    279e:	1f 4f       	sbci	r17, 0xFF	; 255
    27a0:	c8 01       	movw	r24, r16
    27a2:	0e 94 1d 0a 	call	0x143a	; 0x143a <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    27a6:	8f a1       	ldd	r24, Y+39	; 0x27
    27a8:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    27aa:	44 e0       	ldi	r20, 0x04	; 4
    27ac:	50 e0       	ldi	r21, 0x00	; 0
    27ae:	60 e0       	ldi	r22, 0x00	; 0
    27b0:	70 e0       	ldi	r23, 0x00	; 0
    27b2:	48 1b       	sub	r20, r24
    27b4:	51 09       	sbc	r21, r1
    27b6:	61 09       	sbc	r22, r1
    27b8:	71 09       	sbc	r23, r1
    27ba:	4e 87       	std	Y+14, r20	; 0x0e
    27bc:	5f 87       	std	Y+15, r21	; 0x0f
    27be:	68 8b       	std	Y+16, r22	; 0x10
    27c0:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    27c2:	90 91 00 31 	lds	r25, 0x3100	; 0x803100 <uxTopReadyPriority>
    27c6:	98 17       	cp	r25, r24
    27c8:	10 f4       	brcc	.+4      	; 0x27ce <vTaskPriorityDisinherit+0x4c>
    27ca:	80 93 00 31 	sts	0x3100, r24	; 0x803100 <uxTopReadyPriority>
    27ce:	fb e0       	ldi	r31, 0x0B	; 11
    27d0:	8f 9f       	mul	r24, r31
    27d2:	c0 01       	movw	r24, r0
    27d4:	11 24       	eor	r1, r1
    27d6:	b8 01       	movw	r22, r16
    27d8:	82 5d       	subi	r24, 0xD2	; 210
    27da:	9e 4c       	sbci	r25, 0xCE	; 206
    27dc:	0e 94 ab 09 	call	0x1356	; 0x1356 <vListInsertEnd>
			}
		}
	}
    27e0:	df 91       	pop	r29
    27e2:	cf 91       	pop	r28
    27e4:	1f 91       	pop	r17
    27e6:	0f 91       	pop	r16
    27e8:	08 95       	ret

000027ea <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    27ea:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    27ec:	e8 81       	ld	r30, Y
    27ee:	f9 81       	ldd	r31, Y+1	; 0x01
    27f0:	01 90       	ld	r0, Z+
    27f2:	f0 81       	ld	r31, Z
    27f4:	e0 2d       	mov	r30, r0
    27f6:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    27f8:	1a 82       	std	Y+2, r1	; 0x02
    27fa:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    27fc:	6f ef       	ldi	r22, 0xFF	; 255
    27fe:	7f ef       	ldi	r23, 0xFF	; 255
    2800:	cb 01       	movw	r24, r22
    2802:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <vTaskDelay>
    2806:	fa cf       	rjmp	.-12     	; 0x27fc <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002808 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2808:	fc 01       	movw	r30, r24
    280a:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    280c:	65 87       	std	Z+13, r22	; 0x0d
    280e:	08 95       	ret

00002810 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2810:	4f 92       	push	r4
    2812:	5f 92       	push	r5
    2814:	6f 92       	push	r6
    2816:	7f 92       	push	r7
    2818:	8f 92       	push	r8
    281a:	9f 92       	push	r9
    281c:	af 92       	push	r10
    281e:	bf 92       	push	r11
    2820:	cf 92       	push	r12
    2822:	df 92       	push	r13
    2824:	ef 92       	push	r14
    2826:	ff 92       	push	r15
    2828:	0f 93       	push	r16
    282a:	1f 93       	push	r17
    282c:	cf 93       	push	r28
    282e:	df 93       	push	r29
    2830:	cd b7       	in	r28, 0x3d	; 61
    2832:	de b7       	in	r29, 0x3e	; 62
    2834:	2a 97       	sbiw	r28, 0x0a	; 10
    2836:	cd bf       	out	0x3d, r28	; 61
    2838:	de bf       	out	0x3e, r29	; 62
    283a:	4c 01       	movw	r8, r24
    283c:	29 01       	movw	r4, r18
    283e:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2840:	89 e4       	ldi	r24, 0x49	; 73
    2842:	90 e2       	ldi	r25, 0x20	; 32
    2844:	f4 01       	movw	r30, r8
    2846:	80 83       	st	Z, r24
    2848:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    284a:	fb 01       	movw	r30, r22
    284c:	80 81       	ld	r24, Z
    284e:	88 23       	and	r24, r24
    2850:	69 f0       	breq	.+26     	; 0x286c <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2852:	de 01       	movw	r26, r28
    2854:	11 96       	adiw	r26, 0x01	; 1
    2856:	31 96       	adiw	r30, 0x01	; 1
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	02 c0       	rjmp	.+4      	; 0x2860 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    285c:	99 30       	cpi	r25, 0x09	; 9
    285e:	39 f0       	breq	.+14     	; 0x286e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    2860:	9f 5f       	subi	r25, 0xFF	; 255
    2862:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2864:	81 91       	ld	r24, Z+
    2866:	81 11       	cpse	r24, r1
    2868:	f9 cf       	rjmp	.-14     	; 0x285c <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    286a:	01 c0       	rjmp	.+2      	; 0x286e <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    286c:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    286e:	e1 e0       	ldi	r30, 0x01	; 1
    2870:	f0 e0       	ldi	r31, 0x00	; 0
    2872:	ec 0f       	add	r30, r28
    2874:	fd 1f       	adc	r31, r29
    2876:	e9 0f       	add	r30, r25
    2878:	f1 1d       	adc	r31, r1
    287a:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    287c:	74 01       	movw	r14, r8
    287e:	f2 e0       	ldi	r31, 0x02	; 2
    2880:	ef 0e       	add	r14, r31
    2882:	f1 1c       	adc	r15, r1
    2884:	a1 2c       	mov	r10, r1
    2886:	b1 2c       	mov	r11, r1
    2888:	c1 2c       	mov	r12, r1
    288a:	d1 2c       	mov	r13, r1
    288c:	04 2f       	mov	r16, r20
    288e:	94 01       	movw	r18, r8
    2890:	a2 01       	movw	r20, r4
    2892:	be 01       	movw	r22, r28
    2894:	6f 5f       	subi	r22, 0xFF	; 255
    2896:	7f 4f       	sbci	r23, 0xFF	; 255
    2898:	80 ef       	ldi	r24, 0xF0	; 240
    289a:	92 e0       	ldi	r25, 0x02	; 2
    289c:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    28a0:	f4 01       	movw	r30, r8
    28a2:	66 82       	std	Z+6, r6	; 0x06
    28a4:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    28a6:	40 86       	std	Z+8, r4	; 0x08
    28a8:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    28aa:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <last_created_task_pointer>
    28ae:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <last_created_task_pointer+0x1>
    28b2:	24 83       	std	Z+4, r18	; 0x04
    28b4:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    28b6:	80 92 5c 31 	sts	0x315C, r8	; 0x80315c <last_created_task_pointer>
    28ba:	90 92 5d 31 	sts	0x315D, r9	; 0x80315d <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    28be:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    28c0:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    28c2:	40 90 be 31 	lds	r4, 0x31BE	; 0x8031be <portStackTopForTask>
    28c6:	50 90 bf 31 	lds	r5, 0x31BF	; 0x8031bf <portStackTopForTask+0x1>
    28ca:	ff ef       	ldi	r31, 0xFF	; 255
    28cc:	4f 1a       	sub	r4, r31
    28ce:	5f 0a       	sbc	r5, r31
    28d0:	40 92 be 31 	sts	0x31BE, r4	; 0x8031be <portStackTopForTask>
    28d4:	50 92 bf 31 	sts	0x31BF, r5	; 0x8031bf <portStackTopForTask+0x1>
    28d8:	f4 01       	movw	r30, r8
    28da:	42 86       	std	Z+10, r4	; 0x0a
    28dc:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    28de:	16 86       	std	Z+14, r1	; 0x0e
    28e0:	17 86       	std	Z+15, r1	; 0x0f
    28e2:	10 8a       	std	Z+16, r1	; 0x10
    28e4:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    28e6:	61 14       	cp	r6, r1
    28e8:	71 04       	cpc	r7, r1
    28ea:	09 f4       	brne	.+2      	; 0x28ee <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    28ec:	44 c0       	rjmp	.+136    	; 0x2976 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    28ee:	81 30       	cpi	r24, 0x01	; 1
    28f0:	79 f5       	brne	.+94     	; 0x2950 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    28f2:	6a e0       	ldi	r22, 0x0A	; 10
    28f4:	c3 01       	movw	r24, r6
    28f6:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    28fa:	7c 01       	movw	r14, r24
    28fc:	6d e2       	ldi	r22, 0x2D	; 45
    28fe:	75 e0       	ldi	r23, 0x05	; 5
    2900:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2904:	be 01       	movw	r22, r28
    2906:	6f 5f       	subi	r22, 0xFF	; 255
    2908:	7f 4f       	sbci	r23, 0xFF	; 255
    290a:	c7 01       	movw	r24, r14
    290c:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2910:	6a e0       	ldi	r22, 0x0A	; 10
    2912:	c7 01       	movw	r24, r14
    2914:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2918:	7c 01       	movw	r14, r24
    291a:	64 e2       	ldi	r22, 0x24	; 36
    291c:	75 e0       	ldi	r23, 0x05	; 5
    291e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2922:	6a e0       	ldi	r22, 0x0A	; 10
    2924:	c7 01       	movw	r24, r14
    2926:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    292a:	7c 01       	movw	r14, r24
    292c:	66 e1       	ldi	r22, 0x16	; 22
    292e:	75 e0       	ldi	r23, 0x05	; 5
    2930:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2934:	63 e0       	ldi	r22, 0x03	; 3
    2936:	c7 01       	movw	r24, r14
    2938:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    293c:	b2 01       	movw	r22, r4
    293e:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
    2942:	62 e0       	ldi	r22, 0x02	; 2
    2944:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2948:	66 e0       	ldi	r22, 0x06	; 6
    294a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    294e:	13 c0       	rjmp	.+38     	; 0x2976 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2950:	6a e0       	ldi	r22, 0x0A	; 10
    2952:	c3 01       	movw	r24, r6
    2954:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2958:	4c 01       	movw	r8, r24
    295a:	61 e0       	ldi	r22, 0x01	; 1
    295c:	75 e0       	ldi	r23, 0x05	; 5
    295e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2962:	be 01       	movw	r22, r28
    2964:	6f 5f       	subi	r22, 0xFF	; 255
    2966:	7f 4f       	sbci	r23, 0xFF	; 255
    2968:	c4 01       	movw	r24, r8
    296a:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    296e:	66 e0       	ldi	r22, 0x06	; 6
    2970:	c4 01       	movw	r24, r8
    2972:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2976:	2a 96       	adiw	r28, 0x0a	; 10
    2978:	cd bf       	out	0x3d, r28	; 61
    297a:	de bf       	out	0x3e, r29	; 62
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	ef 90       	pop	r14
    2988:	df 90       	pop	r13
    298a:	cf 90       	pop	r12
    298c:	bf 90       	pop	r11
    298e:	af 90       	pop	r10
    2990:	9f 90       	pop	r9
    2992:	8f 90       	pop	r8
    2994:	7f 90       	pop	r7
    2996:	6f 90       	pop	r6
    2998:	5f 90       	pop	r5
    299a:	4f 90       	pop	r4
    299c:	08 95       	ret

0000299e <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    299e:	cf 92       	push	r12
    29a0:	df 92       	push	r13
    29a2:	ef 92       	push	r14
    29a4:	ff 92       	push	r15
    29a6:	0f 93       	push	r16
    29a8:	1f 93       	push	r17
    29aa:	cf 93       	push	r28
    29ac:	df 93       	push	r29
    29ae:	ec 01       	movw	r28, r24
    29b0:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    29b2:	8a 81       	ldd	r24, Y+2	; 0x02
    29b4:	9b 81       	ldd	r25, Y+3	; 0x03
    29b6:	0e 94 48 10 	call	0x2090	; 0x2090 <pcTaskGetTaskName>
    29ba:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    29bc:	6a e0       	ldi	r22, 0x0A	; 10
    29be:	c7 01       	movw	r24, r14
    29c0:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    29c4:	8c 01       	movw	r16, r24
    29c6:	60 e4       	ldi	r22, 0x40	; 64
    29c8:	75 e0       	ldi	r23, 0x05	; 5
    29ca:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    29ce:	6a e0       	ldi	r22, 0x0A	; 10
    29d0:	c8 01       	movw	r24, r16
    29d2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    29d6:	8c 01       	movw	r16, r24
    29d8:	69 e3       	ldi	r22, 0x39	; 57
    29da:	75 e0       	ldi	r23, 0x05	; 5
    29dc:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    29e0:	b6 01       	movw	r22, r12
    29e2:	c8 01       	movw	r24, r16
    29e4:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    29e8:	6a e0       	ldi	r22, 0x0A	; 10
    29ea:	c8 01       	movw	r24, r16
    29ec:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    29f0:	8c 01       	movw	r16, r24
    29f2:	63 e3       	ldi	r22, 0x33	; 51
    29f4:	75 e0       	ldi	r23, 0x05	; 5
    29f6:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    29fa:	66 e0       	ldi	r22, 0x06	; 6
    29fc:	c8 01       	movw	r24, r16
    29fe:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2a02:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a04:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a06:	e8 85       	ldd	r30, Y+8	; 0x08
    2a08:	f9 85       	ldd	r31, Y+9	; 0x09
    2a0a:	01 e1       	ldi	r16, 0x11	; 17
    2a0c:	21 e0       	ldi	r18, 0x01	; 1
    2a0e:	a7 01       	movw	r20, r14
    2a10:	bc 01       	movw	r22, r24
    2a12:	8e 1b       	sub	r24, r30
    2a14:	9f 0b       	sbc	r25, r31
    2a16:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    2a1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2a1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2a1e:	00 97       	sbiw	r24, 0x00	; 0
    2a20:	19 f0       	breq	.+6      	; 0x2a28 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2a22:	b7 01       	movw	r22, r14
    2a24:	0e 94 cf 14 	call	0x299e	; 0x299e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2a28:	df 91       	pop	r29
    2a2a:	cf 91       	pop	r28
    2a2c:	1f 91       	pop	r17
    2a2e:	0f 91       	pop	r16
    2a30:	ff 90       	pop	r15
    2a32:	ef 90       	pop	r14
    2a34:	df 90       	pop	r13
    2a36:	cf 90       	pop	r12
    2a38:	08 95       	ret

00002a3a <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    2a3a:	0f 93       	push	r16
    2a3c:	1f 93       	push	r17
    2a3e:	cf 93       	push	r28
    2a40:	df 93       	push	r29
    2a42:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2a44:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <last_created_task_pointer>
    2a48:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <last_created_task_pointer+0x1>
    2a4c:	00 97       	sbiw	r24, 0x00	; 0
    2a4e:	19 f0       	breq	.+6      	; 0x2a56 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2a50:	be 01       	movw	r22, r28
    2a52:	0e 94 cf 14 	call	0x299e	; 0x299e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2a56:	6a e0       	ldi	r22, 0x0A	; 10
    2a58:	ce 01       	movw	r24, r28
    2a5a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2a5e:	8c 01       	movw	r16, r24
    2a60:	66 e5       	ldi	r22, 0x56	; 86
    2a62:	75 e0       	ldi	r23, 0x05	; 5
    2a64:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2a68:	6a e0       	ldi	r22, 0x0A	; 10
    2a6a:	c8 01       	movw	r24, r16
    2a6c:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2a70:	8c 01       	movw	r16, r24
    2a72:	6b e4       	ldi	r22, 0x4B	; 75
    2a74:	75 e0       	ldi	r23, 0x05	; 5
    2a76:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2a7a:	6a e0       	ldi	r22, 0x0A	; 10
    2a7c:	c8 01       	movw	r24, r16
    2a7e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2a82:	8c 01       	movw	r16, r24
    2a84:	65 e4       	ldi	r22, 0x45	; 69
    2a86:	75 e0       	ldi	r23, 0x05	; 5
    2a88:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2a8c:	66 e0       	ldi	r22, 0x06	; 6
    2a8e:	c8 01       	movw	r24, r16
    2a90:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2a94:	80 91 be 31 	lds	r24, 0x31BE	; 0x8031be <portStackTopForTask>
    2a98:	90 91 bf 31 	lds	r25, 0x31BF	; 0x8031bf <portStackTopForTask+0x1>
    2a9c:	bc 01       	movw	r22, r24
    2a9e:	6f 5f       	subi	r22, 0xFF	; 255
    2aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa2:	01 e1       	ldi	r16, 0x11	; 17
    2aa4:	21 e0       	ldi	r18, 0x01	; 1
    2aa6:	ae 01       	movw	r20, r28
    2aa8:	83 56       	subi	r24, 0x63	; 99
    2aaa:	91 09       	sbc	r25, r1
    2aac:	0e 94 d1 17 	call	0x2fa2	; 0x2fa2 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2ab0:	df 91       	pop	r29
    2ab2:	cf 91       	pop	r28
    2ab4:	1f 91       	pop	r17
    2ab6:	0f 91       	pop	r16
    2ab8:	08 95       	ret

00002aba <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2aba:	8f 92       	push	r8
    2abc:	9f 92       	push	r9
    2abe:	af 92       	push	r10
    2ac0:	bf 92       	push	r11
    2ac2:	cf 92       	push	r12
    2ac4:	df 92       	push	r13
    2ac6:	ef 92       	push	r14
    2ac8:	ff 92       	push	r15
    2aca:	0f 93       	push	r16
    2acc:	1f 93       	push	r17
    2ace:	cf 93       	push	r28
    2ad0:	df 93       	push	r29
    2ad2:	ec 01       	movw	r28, r24
    2ad4:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad8:	9b 81       	ldd	r25, Y+3	; 0x03
    2ada:	0e 94 48 10 	call	0x2090	; 0x2090 <pcTaskGetTaskName>
    2ade:	bc 01       	movw	r22, r24
    2ae0:	c8 01       	movw	r24, r16
    2ae2:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2ae6:	d8 01       	movw	r26, r16
    2ae8:	ed 91       	ld	r30, X+
    2aea:	fc 91       	ld	r31, X
    2aec:	02 80       	ldd	r0, Z+2	; 0x02
    2aee:	f3 81       	ldd	r31, Z+3	; 0x03
    2af0:	e0 2d       	mov	r30, r0
    2af2:	69 e0       	ldi	r22, 0x09	; 9
    2af4:	c8 01       	movw	r24, r16
    2af6:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2af8:	8a 81       	ldd	r24, Y+2	; 0x02
    2afa:	9b 81       	ldd	r25, Y+3	; 0x03
    2afc:	0e 94 48 10 	call	0x2090	; 0x2090 <pcTaskGetTaskName>
    2b00:	fc 01       	movw	r30, r24
    2b02:	01 90       	ld	r0, Z+
    2b04:	00 20       	and	r0, r0
    2b06:	e9 f7       	brne	.-6      	; 0x2b02 <_ZN8frt_task12print_statusER8emstream+0x48>
    2b08:	31 97       	sbiw	r30, 0x01	; 1
    2b0a:	e8 1b       	sub	r30, r24
    2b0c:	f9 0b       	sbc	r31, r25
    2b0e:	38 97       	sbiw	r30, 0x08	; 8
    2b10:	48 f4       	brcc	.+18     	; 0x2b24 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2b12:	d8 01       	movw	r26, r16
    2b14:	ed 91       	ld	r30, X+
    2b16:	fc 91       	ld	r31, X
    2b18:	02 80       	ldd	r0, Z+2	; 0x02
    2b1a:	f3 81       	ldd	r31, Z+3	; 0x03
    2b1c:	e0 2d       	mov	r30, r0
    2b1e:	69 e0       	ldi	r22, 0x09	; 9
    2b20:	c8 01       	movw	r24, r16
    2b22:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2b24:	ce 84       	ldd	r12, Y+14	; 0x0e
    2b26:	df 84       	ldd	r13, Y+15	; 0x0f
    2b28:	e8 88       	ldd	r14, Y+16	; 0x10
    2b2a:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2b2c:	a8 84       	ldd	r10, Y+8	; 0x08
    2b2e:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2b30:	8a 81       	ldd	r24, Y+2	; 0x02
    2b32:	9b 81       	ldd	r25, Y+3	; 0x03
    2b34:	0e 94 4e 13 	call	0x269c	; 0x269c <uxTaskGetStackHighWaterMark>
    2b38:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    2b3a:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2b3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b40:	0e 94 f3 0f 	call	0x1fe6	; 0x1fe6 <uxTaskPriorityGet>
    2b44:	68 2f       	mov	r22, r24
    2b46:	c8 01       	movw	r24, r16
    2b48:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    2b4c:	6a e0       	ldi	r22, 0x0A	; 10
    2b4e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2b52:	ec 01       	movw	r28, r24
    2b54:	6b ec       	ldi	r22, 0xCB	; 203
    2b56:	75 e0       	ldi	r23, 0x05	; 5
    2b58:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
			<< get_state ()
    2b5c:	68 2d       	mov	r22, r8
    2b5e:	ce 01       	movw	r24, r28
    2b60:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2b64:	6a e0       	ldi	r22, 0x0A	; 10
    2b66:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2b6a:	ec 01       	movw	r28, r24
    2b6c:	69 ec       	ldi	r22, 0xC9	; 201
    2b6e:	75 e0       	ldi	r23, 0x05	; 5
    2b70:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2b74:	69 2d       	mov	r22, r9
    2b76:	ce 01       	movw	r24, r28
    2b78:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    2b7c:	6a e0       	ldi	r22, 0x0A	; 10
    2b7e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2b82:	ec 01       	movw	r28, r24
    2b84:	67 ec       	ldi	r22, 0xC7	; 199
    2b86:	75 e0       	ldi	r23, 0x05	; 5
    2b88:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2b8c:	b5 01       	movw	r22, r10
    2b8e:	ce 01       	movw	r24, r28
    2b90:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
    2b94:	6a e0       	ldi	r22, 0x0A	; 10
    2b96:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2b9a:	ec 01       	movw	r28, r24
    2b9c:	65 ec       	ldi	r22, 0xC5	; 197
    2b9e:	75 e0       	ldi	r23, 0x05	; 5
    2ba0:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2ba4:	6a e0       	ldi	r22, 0x0A	; 10
    2ba6:	ce 01       	movw	r24, r28
    2ba8:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2bac:	ec 01       	movw	r28, r24
    2bae:	63 ec       	ldi	r22, 0xC3	; 195
    2bb0:	75 e0       	ldi	r23, 0x05	; 5
    2bb2:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2bb6:	b7 01       	movw	r22, r14
    2bb8:	a6 01       	movw	r20, r12
    2bba:	ce 01       	movw	r24, r28
    2bbc:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstreamlsEm>
}
    2bc0:	df 91       	pop	r29
    2bc2:	cf 91       	pop	r28
    2bc4:	1f 91       	pop	r17
    2bc6:	0f 91       	pop	r16
    2bc8:	ff 90       	pop	r15
    2bca:	ef 90       	pop	r14
    2bcc:	df 90       	pop	r13
    2bce:	cf 90       	pop	r12
    2bd0:	bf 90       	pop	r11
    2bd2:	af 90       	pop	r10
    2bd4:	9f 90       	pop	r9
    2bd6:	8f 90       	pop	r8
    2bd8:	08 95       	ret

00002bda <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2bda:	cf 93       	push	r28
    2bdc:	df 93       	push	r29
    2bde:	ec 01       	movw	r28, r24
    2be0:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2be2:	db 01       	movw	r26, r22
    2be4:	ed 91       	ld	r30, X+
    2be6:	fc 91       	ld	r31, X
    2be8:	02 80       	ldd	r0, Z+2	; 0x02
    2bea:	f3 81       	ldd	r31, Z+3	; 0x03
    2bec:	e0 2d       	mov	r30, r0
    2bee:	be 01       	movw	r22, r28
    2bf0:	19 95       	eicall
	return (ser_dev);
}
    2bf2:	ce 01       	movw	r24, r28
    2bf4:	df 91       	pop	r29
    2bf6:	cf 91       	pop	r28
    2bf8:	08 95       	ret

00002bfa <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2bfa:	0f 93       	push	r16
    2bfc:	1f 93       	push	r17
    2bfe:	cf 93       	push	r28
    2c00:	df 93       	push	r29
    2c02:	ec 01       	movw	r28, r24
    2c04:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2c06:	bc 01       	movw	r22, r24
    2c08:	c8 01       	movw	r24, r16
    2c0a:	0e 94 ed 15 	call	0x2bda	; 0x2bda <_ZlsR8emstreamR8frt_task>
    2c0e:	66 e0       	ldi	r22, 0x06	; 6
    2c10:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2c14:	8c 81       	ldd	r24, Y+4	; 0x04
    2c16:	9d 81       	ldd	r25, Y+5	; 0x05
    2c18:	00 97       	sbiw	r24, 0x00	; 0
    2c1a:	19 f0       	breq	.+6      	; 0x2c22 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2c1c:	b8 01       	movw	r22, r16
    2c1e:	0e 94 fd 15 	call	0x2bfa	; 0x2bfa <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2c22:	df 91       	pop	r29
    2c24:	cf 91       	pop	r28
    2c26:	1f 91       	pop	r17
    2c28:	0f 91       	pop	r16
    2c2a:	08 95       	ret

00002c2c <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2c2c:	0f 93       	push	r16
    2c2e:	1f 93       	push	r17
    2c30:	cf 93       	push	r28
    2c32:	df 93       	push	r29
    2c34:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2c36:	6a e0       	ldi	r22, 0x0A	; 10
    2c38:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2c3c:	8c 01       	movw	r16, r24
    2c3e:	68 eb       	ldi	r22, 0xB8	; 184
    2c40:	75 e0       	ldi	r23, 0x05	; 5
    2c42:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2c46:	6a e0       	ldi	r22, 0x0A	; 10
    2c48:	c8 01       	movw	r24, r16
    2c4a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2c4e:	8c 01       	movw	r16, r24
    2c50:	61 eb       	ldi	r22, 0xB1	; 177
    2c52:	75 e0       	ldi	r23, 0x05	; 5
    2c54:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2c58:	66 e0       	ldi	r22, 0x06	; 6
    2c5a:	c8 01       	movw	r24, r16
    2c5c:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2c60:	6a e0       	ldi	r22, 0x0A	; 10
    2c62:	ce 01       	movw	r24, r28
    2c64:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2c68:	8c 01       	movw	r16, r24
    2c6a:	60 ea       	ldi	r22, 0xA0	; 160
    2c6c:	75 e0       	ldi	r23, 0x05	; 5
    2c6e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2c72:	6a e0       	ldi	r22, 0x0A	; 10
    2c74:	c8 01       	movw	r24, r16
    2c76:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2c7a:	8c 01       	movw	r16, r24
    2c7c:	64 e9       	ldi	r22, 0x94	; 148
    2c7e:	75 e0       	ldi	r23, 0x05	; 5
    2c80:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2c84:	6a e0       	ldi	r22, 0x0A	; 10
    2c86:	c8 01       	movw	r24, r16
    2c88:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2c8c:	8c 01       	movw	r16, r24
    2c8e:	6e e8       	ldi	r22, 0x8E	; 142
    2c90:	75 e0       	ldi	r23, 0x05	; 5
    2c92:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2c96:	66 e0       	ldi	r22, 0x06	; 6
    2c98:	c8 01       	movw	r24, r16
    2c9a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2c9e:	6a e0       	ldi	r22, 0x0A	; 10
    2ca0:	ce 01       	movw	r24, r28
    2ca2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2ca6:	8c 01       	movw	r16, r24
    2ca8:	6d e7       	ldi	r22, 0x7D	; 125
    2caa:	75 e0       	ldi	r23, 0x05	; 5
    2cac:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2cb0:	6a e0       	ldi	r22, 0x0A	; 10
    2cb2:	c8 01       	movw	r24, r16
    2cb4:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2cb8:	8c 01       	movw	r16, r24
    2cba:	61 e7       	ldi	r22, 0x71	; 113
    2cbc:	75 e0       	ldi	r23, 0x05	; 5
    2cbe:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2cc2:	6a e0       	ldi	r22, 0x0A	; 10
    2cc4:	c8 01       	movw	r24, r16
    2cc6:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2cca:	8c 01       	movw	r16, r24
    2ccc:	6b e6       	ldi	r22, 0x6B	; 107
    2cce:	75 e0       	ldi	r23, 0x05	; 5
    2cd0:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2cd4:	66 e0       	ldi	r22, 0x06	; 6
    2cd6:	c8 01       	movw	r24, r16
    2cd8:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2cdc:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <last_created_task_pointer>
    2ce0:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <last_created_task_pointer+0x1>
    2ce4:	00 97       	sbiw	r24, 0x00	; 0
    2ce6:	19 f0       	breq	.+6      	; 0x2cee <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2ce8:	be 01       	movw	r22, r28
    2cea:	0e 94 fd 15 	call	0x2bfa	; 0x2bfa <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2cee:	0e 94 50 10 	call	0x20a0	; 0x20a0 <xTaskGetIdleTaskHandle>
    2cf2:	0e 94 4e 13 	call	0x269c	; 0x269c <uxTaskGetStackHighWaterMark>
    2cf6:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2cf8:	6a e0       	ldi	r22, 0x0A	; 10
    2cfa:	ce 01       	movw	r24, r28
    2cfc:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2d00:	ec 01       	movw	r28, r24
    2d02:	60 e6       	ldi	r22, 0x60	; 96
    2d04:	75 e0       	ldi	r23, 0x05	; 5
    2d06:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2d0a:	61 2f       	mov	r22, r17
    2d0c:	ce 01       	movw	r24, r28
    2d0e:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2d12:	6a e0       	ldi	r22, 0x0A	; 10
    2d14:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2d18:	ec 01       	movw	r28, r24
    2d1a:	6e e5       	ldi	r22, 0x5E	; 94
    2d1c:	75 e0       	ldi	r23, 0x05	; 5
    2d1e:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    2d22:	64 e6       	ldi	r22, 0x64	; 100
    2d24:	70 e0       	ldi	r23, 0x00	; 0
    2d26:	ce 01       	movw	r24, r28
    2d28:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
    2d2c:	6a e0       	ldi	r22, 0x0A	; 10
    2d2e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2d32:	ec 01       	movw	r28, r24
    2d34:	6b e5       	ldi	r22, 0x5B	; 91
    2d36:	75 e0       	ldi	r23, 0x05	; 5
    2d38:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2d3c:	66 e0       	ldi	r22, 0x06	; 6
    2d3e:	ce 01       	movw	r24, r28
    2d40:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
}
    2d44:	df 91       	pop	r29
    2d46:	cf 91       	pop	r28
    2d48:	1f 91       	pop	r17
    2d4a:	0f 91       	pop	r16
    2d4c:	08 95       	ret

00002d4e <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2d4e:	0f 93       	push	r16
    2d50:	cf 93       	push	r28
    2d52:	df 93       	push	r29
    2d54:	1f 92       	push	r1
    2d56:	cd b7       	in	r28, 0x3d	; 61
    2d58:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2d5a:	00 e0       	ldi	r16, 0x00	; 0
    2d5c:	2f ef       	ldi	r18, 0xFF	; 255
    2d5e:	3f ef       	ldi	r19, 0xFF	; 255
    2d60:	a9 01       	movw	r20, r18
    2d62:	be 01       	movw	r22, r28
    2d64:	6f 5f       	subi	r22, 0xFF	; 255
    2d66:	7f 4f       	sbci	r23, 0xFF	; 255
    2d68:	fc 01       	movw	r30, r24
    2d6a:	80 85       	ldd	r24, Z+8	; 0x08
    2d6c:	91 85       	ldd	r25, Z+9	; 0x09
    2d6e:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
    2d72:	81 30       	cpi	r24, 0x01	; 1
    2d74:	19 f4       	brne	.+6      	; 0x2d7c <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	02 c0       	rjmp	.+4      	; 0x2d80 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2d7c:	8f ef       	ldi	r24, 0xFF	; 255
    2d7e:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2d80:	0f 90       	pop	r0
    2d82:	df 91       	pop	r29
    2d84:	cf 91       	pop	r28
    2d86:	0f 91       	pop	r16
    2d88:	08 95       	ret

00002d8a <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2d8a:	fc 01       	movw	r30, r24
    2d8c:	80 85       	ldd	r24, Z+8	; 0x08
    2d8e:	91 85       	ldd	r25, Z+9	; 0x09
    2d90:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
    2d94:	91 e0       	ldi	r25, 0x01	; 1
    2d96:	81 11       	cpse	r24, r1
    2d98:	01 c0       	rjmp	.+2      	; 0x2d9c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2d9a:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2d9c:	89 2f       	mov	r24, r25
    2d9e:	08 95       	ret

00002da0 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2da0:	0f 93       	push	r16
    2da2:	cf 93       	push	r28
    2da4:	df 93       	push	r29
    2da6:	1f 92       	push	r1
    2da8:	cd b7       	in	r28, 0x3d	; 61
    2daa:	de b7       	in	r29, 0x3e	; 62
    2dac:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2dae:	fc 01       	movw	r30, r24
    2db0:	22 85       	ldd	r18, Z+10	; 0x0a
    2db2:	33 85       	ldd	r19, Z+11	; 0x0b
    2db4:	44 85       	ldd	r20, Z+12	; 0x0c
    2db6:	55 85       	ldd	r21, Z+13	; 0x0d
    2db8:	00 e0       	ldi	r16, 0x00	; 0
    2dba:	be 01       	movw	r22, r28
    2dbc:	6f 5f       	subi	r22, 0xFF	; 255
    2dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2dc0:	80 85       	ldd	r24, Z+8	; 0x08
    2dc2:	91 85       	ldd	r25, Z+9	; 0x09
    2dc4:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSend>
    2dc8:	91 e0       	ldi	r25, 0x01	; 1
    2dca:	81 11       	cpse	r24, r1
    2dcc:	01 c0       	rjmp	.+2      	; 0x2dd0 <_ZN14frt_text_queue7putcharEc+0x30>
    2dce:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2dd0:	89 2f       	mov	r24, r25
    2dd2:	0f 90       	pop	r0
    2dd4:	df 91       	pop	r29
    2dd6:	cf 91       	pop	r28
    2dd8:	0f 91       	pop	r16
    2dda:	08 95       	ret

00002ddc <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2ddc:	8f 92       	push	r8
    2dde:	9f 92       	push	r9
    2de0:	bf 92       	push	r11
    2de2:	cf 92       	push	r12
    2de4:	df 92       	push	r13
    2de6:	ef 92       	push	r14
    2de8:	ff 92       	push	r15
    2dea:	0f 93       	push	r16
    2dec:	1f 93       	push	r17
    2dee:	cf 93       	push	r28
    2df0:	df 93       	push	r29
    2df2:	ec 01       	movw	r28, r24
    2df4:	b6 2e       	mov	r11, r22
    2df6:	4a 01       	movw	r8, r20
    2df8:	68 01       	movw	r12, r16
    2dfa:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2dfc:	0e 94 28 19 	call	0x3250	; 0x3250 <_ZN8emstreamC1Ev>
    2e00:	81 e5       	ldi	r24, 0x51	; 81
    2e02:	90 e2       	ldi	r25, 0x20	; 32
    2e04:	88 83       	st	Y, r24
    2e06:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2e08:	8e 86       	std	Y+14, r8	; 0x0e
    2e0a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2e0c:	40 e0       	ldi	r20, 0x00	; 0
    2e0e:	61 e0       	ldi	r22, 0x01	; 1
    2e10:	8b 2d       	mov	r24, r11
    2e12:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    2e16:	88 87       	std	Y+8, r24	; 0x08
    2e18:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2e1a:	ca 86       	std	Y+10, r12	; 0x0a
    2e1c:	db 86       	std	Y+11, r13	; 0x0b
    2e1e:	ec 86       	std	Y+12, r14	; 0x0c
    2e20:	fd 86       	std	Y+13, r15	; 0x0d
}
    2e22:	df 91       	pop	r29
    2e24:	cf 91       	pop	r28
    2e26:	1f 91       	pop	r17
    2e28:	0f 91       	pop	r16
    2e2a:	ff 90       	pop	r15
    2e2c:	ef 90       	pop	r14
    2e2e:	df 90       	pop	r13
    2e30:	cf 90       	pop	r12
    2e32:	bf 90       	pop	r11
    2e34:	9f 90       	pop	r9
    2e36:	8f 90       	pop	r8
    2e38:	08 95       	ret

00002e3a <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2e3a:	cf 92       	push	r12
    2e3c:	df 92       	push	r13
    2e3e:	ef 92       	push	r14
    2e40:	ff 92       	push	r15
    2e42:	cf 93       	push	r28
    2e44:	df 93       	push	r29
    2e46:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2e48:	68 81       	ld	r22, Y
    2e4a:	79 81       	ldd	r23, Y+1	; 0x01
    2e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e50:	0f 2e       	mov	r0, r31
    2e52:	f8 ee       	ldi	r31, 0xE8	; 232
    2e54:	cf 2e       	mov	r12, r31
    2e56:	f3 e0       	ldi	r31, 0x03	; 3
    2e58:	df 2e       	mov	r13, r31
    2e5a:	e1 2c       	mov	r14, r1
    2e5c:	f1 2c       	mov	r15, r1
    2e5e:	f0 2d       	mov	r31, r0
    2e60:	a7 01       	movw	r20, r14
    2e62:	96 01       	movw	r18, r12
    2e64:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
    2e68:	9b 01       	movw	r18, r22
    2e6a:	ac 01       	movw	r20, r24
    2e6c:	60 e4       	ldi	r22, 0x40	; 64
    2e6e:	72 e4       	ldi	r23, 0x42	; 66
    2e70:	8f e0       	ldi	r24, 0x0F	; 15
    2e72:	90 e0       	ldi	r25, 0x00	; 0
    2e74:	0e 94 80 20 	call	0x4100	; 0x4100 <__mulsi3>
    2e78:	a7 01       	movw	r20, r14
    2e7a:	96 01       	movw	r18, r12
    2e7c:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
    2e80:	69 01       	movw	r12, r18
    2e82:	7a 01       	movw	r14, r20
    2e84:	ac 81       	ldd	r26, Y+4	; 0x04
    2e86:	bd 81       	ldd	r27, Y+5	; 0x05
    2e88:	20 e4       	ldi	r18, 0x40	; 64
    2e8a:	32 e4       	ldi	r19, 0x42	; 66
    2e8c:	4f e0       	ldi	r20, 0x0F	; 15
    2e8e:	50 e0       	ldi	r21, 0x00	; 0
    2e90:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__muluhisi3>
    2e94:	20 e0       	ldi	r18, 0x00	; 0
    2e96:	38 e4       	ldi	r19, 0x48	; 72
    2e98:	48 ee       	ldi	r20, 0xE8	; 232
    2e9a:	51 e0       	ldi	r21, 0x01	; 1
    2e9c:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
    2ea0:	c7 01       	movw	r24, r14
    2ea2:	b6 01       	movw	r22, r12
    2ea4:	62 0f       	add	r22, r18
    2ea6:	73 1f       	adc	r23, r19
    2ea8:	84 1f       	adc	r24, r20
    2eaa:	95 1f       	adc	r25, r21
}
    2eac:	df 91       	pop	r29
    2eae:	cf 91       	pop	r28
    2eb0:	ff 90       	pop	r15
    2eb2:	ef 90       	pop	r14
    2eb4:	df 90       	pop	r13
    2eb6:	cf 90       	pop	r12
    2eb8:	08 95       	ret

00002eba <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2eba:	cf 92       	push	r12
    2ebc:	df 92       	push	r13
    2ebe:	ef 92       	push	r14
    2ec0:	ff 92       	push	r15
    2ec2:	0f 93       	push	r16
    2ec4:	1f 93       	push	r17
    2ec6:	cf 93       	push	r28
    2ec8:	df 93       	push	r29
    2eca:	cd b7       	in	r28, 0x3d	; 61
    2ecc:	de b7       	in	r29, 0x3e	; 62
    2ece:	2f 97       	sbiw	r28, 0x0f	; 15
    2ed0:	cd bf       	out	0x3d, r28	; 61
    2ed2:	de bf       	out	0x3e, r29	; 62
    2ed4:	6c 01       	movw	r12, r24
    2ed6:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2ed8:	db 01       	movw	r26, r22
    2eda:	6d 91       	ld	r22, X+
    2edc:	7d 91       	ld	r23, X+
    2ede:	8d 91       	ld	r24, X+
    2ee0:	9c 91       	ld	r25, X
    2ee2:	28 ee       	ldi	r18, 0xE8	; 232
    2ee4:	33 e0       	ldi	r19, 0x03	; 3
    2ee6:	40 e0       	ldi	r20, 0x00	; 0
    2ee8:	50 e0       	ldi	r21, 0x00	; 0
    2eea:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
    2eee:	ba 01       	movw	r22, r20
    2ef0:	a9 01       	movw	r20, r18
    2ef2:	c6 01       	movw	r24, r12
    2ef4:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2ef8:	d6 01       	movw	r26, r12
    2efa:	ed 91       	ld	r30, X+
    2efc:	fc 91       	ld	r31, X
    2efe:	02 80       	ldd	r0, Z+2	; 0x02
    2f00:	f3 81       	ldd	r31, Z+3	; 0x03
    2f02:	e0 2d       	mov	r30, r0
    2f04:	6e e2       	ldi	r22, 0x2E	; 46
    2f06:	c6 01       	movw	r24, r12
    2f08:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2f0a:	c8 01       	movw	r24, r16
    2f0c:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <_ZN10time_stamp12get_microsecEv>
    2f10:	8e 01       	movw	r16, r28
    2f12:	09 5f       	subi	r16, 0xF9	; 249
    2f14:	1f 4f       	sbci	r17, 0xFF	; 255
    2f16:	fe 01       	movw	r30, r28
    2f18:	31 96       	adiw	r30, 0x01	; 1
    2f1a:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2f1c:	2a e0       	ldi	r18, 0x0A	; 10
    2f1e:	30 e0       	ldi	r19, 0x00	; 0
    2f20:	40 e0       	ldi	r20, 0x00	; 0
    2f22:	50 e0       	ldi	r21, 0x00	; 0
    2f24:	0e 94 b2 20 	call	0x4164	; 0x4164 <__divmodsi4>
    2f28:	e6 2f       	mov	r30, r22
    2f2a:	28 87       	std	Y+8, r18	; 0x08
    2f2c:	39 87       	std	Y+9, r19	; 0x09
    2f2e:	4a 87       	std	Y+10, r20	; 0x0a
    2f30:	5b 87       	std	Y+11, r21	; 0x0b
    2f32:	68 85       	ldd	r22, Y+8	; 0x08
    2f34:	79 85       	ldd	r23, Y+9	; 0x09
    2f36:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f38:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2f3a:	20 e3       	ldi	r18, 0x30	; 48
    2f3c:	2e 0f       	add	r18, r30
    2f3e:	d8 01       	movw	r26, r16
    2f40:	2e 93       	st	-X, r18
    2f42:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2f44:	ae 15       	cp	r26, r14
    2f46:	bf 05       	cpc	r27, r15
    2f48:	49 f7       	brne	.-46     	; 0x2f1c <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2f4a:	1f 82       	std	Y+7, r1	; 0x07
    2f4c:	be 01       	movw	r22, r28
    2f4e:	6f 5f       	subi	r22, 0xFF	; 255
    2f50:	7f 4f       	sbci	r23, 0xFF	; 255
    2f52:	c6 01       	movw	r24, r12
    2f54:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2f58:	c6 01       	movw	r24, r12
    2f5a:	2f 96       	adiw	r28, 0x0f	; 15
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	de bf       	out	0x3e, r29	; 62
    2f60:	df 91       	pop	r29
    2f62:	cf 91       	pop	r28
    2f64:	1f 91       	pop	r17
    2f66:	0f 91       	pop	r16
    2f68:	ff 90       	pop	r15
    2f6a:	ef 90       	pop	r14
    2f6c:	df 90       	pop	r13
    2f6e:	cf 90       	pop	r12
    2f70:	08 95       	ret

00002f72 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
    2f76:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2f78:	0f b6       	in	r0, 0x3f	; 63
    2f7a:	f8 94       	cli
    2f7c:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2f7e:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2f82:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2f86:	8c 83       	std	Y+4, r24	; 0x04
    2f88:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2f8a:	0e 94 3a 10 	call	0x2074	; 0x2074 <xTaskGetTickCount>
    2f8e:	68 83       	st	Y, r22
    2f90:	79 83       	std	Y+1, r23	; 0x01
    2f92:	8a 83       	std	Y+2, r24	; 0x02
    2f94:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2f96:	0f 90       	pop	r0
    2f98:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2f9a:	ce 01       	movw	r24, r28
    2f9c:	df 91       	pop	r29
    2f9e:	cf 91       	pop	r28
    2fa0:	08 95       	ret

00002fa2 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2fa2:	5f 92       	push	r5
    2fa4:	6f 92       	push	r6
    2fa6:	7f 92       	push	r7
    2fa8:	8f 92       	push	r8
    2faa:	9f 92       	push	r9
    2fac:	af 92       	push	r10
    2fae:	bf 92       	push	r11
    2fb0:	cf 92       	push	r12
    2fb2:	df 92       	push	r13
    2fb4:	ef 92       	push	r14
    2fb6:	ff 92       	push	r15
    2fb8:	0f 93       	push	r16
    2fba:	1f 93       	push	r17
    2fbc:	cf 93       	push	r28
    2fbe:	df 93       	push	r29
    2fc0:	5c 01       	movw	r10, r24
    2fc2:	4b 01       	movw	r8, r22
    2fc4:	7a 01       	movw	r14, r20
    2fc6:	12 2f       	mov	r17, r18
    2fc8:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2fca:	63 e0       	ldi	r22, 0x03	; 3
    2fcc:	ca 01       	movw	r24, r20
    2fce:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2fd2:	a8 14       	cp	r10, r8
    2fd4:	b9 04       	cpc	r11, r9
    2fd6:	08 f0       	brcs	.+2      	; 0x2fda <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2fd8:	7d c0       	rjmp	.+250    	; 0x30d4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2fda:	65 01       	movw	r12, r10
    2fdc:	84 e1       	ldi	r24, 0x14	; 20
    2fde:	c8 0e       	add	r12, r24
    2fe0:	d1 1c       	adc	r13, r1
    2fe2:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2fe4:	6a 2c       	mov	r6, r10
    2fe6:	5b 2c       	mov	r5, r11
    2fe8:	b5 01       	movw	r22, r10
    2fea:	c7 01       	movw	r24, r14
    2fec:	0e 94 b4 19 	call	0x3368	; 0x3368 <_ZN8emstreamlsEj>
    2ff0:	6a e0       	ldi	r22, 0x0A	; 10
    2ff2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    2ff6:	6d ed       	ldi	r22, 0xDD	; 221
    2ff8:	75 e0       	ldi	r23, 0x05	; 5
    2ffa:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2ffe:	11 23       	and	r17, r17
    3000:	09 f4       	brne	.+2      	; 0x3004 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    3002:	6d c0       	rjmp	.+218    	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    3004:	00 23       	and	r16, r16
    3006:	09 f4       	brne	.+2      	; 0x300a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    3008:	6a c0       	rjmp	.+212    	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    300a:	6a e0       	ldi	r22, 0x0A	; 10
    300c:	c7 01       	movw	r24, r14
    300e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    3012:	68 ed       	ldi	r22, 0xD8	; 216
    3014:	75 e0       	ldi	r23, 0x05	; 5
    3016:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    301a:	61 c0       	rjmp	.+194    	; 0x30de <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    301c:	11 23       	and	r17, r17
    301e:	71 f0       	breq	.+28     	; 0x303c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3020:	01 11       	cpse	r16, r1
    3022:	0c c0       	rjmp	.+24     	; 0x303c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    3024:	88 81       	ld	r24, Y
    3026:	87 15       	cp	r24, r7
    3028:	49 f0       	breq	.+18     	; 0x303c <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    302a:	6a e0       	ldi	r22, 0x0A	; 10
    302c:	c7 01       	movw	r24, r14
    302e:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    3032:	63 ed       	ldi	r22, 0xD3	; 211
    3034:	75 e0       	ldi	r23, 0x05	; 5
    3036:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    303a:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    303c:	69 91       	ld	r22, Y+
    303e:	c7 01       	movw	r24, r14
    3040:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3044:	dc 01       	movw	r26, r24
    3046:	ed 91       	ld	r30, X+
    3048:	fc 91       	ld	r31, X
    304a:	02 80       	ldd	r0, Z+2	; 0x02
    304c:	f3 81       	ldd	r31, Z+3	; 0x03
    304e:	e0 2d       	mov	r30, r0
    3050:	60 e2       	ldi	r22, 0x20	; 32
    3052:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    3054:	cc 16       	cp	r12, r28
    3056:	dd 06       	cpc	r13, r29
    3058:	09 f7       	brne	.-62     	; 0x301c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    305a:	11 23       	and	r17, r17
    305c:	89 f0       	breq	.+34     	; 0x3080 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    305e:	6a e0       	ldi	r22, 0x0A	; 10
    3060:	c7 01       	movw	r24, r14
    3062:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    3066:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3068:	6d ec       	ldi	r22, 0xCD	; 205
    306a:	75 e0       	ldi	r23, 0x05	; 5
    306c:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    3070:	e8 81       	ld	r30, Y
    3072:	f9 81       	ldd	r31, Y+1	; 0x01
    3074:	02 80       	ldd	r0, Z+2	; 0x02
    3076:	f3 81       	ldd	r31, Z+3	; 0x03
    3078:	e0 2d       	mov	r30, r0
    307a:	60 e2       	ldi	r22, 0x20	; 32
    307c:	ce 01       	movw	r24, r28
    307e:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    3080:	c6 2d       	mov	r28, r6
    3082:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    3084:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    3086:	80 ee       	ldi	r24, 0xE0	; 224
    3088:	86 0f       	add	r24, r22
    308a:	8f 35       	cpi	r24, 0x5F	; 95
    308c:	48 f4       	brcc	.+18     	; 0x30a0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    308e:	d7 01       	movw	r26, r14
    3090:	ed 91       	ld	r30, X+
    3092:	fc 91       	ld	r31, X
    3094:	02 80       	ldd	r0, Z+2	; 0x02
    3096:	f3 81       	ldd	r31, Z+3	; 0x03
    3098:	e0 2d       	mov	r30, r0
    309a:	c7 01       	movw	r24, r14
    309c:	19 95       	eicall
    309e:	09 c0       	rjmp	.+18     	; 0x30b2 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    30a0:	d7 01       	movw	r26, r14
    30a2:	ed 91       	ld	r30, X+
    30a4:	fc 91       	ld	r31, X
    30a6:	02 80       	ldd	r0, Z+2	; 0x02
    30a8:	f3 81       	ldd	r31, Z+3	; 0x03
    30aa:	e0 2d       	mov	r30, r0
    30ac:	6e e2       	ldi	r22, 0x2E	; 46
    30ae:	c7 01       	movw	r24, r14
    30b0:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    30b2:	cc 16       	cp	r12, r28
    30b4:	dd 06       	cpc	r13, r29
    30b6:	31 f7       	brne	.-52     	; 0x3084 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    30b8:	b4 e1       	ldi	r27, 0x14	; 20
    30ba:	ab 0e       	add	r10, r27
    30bc:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    30be:	66 e0       	ldi	r22, 0x06	; 6
    30c0:	c7 01       	movw	r24, r14
    30c2:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    30c6:	84 e1       	ldi	r24, 0x14	; 20
    30c8:	c8 0e       	add	r12, r24
    30ca:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    30cc:	a8 14       	cp	r10, r8
    30ce:	b9 04       	cpc	r11, r9
    30d0:	08 f4       	brcc	.+2      	; 0x30d4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    30d2:	88 cf       	rjmp	.-240    	; 0x2fe4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    30d4:	62 e0       	ldi	r22, 0x02	; 2
    30d6:	c7 01       	movw	r24, r14
    30d8:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
}
    30dc:	03 c0       	rjmp	.+6      	; 0x30e4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    30de:	c6 2d       	mov	r28, r6
    30e0:	d5 2d       	mov	r29, r5
    30e2:	9c cf       	rjmp	.-200    	; 0x301c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    30e4:	df 91       	pop	r29
    30e6:	cf 91       	pop	r28
    30e8:	1f 91       	pop	r17
    30ea:	0f 91       	pop	r16
    30ec:	ff 90       	pop	r15
    30ee:	ef 90       	pop	r14
    30f0:	df 90       	pop	r13
    30f2:	cf 90       	pop	r12
    30f4:	bf 90       	pop	r11
    30f6:	af 90       	pop	r10
    30f8:	9f 90       	pop	r9
    30fa:	8f 90       	pop	r8
    30fc:	7f 90       	pop	r7
    30fe:	6f 90       	pop	r6
    3100:	5f 90       	pop	r5
    3102:	08 95       	ret

00003104 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    3104:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    3108:	08 95       	ret

0000310a <_Znaj>:
    310a:	0e 94 c4 08 	call	0x1188	; 0x1188 <pvPortMalloc>
    310e:	08 95       	ret

00003110 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    3110:	08 95       	ret

00003112 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    3112:	cf 93       	push	r28
    3114:	df 93       	push	r29
    3116:	fc 01       	movw	r30, r24
    3118:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    311a:	40 3a       	cpi	r20, 0xA0	; 160
    311c:	68 e0       	ldi	r22, 0x08	; 8
    311e:	56 07       	cpc	r21, r22
    3120:	49 f4       	brne	.+18     	; 0x3134 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    3122:	80 e4       	ldi	r24, 0x40	; 64
    3124:	96 e0       	ldi	r25, 0x06	; 6
    3126:	82 83       	std	Z+2, r24	; 0x02
    3128:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    312a:	82 e0       	ldi	r24, 0x02	; 2
    312c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    312e:	83 e0       	ldi	r24, 0x03	; 3
    3130:	85 83       	std	Z+5, r24	; 0x05
    3132:	32 c0       	rjmp	.+100    	; 0x3198 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    3134:	40 3b       	cpi	r20, 0xB0	; 176
    3136:	78 e0       	ldi	r23, 0x08	; 8
    3138:	57 07       	cpc	r21, r23
    313a:	49 f4       	brne	.+18     	; 0x314e <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    313c:	80 e4       	ldi	r24, 0x40	; 64
    313e:	96 e0       	ldi	r25, 0x06	; 6
    3140:	82 83       	std	Z+2, r24	; 0x02
    3142:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3144:	86 e0       	ldi	r24, 0x06	; 6
    3146:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3148:	87 e0       	ldi	r24, 0x07	; 7
    314a:	85 83       	std	Z+5, r24	; 0x05
    314c:	25 c0       	rjmp	.+74     	; 0x3198 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    314e:	40 3a       	cpi	r20, 0xA0	; 160
    3150:	89 e0       	ldi	r24, 0x09	; 9
    3152:	58 07       	cpc	r21, r24
    3154:	49 f4       	brne	.+18     	; 0x3168 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3156:	80 e6       	ldi	r24, 0x60	; 96
    3158:	96 e0       	ldi	r25, 0x06	; 6
    315a:	82 83       	std	Z+2, r24	; 0x02
    315c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    315e:	82 e0       	ldi	r24, 0x02	; 2
    3160:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3162:	83 e0       	ldi	r24, 0x03	; 3
    3164:	85 83       	std	Z+5, r24	; 0x05
    3166:	18 c0       	rjmp	.+48     	; 0x3198 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3168:	40 3b       	cpi	r20, 0xB0	; 176
    316a:	69 e0       	ldi	r22, 0x09	; 9
    316c:	56 07       	cpc	r21, r22
    316e:	49 f4       	brne	.+18     	; 0x3182 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    3170:	80 e6       	ldi	r24, 0x60	; 96
    3172:	96 e0       	ldi	r25, 0x06	; 6
    3174:	82 83       	std	Z+2, r24	; 0x02
    3176:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3178:	86 e0       	ldi	r24, 0x06	; 6
    317a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    317c:	87 e0       	ldi	r24, 0x07	; 7
    317e:	85 83       	std	Z+5, r24	; 0x05
    3180:	0b c0       	rjmp	.+22     	; 0x3198 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3182:	40 3a       	cpi	r20, 0xA0	; 160
    3184:	5a 40       	sbci	r21, 0x0A	; 10
    3186:	41 f4       	brne	.+16     	; 0x3198 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3188:	80 e8       	ldi	r24, 0x80	; 128
    318a:	96 e0       	ldi	r25, 0x06	; 6
    318c:	82 83       	std	Z+2, r24	; 0x02
    318e:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3190:	82 e0       	ldi	r24, 0x02	; 2
    3192:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    3194:	83 e0       	ldi	r24, 0x03	; 3
    3196:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3198:	a6 83       	std	Z+6, r26	; 0x06
    319a:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    319c:	cd 01       	movw	r24, r26
    319e:	01 96       	adiw	r24, 0x01	; 1
    31a0:	80 87       	std	Z+8, r24	; 0x08
    31a2:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    31a4:	03 96       	adiw	r24, 0x03	; 3
    31a6:	82 87       	std	Z+10, r24	; 0x0a
    31a8:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    31aa:	25 81       	ldd	r18, Z+5	; 0x05
    31ac:	c2 81       	ldd	r28, Z+2	; 0x02
    31ae:	d3 81       	ldd	r29, Z+3	; 0x03
    31b0:	4c 81       	ldd	r20, Y+4	; 0x04
    31b2:	81 e0       	ldi	r24, 0x01	; 1
    31b4:	90 e0       	ldi	r25, 0x00	; 0
    31b6:	bc 01       	movw	r22, r24
    31b8:	02 c0       	rjmp	.+4      	; 0x31be <_ZN7base232C1EjP12USART_struct+0xac>
    31ba:	66 0f       	add	r22, r22
    31bc:	77 1f       	adc	r23, r23
    31be:	2a 95       	dec	r18
    31c0:	e2 f7       	brpl	.-8      	; 0x31ba <_ZN7base232C1EjP12USART_struct+0xa8>
    31c2:	9b 01       	movw	r18, r22
    31c4:	24 2b       	or	r18, r20
    31c6:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    31c8:	25 81       	ldd	r18, Z+5	; 0x05
    31ca:	c2 81       	ldd	r28, Z+2	; 0x02
    31cc:	d3 81       	ldd	r29, Z+3	; 0x03
    31ce:	48 81       	ld	r20, Y
    31d0:	bc 01       	movw	r22, r24
    31d2:	02 c0       	rjmp	.+4      	; 0x31d8 <_ZN7base232C1EjP12USART_struct+0xc6>
    31d4:	66 0f       	add	r22, r22
    31d6:	77 1f       	adc	r23, r23
    31d8:	2a 95       	dec	r18
    31da:	e2 f7       	brpl	.-8      	; 0x31d4 <_ZN7base232C1EjP12USART_struct+0xc2>
    31dc:	9b 01       	movw	r18, r22
    31de:	24 2b       	or	r18, r20
    31e0:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    31e2:	34 81       	ldd	r19, Z+4	; 0x04
    31e4:	c2 81       	ldd	r28, Z+2	; 0x02
    31e6:	d3 81       	ldd	r29, Z+3	; 0x03
    31e8:	28 81       	ld	r18, Y
    31ea:	02 c0       	rjmp	.+4      	; 0x31f0 <_ZN7base232C1EjP12USART_struct+0xde>
    31ec:	88 0f       	add	r24, r24
    31ee:	99 1f       	adc	r25, r25
    31f0:	3a 95       	dec	r19
    31f2:	e2 f7       	brpl	.-8      	; 0x31ec <_ZN7base232C1EjP12USART_struct+0xda>
    31f4:	80 95       	com	r24
    31f6:	90 95       	com	r25
    31f8:	82 23       	and	r24, r18
    31fa:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    31fc:	80 e1       	ldi	r24, 0x10	; 16
    31fe:	13 96       	adiw	r26, 0x03	; 3
    3200:	8c 93       	st	X, r24
    3202:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    3204:	83 e0       	ldi	r24, 0x03	; 3
    3206:	15 96       	adiw	r26, 0x05	; 5
    3208:	8c 93       	st	X, r24
    320a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    320c:	80 ef       	ldi	r24, 0xF0	; 240
    320e:	17 96       	adiw	r26, 0x07	; 7
    3210:	8c 93       	st	X, r24
    3212:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    3214:	81 e2       	ldi	r24, 0x21	; 33
    3216:	16 96       	adiw	r26, 0x06	; 6
    3218:	8c 93       	st	X, r24
    321a:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    321c:	88 e1       	ldi	r24, 0x18	; 24
    321e:	14 96       	adiw	r26, 0x04	; 4
    3220:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    3222:	80 e8       	ldi	r24, 0x80	; 128
    3224:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    3226:	80 e4       	ldi	r24, 0x40	; 64
    3228:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    322a:	80 e2       	ldi	r24, 0x20	; 32
    322c:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    322e:	06 80       	ldd	r0, Z+6	; 0x06
    3230:	f7 81       	ldd	r31, Z+7	; 0x07
    3232:	e0 2d       	mov	r30, r0
    3234:	80 81       	ld	r24, Z
    3236:	80 81       	ld	r24, Z
}
    3238:	df 91       	pop	r29
    323a:	cf 91       	pop	r28
    323c:	08 95       	ret

0000323e <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    323e:	81 e0       	ldi	r24, 0x01	; 1
    3240:	08 95       	ret

00003242 <_ZN8emstream7getcharEv>:
    3242:	80 e0       	ldi	r24, 0x00	; 0
    3244:	90 e0       	ldi	r25, 0x00	; 0
    3246:	08 95       	ret

00003248 <_ZN8emstream14check_for_charEv>:
    3248:	80 e0       	ldi	r24, 0x00	; 0
    324a:	08 95       	ret

0000324c <_ZN8emstream12transmit_nowEv>:
    324c:	08 95       	ret

0000324e <_ZN8emstream12clear_screenEv>:
    324e:	08 95       	ret

00003250 <_ZN8emstreamC1Ev>:
    3250:	fc 01       	movw	r30, r24
    3252:	81 e6       	ldi	r24, 0x61	; 97
    3254:	90 e2       	ldi	r25, 0x20	; 32
    3256:	80 83       	st	Z, r24
    3258:	91 83       	std	Z+1, r25	; 0x01
    325a:	8a e0       	ldi	r24, 0x0A	; 10
    325c:	82 83       	std	Z+2, r24	; 0x02
    325e:	13 82       	std	Z+3, r1	; 0x03
    3260:	83 e0       	ldi	r24, 0x03	; 3
    3262:	85 83       	std	Z+5, r24	; 0x05
    3264:	14 82       	std	Z+4, r1	; 0x04
    3266:	16 82       	std	Z+6, r1	; 0x06
    3268:	17 82       	std	Z+7, r1	; 0x07
    326a:	08 95       	ret

0000326c <_ZN8emstream4putsEPKc>:
    326c:	0f 93       	push	r16
    326e:	1f 93       	push	r17
    3270:	cf 93       	push	r28
    3272:	df 93       	push	r29
    3274:	8c 01       	movw	r16, r24
    3276:	fb 01       	movw	r30, r22
    3278:	dc 01       	movw	r26, r24
    327a:	14 96       	adiw	r26, 0x04	; 4
    327c:	8c 91       	ld	r24, X
    327e:	81 11       	cpse	r24, r1
    3280:	04 c0       	rjmp	.+8      	; 0x328a <_ZN8emstream4putsEPKc+0x1e>
    3282:	60 81       	ld	r22, Z
    3284:	61 11       	cpse	r22, r1
    3286:	17 c0       	rjmp	.+46     	; 0x32b6 <_ZN8emstream4putsEPKc+0x4a>
    3288:	23 c0       	rjmp	.+70     	; 0x32d0 <_ZN8emstream4putsEPKc+0x64>
    328a:	d8 01       	movw	r26, r16
    328c:	14 96       	adiw	r26, 0x04	; 4
    328e:	1c 92       	st	X, r1
    3290:	eb 01       	movw	r28, r22
    3292:	21 96       	adiw	r28, 0x01	; 1
    3294:	64 91       	lpm	r22, Z
    3296:	66 23       	and	r22, r22
    3298:	d9 f0       	breq	.+54     	; 0x32d0 <_ZN8emstream4putsEPKc+0x64>
    329a:	d8 01       	movw	r26, r16
    329c:	ed 91       	ld	r30, X+
    329e:	fc 91       	ld	r31, X
    32a0:	02 80       	ldd	r0, Z+2	; 0x02
    32a2:	f3 81       	ldd	r31, Z+3	; 0x03
    32a4:	e0 2d       	mov	r30, r0
    32a6:	c8 01       	movw	r24, r16
    32a8:	19 95       	eicall
    32aa:	fe 01       	movw	r30, r28
    32ac:	64 91       	lpm	r22, Z
    32ae:	21 96       	adiw	r28, 0x01	; 1
    32b0:	61 11       	cpse	r22, r1
    32b2:	f3 cf       	rjmp	.-26     	; 0x329a <_ZN8emstream4putsEPKc+0x2e>
    32b4:	0d c0       	rjmp	.+26     	; 0x32d0 <_ZN8emstream4putsEPKc+0x64>
    32b6:	ef 01       	movw	r28, r30
    32b8:	21 96       	adiw	r28, 0x01	; 1
    32ba:	d8 01       	movw	r26, r16
    32bc:	ed 91       	ld	r30, X+
    32be:	fc 91       	ld	r31, X
    32c0:	02 80       	ldd	r0, Z+2	; 0x02
    32c2:	f3 81       	ldd	r31, Z+3	; 0x03
    32c4:	e0 2d       	mov	r30, r0
    32c6:	c8 01       	movw	r24, r16
    32c8:	19 95       	eicall
    32ca:	69 91       	ld	r22, Y+
    32cc:	61 11       	cpse	r22, r1
    32ce:	f5 cf       	rjmp	.-22     	; 0x32ba <_ZN8emstream4putsEPKc+0x4e>
    32d0:	df 91       	pop	r29
    32d2:	cf 91       	pop	r28
    32d4:	1f 91       	pop	r17
    32d6:	0f 91       	pop	r16
    32d8:	08 95       	ret

000032da <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    32da:	cf 93       	push	r28
    32dc:	df 93       	push	r29
    32de:	ec 01       	movw	r28, r24
	switch (new_manip)
    32e0:	86 2f       	mov	r24, r22
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	8b 30       	cpi	r24, 0x0B	; 11
    32e6:	91 05       	cpc	r25, r1
    32e8:	d8 f5       	brcc	.+118    	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
    32ea:	fc 01       	movw	r30, r24
    32ec:	88 27       	eor	r24, r24
    32ee:	e2 50       	subi	r30, 0x02	; 2
    32f0:	ff 4f       	sbci	r31, 0xFF	; 255
    32f2:	8f 4f       	sbci	r24, 0xFF	; 255
    32f4:	0c 94 d1 20 	jmp	0x41a2	; 0x41a2 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    32f8:	82 e0       	ldi	r24, 0x02	; 2
    32fa:	8a 83       	std	Y+2, r24	; 0x02
			break;
    32fc:	31 c0       	rjmp	.+98     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    32fe:	88 e0       	ldi	r24, 0x08	; 8
    3300:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3302:	2e c0       	rjmp	.+92     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    3304:	8a e0       	ldi	r24, 0x0A	; 10
    3306:	8a 83       	std	Y+2, r24	; 0x02
			break;
    3308:	2b c0       	rjmp	.+86     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    330a:	80 e1       	ldi	r24, 0x10	; 16
    330c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    330e:	28 c0       	rjmp	.+80     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	8b 83       	std	Y+3, r24	; 0x03
			break;
    3314:	25 c0       	rjmp	.+74     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    3316:	1b 82       	std	Y+3, r1	; 0x03
			break;
    3318:	23 c0       	rjmp	.+70     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    331a:	e8 81       	ld	r30, Y
    331c:	f9 81       	ldd	r31, Y+1	; 0x01
    331e:	02 80       	ldd	r0, Z+2	; 0x02
    3320:	f3 81       	ldd	r31, Z+3	; 0x03
    3322:	e0 2d       	mov	r30, r0
    3324:	6d e0       	ldi	r22, 0x0D	; 13
    3326:	ce 01       	movw	r24, r28
    3328:	19 95       	eicall
    332a:	e8 81       	ld	r30, Y
    332c:	f9 81       	ldd	r31, Y+1	; 0x01
    332e:	02 80       	ldd	r0, Z+2	; 0x02
    3330:	f3 81       	ldd	r31, Z+3	; 0x03
    3332:	e0 2d       	mov	r30, r0
    3334:	6a e0       	ldi	r22, 0x0A	; 10
    3336:	ce 01       	movw	r24, r28
    3338:	19 95       	eicall
			break;
    333a:	12 c0       	rjmp	.+36     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    333c:	e8 81       	ld	r30, Y
    333e:	f9 81       	ldd	r31, Y+1	; 0x01
    3340:	02 84       	ldd	r0, Z+10	; 0x0a
    3342:	f3 85       	ldd	r31, Z+11	; 0x0b
    3344:	e0 2d       	mov	r30, r0
    3346:	ce 01       	movw	r24, r28
    3348:	19 95       	eicall
			break;
    334a:	0a c0       	rjmp	.+20     	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    334c:	e8 81       	ld	r30, Y
    334e:	f9 81       	ldd	r31, Y+1	; 0x01
    3350:	00 84       	ldd	r0, Z+8	; 0x08
    3352:	f1 85       	ldd	r31, Z+9	; 0x09
    3354:	e0 2d       	mov	r30, r0
    3356:	ce 01       	movw	r24, r28
    3358:	19 95       	eicall
			break;
    335a:	02 c0       	rjmp	.+4      	; 0x3360 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    335c:	81 e0       	ldi	r24, 0x01	; 1
    335e:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    3360:	ce 01       	movw	r24, r28
    3362:	df 91       	pop	r29
    3364:	cf 91       	pop	r28
    3366:	08 95       	ret

00003368 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3368:	ff 92       	push	r15
    336a:	0f 93       	push	r16
    336c:	1f 93       	push	r17
    336e:	cf 93       	push	r28
    3370:	df 93       	push	r29
    3372:	cd b7       	in	r28, 0x3d	; 61
    3374:	de b7       	in	r29, 0x3e	; 62
    3376:	61 97       	sbiw	r28, 0x11	; 17
    3378:	cd bf       	out	0x3d, r28	; 61
    337a:	de bf       	out	0x3e, r29	; 62
    337c:	8c 01       	movw	r16, r24
    337e:	f6 2e       	mov	r15, r22
    3380:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3382:	f8 01       	movw	r30, r16
    3384:	42 81       	ldd	r20, Z+2	; 0x02
    3386:	40 31       	cpi	r20, 0x10	; 16
    3388:	21 f0       	breq	.+8      	; 0x3392 <_ZN8emstreamlsEj+0x2a>
    338a:	48 30       	cpi	r20, 0x08	; 8
    338c:	11 f0       	breq	.+4      	; 0x3392 <_ZN8emstreamlsEj+0x2a>
    338e:	42 30       	cpi	r20, 0x02	; 2
    3390:	41 f4       	brne	.+16     	; 0x33a2 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3392:	69 2f       	mov	r22, r25
    3394:	c8 01       	movw	r24, r16
    3396:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    339a:	6f 2d       	mov	r22, r15
    339c:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    33a0:	0d c0       	rjmp	.+26     	; 0x33bc <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    33a2:	50 e0       	ldi	r21, 0x00	; 0
    33a4:	be 01       	movw	r22, r28
    33a6:	6f 5f       	subi	r22, 0xFF	; 255
    33a8:	7f 4f       	sbci	r23, 0xFF	; 255
    33aa:	8f 2d       	mov	r24, r15
    33ac:	0e 94 40 21 	call	0x4280	; 0x4280 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    33b0:	be 01       	movw	r22, r28
    33b2:	6f 5f       	subi	r22, 0xFF	; 255
    33b4:	7f 4f       	sbci	r23, 0xFF	; 255
    33b6:	c8 01       	movw	r24, r16
    33b8:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    33bc:	c8 01       	movw	r24, r16
    33be:	61 96       	adiw	r28, 0x11	; 17
    33c0:	cd bf       	out	0x3d, r28	; 61
    33c2:	de bf       	out	0x3e, r29	; 62
    33c4:	df 91       	pop	r29
    33c6:	cf 91       	pop	r28
    33c8:	1f 91       	pop	r17
    33ca:	0f 91       	pop	r16
    33cc:	ff 90       	pop	r15
    33ce:	08 95       	ret

000033d0 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    33d0:	df 92       	push	r13
    33d2:	ef 92       	push	r14
    33d4:	ff 92       	push	r15
    33d6:	0f 93       	push	r16
    33d8:	1f 93       	push	r17
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	cd b7       	in	r28, 0x3d	; 61
    33e0:	de b7       	in	r29, 0x3e	; 62
    33e2:	a1 97       	sbiw	r28, 0x21	; 33
    33e4:	cd bf       	out	0x3d, r28	; 61
    33e6:	de bf       	out	0x3e, r29	; 62
    33e8:	8c 01       	movw	r16, r24
    33ea:	d4 2e       	mov	r13, r20
    33ec:	e5 2e       	mov	r14, r21
    33ee:	f6 2e       	mov	r15, r22
    33f0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    33f2:	f8 01       	movw	r30, r16
    33f4:	22 81       	ldd	r18, Z+2	; 0x02
    33f6:	20 31       	cpi	r18, 0x10	; 16
    33f8:	21 f0       	breq	.+8      	; 0x3402 <_ZN8emstreamlsEm+0x32>
    33fa:	28 30       	cpi	r18, 0x08	; 8
    33fc:	11 f0       	breq	.+4      	; 0x3402 <_ZN8emstreamlsEm+0x32>
    33fe:	22 30       	cpi	r18, 0x02	; 2
    3400:	71 f4       	brne	.+28     	; 0x341e <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3402:	69 2f       	mov	r22, r25
    3404:	c8 01       	movw	r24, r16
    3406:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    340a:	6f 2d       	mov	r22, r15
    340c:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    3410:	6e 2d       	mov	r22, r14
    3412:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    3416:	6d 2d       	mov	r22, r13
    3418:	0e 94 2a 1a 	call	0x3454	; 0x3454 <_ZN8emstreamlsEh>
    341c:	0f c0       	rjmp	.+30     	; 0x343c <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    341e:	30 e0       	ldi	r19, 0x00	; 0
    3420:	ae 01       	movw	r20, r28
    3422:	4f 5f       	subi	r20, 0xFF	; 255
    3424:	5f 4f       	sbci	r21, 0xFF	; 255
    3426:	6d 2d       	mov	r22, r13
    3428:	7e 2d       	mov	r23, r14
    342a:	8f 2d       	mov	r24, r15
    342c:	0e 94 13 21 	call	0x4226	; 0x4226 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    3430:	be 01       	movw	r22, r28
    3432:	6f 5f       	subi	r22, 0xFF	; 255
    3434:	7f 4f       	sbci	r23, 0xFF	; 255
    3436:	c8 01       	movw	r24, r16
    3438:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    343c:	c8 01       	movw	r24, r16
    343e:	a1 96       	adiw	r28, 0x21	; 33
    3440:	cd bf       	out	0x3d, r28	; 61
    3442:	de bf       	out	0x3e, r29	; 62
    3444:	df 91       	pop	r29
    3446:	cf 91       	pop	r28
    3448:	1f 91       	pop	r17
    344a:	0f 91       	pop	r16
    344c:	ff 90       	pop	r15
    344e:	ef 90       	pop	r14
    3450:	df 90       	pop	r13
    3452:	08 95       	ret

00003454 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    3454:	cf 92       	push	r12
    3456:	df 92       	push	r13
    3458:	ef 92       	push	r14
    345a:	ff 92       	push	r15
    345c:	0f 93       	push	r16
    345e:	1f 93       	push	r17
    3460:	cf 93       	push	r28
    3462:	df 93       	push	r29
    3464:	cd b7       	in	r28, 0x3d	; 61
    3466:	de b7       	in	r29, 0x3e	; 62
    3468:	29 97       	sbiw	r28, 0x09	; 9
    346a:	cd bf       	out	0x3d, r28	; 61
    346c:	de bf       	out	0x3e, r29	; 62
    346e:	8c 01       	movw	r16, r24
    3470:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    3472:	dc 01       	movw	r26, r24
    3474:	13 96       	adiw	r26, 0x03	; 3
    3476:	8c 91       	ld	r24, X
    3478:	13 97       	sbiw	r26, 0x03	; 3
    347a:	88 23       	and	r24, r24
    347c:	41 f0       	breq	.+16     	; 0x348e <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    347e:	ed 91       	ld	r30, X+
    3480:	fc 91       	ld	r31, X
    3482:	02 80       	ldd	r0, Z+2	; 0x02
    3484:	f3 81       	ldd	r31, Z+3	; 0x03
    3486:	e0 2d       	mov	r30, r0
    3488:	c8 01       	movw	r24, r16
    348a:	19 95       	eicall
    348c:	56 c0       	rjmp	.+172    	; 0x353a <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    348e:	f8 01       	movw	r30, r16
    3490:	42 81       	ldd	r20, Z+2	; 0x02
    3492:	42 30       	cpi	r20, 0x02	; 2
    3494:	19 f5       	brne	.+70     	; 0x34dc <_ZN8emstreamlsEh+0x88>
    3496:	68 94       	set
    3498:	cc 24       	eor	r12, r12
    349a:	c3 f8       	bld	r12, 3
    349c:	d1 2c       	mov	r13, r1
    349e:	68 94       	set
    34a0:	ff 24       	eor	r15, r15
    34a2:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    34a4:	8e 2d       	mov	r24, r14
    34a6:	8f 21       	and	r24, r15
    34a8:	51 f0       	breq	.+20     	; 0x34be <_ZN8emstreamlsEh+0x6a>
    34aa:	d8 01       	movw	r26, r16
    34ac:	ed 91       	ld	r30, X+
    34ae:	fc 91       	ld	r31, X
    34b0:	02 80       	ldd	r0, Z+2	; 0x02
    34b2:	f3 81       	ldd	r31, Z+3	; 0x03
    34b4:	e0 2d       	mov	r30, r0
    34b6:	61 e3       	ldi	r22, 0x31	; 49
    34b8:	c8 01       	movw	r24, r16
    34ba:	19 95       	eicall
    34bc:	09 c0       	rjmp	.+18     	; 0x34d0 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    34be:	d8 01       	movw	r26, r16
    34c0:	ed 91       	ld	r30, X+
    34c2:	fc 91       	ld	r31, X
    34c4:	02 80       	ldd	r0, Z+2	; 0x02
    34c6:	f3 81       	ldd	r31, Z+3	; 0x03
    34c8:	e0 2d       	mov	r30, r0
    34ca:	60 e3       	ldi	r22, 0x30	; 48
    34cc:	c8 01       	movw	r24, r16
    34ce:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    34d0:	f6 94       	lsr	r15
    34d2:	b1 e0       	ldi	r27, 0x01	; 1
    34d4:	cb 1a       	sub	r12, r27
    34d6:	d1 08       	sbc	r13, r1
    34d8:	29 f7       	brne	.-54     	; 0x34a4 <_ZN8emstreamlsEh+0x50>
    34da:	2f c0       	rjmp	.+94     	; 0x353a <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    34dc:	40 31       	cpi	r20, 0x10	; 16
    34de:	f9 f4       	brne	.+62     	; 0x351e <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    34e0:	62 95       	swap	r22
    34e2:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    34e4:	01 90       	ld	r0, Z+
    34e6:	f0 81       	ld	r31, Z
    34e8:	e0 2d       	mov	r30, r0
    34ea:	02 80       	ldd	r0, Z+2	; 0x02
    34ec:	f3 81       	ldd	r31, Z+3	; 0x03
    34ee:	e0 2d       	mov	r30, r0
    34f0:	6a 30       	cpi	r22, 0x0A	; 10
    34f2:	10 f0       	brcs	.+4      	; 0x34f8 <_ZN8emstreamlsEh+0xa4>
    34f4:	69 5c       	subi	r22, 0xC9	; 201
    34f6:	01 c0       	rjmp	.+2      	; 0x34fa <_ZN8emstreamlsEh+0xa6>
    34f8:	60 5d       	subi	r22, 0xD0	; 208
    34fa:	c8 01       	movw	r24, r16
    34fc:	19 95       	eicall
		temp_char = num & 0x0F;
    34fe:	6e 2d       	mov	r22, r14
    3500:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3502:	d8 01       	movw	r26, r16
    3504:	ed 91       	ld	r30, X+
    3506:	fc 91       	ld	r31, X
    3508:	02 80       	ldd	r0, Z+2	; 0x02
    350a:	f3 81       	ldd	r31, Z+3	; 0x03
    350c:	e0 2d       	mov	r30, r0
    350e:	6a 30       	cpi	r22, 0x0A	; 10
    3510:	10 f0       	brcs	.+4      	; 0x3516 <_ZN8emstreamlsEh+0xc2>
    3512:	69 5c       	subi	r22, 0xC9	; 201
    3514:	01 c0       	rjmp	.+2      	; 0x3518 <_ZN8emstreamlsEh+0xc4>
    3516:	60 5d       	subi	r22, 0xD0	; 208
    3518:	c8 01       	movw	r24, r16
    351a:	19 95       	eicall
    351c:	0e c0       	rjmp	.+28     	; 0x353a <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    351e:	50 e0       	ldi	r21, 0x00	; 0
    3520:	be 01       	movw	r22, r28
    3522:	6f 5f       	subi	r22, 0xFF	; 255
    3524:	7f 4f       	sbci	r23, 0xFF	; 255
    3526:	8e 2d       	mov	r24, r14
    3528:	90 e0       	ldi	r25, 0x00	; 0
    352a:	0e 94 40 21 	call	0x4280	; 0x4280 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    352e:	be 01       	movw	r22, r28
    3530:	6f 5f       	subi	r22, 0xFF	; 255
    3532:	7f 4f       	sbci	r23, 0xFF	; 255
    3534:	c8 01       	movw	r24, r16
    3536:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    353a:	c8 01       	movw	r24, r16
    353c:	29 96       	adiw	r28, 0x09	; 9
    353e:	cd bf       	out	0x3d, r28	; 61
    3540:	de bf       	out	0x3e, r29	; 62
    3542:	df 91       	pop	r29
    3544:	cf 91       	pop	r28
    3546:	1f 91       	pop	r17
    3548:	0f 91       	pop	r16
    354a:	ff 90       	pop	r15
    354c:	ef 90       	pop	r14
    354e:	df 90       	pop	r13
    3550:	cf 90       	pop	r12
    3552:	08 95       	ret

00003554 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    3554:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3556:	50 96       	adiw	r26, 0x10	; 16
    3558:	ed 91       	ld	r30, X+
    355a:	fc 91       	ld	r31, X
    355c:	51 97       	sbiw	r26, 0x11	; 17
    355e:	80 81       	ld	r24, Z
    3560:	54 96       	adiw	r26, 0x14	; 20
    3562:	4c 91       	ld	r20, X
    3564:	54 97       	sbiw	r26, 0x14	; 20
    3566:	84 23       	and	r24, r20
    3568:	29 f0       	breq	.+10     	; 0x3574 <_ZN5rs2327putcharEc+0x20>
    356a:	09 c0       	rjmp	.+18     	; 0x357e <_ZN5rs2327putcharEc+0x2a>
    356c:	21 50       	subi	r18, 0x01	; 1
    356e:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    3570:	19 f4       	brne	.+6      	; 0x3578 <_ZN5rs2327putcharEc+0x24>
    3572:	12 c0       	rjmp	.+36     	; 0x3598 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3574:	21 e2       	ldi	r18, 0x21	; 33
    3576:	3e e4       	ldi	r19, 0x4E	; 78
    3578:	90 81       	ld	r25, Z
    357a:	94 23       	and	r25, r20
    357c:	b9 f3       	breq	.-18     	; 0x356c <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    357e:	90 81       	ld	r25, Z
    3580:	56 96       	adiw	r26, 0x16	; 22
    3582:	8c 91       	ld	r24, X
    3584:	56 97       	sbiw	r26, 0x16	; 22
    3586:	89 2b       	or	r24, r25
    3588:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    358a:	1e 96       	adiw	r26, 0x0e	; 14
    358c:	ed 91       	ld	r30, X+
    358e:	fc 91       	ld	r31, X
    3590:	1f 97       	sbiw	r26, 0x0f	; 15
    3592:	60 83       	st	Z, r22
	return (true);
    3594:	81 e0       	ldi	r24, 0x01	; 1
    3596:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3598:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    359a:	08 95       	ret

0000359c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    359c:	cf 93       	push	r28
    359e:	df 93       	push	r29
    35a0:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    35a2:	c1 8d       	ldd	r28, Z+25	; 0x19
    35a4:	d2 8d       	ldd	r29, Z+26	; 0x1a
    35a6:	28 81       	ld	r18, Y
    35a8:	39 81       	ldd	r19, Y+1	; 0x01
    35aa:	a3 8d       	ldd	r26, Z+27	; 0x1b
    35ac:	b4 8d       	ldd	r27, Z+28	; 0x1c
    35ae:	4d 91       	ld	r20, X+
    35b0:	5c 91       	ld	r21, X
    35b2:	24 17       	cp	r18, r20
    35b4:	35 07       	cpc	r19, r21
    35b6:	e9 f3       	breq	.-6      	; 0x35b2 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    35b8:	a7 89       	ldd	r26, Z+23	; 0x17
    35ba:	b0 8d       	ldd	r27, Z+24	; 0x18
    35bc:	0d 90       	ld	r0, X+
    35be:	bc 91       	ld	r27, X
    35c0:	a0 2d       	mov	r26, r0
    35c2:	a2 0f       	add	r26, r18
    35c4:	b3 1f       	adc	r27, r19
    35c6:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    35c8:	2f 5f       	subi	r18, 0xFF	; 255
    35ca:	3f 4f       	sbci	r19, 0xFF	; 255
    35cc:	28 83       	st	Y, r18
    35ce:	39 83       	std	Y+1, r19	; 0x01
    35d0:	24 36       	cpi	r18, 0x64	; 100
    35d2:	31 05       	cpc	r19, r1
    35d4:	28 f0       	brcs	.+10     	; 0x35e0 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    35d6:	01 8c       	ldd	r0, Z+25	; 0x19
    35d8:	f2 8d       	ldd	r31, Z+26	; 0x1a
    35da:	e0 2d       	mov	r30, r0
    35dc:	10 82       	st	Z, r1
    35de:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    35e0:	90 e0       	ldi	r25, 0x00	; 0
    35e2:	df 91       	pop	r29
    35e4:	cf 91       	pop	r28
    35e6:	08 95       	ret

000035e8 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    35e8:	cf 93       	push	r28
    35ea:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    35ec:	ec 01       	movw	r28, r24
    35ee:	a9 8d       	ldd	r26, Y+25	; 0x19
    35f0:	ba 8d       	ldd	r27, Y+26	; 0x1a
    35f2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    35f4:	fc 8d       	ldd	r31, Y+28	; 0x1c
    35f6:	81 e0       	ldi	r24, 0x01	; 1
    35f8:	4d 91       	ld	r20, X+
    35fa:	5c 91       	ld	r21, X
    35fc:	20 81       	ld	r18, Z
    35fe:	31 81       	ldd	r19, Z+1	; 0x01
    3600:	42 17       	cp	r20, r18
    3602:	53 07       	cpc	r21, r19
    3604:	09 f4       	brne	.+2      	; 0x3608 <_ZN5rs23214check_for_charEv+0x20>
    3606:	80 e0       	ldi	r24, 0x00	; 0
}
    3608:	df 91       	pop	r29
    360a:	cf 91       	pop	r28
    360c:	08 95       	ret

0000360e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    360e:	dc 01       	movw	r26, r24
    3610:	ed 91       	ld	r30, X+
    3612:	fc 91       	ld	r31, X
    3614:	02 80       	ldd	r0, Z+2	; 0x02
    3616:	f3 81       	ldd	r31, Z+3	; 0x03
    3618:	e0 2d       	mov	r30, r0
    361a:	6c e0       	ldi	r22, 0x0C	; 12
    361c:	19 95       	eicall
    361e:	08 95       	ret

00003620 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3620:	ef 92       	push	r14
    3622:	ff 92       	push	r15
    3624:	0f 93       	push	r16
    3626:	1f 93       	push	r17
    3628:	cf 93       	push	r28
    362a:	df 93       	push	r29
    362c:	ec 01       	movw	r28, r24
    362e:	7b 01       	movw	r14, r22
    3630:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3632:	0e 94 28 19 	call	0x3250	; 0x3250 <_ZN8emstreamC1Ev>
    3636:	a8 01       	movw	r20, r16
    3638:	b7 01       	movw	r22, r14
    363a:	ce 01       	movw	r24, r28
    363c:	08 96       	adiw	r24, 0x08	; 8
    363e:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN7base232C1EjP12USART_struct>
    3642:	81 e7       	ldi	r24, 0x71	; 113
    3644:	90 e2       	ldi	r25, 0x20	; 32
    3646:	88 83       	st	Y, r24
    3648:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    364a:	00 3a       	cpi	r16, 0xA0	; 160
    364c:	88 e0       	ldi	r24, 0x08	; 8
    364e:	18 07       	cpc	r17, r24
    3650:	69 f4       	brne	.+26     	; 0x366c <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    3652:	8a e7       	ldi	r24, 0x7A	; 122
    3654:	91 e3       	ldi	r25, 0x31	; 49
    3656:	8f 8b       	std	Y+23, r24	; 0x17
    3658:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    365a:	80 e7       	ldi	r24, 0x70	; 112
    365c:	91 e3       	ldi	r25, 0x31	; 49
    365e:	89 8f       	std	Y+25, r24	; 0x19
    3660:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    3662:	86 e6       	ldi	r24, 0x66	; 102
    3664:	91 e3       	ldi	r25, 0x31	; 49
    3666:	8b 8f       	std	Y+27, r24	; 0x1b
    3668:	9c 8f       	std	Y+28, r25	; 0x1c
    366a:	42 c0       	rjmp	.+132    	; 0x36f0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    366c:	00 3b       	cpi	r16, 0xB0	; 176
    366e:	e8 e0       	ldi	r30, 0x08	; 8
    3670:	1e 07       	cpc	r17, r30
    3672:	69 f4       	brne	.+26     	; 0x368e <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    3674:	88 e7       	ldi	r24, 0x78	; 120
    3676:	91 e3       	ldi	r25, 0x31	; 49
    3678:	8f 8b       	std	Y+23, r24	; 0x17
    367a:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    367c:	8e e6       	ldi	r24, 0x6E	; 110
    367e:	91 e3       	ldi	r25, 0x31	; 49
    3680:	89 8f       	std	Y+25, r24	; 0x19
    3682:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    3684:	84 e6       	ldi	r24, 0x64	; 100
    3686:	91 e3       	ldi	r25, 0x31	; 49
    3688:	8b 8f       	std	Y+27, r24	; 0x1b
    368a:	9c 8f       	std	Y+28, r25	; 0x1c
    368c:	31 c0       	rjmp	.+98     	; 0x36f0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    368e:	00 3a       	cpi	r16, 0xA0	; 160
    3690:	f9 e0       	ldi	r31, 0x09	; 9
    3692:	1f 07       	cpc	r17, r31
    3694:	69 f4       	brne	.+26     	; 0x36b0 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3696:	86 e7       	ldi	r24, 0x76	; 118
    3698:	91 e3       	ldi	r25, 0x31	; 49
    369a:	8f 8b       	std	Y+23, r24	; 0x17
    369c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    369e:	8c e6       	ldi	r24, 0x6C	; 108
    36a0:	91 e3       	ldi	r25, 0x31	; 49
    36a2:	89 8f       	std	Y+25, r24	; 0x19
    36a4:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    36a6:	82 e6       	ldi	r24, 0x62	; 98
    36a8:	91 e3       	ldi	r25, 0x31	; 49
    36aa:	8b 8f       	std	Y+27, r24	; 0x1b
    36ac:	9c 8f       	std	Y+28, r25	; 0x1c
    36ae:	20 c0       	rjmp	.+64     	; 0x36f0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    36b0:	00 3b       	cpi	r16, 0xB0	; 176
    36b2:	89 e0       	ldi	r24, 0x09	; 9
    36b4:	18 07       	cpc	r17, r24
    36b6:	69 f4       	brne	.+26     	; 0x36d2 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    36b8:	84 e7       	ldi	r24, 0x74	; 116
    36ba:	91 e3       	ldi	r25, 0x31	; 49
    36bc:	8f 8b       	std	Y+23, r24	; 0x17
    36be:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    36c0:	8a e6       	ldi	r24, 0x6A	; 106
    36c2:	91 e3       	ldi	r25, 0x31	; 49
    36c4:	89 8f       	std	Y+25, r24	; 0x19
    36c6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    36c8:	80 e6       	ldi	r24, 0x60	; 96
    36ca:	91 e3       	ldi	r25, 0x31	; 49
    36cc:	8b 8f       	std	Y+27, r24	; 0x1b
    36ce:	9c 8f       	std	Y+28, r25	; 0x1c
    36d0:	0f c0       	rjmp	.+30     	; 0x36f0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    36d2:	00 3a       	cpi	r16, 0xA0	; 160
    36d4:	1a 40       	sbci	r17, 0x0A	; 10
    36d6:	61 f4       	brne	.+24     	; 0x36f0 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    36d8:	82 e7       	ldi	r24, 0x72	; 114
    36da:	91 e3       	ldi	r25, 0x31	; 49
    36dc:	8f 8b       	std	Y+23, r24	; 0x17
    36de:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    36e0:	88 e6       	ldi	r24, 0x68	; 104
    36e2:	91 e3       	ldi	r25, 0x31	; 49
    36e4:	89 8f       	std	Y+25, r24	; 0x19
    36e6:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    36e8:	8e e5       	ldi	r24, 0x5E	; 94
    36ea:	91 e3       	ldi	r25, 0x31	; 49
    36ec:	8b 8f       	std	Y+27, r24	; 0x1b
    36ee:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    36f0:	0f 89       	ldd	r16, Y+23	; 0x17
    36f2:	18 8d       	ldd	r17, Y+24	; 0x18
    36f4:	84 e6       	ldi	r24, 0x64	; 100
    36f6:	90 e0       	ldi	r25, 0x00	; 0
    36f8:	0e 94 85 18 	call	0x310a	; 0x310a <_Znaj>
    36fc:	f8 01       	movw	r30, r16
    36fe:	80 83       	st	Z, r24
    3700:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3702:	e9 8d       	ldd	r30, Y+25	; 0x19
    3704:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3706:	10 82       	st	Z, r1
    3708:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    370a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    370c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    370e:	10 82       	st	Z, r1
    3710:	11 82       	std	Z+1, r1	; 0x01
}
    3712:	df 91       	pop	r29
    3714:	cf 91       	pop	r28
    3716:	1f 91       	pop	r17
    3718:	0f 91       	pop	r16
    371a:	ff 90       	pop	r15
    371c:	ef 90       	pop	r14
    371e:	08 95       	ret

00003720 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3720:	1f 92       	push	r1
    3722:	0f 92       	push	r0
    3724:	0f b6       	in	r0, 0x3f	; 63
    3726:	0f 92       	push	r0
    3728:	11 24       	eor	r1, r1
    372a:	08 b6       	in	r0, 0x38	; 56
    372c:	0f 92       	push	r0
    372e:	18 be       	out	0x38, r1	; 56
    3730:	0b b6       	in	r0, 0x3b	; 59
    3732:	0f 92       	push	r0
    3734:	1b be       	out	0x3b, r1	; 59
    3736:	2f 93       	push	r18
    3738:	3f 93       	push	r19
    373a:	8f 93       	push	r24
    373c:	9f 93       	push	r25
    373e:	ef 93       	push	r30
    3740:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    3742:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3746:	e0 91 7a 31 	lds	r30, 0x317A	; 0x80317a <rcvC0_buffer>
    374a:	f0 91 7b 31 	lds	r31, 0x317B	; 0x80317b <rcvC0_buffer+0x1>
    374e:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvC0_write_index>
    3752:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvC0_write_index+0x1>
    3756:	e8 0f       	add	r30, r24
    3758:	f9 1f       	adc	r31, r25
    375a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    375c:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvC0_write_index>
    3760:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvC0_write_index+0x1>
    3764:	01 96       	adiw	r24, 0x01	; 1
    3766:	84 36       	cpi	r24, 0x64	; 100
    3768:	91 05       	cpc	r25, r1
    376a:	60 f4       	brcc	.+24     	; 0x3784 <__vector_25+0x64>
    376c:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <rcvC0_write_index>
    3770:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3774:	20 91 70 31 	lds	r18, 0x3170	; 0x803170 <rcvC0_read_index>
    3778:	30 91 71 31 	lds	r19, 0x3171	; 0x803171 <rcvC0_read_index+0x1>
    377c:	82 17       	cp	r24, r18
    377e:	93 07       	cpc	r25, r19
    3780:	f1 f4       	brne	.+60     	; 0x37be <__vector_25+0x9e>
    3782:	0c c0       	rjmp	.+24     	; 0x379c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    3784:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <rcvC0_write_index>
    3788:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    378c:	80 91 70 31 	lds	r24, 0x3170	; 0x803170 <rcvC0_read_index>
    3790:	90 91 71 31 	lds	r25, 0x3171	; 0x803171 <rcvC0_read_index+0x1>
    3794:	18 16       	cp	r1, r24
    3796:	19 06       	cpc	r1, r25
    3798:	91 f4       	brne	.+36     	; 0x37be <__vector_25+0x9e>
    379a:	0e c0       	rjmp	.+28     	; 0x37b8 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    379c:	01 96       	adiw	r24, 0x01	; 1
    379e:	84 36       	cpi	r24, 0x64	; 100
    37a0:	91 05       	cpc	r25, r1
    37a2:	28 f4       	brcc	.+10     	; 0x37ae <__vector_25+0x8e>
    37a4:	80 93 70 31 	sts	0x3170, r24	; 0x803170 <rcvC0_read_index>
    37a8:	90 93 71 31 	sts	0x3171, r25	; 0x803171 <rcvC0_read_index+0x1>
    37ac:	08 c0       	rjmp	.+16     	; 0x37be <__vector_25+0x9e>
			rcvC0_read_index = 0;
    37ae:	10 92 70 31 	sts	0x3170, r1	; 0x803170 <rcvC0_read_index>
    37b2:	10 92 71 31 	sts	0x3171, r1	; 0x803171 <rcvC0_read_index+0x1>
}
    37b6:	03 c0       	rjmp	.+6      	; 0x37be <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    37b8:	81 e0       	ldi	r24, 0x01	; 1
    37ba:	90 e0       	ldi	r25, 0x00	; 0
    37bc:	f3 cf       	rjmp	.-26     	; 0x37a4 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    37be:	ff 91       	pop	r31
    37c0:	ef 91       	pop	r30
    37c2:	9f 91       	pop	r25
    37c4:	8f 91       	pop	r24
    37c6:	3f 91       	pop	r19
    37c8:	2f 91       	pop	r18
    37ca:	0f 90       	pop	r0
    37cc:	0b be       	out	0x3b, r0	; 59
    37ce:	0f 90       	pop	r0
    37d0:	08 be       	out	0x38, r0	; 56
    37d2:	0f 90       	pop	r0
    37d4:	0f be       	out	0x3f, r0	; 63
    37d6:	0f 90       	pop	r0
    37d8:	1f 90       	pop	r1
    37da:	18 95       	reti

000037dc <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    37dc:	1f 92       	push	r1
    37de:	0f 92       	push	r0
    37e0:	0f b6       	in	r0, 0x3f	; 63
    37e2:	0f 92       	push	r0
    37e4:	11 24       	eor	r1, r1
    37e6:	08 b6       	in	r0, 0x38	; 56
    37e8:	0f 92       	push	r0
    37ea:	18 be       	out	0x38, r1	; 56
    37ec:	0b b6       	in	r0, 0x3b	; 59
    37ee:	0f 92       	push	r0
    37f0:	1b be       	out	0x3b, r1	; 59
    37f2:	2f 93       	push	r18
    37f4:	3f 93       	push	r19
    37f6:	8f 93       	push	r24
    37f8:	9f 93       	push	r25
    37fa:	ef 93       	push	r30
    37fc:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    37fe:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3802:	e0 91 78 31 	lds	r30, 0x3178	; 0x803178 <rcvC1_buffer>
    3806:	f0 91 79 31 	lds	r31, 0x3179	; 0x803179 <rcvC1_buffer+0x1>
    380a:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvC1_write_index>
    380e:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvC1_write_index+0x1>
    3812:	e8 0f       	add	r30, r24
    3814:	f9 1f       	adc	r31, r25
    3816:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3818:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvC1_write_index>
    381c:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvC1_write_index+0x1>
    3820:	01 96       	adiw	r24, 0x01	; 1
    3822:	84 36       	cpi	r24, 0x64	; 100
    3824:	91 05       	cpc	r25, r1
    3826:	60 f4       	brcc	.+24     	; 0x3840 <__vector_28+0x64>
    3828:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <rcvC1_write_index>
    382c:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3830:	20 91 6e 31 	lds	r18, 0x316E	; 0x80316e <rcvC1_read_index>
    3834:	30 91 6f 31 	lds	r19, 0x316F	; 0x80316f <rcvC1_read_index+0x1>
    3838:	82 17       	cp	r24, r18
    383a:	93 07       	cpc	r25, r19
    383c:	f1 f4       	brne	.+60     	; 0x387a <__vector_28+0x9e>
    383e:	0c c0       	rjmp	.+24     	; 0x3858 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    3840:	10 92 64 31 	sts	0x3164, r1	; 0x803164 <rcvC1_write_index>
    3844:	10 92 65 31 	sts	0x3165, r1	; 0x803165 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3848:	80 91 6e 31 	lds	r24, 0x316E	; 0x80316e <rcvC1_read_index>
    384c:	90 91 6f 31 	lds	r25, 0x316F	; 0x80316f <rcvC1_read_index+0x1>
    3850:	18 16       	cp	r1, r24
    3852:	19 06       	cpc	r1, r25
    3854:	91 f4       	brne	.+36     	; 0x387a <__vector_28+0x9e>
    3856:	0e c0       	rjmp	.+28     	; 0x3874 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3858:	01 96       	adiw	r24, 0x01	; 1
    385a:	84 36       	cpi	r24, 0x64	; 100
    385c:	91 05       	cpc	r25, r1
    385e:	28 f4       	brcc	.+10     	; 0x386a <__vector_28+0x8e>
    3860:	80 93 6e 31 	sts	0x316E, r24	; 0x80316e <rcvC1_read_index>
    3864:	90 93 6f 31 	sts	0x316F, r25	; 0x80316f <rcvC1_read_index+0x1>
    3868:	08 c0       	rjmp	.+16     	; 0x387a <__vector_28+0x9e>
	rcvC1_read_index = 0;
    386a:	10 92 6e 31 	sts	0x316E, r1	; 0x80316e <rcvC1_read_index>
    386e:	10 92 6f 31 	sts	0x316F, r1	; 0x80316f <rcvC1_read_index+0x1>
}
    3872:	03 c0       	rjmp	.+6      	; 0x387a <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3874:	81 e0       	ldi	r24, 0x01	; 1
    3876:	90 e0       	ldi	r25, 0x00	; 0
    3878:	f3 cf       	rjmp	.-26     	; 0x3860 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    387a:	ff 91       	pop	r31
    387c:	ef 91       	pop	r30
    387e:	9f 91       	pop	r25
    3880:	8f 91       	pop	r24
    3882:	3f 91       	pop	r19
    3884:	2f 91       	pop	r18
    3886:	0f 90       	pop	r0
    3888:	0b be       	out	0x3b, r0	; 59
    388a:	0f 90       	pop	r0
    388c:	08 be       	out	0x38, r0	; 56
    388e:	0f 90       	pop	r0
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	0f 90       	pop	r0
    3894:	1f 90       	pop	r1
    3896:	18 95       	reti

00003898 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3898:	1f 92       	push	r1
    389a:	0f 92       	push	r0
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	0f 92       	push	r0
    38a0:	11 24       	eor	r1, r1
    38a2:	08 b6       	in	r0, 0x38	; 56
    38a4:	0f 92       	push	r0
    38a6:	18 be       	out	0x38, r1	; 56
    38a8:	0b b6       	in	r0, 0x3b	; 59
    38aa:	0f 92       	push	r0
    38ac:	1b be       	out	0x3b, r1	; 59
    38ae:	2f 93       	push	r18
    38b0:	3f 93       	push	r19
    38b2:	8f 93       	push	r24
    38b4:	9f 93       	push	r25
    38b6:	ef 93       	push	r30
    38b8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    38ba:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    38be:	e0 91 76 31 	lds	r30, 0x3176	; 0x803176 <rcvD0_buffer>
    38c2:	f0 91 77 31 	lds	r31, 0x3177	; 0x803177 <rcvD0_buffer+0x1>
    38c6:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvC0_write_index>
    38ca:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvC0_write_index+0x1>
    38ce:	e8 0f       	add	r30, r24
    38d0:	f9 1f       	adc	r31, r25
    38d2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    38d4:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvD0_write_index>
    38d8:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvD0_write_index+0x1>
    38dc:	01 96       	adiw	r24, 0x01	; 1
    38de:	84 36       	cpi	r24, 0x64	; 100
    38e0:	91 05       	cpc	r25, r1
    38e2:	60 f4       	brcc	.+24     	; 0x38fc <__vector_88+0x64>
    38e4:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <rcvD0_write_index>
    38e8:	90 93 63 31 	sts	0x3163, r25	; 0x803163 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    38ec:	20 91 6c 31 	lds	r18, 0x316C	; 0x80316c <rcvD0_read_index>
    38f0:	30 91 6d 31 	lds	r19, 0x316D	; 0x80316d <rcvD0_read_index+0x1>
    38f4:	82 17       	cp	r24, r18
    38f6:	93 07       	cpc	r25, r19
    38f8:	f1 f4       	brne	.+60     	; 0x3936 <__vector_88+0x9e>
    38fa:	0c c0       	rjmp	.+24     	; 0x3914 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    38fc:	10 92 62 31 	sts	0x3162, r1	; 0x803162 <rcvD0_write_index>
    3900:	10 92 63 31 	sts	0x3163, r1	; 0x803163 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3904:	80 91 6c 31 	lds	r24, 0x316C	; 0x80316c <rcvD0_read_index>
    3908:	90 91 6d 31 	lds	r25, 0x316D	; 0x80316d <rcvD0_read_index+0x1>
    390c:	18 16       	cp	r1, r24
    390e:	19 06       	cpc	r1, r25
    3910:	91 f4       	brne	.+36     	; 0x3936 <__vector_88+0x9e>
    3912:	0e c0       	rjmp	.+28     	; 0x3930 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3914:	01 96       	adiw	r24, 0x01	; 1
    3916:	84 36       	cpi	r24, 0x64	; 100
    3918:	91 05       	cpc	r25, r1
    391a:	28 f4       	brcc	.+10     	; 0x3926 <__vector_88+0x8e>
    391c:	80 93 6c 31 	sts	0x316C, r24	; 0x80316c <rcvD0_read_index>
    3920:	90 93 6d 31 	sts	0x316D, r25	; 0x80316d <rcvD0_read_index+0x1>
    3924:	08 c0       	rjmp	.+16     	; 0x3936 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3926:	10 92 6c 31 	sts	0x316C, r1	; 0x80316c <rcvD0_read_index>
    392a:	10 92 6d 31 	sts	0x316D, r1	; 0x80316d <rcvD0_read_index+0x1>
}
    392e:	03 c0       	rjmp	.+6      	; 0x3936 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3930:	81 e0       	ldi	r24, 0x01	; 1
    3932:	90 e0       	ldi	r25, 0x00	; 0
    3934:	f3 cf       	rjmp	.-26     	; 0x391c <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    3936:	ff 91       	pop	r31
    3938:	ef 91       	pop	r30
    393a:	9f 91       	pop	r25
    393c:	8f 91       	pop	r24
    393e:	3f 91       	pop	r19
    3940:	2f 91       	pop	r18
    3942:	0f 90       	pop	r0
    3944:	0b be       	out	0x3b, r0	; 59
    3946:	0f 90       	pop	r0
    3948:	08 be       	out	0x38, r0	; 56
    394a:	0f 90       	pop	r0
    394c:	0f be       	out	0x3f, r0	; 63
    394e:	0f 90       	pop	r0
    3950:	1f 90       	pop	r1
    3952:	18 95       	reti

00003954 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    3954:	1f 92       	push	r1
    3956:	0f 92       	push	r0
    3958:	0f b6       	in	r0, 0x3f	; 63
    395a:	0f 92       	push	r0
    395c:	11 24       	eor	r1, r1
    395e:	08 b6       	in	r0, 0x38	; 56
    3960:	0f 92       	push	r0
    3962:	18 be       	out	0x38, r1	; 56
    3964:	0b b6       	in	r0, 0x3b	; 59
    3966:	0f 92       	push	r0
    3968:	1b be       	out	0x3b, r1	; 59
    396a:	2f 93       	push	r18
    396c:	3f 93       	push	r19
    396e:	8f 93       	push	r24
    3970:	9f 93       	push	r25
    3972:	ef 93       	push	r30
    3974:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3976:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    397a:	e0 91 74 31 	lds	r30, 0x3174	; 0x803174 <rcvD1_buffer>
    397e:	f0 91 75 31 	lds	r31, 0x3175	; 0x803175 <rcvD1_buffer+0x1>
    3982:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvD1_write_index>
    3986:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvD1_write_index+0x1>
    398a:	e8 0f       	add	r30, r24
    398c:	f9 1f       	adc	r31, r25
    398e:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3990:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvD1_write_index>
    3994:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvD1_write_index+0x1>
    3998:	01 96       	adiw	r24, 0x01	; 1
    399a:	84 36       	cpi	r24, 0x64	; 100
    399c:	91 05       	cpc	r25, r1
    399e:	60 f4       	brcc	.+24     	; 0x39b8 <__vector_91+0x64>
    39a0:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvD1_write_index>
    39a4:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    39a8:	20 91 6a 31 	lds	r18, 0x316A	; 0x80316a <rcvD1_read_index>
    39ac:	30 91 6b 31 	lds	r19, 0x316B	; 0x80316b <rcvD1_read_index+0x1>
    39b0:	82 17       	cp	r24, r18
    39b2:	93 07       	cpc	r25, r19
    39b4:	f1 f4       	brne	.+60     	; 0x39f2 <__vector_91+0x9e>
    39b6:	0c c0       	rjmp	.+24     	; 0x39d0 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    39b8:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvD1_write_index>
    39bc:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    39c0:	80 91 6a 31 	lds	r24, 0x316A	; 0x80316a <rcvD1_read_index>
    39c4:	90 91 6b 31 	lds	r25, 0x316B	; 0x80316b <rcvD1_read_index+0x1>
    39c8:	18 16       	cp	r1, r24
    39ca:	19 06       	cpc	r1, r25
    39cc:	91 f4       	brne	.+36     	; 0x39f2 <__vector_91+0x9e>
    39ce:	0e c0       	rjmp	.+28     	; 0x39ec <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    39d0:	01 96       	adiw	r24, 0x01	; 1
    39d2:	84 36       	cpi	r24, 0x64	; 100
    39d4:	91 05       	cpc	r25, r1
    39d6:	28 f4       	brcc	.+10     	; 0x39e2 <__vector_91+0x8e>
    39d8:	80 93 6a 31 	sts	0x316A, r24	; 0x80316a <rcvD1_read_index>
    39dc:	90 93 6b 31 	sts	0x316B, r25	; 0x80316b <rcvD1_read_index+0x1>
    39e0:	08 c0       	rjmp	.+16     	; 0x39f2 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    39e2:	10 92 6a 31 	sts	0x316A, r1	; 0x80316a <rcvD1_read_index>
    39e6:	10 92 6b 31 	sts	0x316B, r1	; 0x80316b <rcvD1_read_index+0x1>
}
    39ea:	03 c0       	rjmp	.+6      	; 0x39f2 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    39ec:	81 e0       	ldi	r24, 0x01	; 1
    39ee:	90 e0       	ldi	r25, 0x00	; 0
    39f0:	f3 cf       	rjmp	.-26     	; 0x39d8 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    39f2:	ff 91       	pop	r31
    39f4:	ef 91       	pop	r30
    39f6:	9f 91       	pop	r25
    39f8:	8f 91       	pop	r24
    39fa:	3f 91       	pop	r19
    39fc:	2f 91       	pop	r18
    39fe:	0f 90       	pop	r0
    3a00:	0b be       	out	0x3b, r0	; 59
    3a02:	0f 90       	pop	r0
    3a04:	08 be       	out	0x38, r0	; 56
    3a06:	0f 90       	pop	r0
    3a08:	0f be       	out	0x3f, r0	; 63
    3a0a:	0f 90       	pop	r0
    3a0c:	1f 90       	pop	r1
    3a0e:	18 95       	reti

00003a10 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3a10:	1f 92       	push	r1
    3a12:	0f 92       	push	r0
    3a14:	0f b6       	in	r0, 0x3f	; 63
    3a16:	0f 92       	push	r0
    3a18:	11 24       	eor	r1, r1
    3a1a:	08 b6       	in	r0, 0x38	; 56
    3a1c:	0f 92       	push	r0
    3a1e:	18 be       	out	0x38, r1	; 56
    3a20:	0b b6       	in	r0, 0x3b	; 59
    3a22:	0f 92       	push	r0
    3a24:	1b be       	out	0x3b, r1	; 59
    3a26:	2f 93       	push	r18
    3a28:	3f 93       	push	r19
    3a2a:	8f 93       	push	r24
    3a2c:	9f 93       	push	r25
    3a2e:	ef 93       	push	r30
    3a30:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    3a32:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3a36:	e0 91 72 31 	lds	r30, 0x3172	; 0x803172 <rcvE0_buffer>
    3a3a:	f0 91 73 31 	lds	r31, 0x3173	; 0x803173 <rcvE0_buffer+0x1>
    3a3e:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvE0_write_index>
    3a42:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvE0_write_index+0x1>
    3a46:	e8 0f       	add	r30, r24
    3a48:	f9 1f       	adc	r31, r25
    3a4a:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3a4c:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvE0_write_index>
    3a50:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvE0_write_index+0x1>
    3a54:	01 96       	adiw	r24, 0x01	; 1
    3a56:	84 36       	cpi	r24, 0x64	; 100
    3a58:	91 05       	cpc	r25, r1
    3a5a:	60 f4       	brcc	.+24     	; 0x3a74 <__vector_58+0x64>
    3a5c:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvE0_write_index>
    3a60:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3a64:	20 91 68 31 	lds	r18, 0x3168	; 0x803168 <rcvE0_read_index>
    3a68:	30 91 69 31 	lds	r19, 0x3169	; 0x803169 <rcvE0_read_index+0x1>
    3a6c:	82 17       	cp	r24, r18
    3a6e:	93 07       	cpc	r25, r19
    3a70:	f1 f4       	brne	.+60     	; 0x3aae <__vector_58+0x9e>
    3a72:	0c c0       	rjmp	.+24     	; 0x3a8c <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    3a74:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvE0_write_index>
    3a78:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3a7c:	80 91 68 31 	lds	r24, 0x3168	; 0x803168 <rcvE0_read_index>
    3a80:	90 91 69 31 	lds	r25, 0x3169	; 0x803169 <rcvE0_read_index+0x1>
    3a84:	18 16       	cp	r1, r24
    3a86:	19 06       	cpc	r1, r25
    3a88:	91 f4       	brne	.+36     	; 0x3aae <__vector_58+0x9e>
    3a8a:	0e c0       	rjmp	.+28     	; 0x3aa8 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3a8c:	01 96       	adiw	r24, 0x01	; 1
    3a8e:	84 36       	cpi	r24, 0x64	; 100
    3a90:	91 05       	cpc	r25, r1
    3a92:	28 f4       	brcc	.+10     	; 0x3a9e <__vector_58+0x8e>
    3a94:	80 93 68 31 	sts	0x3168, r24	; 0x803168 <rcvE0_read_index>
    3a98:	90 93 69 31 	sts	0x3169, r25	; 0x803169 <rcvE0_read_index+0x1>
    3a9c:	08 c0       	rjmp	.+16     	; 0x3aae <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3a9e:	10 92 68 31 	sts	0x3168, r1	; 0x803168 <rcvE0_read_index>
    3aa2:	10 92 69 31 	sts	0x3169, r1	; 0x803169 <rcvE0_read_index+0x1>
}
    3aa6:	03 c0       	rjmp	.+6      	; 0x3aae <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3aa8:	81 e0       	ldi	r24, 0x01	; 1
    3aaa:	90 e0       	ldi	r25, 0x00	; 0
    3aac:	f3 cf       	rjmp	.-26     	; 0x3a94 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3aae:	ff 91       	pop	r31
    3ab0:	ef 91       	pop	r30
    3ab2:	9f 91       	pop	r25
    3ab4:	8f 91       	pop	r24
    3ab6:	3f 91       	pop	r19
    3ab8:	2f 91       	pop	r18
    3aba:	0f 90       	pop	r0
    3abc:	0b be       	out	0x3b, r0	; 59
    3abe:	0f 90       	pop	r0
    3ac0:	08 be       	out	0x38, r0	; 56
    3ac2:	0f 90       	pop	r0
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	0f 90       	pop	r0
    3ac8:	1f 90       	pop	r1
    3aca:	18 95       	reti

00003acc <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3acc:	fc 01       	movw	r30, r24
    3ace:	84 81       	ldd	r24, Z+4	; 0x04
    3ad0:	95 81       	ldd	r25, Z+5	; 0x05
    3ad2:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
		}
    3ad6:	90 e0       	ldi	r25, 0x00	; 0
    3ad8:	08 95       	ret

00003ada <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3ada:	fc 01       	movw	r30, r24
    3adc:	84 81       	ldd	r24, Z+4	; 0x04
    3ade:	95 81       	ldd	r25, Z+5	; 0x05
    3ae0:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
    3ae4:	91 e0       	ldi	r25, 0x01	; 1
    3ae6:	81 11       	cpse	r24, r1
    3ae8:	01 c0       	rjmp	.+2      	; 0x3aec <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    3aea:	90 e0       	ldi	r25, 0x00	; 0
		}
    3aec:	89 2f       	mov	r24, r25
    3aee:	08 95       	ret

00003af0 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3af0:	fc 01       	movw	r30, r24
    3af2:	84 81       	ldd	r24, Z+4	; 0x04
    3af4:	95 81       	ldd	r25, Z+5	; 0x05
    3af6:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
    3afa:	91 e0       	ldi	r25, 0x01	; 1
    3afc:	81 11       	cpse	r24, r1
    3afe:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b00:	89 2f       	mov	r24, r25
    3b02:	08 95       	ret

00003b04 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3b04:	fc 01       	movw	r30, r24
    3b06:	84 81       	ldd	r24, Z+4	; 0x04
    3b08:	95 81       	ldd	r25, Z+5	; 0x05
    3b0a:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
		}
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
    3b10:	08 95       	ret

00003b12 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3b12:	fc 01       	movw	r30, r24
    3b14:	84 81       	ldd	r24, Z+4	; 0x04
    3b16:	95 81       	ldd	r25, Z+5	; 0x05
    3b18:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
    3b1c:	91 e0       	ldi	r25, 0x01	; 1
    3b1e:	81 11       	cpse	r24, r1
    3b20:	01 c0       	rjmp	.+2      	; 0x3b24 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    3b22:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b24:	89 2f       	mov	r24, r25
    3b26:	08 95       	ret

00003b28 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    3b28:	fc 01       	movw	r30, r24
    3b2a:	84 81       	ldd	r24, Z+4	; 0x04
    3b2c:	95 81       	ldd	r25, Z+5	; 0x05
    3b2e:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxQueueMessagesWaitingFromISR>
    3b32:	91 e0       	ldi	r25, 0x01	; 1
    3b34:	81 11       	cpse	r24, r1
    3b36:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b38:	89 2f       	mov	r24, r25
    3b3a:	08 95       	ret

00003b3c <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3b3c:	fc 01       	movw	r30, r24
    3b3e:	84 81       	ldd	r24, Z+4	; 0x04
    3b40:	95 81       	ldd	r25, Z+5	; 0x05
    3b42:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
		}
    3b46:	90 e0       	ldi	r25, 0x00	; 0
    3b48:	08 95       	ret

00003b4a <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3b4a:	fc 01       	movw	r30, r24
    3b4c:	84 81       	ldd	r24, Z+4	; 0x04
    3b4e:	95 81       	ldd	r25, Z+5	; 0x05
    3b50:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
    3b54:	91 e0       	ldi	r25, 0x01	; 1
    3b56:	81 11       	cpse	r24, r1
    3b58:	01 c0       	rjmp	.+2      	; 0x3b5c <_ZN9frt_queueIjE9not_emptyEv+0x12>
    3b5a:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b5c:	89 2f       	mov	r24, r25
    3b5e:	08 95       	ret

00003b60 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3b60:	fc 01       	movw	r30, r24
    3b62:	84 81       	ldd	r24, Z+4	; 0x04
    3b64:	95 81       	ldd	r25, Z+5	; 0x05
    3b66:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
    3b6a:	91 e0       	ldi	r25, 0x01	; 1
    3b6c:	81 11       	cpse	r24, r1
    3b6e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b70:	89 2f       	mov	r24, r25
    3b72:	08 95       	ret

00003b74 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3b74:	fc 01       	movw	r30, r24
    3b76:	84 81       	ldd	r24, Z+4	; 0x04
    3b78:	95 81       	ldd	r25, Z+5	; 0x05
    3b7a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
		}
    3b7e:	90 e0       	ldi	r25, 0x00	; 0
    3b80:	08 95       	ret

00003b82 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3b82:	fc 01       	movw	r30, r24
    3b84:	84 81       	ldd	r24, Z+4	; 0x04
    3b86:	95 81       	ldd	r25, Z+5	; 0x05
    3b88:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
    3b8c:	91 e0       	ldi	r25, 0x01	; 1
    3b8e:	81 11       	cpse	r24, r1
    3b90:	01 c0       	rjmp	.+2      	; 0x3b94 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3b92:	90 e0       	ldi	r25, 0x00	; 0
		}
    3b94:	89 2f       	mov	r24, r25
    3b96:	08 95       	ret

00003b98 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3b98:	fc 01       	movw	r30, r24
    3b9a:	84 81       	ldd	r24, Z+4	; 0x04
    3b9c:	95 81       	ldd	r25, Z+5	; 0x05
    3b9e:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <uxQueueMessagesWaiting>
    3ba2:	91 e0       	ldi	r25, 0x01	; 1
    3ba4:	81 11       	cpse	r24, r1
    3ba6:	90 e0       	ldi	r25, 0x00	; 0
		}
    3ba8:	89 2f       	mov	r24, r25
    3baa:	08 95       	ret

00003bac <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3bac:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3bae:	01 e0       	ldi	r16, 0x01	; 1
    3bb0:	2f ef       	ldi	r18, 0xFF	; 255
    3bb2:	3f ef       	ldi	r19, 0xFF	; 255
    3bb4:	a9 01       	movw	r20, r18
    3bb6:	fc 01       	movw	r30, r24
    3bb8:	84 81       	ldd	r24, Z+4	; 0x04
    3bba:	95 81       	ldd	r25, Z+5	; 0x05
    3bbc:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
}
    3bc0:	0f 91       	pop	r16
    3bc2:	08 95       	ret

00003bc4 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3bc4:	0f 93       	push	r16
    3bc6:	cf 93       	push	r28
    3bc8:	df 93       	push	r29
    3bca:	1f 92       	push	r1
    3bcc:	1f 92       	push	r1
    3bce:	cd b7       	in	r28, 0x3d	; 61
    3bd0:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3bd2:	01 e0       	ldi	r16, 0x01	; 1
    3bd4:	2f ef       	ldi	r18, 0xFF	; 255
    3bd6:	3f ef       	ldi	r19, 0xFF	; 255
    3bd8:	a9 01       	movw	r20, r18
    3bda:	be 01       	movw	r22, r28
    3bdc:	6f 5f       	subi	r22, 0xFF	; 255
    3bde:	7f 4f       	sbci	r23, 0xFF	; 255
    3be0:	fc 01       	movw	r30, r24
    3be2:	84 81       	ldd	r24, Z+4	; 0x04
    3be4:	95 81       	ldd	r25, Z+5	; 0x05
    3be6:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
	return (recv_item);
}
    3bea:	89 81       	ldd	r24, Y+1	; 0x01
    3bec:	9a 81       	ldd	r25, Y+2	; 0x02
    3bee:	0f 90       	pop	r0
    3bf0:	0f 90       	pop	r0
    3bf2:	df 91       	pop	r29
    3bf4:	cf 91       	pop	r28
    3bf6:	0f 91       	pop	r16
    3bf8:	08 95       	ret

00003bfa <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3bfa:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3bfc:	00 e0       	ldi	r16, 0x00	; 0
    3bfe:	2f ef       	ldi	r18, 0xFF	; 255
    3c00:	3f ef       	ldi	r19, 0xFF	; 255
    3c02:	a9 01       	movw	r20, r18
    3c04:	fc 01       	movw	r30, r24
    3c06:	84 81       	ldd	r24, Z+4	; 0x04
    3c08:	95 81       	ldd	r25, Z+5	; 0x05
    3c0a:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
}
    3c0e:	0f 91       	pop	r16
    3c10:	08 95       	ret

00003c12 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3c12:	0f 93       	push	r16
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	1f 92       	push	r1
    3c1a:	1f 92       	push	r1
    3c1c:	cd b7       	in	r28, 0x3d	; 61
    3c1e:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3c20:	00 e0       	ldi	r16, 0x00	; 0
    3c22:	2f ef       	ldi	r18, 0xFF	; 255
    3c24:	3f ef       	ldi	r19, 0xFF	; 255
    3c26:	a9 01       	movw	r20, r18
    3c28:	be 01       	movw	r22, r28
    3c2a:	6f 5f       	subi	r22, 0xFF	; 255
    3c2c:	7f 4f       	sbci	r23, 0xFF	; 255
    3c2e:	fc 01       	movw	r30, r24
    3c30:	84 81       	ldd	r24, Z+4	; 0x04
    3c32:	95 81       	ldd	r25, Z+5	; 0x05
    3c34:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
	return (recv_item);
}
    3c38:	89 81       	ldd	r24, Y+1	; 0x01
    3c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3c:	0f 90       	pop	r0
    3c3e:	0f 90       	pop	r0
    3c40:	df 91       	pop	r29
    3c42:	cf 91       	pop	r28
    3c44:	0f 91       	pop	r16
    3c46:	08 95       	ret

00003c48 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3c48:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3c4a:	01 e0       	ldi	r16, 0x01	; 1
    3c4c:	2f ef       	ldi	r18, 0xFF	; 255
    3c4e:	3f ef       	ldi	r19, 0xFF	; 255
    3c50:	a9 01       	movw	r20, r18
    3c52:	fc 01       	movw	r30, r24
    3c54:	84 81       	ldd	r24, Z+4	; 0x04
    3c56:	95 81       	ldd	r25, Z+5	; 0x05
    3c58:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
}
    3c5c:	0f 91       	pop	r16
    3c5e:	08 95       	ret

00003c60 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3c60:	0f 93       	push	r16
    3c62:	cf 93       	push	r28
    3c64:	df 93       	push	r29
    3c66:	1f 92       	push	r1
    3c68:	1f 92       	push	r1
    3c6a:	cd b7       	in	r28, 0x3d	; 61
    3c6c:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3c6e:	01 e0       	ldi	r16, 0x01	; 1
    3c70:	2f ef       	ldi	r18, 0xFF	; 255
    3c72:	3f ef       	ldi	r19, 0xFF	; 255
    3c74:	a9 01       	movw	r20, r18
    3c76:	be 01       	movw	r22, r28
    3c78:	6f 5f       	subi	r22, 0xFF	; 255
    3c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c7c:	fc 01       	movw	r30, r24
    3c7e:	84 81       	ldd	r24, Z+4	; 0x04
    3c80:	95 81       	ldd	r25, Z+5	; 0x05
    3c82:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
	return (recv_item);
}
    3c86:	89 81       	ldd	r24, Y+1	; 0x01
    3c88:	9a 81       	ldd	r25, Y+2	; 0x02
    3c8a:	0f 90       	pop	r0
    3c8c:	0f 90       	pop	r0
    3c8e:	df 91       	pop	r29
    3c90:	cf 91       	pop	r28
    3c92:	0f 91       	pop	r16
    3c94:	08 95       	ret

00003c96 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3c96:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3c98:	00 e0       	ldi	r16, 0x00	; 0
    3c9a:	2f ef       	ldi	r18, 0xFF	; 255
    3c9c:	3f ef       	ldi	r19, 0xFF	; 255
    3c9e:	a9 01       	movw	r20, r18
    3ca0:	fc 01       	movw	r30, r24
    3ca2:	84 81       	ldd	r24, Z+4	; 0x04
    3ca4:	95 81       	ldd	r25, Z+5	; 0x05
    3ca6:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
}
    3caa:	0f 91       	pop	r16
    3cac:	08 95       	ret

00003cae <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3cae:	0f 93       	push	r16
    3cb0:	cf 93       	push	r28
    3cb2:	df 93       	push	r29
    3cb4:	1f 92       	push	r1
    3cb6:	1f 92       	push	r1
    3cb8:	cd b7       	in	r28, 0x3d	; 61
    3cba:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3cbc:	00 e0       	ldi	r16, 0x00	; 0
    3cbe:	2f ef       	ldi	r18, 0xFF	; 255
    3cc0:	3f ef       	ldi	r19, 0xFF	; 255
    3cc2:	a9 01       	movw	r20, r18
    3cc4:	be 01       	movw	r22, r28
    3cc6:	6f 5f       	subi	r22, 0xFF	; 255
    3cc8:	7f 4f       	sbci	r23, 0xFF	; 255
    3cca:	fc 01       	movw	r30, r24
    3ccc:	84 81       	ldd	r24, Z+4	; 0x04
    3cce:	95 81       	ldd	r25, Z+5	; 0x05
    3cd0:	0e 94 9f 0d 	call	0x1b3e	; 0x1b3e <xQueueGenericReceive>
	return (recv_item);
}
    3cd4:	89 81       	ldd	r24, Y+1	; 0x01
    3cd6:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	df 91       	pop	r29
    3cde:	cf 91       	pop	r28
    3ce0:	0f 91       	pop	r16
    3ce2:	08 95       	ret

00003ce4 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3ce4:	cf 93       	push	r28
    3ce6:	df 93       	push	r29
    3ce8:	1f 92       	push	r1
    3cea:	cd b7       	in	r28, 0x3d	; 61
    3cec:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3cee:	ae 01       	movw	r20, r28
    3cf0:	4f 5f       	subi	r20, 0xFF	; 255
    3cf2:	5f 4f       	sbci	r21, 0xFF	; 255
    3cf4:	fc 01       	movw	r30, r24
    3cf6:	84 81       	ldd	r24, Z+4	; 0x04
    3cf8:	95 81       	ldd	r25, Z+5	; 0x05
    3cfa:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueReceiveFromISR>
}
    3cfe:	0f 90       	pop	r0
    3d00:	df 91       	pop	r29
    3d02:	cf 91       	pop	r28
    3d04:	08 95       	ret

00003d06 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	00 d0       	rcall	.+0      	; 0x3d0c <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3d0c:	cd b7       	in	r28, 0x3d	; 61
    3d0e:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3d10:	ae 01       	movw	r20, r28
    3d12:	4d 5f       	subi	r20, 0xFD	; 253
    3d14:	5f 4f       	sbci	r21, 0xFF	; 255
    3d16:	be 01       	movw	r22, r28
    3d18:	6f 5f       	subi	r22, 0xFF	; 255
    3d1a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d1c:	fc 01       	movw	r30, r24
    3d1e:	84 81       	ldd	r24, Z+4	; 0x04
    3d20:	95 81       	ldd	r25, Z+5	; 0x05
    3d22:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueReceiveFromISR>
	return (recv_item);
}
    3d26:	89 81       	ldd	r24, Y+1	; 0x01
    3d28:	9a 81       	ldd	r25, Y+2	; 0x02
    3d2a:	23 96       	adiw	r28, 0x03	; 3
    3d2c:	cd bf       	out	0x3d, r28	; 61
    3d2e:	de bf       	out	0x3e, r29	; 62
    3d30:	df 91       	pop	r29
    3d32:	cf 91       	pop	r28
    3d34:	08 95       	ret

00003d36 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3d36:	cf 93       	push	r28
    3d38:	df 93       	push	r29
    3d3a:	1f 92       	push	r1
    3d3c:	cd b7       	in	r28, 0x3d	; 61
    3d3e:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3d40:	ae 01       	movw	r20, r28
    3d42:	4f 5f       	subi	r20, 0xFF	; 255
    3d44:	5f 4f       	sbci	r21, 0xFF	; 255
    3d46:	fc 01       	movw	r30, r24
    3d48:	84 81       	ldd	r24, Z+4	; 0x04
    3d4a:	95 81       	ldd	r25, Z+5	; 0x05
    3d4c:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueReceiveFromISR>
}
    3d50:	0f 90       	pop	r0
    3d52:	df 91       	pop	r29
    3d54:	cf 91       	pop	r28
    3d56:	08 95       	ret

00003d58 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3d58:	cf 93       	push	r28
    3d5a:	df 93       	push	r29
    3d5c:	00 d0       	rcall	.+0      	; 0x3d5e <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3d5e:	cd b7       	in	r28, 0x3d	; 61
    3d60:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3d62:	ae 01       	movw	r20, r28
    3d64:	4d 5f       	subi	r20, 0xFD	; 253
    3d66:	5f 4f       	sbci	r21, 0xFF	; 255
    3d68:	be 01       	movw	r22, r28
    3d6a:	6f 5f       	subi	r22, 0xFF	; 255
    3d6c:	7f 4f       	sbci	r23, 0xFF	; 255
    3d6e:	fc 01       	movw	r30, r24
    3d70:	84 81       	ldd	r24, Z+4	; 0x04
    3d72:	95 81       	ldd	r25, Z+5	; 0x05
    3d74:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <xQueueReceiveFromISR>
	return (recv_item);
}
    3d78:	89 81       	ldd	r24, Y+1	; 0x01
    3d7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3d7c:	23 96       	adiw	r28, 0x03	; 3
    3d7e:	cd bf       	out	0x3d, r28	; 61
    3d80:	de bf       	out	0x3e, r29	; 62
    3d82:	df 91       	pop	r29
    3d84:	cf 91       	pop	r28
    3d86:	08 95       	ret

00003d88 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3d88:	cf 93       	push	r28
    3d8a:	df 93       	push	r29
    3d8c:	1f 92       	push	r1
    3d8e:	cd b7       	in	r28, 0x3d	; 61
    3d90:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3d92:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3d94:	21 e0       	ldi	r18, 0x01	; 1
    3d96:	ae 01       	movw	r20, r28
    3d98:	4f 5f       	subi	r20, 0xFF	; 255
    3d9a:	5f 4f       	sbci	r21, 0xFF	; 255
    3d9c:	fc 01       	movw	r30, r24
    3d9e:	84 81       	ldd	r24, Z+4	; 0x04
    3da0:	95 81       	ldd	r25, Z+5	; 0x05
    3da2:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3da6:	91 e0       	ldi	r25, 0x01	; 1
    3da8:	81 11       	cpse	r24, r1
    3daa:	01 c0       	rjmp	.+2      	; 0x3dae <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3dac:	90 e0       	ldi	r25, 0x00	; 0
}
    3dae:	89 2f       	mov	r24, r25
    3db0:	0f 90       	pop	r0
    3db2:	df 91       	pop	r29
    3db4:	cf 91       	pop	r28
    3db6:	08 95       	ret

00003db8 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3db8:	cf 93       	push	r28
    3dba:	df 93       	push	r29
    3dbc:	1f 92       	push	r1
    3dbe:	cd b7       	in	r28, 0x3d	; 61
    3dc0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3dc2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3dc4:	20 e0       	ldi	r18, 0x00	; 0
    3dc6:	ae 01       	movw	r20, r28
    3dc8:	4f 5f       	subi	r20, 0xFF	; 255
    3dca:	5f 4f       	sbci	r21, 0xFF	; 255
    3dcc:	fc 01       	movw	r30, r24
    3dce:	84 81       	ldd	r24, Z+4	; 0x04
    3dd0:	95 81       	ldd	r25, Z+5	; 0x05
    3dd2:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3dd6:	91 e0       	ldi	r25, 0x01	; 1
    3dd8:	81 11       	cpse	r24, r1
    3dda:	01 c0       	rjmp	.+2      	; 0x3dde <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3ddc:	90 e0       	ldi	r25, 0x00	; 0
}
    3dde:	89 2f       	mov	r24, r25
    3de0:	0f 90       	pop	r0
    3de2:	df 91       	pop	r29
    3de4:	cf 91       	pop	r28
    3de6:	08 95       	ret

00003de8 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3de8:	cf 93       	push	r28
    3dea:	df 93       	push	r29
    3dec:	1f 92       	push	r1
    3dee:	cd b7       	in	r28, 0x3d	; 61
    3df0:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3df2:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3df4:	21 e0       	ldi	r18, 0x01	; 1
    3df6:	ae 01       	movw	r20, r28
    3df8:	4f 5f       	subi	r20, 0xFF	; 255
    3dfa:	5f 4f       	sbci	r21, 0xFF	; 255
    3dfc:	fc 01       	movw	r30, r24
    3dfe:	84 81       	ldd	r24, Z+4	; 0x04
    3e00:	95 81       	ldd	r25, Z+5	; 0x05
    3e02:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3e06:	91 e0       	ldi	r25, 0x01	; 1
    3e08:	81 11       	cpse	r24, r1
    3e0a:	01 c0       	rjmp	.+2      	; 0x3e0e <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3e0c:	90 e0       	ldi	r25, 0x00	; 0
}
    3e0e:	89 2f       	mov	r24, r25
    3e10:	0f 90       	pop	r0
    3e12:	df 91       	pop	r29
    3e14:	cf 91       	pop	r28
    3e16:	08 95       	ret

00003e18 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3e18:	cf 93       	push	r28
    3e1a:	df 93       	push	r29
    3e1c:	1f 92       	push	r1
    3e1e:	cd b7       	in	r28, 0x3d	; 61
    3e20:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3e22:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3e24:	20 e0       	ldi	r18, 0x00	; 0
    3e26:	ae 01       	movw	r20, r28
    3e28:	4f 5f       	subi	r20, 0xFF	; 255
    3e2a:	5f 4f       	sbci	r21, 0xFF	; 255
    3e2c:	fc 01       	movw	r30, r24
    3e2e:	84 81       	ldd	r24, Z+4	; 0x04
    3e30:	95 81       	ldd	r25, Z+5	; 0x05
    3e32:	0e 94 73 0d 	call	0x1ae6	; 0x1ae6 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3e36:	91 e0       	ldi	r25, 0x01	; 1
    3e38:	81 11       	cpse	r24, r1
    3e3a:	01 c0       	rjmp	.+2      	; 0x3e3e <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
}
    3e3e:	89 2f       	mov	r24, r25
    3e40:	0f 90       	pop	r0
    3e42:	df 91       	pop	r29
    3e44:	cf 91       	pop	r28
    3e46:	08 95       	ret

00003e48 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3e48:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3e4a:	fc 01       	movw	r30, r24
    3e4c:	26 81       	ldd	r18, Z+6	; 0x06
    3e4e:	37 81       	ldd	r19, Z+7	; 0x07
    3e50:	40 85       	ldd	r20, Z+8	; 0x08
    3e52:	51 85       	ldd	r21, Z+9	; 0x09
    3e54:	01 e0       	ldi	r16, 0x01	; 1
    3e56:	84 81       	ldd	r24, Z+4	; 0x04
    3e58:	95 81       	ldd	r25, Z+5	; 0x05
    3e5a:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSend>
    3e5e:	91 e0       	ldi	r25, 0x01	; 1
    3e60:	81 11       	cpse	r24, r1
    3e62:	01 c0       	rjmp	.+2      	; 0x3e66 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3e64:	90 e0       	ldi	r25, 0x00	; 0
		}
    3e66:	89 2f       	mov	r24, r25
    3e68:	0f 91       	pop	r16
    3e6a:	08 95       	ret

00003e6c <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3e6c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3e6e:	fc 01       	movw	r30, r24
    3e70:	26 81       	ldd	r18, Z+6	; 0x06
    3e72:	37 81       	ldd	r19, Z+7	; 0x07
    3e74:	40 85       	ldd	r20, Z+8	; 0x08
    3e76:	51 85       	ldd	r21, Z+9	; 0x09
    3e78:	00 e0       	ldi	r16, 0x00	; 0
    3e7a:	84 81       	ldd	r24, Z+4	; 0x04
    3e7c:	95 81       	ldd	r25, Z+5	; 0x05
    3e7e:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSend>
    3e82:	91 e0       	ldi	r25, 0x01	; 1
    3e84:	81 11       	cpse	r24, r1
    3e86:	01 c0       	rjmp	.+2      	; 0x3e8a <_ZN9frt_queueIjE3putERKj+0x1e>
    3e88:	90 e0       	ldi	r25, 0x00	; 0
		}
    3e8a:	89 2f       	mov	r24, r25
    3e8c:	0f 91       	pop	r16
    3e8e:	08 95       	ret

00003e90 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3e90:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3e92:	fc 01       	movw	r30, r24
    3e94:	26 81       	ldd	r18, Z+6	; 0x06
    3e96:	37 81       	ldd	r19, Z+7	; 0x07
    3e98:	40 85       	ldd	r20, Z+8	; 0x08
    3e9a:	51 85       	ldd	r21, Z+9	; 0x09
    3e9c:	01 e0       	ldi	r16, 0x01	; 1
    3e9e:	84 81       	ldd	r24, Z+4	; 0x04
    3ea0:	95 81       	ldd	r25, Z+5	; 0x05
    3ea2:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSend>
    3ea6:	91 e0       	ldi	r25, 0x01	; 1
    3ea8:	81 11       	cpse	r24, r1
    3eaa:	01 c0       	rjmp	.+2      	; 0x3eae <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3eac:	90 e0       	ldi	r25, 0x00	; 0
		}
    3eae:	89 2f       	mov	r24, r25
    3eb0:	0f 91       	pop	r16
    3eb2:	08 95       	ret

00003eb4 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3eb4:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3eb6:	fc 01       	movw	r30, r24
    3eb8:	26 81       	ldd	r18, Z+6	; 0x06
    3eba:	37 81       	ldd	r19, Z+7	; 0x07
    3ebc:	40 85       	ldd	r20, Z+8	; 0x08
    3ebe:	51 85       	ldd	r21, Z+9	; 0x09
    3ec0:	00 e0       	ldi	r16, 0x00	; 0
    3ec2:	84 81       	ldd	r24, Z+4	; 0x04
    3ec4:	95 81       	ldd	r25, Z+5	; 0x05
    3ec6:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <xQueueGenericSend>
    3eca:	91 e0       	ldi	r25, 0x01	; 1
    3ecc:	81 11       	cpse	r24, r1
    3ece:	01 c0       	rjmp	.+2      	; 0x3ed2 <_ZN9frt_queueIiE3putERKi+0x1e>
    3ed0:	90 e0       	ldi	r25, 0x00	; 0
		}
    3ed2:	89 2f       	mov	r24, r25
    3ed4:	0f 91       	pop	r16
    3ed6:	08 95       	ret

00003ed8 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3ed8:	0f 93       	push	r16
    3eda:	cf 93       	push	r28
    3edc:	df 93       	push	r29
    3ede:	1f 92       	push	r1
    3ee0:	cd b7       	in	r28, 0x3d	; 61
    3ee2:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3ee4:	2f b7       	in	r18, 0x3f	; 63
    3ee6:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3ee8:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3eea:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3eec:	fc 01       	movw	r30, r24
    3eee:	08 ed       	ldi	r16, 0xD8	; 216
    3ef0:	04 bf       	out	0x34, r16	; 52
    3ef2:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3ef4:	89 81       	ldd	r24, Y+1	; 0x01
    3ef6:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3ef8:	0f 90       	pop	r0
    3efa:	df 91       	pop	r29
    3efc:	cf 91       	pop	r28
    3efe:	0f 91       	pop	r16
    3f00:	08 95       	ret

00003f02 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3f02:	ef 92       	push	r14
    3f04:	ff 92       	push	r15
    3f06:	0f 93       	push	r16
    3f08:	1f 93       	push	r17
    3f0a:	cf 93       	push	r28
    3f0c:	df 93       	push	r29
    3f0e:	cd b7       	in	r28, 0x3d	; 61
    3f10:	de b7       	in	r29, 0x3e	; 62
    3f12:	ef 97       	sbiw	r28, 0x3f	; 63
    3f14:	cd bf       	out	0x3d, r28	; 61
    3f16:	de bf       	out	0x3e, r29	; 62
	cli();
    3f18:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3f1a:	e0 e5       	ldi	r30, 0x50	; 80
    3f1c:	f0 e0       	ldi	r31, 0x00	; 0
    3f1e:	80 81       	ld	r24, Z
    3f20:	82 60       	ori	r24, 0x02	; 2
    3f22:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3f24:	81 81       	ldd	r24, Z+1	; 0x01
    3f26:	81 ff       	sbrs	r24, 1
    3f28:	fd cf       	rjmp	.-6      	; 0x3f24 <main+0x22>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3f2a:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3f2e:	68 7f       	andi	r22, 0xF8	; 248
    3f30:	61 60       	ori	r22, 0x01	; 1
    3f32:	80 e4       	ldi	r24, 0x40	; 64
    3f34:	90 e0       	ldi	r25, 0x00	; 0
    3f36:	0e 94 6c 1f 	call	0x3ed8	; 0x3ed8 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3f3a:	e0 e5       	ldi	r30, 0x50	; 80
    3f3c:	f0 e0       	ldi	r31, 0x00	; 0
    3f3e:	80 81       	ld	r24, Z
    3f40:	8e 7f       	andi	r24, 0xFE	; 254
    3f42:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3f44:	9d ef       	ldi	r25, 0xFD	; 253
    3f46:	88 ed       	ldi	r24, 0xD8	; 216
    3f48:	08 b6       	in	r0, 0x38	; 56
    3f4a:	18 be       	out	0x38, r1	; 56
    3f4c:	84 bf       	out	0x34, r24	; 52
    3f4e:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3f52:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3f54:	40 ea       	ldi	r20, 0xA0	; 160
    3f56:	5a e0       	ldi	r21, 0x0A	; 10
    3f58:	60 e0       	ldi	r22, 0x00	; 0
    3f5a:	70 e0       	ldi	r23, 0x00	; 0
    3f5c:	ce 01       	movw	r24, r28
    3f5e:	01 96       	adiw	r24, 0x01	; 1
    3f60:	0e 94 10 1b 	call	0x3620	; 0x3620 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3f64:	67 e0       	ldi	r22, 0x07	; 7
    3f66:	ce 01       	movw	r24, r28
    3f68:	01 96       	adiw	r24, 0x01	; 1
    3f6a:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    3f6e:	8c 01       	movw	r16, r24
    3f70:	6d e7       	ldi	r22, 0x7D	; 125
    3f72:	70 e2       	ldi	r23, 0x20	; 32
    3f74:	0e 94 36 19 	call	0x326c	; 0x326c <_ZN8emstream4putsEPKc>
    3f78:	66 e0       	ldi	r22, 0x06	; 6
    3f7a:	c8 01       	movw	r24, r16
    3f7c:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
    3f80:	66 e0       	ldi	r22, 0x06	; 6
    3f82:	0e 94 6d 19 	call	0x32da	; 0x32da <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c (&TWIE, 62000);
    3f86:	20 e3       	ldi	r18, 0x30	; 48
    3f88:	32 ef       	ldi	r19, 0xF2	; 242
    3f8a:	40 e0       	ldi	r20, 0x00	; 0
    3f8c:	50 e0       	ldi	r21, 0x00	; 0
    3f8e:	60 ea       	ldi	r22, 0xA0	; 160
    3f90:	74 e0       	ldi	r23, 0x04	; 4
    3f92:	ce 01       	movw	r24, r28
    3f94:	4e 96       	adiw	r24, 0x1e	; 30
    3f96:	0e 94 54 04 	call	0x8a8	; 0x8a8 <_ZN9I2CMasterC1EP10TWI_structm>
	
	MB1202 mb1202 (&i2c);
    3f9a:	be 01       	movw	r22, r28
    3f9c:	62 5e       	subi	r22, 0xE2	; 226
    3f9e:	7f 4f       	sbci	r23, 0xFF	; 255
    3fa0:	ce 01       	movw	r24, r28
    3fa2:	c3 96       	adiw	r24, 0x33	; 51
    3fa4:	0e 94 aa 05 	call	0xb54	; 0xb54 <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3fa8:	82 e1       	ldi	r24, 0x12	; 18
    3faa:	90 e0       	ldi	r25, 0x00	; 0
    3fac:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
    3fb0:	8e 01       	movw	r16, r28
    3fb2:	0f 5f       	subi	r16, 0xFF	; 255
    3fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    3fb6:	20 e8       	ldi	r18, 0x80	; 128
    3fb8:	30 e0       	ldi	r19, 0x00	; 0
    3fba:	40 e0       	ldi	r20, 0x00	; 0
    3fbc:	6c e9       	ldi	r22, 0x9C	; 156
    3fbe:	70 e2       	ldi	r23, 0x20	; 32
    3fc0:	0e 94 54 06 	call	0xca8	; 0xca8 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    3fc4:	88 e1       	ldi	r24, 0x18	; 24
    3fc6:	90 e0       	ldi	r25, 0x00	; 0
    3fc8:	0e 94 82 18 	call	0x3104	; 0x3104 <_Znwj>
    3fcc:	9e 01       	movw	r18, r28
    3fce:	2d 5c       	subi	r18, 0xCD	; 205
    3fd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3fd2:	79 01       	movw	r14, r18
    3fd4:	20 e8       	ldi	r18, 0x80	; 128
    3fd6:	30 e0       	ldi	r19, 0x00	; 0
    3fd8:	42 e0       	ldi	r20, 0x02	; 2
    3fda:	64 ea       	ldi	r22, 0xA4	; 164
    3fdc:	70 e2       	ldi	r23, 0x20	; 32
    3fde:	0e 94 37 06 	call	0xc6e	; 0xc6e <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3fe2:	87 e0       	ldi	r24, 0x07	; 7
    3fe4:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3fe8:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3fea:	0e 94 01 10 	call	0x2002	; 0x2002 <vTaskStartScheduler>
}
    3fee:	80 e0       	ldi	r24, 0x00	; 0
    3ff0:	90 e0       	ldi	r25, 0x00	; 0
    3ff2:	ef 96       	adiw	r28, 0x3f	; 63
    3ff4:	cd bf       	out	0x3d, r28	; 61
    3ff6:	de bf       	out	0x3e, r29	; 62
    3ff8:	df 91       	pop	r29
    3ffa:	cf 91       	pop	r28
    3ffc:	1f 91       	pop	r17
    3ffe:	0f 91       	pop	r16
    4000:	ff 90       	pop	r15
    4002:	ef 90       	pop	r14
    4004:	08 95       	ret

00004006 <_GLOBAL__sub_I_counter>:
    4006:	cf 92       	push	r12
    4008:	df 92       	push	r13
    400a:	ef 92       	push	r14
    400c:	ff 92       	push	r15
    400e:	0f 93       	push	r16
    4010:	1f 93       	push	r17
    4012:	cf 93       	push	r28
    4014:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    4016:	0a e0       	ldi	r16, 0x0A	; 10
    4018:	10 e0       	ldi	r17, 0x00	; 0
    401a:	20 e0       	ldi	r18, 0x00	; 0
    401c:	30 e0       	ldi	r19, 0x00	; 0
    401e:	40 e0       	ldi	r20, 0x00	; 0
    4020:	50 e0       	ldi	r21, 0x00	; 0
    4022:	60 e2       	ldi	r22, 0x20	; 32
    4024:	70 e0       	ldi	r23, 0x00	; 0
    4026:	8e ea       	ldi	r24, 0xAE	; 174
    4028:	91 e3       	ldi	r25, 0x31	; 49
    402a:	0e 94 ee 16 	call	0x2ddc	; 0x2ddc <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    402e:	c4 ea       	ldi	r28, 0xA4	; 164
    4030:	d1 e3       	ldi	r29, 0x31	; 49
    4032:	1a 82       	std	Y+2, r1	; 0x02
    4034:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4036:	8e ea       	ldi	r24, 0xAE	; 174
    4038:	90 e2       	ldi	r25, 0x20	; 32
    403a:	88 83       	st	Y, r24
    403c:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    403e:	40 e0       	ldi	r20, 0x00	; 0
    4040:	62 e0       	ldi	r22, 0x02	; 2
    4042:	8f ef       	ldi	r24, 0xFF	; 255
    4044:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    4048:	8c 83       	std	Y+4, r24	; 0x04
    404a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    404c:	0f 2e       	mov	r0, r31
    404e:	fa e0       	ldi	r31, 0x0A	; 10
    4050:	cf 2e       	mov	r12, r31
    4052:	d1 2c       	mov	r13, r1
    4054:	e1 2c       	mov	r14, r1
    4056:	f1 2c       	mov	r15, r1
    4058:	f0 2d       	mov	r31, r0
    405a:	ce 82       	std	Y+6, r12	; 0x06
    405c:	df 82       	std	Y+7, r13	; 0x07
    405e:	e8 86       	std	Y+8, r14	; 0x08
    4060:	f9 86       	std	Y+9, r15	; 0x09
    4062:	ca e9       	ldi	r28, 0x9A	; 154
    4064:	d1 e3       	ldi	r29, 0x31	; 49
    4066:	1a 82       	std	Y+2, r1	; 0x02
    4068:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    406a:	02 ed       	ldi	r16, 0xD2	; 210
    406c:	10 e2       	ldi	r17, 0x20	; 32
    406e:	08 83       	st	Y, r16
    4070:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4072:	40 e0       	ldi	r20, 0x00	; 0
    4074:	62 e0       	ldi	r22, 0x02	; 2
    4076:	8f ef       	ldi	r24, 0xFF	; 255
    4078:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    407c:	8c 83       	std	Y+4, r24	; 0x04
    407e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4080:	ce 82       	std	Y+6, r12	; 0x06
    4082:	df 82       	std	Y+7, r13	; 0x07
    4084:	e8 86       	std	Y+8, r14	; 0x08
    4086:	f9 86       	std	Y+9, r15	; 0x09
    4088:	c0 e9       	ldi	r28, 0x90	; 144
    408a:	d1 e3       	ldi	r29, 0x31	; 49
    408c:	1a 82       	std	Y+2, r1	; 0x02
    408e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4090:	08 83       	st	Y, r16
    4092:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4094:	40 e0       	ldi	r20, 0x00	; 0
    4096:	62 e0       	ldi	r22, 0x02	; 2
    4098:	8f ef       	ldi	r24, 0xFF	; 255
    409a:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    409e:	8c 83       	std	Y+4, r24	; 0x04
    40a0:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    40a2:	ce 82       	std	Y+6, r12	; 0x06
    40a4:	df 82       	std	Y+7, r13	; 0x07
    40a6:	e8 86       	std	Y+8, r14	; 0x08
    40a8:	f9 86       	std	Y+9, r15	; 0x09
    40aa:	c6 e8       	ldi	r28, 0x86	; 134
    40ac:	d1 e3       	ldi	r29, 0x31	; 49
    40ae:	1a 82       	std	Y+2, r1	; 0x02
    40b0:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    40b2:	08 83       	st	Y, r16
    40b4:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    40b6:	40 e0       	ldi	r20, 0x00	; 0
    40b8:	62 e0       	ldi	r22, 0x02	; 2
    40ba:	8f ef       	ldi	r24, 0xFF	; 255
    40bc:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    40c0:	8c 83       	std	Y+4, r24	; 0x04
    40c2:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    40c4:	ce 82       	std	Y+6, r12	; 0x06
    40c6:	df 82       	std	Y+7, r13	; 0x07
    40c8:	e8 86       	std	Y+8, r14	; 0x08
    40ca:	f9 86       	std	Y+9, r15	; 0x09
    40cc:	cc e7       	ldi	r28, 0x7C	; 124
    40ce:	d1 e3       	ldi	r29, 0x31	; 49
    40d0:	1a 82       	std	Y+2, r1	; 0x02
    40d2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    40d4:	08 83       	st	Y, r16
    40d6:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    40d8:	40 e0       	ldi	r20, 0x00	; 0
    40da:	62 e0       	ldi	r22, 0x02	; 2
    40dc:	8f ef       	ldi	r24, 0xFF	; 255
    40de:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xQueueGenericCreate>
    40e2:	8c 83       	std	Y+4, r24	; 0x04
    40e4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    40e6:	ce 82       	std	Y+6, r12	; 0x06
    40e8:	df 82       	std	Y+7, r13	; 0x07
    40ea:	e8 86       	std	Y+8, r14	; 0x08
    40ec:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    40ee:	df 91       	pop	r29
    40f0:	cf 91       	pop	r28
    40f2:	1f 91       	pop	r17
    40f4:	0f 91       	pop	r16
    40f6:	ff 90       	pop	r15
    40f8:	ef 90       	pop	r14
    40fa:	df 90       	pop	r13
    40fc:	cf 90       	pop	r12
    40fe:	08 95       	ret

00004100 <__mulsi3>:
    4100:	db 01       	movw	r26, r22
    4102:	8f 93       	push	r24
    4104:	9f 93       	push	r25
    4106:	0e 94 da 20 	call	0x41b4	; 0x41b4 <__muluhisi3>
    410a:	bf 91       	pop	r27
    410c:	af 91       	pop	r26
    410e:	a2 9f       	mul	r26, r18
    4110:	80 0d       	add	r24, r0
    4112:	91 1d       	adc	r25, r1
    4114:	a3 9f       	mul	r26, r19
    4116:	90 0d       	add	r25, r0
    4118:	b2 9f       	mul	r27, r18
    411a:	90 0d       	add	r25, r0
    411c:	11 24       	eor	r1, r1
    411e:	08 95       	ret

00004120 <__udivmodsi4>:
    4120:	a1 e2       	ldi	r26, 0x21	; 33
    4122:	1a 2e       	mov	r1, r26
    4124:	aa 1b       	sub	r26, r26
    4126:	bb 1b       	sub	r27, r27
    4128:	fd 01       	movw	r30, r26
    412a:	0d c0       	rjmp	.+26     	; 0x4146 <__udivmodsi4_ep>

0000412c <__udivmodsi4_loop>:
    412c:	aa 1f       	adc	r26, r26
    412e:	bb 1f       	adc	r27, r27
    4130:	ee 1f       	adc	r30, r30
    4132:	ff 1f       	adc	r31, r31
    4134:	a2 17       	cp	r26, r18
    4136:	b3 07       	cpc	r27, r19
    4138:	e4 07       	cpc	r30, r20
    413a:	f5 07       	cpc	r31, r21
    413c:	20 f0       	brcs	.+8      	; 0x4146 <__udivmodsi4_ep>
    413e:	a2 1b       	sub	r26, r18
    4140:	b3 0b       	sbc	r27, r19
    4142:	e4 0b       	sbc	r30, r20
    4144:	f5 0b       	sbc	r31, r21

00004146 <__udivmodsi4_ep>:
    4146:	66 1f       	adc	r22, r22
    4148:	77 1f       	adc	r23, r23
    414a:	88 1f       	adc	r24, r24
    414c:	99 1f       	adc	r25, r25
    414e:	1a 94       	dec	r1
    4150:	69 f7       	brne	.-38     	; 0x412c <__udivmodsi4_loop>
    4152:	60 95       	com	r22
    4154:	70 95       	com	r23
    4156:	80 95       	com	r24
    4158:	90 95       	com	r25
    415a:	9b 01       	movw	r18, r22
    415c:	ac 01       	movw	r20, r24
    415e:	bd 01       	movw	r22, r26
    4160:	cf 01       	movw	r24, r30
    4162:	08 95       	ret

00004164 <__divmodsi4>:
    4164:	05 2e       	mov	r0, r21
    4166:	97 fb       	bst	r25, 7
    4168:	1e f4       	brtc	.+6      	; 0x4170 <__divmodsi4+0xc>
    416a:	00 94       	com	r0
    416c:	0e 94 c9 20 	call	0x4192	; 0x4192 <__negsi2>
    4170:	57 fd       	sbrc	r21, 7
    4172:	07 d0       	rcall	.+14     	; 0x4182 <__divmodsi4_neg2>
    4174:	0e 94 90 20 	call	0x4120	; 0x4120 <__udivmodsi4>
    4178:	07 fc       	sbrc	r0, 7
    417a:	03 d0       	rcall	.+6      	; 0x4182 <__divmodsi4_neg2>
    417c:	4e f4       	brtc	.+18     	; 0x4190 <__divmodsi4_exit>
    417e:	0c 94 c9 20 	jmp	0x4192	; 0x4192 <__negsi2>

00004182 <__divmodsi4_neg2>:
    4182:	50 95       	com	r21
    4184:	40 95       	com	r20
    4186:	30 95       	com	r19
    4188:	21 95       	neg	r18
    418a:	3f 4f       	sbci	r19, 0xFF	; 255
    418c:	4f 4f       	sbci	r20, 0xFF	; 255
    418e:	5f 4f       	sbci	r21, 0xFF	; 255

00004190 <__divmodsi4_exit>:
    4190:	08 95       	ret

00004192 <__negsi2>:
    4192:	90 95       	com	r25
    4194:	80 95       	com	r24
    4196:	70 95       	com	r23
    4198:	61 95       	neg	r22
    419a:	7f 4f       	sbci	r23, 0xFF	; 255
    419c:	8f 4f       	sbci	r24, 0xFF	; 255
    419e:	9f 4f       	sbci	r25, 0xFF	; 255
    41a0:	08 95       	ret

000041a2 <__tablejump2__>:
    41a2:	ee 0f       	add	r30, r30
    41a4:	ff 1f       	adc	r31, r31
    41a6:	88 1f       	adc	r24, r24
    41a8:	8b bf       	out	0x3b, r24	; 59
    41aa:	07 90       	elpm	r0, Z+
    41ac:	f6 91       	elpm	r31, Z
    41ae:	e0 2d       	mov	r30, r0
    41b0:	1b be       	out	0x3b, r1	; 59
    41b2:	19 94       	eijmp

000041b4 <__muluhisi3>:
    41b4:	0e 94 e5 20 	call	0x41ca	; 0x41ca <__umulhisi3>
    41b8:	a5 9f       	mul	r26, r21
    41ba:	90 0d       	add	r25, r0
    41bc:	b4 9f       	mul	r27, r20
    41be:	90 0d       	add	r25, r0
    41c0:	a4 9f       	mul	r26, r20
    41c2:	80 0d       	add	r24, r0
    41c4:	91 1d       	adc	r25, r1
    41c6:	11 24       	eor	r1, r1
    41c8:	08 95       	ret

000041ca <__umulhisi3>:
    41ca:	a2 9f       	mul	r26, r18
    41cc:	b0 01       	movw	r22, r0
    41ce:	b3 9f       	mul	r27, r19
    41d0:	c0 01       	movw	r24, r0
    41d2:	a3 9f       	mul	r26, r19
    41d4:	70 0d       	add	r23, r0
    41d6:	81 1d       	adc	r24, r1
    41d8:	11 24       	eor	r1, r1
    41da:	91 1d       	adc	r25, r1
    41dc:	b2 9f       	mul	r27, r18
    41de:	70 0d       	add	r23, r0
    41e0:	81 1d       	adc	r24, r1
    41e2:	11 24       	eor	r1, r1
    41e4:	91 1d       	adc	r25, r1
    41e6:	08 95       	ret

000041e8 <memcpy>:
    41e8:	fb 01       	movw	r30, r22
    41ea:	dc 01       	movw	r26, r24
    41ec:	02 c0       	rjmp	.+4      	; 0x41f2 <memcpy+0xa>
    41ee:	01 90       	ld	r0, Z+
    41f0:	0d 92       	st	X+, r0
    41f2:	41 50       	subi	r20, 0x01	; 1
    41f4:	50 40       	sbci	r21, 0x00	; 0
    41f6:	d8 f7       	brcc	.-10     	; 0x41ee <memcpy+0x6>
    41f8:	08 95       	ret

000041fa <memset>:
    41fa:	dc 01       	movw	r26, r24
    41fc:	01 c0       	rjmp	.+2      	; 0x4200 <memset+0x6>
    41fe:	6d 93       	st	X+, r22
    4200:	41 50       	subi	r20, 0x01	; 1
    4202:	50 40       	sbci	r21, 0x00	; 0
    4204:	e0 f7       	brcc	.-8      	; 0x41fe <memset+0x4>
    4206:	08 95       	ret

00004208 <strncpy>:
    4208:	fb 01       	movw	r30, r22
    420a:	dc 01       	movw	r26, r24
    420c:	41 50       	subi	r20, 0x01	; 1
    420e:	50 40       	sbci	r21, 0x00	; 0
    4210:	48 f0       	brcs	.+18     	; 0x4224 <strncpy+0x1c>
    4212:	01 90       	ld	r0, Z+
    4214:	0d 92       	st	X+, r0
    4216:	00 20       	and	r0, r0
    4218:	c9 f7       	brne	.-14     	; 0x420c <strncpy+0x4>
    421a:	01 c0       	rjmp	.+2      	; 0x421e <strncpy+0x16>
    421c:	1d 92       	st	X+, r1
    421e:	41 50       	subi	r20, 0x01	; 1
    4220:	50 40       	sbci	r21, 0x00	; 0
    4222:	e0 f7       	brcc	.-8      	; 0x421c <strncpy+0x14>
    4224:	08 95       	ret

00004226 <ultoa>:
    4226:	25 32       	cpi	r18, 0x25	; 37
    4228:	31 05       	cpc	r19, r1
    422a:	20 f4       	brcc	.+8      	; 0x4234 <ultoa+0xe>
    422c:	22 30       	cpi	r18, 0x02	; 2
    422e:	10 f0       	brcs	.+4      	; 0x4234 <ultoa+0xe>
    4230:	0c 94 1e 21 	jmp	0x423c	; 0x423c <__ultoa_ncheck>
    4234:	fa 01       	movw	r30, r20
    4236:	10 82       	st	Z, r1
    4238:	ca 01       	movw	r24, r20
    423a:	08 95       	ret

0000423c <__ultoa_ncheck>:
    423c:	bb 27       	eor	r27, r27

0000423e <__ultoa_common>:
    423e:	fa 01       	movw	r30, r20
    4240:	a6 2f       	mov	r26, r22
    4242:	62 17       	cp	r22, r18
    4244:	71 05       	cpc	r23, r1
    4246:	81 05       	cpc	r24, r1
    4248:	91 05       	cpc	r25, r1
    424a:	33 0b       	sbc	r19, r19
    424c:	30 fb       	bst	r19, 0
    424e:	66 f0       	brts	.+24     	; 0x4268 <__ultoa_common+0x2a>
    4250:	aa 27       	eor	r26, r26
    4252:	66 0f       	add	r22, r22
    4254:	77 1f       	adc	r23, r23
    4256:	88 1f       	adc	r24, r24
    4258:	99 1f       	adc	r25, r25
    425a:	aa 1f       	adc	r26, r26
    425c:	a2 17       	cp	r26, r18
    425e:	10 f0       	brcs	.+4      	; 0x4264 <__ultoa_common+0x26>
    4260:	a2 1b       	sub	r26, r18
    4262:	63 95       	inc	r22
    4264:	38 50       	subi	r19, 0x08	; 8
    4266:	a9 f7       	brne	.-22     	; 0x4252 <__ultoa_common+0x14>
    4268:	a0 5d       	subi	r26, 0xD0	; 208
    426a:	aa 33       	cpi	r26, 0x3A	; 58
    426c:	08 f0       	brcs	.+2      	; 0x4270 <__ultoa_common+0x32>
    426e:	a9 5d       	subi	r26, 0xD9	; 217
    4270:	a1 93       	st	Z+, r26
    4272:	36 f7       	brtc	.-52     	; 0x4240 <__ultoa_common+0x2>
    4274:	b1 11       	cpse	r27, r1
    4276:	b1 93       	st	Z+, r27
    4278:	10 82       	st	Z, r1
    427a:	ca 01       	movw	r24, r20
    427c:	0c 94 65 21 	jmp	0x42ca	; 0x42ca <strrev>

00004280 <utoa>:
    4280:	45 32       	cpi	r20, 0x25	; 37
    4282:	51 05       	cpc	r21, r1
    4284:	20 f4       	brcc	.+8      	; 0x428e <utoa+0xe>
    4286:	42 30       	cpi	r20, 0x02	; 2
    4288:	10 f0       	brcs	.+4      	; 0x428e <utoa+0xe>
    428a:	0c 94 4b 21 	jmp	0x4296	; 0x4296 <__utoa_ncheck>
    428e:	fb 01       	movw	r30, r22
    4290:	10 82       	st	Z, r1
    4292:	cb 01       	movw	r24, r22
    4294:	08 95       	ret

00004296 <__utoa_ncheck>:
    4296:	bb 27       	eor	r27, r27

00004298 <__utoa_common>:
    4298:	fb 01       	movw	r30, r22
    429a:	55 27       	eor	r21, r21
    429c:	aa 27       	eor	r26, r26
    429e:	88 0f       	add	r24, r24
    42a0:	99 1f       	adc	r25, r25
    42a2:	aa 1f       	adc	r26, r26
    42a4:	a4 17       	cp	r26, r20
    42a6:	10 f0       	brcs	.+4      	; 0x42ac <__utoa_common+0x14>
    42a8:	a4 1b       	sub	r26, r20
    42aa:	83 95       	inc	r24
    42ac:	50 51       	subi	r21, 0x10	; 16
    42ae:	b9 f7       	brne	.-18     	; 0x429e <__utoa_common+0x6>
    42b0:	a0 5d       	subi	r26, 0xD0	; 208
    42b2:	aa 33       	cpi	r26, 0x3A	; 58
    42b4:	08 f0       	brcs	.+2      	; 0x42b8 <__utoa_common+0x20>
    42b6:	a9 5d       	subi	r26, 0xD9	; 217
    42b8:	a1 93       	st	Z+, r26
    42ba:	00 97       	sbiw	r24, 0x00	; 0
    42bc:	79 f7       	brne	.-34     	; 0x429c <__utoa_common+0x4>
    42be:	b1 11       	cpse	r27, r1
    42c0:	b1 93       	st	Z+, r27
    42c2:	11 92       	st	Z+, r1
    42c4:	cb 01       	movw	r24, r22
    42c6:	0c 94 65 21 	jmp	0x42ca	; 0x42ca <strrev>

000042ca <strrev>:
    42ca:	dc 01       	movw	r26, r24
    42cc:	fc 01       	movw	r30, r24
    42ce:	67 2f       	mov	r22, r23
    42d0:	71 91       	ld	r23, Z+
    42d2:	77 23       	and	r23, r23
    42d4:	e1 f7       	brne	.-8      	; 0x42ce <strrev+0x4>
    42d6:	32 97       	sbiw	r30, 0x02	; 2
    42d8:	04 c0       	rjmp	.+8      	; 0x42e2 <strrev+0x18>
    42da:	7c 91       	ld	r23, X
    42dc:	6d 93       	st	X+, r22
    42de:	70 83       	st	Z, r23
    42e0:	62 91       	ld	r22, -Z
    42e2:	ae 17       	cp	r26, r30
    42e4:	bf 07       	cpc	r27, r31
    42e6:	c8 f3       	brcs	.-14     	; 0x42da <strrev+0x10>
    42e8:	08 95       	ret

000042ea <_exit>:
    42ea:	f8 94       	cli

000042ec <__stop_program>:
    42ec:	ff cf       	rjmp	.-2      	; 0x42ec <__stop_program>
