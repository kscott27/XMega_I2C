
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000041a8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e0  00802000  000041a8  0000423c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000010ce  008020e0  008020e0  0000431c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000431c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000434c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000808  00000000  00000000  0000438c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012d58  00000000  00000000  00004b94  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006080  00000000  00000000  000178ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000052bb  00000000  00000000  0001d96c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001764  00000000  00000000  00022c28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005f29  00000000  00000000  0002438c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000071aa  00000000  00000000  0002a2b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000748  00000000  00000000  0003145f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ed 02 	jmp	0x5da	; 0x5da <__ctors_end>
       4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
       8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
       c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      10:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      14:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      18:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      1c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      20:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      24:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      28:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      2c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      30:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      34:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      38:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      3c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      40:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      44:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      48:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      4c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      50:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      54:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      58:	0c 94 18 0b 	jmp	0x1630	; 0x1630 <__vector_22>
      5c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      60:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      64:	0c 94 ed 1a 	jmp	0x35da	; 0x35da <__vector_25>
      68:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      6c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      70:	0c 94 4b 1b 	jmp	0x3696	; 0x3696 <__vector_28>
      74:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      78:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      7c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      80:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      84:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      88:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      8c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      90:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      94:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      98:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      9c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      a8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      ac:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      b8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      bc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      c8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      cc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      d8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      dc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      e8:	0c 94 65 1c 	jmp	0x38ca	; 0x38ca <__vector_58>
      ec:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      f8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
      fc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     100:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     104:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     108:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     10c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     110:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     114:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     118:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     11c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     120:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     124:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     128:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     12c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     130:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     134:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     138:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     13c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     140:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     144:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     148:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     14c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     150:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     154:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     158:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     15c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     160:	0c 94 a9 1b 	jmp	0x3752	; 0x3752 <__vector_88>
     164:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     168:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     16c:	0c 94 07 1c 	jmp	0x380e	; 0x380e <__vector_91>
     170:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     174:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     178:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     17c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     180:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     184:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     188:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     18c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     190:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     194:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     198:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     19c:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1a8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1ac:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1b8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1bc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1c8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1cc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1d8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1dc:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1e8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1ec:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f0:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f4:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1f8:	0c 94 23 03 	jmp	0x646	; 0x646 <__bad_interrupt>
     1fc:	d9 18       	sub	r13, r9
     1fe:	dc 18       	sub	r13, r12
     200:	df 18       	sub	r13, r15
     202:	e2 18       	sub	r14, r2
     204:	e5 18       	sub	r14, r5
     206:	e8 18       	sub	r14, r8
     208:	ea 18       	sub	r14, r10
     20a:	fb 18       	sub	r15, r11
     20c:	03 19       	sub	r16, r3
     20e:	0d 19       	sub	r16, r13
     210:	0b 19       	sub	r16, r11

00000212 <__trampolines_start>:
     212:	0c 94 02 1d 	jmp	0x3a04	; 0x3a04 <_ZN9frt_queueIjE9not_emptyEv>
     216:	0c 94 0d 19 	jmp	0x321a	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
     21a:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <_ZN9task_user3runEv>
     21e:	0c 94 8d 1d 	jmp	0x3b1a	; 0x3b1a <_ZN9frt_queueIiE10get_a_copyEv>
     222:	0c 94 60 1f 	jmp	0x3ec0	; 0x3ec0 <_GLOBAL__sub_I_counter>
     226:	0c 94 84 18 	jmp	0x3108	; 0x3108 <_ZN8emstream12clear_screenEv>
     22a:	0c 94 fb 1c 	jmp	0x39f6	; 0x39f6 <_ZN9frt_queueIjE12num_items_inEv>
     22e:	0c 94 81 18 	jmp	0x3102	; 0x3102 <_ZN8emstream14check_for_charEv>
     232:	0c 94 fa 04 	jmp	0x9f4	; 0x9f4 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>
     236:	0c 94 29 1d 	jmp	0x3a52	; 0x3a52 <_ZN9frt_queueIiE8is_emptyEv>
     23a:	0c 94 21 1e 	jmp	0x3c42	; 0x3c42 <_ZN9frt_queueIjE11ISR_butt_inERKj>
     23e:	0c 94 93 1e 	jmp	0x3d26	; 0x3d26 <_ZN9frt_queueIjE3putERKj>
     242:	0c 94 fb 18 	jmp	0x31f6	; 0x31f6 <_ZN8emstreamlsE15ser_manipulator+0x62>
     246:	0c 94 ea 18 	jmp	0x31d4	; 0x31d4 <_ZN8emstreamlsE15ser_manipulator+0x40>
     24a:	0c 94 56 05 	jmp	0xaac	; 0xaac <_ZN10task_sonar3runEv>
     24e:	0c 94 7c 18 	jmp	0x30f8	; 0x30f8 <_ZN8emstream13ready_to_sendEv>
     252:	0c 94 ea 02 	jmp	0x5d4	; 0x5d4 <_call_static_run_method>
     256:	0c 94 1e 1d 	jmp	0x3a3c	; 0x3a3c <_ZN9frt_queueIiE9not_emptyEv>
     25a:	0c 94 39 1e 	jmp	0x3c72	; 0x3c72 <_ZN9frt_queueIjE7ISR_putERKj>
     25e:	0c 94 dc 18 	jmp	0x31b8	; 0x31b8 <_ZN8emstreamlsE15ser_manipulator+0x24>
     262:	0c 94 a5 1e 	jmp	0x3d4a	; 0x3d4a <_ZN9frt_queueIiE7butt_inERKi>
     266:	0c 94 ca 1c 	jmp	0x3994	; 0x3994 <_ZN9frt_queueIjE13ISR_not_emptyEv>
     26a:	0c 94 e5 18 	jmp	0x31ca	; 0x31ca <_ZN8emstreamlsE15ser_manipulator+0x36>
     26e:	0c 94 69 1e 	jmp	0x3cd2	; 0x3cd2 <_ZN9frt_queueIiE7ISR_putERKi>
     272:	0c 94 f1 1c 	jmp	0x39e2	; 0x39e2 <_ZN9frt_queueIiE12ISR_is_emptyEv>
     276:	0c 94 e0 1d 	jmp	0x3bc0	; 0x3bc0 <_ZN9frt_queueIjE7ISR_getEv>
     27a:	0c 94 51 1e 	jmp	0x3ca2	; 0x3ca2 <_ZN9frt_queueIiE11ISR_butt_inERKi>
     27e:	0c 94 5a 1d 	jmp	0x3ab4	; 0x3ab4 <_ZN9frt_queueIjE3getEPj>
     282:	0c 94 e5 17 	jmp	0x2fca	; 0x2fca <__cxa_pure_virtual>
     286:	0c 94 e8 18 	jmp	0x31d0	; 0x31d0 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     28a:	0c 94 22 16 	jmp	0x2c44	; 0x2c44 <_ZN14frt_text_queue14check_for_charEv>
     28e:	0c 94 d9 18 	jmp	0x31b2	; 0x31b2 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     292:	0c 94 ba 14 	jmp	0x2974	; 0x2974 <_ZN8frt_task12print_statusER8emstream>
     296:	0c 94 64 1a 	jmp	0x34c8	; 0x34c8 <_ZN5rs23212clear_screenEv>
     29a:	0c 94 66 1d 	jmp	0x3acc	; 0x3acc <_ZN9frt_queueIjE3getEv>
     29e:	0c 94 0b 19 	jmp	0x3216	; 0x3216 <_ZN8emstreamlsE15ser_manipulator+0x82>
     2a2:	0c 94 b4 1d 	jmp	0x3b68	; 0x3b68 <_ZN9frt_queueIiE3getEv>
     2a6:	0c 94 3d 03 	jmp	0x67a	; 0x67a <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>
     2aa:	0c 94 17 1d 	jmp	0x3a2e	; 0x3a2e <_ZN9frt_queueIiE12num_items_inEv>
     2ae:	0c 94 df 1c 	jmp	0x39be	; 0x39be <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2b2:	0c 94 33 1d 	jmp	0x3a66	; 0x3a66 <_ZN9frt_queueIjE10get_a_copyERj>
     2b6:	0c 94 03 19 	jmp	0x3206	; 0x3206 <_ZN8emstreamlsE15ser_manipulator+0x72>
     2ba:	0c 94 07 1a 	jmp	0x340e	; 0x340e <_ZN5rs2327putcharEc>
     2be:	0c 94 09 1e 	jmp	0x3c12	; 0x3c12 <_ZN9frt_queueIiE7ISR_getEv>
     2c2:	0c 94 d5 1c 	jmp	0x39aa	; 0x39aa <_ZN9frt_queueIjE12ISR_is_emptyEv>
     2c6:	0c 94 a8 1d 	jmp	0x3b50	; 0x3b50 <_ZN9frt_queueIiE3getEPi>
     2ca:	0c 94 25 03 	jmp	0x64a	; 0x64a <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>
     2ce:	0c 94 2d 16 	jmp	0x2c5a	; 0x2c5a <_ZN14frt_text_queue7putcharEc>
     2d2:	0c 94 f8 0d 	jmp	0x1bf0	; 0x1bf0 <prvIdleTask>
     2d6:	0c 94 3f 1d 	jmp	0x3a7e	; 0x3a7e <_ZN9frt_queueIjE10get_a_copyEv>
     2da:	0c 94 c3 1c 	jmp	0x3986	; 0x3986 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     2de:	0c 94 04 16 	jmp	0x2c08	; 0x2c08 <_ZN14frt_text_queue7getcharEv>
     2e2:	0c 94 81 1e 	jmp	0x3d02	; 0x3d02 <_ZN9frt_queueIjE7butt_inERKj>
     2e6:	0c 94 b7 1e 	jmp	0x3d6e	; 0x3d6e <_ZN9frt_queueIiE3putERKi>
     2ea:	0c 94 81 1d 	jmp	0x3b02	; 0x3b02 <_ZN9frt_queueIiE10get_a_copyERi>
     2ee:	0c 94 83 18 	jmp	0x3106	; 0x3106 <_ZN8emstream12transmit_nowEv>
     2f2:	0c 94 2b 1a 	jmp	0x3456	; 0x3456 <_ZN5rs2327getcharEv>
     2f6:	0c 94 7e 18 	jmp	0x30fc	; 0x30fc <_ZN8emstream7getcharEv>
     2fa:	0c 94 f8 1d 	jmp	0x3bf0	; 0x3bf0 <_ZN9frt_queueIiE7ISR_getEPi>
     2fe:	0c 94 0d 1d 	jmp	0x3a1a	; 0x3a1a <_ZN9frt_queueIjE8is_emptyEv>
     302:	0c 94 df 18 	jmp	0x31be	; 0x31be <_ZN8emstreamlsE15ser_manipulator+0x2a>
     306:	0c 94 cf 1d 	jmp	0x3b9e	; 0x3b9e <_ZN9frt_queueIjE7ISR_getEPj>
     30a:	0c 94 6e 03 	jmp	0x6dc	; 0x6dc <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>
     30e:	0c 94 e6 1c 	jmp	0x39cc	; 0x39cc <_ZN9frt_queueIiE13ISR_not_emptyEv>
     312:	0c 94 e2 18 	jmp	0x31c4	; 0x31c4 <_ZN8emstreamlsE15ser_manipulator+0x30>
     316:	0c 94 51 1a 	jmp	0x34a2	; 0x34a2 <_ZN5rs23214check_for_charEv>

0000031a <__trampolines_end>:
     31a:	53 6f       	ori	r21, 0xF3	; 243
     31c:	6e 61       	ori	r22, 0x1E	; 30
     31e:	72 3a       	cpi	r23, 0xA2	; 162
     320:	20 00       	.word	0x0020	; ????

00000322 <_ZZN9task_user11show_statusEvE3__c_4>:
     322:	2c 20 54 43 43 30 43 43 41 3d 00                    , TCC0CCA=.

0000032d <_ZZN9task_user11show_statusEvE3__c_3>:
     32d:	2f 00                                               /.

0000032f <_ZZN9task_user11show_statusEvE3__c_2>:
     32f:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

0000033d <_ZZN9task_user11show_statusEvE3__c_1>:
     33d:	54 69 6d 65 3a 20 00                                Time: .

00000344 <_ZZN9task_user11show_statusEvE3__c_0>:
     344:	4d 61 72 20 31 35 20 32 30 31 38 00                 Mar 15 2018.

00000350 <_ZZN9task_user11show_statusEvE3__c>:
     350:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     360:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000036f <_ZZN9task_user18print_help_messageEvE3__c_10>:
     36f:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

0000037e <_ZZN9task_user18print_help_messageEvE3__c_9>:
     37e:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     38e:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000399 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     399:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3a9:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003b7 <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3b7:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3c7:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3d7:	6d 61 74 69 6f 6e 00                                mation.

000003de <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3de:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3ee:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

000003ff <_ZZN9task_user18print_help_messageEvE3__c_5>:
     3ff:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     40f:	65 20 6f 6e 6c 79 3a 00                             e only:.

00000417 <_ZZN9task_user18print_help_messageEvE3__c_4>:
     417:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     427:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000433 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     433:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     443:	68 65 20 41 56 52 00                                he AVR.

0000044a <_ZZN9task_user18print_help_messageEvE3__c_2>:
     44a:	20 68 65 6c 70 00                                    help.

00000450 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     450:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     460:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

0000046f <_ZZN9task_user18print_help_messageEvE3__c_0>:
     46f:	1b 5b 33 30 6d 00                                   .[30m.

00000475 <_ZZN9task_user18print_help_messageEvE3__c>:
     475:	1b 5b 34 36 6d 00                                   .[46m.

0000047b <_ZZN9task_user3runEvE3__c_3>:
     47b:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     48b:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000498 <_ZZN9task_user3runEvE3__c_2>:
     498:	3a 57 54 46 3f 00                                   :WTF?.

0000049e <_ZZN9task_user3runEvE3__c_1>:
     49e:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4ae:	65 00                                               e.

000004b0 <_ZZN9task_user3runEvE3__c_0>:
     4b0:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004be <_ZZN9task_user3runEvE3__c>:
     4be:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4ce:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004dc <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4dc:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004e6 <_ZZN8frt_task15emergency_resetEvE3__c>:
     4e6:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004f5 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4f5:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     505:	61 73 6b 20 00                                      ask .

0000050a <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     50a:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000518 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     518:	20 63 72 65 61 74 65 64 00                           created.

00000521 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     521:	54 61 73 6b 20 00                                   Task .

00000527 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     527:	1b 5b 32 32 6d 00                                   .[22m.

0000052d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     52d:	54 61 73 6b 3a 20 00                                Task: .

00000534 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     534:	1b 5b 31 6d 00                                      .[1m.

00000539 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     53f:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

0000054a <_ZZ17print_task_stacksP8emstreamE3__c>:
     54a:	1b 5b 31 6d 00                                      .[1m.

0000054f <_ZZ15print_task_listP8emstreamE3__c_9>:
     54f:	09 09 00                                            ...

00000552 <_ZZ15print_task_listP8emstreamE3__c_8>:
     552:	2f 00                                               /.

00000554 <_ZZ15print_task_listP8emstreamE3__c_7>:
     554:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

0000055f <_ZZ15print_task_listP8emstreamE3__c_6>:
     55f:	09 2d 2d 2d 2d 00                                   .----.

00000565 <_ZZ15print_task_listP8emstreamE3__c_5>:
     565:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000571 <_ZZ15print_task_listP8emstreamE3__c_4>:
     571:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000582 <_ZZ15print_task_listP8emstreamE3__c_3>:
     582:	09 52 75 6e 73 00                                   .Runs.

00000588 <_ZZ15print_task_listP8emstreamE3__c_2>:
     588:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

00000594 <_ZZ15print_task_listP8emstreamE3__c_1>:
     594:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005a5 <_ZZ15print_task_listP8emstreamE3__c_0>:
     5a5:	09 53 74 61 63 6b 00                                .Stack.

000005ac <_ZZ15print_task_listP8emstreamE3__c>:
     5ac:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005b7 <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5b7:	09 00                                               ..

000005b9 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5b9:	09 00                                               ..

000005bb <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5bb:	2f 00                                               /.

000005bd <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5bd:	09 00                                               ..

000005bf <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5bf:	09 00                                               ..

000005c1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5c1:	1b 5b 32 32 6d 00                                   .[22m.

000005c7 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5c7:	1b 5b 31 6d 00                                      .[1m.

000005cc <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5cc:	1b 5b 31 6d 00                                      .[1m.

000005d1 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5d1:	20 20 00                                              .

000005d4 <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5d4:	0e 94 52 13 	call	0x26a4	; 0x26a4 <_ZN8frt_task22_call_users_run_methodEPS_>

000005d8 <__ctors_start>:
     5d8:	60 1f       	adc	r22, r16

000005da <__ctors_end>:
     5da:	11 24       	eor	r1, r1
     5dc:	1f be       	out	0x3f, r1	; 63
     5de:	cf ef       	ldi	r28, 0xFF	; 255
     5e0:	cd bf       	out	0x3d, r28	; 61
     5e2:	df e3       	ldi	r29, 0x3F	; 63
     5e4:	de bf       	out	0x3e, r29	; 62
     5e6:	00 e0       	ldi	r16, 0x00	; 0
     5e8:	0c bf       	out	0x3c, r16	; 60
     5ea:	18 be       	out	0x38, r1	; 56
     5ec:	19 be       	out	0x39, r1	; 57
     5ee:	1a be       	out	0x3a, r1	; 58
     5f0:	1b be       	out	0x3b, r1	; 59

000005f2 <__do_copy_data>:
     5f2:	10 e2       	ldi	r17, 0x20	; 32
     5f4:	a0 e0       	ldi	r26, 0x00	; 0
     5f6:	b0 e2       	ldi	r27, 0x20	; 32
     5f8:	e8 ea       	ldi	r30, 0xA8	; 168
     5fa:	f1 e4       	ldi	r31, 0x41	; 65
     5fc:	00 e0       	ldi	r16, 0x00	; 0
     5fe:	0b bf       	out	0x3b, r16	; 59
     600:	02 c0       	rjmp	.+4      	; 0x606 <__do_copy_data+0x14>
     602:	07 90       	elpm	r0, Z+
     604:	0d 92       	st	X+, r0
     606:	a0 3e       	cpi	r26, 0xE0	; 224
     608:	b1 07       	cpc	r27, r17
     60a:	d9 f7       	brne	.-10     	; 0x602 <__do_copy_data+0x10>
     60c:	1b be       	out	0x3b, r1	; 59

0000060e <__do_clear_bss>:
     60e:	21 e3       	ldi	r18, 0x31	; 49
     610:	a0 ee       	ldi	r26, 0xE0	; 224
     612:	b0 e2       	ldi	r27, 0x20	; 32
     614:	01 c0       	rjmp	.+2      	; 0x618 <.do_clear_bss_start>

00000616 <.do_clear_bss_loop>:
     616:	1d 92       	st	X+, r1

00000618 <.do_clear_bss_start>:
     618:	ae 3a       	cpi	r26, 0xAE	; 174
     61a:	b2 07       	cpc	r27, r18
     61c:	e1 f7       	brne	.-8      	; 0x616 <.do_clear_bss_loop>

0000061e <__do_global_ctors>:
     61e:	12 e0       	ldi	r17, 0x02	; 2
     620:	cd ee       	ldi	r28, 0xED	; 237
     622:	d2 e0       	ldi	r29, 0x02	; 2
     624:	00 e0       	ldi	r16, 0x00	; 0
     626:	06 c0       	rjmp	.+12     	; 0x634 <__do_global_ctors+0x16>
     628:	21 97       	sbiw	r28, 0x01	; 1
     62a:	01 09       	sbc	r16, r1
     62c:	80 2f       	mov	r24, r16
     62e:	fe 01       	movw	r30, r28
     630:	0e 94 2e 20 	call	0x405c	; 0x405c <__tablejump2__>
     634:	cc 3e       	cpi	r28, 0xEC	; 236
     636:	d1 07       	cpc	r29, r17
     638:	80 e0       	ldi	r24, 0x00	; 0
     63a:	08 07       	cpc	r16, r24
     63c:	a9 f7       	brne	.-22     	; 0x628 <__do_global_ctors+0xa>
     63e:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <main>
     642:	0c 94 d2 20 	jmp	0x41a4	; 0x41a4 <_exit>

00000646 <__bad_interrupt>:
     646:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000064a <_ZN9I2CMaster11Transmitter10StartState7executeER9frt_queueIhE>:
	}
	else
	{
		return false;
	}
}
     64a:	0f 93       	push	r16
     64c:	1f 93       	push	r17
     64e:	cf 93       	push	r28
     650:	df 93       	push	r29
     652:	ec 01       	movw	r28, r24
     654:	cb 01       	movw	r24, r22
     656:	0e 81       	ldd	r16, Y+6	; 0x06
     658:	1f 81       	ldd	r17, Y+7	; 0x07
     65a:	db 01       	movw	r26, r22
     65c:	ed 91       	ld	r30, X+
     65e:	fc 91       	ld	r31, X
     660:	00 84       	ldd	r0, Z+8	; 0x08
     662:	f1 85       	ldd	r31, Z+9	; 0x09
     664:	e0 2d       	mov	r30, r0
     666:	19 95       	eicall
     668:	f8 01       	movw	r30, r16
     66a:	86 83       	std	Z+6, r24	; 0x06
     66c:	8a 81       	ldd	r24, Y+2	; 0x02
     66e:	9b 81       	ldd	r25, Y+3	; 0x03
     670:	df 91       	pop	r29
     672:	cf 91       	pop	r28
     674:	1f 91       	pop	r17
     676:	0f 91       	pop	r16
     678:	08 95       	ret

0000067a <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE>:
     67a:	cf 93       	push	r28
     67c:	df 93       	push	r29
     67e:	1f 92       	push	r1
     680:	1f 92       	push	r1
     682:	cd b7       	in	r28, 0x3d	; 61
     684:	de b7       	in	r29, 0x3e	; 62
     686:	dc 01       	movw	r26, r24
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	8d 91       	ld	r24, X+
     68c:	9c 91       	ld	r25, X
     68e:	19 97       	sbiw	r26, 0x09	; 9
     690:	89 83       	std	Y+1, r24	; 0x01
     692:	9a 83       	std	Y+2, r25	; 0x02
     694:	29 81       	ldd	r18, Y+1	; 0x01
     696:	3a 81       	ldd	r19, Y+2	; 0x02
     698:	21 50       	subi	r18, 0x01	; 1
     69a:	31 09       	sbc	r19, r1
     69c:	29 83       	std	Y+1, r18	; 0x01
     69e:	3a 83       	std	Y+2, r19	; 0x02
     6a0:	23 2b       	or	r18, r19
     6a2:	91 f0       	breq	.+36     	; 0x6c8 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6a4:	16 96       	adiw	r26, 0x06	; 6
     6a6:	ed 91       	ld	r30, X+
     6a8:	fc 91       	ld	r31, X
     6aa:	17 97       	sbiw	r26, 0x07	; 7
     6ac:	94 81       	ldd	r25, Z+4	; 0x04
     6ae:	94 fd       	sbrc	r25, 4
     6b0:	f1 cf       	rjmp	.-30     	; 0x694 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x1a>
     6b2:	0a c0       	rjmp	.+20     	; 0x6c8 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x4e>
     6b4:	14 96       	adiw	r26, 0x04	; 4
     6b6:	8d 91       	ld	r24, X+
     6b8:	9c 91       	ld	r25, X
     6ba:	15 97       	sbiw	r26, 0x05	; 5
     6bc:	0a c0       	rjmp	.+20     	; 0x6d2 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6be:	12 96       	adiw	r26, 0x02	; 2
     6c0:	8d 91       	ld	r24, X+
     6c2:	9c 91       	ld	r25, X
     6c4:	13 97       	sbiw	r26, 0x03	; 3
     6c6:	05 c0       	rjmp	.+10     	; 0x6d2 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x58>
     6c8:	29 81       	ldd	r18, Y+1	; 0x01
     6ca:	3a 81       	ldd	r19, Y+2	; 0x02
     6cc:	23 2b       	or	r18, r19
     6ce:	b9 f7       	brne	.-18     	; 0x6be <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x44>
     6d0:	f1 cf       	rjmp	.-30     	; 0x6b4 <_ZN9I2CMaster11Transmitter11StatusState7executeER9frt_queueIhE+0x3a>
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <_ZN9I2CMaster11Transmitter9DoneState7executeER9frt_queueIhE>:
     6dc:	fc 01       	movw	r30, r24
     6de:	82 81       	ldd	r24, Z+2	; 0x02
     6e0:	93 81       	ldd	r25, Z+3	; 0x03
     6e2:	08 95       	ret

000006e4 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>:
     6e4:	0f 93       	push	r16
     6e6:	1f 93       	push	r17
     6e8:	cf 93       	push	r28
     6ea:	df 93       	push	r29
     6ec:	ec 01       	movw	r28, r24
     6ee:	8b 01       	movw	r16, r22
     6f0:	88 e0       	ldi	r24, 0x08	; 8
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
     6f8:	2a e0       	ldi	r18, 0x0A	; 10
     6fa:	30 e2       	ldi	r19, 0x20	; 32
     6fc:	fc 01       	movw	r30, r24
     6fe:	20 83       	st	Z, r18
     700:	31 83       	std	Z+1, r19	; 0x01
     702:	06 83       	std	Z+6, r16	; 0x06
     704:	17 83       	std	Z+7, r17	; 0x07
     706:	8a 83       	std	Y+2, r24	; 0x02
     708:	9b 83       	std	Y+3, r25	; 0x03
     70a:	8a e0       	ldi	r24, 0x0A	; 10
     70c:	90 e0       	ldi	r25, 0x00	; 0
     70e:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
     712:	fc 01       	movw	r30, r24
     714:	8d 85       	ldd	r24, Y+13	; 0x0d
     716:	9e 85       	ldd	r25, Y+14	; 0x0e
     718:	20 e1       	ldi	r18, 0x10	; 16
     71a:	30 e2       	ldi	r19, 0x20	; 32
     71c:	20 83       	st	Z, r18
     71e:	31 83       	std	Z+1, r19	; 0x01
     720:	06 83       	std	Z+6, r16	; 0x06
     722:	17 83       	std	Z+7, r17	; 0x07
     724:	80 87       	std	Z+8, r24	; 0x08
     726:	91 87       	std	Z+9, r25	; 0x09
     728:	ec 83       	std	Y+4, r30	; 0x04
     72a:	fd 83       	std	Y+5, r31	; 0x05
     72c:	88 e0       	ldi	r24, 0x08	; 8
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
     734:	26 e1       	ldi	r18, 0x16	; 22
     736:	30 e2       	ldi	r19, 0x20	; 32
     738:	fc 01       	movw	r30, r24
     73a:	20 83       	st	Z, r18
     73c:	31 83       	std	Z+1, r19	; 0x01
     73e:	06 83       	std	Z+6, r16	; 0x06
     740:	17 83       	std	Z+7, r17	; 0x07
     742:	88 87       	std	Y+8, r24	; 0x08
     744:	99 87       	std	Y+9, r25	; 0x09
     746:	80 e1       	ldi	r24, 0x10	; 16
     748:	97 e2       	ldi	r25, 0x27	; 39
     74a:	8d 87       	std	Y+13, r24	; 0x0d
     74c:	9e 87       	std	Y+14, r25	; 0x0e
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	1f 91       	pop	r17
     754:	0f 91       	pop	r16
     756:	08 95       	ret

00000758 <_ZN9I2CMaster12set_baudrateEm>:
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	9a 01       	movw	r18, r20
     760:	ab 01       	movw	r20, r22
     762:	22 0f       	add	r18, r18
     764:	33 1f       	adc	r19, r19
     766:	44 1f       	adc	r20, r20
     768:	55 1f       	adc	r21, r21
     76a:	60 e0       	ldi	r22, 0x00	; 0
     76c:	78 e4       	ldi	r23, 0x48	; 72
     76e:	88 ee       	ldi	r24, 0xE8	; 232
     770:	91 e0       	ldi	r25, 0x01	; 1
     772:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
     776:	25 50       	subi	r18, 0x05	; 5
     778:	2c 83       	std	Y+4, r18	; 0x04
     77a:	e8 81       	ld	r30, Y
     77c:	f9 81       	ldd	r31, Y+1	; 0x01
     77e:	25 83       	std	Z+5, r18	; 0x05
     780:	df 91       	pop	r29
     782:	cf 91       	pop	r28
     784:	08 95       	ret

00000786 <_ZN9I2CMasterC1EP10TWI_structm>:
     786:	af 92       	push	r10
     788:	bf 92       	push	r11
     78a:	cf 92       	push	r12
     78c:	df 92       	push	r13
     78e:	ef 92       	push	r14
     790:	ff 92       	push	r15
     792:	0f 93       	push	r16
     794:	1f 93       	push	r17
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	8c 01       	movw	r16, r24
     79c:	eb 01       	movw	r28, r22
     79e:	69 01       	movw	r12, r18
     7a0:	7a 01       	movw	r14, r20
     7a2:	dc 01       	movw	r26, r24
     7a4:	6d 93       	st	X+, r22
     7a6:	7c 93       	st	X, r23
     7a8:	fc 01       	movw	r30, r24
     7aa:	25 83       	std	Z+5, r18	; 0x05
     7ac:	36 83       	std	Z+6, r19	; 0x06
     7ae:	47 83       	std	Z+7, r20	; 0x07
     7b0:	50 87       	std	Z+8, r21	; 0x08
     7b2:	8f e0       	ldi	r24, 0x0F	; 15
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
     7ba:	5c 01       	movw	r10, r24
     7bc:	be 01       	movw	r22, r28
     7be:	0e 94 72 03 	call	0x6e4	; 0x6e4 <_ZN9I2CMaster11TransmitterC1EP10TWI_struct>
     7c2:	d8 01       	movw	r26, r16
     7c4:	53 96       	adiw	r26, 0x13	; 19
     7c6:	ad 92       	st	X+, r10
     7c8:	bc 92       	st	X, r11
     7ca:	54 97       	sbiw	r26, 0x14	; 20
     7cc:	c0 38       	cpi	r28, 0x80	; 128
     7ce:	b4 e0       	ldi	r27, 0x04	; 4
     7d0:	db 07       	cpc	r29, r27
     7d2:	31 f4       	brne	.+12     	; 0x7e0 <_ZN9I2CMasterC1EP10TWI_structm+0x5a>
     7d4:	80 e4       	ldi	r24, 0x40	; 64
     7d6:	96 e0       	ldi	r25, 0x06	; 6
     7d8:	f8 01       	movw	r30, r16
     7da:	82 83       	std	Z+2, r24	; 0x02
     7dc:	93 83       	std	Z+3, r25	; 0x03
     7de:	0b c0       	rjmp	.+22     	; 0x7f6 <_ZN9I2CMasterC1EP10TWI_structm+0x70>
     7e0:	c0 3a       	cpi	r28, 0xA0	; 160
     7e2:	f4 e0       	ldi	r31, 0x04	; 4
     7e4:	df 07       	cpc	r29, r31
     7e6:	39 f4       	brne	.+14     	; 0x7f6 <_ZN9I2CMasterC1EP10TWI_structm+0x70>
     7e8:	80 e8       	ldi	r24, 0x80	; 128
     7ea:	96 e0       	ldi	r25, 0x06	; 6
     7ec:	d8 01       	movw	r26, r16
     7ee:	12 96       	adiw	r26, 0x02	; 2
     7f0:	8d 93       	st	X+, r24
     7f2:	9c 93       	st	X, r25
     7f4:	13 97       	sbiw	r26, 0x03	; 3
     7f6:	d8 01       	movw	r26, r16
     7f8:	12 96       	adiw	r26, 0x02	; 2
     7fa:	ed 91       	ld	r30, X+
     7fc:	fc 91       	ld	r31, X
     7fe:	13 97       	sbiw	r26, 0x03	; 3
     800:	83 e0       	ldi	r24, 0x03	; 3
     802:	81 83       	std	Z+1, r24	; 0x01
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	ed 91       	ld	r30, X+
     808:	fc 91       	ld	r31, X
     80a:	13 97       	sbiw	r26, 0x03	; 3
     80c:	88 e3       	ldi	r24, 0x38	; 56
     80e:	80 8b       	std	Z+16, r24	; 0x10
     810:	12 96       	adiw	r26, 0x02	; 2
     812:	ed 91       	ld	r30, X+
     814:	fc 91       	ld	r31, X
     816:	13 97       	sbiw	r26, 0x03	; 3
     818:	81 8b       	std	Z+17, r24	; 0x11
     81a:	82 e0       	ldi	r24, 0x02	; 2
     81c:	8a 83       	std	Y+2, r24	; 0x02
     81e:	b7 01       	movw	r22, r14
     820:	a6 01       	movw	r20, r12
     822:	c8 01       	movw	r24, r16
     824:	0e 94 ac 03 	call	0x758	; 0x758 <_ZN9I2CMaster12set_baudrateEm>
     828:	8c 81       	ldd	r24, Y+4	; 0x04
     82a:	8d 6c       	ori	r24, 0xCD	; 205
     82c:	8c 83       	std	Y+4, r24	; 0x04
     82e:	88 e0       	ldi	r24, 0x08	; 8
     830:	89 83       	std	Y+1, r24	; 0x01
     832:	df 91       	pop	r29
     834:	cf 91       	pop	r28
     836:	1f 91       	pop	r17
     838:	0f 91       	pop	r16
     83a:	ff 90       	pop	r15
     83c:	ef 90       	pop	r14
     83e:	df 90       	pop	r13
     840:	cf 90       	pop	r12
     842:	bf 90       	pop	r11
     844:	af 90       	pop	r10
     846:	08 95       	ret

00000848 <_ZN9I2CMaster5writeEhPhhj>:
     848:	0f 93       	push	r16
     84a:	1f 93       	push	r17
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	1f 92       	push	r1
     852:	1f 92       	push	r1
     854:	cd b7       	in	r28, 0x3d	; 61
     856:	de b7       	in	r29, 0x3e	; 62
     858:	dc 01       	movw	r26, r24
     85a:	09 83       	std	Y+1, r16	; 0x01
     85c:	1a 83       	std	Y+2, r17	; 0x02
     85e:	ed 91       	ld	r30, X+
     860:	fc 91       	ld	r31, X
     862:	11 97       	sbiw	r26, 0x01	; 1
     864:	66 0f       	add	r22, r22
     866:	66 83       	std	Z+6, r22	; 0x06
     868:	89 81       	ldd	r24, Y+1	; 0x01
     86a:	9a 81       	ldd	r25, Y+2	; 0x02
     86c:	01 97       	sbiw	r24, 0x01	; 1
     86e:	89 83       	std	Y+1, r24	; 0x01
     870:	9a 83       	std	Y+2, r25	; 0x02
     872:	89 2b       	or	r24, r25
     874:	d1 f1       	breq	.+116    	; 0x8ea <_ZN9I2CMaster5writeEhPhhj+0xa2>
     876:	ed 91       	ld	r30, X+
     878:	fc 91       	ld	r31, X
     87a:	11 97       	sbiw	r26, 0x01	; 1
     87c:	84 81       	ldd	r24, Z+4	; 0x04
     87e:	86 ff       	sbrs	r24, 6
     880:	f3 cf       	rjmp	.-26     	; 0x868 <_ZN9I2CMaster5writeEhPhhj+0x20>
     882:	33 c0       	rjmp	.+102    	; 0x8ea <_ZN9I2CMaster5writeEhPhhj+0xa2>
     884:	22 23       	and	r18, r18
     886:	49 f1       	breq	.+82     	; 0x8da <_ZN9I2CMaster5writeEhPhhj+0x92>
     888:	ba 01       	movw	r22, r20
     88a:	21 50       	subi	r18, 0x01	; 1
     88c:	82 2f       	mov	r24, r18
     88e:	90 e0       	ldi	r25, 0x00	; 0
     890:	01 96       	adiw	r24, 0x01	; 1
     892:	48 0f       	add	r20, r24
     894:	59 1f       	adc	r21, r25
     896:	09 83       	std	Y+1, r16	; 0x01
     898:	1a 83       	std	Y+2, r17	; 0x02
     89a:	2d 91       	ld	r18, X+
     89c:	3c 91       	ld	r19, X
     89e:	11 97       	sbiw	r26, 0x01	; 1
     8a0:	fb 01       	movw	r30, r22
     8a2:	81 91       	ld	r24, Z+
     8a4:	bf 01       	movw	r22, r30
     8a6:	f9 01       	movw	r30, r18
     8a8:	87 83       	std	Z+7, r24	; 0x07
     8aa:	29 81       	ldd	r18, Y+1	; 0x01
     8ac:	3a 81       	ldd	r19, Y+2	; 0x02
     8ae:	21 50       	subi	r18, 0x01	; 1
     8b0:	31 09       	sbc	r19, r1
     8b2:	29 83       	std	Y+1, r18	; 0x01
     8b4:	3a 83       	std	Y+2, r19	; 0x02
     8b6:	23 2b       	or	r18, r19
     8b8:	f1 f0       	breq	.+60     	; 0x8f6 <_ZN9I2CMaster5writeEhPhhj+0xae>
     8ba:	ed 91       	ld	r30, X+
     8bc:	fc 91       	ld	r31, X
     8be:	11 97       	sbiw	r26, 0x01	; 1
     8c0:	94 81       	ldd	r25, Z+4	; 0x04
     8c2:	94 fd       	sbrc	r25, 4
     8c4:	f2 cf       	rjmp	.-28     	; 0x8aa <_ZN9I2CMaster5writeEhPhhj+0x62>
     8c6:	17 c0       	rjmp	.+46     	; 0x8f6 <_ZN9I2CMaster5writeEhPhhj+0xae>
     8c8:	ed 91       	ld	r30, X+
     8ca:	fc 91       	ld	r31, X
     8cc:	11 97       	sbiw	r26, 0x01	; 1
     8ce:	84 81       	ldd	r24, Z+4	; 0x04
     8d0:	80 64       	ori	r24, 0x40	; 64
     8d2:	84 83       	std	Z+4, r24	; 0x04
     8d4:	46 17       	cp	r20, r22
     8d6:	57 07       	cpc	r21, r23
     8d8:	f1 f6       	brne	.-68     	; 0x896 <_ZN9I2CMaster5writeEhPhhj+0x4e>
     8da:	ed 91       	ld	r30, X+
     8dc:	fc 91       	ld	r31, X
     8de:	83 e0       	ldi	r24, 0x03	; 3
     8e0:	83 83       	std	Z+3, r24	; 0x03
     8e2:	81 e0       	ldi	r24, 0x01	; 1
     8e4:	0d c0       	rjmp	.+26     	; 0x900 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	0b c0       	rjmp	.+22     	; 0x900 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8ea:	89 81       	ldd	r24, Y+1	; 0x01
     8ec:	9a 81       	ldd	r25, Y+2	; 0x02
     8ee:	89 2b       	or	r24, r25
     8f0:	49 f6       	brne	.-110    	; 0x884 <_ZN9I2CMaster5writeEhPhhj+0x3c>
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	05 c0       	rjmp	.+10     	; 0x900 <_ZN9I2CMaster5writeEhPhhj+0xb8>
     8f6:	29 81       	ldd	r18, Y+1	; 0x01
     8f8:	3a 81       	ldd	r19, Y+2	; 0x02
     8fa:	23 2b       	or	r18, r19
     8fc:	29 f7       	brne	.-54     	; 0x8c8 <_ZN9I2CMaster5writeEhPhhj+0x80>
     8fe:	f3 cf       	rjmp	.-26     	; 0x8e6 <_ZN9I2CMaster5writeEhPhhj+0x9e>
     900:	0f 90       	pop	r0
     902:	0f 90       	pop	r0
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	1f 91       	pop	r17
     90a:	0f 91       	pop	r16
     90c:	08 95       	ret

0000090e <_ZN9I2CMaster4readEhPhhj>:

bool I2CMaster::read (uint8_t slave_addr, uint8_t* data, uint8_t packet_len, uint16_t timeout)
{
     90e:	0f 93       	push	r16
     910:	1f 93       	push	r17
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
     916:	00 d0       	rcall	.+0      	; 0x918 <_ZN9I2CMaster4readEhPhhj+0xa>
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	dc 01       	movw	r26, r24
	volatile uint16_t counter;
	volatile uint8_t i;
	counter = timeout;
     91e:	09 83       	std	Y+1, r16	; 0x01
     920:	1a 83       	std	Y+2, r17	; 0x02
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
     922:	ed 91       	ld	r30, X+
     924:	fc 91       	ld	r31, X
     926:	11 97       	sbiw	r26, 0x01	; 1
     928:	66 0f       	add	r22, r22
     92a:	61 60       	ori	r22, 0x01	; 1
     92c:	66 83       	std	Z+6, r22	; 0x06
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	9a 81       	ldd	r25, Y+2	; 0x02
     932:	01 97       	sbiw	r24, 0x01	; 1
     934:	89 83       	std	Y+1, r24	; 0x01
     936:	9a 83       	std	Y+2, r25	; 0x02
     938:	89 2b       	or	r24, r25
     93a:	09 f4       	brne	.+2      	; 0x93e <_ZN9I2CMaster4readEhPhhj+0x30>
     93c:	47 c0       	rjmp	.+142    	; 0x9cc <_ZN9I2CMaster4readEhPhhj+0xbe>
     93e:	ed 91       	ld	r30, X+
     940:	fc 91       	ld	r31, X
     942:	11 97       	sbiw	r26, 0x01	; 1
     944:	84 81       	ldd	r24, Z+4	; 0x04
     946:	88 23       	and	r24, r24
     948:	94 f7       	brge	.-28     	; 0x92e <_ZN9I2CMaster4readEhPhhj+0x20>
     94a:	40 c0       	rjmp	.+128    	; 0x9cc <_ZN9I2CMaster4readEhPhhj+0xbe>
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     94c:	1b 82       	std	Y+3, r1	; 0x03
     94e:	8b 81       	ldd	r24, Y+3	; 0x03
     950:	82 17       	cp	r24, r18
     952:	d8 f5       	brcc	.+118    	; 0x9ca <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     954:	32 e0       	ldi	r19, 0x02	; 2
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
     956:	09 83       	std	Y+1, r16	; 0x01
     958:	1a 83       	std	Y+2, r17	; 0x02
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
     95a:	69 81       	ldd	r22, Y+1	; 0x01
     95c:	7a 81       	ldd	r23, Y+2	; 0x02
     95e:	61 50       	subi	r22, 0x01	; 1
     960:	71 09       	sbc	r23, r1
     962:	69 83       	std	Y+1, r22	; 0x01
     964:	7a 83       	std	Y+2, r23	; 0x02
     966:	67 2b       	or	r22, r23
     968:	c1 f1       	breq	.+112    	; 0x9da <_ZN9I2CMaster4readEhPhhj+0xcc>
     96a:	ed 91       	ld	r30, X+
     96c:	fc 91       	ld	r31, X
     96e:	11 97       	sbiw	r26, 0x01	; 1
     970:	94 81       	ldd	r25, Z+4	; 0x04
     972:	99 23       	and	r25, r25
     974:	94 f7       	brge	.-28     	; 0x95a <_ZN9I2CMaster4readEhPhhj+0x4c>
     976:	31 c0       	rjmp	.+98     	; 0x9da <_ZN9I2CMaster4readEhPhhj+0xcc>
			if (counter != 0)
			{
				data[i] = interface->MASTER.DATA;
     978:	9b 81       	ldd	r25, Y+3	; 0x03
     97a:	ed 91       	ld	r30, X+
     97c:	fc 91       	ld	r31, X
     97e:	11 97       	sbiw	r26, 0x01	; 1
     980:	87 81       	ldd	r24, Z+7	; 0x07
     982:	fa 01       	movw	r30, r20
     984:	e9 0f       	add	r30, r25
     986:	f1 1d       	adc	r31, r1
     988:	80 83       	st	Z, r24
				if (i < packet_len)
     98a:	8b 81       	ldd	r24, Y+3	; 0x03
     98c:	82 17       	cp	r24, r18
     98e:	88 f4       	brcc	.+34     	; 0x9b2 <_ZN9I2CMaster4readEhPhhj+0xa4>
	interface->MASTER.CTRLC |= (1<<TWI_MASTER_CMD0_bp);
}

void I2CMaster::byte_recv(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_CMD_RECVTRANS_gc;
     990:	ed 91       	ld	r30, X+
     992:	fc 91       	ld	r31, X
     994:	11 97       	sbiw	r26, 0x01	; 1
     996:	33 83       	std	Z+3, r19	; 0x03
			{
				data[i] = interface->MASTER.DATA;
				if (i < packet_len)
				{
					byte_recv();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     998:	ed 91       	ld	r30, X+
     99a:	fc 91       	ld	r31, X
     99c:	11 97       	sbiw	r26, 0x01	; 1
     99e:	84 81       	ldd	r24, Z+4	; 0x04
     9a0:	80 68       	ori	r24, 0x80	; 128
     9a2:	84 83       	std	Z+4, r24	; 0x04
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
	{
		for (i = 0; i < packet_len; ++i)
     9a4:	8b 81       	ldd	r24, Y+3	; 0x03
     9a6:	8f 5f       	subi	r24, 0xFF	; 255
     9a8:	8b 83       	std	Y+3, r24	; 0x03
     9aa:	8b 81       	ldd	r24, Y+3	; 0x03
     9ac:	82 17       	cp	r24, r18
     9ae:	98 f2       	brcs	.-90     	; 0x956 <_ZN9I2CMaster4readEhPhhj+0x48>
     9b0:	0c c0       	rjmp	.+24     	; 0x9ca <_ZN9I2CMaster4readEhPhhj+0xbc>
	interface->MASTER.CTRLC |= TWI_MASTER_CMD_REPSTART_gc;
}

void I2CMaster::send_nack_stop(void)
{
	interface->MASTER.CTRLC = TWI_MASTER_ACKACT_bm | TWI_MASTER_CMD_STOP_gc;
     9b2:	ed 91       	ld	r30, X+
     9b4:	fc 91       	ld	r31, X
     9b6:	11 97       	sbiw	r26, 0x01	; 1
     9b8:	87 e0       	ldi	r24, 0x07	; 7
     9ba:	83 83       	std	Z+3, r24	; 0x03
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
				}
				else
				{
					send_nack_stop();
					interface->MASTER.STATUS |= TWI_MASTER_RIF_bm;
     9bc:	ed 91       	ld	r30, X+
     9be:	fc 91       	ld	r31, X
     9c0:	84 81       	ldd	r24, Z+4	; 0x04
     9c2:	80 68       	ori	r24, 0x80	; 128
     9c4:	84 83       	std	Z+4, r24	; 0x04
					return true;
     9c6:	81 e0       	ldi	r24, 0x01	; 1
     9c8:	0d c0       	rjmp	.+26     	; 0x9e4 <_ZN9I2CMaster4readEhPhhj+0xd6>
	}
	else
	{
		return false;
	}
}
     9ca:	0c c0       	rjmp	.+24     	; 0x9e4 <_ZN9I2CMaster4readEhPhhj+0xd6>
	counter = timeout;
	
	interface->MASTER.ADDR = slave_addr << 1 | 1 << 0;
	
	while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }
	if (counter != 0)
     9cc:	89 81       	ldd	r24, Y+1	; 0x01
     9ce:	9a 81       	ldd	r25, Y+2	; 0x02
     9d0:	89 2b       	or	r24, r25
     9d2:	09 f0       	breq	.+2      	; 0x9d6 <_ZN9I2CMaster4readEhPhhj+0xc8>
     9d4:	bb cf       	rjmp	.-138    	; 0x94c <_ZN9I2CMaster4readEhPhhj+0x3e>
			}		
		}
	}
	else
	{
		return false;
     9d6:	80 e0       	ldi	r24, 0x00	; 0
     9d8:	05 c0       	rjmp	.+10     	; 0x9e4 <_ZN9I2CMaster4readEhPhhj+0xd6>
	{
		for (i = 0; i < packet_len; ++i)
		{
			counter = timeout;
			while ((--counter != 0) && !(interface->MASTER.STATUS & TWI_MASTER_RIF_bm)){ }			
			if (counter != 0)
     9da:	69 81       	ldd	r22, Y+1	; 0x01
     9dc:	7a 81       	ldd	r23, Y+2	; 0x02
     9de:	67 2b       	or	r22, r23
     9e0:	59 f6       	brne	.-106    	; 0x978 <_ZN9I2CMaster4readEhPhhj+0x6a>
					return true;
				}
			}
			else
			{
				return false;
     9e2:	80 e0       	ldi	r24, 0x00	; 0
	}
	else
	{
		return false;
	}
}
     9e4:	23 96       	adiw	r28, 0x03	; 3
     9e6:	cd bf       	out	0x3d, r28	; 61
     9e8:	de bf       	out	0x3e, r29	; 62
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	08 95       	ret

000009f4 <_ZN6MB120212RangeCommand11writePacketER9frt_queueIhE>:
}

bool MB1202::is_ready (void)
{
	return i2c->is_ready(slave_addr);
};
     9f4:	db 01       	movw	r26, r22
     9f6:	bc 01       	movw	r22, r24
     9f8:	6e 5f       	subi	r22, 0xFE	; 254
     9fa:	7f 4f       	sbci	r23, 0xFF	; 255
     9fc:	ed 91       	ld	r30, X+
     9fe:	fc 91       	ld	r31, X
     a00:	11 97       	sbiw	r26, 0x01	; 1
     a02:	01 90       	ld	r0, Z+
     a04:	f0 81       	ld	r31, Z
     a06:	e0 2d       	mov	r30, r0
     a08:	cd 01       	movw	r24, r26
     a0a:	19 95       	eicall
     a0c:	08 95       	ret

00000a0e <_ZN6MB1202C1EP9I2CMaster>:
     a0e:	cf 93       	push	r28
     a10:	df 93       	push	r29
     a12:	ec 01       	movw	r28, r24
     a14:	68 83       	st	Y, r22
     a16:	79 83       	std	Y+1, r23	; 0x01
     a18:	1c 82       	std	Y+4, r1	; 0x04
     a1a:	1d 82       	std	Y+5, r1	; 0x05
     a1c:	1e 82       	std	Y+6, r1	; 0x06
     a1e:	1f 82       	std	Y+7, r1	; 0x07
     a20:	18 86       	std	Y+8, r1	; 0x08
     a22:	83 e0       	ldi	r24, 0x03	; 3
     a24:	90 e0       	ldi	r25, 0x00	; 0
     a26:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
     a2a:	2c e1       	ldi	r18, 0x1C	; 28
     a2c:	30 e2       	ldi	r19, 0x20	; 32
     a2e:	fc 01       	movw	r30, r24
     a30:	20 83       	st	Z, r18
     a32:	31 83       	std	Z+1, r19	; 0x01
     a34:	21 e5       	ldi	r18, 0x51	; 81
     a36:	22 83       	std	Z+2, r18	; 0x02
     a38:	8b 87       	std	Y+11, r24	; 0x0b
     a3a:	9c 87       	std	Y+12, r25	; 0x0c
     a3c:	80 e7       	ldi	r24, 0x70	; 112
     a3e:	8a 83       	std	Y+2, r24	; 0x02
     a40:	2b 83       	std	Y+3, r18	; 0x03
     a42:	8a ea       	ldi	r24, 0xAA	; 170
     a44:	8c 83       	std	Y+4, r24	; 0x04
     a46:	85 ea       	ldi	r24, 0xA5	; 165
     a48:	8d 83       	std	Y+5, r24	; 0x05
     a4a:	df 91       	pop	r29
     a4c:	cf 91       	pop	r28
     a4e:	08 95       	ret

00000a50 <_ZN6MB120212take_readingEv>:

bool MB1202::take_reading (void)
{
     a50:	0f 93       	push	r16
     a52:	1f 93       	push	r17
	return i2c->write (slave_addr, range_cmd, 1);
     a54:	ac 01       	movw	r20, r24
     a56:	4d 5f       	subi	r20, 0xFD	; 253
     a58:	5f 4f       	sbci	r21, 0xFF	; 255
     a5a:	08 ee       	ldi	r16, 0xE8	; 232
     a5c:	13 e0       	ldi	r17, 0x03	; 3
     a5e:	21 e0       	ldi	r18, 0x01	; 1
     a60:	fc 01       	movw	r30, r24
     a62:	62 81       	ldd	r22, Z+2	; 0x02
     a64:	80 81       	ld	r24, Z
     a66:	91 81       	ldd	r25, Z+1	; 0x01
     a68:	0e 94 24 04 	call	0x848	; 0x848 <_ZN9I2CMaster5writeEhPhhj>
};
     a6c:	1f 91       	pop	r17
     a6e:	0f 91       	pop	r16
     a70:	08 95       	ret

00000a72 <_ZN6MB120211get_readingEv>:

uint16_t MB1202::get_reading (void)
{
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	ec 01       	movw	r28, r24
	i2c->read (slave_addr, bytes_received, 2);
     a7c:	ac 01       	movw	r20, r24
     a7e:	49 5f       	subi	r20, 0xF9	; 249
     a80:	5f 4f       	sbci	r21, 0xFF	; 255
     a82:	08 ee       	ldi	r16, 0xE8	; 232
     a84:	13 e0       	ldi	r17, 0x03	; 3
     a86:	22 e0       	ldi	r18, 0x02	; 2
     a88:	6a 81       	ldd	r22, Y+2	; 0x02
     a8a:	88 81       	ld	r24, Y
     a8c:	99 81       	ldd	r25, Y+1	; 0x01
     a8e:	0e 94 87 04 	call	0x90e	; 0x90e <_ZN9I2CMaster4readEhPhhj>
	range_reading = ((uint16_t) bytes_received[0] << 8) | ((uint16_t) bytes_received[1]);
     a92:	8f 81       	ldd	r24, Y+7	; 0x07
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	98 2f       	mov	r25, r24
     a98:	88 27       	eor	r24, r24
     a9a:	28 85       	ldd	r18, Y+8	; 0x08
     a9c:	82 2b       	or	r24, r18
     a9e:	89 87       	std	Y+9, r24	; 0x09
     aa0:	9a 87       	std	Y+10, r25	; 0x0a
	return range_reading;
}
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	1f 91       	pop	r17
     aa8:	0f 91       	pop	r16
     aaa:	08 95       	ret

00000aac <_ZN10task_sonar3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_sonar::run (void)
{
     aac:	ec 01       	movw	r28, r24
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     aae:	8c 85       	ldd	r24, Y+12	; 0x0c
     ab0:	88 23       	and	r24, r24
     ab2:	19 f0       	breq	.+6      	; 0xaba <_ZN10task_sonar3runEv+0xe>
     ab4:	81 30       	cpi	r24, 0x01	; 1
     ab6:	51 f0       	breq	.+20     	; 0xacc <_ZN10task_sonar3runEv+0x20>
     ab8:	25 c0       	rjmp	.+74     	; 0xb04 <_ZN10task_sonar3runEv+0x58>
			// In state 0, the motor task is waiting for the user to enter data before 
			// proceeding to its routine.
			case (0):
			    
				//*p_serial << PMS ("Sonar ready: ") << mb1202->take_reading() << endl;
				mb1202->take_reading();	
     aba:	8c 89       	ldd	r24, Y+20	; 0x14
     abc:	9d 89       	ldd	r25, Y+21	; 0x15
     abe:	0e 94 28 05 	call	0xa50	; 0xa50 <_ZN6MB120212take_readingEv>
				
				transition_to(1);			
     ac2:	61 e0       	ldi	r22, 0x01	; 1
     ac4:	ce 01       	movw	r24, r28
     ac6:	0e 94 61 13 	call	0x26c2	; 0x26c2 <_ZN8frt_task13transition_toEh>
			
			    break;
     aca:	1c c0       	rjmp	.+56     	; 0xb04 <_ZN10task_sonar3runEv+0x58>
				
			case (1):
			
				range_reading = mb1202->get_reading();
     acc:	8c 89       	ldd	r24, Y+20	; 0x14
     ace:	9d 89       	ldd	r25, Y+21	; 0x15
     ad0:	0e 94 39 05 	call	0xa72	; 0xa72 <_ZN6MB120211get_readingEv>
     ad4:	7c 01       	movw	r14, r24
     ad6:	8a 8b       	std	Y+18, r24	; 0x12
     ad8:	9b 8b       	std	Y+19, r25	; 0x13
				*p_serial << PMS ("Sonar: ") << range_reading << endl;
     ada:	6a e0       	ldi	r22, 0x0A	; 10
     adc:	8e 81       	ldd	r24, Y+6	; 0x06
     ade:	9f 81       	ldd	r25, Y+7	; 0x07
     ae0:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     ae4:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     ae6:	6a e1       	ldi	r22, 0x1A	; 26
     ae8:	73 e0       	ldi	r23, 0x03	; 3
     aea:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     aee:	b7 01       	movw	r22, r14
     af0:	c8 01       	movw	r24, r16
     af2:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
     af6:	66 e0       	ldi	r22, 0x06	; 6
     af8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
				
				transition_to(0);
     afc:	60 e0       	ldi	r22, 0x00	; 0
     afe:	ce 01       	movw	r24, r28
     b00:	0e 94 61 13 	call	0x26c2	; 0x26c2 <_ZN8frt_task13transition_toEh>
				break;
			

		} // End switch state

		runs++;                             // Increment counter for debugging
     b04:	8e 85       	ldd	r24, Y+14	; 0x0e
     b06:	9f 85       	ldd	r25, Y+15	; 0x0f
     b08:	a8 89       	ldd	r26, Y+16	; 0x10
     b0a:	b9 89       	ldd	r27, Y+17	; 0x11
     b0c:	01 96       	adiw	r24, 0x01	; 1
     b0e:	a1 1d       	adc	r26, r1
     b10:	b1 1d       	adc	r27, r1
     b12:	8e 87       	std	Y+14, r24	; 0x0e
     b14:	9f 87       	std	Y+15, r25	; 0x0f
     b16:	a8 8b       	std	Y+16, r26	; 0x10
     b18:	b9 8b       	std	Y+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (500));
     b1a:	64 ef       	ldi	r22, 0xF4	; 244
     b1c:	71 e0       	ldi	r23, 0x01	; 1
     b1e:	80 e0       	ldi	r24, 0x00	; 0
     b20:	90 e0       	ldi	r25, 0x00	; 0
     b22:	0e 94 35 11 	call	0x226a	; 0x226a <vTaskDelay>
	uint8_t addrs[10];
	

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     b26:	c3 cf       	rjmp	.-122    	; 0xaae <_ZN10task_sonar3runEv+0x2>

00000b28 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_sonar::task_sonar (const char* a_name, 
     b28:	cf 92       	push	r12
     b2a:	df 92       	push	r13
     b2c:	ef 92       	push	r14
     b2e:	ff 92       	push	r15
     b30:	0f 93       	push	r16
     b32:	1f 93       	push	r17
     b34:	cf 93       	push	r28
     b36:	df 93       	push	r29
     b38:	ec 01       	movw	r28, r24
     b3a:	6b 01       	movw	r12, r22
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev,
					  MB1202* mb1202
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev), mb1202(mb1202)
     b3c:	0e 94 65 13 	call	0x26ca	; 0x26ca <_ZN8frt_taskC1EPKchjP8emstream>
     b40:	82 e2       	ldi	r24, 0x22	; 34
     b42:	90 e2       	ldi	r25, 0x20	; 32
     b44:	88 83       	st	Y, r24
     b46:	99 83       	std	Y+1, r25	; 0x01
     b48:	ec 8a       	std	Y+20, r14	; 0x14
     b4a:	fd 8a       	std	Y+21, r15	; 0x15
{
	task_name = a_name;
     b4c:	ce 8a       	std	Y+22, r12	; 0x16
     b4e:	df 8a       	std	Y+23, r13	; 0x17
}
     b50:	df 91       	pop	r29
     b52:	cf 91       	pop	r28
     b54:	1f 91       	pop	r17
     b56:	0f 91       	pop	r16
     b58:	ff 90       	pop	r15
     b5a:	ef 90       	pop	r14
     b5c:	df 90       	pop	r13
     b5e:	cf 90       	pop	r12
     b60:	08 95       	ret

00000b62 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     b6c:	0e 94 65 13 	call	0x26ca	; 0x26ca <_ZN8frt_taskC1EPKchjP8emstream>
     b70:	8a e2       	ldi	r24, 0x2A	; 42
     b72:	90 e2       	ldi	r25, 0x20	; 32
     b74:	88 83       	st	Y, r24
     b76:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	08 95       	ret

00000b82 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     b82:	0f 93       	push	r16
     b84:	1f 93       	push	r17
     b86:	cf 93       	push	r28
     b88:	df 93       	push	r29
     b8a:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     b8c:	6a e0       	ldi	r22, 0x0A	; 10
     b8e:	8e 81       	ldd	r24, Y+6	; 0x06
     b90:	9f 81       	ldd	r25, Y+7	; 0x07
     b92:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     b96:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     b98:	65 e7       	ldi	r22, 0x75	; 117
     b9a:	74 e0       	ldi	r23, 0x04	; 4
     b9c:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     ba0:	6a e0       	ldi	r22, 0x0A	; 10
     ba2:	c8 01       	movw	r24, r16
     ba4:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     ba8:	8c 01       	movw	r16, r24
     baa:	6f e6       	ldi	r22, 0x6F	; 111
     bac:	74 e0       	ldi	r23, 0x04	; 4
     bae:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     bb2:	67 e0       	ldi	r22, 0x07	; 7
     bb4:	c8 01       	movw	r24, r16
     bb6:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     bba:	6a e0       	ldi	r22, 0x0A	; 10
     bbc:	8e 81       	ldd	r24, Y+6	; 0x06
     bbe:	9f 81       	ldd	r25, Y+7	; 0x07
     bc0:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     bc4:	8c 01       	movw	r16, r24
     bc6:	60 e5       	ldi	r22, 0x50	; 80
     bc8:	74 e0       	ldi	r23, 0x04	; 4
     bca:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     bce:	6a e0       	ldi	r22, 0x0A	; 10
     bd0:	c8 01       	movw	r24, r16
     bd2:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     bd6:	8c 01       	movw	r16, r24
     bd8:	6a e4       	ldi	r22, 0x4A	; 74
     bda:	74 e0       	ldi	r23, 0x04	; 4
     bdc:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     be0:	66 e0       	ldi	r22, 0x06	; 6
     be2:	c8 01       	movw	r24, r16
     be4:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     be8:	6a e0       	ldi	r22, 0x0A	; 10
     bea:	8e 81       	ldd	r24, Y+6	; 0x06
     bec:	9f 81       	ldd	r25, Y+7	; 0x07
     bee:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     bf2:	8c 01       	movw	r16, r24
     bf4:	63 e3       	ldi	r22, 0x33	; 51
     bf6:	74 e0       	ldi	r23, 0x04	; 4
     bf8:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     bfc:	66 e0       	ldi	r22, 0x06	; 6
     bfe:	c8 01       	movw	r24, r16
     c00:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     c04:	6a e0       	ldi	r22, 0x0A	; 10
     c06:	8e 81       	ldd	r24, Y+6	; 0x06
     c08:	9f 81       	ldd	r25, Y+7	; 0x07
     c0a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c0e:	8c 01       	movw	r16, r24
     c10:	67 e1       	ldi	r22, 0x17	; 23
     c12:	74 e0       	ldi	r23, 0x04	; 4
     c14:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     c18:	66 e0       	ldi	r22, 0x06	; 6
     c1a:	c8 01       	movw	r24, r16
     c1c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     c20:	6a e0       	ldi	r22, 0x0A	; 10
     c22:	8e 81       	ldd	r24, Y+6	; 0x06
     c24:	9f 81       	ldd	r25, Y+7	; 0x07
     c26:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c2a:	8c 01       	movw	r16, r24
     c2c:	6f ef       	ldi	r22, 0xFF	; 255
     c2e:	73 e0       	ldi	r23, 0x03	; 3
     c30:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     c34:	66 e0       	ldi	r22, 0x06	; 6
     c36:	c8 01       	movw	r24, r16
     c38:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     c3c:	6a e0       	ldi	r22, 0x0A	; 10
     c3e:	8e 81       	ldd	r24, Y+6	; 0x06
     c40:	9f 81       	ldd	r25, Y+7	; 0x07
     c42:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c46:	8c 01       	movw	r16, r24
     c48:	6e ed       	ldi	r22, 0xDE	; 222
     c4a:	73 e0       	ldi	r23, 0x03	; 3
     c4c:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     c50:	66 e0       	ldi	r22, 0x06	; 6
     c52:	c8 01       	movw	r24, r16
     c54:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     c58:	6a e0       	ldi	r22, 0x0A	; 10
     c5a:	8e 81       	ldd	r24, Y+6	; 0x06
     c5c:	9f 81       	ldd	r25, Y+7	; 0x07
     c5e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c62:	8c 01       	movw	r16, r24
     c64:	67 eb       	ldi	r22, 0xB7	; 183
     c66:	73 e0       	ldi	r23, 0x03	; 3
     c68:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     c6c:	66 e0       	ldi	r22, 0x06	; 6
     c6e:	c8 01       	movw	r24, r16
     c70:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     c74:	6a e0       	ldi	r22, 0x0A	; 10
     c76:	8e 81       	ldd	r24, Y+6	; 0x06
     c78:	9f 81       	ldd	r25, Y+7	; 0x07
     c7a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c7e:	8c 01       	movw	r16, r24
     c80:	69 e9       	ldi	r22, 0x99	; 153
     c82:	73 e0       	ldi	r23, 0x03	; 3
     c84:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     c88:	66 e0       	ldi	r22, 0x06	; 6
     c8a:	c8 01       	movw	r24, r16
     c8c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     c90:	6a e0       	ldi	r22, 0x0A	; 10
     c92:	8e 81       	ldd	r24, Y+6	; 0x06
     c94:	9f 81       	ldd	r25, Y+7	; 0x07
     c96:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     c9a:	8c 01       	movw	r16, r24
     c9c:	6e e7       	ldi	r22, 0x7E	; 126
     c9e:	73 e0       	ldi	r23, 0x03	; 3
     ca0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     ca4:	66 e0       	ldi	r22, 0x06	; 6
     ca6:	c8 01       	movw	r24, r16
     ca8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     cac:	6a e0       	ldi	r22, 0x0A	; 10
     cae:	8e 81       	ldd	r24, Y+6	; 0x06
     cb0:	9f 81       	ldd	r25, Y+7	; 0x07
     cb2:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     cb6:	ec 01       	movw	r28, r24
     cb8:	6f e6       	ldi	r22, 0x6F	; 111
     cba:	73 e0       	ldi	r23, 0x03	; 3
     cbc:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     cc0:	66 e0       	ldi	r22, 0x06	; 6
     cc2:	ce 01       	movw	r24, r28
     cc4:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
}
     cc8:	df 91       	pop	r29
     cca:	cf 91       	pop	r28
     ccc:	1f 91       	pop	r17
     cce:	0f 91       	pop	r16
     cd0:	08 95       	ret

00000cd2 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     cd2:	af 92       	push	r10
     cd4:	bf 92       	push	r11
     cd6:	cf 92       	push	r12
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	00 d0       	rcall	.+0      	; 0xce8 <_ZN9task_user11show_statusEv+0x16>
     ce8:	00 d0       	rcall	.+0      	; 0xcea <_ZN9task_user11show_statusEv+0x18>
     cea:	cd b7       	in	r28, 0x3d	; 61
     cec:	de b7       	in	r29, 0x3e	; 62
     cee:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     cf0:	19 82       	std	Y+1, r1	; 0x01
     cf2:	1a 82       	std	Y+2, r1	; 0x02
     cf4:	1b 82       	std	Y+3, r1	; 0x03
     cf6:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     cf8:	1d 82       	std	Y+5, r1	; 0x05
     cfa:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     cfc:	0e 94 ee 08 	call	0x11dc	; 0x11dc <xPortGetFreeHeapSize>
     d00:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     d02:	ce 01       	movw	r24, r28
     d04:	01 96       	adiw	r24, 0x01	; 1
     d06:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <_ZN10time_stamp10set_to_nowEv>
     d0a:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     d0c:	66 e0       	ldi	r22, 0x06	; 6
     d0e:	f8 01       	movw	r30, r16
     d10:	86 81       	ldd	r24, Z+6	; 0x06
     d12:	97 81       	ldd	r25, Z+7	; 0x07
     d14:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d18:	6a e0       	ldi	r22, 0x0A	; 10
     d1a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d1e:	7c 01       	movw	r14, r24
     d20:	60 e5       	ldi	r22, 0x50	; 80
     d22:	73 e0       	ldi	r23, 0x03	; 3
     d24:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     d28:	6a e0       	ldi	r22, 0x0A	; 10
     d2a:	c7 01       	movw	r24, r14
     d2c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d30:	7c 01       	movw	r14, r24
     d32:	64 e4       	ldi	r22, 0x44	; 68
     d34:	73 e0       	ldi	r23, 0x03	; 3
     d36:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     d3a:	66 e0       	ldi	r22, 0x06	; 6
     d3c:	c7 01       	movw	r24, r14
     d3e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     d42:	6a e0       	ldi	r22, 0x0A	; 10
     d44:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d48:	7c 01       	movw	r14, r24
     d4a:	6d e3       	ldi	r22, 0x3D	; 61
     d4c:	73 e0       	ldi	r23, 0x03	; 3
     d4e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     d52:	b5 01       	movw	r22, r10
     d54:	c7 01       	movw	r24, r14
     d56:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     d5a:	6a e0       	ldi	r22, 0x0A	; 10
     d5c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d60:	7c 01       	movw	r14, r24
     d62:	6f e2       	ldi	r22, 0x2F	; 47
     d64:	73 e0       	ldi	r23, 0x03	; 3
     d66:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     d6a:	b6 01       	movw	r22, r12
     d6c:	c7 01       	movw	r24, r14
     d6e:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
     d72:	6a e0       	ldi	r22, 0x0A	; 10
     d74:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     d78:	7c 01       	movw	r14, r24
     d7a:	6d e2       	ldi	r22, 0x2D	; 45
     d7c:	73 e0       	ldi	r23, 0x03	; 3
     d7e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     d82:	4f ef       	ldi	r20, 0xFF	; 255
     d84:	5f e0       	ldi	r21, 0x0F	; 15
     d86:	60 e0       	ldi	r22, 0x00	; 0
     d88:	70 e0       	ldi	r23, 0x00	; 0
     d8a:	c7 01       	movw	r24, r14
     d8c:	0e 94 45 19 	call	0x328a	; 0x328a <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     d90:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     d94:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     d98:	6a e0       	ldi	r22, 0x0A	; 10
     d9a:	f8 01       	movw	r30, r16
     d9c:	86 81       	ldd	r24, Z+6	; 0x06
     d9e:	97 81       	ldd	r25, Z+7	; 0x07
     da0:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     da4:	7c 01       	movw	r14, r24
     da6:	62 e2       	ldi	r22, 0x22	; 34
     da8:	73 e0       	ldi	r23, 0x03	; 3
     daa:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     dae:	b6 01       	movw	r22, r12
     db0:	c7 01       	movw	r24, r14
     db2:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
     db6:	66 e0       	ldi	r22, 0x06	; 6
     db8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     dbc:	66 e0       	ldi	r22, 0x06	; 6
     dbe:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     dc2:	f8 01       	movw	r30, r16
     dc4:	86 81       	ldd	r24, Z+6	; 0x06
     dc6:	97 81       	ldd	r25, Z+7	; 0x07
     dc8:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <_Z15print_task_listP8emstream>
}
     dcc:	26 96       	adiw	r28, 0x06	; 6
     dce:	cd bf       	out	0x3d, r28	; 61
     dd0:	de bf       	out	0x3e, r29	; 62
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	1f 91       	pop	r17
     dd8:	0f 91       	pop	r16
     dda:	ff 90       	pop	r15
     ddc:	ef 90       	pop	r14
     dde:	df 90       	pop	r13
     de0:	cf 90       	pop	r12
     de2:	bf 90       	pop	r11
     de4:	af 90       	pop	r10
     de6:	08 95       	ret

00000de8 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     de8:	cf 93       	push	r28
     dea:	df 93       	push	r29
     dec:	00 d0       	rcall	.+0      	; 0xdee <_ZN9task_user3runEv+0x6>
     dee:	00 d0       	rcall	.+0      	; 0xdf0 <_ZN9task_user3runEv+0x8>
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     df6:	19 82       	std	Y+1, r1	; 0x01
     df8:	1a 82       	std	Y+2, r1	; 0x02
     dfa:	1b 82       	std	Y+3, r1	; 0x03
     dfc:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     dfe:	1d 82       	std	Y+5, r1	; 0x05
     e00:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     e02:	6a e0       	ldi	r22, 0x0A	; 10
     e04:	dc 01       	movw	r26, r24
     e06:	16 96       	adiw	r26, 0x06	; 6
     e08:	8d 91       	ld	r24, X+
     e0a:	9c 91       	ld	r25, X
     e0c:	17 97       	sbiw	r26, 0x07	; 7
     e0e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     e12:	7c 01       	movw	r14, r24
     e14:	6e eb       	ldi	r22, 0xBE	; 190
     e16:	74 e0       	ldi	r23, 0x04	; 4
     e18:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     e1c:	66 e0       	ldi	r22, 0x06	; 6
     e1e:	c7 01       	movw	r24, r14
     e20:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     e24:	f8 01       	movw	r30, r16
     e26:	84 85       	ldd	r24, Z+12	; 0x0c
     e28:	88 23       	and	r24, r24
     e2a:	21 f0       	breq	.+8      	; 0xe34 <_ZN9task_user3runEv+0x4c>
     e2c:	81 30       	cpi	r24, 0x01	; 1
     e2e:	09 f4       	brne	.+2      	; 0xe32 <_ZN9task_user3runEv+0x4a>
     e30:	5d c0       	rjmp	.+186    	; 0xeec <_ZN9task_user3runEv+0x104>
     e32:	d8 c0       	rjmp	.+432    	; 0xfe4 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     e34:	86 81       	ldd	r24, Z+6	; 0x06
     e36:	97 81       	ldd	r25, Z+7	; 0x07
     e38:	dc 01       	movw	r26, r24
     e3a:	ed 91       	ld	r30, X+
     e3c:	fc 91       	ld	r31, X
     e3e:	04 80       	ldd	r0, Z+4	; 0x04
     e40:	f5 81       	ldd	r31, Z+5	; 0x05
     e42:	e0 2d       	mov	r30, r0
     e44:	19 95       	eicall
     e46:	88 23       	and	r24, r24
     e48:	a9 f1       	breq	.+106    	; 0xeb4 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     e4a:	f8 01       	movw	r30, r16
     e4c:	86 81       	ldd	r24, Z+6	; 0x06
     e4e:	97 81       	ldd	r25, Z+7	; 0x07
     e50:	dc 01       	movw	r26, r24
     e52:	ed 91       	ld	r30, X+
     e54:	fc 91       	ld	r31, X
     e56:	06 80       	ldd	r0, Z+6	; 0x06
     e58:	f7 81       	ldd	r31, Z+7	; 0x07
     e5a:	e0 2d       	mov	r30, r0
     e5c:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     e5e:	99 27       	eor	r25, r25
     e60:	81 30       	cpi	r24, 0x01	; 1
     e62:	91 05       	cpc	r25, r1
     e64:	f9 f0       	breq	.+62     	; 0xea4 <_ZN9task_user3runEv+0xbc>
     e66:	03 97       	sbiw	r24, 0x03	; 3
     e68:	09 f0       	breq	.+2      	; 0xe6c <_ZN9task_user3runEv+0x84>
     e6a:	d8 c0       	rjmp	.+432    	; 0x101c <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     e6c:	6a e0       	ldi	r22, 0x0A	; 10
     e6e:	f8 01       	movw	r30, r16
     e70:	86 81       	ldd	r24, Z+6	; 0x06
     e72:	97 81       	ldd	r25, Z+7	; 0x07
     e74:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     e78:	8c 01       	movw	r16, r24
     e7a:	60 eb       	ldi	r22, 0xB0	; 176
     e7c:	74 e0       	ldi	r23, 0x04	; 4
     e7e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     e82:	66 e0       	ldi	r22, 0x06	; 6
     e84:	c8 01       	movw	r24, r16
     e86:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     e8a:	93 e0       	ldi	r25, 0x03	; 3
     e8c:	88 ed       	ldi	r24, 0xD8	; 216
     e8e:	08 b6       	in	r0, 0x38	; 56
     e90:	18 be       	out	0x38, r1	; 56
     e92:	84 bf       	out	0x34, r24	; 52
     e94:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     e98:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     e9c:	81 fd       	sbrc	r24, 1
     e9e:	fc cf       	rjmp	.-8      	; 0xe98 <_ZN9task_user3runEv+0xb0>
     ea0:	08 be       	out	0x38, r0	; 56
     ea2:	ff cf       	rjmp	.-2      	; 0xea2 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     ea4:	c8 01       	movw	r24, r16
     ea6:	0e 94 c1 05 	call	0xb82	; 0xb82 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     eaa:	61 e0       	ldi	r22, 0x01	; 1
     eac:	c8 01       	movw	r24, r16
     eae:	0e 94 61 13 	call	0x26c2	; 0x26c2 <_ZN8frt_task13transition_toEh>
							break;
     eb2:	b4 c0       	rjmp	.+360    	; 0x101c <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     eb4:	8c e9       	ldi	r24, 0x9C	; 156
     eb6:	91 e3       	ldi	r25, 0x31	; 49
     eb8:	0e 94 22 16 	call	0x2c44	; 0x2c44 <_ZN14frt_text_queue14check_for_charEv>
     ebc:	88 23       	and	r24, r24
     ebe:	09 f4       	brne	.+2      	; 0xec2 <_ZN9task_user3runEv+0xda>
     ec0:	ad c0       	rjmp	.+346    	; 0x101c <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     ec2:	d8 01       	movw	r26, r16
     ec4:	16 96       	adiw	r26, 0x06	; 6
     ec6:	ed 91       	ld	r30, X+
     ec8:	fc 91       	ld	r31, X
     eca:	17 97       	sbiw	r26, 0x07	; 7
     ecc:	01 90       	ld	r0, Z+
     ece:	f0 81       	ld	r31, Z
     ed0:	e0 2d       	mov	r30, r0
     ed2:	e2 80       	ldd	r14, Z+2	; 0x02
     ed4:	f3 80       	ldd	r15, Z+3	; 0x03
     ed6:	8c e9       	ldi	r24, 0x9C	; 156
     ed8:	91 e3       	ldi	r25, 0x31	; 49
     eda:	0e 94 04 16 	call	0x2c08	; 0x2c08 <_ZN14frt_text_queue7getcharEv>
     ede:	68 2f       	mov	r22, r24
     ee0:	f8 01       	movw	r30, r16
     ee2:	86 81       	ldd	r24, Z+6	; 0x06
     ee4:	97 81       	ldd	r25, Z+7	; 0x07
     ee6:	f7 01       	movw	r30, r14
     ee8:	19 95       	eicall
     eea:	98 c0       	rjmp	.+304    	; 0x101c <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     eec:	86 81       	ldd	r24, Z+6	; 0x06
     eee:	97 81       	ldd	r25, Z+7	; 0x07
     ef0:	dc 01       	movw	r26, r24
     ef2:	ed 91       	ld	r30, X+
     ef4:	fc 91       	ld	r31, X
     ef6:	04 80       	ldd	r0, Z+4	; 0x04
     ef8:	f5 81       	ldd	r31, Z+5	; 0x05
     efa:	e0 2d       	mov	r30, r0
     efc:	19 95       	eicall
     efe:	88 23       	and	r24, r24
     f00:	09 f4       	brne	.+2      	; 0xf04 <_ZN9task_user3runEv+0x11c>
     f02:	8c c0       	rjmp	.+280    	; 0x101c <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     f04:	f8 01       	movw	r30, r16
     f06:	86 81       	ldd	r24, Z+6	; 0x06
     f08:	97 81       	ldd	r25, Z+7	; 0x07
     f0a:	dc 01       	movw	r26, r24
     f0c:	ed 91       	ld	r30, X+
     f0e:	fc 91       	ld	r31, X
     f10:	06 80       	ldd	r0, Z+6	; 0x06
     f12:	f7 81       	ldd	r31, Z+7	; 0x07
     f14:	e0 2d       	mov	r30, r0
     f16:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     f18:	9c 01       	movw	r18, r24
     f1a:	33 27       	eor	r19, r19
     f1c:	28 36       	cpi	r18, 0x68	; 104
     f1e:	31 05       	cpc	r19, r1
     f20:	59 f1       	breq	.+86     	; 0xf78 <_ZN9task_user3runEv+0x190>
     f22:	3c f4       	brge	.+14     	; 0xf32 <_ZN9task_user3runEv+0x14a>
     f24:	2b 31       	cpi	r18, 0x1B	; 27
     f26:	31 05       	cpc	r19, r1
     f28:	59 f1       	breq	.+86     	; 0xf80 <_ZN9task_user3runEv+0x198>
     f2a:	25 36       	cpi	r18, 0x65	; 101
     f2c:	31 05       	cpc	r19, r1
     f2e:	41 f1       	breq	.+80     	; 0xf80 <_ZN9task_user3runEv+0x198>
     f30:	3b c0       	rjmp	.+118    	; 0xfa8 <_ZN9task_user3runEv+0x1c0>
     f32:	23 37       	cpi	r18, 0x73	; 115
     f34:	31 05       	cpc	r19, r1
     f36:	c1 f0       	breq	.+48     	; 0xf68 <_ZN9task_user3runEv+0x180>
     f38:	26 37       	cpi	r18, 0x76	; 118
     f3a:	31 05       	cpc	r19, r1
     f3c:	89 f0       	breq	.+34     	; 0xf60 <_ZN9task_user3runEv+0x178>
     f3e:	2e 36       	cpi	r18, 0x6E	; 110
     f40:	31 05       	cpc	r19, r1
     f42:	91 f5       	brne	.+100    	; 0xfa8 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     f44:	ce 01       	movw	r24, r28
     f46:	01 96       	adiw	r24, 0x01	; 1
     f48:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <_ZN10time_stamp10set_to_nowEv>
     f4c:	bc 01       	movw	r22, r24
     f4e:	f8 01       	movw	r30, r16
     f50:	86 81       	ldd	r24, Z+6	; 0x06
     f52:	97 81       	ldd	r25, Z+7	; 0x07
     f54:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_ZlsR8emstreamR10time_stamp>
     f58:	66 e0       	ldi	r22, 0x06	; 6
     f5a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
							break;
     f5e:	5e c0       	rjmp	.+188    	; 0x101c <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     f60:	c8 01       	movw	r24, r16
     f62:	0e 94 69 06 	call	0xcd2	; 0xcd2 <_ZN9task_user11show_statusEv>
							break;
     f66:	5a c0       	rjmp	.+180    	; 0x101c <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     f68:	d8 01       	movw	r26, r16
     f6a:	16 96       	adiw	r26, 0x06	; 6
     f6c:	8d 91       	ld	r24, X+
     f6e:	9c 91       	ld	r25, X
     f70:	17 97       	sbiw	r26, 0x07	; 7
     f72:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <_Z17print_task_stacksP8emstream>
							break;
     f76:	52 c0       	rjmp	.+164    	; 0x101c <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     f78:	c8 01       	movw	r24, r16
     f7a:	0e 94 c1 05 	call	0xb82	; 0xb82 <_ZN9task_user18print_help_messageEv>
							break;
     f7e:	4e c0       	rjmp	.+156    	; 0x101c <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     f80:	6a e0       	ldi	r22, 0x0A	; 10
     f82:	f8 01       	movw	r30, r16
     f84:	86 81       	ldd	r24, Z+6	; 0x06
     f86:	97 81       	ldd	r25, Z+7	; 0x07
     f88:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     f8c:	7c 01       	movw	r14, r24
     f8e:	6e e9       	ldi	r22, 0x9E	; 158
     f90:	74 e0       	ldi	r23, 0x04	; 4
     f92:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     f96:	66 e0       	ldi	r22, 0x06	; 6
     f98:	c7 01       	movw	r24, r14
     f9a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     f9e:	60 e0       	ldi	r22, 0x00	; 0
     fa0:	c8 01       	movw	r24, r16
     fa2:	0e 94 61 13 	call	0x26c2	; 0x26c2 <_ZN8frt_task13transition_toEh>
							break;
     fa6:	3a c0       	rjmp	.+116    	; 0x101c <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     fa8:	f8 01       	movw	r30, r16
     faa:	a6 81       	ldd	r26, Z+6	; 0x06
     fac:	b7 81       	ldd	r27, Z+7	; 0x07
     fae:	ed 91       	ld	r30, X+
     fb0:	fc 91       	ld	r31, X
     fb2:	11 97       	sbiw	r26, 0x01	; 1
     fb4:	02 80       	ldd	r0, Z+2	; 0x02
     fb6:	f3 81       	ldd	r31, Z+3	; 0x03
     fb8:	e0 2d       	mov	r30, r0
     fba:	68 2f       	mov	r22, r24
     fbc:	cd 01       	movw	r24, r26
     fbe:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     fc0:	6a e0       	ldi	r22, 0x0A	; 10
     fc2:	d8 01       	movw	r26, r16
     fc4:	16 96       	adiw	r26, 0x06	; 6
     fc6:	8d 91       	ld	r24, X+
     fc8:	9c 91       	ld	r25, X
     fca:	17 97       	sbiw	r26, 0x07	; 7
     fcc:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     fd0:	7c 01       	movw	r14, r24
     fd2:	68 e9       	ldi	r22, 0x98	; 152
     fd4:	74 e0       	ldi	r23, 0x04	; 4
     fd6:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     fda:	66 e0       	ldi	r22, 0x06	; 6
     fdc:	c7 01       	movw	r24, r14
     fde:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
							break;
     fe2:	1c c0       	rjmp	.+56     	; 0x101c <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     fe4:	6a e0       	ldi	r22, 0x0A	; 10
     fe6:	f8 01       	movw	r30, r16
     fe8:	86 81       	ldd	r24, Z+6	; 0x06
     fea:	97 81       	ldd	r25, Z+7	; 0x07
     fec:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
     ff0:	8c 01       	movw	r16, r24
     ff2:	6b e7       	ldi	r22, 0x7B	; 123
     ff4:	74 e0       	ldi	r23, 0x04	; 4
     ff6:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
     ffa:	66 e0       	ldi	r22, 0x06	; 6
     ffc:	c8 01       	movw	r24, r16
     ffe:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
    1002:	93 e0       	ldi	r25, 0x03	; 3
    1004:	88 ed       	ldi	r24, 0xD8	; 216
    1006:	08 b6       	in	r0, 0x38	; 56
    1008:	18 be       	out	0x38, r1	; 56
    100a:	84 bf       	out	0x34, r24	; 52
    100c:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    1010:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
    1014:	81 fd       	sbrc	r24, 1
    1016:	fc cf       	rjmp	.-8      	; 0x1010 <_ZN9task_user3runEv+0x228>
    1018:	08 be       	out	0x38, r0	; 56
    101a:	ff cf       	rjmp	.-2      	; 0x101a <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
    101c:	f8 01       	movw	r30, r16
    101e:	86 85       	ldd	r24, Z+14	; 0x0e
    1020:	97 85       	ldd	r25, Z+15	; 0x0f
    1022:	a0 89       	ldd	r26, Z+16	; 0x10
    1024:	b1 89       	ldd	r27, Z+17	; 0x11
    1026:	01 96       	adiw	r24, 0x01	; 1
    1028:	a1 1d       	adc	r26, r1
    102a:	b1 1d       	adc	r27, r1
    102c:	86 87       	std	Z+14, r24	; 0x0e
    102e:	97 87       	std	Z+15, r25	; 0x0f
    1030:	a0 8b       	std	Z+16, r26	; 0x10
    1032:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
    1034:	61 e0       	ldi	r22, 0x01	; 1
    1036:	70 e0       	ldi	r23, 0x00	; 0
    1038:	80 e0       	ldi	r24, 0x00	; 0
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	0e 94 35 11 	call	0x226a	; 0x226a <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
    1040:	f1 ce       	rjmp	.-542    	; 0xe24 <_ZN9task_user3runEv+0x3c>

00001042 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1042:	0f 93       	push	r16
    1044:	1f 93       	push	r17
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
    104a:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    104c:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    1050:	80 91 e0 20 	lds	r24, 0x20E0	; 0x8020e0 <__data_end>
    1054:	81 11       	cpse	r24, r1
    1056:	1d c0       	rjmp	.+58     	; 0x1092 <pvPortMalloc+0x50>
		{
			prvHeapInit();
    1058:	a5 ee       	ldi	r26, 0xE5	; 229
    105a:	b0 e2       	ldi	r27, 0x20	; 32
    105c:	e9 ee       	ldi	r30, 0xE9	; 233
    105e:	f0 e2       	ldi	r31, 0x20	; 32
    1060:	ed 93       	st	X+, r30
    1062:	fc 93       	st	X, r31
    1064:	11 97       	sbiw	r26, 0x01	; 1
    1066:	12 96       	adiw	r26, 0x02	; 2
    1068:	1d 92       	st	X+, r1
    106a:	1c 92       	st	X, r1
    106c:	13 97       	sbiw	r26, 0x03	; 3
    106e:	a1 ee       	ldi	r26, 0xE1	; 225
    1070:	b0 e2       	ldi	r27, 0x20	; 32
    1072:	8f ef       	ldi	r24, 0xFF	; 255
    1074:	9f e0       	ldi	r25, 0x0F	; 15
    1076:	12 96       	adiw	r26, 0x02	; 2
    1078:	8d 93       	st	X+, r24
    107a:	9c 93       	st	X, r25
    107c:	13 97       	sbiw	r26, 0x03	; 3
    107e:	1d 92       	st	X+, r1
    1080:	1c 92       	st	X, r1
    1082:	11 97       	sbiw	r26, 0x01	; 1
    1084:	82 83       	std	Z+2, r24	; 0x02
    1086:	93 83       	std	Z+3, r25	; 0x03
    1088:	a0 83       	st	Z, r26
    108a:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	80 93 e0 20 	sts	0x20E0, r24	; 0x8020e0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    1092:	20 97       	sbiw	r28, 0x00	; 0
    1094:	09 f4       	brne	.+2      	; 0x1098 <pvPortMalloc+0x56>
    1096:	5f c0       	rjmp	.+190    	; 0x1156 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    1098:	9e 01       	movw	r18, r28
    109a:	2b 5f       	subi	r18, 0xFB	; 251
    109c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    109e:	24 96       	adiw	r28, 0x04	; 4
    10a0:	ce 3f       	cpi	r28, 0xFE	; 254
    10a2:	df 40       	sbci	r29, 0x0F	; 15
    10a4:	08 f0       	brcs	.+2      	; 0x10a8 <pvPortMalloc+0x66>
    10a6:	5a c0       	rjmp	.+180    	; 0x115c <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    10a8:	e0 91 e5 20 	lds	r30, 0x20E5	; 0x8020e5 <xStart>
    10ac:	f0 91 e6 20 	lds	r31, 0x20E6	; 0x8020e6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    10b0:	a5 ee       	ldi	r26, 0xE5	; 229
    10b2:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    10b4:	02 c0       	rjmp	.+4      	; 0x10ba <pvPortMalloc+0x78>
    10b6:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    10b8:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    10ba:	82 81       	ldd	r24, Z+2	; 0x02
    10bc:	93 81       	ldd	r25, Z+3	; 0x03
    10be:	82 17       	cp	r24, r18
    10c0:	93 07       	cpc	r25, r19
    10c2:	20 f4       	brcc	.+8      	; 0x10cc <pvPortMalloc+0x8a>
    10c4:	80 81       	ld	r24, Z
    10c6:	91 81       	ldd	r25, Z+1	; 0x01
    10c8:	00 97       	sbiw	r24, 0x00	; 0
    10ca:	a9 f7       	brne	.-22     	; 0x10b6 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    10cc:	c0 e2       	ldi	r28, 0x20	; 32
    10ce:	e1 3e       	cpi	r30, 0xE1	; 225
    10d0:	fc 07       	cpc	r31, r28
    10d2:	09 f4       	brne	.+2      	; 0x10d6 <pvPortMalloc+0x94>
    10d4:	46 c0       	rjmp	.+140    	; 0x1162 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    10d6:	cd 91       	ld	r28, X+
    10d8:	dc 91       	ld	r29, X
    10da:	11 97       	sbiw	r26, 0x01	; 1
    10dc:	8e 01       	movw	r16, r28
    10de:	0b 5f       	subi	r16, 0xFB	; 251
    10e0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    10e2:	80 81       	ld	r24, Z
    10e4:	91 81       	ldd	r25, Z+1	; 0x01
    10e6:	8d 93       	st	X+, r24
    10e8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    10ea:	82 81       	ldd	r24, Z+2	; 0x02
    10ec:	93 81       	ldd	r25, Z+3	; 0x03
    10ee:	82 1b       	sub	r24, r18
    10f0:	93 0b       	sbc	r25, r19
    10f2:	8b 30       	cpi	r24, 0x0B	; 11
    10f4:	91 05       	cpc	r25, r1
    10f6:	10 f1       	brcs	.+68     	; 0x113c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    10f8:	bf 01       	movw	r22, r30
    10fa:	62 0f       	add	r22, r18
    10fc:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    10fe:	db 01       	movw	r26, r22
    1100:	12 96       	adiw	r26, 0x02	; 2
    1102:	8d 93       	st	X+, r24
    1104:	9c 93       	st	X, r25
    1106:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    1108:	22 83       	std	Z+2, r18	; 0x02
    110a:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    110c:	12 96       	adiw	r26, 0x02	; 2
    110e:	4d 91       	ld	r20, X+
    1110:	5c 91       	ld	r21, X
    1112:	13 97       	sbiw	r26, 0x03	; 3
    1114:	85 ee       	ldi	r24, 0xE5	; 229
    1116:	90 e2       	ldi	r25, 0x20	; 32
    1118:	01 c0       	rjmp	.+2      	; 0x111c <pvPortMalloc+0xda>
    111a:	cd 01       	movw	r24, r26
    111c:	ec 01       	movw	r28, r24
    111e:	a8 81       	ld	r26, Y
    1120:	b9 81       	ldd	r27, Y+1	; 0x01
    1122:	12 96       	adiw	r26, 0x02	; 2
    1124:	2d 91       	ld	r18, X+
    1126:	3c 91       	ld	r19, X
    1128:	13 97       	sbiw	r26, 0x03	; 3
    112a:	24 17       	cp	r18, r20
    112c:	35 07       	cpc	r19, r21
    112e:	a8 f3       	brcs	.-22     	; 0x111a <pvPortMalloc+0xd8>
    1130:	eb 01       	movw	r28, r22
    1132:	a8 83       	st	Y, r26
    1134:	b9 83       	std	Y+1, r27	; 0x01
    1136:	dc 01       	movw	r26, r24
    1138:	6d 93       	st	X+, r22
    113a:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    113c:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    1140:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    1144:	22 81       	ldd	r18, Z+2	; 0x02
    1146:	33 81       	ldd	r19, Z+3	; 0x03
    1148:	82 1b       	sub	r24, r18
    114a:	93 0b       	sbc	r25, r19
    114c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    1150:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
    1154:	08 c0       	rjmp	.+16     	; 0x1166 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1156:	00 e0       	ldi	r16, 0x00	; 0
    1158:	10 e0       	ldi	r17, 0x00	; 0
    115a:	05 c0       	rjmp	.+10     	; 0x1166 <pvPortMalloc+0x124>
    115c:	00 e0       	ldi	r16, 0x00	; 0
    115e:	10 e0       	ldi	r17, 0x00	; 0
    1160:	02 c0       	rjmp	.+4      	; 0x1166 <pvPortMalloc+0x124>
    1162:	00 e0       	ldi	r16, 0x00	; 0
    1164:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1166:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    116a:	c8 01       	movw	r24, r16
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	1f 91       	pop	r17
    1172:	0f 91       	pop	r16
    1174:	08 95       	ret

00001176 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1176:	0f 93       	push	r16
    1178:	1f 93       	push	r17
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    117e:	00 97       	sbiw	r24, 0x00	; 0
    1180:	41 f1       	breq	.+80     	; 0x11d2 <vPortFree+0x5c>
    1182:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    1184:	8c 01       	movw	r16, r24
    1186:	05 50       	subi	r16, 0x05	; 5
    1188:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    118a:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    118e:	f8 01       	movw	r30, r16
    1190:	42 81       	ldd	r20, Z+2	; 0x02
    1192:	53 81       	ldd	r21, Z+3	; 0x03
    1194:	a5 ee       	ldi	r26, 0xE5	; 229
    1196:	b0 e2       	ldi	r27, 0x20	; 32
    1198:	01 c0       	rjmp	.+2      	; 0x119c <vPortFree+0x26>
    119a:	df 01       	movw	r26, r30
    119c:	ed 91       	ld	r30, X+
    119e:	fc 91       	ld	r31, X
    11a0:	11 97       	sbiw	r26, 0x01	; 1
    11a2:	22 81       	ldd	r18, Z+2	; 0x02
    11a4:	33 81       	ldd	r19, Z+3	; 0x03
    11a6:	24 17       	cp	r18, r20
    11a8:	35 07       	cpc	r19, r21
    11aa:	b8 f3       	brcs	.-18     	; 0x119a <vPortFree+0x24>
    11ac:	25 97       	sbiw	r28, 0x05	; 5
    11ae:	e8 83       	st	Y, r30
    11b0:	f9 83       	std	Y+1, r31	; 0x01
    11b2:	0d 93       	st	X+, r16
    11b4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    11b6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    11ba:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    11be:	8a 81       	ldd	r24, Y+2	; 0x02
    11c0:	9b 81       	ldd	r25, Y+3	; 0x03
    11c2:	82 0f       	add	r24, r18
    11c4:	93 1f       	adc	r25, r19
    11c6:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
    11ca:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
    11ce:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
	}
}
    11d2:	df 91       	pop	r29
    11d4:	cf 91       	pop	r28
    11d6:	1f 91       	pop	r17
    11d8:	0f 91       	pop	r16
    11da:	08 95       	ret

000011dc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    11dc:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
    11e0:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
    11e4:	08 95       	ret

000011e6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    11e6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    11e8:	03 96       	adiw	r24, 0x03	; 3
    11ea:	81 83       	std	Z+1, r24	; 0x01
    11ec:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    11ee:	4f ef       	ldi	r20, 0xFF	; 255
    11f0:	5f ef       	ldi	r21, 0xFF	; 255
    11f2:	ba 01       	movw	r22, r20
    11f4:	43 83       	std	Z+3, r20	; 0x03
    11f6:	54 83       	std	Z+4, r21	; 0x04
    11f8:	65 83       	std	Z+5, r22	; 0x05
    11fa:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    11fc:	87 83       	std	Z+7, r24	; 0x07
    11fe:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1200:	81 87       	std	Z+9, r24	; 0x09
    1202:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1204:	10 82       	st	Z, r1
    1206:	08 95       	ret

00001208 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1208:	fc 01       	movw	r30, r24
    120a:	12 86       	std	Z+10, r1	; 0x0a
    120c:	13 86       	std	Z+11, r1	; 0x0b
    120e:	08 95       	ret

00001210 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1210:	cf 93       	push	r28
    1212:	df 93       	push	r29
    1214:	fc 01       	movw	r30, r24
    1216:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1218:	21 81       	ldd	r18, Z+1	; 0x01
    121a:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    121c:	e9 01       	movw	r28, r18
    121e:	8c 81       	ldd	r24, Y+4	; 0x04
    1220:	9d 81       	ldd	r25, Y+5	; 0x05
    1222:	14 96       	adiw	r26, 0x04	; 4
    1224:	8d 93       	st	X+, r24
    1226:	9c 93       	st	X, r25
    1228:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
    122a:	81 81       	ldd	r24, Z+1	; 0x01
    122c:	92 81       	ldd	r25, Z+2	; 0x02
    122e:	16 96       	adiw	r26, 0x06	; 6
    1230:	8d 93       	st	X+, r24
    1232:	9c 93       	st	X, r25
    1234:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1236:	8c 81       	ldd	r24, Y+4	; 0x04
    1238:	9d 81       	ldd	r25, Y+5	; 0x05
    123a:	ec 01       	movw	r28, r24
    123c:	6e 83       	std	Y+6, r22	; 0x06
    123e:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1240:	e9 01       	movw	r28, r18
    1242:	6c 83       	std	Y+4, r22	; 0x04
    1244:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1246:	61 83       	std	Z+1, r22	; 0x01
    1248:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    124a:	1a 96       	adiw	r26, 0x0a	; 10
    124c:	ed 93       	st	X+, r30
    124e:	fc 93       	st	X, r31
    1250:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
    1252:	80 81       	ld	r24, Z
    1254:	8f 5f       	subi	r24, 0xFF	; 255
    1256:	80 83       	st	Z, r24
}
    1258:	df 91       	pop	r29
    125a:	cf 91       	pop	r28
    125c:	08 95       	ret

0000125e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    125e:	0f 93       	push	r16
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1268:	08 81       	ld	r16, Y
    126a:	19 81       	ldd	r17, Y+1	; 0x01
    126c:	2a 81       	ldd	r18, Y+2	; 0x02
    126e:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1270:	0f 3f       	cpi	r16, 0xFF	; 255
    1272:	4f ef       	ldi	r20, 0xFF	; 255
    1274:	14 07       	cpc	r17, r20
    1276:	24 07       	cpc	r18, r20
    1278:	34 07       	cpc	r19, r20
    127a:	31 f4       	brne	.+12     	; 0x1288 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    127c:	dc 01       	movw	r26, r24
    127e:	19 96       	adiw	r26, 0x09	; 9
    1280:	ed 91       	ld	r30, X+
    1282:	fc 91       	ld	r31, X
    1284:	1a 97       	sbiw	r26, 0x0a	; 10
    1286:	1f c0       	rjmp	.+62     	; 0x12c6 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1288:	fc 01       	movw	r30, r24
    128a:	33 96       	adiw	r30, 0x03	; 3
    128c:	dc 01       	movw	r26, r24
    128e:	17 96       	adiw	r26, 0x07	; 7
    1290:	4d 91       	ld	r20, X+
    1292:	5c 91       	ld	r21, X
    1294:	18 97       	sbiw	r26, 0x08	; 8
    1296:	da 01       	movw	r26, r20
    1298:	4d 91       	ld	r20, X+
    129a:	5d 91       	ld	r21, X+
    129c:	6d 91       	ld	r22, X+
    129e:	7c 91       	ld	r23, X
    12a0:	04 17       	cp	r16, r20
    12a2:	15 07       	cpc	r17, r21
    12a4:	26 07       	cpc	r18, r22
    12a6:	37 07       	cpc	r19, r23
    12a8:	70 f0       	brcs	.+28     	; 0x12c6 <vListInsert+0x68>
    12aa:	04 80       	ldd	r0, Z+4	; 0x04
    12ac:	f5 81       	ldd	r31, Z+5	; 0x05
    12ae:	e0 2d       	mov	r30, r0
    12b0:	a4 81       	ldd	r26, Z+4	; 0x04
    12b2:	b5 81       	ldd	r27, Z+5	; 0x05
    12b4:	4d 91       	ld	r20, X+
    12b6:	5d 91       	ld	r21, X+
    12b8:	6d 91       	ld	r22, X+
    12ba:	7c 91       	ld	r23, X
    12bc:	04 17       	cp	r16, r20
    12be:	15 07       	cpc	r17, r21
    12c0:	26 07       	cpc	r18, r22
    12c2:	37 07       	cpc	r19, r23
    12c4:	90 f7       	brcc	.-28     	; 0x12aa <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    12c6:	a4 81       	ldd	r26, Z+4	; 0x04
    12c8:	b5 81       	ldd	r27, Z+5	; 0x05
    12ca:	ac 83       	std	Y+4, r26	; 0x04
    12cc:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    12ce:	16 96       	adiw	r26, 0x06	; 6
    12d0:	cd 93       	st	X+, r28
    12d2:	dc 93       	st	X, r29
    12d4:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    12d6:	ee 83       	std	Y+6, r30	; 0x06
    12d8:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    12da:	c4 83       	std	Z+4, r28	; 0x04
    12dc:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    12de:	8a 87       	std	Y+10, r24	; 0x0a
    12e0:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    12e2:	fc 01       	movw	r30, r24
    12e4:	20 81       	ld	r18, Z
    12e6:	2f 5f       	subi	r18, 0xFF	; 255
    12e8:	20 83       	st	Z, r18
}
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	1f 91       	pop	r17
    12f0:	0f 91       	pop	r16
    12f2:	08 95       	ret

000012f4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    12f4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    12f6:	a4 81       	ldd	r26, Z+4	; 0x04
    12f8:	b5 81       	ldd	r27, Z+5	; 0x05
    12fa:	86 81       	ldd	r24, Z+6	; 0x06
    12fc:	97 81       	ldd	r25, Z+7	; 0x07
    12fe:	16 96       	adiw	r26, 0x06	; 6
    1300:	8d 93       	st	X+, r24
    1302:	9c 93       	st	X, r25
    1304:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1306:	a6 81       	ldd	r26, Z+6	; 0x06
    1308:	b7 81       	ldd	r27, Z+7	; 0x07
    130a:	84 81       	ldd	r24, Z+4	; 0x04
    130c:	95 81       	ldd	r25, Z+5	; 0x05
    130e:	14 96       	adiw	r26, 0x04	; 4
    1310:	8d 93       	st	X+, r24
    1312:	9c 93       	st	X, r25
    1314:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1316:	a2 85       	ldd	r26, Z+10	; 0x0a
    1318:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    131a:	11 96       	adiw	r26, 0x01	; 1
    131c:	8d 91       	ld	r24, X+
    131e:	9c 91       	ld	r25, X
    1320:	12 97       	sbiw	r26, 0x02	; 2
    1322:	e8 17       	cp	r30, r24
    1324:	f9 07       	cpc	r31, r25
    1326:	31 f4       	brne	.+12     	; 0x1334 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1328:	86 81       	ldd	r24, Z+6	; 0x06
    132a:	97 81       	ldd	r25, Z+7	; 0x07
    132c:	11 96       	adiw	r26, 0x01	; 1
    132e:	8d 93       	st	X+, r24
    1330:	9c 93       	st	X, r25
    1332:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    1334:	12 86       	std	Z+10, r1	; 0x0a
    1336:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    1338:	8c 91       	ld	r24, X
    133a:	81 50       	subi	r24, 0x01	; 1
    133c:	8c 93       	st	X, r24
    133e:	08 95       	ret

00001340 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1340:	80 93 ac 31 	sts	0x31AC, r24	; 0x8031ac <portStackTopForTask>
    1344:	90 93 ad 31 	sts	0x31AD, r25	; 0x8031ad <portStackTopForTask+0x1>
    1348:	31 e1       	ldi	r19, 0x11	; 17
    134a:	fc 01       	movw	r30, r24
    134c:	30 83       	st	Z, r19
    134e:	31 97       	sbiw	r30, 0x01	; 1
    1350:	22 e2       	ldi	r18, 0x22	; 34
    1352:	20 83       	st	Z, r18
    1354:	31 97       	sbiw	r30, 0x01	; 1
    1356:	a3 e3       	ldi	r26, 0x33	; 51
    1358:	a0 83       	st	Z, r26
    135a:	31 97       	sbiw	r30, 0x01	; 1
    135c:	60 83       	st	Z, r22
    135e:	31 97       	sbiw	r30, 0x01	; 1
    1360:	70 83       	st	Z, r23
    1362:	31 97       	sbiw	r30, 0x01	; 1
    1364:	10 82       	st	Z, r1
    1366:	31 97       	sbiw	r30, 0x01	; 1
    1368:	10 82       	st	Z, r1
    136a:	31 97       	sbiw	r30, 0x01	; 1
    136c:	60 e8       	ldi	r22, 0x80	; 128
    136e:	60 83       	st	Z, r22
    1370:	31 97       	sbiw	r30, 0x01	; 1
    1372:	10 82       	st	Z, r1
    1374:	31 97       	sbiw	r30, 0x01	; 1
    1376:	10 82       	st	Z, r1
    1378:	31 97       	sbiw	r30, 0x01	; 1
    137a:	10 82       	st	Z, r1
    137c:	31 97       	sbiw	r30, 0x01	; 1
    137e:	62 e0       	ldi	r22, 0x02	; 2
    1380:	60 83       	st	Z, r22
    1382:	31 97       	sbiw	r30, 0x01	; 1
    1384:	63 e0       	ldi	r22, 0x03	; 3
    1386:	60 83       	st	Z, r22
    1388:	31 97       	sbiw	r30, 0x01	; 1
    138a:	64 e0       	ldi	r22, 0x04	; 4
    138c:	60 83       	st	Z, r22
    138e:	31 97       	sbiw	r30, 0x01	; 1
    1390:	65 e0       	ldi	r22, 0x05	; 5
    1392:	60 83       	st	Z, r22
    1394:	31 97       	sbiw	r30, 0x01	; 1
    1396:	66 e0       	ldi	r22, 0x06	; 6
    1398:	60 83       	st	Z, r22
    139a:	31 97       	sbiw	r30, 0x01	; 1
    139c:	67 e0       	ldi	r22, 0x07	; 7
    139e:	60 83       	st	Z, r22
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	68 e0       	ldi	r22, 0x08	; 8
    13a4:	60 83       	st	Z, r22
    13a6:	31 97       	sbiw	r30, 0x01	; 1
    13a8:	69 e0       	ldi	r22, 0x09	; 9
    13aa:	60 83       	st	Z, r22
    13ac:	31 97       	sbiw	r30, 0x01	; 1
    13ae:	60 e1       	ldi	r22, 0x10	; 16
    13b0:	60 83       	st	Z, r22
    13b2:	31 97       	sbiw	r30, 0x01	; 1
    13b4:	30 83       	st	Z, r19
    13b6:	31 97       	sbiw	r30, 0x01	; 1
    13b8:	32 e1       	ldi	r19, 0x12	; 18
    13ba:	30 83       	st	Z, r19
    13bc:	31 97       	sbiw	r30, 0x01	; 1
    13be:	33 e1       	ldi	r19, 0x13	; 19
    13c0:	30 83       	st	Z, r19
    13c2:	31 97       	sbiw	r30, 0x01	; 1
    13c4:	34 e1       	ldi	r19, 0x14	; 20
    13c6:	30 83       	st	Z, r19
    13c8:	31 97       	sbiw	r30, 0x01	; 1
    13ca:	35 e1       	ldi	r19, 0x15	; 21
    13cc:	30 83       	st	Z, r19
    13ce:	31 97       	sbiw	r30, 0x01	; 1
    13d0:	36 e1       	ldi	r19, 0x16	; 22
    13d2:	30 83       	st	Z, r19
    13d4:	31 97       	sbiw	r30, 0x01	; 1
    13d6:	37 e1       	ldi	r19, 0x17	; 23
    13d8:	30 83       	st	Z, r19
    13da:	31 97       	sbiw	r30, 0x01	; 1
    13dc:	38 e1       	ldi	r19, 0x18	; 24
    13de:	30 83       	st	Z, r19
    13e0:	31 97       	sbiw	r30, 0x01	; 1
    13e2:	39 e1       	ldi	r19, 0x19	; 25
    13e4:	30 83       	st	Z, r19
    13e6:	31 97       	sbiw	r30, 0x01	; 1
    13e8:	30 e2       	ldi	r19, 0x20	; 32
    13ea:	30 83       	st	Z, r19
    13ec:	31 97       	sbiw	r30, 0x01	; 1
    13ee:	31 e2       	ldi	r19, 0x21	; 33
    13f0:	30 83       	st	Z, r19
    13f2:	31 97       	sbiw	r30, 0x01	; 1
    13f4:	20 83       	st	Z, r18
    13f6:	31 97       	sbiw	r30, 0x01	; 1
    13f8:	23 e2       	ldi	r18, 0x23	; 35
    13fa:	20 83       	st	Z, r18
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	40 83       	st	Z, r20
    1400:	31 97       	sbiw	r30, 0x01	; 1
    1402:	50 83       	st	Z, r21
    1404:	31 97       	sbiw	r30, 0x01	; 1
    1406:	26 e2       	ldi	r18, 0x26	; 38
    1408:	20 83       	st	Z, r18
    140a:	31 97       	sbiw	r30, 0x01	; 1
    140c:	27 e2       	ldi	r18, 0x27	; 39
    140e:	20 83       	st	Z, r18
    1410:	31 97       	sbiw	r30, 0x01	; 1
    1412:	28 e2       	ldi	r18, 0x28	; 40
    1414:	20 83       	st	Z, r18
    1416:	31 97       	sbiw	r30, 0x01	; 1
    1418:	29 e2       	ldi	r18, 0x29	; 41
    141a:	20 83       	st	Z, r18
    141c:	31 97       	sbiw	r30, 0x01	; 1
    141e:	20 e3       	ldi	r18, 0x30	; 48
    1420:	20 83       	st	Z, r18
    1422:	31 97       	sbiw	r30, 0x01	; 1
    1424:	21 e3       	ldi	r18, 0x31	; 49
    1426:	20 83       	st	Z, r18
    1428:	89 97       	sbiw	r24, 0x29	; 41
    142a:	08 95       	ret

0000142c <xPortStartScheduler>:
    142c:	8c e7       	ldi	r24, 0x7C	; 124
    142e:	80 93 69 08 	sts	0x0869, r24	; 0x800869 <__TEXT_REGION_LENGTH__+0x700869>
    1432:	8f ef       	ldi	r24, 0xFF	; 255
    1434:	80 93 68 08 	sts	0x0868, r24	; 0x800868 <__TEXT_REGION_LENGTH__+0x700868>
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	80 93 40 08 	sts	0x0840, r24	; 0x800840 <__TEXT_REGION_LENGTH__+0x700840>
    143e:	91 e1       	ldi	r25, 0x11	; 17
    1440:	90 93 41 08 	sts	0x0841, r25	; 0x800841 <__TEXT_REGION_LENGTH__+0x700841>
    1444:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <__TEXT_REGION_LENGTH__+0x700847>
    1448:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    144c:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1450:	cd 91       	ld	r28, X+
    1452:	cd bf       	out	0x3d, r28	; 61
    1454:	dd 91       	ld	r29, X+
    1456:	de bf       	out	0x3e, r29	; 62
    1458:	ff 91       	pop	r31
    145a:	ef 91       	pop	r30
    145c:	df 91       	pop	r29
    145e:	cf 91       	pop	r28
    1460:	bf 91       	pop	r27
    1462:	af 91       	pop	r26
    1464:	9f 91       	pop	r25
    1466:	8f 91       	pop	r24
    1468:	7f 91       	pop	r23
    146a:	6f 91       	pop	r22
    146c:	5f 91       	pop	r21
    146e:	4f 91       	pop	r20
    1470:	3f 91       	pop	r19
    1472:	2f 91       	pop	r18
    1474:	1f 91       	pop	r17
    1476:	0f 91       	pop	r16
    1478:	ff 90       	pop	r15
    147a:	ef 90       	pop	r14
    147c:	df 90       	pop	r13
    147e:	cf 90       	pop	r12
    1480:	bf 90       	pop	r11
    1482:	af 90       	pop	r10
    1484:	9f 90       	pop	r9
    1486:	8f 90       	pop	r8
    1488:	7f 90       	pop	r7
    148a:	6f 90       	pop	r6
    148c:	5f 90       	pop	r5
    148e:	4f 90       	pop	r4
    1490:	3f 90       	pop	r3
    1492:	2f 90       	pop	r2
    1494:	1f 90       	pop	r1
    1496:	0f 90       	pop	r0
    1498:	0c be       	out	0x3c, r0	; 60
    149a:	0f 90       	pop	r0
    149c:	0b be       	out	0x3b, r0	; 59
    149e:	0f 90       	pop	r0
    14a0:	0f be       	out	0x3f, r0	; 63
    14a2:	0f 90       	pop	r0
    14a4:	08 95       	ret
    14a6:	08 95       	ret

000014a8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    14a8:	0f 92       	push	r0
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	0f 92       	push	r0
    14b0:	0b b6       	in	r0, 0x3b	; 59
    14b2:	0f 92       	push	r0
    14b4:	0c b6       	in	r0, 0x3c	; 60
    14b6:	0f 92       	push	r0
    14b8:	1f 92       	push	r1
    14ba:	11 24       	eor	r1, r1
    14bc:	2f 92       	push	r2
    14be:	3f 92       	push	r3
    14c0:	4f 92       	push	r4
    14c2:	5f 92       	push	r5
    14c4:	6f 92       	push	r6
    14c6:	7f 92       	push	r7
    14c8:	8f 92       	push	r8
    14ca:	9f 92       	push	r9
    14cc:	af 92       	push	r10
    14ce:	bf 92       	push	r11
    14d0:	cf 92       	push	r12
    14d2:	df 92       	push	r13
    14d4:	ef 92       	push	r14
    14d6:	ff 92       	push	r15
    14d8:	0f 93       	push	r16
    14da:	1f 93       	push	r17
    14dc:	2f 93       	push	r18
    14de:	3f 93       	push	r19
    14e0:	4f 93       	push	r20
    14e2:	5f 93       	push	r21
    14e4:	6f 93       	push	r22
    14e6:	7f 93       	push	r23
    14e8:	8f 93       	push	r24
    14ea:	9f 93       	push	r25
    14ec:	af 93       	push	r26
    14ee:	bf 93       	push	r27
    14f0:	cf 93       	push	r28
    14f2:	df 93       	push	r29
    14f4:	ef 93       	push	r30
    14f6:	ff 93       	push	r31
    14f8:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    14fc:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1500:	0d b6       	in	r0, 0x3d	; 61
    1502:	0d 92       	st	X+, r0
    1504:	0e b6       	in	r0, 0x3e	; 62
    1506:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1508:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    150c:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    1510:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1514:	cd 91       	ld	r28, X+
    1516:	cd bf       	out	0x3d, r28	; 61
    1518:	dd 91       	ld	r29, X+
    151a:	de bf       	out	0x3e, r29	; 62
    151c:	ff 91       	pop	r31
    151e:	ef 91       	pop	r30
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	bf 91       	pop	r27
    1526:	af 91       	pop	r26
    1528:	9f 91       	pop	r25
    152a:	8f 91       	pop	r24
    152c:	7f 91       	pop	r23
    152e:	6f 91       	pop	r22
    1530:	5f 91       	pop	r21
    1532:	4f 91       	pop	r20
    1534:	3f 91       	pop	r19
    1536:	2f 91       	pop	r18
    1538:	1f 91       	pop	r17
    153a:	0f 91       	pop	r16
    153c:	ff 90       	pop	r15
    153e:	ef 90       	pop	r14
    1540:	df 90       	pop	r13
    1542:	cf 90       	pop	r12
    1544:	bf 90       	pop	r11
    1546:	af 90       	pop	r10
    1548:	9f 90       	pop	r9
    154a:	8f 90       	pop	r8
    154c:	7f 90       	pop	r7
    154e:	6f 90       	pop	r6
    1550:	5f 90       	pop	r5
    1552:	4f 90       	pop	r4
    1554:	3f 90       	pop	r3
    1556:	2f 90       	pop	r2
    1558:	1f 90       	pop	r1
    155a:	0f 90       	pop	r0
    155c:	0c be       	out	0x3c, r0	; 60
    155e:	0f 90       	pop	r0
    1560:	0b be       	out	0x3b, r0	; 59
    1562:	0f 90       	pop	r0
    1564:	0f be       	out	0x3f, r0	; 63
    1566:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1568:	08 95       	ret

0000156a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    156a:	0f 92       	push	r0
    156c:	0f b6       	in	r0, 0x3f	; 63
    156e:	f8 94       	cli
    1570:	0f 92       	push	r0
    1572:	0b b6       	in	r0, 0x3b	; 59
    1574:	0f 92       	push	r0
    1576:	0c b6       	in	r0, 0x3c	; 60
    1578:	0f 92       	push	r0
    157a:	1f 92       	push	r1
    157c:	11 24       	eor	r1, r1
    157e:	2f 92       	push	r2
    1580:	3f 92       	push	r3
    1582:	4f 92       	push	r4
    1584:	5f 92       	push	r5
    1586:	6f 92       	push	r6
    1588:	7f 92       	push	r7
    158a:	8f 92       	push	r8
    158c:	9f 92       	push	r9
    158e:	af 92       	push	r10
    1590:	bf 92       	push	r11
    1592:	cf 92       	push	r12
    1594:	df 92       	push	r13
    1596:	ef 92       	push	r14
    1598:	ff 92       	push	r15
    159a:	0f 93       	push	r16
    159c:	1f 93       	push	r17
    159e:	2f 93       	push	r18
    15a0:	3f 93       	push	r19
    15a2:	4f 93       	push	r20
    15a4:	5f 93       	push	r21
    15a6:	6f 93       	push	r22
    15a8:	7f 93       	push	r23
    15aa:	8f 93       	push	r24
    15ac:	9f 93       	push	r25
    15ae:	af 93       	push	r26
    15b0:	bf 93       	push	r27
    15b2:	cf 93       	push	r28
    15b4:	df 93       	push	r29
    15b6:	ef 93       	push	r30
    15b8:	ff 93       	push	r31
    15ba:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    15be:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    15c2:	0d b6       	in	r0, 0x3d	; 61
    15c4:	0d 92       	st	X+, r0
    15c6:	0e b6       	in	r0, 0x3e	; 62
    15c8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    15ca:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <vTaskIncrementTick>
	vTaskSwitchContext();
    15ce:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    15d2:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    15d6:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    15da:	cd 91       	ld	r28, X+
    15dc:	cd bf       	out	0x3d, r28	; 61
    15de:	dd 91       	ld	r29, X+
    15e0:	de bf       	out	0x3e, r29	; 62
    15e2:	ff 91       	pop	r31
    15e4:	ef 91       	pop	r30
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	bf 91       	pop	r27
    15ec:	af 91       	pop	r26
    15ee:	9f 91       	pop	r25
    15f0:	8f 91       	pop	r24
    15f2:	7f 91       	pop	r23
    15f4:	6f 91       	pop	r22
    15f6:	5f 91       	pop	r21
    15f8:	4f 91       	pop	r20
    15fa:	3f 91       	pop	r19
    15fc:	2f 91       	pop	r18
    15fe:	1f 91       	pop	r17
    1600:	0f 91       	pop	r16
    1602:	ff 90       	pop	r15
    1604:	ef 90       	pop	r14
    1606:	df 90       	pop	r13
    1608:	cf 90       	pop	r12
    160a:	bf 90       	pop	r11
    160c:	af 90       	pop	r10
    160e:	9f 90       	pop	r9
    1610:	8f 90       	pop	r8
    1612:	7f 90       	pop	r7
    1614:	6f 90       	pop	r6
    1616:	5f 90       	pop	r5
    1618:	4f 90       	pop	r4
    161a:	3f 90       	pop	r3
    161c:	2f 90       	pop	r2
    161e:	1f 90       	pop	r1
    1620:	0f 90       	pop	r0
    1622:	0c be       	out	0x3c, r0	; 60
    1624:	0f 90       	pop	r0
    1626:	0b be       	out	0x3b, r0	; 59
    1628:	0f 90       	pop	r0
    162a:	0f be       	out	0x3f, r0	; 63
    162c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    162e:	08 95       	ret

00001630 <__vector_22>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    1630:	0e 94 b5 0a 	call	0x156a	; 0x156a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1634:	18 95       	reti

00001636 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    1636:	cf 93       	push	r28
    1638:	df 93       	push	r29
    163a:	ec 01       	movw	r28, r24
    163c:	88 a1       	ldd	r24, Y+32	; 0x20
    163e:	81 11       	cpse	r24, r1
    1640:	0b c0       	rjmp	.+22     	; 0x1658 <prvCopyDataToQueue+0x22>
    1642:	88 81       	ld	r24, Y
    1644:	99 81       	ldd	r25, Y+1	; 0x01
    1646:	89 2b       	or	r24, r25
    1648:	e1 f5       	brne	.+120    	; 0x16c2 <prvCopyDataToQueue+0x8c>
    164a:	8a 81       	ldd	r24, Y+2	; 0x02
    164c:	9b 81       	ldd	r25, Y+3	; 0x03
    164e:	0e 94 1e 13 	call	0x263c	; 0x263c <vTaskPriorityDisinherit>
    1652:	1a 82       	std	Y+2, r1	; 0x02
    1654:	1b 82       	std	Y+3, r1	; 0x03
    1656:	35 c0       	rjmp	.+106    	; 0x16c2 <prvCopyDataToQueue+0x8c>
    1658:	41 11       	cpse	r20, r1
    165a:	17 c0       	rjmp	.+46     	; 0x168a <prvCopyDataToQueue+0x54>
    165c:	48 2f       	mov	r20, r24
    165e:	50 e0       	ldi	r21, 0x00	; 0
    1660:	8c 81       	ldd	r24, Y+4	; 0x04
    1662:	9d 81       	ldd	r25, Y+5	; 0x05
    1664:	0e 94 51 20 	call	0x40a2	; 0x40a2 <memcpy>
    1668:	28 a1       	ldd	r18, Y+32	; 0x20
    166a:	8c 81       	ldd	r24, Y+4	; 0x04
    166c:	9d 81       	ldd	r25, Y+5	; 0x05
    166e:	82 0f       	add	r24, r18
    1670:	91 1d       	adc	r25, r1
    1672:	8c 83       	std	Y+4, r24	; 0x04
    1674:	9d 83       	std	Y+5, r25	; 0x05
    1676:	2a 81       	ldd	r18, Y+2	; 0x02
    1678:	3b 81       	ldd	r19, Y+3	; 0x03
    167a:	82 17       	cp	r24, r18
    167c:	93 07       	cpc	r25, r19
    167e:	08 f1       	brcs	.+66     	; 0x16c2 <prvCopyDataToQueue+0x8c>
    1680:	88 81       	ld	r24, Y
    1682:	99 81       	ldd	r25, Y+1	; 0x01
    1684:	8c 83       	std	Y+4, r24	; 0x04
    1686:	9d 83       	std	Y+5, r25	; 0x05
    1688:	1c c0       	rjmp	.+56     	; 0x16c2 <prvCopyDataToQueue+0x8c>
    168a:	48 2f       	mov	r20, r24
    168c:	50 e0       	ldi	r21, 0x00	; 0
    168e:	8e 81       	ldd	r24, Y+6	; 0x06
    1690:	9f 81       	ldd	r25, Y+7	; 0x07
    1692:	0e 94 51 20 	call	0x40a2	; 0x40a2 <memcpy>
    1696:	88 a1       	ldd	r24, Y+32	; 0x20
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	91 95       	neg	r25
    169c:	81 95       	neg	r24
    169e:	91 09       	sbc	r25, r1
    16a0:	2e 81       	ldd	r18, Y+6	; 0x06
    16a2:	3f 81       	ldd	r19, Y+7	; 0x07
    16a4:	28 0f       	add	r18, r24
    16a6:	39 1f       	adc	r19, r25
    16a8:	2e 83       	std	Y+6, r18	; 0x06
    16aa:	3f 83       	std	Y+7, r19	; 0x07
    16ac:	48 81       	ld	r20, Y
    16ae:	59 81       	ldd	r21, Y+1	; 0x01
    16b0:	24 17       	cp	r18, r20
    16b2:	35 07       	cpc	r19, r21
    16b4:	30 f4       	brcc	.+12     	; 0x16c2 <prvCopyDataToQueue+0x8c>
    16b6:	2a 81       	ldd	r18, Y+2	; 0x02
    16b8:	3b 81       	ldd	r19, Y+3	; 0x03
    16ba:	82 0f       	add	r24, r18
    16bc:	93 1f       	adc	r25, r19
    16be:	8e 83       	std	Y+6, r24	; 0x06
    16c0:	9f 83       	std	Y+7, r25	; 0x07
    16c2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    16c4:	8f 5f       	subi	r24, 0xFF	; 255
    16c6:	8e 8f       	std	Y+30, r24	; 0x1e
    16c8:	df 91       	pop	r29
    16ca:	cf 91       	pop	r28
    16cc:	08 95       	ret

000016ce <prvCopyDataFromQueue>:
    16ce:	fc 01       	movw	r30, r24
    16d0:	80 81       	ld	r24, Z
    16d2:	91 81       	ldd	r25, Z+1	; 0x01
    16d4:	00 97       	sbiw	r24, 0x00	; 0
    16d6:	a1 f0       	breq	.+40     	; 0x1700 <prvCopyDataFromQueue+0x32>
    16d8:	40 a1       	ldd	r20, Z+32	; 0x20
    16da:	50 e0       	ldi	r21, 0x00	; 0
    16dc:	26 81       	ldd	r18, Z+6	; 0x06
    16de:	37 81       	ldd	r19, Z+7	; 0x07
    16e0:	24 0f       	add	r18, r20
    16e2:	35 1f       	adc	r19, r21
    16e4:	26 83       	std	Z+6, r18	; 0x06
    16e6:	37 83       	std	Z+7, r19	; 0x07
    16e8:	a2 81       	ldd	r26, Z+2	; 0x02
    16ea:	b3 81       	ldd	r27, Z+3	; 0x03
    16ec:	2a 17       	cp	r18, r26
    16ee:	3b 07       	cpc	r19, r27
    16f0:	10 f0       	brcs	.+4      	; 0x16f6 <prvCopyDataFromQueue+0x28>
    16f2:	86 83       	std	Z+6, r24	; 0x06
    16f4:	97 83       	std	Z+7, r25	; 0x07
    16f6:	cb 01       	movw	r24, r22
    16f8:	66 81       	ldd	r22, Z+6	; 0x06
    16fa:	77 81       	ldd	r23, Z+7	; 0x07
    16fc:	0e 94 51 20 	call	0x40a2	; 0x40a2 <memcpy>
    1700:	08 95       	ret

00001702 <prvUnlockQueue>:
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
    170a:	ec 01       	movw	r28, r24
    170c:	0f b6       	in	r0, 0x3f	; 63
    170e:	f8 94       	cli
    1710:	0f 92       	push	r0
    1712:	8a a1       	ldd	r24, Y+34	; 0x22
    1714:	18 16       	cp	r1, r24
    1716:	b4 f4       	brge	.+44     	; 0x1744 <prvUnlockQueue+0x42>
    1718:	8b 89       	ldd	r24, Y+19	; 0x13
    171a:	81 11       	cpse	r24, r1
    171c:	05 c0       	rjmp	.+10     	; 0x1728 <prvUnlockQueue+0x26>
    171e:	12 c0       	rjmp	.+36     	; 0x1744 <prvUnlockQueue+0x42>
    1720:	8b 89       	ldd	r24, Y+19	; 0x13
    1722:	81 11       	cpse	r24, r1
    1724:	04 c0       	rjmp	.+8      	; 0x172e <prvUnlockQueue+0x2c>
    1726:	0e c0       	rjmp	.+28     	; 0x1744 <prvUnlockQueue+0x42>
    1728:	8e 01       	movw	r16, r28
    172a:	0d 5e       	subi	r16, 0xED	; 237
    172c:	1f 4f       	sbci	r17, 0xFF	; 255
    172e:	c8 01       	movw	r24, r16
    1730:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    1734:	81 11       	cpse	r24, r1
    1736:	0e 94 a7 12 	call	0x254e	; 0x254e <vTaskMissedYield>
    173a:	8a a1       	ldd	r24, Y+34	; 0x22
    173c:	81 50       	subi	r24, 0x01	; 1
    173e:	8a a3       	std	Y+34, r24	; 0x22
    1740:	18 16       	cp	r1, r24
    1742:	74 f3       	brlt	.-36     	; 0x1720 <prvUnlockQueue+0x1e>
    1744:	8f ef       	ldi	r24, 0xFF	; 255
    1746:	8a a3       	std	Y+34, r24	; 0x22
    1748:	0f 90       	pop	r0
    174a:	0f be       	out	0x3f, r0	; 63
    174c:	0f b6       	in	r0, 0x3f	; 63
    174e:	f8 94       	cli
    1750:	0f 92       	push	r0
    1752:	89 a1       	ldd	r24, Y+33	; 0x21
    1754:	18 16       	cp	r1, r24
    1756:	b4 f4       	brge	.+44     	; 0x1784 <prvUnlockQueue+0x82>
    1758:	88 85       	ldd	r24, Y+8	; 0x08
    175a:	81 11       	cpse	r24, r1
    175c:	05 c0       	rjmp	.+10     	; 0x1768 <prvUnlockQueue+0x66>
    175e:	12 c0       	rjmp	.+36     	; 0x1784 <prvUnlockQueue+0x82>
    1760:	88 85       	ldd	r24, Y+8	; 0x08
    1762:	81 11       	cpse	r24, r1
    1764:	04 c0       	rjmp	.+8      	; 0x176e <prvUnlockQueue+0x6c>
    1766:	0e c0       	rjmp	.+28     	; 0x1784 <prvUnlockQueue+0x82>
    1768:	8e 01       	movw	r16, r28
    176a:	08 5f       	subi	r16, 0xF8	; 248
    176c:	1f 4f       	sbci	r17, 0xFF	; 255
    176e:	c8 01       	movw	r24, r16
    1770:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    1774:	81 11       	cpse	r24, r1
    1776:	0e 94 a7 12 	call	0x254e	; 0x254e <vTaskMissedYield>
    177a:	89 a1       	ldd	r24, Y+33	; 0x21
    177c:	81 50       	subi	r24, 0x01	; 1
    177e:	89 a3       	std	Y+33, r24	; 0x21
    1780:	18 16       	cp	r1, r24
    1782:	74 f3       	brlt	.-36     	; 0x1760 <prvUnlockQueue+0x5e>
    1784:	8f ef       	ldi	r24, 0xFF	; 255
    1786:	89 a3       	std	Y+33, r24	; 0x21
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	1f 91       	pop	r17
    1792:	0f 91       	pop	r16
    1794:	08 95       	ret

00001796 <xQueueGenericReset>:
    1796:	1f 93       	push	r17
    1798:	cf 93       	push	r28
    179a:	df 93       	push	r29
    179c:	61 30       	cpi	r22, 0x01	; 1
    179e:	59 f0       	breq	.+22     	; 0x17b6 <xQueueGenericReset+0x20>
    17a0:	fc 01       	movw	r30, r24
    17a2:	23 89       	ldd	r18, Z+19	; 0x13
    17a4:	30 85       	ldd	r19, Z+8	; 0x08
    17a6:	31 11       	cpse	r19, r1
    17a8:	2c c0       	rjmp	.+88     	; 0x1802 <xQueueGenericReset+0x6c>
    17aa:	11 e0       	ldi	r17, 0x01	; 1
    17ac:	21 11       	cpse	r18, r1
    17ae:	10 e0       	ldi	r17, 0x00	; 0
    17b0:	21 11       	cpse	r18, r1
    17b2:	28 c0       	rjmp	.+80     	; 0x1804 <xQueueGenericReset+0x6e>
    17b4:	01 c0       	rjmp	.+2      	; 0x17b8 <xQueueGenericReset+0x22>
    17b6:	11 e0       	ldi	r17, 0x01	; 1
    17b8:	ec 01       	movw	r28, r24
    17ba:	48 81       	ld	r20, Y
    17bc:	59 81       	ldd	r21, Y+1	; 0x01
    17be:	28 a1       	ldd	r18, Y+32	; 0x20
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    17c4:	62 9f       	mul	r22, r18
    17c6:	c0 01       	movw	r24, r0
    17c8:	63 9f       	mul	r22, r19
    17ca:	90 0d       	add	r25, r0
    17cc:	11 24       	eor	r1, r1
    17ce:	ba 01       	movw	r22, r20
    17d0:	68 0f       	add	r22, r24
    17d2:	79 1f       	adc	r23, r25
    17d4:	6a 83       	std	Y+2, r22	; 0x02
    17d6:	7b 83       	std	Y+3, r23	; 0x03
    17d8:	1e 8e       	std	Y+30, r1	; 0x1e
    17da:	4c 83       	std	Y+4, r20	; 0x04
    17dc:	5d 83       	std	Y+5, r21	; 0x05
    17de:	82 1b       	sub	r24, r18
    17e0:	93 0b       	sbc	r25, r19
    17e2:	84 0f       	add	r24, r20
    17e4:	95 1f       	adc	r25, r21
    17e6:	8e 83       	std	Y+6, r24	; 0x06
    17e8:	9f 83       	std	Y+7, r25	; 0x07
    17ea:	8f ef       	ldi	r24, 0xFF	; 255
    17ec:	89 a3       	std	Y+33, r24	; 0x21
    17ee:	8a a3       	std	Y+34, r24	; 0x22
    17f0:	ce 01       	movw	r24, r28
    17f2:	08 96       	adiw	r24, 0x08	; 8
    17f4:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    17f8:	ce 01       	movw	r24, r28
    17fa:	43 96       	adiw	r24, 0x13	; 19
    17fc:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1800:	01 c0       	rjmp	.+2      	; 0x1804 <xQueueGenericReset+0x6e>
    1802:	10 e0       	ldi	r17, 0x00	; 0
    1804:	81 2f       	mov	r24, r17
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	1f 91       	pop	r17
    180c:	08 95       	ret

0000180e <xQueueGenericCreate>:
    180e:	0f 93       	push	r16
    1810:	1f 93       	push	r17
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
    1816:	88 23       	and	r24, r24
    1818:	01 f1       	breq	.+64     	; 0x185a <xQueueGenericCreate+0x4c>
    181a:	06 2f       	mov	r16, r22
    181c:	18 2f       	mov	r17, r24
    181e:	83 e2       	ldi	r24, 0x23	; 35
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    1826:	ec 01       	movw	r28, r24
    1828:	89 2b       	or	r24, r25
    182a:	c9 f0       	breq	.+50     	; 0x185e <xQueueGenericCreate+0x50>
    182c:	10 9f       	mul	r17, r16
    182e:	c0 01       	movw	r24, r0
    1830:	11 24       	eor	r1, r1
    1832:	01 96       	adiw	r24, 0x01	; 1
    1834:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    1838:	88 83       	st	Y, r24
    183a:	99 83       	std	Y+1, r25	; 0x01
    183c:	89 2b       	or	r24, r25
    183e:	39 f0       	breq	.+14     	; 0x184e <xQueueGenericCreate+0x40>
    1840:	1f 8f       	std	Y+31, r17	; 0x1f
    1842:	08 a3       	std	Y+32, r16	; 0x20
    1844:	61 e0       	ldi	r22, 0x01	; 1
    1846:	ce 01       	movw	r24, r28
    1848:	0e 94 cb 0b 	call	0x1796	; 0x1796 <xQueueGenericReset>
    184c:	08 c0       	rjmp	.+16     	; 0x185e <xQueueGenericCreate+0x50>
    184e:	ce 01       	movw	r24, r28
    1850:	0e 94 bb 08 	call	0x1176	; 0x1176 <vPortFree>
    1854:	c0 e0       	ldi	r28, 0x00	; 0
    1856:	d0 e0       	ldi	r29, 0x00	; 0
    1858:	02 c0       	rjmp	.+4      	; 0x185e <xQueueGenericCreate+0x50>
    185a:	c0 e0       	ldi	r28, 0x00	; 0
    185c:	d0 e0       	ldi	r29, 0x00	; 0
    185e:	ce 01       	movw	r24, r28
    1860:	df 91       	pop	r29
    1862:	cf 91       	pop	r28
    1864:	1f 91       	pop	r17
    1866:	0f 91       	pop	r16
    1868:	08 95       	ret

0000186a <xQueueGenericSend>:
    186a:	af 92       	push	r10
    186c:	bf 92       	push	r11
    186e:	cf 92       	push	r12
    1870:	df 92       	push	r13
    1872:	ef 92       	push	r14
    1874:	ff 92       	push	r15
    1876:	0f 93       	push	r16
    1878:	1f 93       	push	r17
    187a:	cf 93       	push	r28
    187c:	df 93       	push	r29
    187e:	cd b7       	in	r28, 0x3d	; 61
    1880:	de b7       	in	r29, 0x3e	; 62
    1882:	29 97       	sbiw	r28, 0x09	; 9
    1884:	cd bf       	out	0x3d, r28	; 61
    1886:	de bf       	out	0x3e, r29	; 62
    1888:	7c 01       	movw	r14, r24
    188a:	5b 01       	movw	r10, r22
    188c:	2e 83       	std	Y+6, r18	; 0x06
    188e:	3f 83       	std	Y+7, r19	; 0x07
    1890:	48 87       	std	Y+8, r20	; 0x08
    1892:	59 87       	std	Y+9, r21	; 0x09
    1894:	10 e0       	ldi	r17, 0x00	; 0
    1896:	6c 01       	movw	r12, r24
    1898:	88 e0       	ldi	r24, 0x08	; 8
    189a:	c8 0e       	add	r12, r24
    189c:	d1 1c       	adc	r13, r1
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	0f 92       	push	r0
    18a4:	f7 01       	movw	r30, r14
    18a6:	96 8d       	ldd	r25, Z+30	; 0x1e
    18a8:	87 8d       	ldd	r24, Z+31	; 0x1f
    18aa:	98 17       	cp	r25, r24
    18ac:	a8 f4       	brcc	.+42     	; 0x18d8 <xQueueGenericSend+0x6e>
    18ae:	40 2f       	mov	r20, r16
    18b0:	b5 01       	movw	r22, r10
    18b2:	c7 01       	movw	r24, r14
    18b4:	0e 94 1b 0b 	call	0x1636	; 0x1636 <prvCopyDataToQueue>
    18b8:	f7 01       	movw	r30, r14
    18ba:	83 89       	ldd	r24, Z+19	; 0x13
    18bc:	88 23       	and	r24, r24
    18be:	41 f0       	breq	.+16     	; 0x18d0 <xQueueGenericSend+0x66>
    18c0:	c7 01       	movw	r24, r14
    18c2:	43 96       	adiw	r24, 0x13	; 19
    18c4:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    18c8:	81 30       	cpi	r24, 0x01	; 1
    18ca:	11 f4       	brne	.+4      	; 0x18d0 <xQueueGenericSend+0x66>
    18cc:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    18d0:	0f 90       	pop	r0
    18d2:	0f be       	out	0x3f, r0	; 63
    18d4:	81 e0       	ldi	r24, 0x01	; 1
    18d6:	56 c0       	rjmp	.+172    	; 0x1984 <xQueueGenericSend+0x11a>
    18d8:	8e 81       	ldd	r24, Y+6	; 0x06
    18da:	9f 81       	ldd	r25, Y+7	; 0x07
    18dc:	a8 85       	ldd	r26, Y+8	; 0x08
    18de:	b9 85       	ldd	r27, Y+9	; 0x09
    18e0:	89 2b       	or	r24, r25
    18e2:	8a 2b       	or	r24, r26
    18e4:	8b 2b       	or	r24, r27
    18e6:	21 f4       	brne	.+8      	; 0x18f0 <xQueueGenericSend+0x86>
    18e8:	0f 90       	pop	r0
    18ea:	0f be       	out	0x3f, r0	; 63
    18ec:	80 e0       	ldi	r24, 0x00	; 0
    18ee:	4a c0       	rjmp	.+148    	; 0x1984 <xQueueGenericSend+0x11a>
    18f0:	11 11       	cpse	r17, r1
    18f2:	05 c0       	rjmp	.+10     	; 0x18fe <xQueueGenericSend+0x94>
    18f4:	ce 01       	movw	r24, r28
    18f6:	01 96       	adiw	r24, 0x01	; 1
    18f8:	0e 94 29 12 	call	0x2452	; 0x2452 <vTaskSetTimeOutState>
    18fc:	11 e0       	ldi	r17, 0x01	; 1
    18fe:	0f 90       	pop	r0
    1900:	0f be       	out	0x3f, r0	; 63
    1902:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <vTaskSuspendAll>
    1906:	0f b6       	in	r0, 0x3f	; 63
    1908:	f8 94       	cli
    190a:	0f 92       	push	r0
    190c:	f7 01       	movw	r30, r14
    190e:	81 a1       	ldd	r24, Z+33	; 0x21
    1910:	8f 3f       	cpi	r24, 0xFF	; 255
    1912:	09 f4       	brne	.+2      	; 0x1916 <xQueueGenericSend+0xac>
    1914:	11 a2       	std	Z+33, r1	; 0x21
    1916:	f7 01       	movw	r30, r14
    1918:	82 a1       	ldd	r24, Z+34	; 0x22
    191a:	8f 3f       	cpi	r24, 0xFF	; 255
    191c:	09 f4       	brne	.+2      	; 0x1920 <xQueueGenericSend+0xb6>
    191e:	12 a2       	std	Z+34, r1	; 0x22
    1920:	0f 90       	pop	r0
    1922:	0f be       	out	0x3f, r0	; 63
    1924:	be 01       	movw	r22, r28
    1926:	6a 5f       	subi	r22, 0xFA	; 250
    1928:	7f 4f       	sbci	r23, 0xFF	; 255
    192a:	ce 01       	movw	r24, r28
    192c:	01 96       	adiw	r24, 0x01	; 1
    192e:	0e 94 3a 12 	call	0x2474	; 0x2474 <xTaskCheckForTimeOut>
    1932:	81 11       	cpse	r24, r1
    1934:	21 c0       	rjmp	.+66     	; 0x1978 <xQueueGenericSend+0x10e>
    1936:	0f b6       	in	r0, 0x3f	; 63
    1938:	f8 94       	cli
    193a:	0f 92       	push	r0
    193c:	f7 01       	movw	r30, r14
    193e:	96 8d       	ldd	r25, Z+30	; 0x1e
    1940:	0f 90       	pop	r0
    1942:	0f be       	out	0x3f, r0	; 63
    1944:	87 8d       	ldd	r24, Z+31	; 0x1f
    1946:	98 13       	cpse	r25, r24
    1948:	11 c0       	rjmp	.+34     	; 0x196c <xQueueGenericSend+0x102>
    194a:	4e 81       	ldd	r20, Y+6	; 0x06
    194c:	5f 81       	ldd	r21, Y+7	; 0x07
    194e:	68 85       	ldd	r22, Y+8	; 0x08
    1950:	79 85       	ldd	r23, Y+9	; 0x09
    1952:	c6 01       	movw	r24, r12
    1954:	0e 94 c0 11 	call	0x2380	; 0x2380 <vTaskPlaceOnEventList>
    1958:	c7 01       	movw	r24, r14
    195a:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
    195e:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
    1962:	81 11       	cpse	r24, r1
    1964:	9c cf       	rjmp	.-200    	; 0x189e <xQueueGenericSend+0x34>
    1966:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    196a:	99 cf       	rjmp	.-206    	; 0x189e <xQueueGenericSend+0x34>
    196c:	c7 01       	movw	r24, r14
    196e:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
    1972:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
    1976:	93 cf       	rjmp	.-218    	; 0x189e <xQueueGenericSend+0x34>
    1978:	c7 01       	movw	r24, r14
    197a:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
    197e:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	29 96       	adiw	r28, 0x09	; 9
    1986:	cd bf       	out	0x3d, r28	; 61
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	1f 91       	pop	r17
    1990:	0f 91       	pop	r16
    1992:	ff 90       	pop	r15
    1994:	ef 90       	pop	r14
    1996:	df 90       	pop	r13
    1998:	cf 90       	pop	r12
    199a:	bf 90       	pop	r11
    199c:	af 90       	pop	r10
    199e:	08 95       	ret

000019a0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    19a0:	0f 93       	push	r16
    19a2:	1f 93       	push	r17
    19a4:	cf 93       	push	r28
    19a6:	df 93       	push	r29
    19a8:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    19aa:	fc 01       	movw	r30, r24
    19ac:	56 8d       	ldd	r21, Z+30	; 0x1e
    19ae:	37 8d       	ldd	r19, Z+31	; 0x1f
    19b0:	53 17       	cp	r21, r19
    19b2:	c0 f4       	brcc	.+48     	; 0x19e4 <xQueueGenericSendFromISR+0x44>
    19b4:	42 2f       	mov	r20, r18
    19b6:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    19b8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    19bc:	8a a1       	ldd	r24, Y+34	; 0x22
    19be:	8f 3f       	cpi	r24, 0xFF	; 255
    19c0:	69 f4       	brne	.+26     	; 0x19dc <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    19c2:	8b 89       	ldd	r24, Y+19	; 0x13
    19c4:	88 23       	and	r24, r24
    19c6:	81 f0       	breq	.+32     	; 0x19e8 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    19c8:	ce 01       	movw	r24, r28
    19ca:	43 96       	adiw	r24, 0x13	; 19
    19cc:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    19d0:	88 23       	and	r24, r24
    19d2:	61 f0       	breq	.+24     	; 0x19ec <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    19d4:	81 e0       	ldi	r24, 0x01	; 1
    19d6:	f8 01       	movw	r30, r16
    19d8:	80 83       	st	Z, r24
    19da:	09 c0       	rjmp	.+18     	; 0x19ee <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    19dc:	8f 5f       	subi	r24, 0xFF	; 255
    19de:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	05 c0       	rjmp	.+10     	; 0x19ee <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	03 c0       	rjmp	.+6      	; 0x19ee <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	01 c0       	rjmp	.+2      	; 0x19ee <xQueueGenericSendFromISR+0x4e>
    19ec:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19ee:	df 91       	pop	r29
    19f0:	cf 91       	pop	r28
    19f2:	1f 91       	pop	r17
    19f4:	0f 91       	pop	r16
    19f6:	08 95       	ret

000019f8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    19f8:	af 92       	push	r10
    19fa:	bf 92       	push	r11
    19fc:	cf 92       	push	r12
    19fe:	df 92       	push	r13
    1a00:	ef 92       	push	r14
    1a02:	ff 92       	push	r15
    1a04:	0f 93       	push	r16
    1a06:	1f 93       	push	r17
    1a08:	cf 93       	push	r28
    1a0a:	df 93       	push	r29
    1a0c:	cd b7       	in	r28, 0x3d	; 61
    1a0e:	de b7       	in	r29, 0x3e	; 62
    1a10:	29 97       	sbiw	r28, 0x09	; 9
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	de bf       	out	0x3e, r29	; 62
    1a16:	7c 01       	movw	r14, r24
    1a18:	5b 01       	movw	r10, r22
    1a1a:	2e 83       	std	Y+6, r18	; 0x06
    1a1c:	3f 83       	std	Y+7, r19	; 0x07
    1a1e:	48 87       	std	Y+8, r20	; 0x08
    1a20:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1a22:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a24:	6c 01       	movw	r12, r24
    1a26:	83 e1       	ldi	r24, 0x13	; 19
    1a28:	c8 0e       	add	r12, r24
    1a2a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1a2c:	0f b6       	in	r0, 0x3f	; 63
    1a2e:	f8 94       	cli
    1a30:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1a32:	f7 01       	movw	r30, r14
    1a34:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a36:	88 23       	and	r24, r24
    1a38:	99 f1       	breq	.+102    	; 0x1aa0 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1a3a:	c6 80       	ldd	r12, Z+6	; 0x06
    1a3c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a3e:	b5 01       	movw	r22, r10
    1a40:	c7 01       	movw	r24, r14
    1a42:	0e 94 67 0b 	call	0x16ce	; 0x16ce <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1a46:	01 11       	cpse	r16, r1
    1a48:	1a c0       	rjmp	.+52     	; 0x1a7e <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1a4a:	f7 01       	movw	r30, r14
    1a4c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a4e:	81 50       	subi	r24, 0x01	; 1
    1a50:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1a52:	80 81       	ld	r24, Z
    1a54:	91 81       	ldd	r25, Z+1	; 0x01
    1a56:	89 2b       	or	r24, r25
    1a58:	29 f4       	brne	.+10     	; 0x1a64 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    1a5a:	0e 94 c4 12 	call	0x2588	; 0x2588 <xTaskGetCurrentTaskHandle>
    1a5e:	f7 01       	movw	r30, r14
    1a60:	82 83       	std	Z+2, r24	; 0x02
    1a62:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a64:	f7 01       	movw	r30, r14
    1a66:	80 85       	ldd	r24, Z+8	; 0x08
    1a68:	88 23       	and	r24, r24
    1a6a:	b1 f0       	breq	.+44     	; 0x1a98 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1a6c:	c7 01       	movw	r24, r14
    1a6e:	08 96       	adiw	r24, 0x08	; 8
    1a70:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    1a74:	81 30       	cpi	r24, 0x01	; 1
    1a76:	81 f4       	brne	.+32     	; 0x1a98 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1a78:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    1a7c:	0d c0       	rjmp	.+26     	; 0x1a98 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1a7e:	f7 01       	movw	r30, r14
    1a80:	c6 82       	std	Z+6, r12	; 0x06
    1a82:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a84:	83 89       	ldd	r24, Z+19	; 0x13
    1a86:	88 23       	and	r24, r24
    1a88:	39 f0       	breq	.+14     	; 0x1a98 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a8a:	c7 01       	movw	r24, r14
    1a8c:	43 96       	adiw	r24, 0x13	; 19
    1a8e:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    1a92:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1a94:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1a98:	0f 90       	pop	r0
    1a9a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	62 c0       	rjmp	.+196    	; 0x1b64 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1aa0:	8e 81       	ldd	r24, Y+6	; 0x06
    1aa2:	9f 81       	ldd	r25, Y+7	; 0x07
    1aa4:	a8 85       	ldd	r26, Y+8	; 0x08
    1aa6:	b9 85       	ldd	r27, Y+9	; 0x09
    1aa8:	89 2b       	or	r24, r25
    1aaa:	8a 2b       	or	r24, r26
    1aac:	8b 2b       	or	r24, r27
    1aae:	21 f4       	brne	.+8      	; 0x1ab8 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ab0:	0f 90       	pop	r0
    1ab2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1ab4:	80 e0       	ldi	r24, 0x00	; 0
    1ab6:	56 c0       	rjmp	.+172    	; 0x1b64 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ab8:	11 11       	cpse	r17, r1
    1aba:	05 c0       	rjmp	.+10     	; 0x1ac6 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1abc:	ce 01       	movw	r24, r28
    1abe:	01 96       	adiw	r24, 0x01	; 1
    1ac0:	0e 94 29 12 	call	0x2452	; 0x2452 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1ac4:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1ac6:	0f 90       	pop	r0
    1ac8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1aca:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	0f 92       	push	r0
    1ad4:	f7 01       	movw	r30, r14
    1ad6:	81 a1       	ldd	r24, Z+33	; 0x21
    1ad8:	8f 3f       	cpi	r24, 0xFF	; 255
    1ada:	09 f4       	brne	.+2      	; 0x1ade <xQueueGenericReceive+0xe6>
    1adc:	11 a2       	std	Z+33, r1	; 0x21
    1ade:	f7 01       	movw	r30, r14
    1ae0:	82 a1       	ldd	r24, Z+34	; 0x22
    1ae2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ae4:	09 f4       	brne	.+2      	; 0x1ae8 <xQueueGenericReceive+0xf0>
    1ae6:	12 a2       	std	Z+34, r1	; 0x22
    1ae8:	0f 90       	pop	r0
    1aea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1aec:	be 01       	movw	r22, r28
    1aee:	6a 5f       	subi	r22, 0xFA	; 250
    1af0:	7f 4f       	sbci	r23, 0xFF	; 255
    1af2:	ce 01       	movw	r24, r28
    1af4:	01 96       	adiw	r24, 0x01	; 1
    1af6:	0e 94 3a 12 	call	0x2474	; 0x2474 <xTaskCheckForTimeOut>
    1afa:	81 11       	cpse	r24, r1
    1afc:	2d c0       	rjmp	.+90     	; 0x1b58 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1afe:	0f b6       	in	r0, 0x3f	; 63
    1b00:	f8 94       	cli
    1b02:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1b04:	f7 01       	movw	r30, r14
    1b06:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1b0c:	81 11       	cpse	r24, r1
    1b0e:	1e c0       	rjmp	.+60     	; 0x1b4c <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1b10:	80 81       	ld	r24, Z
    1b12:	91 81       	ldd	r25, Z+1	; 0x01
    1b14:	89 2b       	or	r24, r25
    1b16:	49 f4       	brne	.+18     	; 0x1b2a <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    1b18:	0f b6       	in	r0, 0x3f	; 63
    1b1a:	f8 94       	cli
    1b1c:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1b1e:	82 81       	ldd	r24, Z+2	; 0x02
    1b20:	93 81       	ldd	r25, Z+3	; 0x03
    1b22:	0e 94 c9 12 	call	0x2592	; 0x2592 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1b2a:	4e 81       	ldd	r20, Y+6	; 0x06
    1b2c:	5f 81       	ldd	r21, Y+7	; 0x07
    1b2e:	68 85       	ldd	r22, Y+8	; 0x08
    1b30:	79 85       	ldd	r23, Y+9	; 0x09
    1b32:	c6 01       	movw	r24, r12
    1b34:	0e 94 c0 11 	call	0x2380	; 0x2380 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1b38:	c7 01       	movw	r24, r14
    1b3a:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1b3e:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
    1b42:	81 11       	cpse	r24, r1
    1b44:	73 cf       	rjmp	.-282    	; 0x1a2c <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    1b46:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    1b4a:	70 cf       	rjmp	.-288    	; 0x1a2c <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b4c:	c7 01       	movw	r24, r14
    1b4e:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b52:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
    1b56:	6a cf       	rjmp	.-300    	; 0x1a2c <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1b58:	c7 01       	movw	r24, r14
    1b5a:	0e 94 81 0b 	call	0x1702	; 0x1702 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b5e:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1b62:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1b64:	29 96       	adiw	r28, 0x09	; 9
    1b66:	cd bf       	out	0x3d, r28	; 61
    1b68:	de bf       	out	0x3e, r29	; 62
    1b6a:	df 91       	pop	r29
    1b6c:	cf 91       	pop	r28
    1b6e:	1f 91       	pop	r17
    1b70:	0f 91       	pop	r16
    1b72:	ff 90       	pop	r15
    1b74:	ef 90       	pop	r14
    1b76:	df 90       	pop	r13
    1b78:	cf 90       	pop	r12
    1b7a:	bf 90       	pop	r11
    1b7c:	af 90       	pop	r10
    1b7e:	08 95       	ret

00001b80 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1b80:	0f 93       	push	r16
    1b82:	1f 93       	push	r17
    1b84:	cf 93       	push	r28
    1b86:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1b88:	fc 01       	movw	r30, r24
    1b8a:	26 8d       	ldd	r18, Z+30	; 0x1e
    1b8c:	22 23       	and	r18, r18
    1b8e:	d9 f0       	breq	.+54     	; 0x1bc6 <xQueueReceiveFromISR+0x46>
    1b90:	8a 01       	movw	r16, r20
    1b92:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b94:	0e 94 67 0b 	call	0x16ce	; 0x16ce <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1b98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b9a:	81 50       	subi	r24, 0x01	; 1
    1b9c:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1b9e:	89 a1       	ldd	r24, Y+33	; 0x21
    1ba0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ba2:	69 f4       	brne	.+26     	; 0x1bbe <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ba4:	88 85       	ldd	r24, Y+8	; 0x08
    1ba6:	88 23       	and	r24, r24
    1ba8:	81 f0       	breq	.+32     	; 0x1bca <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1baa:	ce 01       	movw	r24, r28
    1bac:	08 96       	adiw	r24, 0x08	; 8
    1bae:	0e 94 ea 11 	call	0x23d4	; 0x23d4 <xTaskRemoveFromEventList>
    1bb2:	88 23       	and	r24, r24
    1bb4:	61 f0       	breq	.+24     	; 0x1bce <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	f8 01       	movw	r30, r16
    1bba:	80 83       	st	Z, r24
    1bbc:	09 c0       	rjmp	.+18     	; 0x1bd0 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1bbe:	8f 5f       	subi	r24, 0xFF	; 255
    1bc0:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	05 c0       	rjmp	.+10     	; 0x1bd0 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1bc6:	80 e0       	ldi	r24, 0x00	; 0
    1bc8:	03 c0       	rjmp	.+6      	; 0x1bd0 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	01 c0       	rjmp	.+2      	; 0x1bd0 <xQueueReceiveFromISR+0x50>
    1bce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1bd0:	df 91       	pop	r29
    1bd2:	cf 91       	pop	r28
    1bd4:	1f 91       	pop	r17
    1bd6:	0f 91       	pop	r16
    1bd8:	08 95       	ret

00001bda <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1be0:	fc 01       	movw	r30, r24
    1be2:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1be4:	0f 90       	pop	r0
    1be6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1be8:	08 95       	ret

00001bea <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1bea:	fc 01       	movw	r30, r24
    1bec:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    1bee:	08 95       	ret

00001bf0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1bf0:	cc e1       	ldi	r28, 0x1C	; 28
    1bf2:	d1 e3       	ldi	r29, 0x31	; 49
    1bf4:	88 81       	ld	r24, Y
    1bf6:	82 30       	cpi	r24, 0x02	; 2
    1bf8:	e8 f3       	brcs	.-6      	; 0x1bf4 <prvIdleTask+0x4>
    1bfa:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    1bfe:	fa cf       	rjmp	.-12     	; 0x1bf4 <prvIdleTask+0x4>

00001c00 <prvAddCurrentTaskToDelayedList>:
    1c00:	cf 92       	push	r12
    1c02:	df 92       	push	r13
    1c04:	ef 92       	push	r14
    1c06:	ff 92       	push	r15
    1c08:	6b 01       	movw	r12, r22
    1c0a:	7c 01       	movw	r14, r24
    1c0c:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1c10:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c14:	62 83       	std	Z+2, r22	; 0x02
    1c16:	73 83       	std	Z+3, r23	; 0x03
    1c18:	84 83       	std	Z+4, r24	; 0x04
    1c1a:	95 83       	std	Z+5, r25	; 0x05
    1c1c:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1c20:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1c24:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1c28:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1c2c:	c8 16       	cp	r12, r24
    1c2e:	d9 06       	cpc	r13, r25
    1c30:	ea 06       	cpc	r14, r26
    1c32:	fb 06       	cpc	r15, r27
    1c34:	68 f4       	brcc	.+26     	; 0x1c50 <prvAddCurrentTaskToDelayedList+0x50>
    1c36:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    1c3a:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c3e:	80 91 02 31 	lds	r24, 0x3102	; 0x803102 <pxOverflowDelayedTaskList>
    1c42:	90 91 03 31 	lds	r25, 0x3103	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1c46:	6e 5f       	subi	r22, 0xFE	; 254
    1c48:	7f 4f       	sbci	r23, 0xFF	; 255
    1c4a:	0e 94 2f 09 	call	0x125e	; 0x125e <vListInsert>
    1c4e:	21 c0       	rjmp	.+66     	; 0x1c92 <prvAddCurrentTaskToDelayedList+0x92>
    1c50:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    1c54:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1c58:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxDelayedTaskList>
    1c5c:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    1c60:	6e 5f       	subi	r22, 0xFE	; 254
    1c62:	7f 4f       	sbci	r23, 0xFF	; 255
    1c64:	0e 94 2f 09 	call	0x125e	; 0x125e <vListInsert>
    1c68:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1c6c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c70:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c74:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c78:	c8 16       	cp	r12, r24
    1c7a:	d9 06       	cpc	r13, r25
    1c7c:	ea 06       	cpc	r14, r26
    1c7e:	fb 06       	cpc	r15, r27
    1c80:	40 f4       	brcc	.+16     	; 0x1c92 <prvAddCurrentTaskToDelayedList+0x92>
    1c82:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1c86:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c8a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c8e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c92:	ff 90       	pop	r15
    1c94:	ef 90       	pop	r14
    1c96:	df 90       	pop	r13
    1c98:	cf 90       	pop	r12
    1c9a:	08 95       	ret

00001c9c <xTaskGenericCreate>:
    1c9c:	4f 92       	push	r4
    1c9e:	5f 92       	push	r5
    1ca0:	6f 92       	push	r6
    1ca2:	7f 92       	push	r7
    1ca4:	8f 92       	push	r8
    1ca6:	9f 92       	push	r9
    1ca8:	af 92       	push	r10
    1caa:	bf 92       	push	r11
    1cac:	cf 92       	push	r12
    1cae:	df 92       	push	r13
    1cb0:	ef 92       	push	r14
    1cb2:	ff 92       	push	r15
    1cb4:	0f 93       	push	r16
    1cb6:	1f 93       	push	r17
    1cb8:	cf 93       	push	r28
    1cba:	df 93       	push	r29
    1cbc:	5c 01       	movw	r10, r24
    1cbe:	4b 01       	movw	r8, r22
    1cc0:	3a 01       	movw	r6, r20
    1cc2:	29 01       	movw	r4, r18
    1cc4:	88 e2       	ldi	r24, 0x28	; 40
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    1ccc:	ec 01       	movw	r28, r24
    1cce:	89 2b       	or	r24, r25
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <xTaskGenericCreate+0x38>
    1cd2:	d4 c0       	rjmp	.+424    	; 0x1e7c <xTaskGenericCreate+0x1e0>
    1cd4:	c1 14       	cp	r12, r1
    1cd6:	d1 04       	cpc	r13, r1
    1cd8:	09 f0       	breq	.+2      	; 0x1cdc <xTaskGenericCreate+0x40>
    1cda:	cc c0       	rjmp	.+408    	; 0x1e74 <xTaskGenericCreate+0x1d8>
    1cdc:	c3 01       	movw	r24, r6
    1cde:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    1ce2:	8b 8f       	std	Y+27, r24	; 0x1b
    1ce4:	9c 8f       	std	Y+28, r25	; 0x1c
    1ce6:	00 97       	sbiw	r24, 0x00	; 0
    1ce8:	21 f4       	brne	.+8      	; 0x1cf2 <xTaskGenericCreate+0x56>
    1cea:	ce 01       	movw	r24, r28
    1cec:	0e 94 bb 08 	call	0x1176	; 0x1176 <vPortFree>
    1cf0:	c5 c0       	rjmp	.+394    	; 0x1e7c <xTaskGenericCreate+0x1e0>
    1cf2:	a3 01       	movw	r20, r6
    1cf4:	61 e1       	ldi	r22, 0x11	; 17
    1cf6:	70 e0       	ldi	r23, 0x00	; 0
    1cf8:	0e 94 5a 20 	call	0x40b4	; 0x40b4 <memset>
    1cfc:	93 01       	movw	r18, r6
    1cfe:	21 50       	subi	r18, 0x01	; 1
    1d00:	31 09       	sbc	r19, r1
    1d02:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d04:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1d06:	3c 01       	movw	r6, r24
    1d08:	62 0e       	add	r6, r18
    1d0a:	73 1e       	adc	r7, r19
    1d0c:	4a e0       	ldi	r20, 0x0A	; 10
    1d0e:	50 e0       	ldi	r21, 0x00	; 0
    1d10:	b4 01       	movw	r22, r8
    1d12:	ce 01       	movw	r24, r28
    1d14:	4d 96       	adiw	r24, 0x1d	; 29
    1d16:	0e 94 61 20 	call	0x40c2	; 0x40c2 <strncpy>
    1d1a:	1e a2       	std	Y+38, r1	; 0x26
    1d1c:	10 2f       	mov	r17, r16
    1d1e:	04 30       	cpi	r16, 0x04	; 4
    1d20:	08 f0       	brcs	.+2      	; 0x1d24 <xTaskGenericCreate+0x88>
    1d22:	13 e0       	ldi	r17, 0x03	; 3
    1d24:	1a 8f       	std	Y+26, r17	; 0x1a
    1d26:	1f a3       	std	Y+39, r17	; 0x27
    1d28:	6e 01       	movw	r12, r28
    1d2a:	22 e0       	ldi	r18, 0x02	; 2
    1d2c:	c2 0e       	add	r12, r18
    1d2e:	d1 1c       	adc	r13, r1
    1d30:	c6 01       	movw	r24, r12
    1d32:	0e 94 04 09 	call	0x1208	; 0x1208 <vListInitialiseItem>
    1d36:	ce 01       	movw	r24, r28
    1d38:	0e 96       	adiw	r24, 0x0e	; 14
    1d3a:	0e 94 04 09 	call	0x1208	; 0x1208 <vListInitialiseItem>
    1d3e:	ca 87       	std	Y+10, r28	; 0x0a
    1d40:	db 87       	std	Y+11, r29	; 0x0b
    1d42:	84 e0       	ldi	r24, 0x04	; 4
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	a0 e0       	ldi	r26, 0x00	; 0
    1d48:	b0 e0       	ldi	r27, 0x00	; 0
    1d4a:	81 1b       	sub	r24, r17
    1d4c:	91 09       	sbc	r25, r1
    1d4e:	a1 09       	sbc	r26, r1
    1d50:	b1 09       	sbc	r27, r1
    1d52:	8e 87       	std	Y+14, r24	; 0x0e
    1d54:	9f 87       	std	Y+15, r25	; 0x0f
    1d56:	a8 8b       	std	Y+16, r26	; 0x10
    1d58:	b9 8b       	std	Y+17, r27	; 0x11
    1d5a:	ce 8b       	std	Y+22, r28	; 0x16
    1d5c:	df 8b       	std	Y+23, r29	; 0x17
    1d5e:	a2 01       	movw	r20, r4
    1d60:	b5 01       	movw	r22, r10
    1d62:	c3 01       	movw	r24, r6
    1d64:	0e 94 a0 09 	call	0x1340	; 0x1340 <pxPortInitialiseStack>
    1d68:	88 83       	st	Y, r24
    1d6a:	99 83       	std	Y+1, r25	; 0x01
    1d6c:	e1 14       	cp	r14, r1
    1d6e:	f1 04       	cpc	r15, r1
    1d70:	19 f0       	breq	.+6      	; 0x1d78 <xTaskGenericCreate+0xdc>
    1d72:	f7 01       	movw	r30, r14
    1d74:	c0 83       	st	Z, r28
    1d76:	d1 83       	std	Z+1, r29	; 0x01
    1d78:	0f b6       	in	r0, 0x3f	; 63
    1d7a:	f8 94       	cli
    1d7c:	0f 92       	push	r0
    1d7e:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    1d82:	8f 5f       	subi	r24, 0xFF	; 255
    1d84:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <uxCurrentNumberOfTasks>
    1d88:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1d8c:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1d90:	89 2b       	or	r24, r25
    1d92:	89 f5       	brne	.+98     	; 0x1df6 <xTaskGenericCreate+0x15a>
    1d94:	c0 93 48 31 	sts	0x3148, r28	; 0x803148 <pxCurrentTCB>
    1d98:	d0 93 49 31 	sts	0x3149, r29	; 0x803149 <pxCurrentTCB+0x1>
    1d9c:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    1da0:	81 30       	cpi	r24, 0x01	; 1
    1da2:	c1 f5       	brne	.+112    	; 0x1e14 <xTaskGenericCreate+0x178>
    1da4:	8c e1       	ldi	r24, 0x1C	; 28
    1da6:	91 e3       	ldi	r25, 0x31	; 49
    1da8:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1dac:	87 e2       	ldi	r24, 0x27	; 39
    1dae:	91 e3       	ldi	r25, 0x31	; 49
    1db0:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1db4:	82 e3       	ldi	r24, 0x32	; 50
    1db6:	91 e3       	ldi	r25, 0x31	; 49
    1db8:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1dbc:	8d e3       	ldi	r24, 0x3D	; 61
    1dbe:	91 e3       	ldi	r25, 0x31	; 49
    1dc0:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1dc4:	81 e1       	ldi	r24, 0x11	; 17
    1dc6:	91 e3       	ldi	r25, 0x31	; 49
    1dc8:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1dcc:	86 e0       	ldi	r24, 0x06	; 6
    1dce:	91 e3       	ldi	r25, 0x31	; 49
    1dd0:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1dd4:	87 ef       	ldi	r24, 0xF7	; 247
    1dd6:	90 e3       	ldi	r25, 0x30	; 48
    1dd8:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <vListInitialise>
    1ddc:	81 e1       	ldi	r24, 0x11	; 17
    1dde:	91 e3       	ldi	r25, 0x31	; 49
    1de0:	80 93 04 31 	sts	0x3104, r24	; 0x803104 <pxDelayedTaskList>
    1de4:	90 93 05 31 	sts	0x3105, r25	; 0x803105 <pxDelayedTaskList+0x1>
    1de8:	86 e0       	ldi	r24, 0x06	; 6
    1dea:	91 e3       	ldi	r25, 0x31	; 49
    1dec:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxOverflowDelayedTaskList>
    1df0:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1df4:	0f c0       	rjmp	.+30     	; 0x1e14 <xTaskGenericCreate+0x178>
    1df6:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <xSchedulerRunning>
    1dfa:	81 11       	cpse	r24, r1
    1dfc:	0b c0       	rjmp	.+22     	; 0x1e14 <xTaskGenericCreate+0x178>
    1dfe:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1e02:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1e06:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e08:	08 17       	cp	r16, r24
    1e0a:	20 f0       	brcs	.+8      	; 0x1e14 <xTaskGenericCreate+0x178>
    1e0c:	c0 93 48 31 	sts	0x3148, r28	; 0x803148 <pxCurrentTCB>
    1e10:	d0 93 49 31 	sts	0x3149, r29	; 0x803149 <pxCurrentTCB+0x1>
    1e14:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e16:	90 91 ef 30 	lds	r25, 0x30EF	; 0x8030ef <uxTopUsedPriority>
    1e1a:	98 17       	cp	r25, r24
    1e1c:	10 f4       	brcc	.+4      	; 0x1e22 <xTaskGenericCreate+0x186>
    1e1e:	80 93 ef 30 	sts	0x30EF, r24	; 0x8030ef <uxTopUsedPriority>
    1e22:	90 91 e8 30 	lds	r25, 0x30E8	; 0x8030e8 <uxTaskNumber>
    1e26:	9f 5f       	subi	r25, 0xFF	; 255
    1e28:	90 93 e8 30 	sts	0x30E8, r25	; 0x8030e8 <uxTaskNumber>
    1e2c:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    1e30:	98 17       	cp	r25, r24
    1e32:	10 f4       	brcc	.+4      	; 0x1e38 <xTaskGenericCreate+0x19c>
    1e34:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    1e38:	fb e0       	ldi	r31, 0x0B	; 11
    1e3a:	8f 9f       	mul	r24, r31
    1e3c:	c0 01       	movw	r24, r0
    1e3e:	11 24       	eor	r1, r1
    1e40:	b6 01       	movw	r22, r12
    1e42:	84 5e       	subi	r24, 0xE4	; 228
    1e44:	9e 4c       	sbci	r25, 0xCE	; 206
    1e46:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
    1e4a:	0f 90       	pop	r0
    1e4c:	0f be       	out	0x3f, r0	; 63
    1e4e:	80 91 ed 30 	lds	r24, 0x30ED	; 0x8030ed <xSchedulerRunning>
    1e52:	88 23       	and	r24, r24
    1e54:	59 f0       	breq	.+22     	; 0x1e6c <xTaskGenericCreate+0x1d0>
    1e56:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    1e5a:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1e5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e60:	80 17       	cp	r24, r16
    1e62:	30 f4       	brcc	.+12     	; 0x1e70 <xTaskGenericCreate+0x1d4>
    1e64:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	09 c0       	rjmp	.+18     	; 0x1e7e <xTaskGenericCreate+0x1e2>
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	07 c0       	rjmp	.+14     	; 0x1e7e <xTaskGenericCreate+0x1e2>
    1e70:	81 e0       	ldi	r24, 0x01	; 1
    1e72:	05 c0       	rjmp	.+10     	; 0x1e7e <xTaskGenericCreate+0x1e2>
    1e74:	cb 8e       	std	Y+27, r12	; 0x1b
    1e76:	dc 8e       	std	Y+28, r13	; 0x1c
    1e78:	c6 01       	movw	r24, r12
    1e7a:	3b cf       	rjmp	.-394    	; 0x1cf2 <xTaskGenericCreate+0x56>
    1e7c:	8f ef       	ldi	r24, 0xFF	; 255
    1e7e:	df 91       	pop	r29
    1e80:	cf 91       	pop	r28
    1e82:	1f 91       	pop	r17
    1e84:	0f 91       	pop	r16
    1e86:	ff 90       	pop	r15
    1e88:	ef 90       	pop	r14
    1e8a:	df 90       	pop	r13
    1e8c:	cf 90       	pop	r12
    1e8e:	bf 90       	pop	r11
    1e90:	af 90       	pop	r10
    1e92:	9f 90       	pop	r9
    1e94:	8f 90       	pop	r8
    1e96:	7f 90       	pop	r7
    1e98:	6f 90       	pop	r6
    1e9a:	5f 90       	pop	r5
    1e9c:	4f 90       	pop	r4
    1e9e:	08 95       	ret

00001ea0 <uxTaskPriorityGet>:
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	0f 92       	push	r0
    1ea6:	00 97       	sbiw	r24, 0x00	; 0
    1ea8:	21 f4       	brne	.+8      	; 0x1eb2 <uxTaskPriorityGet+0x12>
    1eaa:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1eae:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
    1eb6:	fc 01       	movw	r30, r24
    1eb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eba:	08 95       	ret

00001ebc <vTaskStartScheduler>:
    1ebc:	af 92       	push	r10
    1ebe:	bf 92       	push	r11
    1ec0:	cf 92       	push	r12
    1ec2:	df 92       	push	r13
    1ec4:	ef 92       	push	r14
    1ec6:	ff 92       	push	r15
    1ec8:	0f 93       	push	r16
    1eca:	a1 2c       	mov	r10, r1
    1ecc:	b1 2c       	mov	r11, r1
    1ece:	c1 2c       	mov	r12, r1
    1ed0:	d1 2c       	mov	r13, r1
    1ed2:	0f 2e       	mov	r0, r31
    1ed4:	f5 ef       	ldi	r31, 0xF5	; 245
    1ed6:	ef 2e       	mov	r14, r31
    1ed8:	f0 e3       	ldi	r31, 0x30	; 48
    1eda:	ff 2e       	mov	r15, r31
    1edc:	f0 2d       	mov	r31, r0
    1ede:	00 e0       	ldi	r16, 0x00	; 0
    1ee0:	20 e0       	ldi	r18, 0x00	; 0
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	44 e6       	ldi	r20, 0x64	; 100
    1ee6:	50 e0       	ldi	r21, 0x00	; 0
    1ee8:	6e e2       	ldi	r22, 0x2E	; 46
    1eea:	70 e2       	ldi	r23, 0x20	; 32
    1eec:	88 ef       	ldi	r24, 0xF8	; 248
    1eee:	9d e0       	ldi	r25, 0x0D	; 13
    1ef0:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <xTaskGenericCreate>
    1ef4:	81 30       	cpi	r24, 0x01	; 1
    1ef6:	69 f4       	brne	.+26     	; 0x1f12 <vTaskStartScheduler+0x56>
    1ef8:	f8 94       	cli
    1efa:	80 93 ed 30 	sts	0x30ED, r24	; 0x8030ed <xSchedulerRunning>
    1efe:	10 92 f0 30 	sts	0x30F0, r1	; 0x8030f0 <xTickCount>
    1f02:	10 92 f1 30 	sts	0x30F1, r1	; 0x8030f1 <xTickCount+0x1>
    1f06:	10 92 f2 30 	sts	0x30F2, r1	; 0x8030f2 <xTickCount+0x2>
    1f0a:	10 92 f3 30 	sts	0x30F3, r1	; 0x8030f3 <xTickCount+0x3>
    1f0e:	0e 94 16 0a 	call	0x142c	; 0x142c <xPortStartScheduler>
    1f12:	0f 91       	pop	r16
    1f14:	ff 90       	pop	r15
    1f16:	ef 90       	pop	r14
    1f18:	df 90       	pop	r13
    1f1a:	cf 90       	pop	r12
    1f1c:	bf 90       	pop	r11
    1f1e:	af 90       	pop	r10
    1f20:	08 95       	ret

00001f22 <vTaskSuspendAll>:
    1f22:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    1f26:	8f 5f       	subi	r24, 0xFF	; 255
    1f28:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxSchedulerSuspended>
    1f2c:	08 95       	ret

00001f2e <xTaskGetTickCount>:
    1f2e:	0f b6       	in	r0, 0x3f	; 63
    1f30:	f8 94       	cli
    1f32:	0f 92       	push	r0
    1f34:	60 91 f0 30 	lds	r22, 0x30F0	; 0x8030f0 <xTickCount>
    1f38:	70 91 f1 30 	lds	r23, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1f3c:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1f40:	90 91 f3 30 	lds	r25, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1f44:	0f 90       	pop	r0
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	08 95       	ret

00001f4a <pcTaskGetTaskName>:
    1f4a:	00 97       	sbiw	r24, 0x00	; 0
    1f4c:	21 f4       	brne	.+8      	; 0x1f56 <pcTaskGetTaskName+0xc>
    1f4e:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    1f52:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    1f56:	4d 96       	adiw	r24, 0x1d	; 29
    1f58:	08 95       	ret

00001f5a <xTaskGetIdleTaskHandle>:
    1f5a:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <xIdleTaskHandle>
    1f5e:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <xIdleTaskHandle+0x1>
    1f62:	08 95       	ret

00001f64 <vTaskIncrementTick>:
    1f64:	ff 92       	push	r15
    1f66:	0f 93       	push	r16
    1f68:	1f 93       	push	r17
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
    1f6e:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    1f72:	81 11       	cpse	r24, r1
    1f74:	ed c0       	rjmp	.+474    	; 0x2150 <vTaskIncrementTick+0x1ec>
    1f76:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1f7a:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1f7e:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1f82:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1f86:	01 96       	adiw	r24, 0x01	; 1
    1f88:	a1 1d       	adc	r26, r1
    1f8a:	b1 1d       	adc	r27, r1
    1f8c:	80 93 f0 30 	sts	0x30F0, r24	; 0x8030f0 <xTickCount>
    1f90:	90 93 f1 30 	sts	0x30F1, r25	; 0x8030f1 <xTickCount+0x1>
    1f94:	a0 93 f2 30 	sts	0x30F2, r26	; 0x8030f2 <xTickCount+0x2>
    1f98:	b0 93 f3 30 	sts	0x30F3, r27	; 0x8030f3 <xTickCount+0x3>
    1f9c:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    1fa0:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    1fa4:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    1fa8:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    1fac:	89 2b       	or	r24, r25
    1fae:	8a 2b       	or	r24, r26
    1fb0:	8b 2b       	or	r24, r27
    1fb2:	f1 f5       	brne	.+124    	; 0x2030 <vTaskIncrementTick+0xcc>
    1fb4:	80 91 04 31 	lds	r24, 0x3104	; 0x803104 <pxDelayedTaskList>
    1fb8:	90 91 05 31 	lds	r25, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    1fbc:	20 91 02 31 	lds	r18, 0x3102	; 0x803102 <pxOverflowDelayedTaskList>
    1fc0:	30 91 03 31 	lds	r19, 0x3103	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1fc4:	20 93 04 31 	sts	0x3104, r18	; 0x803104 <pxDelayedTaskList>
    1fc8:	30 93 05 31 	sts	0x3105, r19	; 0x803105 <pxDelayedTaskList+0x1>
    1fcc:	80 93 02 31 	sts	0x3102, r24	; 0x803102 <pxOverflowDelayedTaskList>
    1fd0:	90 93 03 31 	sts	0x3103, r25	; 0x803103 <pxOverflowDelayedTaskList+0x1>
    1fd4:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    1fd8:	8f 5f       	subi	r24, 0xFF	; 255
    1fda:	80 93 e9 30 	sts	0x30E9, r24	; 0x8030e9 <xNumOfOverflows>
    1fde:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    1fe2:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    1fe6:	80 81       	ld	r24, Z
    1fe8:	81 11       	cpse	r24, r1
    1fea:	0c c0       	rjmp	.+24     	; 0x2004 <vTaskIncrementTick+0xa0>
    1fec:	8f ef       	ldi	r24, 0xFF	; 255
    1fee:	9f ef       	ldi	r25, 0xFF	; 255
    1ff0:	dc 01       	movw	r26, r24
    1ff2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1ff6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1ffa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ffe:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2002:	16 c0       	rjmp	.+44     	; 0x2030 <vTaskIncrementTick+0xcc>
    2004:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2008:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    200c:	07 80       	ldd	r0, Z+7	; 0x07
    200e:	f0 85       	ldd	r31, Z+8	; 0x08
    2010:	e0 2d       	mov	r30, r0
    2012:	00 84       	ldd	r0, Z+8	; 0x08
    2014:	f1 85       	ldd	r31, Z+9	; 0x09
    2016:	e0 2d       	mov	r30, r0
    2018:	82 81       	ldd	r24, Z+2	; 0x02
    201a:	93 81       	ldd	r25, Z+3	; 0x03
    201c:	a4 81       	ldd	r26, Z+4	; 0x04
    201e:	b5 81       	ldd	r27, Z+5	; 0x05
    2020:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    2024:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    2028:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    202c:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2030:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    2034:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    2038:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    203c:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    2040:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    2044:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    2048:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    204c:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    2050:	48 17       	cp	r20, r24
    2052:	59 07       	cpc	r21, r25
    2054:	6a 07       	cpc	r22, r26
    2056:	7b 07       	cpc	r23, r27
    2058:	08 f4       	brcc	.+2      	; 0x205c <vTaskIncrementTick+0xf8>
    205a:	7f c0       	rjmp	.+254    	; 0x215a <vTaskIncrementTick+0x1f6>
    205c:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2060:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2064:	80 81       	ld	r24, Z
    2066:	88 23       	and	r24, r24
    2068:	f9 f0       	breq	.+62     	; 0x20a8 <vTaskIncrementTick+0x144>
    206a:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    206e:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2072:	07 80       	ldd	r0, Z+7	; 0x07
    2074:	f0 85       	ldd	r31, Z+8	; 0x08
    2076:	e0 2d       	mov	r30, r0
    2078:	c0 85       	ldd	r28, Z+8	; 0x08
    207a:	d1 85       	ldd	r29, Z+9	; 0x09
    207c:	8a 81       	ldd	r24, Y+2	; 0x02
    207e:	9b 81       	ldd	r25, Y+3	; 0x03
    2080:	ac 81       	ldd	r26, Y+4	; 0x04
    2082:	bd 81       	ldd	r27, Y+5	; 0x05
    2084:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    2088:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    208c:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    2090:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    2094:	48 17       	cp	r20, r24
    2096:	59 07       	cpc	r21, r25
    2098:	6a 07       	cpc	r22, r26
    209a:	7b 07       	cpc	r23, r27
    209c:	58 f1       	brcs	.+86     	; 0x20f4 <vTaskIncrementTick+0x190>
    209e:	0f 2e       	mov	r0, r31
    20a0:	fb e0       	ldi	r31, 0x0B	; 11
    20a2:	ff 2e       	mov	r15, r31
    20a4:	f0 2d       	mov	r31, r0
    20a6:	2f c0       	rjmp	.+94     	; 0x2106 <vTaskIncrementTick+0x1a2>
    20a8:	8f ef       	ldi	r24, 0xFF	; 255
    20aa:	9f ef       	ldi	r25, 0xFF	; 255
    20ac:	dc 01       	movw	r26, r24
    20ae:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20b2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20b6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    20ba:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    20be:	4d c0       	rjmp	.+154    	; 0x215a <vTaskIncrementTick+0x1f6>
    20c0:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    20c4:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    20c8:	07 80       	ldd	r0, Z+7	; 0x07
    20ca:	f0 85       	ldd	r31, Z+8	; 0x08
    20cc:	e0 2d       	mov	r30, r0
    20ce:	c0 85       	ldd	r28, Z+8	; 0x08
    20d0:	d1 85       	ldd	r29, Z+9	; 0x09
    20d2:	8a 81       	ldd	r24, Y+2	; 0x02
    20d4:	9b 81       	ldd	r25, Y+3	; 0x03
    20d6:	ac 81       	ldd	r26, Y+4	; 0x04
    20d8:	bd 81       	ldd	r27, Y+5	; 0x05
    20da:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    20de:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    20e2:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    20e6:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    20ea:	48 17       	cp	r20, r24
    20ec:	59 07       	cpc	r21, r25
    20ee:	6a 07       	cpc	r22, r26
    20f0:	7b 07       	cpc	r23, r27
    20f2:	48 f4       	brcc	.+18     	; 0x2106 <vTaskIncrementTick+0x1a2>
    20f4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    20f8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    20fc:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    2100:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    2104:	2a c0       	rjmp	.+84     	; 0x215a <vTaskIncrementTick+0x1f6>
    2106:	8e 01       	movw	r16, r28
    2108:	0e 5f       	subi	r16, 0xFE	; 254
    210a:	1f 4f       	sbci	r17, 0xFF	; 255
    210c:	c8 01       	movw	r24, r16
    210e:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
    2112:	88 8d       	ldd	r24, Y+24	; 0x18
    2114:	99 8d       	ldd	r25, Y+25	; 0x19
    2116:	89 2b       	or	r24, r25
    2118:	21 f0       	breq	.+8      	; 0x2122 <vTaskIncrementTick+0x1be>
    211a:	ce 01       	movw	r24, r28
    211c:	0e 96       	adiw	r24, 0x0e	; 14
    211e:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
    2122:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2124:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2128:	98 17       	cp	r25, r24
    212a:	10 f4       	brcc	.+4      	; 0x2130 <vTaskIncrementTick+0x1cc>
    212c:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2130:	f8 9e       	mul	r15, r24
    2132:	c0 01       	movw	r24, r0
    2134:	11 24       	eor	r1, r1
    2136:	b8 01       	movw	r22, r16
    2138:	84 5e       	subi	r24, 0xE4	; 228
    213a:	9e 4c       	sbci	r25, 0xCE	; 206
    213c:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
    2140:	e0 91 04 31 	lds	r30, 0x3104	; 0x803104 <pxDelayedTaskList>
    2144:	f0 91 05 31 	lds	r31, 0x3105	; 0x803105 <pxDelayedTaskList+0x1>
    2148:	80 81       	ld	r24, Z
    214a:	81 11       	cpse	r24, r1
    214c:	b9 cf       	rjmp	.-142    	; 0x20c0 <vTaskIncrementTick+0x15c>
    214e:	ac cf       	rjmp	.-168    	; 0x20a8 <vTaskIncrementTick+0x144>
    2150:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2154:	8f 5f       	subi	r24, 0xFF	; 255
    2156:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <uxMissedTicks>
    215a:	df 91       	pop	r29
    215c:	cf 91       	pop	r28
    215e:	1f 91       	pop	r17
    2160:	0f 91       	pop	r16
    2162:	ff 90       	pop	r15
    2164:	08 95       	ret

00002166 <xTaskResumeAll>:
    2166:	cf 92       	push	r12
    2168:	df 92       	push	r13
    216a:	ef 92       	push	r14
    216c:	ff 92       	push	r15
    216e:	0f 93       	push	r16
    2170:	1f 93       	push	r17
    2172:	cf 93       	push	r28
    2174:	df 93       	push	r29
    2176:	0f b6       	in	r0, 0x3f	; 63
    2178:	f8 94       	cli
    217a:	0f 92       	push	r0
    217c:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    2180:	81 50       	subi	r24, 0x01	; 1
    2182:	80 93 ec 30 	sts	0x30EC, r24	; 0x8030ec <uxSchedulerSuspended>
    2186:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    218a:	81 11       	cpse	r24, r1
    218c:	60 c0       	rjmp	.+192    	; 0x224e <xTaskResumeAll+0xe8>
    218e:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxCurrentNumberOfTasks>
    2192:	81 11       	cpse	r24, r1
    2194:	2c c0       	rjmp	.+88     	; 0x21ee <xTaskResumeAll+0x88>
    2196:	5e c0       	rjmp	.+188    	; 0x2254 <xTaskResumeAll+0xee>
    2198:	d7 01       	movw	r26, r14
    219a:	17 96       	adiw	r26, 0x07	; 7
    219c:	ed 91       	ld	r30, X+
    219e:	fc 91       	ld	r31, X
    21a0:	18 97       	sbiw	r26, 0x08	; 8
    21a2:	c0 85       	ldd	r28, Z+8	; 0x08
    21a4:	d1 85       	ldd	r29, Z+9	; 0x09
    21a6:	ce 01       	movw	r24, r28
    21a8:	0e 96       	adiw	r24, 0x0e	; 14
    21aa:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
    21ae:	8e 01       	movw	r16, r28
    21b0:	0e 5f       	subi	r16, 0xFE	; 254
    21b2:	1f 4f       	sbci	r17, 0xFF	; 255
    21b4:	c8 01       	movw	r24, r16
    21b6:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
    21ba:	8a 8d       	ldd	r24, Y+26	; 0x1a
    21bc:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    21c0:	98 17       	cp	r25, r24
    21c2:	10 f4       	brcc	.+4      	; 0x21c8 <xTaskResumeAll+0x62>
    21c4:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    21c8:	d8 9e       	mul	r13, r24
    21ca:	c0 01       	movw	r24, r0
    21cc:	11 24       	eor	r1, r1
    21ce:	b8 01       	movw	r22, r16
    21d0:	84 5e       	subi	r24, 0xE4	; 228
    21d2:	9e 4c       	sbci	r25, 0xCE	; 206
    21d4:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
    21d8:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    21dc:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    21e0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    21e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21e4:	98 17       	cp	r25, r24
    21e6:	70 f0       	brcs	.+28     	; 0x2204 <xTaskResumeAll+0x9e>
    21e8:	cc 24       	eor	r12, r12
    21ea:	c3 94       	inc	r12
    21ec:	0b c0       	rjmp	.+22     	; 0x2204 <xTaskResumeAll+0x9e>
    21ee:	c1 2c       	mov	r12, r1
    21f0:	0f 2e       	mov	r0, r31
    21f2:	f7 ef       	ldi	r31, 0xF7	; 247
    21f4:	ef 2e       	mov	r14, r31
    21f6:	f0 e3       	ldi	r31, 0x30	; 48
    21f8:	ff 2e       	mov	r15, r31
    21fa:	f0 2d       	mov	r31, r0
    21fc:	0f 2e       	mov	r0, r31
    21fe:	fb e0       	ldi	r31, 0x0B	; 11
    2200:	df 2e       	mov	r13, r31
    2202:	f0 2d       	mov	r31, r0
    2204:	f7 01       	movw	r30, r14
    2206:	80 81       	ld	r24, Z
    2208:	81 11       	cpse	r24, r1
    220a:	c6 cf       	rjmp	.-116    	; 0x2198 <xTaskResumeAll+0x32>
    220c:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2210:	88 23       	and	r24, r24
    2212:	81 f0       	breq	.+32     	; 0x2234 <xTaskResumeAll+0xce>
    2214:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2218:	88 23       	and	r24, r24
    221a:	99 f0       	breq	.+38     	; 0x2242 <xTaskResumeAll+0xdc>
    221c:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <vTaskIncrementTick>
    2220:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    2224:	81 50       	subi	r24, 0x01	; 1
    2226:	80 93 eb 30 	sts	0x30EB, r24	; 0x8030eb <uxMissedTicks>
    222a:	80 91 eb 30 	lds	r24, 0x30EB	; 0x8030eb <uxMissedTicks>
    222e:	81 11       	cpse	r24, r1
    2230:	f5 cf       	rjmp	.-22     	; 0x221c <xTaskResumeAll+0xb6>
    2232:	07 c0       	rjmp	.+14     	; 0x2242 <xTaskResumeAll+0xdc>
    2234:	f1 e0       	ldi	r31, 0x01	; 1
    2236:	cf 16       	cp	r12, r31
    2238:	21 f0       	breq	.+8      	; 0x2242 <xTaskResumeAll+0xdc>
    223a:	80 91 ea 30 	lds	r24, 0x30EA	; 0x8030ea <xMissedYield>
    223e:	81 30       	cpi	r24, 0x01	; 1
    2240:	41 f4       	brne	.+16     	; 0x2252 <xTaskResumeAll+0xec>
    2242:	10 92 ea 30 	sts	0x30EA, r1	; 0x8030ea <xMissedYield>
    2246:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
    224a:	81 e0       	ldi	r24, 0x01	; 1
    224c:	03 c0       	rjmp	.+6      	; 0x2254 <xTaskResumeAll+0xee>
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	01 c0       	rjmp	.+2      	; 0x2254 <xTaskResumeAll+0xee>
    2252:	80 e0       	ldi	r24, 0x00	; 0
    2254:	0f 90       	pop	r0
    2256:	0f be       	out	0x3f, r0	; 63
    2258:	df 91       	pop	r29
    225a:	cf 91       	pop	r28
    225c:	1f 91       	pop	r17
    225e:	0f 91       	pop	r16
    2260:	ff 90       	pop	r15
    2262:	ef 90       	pop	r14
    2264:	df 90       	pop	r13
    2266:	cf 90       	pop	r12
    2268:	08 95       	ret

0000226a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    226a:	cf 92       	push	r12
    226c:	df 92       	push	r13
    226e:	ef 92       	push	r14
    2270:	ff 92       	push	r15
    2272:	6b 01       	movw	r12, r22
    2274:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2276:	67 2b       	or	r22, r23
    2278:	68 2b       	or	r22, r24
    227a:	69 2b       	or	r22, r25
    227c:	e9 f0       	breq	.+58     	; 0x22b8 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    227e:	0e 94 91 0f 	call	0x1f22	; 0x1f22 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2282:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    2286:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    228a:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    228e:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    2292:	c8 0e       	add	r12, r24
    2294:	d9 1e       	adc	r13, r25
    2296:	ea 1e       	adc	r14, r26
    2298:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    229a:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    229e:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    22a2:	02 96       	adiw	r24, 0x02	; 2
    22a4:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22a8:	c7 01       	movw	r24, r14
    22aa:	b6 01       	movw	r22, r12
    22ac:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    22b0:	0e 94 b3 10 	call	0x2166	; 0x2166 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22b4:	81 11       	cpse	r24, r1
    22b6:	02 c0       	rjmp	.+4      	; 0x22bc <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    22b8:	0e 94 54 0a 	call	0x14a8	; 0x14a8 <vPortYield>
		}
	}
    22bc:	ff 90       	pop	r15
    22be:	ef 90       	pop	r14
    22c0:	df 90       	pop	r13
    22c2:	cf 90       	pop	r12
    22c4:	08 95       	ret

000022c6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    22c6:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    22ca:	81 11       	cpse	r24, r1
    22cc:	0c c0       	rjmp	.+24     	; 0x22e6 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22ce:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    22d2:	4b e0       	ldi	r20, 0x0B	; 11
    22d4:	e4 9f       	mul	r30, r20
    22d6:	f0 01       	movw	r30, r0
    22d8:	11 24       	eor	r1, r1
    22da:	e4 5e       	subi	r30, 0xE4	; 228
    22dc:	fe 4c       	sbci	r31, 0xCE	; 206
    22de:	80 81       	ld	r24, Z
    22e0:	88 23       	and	r24, r24
    22e2:	29 f0       	breq	.+10     	; 0x22ee <vTaskSwitchContext+0x28>
    22e4:	14 c0       	rjmp	.+40     	; 0x230e <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xMissedYield>
    22ec:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22ee:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    22f0:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    22f4:	81 50       	subi	r24, 0x01	; 1
    22f6:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    22fa:	e0 91 ee 30 	lds	r30, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    22fe:	9e 9f       	mul	r25, r30
    2300:	f0 01       	movw	r30, r0
    2302:	11 24       	eor	r1, r1
    2304:	e4 5e       	subi	r30, 0xE4	; 228
    2306:	fe 4c       	sbci	r31, 0xCE	; 206
    2308:	80 81       	ld	r24, Z
    230a:	88 23       	and	r24, r24
    230c:	89 f3       	breq	.-30     	; 0x22f0 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    230e:	80 91 ee 30 	lds	r24, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2312:	28 2f       	mov	r18, r24
    2314:	30 e0       	ldi	r19, 0x00	; 0
    2316:	4b e0       	ldi	r20, 0x0B	; 11
    2318:	84 9f       	mul	r24, r20
    231a:	c0 01       	movw	r24, r0
    231c:	11 24       	eor	r1, r1
    231e:	dc 01       	movw	r26, r24
    2320:	a4 5e       	subi	r26, 0xE4	; 228
    2322:	be 4c       	sbci	r27, 0xCE	; 206
    2324:	11 96       	adiw	r26, 0x01	; 1
    2326:	ed 91       	ld	r30, X+
    2328:	fc 91       	ld	r31, X
    232a:	12 97       	sbiw	r26, 0x02	; 2
    232c:	04 80       	ldd	r0, Z+4	; 0x04
    232e:	f5 81       	ldd	r31, Z+5	; 0x05
    2330:	e0 2d       	mov	r30, r0
    2332:	11 96       	adiw	r26, 0x01	; 1
    2334:	ed 93       	st	X+, r30
    2336:	fc 93       	st	X, r31
    2338:	12 97       	sbiw	r26, 0x02	; 2
    233a:	81 5e       	subi	r24, 0xE1	; 225
    233c:	9e 4c       	sbci	r25, 0xCE	; 206
    233e:	e8 17       	cp	r30, r24
    2340:	f9 07       	cpc	r31, r25
    2342:	61 f4       	brne	.+24     	; 0x235c <vTaskSwitchContext+0x96>
    2344:	84 81       	ldd	r24, Z+4	; 0x04
    2346:	95 81       	ldd	r25, Z+5	; 0x05
    2348:	4b e0       	ldi	r20, 0x0B	; 11
    234a:	42 9f       	mul	r20, r18
    234c:	f0 01       	movw	r30, r0
    234e:	43 9f       	mul	r20, r19
    2350:	f0 0d       	add	r31, r0
    2352:	11 24       	eor	r1, r1
    2354:	e4 5e       	subi	r30, 0xE4	; 228
    2356:	fe 4c       	sbci	r31, 0xCE	; 206
    2358:	81 83       	std	Z+1, r24	; 0x01
    235a:	92 83       	std	Z+2, r25	; 0x02
    235c:	8b e0       	ldi	r24, 0x0B	; 11
    235e:	82 9f       	mul	r24, r18
    2360:	f0 01       	movw	r30, r0
    2362:	83 9f       	mul	r24, r19
    2364:	f0 0d       	add	r31, r0
    2366:	11 24       	eor	r1, r1
    2368:	e4 5e       	subi	r30, 0xE4	; 228
    236a:	fe 4c       	sbci	r31, 0xCE	; 206
    236c:	01 80       	ldd	r0, Z+1	; 0x01
    236e:	f2 81       	ldd	r31, Z+2	; 0x02
    2370:	e0 2d       	mov	r30, r0
    2372:	80 85       	ldd	r24, Z+8	; 0x08
    2374:	91 85       	ldd	r25, Z+9	; 0x09
    2376:	80 93 48 31 	sts	0x3148, r24	; 0x803148 <pxCurrentTCB>
    237a:	90 93 49 31 	sts	0x3149, r25	; 0x803149 <pxCurrentTCB+0x1>
    237e:	08 95       	ret

00002380 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2380:	cf 92       	push	r12
    2382:	df 92       	push	r13
    2384:	ef 92       	push	r14
    2386:	ff 92       	push	r15
    2388:	6a 01       	movw	r12, r20
    238a:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    238c:	60 91 48 31 	lds	r22, 0x3148	; 0x803148 <pxCurrentTCB>
    2390:	70 91 49 31 	lds	r23, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    2394:	62 5f       	subi	r22, 0xF2	; 242
    2396:	7f 4f       	sbci	r23, 0xFF	; 255
    2398:	0e 94 2f 09 	call	0x125e	; 0x125e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    239c:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    23a0:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    23a4:	02 96       	adiw	r24, 0x02	; 2
    23a6:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    23aa:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    23ae:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    23b2:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    23b6:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    23ba:	bc 01       	movw	r22, r24
    23bc:	cd 01       	movw	r24, r26
    23be:	6c 0d       	add	r22, r12
    23c0:	7d 1d       	adc	r23, r13
    23c2:	8e 1d       	adc	r24, r14
    23c4:	9f 1d       	adc	r25, r15
    23c6:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    23ca:	ff 90       	pop	r15
    23cc:	ef 90       	pop	r14
    23ce:	df 90       	pop	r13
    23d0:	cf 90       	pop	r12
    23d2:	08 95       	ret

000023d4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    23d4:	0f 93       	push	r16
    23d6:	1f 93       	push	r17
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23dc:	dc 01       	movw	r26, r24
    23de:	17 96       	adiw	r26, 0x07	; 7
    23e0:	ed 91       	ld	r30, X+
    23e2:	fc 91       	ld	r31, X
    23e4:	18 97       	sbiw	r26, 0x08	; 8
    23e6:	c0 85       	ldd	r28, Z+8	; 0x08
    23e8:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    23ea:	8e 01       	movw	r16, r28
    23ec:	02 5f       	subi	r16, 0xF2	; 242
    23ee:	1f 4f       	sbci	r17, 0xFF	; 255
    23f0:	c8 01       	movw	r24, r16
    23f2:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23f6:	80 91 ec 30 	lds	r24, 0x30EC	; 0x8030ec <uxSchedulerSuspended>
    23fa:	81 11       	cpse	r24, r1
    23fc:	16 c0       	rjmp	.+44     	; 0x242a <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    23fe:	0c 50       	subi	r16, 0x0C	; 12
    2400:	11 09       	sbc	r17, r1
    2402:	c8 01       	movw	r24, r16
    2404:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2408:	8a 8d       	ldd	r24, Y+26	; 0x1a
    240a:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    240e:	98 17       	cp	r25, r24
    2410:	10 f4       	brcc	.+4      	; 0x2416 <xTaskRemoveFromEventList+0x42>
    2412:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2416:	bb e0       	ldi	r27, 0x0B	; 11
    2418:	8b 9f       	mul	r24, r27
    241a:	c0 01       	movw	r24, r0
    241c:	11 24       	eor	r1, r1
    241e:	b8 01       	movw	r22, r16
    2420:	84 5e       	subi	r24, 0xE4	; 228
    2422:	9e 4c       	sbci	r25, 0xCE	; 206
    2424:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
    2428:	05 c0       	rjmp	.+10     	; 0x2434 <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    242a:	b8 01       	movw	r22, r16
    242c:	87 ef       	ldi	r24, 0xF7	; 247
    242e:	90 e3       	ldi	r25, 0x30	; 48
    2430:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2434:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    2438:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    243c:	81 e0       	ldi	r24, 0x01	; 1
    243e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2440:	92 8d       	ldd	r25, Z+26	; 0x1a
    2442:	29 17       	cp	r18, r25
    2444:	08 f4       	brcc	.+2      	; 0x2448 <xTaskRemoveFromEventList+0x74>
    2446:	80 e0       	ldi	r24, 0x00	; 0
}
    2448:	df 91       	pop	r29
    244a:	cf 91       	pop	r28
    244c:	1f 91       	pop	r17
    244e:	0f 91       	pop	r16
    2450:	08 95       	ret

00002452 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2452:	20 91 e9 30 	lds	r18, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    2456:	fc 01       	movw	r30, r24
    2458:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    245a:	40 91 f0 30 	lds	r20, 0x30F0	; 0x8030f0 <xTickCount>
    245e:	50 91 f1 30 	lds	r21, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    2462:	60 91 f2 30 	lds	r22, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    2466:	70 91 f3 30 	lds	r23, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    246a:	41 83       	std	Z+1, r20	; 0x01
    246c:	52 83       	std	Z+2, r21	; 0x02
    246e:	63 83       	std	Z+3, r22	; 0x03
    2470:	74 83       	std	Z+4, r23	; 0x04
    2472:	08 95       	ret

00002474 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2474:	8f 92       	push	r8
    2476:	9f 92       	push	r9
    2478:	af 92       	push	r10
    247a:	bf 92       	push	r11
    247c:	cf 92       	push	r12
    247e:	df 92       	push	r13
    2480:	ef 92       	push	r14
    2482:	ff 92       	push	r15
    2484:	0f 93       	push	r16
    2486:	1f 93       	push	r17
    2488:	cf 93       	push	r28
    248a:	df 93       	push	r29
    248c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    248e:	0f b6       	in	r0, 0x3f	; 63
    2490:	f8 94       	cli
    2492:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    2494:	80 91 e9 30 	lds	r24, 0x30E9	; 0x8030e9 <xNumOfOverflows>
    2498:	90 81       	ld	r25, Z
    249a:	98 17       	cp	r25, r24
    249c:	89 f0       	breq	.+34     	; 0x24c0 <xTaskCheckForTimeOut+0x4c>
    249e:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    24a2:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    24a6:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    24aa:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    24ae:	01 81       	ldd	r16, Z+1	; 0x01
    24b0:	12 81       	ldd	r17, Z+2	; 0x02
    24b2:	23 81       	ldd	r18, Z+3	; 0x03
    24b4:	34 81       	ldd	r19, Z+4	; 0x04
    24b6:	80 17       	cp	r24, r16
    24b8:	91 07       	cpc	r25, r17
    24ba:	a2 07       	cpc	r26, r18
    24bc:	b3 07       	cpc	r27, r19
    24be:	a8 f5       	brcc	.+106    	; 0x252a <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    24c0:	80 91 f0 30 	lds	r24, 0x30F0	; 0x8030f0 <xTickCount>
    24c4:	90 91 f1 30 	lds	r25, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    24c8:	a0 91 f2 30 	lds	r26, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    24cc:	b0 91 f3 30 	lds	r27, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    24d0:	c1 80       	ldd	r12, Z+1	; 0x01
    24d2:	d2 80       	ldd	r13, Z+2	; 0x02
    24d4:	e3 80       	ldd	r14, Z+3	; 0x03
    24d6:	f4 80       	ldd	r15, Z+4	; 0x04
    24d8:	eb 01       	movw	r28, r22
    24da:	08 81       	ld	r16, Y
    24dc:	19 81       	ldd	r17, Y+1	; 0x01
    24de:	2a 81       	ldd	r18, Y+2	; 0x02
    24e0:	3b 81       	ldd	r19, Y+3	; 0x03
    24e2:	8c 19       	sub	r24, r12
    24e4:	9d 09       	sbc	r25, r13
    24e6:	ae 09       	sbc	r26, r14
    24e8:	bf 09       	sbc	r27, r15
    24ea:	80 17       	cp	r24, r16
    24ec:	91 07       	cpc	r25, r17
    24ee:	a2 07       	cpc	r26, r18
    24f0:	b3 07       	cpc	r27, r19
    24f2:	e8 f4       	brcc	.+58     	; 0x252e <xTaskCheckForTimeOut+0xba>
    24f4:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    24f6:	80 90 f0 30 	lds	r8, 0x30F0	; 0x8030f0 <xTickCount>
    24fa:	90 90 f1 30 	lds	r9, 0x30F1	; 0x8030f1 <xTickCount+0x1>
    24fe:	a0 90 f2 30 	lds	r10, 0x30F2	; 0x8030f2 <xTickCount+0x2>
    2502:	b0 90 f3 30 	lds	r11, 0x30F3	; 0x8030f3 <xTickCount+0x3>
    2506:	b5 01       	movw	r22, r10
    2508:	a4 01       	movw	r20, r8
    250a:	4c 19       	sub	r20, r12
    250c:	5d 09       	sbc	r21, r13
    250e:	6e 09       	sbc	r22, r14
    2510:	7f 09       	sbc	r23, r15
    2512:	04 1b       	sub	r16, r20
    2514:	15 0b       	sbc	r17, r21
    2516:	26 0b       	sbc	r18, r22
    2518:	37 0b       	sbc	r19, r23
    251a:	08 83       	st	Y, r16
    251c:	19 83       	std	Y+1, r17	; 0x01
    251e:	2a 83       	std	Y+2, r18	; 0x02
    2520:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    2522:	0e 94 29 12 	call	0x2452	; 0x2452 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2526:	80 e0       	ldi	r24, 0x00	; 0
    2528:	03 c0       	rjmp	.+6      	; 0x2530 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    252a:	81 e0       	ldi	r24, 0x01	; 1
    252c:	01 c0       	rjmp	.+2      	; 0x2530 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    252e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2530:	0f 90       	pop	r0
    2532:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	1f 91       	pop	r17
    253a:	0f 91       	pop	r16
    253c:	ff 90       	pop	r15
    253e:	ef 90       	pop	r14
    2540:	df 90       	pop	r13
    2542:	cf 90       	pop	r12
    2544:	bf 90       	pop	r11
    2546:	af 90       	pop	r10
    2548:	9f 90       	pop	r9
    254a:	8f 90       	pop	r8
    254c:	08 95       	ret

0000254e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	80 93 ea 30 	sts	0x30EA, r24	; 0x8030ea <xMissedYield>
    2554:	08 95       	ret

00002556 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    2556:	00 97       	sbiw	r24, 0x00	; 0
    2558:	21 f4       	brne	.+8      	; 0x2562 <uxTaskGetStackHighWaterMark+0xc>
    255a:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    255e:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2562:	dc 01       	movw	r26, r24
    2564:	5b 96       	adiw	r26, 0x1b	; 27
    2566:	ed 91       	ld	r30, X+
    2568:	fc 91       	ld	r31, X
    256a:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    256c:	80 81       	ld	r24, Z
    256e:	81 31       	cpi	r24, 0x11	; 17
    2570:	41 f4       	brne	.+16     	; 0x2582 <uxTaskGetStackHighWaterMark+0x2c>
    2572:	31 96       	adiw	r30, 0x01	; 1
    2574:	80 e0       	ldi	r24, 0x00	; 0
    2576:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2578:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    257a:	21 91       	ld	r18, Z+
    257c:	21 31       	cpi	r18, 0x11	; 17
    257e:	e1 f3       	breq	.-8      	; 0x2578 <uxTaskGetStackHighWaterMark+0x22>
    2580:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2582:	80 e0       	ldi	r24, 0x00	; 0
    2584:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2586:	08 95       	ret

00002588 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2588:	80 91 48 31 	lds	r24, 0x3148	; 0x803148 <pxCurrentTCB>
    258c:	90 91 49 31 	lds	r25, 0x3149	; 0x803149 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2590:	08 95       	ret

00002592 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2592:	0f 93       	push	r16
    2594:	1f 93       	push	r17
    2596:	cf 93       	push	r28
    2598:	df 93       	push	r29
    259a:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    259c:	22 8d       	ldd	r18, Z+26	; 0x1a
    259e:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    25a2:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    25a6:	5a 96       	adiw	r26, 0x1a	; 26
    25a8:	8c 91       	ld	r24, X
    25aa:	28 17       	cp	r18, r24
    25ac:	08 f0       	brcs	.+2      	; 0x25b0 <vTaskPriorityInherit+0x1e>
    25ae:	41 c0       	rjmp	.+130    	; 0x2632 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    25b0:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    25b4:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    25b8:	5a 96       	adiw	r26, 0x1a	; 26
    25ba:	3c 91       	ld	r19, X
    25bc:	84 e0       	ldi	r24, 0x04	; 4
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	a0 e0       	ldi	r26, 0x00	; 0
    25c2:	b0 e0       	ldi	r27, 0x00	; 0
    25c4:	83 1b       	sub	r24, r19
    25c6:	91 09       	sbc	r25, r1
    25c8:	a1 09       	sbc	r26, r1
    25ca:	b1 09       	sbc	r27, r1
    25cc:	86 87       	std	Z+14, r24	; 0x0e
    25ce:	97 87       	std	Z+15, r25	; 0x0f
    25d0:	a0 8b       	std	Z+16, r26	; 0x10
    25d2:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    25d4:	8b e0       	ldi	r24, 0x0B	; 11
    25d6:	28 9f       	mul	r18, r24
    25d8:	90 01       	movw	r18, r0
    25da:	11 24       	eor	r1, r1
    25dc:	24 5e       	subi	r18, 0xE4	; 228
    25de:	3e 4c       	sbci	r19, 0xCE	; 206
    25e0:	84 85       	ldd	r24, Z+12	; 0x0c
    25e2:	95 85       	ldd	r25, Z+13	; 0x0d
    25e4:	82 17       	cp	r24, r18
    25e6:	93 07       	cpc	r25, r19
    25e8:	e9 f4       	brne	.+58     	; 0x2624 <vTaskPriorityInherit+0x92>
    25ea:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    25ec:	ef 01       	movw	r28, r30
    25ee:	22 96       	adiw	r28, 0x02	; 2
    25f0:	ce 01       	movw	r24, r28
    25f2:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    25f6:	e0 91 48 31 	lds	r30, 0x3148	; 0x803148 <pxCurrentTCB>
    25fa:	f0 91 49 31 	lds	r31, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    25fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2600:	f8 01       	movw	r30, r16
    2602:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    2604:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2608:	98 17       	cp	r25, r24
    260a:	10 f4       	brcc	.+4      	; 0x2610 <vTaskPriorityInherit+0x7e>
    260c:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2610:	fb e0       	ldi	r31, 0x0B	; 11
    2612:	8f 9f       	mul	r24, r31
    2614:	c0 01       	movw	r24, r0
    2616:	11 24       	eor	r1, r1
    2618:	be 01       	movw	r22, r28
    261a:	84 5e       	subi	r24, 0xE4	; 228
    261c:	9e 4c       	sbci	r25, 0xCE	; 206
    261e:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
    2622:	07 c0       	rjmp	.+14     	; 0x2632 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2624:	a0 91 48 31 	lds	r26, 0x3148	; 0x803148 <pxCurrentTCB>
    2628:	b0 91 49 31 	lds	r27, 0x3149	; 0x803149 <pxCurrentTCB+0x1>
    262c:	5a 96       	adiw	r26, 0x1a	; 26
    262e:	8c 91       	ld	r24, X
    2630:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    2632:	df 91       	pop	r29
    2634:	cf 91       	pop	r28
    2636:	1f 91       	pop	r17
    2638:	0f 91       	pop	r16
    263a:	08 95       	ret

0000263c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    263c:	0f 93       	push	r16
    263e:	1f 93       	push	r17
    2640:	cf 93       	push	r28
    2642:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	49 f1       	breq	.+82     	; 0x269a <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    2648:	fc 01       	movw	r30, r24
    264a:	32 8d       	ldd	r19, Z+26	; 0x1a
    264c:	27 a1       	ldd	r18, Z+39	; 0x27
    264e:	32 17       	cp	r19, r18
    2650:	21 f1       	breq	.+72     	; 0x269a <vTaskPriorityDisinherit+0x5e>
    2652:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    2654:	8c 01       	movw	r16, r24
    2656:	0e 5f       	subi	r16, 0xFE	; 254
    2658:	1f 4f       	sbci	r17, 0xFF	; 255
    265a:	c8 01       	movw	r24, r16
    265c:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2660:	8f a1       	ldd	r24, Y+39	; 0x27
    2662:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    2664:	44 e0       	ldi	r20, 0x04	; 4
    2666:	50 e0       	ldi	r21, 0x00	; 0
    2668:	60 e0       	ldi	r22, 0x00	; 0
    266a:	70 e0       	ldi	r23, 0x00	; 0
    266c:	48 1b       	sub	r20, r24
    266e:	51 09       	sbc	r21, r1
    2670:	61 09       	sbc	r22, r1
    2672:	71 09       	sbc	r23, r1
    2674:	4e 87       	std	Y+14, r20	; 0x0e
    2676:	5f 87       	std	Y+15, r21	; 0x0f
    2678:	68 8b       	std	Y+16, r22	; 0x10
    267a:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    267c:	90 91 ee 30 	lds	r25, 0x30EE	; 0x8030ee <uxTopReadyPriority>
    2680:	98 17       	cp	r25, r24
    2682:	10 f4       	brcc	.+4      	; 0x2688 <vTaskPriorityDisinherit+0x4c>
    2684:	80 93 ee 30 	sts	0x30EE, r24	; 0x8030ee <uxTopReadyPriority>
    2688:	fb e0       	ldi	r31, 0x0B	; 11
    268a:	8f 9f       	mul	r24, r31
    268c:	c0 01       	movw	r24, r0
    268e:	11 24       	eor	r1, r1
    2690:	b8 01       	movw	r22, r16
    2692:	84 5e       	subi	r24, 0xE4	; 228
    2694:	9e 4c       	sbci	r25, 0xCE	; 206
    2696:	0e 94 08 09 	call	0x1210	; 0x1210 <vListInsertEnd>
			}
		}
	}
    269a:	df 91       	pop	r29
    269c:	cf 91       	pop	r28
    269e:	1f 91       	pop	r17
    26a0:	0f 91       	pop	r16
    26a2:	08 95       	ret

000026a4 <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    26a4:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    26a6:	e8 81       	ld	r30, Y
    26a8:	f9 81       	ldd	r31, Y+1	; 0x01
    26aa:	01 90       	ld	r0, Z+
    26ac:	f0 81       	ld	r31, Z
    26ae:	e0 2d       	mov	r30, r0
    26b0:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    26b2:	1a 82       	std	Y+2, r1	; 0x02
    26b4:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    26b6:	6f ef       	ldi	r22, 0xFF	; 255
    26b8:	7f ef       	ldi	r23, 0xFF	; 255
    26ba:	cb 01       	movw	r24, r22
    26bc:	0e 94 35 11 	call	0x226a	; 0x226a <vTaskDelay>
    26c0:	fa cf       	rjmp	.-12     	; 0x26b6 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

000026c2 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    26c2:	fc 01       	movw	r30, r24
    26c4:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    26c6:	65 87       	std	Z+13, r22	; 0x0d
    26c8:	08 95       	ret

000026ca <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    26ca:	4f 92       	push	r4
    26cc:	5f 92       	push	r5
    26ce:	6f 92       	push	r6
    26d0:	7f 92       	push	r7
    26d2:	8f 92       	push	r8
    26d4:	9f 92       	push	r9
    26d6:	af 92       	push	r10
    26d8:	bf 92       	push	r11
    26da:	cf 92       	push	r12
    26dc:	df 92       	push	r13
    26de:	ef 92       	push	r14
    26e0:	ff 92       	push	r15
    26e2:	0f 93       	push	r16
    26e4:	1f 93       	push	r17
    26e6:	cf 93       	push	r28
    26e8:	df 93       	push	r29
    26ea:	cd b7       	in	r28, 0x3d	; 61
    26ec:	de b7       	in	r29, 0x3e	; 62
    26ee:	2a 97       	sbiw	r28, 0x0a	; 10
    26f0:	cd bf       	out	0x3d, r28	; 61
    26f2:	de bf       	out	0x3e, r29	; 62
    26f4:	4c 01       	movw	r8, r24
    26f6:	29 01       	movw	r4, r18
    26f8:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    26fa:	87 e3       	ldi	r24, 0x37	; 55
    26fc:	90 e2       	ldi	r25, 0x20	; 32
    26fe:	f4 01       	movw	r30, r8
    2700:	80 83       	st	Z, r24
    2702:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    2704:	fb 01       	movw	r30, r22
    2706:	80 81       	ld	r24, Z
    2708:	88 23       	and	r24, r24
    270a:	69 f0       	breq	.+26     	; 0x2726 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    270c:	de 01       	movw	r26, r28
    270e:	11 96       	adiw	r26, 0x01	; 1
    2710:	31 96       	adiw	r30, 0x01	; 1
    2712:	90 e0       	ldi	r25, 0x00	; 0
    2714:	02 c0       	rjmp	.+4      	; 0x271a <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    2716:	99 30       	cpi	r25, 0x09	; 9
    2718:	39 f0       	breq	.+14     	; 0x2728 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    271a:	9f 5f       	subi	r25, 0xFF	; 255
    271c:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    271e:	81 91       	ld	r24, Z+
    2720:	81 11       	cpse	r24, r1
    2722:	f9 cf       	rjmp	.-14     	; 0x2716 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    2724:	01 c0       	rjmp	.+2      	; 0x2728 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    2726:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    2728:	e1 e0       	ldi	r30, 0x01	; 1
    272a:	f0 e0       	ldi	r31, 0x00	; 0
    272c:	ec 0f       	add	r30, r28
    272e:	fd 1f       	adc	r31, r29
    2730:	e9 0f       	add	r30, r25
    2732:	f1 1d       	adc	r31, r1
    2734:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    2736:	74 01       	movw	r14, r8
    2738:	f2 e0       	ldi	r31, 0x02	; 2
    273a:	ef 0e       	add	r14, r31
    273c:	f1 1c       	adc	r15, r1
    273e:	a1 2c       	mov	r10, r1
    2740:	b1 2c       	mov	r11, r1
    2742:	c1 2c       	mov	r12, r1
    2744:	d1 2c       	mov	r13, r1
    2746:	04 2f       	mov	r16, r20
    2748:	94 01       	movw	r18, r8
    274a:	a2 01       	movw	r20, r4
    274c:	be 01       	movw	r22, r28
    274e:	6f 5f       	subi	r22, 0xFF	; 255
    2750:	7f 4f       	sbci	r23, 0xFF	; 255
    2752:	8a ee       	ldi	r24, 0xEA	; 234
    2754:	92 e0       	ldi	r25, 0x02	; 2
    2756:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    275a:	f4 01       	movw	r30, r8
    275c:	66 82       	std	Z+6, r6	; 0x06
    275e:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2760:	40 86       	std	Z+8, r4	; 0x08
    2762:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    2764:	20 91 4a 31 	lds	r18, 0x314A	; 0x80314a <last_created_task_pointer>
    2768:	30 91 4b 31 	lds	r19, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    276c:	24 83       	std	Z+4, r18	; 0x04
    276e:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2770:	80 92 4a 31 	sts	0x314A, r8	; 0x80314a <last_created_task_pointer>
    2774:	90 92 4b 31 	sts	0x314B, r9	; 0x80314b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2778:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    277a:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    277c:	40 90 ac 31 	lds	r4, 0x31AC	; 0x8031ac <portStackTopForTask>
    2780:	50 90 ad 31 	lds	r5, 0x31AD	; 0x8031ad <portStackTopForTask+0x1>
    2784:	ff ef       	ldi	r31, 0xFF	; 255
    2786:	4f 1a       	sub	r4, r31
    2788:	5f 0a       	sbc	r5, r31
    278a:	40 92 ac 31 	sts	0x31AC, r4	; 0x8031ac <portStackTopForTask>
    278e:	50 92 ad 31 	sts	0x31AD, r5	; 0x8031ad <portStackTopForTask+0x1>
    2792:	f4 01       	movw	r30, r8
    2794:	42 86       	std	Z+10, r4	; 0x0a
    2796:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2798:	16 86       	std	Z+14, r1	; 0x0e
    279a:	17 86       	std	Z+15, r1	; 0x0f
    279c:	10 8a       	std	Z+16, r1	; 0x10
    279e:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    27a0:	61 14       	cp	r6, r1
    27a2:	71 04       	cpc	r7, r1
    27a4:	09 f4       	brne	.+2      	; 0x27a8 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    27a6:	44 c0       	rjmp	.+136    	; 0x2830 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    27a8:	81 30       	cpi	r24, 0x01	; 1
    27aa:	79 f5       	brne	.+94     	; 0x280a <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    27ac:	6a e0       	ldi	r22, 0x0A	; 10
    27ae:	c3 01       	movw	r24, r6
    27b0:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    27b4:	7c 01       	movw	r14, r24
    27b6:	61 e2       	ldi	r22, 0x21	; 33
    27b8:	75 e0       	ldi	r23, 0x05	; 5
    27ba:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    27be:	be 01       	movw	r22, r28
    27c0:	6f 5f       	subi	r22, 0xFF	; 255
    27c2:	7f 4f       	sbci	r23, 0xFF	; 255
    27c4:	c7 01       	movw	r24, r14
    27c6:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    27ca:	6a e0       	ldi	r22, 0x0A	; 10
    27cc:	c7 01       	movw	r24, r14
    27ce:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    27d2:	7c 01       	movw	r14, r24
    27d4:	68 e1       	ldi	r22, 0x18	; 24
    27d6:	75 e0       	ldi	r23, 0x05	; 5
    27d8:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    27dc:	6a e0       	ldi	r22, 0x0A	; 10
    27de:	c7 01       	movw	r24, r14
    27e0:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    27e4:	7c 01       	movw	r14, r24
    27e6:	6a e0       	ldi	r22, 0x0A	; 10
    27e8:	75 e0       	ldi	r23, 0x05	; 5
    27ea:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    27ee:	63 e0       	ldi	r22, 0x03	; 3
    27f0:	c7 01       	movw	r24, r14
    27f2:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    27f6:	b2 01       	movw	r22, r4
    27f8:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
    27fc:	62 e0       	ldi	r22, 0x02	; 2
    27fe:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2802:	66 e0       	ldi	r22, 0x06	; 6
    2804:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2808:	13 c0       	rjmp	.+38     	; 0x2830 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    280a:	6a e0       	ldi	r22, 0x0A	; 10
    280c:	c3 01       	movw	r24, r6
    280e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2812:	4c 01       	movw	r8, r24
    2814:	65 ef       	ldi	r22, 0xF5	; 245
    2816:	74 e0       	ldi	r23, 0x04	; 4
    2818:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    281c:	be 01       	movw	r22, r28
    281e:	6f 5f       	subi	r22, 0xFF	; 255
    2820:	7f 4f       	sbci	r23, 0xFF	; 255
    2822:	c4 01       	movw	r24, r8
    2824:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2828:	66 e0       	ldi	r22, 0x06	; 6
    282a:	c4 01       	movw	r24, r8
    282c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    2830:	2a 96       	adiw	r28, 0x0a	; 10
    2832:	cd bf       	out	0x3d, r28	; 61
    2834:	de bf       	out	0x3e, r29	; 62
    2836:	df 91       	pop	r29
    2838:	cf 91       	pop	r28
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	ff 90       	pop	r15
    2840:	ef 90       	pop	r14
    2842:	df 90       	pop	r13
    2844:	cf 90       	pop	r12
    2846:	bf 90       	pop	r11
    2848:	af 90       	pop	r10
    284a:	9f 90       	pop	r9
    284c:	8f 90       	pop	r8
    284e:	7f 90       	pop	r7
    2850:	6f 90       	pop	r6
    2852:	5f 90       	pop	r5
    2854:	4f 90       	pop	r4
    2856:	08 95       	ret

00002858 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    2858:	cf 92       	push	r12
    285a:	df 92       	push	r13
    285c:	ef 92       	push	r14
    285e:	ff 92       	push	r15
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	cf 93       	push	r28
    2866:	df 93       	push	r29
    2868:	ec 01       	movw	r28, r24
    286a:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    286c:	8a 81       	ldd	r24, Y+2	; 0x02
    286e:	9b 81       	ldd	r25, Y+3	; 0x03
    2870:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <pcTaskGetTaskName>
    2874:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2876:	6a e0       	ldi	r22, 0x0A	; 10
    2878:	c7 01       	movw	r24, r14
    287a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    287e:	8c 01       	movw	r16, r24
    2880:	64 e3       	ldi	r22, 0x34	; 52
    2882:	75 e0       	ldi	r23, 0x05	; 5
    2884:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2888:	6a e0       	ldi	r22, 0x0A	; 10
    288a:	c8 01       	movw	r24, r16
    288c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2890:	8c 01       	movw	r16, r24
    2892:	6d e2       	ldi	r22, 0x2D	; 45
    2894:	75 e0       	ldi	r23, 0x05	; 5
    2896:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    289a:	b6 01       	movw	r22, r12
    289c:	c8 01       	movw	r24, r16
    289e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    28a2:	6a e0       	ldi	r22, 0x0A	; 10
    28a4:	c8 01       	movw	r24, r16
    28a6:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    28aa:	8c 01       	movw	r16, r24
    28ac:	67 e2       	ldi	r22, 0x27	; 39
    28ae:	75 e0       	ldi	r23, 0x05	; 5
    28b0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    28b4:	66 e0       	ldi	r22, 0x06	; 6
    28b6:	c8 01       	movw	r24, r16
    28b8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    28bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    28be:	9b 85       	ldd	r25, Y+11	; 0x0b
    28c0:	e8 85       	ldd	r30, Y+8	; 0x08
    28c2:	f9 85       	ldd	r31, Y+9	; 0x09
    28c4:	01 e1       	ldi	r16, 0x11	; 17
    28c6:	21 e0       	ldi	r18, 0x01	; 1
    28c8:	a7 01       	movw	r20, r14
    28ca:	bc 01       	movw	r22, r24
    28cc:	8e 1b       	sub	r24, r30
    28ce:	9f 0b       	sbc	r25, r31
    28d0:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    28d4:	8c 81       	ldd	r24, Y+4	; 0x04
    28d6:	9d 81       	ldd	r25, Y+5	; 0x05
    28d8:	00 97       	sbiw	r24, 0x00	; 0
    28da:	19 f0       	breq	.+6      	; 0x28e2 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    28dc:	b7 01       	movw	r22, r14
    28de:	0e 94 2c 14 	call	0x2858	; 0x2858 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    28e2:	df 91       	pop	r29
    28e4:	cf 91       	pop	r28
    28e6:	1f 91       	pop	r17
    28e8:	0f 91       	pop	r16
    28ea:	ff 90       	pop	r15
    28ec:	ef 90       	pop	r14
    28ee:	df 90       	pop	r13
    28f0:	cf 90       	pop	r12
    28f2:	08 95       	ret

000028f4 <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    28f4:	0f 93       	push	r16
    28f6:	1f 93       	push	r17
    28f8:	cf 93       	push	r28
    28fa:	df 93       	push	r29
    28fc:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    28fe:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <last_created_task_pointer>
    2902:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    2906:	00 97       	sbiw	r24, 0x00	; 0
    2908:	19 f0       	breq	.+6      	; 0x2910 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    290a:	be 01       	movw	r22, r28
    290c:	0e 94 2c 14 	call	0x2858	; 0x2858 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    2910:	6a e0       	ldi	r22, 0x0A	; 10
    2912:	ce 01       	movw	r24, r28
    2914:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2918:	8c 01       	movw	r16, r24
    291a:	6a e4       	ldi	r22, 0x4A	; 74
    291c:	75 e0       	ldi	r23, 0x05	; 5
    291e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2922:	6a e0       	ldi	r22, 0x0A	; 10
    2924:	c8 01       	movw	r24, r16
    2926:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    292a:	8c 01       	movw	r16, r24
    292c:	6f e3       	ldi	r22, 0x3F	; 63
    292e:	75 e0       	ldi	r23, 0x05	; 5
    2930:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2934:	6a e0       	ldi	r22, 0x0A	; 10
    2936:	c8 01       	movw	r24, r16
    2938:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    293c:	8c 01       	movw	r16, r24
    293e:	69 e3       	ldi	r22, 0x39	; 57
    2940:	75 e0       	ldi	r23, 0x05	; 5
    2942:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2946:	66 e0       	ldi	r22, 0x06	; 6
    2948:	c8 01       	movw	r24, r16
    294a:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    294e:	80 91 ac 31 	lds	r24, 0x31AC	; 0x8031ac <portStackTopForTask>
    2952:	90 91 ad 31 	lds	r25, 0x31AD	; 0x8031ad <portStackTopForTask+0x1>
    2956:	bc 01       	movw	r22, r24
    2958:	6f 5f       	subi	r22, 0xFF	; 255
    295a:	7f 4f       	sbci	r23, 0xFF	; 255
    295c:	01 e1       	ldi	r16, 0x11	; 17
    295e:	21 e0       	ldi	r18, 0x01	; 1
    2960:	ae 01       	movw	r20, r28
    2962:	83 56       	subi	r24, 0x63	; 99
    2964:	91 09       	sbc	r25, r1
    2966:	0e 94 2e 17 	call	0x2e5c	; 0x2e5c <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    296a:	df 91       	pop	r29
    296c:	cf 91       	pop	r28
    296e:	1f 91       	pop	r17
    2970:	0f 91       	pop	r16
    2972:	08 95       	ret

00002974 <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    2974:	8f 92       	push	r8
    2976:	9f 92       	push	r9
    2978:	af 92       	push	r10
    297a:	bf 92       	push	r11
    297c:	cf 92       	push	r12
    297e:	df 92       	push	r13
    2980:	ef 92       	push	r14
    2982:	ff 92       	push	r15
    2984:	0f 93       	push	r16
    2986:	1f 93       	push	r17
    2988:	cf 93       	push	r28
    298a:	df 93       	push	r29
    298c:	ec 01       	movw	r28, r24
    298e:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2990:	8a 81       	ldd	r24, Y+2	; 0x02
    2992:	9b 81       	ldd	r25, Y+3	; 0x03
    2994:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <pcTaskGetTaskName>
    2998:	bc 01       	movw	r22, r24
    299a:	c8 01       	movw	r24, r16
    299c:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    29a0:	d8 01       	movw	r26, r16
    29a2:	ed 91       	ld	r30, X+
    29a4:	fc 91       	ld	r31, X
    29a6:	02 80       	ldd	r0, Z+2	; 0x02
    29a8:	f3 81       	ldd	r31, Z+3	; 0x03
    29aa:	e0 2d       	mov	r30, r0
    29ac:	69 e0       	ldi	r22, 0x09	; 9
    29ae:	c8 01       	movw	r24, r16
    29b0:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    29b2:	8a 81       	ldd	r24, Y+2	; 0x02
    29b4:	9b 81       	ldd	r25, Y+3	; 0x03
    29b6:	0e 94 a5 0f 	call	0x1f4a	; 0x1f4a <pcTaskGetTaskName>
    29ba:	fc 01       	movw	r30, r24
    29bc:	01 90       	ld	r0, Z+
    29be:	00 20       	and	r0, r0
    29c0:	e9 f7       	brne	.-6      	; 0x29bc <_ZN8frt_task12print_statusER8emstream+0x48>
    29c2:	31 97       	sbiw	r30, 0x01	; 1
    29c4:	e8 1b       	sub	r30, r24
    29c6:	f9 0b       	sbc	r31, r25
    29c8:	38 97       	sbiw	r30, 0x08	; 8
    29ca:	48 f4       	brcc	.+18     	; 0x29de <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    29cc:	d8 01       	movw	r26, r16
    29ce:	ed 91       	ld	r30, X+
    29d0:	fc 91       	ld	r31, X
    29d2:	02 80       	ldd	r0, Z+2	; 0x02
    29d4:	f3 81       	ldd	r31, Z+3	; 0x03
    29d6:	e0 2d       	mov	r30, r0
    29d8:	69 e0       	ldi	r22, 0x09	; 9
    29da:	c8 01       	movw	r24, r16
    29dc:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    29de:	ce 84       	ldd	r12, Y+14	; 0x0e
    29e0:	df 84       	ldd	r13, Y+15	; 0x0f
    29e2:	e8 88       	ldd	r14, Y+16	; 0x10
    29e4:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    29e6:	a8 84       	ldd	r10, Y+8	; 0x08
    29e8:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    29ea:	8a 81       	ldd	r24, Y+2	; 0x02
    29ec:	9b 81       	ldd	r25, Y+3	; 0x03
    29ee:	0e 94 ab 12 	call	0x2556	; 0x2556 <uxTaskGetStackHighWaterMark>
    29f2:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    29f4:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    29f6:	8a 81       	ldd	r24, Y+2	; 0x02
    29f8:	9b 81       	ldd	r25, Y+3	; 0x03
    29fa:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <uxTaskPriorityGet>
    29fe:	68 2f       	mov	r22, r24
    2a00:	c8 01       	movw	r24, r16
    2a02:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    2a06:	6a e0       	ldi	r22, 0x0A	; 10
    2a08:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2a0c:	ec 01       	movw	r28, r24
    2a0e:	6f eb       	ldi	r22, 0xBF	; 191
    2a10:	75 e0       	ldi	r23, 0x05	; 5
    2a12:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
			<< get_state ()
    2a16:	68 2d       	mov	r22, r8
    2a18:	ce 01       	movw	r24, r28
    2a1a:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2a1e:	6a e0       	ldi	r22, 0x0A	; 10
    2a20:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2a24:	ec 01       	movw	r28, r24
    2a26:	6d eb       	ldi	r22, 0xBD	; 189
    2a28:	75 e0       	ldi	r23, 0x05	; 5
    2a2a:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2a2e:	69 2d       	mov	r22, r9
    2a30:	ce 01       	movw	r24, r28
    2a32:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    2a36:	6a e0       	ldi	r22, 0x0A	; 10
    2a38:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2a3c:	ec 01       	movw	r28, r24
    2a3e:	6b eb       	ldi	r22, 0xBB	; 187
    2a40:	75 e0       	ldi	r23, 0x05	; 5
    2a42:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    2a46:	b5 01       	movw	r22, r10
    2a48:	ce 01       	movw	r24, r28
    2a4a:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
    2a4e:	6a e0       	ldi	r22, 0x0A	; 10
    2a50:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2a54:	ec 01       	movw	r28, r24
    2a56:	69 eb       	ldi	r22, 0xB9	; 185
    2a58:	75 e0       	ldi	r23, 0x05	; 5
    2a5a:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2a5e:	6a e0       	ldi	r22, 0x0A	; 10
    2a60:	ce 01       	movw	r24, r28
    2a62:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2a66:	ec 01       	movw	r28, r24
    2a68:	67 eb       	ldi	r22, 0xB7	; 183
    2a6a:	75 e0       	ldi	r23, 0x05	; 5
    2a6c:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2a70:	b7 01       	movw	r22, r14
    2a72:	a6 01       	movw	r20, r12
    2a74:	ce 01       	movw	r24, r28
    2a76:	0e 94 45 19 	call	0x328a	; 0x328a <_ZN8emstreamlsEm>
}
    2a7a:	df 91       	pop	r29
    2a7c:	cf 91       	pop	r28
    2a7e:	1f 91       	pop	r17
    2a80:	0f 91       	pop	r16
    2a82:	ff 90       	pop	r15
    2a84:	ef 90       	pop	r14
    2a86:	df 90       	pop	r13
    2a88:	cf 90       	pop	r12
    2a8a:	bf 90       	pop	r11
    2a8c:	af 90       	pop	r10
    2a8e:	9f 90       	pop	r9
    2a90:	8f 90       	pop	r8
    2a92:	08 95       	ret

00002a94 <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	ec 01       	movw	r28, r24
    2a9a:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2a9c:	db 01       	movw	r26, r22
    2a9e:	ed 91       	ld	r30, X+
    2aa0:	fc 91       	ld	r31, X
    2aa2:	02 80       	ldd	r0, Z+2	; 0x02
    2aa4:	f3 81       	ldd	r31, Z+3	; 0x03
    2aa6:	e0 2d       	mov	r30, r0
    2aa8:	be 01       	movw	r22, r28
    2aaa:	19 95       	eicall
	return (ser_dev);
}
    2aac:	ce 01       	movw	r24, r28
    2aae:	df 91       	pop	r29
    2ab0:	cf 91       	pop	r28
    2ab2:	08 95       	ret

00002ab4 <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    2ab4:	0f 93       	push	r16
    2ab6:	1f 93       	push	r17
    2ab8:	cf 93       	push	r28
    2aba:	df 93       	push	r29
    2abc:	ec 01       	movw	r28, r24
    2abe:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2ac0:	bc 01       	movw	r22, r24
    2ac2:	c8 01       	movw	r24, r16
    2ac4:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <_ZlsR8emstreamR8frt_task>
    2ac8:	66 e0       	ldi	r22, 0x06	; 6
    2aca:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2ace:	8c 81       	ldd	r24, Y+4	; 0x04
    2ad0:	9d 81       	ldd	r25, Y+5	; 0x05
    2ad2:	00 97       	sbiw	r24, 0x00	; 0
    2ad4:	19 f0       	breq	.+6      	; 0x2adc <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2ad6:	b8 01       	movw	r22, r16
    2ad8:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2adc:	df 91       	pop	r29
    2ade:	cf 91       	pop	r28
    2ae0:	1f 91       	pop	r17
    2ae2:	0f 91       	pop	r16
    2ae4:	08 95       	ret

00002ae6 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2ae6:	0f 93       	push	r16
    2ae8:	1f 93       	push	r17
    2aea:	cf 93       	push	r28
    2aec:	df 93       	push	r29
    2aee:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    2af0:	6a e0       	ldi	r22, 0x0A	; 10
    2af2:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2af6:	8c 01       	movw	r16, r24
    2af8:	6c ea       	ldi	r22, 0xAC	; 172
    2afa:	75 e0       	ldi	r23, 0x05	; 5
    2afc:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    2b00:	6a e0       	ldi	r22, 0x0A	; 10
    2b02:	c8 01       	movw	r24, r16
    2b04:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b08:	8c 01       	movw	r16, r24
    2b0a:	65 ea       	ldi	r22, 0xA5	; 165
    2b0c:	75 e0       	ldi	r23, 0x05	; 5
    2b0e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    2b12:	66 e0       	ldi	r22, 0x06	; 6
    2b14:	c8 01       	movw	r24, r16
    2b16:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    2b1a:	6a e0       	ldi	r22, 0x0A	; 10
    2b1c:	ce 01       	movw	r24, r28
    2b1e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b22:	8c 01       	movw	r16, r24
    2b24:	64 e9       	ldi	r22, 0x94	; 148
    2b26:	75 e0       	ldi	r23, 0x05	; 5
    2b28:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    2b2c:	6a e0       	ldi	r22, 0x0A	; 10
    2b2e:	c8 01       	movw	r24, r16
    2b30:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b34:	8c 01       	movw	r16, r24
    2b36:	68 e8       	ldi	r22, 0x88	; 136
    2b38:	75 e0       	ldi	r23, 0x05	; 5
    2b3a:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    2b3e:	6a e0       	ldi	r22, 0x0A	; 10
    2b40:	c8 01       	movw	r24, r16
    2b42:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b46:	8c 01       	movw	r16, r24
    2b48:	62 e8       	ldi	r22, 0x82	; 130
    2b4a:	75 e0       	ldi	r23, 0x05	; 5
    2b4c:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2b50:	66 e0       	ldi	r22, 0x06	; 6
    2b52:	c8 01       	movw	r24, r16
    2b54:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    2b58:	6a e0       	ldi	r22, 0x0A	; 10
    2b5a:	ce 01       	movw	r24, r28
    2b5c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b60:	8c 01       	movw	r16, r24
    2b62:	61 e7       	ldi	r22, 0x71	; 113
    2b64:	75 e0       	ldi	r23, 0x05	; 5
    2b66:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2b6a:	6a e0       	ldi	r22, 0x0A	; 10
    2b6c:	c8 01       	movw	r24, r16
    2b6e:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b72:	8c 01       	movw	r16, r24
    2b74:	65 e6       	ldi	r22, 0x65	; 101
    2b76:	75 e0       	ldi	r23, 0x05	; 5
    2b78:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2b7c:	6a e0       	ldi	r22, 0x0A	; 10
    2b7e:	c8 01       	movw	r24, r16
    2b80:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2b84:	8c 01       	movw	r16, r24
    2b86:	6f e5       	ldi	r22, 0x5F	; 95
    2b88:	75 e0       	ldi	r23, 0x05	; 5
    2b8a:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2b8e:	66 e0       	ldi	r22, 0x06	; 6
    2b90:	c8 01       	movw	r24, r16
    2b92:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2b96:	80 91 4a 31 	lds	r24, 0x314A	; 0x80314a <last_created_task_pointer>
    2b9a:	90 91 4b 31 	lds	r25, 0x314B	; 0x80314b <last_created_task_pointer+0x1>
    2b9e:	00 97       	sbiw	r24, 0x00	; 0
    2ba0:	19 f0       	breq	.+6      	; 0x2ba8 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2ba2:	be 01       	movw	r22, r28
    2ba4:	0e 94 5a 15 	call	0x2ab4	; 0x2ab4 <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2ba8:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <xTaskGetIdleTaskHandle>
    2bac:	0e 94 ab 12 	call	0x2556	; 0x2556 <uxTaskGetStackHighWaterMark>
    2bb0:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2bb2:	6a e0       	ldi	r22, 0x0A	; 10
    2bb4:	ce 01       	movw	r24, r28
    2bb6:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2bba:	ec 01       	movw	r28, r24
    2bbc:	64 e5       	ldi	r22, 0x54	; 84
    2bbe:	75 e0       	ldi	r23, 0x05	; 5
    2bc0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2bc4:	61 2f       	mov	r22, r17
    2bc6:	ce 01       	movw	r24, r28
    2bc8:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2bcc:	6a e0       	ldi	r22, 0x0A	; 10
    2bce:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2bd2:	ec 01       	movw	r28, r24
    2bd4:	62 e5       	ldi	r22, 0x52	; 82
    2bd6:	75 e0       	ldi	r23, 0x05	; 5
    2bd8:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2bdc:	64 e6       	ldi	r22, 0x64	; 100
    2bde:	70 e0       	ldi	r23, 0x00	; 0
    2be0:	ce 01       	movw	r24, r28
    2be2:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
    2be6:	6a e0       	ldi	r22, 0x0A	; 10
    2be8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2bec:	ec 01       	movw	r28, r24
    2bee:	6f e4       	ldi	r22, 0x4F	; 79
    2bf0:	75 e0       	ldi	r23, 0x05	; 5
    2bf2:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2bf6:	66 e0       	ldi	r22, 0x06	; 6
    2bf8:	ce 01       	movw	r24, r28
    2bfa:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
}
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	08 95       	ret

00002c08 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2c08:	0f 93       	push	r16
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	1f 92       	push	r1
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    2c14:	00 e0       	ldi	r16, 0x00	; 0
    2c16:	2f ef       	ldi	r18, 0xFF	; 255
    2c18:	3f ef       	ldi	r19, 0xFF	; 255
    2c1a:	a9 01       	movw	r20, r18
    2c1c:	be 01       	movw	r22, r28
    2c1e:	6f 5f       	subi	r22, 0xFF	; 255
    2c20:	7f 4f       	sbci	r23, 0xFF	; 255
    2c22:	fc 01       	movw	r30, r24
    2c24:	80 85       	ldd	r24, Z+8	; 0x08
    2c26:	91 85       	ldd	r25, Z+9	; 0x09
    2c28:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
    2c2c:	81 30       	cpi	r24, 0x01	; 1
    2c2e:	19 f4       	brne	.+6      	; 0x2c36 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    2c30:	89 81       	ldd	r24, Y+1	; 0x01
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	02 c0       	rjmp	.+4      	; 0x2c3a <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    2c36:	8f ef       	ldi	r24, 0xFF	; 255
    2c38:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    2c3a:	0f 90       	pop	r0
    2c3c:	df 91       	pop	r29
    2c3e:	cf 91       	pop	r28
    2c40:	0f 91       	pop	r16
    2c42:	08 95       	ret

00002c44 <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    2c44:	fc 01       	movw	r30, r24
    2c46:	80 85       	ldd	r24, Z+8	; 0x08
    2c48:	91 85       	ldd	r25, Z+9	; 0x09
    2c4a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
    2c4e:	91 e0       	ldi	r25, 0x01	; 1
    2c50:	81 11       	cpse	r24, r1
    2c52:	01 c0       	rjmp	.+2      	; 0x2c56 <_ZN14frt_text_queue14check_for_charEv+0x12>
    2c54:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2c56:	89 2f       	mov	r24, r25
    2c58:	08 95       	ret

00002c5a <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2c5a:	0f 93       	push	r16
    2c5c:	cf 93       	push	r28
    2c5e:	df 93       	push	r29
    2c60:	1f 92       	push	r1
    2c62:	cd b7       	in	r28, 0x3d	; 61
    2c64:	de b7       	in	r29, 0x3e	; 62
    2c66:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2c68:	fc 01       	movw	r30, r24
    2c6a:	22 85       	ldd	r18, Z+10	; 0x0a
    2c6c:	33 85       	ldd	r19, Z+11	; 0x0b
    2c6e:	44 85       	ldd	r20, Z+12	; 0x0c
    2c70:	55 85       	ldd	r21, Z+13	; 0x0d
    2c72:	00 e0       	ldi	r16, 0x00	; 0
    2c74:	be 01       	movw	r22, r28
    2c76:	6f 5f       	subi	r22, 0xFF	; 255
    2c78:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7a:	80 85       	ldd	r24, Z+8	; 0x08
    2c7c:	91 85       	ldd	r25, Z+9	; 0x09
    2c7e:	0e 94 35 0c 	call	0x186a	; 0x186a <xQueueGenericSend>
    2c82:	91 e0       	ldi	r25, 0x01	; 1
    2c84:	81 11       	cpse	r24, r1
    2c86:	01 c0       	rjmp	.+2      	; 0x2c8a <_ZN14frt_text_queue7putcharEc+0x30>
    2c88:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2c8a:	89 2f       	mov	r24, r25
    2c8c:	0f 90       	pop	r0
    2c8e:	df 91       	pop	r29
    2c90:	cf 91       	pop	r28
    2c92:	0f 91       	pop	r16
    2c94:	08 95       	ret

00002c96 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2c96:	8f 92       	push	r8
    2c98:	9f 92       	push	r9
    2c9a:	bf 92       	push	r11
    2c9c:	cf 92       	push	r12
    2c9e:	df 92       	push	r13
    2ca0:	ef 92       	push	r14
    2ca2:	ff 92       	push	r15
    2ca4:	0f 93       	push	r16
    2ca6:	1f 93       	push	r17
    2ca8:	cf 93       	push	r28
    2caa:	df 93       	push	r29
    2cac:	ec 01       	movw	r28, r24
    2cae:	b6 2e       	mov	r11, r22
    2cb0:	4a 01       	movw	r8, r20
    2cb2:	68 01       	movw	r12, r16
    2cb4:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2cb6:	0e 94 85 18 	call	0x310a	; 0x310a <_ZN8emstreamC1Ev>
    2cba:	8f e3       	ldi	r24, 0x3F	; 63
    2cbc:	90 e2       	ldi	r25, 0x20	; 32
    2cbe:	88 83       	st	Y, r24
    2cc0:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2cc2:	8e 86       	std	Y+14, r8	; 0x0e
    2cc4:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2cc6:	40 e0       	ldi	r20, 0x00	; 0
    2cc8:	61 e0       	ldi	r22, 0x01	; 1
    2cca:	8b 2d       	mov	r24, r11
    2ccc:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    2cd0:	88 87       	std	Y+8, r24	; 0x08
    2cd2:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2cd4:	ca 86       	std	Y+10, r12	; 0x0a
    2cd6:	db 86       	std	Y+11, r13	; 0x0b
    2cd8:	ec 86       	std	Y+12, r14	; 0x0c
    2cda:	fd 86       	std	Y+13, r15	; 0x0d
}
    2cdc:	df 91       	pop	r29
    2cde:	cf 91       	pop	r28
    2ce0:	1f 91       	pop	r17
    2ce2:	0f 91       	pop	r16
    2ce4:	ff 90       	pop	r15
    2ce6:	ef 90       	pop	r14
    2ce8:	df 90       	pop	r13
    2cea:	cf 90       	pop	r12
    2cec:	bf 90       	pop	r11
    2cee:	9f 90       	pop	r9
    2cf0:	8f 90       	pop	r8
    2cf2:	08 95       	ret

00002cf4 <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2cf4:	cf 92       	push	r12
    2cf6:	df 92       	push	r13
    2cf8:	ef 92       	push	r14
    2cfa:	ff 92       	push	r15
    2cfc:	cf 93       	push	r28
    2cfe:	df 93       	push	r29
    2d00:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2d02:	68 81       	ld	r22, Y
    2d04:	79 81       	ldd	r23, Y+1	; 0x01
    2d06:	8a 81       	ldd	r24, Y+2	; 0x02
    2d08:	9b 81       	ldd	r25, Y+3	; 0x03
    2d0a:	0f 2e       	mov	r0, r31
    2d0c:	f8 ee       	ldi	r31, 0xE8	; 232
    2d0e:	cf 2e       	mov	r12, r31
    2d10:	f3 e0       	ldi	r31, 0x03	; 3
    2d12:	df 2e       	mov	r13, r31
    2d14:	e1 2c       	mov	r14, r1
    2d16:	f1 2c       	mov	r15, r1
    2d18:	f0 2d       	mov	r31, r0
    2d1a:	a7 01       	movw	r20, r14
    2d1c:	96 01       	movw	r18, r12
    2d1e:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
    2d22:	9b 01       	movw	r18, r22
    2d24:	ac 01       	movw	r20, r24
    2d26:	60 e4       	ldi	r22, 0x40	; 64
    2d28:	72 e4       	ldi	r23, 0x42	; 66
    2d2a:	8f e0       	ldi	r24, 0x0F	; 15
    2d2c:	90 e0       	ldi	r25, 0x00	; 0
    2d2e:	0e 94 dd 1f 	call	0x3fba	; 0x3fba <__mulsi3>
    2d32:	a7 01       	movw	r20, r14
    2d34:	96 01       	movw	r18, r12
    2d36:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
    2d3a:	69 01       	movw	r12, r18
    2d3c:	7a 01       	movw	r14, r20
    2d3e:	ac 81       	ldd	r26, Y+4	; 0x04
    2d40:	bd 81       	ldd	r27, Y+5	; 0x05
    2d42:	20 e4       	ldi	r18, 0x40	; 64
    2d44:	32 e4       	ldi	r19, 0x42	; 66
    2d46:	4f e0       	ldi	r20, 0x0F	; 15
    2d48:	50 e0       	ldi	r21, 0x00	; 0
    2d4a:	0e 94 37 20 	call	0x406e	; 0x406e <__muluhisi3>
    2d4e:	20 e0       	ldi	r18, 0x00	; 0
    2d50:	38 e4       	ldi	r19, 0x48	; 72
    2d52:	48 ee       	ldi	r20, 0xE8	; 232
    2d54:	51 e0       	ldi	r21, 0x01	; 1
    2d56:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
    2d5a:	c7 01       	movw	r24, r14
    2d5c:	b6 01       	movw	r22, r12
    2d5e:	62 0f       	add	r22, r18
    2d60:	73 1f       	adc	r23, r19
    2d62:	84 1f       	adc	r24, r20
    2d64:	95 1f       	adc	r25, r21
}
    2d66:	df 91       	pop	r29
    2d68:	cf 91       	pop	r28
    2d6a:	ff 90       	pop	r15
    2d6c:	ef 90       	pop	r14
    2d6e:	df 90       	pop	r13
    2d70:	cf 90       	pop	r12
    2d72:	08 95       	ret

00002d74 <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2d74:	cf 92       	push	r12
    2d76:	df 92       	push	r13
    2d78:	ef 92       	push	r14
    2d7a:	ff 92       	push	r15
    2d7c:	0f 93       	push	r16
    2d7e:	1f 93       	push	r17
    2d80:	cf 93       	push	r28
    2d82:	df 93       	push	r29
    2d84:	cd b7       	in	r28, 0x3d	; 61
    2d86:	de b7       	in	r29, 0x3e	; 62
    2d88:	2f 97       	sbiw	r28, 0x0f	; 15
    2d8a:	cd bf       	out	0x3d, r28	; 61
    2d8c:	de bf       	out	0x3e, r29	; 62
    2d8e:	6c 01       	movw	r12, r24
    2d90:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2d92:	db 01       	movw	r26, r22
    2d94:	6d 91       	ld	r22, X+
    2d96:	7d 91       	ld	r23, X+
    2d98:	8d 91       	ld	r24, X+
    2d9a:	9c 91       	ld	r25, X
    2d9c:	28 ee       	ldi	r18, 0xE8	; 232
    2d9e:	33 e0       	ldi	r19, 0x03	; 3
    2da0:	40 e0       	ldi	r20, 0x00	; 0
    2da2:	50 e0       	ldi	r21, 0x00	; 0
    2da4:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
    2da8:	ba 01       	movw	r22, r20
    2daa:	a9 01       	movw	r20, r18
    2dac:	c6 01       	movw	r24, r12
    2dae:	0e 94 45 19 	call	0x328a	; 0x328a <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2db2:	d6 01       	movw	r26, r12
    2db4:	ed 91       	ld	r30, X+
    2db6:	fc 91       	ld	r31, X
    2db8:	02 80       	ldd	r0, Z+2	; 0x02
    2dba:	f3 81       	ldd	r31, Z+3	; 0x03
    2dbc:	e0 2d       	mov	r30, r0
    2dbe:	6e e2       	ldi	r22, 0x2E	; 46
    2dc0:	c6 01       	movw	r24, r12
    2dc2:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2dc4:	c8 01       	movw	r24, r16
    2dc6:	0e 94 7a 16 	call	0x2cf4	; 0x2cf4 <_ZN10time_stamp12get_microsecEv>
    2dca:	8e 01       	movw	r16, r28
    2dcc:	09 5f       	subi	r16, 0xF9	; 249
    2dce:	1f 4f       	sbci	r17, 0xFF	; 255
    2dd0:	fe 01       	movw	r30, r28
    2dd2:	31 96       	adiw	r30, 0x01	; 1
    2dd4:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2dd6:	2a e0       	ldi	r18, 0x0A	; 10
    2dd8:	30 e0       	ldi	r19, 0x00	; 0
    2dda:	40 e0       	ldi	r20, 0x00	; 0
    2ddc:	50 e0       	ldi	r21, 0x00	; 0
    2dde:	0e 94 0f 20 	call	0x401e	; 0x401e <__divmodsi4>
    2de2:	e6 2f       	mov	r30, r22
    2de4:	28 87       	std	Y+8, r18	; 0x08
    2de6:	39 87       	std	Y+9, r19	; 0x09
    2de8:	4a 87       	std	Y+10, r20	; 0x0a
    2dea:	5b 87       	std	Y+11, r21	; 0x0b
    2dec:	68 85       	ldd	r22, Y+8	; 0x08
    2dee:	79 85       	ldd	r23, Y+9	; 0x09
    2df0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2df2:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2df4:	20 e3       	ldi	r18, 0x30	; 48
    2df6:	2e 0f       	add	r18, r30
    2df8:	d8 01       	movw	r26, r16
    2dfa:	2e 93       	st	-X, r18
    2dfc:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2dfe:	ae 15       	cp	r26, r14
    2e00:	bf 05       	cpc	r27, r15
    2e02:	49 f7       	brne	.-46     	; 0x2dd6 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2e04:	1f 82       	std	Y+7, r1	; 0x07
    2e06:	be 01       	movw	r22, r28
    2e08:	6f 5f       	subi	r22, 0xFF	; 255
    2e0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e0c:	c6 01       	movw	r24, r12
    2e0e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2e12:	c6 01       	movw	r24, r12
    2e14:	2f 96       	adiw	r28, 0x0f	; 15
    2e16:	cd bf       	out	0x3d, r28	; 61
    2e18:	de bf       	out	0x3e, r29	; 62
    2e1a:	df 91       	pop	r29
    2e1c:	cf 91       	pop	r28
    2e1e:	1f 91       	pop	r17
    2e20:	0f 91       	pop	r16
    2e22:	ff 90       	pop	r15
    2e24:	ef 90       	pop	r14
    2e26:	df 90       	pop	r13
    2e28:	cf 90       	pop	r12
    2e2a:	08 95       	ret

00002e2c <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2e2c:	cf 93       	push	r28
    2e2e:	df 93       	push	r29
    2e30:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2e32:	0f b6       	in	r0, 0x3f	; 63
    2e34:	f8 94       	cli
    2e36:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2e38:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2e3c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2e40:	8c 83       	std	Y+4, r24	; 0x04
    2e42:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2e44:	0e 94 97 0f 	call	0x1f2e	; 0x1f2e <xTaskGetTickCount>
    2e48:	68 83       	st	Y, r22
    2e4a:	79 83       	std	Y+1, r23	; 0x01
    2e4c:	8a 83       	std	Y+2, r24	; 0x02
    2e4e:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2e50:	0f 90       	pop	r0
    2e52:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2e54:	ce 01       	movw	r24, r28
    2e56:	df 91       	pop	r29
    2e58:	cf 91       	pop	r28
    2e5a:	08 95       	ret

00002e5c <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2e5c:	5f 92       	push	r5
    2e5e:	6f 92       	push	r6
    2e60:	7f 92       	push	r7
    2e62:	8f 92       	push	r8
    2e64:	9f 92       	push	r9
    2e66:	af 92       	push	r10
    2e68:	bf 92       	push	r11
    2e6a:	cf 92       	push	r12
    2e6c:	df 92       	push	r13
    2e6e:	ef 92       	push	r14
    2e70:	ff 92       	push	r15
    2e72:	0f 93       	push	r16
    2e74:	1f 93       	push	r17
    2e76:	cf 93       	push	r28
    2e78:	df 93       	push	r29
    2e7a:	5c 01       	movw	r10, r24
    2e7c:	4b 01       	movw	r8, r22
    2e7e:	7a 01       	movw	r14, r20
    2e80:	12 2f       	mov	r17, r18
    2e82:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2e84:	63 e0       	ldi	r22, 0x03	; 3
    2e86:	ca 01       	movw	r24, r20
    2e88:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2e8c:	a8 14       	cp	r10, r8
    2e8e:	b9 04       	cpc	r11, r9
    2e90:	08 f0       	brcs	.+2      	; 0x2e94 <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2e92:	7d c0       	rjmp	.+250    	; 0x2f8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2e94:	65 01       	movw	r12, r10
    2e96:	84 e1       	ldi	r24, 0x14	; 20
    2e98:	c8 0e       	add	r12, r24
    2e9a:	d1 1c       	adc	r13, r1
    2e9c:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2e9e:	6a 2c       	mov	r6, r10
    2ea0:	5b 2c       	mov	r5, r11
    2ea2:	b5 01       	movw	r22, r10
    2ea4:	c7 01       	movw	r24, r14
    2ea6:	0e 94 11 19 	call	0x3222	; 0x3222 <_ZN8emstreamlsEj>
    2eaa:	6a e0       	ldi	r22, 0x0A	; 10
    2eac:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2eb0:	61 ed       	ldi	r22, 0xD1	; 209
    2eb2:	75 e0       	ldi	r23, 0x05	; 5
    2eb4:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2eb8:	11 23       	and	r17, r17
    2eba:	09 f4       	brne	.+2      	; 0x2ebe <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2ebc:	6d c0       	rjmp	.+218    	; 0x2f98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2ebe:	00 23       	and	r16, r16
    2ec0:	09 f4       	brne	.+2      	; 0x2ec4 <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2ec2:	6a c0       	rjmp	.+212    	; 0x2f98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2ec4:	6a e0       	ldi	r22, 0x0A	; 10
    2ec6:	c7 01       	movw	r24, r14
    2ec8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2ecc:	6c ec       	ldi	r22, 0xCC	; 204
    2ece:	75 e0       	ldi	r23, 0x05	; 5
    2ed0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    2ed4:	61 c0       	rjmp	.+194    	; 0x2f98 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2ed6:	11 23       	and	r17, r17
    2ed8:	71 f0       	breq	.+28     	; 0x2ef6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2eda:	01 11       	cpse	r16, r1
    2edc:	0c c0       	rjmp	.+24     	; 0x2ef6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2ede:	88 81       	ld	r24, Y
    2ee0:	87 15       	cp	r24, r7
    2ee2:	49 f0       	breq	.+18     	; 0x2ef6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2ee4:	6a e0       	ldi	r22, 0x0A	; 10
    2ee6:	c7 01       	movw	r24, r14
    2ee8:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2eec:	67 ec       	ldi	r22, 0xC7	; 199
    2eee:	75 e0       	ldi	r23, 0x05	; 5
    2ef0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2ef4:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2ef6:	69 91       	ld	r22, Y+
    2ef8:	c7 01       	movw	r24, r14
    2efa:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2efe:	dc 01       	movw	r26, r24
    2f00:	ed 91       	ld	r30, X+
    2f02:	fc 91       	ld	r31, X
    2f04:	02 80       	ldd	r0, Z+2	; 0x02
    2f06:	f3 81       	ldd	r31, Z+3	; 0x03
    2f08:	e0 2d       	mov	r30, r0
    2f0a:	60 e2       	ldi	r22, 0x20	; 32
    2f0c:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2f0e:	cc 16       	cp	r12, r28
    2f10:	dd 06       	cpc	r13, r29
    2f12:	09 f7       	brne	.-62     	; 0x2ed6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2f14:	11 23       	and	r17, r17
    2f16:	89 f0       	breq	.+34     	; 0x2f3a <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2f18:	6a e0       	ldi	r22, 0x0A	; 10
    2f1a:	c7 01       	movw	r24, r14
    2f1c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2f20:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2f22:	61 ec       	ldi	r22, 0xC1	; 193
    2f24:	75 e0       	ldi	r23, 0x05	; 5
    2f26:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2f2a:	e8 81       	ld	r30, Y
    2f2c:	f9 81       	ldd	r31, Y+1	; 0x01
    2f2e:	02 80       	ldd	r0, Z+2	; 0x02
    2f30:	f3 81       	ldd	r31, Z+3	; 0x03
    2f32:	e0 2d       	mov	r30, r0
    2f34:	60 e2       	ldi	r22, 0x20	; 32
    2f36:	ce 01       	movw	r24, r28
    2f38:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2f3a:	c6 2d       	mov	r28, r6
    2f3c:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2f3e:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2f40:	80 ee       	ldi	r24, 0xE0	; 224
    2f42:	86 0f       	add	r24, r22
    2f44:	8f 35       	cpi	r24, 0x5F	; 95
    2f46:	48 f4       	brcc	.+18     	; 0x2f5a <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2f48:	d7 01       	movw	r26, r14
    2f4a:	ed 91       	ld	r30, X+
    2f4c:	fc 91       	ld	r31, X
    2f4e:	02 80       	ldd	r0, Z+2	; 0x02
    2f50:	f3 81       	ldd	r31, Z+3	; 0x03
    2f52:	e0 2d       	mov	r30, r0
    2f54:	c7 01       	movw	r24, r14
    2f56:	19 95       	eicall
    2f58:	09 c0       	rjmp	.+18     	; 0x2f6c <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2f5a:	d7 01       	movw	r26, r14
    2f5c:	ed 91       	ld	r30, X+
    2f5e:	fc 91       	ld	r31, X
    2f60:	02 80       	ldd	r0, Z+2	; 0x02
    2f62:	f3 81       	ldd	r31, Z+3	; 0x03
    2f64:	e0 2d       	mov	r30, r0
    2f66:	6e e2       	ldi	r22, 0x2E	; 46
    2f68:	c7 01       	movw	r24, r14
    2f6a:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2f6c:	cc 16       	cp	r12, r28
    2f6e:	dd 06       	cpc	r13, r29
    2f70:	31 f7       	brne	.-52     	; 0x2f3e <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2f72:	b4 e1       	ldi	r27, 0x14	; 20
    2f74:	ab 0e       	add	r10, r27
    2f76:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2f78:	66 e0       	ldi	r22, 0x06	; 6
    2f7a:	c7 01       	movw	r24, r14
    2f7c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    2f80:	84 e1       	ldi	r24, 0x14	; 20
    2f82:	c8 0e       	add	r12, r24
    2f84:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f86:	a8 14       	cp	r10, r8
    2f88:	b9 04       	cpc	r11, r9
    2f8a:	08 f4       	brcc	.+2      	; 0x2f8e <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2f8c:	88 cf       	rjmp	.-240    	; 0x2e9e <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2f8e:	62 e0       	ldi	r22, 0x02	; 2
    2f90:	c7 01       	movw	r24, r14
    2f92:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
}
    2f96:	03 c0       	rjmp	.+6      	; 0x2f9e <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2f98:	c6 2d       	mov	r28, r6
    2f9a:	d5 2d       	mov	r29, r5
    2f9c:	9c cf       	rjmp	.-200    	; 0x2ed6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2f9e:	df 91       	pop	r29
    2fa0:	cf 91       	pop	r28
    2fa2:	1f 91       	pop	r17
    2fa4:	0f 91       	pop	r16
    2fa6:	ff 90       	pop	r15
    2fa8:	ef 90       	pop	r14
    2faa:	df 90       	pop	r13
    2fac:	cf 90       	pop	r12
    2fae:	bf 90       	pop	r11
    2fb0:	af 90       	pop	r10
    2fb2:	9f 90       	pop	r9
    2fb4:	8f 90       	pop	r8
    2fb6:	7f 90       	pop	r7
    2fb8:	6f 90       	pop	r6
    2fba:	5f 90       	pop	r5
    2fbc:	08 95       	ret

00002fbe <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2fbe:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    2fc2:	08 95       	ret

00002fc4 <_Znaj>:
    2fc4:	0e 94 21 08 	call	0x1042	; 0x1042 <pvPortMalloc>
    2fc8:	08 95       	ret

00002fca <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2fca:	08 95       	ret

00002fcc <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2fcc:	cf 93       	push	r28
    2fce:	df 93       	push	r29
    2fd0:	fc 01       	movw	r30, r24
    2fd2:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2fd4:	40 3a       	cpi	r20, 0xA0	; 160
    2fd6:	68 e0       	ldi	r22, 0x08	; 8
    2fd8:	56 07       	cpc	r21, r22
    2fda:	49 f4       	brne	.+18     	; 0x2fee <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2fdc:	80 e4       	ldi	r24, 0x40	; 64
    2fde:	96 e0       	ldi	r25, 0x06	; 6
    2fe0:	82 83       	std	Z+2, r24	; 0x02
    2fe2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2fe4:	82 e0       	ldi	r24, 0x02	; 2
    2fe6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2fe8:	83 e0       	ldi	r24, 0x03	; 3
    2fea:	85 83       	std	Z+5, r24	; 0x05
    2fec:	32 c0       	rjmp	.+100    	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2fee:	40 3b       	cpi	r20, 0xB0	; 176
    2ff0:	78 e0       	ldi	r23, 0x08	; 8
    2ff2:	57 07       	cpc	r21, r23
    2ff4:	49 f4       	brne	.+18     	; 0x3008 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2ff6:	80 e4       	ldi	r24, 0x40	; 64
    2ff8:	96 e0       	ldi	r25, 0x06	; 6
    2ffa:	82 83       	std	Z+2, r24	; 0x02
    2ffc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2ffe:	86 e0       	ldi	r24, 0x06	; 6
    3000:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3002:	87 e0       	ldi	r24, 0x07	; 7
    3004:	85 83       	std	Z+5, r24	; 0x05
    3006:	25 c0       	rjmp	.+74     	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3008:	40 3a       	cpi	r20, 0xA0	; 160
    300a:	89 e0       	ldi	r24, 0x09	; 9
    300c:	58 07       	cpc	r21, r24
    300e:	49 f4       	brne	.+18     	; 0x3022 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    3010:	80 e6       	ldi	r24, 0x60	; 96
    3012:	96 e0       	ldi	r25, 0x06	; 6
    3014:	82 83       	std	Z+2, r24	; 0x02
    3016:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    3018:	82 e0       	ldi	r24, 0x02	; 2
    301a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    301c:	83 e0       	ldi	r24, 0x03	; 3
    301e:	85 83       	std	Z+5, r24	; 0x05
    3020:	18 c0       	rjmp	.+48     	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    3022:	40 3b       	cpi	r20, 0xB0	; 176
    3024:	69 e0       	ldi	r22, 0x09	; 9
    3026:	56 07       	cpc	r21, r22
    3028:	49 f4       	brne	.+18     	; 0x303c <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    302a:	80 e6       	ldi	r24, 0x60	; 96
    302c:	96 e0       	ldi	r25, 0x06	; 6
    302e:	82 83       	std	Z+2, r24	; 0x02
    3030:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    3032:	86 e0       	ldi	r24, 0x06	; 6
    3034:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    3036:	87 e0       	ldi	r24, 0x07	; 7
    3038:	85 83       	std	Z+5, r24	; 0x05
    303a:	0b c0       	rjmp	.+22     	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    303c:	40 3a       	cpi	r20, 0xA0	; 160
    303e:	5a 40       	sbci	r21, 0x0A	; 10
    3040:	41 f4       	brne	.+16     	; 0x3052 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    3042:	80 e8       	ldi	r24, 0x80	; 128
    3044:	96 e0       	ldi	r25, 0x06	; 6
    3046:	82 83       	std	Z+2, r24	; 0x02
    3048:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    304a:	82 e0       	ldi	r24, 0x02	; 2
    304c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    304e:	83 e0       	ldi	r24, 0x03	; 3
    3050:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    3052:	a6 83       	std	Z+6, r26	; 0x06
    3054:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    3056:	cd 01       	movw	r24, r26
    3058:	01 96       	adiw	r24, 0x01	; 1
    305a:	80 87       	std	Z+8, r24	; 0x08
    305c:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    305e:	03 96       	adiw	r24, 0x03	; 3
    3060:	82 87       	std	Z+10, r24	; 0x0a
    3062:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    3064:	25 81       	ldd	r18, Z+5	; 0x05
    3066:	c2 81       	ldd	r28, Z+2	; 0x02
    3068:	d3 81       	ldd	r29, Z+3	; 0x03
    306a:	4c 81       	ldd	r20, Y+4	; 0x04
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	90 e0       	ldi	r25, 0x00	; 0
    3070:	bc 01       	movw	r22, r24
    3072:	02 c0       	rjmp	.+4      	; 0x3078 <_ZN7base232C1EjP12USART_struct+0xac>
    3074:	66 0f       	add	r22, r22
    3076:	77 1f       	adc	r23, r23
    3078:	2a 95       	dec	r18
    307a:	e2 f7       	brpl	.-8      	; 0x3074 <_ZN7base232C1EjP12USART_struct+0xa8>
    307c:	9b 01       	movw	r18, r22
    307e:	24 2b       	or	r18, r20
    3080:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    3082:	25 81       	ldd	r18, Z+5	; 0x05
    3084:	c2 81       	ldd	r28, Z+2	; 0x02
    3086:	d3 81       	ldd	r29, Z+3	; 0x03
    3088:	48 81       	ld	r20, Y
    308a:	bc 01       	movw	r22, r24
    308c:	02 c0       	rjmp	.+4      	; 0x3092 <_ZN7base232C1EjP12USART_struct+0xc6>
    308e:	66 0f       	add	r22, r22
    3090:	77 1f       	adc	r23, r23
    3092:	2a 95       	dec	r18
    3094:	e2 f7       	brpl	.-8      	; 0x308e <_ZN7base232C1EjP12USART_struct+0xc2>
    3096:	9b 01       	movw	r18, r22
    3098:	24 2b       	or	r18, r20
    309a:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    309c:	34 81       	ldd	r19, Z+4	; 0x04
    309e:	c2 81       	ldd	r28, Z+2	; 0x02
    30a0:	d3 81       	ldd	r29, Z+3	; 0x03
    30a2:	28 81       	ld	r18, Y
    30a4:	02 c0       	rjmp	.+4      	; 0x30aa <_ZN7base232C1EjP12USART_struct+0xde>
    30a6:	88 0f       	add	r24, r24
    30a8:	99 1f       	adc	r25, r25
    30aa:	3a 95       	dec	r19
    30ac:	e2 f7       	brpl	.-8      	; 0x30a6 <_ZN7base232C1EjP12USART_struct+0xda>
    30ae:	80 95       	com	r24
    30b0:	90 95       	com	r25
    30b2:	82 23       	and	r24, r18
    30b4:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    30b6:	80 e1       	ldi	r24, 0x10	; 16
    30b8:	13 96       	adiw	r26, 0x03	; 3
    30ba:	8c 93       	st	X, r24
    30bc:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    30be:	83 e0       	ldi	r24, 0x03	; 3
    30c0:	15 96       	adiw	r26, 0x05	; 5
    30c2:	8c 93       	st	X, r24
    30c4:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    30c6:	80 ef       	ldi	r24, 0xF0	; 240
    30c8:	17 96       	adiw	r26, 0x07	; 7
    30ca:	8c 93       	st	X, r24
    30cc:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    30ce:	81 e2       	ldi	r24, 0x21	; 33
    30d0:	16 96       	adiw	r26, 0x06	; 6
    30d2:	8c 93       	st	X, r24
    30d4:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    30d6:	88 e1       	ldi	r24, 0x18	; 24
    30d8:	14 96       	adiw	r26, 0x04	; 4
    30da:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    30dc:	80 e8       	ldi	r24, 0x80	; 128
    30de:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    30e0:	80 e4       	ldi	r24, 0x40	; 64
    30e2:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    30e4:	80 e2       	ldi	r24, 0x20	; 32
    30e6:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    30e8:	06 80       	ldd	r0, Z+6	; 0x06
    30ea:	f7 81       	ldd	r31, Z+7	; 0x07
    30ec:	e0 2d       	mov	r30, r0
    30ee:	80 81       	ld	r24, Z
    30f0:	80 81       	ld	r24, Z
}
    30f2:	df 91       	pop	r29
    30f4:	cf 91       	pop	r28
    30f6:	08 95       	ret

000030f8 <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    30f8:	81 e0       	ldi	r24, 0x01	; 1
    30fa:	08 95       	ret

000030fc <_ZN8emstream7getcharEv>:
    30fc:	80 e0       	ldi	r24, 0x00	; 0
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	08 95       	ret

00003102 <_ZN8emstream14check_for_charEv>:
    3102:	80 e0       	ldi	r24, 0x00	; 0
    3104:	08 95       	ret

00003106 <_ZN8emstream12transmit_nowEv>:
    3106:	08 95       	ret

00003108 <_ZN8emstream12clear_screenEv>:
    3108:	08 95       	ret

0000310a <_ZN8emstreamC1Ev>:
    310a:	fc 01       	movw	r30, r24
    310c:	8f e4       	ldi	r24, 0x4F	; 79
    310e:	90 e2       	ldi	r25, 0x20	; 32
    3110:	80 83       	st	Z, r24
    3112:	91 83       	std	Z+1, r25	; 0x01
    3114:	8a e0       	ldi	r24, 0x0A	; 10
    3116:	82 83       	std	Z+2, r24	; 0x02
    3118:	13 82       	std	Z+3, r1	; 0x03
    311a:	83 e0       	ldi	r24, 0x03	; 3
    311c:	85 83       	std	Z+5, r24	; 0x05
    311e:	14 82       	std	Z+4, r1	; 0x04
    3120:	16 82       	std	Z+6, r1	; 0x06
    3122:	17 82       	std	Z+7, r1	; 0x07
    3124:	08 95       	ret

00003126 <_ZN8emstream4putsEPKc>:
    3126:	0f 93       	push	r16
    3128:	1f 93       	push	r17
    312a:	cf 93       	push	r28
    312c:	df 93       	push	r29
    312e:	8c 01       	movw	r16, r24
    3130:	fb 01       	movw	r30, r22
    3132:	dc 01       	movw	r26, r24
    3134:	14 96       	adiw	r26, 0x04	; 4
    3136:	8c 91       	ld	r24, X
    3138:	81 11       	cpse	r24, r1
    313a:	04 c0       	rjmp	.+8      	; 0x3144 <_ZN8emstream4putsEPKc+0x1e>
    313c:	60 81       	ld	r22, Z
    313e:	61 11       	cpse	r22, r1
    3140:	17 c0       	rjmp	.+46     	; 0x3170 <_ZN8emstream4putsEPKc+0x4a>
    3142:	23 c0       	rjmp	.+70     	; 0x318a <_ZN8emstream4putsEPKc+0x64>
    3144:	d8 01       	movw	r26, r16
    3146:	14 96       	adiw	r26, 0x04	; 4
    3148:	1c 92       	st	X, r1
    314a:	eb 01       	movw	r28, r22
    314c:	21 96       	adiw	r28, 0x01	; 1
    314e:	64 91       	lpm	r22, Z
    3150:	66 23       	and	r22, r22
    3152:	d9 f0       	breq	.+54     	; 0x318a <_ZN8emstream4putsEPKc+0x64>
    3154:	d8 01       	movw	r26, r16
    3156:	ed 91       	ld	r30, X+
    3158:	fc 91       	ld	r31, X
    315a:	02 80       	ldd	r0, Z+2	; 0x02
    315c:	f3 81       	ldd	r31, Z+3	; 0x03
    315e:	e0 2d       	mov	r30, r0
    3160:	c8 01       	movw	r24, r16
    3162:	19 95       	eicall
    3164:	fe 01       	movw	r30, r28
    3166:	64 91       	lpm	r22, Z
    3168:	21 96       	adiw	r28, 0x01	; 1
    316a:	61 11       	cpse	r22, r1
    316c:	f3 cf       	rjmp	.-26     	; 0x3154 <_ZN8emstream4putsEPKc+0x2e>
    316e:	0d c0       	rjmp	.+26     	; 0x318a <_ZN8emstream4putsEPKc+0x64>
    3170:	ef 01       	movw	r28, r30
    3172:	21 96       	adiw	r28, 0x01	; 1
    3174:	d8 01       	movw	r26, r16
    3176:	ed 91       	ld	r30, X+
    3178:	fc 91       	ld	r31, X
    317a:	02 80       	ldd	r0, Z+2	; 0x02
    317c:	f3 81       	ldd	r31, Z+3	; 0x03
    317e:	e0 2d       	mov	r30, r0
    3180:	c8 01       	movw	r24, r16
    3182:	19 95       	eicall
    3184:	69 91       	ld	r22, Y+
    3186:	61 11       	cpse	r22, r1
    3188:	f5 cf       	rjmp	.-22     	; 0x3174 <_ZN8emstream4putsEPKc+0x4e>
    318a:	df 91       	pop	r29
    318c:	cf 91       	pop	r28
    318e:	1f 91       	pop	r17
    3190:	0f 91       	pop	r16
    3192:	08 95       	ret

00003194 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    3194:	cf 93       	push	r28
    3196:	df 93       	push	r29
    3198:	ec 01       	movw	r28, r24
	switch (new_manip)
    319a:	86 2f       	mov	r24, r22
    319c:	90 e0       	ldi	r25, 0x00	; 0
    319e:	8b 30       	cpi	r24, 0x0B	; 11
    31a0:	91 05       	cpc	r25, r1
    31a2:	d8 f5       	brcc	.+118    	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
    31a4:	fc 01       	movw	r30, r24
    31a6:	88 27       	eor	r24, r24
    31a8:	e2 50       	subi	r30, 0x02	; 2
    31aa:	ff 4f       	sbci	r31, 0xFF	; 255
    31ac:	8f 4f       	sbci	r24, 0xFF	; 255
    31ae:	0c 94 2e 20 	jmp	0x405c	; 0x405c <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    31b2:	82 e0       	ldi	r24, 0x02	; 2
    31b4:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31b6:	31 c0       	rjmp	.+98     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    31b8:	88 e0       	ldi	r24, 0x08	; 8
    31ba:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31bc:	2e c0       	rjmp	.+92     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    31be:	8a e0       	ldi	r24, 0x0A	; 10
    31c0:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31c2:	2b c0       	rjmp	.+86     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    31c4:	80 e1       	ldi	r24, 0x10	; 16
    31c6:	8a 83       	std	Y+2, r24	; 0x02
			break;
    31c8:	28 c0       	rjmp	.+80     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    31ca:	81 e0       	ldi	r24, 0x01	; 1
    31cc:	8b 83       	std	Y+3, r24	; 0x03
			break;
    31ce:	25 c0       	rjmp	.+74     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    31d0:	1b 82       	std	Y+3, r1	; 0x03
			break;
    31d2:	23 c0       	rjmp	.+70     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    31d4:	e8 81       	ld	r30, Y
    31d6:	f9 81       	ldd	r31, Y+1	; 0x01
    31d8:	02 80       	ldd	r0, Z+2	; 0x02
    31da:	f3 81       	ldd	r31, Z+3	; 0x03
    31dc:	e0 2d       	mov	r30, r0
    31de:	6d e0       	ldi	r22, 0x0D	; 13
    31e0:	ce 01       	movw	r24, r28
    31e2:	19 95       	eicall
    31e4:	e8 81       	ld	r30, Y
    31e6:	f9 81       	ldd	r31, Y+1	; 0x01
    31e8:	02 80       	ldd	r0, Z+2	; 0x02
    31ea:	f3 81       	ldd	r31, Z+3	; 0x03
    31ec:	e0 2d       	mov	r30, r0
    31ee:	6a e0       	ldi	r22, 0x0A	; 10
    31f0:	ce 01       	movw	r24, r28
    31f2:	19 95       	eicall
			break;
    31f4:	12 c0       	rjmp	.+36     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    31f6:	e8 81       	ld	r30, Y
    31f8:	f9 81       	ldd	r31, Y+1	; 0x01
    31fa:	02 84       	ldd	r0, Z+10	; 0x0a
    31fc:	f3 85       	ldd	r31, Z+11	; 0x0b
    31fe:	e0 2d       	mov	r30, r0
    3200:	ce 01       	movw	r24, r28
    3202:	19 95       	eicall
			break;
    3204:	0a c0       	rjmp	.+20     	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    3206:	e8 81       	ld	r30, Y
    3208:	f9 81       	ldd	r31, Y+1	; 0x01
    320a:	00 84       	ldd	r0, Z+8	; 0x08
    320c:	f1 85       	ldd	r31, Z+9	; 0x09
    320e:	e0 2d       	mov	r30, r0
    3210:	ce 01       	movw	r24, r28
    3212:	19 95       	eicall
			break;
    3214:	02 c0       	rjmp	.+4      	; 0x321a <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    3216:	81 e0       	ldi	r24, 0x01	; 1
    3218:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    321a:	ce 01       	movw	r24, r28
    321c:	df 91       	pop	r29
    321e:	cf 91       	pop	r28
    3220:	08 95       	ret

00003222 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    3222:	ff 92       	push	r15
    3224:	0f 93       	push	r16
    3226:	1f 93       	push	r17
    3228:	cf 93       	push	r28
    322a:	df 93       	push	r29
    322c:	cd b7       	in	r28, 0x3d	; 61
    322e:	de b7       	in	r29, 0x3e	; 62
    3230:	61 97       	sbiw	r28, 0x11	; 17
    3232:	cd bf       	out	0x3d, r28	; 61
    3234:	de bf       	out	0x3e, r29	; 62
    3236:	8c 01       	movw	r16, r24
    3238:	f6 2e       	mov	r15, r22
    323a:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    323c:	f8 01       	movw	r30, r16
    323e:	42 81       	ldd	r20, Z+2	; 0x02
    3240:	40 31       	cpi	r20, 0x10	; 16
    3242:	21 f0       	breq	.+8      	; 0x324c <_ZN8emstreamlsEj+0x2a>
    3244:	48 30       	cpi	r20, 0x08	; 8
    3246:	11 f0       	breq	.+4      	; 0x324c <_ZN8emstreamlsEj+0x2a>
    3248:	42 30       	cpi	r20, 0x02	; 2
    324a:	41 f4       	brne	.+16     	; 0x325c <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    324c:	69 2f       	mov	r22, r25
    324e:	c8 01       	movw	r24, r16
    3250:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    3254:	6f 2d       	mov	r22, r15
    3256:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    325a:	0d c0       	rjmp	.+26     	; 0x3276 <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    325c:	50 e0       	ldi	r21, 0x00	; 0
    325e:	be 01       	movw	r22, r28
    3260:	6f 5f       	subi	r22, 0xFF	; 255
    3262:	7f 4f       	sbci	r23, 0xFF	; 255
    3264:	8f 2d       	mov	r24, r15
    3266:	0e 94 9d 20 	call	0x413a	; 0x413a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    326a:	be 01       	movw	r22, r28
    326c:	6f 5f       	subi	r22, 0xFF	; 255
    326e:	7f 4f       	sbci	r23, 0xFF	; 255
    3270:	c8 01       	movw	r24, r16
    3272:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    3276:	c8 01       	movw	r24, r16
    3278:	61 96       	adiw	r28, 0x11	; 17
    327a:	cd bf       	out	0x3d, r28	; 61
    327c:	de bf       	out	0x3e, r29	; 62
    327e:	df 91       	pop	r29
    3280:	cf 91       	pop	r28
    3282:	1f 91       	pop	r17
    3284:	0f 91       	pop	r16
    3286:	ff 90       	pop	r15
    3288:	08 95       	ret

0000328a <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    328a:	df 92       	push	r13
    328c:	ef 92       	push	r14
    328e:	ff 92       	push	r15
    3290:	0f 93       	push	r16
    3292:	1f 93       	push	r17
    3294:	cf 93       	push	r28
    3296:	df 93       	push	r29
    3298:	cd b7       	in	r28, 0x3d	; 61
    329a:	de b7       	in	r29, 0x3e	; 62
    329c:	a1 97       	sbiw	r28, 0x21	; 33
    329e:	cd bf       	out	0x3d, r28	; 61
    32a0:	de bf       	out	0x3e, r29	; 62
    32a2:	8c 01       	movw	r16, r24
    32a4:	d4 2e       	mov	r13, r20
    32a6:	e5 2e       	mov	r14, r21
    32a8:	f6 2e       	mov	r15, r22
    32aa:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    32ac:	f8 01       	movw	r30, r16
    32ae:	22 81       	ldd	r18, Z+2	; 0x02
    32b0:	20 31       	cpi	r18, 0x10	; 16
    32b2:	21 f0       	breq	.+8      	; 0x32bc <_ZN8emstreamlsEm+0x32>
    32b4:	28 30       	cpi	r18, 0x08	; 8
    32b6:	11 f0       	breq	.+4      	; 0x32bc <_ZN8emstreamlsEm+0x32>
    32b8:	22 30       	cpi	r18, 0x02	; 2
    32ba:	71 f4       	brne	.+28     	; 0x32d8 <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    32bc:	69 2f       	mov	r22, r25
    32be:	c8 01       	movw	r24, r16
    32c0:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    32c4:	6f 2d       	mov	r22, r15
    32c6:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    32ca:	6e 2d       	mov	r22, r14
    32cc:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    32d0:	6d 2d       	mov	r22, r13
    32d2:	0e 94 87 19 	call	0x330e	; 0x330e <_ZN8emstreamlsEh>
    32d6:	0f c0       	rjmp	.+30     	; 0x32f6 <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    32d8:	30 e0       	ldi	r19, 0x00	; 0
    32da:	ae 01       	movw	r20, r28
    32dc:	4f 5f       	subi	r20, 0xFF	; 255
    32de:	5f 4f       	sbci	r21, 0xFF	; 255
    32e0:	6d 2d       	mov	r22, r13
    32e2:	7e 2d       	mov	r23, r14
    32e4:	8f 2d       	mov	r24, r15
    32e6:	0e 94 70 20 	call	0x40e0	; 0x40e0 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    32ea:	be 01       	movw	r22, r28
    32ec:	6f 5f       	subi	r22, 0xFF	; 255
    32ee:	7f 4f       	sbci	r23, 0xFF	; 255
    32f0:	c8 01       	movw	r24, r16
    32f2:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    32f6:	c8 01       	movw	r24, r16
    32f8:	a1 96       	adiw	r28, 0x21	; 33
    32fa:	cd bf       	out	0x3d, r28	; 61
    32fc:	de bf       	out	0x3e, r29	; 62
    32fe:	df 91       	pop	r29
    3300:	cf 91       	pop	r28
    3302:	1f 91       	pop	r17
    3304:	0f 91       	pop	r16
    3306:	ff 90       	pop	r15
    3308:	ef 90       	pop	r14
    330a:	df 90       	pop	r13
    330c:	08 95       	ret

0000330e <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    330e:	cf 92       	push	r12
    3310:	df 92       	push	r13
    3312:	ef 92       	push	r14
    3314:	ff 92       	push	r15
    3316:	0f 93       	push	r16
    3318:	1f 93       	push	r17
    331a:	cf 93       	push	r28
    331c:	df 93       	push	r29
    331e:	cd b7       	in	r28, 0x3d	; 61
    3320:	de b7       	in	r29, 0x3e	; 62
    3322:	29 97       	sbiw	r28, 0x09	; 9
    3324:	cd bf       	out	0x3d, r28	; 61
    3326:	de bf       	out	0x3e, r29	; 62
    3328:	8c 01       	movw	r16, r24
    332a:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    332c:	dc 01       	movw	r26, r24
    332e:	13 96       	adiw	r26, 0x03	; 3
    3330:	8c 91       	ld	r24, X
    3332:	13 97       	sbiw	r26, 0x03	; 3
    3334:	88 23       	and	r24, r24
    3336:	41 f0       	breq	.+16     	; 0x3348 <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    3338:	ed 91       	ld	r30, X+
    333a:	fc 91       	ld	r31, X
    333c:	02 80       	ldd	r0, Z+2	; 0x02
    333e:	f3 81       	ldd	r31, Z+3	; 0x03
    3340:	e0 2d       	mov	r30, r0
    3342:	c8 01       	movw	r24, r16
    3344:	19 95       	eicall
    3346:	56 c0       	rjmp	.+172    	; 0x33f4 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    3348:	f8 01       	movw	r30, r16
    334a:	42 81       	ldd	r20, Z+2	; 0x02
    334c:	42 30       	cpi	r20, 0x02	; 2
    334e:	19 f5       	brne	.+70     	; 0x3396 <_ZN8emstreamlsEh+0x88>
    3350:	68 94       	set
    3352:	cc 24       	eor	r12, r12
    3354:	c3 f8       	bld	r12, 3
    3356:	d1 2c       	mov	r13, r1
    3358:	68 94       	set
    335a:	ff 24       	eor	r15, r15
    335c:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    335e:	8e 2d       	mov	r24, r14
    3360:	8f 21       	and	r24, r15
    3362:	51 f0       	breq	.+20     	; 0x3378 <_ZN8emstreamlsEh+0x6a>
    3364:	d8 01       	movw	r26, r16
    3366:	ed 91       	ld	r30, X+
    3368:	fc 91       	ld	r31, X
    336a:	02 80       	ldd	r0, Z+2	; 0x02
    336c:	f3 81       	ldd	r31, Z+3	; 0x03
    336e:	e0 2d       	mov	r30, r0
    3370:	61 e3       	ldi	r22, 0x31	; 49
    3372:	c8 01       	movw	r24, r16
    3374:	19 95       	eicall
    3376:	09 c0       	rjmp	.+18     	; 0x338a <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    3378:	d8 01       	movw	r26, r16
    337a:	ed 91       	ld	r30, X+
    337c:	fc 91       	ld	r31, X
    337e:	02 80       	ldd	r0, Z+2	; 0x02
    3380:	f3 81       	ldd	r31, Z+3	; 0x03
    3382:	e0 2d       	mov	r30, r0
    3384:	60 e3       	ldi	r22, 0x30	; 48
    3386:	c8 01       	movw	r24, r16
    3388:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    338a:	f6 94       	lsr	r15
    338c:	b1 e0       	ldi	r27, 0x01	; 1
    338e:	cb 1a       	sub	r12, r27
    3390:	d1 08       	sbc	r13, r1
    3392:	29 f7       	brne	.-54     	; 0x335e <_ZN8emstreamlsEh+0x50>
    3394:	2f c0       	rjmp	.+94     	; 0x33f4 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    3396:	40 31       	cpi	r20, 0x10	; 16
    3398:	f9 f4       	brne	.+62     	; 0x33d8 <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    339a:	62 95       	swap	r22
    339c:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    339e:	01 90       	ld	r0, Z+
    33a0:	f0 81       	ld	r31, Z
    33a2:	e0 2d       	mov	r30, r0
    33a4:	02 80       	ldd	r0, Z+2	; 0x02
    33a6:	f3 81       	ldd	r31, Z+3	; 0x03
    33a8:	e0 2d       	mov	r30, r0
    33aa:	6a 30       	cpi	r22, 0x0A	; 10
    33ac:	10 f0       	brcs	.+4      	; 0x33b2 <_ZN8emstreamlsEh+0xa4>
    33ae:	69 5c       	subi	r22, 0xC9	; 201
    33b0:	01 c0       	rjmp	.+2      	; 0x33b4 <_ZN8emstreamlsEh+0xa6>
    33b2:	60 5d       	subi	r22, 0xD0	; 208
    33b4:	c8 01       	movw	r24, r16
    33b6:	19 95       	eicall
		temp_char = num & 0x0F;
    33b8:	6e 2d       	mov	r22, r14
    33ba:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    33bc:	d8 01       	movw	r26, r16
    33be:	ed 91       	ld	r30, X+
    33c0:	fc 91       	ld	r31, X
    33c2:	02 80       	ldd	r0, Z+2	; 0x02
    33c4:	f3 81       	ldd	r31, Z+3	; 0x03
    33c6:	e0 2d       	mov	r30, r0
    33c8:	6a 30       	cpi	r22, 0x0A	; 10
    33ca:	10 f0       	brcs	.+4      	; 0x33d0 <_ZN8emstreamlsEh+0xc2>
    33cc:	69 5c       	subi	r22, 0xC9	; 201
    33ce:	01 c0       	rjmp	.+2      	; 0x33d2 <_ZN8emstreamlsEh+0xc4>
    33d0:	60 5d       	subi	r22, 0xD0	; 208
    33d2:	c8 01       	movw	r24, r16
    33d4:	19 95       	eicall
    33d6:	0e c0       	rjmp	.+28     	; 0x33f4 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    33d8:	50 e0       	ldi	r21, 0x00	; 0
    33da:	be 01       	movw	r22, r28
    33dc:	6f 5f       	subi	r22, 0xFF	; 255
    33de:	7f 4f       	sbci	r23, 0xFF	; 255
    33e0:	8e 2d       	mov	r24, r14
    33e2:	90 e0       	ldi	r25, 0x00	; 0
    33e4:	0e 94 9d 20 	call	0x413a	; 0x413a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    33e8:	be 01       	movw	r22, r28
    33ea:	6f 5f       	subi	r22, 0xFF	; 255
    33ec:	7f 4f       	sbci	r23, 0xFF	; 255
    33ee:	c8 01       	movw	r24, r16
    33f0:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    33f4:	c8 01       	movw	r24, r16
    33f6:	29 96       	adiw	r28, 0x09	; 9
    33f8:	cd bf       	out	0x3d, r28	; 61
    33fa:	de bf       	out	0x3e, r29	; 62
    33fc:	df 91       	pop	r29
    33fe:	cf 91       	pop	r28
    3400:	1f 91       	pop	r17
    3402:	0f 91       	pop	r16
    3404:	ff 90       	pop	r15
    3406:	ef 90       	pop	r14
    3408:	df 90       	pop	r13
    340a:	cf 90       	pop	r12
    340c:	08 95       	ret

0000340e <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    340e:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    3410:	50 96       	adiw	r26, 0x10	; 16
    3412:	ed 91       	ld	r30, X+
    3414:	fc 91       	ld	r31, X
    3416:	51 97       	sbiw	r26, 0x11	; 17
    3418:	80 81       	ld	r24, Z
    341a:	54 96       	adiw	r26, 0x14	; 20
    341c:	4c 91       	ld	r20, X
    341e:	54 97       	sbiw	r26, 0x14	; 20
    3420:	84 23       	and	r24, r20
    3422:	29 f0       	breq	.+10     	; 0x342e <_ZN5rs2327putcharEc+0x20>
    3424:	09 c0       	rjmp	.+18     	; 0x3438 <_ZN5rs2327putcharEc+0x2a>
    3426:	21 50       	subi	r18, 0x01	; 1
    3428:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    342a:	19 f4       	brne	.+6      	; 0x3432 <_ZN5rs2327putcharEc+0x24>
    342c:	12 c0       	rjmp	.+36     	; 0x3452 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    342e:	21 e2       	ldi	r18, 0x21	; 33
    3430:	3e e4       	ldi	r19, 0x4E	; 78
    3432:	90 81       	ld	r25, Z
    3434:	94 23       	and	r25, r20
    3436:	b9 f3       	breq	.-18     	; 0x3426 <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    3438:	90 81       	ld	r25, Z
    343a:	56 96       	adiw	r26, 0x16	; 22
    343c:	8c 91       	ld	r24, X
    343e:	56 97       	sbiw	r26, 0x16	; 22
    3440:	89 2b       	or	r24, r25
    3442:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    3444:	1e 96       	adiw	r26, 0x0e	; 14
    3446:	ed 91       	ld	r30, X+
    3448:	fc 91       	ld	r31, X
    344a:	1f 97       	sbiw	r26, 0x0f	; 15
    344c:	60 83       	st	Z, r22
	return (true);
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3452:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    3454:	08 95       	ret

00003456 <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    3456:	cf 93       	push	r28
    3458:	df 93       	push	r29
    345a:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    345c:	c1 8d       	ldd	r28, Z+25	; 0x19
    345e:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3460:	28 81       	ld	r18, Y
    3462:	39 81       	ldd	r19, Y+1	; 0x01
    3464:	a3 8d       	ldd	r26, Z+27	; 0x1b
    3466:	b4 8d       	ldd	r27, Z+28	; 0x1c
    3468:	4d 91       	ld	r20, X+
    346a:	5c 91       	ld	r21, X
    346c:	24 17       	cp	r18, r20
    346e:	35 07       	cpc	r19, r21
    3470:	e9 f3       	breq	.-6      	; 0x346c <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3472:	a7 89       	ldd	r26, Z+23	; 0x17
    3474:	b0 8d       	ldd	r27, Z+24	; 0x18
    3476:	0d 90       	ld	r0, X+
    3478:	bc 91       	ld	r27, X
    347a:	a0 2d       	mov	r26, r0
    347c:	a2 0f       	add	r26, r18
    347e:	b3 1f       	adc	r27, r19
    3480:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3482:	2f 5f       	subi	r18, 0xFF	; 255
    3484:	3f 4f       	sbci	r19, 0xFF	; 255
    3486:	28 83       	st	Y, r18
    3488:	39 83       	std	Y+1, r19	; 0x01
    348a:	24 36       	cpi	r18, 0x64	; 100
    348c:	31 05       	cpc	r19, r1
    348e:	28 f0       	brcs	.+10     	; 0x349a <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3490:	01 8c       	ldd	r0, Z+25	; 0x19
    3492:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3494:	e0 2d       	mov	r30, r0
    3496:	10 82       	st	Z, r1
    3498:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    349a:	90 e0       	ldi	r25, 0x00	; 0
    349c:	df 91       	pop	r29
    349e:	cf 91       	pop	r28
    34a0:	08 95       	ret

000034a2 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    34a2:	cf 93       	push	r28
    34a4:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    34a6:	ec 01       	movw	r28, r24
    34a8:	a9 8d       	ldd	r26, Y+25	; 0x19
    34aa:	ba 8d       	ldd	r27, Y+26	; 0x1a
    34ac:	eb 8d       	ldd	r30, Y+27	; 0x1b
    34ae:	fc 8d       	ldd	r31, Y+28	; 0x1c
    34b0:	81 e0       	ldi	r24, 0x01	; 1
    34b2:	4d 91       	ld	r20, X+
    34b4:	5c 91       	ld	r21, X
    34b6:	20 81       	ld	r18, Z
    34b8:	31 81       	ldd	r19, Z+1	; 0x01
    34ba:	42 17       	cp	r20, r18
    34bc:	53 07       	cpc	r21, r19
    34be:	09 f4       	brne	.+2      	; 0x34c2 <_ZN5rs23214check_for_charEv+0x20>
    34c0:	80 e0       	ldi	r24, 0x00	; 0
}
    34c2:	df 91       	pop	r29
    34c4:	cf 91       	pop	r28
    34c6:	08 95       	ret

000034c8 <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    34c8:	dc 01       	movw	r26, r24
    34ca:	ed 91       	ld	r30, X+
    34cc:	fc 91       	ld	r31, X
    34ce:	02 80       	ldd	r0, Z+2	; 0x02
    34d0:	f3 81       	ldd	r31, Z+3	; 0x03
    34d2:	e0 2d       	mov	r30, r0
    34d4:	6c e0       	ldi	r22, 0x0C	; 12
    34d6:	19 95       	eicall
    34d8:	08 95       	ret

000034da <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    34da:	ef 92       	push	r14
    34dc:	ff 92       	push	r15
    34de:	0f 93       	push	r16
    34e0:	1f 93       	push	r17
    34e2:	cf 93       	push	r28
    34e4:	df 93       	push	r29
    34e6:	ec 01       	movw	r28, r24
    34e8:	7b 01       	movw	r14, r22
    34ea:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    34ec:	0e 94 85 18 	call	0x310a	; 0x310a <_ZN8emstreamC1Ev>
    34f0:	a8 01       	movw	r20, r16
    34f2:	b7 01       	movw	r22, r14
    34f4:	ce 01       	movw	r24, r28
    34f6:	08 96       	adiw	r24, 0x08	; 8
    34f8:	0e 94 e6 17 	call	0x2fcc	; 0x2fcc <_ZN7base232C1EjP12USART_struct>
    34fc:	8f e5       	ldi	r24, 0x5F	; 95
    34fe:	90 e2       	ldi	r25, 0x20	; 32
    3500:	88 83       	st	Y, r24
    3502:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    3504:	00 3a       	cpi	r16, 0xA0	; 160
    3506:	88 e0       	ldi	r24, 0x08	; 8
    3508:	18 07       	cpc	r17, r24
    350a:	69 f4       	brne	.+26     	; 0x3526 <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    350c:	88 e6       	ldi	r24, 0x68	; 104
    350e:	91 e3       	ldi	r25, 0x31	; 49
    3510:	8f 8b       	std	Y+23, r24	; 0x17
    3512:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    3514:	8e e5       	ldi	r24, 0x5E	; 94
    3516:	91 e3       	ldi	r25, 0x31	; 49
    3518:	89 8f       	std	Y+25, r24	; 0x19
    351a:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    351c:	84 e5       	ldi	r24, 0x54	; 84
    351e:	91 e3       	ldi	r25, 0x31	; 49
    3520:	8b 8f       	std	Y+27, r24	; 0x1b
    3522:	9c 8f       	std	Y+28, r25	; 0x1c
    3524:	42 c0       	rjmp	.+132    	; 0x35aa <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    3526:	00 3b       	cpi	r16, 0xB0	; 176
    3528:	e8 e0       	ldi	r30, 0x08	; 8
    352a:	1e 07       	cpc	r17, r30
    352c:	69 f4       	brne	.+26     	; 0x3548 <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    352e:	86 e6       	ldi	r24, 0x66	; 102
    3530:	91 e3       	ldi	r25, 0x31	; 49
    3532:	8f 8b       	std	Y+23, r24	; 0x17
    3534:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    3536:	8c e5       	ldi	r24, 0x5C	; 92
    3538:	91 e3       	ldi	r25, 0x31	; 49
    353a:	89 8f       	std	Y+25, r24	; 0x19
    353c:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    353e:	82 e5       	ldi	r24, 0x52	; 82
    3540:	91 e3       	ldi	r25, 0x31	; 49
    3542:	8b 8f       	std	Y+27, r24	; 0x1b
    3544:	9c 8f       	std	Y+28, r25	; 0x1c
    3546:	31 c0       	rjmp	.+98     	; 0x35aa <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    3548:	00 3a       	cpi	r16, 0xA0	; 160
    354a:	f9 e0       	ldi	r31, 0x09	; 9
    354c:	1f 07       	cpc	r17, r31
    354e:	69 f4       	brne	.+26     	; 0x356a <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3550:	84 e6       	ldi	r24, 0x64	; 100
    3552:	91 e3       	ldi	r25, 0x31	; 49
    3554:	8f 8b       	std	Y+23, r24	; 0x17
    3556:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    3558:	8a e5       	ldi	r24, 0x5A	; 90
    355a:	91 e3       	ldi	r25, 0x31	; 49
    355c:	89 8f       	std	Y+25, r24	; 0x19
    355e:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3560:	80 e5       	ldi	r24, 0x50	; 80
    3562:	91 e3       	ldi	r25, 0x31	; 49
    3564:	8b 8f       	std	Y+27, r24	; 0x1b
    3566:	9c 8f       	std	Y+28, r25	; 0x1c
    3568:	20 c0       	rjmp	.+64     	; 0x35aa <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    356a:	00 3b       	cpi	r16, 0xB0	; 176
    356c:	89 e0       	ldi	r24, 0x09	; 9
    356e:	18 07       	cpc	r17, r24
    3570:	69 f4       	brne	.+26     	; 0x358c <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3572:	82 e6       	ldi	r24, 0x62	; 98
    3574:	91 e3       	ldi	r25, 0x31	; 49
    3576:	8f 8b       	std	Y+23, r24	; 0x17
    3578:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    357a:	88 e5       	ldi	r24, 0x58	; 88
    357c:	91 e3       	ldi	r25, 0x31	; 49
    357e:	89 8f       	std	Y+25, r24	; 0x19
    3580:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3582:	8e e4       	ldi	r24, 0x4E	; 78
    3584:	91 e3       	ldi	r25, 0x31	; 49
    3586:	8b 8f       	std	Y+27, r24	; 0x1b
    3588:	9c 8f       	std	Y+28, r25	; 0x1c
    358a:	0f c0       	rjmp	.+30     	; 0x35aa <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    358c:	00 3a       	cpi	r16, 0xA0	; 160
    358e:	1a 40       	sbci	r17, 0x0A	; 10
    3590:	61 f4       	brne	.+24     	; 0x35aa <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3592:	80 e6       	ldi	r24, 0x60	; 96
    3594:	91 e3       	ldi	r25, 0x31	; 49
    3596:	8f 8b       	std	Y+23, r24	; 0x17
    3598:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    359a:	86 e5       	ldi	r24, 0x56	; 86
    359c:	91 e3       	ldi	r25, 0x31	; 49
    359e:	89 8f       	std	Y+25, r24	; 0x19
    35a0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    35a2:	8c e4       	ldi	r24, 0x4C	; 76
    35a4:	91 e3       	ldi	r25, 0x31	; 49
    35a6:	8b 8f       	std	Y+27, r24	; 0x1b
    35a8:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    35aa:	0f 89       	ldd	r16, Y+23	; 0x17
    35ac:	18 8d       	ldd	r17, Y+24	; 0x18
    35ae:	84 e6       	ldi	r24, 0x64	; 100
    35b0:	90 e0       	ldi	r25, 0x00	; 0
    35b2:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <_Znaj>
    35b6:	f8 01       	movw	r30, r16
    35b8:	80 83       	st	Z, r24
    35ba:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    35bc:	e9 8d       	ldd	r30, Y+25	; 0x19
    35be:	fa 8d       	ldd	r31, Y+26	; 0x1a
    35c0:	10 82       	st	Z, r1
    35c2:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    35c4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    35c6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    35c8:	10 82       	st	Z, r1
    35ca:	11 82       	std	Z+1, r1	; 0x01
}
    35cc:	df 91       	pop	r29
    35ce:	cf 91       	pop	r28
    35d0:	1f 91       	pop	r17
    35d2:	0f 91       	pop	r16
    35d4:	ff 90       	pop	r15
    35d6:	ef 90       	pop	r14
    35d8:	08 95       	ret

000035da <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    35da:	1f 92       	push	r1
    35dc:	0f 92       	push	r0
    35de:	0f b6       	in	r0, 0x3f	; 63
    35e0:	0f 92       	push	r0
    35e2:	11 24       	eor	r1, r1
    35e4:	08 b6       	in	r0, 0x38	; 56
    35e6:	0f 92       	push	r0
    35e8:	18 be       	out	0x38, r1	; 56
    35ea:	0b b6       	in	r0, 0x3b	; 59
    35ec:	0f 92       	push	r0
    35ee:	1b be       	out	0x3b, r1	; 59
    35f0:	2f 93       	push	r18
    35f2:	3f 93       	push	r19
    35f4:	8f 93       	push	r24
    35f6:	9f 93       	push	r25
    35f8:	ef 93       	push	r30
    35fa:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    35fc:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    3600:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvC0_buffer>
    3604:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvC0_buffer+0x1>
    3608:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    360c:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    3610:	e8 0f       	add	r30, r24
    3612:	f9 1f       	adc	r31, r25
    3614:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    3616:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    361a:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    361e:	01 96       	adiw	r24, 0x01	; 1
    3620:	84 36       	cpi	r24, 0x64	; 100
    3622:	91 05       	cpc	r25, r1
    3624:	60 f4       	brcc	.+24     	; 0x363e <__vector_25+0x64>
    3626:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvC0_write_index>
    362a:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    362e:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvC0_read_index>
    3632:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvC0_read_index+0x1>
    3636:	82 17       	cp	r24, r18
    3638:	93 07       	cpc	r25, r19
    363a:	f1 f4       	brne	.+60     	; 0x3678 <__vector_25+0x9e>
    363c:	0c c0       	rjmp	.+24     	; 0x3656 <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    363e:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvC0_write_index>
    3642:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3646:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvC0_read_index>
    364a:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvC0_read_index+0x1>
    364e:	18 16       	cp	r1, r24
    3650:	19 06       	cpc	r1, r25
    3652:	91 f4       	brne	.+36     	; 0x3678 <__vector_25+0x9e>
    3654:	0e c0       	rjmp	.+28     	; 0x3672 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3656:	01 96       	adiw	r24, 0x01	; 1
    3658:	84 36       	cpi	r24, 0x64	; 100
    365a:	91 05       	cpc	r25, r1
    365c:	28 f4       	brcc	.+10     	; 0x3668 <__vector_25+0x8e>
    365e:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvC0_read_index>
    3662:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvC0_read_index+0x1>
    3666:	08 c0       	rjmp	.+16     	; 0x3678 <__vector_25+0x9e>
			rcvC0_read_index = 0;
    3668:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvC0_read_index>
    366c:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvC0_read_index+0x1>
}
    3670:	03 c0       	rjmp	.+6      	; 0x3678 <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3672:	81 e0       	ldi	r24, 0x01	; 1
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	f3 cf       	rjmp	.-26     	; 0x365e <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    3678:	ff 91       	pop	r31
    367a:	ef 91       	pop	r30
    367c:	9f 91       	pop	r25
    367e:	8f 91       	pop	r24
    3680:	3f 91       	pop	r19
    3682:	2f 91       	pop	r18
    3684:	0f 90       	pop	r0
    3686:	0b be       	out	0x3b, r0	; 59
    3688:	0f 90       	pop	r0
    368a:	08 be       	out	0x38, r0	; 56
    368c:	0f 90       	pop	r0
    368e:	0f be       	out	0x3f, r0	; 63
    3690:	0f 90       	pop	r0
    3692:	1f 90       	pop	r1
    3694:	18 95       	reti

00003696 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3696:	1f 92       	push	r1
    3698:	0f 92       	push	r0
    369a:	0f b6       	in	r0, 0x3f	; 63
    369c:	0f 92       	push	r0
    369e:	11 24       	eor	r1, r1
    36a0:	08 b6       	in	r0, 0x38	; 56
    36a2:	0f 92       	push	r0
    36a4:	18 be       	out	0x38, r1	; 56
    36a6:	0b b6       	in	r0, 0x3b	; 59
    36a8:	0f 92       	push	r0
    36aa:	1b be       	out	0x3b, r1	; 59
    36ac:	2f 93       	push	r18
    36ae:	3f 93       	push	r19
    36b0:	8f 93       	push	r24
    36b2:	9f 93       	push	r25
    36b4:	ef 93       	push	r30
    36b6:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    36b8:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    36bc:	e0 91 66 31 	lds	r30, 0x3166	; 0x803166 <rcvC1_buffer>
    36c0:	f0 91 67 31 	lds	r31, 0x3167	; 0x803167 <rcvC1_buffer+0x1>
    36c4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC1_write_index>
    36c8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC1_write_index+0x1>
    36cc:	e8 0f       	add	r30, r24
    36ce:	f9 1f       	adc	r31, r25
    36d0:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    36d2:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <rcvC1_write_index>
    36d6:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <rcvC1_write_index+0x1>
    36da:	01 96       	adiw	r24, 0x01	; 1
    36dc:	84 36       	cpi	r24, 0x64	; 100
    36de:	91 05       	cpc	r25, r1
    36e0:	60 f4       	brcc	.+24     	; 0x36fa <__vector_28+0x64>
    36e2:	80 93 52 31 	sts	0x3152, r24	; 0x803152 <rcvC1_write_index>
    36e6:	90 93 53 31 	sts	0x3153, r25	; 0x803153 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    36ea:	20 91 5c 31 	lds	r18, 0x315C	; 0x80315c <rcvC1_read_index>
    36ee:	30 91 5d 31 	lds	r19, 0x315D	; 0x80315d <rcvC1_read_index+0x1>
    36f2:	82 17       	cp	r24, r18
    36f4:	93 07       	cpc	r25, r19
    36f6:	f1 f4       	brne	.+60     	; 0x3734 <__vector_28+0x9e>
    36f8:	0c c0       	rjmp	.+24     	; 0x3712 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    36fa:	10 92 52 31 	sts	0x3152, r1	; 0x803152 <rcvC1_write_index>
    36fe:	10 92 53 31 	sts	0x3153, r1	; 0x803153 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    3702:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC1_read_index>
    3706:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC1_read_index+0x1>
    370a:	18 16       	cp	r1, r24
    370c:	19 06       	cpc	r1, r25
    370e:	91 f4       	brne	.+36     	; 0x3734 <__vector_28+0x9e>
    3710:	0e c0       	rjmp	.+28     	; 0x372e <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    3712:	01 96       	adiw	r24, 0x01	; 1
    3714:	84 36       	cpi	r24, 0x64	; 100
    3716:	91 05       	cpc	r25, r1
    3718:	28 f4       	brcc	.+10     	; 0x3724 <__vector_28+0x8e>
    371a:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC1_read_index>
    371e:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC1_read_index+0x1>
    3722:	08 c0       	rjmp	.+16     	; 0x3734 <__vector_28+0x9e>
	rcvC1_read_index = 0;
    3724:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC1_read_index>
    3728:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC1_read_index+0x1>
}
    372c:	03 c0       	rjmp	.+6      	; 0x3734 <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    372e:	81 e0       	ldi	r24, 0x01	; 1
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	f3 cf       	rjmp	.-26     	; 0x371a <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    3734:	ff 91       	pop	r31
    3736:	ef 91       	pop	r30
    3738:	9f 91       	pop	r25
    373a:	8f 91       	pop	r24
    373c:	3f 91       	pop	r19
    373e:	2f 91       	pop	r18
    3740:	0f 90       	pop	r0
    3742:	0b be       	out	0x3b, r0	; 59
    3744:	0f 90       	pop	r0
    3746:	08 be       	out	0x38, r0	; 56
    3748:	0f 90       	pop	r0
    374a:	0f be       	out	0x3f, r0	; 63
    374c:	0f 90       	pop	r0
    374e:	1f 90       	pop	r1
    3750:	18 95       	reti

00003752 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3752:	1f 92       	push	r1
    3754:	0f 92       	push	r0
    3756:	0f b6       	in	r0, 0x3f	; 63
    3758:	0f 92       	push	r0
    375a:	11 24       	eor	r1, r1
    375c:	08 b6       	in	r0, 0x38	; 56
    375e:	0f 92       	push	r0
    3760:	18 be       	out	0x38, r1	; 56
    3762:	0b b6       	in	r0, 0x3b	; 59
    3764:	0f 92       	push	r0
    3766:	1b be       	out	0x3b, r1	; 59
    3768:	2f 93       	push	r18
    376a:	3f 93       	push	r19
    376c:	8f 93       	push	r24
    376e:	9f 93       	push	r25
    3770:	ef 93       	push	r30
    3772:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    3774:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    3778:	e0 91 64 31 	lds	r30, 0x3164	; 0x803164 <rcvD0_buffer>
    377c:	f0 91 65 31 	lds	r31, 0x3165	; 0x803165 <rcvD0_buffer+0x1>
    3780:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvC0_write_index>
    3784:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvC0_write_index+0x1>
    3788:	e8 0f       	add	r30, r24
    378a:	f9 1f       	adc	r31, r25
    378c:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    378e:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <rcvD0_write_index>
    3792:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <rcvD0_write_index+0x1>
    3796:	01 96       	adiw	r24, 0x01	; 1
    3798:	84 36       	cpi	r24, 0x64	; 100
    379a:	91 05       	cpc	r25, r1
    379c:	60 f4       	brcc	.+24     	; 0x37b6 <__vector_88+0x64>
    379e:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <rcvD0_write_index>
    37a2:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    37a6:	20 91 5a 31 	lds	r18, 0x315A	; 0x80315a <rcvD0_read_index>
    37aa:	30 91 5b 31 	lds	r19, 0x315B	; 0x80315b <rcvD0_read_index+0x1>
    37ae:	82 17       	cp	r24, r18
    37b0:	93 07       	cpc	r25, r19
    37b2:	f1 f4       	brne	.+60     	; 0x37f0 <__vector_88+0x9e>
    37b4:	0c c0       	rjmp	.+24     	; 0x37ce <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    37b6:	10 92 50 31 	sts	0x3150, r1	; 0x803150 <rcvD0_write_index>
    37ba:	10 92 51 31 	sts	0x3151, r1	; 0x803151 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    37be:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvD0_read_index>
    37c2:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvD0_read_index+0x1>
    37c6:	18 16       	cp	r1, r24
    37c8:	19 06       	cpc	r1, r25
    37ca:	91 f4       	brne	.+36     	; 0x37f0 <__vector_88+0x9e>
    37cc:	0e c0       	rjmp	.+28     	; 0x37ea <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    37ce:	01 96       	adiw	r24, 0x01	; 1
    37d0:	84 36       	cpi	r24, 0x64	; 100
    37d2:	91 05       	cpc	r25, r1
    37d4:	28 f4       	brcc	.+10     	; 0x37e0 <__vector_88+0x8e>
    37d6:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvD0_read_index>
    37da:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvD0_read_index+0x1>
    37de:	08 c0       	rjmp	.+16     	; 0x37f0 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    37e0:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvD0_read_index>
    37e4:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvD0_read_index+0x1>
}
    37e8:	03 c0       	rjmp	.+6      	; 0x37f0 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    37ea:	81 e0       	ldi	r24, 0x01	; 1
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	f3 cf       	rjmp	.-26     	; 0x37d6 <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    37f0:	ff 91       	pop	r31
    37f2:	ef 91       	pop	r30
    37f4:	9f 91       	pop	r25
    37f6:	8f 91       	pop	r24
    37f8:	3f 91       	pop	r19
    37fa:	2f 91       	pop	r18
    37fc:	0f 90       	pop	r0
    37fe:	0b be       	out	0x3b, r0	; 59
    3800:	0f 90       	pop	r0
    3802:	08 be       	out	0x38, r0	; 56
    3804:	0f 90       	pop	r0
    3806:	0f be       	out	0x3f, r0	; 63
    3808:	0f 90       	pop	r0
    380a:	1f 90       	pop	r1
    380c:	18 95       	reti

0000380e <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    380e:	1f 92       	push	r1
    3810:	0f 92       	push	r0
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	0f 92       	push	r0
    3816:	11 24       	eor	r1, r1
    3818:	08 b6       	in	r0, 0x38	; 56
    381a:	0f 92       	push	r0
    381c:	18 be       	out	0x38, r1	; 56
    381e:	0b b6       	in	r0, 0x3b	; 59
    3820:	0f 92       	push	r0
    3822:	1b be       	out	0x3b, r1	; 59
    3824:	2f 93       	push	r18
    3826:	3f 93       	push	r19
    3828:	8f 93       	push	r24
    382a:	9f 93       	push	r25
    382c:	ef 93       	push	r30
    382e:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    3830:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    3834:	e0 91 62 31 	lds	r30, 0x3162	; 0x803162 <rcvD1_buffer>
    3838:	f0 91 63 31 	lds	r31, 0x3163	; 0x803163 <rcvD1_buffer+0x1>
    383c:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD1_write_index>
    3840:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD1_write_index+0x1>
    3844:	e8 0f       	add	r30, r24
    3846:	f9 1f       	adc	r31, r25
    3848:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    384a:	80 91 4e 31 	lds	r24, 0x314E	; 0x80314e <rcvD1_write_index>
    384e:	90 91 4f 31 	lds	r25, 0x314F	; 0x80314f <rcvD1_write_index+0x1>
    3852:	01 96       	adiw	r24, 0x01	; 1
    3854:	84 36       	cpi	r24, 0x64	; 100
    3856:	91 05       	cpc	r25, r1
    3858:	60 f4       	brcc	.+24     	; 0x3872 <__vector_91+0x64>
    385a:	80 93 4e 31 	sts	0x314E, r24	; 0x80314e <rcvD1_write_index>
    385e:	90 93 4f 31 	sts	0x314F, r25	; 0x80314f <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3862:	20 91 58 31 	lds	r18, 0x3158	; 0x803158 <rcvD1_read_index>
    3866:	30 91 59 31 	lds	r19, 0x3159	; 0x803159 <rcvD1_read_index+0x1>
    386a:	82 17       	cp	r24, r18
    386c:	93 07       	cpc	r25, r19
    386e:	f1 f4       	brne	.+60     	; 0x38ac <__vector_91+0x9e>
    3870:	0c c0       	rjmp	.+24     	; 0x388a <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3872:	10 92 4e 31 	sts	0x314E, r1	; 0x80314e <rcvD1_write_index>
    3876:	10 92 4f 31 	sts	0x314F, r1	; 0x80314f <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    387a:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD1_read_index>
    387e:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD1_read_index+0x1>
    3882:	18 16       	cp	r1, r24
    3884:	19 06       	cpc	r1, r25
    3886:	91 f4       	brne	.+36     	; 0x38ac <__vector_91+0x9e>
    3888:	0e c0       	rjmp	.+28     	; 0x38a6 <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    388a:	01 96       	adiw	r24, 0x01	; 1
    388c:	84 36       	cpi	r24, 0x64	; 100
    388e:	91 05       	cpc	r25, r1
    3890:	28 f4       	brcc	.+10     	; 0x389c <__vector_91+0x8e>
    3892:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD1_read_index>
    3896:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD1_read_index+0x1>
    389a:	08 c0       	rjmp	.+16     	; 0x38ac <__vector_91+0x9e>
	rcvD1_read_index = 0;
    389c:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD1_read_index>
    38a0:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD1_read_index+0x1>
}
    38a4:	03 c0       	rjmp	.+6      	; 0x38ac <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    38a6:	81 e0       	ldi	r24, 0x01	; 1
    38a8:	90 e0       	ldi	r25, 0x00	; 0
    38aa:	f3 cf       	rjmp	.-26     	; 0x3892 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    38ac:	ff 91       	pop	r31
    38ae:	ef 91       	pop	r30
    38b0:	9f 91       	pop	r25
    38b2:	8f 91       	pop	r24
    38b4:	3f 91       	pop	r19
    38b6:	2f 91       	pop	r18
    38b8:	0f 90       	pop	r0
    38ba:	0b be       	out	0x3b, r0	; 59
    38bc:	0f 90       	pop	r0
    38be:	08 be       	out	0x38, r0	; 56
    38c0:	0f 90       	pop	r0
    38c2:	0f be       	out	0x3f, r0	; 63
    38c4:	0f 90       	pop	r0
    38c6:	1f 90       	pop	r1
    38c8:	18 95       	reti

000038ca <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    38ca:	1f 92       	push	r1
    38cc:	0f 92       	push	r0
    38ce:	0f b6       	in	r0, 0x3f	; 63
    38d0:	0f 92       	push	r0
    38d2:	11 24       	eor	r1, r1
    38d4:	08 b6       	in	r0, 0x38	; 56
    38d6:	0f 92       	push	r0
    38d8:	18 be       	out	0x38, r1	; 56
    38da:	0b b6       	in	r0, 0x3b	; 59
    38dc:	0f 92       	push	r0
    38de:	1b be       	out	0x3b, r1	; 59
    38e0:	2f 93       	push	r18
    38e2:	3f 93       	push	r19
    38e4:	8f 93       	push	r24
    38e6:	9f 93       	push	r25
    38e8:	ef 93       	push	r30
    38ea:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    38ec:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    38f0:	e0 91 60 31 	lds	r30, 0x3160	; 0x803160 <rcvE0_buffer>
    38f4:	f0 91 61 31 	lds	r31, 0x3161	; 0x803161 <rcvE0_buffer+0x1>
    38f8:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvE0_write_index>
    38fc:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvE0_write_index+0x1>
    3900:	e8 0f       	add	r30, r24
    3902:	f9 1f       	adc	r31, r25
    3904:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3906:	80 91 4c 31 	lds	r24, 0x314C	; 0x80314c <rcvE0_write_index>
    390a:	90 91 4d 31 	lds	r25, 0x314D	; 0x80314d <rcvE0_write_index+0x1>
    390e:	01 96       	adiw	r24, 0x01	; 1
    3910:	84 36       	cpi	r24, 0x64	; 100
    3912:	91 05       	cpc	r25, r1
    3914:	60 f4       	brcc	.+24     	; 0x392e <__vector_58+0x64>
    3916:	80 93 4c 31 	sts	0x314C, r24	; 0x80314c <rcvE0_write_index>
    391a:	90 93 4d 31 	sts	0x314D, r25	; 0x80314d <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    391e:	20 91 56 31 	lds	r18, 0x3156	; 0x803156 <rcvE0_read_index>
    3922:	30 91 57 31 	lds	r19, 0x3157	; 0x803157 <rcvE0_read_index+0x1>
    3926:	82 17       	cp	r24, r18
    3928:	93 07       	cpc	r25, r19
    392a:	f1 f4       	brne	.+60     	; 0x3968 <__vector_58+0x9e>
    392c:	0c c0       	rjmp	.+24     	; 0x3946 <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    392e:	10 92 4c 31 	sts	0x314C, r1	; 0x80314c <rcvE0_write_index>
    3932:	10 92 4d 31 	sts	0x314D, r1	; 0x80314d <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    3936:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvE0_read_index>
    393a:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvE0_read_index+0x1>
    393e:	18 16       	cp	r1, r24
    3940:	19 06       	cpc	r1, r25
    3942:	91 f4       	brne	.+36     	; 0x3968 <__vector_58+0x9e>
    3944:	0e c0       	rjmp	.+28     	; 0x3962 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3946:	01 96       	adiw	r24, 0x01	; 1
    3948:	84 36       	cpi	r24, 0x64	; 100
    394a:	91 05       	cpc	r25, r1
    394c:	28 f4       	brcc	.+10     	; 0x3958 <__vector_58+0x8e>
    394e:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvE0_read_index>
    3952:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvE0_read_index+0x1>
    3956:	08 c0       	rjmp	.+16     	; 0x3968 <__vector_58+0x9e>
	rcvE0_read_index = 0;
    3958:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvE0_read_index>
    395c:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvE0_read_index+0x1>
}
    3960:	03 c0       	rjmp	.+6      	; 0x3968 <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3962:	81 e0       	ldi	r24, 0x01	; 1
    3964:	90 e0       	ldi	r25, 0x00	; 0
    3966:	f3 cf       	rjmp	.-26     	; 0x394e <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    3968:	ff 91       	pop	r31
    396a:	ef 91       	pop	r30
    396c:	9f 91       	pop	r25
    396e:	8f 91       	pop	r24
    3970:	3f 91       	pop	r19
    3972:	2f 91       	pop	r18
    3974:	0f 90       	pop	r0
    3976:	0b be       	out	0x3b, r0	; 59
    3978:	0f 90       	pop	r0
    397a:	08 be       	out	0x38, r0	; 56
    397c:	0f 90       	pop	r0
    397e:	0f be       	out	0x3f, r0	; 63
    3980:	0f 90       	pop	r0
    3982:	1f 90       	pop	r1
    3984:	18 95       	reti

00003986 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    3986:	fc 01       	movw	r30, r24
    3988:	84 81       	ldd	r24, Z+4	; 0x04
    398a:	95 81       	ldd	r25, Z+5	; 0x05
    398c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
		}
    3990:	90 e0       	ldi	r25, 0x00	; 0
    3992:	08 95       	ret

00003994 <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3994:	fc 01       	movw	r30, r24
    3996:	84 81       	ldd	r24, Z+4	; 0x04
    3998:	95 81       	ldd	r25, Z+5	; 0x05
    399a:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
    399e:	91 e0       	ldi	r25, 0x01	; 1
    39a0:	81 11       	cpse	r24, r1
    39a2:	01 c0       	rjmp	.+2      	; 0x39a6 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    39a4:	90 e0       	ldi	r25, 0x00	; 0
		}
    39a6:	89 2f       	mov	r24, r25
    39a8:	08 95       	ret

000039aa <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    39aa:	fc 01       	movw	r30, r24
    39ac:	84 81       	ldd	r24, Z+4	; 0x04
    39ae:	95 81       	ldd	r25, Z+5	; 0x05
    39b0:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
    39b4:	91 e0       	ldi	r25, 0x01	; 1
    39b6:	81 11       	cpse	r24, r1
    39b8:	90 e0       	ldi	r25, 0x00	; 0
		}
    39ba:	89 2f       	mov	r24, r25
    39bc:	08 95       	ret

000039be <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    39be:	fc 01       	movw	r30, r24
    39c0:	84 81       	ldd	r24, Z+4	; 0x04
    39c2:	95 81       	ldd	r25, Z+5	; 0x05
    39c4:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
		}
    39c8:	90 e0       	ldi	r25, 0x00	; 0
    39ca:	08 95       	ret

000039cc <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    39cc:	fc 01       	movw	r30, r24
    39ce:	84 81       	ldd	r24, Z+4	; 0x04
    39d0:	95 81       	ldd	r25, Z+5	; 0x05
    39d2:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
    39d6:	91 e0       	ldi	r25, 0x01	; 1
    39d8:	81 11       	cpse	r24, r1
    39da:	01 c0       	rjmp	.+2      	; 0x39de <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    39dc:	90 e0       	ldi	r25, 0x00	; 0
		}
    39de:	89 2f       	mov	r24, r25
    39e0:	08 95       	ret

000039e2 <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    39e2:	fc 01       	movw	r30, r24
    39e4:	84 81       	ldd	r24, Z+4	; 0x04
    39e6:	95 81       	ldd	r25, Z+5	; 0x05
    39e8:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <uxQueueMessagesWaitingFromISR>
    39ec:	91 e0       	ldi	r25, 0x01	; 1
    39ee:	81 11       	cpse	r24, r1
    39f0:	90 e0       	ldi	r25, 0x00	; 0
		}
    39f2:	89 2f       	mov	r24, r25
    39f4:	08 95       	ret

000039f6 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    39f6:	fc 01       	movw	r30, r24
    39f8:	84 81       	ldd	r24, Z+4	; 0x04
    39fa:	95 81       	ldd	r25, Z+5	; 0x05
    39fc:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
		}
    3a00:	90 e0       	ldi	r25, 0x00	; 0
    3a02:	08 95       	ret

00003a04 <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3a04:	fc 01       	movw	r30, r24
    3a06:	84 81       	ldd	r24, Z+4	; 0x04
    3a08:	95 81       	ldd	r25, Z+5	; 0x05
    3a0a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
    3a0e:	91 e0       	ldi	r25, 0x01	; 1
    3a10:	81 11       	cpse	r24, r1
    3a12:	01 c0       	rjmp	.+2      	; 0x3a16 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    3a14:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a16:	89 2f       	mov	r24, r25
    3a18:	08 95       	ret

00003a1a <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3a1a:	fc 01       	movw	r30, r24
    3a1c:	84 81       	ldd	r24, Z+4	; 0x04
    3a1e:	95 81       	ldd	r25, Z+5	; 0x05
    3a20:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
    3a24:	91 e0       	ldi	r25, 0x01	; 1
    3a26:	81 11       	cpse	r24, r1
    3a28:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a2a:	89 2f       	mov	r24, r25
    3a2c:	08 95       	ret

00003a2e <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3a2e:	fc 01       	movw	r30, r24
    3a30:	84 81       	ldd	r24, Z+4	; 0x04
    3a32:	95 81       	ldd	r25, Z+5	; 0x05
    3a34:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
		}
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	08 95       	ret

00003a3c <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3a3c:	fc 01       	movw	r30, r24
    3a3e:	84 81       	ldd	r24, Z+4	; 0x04
    3a40:	95 81       	ldd	r25, Z+5	; 0x05
    3a42:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
    3a46:	91 e0       	ldi	r25, 0x01	; 1
    3a48:	81 11       	cpse	r24, r1
    3a4a:	01 c0       	rjmp	.+2      	; 0x3a4e <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a4e:	89 2f       	mov	r24, r25
    3a50:	08 95       	ret

00003a52 <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3a52:	fc 01       	movw	r30, r24
    3a54:	84 81       	ldd	r24, Z+4	; 0x04
    3a56:	95 81       	ldd	r25, Z+5	; 0x05
    3a58:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <uxQueueMessagesWaiting>
    3a5c:	91 e0       	ldi	r25, 0x01	; 1
    3a5e:	81 11       	cpse	r24, r1
    3a60:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a62:	89 2f       	mov	r24, r25
    3a64:	08 95       	ret

00003a66 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3a66:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3a68:	01 e0       	ldi	r16, 0x01	; 1
    3a6a:	2f ef       	ldi	r18, 0xFF	; 255
    3a6c:	3f ef       	ldi	r19, 0xFF	; 255
    3a6e:	a9 01       	movw	r20, r18
    3a70:	fc 01       	movw	r30, r24
    3a72:	84 81       	ldd	r24, Z+4	; 0x04
    3a74:	95 81       	ldd	r25, Z+5	; 0x05
    3a76:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
}
    3a7a:	0f 91       	pop	r16
    3a7c:	08 95       	ret

00003a7e <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3a7e:	0f 93       	push	r16
    3a80:	cf 93       	push	r28
    3a82:	df 93       	push	r29
    3a84:	1f 92       	push	r1
    3a86:	1f 92       	push	r1
    3a88:	cd b7       	in	r28, 0x3d	; 61
    3a8a:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3a8c:	01 e0       	ldi	r16, 0x01	; 1
    3a8e:	2f ef       	ldi	r18, 0xFF	; 255
    3a90:	3f ef       	ldi	r19, 0xFF	; 255
    3a92:	a9 01       	movw	r20, r18
    3a94:	be 01       	movw	r22, r28
    3a96:	6f 5f       	subi	r22, 0xFF	; 255
    3a98:	7f 4f       	sbci	r23, 0xFF	; 255
    3a9a:	fc 01       	movw	r30, r24
    3a9c:	84 81       	ldd	r24, Z+4	; 0x04
    3a9e:	95 81       	ldd	r25, Z+5	; 0x05
    3aa0:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
	return (recv_item);
}
    3aa4:	89 81       	ldd	r24, Y+1	; 0x01
    3aa6:	9a 81       	ldd	r25, Y+2	; 0x02
    3aa8:	0f 90       	pop	r0
    3aaa:	0f 90       	pop	r0
    3aac:	df 91       	pop	r29
    3aae:	cf 91       	pop	r28
    3ab0:	0f 91       	pop	r16
    3ab2:	08 95       	ret

00003ab4 <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3ab4:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3ab6:	00 e0       	ldi	r16, 0x00	; 0
    3ab8:	2f ef       	ldi	r18, 0xFF	; 255
    3aba:	3f ef       	ldi	r19, 0xFF	; 255
    3abc:	a9 01       	movw	r20, r18
    3abe:	fc 01       	movw	r30, r24
    3ac0:	84 81       	ldd	r24, Z+4	; 0x04
    3ac2:	95 81       	ldd	r25, Z+5	; 0x05
    3ac4:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
}
    3ac8:	0f 91       	pop	r16
    3aca:	08 95       	ret

00003acc <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3acc:	0f 93       	push	r16
    3ace:	cf 93       	push	r28
    3ad0:	df 93       	push	r29
    3ad2:	1f 92       	push	r1
    3ad4:	1f 92       	push	r1
    3ad6:	cd b7       	in	r28, 0x3d	; 61
    3ad8:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3ada:	00 e0       	ldi	r16, 0x00	; 0
    3adc:	2f ef       	ldi	r18, 0xFF	; 255
    3ade:	3f ef       	ldi	r19, 0xFF	; 255
    3ae0:	a9 01       	movw	r20, r18
    3ae2:	be 01       	movw	r22, r28
    3ae4:	6f 5f       	subi	r22, 0xFF	; 255
    3ae6:	7f 4f       	sbci	r23, 0xFF	; 255
    3ae8:	fc 01       	movw	r30, r24
    3aea:	84 81       	ldd	r24, Z+4	; 0x04
    3aec:	95 81       	ldd	r25, Z+5	; 0x05
    3aee:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
	return (recv_item);
}
    3af2:	89 81       	ldd	r24, Y+1	; 0x01
    3af4:	9a 81       	ldd	r25, Y+2	; 0x02
    3af6:	0f 90       	pop	r0
    3af8:	0f 90       	pop	r0
    3afa:	df 91       	pop	r29
    3afc:	cf 91       	pop	r28
    3afe:	0f 91       	pop	r16
    3b00:	08 95       	ret

00003b02 <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    3b02:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    3b04:	01 e0       	ldi	r16, 0x01	; 1
    3b06:	2f ef       	ldi	r18, 0xFF	; 255
    3b08:	3f ef       	ldi	r19, 0xFF	; 255
    3b0a:	a9 01       	movw	r20, r18
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	84 81       	ldd	r24, Z+4	; 0x04
    3b10:	95 81       	ldd	r25, Z+5	; 0x05
    3b12:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
}
    3b16:	0f 91       	pop	r16
    3b18:	08 95       	ret

00003b1a <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3b1a:	0f 93       	push	r16
    3b1c:	cf 93       	push	r28
    3b1e:	df 93       	push	r29
    3b20:	1f 92       	push	r1
    3b22:	1f 92       	push	r1
    3b24:	cd b7       	in	r28, 0x3d	; 61
    3b26:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3b28:	01 e0       	ldi	r16, 0x01	; 1
    3b2a:	2f ef       	ldi	r18, 0xFF	; 255
    3b2c:	3f ef       	ldi	r19, 0xFF	; 255
    3b2e:	a9 01       	movw	r20, r18
    3b30:	be 01       	movw	r22, r28
    3b32:	6f 5f       	subi	r22, 0xFF	; 255
    3b34:	7f 4f       	sbci	r23, 0xFF	; 255
    3b36:	fc 01       	movw	r30, r24
    3b38:	84 81       	ldd	r24, Z+4	; 0x04
    3b3a:	95 81       	ldd	r25, Z+5	; 0x05
    3b3c:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
	return (recv_item);
}
    3b40:	89 81       	ldd	r24, Y+1	; 0x01
    3b42:	9a 81       	ldd	r25, Y+2	; 0x02
    3b44:	0f 90       	pop	r0
    3b46:	0f 90       	pop	r0
    3b48:	df 91       	pop	r29
    3b4a:	cf 91       	pop	r28
    3b4c:	0f 91       	pop	r16
    3b4e:	08 95       	ret

00003b50 <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    3b50:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    3b52:	00 e0       	ldi	r16, 0x00	; 0
    3b54:	2f ef       	ldi	r18, 0xFF	; 255
    3b56:	3f ef       	ldi	r19, 0xFF	; 255
    3b58:	a9 01       	movw	r20, r18
    3b5a:	fc 01       	movw	r30, r24
    3b5c:	84 81       	ldd	r24, Z+4	; 0x04
    3b5e:	95 81       	ldd	r25, Z+5	; 0x05
    3b60:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
}
    3b64:	0f 91       	pop	r16
    3b66:	08 95       	ret

00003b68 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3b68:	0f 93       	push	r16
    3b6a:	cf 93       	push	r28
    3b6c:	df 93       	push	r29
    3b6e:	1f 92       	push	r1
    3b70:	1f 92       	push	r1
    3b72:	cd b7       	in	r28, 0x3d	; 61
    3b74:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3b76:	00 e0       	ldi	r16, 0x00	; 0
    3b78:	2f ef       	ldi	r18, 0xFF	; 255
    3b7a:	3f ef       	ldi	r19, 0xFF	; 255
    3b7c:	a9 01       	movw	r20, r18
    3b7e:	be 01       	movw	r22, r28
    3b80:	6f 5f       	subi	r22, 0xFF	; 255
    3b82:	7f 4f       	sbci	r23, 0xFF	; 255
    3b84:	fc 01       	movw	r30, r24
    3b86:	84 81       	ldd	r24, Z+4	; 0x04
    3b88:	95 81       	ldd	r25, Z+5	; 0x05
    3b8a:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <xQueueGenericReceive>
	return (recv_item);
}
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
    3b90:	9a 81       	ldd	r25, Y+2	; 0x02
    3b92:	0f 90       	pop	r0
    3b94:	0f 90       	pop	r0
    3b96:	df 91       	pop	r29
    3b98:	cf 91       	pop	r28
    3b9a:	0f 91       	pop	r16
    3b9c:	08 95       	ret

00003b9e <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
    3ba2:	1f 92       	push	r1
    3ba4:	cd b7       	in	r28, 0x3d	; 61
    3ba6:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3ba8:	ae 01       	movw	r20, r28
    3baa:	4f 5f       	subi	r20, 0xFF	; 255
    3bac:	5f 4f       	sbci	r21, 0xFF	; 255
    3bae:	fc 01       	movw	r30, r24
    3bb0:	84 81       	ldd	r24, Z+4	; 0x04
    3bb2:	95 81       	ldd	r25, Z+5	; 0x05
    3bb4:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueReceiveFromISR>
}
    3bb8:	0f 90       	pop	r0
    3bba:	df 91       	pop	r29
    3bbc:	cf 91       	pop	r28
    3bbe:	08 95       	ret

00003bc0 <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3bc0:	cf 93       	push	r28
    3bc2:	df 93       	push	r29
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3bc6:	cd b7       	in	r28, 0x3d	; 61
    3bc8:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3bca:	ae 01       	movw	r20, r28
    3bcc:	4d 5f       	subi	r20, 0xFD	; 253
    3bce:	5f 4f       	sbci	r21, 0xFF	; 255
    3bd0:	be 01       	movw	r22, r28
    3bd2:	6f 5f       	subi	r22, 0xFF	; 255
    3bd4:	7f 4f       	sbci	r23, 0xFF	; 255
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	84 81       	ldd	r24, Z+4	; 0x04
    3bda:	95 81       	ldd	r25, Z+5	; 0x05
    3bdc:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueReceiveFromISR>
	return (recv_item);
}
    3be0:	89 81       	ldd	r24, Y+1	; 0x01
    3be2:	9a 81       	ldd	r25, Y+2	; 0x02
    3be4:	23 96       	adiw	r28, 0x03	; 3
    3be6:	cd bf       	out	0x3d, r28	; 61
    3be8:	de bf       	out	0x3e, r29	; 62
    3bea:	df 91       	pop	r29
    3bec:	cf 91       	pop	r28
    3bee:	08 95       	ret

00003bf0 <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    3bf0:	cf 93       	push	r28
    3bf2:	df 93       	push	r29
    3bf4:	1f 92       	push	r1
    3bf6:	cd b7       	in	r28, 0x3d	; 61
    3bf8:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3bfa:	ae 01       	movw	r20, r28
    3bfc:	4f 5f       	subi	r20, 0xFF	; 255
    3bfe:	5f 4f       	sbci	r21, 0xFF	; 255
    3c00:	fc 01       	movw	r30, r24
    3c02:	84 81       	ldd	r24, Z+4	; 0x04
    3c04:	95 81       	ldd	r25, Z+5	; 0x05
    3c06:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueReceiveFromISR>
}
    3c0a:	0f 90       	pop	r0
    3c0c:	df 91       	pop	r29
    3c0e:	cf 91       	pop	r28
    3c10:	08 95       	ret

00003c12 <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    3c12:	cf 93       	push	r28
    3c14:	df 93       	push	r29
    3c16:	00 d0       	rcall	.+0      	; 0x3c18 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3c18:	cd b7       	in	r28, 0x3d	; 61
    3c1a:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3c1c:	ae 01       	movw	r20, r28
    3c1e:	4d 5f       	subi	r20, 0xFD	; 253
    3c20:	5f 4f       	sbci	r21, 0xFF	; 255
    3c22:	be 01       	movw	r22, r28
    3c24:	6f 5f       	subi	r22, 0xFF	; 255
    3c26:	7f 4f       	sbci	r23, 0xFF	; 255
    3c28:	fc 01       	movw	r30, r24
    3c2a:	84 81       	ldd	r24, Z+4	; 0x04
    3c2c:	95 81       	ldd	r25, Z+5	; 0x05
    3c2e:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueReceiveFromISR>
	return (recv_item);
}
    3c32:	89 81       	ldd	r24, Y+1	; 0x01
    3c34:	9a 81       	ldd	r25, Y+2	; 0x02
    3c36:	23 96       	adiw	r28, 0x03	; 3
    3c38:	cd bf       	out	0x3d, r28	; 61
    3c3a:	de bf       	out	0x3e, r29	; 62
    3c3c:	df 91       	pop	r29
    3c3e:	cf 91       	pop	r28
    3c40:	08 95       	ret

00003c42 <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3c42:	cf 93       	push	r28
    3c44:	df 93       	push	r29
    3c46:	1f 92       	push	r1
    3c48:	cd b7       	in	r28, 0x3d	; 61
    3c4a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c4c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3c4e:	21 e0       	ldi	r18, 0x01	; 1
    3c50:	ae 01       	movw	r20, r28
    3c52:	4f 5f       	subi	r20, 0xFF	; 255
    3c54:	5f 4f       	sbci	r21, 0xFF	; 255
    3c56:	fc 01       	movw	r30, r24
    3c58:	84 81       	ldd	r24, Z+4	; 0x04
    3c5a:	95 81       	ldd	r25, Z+5	; 0x05
    3c5c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c60:	91 e0       	ldi	r25, 0x01	; 1
    3c62:	81 11       	cpse	r24, r1
    3c64:	01 c0       	rjmp	.+2      	; 0x3c68 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    3c66:	90 e0       	ldi	r25, 0x00	; 0
}
    3c68:	89 2f       	mov	r24, r25
    3c6a:	0f 90       	pop	r0
    3c6c:	df 91       	pop	r29
    3c6e:	cf 91       	pop	r28
    3c70:	08 95       	ret

00003c72 <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3c72:	cf 93       	push	r28
    3c74:	df 93       	push	r29
    3c76:	1f 92       	push	r1
    3c78:	cd b7       	in	r28, 0x3d	; 61
    3c7a:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3c7c:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3c7e:	20 e0       	ldi	r18, 0x00	; 0
    3c80:	ae 01       	movw	r20, r28
    3c82:	4f 5f       	subi	r20, 0xFF	; 255
    3c84:	5f 4f       	sbci	r21, 0xFF	; 255
    3c86:	fc 01       	movw	r30, r24
    3c88:	84 81       	ldd	r24, Z+4	; 0x04
    3c8a:	95 81       	ldd	r25, Z+5	; 0x05
    3c8c:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3c90:	91 e0       	ldi	r25, 0x01	; 1
    3c92:	81 11       	cpse	r24, r1
    3c94:	01 c0       	rjmp	.+2      	; 0x3c98 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    3c96:	90 e0       	ldi	r25, 0x00	; 0
}
    3c98:	89 2f       	mov	r24, r25
    3c9a:	0f 90       	pop	r0
    3c9c:	df 91       	pop	r29
    3c9e:	cf 91       	pop	r28
    3ca0:	08 95       	ret

00003ca2 <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    3ca2:	cf 93       	push	r28
    3ca4:	df 93       	push	r29
    3ca6:	1f 92       	push	r1
    3ca8:	cd b7       	in	r28, 0x3d	; 61
    3caa:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3cac:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3cae:	21 e0       	ldi	r18, 0x01	; 1
    3cb0:	ae 01       	movw	r20, r28
    3cb2:	4f 5f       	subi	r20, 0xFF	; 255
    3cb4:	5f 4f       	sbci	r21, 0xFF	; 255
    3cb6:	fc 01       	movw	r30, r24
    3cb8:	84 81       	ldd	r24, Z+4	; 0x04
    3cba:	95 81       	ldd	r25, Z+5	; 0x05
    3cbc:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3cc0:	91 e0       	ldi	r25, 0x01	; 1
    3cc2:	81 11       	cpse	r24, r1
    3cc4:	01 c0       	rjmp	.+2      	; 0x3cc8 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3cc6:	90 e0       	ldi	r25, 0x00	; 0
}
    3cc8:	89 2f       	mov	r24, r25
    3cca:	0f 90       	pop	r0
    3ccc:	df 91       	pop	r29
    3cce:	cf 91       	pop	r28
    3cd0:	08 95       	ret

00003cd2 <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	1f 92       	push	r1
    3cd8:	cd b7       	in	r28, 0x3d	; 61
    3cda:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3cdc:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3cde:	20 e0       	ldi	r18, 0x00	; 0
    3ce0:	ae 01       	movw	r20, r28
    3ce2:	4f 5f       	subi	r20, 0xFF	; 255
    3ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ce6:	fc 01       	movw	r30, r24
    3ce8:	84 81       	ldd	r24, Z+4	; 0x04
    3cea:	95 81       	ldd	r25, Z+5	; 0x05
    3cec:	0e 94 d0 0c 	call	0x19a0	; 0x19a0 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3cf0:	91 e0       	ldi	r25, 0x01	; 1
    3cf2:	81 11       	cpse	r24, r1
    3cf4:	01 c0       	rjmp	.+2      	; 0x3cf8 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
}
    3cf8:	89 2f       	mov	r24, r25
    3cfa:	0f 90       	pop	r0
    3cfc:	df 91       	pop	r29
    3cfe:	cf 91       	pop	r28
    3d00:	08 95       	ret

00003d02 <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3d02:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3d04:	fc 01       	movw	r30, r24
    3d06:	26 81       	ldd	r18, Z+6	; 0x06
    3d08:	37 81       	ldd	r19, Z+7	; 0x07
    3d0a:	40 85       	ldd	r20, Z+8	; 0x08
    3d0c:	51 85       	ldd	r21, Z+9	; 0x09
    3d0e:	01 e0       	ldi	r16, 0x01	; 1
    3d10:	84 81       	ldd	r24, Z+4	; 0x04
    3d12:	95 81       	ldd	r25, Z+5	; 0x05
    3d14:	0e 94 35 0c 	call	0x186a	; 0x186a <xQueueGenericSend>
    3d18:	91 e0       	ldi	r25, 0x01	; 1
    3d1a:	81 11       	cpse	r24, r1
    3d1c:	01 c0       	rjmp	.+2      	; 0x3d20 <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3d1e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d20:	89 2f       	mov	r24, r25
    3d22:	0f 91       	pop	r16
    3d24:	08 95       	ret

00003d26 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3d26:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3d28:	fc 01       	movw	r30, r24
    3d2a:	26 81       	ldd	r18, Z+6	; 0x06
    3d2c:	37 81       	ldd	r19, Z+7	; 0x07
    3d2e:	40 85       	ldd	r20, Z+8	; 0x08
    3d30:	51 85       	ldd	r21, Z+9	; 0x09
    3d32:	00 e0       	ldi	r16, 0x00	; 0
    3d34:	84 81       	ldd	r24, Z+4	; 0x04
    3d36:	95 81       	ldd	r25, Z+5	; 0x05
    3d38:	0e 94 35 0c 	call	0x186a	; 0x186a <xQueueGenericSend>
    3d3c:	91 e0       	ldi	r25, 0x01	; 1
    3d3e:	81 11       	cpse	r24, r1
    3d40:	01 c0       	rjmp	.+2      	; 0x3d44 <_ZN9frt_queueIjE3putERKj+0x1e>
    3d42:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d44:	89 2f       	mov	r24, r25
    3d46:	0f 91       	pop	r16
    3d48:	08 95       	ret

00003d4a <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3d4a:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3d4c:	fc 01       	movw	r30, r24
    3d4e:	26 81       	ldd	r18, Z+6	; 0x06
    3d50:	37 81       	ldd	r19, Z+7	; 0x07
    3d52:	40 85       	ldd	r20, Z+8	; 0x08
    3d54:	51 85       	ldd	r21, Z+9	; 0x09
    3d56:	01 e0       	ldi	r16, 0x01	; 1
    3d58:	84 81       	ldd	r24, Z+4	; 0x04
    3d5a:	95 81       	ldd	r25, Z+5	; 0x05
    3d5c:	0e 94 35 0c 	call	0x186a	; 0x186a <xQueueGenericSend>
    3d60:	91 e0       	ldi	r25, 0x01	; 1
    3d62:	81 11       	cpse	r24, r1
    3d64:	01 c0       	rjmp	.+2      	; 0x3d68 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3d66:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d68:	89 2f       	mov	r24, r25
    3d6a:	0f 91       	pop	r16
    3d6c:	08 95       	ret

00003d6e <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3d6e:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3d70:	fc 01       	movw	r30, r24
    3d72:	26 81       	ldd	r18, Z+6	; 0x06
    3d74:	37 81       	ldd	r19, Z+7	; 0x07
    3d76:	40 85       	ldd	r20, Z+8	; 0x08
    3d78:	51 85       	ldd	r21, Z+9	; 0x09
    3d7a:	00 e0       	ldi	r16, 0x00	; 0
    3d7c:	84 81       	ldd	r24, Z+4	; 0x04
    3d7e:	95 81       	ldd	r25, Z+5	; 0x05
    3d80:	0e 94 35 0c 	call	0x186a	; 0x186a <xQueueGenericSend>
    3d84:	91 e0       	ldi	r25, 0x01	; 1
    3d86:	81 11       	cpse	r24, r1
    3d88:	01 c0       	rjmp	.+2      	; 0x3d8c <_ZN9frt_queueIiE3putERKi+0x1e>
    3d8a:	90 e0       	ldi	r25, 0x00	; 0
		}
    3d8c:	89 2f       	mov	r24, r25
    3d8e:	0f 91       	pop	r16
    3d90:	08 95       	ret

00003d92 <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3d92:	0f 93       	push	r16
    3d94:	cf 93       	push	r28
    3d96:	df 93       	push	r29
    3d98:	1f 92       	push	r1
    3d9a:	cd b7       	in	r28, 0x3d	; 61
    3d9c:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3d9e:	2f b7       	in	r18, 0x3f	; 63
    3da0:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3da2:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3da4:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3da6:	fc 01       	movw	r30, r24
    3da8:	08 ed       	ldi	r16, 0xD8	; 216
    3daa:	04 bf       	out	0x34, r16	; 52
    3dac:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3dae:	89 81       	ldd	r24, Y+1	; 0x01
    3db0:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3db2:	0f 90       	pop	r0
    3db4:	df 91       	pop	r29
    3db6:	cf 91       	pop	r28
    3db8:	0f 91       	pop	r16
    3dba:	08 95       	ret

00003dbc <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3dbc:	ef 92       	push	r14
    3dbe:	ff 92       	push	r15
    3dc0:	0f 93       	push	r16
    3dc2:	1f 93       	push	r17
    3dc4:	cf 93       	push	r28
    3dc6:	df 93       	push	r29
    3dc8:	cd b7       	in	r28, 0x3d	; 61
    3dca:	de b7       	in	r29, 0x3e	; 62
    3dcc:	ef 97       	sbiw	r28, 0x3f	; 63
    3dce:	cd bf       	out	0x3d, r28	; 61
    3dd0:	de bf       	out	0x3e, r29	; 62
	cli();
    3dd2:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3dd4:	e0 e5       	ldi	r30, 0x50	; 80
    3dd6:	f0 e0       	ldi	r31, 0x00	; 0
    3dd8:	80 81       	ld	r24, Z
    3dda:	82 60       	ori	r24, 0x02	; 2
    3ddc:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3dde:	81 81       	ldd	r24, Z+1	; 0x01
    3de0:	81 ff       	sbrs	r24, 1
    3de2:	fd cf       	rjmp	.-6      	; 0x3dde <main+0x22>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3de4:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3de8:	68 7f       	andi	r22, 0xF8	; 248
    3dea:	61 60       	ori	r22, 0x01	; 1
    3dec:	80 e4       	ldi	r24, 0x40	; 64
    3dee:	90 e0       	ldi	r25, 0x00	; 0
    3df0:	0e 94 c9 1e 	call	0x3d92	; 0x3d92 <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3df4:	e0 e5       	ldi	r30, 0x50	; 80
    3df6:	f0 e0       	ldi	r31, 0x00	; 0
    3df8:	80 81       	ld	r24, Z
    3dfa:	8e 7f       	andi	r24, 0xFE	; 254
    3dfc:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3dfe:	9d ef       	ldi	r25, 0xFD	; 253
    3e00:	88 ed       	ldi	r24, 0xD8	; 216
    3e02:	08 b6       	in	r0, 0x38	; 56
    3e04:	18 be       	out	0x38, r1	; 56
    3e06:	84 bf       	out	0x34, r24	; 52
    3e08:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3e0c:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3e0e:	40 ea       	ldi	r20, 0xA0	; 160
    3e10:	5a e0       	ldi	r21, 0x0A	; 10
    3e12:	60 e0       	ldi	r22, 0x00	; 0
    3e14:	70 e0       	ldi	r23, 0x00	; 0
    3e16:	ce 01       	movw	r24, r28
    3e18:	01 96       	adiw	r24, 0x01	; 1
    3e1a:	0e 94 6d 1a 	call	0x34da	; 0x34da <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3e1e:	67 e0       	ldi	r22, 0x07	; 7
    3e20:	ce 01       	movw	r24, r28
    3e22:	01 96       	adiw	r24, 0x01	; 1
    3e24:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    3e28:	8c 01       	movw	r16, r24
    3e2a:	6b e6       	ldi	r22, 0x6B	; 107
    3e2c:	70 e2       	ldi	r23, 0x20	; 32
    3e2e:	0e 94 93 18 	call	0x3126	; 0x3126 <_ZN8emstream4putsEPKc>
    3e32:	66 e0       	ldi	r22, 0x06	; 6
    3e34:	c8 01       	movw	r24, r16
    3e36:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
    3e3a:	66 e0       	ldi	r22, 0x06	; 6
    3e3c:	0e 94 ca 18 	call	0x3194	; 0x3194 <_ZN8emstreamlsE15ser_manipulator>
	
	I2CMaster i2c (&TWIE, 62000);
    3e40:	20 e3       	ldi	r18, 0x30	; 48
    3e42:	32 ef       	ldi	r19, 0xF2	; 242
    3e44:	40 e0       	ldi	r20, 0x00	; 0
    3e46:	50 e0       	ldi	r21, 0x00	; 0
    3e48:	60 ea       	ldi	r22, 0xA0	; 160
    3e4a:	74 e0       	ldi	r23, 0x04	; 4
    3e4c:	ce 01       	movw	r24, r28
    3e4e:	4e 96       	adiw	r24, 0x1e	; 30
    3e50:	0e 94 c3 03 	call	0x786	; 0x786 <_ZN9I2CMasterC1EP10TWI_structm>
	
	MB1202 mb1202 (&i2c);
    3e54:	be 01       	movw	r22, r28
    3e56:	62 5e       	subi	r22, 0xE2	; 226
    3e58:	7f 4f       	sbci	r23, 0xFF	; 255
    3e5a:	ce 01       	movw	r24, r28
    3e5c:	c3 96       	adiw	r24, 0x33	; 51
    3e5e:	0e 94 07 05 	call	0xa0e	; 0xa0e <_ZN6MB1202C1EP9I2CMaster>
	
	//hi = i2c.is_ready(85);
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 128, &ser_dev);
    3e62:	82 e1       	ldi	r24, 0x12	; 18
    3e64:	90 e0       	ldi	r25, 0x00	; 0
    3e66:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
    3e6a:	8e 01       	movw	r16, r28
    3e6c:	0f 5f       	subi	r16, 0xFF	; 255
    3e6e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e70:	20 e8       	ldi	r18, 0x80	; 128
    3e72:	30 e0       	ldi	r19, 0x00	; 0
    3e74:	40 e0       	ldi	r20, 0x00	; 0
    3e76:	6a e8       	ldi	r22, 0x8A	; 138
    3e78:	70 e2       	ldi	r23, 0x20	; 32
    3e7a:	0e 94 b1 05 	call	0xb62	; 0xb62 <_ZN9task_userC1EPKchjP8emstream>
	
	new task_sonar ("Sonar", task_priority (2), 128, &ser_dev, &mb1202);
    3e7e:	88 e1       	ldi	r24, 0x18	; 24
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	0e 94 df 17 	call	0x2fbe	; 0x2fbe <_Znwj>
    3e86:	9e 01       	movw	r18, r28
    3e88:	2d 5c       	subi	r18, 0xCD	; 205
    3e8a:	3f 4f       	sbci	r19, 0xFF	; 255
    3e8c:	79 01       	movw	r14, r18
    3e8e:	20 e8       	ldi	r18, 0x80	; 128
    3e90:	30 e0       	ldi	r19, 0x00	; 0
    3e92:	42 e0       	ldi	r20, 0x02	; 2
    3e94:	62 e9       	ldi	r22, 0x92	; 146
    3e96:	70 e2       	ldi	r23, 0x20	; 32
    3e98:	0e 94 94 05 	call	0xb28	; 0xb28 <_ZN10task_sonarC1EPKchjP8emstreamP6MB1202>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3e9c:	87 e0       	ldi	r24, 0x07	; 7
    3e9e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3ea2:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3ea4:	0e 94 5e 0f 	call	0x1ebc	; 0x1ebc <vTaskStartScheduler>
}
    3ea8:	80 e0       	ldi	r24, 0x00	; 0
    3eaa:	90 e0       	ldi	r25, 0x00	; 0
    3eac:	ef 96       	adiw	r28, 0x3f	; 63
    3eae:	cd bf       	out	0x3d, r28	; 61
    3eb0:	de bf       	out	0x3e, r29	; 62
    3eb2:	df 91       	pop	r29
    3eb4:	cf 91       	pop	r28
    3eb6:	1f 91       	pop	r17
    3eb8:	0f 91       	pop	r16
    3eba:	ff 90       	pop	r15
    3ebc:	ef 90       	pop	r14
    3ebe:	08 95       	ret

00003ec0 <_GLOBAL__sub_I_counter>:
    3ec0:	cf 92       	push	r12
    3ec2:	df 92       	push	r13
    3ec4:	ef 92       	push	r14
    3ec6:	ff 92       	push	r15
    3ec8:	0f 93       	push	r16
    3eca:	1f 93       	push	r17
    3ecc:	cf 93       	push	r28
    3ece:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_sonar.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    3ed0:	0a e0       	ldi	r16, 0x0A	; 10
    3ed2:	10 e0       	ldi	r17, 0x00	; 0
    3ed4:	20 e0       	ldi	r18, 0x00	; 0
    3ed6:	30 e0       	ldi	r19, 0x00	; 0
    3ed8:	40 e0       	ldi	r20, 0x00	; 0
    3eda:	50 e0       	ldi	r21, 0x00	; 0
    3edc:	60 e2       	ldi	r22, 0x20	; 32
    3ede:	70 e0       	ldi	r23, 0x00	; 0
    3ee0:	8c e9       	ldi	r24, 0x9C	; 156
    3ee2:	91 e3       	ldi	r25, 0x31	; 49
    3ee4:	0e 94 4b 16 	call	0x2c96	; 0x2c96 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    3ee8:	c2 e9       	ldi	r28, 0x92	; 146
    3eea:	d1 e3       	ldi	r29, 0x31	; 49
    3eec:	1a 82       	std	Y+2, r1	; 0x02
    3eee:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3ef0:	8c e9       	ldi	r24, 0x9C	; 156
    3ef2:	90 e2       	ldi	r25, 0x20	; 32
    3ef4:	88 83       	st	Y, r24
    3ef6:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3ef8:	40 e0       	ldi	r20, 0x00	; 0
    3efa:	62 e0       	ldi	r22, 0x02	; 2
    3efc:	8f ef       	ldi	r24, 0xFF	; 255
    3efe:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    3f02:	8c 83       	std	Y+4, r24	; 0x04
    3f04:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f06:	0f 2e       	mov	r0, r31
    3f08:	fa e0       	ldi	r31, 0x0A	; 10
    3f0a:	cf 2e       	mov	r12, r31
    3f0c:	d1 2c       	mov	r13, r1
    3f0e:	e1 2c       	mov	r14, r1
    3f10:	f1 2c       	mov	r15, r1
    3f12:	f0 2d       	mov	r31, r0
    3f14:	ce 82       	std	Y+6, r12	; 0x06
    3f16:	df 82       	std	Y+7, r13	; 0x07
    3f18:	e8 86       	std	Y+8, r14	; 0x08
    3f1a:	f9 86       	std	Y+9, r15	; 0x09
    3f1c:	c8 e8       	ldi	r28, 0x88	; 136
    3f1e:	d1 e3       	ldi	r29, 0x31	; 49
    3f20:	1a 82       	std	Y+2, r1	; 0x02
    3f22:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f24:	00 ec       	ldi	r16, 0xC0	; 192
    3f26:	10 e2       	ldi	r17, 0x20	; 32
    3f28:	08 83       	st	Y, r16
    3f2a:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f2c:	40 e0       	ldi	r20, 0x00	; 0
    3f2e:	62 e0       	ldi	r22, 0x02	; 2
    3f30:	8f ef       	ldi	r24, 0xFF	; 255
    3f32:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    3f36:	8c 83       	std	Y+4, r24	; 0x04
    3f38:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f3a:	ce 82       	std	Y+6, r12	; 0x06
    3f3c:	df 82       	std	Y+7, r13	; 0x07
    3f3e:	e8 86       	std	Y+8, r14	; 0x08
    3f40:	f9 86       	std	Y+9, r15	; 0x09
    3f42:	ce e7       	ldi	r28, 0x7E	; 126
    3f44:	d1 e3       	ldi	r29, 0x31	; 49
    3f46:	1a 82       	std	Y+2, r1	; 0x02
    3f48:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f4a:	08 83       	st	Y, r16
    3f4c:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f4e:	40 e0       	ldi	r20, 0x00	; 0
    3f50:	62 e0       	ldi	r22, 0x02	; 2
    3f52:	8f ef       	ldi	r24, 0xFF	; 255
    3f54:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    3f58:	8c 83       	std	Y+4, r24	; 0x04
    3f5a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f5c:	ce 82       	std	Y+6, r12	; 0x06
    3f5e:	df 82       	std	Y+7, r13	; 0x07
    3f60:	e8 86       	std	Y+8, r14	; 0x08
    3f62:	f9 86       	std	Y+9, r15	; 0x09
    3f64:	c4 e7       	ldi	r28, 0x74	; 116
    3f66:	d1 e3       	ldi	r29, 0x31	; 49
    3f68:	1a 82       	std	Y+2, r1	; 0x02
    3f6a:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f6c:	08 83       	st	Y, r16
    3f6e:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f70:	40 e0       	ldi	r20, 0x00	; 0
    3f72:	62 e0       	ldi	r22, 0x02	; 2
    3f74:	8f ef       	ldi	r24, 0xFF	; 255
    3f76:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    3f7a:	8c 83       	std	Y+4, r24	; 0x04
    3f7c:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3f7e:	ce 82       	std	Y+6, r12	; 0x06
    3f80:	df 82       	std	Y+7, r13	; 0x07
    3f82:	e8 86       	std	Y+8, r14	; 0x08
    3f84:	f9 86       	std	Y+9, r15	; 0x09
    3f86:	ca e6       	ldi	r28, 0x6A	; 106
    3f88:	d1 e3       	ldi	r29, 0x31	; 49
    3f8a:	1a 82       	std	Y+2, r1	; 0x02
    3f8c:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    3f8e:	08 83       	st	Y, r16
    3f90:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    3f92:	40 e0       	ldi	r20, 0x00	; 0
    3f94:	62 e0       	ldi	r22, 0x02	; 2
    3f96:	8f ef       	ldi	r24, 0xFF	; 255
    3f98:	0e 94 07 0c 	call	0x180e	; 0x180e <xQueueGenericCreate>
    3f9c:	8c 83       	std	Y+4, r24	; 0x04
    3f9e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    3fa0:	ce 82       	std	Y+6, r12	; 0x06
    3fa2:	df 82       	std	Y+7, r13	; 0x07
    3fa4:	e8 86       	std	Y+8, r14	; 0x08
    3fa6:	f9 86       	std	Y+9, r15	; 0x09
	sei();
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
}
    3fa8:	df 91       	pop	r29
    3faa:	cf 91       	pop	r28
    3fac:	1f 91       	pop	r17
    3fae:	0f 91       	pop	r16
    3fb0:	ff 90       	pop	r15
    3fb2:	ef 90       	pop	r14
    3fb4:	df 90       	pop	r13
    3fb6:	cf 90       	pop	r12
    3fb8:	08 95       	ret

00003fba <__mulsi3>:
    3fba:	db 01       	movw	r26, r22
    3fbc:	8f 93       	push	r24
    3fbe:	9f 93       	push	r25
    3fc0:	0e 94 37 20 	call	0x406e	; 0x406e <__muluhisi3>
    3fc4:	bf 91       	pop	r27
    3fc6:	af 91       	pop	r26
    3fc8:	a2 9f       	mul	r26, r18
    3fca:	80 0d       	add	r24, r0
    3fcc:	91 1d       	adc	r25, r1
    3fce:	a3 9f       	mul	r26, r19
    3fd0:	90 0d       	add	r25, r0
    3fd2:	b2 9f       	mul	r27, r18
    3fd4:	90 0d       	add	r25, r0
    3fd6:	11 24       	eor	r1, r1
    3fd8:	08 95       	ret

00003fda <__udivmodsi4>:
    3fda:	a1 e2       	ldi	r26, 0x21	; 33
    3fdc:	1a 2e       	mov	r1, r26
    3fde:	aa 1b       	sub	r26, r26
    3fe0:	bb 1b       	sub	r27, r27
    3fe2:	fd 01       	movw	r30, r26
    3fe4:	0d c0       	rjmp	.+26     	; 0x4000 <__udivmodsi4_ep>

00003fe6 <__udivmodsi4_loop>:
    3fe6:	aa 1f       	adc	r26, r26
    3fe8:	bb 1f       	adc	r27, r27
    3fea:	ee 1f       	adc	r30, r30
    3fec:	ff 1f       	adc	r31, r31
    3fee:	a2 17       	cp	r26, r18
    3ff0:	b3 07       	cpc	r27, r19
    3ff2:	e4 07       	cpc	r30, r20
    3ff4:	f5 07       	cpc	r31, r21
    3ff6:	20 f0       	brcs	.+8      	; 0x4000 <__udivmodsi4_ep>
    3ff8:	a2 1b       	sub	r26, r18
    3ffa:	b3 0b       	sbc	r27, r19
    3ffc:	e4 0b       	sbc	r30, r20
    3ffe:	f5 0b       	sbc	r31, r21

00004000 <__udivmodsi4_ep>:
    4000:	66 1f       	adc	r22, r22
    4002:	77 1f       	adc	r23, r23
    4004:	88 1f       	adc	r24, r24
    4006:	99 1f       	adc	r25, r25
    4008:	1a 94       	dec	r1
    400a:	69 f7       	brne	.-38     	; 0x3fe6 <__udivmodsi4_loop>
    400c:	60 95       	com	r22
    400e:	70 95       	com	r23
    4010:	80 95       	com	r24
    4012:	90 95       	com	r25
    4014:	9b 01       	movw	r18, r22
    4016:	ac 01       	movw	r20, r24
    4018:	bd 01       	movw	r22, r26
    401a:	cf 01       	movw	r24, r30
    401c:	08 95       	ret

0000401e <__divmodsi4>:
    401e:	05 2e       	mov	r0, r21
    4020:	97 fb       	bst	r25, 7
    4022:	1e f4       	brtc	.+6      	; 0x402a <__divmodsi4+0xc>
    4024:	00 94       	com	r0
    4026:	0e 94 26 20 	call	0x404c	; 0x404c <__negsi2>
    402a:	57 fd       	sbrc	r21, 7
    402c:	07 d0       	rcall	.+14     	; 0x403c <__divmodsi4_neg2>
    402e:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <__udivmodsi4>
    4032:	07 fc       	sbrc	r0, 7
    4034:	03 d0       	rcall	.+6      	; 0x403c <__divmodsi4_neg2>
    4036:	4e f4       	brtc	.+18     	; 0x404a <__divmodsi4_exit>
    4038:	0c 94 26 20 	jmp	0x404c	; 0x404c <__negsi2>

0000403c <__divmodsi4_neg2>:
    403c:	50 95       	com	r21
    403e:	40 95       	com	r20
    4040:	30 95       	com	r19
    4042:	21 95       	neg	r18
    4044:	3f 4f       	sbci	r19, 0xFF	; 255
    4046:	4f 4f       	sbci	r20, 0xFF	; 255
    4048:	5f 4f       	sbci	r21, 0xFF	; 255

0000404a <__divmodsi4_exit>:
    404a:	08 95       	ret

0000404c <__negsi2>:
    404c:	90 95       	com	r25
    404e:	80 95       	com	r24
    4050:	70 95       	com	r23
    4052:	61 95       	neg	r22
    4054:	7f 4f       	sbci	r23, 0xFF	; 255
    4056:	8f 4f       	sbci	r24, 0xFF	; 255
    4058:	9f 4f       	sbci	r25, 0xFF	; 255
    405a:	08 95       	ret

0000405c <__tablejump2__>:
    405c:	ee 0f       	add	r30, r30
    405e:	ff 1f       	adc	r31, r31
    4060:	88 1f       	adc	r24, r24
    4062:	8b bf       	out	0x3b, r24	; 59
    4064:	07 90       	elpm	r0, Z+
    4066:	f6 91       	elpm	r31, Z
    4068:	e0 2d       	mov	r30, r0
    406a:	1b be       	out	0x3b, r1	; 59
    406c:	19 94       	eijmp

0000406e <__muluhisi3>:
    406e:	0e 94 42 20 	call	0x4084	; 0x4084 <__umulhisi3>
    4072:	a5 9f       	mul	r26, r21
    4074:	90 0d       	add	r25, r0
    4076:	b4 9f       	mul	r27, r20
    4078:	90 0d       	add	r25, r0
    407a:	a4 9f       	mul	r26, r20
    407c:	80 0d       	add	r24, r0
    407e:	91 1d       	adc	r25, r1
    4080:	11 24       	eor	r1, r1
    4082:	08 95       	ret

00004084 <__umulhisi3>:
    4084:	a2 9f       	mul	r26, r18
    4086:	b0 01       	movw	r22, r0
    4088:	b3 9f       	mul	r27, r19
    408a:	c0 01       	movw	r24, r0
    408c:	a3 9f       	mul	r26, r19
    408e:	70 0d       	add	r23, r0
    4090:	81 1d       	adc	r24, r1
    4092:	11 24       	eor	r1, r1
    4094:	91 1d       	adc	r25, r1
    4096:	b2 9f       	mul	r27, r18
    4098:	70 0d       	add	r23, r0
    409a:	81 1d       	adc	r24, r1
    409c:	11 24       	eor	r1, r1
    409e:	91 1d       	adc	r25, r1
    40a0:	08 95       	ret

000040a2 <memcpy>:
    40a2:	fb 01       	movw	r30, r22
    40a4:	dc 01       	movw	r26, r24
    40a6:	02 c0       	rjmp	.+4      	; 0x40ac <memcpy+0xa>
    40a8:	01 90       	ld	r0, Z+
    40aa:	0d 92       	st	X+, r0
    40ac:	41 50       	subi	r20, 0x01	; 1
    40ae:	50 40       	sbci	r21, 0x00	; 0
    40b0:	d8 f7       	brcc	.-10     	; 0x40a8 <memcpy+0x6>
    40b2:	08 95       	ret

000040b4 <memset>:
    40b4:	dc 01       	movw	r26, r24
    40b6:	01 c0       	rjmp	.+2      	; 0x40ba <memset+0x6>
    40b8:	6d 93       	st	X+, r22
    40ba:	41 50       	subi	r20, 0x01	; 1
    40bc:	50 40       	sbci	r21, 0x00	; 0
    40be:	e0 f7       	brcc	.-8      	; 0x40b8 <memset+0x4>
    40c0:	08 95       	ret

000040c2 <strncpy>:
    40c2:	fb 01       	movw	r30, r22
    40c4:	dc 01       	movw	r26, r24
    40c6:	41 50       	subi	r20, 0x01	; 1
    40c8:	50 40       	sbci	r21, 0x00	; 0
    40ca:	48 f0       	brcs	.+18     	; 0x40de <strncpy+0x1c>
    40cc:	01 90       	ld	r0, Z+
    40ce:	0d 92       	st	X+, r0
    40d0:	00 20       	and	r0, r0
    40d2:	c9 f7       	brne	.-14     	; 0x40c6 <strncpy+0x4>
    40d4:	01 c0       	rjmp	.+2      	; 0x40d8 <strncpy+0x16>
    40d6:	1d 92       	st	X+, r1
    40d8:	41 50       	subi	r20, 0x01	; 1
    40da:	50 40       	sbci	r21, 0x00	; 0
    40dc:	e0 f7       	brcc	.-8      	; 0x40d6 <strncpy+0x14>
    40de:	08 95       	ret

000040e0 <ultoa>:
    40e0:	25 32       	cpi	r18, 0x25	; 37
    40e2:	31 05       	cpc	r19, r1
    40e4:	20 f4       	brcc	.+8      	; 0x40ee <ultoa+0xe>
    40e6:	22 30       	cpi	r18, 0x02	; 2
    40e8:	10 f0       	brcs	.+4      	; 0x40ee <ultoa+0xe>
    40ea:	0c 94 7b 20 	jmp	0x40f6	; 0x40f6 <__ultoa_ncheck>
    40ee:	fa 01       	movw	r30, r20
    40f0:	10 82       	st	Z, r1
    40f2:	ca 01       	movw	r24, r20
    40f4:	08 95       	ret

000040f6 <__ultoa_ncheck>:
    40f6:	bb 27       	eor	r27, r27

000040f8 <__ultoa_common>:
    40f8:	fa 01       	movw	r30, r20
    40fa:	a6 2f       	mov	r26, r22
    40fc:	62 17       	cp	r22, r18
    40fe:	71 05       	cpc	r23, r1
    4100:	81 05       	cpc	r24, r1
    4102:	91 05       	cpc	r25, r1
    4104:	33 0b       	sbc	r19, r19
    4106:	30 fb       	bst	r19, 0
    4108:	66 f0       	brts	.+24     	; 0x4122 <__ultoa_common+0x2a>
    410a:	aa 27       	eor	r26, r26
    410c:	66 0f       	add	r22, r22
    410e:	77 1f       	adc	r23, r23
    4110:	88 1f       	adc	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	aa 1f       	adc	r26, r26
    4116:	a2 17       	cp	r26, r18
    4118:	10 f0       	brcs	.+4      	; 0x411e <__ultoa_common+0x26>
    411a:	a2 1b       	sub	r26, r18
    411c:	63 95       	inc	r22
    411e:	38 50       	subi	r19, 0x08	; 8
    4120:	a9 f7       	brne	.-22     	; 0x410c <__ultoa_common+0x14>
    4122:	a0 5d       	subi	r26, 0xD0	; 208
    4124:	aa 33       	cpi	r26, 0x3A	; 58
    4126:	08 f0       	brcs	.+2      	; 0x412a <__ultoa_common+0x32>
    4128:	a9 5d       	subi	r26, 0xD9	; 217
    412a:	a1 93       	st	Z+, r26
    412c:	36 f7       	brtc	.-52     	; 0x40fa <__ultoa_common+0x2>
    412e:	b1 11       	cpse	r27, r1
    4130:	b1 93       	st	Z+, r27
    4132:	10 82       	st	Z, r1
    4134:	ca 01       	movw	r24, r20
    4136:	0c 94 c2 20 	jmp	0x4184	; 0x4184 <strrev>

0000413a <utoa>:
    413a:	45 32       	cpi	r20, 0x25	; 37
    413c:	51 05       	cpc	r21, r1
    413e:	20 f4       	brcc	.+8      	; 0x4148 <utoa+0xe>
    4140:	42 30       	cpi	r20, 0x02	; 2
    4142:	10 f0       	brcs	.+4      	; 0x4148 <utoa+0xe>
    4144:	0c 94 a8 20 	jmp	0x4150	; 0x4150 <__utoa_ncheck>
    4148:	fb 01       	movw	r30, r22
    414a:	10 82       	st	Z, r1
    414c:	cb 01       	movw	r24, r22
    414e:	08 95       	ret

00004150 <__utoa_ncheck>:
    4150:	bb 27       	eor	r27, r27

00004152 <__utoa_common>:
    4152:	fb 01       	movw	r30, r22
    4154:	55 27       	eor	r21, r21
    4156:	aa 27       	eor	r26, r26
    4158:	88 0f       	add	r24, r24
    415a:	99 1f       	adc	r25, r25
    415c:	aa 1f       	adc	r26, r26
    415e:	a4 17       	cp	r26, r20
    4160:	10 f0       	brcs	.+4      	; 0x4166 <__utoa_common+0x14>
    4162:	a4 1b       	sub	r26, r20
    4164:	83 95       	inc	r24
    4166:	50 51       	subi	r21, 0x10	; 16
    4168:	b9 f7       	brne	.-18     	; 0x4158 <__utoa_common+0x6>
    416a:	a0 5d       	subi	r26, 0xD0	; 208
    416c:	aa 33       	cpi	r26, 0x3A	; 58
    416e:	08 f0       	brcs	.+2      	; 0x4172 <__utoa_common+0x20>
    4170:	a9 5d       	subi	r26, 0xD9	; 217
    4172:	a1 93       	st	Z+, r26
    4174:	00 97       	sbiw	r24, 0x00	; 0
    4176:	79 f7       	brne	.-34     	; 0x4156 <__utoa_common+0x4>
    4178:	b1 11       	cpse	r27, r1
    417a:	b1 93       	st	Z+, r27
    417c:	11 92       	st	Z+, r1
    417e:	cb 01       	movw	r24, r22
    4180:	0c 94 c2 20 	jmp	0x4184	; 0x4184 <strrev>

00004184 <strrev>:
    4184:	dc 01       	movw	r26, r24
    4186:	fc 01       	movw	r30, r24
    4188:	67 2f       	mov	r22, r23
    418a:	71 91       	ld	r23, Z+
    418c:	77 23       	and	r23, r23
    418e:	e1 f7       	brne	.-8      	; 0x4188 <strrev+0x4>
    4190:	32 97       	sbiw	r30, 0x02	; 2
    4192:	04 c0       	rjmp	.+8      	; 0x419c <strrev+0x18>
    4194:	7c 91       	ld	r23, X
    4196:	6d 93       	st	X+, r22
    4198:	70 83       	st	Z, r23
    419a:	62 91       	ld	r22, -Z
    419c:	ae 17       	cp	r26, r30
    419e:	bf 07       	cpc	r27, r31
    41a0:	c8 f3       	brcs	.-14     	; 0x4194 <strrev+0x10>
    41a2:	08 95       	ret

000041a4 <_exit>:
    41a4:	f8 94       	cli

000041a6 <__stop_program>:
    41a6:	ff cf       	rjmp	.-2      	; 0x41a6 <__stop_program>
